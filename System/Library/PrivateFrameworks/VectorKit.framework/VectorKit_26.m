uint64_t std::sort[abi:nn180100]<std::__wrap_iter<unsigned long *>,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v7[2];

  v4 = 126 - 2 * __clz(((uint64_t)a2 - a1) >> 3);
  v7[0] = a3;
  v7[1] = a4;
  if (a2 == (uint64_t *)a1) {
    v5 = 0;
  }
  else {
    v5 = v4;
  }
  return std::__introsort<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *,false>(a1, a2, v7, v5, 1);
}

uint64_t std::__tree<md::LabelShieldEntry,std::less<md::LabelShieldEntry>,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>>::__emplace_unique_key_args<md::LabelShieldEntry,md::LabelShieldEntry const&>(uint64_t **a1, void **a2, long long *a3)
{
  uint64_t v4 = (uint64_t)(a1 + 1);
  uint64_t v3 = (uint64_t)a1[1];
  if (v3)
  {
    v6 = a2[4];
    unsigned int v7 = *((unsigned __int8 *)a2 + 44);
    char v8 = *((unsigned char *)a2 + 23);
    if (v8 >= 0) {
      v9 = a2;
    }
    else {
      v9 = *a2;
    }
    __s1 = v9;
    if (v8 >= 0) {
      size_t v10 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v10 = (size_t)a2[1];
    }
    while (1)
    {
      uint64_t v4 = v3;
      uint64_t v12 = *(void *)(v3 + 64);
      if ((uint64_t)v6 < v12) {
        goto LABEL_8;
      }
      unsigned int v13 = *(unsigned __int8 *)(v3 + 76);
      if (v7 < v13) {
        goto LABEL_8;
      }
      int v14 = *(char *)(v3 + 55);
      if (v14 >= 0) {
        v15 = (const void *)(v3 + 32);
      }
      else {
        v15 = *(const void **)(v3 + 32);
      }
      if (v14 >= 0) {
        size_t v16 = *(unsigned __int8 *)(v3 + 55);
      }
      else {
        size_t v16 = *(void *)(v3 + 40);
      }
      if (v16 >= v10) {
        size_t v17 = v10;
      }
      else {
        size_t v17 = v16;
      }
      int v18 = memcmp(__s1, v15, v17);
      if (v18)
      {
        if (v18 < 0) {
          goto LABEL_8;
        }
LABEL_24:
        unsigned int v19 = bswap32(*((_DWORD *)a2 + 10));
        unsigned int v20 = bswap32(*(_DWORD *)(v4 + 72));
        BOOL v21 = v19 >= v20;
        BOOL v22 = v19 > v20;
        int v23 = !v21;
        if (v22 - v23 < 0) {
          goto LABEL_8;
        }
        if (v12 >= (uint64_t)v6 && v13 >= v7)
        {
          int v24 = memcmp(v15, __s1, v17);
          if (v24)
          {
            if (v24 < 0) {
              goto LABEL_38;
            }
          }
          else if (v16 < v10)
          {
            goto LABEL_38;
          }
          unsigned int v25 = bswap32(*(_DWORD *)(v4 + 72));
          unsigned int v26 = bswap32(*((_DWORD *)a2 + 10));
          BOOL v21 = v25 >= v26;
          BOOL v27 = v25 > v26;
          int v28 = !v21;
          if (v27 - v28 >= 0) {
            return 0;
          }
        }
LABEL_38:
        v11 = (uint64_t *)(v4 + 8);
        uint64_t v3 = *(void *)(v4 + 8);
        if (!v3) {
          goto LABEL_41;
        }
      }
      else
      {
        if (v10 >= v16) {
          goto LABEL_24;
        }
LABEL_8:
        uint64_t v3 = *(void *)v4;
        v11 = (uint64_t *)v4;
        if (!*(void *)v4) {
          goto LABEL_41;
        }
      }
    }
  }
  v11 = (uint64_t *)(a1 + 1);
LABEL_41:
  uint64_t v29 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*a1[2] + 16))(a1[2], 80, 8);
  v30 = (void **)(v29 + 32);
  *(void *)(v29 + 56) = *((void *)a3 + 3);
  if (*((char *)a3 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external(v30, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v31 = *a3;
    *(void *)(v29 + 48) = *((void *)a3 + 2);
    *(_OWORD *)v30 = v31;
  }
  *(void *)(v29 + 64) = *((void *)a3 + 4);
  *(_DWORD *)(v29 + 72) = *((_DWORD *)a3 + 10);
  *(unsigned char *)(v29 + 76) = *((unsigned char *)a3 + 44);
  *(void *)uint64_t v29 = 0;
  *(void *)(v29 + 8) = 0;
  *(void *)(v29 + 16) = v4;
  uint64_t *v11 = v29;
  v32 = (uint64_t *)**a1;
  if (v32)
  {
    *a1 = v32;
    uint64_t v29 = *v11;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], (uint64_t *)v29);
  a1[3] = (uint64_t *)((char *)a1[3] + 1);
  return 1;
}

void sub_1A25311E0(_Unwind_Exception *a1)
{
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 16) + 40))(*(void *)(v1 + 16), v2, 80);
  _Unwind_Resume(a1);
}

uint64_t std::vector<md::TransitShieldIconLabelPart *,geo::StdAllocator<md::TransitShieldIconLabelPart *,mdm::Allocator>>::push_back[abi:nn180100](uint64_t result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void **)(result + 8);
  unint64_t v5 = *(void *)(result + 16);
  if ((unint64_t)v4 < v5)
  {
    if (v4) {
      *uint64_t v4 = *a2;
    }
    v6 = v4 + 1;
    goto LABEL_27;
  }
  uint64_t v7 = ((uint64_t)v4 - *(void *)result) >> 3;
  unint64_t v8 = v7 + 1;
  if ((unint64_t)(v7 + 1) >> 61) {
    abort();
  }
  uint64_t v9 = v5 - *(void *)result;
  if (v9 >> 2 > v8) {
    unint64_t v8 = v9 >> 2;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  if (v8)
  {
    uint64_t v10 = 8 * v8;
    result = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(result + 24) + 16))(*(void *)(result + 24), 8 * v8, 8);
    v11 = (void *)(result + 8 * v7);
    unint64_t v8 = result + v10;
    if (result) {
      void *v11 = *a2;
    }
  }
  else
  {
    v11 = (void *)(8 * v7);
  }
  v6 = v11 + 1;
  uint64_t v13 = *(void *)v3;
  uint64_t v12 = *(void *)(v3 + 8);
  if (v12 != *(void *)v3)
  {
    unint64_t v14 = v12 - *(void *)v3 - 8;
    if (v14 < 0x38)
    {
      uint64_t v16 = *(void *)(v3 + 8);
    }
    else if ((unint64_t)(v12 - (void)v11) < 0x20)
    {
      uint64_t v16 = *(void *)(v3 + 8);
    }
    else
    {
      uint64_t v15 = (v14 >> 3) + 1;
      uint64_t v16 = v12 - 8 * (v15 & 0x3FFFFFFFFFFFFFFCLL);
      size_t v17 = v11 - 2;
      int v18 = (long long *)(v12 - 16);
      uint64_t v19 = v15 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v20 = *v18;
        *(v17 - 1) = *(v18 - 1);
        *size_t v17 = v20;
        v17 -= 2;
        v18 -= 2;
        v19 -= 4;
      }
      while (v19);
      v11 -= v15 & 0x3FFFFFFFFFFFFFFCLL;
      if (v15 == (v15 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_24;
      }
    }
    do
    {
      uint64_t v21 = *(void *)(v16 - 8);
      v16 -= 8;
      *--v11 = v21;
    }
    while (v16 != v13);
LABEL_24:
    uint64_t v12 = *(void *)v3;
  }
  *(void *)uint64_t v3 = v11;
  *(void *)(v3 + 8) = v6;
  uint64_t v22 = *(void *)(v3 + 16);
  *(void *)(v3 + 16) = v8;
  if (v12) {
    result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v3 + 24) + 40))(*(void *)(v3 + 24), v12, v22 - v12);
  }
LABEL_27:
  *(void *)(v3 + 8) = v6;
  return result;
}

uint64_t md::LabelStyle::textStyleGroup(uint64_t a1)
{
  uint64_t v2 = *(float **)(a1 + 280);
  if (v2)
  {
    if (vabds_f32(v2[2], *(float *)(a1 + 104)) >= 0.01)
    {
      md::LabelStyle::updateStyleGroup<md::LabelTextStyleGroup>((unsigned __int8 *)a1, (uint64_t)v2, 0);
      uint64_t v2 = *(float **)(a1 + 280);
    }
  }
  else
  {
    uint64_t v2 = (float *)md::LabelStyle::prepareStyleGroup<md::LabelTextStyleGroup>(a1, 0);
    *(void *)(a1 + 280) = v2;
  }
  return *(void *)v2;
}

uint64_t std::make_shared[abi:nn180100]<md::LabelText,std::shared_ptr<md::TextDataString> const&,unsigned char const&,void>(uint64_t *a1, uint64_t a2, uint64_t a3, char a4)
{
  unint64_t v8 = operator new(0xB0uLL);
  v8[1] = 0;
  v8[2] = 0;
  *unint64_t v8 = &unk_1EF582A90;
  uint64_t result = md::LabelText::LabelText((uint64_t)(v8 + 3), a2, a3, a4);
  *a1 = result;
  a1[1] = (uint64_t)v8;
  return result;
}

uint64_t std::__tree<md::LabelShieldEntry,std::less<md::LabelShieldEntry>,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>>::destroy(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<md::LabelShieldEntry,std::less<md::LabelShieldEntry>,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>>::destroy(result, *(void *)a2);
    std::__tree<md::LabelShieldEntry,std::less<md::LabelShieldEntry>,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>>::destroy(v3, *(void *)(a2 + 8));
    if (*(char *)(a2 + 55) < 0) {
      (*(void (**)(void, void, uint64_t))(**(void **)(a2 + 56) + 40))(*(void *)(a2 + 56), *(void *)(a2 + 32), *(void *)(a2 + 48) & 0x7FFFFFFFFFFFFFFFLL);
    }
    uint64_t v4 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v4();
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *,false>(uint64_t result, uint64_t *a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t v10 = (uint64_t *)result;
LABEL_2:
  v11 = a2 - 1;
  v146 = a2 - 3;
  v147 = a2 - 2;
  k = v10;
  v148 = a2;
  while (1)
  {
    uint64_t v10 = k;
    uint64_t v13 = (char *)a2 - (char *)k;
    unint64_t v14 = a2 - k;
    if (v6 || !v5)
    {
      switch(v14)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t v60 = *v11;
          uint64_t v61 = *k;
          uint64_t v62 = *(void *)a3[1];
          float v63 = *(float *)(v62 + 20 * *v11);
          float v64 = *(float *)(v62 + 20 * *k);
          if (v63 < v64
            || v63 == v64
            && *(unsigned __int16 *)(*(void *)(*a3 + 536) + 32 * v60 + 14) < *(unsigned __int16 *)(*(void *)(*a3 + 536) + 32 * v61 + 14))
          {
            uint64_t *k = v60;
            uint64_t *v11 = v61;
          }
          break;
        case 3uLL:
          uint64_t v65 = *a3;
          uint64_t v66 = *(void *)a3[1];
          uint64_t result = (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(k, k + 1, v11, v65, v66);
          break;
        case 4uLL:
          uint64_t result = (uint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(k, k + 1, k + 2, v11, (uint64_t)a3);
          break;
        case 5uLL:
          uint64_t result = (uint64_t)std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *,0>(k, k + 1, k + 2, k + 3, v11, (uint64_t)a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v13 <= 191)
    {
      uint64_t v67 = *a3;
      v68 = (uint64_t *)a3[1];
      if (a5)
      {
        if (k != a2)
        {
          v69 = k + 1;
          if (k + 1 != a2)
          {
            uint64_t v70 = 0;
            uint64_t v71 = *v68;
            v72 = k;
            do
            {
              v74 = v72;
              v72 = v69;
              uint64_t v76 = *v74;
              uint64_t v75 = v74[1];
              float v77 = *(float *)(v71 + 20 * v75);
              float v78 = *(float *)(v71 + 20 * *v74);
              if (v77 < v78
                || v77 == v78
                && *(unsigned __int16 *)(*(void *)(v67 + 536) + 32 * v75 + 14) < *(unsigned __int16 *)(*(void *)(v67 + 536) + 32 * v76 + 14))
              {
                v74[1] = v76;
                v73 = k;
                if (v74 != k)
                {
                  uint64_t v79 = v70;
                  while (1)
                  {
                    uint64_t v80 = *(uint64_t *)((char *)k + v79 - 8);
                    uint64_t result = 20 * v80;
                    float v81 = *(float *)(v71 + 20 * v80);
                    if (v77 >= v81)
                    {
                      if (v77 != v81)
                      {
                        v73 = (uint64_t *)((char *)k + v79);
                        goto LABEL_110;
                      }
                      uint64_t v82 = *(void *)(v67 + 536);
                      unsigned int v83 = *(unsigned __int16 *)(v82 + 32 * v75 + 14);
                      uint64_t result = *(unsigned __int16 *)(v82 + 32 * v80 + 14);
                      if (v83 >= result) {
                        break;
                      }
                    }
                    --v74;
                    *(uint64_t *)((char *)k + v79) = v80;
                    v79 -= 8;
                    if (!v79)
                    {
                      v73 = k;
                      goto LABEL_110;
                    }
                  }
                  v73 = v74;
                }
LABEL_110:
                uint64_t *v73 = v75;
              }
              v69 = v72 + 1;
              v70 += 8;
            }
            while (v72 + 1 != a2);
          }
        }
      }
      else if (k != a2)
      {
        v135 = k + 1;
        if (k + 1 != a2)
        {
          uint64_t v136 = *v68;
          do
          {
            v137 = v10;
            uint64_t v10 = v135;
            uint64_t v139 = *v137;
            uint64_t v138 = v137[1];
            float v140 = *(float *)(v136 + 20 * v138);
            float v141 = *(float *)(v136 + 20 * *v137);
            if (v140 < v141
              || v140 == v141
              && *(unsigned __int16 *)(*(void *)(v67 + 536) + 32 * v138 + 14) < *(unsigned __int16 *)(*(void *)(v67 + 536) + 32 * v139 + 14))
            {
              do
              {
                do
                {
                  v142 = v137;
                  uint64_t v143 = v139;
                  uint64_t v144 = *--v137;
                  uint64_t v139 = v144;
                  v137[2] = v143;
                  float v145 = *(float *)(v136 + 20 * v144);
                }
                while (v140 < v145);
              }
              while (v140 == v145
                   && *(unsigned __int16 *)(*(void *)(v67 + 536) + 32 * v138 + 14) < *(unsigned __int16 *)(*(void *)(v67 + 536) + 32 * v139 + 14));
              uint64_t *v142 = v138;
            }
            v135 = v10 + 1;
          }
          while (v10 + 1 != a2);
        }
      }
      return result;
    }
    if (!a4) {
      break;
    }
    unint64_t v15 = v14 >> 1;
    uint64_t v16 = &k[v14 >> 1];
    uint64_t v17 = *a3;
    uint64_t v18 = *(void *)a3[1];
    if ((unint64_t)v13 >= 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(v10, &v10[v14 >> 1], v11, v17, v18);
      uint64_t v19 = &v10[v15];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(v10 + 1, v19 - 1, v147, *a3, *(void *)a3[1]);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(v10 + 2, &v10[v15 + 1], v146, *a3, *(void *)a3[1]);
      uint64_t result = (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(v19 - 1, v16, &v10[v15 + 1], *a3, *(void *)a3[1]);
      uint64_t v20 = *v10;
      *uint64_t v10 = *v19;
      *uint64_t v19 = v20;
      a2 = v148;
    }
    else
    {
      uint64_t result = (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(&v10[v14 >> 1], v10, v11, v17, v18);
    }
    --a4;
    uint64_t v21 = *a3;
    uint64_t v22 = *v10;
    uint64_t v23 = *(void *)a3[1];
    if (a5)
    {
      float v24 = *(float *)(v23 + 20 * v22);
LABEL_15:
      for (i = v10 + 1; ; ++i)
      {
        uint64_t v28 = *i;
        float v29 = *(float *)(v23 + 20 * *i);
        if (v29 >= v24
          && (v29 != v24
           || *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v28 + 14) >= *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v22 + 14)))
        {
          break;
        }
      }
      v30 = i - 1;
      if (i - 1 == v10)
      {
        j = a2;
        if (i < a2)
        {
          uint64_t v35 = *v11;
          float v36 = *(float *)(v23 + 20 * *v11);
          j = v11;
          if (v36 >= v24)
          {
            j = v11;
            do
            {
              if (v36 == v24)
              {
                if (i >= j
                  || *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v35 + 14) < *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v22 + 14))
                {
                  break;
                }
              }
              else if (i >= j)
              {
                break;
              }
              uint64_t v44 = *--j;
              uint64_t v35 = v44;
              float v36 = *(float *)(v23 + 20 * v44);
            }
            while (v36 >= v24);
          }
        }
      }
      else
      {
        uint64_t v31 = *v11;
        float v32 = *(float *)(v23 + 20 * *v11);
        for (j = v11; v32 >= v24; float v32 = *(float *)(v23 + 20 * v34))
        {
          if (v32 == v24
            && *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v31 + 14) < *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v22 + 14))
          {
            break;
          }
          uint64_t v34 = *--j;
          uint64_t v31 = v34;
        }
      }
      if (i < j)
      {
        uint64_t v37 = *j;
        v38 = i;
        v39 = j;
        do
        {
          *v38++ = v37;
          uint64_t *v39 = v28;
          while (1)
          {
            uint64_t v28 = *v38;
            float v40 = *(float *)(v23 + 20 * *v38);
            if (v40 >= v24
              && (v40 != v24
               || *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v28 + 14) >= *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v22 + 14)))
            {
              break;
            }
            ++v38;
          }
          v30 = v38 - 1;
          do
          {
            uint64_t v41 = *--v39;
            uint64_t v37 = v41;
            float v42 = *(float *)(v23 + 20 * v41);
          }
          while (v42 >= v24
               && (v42 != v24
                || *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v37 + 14) >= *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v22 + 14)));
        }
        while (v38 < v39);
      }
      if (v30 != v10) {
        *uint64_t v10 = *v30;
      }
      uint64_t *v30 = v22;
      if (i < j) {
        goto LABEL_47;
      }
      BOOL v43 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(v10, v30, a3);
      k = v30 + 1;
      uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(v30 + 1, a2, a3);
      if (result)
      {
        a2 = v30;
        if (v43) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v43)
      {
LABEL_47:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *,false>(v10, v30, a3, a4, a5 & 1);
        a5 = 0;
        k = v30 + 1;
      }
    }
    else
    {
      uint64_t v25 = *(v10 - 1);
      float v26 = *(float *)(v23 + 20 * v25);
      float v24 = *(float *)(v23 + 20 * v22);
      if (v26 < v24
        || v26 == v24
        && *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v25 + 14) < *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v22 + 14))
      {
        goto LABEL_15;
      }
      uint64_t v45 = *v11;
      float v46 = *(float *)(v23 + 20 * *v11);
      if (v24 < v46
        || v24 == v46
        && *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v22 + 14) < *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v45 + 14))
      {
        k = v10;
        do
        {
          uint64_t v48 = k[1];
          ++k;
          uint64_t v47 = v48;
          float v49 = *(float *)(v23 + 20 * v48);
        }
        while (v24 >= v49
             && (v24 != v49
              || *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v22 + 14) >= *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v47 + 14)));
      }
      else
      {
        for (k = v10 + 1; k < a2; ++k)
        {
          float v50 = *(float *)(v23 + 20 * *k);
          if (v24 < v50
            || v24 == v50
            && *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v22 + 14) < *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * *k + 14))
          {
            break;
          }
        }
      }
      v51 = a2;
      if (k < a2)
      {
        v51 = v11;
        while (v24 < v46
             || v24 == v46
             && *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v22 + 14) < *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v45 + 14))
        {
          uint64_t v52 = *--v51;
          uint64_t v45 = v52;
          float v46 = *(float *)(v23 + 20 * v52);
        }
      }
      if (k < v51)
      {
        uint64_t v53 = *k;
        uint64_t v54 = *v51;
        do
        {
          uint64_t *k = v54;
          uint64_t *v51 = v53;
          do
          {
            uint64_t v55 = k[1];
            ++k;
            uint64_t v53 = v55;
            float v56 = *(float *)(v23 + 20 * v55);
          }
          while (v24 >= v56
               && (v24 != v56
                || *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v22 + 14) >= *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v53 + 14)));
          do
          {
            do
            {
              uint64_t v57 = *--v51;
              uint64_t v54 = v57;
              float v58 = *(float *)(v23 + 20 * v57);
            }
            while (v24 < v58);
          }
          while (v24 == v58
               && *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v22 + 14) < *(unsigned __int16 *)(*(void *)(v21 + 536) + 32 * v54 + 14));
        }
        while (k < v51);
      }
      v59 = k - 1;
      BOOL v5 = k - 1 >= v10;
      BOOL v6 = k - 1 == v10;
      if (k - 1 != v10) {
        *uint64_t v10 = *v59;
      }
      a5 = 0;
      uint64_t *v59 = v22;
    }
  }
  if (k != a2)
  {
    int64_t v84 = (v14 - 2) >> 1;
    uint64_t v85 = *a3;
    int64_t v86 = v84;
    do
    {
      int64_t v88 = v86;
      if (v84 >= v86)
      {
        uint64_t v89 = (2 * v86) | 1;
        v90 = &k[v89];
        uint64_t v91 = *(void *)a3[1];
        if (2 * v88 + 2 < (uint64_t)v14)
        {
          uint64_t v92 = v90[1];
          float v93 = *(float *)(v91 + 20 * *v90);
          float v94 = *(float *)(v91 + 20 * v92);
          if (v93 < v94
            || v93 == v94
            && *(unsigned __int16 *)(*(void *)(v85 + 536) + 32 * *v90 + 14) < *(unsigned __int16 *)(*(void *)(v85 + 536) + 32 * v92 + 14))
          {
            ++v90;
            uint64_t v89 = 2 * v88 + 2;
          }
        }
        uint64_t v95 = *v90;
        uint64_t v96 = k[v88];
        float v97 = *(float *)(v91 + 20 * *v90);
        float v98 = *(float *)(v91 + 20 * v96);
        if (v97 >= v98
          && (v97 != v98
           || *(unsigned __int16 *)(*(void *)(v85 + 536) + 32 * v95 + 14) >= *(unsigned __int16 *)(*(void *)(v85 + 536) + 32 * v96 + 14)))
        {
          k[v88] = v95;
          if (v84 >= v89)
          {
            while (1)
            {
              uint64_t v99 = 2 * v89;
              uint64_t v89 = (2 * v89) | 1;
              v87 = &k[v89];
              uint64_t v100 = v99 + 2;
              if (v100 < (uint64_t)v14)
              {
                uint64_t v101 = v87[1];
                float v102 = *(float *)(v91 + 20 * *v87);
                float v103 = *(float *)(v91 + 20 * v101);
                if (v102 < v103
                  || v102 == v103
                  && *(unsigned __int16 *)(*(void *)(v85 + 536) + 32 * *v87 + 14) < *(unsigned __int16 *)(*(void *)(v85 + 536) + 32 * v101 + 14))
                {
                  ++v87;
                  uint64_t v89 = v100;
                }
              }
              uint64_t v104 = *v87;
              float v105 = *(float *)(v91 + 20 * *v87);
              if (v105 < v98
                || v105 == v98
                && *(unsigned __int16 *)(*(void *)(v85 + 536) + 32 * v104 + 14) < *(unsigned __int16 *)(*(void *)(v85 + 536) + 32 * v96 + 14))
              {
                break;
              }
              uint64_t *v90 = v104;
              v90 = v87;
              if (v84 < v89) {
                goto LABEL_126;
              }
            }
          }
          v87 = v90;
LABEL_126:
          uint64_t *v87 = v96;
          uint64_t v85 = *a3;
        }
      }
      int64_t v86 = v88 - 1;
    }
    while (v88);
    uint64_t v106 = (unint64_t)v13 >> 3;
    while (2)
    {
      int64_t v109 = 0;
      uint64_t v110 = *k;
      uint64_t v111 = *a3;
      v112 = (void *)a3[1];
      v107 = k;
      do
      {
        v113 = v107;
        v107 += v109 + 1;
        uint64_t v114 = 2 * v109;
        uint64_t result = (2 * v109) | 1;
        int64_t v109 = result;
        int64_t v115 = v114 + 2;
        if (v115 < v106)
        {
          uint64_t result = (uint64_t)(v107 + 1);
          uint64_t v116 = v107[1];
          float v117 = *(float *)(*v112 + 20 * *v107);
          float v118 = *(float *)(*v112 + 20 * v116);
          if (v117 < v118
            || v117 == v118
            && *(unsigned __int16 *)(*(void *)(v111 + 536) + 32 * *v107 + 14) < *(unsigned __int16 *)(*(void *)(v111 + 536) + 32 * v116 + 14))
          {
            ++v107;
            int64_t v109 = v115;
          }
        }
        uint64_t *v113 = *v107;
      }
      while (v109 <= (uint64_t)((unint64_t)(v106 - 2) >> 1));
      if (v107 == --a2)
      {
LABEL_151:
        uint64_t *v107 = v110;
      }
      else
      {
        uint64_t *v107 = *a2;
        *a2 = v110;
        uint64_t v119 = (char *)v107 - (char *)k + 8;
        if (v119 >= 9)
        {
          uint64_t v120 = *a3;
          unint64_t v121 = ((unint64_t)v119 >> 3) - 2;
          unint64_t v122 = v121 >> 1;
          v123 = &k[v121 >> 1];
          uint64_t v124 = *v123;
          uint64_t v110 = *v107;
          uint64_t v125 = *(void *)a3[1];
          float v126 = *(float *)(v125 + 20 * *v123);
          uint64_t result = 20 * *v107;
          float v127 = *(float *)(v125 + result);
          if (v126 < v127
            || v126 == v127
            && (uint64_t v128 = *(void *)(v120 + 536),
                unsigned int v129 = *(unsigned __int16 *)(v128 + 32 * v124 + 14),
                uint64_t result = *(unsigned __int16 *)(v128 + 32 * v110 + 14),
                v129 < result))
          {
            uint64_t *v107 = v124;
            if (v121 >= 2)
            {
              while (1)
              {
                unint64_t v130 = v122 - 1;
                unint64_t v122 = (v122 - 1) >> 1;
                v107 = &k[v122];
                uint64_t v131 = *v107;
                uint64_t result = 20 * *v107;
                float v132 = *(float *)(v125 + result);
                if (v132 >= v127)
                {
                  if (v132 != v127) {
                    break;
                  }
                  uint64_t v133 = *(void *)(v120 + 536);
                  unsigned int v134 = *(unsigned __int16 *)(v133 + 32 * v131 + 14);
                  uint64_t result = *(unsigned __int16 *)(v133 + 32 * v110 + 14);
                  if (v134 >= result) {
                    break;
                  }
                }
                uint64_t *v123 = v131;
                v123 = &k[v122];
                if (v130 <= 1) {
                  goto LABEL_151;
                }
              }
            }
            v107 = v123;
            goto LABEL_151;
          }
        }
      }
      if (v106-- <= 2) {
        return result;
      }
      continue;
    }
  }
  return result;
}

uint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a2;
  uint64_t v6 = *result;
  float v7 = *(float *)(a5 + 20 * *a2);
  float v8 = *(float *)(a5 + 20 * *result);
  if (v7 < v8
    || v7 == v8
    && *(unsigned __int16 *)(*(void *)(a4 + 536) + 32 * v5 + 14) < *(unsigned __int16 *)(*(void *)(a4 + 536) + 32 * v6 + 14))
  {
    uint64_t v9 = *a3;
    float v10 = *(float *)(a5 + 20 * *a3);
    if (v10 < v7
      || v10 == v7
      && *(unsigned __int16 *)(*(void *)(a4 + 536) + 32 * v9 + 14) < *(unsigned __int16 *)(*(void *)(a4 + 536) + 32 * v5 + 14))
    {
      *uint64_t result = v9;
LABEL_19:
      *a3 = v6;
      return result;
    }
    *uint64_t result = v5;
    *a2 = v6;
    uint64_t v17 = *a3;
    float v18 = *(float *)(a5 + 20 * *a3);
    if (v18 < v8
      || v18 == v8
      && *(unsigned __int16 *)(*(void *)(a4 + 536) + 32 * v17 + 14) < *(unsigned __int16 *)(*(void *)(a4 + 536) + 32 * v6 + 14))
    {
      *a2 = v17;
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v11 = *a3;
    float v12 = *(float *)(a5 + 20 * *a3);
    if (v12 < v7
      || v12 == v7
      && *(unsigned __int16 *)(*(void *)(a4 + 536) + 32 * v11 + 14) < *(unsigned __int16 *)(*(void *)(a4 + 536) + 32 * v5 + 14))
    {
      *a2 = v11;
      *a3 = v5;
      uint64_t v13 = *a2;
      uint64_t v14 = *result;
      float v15 = *(float *)(a5 + 20 * *a2);
      float v16 = *(float *)(a5 + 20 * *result);
      if (v15 < v16
        || v15 == v16
        && *(unsigned __int16 *)(*(void *)(a4 + 536) + 32 * v13 + 14) < *(unsigned __int16 *)(*(void *)(a4 + 536) + 32 * v14 + 14))
      {
        *uint64_t result = v13;
        *a2 = v14;
      }
    }
  }
  return result;
}

uint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(a1, a2, a3, *(void *)a5, **(void **)(a5 + 8));
  uint64_t v11 = *a4;
  uint64_t v12 = *a3;
  uint64_t v13 = *(void *)a5;
  uint64_t v14 = **(void **)(a5 + 8);
  float v15 = *(float *)(v14 + 20 * *a4);
  float v16 = *(float *)(v14 + 20 * *a3);
  if (v15 < v16
    || v15 == v16
    && *(unsigned __int16 *)(*(void *)(v13 + 536) + 32 * v11 + 14) < *(unsigned __int16 *)(*(void *)(v13 + 536) + 32 * v12 + 14))
  {
    *a3 = v11;
    *a4 = v12;
    uint64_t v17 = *a3;
    uint64_t v18 = *a2;
    float v19 = *(float *)(v14 + 20 * *a3);
    float v20 = *(float *)(v14 + 20 * *a2);
    if (v19 < v20
      || v19 == v20
      && *(unsigned __int16 *)(*(void *)(v13 + 536) + 32 * v17 + 14) < *(unsigned __int16 *)(*(void *)(v13 + 536) + 32 * v18 + 14))
    {
      *a2 = v17;
      *a3 = v18;
      uint64_t v21 = *a2;
      uint64_t v22 = *a1;
      float v23 = *(float *)(v14 + 20 * *a2);
      float v24 = *(float *)(v14 + 20 * *a1);
      if (v23 < v24
        || v23 == v24
        && *(unsigned __int16 *)(*(void *)(v13 + 536) + 32 * v21 + 14) < *(unsigned __int16 *)(*(void *)(v13 + 536) + 32 * v22 + 14))
      {
        *a1 = v21;
        *a2 = v22;
      }
    }
  }
  return result;
}

uint64_t *std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(a1, a2, a3, a4, a6);
  uint64_t v13 = *a5;
  uint64_t v14 = *a4;
  uint64_t v15 = *(void *)a6;
  uint64_t v16 = **(void **)(a6 + 8);
  float v17 = *(float *)(v16 + 20 * *a5);
  float v18 = *(float *)(v16 + 20 * *a4);
  if (v17 < v18
    || v17 == v18
    && *(unsigned __int16 *)(*(void *)(v15 + 536) + 32 * v13 + 14) < *(unsigned __int16 *)(*(void *)(v15 + 536) + 32 * v14 + 14))
  {
    *a4 = v13;
    *a5 = v14;
    uint64_t v19 = *a4;
    uint64_t v20 = *a3;
    float v21 = *(float *)(v16 + 20 * *a4);
    float v22 = *(float *)(v16 + 20 * *a3);
    if (v21 < v22
      || v21 == v22
      && *(unsigned __int16 *)(*(void *)(v15 + 536) + 32 * v19 + 14) < *(unsigned __int16 *)(*(void *)(v15 + 536) + 32 * v20 + 14))
    {
      *a3 = v19;
      *a4 = v20;
      uint64_t v23 = *a3;
      uint64_t v24 = *a2;
      float v25 = *(float *)(v16 + 20 * *a3);
      float v26 = *(float *)(v16 + 20 * *a2);
      if (v25 < v26
        || v25 == v26
        && *(unsigned __int16 *)(*(void *)(v15 + 536) + 32 * v23 + 14) < *(unsigned __int16 *)(*(void *)(v15 + 536) + 32 * v24 + 14))
      {
        *a2 = v23;
        *a3 = v24;
        uint64_t v27 = *a2;
        uint64_t v28 = *a1;
        float v29 = *(float *)(v16 + 20 * *a2);
        float v30 = *(float *)(v16 + 20 * *a1);
        if (v29 < v30
          || v29 == v30
          && *(unsigned __int16 *)(*(void *)(v15 + 536) + 32 * v27 + 14) < *(unsigned __int16 *)(*(void *)(v15 + 536) + 32 * v28 + 14))
        {
          *a1 = v27;
          *a2 = v28;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *a1;
      uint64_t v10 = *(void *)a3[1];
      float v11 = *(float *)(v10 + 20 * v8);
      float v12 = *(float *)(v10 + 20 * *a1);
      if (v11 < v12
        || v11 == v12
        && *(unsigned __int16 *)(*(void *)(*a3 + 536) + 32 * v8 + 14) < *(unsigned __int16 *)(*(void *)(*a3 + 536) + 32 * v9 + 14))
      {
        *a1 = v8;
        *(a2 - 1) = v9;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(a1, a1 + 1, a2 - 1, *a3, *(void *)a3[1]);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(a1, a1 + 1, a1 + 2, a2 - 1, (uint64_t)a3);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, (uint64_t)a3);
      return 1;
    default:
      uint64_t v13 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::newShieldPart(md::LabelManager *,md::Label *,md::LabelPartCreationOptions &,std::shared_ptr<md::RoadPosition> const&)::$_0 &,unsigned long *>(a1, a1 + 1, a1 + 2, *a3, *(void *)a3[1]);
      uint64_t v14 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v15 = 0;
      int v16 = 0;
      uint64_t v17 = *a3;
      uint64_t v18 = *(void *)a3[1];
      break;
  }
  while (1)
  {
    uint64_t v20 = *v14;
    uint64_t v21 = *v13;
    float v22 = *(float *)(v18 + 20 * *v14);
    float v23 = *(float *)(v18 + 20 * *v13);
    if (v22 < v23
      || v22 == v23
      && *(unsigned __int16 *)(*(void *)(v17 + 536) + 32 * v20 + 14) < *(unsigned __int16 *)(*(void *)(v17 + 536) + 32 * v21 + 14))
    {
      *uint64_t v14 = v21;
      uint64_t v19 = a1;
      if (v13 != a1)
      {
        uint64_t v24 = v15;
        while (1)
        {
          uint64_t v25 = *(uint64_t *)((char *)a1 + v24 + 8);
          float v26 = *(float *)(v18 + 20 * v25);
          if (v22 >= v26)
          {
            if (v22 != v26)
            {
              uint64_t v19 = v13;
              goto LABEL_9;
            }
            if (*(unsigned __int16 *)(*(void *)(v17 + 536) + 32 * v20 + 14) >= *(unsigned __int16 *)(*(void *)(v17 + 536) + 32 * v25 + 14)) {
              break;
            }
          }
          --v13;
          *(uint64_t *)((char *)a1 + v24 + 16) = v25;
          v24 -= 8;
          if (v24 == -16)
          {
            uint64_t v19 = a1;
            goto LABEL_9;
          }
        }
        uint64_t v19 = (uint64_t *)((char *)a1 + v24 + 16);
      }
LABEL_9:
      *uint64_t v19 = v20;
      if (++v16 == 8) {
        return v14 + 1 == a2;
      }
    }
    uint64_t v13 = v14;
    v15 += 8;
    if (++v14 == a2) {
      return 1;
    }
  }
}

void md::TransitLineLabelFeature::~TransitLineLabelFeature(md::TransitLineLabelFeature *this)
{
  md::TransitLineLabelFeature::~TransitLineLabelFeature(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t vars8;

  *(void *)this = &unk_1EF544230;
  uint64_t v2 = *((void *)this + 85);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 86);
    uint64_t v4 = *((void *)this + 85);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v5->__on_zero_shared)(v5, v4);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 32;
      }
      while (v3 != v2);
      uint64_t v4 = *((void *)this + 85);
    }
    *((void *)this + 86) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 88) + 40))(*((void *)this + 88), v4, *((void *)this + 87) - v4);
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 608));
  std::__tree<std::__value_type<VKTrafficFeatureType,unsigned long>,std::__map_value_compare<VKTrafficFeatureType,std::__value_type<VKTrafficFeatureType,unsigned long>,std::less<VKTrafficFeatureType>,true>,geo::StdAllocator<std::__value_type<VKTrafficFeatureType,unsigned long>,mdm::Allocator>>::destroy((uint64_t)this + 568, *((void **)this + 72));
  uint64_t v6 = *((void *)this + 67);
  if (v6)
  {
    *((void *)this + 68) = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 70) + 40))(*((void *)this + 70), v6, *((void *)this + 69) - v6);
  }
  float v7 = (uint64_t *)((char *)this + 504);
  std::vector<geo::fast_shared_ptr<md::TransitLineLabelFeature::LabelTransitLink,mdm::MDAllocator>,geo::StdAllocator<geo::fast_shared_ptr<md::TransitLineLabelFeature::LabelTransitLink,mdm::MDAllocator>,mdm::Allocator>>::__destroy_vector::operator()[abi:nn180100](&v7);
  std::mutex::~mutex((std::mutex *)((char *)this + 440));
  md::LineLabelFeature::~LineLabelFeature(this);
}

uint64_t **std::vector<geo::fast_shared_ptr<md::TransitLineLabelFeature::LabelTransitLink,mdm::MDAllocator>,geo::StdAllocator<geo::fast_shared_ptr<md::TransitLineLabelFeature::LabelTransitLink,mdm::MDAllocator>,mdm::Allocator>>::__destroy_vector::operator()[abi:nn180100](uint64_t **result)
{
  uint64_t v1 = *result;
  uint64_t v2 = **result;
  if (v2)
  {
    uint64_t v3 = v1[1];
    uint64_t v4 = *result;
    if (v3 != v2)
    {
      uint64_t v5 = result;
      uint64_t v6 = v1[1];
      do
      {
        uint64_t v8 = *(void *)(v6 - 8);
        v6 -= 8;
        uint64_t v7 = v8;
        if (v8)
        {
          if ((*(void *)v7)-- == 1)
          {
            uint64_t v10 = *(void *)(v7 + 16);
            if (v10)
            {
              *(void *)(v7 + 24) = v10;
              (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v7 + 40) + 40))(*(void *)(v7 + 40), v10, *(void *)(v7 + 32) - v10);
            }
            {
              operator new();
            }
            (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, *(void *)(v3 - 8), 56);
            *(void *)(v3 - 8) = 0;
          }
        }
        uint64_t v3 = v6;
      }
      while (v6 != v2);
      uint64_t v4 = *v5;
    }
    v1[1] = v2;
    float v11 = *(uint64_t (**)(void))(*(void *)v4[3] + 40);
    return (uint64_t **)v11();
  }
  return result;
}

uint64_t *md::TransitLineLabelFeature::addTransitLink(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = result + 72;
  uint64_t v5 = (void *)result[72];
  if (v5)
  {
    uint64_t v6 = result + 72;
    do
    {
      unint64_t v7 = v5[4];
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        uint64_t v9 = v5;
      }
      else {
        uint64_t v9 = v5 + 1;
      }
      if (v8) {
        uint64_t v6 = v5;
      }
      uint64_t v5 = (void *)*v9;
    }
    while (*v9);
    if (v6 != v4 && v6[4] <= a2 && v6[5]) {
      return result;
    }
  }
  {
    operator new();
  }
  unsigned int v83 = v3;
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 56, 8);
  *(void *)uint64_t v10 = 1;
  *(void *)(v10 + 8) = a2;
  *(void *)(v10 + 16) = 0;
  float v11 = (uint64_t *)(v10 + 16);
  *(void *)(v10 + 24) = 0;
  *(void *)(v10 + 32) = 0;
  {
    operator new();
  }
  uint64_t v12 = mdm::Allocator::instance(void)::alloc;
  *(void *)(v10 + 40) = mdm::Allocator::instance(void)::alloc;
  *(_DWORD *)(v10 + 48) = -65536;
  unint64_t v13 = *(void *)(a2 + 32);
  uint64_t v14 = *(void *)(v10 + 16);
  if (0xCCCCCCCCCCCCCCCDLL * ((*(void *)(v10 + 32) - v14) >> 2) < v13)
  {
    if (v13 > 0xCCCCCCCCCCCCCCCLL) {
      abort();
    }
    uint64_t v15 = *(void *)(v10 + 24);
    uint64_t v16 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v12 + 16))(v12, 20 * v13, 4);
    uint64_t v18 = *(void *)(v10 + 16);
    uint64_t v17 = *(void *)(v10 + 24);
    uint64_t v19 = v16 + v15 - v14;
    if (v17 != v18)
    {
      do
      {
        uint64_t v20 = *(void *)(v17 - 20);
        v17 -= 20;
        char v21 = *(unsigned char *)(v17 + 8);
        *(void *)(v19 - 20) = v20;
        v19 -= 20;
        *(unsigned char *)(v19 + 8) = v21;
        *(_DWORD *)(v19 + 9) = *(_DWORD *)(v17 + 9);
        int v22 = *(_DWORD *)(v17 + 14);
        *(_WORD *)(v19 + 18) = *(_WORD *)(v17 + 18);
        *(_DWORD *)(v19 + 14) = v22;
      }
      while (v17 != v18);
      uint64_t v17 = *v11;
    }
    *(void *)(v10 + 16) = v19;
    *(void *)(v10 + 24) = v16 + v15 - v14;
    uint64_t v23 = *(void *)(v10 + 32);
    *(void *)(v10 + 32) = v16 + 20 * v13;
    if (v17) {
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v10 + 40) + 40))(*(void *)(v10 + 40), v17, v23 - v17);
    }
  }
  uint64_t v82 = v4;
  if (v13)
  {
    uint64_t v24 = 0;
    unint64_t v25 = *(void *)(v10 + 24);
    do
    {
      unint64_t v26 = *(void *)(v10 + 32);
      if (v25 >= v26)
      {
        unint64_t v27 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v25 - *v11) >> 2);
        unint64_t v28 = v27 + 1;
        if (v27 + 1 > 0xCCCCCCCCCCCCCCCLL) {
          abort();
        }
        unint64_t v29 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v26 - *v11) >> 2);
        if (2 * v29 > v28) {
          unint64_t v28 = 2 * v29;
        }
        if (v29 >= 0x666666666666666) {
          uint64_t v30 = 0xCCCCCCCCCCCCCCCLL;
        }
        else {
          uint64_t v30 = v28;
        }
        if (v30)
        {
          uint64_t v31 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v10 + 40) + 16))(*(void *)(v10 + 40), 20 * v30, 4);
          uint64_t v32 = v31 + 20 * v27;
          uint64_t v33 = v31 + 20 * v30;
          if (v31)
          {
            *(unsigned char *)(v32 + 8) = 0;
            *(void *)uint64_t v32 = 0;
            unint64_t v34 = v31 + 20 * v27;
            *(_DWORD *)(v34 + 9) = -16777216;
            *(_WORD *)(v34 + 14) = v24;
            *(_DWORD *)(v34 + 16) = -1;
          }
        }
        else
        {
          uint64_t v33 = 0;
          uint64_t v32 = 20 * v27;
        }
        uint64_t v36 = *(void *)(v10 + 16);
        uint64_t v35 = *(void *)(v10 + 24);
        uint64_t v37 = v32;
        if (v35 != v36)
        {
          do
          {
            uint64_t v38 = *(void *)(v35 - 20);
            v35 -= 20;
            char v39 = *(unsigned char *)(v35 + 8);
            *(void *)(v37 - 20) = v38;
            v37 -= 20;
            *(unsigned char *)(v37 + 8) = v39;
            *(_DWORD *)(v37 + 9) = *(_DWORD *)(v35 + 9);
            int v40 = *(_DWORD *)(v35 + 14);
            *(_WORD *)(v37 + 18) = *(_WORD *)(v35 + 18);
            *(_DWORD *)(v37 + 14) = v40;
          }
          while (v35 != v36);
          uint64_t v35 = *v11;
        }
        unint64_t v25 = v32 + 20;
        *(void *)(v10 + 16) = v37;
        *(void *)(v10 + 24) = v32 + 20;
        uint64_t v41 = *(void *)(v10 + 32);
        *(void *)(v10 + 32) = v33;
        if (v35) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v10 + 40) + 40))(*(void *)(v10 + 40), v35, v41 - v35);
        }
      }
      else
      {
        if (v25)
        {
          *(unsigned char *)(v25 + 8) = 0;
          *(void *)unint64_t v25 = 0;
          *(_DWORD *)(v25 + 9) = -16777216;
          *(_WORD *)(v25 + 14) = v24;
          *(_DWORD *)(v25 + 16) = -1;
        }
        v25 += 20;
      }
      *(void *)(v10 + 24) = v25;
      ++v24;
    }
    while (v24 != v13);
  }
  uint64_t v84 = v10;
  float v42 = (uint64_t *)v83[64];
  unint64_t v43 = v83[65];
  if ((unint64_t)v42 < v43)
  {
    uint64_t v44 = (uint64_t **)v82;
    if (v42)
    {
      *float v42 = v10;
      uint64_t v10 = 0;
      uint64_t v84 = 0;
    }
    uint64_t v45 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    v83[64] = (uint64_t)(v42 + 1);
    if (!v10) {
      goto LABEL_91;
    }
LABEL_85:
    BOOL v71 = (*(void *)v10)-- == 1;
    if (v71)
    {
      uint64_t v73 = *(void *)(v10 + 16);
      if (v73)
      {
        *(void *)(v10 + 24) = v73;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v10 + 40) + 40))(*(void *)(v10 + 40), v73, *(void *)(v10 + 32) - v73);
      }
      {
        operator new();
      }
      (*(void (**)(void, uint64_t, uint64_t))(**((void **)v45 + 91) + 40))(*((void *)v45 + 91), v84, 56);
    }
    goto LABEL_91;
  }
  uint64_t v46 = v83[63];
  uint64_t v47 = ((uint64_t)v42 - v46) >> 3;
  unint64_t v48 = v47 + 1;
  uint64_t v44 = (uint64_t **)v82;
  if ((unint64_t)(v47 + 1) >> 61) {
    abort();
  }
  uint64_t v49 = v43 - v46;
  if (v49 >> 2 > v48) {
    unint64_t v48 = v49 >> 2;
  }
  if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v50 = v48;
  }
  if (v50)
  {
    uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v83[66] + 16))(v83[66], 8 * v50, 8);
    uint64_t v52 = (uint64_t *)(v51 + 8 * v47);
    uint64_t v53 = v51 + 8 * v50;
    uint64_t v45 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v51)
    {
      *uint64_t v52 = v10;
      uint64_t v84 = 0;
    }
  }
  else
  {
    uint64_t v53 = 0;
    uint64_t v52 = (uint64_t *)(8 * v47);
    uint64_t v45 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  }
  uint64_t v54 = v52 + 1;
  uint64_t v55 = (char *)v83[63];
  float v56 = (char *)v83[64];
  if (v56 == v55)
  {
    v83[63] = (uint64_t)v52;
    v83[64] = (uint64_t)v54;
    uint64_t v59 = v83[65];
    v83[65] = v53;
    goto LABEL_82;
  }
  unint64_t v57 = v56 - v55 - 8;
  if (v57 < 0x48)
  {
    float v58 = (char *)v83[64];
    goto LABEL_69;
  }
  unint64_t v60 = (v55 - v56 + 7) & 0xFFFFFFFFFFFFFFF8;
  if ((char *)v52 + v60 < v56 && &v56[v60] < (char *)v52)
  {
    float v58 = (char *)v83[64];
    do
    {
LABEL_69:
      *--uint64_t v52 = 0;
      uint64_t v66 = *((void *)v58 - 1);
      v58 -= 8;
      *uint64_t v52 = v66;
      *(void *)float v58 = 0;
    }
    while (v58 != v55);
    goto LABEL_70;
  }
  uint64_t v61 = (v57 >> 3) + 1;
  float v58 = &v56[-8 * (v61 & 0x3FFFFFFFFFFFFFFCLL)];
  uint64_t v62 = v52 - 4;
  float v63 = v56 - 32;
  uint64_t v64 = v61 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    *(_OWORD *)uint64_t v62 = 0uLL;
    *((_OWORD *)v62 + 1) = 0uLL;
    long long v65 = *((_OWORD *)v63 + 1);
    *(_OWORD *)uint64_t v62 = *(_OWORD *)v63;
    *((_OWORD *)v62 + 1) = v65;
    v62 -= 4;
    *(_OWORD *)float v63 = 0uLL;
    *((_OWORD *)v63 + 1) = 0uLL;
    v63 -= 32;
    v64 -= 4;
  }
  while (v64);
  v52 -= v61 & 0x3FFFFFFFFFFFFFFCLL;
  if (v61 != (v61 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_69;
  }
LABEL_70:
  float v56 = (char *)v83[63];
  uint64_t v67 = (char *)v83[64];
  v83[63] = (uint64_t)v52;
  v83[64] = (uint64_t)v54;
  uint64_t v59 = v83[65];
  v83[65] = v53;
  if (v67 != v56)
  {
    v68 = v67;
    do
    {
      uint64_t v70 = *((void *)v68 - 1);
      v68 -= 8;
      uint64_t v69 = v70;
      if (v70)
      {
        BOOL v71 = (*(void *)v69)-- == 1;
        if (v71)
        {
          uint64_t v72 = *(void *)(v69 + 16);
          if (v72)
          {
            *(void *)(v69 + 24) = v72;
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v69 + 40) + 40))(*(void *)(v69 + 40), v72, *(void *)(v69 + 32) - v72);
          }
          {
            operator new();
          }
          (*(void (**)(void, void, uint64_t))(**((void **)v45 + 91) + 40))(*((void *)v45 + 91), *((void *)v67 - 1), 56);
          *((void *)v67 - 1) = 0;
        }
      }
      uint64_t v67 = v68;
    }
    while (v68 != v56);
  }
LABEL_82:
  if (v56) {
    (*(void (**)(uint64_t, char *, uint64_t))(*(void *)v83[66] + 40))(v83[66], v56, v59 - (void)v56);
  }
  uint64_t v10 = v84;
  v83[64] = (uint64_t)v54;
  if (v84) {
    goto LABEL_85;
  }
LABEL_91:
  uint64_t v74 = *(void *)(v83[64] - 8);
  if (v74) {
    uint64_t v75 = v74 + 8;
  }
  else {
    uint64_t v75 = 0;
  }
  BOOL result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v83[73] + 16))(v83[73], 48, 8);
  uint64_t v76 = result;
  result[4] = a2;
  result[5] = v75;
  float v77 = (uint64_t *)v83[72];
  float v78 = v44;
  if (v77)
  {
    while (1)
    {
      while (1)
      {
        float v78 = (uint64_t **)v77;
        unint64_t v79 = v77[4];
        if (v79 <= a2) {
          break;
        }
        float v77 = *v78;
        uint64_t v44 = v78;
        if (!*v78) {
          goto LABEL_101;
        }
      }
      if (v79 >= a2) {
        break;
      }
      float v77 = v78[1];
      if (!v77)
      {
        uint64_t v44 = v78 + 1;
        goto LABEL_101;
      }
    }
    if (result)
    {
      float v81 = *(uint64_t (**)(void))(*(void *)v83[73] + 40);
      return (uint64_t *)v81();
    }
  }
  else
  {
LABEL_101:
    *BOOL result = 0;
    result[1] = 0;
    result[2] = (uint64_t)v78;
    *uint64_t v44 = result;
    uint64_t v80 = *(void *)v83[71];
    if (v80)
    {
      v83[71] = v80;
      uint64_t v76 = *v44;
    }
    BOOL result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v83[72], v76);
    ++v83[74];
  }
  return result;
}

void sub_1A25334D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  geo::fast_shared_ptr<md::TransitLineLabelFeature::LabelTransitLink,mdm::MDAllocator>::~fast_shared_ptr((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1A25334E8(_Unwind_Exception *a1)
{
  gss::FeatureAttributeSet::~FeatureAttributeSet(v2);
  if ((*(void *)v1)-- == 1)
  {
    uint64_t v6 = *(void *)v2;
    if (*(void *)v2)
    {
      *(void *)(v1 + 24) = v6;
      uint64_t v4 = (mdm::Allocator *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 40) + 40))(*(void *)(v1 + 40), v6, *(void *)(v1 + 32) - v6);
    }
    uint64_t v7 = mdm::Allocator::instance(v4);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 40))(v7, v1, 56);
  }
  _Unwind_Resume(a1);
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *,false>(unint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  float v11 = (uint64_t *)result;
  while (2)
  {
    uint64_t v12 = a2 - 1;
    float v118 = a2 - 3;
    uint64_t v119 = a2 - 2;
    j = v11;
    float v117 = a2;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          float v11 = j;
          uint64_t v14 = (char *)a2 - (char *)j;
          unint64_t v15 = a2 - j;
          if (v6 || !v5)
          {
            switch(v15)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                uint64_t v56 = *j;
                if (*(void *)(*(void *)(*(void *)a3 + 536) + 32 * *v12 + 16) < *(void *)(*(void *)(*(void *)a3 + 536)
                                                                                                  + 32 * *j
                                                                                                  + 16))
                {
                  uint64_t *j = *v12;
                  *uint64_t v12 = v56;
                }
                break;
              case 3uLL:
                uint64_t v57 = *(void *)(*(void *)a3 + 536);
                BOOL result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(j, j + 1, v12, v57);
                break;
              case 4uLL:
                BOOL result = (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(j, j + 1, j + 2, v12, a3);
                break;
              case 5uLL:
                BOOL result = (unint64_t)std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *,0>(j, j + 1, j + 2, j + 3, v12, a3);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v14 <= 191)
          {
            uint64_t v58 = *(void *)a3;
            if (a5)
            {
              if (j != a2)
              {
                uint64_t v59 = j + 1;
                if (j + 1 != a2)
                {
                  uint64_t v60 = 0;
                  uint64_t v61 = *(void *)(v58 + 536);
                  uint64_t v62 = j;
                  do
                  {
                    uint64_t v64 = v62;
                    uint64_t v62 = v59;
                    uint64_t v65 = v64[1];
                    uint64_t v66 = v61 + 32 * v65;
                    unsigned int v67 = *(_DWORD *)(v66 + 20);
                    if (*(void *)(v66 + 16) < *(void *)(v61 + 32 * *v64 + 16))
                    {
                      v64[1] = *v64;
                      float v63 = j;
                      if (v64 != j)
                      {
                        v68 = (unsigned int *)(v66 + 16);
                        uint64_t v69 = v60;
                        while (1)
                        {
                          uint64_t v70 = *(uint64_t *)((char *)j + v69 - 8);
                          BOOL result = *(unsigned int *)(v61 + 32 * v70 + 20);
                          if (v67 >= result)
                          {
                            if (v67 != result)
                            {
                              float v63 = (uint64_t *)((char *)j + v69);
                              goto LABEL_96;
                            }
                            BOOL result = *v68;
                            if (result >= *(_DWORD *)(v61 + 32 * v70 + 16)) {
                              break;
                            }
                          }
                          --v64;
                          *(uint64_t *)((char *)j + v69) = v70;
                          v69 -= 8;
                          if (!v69)
                          {
                            float v63 = j;
                            goto LABEL_96;
                          }
                        }
                        float v63 = v64;
                      }
LABEL_96:
                      *float v63 = v65;
                    }
                    uint64_t v59 = v62 + 1;
                    v60 += 8;
                  }
                  while (v62 + 1 != a2);
                }
              }
            }
            else if (j != a2)
            {
              uint64_t v106 = j + 1;
              if (j + 1 != a2)
              {
                uint64_t v107 = *(void *)(v58 + 536);
                do
                {
                  v108 = v11;
                  float v11 = v106;
                  uint64_t v110 = *v108;
                  uint64_t v109 = v108[1];
                  uint64_t v111 = v107 + 32 * v109;
                  unsigned int v112 = *(_DWORD *)(v111 + 20);
                  if (*(void *)(v111 + 16) < *(void *)(v107 + 32 * *v108 + 16))
                  {
                    v113 = (_DWORD *)(v111 + 16);
                    do
                    {
                      uint64_t v114 = v108;
                      uint64_t v115 = v110;
                      uint64_t v116 = *--v108;
                      uint64_t v110 = v116;
                      v108[2] = v115;
                    }
                    while (__PAIR64__(v112, *v113) < *(void *)(v107 + 32 * v116 + 16));
                    *uint64_t v114 = v109;
                  }
                  uint64_t v106 = v11 + 1;
                }
                while (v11 + 1 != a2);
              }
            }
            return result;
          }
          if (!a4)
          {
            if (j != a2)
            {
              int64_t v71 = (v15 - 2) >> 1;
              uint64_t v72 = *(void *)a3;
              int64_t v73 = v71;
              do
              {
                int64_t v74 = v73;
                if (v71 >= v73)
                {
                  uint64_t v75 = (2 * v73) | 1;
                  uint64_t v76 = &j[v75];
                  if (2 * v74 + 2 < (uint64_t)v15)
                  {
                    uint64_t v77 = *(void *)(v72 + 536);
                    if (*(void *)(v77 + 32 * *v76 + 16) < *(void *)(v77 + 32 * v76[1] + 16))
                    {
                      ++v76;
                      uint64_t v75 = 2 * v74 + 2;
                    }
                  }
                  else
                  {
                    uint64_t v77 = *(void *)(v72 + 536);
                  }
                  uint64_t v78 = j[v74];
                  BOOL result = *v76;
                  unsigned int v79 = *(_DWORD *)(v77 + 32 * v78 + 20);
                  if (*(void *)(v77 + 32 * *v76 + 16) >= *(void *)(v77 + 32 * v78 + 16))
                  {
                    j[v74] = result;
                    if (v71 >= v75)
                    {
                      while (1)
                      {
                        uint64_t v80 = 2 * v75;
                        uint64_t v75 = (2 * v75) | 1;
                        BOOL result = (unint64_t)&j[v75];
                        uint64_t v81 = v80 + 2;
                        if (v81 < (uint64_t)v15
                          && *(void *)(v77 + 32 * *(void *)result + 16) < *(void *)(v77
                                                                                          + 32
                                                                                          * *(void *)(result + 8)
                                                                                          + 16))
                        {
                          result += 8;
                          uint64_t v75 = v81;
                        }
                        if (*(void *)(v77 + 32 * *(void *)result + 16) < __PAIR64__(v79, *(_DWORD *)(v77 + 32 * v78 + 16)))break; {
                        *uint64_t v76 = *(void *)result;
                        }
                        uint64_t v76 = (uint64_t *)result;
                        if (v71 < v75) {
                          goto LABEL_110;
                        }
                      }
                    }
                    BOOL result = (unint64_t)v76;
LABEL_110:
                    *(void *)BOOL result = v78;
                    uint64_t v72 = *(void *)a3;
                  }
                }
                int64_t v73 = v74 - 1;
              }
              while (v74);
              uint64_t v82 = (unint64_t)v14 >> 3;
              do
              {
                uint64_t v84 = 0;
                uint64_t v85 = *j;
                uint64_t v86 = *(void *)a3;
                v87 = j;
                do
                {
                  int64_t v88 = v87;
                  v87 += v84 + 1;
                  uint64_t v89 = 2 * v84;
                  uint64_t v84 = (2 * v84) | 1;
                  uint64_t v90 = v89 + 2;
                  if (v90 < v82)
                  {
                    BOOL result = v87[1];
                    uint64_t v91 = *(void *)(v86 + 536);
                    unsigned int v92 = *(_DWORD *)(v91 + 32 * *v87 + 20);
                    unsigned int v93 = *(_DWORD *)(v91 + 32 * result + 20);
                    if (v92 < v93
                      || v92 == v93
                      && (BOOL result = *(unsigned int *)(v91 + 32 * result + 16),
                          *(_DWORD *)(v91 + 32 * *v87 + 16) < result))
                    {
                      ++v87;
                      uint64_t v84 = v90;
                    }
                  }
                  *int64_t v88 = *v87;
                }
                while (v84 <= (uint64_t)((unint64_t)(v82 - 2) >> 1));
                if (v87 == --a2)
                {
                  uint64_t *v87 = v85;
                }
                else
                {
                  uint64_t *v87 = *a2;
                  *a2 = v85;
                  uint64_t v94 = (char *)v87 - (char *)j + 8;
                  if (v94 >= 9)
                  {
                    unint64_t v95 = ((unint64_t)v94 >> 3) - 2;
                    unint64_t v96 = v95 >> 1;
                    float v97 = &j[v95 >> 1];
                    uint64_t v98 = *v97;
                    uint64_t v99 = *v87;
                    uint64_t v100 = *(void *)(*(void *)a3 + 536);
                    unsigned int v101 = *(_DWORD *)(v100 + 32 * *v97 + 20);
                    unsigned int v102 = *(_DWORD *)(v100 + 32 * *v87 + 20);
                    if (v101 < v102
                      || v101 == v102
                      && (BOOL result = *(unsigned int *)(v100 + 32 * v99 + 16),
                          *(_DWORD *)(v100 + 32 * v98 + 16) < result))
                    {
                      uint64_t *v87 = v98;
                      if (v95 >= 2)
                      {
                        while (1)
                        {
                          unint64_t v103 = v96 - 1;
                          unint64_t v96 = (v96 - 1) >> 1;
                          uint64_t v104 = &j[v96];
                          uint64_t v105 = *v104;
                          BOOL result = *(unsigned int *)(v100 + 32 * *v104 + 20);
                          if (result >= v102)
                          {
                            if (result != v102) {
                              break;
                            }
                            BOOL result = *(unsigned int *)(v100 + 32 * v105 + 16);
                            if (result >= *(_DWORD *)(v100 + 32 * v99 + 16)) {
                              break;
                            }
                          }
                          *float v97 = v105;
                          float v97 = &j[v96];
                          if (v103 <= 1) {
                            goto LABEL_151;
                          }
                        }
                      }
                      uint64_t v104 = v97;
LABEL_151:
                      *uint64_t v104 = v99;
                    }
                  }
                }
              }
              while (v82-- > 2);
            }
            return result;
          }
          unint64_t v16 = v15 >> 1;
          uint64_t v17 = &j[v15 >> 1];
          uint64_t v18 = *(void *)(*(void *)a3 + 536);
          if ((unint64_t)v14 >= 0x401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(v11, &v11[v15 >> 1], v12, v18);
            uint64_t v19 = &v11[v16];
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(v11 + 1, v19 - 1, v119, *(void *)(*(void *)a3 + 536));
            a2 = v117;
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(v11 + 2, &v11[v16 + 1], v118, *(void *)(*(void *)a3 + 536));
            BOOL result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(v19 - 1, v17, &v11[v16 + 1], *(void *)(*(void *)a3 + 536));
            uint64_t v20 = *v11;
            uint64_t *v11 = *v19;
            *uint64_t v19 = v20;
          }
          else
          {
            BOOL result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(&v11[v15 >> 1], v11, v12, v18);
          }
          --a4;
          uint64_t v21 = *(void *)a3;
          uint64_t v22 = *v11;
          if (a5)
          {
            uint64_t v23 = *(void *)(v21 + 536);
            unsigned int v24 = *(_DWORD *)(v23 + 32 * v22 + 20);
            break;
          }
          uint64_t v25 = *(v11 - 1);
          uint64_t v23 = *(void *)(v21 + 536);
          unsigned int v26 = *(_DWORD *)(v23 + 32 * v25 + 20);
          unsigned int v24 = *(_DWORD *)(v23 + 32 * v22 + 20);
          if (v26 < v24) {
            break;
          }
          if (v26 == v24)
          {
            unsigned int v24 = *(_DWORD *)(v23 + 32 * v25 + 20);
            if (*(_DWORD *)(v23 + 32 * v25 + 16) < *(_DWORD *)(v23 + 32 * v22 + 16)) {
              break;
            }
          }
          uint64_t v43 = *v12;
          unsigned int v44 = *(_DWORD *)(v23 + 32 * *v12 + 20);
          if (__PAIR64__(v24, *(_DWORD *)(v23 + 32 * v22 + 16)) < __PAIR64__(v44, *(_DWORD *)(v23 + 32 * v43 + 16)))
          {
            j = v11 + 1;
            uint64_t v45 = v11[1];
            for (unsigned int i = *(_DWORD *)(v23 + 32 * v45 + 20); v24 >= i; unsigned int i = *(_DWORD *)(v23 + 32 * v47 + 20))
            {
              if (v24 == i && *(_DWORD *)(v23 + 32 * v22 + 16) < *(_DWORD *)(v23 + 32 * v45 + 16)) {
                break;
              }
              uint64_t v47 = j[1];
              ++j;
              uint64_t v45 = v47;
            }
          }
          else
          {
            for (j = v11 + 1; j < a2; ++j)
            {
              if (__PAIR64__(v24, *(_DWORD *)(v23 + 32 * v22 + 16)) < *(void *)(v23 + 32 * *j + 16)) {
                break;
              }
            }
          }
          unint64_t v48 = a2;
          if (j < a2)
          {
            unint64_t v48 = v12;
            while (v24 < v44 || v24 == v44 && *(_DWORD *)(v23 + 32 * v22 + 16) < *(_DWORD *)(v23 + 32 * v43 + 16))
            {
              uint64_t v49 = *--v48;
              uint64_t v43 = v49;
              unsigned int v44 = *(_DWORD *)(v23 + 32 * v49 + 20);
            }
          }
          if (j < v48)
          {
            uint64_t v50 = (_DWORD *)(v23 + 32 * v22 + 16);
            uint64_t v51 = *j;
            uint64_t v52 = *v48;
            do
            {
              uint64_t *j = v52;
              *unint64_t v48 = v51;
              do
              {
                uint64_t v53 = j[1];
                ++j;
                uint64_t v51 = v53;
              }
              while (__PAIR64__(v24, *v50) >= *(void *)(v23 + 32 * v53 + 16));
              do
              {
                uint64_t v54 = *--v48;
                uint64_t v52 = v54;
              }
              while (__PAIR64__(v24, *v50) < *(void *)(v23 + 32 * v54 + 16));
            }
            while (j < v48);
          }
          uint64_t v55 = j - 1;
          BOOL v5 = j - 1 >= v11;
          BOOL v6 = j - 1 == v11;
          if (j - 1 != v11) {
            uint64_t *v11 = *v55;
          }
          a5 = 0;
          *uint64_t v55 = v22;
        }
        unint64_t v27 = (_DWORD *)(v23 + 32 * v22 + 16);
        for (k = v11 + 1; ; ++k)
        {
          uint64_t v29 = *k;
          if (*(void *)(v23 + 32 * *k + 16) >= __PAIR64__(v24, *v27)) {
            break;
          }
        }
        uint64_t v30 = k - 1;
        if (k - 1 == v11)
        {
          uint64_t v33 = a2;
          if (k < a2)
          {
            uint64_t v35 = *v12;
            unsigned int v36 = *(_DWORD *)(v23 + 32 * *v12 + 20);
            uint64_t v33 = v12;
            if (v36 >= v24)
            {
              uint64_t v33 = v12;
              do
              {
                if (v36 == v24)
                {
                  if (k >= v33 || *(_DWORD *)(v23 + 32 * v35 + 16) < *v27) {
                    break;
                  }
                }
                else if (k >= v33)
                {
                  break;
                }
                uint64_t v42 = *--v33;
                uint64_t v35 = v42;
                unsigned int v36 = *(_DWORD *)(v23 + 32 * v42 + 20);
              }
              while (v36 >= v24);
            }
          }
        }
        else
        {
          uint64_t v31 = *v12;
          unsigned int v32 = *(_DWORD *)(v23 + 32 * *v12 + 20);
          uint64_t v33 = v12;
          if (v32 >= v24)
          {
            uint64_t v33 = v12;
            do
            {
              if (v32 == v24 && *(_DWORD *)(v23 + 32 * v31 + 16) < *v27) {
                break;
              }
              uint64_t v34 = *--v33;
              uint64_t v31 = v34;
              unsigned int v32 = *(_DWORD *)(v23 + 32 * v34 + 20);
            }
            while (v32 >= v24);
          }
        }
        if (k < v33)
        {
          uint64_t v37 = *v33;
          uint64_t v38 = k;
          char v39 = v33;
          do
          {
            *v38++ = v37;
            uint64_t *v39 = v29;
            while (1)
            {
              uint64_t v29 = *v38;
              if (*(void *)(v23 + 32 * *v38 + 16) >= __PAIR64__(v24, *v27)) {
                break;
              }
              ++v38;
            }
            uint64_t v30 = v38 - 1;
            do
            {
              uint64_t v40 = *--v39;
              uint64_t v37 = v40;
            }
            while (*(void *)(v23 + 32 * v40 + 16) >= __PAIR64__(v24, *v27));
          }
          while (v38 < v39);
        }
        if (v30 != v11) {
          uint64_t *v11 = *v30;
        }
        uint64_t *v30 = v22;
        if (k >= v33) {
          break;
        }
LABEL_41:
        BOOL result = std::__introsort<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *,false>(v11, v30, a3, a4, a5 & 1);
        a5 = 0;
        j = v30 + 1;
      }
      BOOL v41 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(v11, v30, a3);
      j = v30 + 1;
      BOOL result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(v30 + 1, a2, a3);
      if (result) {
        break;
      }
      if (!v41) {
        goto LABEL_41;
      }
    }
    a2 = v30;
    if (!v41) {
      continue;
    }
    return result;
  }
}

uint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *result;
  unsigned int v6 = *(_DWORD *)(a4 + 32 * *a2 + 20);
  unsigned int v7 = *(_DWORD *)(a4 + 32 * *result + 20);
  if (*(void *)(a4 + 32 * *a2 + 16) >= *(void *)(a4 + 32 * *result + 16))
  {
    if (*(void *)(a4 + 32 * *a3 + 16) < __PAIR64__(v6, *(_DWORD *)(a4 + 32 * v4 + 16)))
    {
      *a2 = *a3;
      *a3 = v4;
      uint64_t v8 = *result;
      if (*(void *)(a4 + 32 * *a2 + 16) < *(void *)(a4 + 32 * *result + 16))
      {
        *BOOL result = *a2;
        *a2 = v8;
      }
    }
  }
  else
  {
    if (*(void *)(a4 + 32 * *a3 + 16) < __PAIR64__(v6, *(_DWORD *)(a4 + 32 * v4 + 16)))
    {
      *BOOL result = *a3;
    }
    else
    {
      *BOOL result = v4;
      *a2 = v5;
      if (*(void *)(a4 + 32 * *a3 + 16) >= __PAIR64__(v7, *(_DWORD *)(a4 + 32 * v5 + 16))) {
        return result;
      }
      *a2 = *a3;
    }
    *a3 = v5;
  }
  return result;
}

uint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  BOOL result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(a1, a2, a3, *(void *)(*(void *)a5 + 536));
  uint64_t v11 = *a3;
  uint64_t v12 = *(void *)(*(void *)a5 + 536);
  if (*(void *)(v12 + 32 * *a4 + 16) < *(void *)(v12 + 32 * *a3 + 16))
  {
    *a3 = *a4;
    *a4 = v11;
    uint64_t v13 = *a2;
    if (*(void *)(v12 + 32 * *a3 + 16) < *(void *)(v12 + 32 * *a2 + 16))
    {
      *a2 = *a3;
      *a3 = v13;
      uint64_t v14 = *a1;
      if (*(void *)(v12 + 32 * *a2 + 16) < *(void *)(v12 + 32 * *a1 + 16))
      {
        *a1 = *a2;
        *a2 = v14;
      }
    }
  }
  return result;
}

uint64_t *std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  BOOL result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(a1, a2, a3, a4, a6);
  uint64_t v13 = *a4;
  uint64_t v14 = *(void *)(*(void *)a6 + 536);
  if (*(void *)(v14 + 32 * *a5 + 16) < *(void *)(v14 + 32 * *a4 + 16))
  {
    *a4 = *a5;
    *a5 = v13;
    uint64_t v15 = *a3;
    if (*(void *)(v14 + 32 * *a4 + 16) < *(void *)(v14 + 32 * *a3 + 16))
    {
      *a3 = *a4;
      *a4 = v15;
      uint64_t v16 = *a2;
      if (*(void *)(v14 + 32 * *a3 + 16) < *(void *)(v14 + 32 * *a2 + 16))
      {
        *a2 = *a3;
        *a3 = v16;
        uint64_t v17 = *a1;
        if (*(void *)(v14 + 32 * *a2 + 16) < *(void *)(v14 + 32 * *a1 + 16))
        {
          *a1 = *a2;
          *a2 = v17;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *a1;
      if (*(void *)(*(void *)(*(void *)a3 + 536) + 32 * v8 + 16) < *(void *)(*(void *)(*(void *)a3 + 536)
                                                                                      + 32 * *a1
                                                                                      + 16))
      {
        *a1 = v8;
        *(a2 - 1) = v9;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(a1, a1 + 1, a2 - 1, *(void *)(*(void *)a3 + 536));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v10 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *>(a1, a1 + 1, a1 + 2, *(void *)(*(void *)a3 + 536));
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      uint64_t v14 = *(void *)(*(void *)a3 + 536);
      break;
  }
  while (1)
  {
    uint64_t v16 = *v11;
    uint64_t v17 = v14 + 32 * *v11;
    unsigned int v18 = *(_DWORD *)(v17 + 20);
    if (*(void *)(v17 + 16) < *(void *)(v14 + 32 * *v10 + 16))
    {
      uint64_t *v11 = *v10;
      uint64_t v15 = a1;
      if (v10 != a1)
      {
        uint64_t v19 = (_DWORD *)(v17 + 16);
        uint64_t v20 = v12;
        while (1)
        {
          uint64_t v21 = *(uint64_t *)((char *)a1 + v20 + 8);
          unsigned int v22 = *(_DWORD *)(v14 + 32 * v21 + 20);
          if (v18 >= v22)
          {
            if (v18 != v22)
            {
              uint64_t v15 = v10;
              goto LABEL_7;
            }
            if (*v19 >= *(_DWORD *)(v14 + 32 * v21 + 16)) {
              break;
            }
          }
          --v10;
          *(uint64_t *)((char *)a1 + v20 + 16) = v21;
          v20 -= 8;
          if (v20 == -16)
          {
            uint64_t v15 = a1;
            goto LABEL_7;
          }
        }
        uint64_t v15 = (uint64_t *)((char *)a1 + v20 + 16);
      }
LABEL_7:
      uint64_t *v15 = v16;
      if (++v13 == 8) {
        return v11 + 1 == a2;
      }
    }
    uint64_t v10 = v11;
    v12 += 8;
    if (++v11 == a2) {
      return 1;
    }
  }
}

void *geo::fast_shared_ptr<md::TransitLineLabelFeature::LabelTransitLink,mdm::MDAllocator>::~fast_shared_ptr(void *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((*(void *)v2)-- == 1)
    {
      uint64_t v4 = *(void *)(v2 + 16);
      if (v4)
      {
        *(void *)(v2 + 24) = v4;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 40) + 40))(*(void *)(v2 + 40), v4, *(void *)(v2 + 32) - v4);
      }
      uint64_t v5 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
      {
        uint64_t v5 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
        if (v7) {
          operator new();
        }
      }
      (*(void (**)(void, void, uint64_t))(**((void **)v5 + 91) + 40))(*((void *)v5 + 91), *a1, 56);
      *a1 = 0;
    }
  }
  return a1;
}

uint64_t *std::__introsort<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::shieldsForLabelMarker(md::LabelManager *,std::vector<md::LabelShieldEntry,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>> &)::$_0 &,unsigned long *,false>(uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v11 = result;
  while (2)
  {
    uint64_t v12 = a2 - 1;
    int v13 = v11;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v11 = v13;
          uint64_t v14 = (char *)a2 - (char *)v13;
          uint64_t v15 = a2 - v13;
          if (v6 || !v5)
          {
            switch(v15)
            {
              case 0:
              case 1:
                return result;
              case 2:
                uint64_t v86 = *v13;
                if (*(unsigned __int16 *)(*(void *)(*(void *)a3 + 536) + 32 * *v12 + 14) >= *(unsigned __int16 *)(*(void *)(*(void *)a3 + 536) + 32 * *v13 + 14)) {
                  return result;
                }
                *int v13 = *v12;
                goto LABEL_168;
              case 3:
                uint64_t v87 = *(void *)(*(void *)a3 + 536);
                uint64_t v86 = *v13;
                uint64_t v88 = v13[1];
                unsigned int v89 = *(unsigned __int16 *)(v87 + 32 * v88 + 14);
                unsigned int v90 = *(unsigned __int16 *)(v87 + 32 * *v13 + 14);
                uint64_t v91 = *v12;
                unsigned int v92 = *(unsigned __int16 *)(v87 + 32 * *v12 + 14);
                if (v89 >= v90)
                {
                  if (v92 < v89)
                  {
                    v13[1] = v91;
                    *uint64_t v12 = v88;
                    uint64_t v146 = *v13;
                    uint64_t v145 = v13[1];
                    if (*(unsigned __int16 *)(v87 + 32 * v145 + 14) < *(unsigned __int16 *)(v87 + 32 * *v13 + 14))
                    {
                      *int v13 = v145;
                      v13[1] = v146;
                    }
                  }
                }
                else
                {
                  if (v92 >= v89)
                  {
                    *int v13 = v88;
                    v13[1] = v86;
                    if (*(unsigned __int16 *)(v87 + 32 * *v12 + 14) >= v90) {
                      return result;
                    }
                    v13[1] = *v12;
                  }
                  else
                  {
                    *int v13 = v91;
                  }
LABEL_168:
                  *uint64_t v12 = v86;
                }
                break;
              case 4:
                uint64_t v93 = *(void *)(*(void *)a3 + 536);
                return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::shieldsForLabelMarker(md::LabelManager *,std::vector<md::LabelShieldEntry,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>> &)::$_0 &,unsigned long *>(v13, v13 + 1, v13 + 2, a2 - 1, v93);
              case 5:
                uint64_t v94 = v13 + 1;
                unint64_t v95 = v13 + 2;
                unint64_t v96 = v13 + 3;
                BOOL result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::shieldsForLabelMarker(md::LabelManager *,std::vector<md::LabelShieldEntry,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>> &)::$_0 &,unsigned long *>(v13, v13 + 1, v13 + 2, v13 + 3, *(void *)(*(void *)a3 + 536));
                uint64_t v97 = v13[3];
                uint64_t v98 = *(void *)(*(void *)a3 + 536);
                if (*(unsigned __int16 *)(v98 + 32 * *v12 + 14) < *(unsigned __int16 *)(v98 + 32 * v97 + 14))
                {
                  *unint64_t v96 = *v12;
                  *uint64_t v12 = v97;
                  uint64_t v99 = *v96;
                  uint64_t v100 = *v95;
                  unsigned int v101 = *(unsigned __int16 *)(v98 + 32 * *v96 + 14);
                  if (v101 < *(unsigned __int16 *)(v98 + 32 * *v95 + 14))
                  {
                    *unint64_t v95 = v99;
                    *unint64_t v96 = v100;
                    uint64_t v102 = *v94;
                    if (v101 < *(unsigned __int16 *)(v98 + 32 * *v94 + 14))
                    {
                      v13[1] = v99;
                      v13[2] = v102;
                      uint64_t v103 = *v13;
                      if (v101 < *(unsigned __int16 *)(v98 + 32 * *v13 + 14))
                      {
                        *int v13 = v99;
                        v13[1] = v103;
                      }
                    }
                  }
                }
                return result;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v14 <= 191)
          {
            uint64_t v104 = *(void *)a3;
            if (a5)
            {
              if (v13 != a2)
              {
                uint64_t v105 = v13 + 1;
                if (v13 + 1 != a2)
                {
                  uint64_t v106 = *(void *)(v104 + 536);
                  uint64_t v107 = 8;
                  v108 = v13;
                  do
                  {
                    uint64_t v111 = *v108;
                    uint64_t v110 = v108[1];
                    v108 = v105;
                    unsigned int v112 = *(unsigned __int16 *)(v106 + 32 * v110 + 14);
                    if (v112 < *(unsigned __int16 *)(v106 + 32 * v111 + 14))
                    {
                      uint64_t v113 = v107;
                      do
                      {
                        *(uint64_t *)((char *)v13 + v113) = v111;
                        uint64_t v114 = v113 - 8;
                        if (v113 == 8)
                        {
                          uint64_t v109 = v13;
                          goto LABEL_113;
                        }
                        uint64_t v111 = *(uint64_t *)((char *)v13 + v113 - 16);
                        v113 -= 8;
                      }
                      while (v112 < *(unsigned __int16 *)(v106 + 32 * v111 + 14));
                      uint64_t v109 = (uint64_t *)((char *)v13 + v114);
LABEL_113:
                      *uint64_t v109 = v110;
                    }
                    uint64_t v105 = v108 + 1;
                    v107 += 8;
                  }
                  while (v108 + 1 != a2);
                }
              }
            }
            else if (v13 != a2)
            {
              v147 = v13 + 1;
              if (v13 + 1 != a2)
              {
                uint64_t v148 = *(void *)(v104 + 536);
                do
                {
                  uint64_t v150 = *v11;
                  uint64_t v149 = v11[1];
                  uint64_t v11 = v147;
                  unsigned int v151 = *(unsigned __int16 *)(v148 + 32 * v149 + 14);
                  if (v151 < *(unsigned __int16 *)(v148 + 32 * v150 + 14))
                  {
                    v152 = v11;
                    do
                    {
                      uint64_t *v152 = v150;
                      uint64_t v150 = *(v152 - 2);
                      --v152;
                    }
                    while (v151 < *(unsigned __int16 *)(v148 + 32 * v150 + 14));
                    uint64_t *v152 = v149;
                  }
                  v147 = v11 + 1;
                }
                while (v11 + 1 != a2);
              }
            }
            return result;
          }
          if (!a4)
          {
            if (v13 != a2)
            {
              int64_t v115 = (unint64_t)(v15 - 2) >> 1;
              uint64_t v116 = *(void *)a3;
              int64_t v117 = v115;
              do
              {
                if (v115 >= v117)
                {
                  uint64_t v119 = (2 * v117) | 1;
                  uint64_t v120 = &v13[v119];
                  uint64_t v121 = *v120;
                  if (2 * v117 + 2 < v15)
                  {
                    uint64_t v122 = *(void *)(v116 + 536);
                    if (*(unsigned __int16 *)(v122 + 32 * v121 + 14) < *(unsigned __int16 *)(v122 + 32 * v120[1] + 14))
                    {
                      uint64_t v121 = v120[1];
                      ++v120;
                      uint64_t v119 = 2 * v117 + 2;
                    }
                  }
                  else
                  {
                    uint64_t v122 = *(void *)(v116 + 536);
                  }
                  v123 = &v13[v117];
                  uint64_t v124 = *v123;
                  BOOL result = (uint64_t *)*(unsigned __int16 *)(v122 + 32 * *v123 + 14);
                  if (*(unsigned __int16 *)(v122 + 32 * v121 + 14) >= result)
                  {
                    do
                    {
                      uint64_t v125 = v120;
                      uint64_t *v123 = v121;
                      if (v115 < v119) {
                        break;
                      }
                      uint64_t v126 = (2 * v119) | 1;
                      uint64_t v120 = &v13[v126];
                      uint64_t v119 = 2 * v119 + 2;
                      uint64_t v121 = *v120;
                      if (v119 < v15)
                      {
                        if (*(unsigned __int16 *)(v122 + 32 * v121 + 14) >= *(unsigned __int16 *)(v122 + 32 * v120[1] + 14))
                        {
                          uint64_t v119 = v126;
                        }
                        else
                        {
                          uint64_t v121 = v120[1];
                          ++v120;
                        }
                      }
                      else
                      {
                        uint64_t v119 = v126;
                      }
                      v123 = v125;
                    }
                    while (*(unsigned __int16 *)(v122 + 32 * v121 + 14) >= result);
                    *uint64_t v125 = v124;
                    uint64_t v116 = *(void *)a3;
                  }
                }
                BOOL v118 = v117-- <= 0;
              }
              while (!v118);
              uint64_t v127 = (unint64_t)v14 >> 3;
              do
              {
                uint64_t v128 = 0;
                uint64_t v129 = *v13;
                uint64_t v130 = *(void *)a3;
                uint64_t v131 = v13;
                do
                {
                  unsigned int v134 = &v131[v128];
                  uint64_t v135 = v134[1];
                  uint64_t v133 = v134 + 1;
                  uint64_t v132 = v135;
                  uint64_t v136 = (2 * v128) | 1;
                  uint64_t v128 = 2 * v128 + 2;
                  if (v128 < v127)
                  {
                    BOOL result = (uint64_t *)v133[1];
                    if (*(unsigned __int16 *)(*(void *)(v130 + 536) + 32 * v132 + 14) >= *(unsigned __int16 *)(*(void *)(v130 + 536) + 32 * (void)result + 14))
                    {
                      uint64_t v128 = v136;
                    }
                    else
                    {
                      uint64_t v132 = v133[1];
                      ++v133;
                    }
                  }
                  else
                  {
                    uint64_t v128 = v136;
                  }
                  *uint64_t v131 = v132;
                  uint64_t v131 = v133;
                }
                while (v128 <= (uint64_t)((unint64_t)(v127 - 2) >> 1));
                if (v133 == --a2)
                {
                  *uint64_t v133 = v129;
                }
                else
                {
                  *uint64_t v133 = *a2;
                  *a2 = v129;
                  uint64_t v137 = (char *)v133 - (char *)v13 + 8;
                  if (v137 >= 9)
                  {
                    unint64_t v138 = (((unint64_t)v137 >> 3) - 2) >> 1;
                    uint64_t v139 = &v13[v138];
                    uint64_t v140 = *v139;
                    uint64_t v141 = *v133;
                    uint64_t v142 = *(void *)(*(void *)a3 + 536);
                    unsigned int v143 = *(unsigned __int16 *)(v142 + 32 * *v133 + 14);
                    if (*(unsigned __int16 *)(v142 + 32 * *v139 + 14) < v143)
                    {
                      do
                      {
                        uint64_t v144 = v139;
                        *uint64_t v133 = v140;
                        if (!v138) {
                          break;
                        }
                        unint64_t v138 = (v138 - 1) >> 1;
                        uint64_t v139 = &v13[v138];
                        uint64_t v140 = *v139;
                        uint64_t v133 = v144;
                      }
                      while (*(unsigned __int16 *)(v142 + 32 * *v139 + 14) < v143);
                      *uint64_t v144 = v141;
                    }
                  }
                }
                BOOL v118 = v127-- <= 2;
              }
              while (!v118);
            }
            return result;
          }
          unint64_t v16 = (unint64_t)v15 >> 1;
          uint64_t v17 = &v13[(unint64_t)v15 >> 1];
          uint64_t v18 = *(void *)(*(void *)a3 + 536);
          uint64_t v19 = *v12;
          unsigned int v20 = *(unsigned __int16 *)(v18 + 32 * *v12 + 14);
          if ((unint64_t)v14 >= 0x401)
          {
            uint64_t v21 = *v17;
            uint64_t v22 = *v13;
            unsigned int v23 = *(unsigned __int16 *)(v18 + 32 * *v17 + 14);
            unsigned int v24 = *(unsigned __int16 *)(v18 + 32 * *v13 + 14);
            if (v23 >= v24)
            {
              if (v20 < v23)
              {
                *uint64_t v17 = v19;
                *uint64_t v12 = v21;
                uint64_t v29 = *v13;
                if (*(unsigned __int16 *)(v18 + 32 * *v17 + 14) < *(unsigned __int16 *)(v18 + 32 * *v13 + 14))
                {
                  *int v13 = *v17;
                  *uint64_t v17 = v29;
                }
              }
            }
            else
            {
              if (v20 >= v23)
              {
                *int v13 = v21;
                *uint64_t v17 = v22;
                if (*(unsigned __int16 *)(v18 + 32 * *v12 + 14) >= v24) {
                  goto LABEL_23;
                }
                *uint64_t v17 = *v12;
              }
              else
              {
                *int v13 = v19;
              }
              *uint64_t v12 = v22;
            }
LABEL_23:
            uint64_t v31 = &v13[v16];
            uint64_t v34 = *(v31 - 1);
            unsigned int v32 = v31 - 1;
            uint64_t v33 = v34;
            uint64_t v35 = v13[1];
            unsigned int v36 = *(unsigned __int16 *)(v18 + 32 * v34 + 14);
            unsigned int v37 = *(unsigned __int16 *)(v18 + 32 * v35 + 14);
            uint64_t v38 = *(a2 - 2);
            unsigned int v39 = *(unsigned __int16 *)(v18 + 32 * v38 + 14);
            if (v36 >= v37)
            {
              if (v39 < v36)
              {
                uint64_t *v32 = v38;
                *(a2 - 2) = v33;
                uint64_t v40 = v13[1];
                if (*(unsigned __int16 *)(v18 + 32 * *v32 + 14) < *(unsigned __int16 *)(v18 + 32 * v40 + 14))
                {
                  v13[1] = *v32;
                  uint64_t *v32 = v40;
                }
              }
            }
            else
            {
              if (v39 >= v36)
              {
                v13[1] = v33;
                uint64_t *v32 = v35;
                uint64_t v41 = *(a2 - 2);
                if (*(unsigned __int16 *)(v18 + 32 * v41 + 14) >= v37) {
                  goto LABEL_35;
                }
                uint64_t *v32 = v41;
              }
              else
              {
                v13[1] = v38;
              }
              *(a2 - 2) = v35;
            }
LABEL_35:
            uint64_t v42 = &v13[v16];
            uint64_t v45 = v42[1];
            uint64_t v43 = v42 + 1;
            uint64_t v44 = v45;
            uint64_t v46 = v13[2];
            unsigned int v47 = *(unsigned __int16 *)(v18 + 32 * v45 + 14);
            unsigned int v48 = *(unsigned __int16 *)(v18 + 32 * v46 + 14);
            uint64_t v49 = *(a2 - 3);
            unsigned int v50 = *(unsigned __int16 *)(v18 + 32 * v49 + 14);
            if (v47 >= v48)
            {
              if (v50 < v47)
              {
                *uint64_t v43 = v49;
                *(a2 - 3) = v44;
                uint64_t v51 = v13[2];
                if (*(unsigned __int16 *)(v18 + 32 * *v43 + 14) < *(unsigned __int16 *)(v18 + 32 * v51 + 14))
                {
                  v13[2] = *v43;
                  *uint64_t v43 = v51;
                }
              }
            }
            else
            {
              if (v50 >= v47)
              {
                v13[2] = v44;
                *uint64_t v43 = v46;
                uint64_t v52 = *(a2 - 3);
                if (*(unsigned __int16 *)(v18 + 32 * v52 + 14) >= v48) {
                  goto LABEL_44;
                }
                *uint64_t v43 = v52;
              }
              else
              {
                v13[2] = v49;
              }
              *(a2 - 3) = v46;
            }
LABEL_44:
            uint64_t v53 = *v17;
            uint64_t v54 = *v32;
            unsigned int v55 = *(unsigned __int16 *)(v18 + 32 * *v17 + 14);
            unsigned int v56 = *(unsigned __int16 *)(v18 + 32 * *v32 + 14);
            uint64_t v57 = *v43;
            unsigned int v58 = *(unsigned __int16 *)(v18 + 32 * *v43 + 14);
            if (v55 >= v56)
            {
              if (v58 >= v55) {
                goto LABEL_51;
              }
              *uint64_t v17 = v57;
              *uint64_t v43 = v53;
              uint64_t v43 = v17;
              uint64_t v53 = v54;
              if (v58 >= v56)
              {
                uint64_t v53 = v57;
                goto LABEL_51;
              }
            }
            else if (v58 >= v55)
            {
              uint64_t *v32 = v53;
              *uint64_t v17 = v54;
              unsigned int v32 = v17;
              uint64_t v53 = v57;
              if (v58 >= v56)
              {
                uint64_t v53 = v54;
LABEL_51:
                uint64_t v59 = *v13;
                *int v13 = v53;
                *uint64_t v17 = v59;
                goto LABEL_52;
              }
            }
            uint64_t *v32 = v57;
            *uint64_t v43 = v54;
            goto LABEL_51;
          }
          uint64_t v25 = *v13;
          uint64_t v26 = *v17;
          unsigned int v27 = *(unsigned __int16 *)(v18 + 32 * *v13 + 14);
          unsigned int v28 = *(unsigned __int16 *)(v18 + 32 * *v17 + 14);
          if (v27 >= v28)
          {
            if (v20 < v27)
            {
              *int v13 = v19;
              *uint64_t v12 = v25;
              uint64_t v30 = *v17;
              if (*(unsigned __int16 *)(v18 + 32 * *v13 + 14) < *(unsigned __int16 *)(v18 + 32 * *v17 + 14))
              {
                *uint64_t v17 = *v13;
                *int v13 = v30;
              }
            }
          }
          else
          {
            if (v20 < v27)
            {
              *uint64_t v17 = v19;
LABEL_31:
              *uint64_t v12 = v26;
              goto LABEL_52;
            }
            *uint64_t v17 = v25;
            *int v13 = v26;
            if (*(unsigned __int16 *)(v18 + 32 * *v12 + 14) < v28)
            {
              *int v13 = *v12;
              goto LABEL_31;
            }
          }
LABEL_52:
          --a4;
          uint64_t v60 = *v13;
          if (a5) {
            break;
          }
          unsigned int v61 = *(unsigned __int16 *)(v18 + 32 * v60 + 14);
          if (*(unsigned __int16 *)(v18 + 32 * *(v13 - 1) + 14) < v61) {
            break;
          }
          if (v61 < *(unsigned __int16 *)(v18 + 32 * *v12 + 14))
          {
            do
            {
              uint64_t v77 = v13[1];
              ++v13;
            }
            while (v61 >= *(unsigned __int16 *)(v18 + 32 * v77 + 14));
          }
          else
          {
            uint64_t v78 = v13 + 1;
            do
            {
              int v13 = v78;
              if (v78 >= a2) {
                break;
              }
              ++v78;
            }
            while (v61 >= *(unsigned __int16 *)(v18 + 32 * *v13 + 14));
          }
          unsigned int v79 = a2;
          if (v13 < a2)
          {
            unsigned int v79 = a2;
            do
              uint64_t v80 = *--v79;
            while (v61 < *(unsigned __int16 *)(v18 + 32 * v80 + 14));
          }
          if (v13 < v79)
          {
            uint64_t v81 = *v13;
            uint64_t v82 = *v79;
            do
            {
              *int v13 = v82;
              *unsigned int v79 = v81;
              do
              {
                uint64_t v83 = v13[1];
                ++v13;
                uint64_t v81 = v83;
              }
              while (v61 >= *(unsigned __int16 *)(v18 + 32 * v83 + 14));
              do
              {
                uint64_t v84 = *--v79;
                uint64_t v82 = v84;
              }
              while (v61 < *(unsigned __int16 *)(v18 + 32 * v84 + 14));
            }
            while (v13 < v79);
          }
          uint64_t v85 = v13 - 1;
          BOOL v5 = v13 - 1 >= v11;
          BOOL v6 = v13 - 1 == v11;
          if (v13 - 1 != v11) {
            uint64_t *v11 = *v85;
          }
          a5 = 0;
          *uint64_t v85 = v60;
        }
        uint64_t v62 = *(void *)(*(void *)a3 + 536);
        unsigned int v63 = *(unsigned __int16 *)(v62 + 32 * v60 + 14);
        uint64_t v64 = v13;
        do
        {
          uint64_t v65 = v64;
          uint64_t v67 = v64[1];
          ++v64;
          uint64_t v66 = v67;
        }
        while (*(unsigned __int16 *)(v62 + 32 * v67 + 14) < v63);
        v68 = a2;
        if (v65 == v13)
        {
          v68 = a2;
          do
          {
            if (v64 >= v68) {
              break;
            }
            uint64_t v70 = *--v68;
          }
          while (*(unsigned __int16 *)(v62 + 32 * v70 + 14) >= v63);
        }
        else
        {
          do
            uint64_t v69 = *--v68;
          while (*(unsigned __int16 *)(v62 + 32 * v69 + 14) >= v63);
        }
        if (v64 < v68)
        {
          uint64_t v71 = *v68;
          uint64_t v72 = v64;
          int64_t v73 = v68;
          do
          {
            uint64_t *v72 = v71;
            uint64_t *v73 = v66;
            do
            {
              uint64_t v65 = v72;
              uint64_t v74 = v72[1];
              ++v72;
              uint64_t v66 = v74;
            }
            while (*(unsigned __int16 *)(v62 + 32 * v74 + 14) < v63);
            do
            {
              uint64_t v75 = *--v73;
              uint64_t v71 = v75;
            }
            while (*(unsigned __int16 *)(v62 + 32 * v75 + 14) >= v63);
          }
          while (v72 < v73);
        }
        if (v65 != v13) {
          *int v13 = *v65;
        }
        *uint64_t v65 = v60;
        if (v64 >= v68) {
          break;
        }
LABEL_73:
        BOOL result = (uint64_t *)std::__introsort<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::shieldsForLabelMarker(md::LabelManager *,std::vector<md::LabelShieldEntry,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>> &)::$_0 &,unsigned long *,false>(v11, v65, a3, a4, a5 & 1);
        a5 = 0;
        int v13 = v65 + 1;
      }
      BOOL v76 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::shieldsForLabelMarker(md::LabelManager *,std::vector<md::LabelShieldEntry,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>> &)::$_0 &,unsigned long *>(v13, v65, a3);
      int v13 = v65 + 1;
      BOOL result = (uint64_t *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::shieldsForLabelMarker(md::LabelManager *,std::vector<md::LabelShieldEntry,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>> &)::$_0 &,unsigned long *>(v65 + 1, a2, a3);
      if (result) {
        break;
      }
      if (!v76) {
        goto LABEL_73;
      }
    }
    a2 = v65;
    if (!v76) {
      continue;
    }
    return result;
  }
}

uint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::shieldsForLabelMarker(md::LabelManager *,std::vector<md::LabelShieldEntry,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>> &)::$_0 &,unsigned long *>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5 = *a2;
  uint64_t v6 = *result;
  unsigned int v7 = *(unsigned __int16 *)(a5 + 32 * *a2 + 14);
  unsigned int v8 = *(unsigned __int16 *)(a5 + 32 * *result + 14);
  uint64_t v9 = *a3;
  unsigned int v10 = *(unsigned __int16 *)(a5 + 32 * *a3 + 14);
  if (v7 >= v8)
  {
    if (v10 >= v7)
    {
      uint64_t v5 = *a3;
    }
    else
    {
      *a2 = v9;
      *a3 = v5;
      uint64_t v11 = *result;
      if (*(unsigned __int16 *)(a5 + 32 * *a2 + 14) < *(unsigned __int16 *)(a5 + 32 * *result + 14))
      {
        *BOOL result = *a2;
        *a2 = v11;
        uint64_t v5 = *a3;
      }
    }
  }
  else
  {
    if (v10 < v7)
    {
      *BOOL result = v9;
LABEL_9:
      *a3 = v6;
      uint64_t v5 = v6;
      goto LABEL_11;
    }
    *BOOL result = v5;
    *a2 = v6;
    uint64_t v5 = *a3;
    if (*(unsigned __int16 *)(a5 + 32 * *a3 + 14) < v8)
    {
      *a2 = v5;
      goto LABEL_9;
    }
  }
LABEL_11:
  if (*(unsigned __int16 *)(a5 + 32 * *a4 + 14) < *(unsigned __int16 *)(a5 + 32 * v5 + 14))
  {
    *a3 = *a4;
    *a4 = v5;
    uint64_t v12 = *a2;
    if (*(unsigned __int16 *)(a5 + 32 * *a3 + 14) < *(unsigned __int16 *)(a5 + 32 * *a2 + 14))
    {
      *a2 = *a3;
      *a3 = v12;
      uint64_t v13 = *result;
      if (*(unsigned __int16 *)(a5 + 32 * *a2 + 14) < *(unsigned __int16 *)(a5 + 32 * *result + 14))
      {
        *BOOL result = *a2;
        *a2 = v13;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::shieldsForLabelMarker(md::LabelManager *,std::vector<md::LabelShieldEntry,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>> &)::$_0 &,unsigned long *>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *a1;
      if (*(unsigned __int16 *)(*(void *)(*(void *)a3 + 536) + 32 * v8 + 14) < *(unsigned __int16 *)(*(void *)(*(void *)a3 + 536) + 32 * *a1 + 14))
      {
        *a1 = v8;
        *(a2 - 1) = v9;
      }
      return result;
    case 3:
      uint64_t v10 = *(void *)(*(void *)a3 + 536);
      uint64_t v11 = *a1;
      uint64_t v12 = a1[1];
      unsigned int v13 = *(unsigned __int16 *)(v10 + 32 * v12 + 14);
      unsigned int v14 = *(unsigned __int16 *)(v10 + 32 * *a1 + 14);
      uint64_t v15 = *(a2 - 1);
      unsigned int v16 = *(unsigned __int16 *)(v10 + 32 * v15 + 14);
      if (v13 >= v14)
      {
        if (v16 < v13)
        {
          a1[1] = v15;
          *(a2 - 1) = v12;
          uint64_t v39 = *a1;
          uint64_t v38 = a1[1];
          if (*(unsigned __int16 *)(v10 + 32 * v38 + 14) < *(unsigned __int16 *)(v10 + 32 * *a1 + 14))
          {
            *a1 = v38;
            a1[1] = v39;
          }
        }
      }
      else if (v16 >= v13)
      {
        *a1 = v12;
        a1[1] = v11;
        uint64_t v49 = *(a2 - 1);
        if (*(unsigned __int16 *)(v10 + 32 * v49 + 14) < v14)
        {
          a1[1] = v49;
          *(a2 - 1) = v11;
        }
      }
      else
      {
        *a1 = v15;
        *(a2 - 1) = v11;
      }
      return result;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::shieldsForLabelMarker(md::LabelManager *,std::vector<md::LabelShieldEntry,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>> &)::$_0 &,unsigned long *>(a1, a1 + 1, a1 + 2, a2 - 1, *(void *)(*(void *)a3 + 536));
      return 1;
    case 5:
      unsigned int v27 = a1 + 1;
      unsigned int v28 = a1 + 2;
      uint64_t v29 = a1 + 3;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::shieldsForLabelMarker(md::LabelManager *,std::vector<md::LabelShieldEntry,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>> &)::$_0 &,unsigned long *>(a1, a1 + 1, a1 + 2, a1 + 3, *(void *)(*(void *)a3 + 536));
      uint64_t v30 = *(a2 - 1);
      uint64_t v31 = a1[3];
      uint64_t v32 = *(void *)(*(void *)a3 + 536);
      if (*(unsigned __int16 *)(v32 + 32 * v30 + 14) < *(unsigned __int16 *)(v32 + 32 * v31 + 14))
      {
        *uint64_t v29 = v30;
        *(a2 - 1) = v31;
        uint64_t v33 = *v29;
        uint64_t v34 = *v28;
        unsigned int v35 = *(unsigned __int16 *)(v32 + 32 * *v29 + 14);
        if (v35 < *(unsigned __int16 *)(v32 + 32 * *v28 + 14))
        {
          *unsigned int v28 = v33;
          *uint64_t v29 = v34;
          uint64_t v36 = *v27;
          if (v35 < *(unsigned __int16 *)(v32 + 32 * *v27 + 14))
          {
            a1[1] = v33;
            a1[2] = v36;
            uint64_t v37 = *a1;
            if (v35 < *(unsigned __int16 *)(v32 + 32 * *a1 + 14))
            {
              *a1 = v33;
              a1[1] = v37;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v18 = a1 + 2;
      uint64_t v17 = a1[2];
      uint64_t v19 = a1[1];
      uint64_t v20 = *(void *)(*(void *)a3 + 536);
      uint64_t v21 = *a1;
      unsigned int v22 = *(unsigned __int16 *)(v20 + 32 * v19 + 14);
      unsigned int v23 = *(unsigned __int16 *)(v20 + 32 * *a1 + 14);
      unsigned int v24 = *(unsigned __int16 *)(v20 + 32 * v17 + 14);
      if (v22 >= v23)
      {
        if (v24 >= v22) {
          goto LABEL_23;
        }
        a1[1] = v17;
        *uint64_t v18 = v19;
        uint64_t v25 = a1;
        uint64_t v26 = a1 + 1;
      }
      else
      {
        uint64_t v25 = a1;
        uint64_t v26 = a1 + 2;
        if (v24 < v22) {
          goto LABEL_22;
        }
        *a1 = v19;
        a1[1] = v21;
        uint64_t v25 = a1 + 1;
        uint64_t v26 = a1 + 2;
      }
      if (v24 >= v23) {
        goto LABEL_23;
      }
LABEL_22:
      *uint64_t v25 = v17;
      *uint64_t v26 = v21;
LABEL_23:
      uint64_t v40 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v41 = 0;
      uint64_t v42 = 24;
      break;
  }
  while (1)
  {
    uint64_t v44 = *v40;
    uint64_t v45 = *v18;
    unsigned int v46 = *(unsigned __int16 *)(v20 + 32 * *v40 + 14);
    if (v46 < *(unsigned __int16 *)(v20 + 32 * v45 + 14))
    {
      uint64_t v47 = v42;
      do
      {
        *(uint64_t *)((char *)a1 + v47) = v45;
        uint64_t v48 = v47 - 8;
        if (v47 == 8)
        {
          uint64_t v43 = a1;
          goto LABEL_26;
        }
        uint64_t v45 = *(uint64_t *)((char *)a1 + v47 - 16);
        v47 -= 8;
      }
      while (v46 < *(unsigned __int16 *)(v20 + 32 * v45 + 14));
      uint64_t v43 = (uint64_t *)((char *)a1 + v48);
LABEL_26:
      *uint64_t v43 = v44;
      if (++v41 == 8) {
        return v40 + 1 == a2;
      }
    }
    uint64_t v18 = v40;
    v42 += 8;
    if (++v40 == a2) {
      return 1;
    }
  }
}

void non-virtual thunk to'ggl::GradientPolylineOverlayRibbon::BaseMesh::~BaseMesh(ggl::GradientPolylineOverlayRibbon::BaseMesh *this)
{
  ggl::Mesh::~Mesh((ggl::GradientPolylineOverlayRibbon::BaseMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::GradientPolylineOverlayRibbon::BaseMesh *)((char *)this - 16));
}

void ggl::GradientPolylineOverlayRibbon::BaseMesh::~BaseMesh(ggl::GradientPolylineOverlayRibbon::BaseMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::GradientPolylineOverlayRibbon::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::GradientPolylineOverlayRibbon::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::GradientPolylineOverlayRibbon::FillPipelineState::~FillPipelineState(ggl::GradientPolylineOverlayRibbon::FillPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::GradientPolylineOverlayRibbon::FillPipelineSetup::textureIsEnabled(ggl::GradientPolylineOverlayRibbon::FillPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::GradientPolylineOverlayRibbon::FillPipelineSetup::constantDataIsEnabled(ggl::GradientPolylineOverlayRibbon::FillPipelineSetup *this, unint64_t a2)
{
  return a2 < 4;
}

void ggl::GradientPolylineOverlayRibbon::FillPipelineSetup::~FillPipelineSetup(ggl::GradientPolylineOverlayRibbon::FillPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::GradientPolylineOverlayRibbon::AlphaPipelineState::~AlphaPipelineState(ggl::GradientPolylineOverlayRibbon::AlphaPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup::textureIsEnabled(ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup::constantDataIsEnabled(ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup *this, unint64_t a2)
{
  return a2 < 4;
}

void ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup::~AlphaPipelineSetup(ggl::GradientPolylineOverlayRibbon::AlphaPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineState::~AlphaFillPipelineState(ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup::textureIsEnabled(ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup::constantDataIsEnabled(ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup *this, unint64_t a2)
{
  return a2 < 4;
}

void ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup::~AlphaFillPipelineSetup(ggl::GradientPolylineOverlayRibbon::AlphaFillPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void md::VectorFeatureMarker::debugString(uint64_t a1@<X8>)
{
  uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  *(void *)(a1 + 24) = *((void *)v2 + 91);
  *(unsigned char *)(a1 + 23) = 19;
  strcpy((char *)a1, "VectorFeatureMarker");
}

float md::VectorFeatureMarker::maxZoomRank(md::VectorFeatureMarker *this)
{
  return -1.0;
}

double md::VectorFeatureMarker::minZoomRank(md::VectorFeatureMarker *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (!v1) {
    return 0.0;
  }
  LODWORD(result) = *(_DWORD *)(v1 + 68);
  return result;
}

uint64_t md::VectorFeatureMarker::styleAttributes@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 32);
  if (v2)
  {
    uint64_t v4 = *(void *)(v2 + 24);
    uint64_t v3 = *(void *)(v2 + 32);
    *a2 = v4;
    a2[1] = v3;
    if (v3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  return this;
}

uint64_t md::VectorFeatureMarker::venueId(md::VectorFeatureMarker *this)
{
  return -1;
}

uint64_t md::VectorFeatureMarker::featureId(md::VectorFeatureMarker *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    return *(void *)(v1 + 40);
  }
  else {
    return 0;
  }
}

unint64_t md::VectorFeatureMarker::name@<X0>(unint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(this + 32);
  if (v3)
  {
    uint64_t v4 = *(const char **)(v3 + 16);
    uint64_t v5 = "unnamed";
    if (v4 && *v4) {
      uint64_t v5 = v4;
    }
    {
      operator new();
    }
    uint64_t v6 = mdm::Allocator::instance(void)::alloc;
    *(void *)(a2 + 24) = mdm::Allocator::instance(void)::alloc;
    this = strlen(v5);
    if (this >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    size_t v7 = this;
    if (this >= 0x17)
    {
      uint64_t v9 = (this & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((this | 7) != 0x17) {
        uint64_t v9 = this | 7;
      }
      uint64_t v10 = v9 + 1;
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 16))(v6, v9 + 1, 1);
      *(void *)(a2 + 8) = v7;
      *(void *)(a2 + 16) = v10 | 0x8000000000000000;
      *(void *)a2 = v11;
      a2 = v11;
    }
    else
    {
      *(unsigned char *)(a2 + 23) = this;
      if (!this) {
        goto LABEL_16;
      }
    }
    this = (unint64_t)memmove((void *)a2, v5, v7);
LABEL_16:
    uint64_t v8 = (unsigned char *)(a2 + v7);
    goto LABEL_17;
  }
  {
    if (this) {
      operator new();
    }
  }
  *(void *)(a2 + 24) = mdm::Allocator::instance(void)::alloc;
  *(unsigned char *)(a2 + 23) = 7;
  *(_DWORD *)a2 = 1634627189;
  *(_DWORD *)(a2 + 3) = 1684368737;
  uint64_t v8 = (unsigned char *)(a2 + 7);
LABEL_17:
  *uint64_t v8 = 0;
  return this;
}

void md::VectorFeatureMarker::~VectorFeatureMarker(md::VectorFeatureMarker *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v1;

  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1A2536D9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);

  md::RoadSignTextMetrics::~RoadSignTextMetrics((md::RoadSignTextMetrics *)&a11);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v13 - 176);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v13 - 152);
  _Unwind_Resume(a1);
}

void std::shared_ptr<md::NavLabel>::shared_ptr[abi:nn180100]<md::NavRoadSign,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1A2536ED0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A25372C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  _Unwind_Resume(a1);
}

void sub_1A25375D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A253785C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A253788C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2537C84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2537D10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2537F88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2538278(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A25384F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A25388A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1A25389D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2538A8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2538C84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2538DBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A25390A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A253914C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A25391E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2539254(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VKLabelNavJunction;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A25394A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2539750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

void *md::realistic::SkyRenderLayer::layout(md::realistic::SkyRenderLayer *this, const md::LayoutContext *a2)
{
  uint64_t v304 = *MEMORY[0x1E4F143B8];
  v292[0] = &unk_1EF579FE0;
  v292[1] = a2;
  v290[0] = &unk_1EF57A028;
  v290[1] = a2;
  v291 = v290;
  v295 = v294;
  v293 = v292;
  v294[0] = &unk_1EF57A028;
  v294[1] = a2;
  std::__function::__func<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()((uint64_t)v292);
  if (v291 == v290)
  {
    (*(void (**)(void *))(v290[0] + 32))(v290);
  }
  else if (v291)
  {
    (*(void (**)(void))(*v291 + 40))();
  }
  if (v293 == v292)
  {
    (*(void (**)(void *))(v292[0] + 32))(v292);
  }
  else if (v293)
  {
    (*(void (**)(void))(*v293 + 40))();
  }
  uint64_t v4 = (void *)*((void *)a2 + 1);
  unint64_t v5 = v4[1];
  if ((v5 & (v5 - 1)) != 0)
  {
    unint64_t v7 = 0x1AF456233693CD46;
    if (v5 <= 0x1AF456233693CD46) {
      unint64_t v7 = 0x1AF456233693CD46 % v5;
    }
    uint64_t v6 = *(void **)(*v4 + 8 * v7);
    do
    {
      do
        uint64_t v6 = (void *)*v6;
      while (v6[1] != 0x1AF456233693CD46);
    }
    while (v6[2] != 0x1AF456233693CD46);
  }
  else
  {
    uint64_t v6 = *(void **)(*v4 + 8 * ((v5 - 1) & 0x1AF456233693CD46));
    do
    {
      do
        uint64_t v6 = (void *)*v6;
      while (v6[1] != 0x1AF456233693CD46);
    }
    while (v6[2] != 0x1AF456233693CD46);
  }
  uint64_t v8 = *(void *)(v6[5] + 32);
  uint64_t v9 = *((void *)this + 5);
  uint64_t v10 = *(void **)(*(void *)(v9 + 24) + 8);
  uint64_t v11 = v10[3];
  uint64_t v12 = v10[4];
  uint64_t v13 = v12 - v11;
  if (v12 == v11) {
    goto LABEL_26;
  }
  uint64_t v14 = 0;
  unint64_t v15 = v13 >> 3;
  while (1)
  {
    unsigned int v16 = *(unsigned __int8 **)(v11 + 8 * v14);
    if (*v16 == *((unsigned __int8 *)this + 272))
    {
      unint64_t v17 = *((void *)v16 + 1);
      uint64_t v18 = v10[15];
      if (v17 < (v10[16] - v18) >> 3) {
        break;
      }
    }
    if (++v14 >= v15) {
      goto LABEL_26;
    }
  }
  uint64_t v19 = *(void *)(v18 + 8 * v17);
  if (!v19) {
LABEL_26:
  }
    uint64_t v20 = 0;
  else {
    uint64_t v20 = *(ggl::CommandBuffer **)(*(void *)(v19 + 24) + 8 * *((unsigned __int8 *)this + 273));
  }
  double v21 = *(double *)(v8 + 32);
  if (*((float *)this + 17) != 1.0)
  {
    uint64_t v22 = *(void *)(v9 + 136);
    double v23 = *(double *)(v22 + 104);
    uint64_t v24 = *(unsigned int *)(v22 + 88);
    uint64_t v25 = *(void *)(*(void *)v22 + 464);
    BOOL v26 = v25
       && (*(unsigned int (**)(uint64_t))(*(void *)v25 + 40))(v25)
       && (unint64_t)(v24 - *((void *)this + 7)) < 0x259;
    double v27 = *((double *)this + 9);
    if (v27 == 0.0 && !v26 && (unint64_t)(v24 - *((void *)this + 7)) >= 0xB)
    {
      *((double *)this + 9) = v23;
      double v27 = v23;
    }
    if (v27 <= 0.0)
    {
      float v29 = *((float *)this + 17);
    }
    else
    {
      float v28 = v23 - v27;
      float v29 = fminf(fmaxf(v28, 0.0), 1.0);
      *((float *)this + 17) = v29;
    }
    if (v29 == 1.0)
    {
      *((unsigned char *)this + 66) = 0;
    }
    else
    {
      *((unsigned char *)this + 66) = 1;
      uint64_t v30 = **(void **)(*(void *)(*(void *)(*((void *)this + 5) + 128) + 856) + 88);
      if (v30)
      {
        LOBYTE(v296) = 7;
        md::MapEngine::setNeedsTick(v30, &v296);
      }
    }
  }
  uint64_t v31 = (void *)*((void *)a2 + 1);
  unint64_t v32 = v31[1];
  if ((v32 & (v32 - 1)) != 0)
  {
    unint64_t v34 = 0xE42D19AFCA302E68;
    if (v32 <= 0xE42D19AFCA302E68) {
      unint64_t v34 = 0xE42D19AFCA302E68 % v32;
    }
    uint64_t v33 = *(void **)(*v31 + 8 * v34);
    do
    {
      do
        uint64_t v33 = (void *)*v33;
      while (v33[1] != 0xE42D19AFCA302E68);
    }
    while (v33[2] != 0xE42D19AFCA302E68);
  }
  else
  {
    uint64_t v33 = *(void **)(*v31 + 8 * ((v32 - 1) & 0xE42D19AFCA302E68));
    do
    {
      do
        uint64_t v33 = (void *)*v33;
      while (v33[1] != 0xE42D19AFCA302E68);
    }
    while (v33[2] != 0xE42D19AFCA302E68);
  }
  if (*(unsigned char *)(*(void *)(v33[5] + 32) + 72) == 1)
  {
    if (*((void *)this + 25)) {
      *((unsigned char *)this + 64) = 1;
    }
    else {
      md::realistic::SkyRenderLayer::load(this);
    }
    if (v21 >= 6378137.0)
    {
      *((unsigned char *)this + 65) = *((float *)this + 17) > 0.0;
      uint64_t v39 = *((void *)this + 29);
      *(_OWORD *)(v39 + 4) = xmmword_1A28FCDD0;
      md::realistic::SkyRenderLayer::updateCorona(this, v39 + 4);
    }
    else
    {
      uint64_t v38 = *((void *)this + 29);
      *(_OWORD *)(v38 + 4) = xmmword_1A28FF660;
      md::realistic::SkyRenderLayer::updateCorona(this, v38 + 4);
      *(_WORD *)((char *)this + 65) = 0;
    }
    *((unsigned char *)this + 80) = 0;
    if (*((void *)this + 25))
    {
      *((unsigned char *)this + 64) = 1;
      if (*((unsigned char *)this + 65)) {
        goto LABEL_123;
      }
    }
    else
    {
      md::realistic::SkyRenderLayer::load(this);
      if (*((unsigned char *)this + 65)) {
        goto LABEL_123;
      }
    }
LABEL_170:
    if (!*((unsigned char *)this + 64)) {
      goto LABEL_184;
    }
    goto LABEL_171;
  }
  *(_WORD *)((char *)this + 65) = 1;
  if (*(double *)(*(void *)(*(void *)(*((void *)this + 5) + 128) + 72) + 32) >= 3189068.5)
  {
    if (*((unsigned char *)this + 80))
    {
      uint64_t v37 = *((void *)this + 29);
      *(_OWORD *)(v37 + 4) = xmmword_1A28FCDD0;
      md::realistic::SkyRenderLayer::updateCorona(this, v37 + 4);
      *((unsigned char *)this + 80) = 0;
    }
    if (!*((void *)this + 25))
    {
      md::realistic::SkyRenderLayer::load(this);
      goto LABEL_76;
    }
    char v36 = 1;
  }
  else
  {
    if (!*((unsigned char *)this + 80))
    {
      uint64_t v35 = *((void *)this + 29);
      *(_OWORD *)(v35 + 4) = xmmword_1A28FF650;
      md::realistic::SkyRenderLayer::updateCorona(this, v35 + 4);
      *((unsigned char *)this + 80) = 1;
    }
    if (!*((void *)this + 25)) {
      goto LABEL_76;
    }
    char v36 = 0;
  }
  *((unsigned char *)this + 64) = v36;
LABEL_76:
  uint64_t v40 = (unsigned char *)*((void *)a2 + 9);
  if (v40) {
    BOOL v41 = *v40 == 0;
  }
  else {
    BOOL v41 = 1;
  }
  if (*((float *)this + 17) <= 0.0)
  {
    BOOL v46 = 0;
    goto LABEL_122;
  }
  uint64_t v42 = (void *)*((void *)a2 + 1);
  int8x8_t v43 = (int8x8_t)v42[1];
  if (!*(void *)&v43) {
    goto LABEL_104;
  }
  uint8x8_t v44 = (uint8x8_t)vcnt_s8(v43);
  v44.i16[0] = vaddlv_u8(v44);
  if (v44.u32[0] > 1uLL)
  {
    uint64_t v45 = 0x1AF456233693CD46;
    if (*(void *)&v43 <= 0x1AF456233693CD46uLL) {
      uint64_t v45 = 0x1AF456233693CD46uLL % *(void *)&v43;
    }
  }
  else
  {
    uint64_t v45 = (*(void *)&v43 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v47 = *(void **)(*v42 + 8 * v45);
  if (!v47) {
    goto LABEL_104;
  }
  uint64_t v48 = (void *)*v47;
  if (!v48) {
    goto LABEL_104;
  }
  if (v44.u32[0] < 2uLL)
  {
    uint64_t v49 = *(void *)&v43 - 1;
    while (1)
    {
      uint64_t v51 = v48[1];
      if (v51 == 0x1AF456233693CD46)
      {
        if (v48[2] == 0x1AF456233693CD46) {
          goto LABEL_102;
        }
      }
      else if ((v51 & v49) != v45)
      {
        goto LABEL_104;
      }
      uint64_t v48 = (void *)*v48;
      if (!v48) {
        goto LABEL_104;
      }
    }
  }
  while (1)
  {
    unint64_t v50 = v48[1];
    if (v50 == 0x1AF456233693CD46) {
      break;
    }
    if (v50 >= *(void *)&v43) {
      v50 %= *(void *)&v43;
    }
    if (v50 != v45) {
      goto LABEL_104;
    }
LABEL_91:
    uint64_t v48 = (void *)*v48;
    if (!v48) {
      goto LABEL_104;
    }
  }
  if (v48[2] != 0x1AF456233693CD46) {
    goto LABEL_91;
  }
LABEL_102:
  uint64_t v52 = v48[5];
  if (*(void *)(v52 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v53 = *(double **)(v52 + 32);
    goto LABEL_105;
  }
LABEL_104:
  uint64_t v53 = 0;
LABEL_105:
  double v55 = v53[46];
  double v54 = v53[47];
  if (v54 >= v55)
  {
    double v57 = v53[57];
    double v60 = v57;
    if (v55 >= v54) {
      goto LABEL_116;
    }
    goto LABEL_112;
  }
  if (v54 * v55 <= 0.0) {
    double v56 = 1.0;
  }
  else {
    double v56 = v54 / v55;
  }
  double v57 = v53[57];
  long double v58 = tan(v57 * 0.5);
  long double v59 = atan(v56 * v58);
  double v60 = v59 + v59;
  if (v55 < v54)
  {
LABEL_112:
    if (v54 * v55 <= 0.0) {
      double v61 = 1.0;
    }
    else {
      double v61 = v55 / v54;
    }
    long double v62 = tan(v57 * 0.5);
    long double v63 = atan(v61 * v62);
    double v57 = v63 + v63;
  }
LABEL_116:
  double v64 = v53[4];
  double v65 = v53[5];
  if (v64 >= 3000.0 || v65 >= 1.13446401)
  {
    BOOL v66 = sqrt(v57 * v57 + v60 * v60) * 0.5 >= acos(6378137.0 / (v64 + 6378137.0)) * -0.6 + 0.942477796;
    if (v65 >= 0.785398163) {
      BOOL v66 = 1;
    }
  }
  else
  {
    BOOL v66 = 0;
  }
  BOOL v46 = v66 && v41;
LABEL_122:
  *((unsigned char *)this + 65) = v46;
  if (!*((unsigned char *)this + 65)) {
    goto LABEL_170;
  }
LABEL_123:
  uint64_t v67 = *((void *)this + 28);
  if (!v67)
  {
    md::realistic::SkyRenderLayer::updateCorona(this, *((void *)this + 29) + 4);
    uint64_t v67 = *((void *)this + 28);
  }
  uint64_t v68 = *(void *)(*((void *)a2 + 92) + 8);
  uint64_t v69 = *((void *)this + 27);
  uint64_t v70 = *(void *)(v69 + 80);
  *(void *)&long long v296 = v67;
  *((void *)&v296 + 1) = v69;
  LOBYTE(v297) = 0;
  BYTE4(v297) = 0;
  *(void *)&v298[4] = 0;
  *(void *)v299 = v70;
  v301 = 0;
  ggl::CommandBuffer::pushLoadItem(v20, (const ggl::Texture2DLoadItem *)&v296);
  uint64_t v71 = *((void *)this + 26);
  if (!v71)
  {
    uint64_t v72 = *((void *)a2 + 92);
    *(void *)&v302[0] = &unk_1EF579F98;
    *(void *)&v302[1] = this;
    v303 = v302;
    double v288 = 0.0;
    v289 = 0;
    (*(void (**)(void, double *, double *))(**(void **)(v72 + 32) + 16))(*(void *)(v72 + 32), v302, &v288);
    int64_t v73 = v289;
    if (v289 && !atomic_fetch_add(&v289->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
      std::__shared_weak_count::__release_weak(v73);
    }
    if (v303 == v302)
    {
      (*(void (**)(double *))(*(void *)&v302[0] + 32))(v302);
    }
    else if (v303)
    {
      (*(void (**)(double *))(*(void *)v303 + 40))(v303);
    }
    uint64_t v71 = *((void *)this + 26);
  }
  uint64_t v74 = *(ggl::PipelineSetup **)(v71 + 8);
  double v75 = *(double *)(v68 + 944);
  double v76 = *(double *)(v68 + 952);
  uint64_t v77 = *((void *)a2 + 4);
  uint64_t v78 = (std::__shared_weak_count *)*((void *)a2 + 5);
  if (!v78)
  {
    double v79 = *(double *)(v77 + 64);
    goto LABEL_139;
  }
  atomic_fetch_add_explicit(&v78->__shared_owners_, 1uLL, memory_order_relaxed);
  double v79 = *(double *)(v77 + 64);
  if (atomic_fetch_add(&v78->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    uint64_t v77 = *((void *)a2 + 4);
    uint64_t v80 = (std::__shared_weak_count *)*((void *)a2 + 5);
    if (!v80)
    {
LABEL_139:
      int v81 = *(unsigned __int8 *)(v77 + 72);
      goto LABEL_143;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
    std::__shared_weak_count::__release_weak(v78);
    uint64_t v77 = *((void *)a2 + 4);
    uint64_t v80 = (std::__shared_weak_count *)*((void *)a2 + 5);
    if (!v80) {
      goto LABEL_139;
    }
  }
  atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
  int v81 = *(unsigned __int8 *)(v77 + 72);
  if (!atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
    std::__shared_weak_count::__release_weak(v80);
  }
LABEL_143:
  karo::graphics::View::setNear((karo::graphics::View *)v68, v76 * 0.000000157313035, v79, v81 != 0);
  karo::graphics::View::setFar((karo::graphics::View *)v68, v75 * 0.000000157313035, v79, v81 != 0);
  float64x2_t v284 = *(float64x2_t *)(v68 + 424);
  float64x2_t v285 = *(float64x2_t *)(v68 + 392);
  float64x2_t v280 = *(float64x2_t *)(v68 + 408);
  float64x2_t v281 = *(float64x2_t *)(v68 + 376);
  float64x2_t v282 = *(float64x2_t *)(v68 + 488);
  float64x2_t v283 = *(float64x2_t *)(v68 + 456);
  float64x2_t v278 = *(float64x2_t *)(v68 + 472);
  float64x2_t v279 = *(float64x2_t *)(v68 + 440);
  karo::graphics::View::setFar((karo::graphics::View *)v68, v75, v79, v81 != 0);
  karo::graphics::View::setNear((karo::graphics::View *)v68, v76, v79, v81 != 0);
  uint64_t v82 = v68 + 40;
  uint64_t v83 = (double *)(*(uint64_t (**)(uint64_t))(*(void *)(v68 + 40) + 24))(v68 + 40);
  double v85 = v83[3];
  double v84 = v83[4];
  double v87 = v83[5];
  double v86 = v83[6];
  uint64_t v88 = (double *)(*(uint64_t (**)(uint64_t))(*(void *)(v68 + 40) + 24))(v68 + 40);
  double v89 = -((v85 + v85) * v87 - v86 * (v84 * -2.0));
  double v90 = v84 * -2.0 * v87 + (v85 + v85) * v86;
  v101.n128_f64[0] = -(v84 * -2.0 * v84 + 1.0 - (v85 + v85) * v85);
  double v91 = 1.0 / sqrt(v89 * v89 + v90 * v90 + v101.n128_f64[0] * v101.n128_f64[0]);
  v92.n128_f64[0] = v91 * v89;
  double v93 = v91 * v90;
  double v94 = v91 * v101.n128_f64[0];
  double v95 = v88[1];
  double v96 = v88[2];
  double v97 = 1.0 / sqrt(*v88 * *v88 + v95 * v95 + v96 * v96);
  double v98 = -(*v88 * v97);
  double v99 = -(v95 * v97);
  double v100 = -(v96 * v97);
  v101.n128_f64[0] = v98 * v92.n128_f64[0] + v99 * v93 + v100 * v94;
  double v277 = v21;
  if (v101.n128_f64[0] >= 0.9999999)
  {
    double v105 = *(double *)(v68 + 72);
    double v106 = *(double *)(v68 + 80);
    float v276 = 0.0;
    float v129 = 1.0;
    float v275 = 0.0;
    float v271 = 0.0;
    float v272 = 1.0;
    float v273 = 1.0;
    double v107 = *(double *)(v68 + 88);
    double v108 = *(double *)(v68 + 96);
    float v274 = 0.0;
    float v269 = 0.0;
    float v270 = 0.0;
  }
  else
  {
    double v102 = -(v99 * v94 - v100 * v93);
    double v103 = -(v100 * v92.n128_f64[0] - v98 * v94);
    double v104 = -(v98 * v93 - v99 * v92.n128_f64[0]);
    double v105 = *(double *)(v68 + 72);
    double v106 = *(double *)(v68 + 80);
    double v107 = *(double *)(v68 + 88);
    double v108 = *(double *)(v68 + 96);
    double v109 = -(v106 * (v106 * -2.0));
    double v110 = v107 * -2.0 * v108;
    double v111 = v108 * (v106 * -2.0);
    double v112 = v105 * -2.0 * v105 + 1.0;
    double v113 = v108 * (v105 * -2.0);
    double v114 = v112 - v109;
    double v115 = v102
         - (v109 - v107 * (v107 * -2.0)) * v102
         + (-(v106 * (v105 * -2.0)) - v110) * v103
         + (v111 - v107 * (v105 * -2.0)) * v104;
    double v116 = (v110 - v106 * (v105 * -2.0)) * v102
         + (v112 - -(v107 * (v107 * -2.0))) * v103
         + (-(v107 * (v106 * -2.0)) - v113) * v104;
    double v117 = v114 * v104 + (-(v107 * (v105 * -2.0)) - v111) * v102 + (v113 - v107 * (v106 * -2.0)) * v103;
    double v118 = 1.0 / sqrt(v115 * v115 + v116 * v116 + v117 * v117);
    float v119 = v118 * v115;
    float v120 = v118 * v116;
    float v121 = v118 * v117;
    float v122 = acos(v101.n128_f64[0]);
    __float2 v123 = __sincosf_stret(v122 * 0.5);
    float v124 = v123.__sinval * v119;
    float v125 = v123.__sinval * v120;
    v101.n128_f32[0] = v123.__sinval * v121;
    float v126 = v125 + v125;
    float v127 = (float)(v125 + v125) * v125;
    float v128 = (float)(v101.n128_f32[0] + v101.n128_f32[0]) * v101.n128_f32[0];
    float v129 = 1.0 - (float)(v128 + v127);
    float v130 = v124 + v124;
    float v131 = (float)(v124 + v124) * (float)(v123.__sinval * v120);
    float v132 = (float)(v101.n128_f32[0] + v101.n128_f32[0]) * v123.__cosval;
    float v133 = (float)(v124 + v124) * (float)(v123.__sinval * v121);
    float v274 = v131 - v132;
    float v275 = (float)(v126 * v123.__cosval) + v133;
    float v270 = v132 + v131;
    float v134 = 1.0 - (float)((float)(v124 + v124) * v124);
    v101.n128_f32[0] = v126 * (float)(v123.__sinval * v121);
    float v276 = v101.n128_f32[0] - (float)(v130 * v123.__cosval);
    float v269 = v133 - (float)(v126 * v123.__cosval);
    float v271 = (float)(v130 * v123.__cosval) + v101.n128_f32[0];
    float v272 = v134 - v128;
    float v273 = v134 - v127;
  }
  double v136 = *(double *)(v68 + 56);
  double v135 = *(double *)(v68 + 64);
  double v137 = *(double *)(v68 + 48);
  uint64_t v138 = *(void *)(*((void *)this + 5) + 136);
  if (*(unsigned char *)(v138 + 48))
  {
    uint64_t v139 = (double *)(*(uint64_t (**)(uint64_t))(*(void *)v82 + 24))(v68 + 40);
    v101.n128_f32[0] = fmin(fmax(fabs(sqrt(*v139 * *v139 + v139[1] * v139[1] + v139[2] * v139[2]) + -6378137.0)* 0.000000666666667+ -4.66666667, 0.0), 1.0);
    unsigned __int32 v268 = v101.n128_u32[0];
    uint64_t v138 = *(void *)(*((void *)this + 5) + 136);
  }
  else
  {
    unsigned __int32 v268 = 0;
  }
  uint64_t v140 = *(unsigned int *)(v138 + 88);
  if (*((void *)this + 19) != v140)
  {
    *((void *)this + 19) = v140;
    v302[0] = 0.0;
    double v287 = 0.0;
    double v288 = 0.0;
    id v141 = objc_alloc_init(MEMORY[0x1E4F643C8]);
    [v141 calculateGeocentricDirectionForSunX:v302 Y:&v288 Z:&v287];
    float v142 = v302[0];
    float v143 = v288;
    float v144 = v287;
    *((float *)this + 40) = v142;
    *((float *)this + 41) = v143;
    *((float *)this + 42) = v144;
  }
  float v267 = v129;
  __int32 v145 = 0;
  v101.n128_u64[0] = 0x415854A640000000;
  v92.n128_f64[0] = v277;
  if (v277 >= 6378137.0) {
    __int32 v145 = *(_DWORD *)(**(void **)(*(void *)(*(void *)(*((void *)this + 5) + 128) + 856) + 40) + 68);
  }
  uint64_t v146 = (double *)(*(uint64_t (**)(uint64_t, __n128, __n128))(*(void *)v82 + 24))(v68 + 40, v101, v92);
  double v147 = -(v135 * v106 - v136 * v107) - (v135 * v106 - v136 * v107);
  double v148 = -(v137 * v107 - v135 * v105) - (v137 * v107 - v135 * v105);
  double v149 = -(v136 * v105 - v137 * v106) - (v136 * v105 - v137 * v106);
  double v150 = v135 + v147 * v106 + v149 * v108;
  double v151 = v136 - v147 * v107 + v148 * v108 + v149 * v105;
  *(float *)&double v149 = -(v137 + v147 * v108 + v148 * v107 - v149 * v106);
  *(float *)&double v151 = v151;
  float v152 = -(v150 - v148 * v105);
  float32x4_t v153 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v281), v285);
  float32x4_t v154 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v280), v284);
  float32x4_t v155 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v279), v283);
  float32x4_t v156 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v278), v282);
  float v157 = *(float *)&v149 * 0.00000015731;
  float v158 = *(float *)&v151 * -0.00000015731;
  float v159 = v152 * 0.00000015731;
  double v160 = fmax(sqrt(*v146 * *v146 + v146[1] * v146[1] + v146[2] * v146[2]) + -6356752.31, 100.0);
  float v161 = sqrt((v160 + 12713504.6) * v160) * 0.000000157313035;
  double v162 = *(double *)(v68 + 80);
  double v163 = *(double *)(v68 + 88);
  double v164 = *(double *)(v68 + 96);
  double v166 = *(double *)(v68 + 64);
  double v165 = *(double *)(v68 + 72);
  double v168 = *(double *)(v68 + 48);
  double v167 = *(double *)(v68 + 56);
  double v169 = -(v166 * v162 - v167 * v163) - (v166 * v162 - v167 * v163);
  double v170 = -(v168 * v163 - v166 * v165) - (v168 * v163 - v166 * v165);
  double v171 = -(v167 * v165 - v168 * v162) - (v167 * v165 - v168 * v162);
  double v172 = -(v171 * v165 - (-(v167 - v169 * v163) - v170 * v164));
  double v173 = -(v168 + v169 * v164 + v170 * v163 - v171 * v162);
  double v174 = -(v166 + v169 * v162 + v171 * v164 - v170 * v165);
  double v175 = v162 * -2.0;
  double v176 = -(v162 * (v162 * -2.0));
  double v177 = 1.0 - (v176 - v163 * (v163 * -2.0));
  double v178 = v165 * -2.0;
  double v179 = -(v162 * (v165 * -2.0));
  double v180 = v163 * -2.0 * v164;
  double v181 = v179 - v180;
  double v182 = -(v163 * (v165 * -2.0));
  double v183 = v164 * v175;
  double v184 = v164 * v175 - v163 * (v165 * -2.0);
  double v185 = v180 + v179;
  double v186 = v165 * -2.0 * v165 + 1.0;
  double v187 = v186 - -(v163 * (v163 * -2.0));
  double v188 = -(v163 * v175);
  double v189 = v164 * v178;
  float v190 = v177;
  float v192 = v182 - v183;
  float v194 = v187;
  float v198 = v186 - v176;
  uint64_t v202 = *((void *)v74 + 8);
  v203 = *(void **)v202;
  unint64_t v204 = *(void *)(*(void *)v202 + 8);
  if (v204) {
    v205 = (float32x4_t *)v203[9];
  }
  else {
    v205 = 0;
  }
  v205->f32[0] = v190;
  float32_t v191 = v185;
  v205->f32[1] = v191;
  v205->f32[2] = v192;
  v205->i32[3] = 0;
  float32_t v193 = v181;
  v205[1].f32[0] = v193;
  v205[1].f32[1] = v194;
  float32_t v195 = v189 + v188;
  v205[1].f32[2] = v195;
  v205[1].i32[3] = 0;
  float32_t v196 = v184;
  v205[2].f32[0] = v196;
  float32_t v197 = v188 - v189;
  v205[2].f32[1] = v197;
  v205[2].f32[2] = v198;
  v205[2].i32[3] = 0;
  float32_t v199 = v173;
  v205[3].f32[0] = v199;
  float32_t v200 = v172;
  v205[3].f32[1] = v200;
  float32_t v201 = v174;
  v205[3].f32[2] = v201;
  v205[3].i32[3] = 1065353216;
  v205[14].f32[0] = v161;
  v205[9].i32[0] = *((_DWORD *)this + 40);
  v205[9].i32[1] = *((_DWORD *)this + 41);
  v205[9].i32[2] = *((_DWORD *)this + 42);
  v205[8].i32[0] = v145;
  v205[14].i32[1] = v268;
  v205[10].f32[0] = v267;
  v205[10].f32[1] = v270;
  v205[10].f32[2] = v269;
  v205[10].i32[3] = 0;
  v205[11].f32[0] = v274;
  v205[11].f32[1] = v272;
  v205[11].f32[2] = v271;
  v205[11].i32[3] = 0;
  v205[12].f32[0] = v275;
  v205[12].f32[1] = v276;
  v205[12].f32[2] = v273;
  v205[12].i32[3] = 0;
  v205[13].f32[0] = v157;
  v205[13].f32[1] = v158;
  v205[13].f32[2] = v159;
  v205[13].i32[3] = 1065353216;
  v205[4] = v153;
  v205[5] = v154;
  v205[6] = v155;
  v205[7] = v156;
  if (!*((unsigned char *)this + 66))
  {
    uint64_t v206 = *((void *)this + 15);
    v207 = (std::__shared_weak_count *)*((void *)this + 16);
    if (v207) {
      goto LABEL_158;
    }
    goto LABEL_161;
  }
  uint64_t v206 = *((void *)this + 17);
  v207 = (std::__shared_weak_count *)*((void *)this + 18);
  if (!v207)
  {
LABEL_161:
    ggl::Flyover::FlyoverPipelineSetup::setState(v74, v206, v207);
    goto LABEL_162;
  }
LABEL_158:
  atomic_fetch_add_explicit(&v207->__shared_owners_, 1uLL, memory_order_relaxed);
  ggl::Flyover::FlyoverPipelineSetup::setState(v74, v206, v207);
  if (!atomic_fetch_add(&v207->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v207->__on_zero_shared)(v207);
    std::__shared_weak_count::__release_weak(v207);
  }
LABEL_162:
  if (v205 && v204)
  {
    unint64_t v208 = v203[8];
    if (v208 <= v204) {
      unint64_t v208 = v204;
    }
    v203[7] = 0;
    v203[8] = v208;
  }
  ggl::CommandBuffer::pushRenderItem((uint64_t)v20, **((void **)this + 26));
  if (v301 != v300)
  {
    if (v301) {
      (*(void (**)(void))(*v301 + 40))();
    }
    goto LABEL_170;
  }
  (*(void (**)(void *))(v300[0] + 32))(v300);
  if (*((unsigned char *)this + 64))
  {
LABEL_171:
    v209 = (uint64_t *)*((void *)this + 25);
    if (v209)
    {
      uint64_t v210 = *(void *)(*((void *)a2 + 92) + 8);
      float32x2_t v211 = vcvt_f32_f64(*(float64x2_t *)(v210 + 376));
      float32x2_t v212 = vcvt_f32_f64(*(float64x2_t *)(v210 + 392));
      float32x2_t v213 = vcvt_f32_f64(*(float64x2_t *)(v210 + 408));
      float32x2_t v214 = vcvt_f32_f64(*(float64x2_t *)(v210 + 424));
      float32x2_t v215 = vcvt_f32_f64(*(float64x2_t *)(v210 + 440));
      float32x2_t v216 = vcvt_f32_f64(*(float64x2_t *)(v210 + 456));
      float32x2_t v217 = vcvt_f32_f64(*(float64x2_t *)(v210 + 472));
      float32x2_t v218 = vcvt_f32_f64(*(float64x2_t *)(v210 + 488));
      double v219 = *(double *)(v210 + 80);
      double v220 = *(double *)(v210 + 88);
      double v221 = *(double *)(v210 + 96);
      double v223 = *(double *)(v210 + 64);
      double v222 = *(double *)(v210 + 72);
      double v225 = *(double *)(v210 + 48);
      double v224 = *(double *)(v210 + 56);
      double v226 = -(v223 * v219 - v224 * v220) - (v223 * v219 - v224 * v220);
      double v227 = -(v225 * v220 - v223 * v222) - (v225 * v220 - v223 * v222);
      double v228 = -(v224 * v222 - v225 * v219) - (v224 * v222 - v225 * v219);
      double v229 = -(v228 * v222 - (-(v224 - v226 * v220) - v227 * v221));
      double v230 = -(v225 + v226 * v221 + v227 * v220 - v228 * v219);
      double v231 = -(v223 + v226 * v219 + v228 * v221 - v227 * v222);
      double v232 = v219 * -2.0;
      double v233 = -(v219 * (v219 * -2.0));
      double v234 = 1.0 - (v233 - v220 * (v220 * -2.0));
      double v235 = v222 * -2.0;
      double v236 = -(v219 * (v222 * -2.0));
      double v237 = v220 * -2.0 * v221;
      double v238 = v236 - v237;
      double v239 = -(v220 * (v222 * -2.0));
      double v240 = v221 * v232;
      double v241 = v221 * v232 - v220 * (v222 * -2.0);
      double v242 = v237 + v236;
      double v243 = v222 * -2.0 * v222 + 1.0;
      double v244 = v243 - -(v220 * (v220 * -2.0));
      double v245 = -(v220 * v232);
      double v246 = v221 * v235;
      float v247 = v234;
      float v249 = v239 - v240;
      float v251 = v244;
      float v252 = v246 + v245;
      float v254 = v245 - v246;
      float v255 = v243 - v233;
      float v257 = v229;
      uint64_t v259 = **(void **)(v209[1] + 64);
      long long v296 = 0uLL;
      unint64_t v260 = *(void *)(v259 + 8);
      *(void *)&long long v261 = 0;
      *((void *)&v261 + 1) = v259;
      v262 = v260 ? *(float32x2_t **)(v259 + 72) : 0;
      float64x2_t v286 = (float64x2_t)v261;
      long long v296 = v261;
      uint64_t v297 = 0;
      *(void *)v298 = v260;
      *(void *)&v299[4] = v262;
      *(_WORD *)&v298[8] = 1;
      v262[8] = v211;
      v262[9] = v212;
      v262[10] = v213;
      v262[11] = v214;
      v262[12] = v215;
      v262[13] = v216;
      v262[14] = v217;
      v262[15] = v218;
      v262->f32[0] = v247;
      float32_t v248 = v242;
      v262->f32[1] = v248;
      v262[1].f32[0] = v249;
      v262[1].i32[1] = 0;
      float32_t v250 = v238;
      v262[2].f32[0] = v250;
      v262[2].f32[1] = v251;
      v262[3].f32[0] = v252;
      v262[3].i32[1] = 0;
      float32_t v253 = v241;
      v262[4].f32[0] = v253;
      v262[4].f32[1] = v254;
      v262[5].f32[0] = v255;
      v262[5].i32[1] = 0;
      float32_t v256 = v230;
      v262[6].f32[0] = v256;
      v262[6].f32[1] = v257;
      float32_t v258 = v231;
      v262[7].f32[0] = v258;
      v262[7].i32[1] = 1065353216;
      uint64_t v263 = *((void *)this + 5);
      v262[16].i32[0] = *(_DWORD *)(**(void **)(*(void *)(*(void *)(v263 + 128) + 856) + 40) + 68);
      float32_t v264 = *(double *)(*(void *)(v263 + 136) + 32);
      v262[16].f32[1] = v264;
      ggl::CommandBuffer::pushRenderItem((uint64_t)v20, *v209);
      if (v260)
      {
        if (*(void *)&v286.f64[0] && *(unsigned char *)(*(void *)&v286.f64[1] + 17) != 2) {
          (*(void (**)(void))(**(void **)&v286.f64[0] + 64))();
        }
        unint64_t v265 = *(void *)(*(void *)&v286.f64[1] + 64);
        if (v265 <= v260) {
          unint64_t v265 = v260;
        }
        *(void *)(*(void *)&v286.f64[1] + 56) = 0;
        *(void *)(*(void *)&v286.f64[1] + 64) = v265;
      }
    }
  }
LABEL_184:
  *((void *)v20 + 4) = *((void *)this + 29);
  if (!v295)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
  (*(void (**)(void *))(*v295 + 48))(v295);
  double result = v295;
  if (v295 == v294) {
    return (void *)(*(uint64_t (**)(void *))(v294[0] + 32))(v294);
  }
  if (v295) {
    return (void *)(*(uint64_t (**)(void))(*v295 + 40))();
  }
  return result;
}

void sub_1A253AD08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  ggl::Texture2DLoadItem::~Texture2DLoadItem((ggl::Texture2DLoadItem *)&a49);
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)&a45);
  _Unwind_Resume(a1);
}

void sub_1A253ADEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t *a48)
{
  if (a48 == &a45)
  {
    (*(void (**)(uint64_t *))(a45 + 32))(&a45);
    _Unwind_Resume(exception_object);
  }
  if (!a48) {
    _Unwind_Resume(exception_object);
  }
  (*(void (**)(void))(*a48 + 40))();
  _Unwind_Resume(exception_object);
}

void std::__function::__func<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)unint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "SkyLayout", "", v5, 2u);
  }
}

unint64_t md::realistic::SkyRenderLayer::updateCorona(md::realistic::SkyRenderLayer *a1, unint64_t a2)
{
  md::realistic::SkyRenderLayer::coronaTexture(a1);
  unint64_t result = (*(uint64_t (**)(void *, void))(**((void **)a1 + 28) + 16))(*((void **)a1 + 28), 0);
  uint64_t v6 = *(unsigned int *)(*((void *)a1 + 28) + 16);
  if (!v6) {
    return result;
  }
  float v7 = (float)(v6 - 1);
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v294 = _Q1;
  if (v6 > 7
    && ((uint64_t v12 = 4 * v6, v13 = 4 * v6 - 4, result + v13 >= result) ? (_CF = result + 1 + v13 >= result + 1) : (_CF = 0),
        _CF ? (BOOL v15 = result + 3 + v13 >= result + 3) : (BOOL v15 = 0),
        v15 ? (BOOL v16 = result + 2 + v13 >= result + 2) : (BOOL v16 = 0),
        v16 && (result + v12 > a2 ? (BOOL v17 = result >= a2 + 12) : (BOOL v17 = 1), v17)))
  {
    __asm { FMOV            V1.2D, #1.5 }
    float64x2_t v285 = _Q1;
    __asm
    {
      FMOV            V3.2D, #1.0
      FMOV            V1.2D, #2.0
    }
    float64x2_t v264 = _Q1;
    __asm { FMOV            V13.2D, #-3.0 }
    if (v6 > 0xF)
    {
      uint64_t v43 = 0;
      uint64_t v22 = v6 & 0xFFFFFFF0;
      uint32x4_t v44 = (uint32x4_t)xmmword_1A28FE8B0;
      uint32x4_t v45 = (uint32x4_t)xmmword_1A28FE8C0;
      float64x2_t v266 = (float64x2_t)vdupq_n_s64(0x4038FFFFFFFFFFFAuLL);
      float64x2_t v268 = (float64x2_t)vdupq_n_s64(0x3FF0A3D70A3D70A4uLL);
      float64x2_t v265 = (float64x2_t)vdupq_n_s64(0xC038FFFFFFFFFFFALL);
      float64x2_t v262 = (float64x2_t)vdupq_n_s64(0x4048FFFFFFFFFFFAuLL);
      float64x2_t v263 = (float64x2_t)vdupq_n_s64(0x3FF051EB851EB852uLL);
      float64x2_t v260 = (float64x2_t)vdupq_n_s64(0x3FECCCCCCCCCCCCDuLL);
      float64x2_t v261 = (float64x2_t)vdupq_n_s64(0xC048FFFFFFFFFFFALL);
      float64x2_t v258 = (float64x2_t)vdupq_n_s64(0x4058FFFFFFFFFFFAuLL);
      float64x2_t v259 = (float64x2_t)vdupq_n_s64(0x3FED1EB851EB851FuLL);
      float32x4_t v256 = (float32x4_t)vdupq_n_s32(0x3F19999Au);
      float64x2_t v257 = (float64x2_t)vdupq_n_s64(0xC0567FFFFFFFFFFBLL);
      float32x4_t v254 = (float32x4_t)vdupq_n_s32(0x3F666666u);
      float32x4_t v255 = (float32x4_t)vdupq_n_s32(0x3F451EB8u);
      float32x4_t v253 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      float v23 = 1.0 / v7;
      uint32x4_t v46 = (uint32x4_t)xmmword_1A28FE8D0;
      uint64_t v47 = v12 & 0x3FFFFFFC0;
      uint32x4_t v48 = (uint32x4_t)xmmword_1A28FC7A0;
      v49.i64[0] = -1;
      v49.i64[1] = -1;
      int8x16_t v284 = v49;
      float v286 = v23;
      do
      {
        int32x4_t v288 = (int32x4_t)v48;
        int32x4_t v281 = (int32x4_t)v46;
        int32x4_t v290 = (int32x4_t)v44;
        int32x4_t v292 = (int32x4_t)v45;
        float32x4_t v50 = vmulq_n_f32(vcvtq_f32_u32(v44), v23);
        float32x4_t v51 = vmulq_n_f32(vcvtq_f32_u32(v45), v23);
        float32x4_t v52 = vmulq_n_f32(vcvtq_f32_u32(v46), v23);
        float32x4_t v53 = vmulq_n_f32(vcvtq_f32_u32(v48), v23);
        float64x2_t v54 = vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v50.f32), v285);
        float64x2_t v276 = vmulq_f64(vcvt_hight_f64_f32(v50), v285);
        float64x2_t v55 = vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v51.f32), v285);
        float64x2_t v56 = vmulq_f64(vcvt_hight_f64_f32(v51), v285);
        float64x2_t v57 = vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v52.f32), v285);
        float64x2_t v58 = vmulq_f64(vcvt_hight_f64_f32(v52), v285);
        float64x2_t v59 = vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v53.f32), v285);
        float64x2_t v60 = vmulq_f64(vcvt_hight_f64_f32(v53), v285);
        float64x2_t v61 = vmaxnmq_f64(v60, _Q3);
        float64x2_t v62 = vmaxnmq_f64(v59, _Q3);
        float64x2_t v63 = vmaxnmq_f64(v58, _Q3);
        float64x2_t v64 = vmaxnmq_f64(v57, _Q3);
        float64x2_t v65 = vmaxnmq_f64(v56, _Q3);
        float64x2_t v66 = vmaxnmq_f64(v55, _Q3);
        float64x2_t v67 = vmaxnmq_f64(v276, _Q3);
        float64x2_t v68 = vmaxnmq_f64(v54, _Q3);
        float64x2_t v69 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v61, v268), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v265, v266, v61));
        float64x2_t v70 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v62, v268), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v265, v266, v62));
        float64x2_t v71 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v63, v268), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v265, v266, v63));
        float64x2_t v72 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v64, v268), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v265, v266, v64));
        float64x2_t v73 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v65, v268), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v265, v266, v65));
        float64x2_t v74 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v66, v268), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v265, v266, v66));
        float64x2_t v75 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v68, v268), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v265, v266, v68));
        float64x2_t v76 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v67, v268), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v265, v266, v67));
        float64x2_t v274 = vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v69), vmulq_f64(v69, v69));
        float64x2_t v272 = vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v70), vmulq_f64(v70, v70));
        float64x2_t v77 = vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v72), vmulq_f64(v72, v72));
        float64x2_t v78 = vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v73), vmulq_f64(v73, v73));
        float64x2_t v79 = vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v74), vmulq_f64(v74, v74));
        float64x2_t v80 = vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v76), vmulq_f64(v76, v76));
        int8x16_t v81 = (int8x16_t)vcgtq_f64(v66, v263);
        int8x16_t v82 = (int8x16_t)vmlaq_f64(v261, v262, v66);
        float64x2_t v83 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v61, v263), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v261, v262, v61));
        float64x2_t v84 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v62, v263), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v261, v262, v62));
        float64x2_t v85 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v63, v263), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v261, v262, v63));
        float64x2_t v86 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v64, v263), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v261, v262, v64));
        float64x2_t v87 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v65, v263), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v261, v262, v65));
        float64x2_t v88 = (float64x2_t)vbslq_s8(v81, (int8x16_t)_Q3, v82);
        float64x2_t v89 = vmulq_f64(v75, v75);
        float64x2_t v90 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v67, v263), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v261, v262, v67));
        float64x2_t v91 = vmlaq_f64(_Q13, v264, v75);
        float64x2_t v92 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v68, v263), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v261, v262, v68));
        float64x2_t v93 = vmlaq_f64(_Q3, v91, v89);
        float64x2_t v94 = vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v83), vmulq_f64(v83, v83));
        float64x2_t v95 = vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v85), vmulq_f64(v85, v85));
        float64x2_t v96 = vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v87), vmulq_f64(v87, v87));
        float64x2_t v97 = vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v88), vmulq_f64(v88, v88));
        float64x2_t v98 = vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v90), vmulq_f64(v90, v90));
        float64x2_t v99 = vmaxnmq_f64(v60, v260);
        float64x2_t v100 = vmaxnmq_f64(v59, v260);
        float64x2_t v101 = vmaxnmq_f64(v58, v260);
        float64x2_t v102 = vmaxnmq_f64(v57, v260);
        float64x2_t v103 = vmaxnmq_f64(v56, v260);
        float64x2_t v104 = vmaxnmq_f64(v55, v260);
        float64x2_t v105 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v99, v259), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v257, v258, v99));
        float64x2_t v106 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v100, v259), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v257, v258, v100));
        float64x2_t v107 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v101, v259), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v257, v258, v101));
        float64x2_t v108 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v102, v259), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v257, v258, v102));
        float64x2_t v109 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v103, v259), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v257, v258, v103));
        float64x2_t v110 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v104, v259), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v257, v258, v104));
        float64x2_t v111 = vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v108), vmulq_f64(v108, v108));
        float64x2_t v112 = vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v109), vmulq_f64(v109, v109));
        float32x4_t v270 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v93), v80);
        float32x4_t v113 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v79), v78);
        float32x4_t v114 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v77), vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v71), vmulq_f64(v71, v71)));
        float32x4_t v115 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v272), v274);
        float32x4_t v116 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v92), vmulq_f64(v92, v92))), v98);
        float64x2_t v117 = vmaxnmq_f64(v276, v260);
        float64x2_t v118 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v117, v259), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v257, v258, v117));
        *(float32x2_t *)&v98.f64[0] = vcvt_f32_f64(vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v84), vmulq_f64(v84, v84)));
        float64x2_t v119 = vmaxnmq_f64(v54, v260);
        float64x2_t v120 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v119, v259), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v257, v258, v119));
        float32x4_t v121 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v86), vmulq_f64(v86, v86))), v95);
        float32x4_t v122 = vcvt_hight_f32_f64(*(int32x2_t *)&v98.f64[0], v94);
        float32x4_t v277 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v120), vmulq_f64(v120, v120))), vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v118), vmulq_f64(v118, v118)));
        float32x4_t v279 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v97), v96);
        float32x4_t v123 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v110), vmulq_f64(v110, v110))), v112);
        float32x4_t v124 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v111), vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v107), vmulq_f64(v107, v107)));
        float32x4_t v125 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v106), vmulq_f64(v106, v106))), vmlaq_f64(_Q3, vmlaq_f64(_Q13, v264, v105), vmulq_f64(v105, v105)));
        float32x4_t v126 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0);
        float32x4_t v127 = vsubq_f32(v256, v126);
        float32x4_t v128 = vmlaq_f32(v126, v115, v127);
        float32x4_t v129 = vmlaq_f32(v126, v114, v127);
        float32x4_t v130 = vmlaq_f32(v126, v113, v127);
        float32x4_t v131 = vmlaq_f32(v126, v270, v127);
        float32x4_t v132 = vmlaq_f32(v128, v122, vsubq_f32(v294, v128));
        float32x4_t v133 = v122;
        float32x4_t v134 = vmlaq_f32(v129, v121, vsubq_f32(v294, v129));
        float32x4_t v135 = vmlaq_f32(v130, v279, vsubq_f32(v294, v130));
        float32x4_t v136 = v116;
        float32x4_t v137 = vmlaq_f32(v131, v116, vsubq_f32(v294, v131));
        v297.val[0] = (int8x16_t)vcvtq_u32_f32(vmulq_f32(vmlaq_f32(v132, v125, vsubq_f32(v126, v132)), v253));
        v297.val[1] = (int8x16_t)vcvtq_u32_f32(vmulq_f32(vmlaq_f32(v134, v124, vsubq_f32(v126, v134)), v253));
        float32x4_t v138 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a2 + 4), 0);
        v297.val[2] = (int8x16_t)vcvtq_u32_f32(vmulq_f32(vmlaq_f32(v135, v123, vsubq_f32(v126, v135)), v253));
        float32x4_t v139 = vsubq_f32(v255, v138);
        v297.val[3] = (int8x16_t)vcvtq_u32_f32(vmulq_f32(vmlaq_f32(v137, v277, vsubq_f32(v126, v137)), v253));
        float32x4_t v140 = vmlaq_f32(v138, v115, v139);
        v298.val[3] = v284;
        v298.val[0] = vqtbl4q_s8(v297, (int8x16_t)xmmword_1A28FE720);
        float32x4_t v141 = v114;
        float32x4_t v142 = vmlaq_f32(v138, v114, v139);
        float32x4_t v143 = vmlaq_f32(v138, v113, v139);
        float32x4_t v144 = vmlaq_f32(v138, v270, v139);
        float32x4_t v145 = vmlaq_f32(v140, v133, vsubq_f32(v294, v140));
        float32x4_t v146 = vmlaq_f32(v142, v121, vsubq_f32(v294, v142));
        float32x4_t v147 = vmlaq_f32(v143, v279, vsubq_f32(v294, v143));
        float32x4_t v148 = vmlaq_f32(v144, v136, vsubq_f32(v294, v144));
        v297.val[0] = (int8x16_t)vcvtq_u32_f32(vmulq_f32(vmlaq_f32(v145, v125, vsubq_f32(v138, v145)), v253));
        float32x4_t v5 = (float32x4_t)vcvtq_u32_f32(vmulq_f32(vmlaq_f32(v146, v124, vsubq_f32(v138, v146)), v253));
        v297.val[2] = (int8x16_t)vcvtq_u32_f32(vmulq_f32(vmlaq_f32(v147, v123, vsubq_f32(v138, v147)), v253));
        v297.val[3] = (int8x16_t)vcvtq_u32_f32(vmulq_f32(vmlaq_f32(v148, v277, vsubq_f32(v138, v148)), v253));
        v298.val[1] = vqtbl4q_s8(*(int8x16x4_t *)(&v5 - 1), (int8x16_t)xmmword_1A28FE720);
        float32x4_t v149 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a2 + 8), 0);
        float32x4_t v150 = vsubq_f32(v254, v149);
        float32x4_t v151 = vmlaq_f32(v149, v115, v150);
        float32x4_t v152 = vmlaq_f32(v149, v141, v150);
        float32x4_t v153 = vmlaq_f32(v149, v113, v150);
        float32x4_t v154 = vmlaq_f32(v149, v270, v150);
        float32x4_t v155 = vmlaq_f32(v151, v133, vsubq_f32(v294, v151));
        float32x4_t v156 = vmlaq_f32(v152, v121, vsubq_f32(v294, v152));
        float32x4_t v157 = vmlaq_f32(v153, v279, vsubq_f32(v294, v153));
        float32x4_t v158 = vmlaq_f32(v154, v136, vsubq_f32(v294, v154));
        float32x4_t v159 = vmlaq_f32(v155, v125, vsubq_f32(v149, v155));
        float32x4_t v160 = vmlaq_f32(v157, v123, vsubq_f32(v149, v157));
        float32x4_t v161 = vmlaq_f32(v158, v277, vsubq_f32(v149, v158));
        float32x4_t v162 = vmulq_f32(vmlaq_f32(v156, v124, vsubq_f32(v149, v156)), v253);
        float v23 = v286;
        uint32x4_t v163 = vcvtq_u32_f32(vmulq_f32(v159, v253));
        uint32x4_t v164 = vcvtq_u32_f32(v162);
        uint32x4_t v165 = vcvtq_u32_f32(vmulq_f32(v160, v253));
        v297.val[0] = (int8x16_t)vcvtq_u32_f32(vmulq_f32(v161, v253));
        v298.val[2] = vqtbl4q_s8(v297, (int8x16_t)xmmword_1A28FE720);
        double v166 = (char *)(result + (v43 & 0xFFFFFFC0));
        vst4q_s8(v166, v298);
        *(void *)&v54.f64[0] = 0x1000000010;
        *(void *)&v54.f64[1] = 0x1000000010;
        uint32x4_t v48 = (uint32x4_t)vaddq_s32(v288, (int32x4_t)v54);
        uint32x4_t v46 = (uint32x4_t)vaddq_s32(v281, (int32x4_t)v54);
        uint32x4_t v45 = (uint32x4_t)vaddq_s32(v292, (int32x4_t)v54);
        v43 += 64;
        uint32x4_t v44 = (uint32x4_t)vaddq_s32(v290, (int32x4_t)v54);
      }
      while (v47 != v43);
      float v7 = (float)(v6 - 1);
      if (v22 == v6) {
        return result;
      }
      if ((v6 & 8) == 0) {
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v22 = 0;
      float v23 = 1.0 / v7;
    }
    uint64_t v167 = v22;
    int8x16_t v168 = (int8x16_t)vdupq_n_s32(v22);
    uint64_t v22 = v6 & 0xFFFFFFF8;
    int32x4_t v169 = (int32x4_t)vorrq_s8(v168, (int8x16_t)xmmword_1A28FE8D0);
    int32x4_t v170 = (int32x4_t)vorrq_s8(v168, (int8x16_t)xmmword_1A28FC7A0);
    uint64_t v171 = v167 - v22;
    uint64_t v172 = 4 * v167;
    float64x2_t v291 = (float64x2_t)vdupq_n_s64(0x4038FFFFFFFFFFFAuLL);
    float64x2_t v293 = (float64x2_t)vdupq_n_s64(0x3FF0A3D70A3D70A4uLL);
    float64x2_t v289 = (float64x2_t)vdupq_n_s64(0xC038FFFFFFFFFFFALL);
    float64x2_t v282 = (float64x2_t)vdupq_n_s64(0x4048FFFFFFFFFFFAuLL);
    float64x2_t v283 = (float64x2_t)vdupq_n_s64(0x3FF051EB851EB852uLL);
    float64x2_t v278 = (float64x2_t)vdupq_n_s64(0x3FECCCCCCCCCCCCDuLL);
    float64x2_t v280 = (float64x2_t)vdupq_n_s64(0xC048FFFFFFFFFFFALL);
    float64x2_t v273 = (float64x2_t)vdupq_n_s64(0x4058FFFFFFFFFFFAuLL);
    float64x2_t v275 = (float64x2_t)vdupq_n_s64(0x3FED1EB851EB851FuLL);
    float64x2_t v173 = (float64x2_t)vdupq_n_s64(0xC0567FFFFFFFFFFBLL);
    float32x4_t v269 = (float32x4_t)vdupq_n_s32(0x3F451EB8u);
    float32x4_t v271 = (float32x4_t)vdupq_n_s32(0x3F19999Au);
    float32x4_t v267 = (float32x4_t)vdupq_n_s32(0x3F666666u);
    float32x4_t v174 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    uint64_t v175 = -1;
    v5.i32[3] = HIDWORD(v264.f64[1]);
    float64x2_t v176 = _Q13;
    float v287 = v23;
    do
    {
      float32x4_t v177 = vmulq_n_f32(vcvtq_f32_u32((uint32x4_t)v169), v23);
      float32x4_t v178 = vmulq_n_f32(vcvtq_f32_u32((uint32x4_t)v170), v23);
      float64x2_t v179 = vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v177.f32), v285);
      float64x2_t v180 = vmulq_f64(vcvt_hight_f64_f32(v177), v285);
      float64x2_t v181 = vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v178.f32), v285);
      float64x2_t v182 = vmulq_f64(vcvt_hight_f64_f32(v178), v285);
      float64x2_t v183 = vmaxnmq_f64(v182, _Q3);
      float64x2_t v184 = vmaxnmq_f64(v181, _Q3);
      float64x2_t v185 = vmaxnmq_f64(v180, _Q3);
      float64x2_t v186 = vmaxnmq_f64(v179, _Q3);
      float64x2_t v187 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v183, v293), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v289, v291, v183));
      float64x2_t v188 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v184, v293), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v289, v291, v184));
      float64x2_t v189 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v186, v293), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v289, v291, v186));
      float64x2_t v190 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v185, v293), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v289, v291, v185));
      float64x2_t v191 = vmulq_f64(v190, v190);
      float64x2_t v192 = vmlaq_f64(v176, v264, v190);
      float64x2_t v193 = vmlaq_f64(_Q3, vmlaq_f64(v176, v264, v187), vmulq_f64(v187, v187));
      float64x2_t v194 = vmlaq_f64(_Q3, vmlaq_f64(v176, v264, v188), vmulq_f64(v188, v188));
      float64x2_t v195 = vmlaq_f64(_Q3, v192, v191);
      float64x2_t v196 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v183, v283), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v280, v282, v183));
      float64x2_t v197 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v184, v283), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v280, v282, v184));
      float64x2_t v198 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v185, v283), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v280, v282, v185));
      float64x2_t v199 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v186, v283), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v280, v282, v186));
      float64x2_t v200 = vmlaq_f64(_Q3, vmlaq_f64(v176, v264, v189), vmulq_f64(v189, v189));
      float64x2_t v201 = vmulq_f64(v199, v199);
      float64x2_t v202 = vmlaq_f64(_Q3, vmlaq_f64(v176, v264, v196), vmulq_f64(v196, v196));
      float64x2_t v203 = vmaxnmq_f64(v182, v278);
      float64x2_t v204 = vmaxnmq_f64(v181, v278);
      float64x2_t v205 = vmaxnmq_f64(v180, v278);
      float64x2_t v206 = vmaxnmq_f64(v179, v278);
      int8x16_t v207 = (int8x16_t)vcgtq_f64(v206, v275);
      int8x16_t v208 = (int8x16_t)vmlaq_f64(v173, v273, v206);
      float64x2_t v209 = vmlaq_f64(v176, v264, v199);
      float64x2_t v210 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v203, v275), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v173, v273, v203));
      float64x2_t v211 = vmulq_f64(v198, v198);
      float64x2_t v212 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v204, v275), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v173, v273, v204));
      float64x2_t v213 = vmlaq_f64(v176, v264, v198);
      float64x2_t v214 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v205, v275), (int8x16_t)_Q3, (int8x16_t)vmlaq_f64(v173, v273, v205));
      float64x2_t v215 = (float64x2_t)vbslq_s8(v207, (int8x16_t)_Q3, v208);
      float64x2_t v216 = vmulq_f64(v215, v215);
      float64x2_t v217 = vmlaq_f64(_Q3, v213, v211);
      float64x2_t v218 = vmlaq_f64(v176, v264, v215);
      float64x2_t v219 = vmlaq_f64(_Q3, v209, v201);
      float64x2_t v220 = vmlaq_f64(_Q3, vmlaq_f64(v176, v264, v214), vmulq_f64(v214, v214));
      float32x4_t v221 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2, 0);
      float32x4_t v222 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v200), v195);
      float32x4_t v223 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a2 + 4), 0);
      float32x4_t v224 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a2 + 8), 0);
      float32x4_t v225 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v194), v193);
      float64x2_t v226 = vmlaq_f64(_Q3, v218, v216);
      float32x4_t v227 = vsubq_f32(v271, v221);
      float32x4_t v228 = vmlaq_f32(v221, v225, v227);
      float32x4_t v229 = vmlaq_f32(v221, v222, v227);
      float32x4_t v230 = vsubq_f32(v269, v223);
      float32x4_t v231 = vmlaq_f32(v223, v225, v230);
      float32x4_t v232 = vsubq_f32(v267, v224);
      float32x4_t v233 = vmlaq_f32(v223, v222, v230);
      float32x4_t v234 = vmlaq_f32(v224, v225, v232);
      float32x4_t v235 = vmlaq_f32(v224, v222, v232);
      float32x4_t v236 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(_Q3, vmlaq_f64(v176, v264, v197), vmulq_f64(v197, v197))), v202);
      float32x4_t v237 = vmlaq_f32(v228, v236, vsubq_f32(v294, v228));
      float32x4_t v238 = vmlaq_f32(v231, v236, vsubq_f32(v294, v231));
      float32x4_t v239 = vmlaq_f32(v234, v236, vsubq_f32(v294, v234));
      float32x4_t v240 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v219), v217);
      float32x4_t v241 = vmlaq_f32(v229, v240, vsubq_f32(v294, v229));
      float32x4_t v242 = vmlaq_f32(v233, v240, vsubq_f32(v294, v233));
      float32x4_t v243 = vmlaq_f32(v235, v240, vsubq_f32(v294, v235));
      float32x4_t v244 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(_Q3, vmlaq_f64(v176, v264, v212), vmulq_f64(v212, v212))), vmlaq_f64(_Q3, vmlaq_f64(v176, v264, v210), vmulq_f64(v210, v210)));
      float32x4_t v245 = vmlaq_f32(v237, v244, vsubq_f32(v221, v237));
      float32x4_t v246 = vmlaq_f32(v238, v244, vsubq_f32(v223, v238));
      float32x4_t v247 = vmlaq_f32(v239, v244, vsubq_f32(v224, v239));
      float32x4_t v248 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v226), v220);
      v296.val[0] = (int8x16_t)vcvtq_u32_f32(vmulq_f32(v245, v174));
      v296.val[1] = (int8x16_t)vcvtq_u32_f32(vmulq_f32(vmlaq_f32(v241, v248, vsubq_f32(v221, v241)), v174));
      unint64_t v249 = vqtbl2q_s8(v296, (int8x16_t)xmmword_1A28FF670).u64[0];
      v296.val[0] = (int8x16_t)vcvtq_u32_f32(vmulq_f32(v246, v174));
      v296.val[1] = (int8x16_t)vcvtq_u32_f32(vmulq_f32(vmlaq_f32(v242, v248, vsubq_f32(v223, v242)), v174));
      unint64_t v250 = vqtbl2q_s8(v296, (int8x16_t)xmmword_1A28FF670).u64[0];
      float v23 = v287;
      v295.val[0] = (int8x16_t)vcvtq_u32_f32(vmulq_f32(v247, v174));
      v295.val[1] = (int8x16_t)vcvtq_u32_f32(vmulq_f32(vmlaq_f32(v243, v248, vsubq_f32(v224, v243)), v174));
      unint64_t v251 = vqtbl2q_s8(v295, (int8x16_t)xmmword_1A28FF670).u64[0];
      float v252 = (char *)(result + (v172 & 0xFFFFFFE0));
      vst4_s8(v252, *(int8x8x4_t *)(&v175 - 3));
      v248.i64[0] = 0x800000008;
      v248.i64[1] = 0x800000008;
      int32x4_t v170 = vaddq_s32(v170, (int32x4_t)v248);
      int32x4_t v169 = vaddq_s32(v169, (int32x4_t)v248);
      v172 += 32;
      v171 += 8;
    }
    while (v171);
    float v7 = (float)(v6 - 1);
    if (v22 == v6) {
      return result;
    }
  }
  else
  {
    uint64_t v22 = 0;
  }
LABEL_22:
  unsigned int v24 = 4 * v22;
  float v25 = 1.0 / v7;
  float32x4_t v26 = (float32x4_t)vdupq_n_s32(0x437F0000u);
  do
  {
    double v27 = (float)((float)v22 * v25) * 1.5;
    double v28 = fmax(v27, 1.0);
    double v29 = v28 * 25.0 + -25.0;
    if (v28 > 1.04) {
      double v29 = 1.0;
    }
    double v30 = v29 * v29;
    double v31 = v29 * 2.0 + -3.0;
    if (v28 <= 1.02) {
      double v32 = v28 * 50.0 + -50.0;
    }
    else {
      double v32 = 1.0;
    }
    double v33 = v32 * v32 * (v32 * 2.0 + -3.0) + 1.0;
    double v34 = fmax(v27, 0.9);
    float v35 = v30 * v31 + 1.0;
    if (v34 <= 0.91) {
      double v36 = v34 * 100.0 + -90.0;
    }
    else {
      double v36 = 1.0;
    }
    float v37 = v33;
    v5.i64[0] = *(void *)a2;
    v5.i32[2] = *(_DWORD *)(a2 + 8);
    float v38 = v36 * v36 * (v36 * 2.0 + -3.0) + 1.0;
    float32x4_t v39 = vmlaq_n_f32(v5, vsubq_f32((float32x4_t)xmmword_1A28FF680, v5), v35);
    float32x4_t v40 = vmlaq_n_f32(v39, vsubq_f32(v294, v39), v37);
    int16x8_t v41 = (int16x8_t)vcvtq_s32_f32(vmulq_f32(vmlaq_n_f32(v40, vsubq_f32(v5, v40), v38), v26));
    *(int16x4_t *)v41.i8 = vmovn_s32((int32x4_t)v41);
    unint64_t v42 = result + v24;
    *(unsigned char *)(v42 + 2) = v41.i8[4];
    *(_WORD *)unint64_t v42 = vmovn_s16(v41).u16[0];
    *(unsigned char *)(result + v24 + 3) = -1;
    ++v22;
    v24 += 4;
  }
  while (v6 != v22);
  return result;
}

void std::__function::__func<md::realistic::SkyRenderLayer::corona(ggl::Loader *)::$_0,std::allocator<md::realistic::SkyRenderLayer::corona(ggl::Loader *)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  os_signpost_id_t v4 = operator new(0xF8uLL);
  v4[1] = 0;
  *os_signpost_id_t v4 = &unk_1EF584578;
  v4[2] = 0;
  v4[3] = &unk_1EF55A1F0;
  v4[4] = 16;
  *((_DWORD *)v4 + 10) = 1;
  v4[6] = 0;
  v4[7] = 0;
  v4[8] = 0;
  v4[9] = 3216;
  long long v5 = 0uLL;
  *((_OWORD *)v4 + 5) = 0u;
  *((_OWORD *)v4 + 6) = 0u;
  v4[14] = 0;
  {
    long long v5 = 0uLL;
    if (v37) {
      operator new();
    }
  }
  uint64_t v6 = 0;
  v4[15] = ggl::Allocator::instance(void)::alloc;
  v4[16] = 0;
  *((_OWORD *)v4 + 11) = v5;
  *((_OWORD *)v4 + 12) = v5;
  v4[26] = 0;
  v4[27] = -1;
  *((_OWORD *)v4 + 9) = xmmword_1A28FCCA0;
  *((_OWORD *)v4 + 10) = v5;
  *((_DWORD *)v4 + 34) = 0;
  v4[29] = "/render/earthcorona/vertexdata";
  v4[30] = &ggl::EarthCorona::defaultVboReflection;
  v4[3] = &unk_1EF55C108;
  v4[28] = &unk_1EF55C128;
  unint64_t v7 = v4[4];
  unint64_t v8 = v4[9] - v4[8];
  if (v8 != v8 % v7)
  {
    if (!v3 || *((unsigned char *)v4 + 41) == 2) {
      uint64_t v6 = v4[12];
    }
    else {
      uint64_t v6 = (*(uint64_t (**)(uint64_t, void *, void, unint64_t, uint64_t, uint64_t))(*(void *)v3 + 56))(v3, v4 + 3, 0, v8 / v7 * v7, 1, 1);
    }
  }
  uint64_t v9 = 0;
  uint64_t v10 = (float32x2_t *)(v6 + 8);
  __asm { FMOV            V0.2D, #1.5 }
  float64x2_t v38 = _Q0;
  do
  {
    __double2 v17 = __sincos_stret((double)v9 * 0.0314159265);
    v16.f64[0] = v17.__cosval;
    v16.f64[1] = v17.__sinval;
    v10[-1] = vcvt_f32_f64(vmulq_f64(v16, v38));
    v10->i32[0] = 0;
    v10 += 2;
    ++v9;
  }
  while (v9 != 200);
  *(_DWORD *)(v6 + 3208) = 0;
  *(void *)(v6 + 3200) = 0;
  uint64_t v18 = operator new(0xF8uLL);
  v18[1] = 0;
  *uint64_t v18 = &unk_1EF583D28;
  v18[2] = 0;
  v18[3] = &unk_1EF55A1F0;
  v18[4] = 2;
  *((_DWORD *)v18 + 10) = 257;
  v18[6] = 0;
  v18[7] = 0;
  v18[8] = 0;
  v18[9] = 1200;
  *((_OWORD *)v18 + 5) = 0u;
  *((_OWORD *)v18 + 6) = 0u;
  v18[14] = 0;
  {
    operator new();
  }
  v18[15] = ggl::Allocator::instance(void)::alloc;
  v18[16] = 0;
  *((_OWORD *)v18 + 11) = 0u;
  *((_OWORD *)v18 + 12) = 0u;
  v18[26] = 0;
  v18[27] = -1;
  *((_OWORD *)v18 + 9) = xmmword_1A28FCCA0;
  *((_OWORD *)v18 + 10) = 0u;
  *((_DWORD *)v18 + 34) = 0;
  *((_DWORD *)v18 + 60) = 0;
  v18[3] = &unk_1EF55B630;
  v18[4] = 2;
  v18[28] = &unk_1EF55B650;
  v18[29] = "/render/earthcorona/indexdata";
  if (!v3 || *((unsigned char *)v18 + 41) == 2) {
    uint64_t v19 = v18[12];
  }
  else {
    uint64_t v19 = (*(uint64_t (**)(uint64_t, void *, void, uint64_t, uint64_t, uint64_t))(*(void *)v3 + 56))(v3, v18 + 3, 0, 1200, 1, 1);
  }
  uint64_t v20 = 0;
  int64x2_t v21 = (int64x2_t)xmmword_1A28FC8F0;
  int64x2_t v22 = (int64x2_t)xmmword_1A28FC900;
  int64x2_t v23 = (int64x2_t)xmmword_1A28FC910;
  int64x2_t v24 = (int64x2_t)xmmword_1A28FC760;
  int16x8_t v25 = (int16x8_t)xmmword_1A28FD560;
  uint64x2_t v26 = (uint64x2_t)vdupq_n_s64(0xC7uLL);
  int64x2_t v27 = vdupq_n_s64(8uLL);
  v28.i64[0] = 0x1000100010001;
  v28.i64[1] = 0x1000100010001;
  v29.i64[0] = 0xC600C600C600C6;
  v29.i64[1] = 0xC600C600C600C6;
  *(void *)&long long v30 = 0xC800C800C800C8;
  *((void *)&v30 + 1) = 0xC800C800C800C8;
  v31.i64[0] = 0x8000800080008;
  v31.i64[1] = 0x8000800080008;
  do
  {
    int8x16_t v32 = vbslq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v26, (uint64x2_t)v24), (int32x4_t)vcgtq_u64(v26, (uint64x2_t)v23)), (int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v26, (uint64x2_t)v22), (int32x4_t)vcgtq_u64(v26, (uint64x2_t)v21))), (int8x16_t)vaddq_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v23), (int16x8_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v21)), v28), (int8x16_t)vaddq_s16(v25, v29));
    double v33 = (__int16 *)(v19 + v20);
    int16x8_t v34 = v25;
    vst3q_s16(v33, *(int16x8x3_t *)&v30);
    int64x2_t v22 = vaddq_s64(v22, v27);
    int64x2_t v23 = vaddq_s64(v23, v27);
    int64x2_t v24 = vaddq_s64(v24, v27);
    int64x2_t v21 = vaddq_s64(v21, v27);
    int16x8_t v25 = vaddq_s16(v25, v31);
    v20 += 48;
  }
  while (v20 != 1200);
  float v35 = operator new(0xE8uLL);
  v35[1] = 0;
  v35[2] = 0;
  *float v35 = &unk_1EF585A08;
  ggl::BufferData::BufferData((uint64_t)(v35 + 3), qword_1E9551458, 2, 1, 6, 1);
  v35[28] = ggl::EarthCorona::Base::reflection(void)::reflection;
  v35[3] = &unk_1EF55D698;
  uint64_t v36 = *(void *)(v2 + 128);
  if (v36) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v36 + 8), 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_1A253CE5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, atomic_ullong *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, atomic_ullong *a16, atomic_ullong *a17, uint64_t a18, atomic_ullong *a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
  if (!atomic_fetch_add(a10, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
  (*(void (**)(uint64_t))(*(void *)v32 + 8))(v32);
  if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  if (!atomic_fetch_add(a17, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a21);
  if (!atomic_fetch_add(a19, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a27);
  if (!atomic_fetch_add(a16, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  _Unwind_Resume(a1);
}

uint64_t md::realistic::SkyRenderLayer::coronaTexture(md::realistic::SkyRenderLayer *this)
{
  uint64_t result = *((void *)this + 27);
  if (!result)
  {
    uint64_t v2 = (char *)operator new(0x58uLL);
    *((void *)v2 + 1) = 0;
    *(void *)uint64_t v2 = &unk_1EF583858;
    *((void *)v2 + 5) = 0;
    *((void *)v2 + 6) = 0;
    *((void *)v2 + 4) = 0;
    *((_DWORD *)v2 + 14) = 0;
    *((void *)v2 + 2) = 0;
    *((void *)v2 + 3) = &unk_1EF55AE58;
    *(void *)&long long v3 = 0x100000001;
    *((void *)&v3 + 1) = 0x100000001;
    *(_OWORD *)(v2 + 60) = v3;
    *(void *)(v2 + 76) = 0x100000001;
    *((_DWORD *)v2 + 21) = 0;
    operator new();
  }
  return result;
}

void sub_1A253D28C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__shared_ptr_emplace<ggl::EarthCorona::BaseMesh>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::EarthCorona::BaseMesh>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5833C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::EarthCorona::BaseMesh>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5833C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::EarthCorona::Base>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::EarthCorona::Base>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::EarthCorona::Base>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::EarthCorona::Base>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585A08;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::EarthCorona::Base>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585A08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::EarthCorona::DefaultVbo>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::EarthCorona::DefaultVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584578;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::EarthCorona::DefaultVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584578;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__function::__func<md::realistic::SkyRenderLayer::corona(ggl::Loader *)::$_0,std::allocator<md::realistic::SkyRenderLayer::corona(ggl::Loader *)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579F98;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::realistic::SkyRenderLayer::corona(ggl::Loader *)::$_0,std::allocator<md::realistic::SkyRenderLayer::corona(ggl::Loader *)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF579F98;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::realistic::SkyRenderLayer::corona(ggl::Loader *)::$_0,std::allocator<md::realistic::SkyRenderLayer::corona(ggl::Loader *)::$_0>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

void md::realistic::SkyRenderLayer::load(md::realistic::SkyRenderLayer *this)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (char *)this + 176;
  (*(void (**)(void *__return_ptr))(**((void **)this + 31) + 104))(&v12);
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v12) == 4)
  {
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    uint64_t v3 = (id)GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      os_signpost_id_t v4 = (char *)this + 176;
      if (*((char *)this + 199) < 0) {
        os_signpost_id_t v4 = *(char **)v2;
      }
      *(_DWORD *)buf = 136315138;
      float64x2_t v16 = v4;
      _os_log_impl(&dword_1A1780000, v3, OS_LOG_TYPE_DEBUG, "Loaded sky model: %s", buf, 0xCu);
    }

    uint64_t v5 = (*(uint64_t (**)(void, char *, uint64_t))(**((void **)this + 31) + 112))(*((void *)this + 31), (char *)this + 176, 1);
    uint64_t v6 = (uint64_t *)*((void *)this + 25);
    *((void *)this + 25) = v5;
    if (v6)
    {
      unint64_t v7 = (std::__shared_weak_count *)v6[3];
      if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
      uint64_t v8 = v6[1];
      v6[1] = 0;
      if (v8) {
        (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
      }
      uint64_t v9 = *v6;
      uint64_t *v6 = 0;
      if (v9) {
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      }
      MEMORY[0x1A6239270](v6, 0x20C40DC1BFBCFLL);
      uint64_t v5 = *((void *)this + 25);
    }
    *(void *)(*(void *)v5 + 24) = *((void *)this + 11);
    if (*((void *)this + 25)) {
      *((unsigned char *)this + 64) = 1;
    }
    else {
      md::realistic::SkyRenderLayer::load(this);
    }
  }
  else if (!karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v12))
  {
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    uint64_t v10 = (id)GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      if (*((char *)this + 199) < 0) {
        uint64_t v2 = *(char **)v2;
      }
      *(_DWORD *)buf = 136315138;
      float64x2_t v16 = v2;
      _os_log_impl(&dword_1A1780000, v10, OS_LOG_TYPE_DEBUG, "Failed to load sky model: %s", buf, 0xCu);
    }
  }
  uint64_t v12 = off_1EF5677B0;
  if (v13) {
    atomic_fetch_add((atomic_uint *volatile)(v13 + 128), 0xFFFFFFFF);
  }
  uint64_t v11 = v14;
  if (v14)
  {
    if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_1A253DA18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  karo::AsyncRequestManager::RequestHandle::~RequestHandle((karo::AsyncRequestManager::RequestHandle *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "SkyLayout", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57A028;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF57A028;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579FE0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF579FE0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::realistic::SkyRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::~__func()
{
}

void md::realistic::SkyRenderLayer::~SkyRenderLayer(md::realistic::SkyRenderLayer *this)
{
  md::realistic::SkyRenderLayer::~SkyRenderLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  void *v19;

  *(void *)this = &unk_1EF554640;
  uint64_t v2 = *((void *)this + 31);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 12);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  os_signpost_id_t v4 = *((void *)this + 11);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 29);
  *((void *)this + 29) = 0;
  if (v5) {
    MEMORY[0x1A6239270](v5, 0x1000C4049ECCB0CLL);
  }
  uint64_t v6 = *((void *)this + 28);
  *((void *)this + 28) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  unint64_t v7 = *((void *)this + 27);
  *((void *)this + 27) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = (uint64_t *)*((void *)this + 26);
  *((void *)this + 26) = 0;
  if (v8)
  {
    uint64_t v9 = (std::__shared_weak_count *)v8[3];
    if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    uint64_t v10 = v8[1];
    v8[1] = 0;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
    uint64_t v11 = *v8;
    *uint64_t v8 = 0;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    }
    MEMORY[0x1A6239270](v8, 0x20C40DC1BFBCFLL);
  }
  uint64_t v12 = (uint64_t *)*((void *)this + 25);
  *((void *)this + 25) = 0;
  if (v12)
  {
    uint64_t v13 = (std::__shared_weak_count *)v12[3];
    if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    uint64_t v14 = v12[1];
    v12[1] = 0;
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
    BOOL v15 = *v12;
    *uint64_t v12 = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
    MEMORY[0x1A6239270](v12, 0x20C40DC1BFBCFLL);
  }
  if (*((char *)this + 199) < 0) {
    operator delete(*((void **)this + 22));
  }
  float64x2_t v16 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
    uint64_t v17 = (std::__shared_weak_count *)*((void *)this + 16);
    if (!v17) {
      goto LABEL_39;
    }
  }
  else
  {
    uint64_t v17 = (std::__shared_weak_count *)*((void *)this + 16);
    if (!v17) {
      goto LABEL_39;
    }
  }
  if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
LABEL_39:
  uint64_t v18 = (std::__shared_weak_count *)*((void *)this + 14);
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  *(void *)this = &unk_1EF530C60;
  uint64_t v19 = (void *)*((void *)this + 1);
  if (v19)
  {
    *((void *)this + 2) = v19;
    operator delete(v19);
  }
}

uint64_t std::__shared_ptr_emplace<ggl::Stars::StarsPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Stars::StarsPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5891D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Stars::StarsPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5891D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::EarthCorona::BasePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::EarthCorona::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583388;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::EarthCorona::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583388;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::ARWalkingGeoTrackingMapEngineMode::buildLocationProvider(md::ARWalkingGeoTrackingMapEngineMode *this, md::MapEngine *a2)
{
}

void md::ARWalkingGeoTrackingMapEngineMode::~ARWalkingGeoTrackingMapEngineMode(md::ARWalkingGeoTrackingMapEngineMode *this)
{
  md::ARWalkingMapEngineMode::~ARWalkingMapEngineMode(this);
  JUMPOUT(0x1A6239270);
}

void md::DaVinciTransitMapEngineMode::willBecomeInactive(uint64_t a1, uint64_t a2, uint64_t a3)
{
  md::DaVinciBaseMapEngineMode::willBecomeInactive(a1, a2);
  uint64_t v5 = *(void **)(a2 + 896);
  uint64_t v6 = v5[7];
  uint64_t v7 = v5[8];
  if (v6 != v7)
  {
    while (*(_WORD *)v6 != 15)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_9;
      }
    }
  }
  if (v6 != v7)
  {
    uint64_t v8 = *(void *)(v6 + 8);
    if (v8)
    {
      if (*(unsigned char *)(v8 + 21)) {
        *(unsigned char *)(v8 + 21) = 0;
      }
    }
  }
LABEL_9:
  uint64_t v10 = v5[4];
  uint64_t v9 = v5[5];
  if (v10 != v9)
  {
    while (*(_WORD *)v10 != 15)
    {
      v10 += 16;
      if (v10 == v9) {
        goto LABEL_18;
      }
    }
  }
  if (v10 != v9)
  {
    uint64_t v11 = *(void *)(v10 + 8);
    if (v11)
    {
      if (*(unsigned char *)(v11 + 600))
      {
        *(unsigned char *)(v11 + 600) = 0;
        uint64_t v12 = *(void *)(v11 + 16);
        for (uint64_t i = *(void *)(v12 + 8); i != v12; uint64_t i = *(void *)(i + 8))
          *(void *)(*(void *)(i + 128) + 152) = 1;
      }
    }
  }
LABEL_18:
  uint64_t v14 = *(void *)(*(void *)(a3 + 856) + 40);
  uint64_t v16 = *(void *)(v14 + 152);
  uint64_t v15 = *(void *)(v14 + 160);
  *(unsigned char *)(v16 + 417) = 0;
  *(unsigned char *)(v15 + 417) = 0;
}

void md::DaVinciTransitMapEngineMode::didBecomeActive(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  md::DaVinciBaseMapEngineMode::didBecomeActive(a1, a2, a3, a4);
  uint64_t v6 = *(void **)(a2 + 896);
  uint64_t v7 = v6[7];
  uint64_t v8 = v6[8];
  if (v7 != v8)
  {
    while (*(_WORD *)v7 != 15)
    {
      v7 += 16;
      if (v7 == v8) {
        goto LABEL_9;
      }
    }
  }
  if (v7 != v8)
  {
    uint64_t v9 = *(void *)(v7 + 8);
    if (v9)
    {
      if (!*(unsigned char *)(v9 + 21)) {
        *(unsigned char *)(v9 + 21) = 1;
      }
    }
  }
LABEL_9:
  uint64_t v11 = v6[4];
  uint64_t v10 = v6[5];
  if (v11 != v10)
  {
    while (*(_WORD *)v11 != 15)
    {
      v11 += 16;
      if (v11 == v10) {
        goto LABEL_18;
      }
    }
  }
  if (v11 != v10)
  {
    uint64_t v12 = *(void *)(v11 + 8);
    if (v12)
    {
      if (!*(unsigned char *)(v12 + 600))
      {
        *(unsigned char *)(v12 + 600) = 1;
        uint64_t v13 = *(void *)(v12 + 16);
        for (uint64_t i = *(void *)(v13 + 8); i != v13; uint64_t i = *(void *)(i + 8))
          *(void *)(*(void *)(i + 128) + 152) = 1;
      }
    }
  }
LABEL_18:
  uint64_t v15 = *(void *)(*(void *)(a3 + 856) + 40);
  uint64_t v17 = *(void *)(v15 + 152);
  uint64_t v16 = *(void *)(v15 + 160);
  *(unsigned char *)(v17 + 417) = 1;
  *(unsigned char *)(v16 + 417) = 1;
}

void md::DaVinciTransitMapEngineMode::~DaVinciTransitMapEngineMode(md::DaVinciTransitMapEngineMode *this)
{
  *(void *)this = &unk_1EF544D70;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 72);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::MapEngineMode::~MapEngineMode(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF544D70;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 72);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::MapEngineMode::~MapEngineMode(this);
}

void md::DaVinciTransitMapEngineMode::DaVinciTransitMapEngineMode(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a4 + 8), 1uLL, memory_order_relaxed);
  }
  md::DaVinciMapEngineMode::DaVinciMapEngineMode(a1, 13, a2, a3, a4);
}

void sub_1A253E8AC(_Unwind_Exception *a1)
{
  *(void *)uint64_t v1 = &unk_1EF544D70;
  uint64_t v3 = (std::__shared_weak_count *)*((void *)v1 + 72);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  md::MapEngineMode::~MapEngineMode(v1);
  _Unwind_Resume(a1);
}

void md::ARWalkingExtrudedTextLabelPart::populateDebugNode(md::ARWalkingExtrudedTextLabelPart *this, gdc::DebugTreeNode *a2)
{
  os_signpost_id_t v4 = (char *)operator new(0x20uLL);
  int64x2_t v22 = v4;
  long long v23 = xmmword_1A28FD1A0;
  strcpy(v4, "ARWalkingExtrudedTextLabelPart");
  ChildNode = gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)&v22);
  operator delete(v4);
  uint64_t v6 = (char *)operator new(0x20uLL);
  int64x2_t v22 = v6;
  long long v23 = xmmword_1A28FCDC0;
  strcpy(v6, "StagingExtrusionCollapseAngle");
  float v7 = *((float *)this + 293);
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v18 = 0;
  int v21 = 2;
  double v17 = v7;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)&v22, (uint64_t)v16);
  operator delete(v6);
  uint64_t v8 = (char *)operator new(0x20uLL);
  int64x2_t v22 = v8;
  long long v23 = xmmword_1A28FCDC0;
  strcpy(v8, "DisplayExtrusionCollapseAngle");
  float v9 = *((float *)this + 294);
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v12 = 0;
  int v15 = 2;
  double v11 = v9;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)&v22, (uint64_t)v10);
  operator delete(v8);
  md::HorizontalTextLabelPart::populateDebugNode(this, (gdc::DebugTreeNode *)ChildNode);
}

float md::HorizontalTextLabelPart::bottomLayoutMargin(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 960;
  if (a2) {
    uint64_t v2 = a1 + 1032;
  }
  return *(float *)(v2 + 56);
}

float md::HorizontalTextLabelPart::topLayoutMargin(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 960;
  if (a2) {
    uint64_t v2 = a1 + 1032;
  }
  return *(float *)(v2 + 52);
}

uint64_t md::HorizontalTextLabelPart::partType(md::HorizontalTextLabelPart *this)
{
  return 4;
}

uint64_t md::ARWalkingExtrudedTextLabelPart::layoutForDisplay(float32x2_t *a1, double *a2, md::LabelAnimator *a3, float32x2_t *a4, float32x2_t *a5, double a6, double a7, double a8, float64x2_t a9)
{
  uint64_t v11 = md::HorizontalTextLabelPart::layoutForDisplay(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, a9);
  if (v11 == 37)
  {
    float v12 = a1[96].f32[0];
    float v13 = a1[147].f32[0];
    if (v13 <= 3.0)
    {
LABEL_10:
      a1[113].f32[1] = v12;
      a1[108].i8[2] = v12 >= 0.0001;
      return v11;
    }
    float32x2_t v14 = a1[2];
    if (*(unsigned char *)(*(void *)&v14 + 164))
    {
      double v15 = *(float *)(*(void *)&v14 + 152);
      double v16 = *(float *)(*(void *)&v14 + 156);
      double v17 = *(float *)(*(void *)&v14 + 160);
      if (!a1[146].i8[0])
      {
LABEL_6:
        double v30 = a2[72] - *(double *)(*(void *)&v14 + 408);
        double v31 = a2[73] - *(double *)(*(void *)&v14 + 416);
        double v32 = a2[74] - *(double *)(*(void *)&v14 + 424);
        float v33 = acos(fabs((v31 * v16 + v32 * v17 + v30 * v15) / sqrt(v30 * v30 + v31 * v31 + v32 * v32)))
            * 57.2957795
            / v13;
        float v34 = fmaxf(v33, 0.0);
        if (v34 <= 1.0) {
          float v35 = 1.0 - v34;
        }
        else {
          float v35 = 0.0;
        }
        float v12 = v12 - (float)(v35 * v12);
        goto LABEL_10;
      }
    }
    else
    {
      double v15 = 1.0;
      double v16 = 0.0;
      double v17 = 0.0;
      if (!a1[146].i8[0]) {
        goto LABEL_6;
      }
    }
    double v18 = *(double *)(*(void *)&v14 + 864);
    double v19 = *(double *)(*(void *)&v14 + 872);
    double v20 = *(double *)(*(void *)&v14 + 880);
    double v21 = 0.382683432 / sqrt(v18 * v18 + v19 * v19 + v20 * v20);
    double v22 = v21 * v18;
    double v23 = v21 * v19;
    double v24 = v21 * v20;
    double v25 = -(v22 * v17 - v24 * v15);
    double v26 = -(v23 * v15 - v22 * v16);
    double v27 = -(v24 * v16 - v23 * v17) - (v24 * v16 - v23 * v17);
    double v28 = v25 - (v22 * v17 - v24 * v15);
    double v29 = v26 - (v23 * v15 - v22 * v16);
    double v15 = v15 + -(v24 * v16 - v23 * v17) * 1.84775907 + v29 * v23 - v28 * v24;
    double v16 = v16 + v25 * 1.84775907 + v27 * v24 - v29 * v22;
    double v17 = v17 + v26 * 1.84775907 + v28 * v22 - v27 * v23;
    goto LABEL_6;
  }
  return v11;
}

void md::ARWalkingExtrudedTextLabelPart::updateForDisplay(md::ARWalkingExtrudedTextLabelPart *this)
{
  md::TextLabelPart::updateForDisplay(this);
  int v2 = *((unsigned __int8 *)this + 1026);
  if (*((unsigned __int8 *)this + 1098) != v2)
  {
    *((unsigned char *)this + 1098) = v2;
    *((unsigned char *)this + 1099) = 1;
  }
  int v3 = *((_DWORD *)this + 244);
  if (*((_DWORD *)this + 262) != v3)
  {
    *((_DWORD *)this + 262) = v3;
    *((unsigned char *)this + 1099) = 1;
  }
  int v4 = *((_DWORD *)this + 245);
  if (*((_DWORD *)this + 263) != v4)
  {
    *((_DWORD *)this + 263) = v4;
    *((unsigned char *)this + 1099) = 1;
  }
  float v5 = *((float *)this + 241);
  if (*((float *)this + 259) != v5)
  {
    *((float *)this + 259) = v5;
    *((unsigned char *)this + 1099) = 1;
  }
  *((unsigned char *)this + 556) = 4 * *((unsigned char *)this + 1029);
  *((_DWORD *)this + 294) = *((_DWORD *)this + 293);
}

uint64_t md::ARWalkingExtrudedTextLabelPart::updateWithStyle(uint64_t **this, md::LabelManager *a2)
{
  md::HorizontalTextLabelPart::updateWithStyle(this, a2);
  uint64_t result = *this[4];
  BOOL v4 = *((unsigned __int8 *)this + 864) == 1;
  uint64_t v5 = result + 280;
  if (*((unsigned char *)this + 864) == 1) {
    uint64_t v6 = 6;
  }
  else {
    uint64_t v6 = 0;
  }
  float v7 = *(float **)(v5 + 8 * (*((unsigned char *)this + 864) == 1));
  if (v7)
  {
    if (vabds_f32(v7[2], *(float *)(result + 104)) >= 0.01)
    {
      uint64_t result = (uint64_t)md::LabelStyle::updateStyleGroup<md::LabelTextStyleGroup>((unsigned __int8 *)result, (uint64_t)v7, v6);
      float v7 = *(float **)(v5 + 8 * v4);
    }
  }
  else
  {
    uint64_t result = md::LabelStyle::prepareStyleGroup<md::LabelTextStyleGroup>(result, v6);
    float v7 = (float *)result;
    *(void *)(v5 + 8 * v4) = result;
  }
  *((_DWORD *)this + 293) = *(_DWORD *)(*(void *)v7 + 28);
  return result;
}

void md::ARWalkingExtrudedTextLabelPart::~ARWalkingExtrudedTextLabelPart(md::ARWalkingExtrudedTextLabelPart *this)
{
  md::TextLabelPart::~TextLabelPart(this);
  uint64_t v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  int v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

uint64_t std::__function::__func<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1,std::allocator<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&)>::operator()(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  uint64_t v6 = HIDWORD(*v5);
  uint64_t v7 = (*v5 << 32) | 1;
  v11[0] = &unk_1EF522940;
  v11[1] = v7;
  int v12 = v6;
  double v16 = v14;
  float v13 = v11;
  v14[0] = &unk_1EF522940;
  v14[1] = v7;
  int v15 = v6;
  int v17 = 0;
  ecs2::Runtime::queueCommand(v8, (uint64_t)v14);
  if (v17 != -1) {
    ((void (*)(char *, void *))off_1EF590BA8[v17])(&v10, v14);
  }
  int v17 = -1;
  if (v13 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v13)
  {
    (*(void (**)(void))(*v13 + 40))();
  }
  return std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>(*(void *)(a1 + 16), *a3, *a3);
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)3>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)3> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  BOOL v4 = (void *)gdc::Registry::storage<md::ls::SliceAssignmentT<(md::SliceType)3>>(a2);
  int v5 = *(_DWORD *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    float v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      int v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 2;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 62) {
        goto LABEL_34;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 1 > v17) {
        unint64_t v17 = v18 >> 1;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v19 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 62) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        double v20 = operator new(4 * v19);
      }
      else
      {
        double v20 = 0;
      }
      double v21 = &v20[4 * v16];
      double v22 = &v20[4 * v19];
      *double v21 = v5;
      float32x2_t v14 = v21 + 1;
      if (v13 != v15)
      {
        unint64_t v23 = v13 - v15 - 4;
        if (v23 < 0x2C) {
          goto LABEL_38;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_38;
        }
        uint64_t v24 = (v23 >> 2) + 1;
        double v25 = &v20[4 * v16 - 16];
        double v26 = v13 - 16;
        uint64_t v27 = v24 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *double v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 8;
        }
        while (v27);
        v21 -= v24 & 0x7FFFFFFFFFFFFFF8;
        v13 -= 4 * (v24 & 0x7FFFFFFFFFFFFFF8);
        if (v24 != (v24 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_38:
          do
          {
            int v29 = *((_DWORD *)v13 - 1);
            v13 -= 4;
            *--double v21 = v29;
          }
          while (v13 != v15);
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(_DWORD *)float v13 = v5;
      float32x2_t v14 = v13 + 4;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (_DWORD *)(v4[10] + (((uint64_t)v6 - v4[7]) >> 1));
    *uint64_t v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (_DWORD *)v4[11])
    {
      char v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          float v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          char v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_33:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_34:
        abort();
      }
      return;
    }
  }
  double v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      float v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      double v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_33;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)3>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)3> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522940;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)3>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)3> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF522940;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)3>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)3> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1,std::allocator<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51F730;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1,std::allocator<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51F730;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1,std::allocator<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0,std::allocator<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&)>::operator()(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  int v5 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  uint64_t v6 = HIDWORD(*v5);
  uint64_t v7 = (*v5 << 32) | 1;
  v11[0] = &unk_1EF522940;
  v11[1] = v7;
  int v12 = v6;
  uint64_t v16 = v14;
  float v13 = v11;
  v14[0] = &unk_1EF522940;
  v14[1] = v7;
  int v15 = v6;
  int v17 = 0;
  ecs2::Runtime::queueCommand(v8, (uint64_t)v14);
  if (v17 != -1) {
    ((void (*)(char *, void *))off_1EF590BA8[v17])(&v10, v14);
  }
  int v17 = -1;
  if (v13 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v13)
  {
    (*(void (**)(void))(*v13 + 40))();
  }
  return std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>(*(void *)(a1 + 16), *a3, *a3);
}

__n128 std::__function::__func<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0,std::allocator<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51F6E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0,std::allocator<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51F6E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0,std::allocator<md::ita::PrepareShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::VisibilityGroupID const&,md::ls::CanCastShadow const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&)>::~__func()
{
}

void *std::function<void ()(md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::ita::PrepareCulledShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*>)::$_0,std::allocator<md::ita::PrepareCulledShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4, unint64_t *a5, uint64_t *a6, long long *a7, float **a8, float **a9)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *a6;
  float v13 = *a8;
  float32x2_t v14 = *a9;
  uint64_t RenderableData = md::VKMRenderResourcesStore::getRenderableData(**(void **)(a1 + 8), *a5);
  long long v25 = 0uLL;
  uint64_t v26 = 0;
  if (v12)
  {
    long long v25 = *(_OWORD *)(RenderableData + 256);
    uint64_t v16 = *(void *)(RenderableData + 272);
  }
  else if (v13 && v14)
  {
    float v17 = *v14 + (float)(*((float *)a7 + 2) * *v13);
    float v18 = *v14 + (float)(*((float *)a7 + 5) * *v13);
    *(void *)uint64_t v31 = *(void *)a7;
    *(float *)&v31[8] = v17;
    *(void *)&v31[12] = *(void *)((char *)a7 + 12);
    *(float *)&v31[20] = v18;
    long long v25 = *(_OWORD *)v31;
    uint64_t v16 = *(void *)&v31[16];
  }
  else
  {
    long long v25 = *a7;
    uint64_t v16 = *((void *)a7 + 2);
  }
  uint64_t v26 = v16;
  uint64_t result = geo::Intersect::encloses<float>((float *)RenderableData, (float *)&v25);
  if (result)
  {
    double v20 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v21 = HIDWORD(*v20);
    uint64_t v22 = (*v20 << 32) | 1;
    v28[0] = &unk_1EF522988;
    v28[1] = v22;
    int v29 = v21;
    uint64_t v32 = v31;
    double v30 = v28;
    *(void *)uint64_t v31 = &unk_1EF522988;
    *(void *)&v31[8] = v22;
    *(_DWORD *)&v31[16] = v21;
    int v33 = 0;
    ecs2::Runtime::queueCommand(v23, (uint64_t)v31);
    if (v33 != -1) {
      ((void (*)(char *, unsigned char *))off_1EF590BA8[v33])(&v27, v31);
    }
    int v33 = -1;
    if (v30 == v28)
    {
      (*(void (**)(void *))(v28[0] + 32))(v28);
    }
    else if (v30)
    {
      (*(void (**)(void *, uint64_t))(*v30 + 40))(v30, v24);
    }
    return std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>(*(void *)(a1 + 24), *a4, *a4);
  }
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)4>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)4> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  BOOL v4 = (void *)gdc::Registry::storage<md::ls::SliceAssignmentT<(md::SliceType)4>>(a2);
  int v5 = *(_DWORD *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    float v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      int v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 2;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 62) {
        goto LABEL_34;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 1 > v17) {
        unint64_t v17 = v18 >> 1;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v19 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 62) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        double v20 = operator new(4 * v19);
      }
      else
      {
        double v20 = 0;
      }
      uint64_t v21 = &v20[4 * v16];
      uint64_t v22 = &v20[4 * v19];
      *uint64_t v21 = v5;
      float32x2_t v14 = v21 + 1;
      if (v13 != v15)
      {
        unint64_t v23 = v13 - v15 - 4;
        if (v23 < 0x2C) {
          goto LABEL_38;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_38;
        }
        uint64_t v24 = (v23 >> 2) + 1;
        long long v25 = &v20[4 * v16 - 16];
        uint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *long long v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 8;
        }
        while (v27);
        v21 -= v24 & 0x7FFFFFFFFFFFFFF8;
        v13 -= 4 * (v24 & 0x7FFFFFFFFFFFFFF8);
        if (v24 != (v24 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_38:
          do
          {
            int v29 = *((_DWORD *)v13 - 1);
            v13 -= 4;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(_DWORD *)float v13 = v5;
      float32x2_t v14 = v13 + 4;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (_DWORD *)(v4[10] + (((uint64_t)v6 - v4[7]) >> 1));
    *uint64_t v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (_DWORD *)v4[11])
    {
      char v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          uint64_t v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          char v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_33:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_34:
        abort();
      }
      return;
    }
  }
  double v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      uint64_t v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      double v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_33;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)4>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)4> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522988;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)4>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)4> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF522988;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)4>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)4> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::PrepareCulledShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*>)::$_0,std::allocator<md::ita::PrepareCulledShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51FCD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::PrepareCulledShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*>)::$_0,std::allocator<md::ita::PrepareCulledShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF51FCD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<md::ita::PrepareCulledShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*>)::$_0,std::allocator<md::ita::PrepareCulledShadowSlice::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1,std::allocator<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1>,void ()(md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&)>::operator()(uint64_t a1, unint64_t *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  BOOL v4 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  uint64_t v5 = HIDWORD(*v4);
  uint64_t v6 = (*v4 << 32) | 1;
  v10[0] = &unk_1EF5229D0;
  v10[1] = v6;
  int v11 = v5;
  int v15 = v13;
  unint64_t v12 = v10;
  v13[0] = &unk_1EF5229D0;
  v13[1] = v6;
  int v14 = v5;
  int v16 = 0;
  ecs2::Runtime::queueCommand(v7, (uint64_t)v13);
  if (v16 != -1) {
    ((void (*)(char *, void *))off_1EF590BA8[v16])(&v9, v13);
  }
  int v16 = -1;
  if (v12 == v10)
  {
    (*(void (**)(void *))(v10[0] + 32))(v10);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  return std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>(*(void *)(a1 + 16), *a2, *a2);
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)5>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)5> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  BOOL v4 = (void *)gdc::Registry::storage<md::ls::SliceAssignmentT<(md::SliceType)5>>(a2);
  int v5 = *(_DWORD *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    float v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      int v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 2;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 62) {
        goto LABEL_34;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 1 > v17) {
        unint64_t v17 = v18 >> 1;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v19 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 62) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        double v20 = operator new(4 * v19);
      }
      else
      {
        double v20 = 0;
      }
      uint64_t v21 = &v20[4 * v16];
      uint64_t v22 = &v20[4 * v19];
      *uint64_t v21 = v5;
      int v14 = v21 + 1;
      if (v13 != v15)
      {
        unint64_t v23 = v13 - v15 - 4;
        if (v23 < 0x2C) {
          goto LABEL_38;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_38;
        }
        uint64_t v24 = (v23 >> 2) + 1;
        long long v25 = &v20[4 * v16 - 16];
        uint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *long long v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 8;
        }
        while (v27);
        v21 -= v24 & 0x7FFFFFFFFFFFFFF8;
        v13 -= 4 * (v24 & 0x7FFFFFFFFFFFFFF8);
        if (v24 != (v24 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_38:
          do
          {
            int v29 = *((_DWORD *)v13 - 1);
            v13 -= 4;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(_DWORD *)float v13 = v5;
      int v14 = v13 + 4;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (_DWORD *)(v4[10] + (((uint64_t)v6 - v4[7]) >> 1));
    *uint64_t v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (_DWORD *)v4[11])
    {
      char v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          uint64_t v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          char v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_33:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_34:
        abort();
      }
      return;
    }
  }
  double v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      uint64_t v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      double v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_33;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)5>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)5> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5229D0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)5>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)5> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF5229D0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)5>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)5> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1,std::allocator<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1>,void ()(md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF520420;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1,std::allocator<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1>,void ()(md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF520420;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1,std::allocator<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_1>,void ()(md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&)>::~__func()
{
}

uint64_t std::__function::__func<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0,std::allocator<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0>,void ()(md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&)>::operator()(uint64_t a1, unint64_t *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  BOOL v4 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  uint64_t v5 = HIDWORD(*v4);
  uint64_t v6 = (*v4 << 32) | 1;
  v10[0] = &unk_1EF5229D0;
  v10[1] = v6;
  int v11 = v5;
  int v15 = v13;
  unint64_t v12 = v10;
  v13[0] = &unk_1EF5229D0;
  v13[1] = v6;
  int v14 = v5;
  int v16 = 0;
  ecs2::Runtime::queueCommand(v7, (uint64_t)v13);
  if (v16 != -1) {
    ((void (*)(char *, void *))off_1EF590BA8[v16])(&v9, v13);
  }
  int v16 = -1;
  if (v12 == v10)
  {
    (*(void (**)(void *))(v10[0] + 32))(v10);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  return std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>(*(void *)(a1 + 16), *a2, *a2);
}

__n128 std::__function::__func<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0,std::allocator<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0>,void ()(md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5203D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0,std::allocator<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0>,void ()(md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5203D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0,std::allocator<md::ita::PrepareCulledDepthPrePassSlice::operator()(ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>,ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>)::$_0>,void ()(md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&)>::~__func()
{
}

uint64_t md::AssetData::estimatedCost(md::AssetData *this)
{
  return *((void *)this + 22);
}

void md::AssetData::~AssetData(md::AssetData *this)
{
  md::AssetData::~AssetData(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  std::__shared_weak_count *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  std::__shared_weak_count *v24;
  void *v25;
  void *v26;
  void **v27;

  *(void *)this = &unk_1EF553F28;
  uint64_t v2 = (uint64_t *)*((void *)this + 61);
  if (v2)
  {
    do
    {
      char v7 = (uint64_t *)*v2;
      uint64_t v8 = v2[3];
      if (v8)
      {
        v2[4] = v8;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[6] + 40))(v2[6], v8, v2[5] - v8);
      }
      (*(void (**)(void, uint64_t *, uint64_t))(**((void **)this + 62) + 40))(*((void *)this + 62), v2, 56);
      uint64_t v2 = v7;
    }
    while (v7);
  }
  uint64_t v3 = *((void *)this + 58);
  *((void *)this + 58) = 0;
  if (v3) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 60) + 40))(*((void *)this + 60), v3, 8 * *((void *)this + 59));
  }
  BOOL v4 = (void *)*((void *)this + 53);
  if (v4)
  {
    uint64_t v5 = (void *)*((void *)this + 54);
    uint64_t v6 = (void *)*((void *)this + 53);
    if (v5 != v4)
    {
      do
      {
        char v9 = (void *)*(v5 - 3);
        if (v9)
        {
          do
          {
            char v10 = (void *)*v9;
            operator delete(v9);
            char v9 = v10;
          }
          while (v10);
        }
        unint64_t v12 = (void *)*(v5 - 5);
        v5 -= 5;
        int v11 = v12;
        *uint64_t v5 = 0;
        if (v12) {
          operator delete(v11);
        }
      }
      while (v5 != v4);
      uint64_t v6 = (void *)*((void *)this + 53);
    }
    *((void *)this + 54) = v4;
    operator delete(v6);
  }
  float v13 = (void *)*((void *)this + 50);
  if (v13)
  {
    do
    {
      int v16 = (void *)*v13;
      uint64_t v17 = (void *)v13[3];
      if (v17)
      {
        v13[4] = v17;
        operator delete(v17);
      }
      operator delete(v13);
      float v13 = v16;
    }
    while (v16);
  }
  int v14 = (void *)*((void *)this + 48);
  *((void *)this + 48) = 0;
  if (v14) {
    operator delete(v14);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 45));
  int v15 = (void *)*((void *)this + 41);
  while (v15)
  {
    uint64_t v18 = v15;
    int v15 = (void *)*v15;
    unint64_t v19 = (std::__shared_weak_count *)v18[4];
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    operator delete(v18);
  }
  double v20 = (void *)*((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v20) {
    operator delete(v20);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 33));
  uint64_t v21 = *((void *)this + 29);
  if (v21)
  {
    uint64_t v22 = *((void *)this + 30);
    unint64_t v23 = (void *)*((void *)this + 29);
    if (v22 != v21)
    {
      do
      {
        uint64_t v24 = *(std::__shared_weak_count **)(v22 - 8);
        if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
        v22 -= 16;
      }
      while (v22 != v21);
      unint64_t v23 = (void *)*((void *)this + 29);
    }
    *((void *)this + 30) = v21;
    operator delete(v23);
  }
  long long v25 = (void *)*((void *)this + 26);
  if (v25)
  {
    *((void *)this + 27) = v25;
    operator delete(v25);
  }
  uint64_t v27 = (void **)((char *)this + 184);
  std::vector<md::Mesh>::__destroy_vector::operator()[abi:nn180100](&v27);
  *(void *)this = &unk_1EF558F70;
  if (*((unsigned char *)this + 112)) {
    *((unsigned char *)this + 112) = 0;
  }
  uint64_t v26 = (void *)*((void *)this + 4);
  if (v26 != *((void **)this + 6)) {
    free(v26);
  }
}

void *std::vector<std::unordered_map<unsigned short,unsigned long long>>::~vector[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)*a1;
  if (*a1)
  {
    uint64_t v3 = (void *)a1[1];
    BOOL v4 = (void *)*a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = (void *)*(v3 - 3);
        if (v5)
        {
          do
          {
            uint64_t v6 = (void *)*v5;
            operator delete(v5);
            uint64_t v5 = v6;
          }
          while (v6);
        }
        uint64_t v8 = (void *)*(v3 - 5);
        v3 -= 5;
        char v7 = v8;
        *uint64_t v3 = 0;
        if (v8) {
          operator delete(v7);
        }
      }
      while (v3 != v2);
      BOOL v4 = (void *)*a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void std::__function::__func<md::AssetData::AssetData(gdc::LayerDataRequestKey const&,std::shared_ptr<md::DaVinciAssetResource> &,VKSharedResources *)::$_0,std::allocator<md::AssetData::AssetData(gdc::LayerDataRequestKey const&,std::shared_ptr<md::DaVinciAssetResource> &,VKSharedResources *)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, const char **a2)
{
}

void md::AssetData::_buildAssets(uint64_t a1, uint64_t *a2, const char *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(*a2 + 152);
  if (v4)
  {
    uint64_t j = a1;
    uint64_t v8 = *(void *)(v4 + 120);
    uint64_t v7 = *(void *)(v4 + 128);
    v499 = *(uint64_t **)(*a2 + 152);
    *(_WORD *)(a1 + 304) = *(_WORD *)(v4 + 302);
    char v9 = (void *)(a1 + 312);
    if (a1 + 312 != v3 + 160)
    {
      *(_DWORD *)(a1 + 344) = *(_DWORD *)(v3 + 192);
      char v10 = *(void **)(v3 + 176);
      uint64_t v11 = *(void *)(a1 + 320);
      if (!v11) {
        goto LABEL_15;
      }
      for (uint64_t i = 0; i != v11; *(void *)(*v9 + 8 * i++) = 0)
        ;
      float v13 = *(void **)(a1 + 328);
      *(void *)(a1 + 328) = 0;
      *(void *)(a1 + 336) = 0;
      if (v13)
      {
        while (v10)
        {
          void v13[2] = v10[2];
          uint64_t v16 = v10[3];
          uint64_t v15 = v10[4];
          if (v15) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v17 = (std::__shared_weak_count *)v13[4];
          v13[3] = v16;
          v13[4] = v15;
          if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
          int v14 = (void *)*v13;
          std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__node_insert_multi((uint64_t)v9, v13);
          char v10 = (void *)*v10;
          float v13 = v14;
          if (!v14) {
            goto LABEL_15;
          }
        }
        uint64_t j = a1;
        do
        {
          float32x4_t v53 = v13;
          float v13 = (void *)*v13;
          float64x2_t v54 = (std::__shared_weak_count *)v53[4];
          if (v54 && !atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
            std::__shared_weak_count::__release_weak(v54);
          }
          operator delete(v53);
        }
        while (v13);
      }
      else
      {
LABEL_15:
        for (j = a1; v10; char v10 = (void *)*v10)
        {
          uint64_t v18 = operator new(0x28uLL);
          *uint64_t v18 = 0;
          v18[1] = 0;
          uint64_t v19 = v10[2];
          v18[2] = v19;
          v18[3] = v10[3];
          uint64_t v20 = v10[4];
          v18[4] = v20;
          if (v20) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
          }
          v18[1] = v19;
          std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__node_insert_multi((uint64_t)v9, v18);
        }
      }
    }
    uint64_t v21 = j + 280;
    unint64_t v496 = v7 - v8;
    uint64_t v22 = (unint64_t *)v499[7];
    unint64_t v23 = (unint64_t *)v499[8];
    if (v22 != v23)
    {
      uint64_t v24 = (uint64_t **)(j + 264);
      do
      {
        uint64_t v26 = *v24;
        unint64_t v27 = *v22;
        long long v28 = (uint64_t **)(j + 264);
        int v29 = (uint64_t **)(j + 264);
        if (*v24)
        {
          while (1)
          {
            while (1)
            {
              int v29 = (uint64_t **)v26;
              unint64_t v30 = v26[4];
              if (v27 >= v30) {
                break;
              }
              uint64_t v26 = *v29;
              long long v28 = v29;
              if (!*v29) {
                goto LABEL_31;
              }
            }
            if (v30 >= v27) {
              break;
            }
            uint64_t v26 = v29[1];
            if (!v26)
            {
              long long v28 = v29 + 1;
              goto LABEL_31;
            }
          }
        }
        else
        {
LABEL_31:
          uint64_t v31 = (uint64_t *)operator new(0x28uLL);
          v31[4] = v27;
          *uint64_t v31 = 0;
          v31[1] = 0;
          v31[2] = (uint64_t)v29;
          *long long v28 = v31;
          uint64_t v32 = **(void **)(j + 256);
          if (v32)
          {
            *(void *)(j + 256) = v32;
            long long v25 = *v28;
          }
          else
          {
            long long v25 = v31;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(j + 264), v25);
          ++*(void *)(j + 272);
        }
        ++v22;
      }
      while (v22 != v23);
    }
    *(_DWORD *)(j + 280) = *((_DWORD *)v499 + 69);
    *(_DWORD *)(j + 284) = *((_DWORD *)v499 + 70);
    *(_DWORD *)(j + 288) = *((_DWORD *)v499 + 71);
    *(_DWORD *)(j + 292) = *((_DWORD *)v499 + 72);
    *(_DWORD *)(j + 296) = *((_DWORD *)v499 + 73);
    *(_DWORD *)(j + 300) = *((_DWORD *)v499 + 74);
    *(_DWORD *)(j + 448) = *((_DWORD *)v499 + 66);
    *(_DWORD *)(j + 452) = *((_DWORD *)v499 + 67);
    *(_DWORD *)(j + 456) = *((_DWORD *)v499 + 68);
    uint64_t v33 = (void **)(j + 352);
    if ((uint64_t *)(j + 352) != v499 + 30)
    {
      uint64_t v34 = (void *)v499[30];
      uint64_t v35 = v499 + 31;
      if (!*(void *)(a1 + 368)) {
        goto LABEL_74;
      }
      uint64_t v36 = (uint64_t **)(a1 + 360);
      uint64_t v37 = *(void *)(a1 + 352);
      uint64_t v38 = *(void *)(a1 + 360);
      *(void *)(a1 + 352) = a1 + 360;
      *(void *)(v38 + 16) = 0;
      *(void *)(a1 + 360) = 0;
      *(void *)(a1 + 368) = 0;
      float32x4_t v39 = *(void *)(v37 + 8) ? *(void **)(v37 + 8) : (void *)v37;
      if (v39)
      {
        float32x4_t v40 = (void *)v39[2];
        if (v40)
        {
          int16x8_t v41 = (void *)*v40;
          if ((void *)*v40 == v39)
          {
            *float32x4_t v40 = 0;
            while (1)
            {
              v460 = (void *)v40[1];
              if (!v460) {
                break;
              }
              do
              {
                float32x4_t v40 = v460;
                v460 = (void *)*v460;
              }
              while (v460);
            }
          }
          else
          {
            for (v40[1] = 0; v41; int16x8_t v41 = (void *)v40[1])
            {
              do
              {
                float32x4_t v40 = v41;
                int16x8_t v41 = (void *)*v41;
              }
              while (v41);
            }
          }
        }
        if (v34 == v35)
        {
          int8x16_t v49 = v34;
          unint64_t v42 = v39;
        }
        else
        {
          do
          {
            unint64_t v42 = v40;
            unsigned int v43 = *(_DWORD *)((char *)v34 + 26);
            *(_DWORD *)((char *)v39 + 26) = v43;
            *((unsigned char *)v39 + 30) = *((unsigned char *)v34 + 30);
            uint32x4_t v44 = *v36;
            uint32x4_t v45 = (void *)(a1 + 360);
            uint32x4_t v46 = (void *)(a1 + 360);
            if (*v36)
            {
              do
              {
                while (1)
                {
                  uint32x4_t v45 = v44;
                  if (*((unsigned __int16 *)v44 + 14) <= HIWORD(v43)) {
                    break;
                  }
                  uint32x4_t v44 = (uint64_t *)*v44;
                  uint32x4_t v46 = v45;
                  if (!*v45) {
                    goto LABEL_52;
                  }
                }
                uint32x4_t v44 = (uint64_t *)v44[1];
              }
              while (v44);
              uint32x4_t v46 = v45 + 1;
            }
LABEL_52:
            void *v39 = 0;
            v39[1] = 0;
            v39[2] = v45;
            *uint32x4_t v46 = v39;
            uint64_t v47 = (void *)**v33;
            if (v47)
            {
              *uint64_t v33 = v47;
              float32x4_t v39 = (void *)*v46;
            }
            std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 360), v39);
            ++*(void *)(a1 + 368);
            if (v40)
            {
              float32x4_t v40 = (void *)v40[2];
              if (v40)
              {
                float32x4_t v51 = (void *)*v40;
                if ((void *)*v40 == v42)
                {
                  *float32x4_t v40 = 0;
                  while (1)
                  {
                    float32x4_t v52 = (void *)v40[1];
                    if (!v52) {
                      break;
                    }
                    do
                    {
                      float32x4_t v40 = v52;
                      float32x4_t v52 = (void *)*v52;
                    }
                    while (v52);
                  }
                }
                else
                {
                  for (v40[1] = 0; v51; float32x4_t v51 = (void *)v40[1])
                  {
                    do
                    {
                      float32x4_t v40 = v51;
                      float32x4_t v51 = (void *)*v51;
                    }
                    while (v51);
                  }
                }
              }
            }
            else
            {
              float32x4_t v40 = 0;
            }
            uint32x4_t v48 = (void *)v34[1];
            if (v48)
            {
              do
              {
                int8x16_t v49 = v48;
                uint32x4_t v48 = (void *)*v48;
              }
              while (v48);
            }
            else
            {
              do
              {
                int8x16_t v49 = (void *)v34[2];
                _ZF = *v49 == (void)v34;
                uint64_t v34 = v49;
              }
              while (!_ZF);
            }
            if (!v42) {
              break;
            }
            float32x4_t v39 = v42;
            uint64_t v34 = v49;
          }
          while (v49 != v35);
        }
        std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v42);
        if (v40)
        {
          for (k = (void *)v40[2]; k; k = (void *)k[2])
            float32x4_t v40 = k;
          std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v40);
        }
      }
      else
      {
LABEL_74:
        int8x16_t v49 = v34;
      }
      if (v49 != v35)
      {
        float64x2_t v56 = (uint64_t ***)(a1 + 360);
        do
        {
          float64x2_t v57 = (char *)operator new(0x20uLL);
          float64x2_t v58 = (uint64_t *)v57;
          __int16 v59 = *((_WORD *)v49 + 15);
          *(_DWORD *)(v57 + 26) = *(_DWORD *)((char *)v49 + 26);
          *((_WORD *)v57 + 15) = v59;
          float64x2_t v60 = *v56;
          float64x2_t v61 = (uint64_t **)(a1 + 360);
          float64x2_t v62 = (uint64_t **)(a1 + 360);
          if (*v56)
          {
            do
            {
              while (1)
              {
                float64x2_t v61 = v60;
                if (*((unsigned __int16 *)v57 + 14) >= *((unsigned __int16 *)v60 + 14)) {
                  break;
                }
                float64x2_t v60 = (uint64_t **)*v60;
                float64x2_t v62 = v61;
                if (!*v61) {
                  goto LABEL_95;
                }
              }
              float64x2_t v60 = (uint64_t **)v60[1];
            }
            while (v60);
            float64x2_t v62 = v61 + 1;
          }
LABEL_95:
          *(void *)float64x2_t v57 = 0;
          *((void *)v57 + 1) = 0;
          *((void *)v57 + 2) = v61;
          *float64x2_t v62 = (uint64_t *)v57;
          float64x2_t v63 = (void *)**v33;
          if (v63)
          {
            *uint64_t v33 = v63;
            float64x2_t v58 = *v62;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 360), v58);
          ++*(void *)(a1 + 368);
          float64x2_t v64 = (void *)v49[1];
          if (v64)
          {
            do
            {
              float64x2_t v65 = v64;
              float64x2_t v64 = (void *)*v64;
            }
            while (v64);
          }
          else
          {
            do
            {
              float64x2_t v65 = (void *)v49[2];
              _ZF = *v65 == (void)v49;
              int8x16_t v49 = v65;
            }
            while (!_ZF);
          }
          int8x16_t v49 = v65;
        }
        while (v65 != v35);
      }
    }
    float64x2_t v66 = (void *)a1;
    *(void *)(a1 + 176) += *(void *)(*a2 + 144);
    float64x2_t v67 = operator new(0xCuLL);
    v68.i64[0] = *(void *)v21;
    v68.i32[2] = *(_DWORD *)(v21 + 8);
    v69.i64[0] = *(void *)(v21 + 12);
    v69.i32[2] = *(_DWORD *)(v21 + 20);
    float32x4_t v70 = vmaxnmq_f32(vabsq_f32(v68), vabsq_f32(v69));
    v67[2] = v70.i32[2];
    *(void *)float64x2_t v67 = v70.i64[0];
    uint64_t v71 = v70.f32[0] < v70.f32[1];
    if (fmaxf(v70.f32[0], v70.f32[1]) < v70.f32[2]) {
      uint64_t v71 = 2;
    }
    v489 = v67;
    float v72 = *(float *)&v67[v71];
    *(float *)(a1 + 376) = v72;
    float v73 = 32767.0 / v72;
    if (*(unsigned __int16 *)(a1 + 304) > 0x13u)
    {
      uint64_t v74 = v499[26];
      uint64_t v503 = v499[27];
      if (v74 != v503)
      {
        v501 = (_OWORD *)((char *)v499 + 276);
        do
        {
          long long v559 = 0uLL;
          uint64_t v560 = 0;
          uint64_t v554 = 0;
          uint64_t v555 = 0;
          uint64_t v556 = 0;
          uint64_t v557 = geo::codec::Allocator::instance((geo::codec::Allocator *)v67);
          v530[0] = 0;
          v530[1] = 0;
          long long v551 = 0u;
          long long v552 = 0u;
          int v553 = 1065353216;
          LODWORD(v547.__begin_) = 0;
          float64x2_t v75 = (md::DaVinciGroundTileData *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>((uint64_t)&v551, 0, &v547);
          *((_DWORD *)v75 + 5) = 0;
          if (*(void *)(v74 + 32) == *(void *)(v74 + 40))
          {
            md::DaVinciGroundTileData::_edgeSmoothingAngleForZ(v75);
            memset(&v547, 0, sizeof(v547));
            uint64_t v79 = *(void *)v74;
            uint64_t v80 = *(void *)(v74 + 8);
            uint64_t v82 = *(void *)(v74 + 96);
            uint64_t v81 = *(void *)(v74 + 104);
            float64x2_t v83 = (char *)operator new(0x10uLL);
            unint64_t v84 = (unint64_t)(v81 - v82) >> 1;
            v543 = v83 + 16;
            *(_DWORD *)float64x2_t v83 = 0;
            *(void *)(v83 + 4) = v84;
            v83[12] = 0;
            __p[0] = v83;
            __p[1] = v83 + 16;
            float64x2_t v85 = *(uint16x4_t **)(v74 + 96);
            HIBYTE(v538) = 5;
            strcpy((char *)v537, "Asset");
            md::DaVinciGroundTileData::_buildNormals(v79, -1431655765 * ((unint64_t)(v80 - v79) >> 2), v84, (uint64_t)__p, v85, (int)&v551, (int)&v559, (int)&v554, &v547, a1 + 208, (uint64_t)v537, 0);
          }
          uint64_t v76 = *(void *)(v74 + 8);
          if (v76 != *(void *)v74)
          {
            unint64_t v77 = 0xAAAAAAAAAAAAAAABLL * ((v76 - *(void *)v74) >> 2);
            if (v77 >> 61) {
              abort();
            }
            float64x2_t v78 = operator new(0x5555555555555558 * ((v76 - *(void *)v74) >> 2));
            *(void *)&long long v559 = v78;
            *((void *)&v559 + 1) = &v78[v77];
            uint64_t v560 = *((void *)&v559 + 1);
            if (*(void *)(v74 + 8) != *(void *)v74)
            {
              unint64_t v86 = 0;
              unsigned int v87 = 1;
              do
              {
                unint64_t v88 = v87;
                v78[v86] = v86 | ((unint64_t)v87++ << 32);
                unint64_t v86 = v88;
              }
              while (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v74 + 8) - *(void *)v74) >> 2) > v88);
            }
          }
          md::DaVinciGroundTileData::_buildIndexBuffer((md::DaVinciGroundTileData *)&v547, a3, *(ResourceAccessor **)(v74 + 96), (const unsigned __int16 *)((*(void *)(v74 + 104) - *(void *)(v74 + 96)) >> 1));
          *(_OWORD *)v530 = *(_OWORD *)&v547.__begin_;
          uint64_t v89 = *(void *)(v74 + 40);
          uint64_t v90 = *(void *)(v74 + 32);
          float64x2_t v91 = (std::__shared_weak_count *)operator new(0xF8uLL);
          v91->__shared_owners_ = 0;
          p_shared_owners = &v91->__shared_owners_;
          uint64_t v92 = -1431655765 * ((unint64_t)(v89 - v90) >> 2);
          v91->__shared_weak_owners_ = 0;
          v91->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585148;
          uint64_t v93 = (uint64_t)&v91[1];
          ggl::BufferData::BufferData((uint64_t)&v91[1], 8, 0, 0, 6, v92);
          v91[9].__shared_weak_owners_ = (uint64_t)"DV Asset Textured Vertex Data";
          v91[10].__vftable = (std::__shared_weak_count_vtbl *)&ggl::DaVinci::texturedCompressedVboReflection;
          v91[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55CDC8;
          v91[9].__shared_owners_ = (uint64_t)&unk_1EF55CDE8;
          float64x2_t v94 = v91;
          v505 = v91;
          float64x2_t v95 = (char *)operator new(0xE0uLL);
          *((void *)v95 + 1) = 0;
          v507 = (atomic_ullong *)(v95 + 8);
          *((void *)v95 + 2) = 0;
          *(void *)float64x2_t v95 = &unk_1EF584000;
          v519 = (uint64_t *)ggl::BufferData::BufferData((uint64_t)(v95 + 24), qword_1E9558BD0, 3, 0, 1, v92);
          *((void *)v95 + 3) = &unk_1EF55B9F0;
          v514 = (std::__shared_weak_count *)v95;
          float64x2_t v96 = operator new(0xE0uLL);
          *((void *)v96 + 1) = 0;
          *((void *)v96 + 2) = 0;
          *(void *)float64x2_t v96 = &unk_1EF583FC8;
          v516 = (uint64_t *)ggl::BufferData::BufferData((uint64_t)v96 + 24, qword_1E9558C10, 3, 0, 1, v92);
          *((void *)v96 + 3) = &unk_1EF55B9D0;
          v547.__end_ = 0;
          v547.__begin_ = 0;
          float64x2_t v97 = (unsigned int *)(v94[1].__shared_owners_ * v92);
          if (v97)
          {
            if (!a3 || BYTE1(v94[1].__shared_weak_owners_) == 2) {
              uint64_t v98 = (uint64_t)v94[4].__vftable;
            }
            else {
              uint64_t v98 = (*(uint64_t (**)(const char *, uint64_t, void, unsigned int *, uint64_t, uint64_t))(*(void *)a3 + 56))(a3, v93, 0, v97, 1, 1);
            }
          }
          else
          {
            uint64_t v98 = 0;
          }
          *(void *)&long long v99 = a3;
          *((void *)&v99 + 1) = v93;
          *(_OWORD *)&v547.__begin_ = v99;
          v547.__end_cap_.__value_ = 0;
          v548 = v97;
          uint64_t v550 = v98;
          __int16 v549 = 257;
          __p[1] = 0;
          __p[0] = 0;
          uint64_t v100 = *((void *)v95 + 4) * v92;
          if (v100)
          {
            if (!a3 || v95[41] == 2) {
              uint64_t v101 = *((void *)v95 + 12);
            }
            else {
              uint64_t v101 = (*(uint64_t (**)(const char *, uint64_t *, void, uint64_t, uint64_t, uint64_t))(*(void *)a3 + 56))(a3, v519, 0, *((void *)v95 + 4) * v92, 1, 1);
            }
          }
          else
          {
            uint64_t v101 = 0;
          }
          *(void *)&long long v102 = a3;
          *((void *)&v102 + 1) = v519;
          *(_OWORD *)__p = v102;
          v543 = 0;
          v544 = (char *)v100;
          uint64_t v546 = v101;
          __int16 v545 = 257;
          v537[1] = 0;
          v537[0] = 0;
          uint64_t v103 = *((void *)v96 + 4) * v92;
          if (v103)
          {
            if (!a3 || *((unsigned char *)v96 + 41) == 2) {
              uint64_t v104 = *((void *)v96 + 12);
            }
            else {
              uint64_t v104 = (*(uint64_t (**)(const char *, uint64_t *, void, uint64_t, uint64_t, uint64_t))(*(void *)a3 + 56))(a3, v516, 0, v103, 1, 1);
            }
          }
          else
          {
            uint64_t v104 = 0;
          }
          *(void *)&long long v105 = a3;
          *((void *)&v105 + 1) = v516;
          *(_OWORD *)v537 = v105;
          unint64_t v538 = 0;
          uint64_t v539 = v103;
          uint64_t v541 = v104;
          __int16 v540 = 257;
          float64x2_t v106 = (std::__shared_weak_count *)operator new(0xA8uLL);
          v106->__shared_owners_ = 0;
          float64x2_t v107 = &v106->__shared_owners_;
          v106->__shared_weak_owners_ = 0;
          v106->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5895C0;
          uint64_t v108 = (uint64_t)&v106[1];
          std::construct_at[abi:nn180100]<ggl::DaVinci::TexturedCompressedMesh,char const(&)[14],std::shared_ptr<ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>> &,std::shared_ptr<ggl::IndexData> &,ggl::DaVinci::TexturedCompressedMesh*>((uint64_t)&v106[1], v93, v94, (uint64_t *)v530);
          v536[0] = v519;
          v536[1] = (uint64_t *)v514;
          atomic_fetch_add_explicit(&v514->__shared_owners_, 1uLL, memory_order_relaxed);
          ggl::Mesh::setCustomDeviceData((uint64_t)&v106[1], v536, (uint64_t *)1);
          if (!atomic_fetch_add(&v514->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v514->__on_zero_shared)(v514);
            std::__shared_weak_count::__release_weak(v514);
          }
          v535[0] = v516;
          v535[1] = (uint64_t *)v96;
          atomic_fetch_add_explicit((atomic_ullong *volatile)v96 + 1, 1uLL, memory_order_relaxed);
          ggl::Mesh::setCustomDeviceData(v108, v535, 0);
          if (!atomic_fetch_add((atomic_ullong *volatile)v96 + 1, 0xFFFFFFFFFFFFFFFFLL))
          {
            (*(void (**)(void *))(*(void *)v96 + 16))(v96);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v96);
          }
          uint64_t v109 = *(void *)v74;
          uint64_t v110 = *(void *)(v74 + 8);
          uint64_t v111 = v110 - *(void *)v74;
          if (v110 != *(void *)v74)
          {
            uint64_t v112 = 0;
            unsigned int v113 = 0;
            uint64_t v115 = *(void *)(v74 + 64);
            uint64_t v114 = *(void *)(v74 + 72);
            unint64_t v116 = 0xAAAAAAAAAAAAAAABLL * (v111 >> 2);
            uint64_t v117 = v559;
            uint64_t v118 = v550;
            uint64_t v119 = v541;
            uint64_t v120 = v546;
            do
            {
              if (v114 == v115)
              {
                _S0 = 0;
                _S1 = 0;
              }
              else
              {
                float32x4_t v121 = (int *)(v115 + 8 * v112);
                _S0 = *v121;
                _S1 = v121[1];
              }
              float32x4_t v124 = (unsigned int *)(v117 + 8 * v112);
              uint64_t v126 = *v124;
              uint64_t v125 = v124[1];
              if (v126 < v125)
              {
                uint64_t v127 = v109 + 12 * v112;
                __asm
                {
                  FCVT            H0, S0
                  FCVT            H1, S1
                }
                uint64_t v132 = v125 - v126;
                float32x4_t v133 = (float *)(*(void *)(v74 + 32) + 12 * v126 + 8);
                do
                {
                  int v134 = (int)(float)(*(float *)(v127 + 4) * v73);
                  int v135 = *(_DWORD *)(v127 + 8);
                  uint64_t v136 = v118 + 8 * v113;
                  *(_WORD *)uint64_t v136 = (int)(float)(*(float *)v127 * v73);
                  *(_WORD *)(v136 + 2) = v134;
                  *(_DWORD *)(v136 + 4) = v135;
                  uint64_t v137 = 4 * v113;
                  float32x4_t v138 = (_WORD *)(v119 + v137);
                  *float32x4_t v138 = _H0;
                  v138[1] = _H1;
                  float v139 = *(v133 - 2);
                  float v140 = *(v133 - 1);
                  float v141 = *v133;
                  v133 += 3;
                  _S2 = (float)((float)(v139 * 0.28126) / (float)(v141 + 1.0)) + 0.5;
                  _S3 = (float)((float)(v140 * 0.28126) / (float)(v141 + 1.0)) + 0.5;
                  __asm
                  {
                    FCVT            H2, S2
                    FCVT            H3, S3
                  }
                  float32x4_t v144 = (_WORD *)(v120 + v137);
                  *float32x4_t v144 = LOWORD(_S2);
                  v144[1] = LOWORD(_S3);
                  ++v113;
                  --v132;
                }
                while (v132);
              }
              ++v112;
            }
            while (v116 > v112);
          }
          uint64_t v145 = (uint64_t)(*(void *)(v74 + 104) - *(void *)(v74 + 96)) >> 1;
          *(void *)&long long v525 = 0;
          *((void *)&v525 + 1) = v145;
          unsigned int v146 = *(unsigned __int8 *)(v74 + 128);
          if (v146 <= 3) {
            char v147 = 0x2010403u >> (8 * v146);
          }
          else {
            char v147 = 3;
          }
          LOBYTE(v529) = v147;
          v558[0] = 0;
          char v534 = 1;
          unint64_t v148 = *(void *)(a1 + 192);
          if (v148 >= *(void *)(a1 + 200))
          {
            float32x4_t v150 = std::vector<md::Mesh>::__emplace_back_slow_path<std::shared_ptr<ggl::DaVinci::TexturedCompressedMesh> &,gm::Range<unsigned long>,ggl::PrimitiveType,gm::Box<float,3> &,md::MeshVertexFormat,BOOL>((void **)(a1 + 184), v108, v106, &v525, (char *)&v529, (uint64_t)v501, v558, &v534);
          }
          else
          {
            atomic_fetch_add_explicit(&v106->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)unint64_t v148 = v108;
            *(void *)(v148 + 8) = v106;
            atomic_fetch_add_explicit(&v106->__shared_owners_, 1uLL, memory_order_relaxed);
            *(_OWORD *)(v148 + 16) = v525;
            *(unsigned char *)(v148 + 32) = v147;
            uint64_t v149 = *(uint64_t *)((char *)v499 + 292);
            *(_OWORD *)(v148 + 36) = *v501;
            *(void *)(v148 + 52) = v149;
            *(_WORD *)(v148 + 60) = 1;
            *(void *)(v148 + 64) = 0;
            *(void *)(v148 + 72) = 0;
            if (!atomic_fetch_add(&v106->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
              std::__shared_weak_count::__release_weak(v106);
            }
            float32x4_t v150 = (char *)(v148 + 80);
          }
          *(void *)(a1 + 192) = v150;
          uint64_t v151 = *((void *)v150 - 10);
          v533[0] = v519;
          v533[1] = (uint64_t *)v514;
          atomic_fetch_add_explicit(&v514->__shared_owners_, 1uLL, memory_order_relaxed);
          ggl::Mesh::setCustomDeviceData(v151, v533, (uint64_t *)1);
          if (!atomic_fetch_add(&v514->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v514->__on_zero_shared)(v514);
            std::__shared_weak_count::__release_weak(v514);
          }
          uint64_t v152 = *(void *)(*(void *)(a1 + 192) - 80);
          v532[0] = v516;
          v532[1] = (uint64_t *)v96;
          atomic_fetch_add_explicit((atomic_ullong *volatile)v96 + 1, 1uLL, memory_order_relaxed);
          ggl::Mesh::setCustomDeviceData(v152, v532, 0);
          if (atomic_fetch_add((atomic_ullong *volatile)v96 + 1, 0xFFFFFFFFFFFFFFFFLL))
          {
            if (!atomic_fetch_add(v107, 0xFFFFFFFFFFFFFFFFLL)) {
              goto LABEL_226;
            }
          }
          else
          {
            (*(void (**)(void *))(*(void *)v96 + 16))(v96);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v96);
            if (!atomic_fetch_add(v107, 0xFFFFFFFFFFFFFFFFLL))
            {
LABEL_226:
              ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
              std::__shared_weak_count::__release_weak(v106);
            }
          }
          if (v541)
          {
            unint64_t v153 = v538;
            unint64_t v154 = v539;
            if (v539 != v538)
            {
              float32x4_t v155 = v537[1];
              int v156 = v540;
              int v157 = HIBYTE(v540);
              if (v537[0] && *((unsigned char *)v537[1] + 17) != 2) {
                (*(void (**)(void))(*(void *)v537[0] + 64))();
              }
              if (v156 && !v157)
              {
                unint64_t v158 = v155[7];
                unint64_t v159 = v155[8];
                if (v159 == v158) {
                  unint64_t v158 = v155[10] - v155[9];
                }
                if (v153 < v158) {
                  unint64_t v158 = v153;
                }
                if (v159 <= v154) {
                  unint64_t v159 = v154;
                }
                if (v159 == v158) {
                  unint64_t v159 = v158 + v155[10] - v155[9];
                }
                v155[7] = v158;
                v155[8] = v159;
              }
            }
          }
          if (v546)
          {
            float32x4_t v160 = v543;
            float32x4_t v161 = v544;
            if (v544 != v543)
            {
              float32x4_t v162 = __p[1];
              int v163 = v545;
              int v164 = HIBYTE(v545);
              if (__p[0] && *((unsigned char *)__p[1] + 17) != 2) {
                (*(void (**)(void))(*(void *)__p[0] + 64))();
              }
              if (v163 && !v164)
              {
                uint32x4_t v165 = (char *)v162[7];
                double v166 = (char *)v162[8];
                if (v166 == v165) {
                  uint32x4_t v165 = (char *)(v162[10] - v162[9]);
                }
                if (v160 < v165) {
                  uint32x4_t v165 = v160;
                }
                if (v166 <= v161) {
                  double v166 = v161;
                }
                if (v166 == v165) {
                  double v166 = &v165[v162[10] - v162[9]];
                }
                v162[7] = v165;
                v162[8] = v166;
              }
            }
          }
          if (v550)
          {
            value = v547.__end_cap_.__value_;
            int8x16_t v168 = v548;
            if (v548 != v547.__end_cap_.__value_)
            {
              std::vector<unsigned int>::pointer end = v547.__end_;
              int v170 = v549;
              int v171 = HIBYTE(v549);
              if (v547.__begin_ && *((unsigned char *)v547.__end_ + 17) != 2) {
                (*(void (**)(void))(*(void *)v547.__begin_ + 64))();
              }
              if (v170 && !v171)
              {
                uint64_t v172 = (unsigned int *)*((void *)end + 7);
                float64x2_t v173 = (unsigned int *)*((void *)end + 8);
                if (v173 == v172) {
                  uint64_t v172 = (unsigned int *)(*((void *)end + 10) - *((void *)end + 9));
                }
                if (value < v172) {
                  uint64_t v172 = value;
                }
                if (v173 <= v168) {
                  float64x2_t v173 = v168;
                }
                if (v173 == v172) {
                  float64x2_t v173 = (unsigned int *)((char *)v172 + *((void *)end + 10) - *((void *)end + 9));
                }
                *((void *)end + 7) = v172;
                *((void *)end + 8) = v173;
              }
            }
          }
          if (!atomic_fetch_add((atomic_ullong *volatile)v96 + 1, 0xFFFFFFFFFFFFFFFFLL))
          {
            (*(void (**)(void *))(*(void *)v96 + 16))(v96);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v96);
          }
          float64x2_t v66 = (void *)a1;
          if (!atomic_fetch_add(v507, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v514->__on_zero_shared)(v514);
            std::__shared_weak_count::__release_weak(v514);
          }
          if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
          {
            float32x4_t v174 = (void *)v552;
            if (!(void)v552) {
              goto LABEL_217;
            }
          }
          else
          {
            ((void (*)(std::__shared_weak_count *))v505->__on_zero_shared)(v505);
            std::__shared_weak_count::__release_weak(v505);
            float32x4_t v174 = (void *)v552;
            if (!(void)v552) {
              goto LABEL_217;
            }
          }
          do
          {
            uint64_t v175 = (void *)*v174;
            operator delete(v174);
            float32x4_t v174 = v175;
          }
          while (v175);
LABEL_217:
          float64x2_t v176 = (void *)v551;
          *(void *)&long long v551 = 0;
          if (v176) {
            operator delete(v176);
          }
          float32x4_t v177 = (std::__shared_weak_count *)v530[1];
          if (v530[1] && !atomic_fetch_add((atomic_ullong *volatile)v530[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v177->__on_zero_shared)(v177);
            std::__shared_weak_count::__release_weak(v177);
            uint64_t v178 = v554;
            if (!v554) {
              goto LABEL_223;
            }
LABEL_222:
            uint64_t v555 = v178;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v557 + 40))(v557, v178, v556 - v178);
            goto LABEL_223;
          }
          uint64_t v178 = v554;
          if (v554) {
            goto LABEL_222;
          }
LABEL_223:
          float64x2_t v67 = (_DWORD *)v559;
          if ((void)v559) {
            operator delete((void *)v559);
          }
          v74 += 152;
        }
        while (v74 != v503);
      }
      unint64_t v411 = (v496 >> 4);
      v412 = (char *)v66[29];
      if (v411 > (uint64_t)(v66[31] - (void)v412) >> 4)
      {
        v413 = (char *)v66[30];
        v414 = (char *)operator new(16 * v411);
        v415 = &v414[16 * v411];
        v416 = &v414[v413 - v412];
        if (v413 == v412)
        {
          v66[29] = v416;
          v66[30] = v416;
          v66[31] = v415;
        }
        else
        {
          v417 = &v414[v413 - v412];
          do
          {
            long long v418 = *((_OWORD *)v413 - 1);
            v413 -= 16;
            *((_OWORD *)v417 - 1) = v418;
            v417 -= 16;
            *(void *)v413 = 0;
            *((void *)v413 + 1) = 0;
          }
          while (v413 != v412);
          v412 = (char *)v66[29];
          v419 = (char *)v66[30];
          v66[29] = v417;
          v66[30] = v416;
          for (v66[31] = v415; v419 != v412; v419 -= 16)
          {
            v420 = (std::__shared_weak_count *)*((void *)v419 - 1);
            if (v420 && !atomic_fetch_add(&v420->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v420->__on_zero_shared)(v420);
              std::__shared_weak_count::__release_weak(v420);
            }
          }
        }
        if (v412) {
          operator delete(v412);
        }
      }
      if ((v496 >> 4))
      {
        uint64_t v438 = 0;
        v439 = (char *)v66[30];
        while (1)
        {
          uint64_t v441 = v499[15];
          unint64_t v442 = v66[31];
          if ((unint64_t)v439 >= v442)
          {
            v444 = (char *)v66[29];
            uint64_t v445 = (v439 - v444) >> 4;
            unint64_t v446 = v445 + 1;
            if ((unint64_t)(v445 + 1) >> 60) {
              abort();
            }
            uint64_t v447 = v442 - (void)v444;
            if (v447 >> 3 > v446) {
              unint64_t v446 = v447 >> 3;
            }
            if ((unint64_t)v447 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v448 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v448 = v446;
            }
            if (v448 >> 60) {
              goto LABEL_672;
            }
            v449 = (char *)operator new(16 * v448);
            v450 = &v449[16 * v445];
            long long v451 = *(_OWORD *)(v441 + 16 * v438);
            *(_OWORD *)v450 = v451;
            if (*((void *)&v451 + 1))
            {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v451 + 1) + 8), 1uLL, memory_order_relaxed);
              v444 = *(char **)(a1 + 232);
              v439 = *(char **)(a1 + 240);
            }
            v452 = &v449[16 * v448];
            v440 = v450 + 16;
            if (v439 == v444)
            {
              *(void *)(a1 + 232) = v450;
              *(void *)(a1 + 240) = v440;
              *(void *)(a1 + 248) = v452;
            }
            else
            {
              do
              {
                long long v453 = *((_OWORD *)v439 - 1);
                v439 -= 16;
                *((_OWORD *)v450 - 1) = v453;
                v450 -= 16;
                *(void *)v439 = 0;
                *((void *)v439 + 1) = 0;
              }
              while (v439 != v444);
              v444 = *(char **)(a1 + 232);
              v454 = *(char **)(a1 + 240);
              *(void *)(a1 + 232) = v450;
              *(void *)(a1 + 240) = v440;
              *(void *)(a1 + 248) = v452;
              while (v454 != v444)
              {
                v455 = (std::__shared_weak_count *)*((void *)v454 - 1);
                if (v455 && !atomic_fetch_add(&v455->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v455->__on_zero_shared)(v455);
                  std::__shared_weak_count::__release_weak(v455);
                }
                v454 -= 16;
              }
            }
            if (v444) {
              operator delete(v444);
            }
          }
          else
          {
            long long v443 = *(_OWORD *)(v441 + 16 * v438);
            *(_OWORD *)v439 = v443;
            if (*((void *)&v443 + 1)) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v443 + 1) + 8), 1uLL, memory_order_relaxed);
            }
            v440 = v439 + 16;
          }
          *(void *)(a1 + 240) = v440;
          ++v438;
          v439 = v440;
          float64x2_t v66 = (void *)a1;
          if (v438 == v411) {
            goto LABEL_670;
          }
        }
      }
      goto LABEL_670;
    }
    if ((v496 >> 4))
    {
      uint64_t v179 = 0;
      uint64_t v490 = (v496 >> 4);
      v492 = (void *)(a1 + 400);
      while (1)
      {
        uint64_t v520 = v499[15] + 16 * v179;
        float64x2_t v180 = *(void **)v520;
        uint64_t v181 = *(void *)(*(void *)v520 + 256);
        uint64_t v182 = *(void *)(*(void *)v520 + 264);
        uint64_t v500 = v179;
        float64x2_t v183 = 0;
        if (v181 == v182)
        {
          uint64_t v206 = v499[15] + 16 * v179;
        }
        else
        {
          float64x2_t v184 = 0;
          float64x2_t v185 = 0;
          do
          {
            int v186 = *(_DWORD *)(v181 + 144);
            int v187 = *(_DWORD *)(v181 + 148);
            if (v184 >= v185)
            {
              unint64_t v188 = 0xAAAAAAAAAAAAAAABLL * ((v184 - v183) >> 3) + 1;
              if (v188 > 0xAAAAAAAAAAAAAAALL) {
                abort();
              }
              if (0x5555555555555556 * ((v185 - v183) >> 3) > v188) {
                unint64_t v188 = 0x5555555555555556 * ((v185 - v183) >> 3);
              }
              if (0xAAAAAAAAAAAAAAABLL * ((v185 - v183) >> 3) >= 0x555555555555555) {
                unint64_t v189 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v189 = v188;
              }
              if (v189)
              {
                if (v189 > 0xAAAAAAAAAAAAAAALL) {
                  goto LABEL_672;
                }
                float64x2_t v190 = (char *)operator new(24 * v189);
              }
              else
              {
                float64x2_t v190 = 0;
              }
              float64x2_t v191 = &v190[8 * ((v184 - v183) >> 3)];
              *(_OWORD *)float64x2_t v191 = xmmword_1A28FC710;
              *((void *)v191 + 2) = 0x80000000800000;
              if (v184 == v183)
              {
                float64x2_t v193 = &v190[8 * ((v184 - v183) >> 3)];
              }
              else
              {
                float64x2_t v192 = &v190[8 * ((v184 - v183) >> 3)];
                do
                {
                  float64x2_t v193 = v192 - 24;
                  long long v194 = *(_OWORD *)(v184 - 24);
                  *((void *)v192 - 1) = *((void *)v184 - 1);
                  *(_OWORD *)(v192 - 24) = v194;
                  v184 -= 24;
                  v192 -= 24;
                }
                while (v184 != v183);
              }
              float64x2_t v185 = &v190[24 * v189];
              float64x2_t v184 = v191 + 24;
              if (v183) {
                operator delete(v183);
              }
              float64x2_t v183 = v193;
            }
            else
            {
              *(_OWORD *)float64x2_t v184 = xmmword_1A28FC710;
              *((void *)v184 + 2) = 0x80000000800000;
              v184 += 24;
            }
            uint64_t v195 = (v187 + v186);
            uint64_t v196 = *(unsigned int *)(v181 + 144);
            if (v196 < v195)
            {
              uint64_t v197 = *(void *)v520;
              uint64_t v198 = v195 - v196;
              float64x2_t v199 = (unsigned __int16 *)(*(void *)(*(void *)v520 + 224) + 2 * v196);
              do
              {
                unsigned int v201 = *v199++;
                unsigned int v200 = v201;
                if (v201 != 0xFFFFLL)
                {
                  float64x2_t v202 = (float *)(*(void *)(v197 + 192) + 12 * v200);
                  float v203 = *((float *)v184 - 5);
                  *((float *)v184 - 6) = fminf(*v202, *((float *)v184 - 6));
                  float v204 = *((float *)v184 - 4);
                  *((float *)v184 - 3) = fmaxf(*((float *)v184 - 3), *v202);
                  *((float *)v184 - 5) = fminf(v202[1], v203);
                  float v205 = *((float *)v184 - 1);
                  *((float *)v184 - 2) = fmaxf(*((float *)v184 - 2), v202[1]);
                  *((float *)v184 - 4) = fminf(v202[2], v204);
                  *((float *)v184 - 1) = fmaxf(v205, v202[2]);
                }
                --v198;
              }
              while (v198);
            }
            v181 += 152;
          }
          while (v181 != v182);
          uint64_t v206 = v520;
          float64x2_t v180 = *(void **)v520;
        }
        uint64_t v208 = v180[24];
        uint64_t v207 = v180[25];
        uint64_t v209 = v180[28];
        uint64_t v517 = v180[29];
        unint64_t v210 = (v207 - v208) / 12;
        if (v207 == v208)
        {
          float64x2_t v212 = 0;
          goto LABEL_284;
        }
        if (v210 >= 0x1555555555555556) {
          abort();
        }
        float64x2_t v211 = (char *)operator new(v207 - v208);
        float64x2_t v212 = v211;
        unint64_t v213 = *(void *)(*(void *)v206 + 192);
        unint64_t v214 = v210 <= 1 ? 1 : (v207 - v208) / 12;
        if (v214 <= 7) {
          break;
        }
        if ((unint64_t)v211 < v213 + 12 * v214 && v213 < (unint64_t)&v211[12 * v214]) {
          break;
        }
        uint64_t v216 = 0;
        unint64_t v217 = v214 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v218 = v214 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          long long v219 = *(_OWORD *)(v213 + v216 + 16);
          long long v221 = *(_OWORD *)(v213 + v216 + 64);
          long long v220 = *(_OWORD *)(v213 + v216 + 80);
          long long v222 = *(_OWORD *)(v213 + v216 + 32);
          long long v223 = *(_OWORD *)(v213 + v216 + 48);
          float32x4_t v224 = &v211[v216];
          *(_OWORD *)float32x4_t v224 = *(_OWORD *)(v213 + v216);
          *((_OWORD *)v224 + 1) = v219;
          *((_OWORD *)v224 + 2) = v222;
          *((_OWORD *)v224 + 3) = v223;
          *((_OWORD *)v224 + 4) = v221;
          *((_OWORD *)v224 + 5) = v220;
          v216 += 96;
          v218 -= 8;
        }
        while (v218);
        if (v214 != v217) {
          goto LABEL_280;
        }
LABEL_284:
        long long v551 = 0u;
        long long v552 = 0u;
        int v553 = 1065353216;
        LODWORD(v547.__begin_) = 0;
        float32x4_t v229 = (geo::codec::Allocator *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>((uint64_t)&v551, 0, &v547);
        *((_DWORD *)v229 + 5) = 0;
        v530[0] = 0;
        v530[1] = 0;
        v531 = 0;
        uint64_t v554 = 0;
        uint64_t v555 = 0;
        uint64_t v556 = 0;
        float32x4_t v230 = (md::DaVinciGroundTileData *)geo::codec::Allocator::instance(v229);
        uint64_t v557 = (uint64_t)v230;
        long long v529 = 0uLL;
        v504 = v212;
        if (*(void *)(*(void *)v206 + 288) == *(void *)(*(void *)v206 + 296))
        {
          md::DaVinciGroundTileData::_edgeSmoothingAngleForZ(v230);
          memset(&v547, 0, sizeof(v547));
          float32x4_t v232 = (char *)operator new(0x10uLL);
          unint64_t v233 = (unint64_t)(v517 - v209) >> 1;
          v543 = v232 + 16;
          *(_DWORD *)float32x4_t v232 = 0;
          *(void *)(v232 + 4) = v233;
          v232[12] = 0;
          __p[0] = v232;
          __p[1] = v232 + 16;
          float32x4_t v234 = *(uint16x4_t **)(*(void *)v206 + 224);
          HIBYTE(v538) = 5;
          strcpy((char *)v537, "Asset");
          md::DaVinciGroundTileData::_buildNormals((uint64_t)v212, (v207 - v208) / 12, v233, (uint64_t)__p, v234, (int)&v551, (int)v530, (int)&v554, &v547, a1 + 208, (uint64_t)v537, 0);
        }
        if ((unint64_t)(v207 - v208 + 11) >= 0x17)
        {
          if (v210 >> 61) {
            abort();
          }
          float32x4_t v231 = (char *)operator new(8 * v210);
          v530[0] = v231;
          v530[1] = &v231[8 * v210];
          v531 = v530[1];
          if (v207 == v208) {
            goto LABEL_298;
          }
        }
        else
        {
          float32x4_t v231 = 0;
          if (v207 == v208) {
            goto LABEL_298;
          }
        }
        if (v210 <= 1) {
          uint64_t v235 = 1;
        }
        else {
          uint64_t v235 = (v207 - v208) / 12;
        }
        if (v235 >= 0xE)
        {
          int v237 = 0;
          uint64_t v236 = 0;
          if (!((unint64_t)(v235 - 1) >> 32))
          {
            int v237 = v235 & 0xFFFFFFFC;
            int8x16_t v362 = 0uLL;
            int v363 = v235 & 0xFFFFFFFC;
            int32x2_t v364 = (int32x2_t)0x100000000;
            do
            {
              int32x2_t v365 = vadd_s32(v364, (int32x2_t)0x100000001);
              int32x2_t v366 = vadd_s32(v364, (int32x2_t)0x300000003);
              v367.i64[0] = v365.u32[0];
              v367.i64[1] = v365.u32[1];
              int8x16_t v368 = v367;
              uint64_t v369 = v362.i64[1];
              int8x16_t v370 = vextq_s8(v362, v367, 8uLL);
              v367.i64[0] = v366.u32[0];
              v367.i64[1] = v366.u32[1];
              int8x16_t v362 = v367;
              v371 = (int8x16_t *)&v231[8 * v369];
              int8x16_t *v371 = vorrq_s8((int8x16_t)vshll_n_s32(v365, 0x20uLL), v370);
              v371[1] = vorrq_s8((int8x16_t)vshll_n_s32(v366, 0x20uLL), vextq_s8(v368, v367, 8uLL));
              int32x2_t v364 = vadd_s32(v364, (int32x2_t)0x400000004);
              v363 -= 4;
            }
            while (v363);
            if (v237 == v235) {
              goto LABEL_298;
            }
            uint64_t v236 = v362.i64[1];
          }
        }
        else
        {
          uint64_t v236 = 0;
          int v237 = 0;
        }
        unsigned int v238 = v237 + 1;
        do
        {
          unint64_t v239 = v238;
          *(void *)&v231[8 * v236] = v236 | ((unint64_t)v238++ << 32);
          uint64_t v236 = v239;
        }
        while (v210 > v239);
LABEL_298:
        md::DaVinciGroundTileData::_buildIndexBuffer((md::DaVinciGroundTileData *)&v547, a3, *(ResourceAccessor **)(*(void *)v206 + 224), (const unsigned __int16 *)((*(void *)(*(void *)v206 + 232) - *(void *)(*(void *)v206 + 224)) >> 1));
        long long v529 = *(_OWORD *)&v547.__begin_;
        float32x4_t v240 = (uint64_t *)(*(void *)v520 + 288);
        uint64_t v242 = *v240;
        uint64_t v241 = *(void *)(*(void *)v520 + 296);
        float32x4_t v243 = (char *)operator new(0xF8uLL);
        *((void *)v243 + 1) = 0;
        uint64_t v244 = -1431655765 * ((unint64_t)(v241 - v242) >> 2);
        *((void *)v243 + 2) = 0;
        *(void *)float32x4_t v243 = &unk_1EF585148;
        uint64_t v245 = ggl::BufferData::BufferData((uint64_t)(v243 + 24), 8, 0, 0, 6, v244);
        *((void *)v243 + 29) = "DV Asset Textured Vertex Data";
        *((void *)v243 + 30) = &ggl::DaVinci::texturedCompressedVboReflection;
        uint64_t v511 = v245;
        *((void *)v243 + 3) = &unk_1EF55CDC8;
        *((void *)v243 + 28) = &unk_1EF55CDE8;
        float32x4_t v246 = operator new(0xE0uLL);
        v246[1] = 0;
        v498 = v246 + 1;
        v246[2] = 0;
        *float32x4_t v246 = &unk_1EF584000;
        v510 = (uint64_t *)ggl::BufferData::BufferData((uint64_t)(v246 + 3), qword_1E9558BD0, 3, 0, 1, v244);
        v246[3] = &unk_1EF55B9F0;
        float32x4_t v247 = operator new(0xE0uLL);
        v247[1] = 0;
        v497 = v247 + 1;
        v247[2] = 0;
        *float32x4_t v247 = &unk_1EF583FC8;
        v508 = (uint64_t *)ggl::BufferData::BufferData((uint64_t)(v247 + 3), qword_1E9558C10, 3, 0, 1, v244);
        v515 = v246;
        v518 = v247;
        v247[3] = &unk_1EF55B9D0;
        v547.__end_ = 0;
        v547.__begin_ = 0;
        float32x4_t v248 = (unsigned int *)(v246[4] * v244);
        if (v248)
        {
          unint64_t v249 = (uint64_t *)v520;
          if (!a3 || *((unsigned char *)v515 + 41) == 2) {
            uint64_t v250 = v515[12];
          }
          else {
            uint64_t v250 = (*(uint64_t (**)(const char *, uint64_t *, void, unsigned int *, uint64_t, uint64_t))(*(void *)a3 + 56))(a3, v510, 0, v248, 1, 1);
          }
        }
        else
        {
          uint64_t v250 = 0;
          unint64_t v249 = (uint64_t *)v520;
        }
        *(void *)&long long v251 = a3;
        *((void *)&v251 + 1) = v510;
        *(_OWORD *)&v547.__begin_ = v251;
        v547.__end_cap_.__value_ = 0;
        v548 = v248;
        uint64_t v550 = v250;
        __int16 v549 = 257;
        __p[1] = 0;
        __p[0] = 0;
        uint64_t v252 = v518[4] * v244;
        if (v252)
        {
          if (!a3 || *((unsigned char *)v518 + 41) == 2) {
            uint64_t v253 = v518[12];
          }
          else {
            uint64_t v253 = (*(uint64_t (**)(const char *, uint64_t *, void, uint64_t, uint64_t, uint64_t))(*(void *)a3 + 56))(a3, v508, 0, v252, 1, 1);
          }
        }
        else
        {
          uint64_t v253 = 0;
        }
        *(void *)&long long v254 = a3;
        *((void *)&v254 + 1) = v508;
        *(_OWORD *)__p = v254;
        v543 = 0;
        v544 = (char *)v252;
        uint64_t v546 = v253;
        __int16 v545 = 257;
        uint64_t v255 = *v249;
        v537[1] = 0;
        v537[0] = 0;
        uint64_t v256 = *((void *)v243 + 4) * v244;
        if (v256)
        {
          uint64_t v257 = v511;
          if (!a3 || v243[41] == 2) {
            uint64_t v258 = *((void *)v243 + 12);
          }
          else {
            uint64_t v258 = (*(uint64_t (**)(const char *, uint64_t, void, uint64_t, uint64_t, uint64_t))(*(void *)a3 + 56))(a3, v511, 0, v256, 1, 1);
          }
        }
        else
        {
          uint64_t v258 = 0;
          uint64_t v257 = v511;
        }
        *(void *)&long long v259 = a3;
        *((void *)&v259 + 1) = v257;
        *(_OWORD *)v537 = v259;
        unint64_t v538 = 0;
        uint64_t v539 = v256;
        uint64_t v541 = v258;
        __int16 v540 = 257;
        float64x2_t v260 = (std::__shared_weak_count *)operator new(0xA8uLL);
        v260->__shared_owners_ = 0;
        v494 = &v260->__shared_owners_;
        v495 = (atomic_ullong *)(v243 + 8);
        v260->__shared_weak_owners_ = 0;
        v260->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5895C0;
        v512 = v260;
        uint64_t v261 = (uint64_t)&v260[1];
        std::construct_at[abi:nn180100]<ggl::DaVinci::TexturedCompressedMesh,char const(&)[14],std::shared_ptr<ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>> &,std::shared_ptr<ggl::IndexData> &,ggl::DaVinci::TexturedCompressedMesh*>((uint64_t)&v260[1], v257, (std::__shared_weak_count *)v243, (uint64_t *)&v529);
        v528[0] = v510;
        v528[1] = v515;
        atomic_fetch_add_explicit(v515 + 1, 1uLL, memory_order_relaxed);
        ggl::Mesh::setCustomDeviceData(v261, v528, (uint64_t *)1);
        if (!atomic_fetch_add(v515 + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          (*(void (**)(void *))(*v515 + 16))(v515);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v515);
        }
        v527[0] = v508;
        v527[1] = v518;
        atomic_fetch_add_explicit(v518 + 1, 1uLL, memory_order_relaxed);
        uint64_t v506 = v261;
        ggl::Mesh::setCustomDeviceData(v261, v527, 0);
        if (!atomic_fetch_add(v518 + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          (*(void (**)(void *))(*v518 + 16))(v518);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v518);
        }
        v491 = (std::__shared_weak_count *)v243;
        long long v525 = 0uLL;
        unint64_t v526 = 0;
        std::vector<md::Mesh>::reserve((uint64_t)&v525, 0x86BCA1AF286BCA1BLL* ((uint64_t)(*(void *)(*(void *)v520 + 264) - *(void *)(*(void *)v520 + 256)) >> 3));
        uint64_t v262 = *(void *)(*(void *)v520 + 256);
        if (*(void *)(*(void *)v520 + 264) != v262)
        {
          uint64_t v263 = 0;
          int v264 = 0;
          unsigned int v265 = 0;
          do
          {
            uint64_t v266 = v262 + 152 * v263;
            uint64_t v267 = *(unsigned int *)(v266 + 136);
            if (v267)
            {
              uint64_t v268 = 0;
              int v269 = *(_DWORD *)(v266 + 140);
              int v270 = *(_DWORD *)(v262 + 152 * v263 + 132);
              float32x4_t v271 = (char *)v530[0];
              uint64_t v272 = v541;
              uint64_t v273 = v546;
              uint64_t v274 = v550;
              do
              {
                if (v269 == -1)
                {
                  _S1 = 0;
                  _S0 = 0;
                }
                else
                {
                  float64x2_t v275 = (int *)(*(void *)(v255 + 320) + 8 * (v269 + v268));
                  _S0 = *v275;
                  _S1 = v275[1];
                }
                float64x2_t v278 = &v271[8 * (v270 + v268)];
                uint64_t v279 = *(unsigned int *)v278;
                uint64_t v280 = *((unsigned int *)v278 + 1);
                if (v279 < v280)
                {
                  int32x4_t v281 = (float *)&v212[12 * (v270 + v268)];
                  __asm
                  {
                    FCVT            H0, S0
                    FCVT            H1, S1
                  }
                  uint64_t v284 = v280 - v279;
                  float64x2_t v285 = (float *)(*v240 + 12 * v279 + 8);
                  do
                  {
                    int v286 = (int)(float)(v281[1] * v73);
                    int v287 = *((_DWORD *)v281 + 2);
                    uint64_t v288 = v272 + 8 * v265;
                    *(_WORD *)uint64_t v288 = (int)(float)(*v281 * v73);
                    *(_WORD *)(v288 + 2) = v286;
                    *(_DWORD *)(v288 + 4) = v287;
                    uint64_t v289 = 4 * v265;
                    int32x4_t v290 = (_WORD *)(v273 + v289);
                    *int32x4_t v290 = _H0;
                    v290[1] = _H1;
                    float v291 = *(v285 - 2);
                    float v292 = *(v285 - 1);
                    float v293 = *v285;
                    v285 += 3;
                    _S2 = (float)((float)(v291 * 0.28126) / (float)(v293 + 1.0)) + 0.5;
                    _S3 = (float)((float)(v292 * 0.28126) / (float)(v293 + 1.0)) + 0.5;
                    __asm
                    {
                      FCVT            H2, S2
                      FCVT            H3, S3
                    }
                    int8x16x2_t v296 = (_WORD *)(v274 + v289);
                    *int8x16x2_t v296 = LOWORD(_S2);
                    v296[1] = LOWORD(_S3);
                    ++v265;
                    --v284;
                  }
                  while (v284);
                }
                ++v268;
              }
              while (v268 != v267);
            }
            uint64_t v297 = v262 + 152 * v263;
            uint64_t v298 = (*(_DWORD *)(v297 + 148) + *(_DWORD *)(v297 + 144));
            *(void *)&long long v559 = *(unsigned int *)(v297 + 144);
            *((void *)&v559 + 1) = v298;
            unsigned int v299 = *(unsigned __int8 *)(v297 + 128);
            if (v299 <= 3) {
              char v300 = 0x2010403u >> (8 * v299);
            }
            else {
              char v300 = 3;
            }
            v558[0] = v300;
            uint64_t v301 = (uint64_t)&v183[24 * v263];
            char v534 = 0;
            char v524 = 1;
            uint64_t v302 = *((void *)&v525 + 1);
            if (*((void *)&v525 + 1) >= v526)
            {
              uint64_t v304 = std::vector<md::Mesh>::__emplace_back_slow_path<std::shared_ptr<ggl::DaVinci::TexturedCompressedMesh> &,gm::Range<unsigned long>,ggl::PrimitiveType,gm::Box<float,3> &,md::MeshVertexFormat,BOOL>((void **)&v525, v506, v512, &v559, v558, v301, &v534, &v524);
            }
            else
            {
              atomic_fetch_add_explicit(&v512->__shared_owners_, 1uLL, memory_order_relaxed);
              *(void *)uint64_t v302 = v506;
              *(void *)(v302 + 8) = v512;
              atomic_fetch_add_explicit(&v512->__shared_owners_, 1uLL, memory_order_relaxed);
              *(_OWORD *)(v302 + 16) = v559;
              *(unsigned char *)(v302 + 32) = v300;
              uint64_t v303 = *(void *)(v301 + 16);
              *(_OWORD *)(v302 + 36) = *(_OWORD *)v301;
              *(void *)(v302 + 52) = v303;
              *(_WORD *)(v302 + 60) = 1;
              *(void *)(v302 + 64) = 0;
              *(void *)(v302 + 72) = 0;
              if (!atomic_fetch_add(&v512->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v512->__on_zero_shared)(v512);
                std::__shared_weak_count::__release_weak(v512);
              }
              uint64_t v304 = (char *)(v302 + 80);
            }
            *((void *)&v525 + 1) = v304;
            uint64_t v305 = *((void *)v304 - 10);
            v523[0] = v510;
            v523[1] = v515;
            atomic_fetch_add_explicit(v515 + 1, 1uLL, memory_order_relaxed);
            ggl::Mesh::setCustomDeviceData(v305, v523, (uint64_t *)1);
            uint64_t v261 = 1;
            if (!atomic_fetch_add(v515 + 1, 0xFFFFFFFFFFFFFFFFLL))
            {
              (*(void (**)(void *))(*v515 + 16))(v515);
              std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v515);
            }
            uint64_t v306 = *(void *)(*((void *)&v525 + 1) - 80);
            v522[0] = v508;
            v522[1] = v518;
            atomic_fetch_add_explicit(v518 + 1, 1uLL, memory_order_relaxed);
            ggl::Mesh::setCustomDeviceData(v306, v522, 0);
            if (!atomic_fetch_add(v518 + 1, 0xFFFFFFFFFFFFFFFFLL))
            {
              (*(void (**)(void *))(*v518 + 16))(v518);
              std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v518);
            }
            uint64_t v263 = (unsigned __int16)++v264;
            uint64_t v262 = *(void *)(*(void *)v520 + 256);
          }
          while (0x86BCA1AF286BCA1BLL * ((*(void *)(*(void *)v520 + 264) - v262) >> 3) > (unsigned __int16)v264);
        }
        uint64_t v307 = *((void *)&v525 + 1);
        uint64_t v308 = v525;
        long long v521 = 0u;
        v493 = v183;
        if (*((void *)&v525 + 1) == (void)v525)
        {
          uint64_t v332 = 0;
          v313 = 0;
          goto LABEL_383;
        }
        uint64_t v309 = 0;
        int v310 = 0;
        v311 = 0;
        v312 = 0;
        v313 = 0;
        do
        {
          uint64_t v314 = v309 - 0x3333333333333333 * ((uint64_t)(*(void *)(a1 + 192) - *(void *)(a1 + 184)) >> 4);
          if (v312 < v311)
          {
            *(_WORD *)v312 = v314;
            v312 += 2;
            goto LABEL_348;
          }
          uint64_t v261 = v312 - v313;
          if (v312 - v313 <= -3) {
            abort();
          }
          uint64_t v315 = v261 >> 1;
          if (v311 - v313 <= (unint64_t)((v261 >> 1) + 1)) {
            uint64_t v316 = v315 + 1;
          }
          else {
            uint64_t v316 = v311 - v313;
          }
          if ((unint64_t)(v311 - v313) >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v317 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v317 = v316;
          }
          if (v317)
          {
            if (v317 < 0) {
              goto LABEL_672;
            }
            uint64_t v318 = v308;
            uint64_t v319 = v307;
            v320 = operator new(2 * v317);
            uint64_t v307 = v319;
            uint64_t v308 = v318;
          }
          else
          {
            v320 = 0;
          }
          v321 = &v320[2 * v315];
          *(_WORD *)v321 = v314;
          v322 = v321 + 2;
          if (v312 != v313)
          {
            unint64_t v323 = v312 - 2 - v313;
            if (v323 >= 0x5E)
            {
              if (&v320[(v261 & 0xFFFFFFFFFFFFFFFELL) - 2 - (v323 & 0xFFFFFFFFFFFFFFFELL)] > &v320[(v261 & 0xFFFFFFFFFFFFFFFELL) - 2])
              {
                v324 = v312;
              }
              else if (&v312[-(v323 & 0xFFFFFFFFFFFFFFFELL) - 2] > v312 - 2)
              {
                v324 = v312;
              }
              else if ((unint64_t)(v312 - &v320[v261 & 0xFFFFFFFFFFFFFFFELL]) >= 0x20)
              {
                uint64_t v326 = (v323 >> 1) + 1;
                v324 = &v312[-2 * (v326 & 0xFFFFFFFFFFFFFFF0)];
                v327 = &v320[2 * v315 - 16];
                v328 = v312 - 16;
                unint64_t v329 = v326 & 0xFFFFFFFFFFFFFFF0;
                do
                {
                  long long v330 = *(_OWORD *)v328;
                  *(v327 - 1) = *((_OWORD *)v328 - 1);
                  _OWORD *v327 = v330;
                  v327 -= 2;
                  v328 -= 32;
                  v329 -= 16;
                }
                while (v329);
                v321 -= 2 * (v326 & 0xFFFFFFFFFFFFFFF0);
                if (v326 == (v326 & 0xFFFFFFFFFFFFFFF0)) {
                  goto LABEL_365;
                }
              }
              else
              {
                v324 = v312;
              }
            }
            else
            {
              v324 = v312;
            }
            do
            {
              __int16 v325 = *((_WORD *)v324 - 1);
              v324 -= 2;
              *((_WORD *)v321 - 1) = v325;
              v321 -= 2;
            }
            while (v324 != v313);
          }
LABEL_365:
          v311 = &v320[2 * v317];
          if (v313)
          {
            operator delete(v313);
            uint64_t v307 = *((void *)&v525 + 1);
            uint64_t v308 = v525;
          }
          v313 = v321;
          v312 = v322;
          float64x2_t v212 = v504;
LABEL_348:
          uint64_t v309 = (unsigned __int16)++v310;
        }
        while (0xCCCCCCCCCCCCCCCDLL * ((v307 - v308) >> 4) > (unsigned __int16)v310);
        int64_t v331 = v312 - v313;
        if (v312 == v313)
        {
          uint64_t v332 = 0;
        }
        else
        {
          if (v331 < 0) {
            abort();
          }
          uint64_t v261 = (uint64_t)operator new(v312 - v313);
          uint64_t v332 = v261 + 2 * (v331 >> 1);
          memcpy((void *)v261, v313, v331);
          *(void *)&long long v333 = v261;
          *((void *)&v333 + 1) = v332;
          long long v521 = v333;
        }
LABEL_383:
        unint64_t v334 = *(void *)(a1 + 392);
        if (!v334) {
          goto LABEL_403;
        }
        uint8x8_t v335 = (uint8x8_t)vcnt_s8((int8x8_t)v334);
        v335.i16[0] = vaddlv_u8(v335);
        if (v335.u32[0] > 1uLL)
        {
          uint64_t v261 = v500;
          if (v334 <= v500) {
            uint64_t v261 = v500 % v334;
          }
        }
        else
        {
          uint64_t v261 = (v334 - 1) & (unint64_t)v500;
        }
        v336 = *(uint64_t ****)(*(void *)(a1 + 384) + 8 * v261);
        if (!v336 || (v337 = *v336) == 0)
        {
LABEL_403:
          v340 = (char *)operator new(0x30uLL);
          *(void *)&long long v559 = v340;
          *((void *)&v559 + 1) = a1 + 400;
          *(void *)v340 = 0;
          *((void *)v340 + 1) = v500;
          v340[16] = v500;
          *(_OWORD *)(v340 + 24) = v521;
          *((void *)v340 + 5) = v332;
          LOBYTE(v560) = 1;
          float64x2_t v66 = (void *)a1;
          float v341 = (float)(unint64_t)(*(void *)(a1 + 408) + 1);
          float v342 = *(float *)(a1 + 416);
          if (v334 && (float)(v342 * (float)v334) >= v341)
          {
            uint64_t v343 = v500;
            goto LABEL_459;
          }
          BOOL v344 = (v334 & (v334 - 1)) != 0;
          if (v334 < 3) {
            BOOL v344 = 1;
          }
          unint64_t v345 = v344 | (2 * v334);
          unint64_t v346 = vcvtps_u32_f32(v341 / v342);
          if (v345 <= v346) {
            size_t prime = v346;
          }
          else {
            size_t prime = v345;
          }
          uint64_t v343 = v500;
          if (prime == 1)
          {
            size_t prime = 2;
          }
          else if ((prime & (prime - 1)) != 0)
          {
            size_t prime = std::__next_prime(prime);
            unint64_t v334 = *(void *)(a1 + 392);
          }
          if (prime > v334)
          {
LABEL_416:
            if (prime >> 61) {
LABEL_672:
            }
              std::__throw_bad_array_new_length[abi:nn180100]();
            v348 = operator new(8 * prime);
            v349 = *(void **)(a1 + 384);
            *(void *)(a1 + 384) = v348;
            if (v349) {
              operator delete(v349);
            }
            uint64_t v350 = 0;
            *(void *)(a1 + 392) = prime;
            do
              *(void *)(*(void *)(a1 + 384) + 8 * v350++) = 0;
            while (prime != v350);
            v351 = (void *)*v492;
            if (!*v492) {
              goto LABEL_445;
            }
            size_t v352 = v351[1];
            size_t v353 = prime - 1;
            if ((prime & (prime - 1)) == 0)
            {
              size_t v354 = v352 & v353;
              *(void *)(*(void *)(a1 + 384) + 8 * v354) = v492;
              for (m = (void *)*v351; *v351; m = (void *)*v351)
              {
                size_t v356 = m[1] & v353;
                if (v356 == v354)
                {
                  v351 = m;
                }
                else
                {
                  uint64_t v357 = *(void *)(a1 + 384);
                  if (*(void *)(v357 + 8 * v356))
                  {
                    void *v351 = *m;
                    uint64_t v358 = 8 * v356;
                    void *m = **(void **)(*(void *)(a1 + 384) + v358);
                    **(void **)(*(void *)(a1 + 384) + v358) = m;
                  }
                  else
                  {
                    *(void *)(v357 + 8 * v356) = v351;
                    v351 = m;
                    size_t v354 = v356;
                  }
                }
              }
              goto LABEL_445;
            }
            if (v352 >= prime) {
              v352 %= prime;
            }
            *(void *)(*(void *)(a1 + 384) + 8 * v352) = v492;
            v372 = (void *)*v351;
            if (!*v351)
            {
LABEL_445:
              unint64_t v334 = prime;
              goto LABEL_446;
            }
            while (2)
            {
              size_t v374 = v372[1];
              if (v374 >= prime) {
                v374 %= prime;
              }
              if (v374 != v352)
              {
                uint64_t v375 = *(void *)(a1 + 384);
                if (!*(void *)(v375 + 8 * v374))
                {
                  *(void *)(v375 + 8 * v374) = v351;
LABEL_450:
                  v351 = v372;
                  v372 = (void *)*v372;
                  size_t v352 = v374;
                  if (!v372) {
                    goto LABEL_445;
                  }
                  continue;
                }
                void *v351 = *v372;
                uint64_t v373 = 8 * v374;
                void *v372 = **(void **)(*(void *)(a1 + 384) + v373);
                **(void **)(*(void *)(a1 + 384) + v373) = v372;
                v372 = v351;
              }
              break;
            }
            size_t v374 = v352;
            goto LABEL_450;
          }
          if (prime < v334)
          {
            unint64_t v359 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 408) / *(float *)(a1 + 416));
            if (v334 < 3
              || (uint8x8_t v360 = (uint8x8_t)vcnt_s8((int8x8_t)v334), v360.i16[0] = vaddlv_u8(v360), v360.u32[0] > 1uLL))
            {
              unint64_t v359 = std::__next_prime(v359);
            }
            else
            {
              uint64_t v361 = 1 << -(char)__clz(v359 - 1);
              if (v359 >= 2) {
                unint64_t v359 = v361;
              }
            }
            if (prime <= v359) {
              size_t prime = v359;
            }
            if (prime >= v334)
            {
              unint64_t v334 = *(void *)(a1 + 392);
            }
            else
            {
              if (prime) {
                goto LABEL_416;
              }
              v410 = *(void **)(a1 + 384);
              *(void *)(a1 + 384) = 0;
              if (v410) {
                operator delete(v410);
              }
              unint64_t v334 = 0;
              *(void *)(a1 + 392) = 0;
            }
          }
LABEL_446:
          if ((v334 & (v334 - 1)) != 0)
          {
            if (v334 <= v500) {
              uint64_t v261 = v500 % v334;
            }
            else {
              uint64_t v261 = v500;
            }
          }
          else
          {
            uint64_t v261 = (v334 - 1) & v500;
          }
LABEL_459:
          uint64_t v376 = *(void *)(a1 + 384);
          v377 = *(void **)(v376 + 8 * v261);
          if (v377)
          {
            *(void *)v340 = *v377;
            goto LABEL_467;
          }
          *(void *)v340 = *v492;
          void *v492 = v340;
          *(void *)(v376 + 8 * v261) = v492;
          if (*(void *)v340)
          {
            unint64_t v378 = *(void *)(*(void *)v340 + 8);
            if ((v334 & (v334 - 1)) != 0)
            {
              if (v378 >= v334) {
                v378 %= v334;
              }
            }
            else
            {
              v378 &= v334 - 1;
            }
            v377 = (void *)(*(void *)(a1 + 384) + 8 * v378);
LABEL_467:
            void *v377 = v340;
          }
          ++*(void *)(a1 + 408);
          goto LABEL_470;
        }
        if (v335.u32[0] < 2uLL)
        {
          while (1)
          {
            v339 = v337[1];
            if (v339 == (uint64_t *)v500)
            {
              if (*((unsigned __int8 *)v337 + 16) == v500) {
                goto LABEL_552;
              }
            }
            else if (((unint64_t)v339 & (v334 - 1)) != v261)
            {
              goto LABEL_403;
            }
            v337 = (uint64_t **)*v337;
            if (!v337) {
              goto LABEL_403;
            }
          }
        }
        while (2)
        {
          unint64_t v338 = (unint64_t)v337[1];
          if (v338 != v500)
          {
            if (v338 >= v334) {
              v338 %= v334;
            }
            if (v338 != v261) {
              goto LABEL_403;
            }
LABEL_393:
            v337 = (uint64_t **)*v337;
            if (!v337) {
              goto LABEL_403;
            }
            continue;
          }
          break;
        }
        if (*((unsigned __int8 *)v337 + 16) != v500) {
          goto LABEL_393;
        }
LABEL_552:
        float64x2_t v66 = (void *)a1;
        uint64_t v343 = v500;
        if ((void)v521) {
          operator delete((void *)v521);
        }
LABEL_470:
        uint64_t v380 = *((void *)&v525 + 1);
        uint64_t v379 = v525;
        if ((void)v525 != *((void *)&v525 + 1))
        {
          v381 = (_OWORD *)v66[24];
          do
          {
            if ((unint64_t)v381 < v66[25])
            {
              _OWORD *v381 = *(_OWORD *)v379;
              *(void *)uint64_t v379 = 0;
              *(void *)(v379 + 8) = 0;
              long long v382 = *(_OWORD *)(v379 + 16);
              long long v383 = *(_OWORD *)(v379 + 32);
              *(_OWORD *)((char *)v381 + 46) = *(_OWORD *)(v379 + 46);
              v381[1] = v382;
              v381[2] = v383;
              v381[4] = *(_OWORD *)(v379 + 64);
              *(void *)(v379 + 64) = 0;
              *(void *)(v379 + 72) = 0;
              v381 += 5;
            }
            else
            {
              v381 = std::vector<md::Mesh>::__push_back_slow_path<md::Mesh>((void **)(a1 + 184), (long long *)v379);
            }
            v66[24] = v381;
            v379 += 80;
          }
          while (v379 != v380);
        }
        if (v313) {
          operator delete(v313);
        }
        *(void *)&long long v559 = &v525;
        std::vector<md::Mesh>::__destroy_vector::operator()[abi:nn180100]((void ***)&v559);
        if (atomic_fetch_add(v494, 0xFFFFFFFFFFFFFFFFLL))
        {
          if (!v541) {
            goto LABEL_497;
          }
LABEL_482:
          unint64_t v384 = v538;
          unint64_t v385 = v539;
          if (v539 != v538)
          {
            v386 = v537[1];
            int v387 = v540;
            int v388 = HIBYTE(v540);
            if (v537[0] && *((unsigned char *)v537[1] + 17) != 2) {
              (*(void (**)(void))(*(void *)v537[0] + 64))();
            }
            if (v387 && !v388)
            {
              unint64_t v389 = v386[7];
              unint64_t v390 = v386[8];
              if (v390 == v389) {
                unint64_t v389 = v386[10] - v386[9];
              }
              if (v384 < v389) {
                unint64_t v389 = v384;
              }
              if (v390 <= v385) {
                unint64_t v390 = v385;
              }
              if (v390 == v389) {
                unint64_t v390 = v389 + v386[10] - v386[9];
              }
              v386[7] = v389;
              v386[8] = v390;
            }
          }
        }
        else
        {
          ((void (*)(std::__shared_weak_count *))v512->__on_zero_shared)(v512);
          std::__shared_weak_count::__release_weak(v512);
          if (v541) {
            goto LABEL_482;
          }
        }
LABEL_497:
        if (v546)
        {
          v391 = v543;
          v392 = v544;
          if (v544 != v543)
          {
            v393 = __p[1];
            int v394 = v545;
            int v395 = HIBYTE(v545);
            if (__p[0] && *((unsigned char *)__p[1] + 17) != 2) {
              (*(void (**)(void))(*(void *)__p[0] + 64))();
            }
            if (v394 && !v395)
            {
              v396 = (char *)v393[7];
              v397 = (char *)v393[8];
              if (v397 == v396) {
                v396 = (char *)(v393[10] - v393[9]);
              }
              if (v391 < v396) {
                v396 = v391;
              }
              if (v397 <= v392) {
                v397 = v392;
              }
              if (v397 == v396) {
                v397 = &v396[v393[10] - v393[9]];
              }
              v393[7] = v396;
              v393[8] = v397;
            }
          }
        }
        if (v550)
        {
          v398 = v547.__end_cap_.__value_;
          v399 = v548;
          if (v548 != v547.__end_cap_.__value_)
          {
            std::vector<unsigned int>::pointer v400 = v547.__end_;
            int v401 = v549;
            int v402 = HIBYTE(v549);
            if (v547.__begin_ && *((unsigned char *)v547.__end_ + 17) != 2) {
              (*(void (**)(void))(*(void *)v547.__begin_ + 64))();
            }
            if (v401 && !v402)
            {
              v403 = (unsigned int *)*((void *)v400 + 7);
              v404 = (unsigned int *)*((void *)v400 + 8);
              if (v404 == v403) {
                v403 = (unsigned int *)(*((void *)v400 + 10) - *((void *)v400 + 9));
              }
              if (v398 < v403) {
                v403 = v398;
              }
              if (v404 <= v399) {
                v404 = v399;
              }
              if (v404 == v403) {
                v404 = (unsigned int *)((char *)v403 + *((void *)v400 + 10) - *((void *)v400 + 9));
              }
              *((void *)v400 + 7) = v403;
              *((void *)v400 + 8) = v404;
            }
          }
        }
        if (!atomic_fetch_add(v497, 0xFFFFFFFFFFFFFFFFLL))
        {
          (*(void (**)(void *))(*v518 + 16))(v518);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v518);
        }
        if (atomic_fetch_add(v498, 0xFFFFFFFFFFFFFFFFLL))
        {
          if (atomic_fetch_add(v495, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_533;
          }
LABEL_536:
          ((void (*)(std::__shared_weak_count *))v491->__on_zero_shared)(v491);
          std::__shared_weak_count::__release_weak(v491);
          v405 = (std::__shared_weak_count *)*((void *)&v529 + 1);
          if (*((void *)&v529 + 1)) {
            goto LABEL_537;
          }
LABEL_538:
          uint64_t v406 = v554;
          if (v554) {
            goto LABEL_539;
          }
        }
        else
        {
          (*(void (**)(void *))(*v515 + 16))(v515);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v515);
          if (!atomic_fetch_add(v495, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_536;
          }
LABEL_533:
          v405 = (std::__shared_weak_count *)*((void *)&v529 + 1);
          if (!*((void *)&v529 + 1)) {
            goto LABEL_538;
          }
LABEL_537:
          if (atomic_fetch_add(&v405->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_538;
          }
          ((void (*)(std::__shared_weak_count *))v405->__on_zero_shared)(v405);
          std::__shared_weak_count::__release_weak(v405);
          uint64_t v406 = v554;
          if (v554)
          {
LABEL_539:
            uint64_t v555 = v406;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v557 + 40))(v557, v406, v556 - v406);
          }
        }
        if (v530[0]) {
          operator delete(v530[0]);
        }
        v407 = (void *)v552;
        if ((void)v552)
        {
          do
          {
            v408 = (void *)*v407;
            operator delete(v407);
            v407 = v408;
          }
          while (v408);
        }
        v409 = (void *)v551;
        *(void *)&long long v551 = 0;
        if (v409) {
          operator delete(v409);
        }
        if (v212) {
          operator delete(v212);
        }
        if (v493) {
          operator delete(v493);
        }
        uint64_t v179 = v343 + 1;
        if (v179 == v490) {
          goto LABEL_573;
        }
      }
      unint64_t v217 = 0;
LABEL_280:
      unint64_t v225 = v214 - v217;
      unint64_t v226 = v213 + 8;
      uint64_t v227 = 12 * v217;
      do
      {
        float32x4_t v228 = &v211[v227];
        *(_DWORD *)float32x4_t v228 = *(_DWORD *)(v226 + v227 - 8);
        *((_DWORD *)v228 + 1) = *(_DWORD *)(v226 + v227 - 4);
        *((_DWORD *)v228 + 2) = *(_DWORD *)(v226 + v227);
        v227 += 12;
        --v225;
      }
      while (v225);
      goto LABEL_284;
    }
LABEL_573:
    v421 = (void **)(v66 + 53);
    if (v66 + 53 != v499)
    {
      uint64_t v423 = *v499;
      uint64_t v422 = v499[1];
      unint64_t v424 = 0xCCCCCCCCCCCCCCCDLL * ((v422 - *v499) >> 3);
      uint64_t v425 = v66[55];
      v426 = (char *)v66[53];
      if (0xCCCCCCCCCCCCCCCDLL * ((v425 - (uint64_t)v426) >> 3) >= v424)
      {
        v433 = (char *)v66[54];
        uint64_t v434 = (v433 - v426) >> 3;
        unint64_t v435 = 0xCCCCCCCCCCCCCCCDLL * v434;
        if (0xCCCCCCCCCCCCCCCDLL * v434 < v424)
        {
          if (v433 != v426)
          {
            uint64_t v436 = 8 * v434;
            uint64_t v437 = *v499;
            do
            {
              if ((char *)v437 != v426)
              {
                *((_DWORD *)v426 + 8) = *(_DWORD *)(v437 + 32);
                std::__hash_table<std::__hash_value_type<unsigned short,unsigned long long>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned long long>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned long long>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned long long>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<unsigned short,unsigned long long>,void *> *>>(v426, *(uint64_t **)(v437 + 16));
              }
              v437 += 40;
              v426 += 40;
              v436 -= 40;
            }
            while (v436);
            v426 = (char *)v66[54];
          }
          uint64_t v461 = v423 + 40 * v435;
          v462 = v426;
          if (v461 != v422)
          {
            uint64_t v463 = 0;
            do
            {
              std::unordered_map<unsigned short,unsigned long long>::unordered_map((uint64_t)&v426[v463], v461 + v463);
              v463 += 40;
            }
            while (v461 + v463 != v422);
            v462 = &v426[v463];
          }
          v66[54] = v462;
          goto LABEL_654;
        }
        if (v423 != v422)
        {
          do
          {
            if ((char *)v423 != v426)
            {
              *((_DWORD *)v426 + 8) = *(_DWORD *)(v423 + 32);
              std::__hash_table<std::__hash_value_type<unsigned short,unsigned long long>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned long long>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned long long>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned long long>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<unsigned short,unsigned long long>,void *> *>>(v426, *(uint64_t **)(v423 + 16));
            }
            v423 += 40;
            v426 += 40;
          }
          while (v423 != v422);
          v433 = (char *)v66[54];
        }
        while (v433 != v426)
        {
          v464 = (void *)*((void *)v433 - 3);
          if (v464)
          {
            do
            {
              v465 = (void *)*v464;
              operator delete(v464);
              v464 = v465;
            }
            while (v465);
          }
          v467 = (void *)*((void *)v433 - 5);
          v433 -= 40;
          v466 = v467;
          *(void *)v433 = 0;
          if (v467) {
            operator delete(v466);
          }
        }
      }
      else
      {
        if (v426)
        {
          v427 = (char *)v66[54];
          v428 = (void *)v66[53];
          if (v427 != v426)
          {
            do
            {
              v429 = (void *)*((void *)v427 - 3);
              if (v429)
              {
                do
                {
                  v430 = (void *)*v429;
                  operator delete(v429);
                  v429 = v430;
                }
                while (v430);
              }
              v432 = (void *)*((void *)v427 - 5);
              v427 -= 40;
              v431 = v432;
              *(void *)v427 = 0;
              if (v432) {
                operator delete(v431);
              }
            }
            while (v427 != v426);
            v428 = *v421;
          }
          v66[54] = v426;
          operator delete(v428);
          uint64_t v425 = 0;
          *v421 = 0;
          v66[54] = 0;
          v66[55] = 0;
        }
        if (v424 > 0x666666666666666) {
          goto LABEL_680;
        }
        unint64_t v456 = 0xCCCCCCCCCCCCCCCDLL * (v425 >> 3);
        uint64_t v457 = 2 * v456;
        if (2 * v456 <= v424) {
          uint64_t v457 = v424;
        }
        unint64_t v458 = v456 >= 0x333333333333333 ? 0x666666666666666 : v457;
        if (v458 > 0x666666666666666) {
LABEL_680:
        }
          abort();
        v426 = (char *)operator new(40 * v458);
        v66[53] = v426;
        v66[54] = v426;
        v66[55] = &v426[40 * v458];
        if (v423 != v422)
        {
          uint64_t v459 = 0;
          do
          {
            std::unordered_map<unsigned short,unsigned long long>::unordered_map((uint64_t)&v426[v459], v423 + v459);
            v459 += 40;
          }
          while (v423 + v459 != v422);
          v426 += v459;
        }
      }
      v66[54] = v426;
    }
LABEL_654:
    v468 = (uint64_t *)v66[23];
    v469 = (uint64_t *)v66[24];
    if (v468 != v469)
    {
      uint64_t v470 = v66[22];
      do
      {
        uint64_t v471 = *v468;
        v468 += 10;
        uint64_t v470 = *(void *)(*(void *)(v471 + 96) + 48)
             + v470
             + *(void *)(**(void **)(v471 + 64) + 48)
             - *(void *)(**(void **)(v471 + 64) + 40)
             - *(void *)(*(void *)(v471 + 96) + 40);
      }
      while (v468 != v469);
      v66[22] = v470;
    }
    v472 = (char ***)v66[29];
    v473 = (char ***)v66[30];
    if (v472 != v473)
    {
      uint64_t v474 = v66[22];
      do
      {
        v475 = *v472;
        v476 = **v472;
        v477 = (*v472)[1];
        if (v476 != v477)
        {
          unint64_t v478 = v477 - v476 - 32;
          if (v478 > 0x7F)
          {
            uint64_t v479 = (v478 >> 5) + 1;
            uint64_t v480 = v479 & 3;
            if ((v479 & 3) == 0) {
              uint64_t v480 = 4;
            }
            uint64_t v481 = v479 - v480;
            uint64_t v482 = 32 * v481;
            int64x2_t v483 = 0uLL;
            int64x2_t v484 = (int64x2_t)(unint64_t)v474;
            v485 = (const double *)(v476 + 64);
            do
            {
              v486 = v485 - 8;
              float64x2x4_t v561 = vld4q_f64(v486);
              float64x2x4_t v562 = vld4q_f64(v485);
              int64x2_t v484 = vaddq_s64(vsubq_s64((int64x2_t)v561.val[1], (int64x2_t)v561.val[0]), v484);
              int64x2_t v483 = vaddq_s64(vsubq_s64((int64x2_t)v562.val[1], (int64x2_t)v562.val[0]), v483);
              v485 += 16;
              v481 -= 4;
            }
            while (v481);
            v476 += v482;
            uint64_t v474 = vaddvq_s64(vaddq_s64(v483, v484));
          }
          do
          {
            uint64_t v488 = *(void *)v476;
            uint64_t v487 = *((void *)v476 + 1);
            v476 += 32;
            v474 += v487 - v488;
          }
          while (v476 != v477);
          v66[22] = v474;
        }
        uint64_t v474 = &v475[21][64 * (void)v475[14] + v475[17] - v475[16] + v474] - v475[20];
        v66[22] = v474;
        v472 += 2;
      }
      while (v472 != v473);
    }
LABEL_670:
    operator delete(v489);
  }
}

void sub_1A2543C64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p)
{
}

void *std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    char v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      char v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            char v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          char v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  char v10 = operator new(0x18uLL);
  *char v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v6 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        v6 %= v7;
      }
    }
    else
    {
      unint64_t v6 = (v7 - 1) & v6;
    }
  }
  uint64_t v22 = *(void *)a1;
  unint64_t v23 = *(void **)(*(void *)a1 + 8 * v6);
  if (v23)
  {
    *char v10 = *v23;
LABEL_58:
    *unint64_t v23 = v10;
    goto LABEL_59;
  }
  *char v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v6) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    unint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A25445E8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:nn180100]<ggl::DaVinci::TexturedCompressedMesh,char const(&)[14],std::shared_ptr<ggl::VertexDataTyped<ggl::DaVinci::TexturedCompressedVbo>> &,std::shared_ptr<ggl::IndexData> &,ggl::DaVinci::TexturedCompressedMesh*>(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t *a4)
{
  uint64_t v9 = a2;
  char v10 = a3;
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (std::__shared_weak_count *)a4[1];
  v8[0] = *a4;
  v8[1] = (uint64_t)v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::DaVinci::TexturedCompressedMesh::TexturedCompressedMesh(a1, (uint64_t)"DV Asset Mesh", &v9, v8);
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    ggl::DaVinci::TexturedCompressedMesh::TexturedCompressedMesh(a1, (uint64_t)"DV Asset Mesh", &v9, v8);
  }
  unint64_t v6 = v10;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  return a1;
}

char *std::vector<md::Mesh>::__emplace_back_slow_path<std::shared_ptr<ggl::DaVinci::TexturedCompressedMesh> &,gm::Range<unsigned long>,ggl::PrimitiveType,gm::Box<float,3> &,md::MeshVertexFormat,BOOL>(void **a1, uint64_t a2, std::__shared_weak_count *a3, _OWORD *a4, char *a5, uint64_t a6, char *a7, char *a8)
{
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 4);
  unint64_t v9 = v8 + 1;
  if (v8 + 1 > 0x333333333333333) {
    abort();
  }
  if (0x999999999999999ALL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) > v9) {
    unint64_t v9 = 0x999999999999999ALL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4);
  }
  if (0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) >= 0x199999999999999) {
    unint64_t v15 = 0x333333333333333;
  }
  else {
    unint64_t v15 = v9;
  }
  if (v15)
  {
    uint64_t v36 = a6;
    if (v15 > 0x333333333333333) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v16 = a2;
    unint64_t v17 = a4;
    uint64_t v18 = (char *)operator new(80 * v15);
    a4 = v17;
    a2 = v16;
    a6 = v36;
  }
  else
  {
    uint64_t v18 = 0;
  }
  unint64_t v19 = &v18[80 * v8];
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    char v20 = *a5;
    char v21 = *a7;
    char v22 = *a8;
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    unint64_t v23 = a3;
  }
  else
  {
    unint64_t v23 = 0;
    char v20 = *a5;
    char v21 = *a7;
    char v22 = *a8;
  }
  *(void *)unint64_t v19 = a2;
  *((void *)v19 + 1) = v23;
  unint64_t v24 = &v18[80 * v8];
  *((_OWORD *)v24 + 1) = *a4;
  v24[32] = v20;
  *(_OWORD *)(v24 + 36) = *(_OWORD *)a6;
  *(void *)(v24 + 52) = *(void *)(a6 + 16);
  v24[60] = v22;
  v24[61] = v21;
  *((void *)v24 + 8) = 0;
  *((void *)v24 + 9) = 0;
  if (a3 && !atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
    std::__shared_weak_count::__release_weak(a3);
  }
  long long v25 = &v18[80 * v15];
  uint64_t v26 = v19 + 80;
  unint64_t v27 = (char *)*a1;
  long long v28 = (char *)a1[1];
  if (v28 == *a1)
  {
    *a1 = v19;
    a1[1] = v26;
    a1[2] = v25;
  }
  else
  {
    do
    {
      long long v29 = *((_OWORD *)v28 - 5);
      v28 -= 80;
      *((_OWORD *)v19 - 5) = v29;
      v19 -= 80;
      *(void *)long long v28 = 0;
      *((void *)v28 + 1) = 0;
      long long v30 = *((_OWORD *)v28 + 1);
      long long v31 = *((_OWORD *)v28 + 2);
      *(_OWORD *)(v19 + 46) = *(_OWORD *)(v28 + 46);
      *((_OWORD *)v19 + 1) = v30;
      *((_OWORD *)v19 + 2) = v31;
      *((_OWORD *)v19 + 4) = *((_OWORD *)v28 + 4);
      *((void *)v28 + 8) = 0;
      *((void *)v28 + 9) = 0;
    }
    while (v28 != v27);
    long long v28 = (char *)*a1;
    uint64_t v32 = (char *)a1[1];
    *a1 = v19;
    a1[1] = v26;
    a1[2] = v25;
    while (v32 != v28)
    {
      uint64_t v33 = (std::__shared_weak_count *)*((void *)v32 - 1);
      if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
        uint64_t v34 = (std::__shared_weak_count *)*((void *)v32 - 9);
        if (v34)
        {
LABEL_25:
          if (!atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
            std::__shared_weak_count::__release_weak(v34);
          }
        }
      }
      else
      {
        uint64_t v34 = (std::__shared_weak_count *)*((void *)v32 - 9);
        if (v34) {
          goto LABEL_25;
        }
      }
      v32 -= 80;
    }
  }
  if (v28) {
    operator delete(v28);
  }
  return v26;
}

void std::__hash_table<std::__hash_value_type<unsigned short,unsigned long long>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned long long>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned long long>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned long long>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<unsigned short,unsigned long long>,void *> *>>(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[1];
  if (!v4) {
    goto LABEL_7;
  }
  for (uint64_t i = 0; i != v4; ++i)
    *(void *)(*a1 + 8 * i) = 0;
  unint64_t v6 = (_WORD *)a1[2];
  a1[2] = 0;
  a1[3] = 0;
  if (v6)
  {
    while (a2)
    {
      v6[8] = *((_WORD *)a2 + 8);
      *((void *)v6 + 3) = a2[3];
      unint64_t v7 = *(_WORD **)v6;
      std::__hash_table<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short>>::__node_insert_multi((uint64_t)a1, (uint64_t)v6);
      a2 = (uint64_t *)*a2;
      unint64_t v6 = v7;
      if (!v7) {
        goto LABEL_7;
      }
    }
    do
    {
      unint64_t v9 = *(_WORD **)v6;
      operator delete(v6);
      unint64_t v6 = v9;
    }
    while (v9);
  }
  else
  {
LABEL_7:
    while (a2)
    {
      unint64_t v8 = operator new(0x20uLL);
      *(void *)unint64_t v8 = 0;
      v8[1] = *((_OWORD *)a2 + 1);
      *((void *)v8 + 1) = *((unsigned __int16 *)v8 + 8);
      std::__hash_table<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short>>::__node_insert_multi((uint64_t)a1, (uint64_t)v8);
      a2 = (uint64_t *)*a2;
    }
  }
}

void sub_1A2544AB0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<unsigned short,unsigned long long>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  unint64_t prime = *(void *)(a2 + 8);
  if (prime == 1)
  {
    unint64_t prime = 2;
LABEL_17:
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    goto LABEL_18;
  }
  if ((prime & (prime - 1)) != 0)
  {
    unint64_t prime = std::__next_prime(*(void *)(a2 + 8));
    int8x8_t v5 = *(int8x8_t *)(a1 + 8);
    BOOL v6 = prime >= *(void *)&v5;
    if (prime > *(void *)&v5) {
      goto LABEL_17;
    }
  }
  else
  {
    int8x8_t v5 = 0;
    BOOL v6 = 1;
    if (prime) {
      goto LABEL_17;
    }
  }
  if (!v6)
  {
    unint64_t v7 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v5 < 3uLL || (uint8x8_t v8 = (uint8x8_t)vcnt_s8(v5), v8.i16[0] = vaddlv_u8(v8), v8.u32[0] > 1uLL))
    {
      unint64_t v7 = std::__next_prime(v7);
    }
    else
    {
      uint64_t v9 = 1 << -(char)__clz(v7 - 1);
      if (v7 >= 2) {
        unint64_t v7 = v9;
      }
    }
    if (prime <= v7) {
      unint64_t prime = v7;
    }
    if (prime < *(void *)&v5) {
      goto LABEL_17;
    }
  }
LABEL_18:
  char v10 = *(uint64_t **)(a2 + 16);
  if (v10)
  {
    unint64_t v11 = (void *)(a1 + 16);
    unint64_t v12 = *(void *)(a1 + 8);
    do
    {
      unint64_t v13 = *((unsigned __int16 *)v10 + 8);
      if (v12)
      {
        uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
        v14.i16[0] = vaddlv_u8(v14);
        if (v14.u32[0] > 1uLL)
        {
          unint64_t prime = *((unsigned __int16 *)v10 + 8);
          if (v12 <= v13) {
            unint64_t prime = v13 % v12;
          }
        }
        else
        {
          unint64_t prime = (v12 - 1) & v13;
        }
        unint64_t v15 = *(uint64_t ****)(*(void *)a1 + 8 * prime);
        if (v15)
        {
          uint64_t v16 = *v15;
          if (v16)
          {
            if (v14.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v18 = v16[1];
                if (v18 == (uint64_t *)v13)
                {
                  if (*((unsigned __int16 *)v16 + 8) == v13) {
                    goto LABEL_78;
                  }
                }
                else if (((unint64_t)v18 & (v12 - 1)) != prime)
                {
                  goto LABEL_40;
                }
                uint64_t v16 = (uint64_t **)*v16;
                if (!v16) {
                  goto LABEL_40;
                }
              }
            }
            do
            {
              unint64_t v17 = (unint64_t)v16[1];
              if (v17 == v13)
              {
                if (*((unsigned __int16 *)v16 + 8) == v13) {
                  goto LABEL_78;
                }
              }
              else
              {
                if (v17 >= v12) {
                  v17 %= v12;
                }
                if (v17 != prime) {
                  break;
                }
              }
              uint64_t v16 = (uint64_t **)*v16;
            }
            while (v16);
          }
        }
      }
LABEL_40:
      unint64_t v19 = operator new(0x20uLL);
      *unint64_t v19 = 0;
      v19[1] = v13;
      *((_OWORD *)v19 + 1) = *((_OWORD *)v10 + 1);
      float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
      float v21 = *(float *)(a1 + 32);
      if (!v12 || (float)(v21 * (float)v12) < v20)
      {
        BOOL v22 = (v12 & (v12 - 1)) != 0;
        if (v12 < 3) {
          BOOL v22 = 1;
        }
        unint64_t v23 = v22 | (2 * v12);
        unint64_t v24 = vcvtps_u32_f32(v20 / v21);
        if (v23 <= v24) {
          size_t v25 = v24;
        }
        else {
          size_t v25 = v23;
        }
        if (v25 == 1)
        {
          size_t v25 = 2;
        }
        else if ((v25 & (v25 - 1)) != 0)
        {
          size_t v25 = std::__next_prime(v25);
          unint64_t v12 = *(void *)(a1 + 8);
        }
        if (v25 > v12) {
          goto LABEL_52;
        }
        if (v25 < v12)
        {
          unint64_t v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
          if (v12 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
          {
            unint64_t v26 = std::__next_prime(v26);
          }
          else
          {
            uint64_t v28 = 1 << -(char)__clz(v26 - 1);
            if (v26 >= 2) {
              unint64_t v26 = v28;
            }
          }
          if (v25 <= v26) {
            size_t v25 = v26;
          }
          if (v25 < v12) {
LABEL_52:
          }
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, v25);
        }
        unint64_t v12 = *(void *)(a1 + 8);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v12 <= v13) {
            unint64_t prime = v13 % v12;
          }
          else {
            unint64_t prime = v13;
          }
        }
        else
        {
          unint64_t prime = (v12 - 1) & v13;
        }
      }
      uint64_t v29 = *(void *)a1;
      long long v30 = *(void **)(*(void *)a1 + 8 * prime);
      if (v30)
      {
        *unint64_t v19 = *v30;
      }
      else
      {
        *unint64_t v19 = *v11;
        void *v11 = v19;
        *(void *)(v29 + 8 * prime) = v11;
        if (!*v19) {
          goto LABEL_77;
        }
        unint64_t v31 = *(void *)(*v19 + 8);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v31 >= v12) {
            v31 %= v12;
          }
        }
        else
        {
          v31 &= v12 - 1;
        }
        long long v30 = (void *)(*(void *)a1 + 8 * v31);
      }
      void *v30 = v19;
LABEL_77:
      ++*(void *)(a1 + 24);
LABEL_78:
      char v10 = (uint64_t *)*v10;
    }
    while (v10);
  }
  return a1;
}

void sub_1A2544E78(_Unwind_Exception *a1)
{
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<md::AssetData::AssetData(gdc::LayerDataRequestKey const&,std::shared_ptr<md::DaVinciAssetResource> &,VKSharedResources *)::$_0,std::allocator<md::AssetData::AssetData(gdc::LayerDataRequestKey const&,std::shared_ptr<md::DaVinciAssetResource> &,VKSharedResources *)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF579338;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::AssetData::AssetData(gdc::LayerDataRequestKey const&,std::shared_ptr<md::DaVinciAssetResource> &,VKSharedResources *)::$_0,std::allocator<md::AssetData::AssetData(gdc::LayerDataRequestKey const&,std::shared_ptr<md::DaVinciAssetResource> &,VKSharedResources *)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF579338;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::AssetData::AssetData(gdc::LayerDataRequestKey const&,std::shared_ptr<md::DaVinciAssetResource> &,VKSharedResources *)::$_0,std::allocator<md::AssetData::AssetData(gdc::LayerDataRequestKey const&,std::shared_ptr<md::DaVinciAssetResource> &,VKSharedResources *)::$_0>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

uint64_t *md::AssetData::getMaterialID(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4, char a5, unsigned int a6)
{
  unint64_t v6 = (a2 - a1) >> 4;
  if (v6 < a3) {
    return 0;
  }
  if (v6 <= a3) {
    goto LABEL_129;
  }
  uint8x8_t v8 = *(void **)(a1 + 16 * a3);
  if (!a5)
  {
    uint64_t v12 = v8[6];
    if (!v12) {
      return 0;
    }
    unint64_t v13 = *(void *)(v12 + 32);
    if (!v13) {
      return 0;
    }
    uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
    v14.i16[0] = vaddlv_u8(v14);
    if (v14.u32[0] > 1uLL)
    {
      unint64_t v15 = a6;
      if (v13 <= a6) {
        unint64_t v15 = a6 % v13;
      }
    }
    else
    {
      unint64_t v15 = (v13 - 1) & a6;
    }
    uint64_t v22 = *(void *)(v12 + 24);
    unint64_t v23 = *(uint64_t ****)(v22 + 8 * v15);
    if (!v23) {
      return 0;
    }
    unint64_t v24 = *v23;
    if (!*v23) {
      return 0;
    }
    unint64_t v25 = v13 - 1;
    if (v14.u32[0] < 2uLL)
    {
      while (1)
      {
        unint64_t v26 = v24[1];
        if (v26 == (uint64_t *)a6)
        {
          if (*((unsigned __int16 *)v24 + 8) == a6) {
            goto LABEL_70;
          }
        }
        else if (((unint64_t)v26 & v25) != v15)
        {
          return 0;
        }
        __n128 result = 0;
        unint64_t v24 = (uint64_t **)*v24;
        if (!v24) {
          return result;
        }
      }
    }
    while (1)
    {
      unint64_t v27 = (unint64_t)v24[1];
      if (v27 == a6)
      {
        if (*((unsigned __int16 *)v24 + 8) == a6)
        {
LABEL_70:
          if (v14.u32[0] > 1uLL)
          {
            unint64_t v36 = a6;
            if (v13 <= a6) {
              unint64_t v36 = a6 % v13;
            }
          }
          else
          {
            unint64_t v36 = (v13 - 1) & a6;
          }
          unsigned int v43 = *(uint64_t ****)(v22 + 8 * v36);
          if (!v43) {
            goto LABEL_129;
          }
          uint32x4_t v44 = *v43;
          if (!v44) {
            goto LABEL_129;
          }
          if (v14.u32[0] < 2uLL)
          {
            while (1)
            {
              uint32x4_t v45 = v44[1];
              if (v45 == (uint64_t *)a6)
              {
                if (*((unsigned __int16 *)v44 + 8) == a6) {
                  return v44[3];
                }
              }
              else if (((unint64_t)v45 & v25) != v36)
              {
                goto LABEL_129;
              }
              uint32x4_t v44 = (uint64_t **)*v44;
              if (!v44) {
                goto LABEL_129;
              }
            }
          }
          while (1)
          {
            unint64_t v46 = (unint64_t)v44[1];
            if (v46 == a6)
            {
              if (*((unsigned __int16 *)v44 + 8) == a6) {
                return v44[3];
              }
            }
            else
            {
              if (v46 >= v13) {
                v46 %= v13;
              }
              if (v46 != v36) {
                goto LABEL_129;
              }
            }
            uint32x4_t v44 = (uint64_t **)*v44;
            if (!v44) {
              goto LABEL_129;
            }
          }
        }
      }
      else
      {
        if (v27 >= v13) {
          v27 %= v13;
        }
        if (v27 != v15) {
          return 0;
        }
      }
      __n128 result = 0;
      unint64_t v24 = (uint64_t **)*v24;
      if (!v24) {
        return result;
      }
    }
  }
  int8x8_t v9 = (int8x8_t)v8[5];
  if (!*(void *)&v9) {
    return 0;
  }
  uint8x8_t v10 = (uint8x8_t)vcnt_s8(v9);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v11 = a4;
    if (*(void *)&v9 <= a4) {
      unint64_t v11 = a4 % *(void *)&v9;
    }
  }
  else
  {
    unint64_t v11 = (*(void *)&v9 - 1) & a4;
  }
  uint64_t v16 = v8[4];
  unint64_t v17 = *(void **)(v16 + 8 * v11);
  if (!v17) {
    return 0;
  }
  uint64_t v18 = (void *)*v17;
  if (!*v17) {
    return 0;
  }
  uint64_t v19 = *(void *)&v9 - 1;
  if (v10.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v20 = v18[1];
      if (v20 == a4)
      {
        if (v18[2] == a4) {
          goto LABEL_48;
        }
      }
      else if ((v20 & v19) != v11)
      {
        return 0;
      }
      __n128 result = 0;
      uint64_t v18 = (void *)*v18;
      if (!v18) {
        return result;
      }
    }
  }
  while (1)
  {
    unint64_t v21 = v18[1];
    if (v21 != a4)
    {
      if (v21 >= *(void *)&v9) {
        v21 %= *(void *)&v9;
      }
      if (v21 != v11) {
        return 0;
      }
      goto LABEL_24;
    }
    if (v18[2] == a4) {
      break;
    }
LABEL_24:
    __n128 result = 0;
    uint64_t v18 = (void *)*v18;
    if (!v18) {
      return result;
    }
  }
LABEL_48:
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v28 = a4;
    if (*(void *)&v9 <= a4) {
      unint64_t v28 = a4 % *(void *)&v9;
    }
  }
  else
  {
    unint64_t v28 = v19 & a4;
  }
  uint64_t v29 = *(void **)(v16 + 8 * v28);
  if (!v29) {
    goto LABEL_129;
  }
  long long v30 = (void *)*v29;
  if (!*v29) {
    goto LABEL_129;
  }
  if (v10.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v31 = v30[1];
      if (v31 == a4)
      {
        if (v30[2] == a4) {
          goto LABEL_60;
        }
      }
      else if ((v31 & v19) != v28)
      {
        goto LABEL_129;
      }
      long long v30 = (void *)*v30;
      if (!v30) {
        goto LABEL_129;
      }
    }
  }
  while (2)
  {
    unint64_t v35 = v30[1];
    if (v35 != a4)
    {
      if (v35 >= *(void *)&v9) {
        v35 %= *(void *)&v9;
      }
      if (v35 != v28) {
        goto LABEL_129;
      }
      goto LABEL_64;
    }
    if (v30[2] != a4)
    {
LABEL_64:
      long long v30 = (void *)*v30;
      if (!v30) {
        goto LABEL_129;
      }
      continue;
    }
    break;
  }
LABEL_60:
  unint64_t v32 = v30[4];
  if (v32)
  {
    uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v32);
    v33.i16[0] = vaddlv_u8(v33);
    if (v33.u32[0] > 1uLL)
    {
      unint64_t v34 = a6;
      if (v32 <= a6) {
        unint64_t v34 = a6 % v32;
      }
    }
    else
    {
      unint64_t v34 = (v32 - 1) & a6;
    }
    uint64_t v37 = v30[3];
    uint64_t v38 = *(uint64_t ****)(v37 + 8 * v34);
    if (v38)
    {
      float32x4_t v39 = *v38;
      if (*v38)
      {
        unint64_t v40 = v32 - 1;
        if (v33.u32[0] < 2uLL)
        {
          while (1)
          {
            int16x8_t v41 = v39[1];
            if (v41 == (uint64_t *)a6)
            {
              if (*((unsigned __int16 *)v39 + 8) == a6) {
                goto LABEL_109;
              }
            }
            else if (((unint64_t)v41 & v40) != v34)
            {
              return 0;
            }
            __n128 result = 0;
            float32x4_t v39 = (uint64_t **)*v39;
            if (!v39) {
              return result;
            }
          }
        }
        while (1)
        {
          unint64_t v42 = (unint64_t)v39[1];
          if (v42 == a6)
          {
            if (*((unsigned __int16 *)v39 + 8) == a6)
            {
LABEL_109:
              if (v33.u32[0] > 1uLL)
              {
                unint64_t v47 = a6;
                if (v32 <= a6) {
                  unint64_t v47 = a6 % v32;
                }
              }
              else
              {
                unint64_t v47 = (v32 - 1) & a6;
              }
              uint32x4_t v48 = *(uint64_t ****)(v37 + 8 * v47);
              if (v48)
              {
                uint32x4_t v44 = *v48;
                if (v44)
                {
                  if (v33.u32[0] < 2uLL)
                  {
                    while (1)
                    {
                      int8x16_t v49 = v44[1];
                      if (v49 == (uint64_t *)a6)
                      {
                        if (*((unsigned __int16 *)v44 + 8) == a6) {
                          return v44[3];
                        }
                      }
                      else if (((unint64_t)v49 & v40) != v47)
                      {
                        goto LABEL_129;
                      }
                      uint32x4_t v44 = (uint64_t **)*v44;
                      if (!v44) {
                        goto LABEL_129;
                      }
                    }
                  }
                  do
                  {
                    unint64_t v50 = (unint64_t)v44[1];
                    if (v50 == a6)
                    {
                      if (*((unsigned __int16 *)v44 + 8) == a6) {
                        return v44[3];
                      }
                    }
                    else
                    {
                      if (v50 >= v32) {
                        v50 %= v32;
                      }
                      if (v50 != v47) {
                        break;
                      }
                    }
                    uint32x4_t v44 = (uint64_t **)*v44;
                  }
                  while (v44);
                }
              }
LABEL_129:
              abort();
            }
          }
          else
          {
            if (v42 >= v32) {
              v42 %= v32;
            }
            if (v42 != v34) {
              return 0;
            }
          }
          __n128 result = 0;
          float32x4_t v39 = (uint64_t **)*v39;
          if (!v39) {
            return result;
          }
        }
      }
    }
  }
  return 0;
}

void sub_1A25455B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL49GEOGetVectorKitVKPuckAnimatorLocationProjectorLogv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.VectorKit", "VKPuckAnimatorLocationProjector");
  uint64_t v1 = (void *)GEOGetVectorKitVKPuckAnimatorLocationProjectorLog(void)::log;
  GEOGetVectorKitVKPuckAnimatorLocationProjectorLog(void)::log = (uint64_t)v0;
}

void sub_1A2545870(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A25458EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint8x8_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VKPuckAnimatorLocationProjector;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void ggl::VSView::PipelineState::~PipelineState(ggl::VSView::PipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::VSView::PipelineSetup::textureIsEnabled(ggl::VSView::PipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::VSView::PipelineSetup::constantDataIsEnabled(ggl::VSView::PipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

void ggl::VSView::PipelineSetup::~PipelineSetup(ggl::VSView::PipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::VSView::StretchAlphaPipelineState::~StretchAlphaPipelineState(ggl::VSView::StretchAlphaPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::VSView::StretchAlphaPipelineSetup::textureIsEnabled(ggl::VSView::StretchAlphaPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::VSView::StretchAlphaPipelineSetup::constantDataIsEnabled(ggl::VSView::StretchAlphaPipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

void ggl::VSView::StretchAlphaPipelineSetup::~StretchAlphaPipelineSetup(ggl::VSView::StretchAlphaPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::GlowAlpha::MeshPipelineState::~MeshPipelineState(ggl::GlowAlpha::MeshPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::GlowAlpha::MeshPipelineSetup::textureIsEnabled(ggl::GlowAlpha::MeshPipelineSetup *this)
{
  return 0;
}

BOOL ggl::GlowAlpha::MeshPipelineSetup::constantDataIsEnabled(ggl::GlowAlpha::MeshPipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::GlowAlpha::MeshPipelineSetup::~MeshPipelineSetup(ggl::GlowAlpha::MeshPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

float md::NavShieldLabelPart::updateWithNavLabelStyle(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a2 + 8);
  if (v4 != *(unsigned __int8 *)(a1 + 768))
  {
    *(unsigned char *)(a1 + 768) = v4;
    *(unsigned char *)(a1 + 565) = v4 != 0;
    if (v4) {
      operator new();
    }
    uint64_t v6 = *(void *)(a1 + 776);
    *(void *)(a1 + 776) = 0;
    if (v6) {
      MEMORY[0x1A6239270](v6, 0x1000C40AE2C30F4);
    }
  }
  float result = *(float *)a2;
  *(_DWORD *)(a1 + 596) = *(_DWORD *)a2;
  return result;
}

void md::NavShieldLabelPart::debugString(char *a1@<X8>)
{
  a1[23] = 18;
  strcpy(a1, "NavShieldLabelPart");
}

void md::NavShieldLabelPart::~NavShieldLabelPart(md::NavShieldLabelPart *this)
{
  *(void *)this = &unk_1EF531878;
  uint64_t v2 = *((void *)this + 102);
  *((void *)this + 102) = 0;
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40AE2C30F4);
  }
  uint64_t v3 = *((void *)this + 97);
  *((void *)this + 97) = 0;
  if (v3) {
    MEMORY[0x1A6239270](v3, 0x1000C40AE2C30F4);
  }
  md::IconLabelPart::~IconLabelPart(this);
  int v4 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    int v4 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v6) {
      operator new();
    }
  }
  int8x8_t v5 = *(void (**)(void))(**((void **)v4 + 91) + 40);
  v5();
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF531878;
  uint64_t v2 = *((void *)this + 102);
  *((void *)this + 102) = 0;
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40AE2C30F4);
  }
  uint64_t v3 = *((void *)this + 97);
  *((void *)this + 97) = 0;
  if (v3) {
    MEMORY[0x1A6239270](v3, 0x1000C40AE2C30F4);
  }
  md::IconLabelPart::~IconLabelPart(this);
}

uint64_t md::NavShield::type(md::NavShield *this)
{
  return 3;
}

void md::NavShield::~NavShield(md::NavShield *this)
{
  md::NavLabel::~NavLabel(this);
  JUMPOUT(0x1A6239270);
}

void *std::function<void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::ProcessRenderableForStyleRouteLineMask::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *>)::$_0,std::allocator<md::ita::ProcessRenderableForStyleRouteLineMask::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *)>::operator()(uint64_t a1, uint64_t a2, unint64_t *a3, int *a4, unint64_t **a5)
{
  uint64_t v365 = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *a5;
  if (*((unsigned char *)a4 + 32))
  {
    _S8 = a4[5];
    _S9 = a4[6];
    _S10 = 1.0;
    _S11 = a4[7];
    if (v7)
    {
LABEL_3:
      unint64_t v12 = *v7;
      unint64_t v357 = v12;
      unint64_t v13 = v12;
      goto LABEL_4;
    }
  }
  else
  {
    if (!*((unsigned char *)a4 + 16))
    {
      if (v7)
      {
        unsigned int v43 = **(void ***)(a1 + 8);
        unint64_t v44 = *v7;
        unint64_t v45 = *v7;
        uint64_t v46 = v43[269];
        if (v45 < (v43[270] - v46) >> 3)
        {
          uint64_t v47 = *(void *)(v46 + 8 * v45);
          if (v47 && HIDWORD(v44) == HIDWORD(v47))
          {
            int8x16_t v49 = (unsigned char *)(v43[272] + 24 * v47);
            if (v49 != (unsigned char *)v43[273] && v49 != 0)
            {
              float32x4_t v51 = std::__hash_table<std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>,std::hash<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,true>,std::__unordered_map_equal<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>,std::equal_to<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::CachedKey<md::ColorStyleCacheKey>> const&>,std::tuple<>>((uint64_t)(v43 + 256), v44, v7);
              ++v51[3];
              *int8x16_t v49 = 0;
            }
          }
        }
      }
      return;
    }
    _S8 = *a4;
    _S9 = a4[1];
    _S11 = a4[2];
    _S10 = *((float *)a4 + 3);
    if (v7) {
      goto LABEL_3;
    }
  }
  uint64_t v33 = **(void **)(a1 + 8);
  uint64_t v34 = *(void *)(v33 + 2136);
  if (*(void *)(v33 + 2128) == v34)
  {
    uint64_t v52 = (-1431655765 * ((*(void *)(v33 + 2184) - *(void *)(v33 + 2176)) >> 3)) | 0x100000000;
    float32x4_t v53 = *(uint64_t **)(v33 + 2160);
    unint64_t v54 = *(void *)(v33 + 2168);
    if ((unint64_t)v53 >= v54)
    {
      float64x2_t v62 = *(char **)(v33 + 2152);
      uint64_t v63 = ((char *)v53 - v62) >> 3;
      unint64_t v64 = v63 + 1;
      if ((unint64_t)(v63 + 1) >> 61) {
        goto LABEL_705;
      }
      uint64_t v65 = v54 - (void)v62;
      if (v65 >> 2 > v64) {
        unint64_t v64 = v65 >> 2;
      }
      if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v66 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v66 = v64;
      }
      if (v66)
      {
        if (v66 >> 61) {
          goto LABEL_702;
        }
        float64x2_t v67 = (char *)operator new(8 * v66);
      }
      else
      {
        float64x2_t v67 = 0;
      }
      uint64_t v227 = (uint64_t *)&v67[8 * v63];
      *uint64_t v227 = v52;
      float64x2_t v55 = v227 + 1;
      if (v53 != (uint64_t *)v62)
      {
        unint64_t v228 = (char *)v53 - v62 - 8;
        if (v228 < 0x58) {
          goto LABEL_708;
        }
        if ((unint64_t)(v62 - v67) < 0x20) {
          goto LABEL_708;
        }
        uint64_t v229 = (v228 >> 3) + 1;
        float32x4_t v230 = &v67[(char *)v53 - v62 - 16];
        float32x4_t v231 = v53 - 2;
        uint64_t v232 = v229 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v233 = *(_OWORD *)v231;
          *((_OWORD *)v230 - 1) = *((_OWORD *)v231 - 1);
          *(_OWORD *)float32x4_t v230 = v233;
          v230 -= 32;
          v231 -= 4;
          v232 -= 4;
        }
        while (v232);
        v227 -= v229 & 0x3FFFFFFFFFFFFFFCLL;
        v53 -= v229 & 0x3FFFFFFFFFFFFFFCLL;
        if (v229 != (v229 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_708:
          do
          {
            uint64_t v234 = *--v53;
            *--uint64_t v227 = v234;
          }
          while (v53 != (uint64_t *)v62);
        }
        float32x4_t v53 = *(uint64_t **)(v33 + 2152);
      }
      *(void *)(v33 + 2152) = v227;
      *(void *)(v33 + 2160) = v55;
      *(void *)(v33 + 2168) = &v67[8 * v66];
      if (v53) {
        operator delete(v53);
      }
    }
    else
    {
      *float32x4_t v53 = v52;
      float64x2_t v55 = v53 + 1;
    }
    *(void *)(v33 + 2160) = v55;
    unint64_t v12 = *(v55 - 1);
  }
  else
  {
    uint64_t v35 = *(void *)(v34 - 8);
    *(void *)(v33 + 2136) = v34 - 8;
    *(_DWORD *)(*(void *)(v33 + 2152) + 8 * v35) = -1431655765
                                                   * ((*(void *)(v33 + 2184) - *(void *)(v33 + 2176)) >> 3);
    *(_DWORD *)(*(void *)(v33 + 2152) + 8 * v35 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(v33 + 2152)
                                                                                             + 8 * v35
                                                                                             + 4) << 32)
                                                        + 0x100000000) >> 32;
    unint64_t v12 = v35 | ((unint64_t)*(unsigned int *)(*(void *)(v33 + 2152) + 8 * v35 + 4) << 32);
  }
  uint64_t v235 = *(unsigned char **)(v33 + 2184);
  unint64_t v236 = *(void *)(v33 + 2192);
  if ((unint64_t)v235 >= v236)
  {
    unsigned int v238 = *(unsigned char **)(v33 + 2176);
    unint64_t v239 = 0xAAAAAAAAAAAAAAABLL * ((v235 - v238) >> 3) + 1;
    if (v239 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_705;
    }
    unint64_t v240 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v236 - (void)v238) >> 3);
    if (2 * v240 > v239) {
      unint64_t v239 = 2 * v240;
    }
    if (v240 >= 0x555555555555555) {
      unint64_t v241 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v241 = v239;
    }
    if (v241)
    {
      if (v241 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_702;
      }
      uint64_t v242 = (char *)operator new(24 * v241);
    }
    else
    {
      uint64_t v242 = 0;
    }
    float32x4_t v243 = &v242[8 * ((v235 - v238) >> 3)];
    *float32x4_t v243 = 0;
    *((_DWORD *)v243 + 1) = _S8;
    *((_DWORD *)v243 + 2) = _S9;
    *((_DWORD *)v243 + 3) = _S11;
    *((float *)v243 + 4) = _S10;
    v243[20] = 1;
    int v237 = v243 + 24;
    if (v235 == v238)
    {
      float32x4_t v246 = &v242[8 * ((v235 - v238) >> 3)];
    }
    else
    {
      uint64_t v244 = v235;
      do
      {
        char v245 = *(v244 - 24);
        v244 -= 24;
        *(v243 - 20) = 0;
        *(v243 - 24) = v245;
        float32x4_t v246 = v243 - 24;
        *(v243 - 4) = 0;
        if (v244[20])
        {
          *(_OWORD *)(v243 - 20) = *(_OWORD *)(v235 - 20);
          *(v243 - 4) = 1;
        }
        uint64_t v235 = v244;
        v243 -= 24;
      }
      while (v244 != v238);
      uint64_t v235 = *(unsigned char **)(v33 + 2176);
    }
    *(void *)(v33 + 2176) = v246;
    *(void *)(v33 + 2184) = v237;
    *(void *)(v33 + 2192) = &v242[24 * v241];
    if (v235) {
      operator delete(v235);
    }
  }
  else
  {
    *uint64_t v235 = 0;
    *((_DWORD *)v235 + 1) = _S8;
    *((_DWORD *)v235 + 2) = _S9;
    *((_DWORD *)v235 + 3) = _S11;
    *((float *)v235 + 4) = _S10;
    int v237 = v235 + 24;
    v235[20] = 1;
  }
  *(void *)(v33 + 2184) = v237;
  unint64_t v13 = v12;
  unint64_t v247 = *(void *)(v33 + 2208);
  unint64_t v248 = *(void *)(v33 + 2216);
  if (v247 >= v248)
  {
    uint64_t v250 = *(unsigned char **)(v33 + 2200);
    uint64_t v251 = (uint64_t)(v247 - (void)v250) >> 3;
    unint64_t v252 = v251 + 1;
    if ((unint64_t)(v251 + 1) >> 61) {
      goto LABEL_705;
    }
    uint64_t v253 = v248 - (void)v250;
    if (v253 >> 2 > v252) {
      unint64_t v252 = v253 >> 2;
    }
    if ((unint64_t)v253 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v254 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v254 = v252;
    }
    if (v254)
    {
      if (v254 >> 61) {
        goto LABEL_702;
      }
      uint64_t v255 = operator new(8 * v254);
    }
    else
    {
      uint64_t v255 = 0;
    }
    uint64_t v256 = &v255[8 * v251];
    *uint64_t v256 = v12;
    unint64_t v249 = (unint64_t)(v256 + 1);
    if ((unsigned char *)v247 != v250)
    {
      unint64_t v257 = v247 - (void)v250 - 8;
      if (v257 < 0x58) {
        goto LABEL_709;
      }
      if ((unint64_t)(v250 - v255) < 0x20) {
        goto LABEL_709;
      }
      uint64_t v258 = (v257 >> 3) + 1;
      long long v259 = &v255[v247 - (void)v250 - 16];
      float64x2_t v260 = (long long *)(v247 - 16);
      uint64_t v261 = v258 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v262 = *v260;
        *(v259 - 1) = *(v260 - 1);
        *long long v259 = v262;
        v259 -= 2;
        v260 -= 2;
        v261 -= 4;
      }
      while (v261);
      v256 -= v258 & 0x3FFFFFFFFFFFFFFCLL;
      v247 -= 8 * (v258 & 0x3FFFFFFFFFFFFFFCLL);
      if (v258 != (v258 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_709:
        do
        {
          uint64_t v263 = *(void *)(v247 - 8);
          v247 -= 8;
          *--uint64_t v256 = v263;
        }
        while ((unsigned char *)v247 != v250);
      }
    }
    *(void *)(v33 + 2200) = v256;
    *(void *)(v33 + 2208) = v249;
    *(void *)(v33 + 2216) = &v255[8 * v254];
    if (v250) {
      operator delete(v250);
    }
  }
  else
  {
    *(void *)unint64_t v247 = v12;
    v247 += 8;
    unint64_t v249 = v247;
  }
  int v264 = (uint64_t *)(v33 + 2048);
  *(void *)(v33 + 2208) = v249;
  unint64_t v265 = *(void *)(v33 + 2056);
  if (v265)
  {
    uint8x8_t v266 = (uint8x8_t)vcnt_s8((int8x8_t)v265);
    v266.i16[0] = vaddlv_u8(v266);
    if (v266.u32[0] > 1uLL)
    {
      unint64_t v249 = v12;
      if (v12 >= v265) {
        unint64_t v249 = v12 % v265;
      }
    }
    else
    {
      unint64_t v249 = (v265 - 1) & v12;
    }
    uint64_t v267 = *(void **)(*v264 + 8 * v249);
    if (v267)
    {
      uint64_t v268 = (void *)*v267;
      if (v268)
      {
        if (v266.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v270 = v268[1];
            if (v270 == v12)
            {
              if (v268[2] == v12) {
                goto LABEL_520;
              }
            }
            else if ((v270 & (v265 - 1)) != v249)
            {
              goto LABEL_482;
            }
            uint64_t v268 = (void *)*v268;
            if (!v268) {
              goto LABEL_482;
            }
          }
        }
        do
        {
          unint64_t v269 = v268[1];
          if (v269 == v12)
          {
            if (v268[2] == v12) {
              goto LABEL_520;
            }
          }
          else
          {
            if (v269 >= v265) {
              v269 %= v265;
            }
            if (v269 != v249) {
              break;
            }
          }
          uint64_t v268 = (void *)*v268;
        }
        while (v268);
      }
    }
  }
LABEL_482:
  unint64_t v247 = (unint64_t)operator new(0x30uLL);
  *(void *)unint64_t v247 = 0;
  *(void *)(v247 + 8) = v12;
  *(void *)(v247 + 16) = v12;
  *(_OWORD *)(v247 + 24) = xmmword_1A28FCC60;
  *(unsigned char *)(v247 + 40) = 0;
  float v271 = (float)(unint64_t)(*(void *)(v33 + 2072) + 1);
  float v272 = *(float *)(v33 + 2080);
  if (!v265 || (float)(v272 * (float)v265) < v271)
  {
    BOOL v273 = 1;
    if (v265 >= 3) {
      BOOL v273 = (v265 & (v265 - 1)) != 0;
    }
    unint64_t v274 = v273 | (2 * v265);
    unint64_t v275 = vcvtps_u32_f32(v271 / v272);
    if (v274 <= v275) {
      size_t prime = v275;
    }
    else {
      size_t prime = v274;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v265 = *(void *)(v33 + 2056);
    }
    if (prime > v265) {
      goto LABEL_494;
    }
    if (prime < v265)
    {
      unint64_t v277 = vcvtps_u32_f32((float)*(unint64_t *)(v33 + 2072) / *(float *)(v33 + 2080));
      if (v265 < 3 || (uint8x8_t v278 = (uint8x8_t)vcnt_s8((int8x8_t)v265), v278.i16[0] = vaddlv_u8(v278), v278.u32[0] > 1uLL))
      {
        unint64_t v277 = std::__next_prime(v277);
      }
      else
      {
        uint64_t v279 = 1 << -(char)__clz(v277 - 1);
        if (v277 >= 2) {
          unint64_t v277 = v279;
        }
      }
      if (prime <= v277) {
        size_t prime = v277;
      }
      if (prime < v265) {
LABEL_494:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v33 + 2048, prime);
    }
    unint64_t v265 = *(void *)(v33 + 2056);
    if ((v265 & (v265 - 1)) != 0)
    {
      if (v12 >= v265) {
        unint64_t v249 = v12 % v265;
      }
      else {
        unint64_t v249 = v12;
      }
    }
    else
    {
      unint64_t v249 = (v265 - 1) & v12;
    }
  }
  uint64_t v280 = *v264;
  int32x4_t v281 = *(unint64_t **)(*v264 + 8 * v249);
  if (v281)
  {
    *(void *)unint64_t v247 = *v281;
LABEL_518:
    *int32x4_t v281 = v247;
    goto LABEL_519;
  }
  *(void *)unint64_t v247 = *(void *)(v33 + 2064);
  *(void *)(v33 + 2064) = v247;
  *(void *)(v280 + 8 * v249) = v33 + 2064;
  if (*(void *)v247)
  {
    unint64_t v282 = *(void *)(*(void *)v247 + 8);
    if ((v265 & (v265 - 1)) != 0)
    {
      if (v282 >= v265) {
        v282 %= v265;
      }
    }
    else
    {
      v282 &= v265 - 1;
    }
    int32x4_t v281 = (unint64_t *)(*v264 + 8 * v282);
    goto LABEL_518;
  }
LABEL_519:
  ++*(void *)(v33 + 2072);
LABEL_520:
  unint64_t v283 = *a3;
  unint64_t v284 = *(void *)(v33 + 2272);
  if (v284)
  {
    uint8x8_t v285 = (uint8x8_t)vcnt_s8((int8x8_t)v284);
    v285.i16[0] = vaddlv_u8(v285);
    if (v285.u32[0] > 1uLL)
    {
      unint64_t v247 = *a3;
      if (v283 >= v284) {
        unint64_t v247 = v283 % v284;
      }
    }
    else
    {
      unint64_t v247 = (v284 - 1) & v283;
    }
    int v286 = *(uint64_t **)(*(void *)(v33 + 2264) + 8 * v247);
    if (v286)
    {
      uint64_t v287 = *v286;
      if (*v286)
      {
        if (v285.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v289 = *(void *)(v287 + 8);
            if (v289 == v283)
            {
              if (*(void *)(v287 + 16) == v283) {
                goto LABEL_608;
              }
            }
            else if ((v289 & (v284 - 1)) != v247)
            {
              goto LABEL_541;
            }
            uint64_t v287 = *(void *)v287;
            if (!v287) {
              goto LABEL_541;
            }
          }
        }
        do
        {
          unint64_t v288 = *(void *)(v287 + 8);
          if (v288 == v283)
          {
            if (*(void *)(v287 + 16) == v283) {
              goto LABEL_608;
            }
          }
          else
          {
            if (v288 >= v284) {
              v288 %= v284;
            }
            if (v288 != v247) {
              break;
            }
          }
          uint64_t v287 = *(void *)v287;
        }
        while (v287);
      }
    }
  }
LABEL_541:
  uint64_t v287 = (uint64_t)operator new(0x20uLL);
  *(void *)uint64_t v287 = 0;
  *(void *)(v287 + 8) = v283;
  *(void *)(v287 + 16) = v283;
  *(void *)(v287 + 24) = 0;
  float v290 = (float)(unint64_t)(*(void *)(v33 + 2288) + 1);
  float v291 = *(float *)(v33 + 2296);
  if (!v284 || (float)(v291 * (float)v284) < v290)
  {
    BOOL v292 = 1;
    if (v284 >= 3) {
      BOOL v292 = (v284 & (v284 - 1)) != 0;
    }
    unint64_t v293 = v292 | (2 * v284);
    unint64_t v294 = vcvtps_u32_f32(v290 / v291);
    if (v293 <= v294) {
      size_t v295 = v294;
    }
    else {
      size_t v295 = v293;
    }
    if (v295 == 1)
    {
      size_t v295 = 2;
    }
    else if ((v295 & (v295 - 1)) != 0)
    {
      size_t v295 = std::__next_prime(v295);
      unint64_t v284 = *(void *)(v33 + 2272);
    }
    if (v295 <= v284)
    {
      if (v295 >= v284) {
        goto LABEL_593;
      }
      unint64_t v308 = vcvtps_u32_f32((float)*(unint64_t *)(v33 + 2288) / *(float *)(v33 + 2296));
      if (v284 < 3 || (uint8x8_t v309 = (uint8x8_t)vcnt_s8((int8x8_t)v284), v309.i16[0] = vaddlv_u8(v309), v309.u32[0] > 1uLL))
      {
        unint64_t v308 = std::__next_prime(v308);
      }
      else
      {
        uint64_t v310 = 1 << -(char)__clz(v308 - 1);
        if (v308 >= 2) {
          unint64_t v308 = v310;
        }
      }
      if (v295 <= v308) {
        size_t v295 = v308;
      }
      if (v295 >= v284) {
        goto LABEL_593;
      }
      if (!v295)
      {
        uint64_t v315 = *(void **)(v33 + 2264);
        *(void *)(v33 + 2264) = 0;
        if (v315) {
          operator delete(v315);
        }
        *(void *)(v33 + 2272) = 0;
        goto LABEL_593;
      }
    }
    if (v295 >> 61) {
      goto LABEL_702;
    }
    int8x16x2_t v296 = operator new(8 * v295);
    uint64_t v297 = *(void **)(v33 + 2264);
    *(void *)(v33 + 2264) = v296;
    if (v297) {
      operator delete(v297);
    }
    uint64_t v298 = 0;
    *(void *)(v33 + 2272) = v295;
    do
      *(void *)(*(void *)(v33 + 2264) + 8 * v298++) = 0;
    while (v295 != v298);
    unsigned int v299 = *(void **)(v33 + 2280);
    if (!v299) {
      goto LABEL_593;
    }
    uint64_t v300 = v33 + 2280;
    size_t v301 = v299[1];
    size_t v302 = v295 - 1;
    if ((v295 & (v295 - 1)) == 0)
    {
      size_t v303 = v301 & v302;
      *(void *)(*(void *)(v33 + 2264) + 8 * v303) = v300;
      while (1)
      {
        uint64_t v304 = (void *)*v299;
        if (!*v299) {
          break;
        }
        size_t v305 = v304[1] & v302;
        if (v305 == v303)
        {
          unsigned int v299 = (void *)*v299;
        }
        else
        {
          uint64_t v306 = *(void *)(v33 + 2264);
          if (*(void *)(v306 + 8 * v305))
          {
            *unsigned int v299 = *v304;
            uint64_t v307 = 8 * v305;
            *uint64_t v304 = **(void **)(*(void *)(v33 + 2264) + v307);
            **(void **)(*(void *)(v33 + 2264) + v307) = v304;
          }
          else
          {
            *(void *)(v306 + 8 * v305) = v299;
            unsigned int v299 = v304;
            size_t v303 = v305;
          }
        }
      }
LABEL_593:
      unint64_t v284 = *(void *)(v33 + 2272);
      if ((v284 & (v284 - 1)) != 0)
      {
        if (v283 >= v284) {
          unint64_t v247 = v283 % v284;
        }
        else {
          unint64_t v247 = v283;
        }
      }
      else
      {
        unint64_t v247 = (v284 - 1) & v283;
      }
      goto LABEL_598;
    }
    if (v301 >= v295) {
      v301 %= v295;
    }
    *(void *)(*(void *)(v33 + 2264) + 8 * v301) = v300;
    v311 = (void *)*v299;
    if (!*v299) {
      goto LABEL_593;
    }
    while (1)
    {
      size_t v313 = v311[1];
      if (v313 >= v295) {
        v313 %= v295;
      }
      if (v313 != v301)
      {
        uint64_t v314 = *(void *)(v33 + 2264);
        if (!*(void *)(v314 + 8 * v313))
        {
          *(void *)(v314 + 8 * v313) = v299;
          goto LABEL_579;
        }
        *unsigned int v299 = *v311;
        uint64_t v312 = 8 * v313;
        void *v311 = **(void **)(*(void *)(v33 + 2264) + v312);
        **(void **)(*(void *)(v33 + 2264) + v312) = v311;
        v311 = v299;
      }
      size_t v313 = v301;
LABEL_579:
      unsigned int v299 = v311;
      v311 = (void *)*v311;
      size_t v301 = v313;
      if (!v311) {
        goto LABEL_593;
      }
    }
  }
LABEL_598:
  uint64_t v316 = *(void *)(v33 + 2264);
  uint64_t v317 = *(uint64_t **)(v316 + 8 * v247);
  if (v317)
  {
    *(void *)uint64_t v287 = *v317;
LABEL_606:
    *uint64_t v317 = v287;
    goto LABEL_607;
  }
  *(void *)uint64_t v287 = *(void *)(v33 + 2280);
  *(void *)(v33 + 2280) = v287;
  *(void *)(v316 + 8 * v247) = v33 + 2280;
  if (*(void *)v287)
  {
    unint64_t v318 = *(void *)(*(void *)v287 + 8);
    if ((v284 & (v284 - 1)) != 0)
    {
      if (v318 >= v284) {
        v318 %= v284;
      }
    }
    else
    {
      v318 &= v284 - 1;
    }
    uint64_t v317 = (uint64_t *)(*(void *)(v33 + 2264) + 8 * v318);
    goto LABEL_606;
  }
LABEL_607:
  ++*(void *)(v33 + 2288);
LABEL_608:
  *(void *)(v287 + 24) = v12;
  unint64_t v319 = *a3;
  unint64_t v320 = *(void *)(v33 + 2312);
  if (v320)
  {
    uint8x8_t v321 = (uint8x8_t)vcnt_s8((int8x8_t)v320);
    v321.i16[0] = vaddlv_u8(v321);
    if (v321.u32[0] > 1uLL)
    {
      uint64_t v287 = v12;
      if (v12 >= v320) {
        uint64_t v287 = v12 % v320;
      }
    }
    else
    {
      uint64_t v287 = (v320 - 1) & v12;
    }
    v322 = *(void ***)(*(void *)(v33 + 2304) + 8 * v287);
    if (v322)
    {
      unint64_t v323 = *v322;
      if (*v322)
      {
        if (v321.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v325 = v323[1];
            if (v325 == v12)
            {
              if (v323[2] == v12) {
                goto LABEL_696;
              }
            }
            else if ((v325 & (v320 - 1)) != v287)
            {
              goto LABEL_629;
            }
            unint64_t v323 = (void *)*v323;
            if (!v323) {
              goto LABEL_629;
            }
          }
        }
        do
        {
          unint64_t v324 = v323[1];
          if (v324 == v12)
          {
            if (v323[2] == v12) {
              goto LABEL_696;
            }
          }
          else
          {
            if (v324 >= v320) {
              v324 %= v320;
            }
            if (v324 != v287) {
              break;
            }
          }
          unint64_t v323 = (void *)*v323;
        }
        while (v323);
      }
    }
  }
LABEL_629:
  unint64_t v323 = operator new(0x20uLL);
  *unint64_t v323 = 0;
  v323[1] = v12;
  v323[2] = v12;
  v323[3] = 0;
  float v326 = (float)(unint64_t)(*(void *)(v33 + 2328) + 1);
  float v327 = *(float *)(v33 + 2336);
  if (!v320 || (float)(v327 * (float)v320) < v326)
  {
    BOOL v328 = 1;
    if (v320 >= 3) {
      BOOL v328 = (v320 & (v320 - 1)) != 0;
    }
    unint64_t v329 = v328 | (2 * v320);
    unint64_t v330 = vcvtps_u32_f32(v326 / v327);
    if (v329 <= v330) {
      size_t v331 = v330;
    }
    else {
      size_t v331 = v329;
    }
    if (v331 == 1)
    {
      size_t v331 = 2;
    }
    else if ((v331 & (v331 - 1)) != 0)
    {
      size_t v331 = std::__next_prime(v331);
      unint64_t v320 = *(void *)(v33 + 2312);
    }
    if (v331 <= v320)
    {
      if (v331 >= v320) {
        goto LABEL_681;
      }
      unint64_t v344 = vcvtps_u32_f32((float)*(unint64_t *)(v33 + 2328) / *(float *)(v33 + 2336));
      if (v320 < 3 || (uint8x8_t v345 = (uint8x8_t)vcnt_s8((int8x8_t)v320), v345.i16[0] = vaddlv_u8(v345), v345.u32[0] > 1uLL))
      {
        unint64_t v344 = std::__next_prime(v344);
      }
      else
      {
        uint64_t v346 = 1 << -(char)__clz(v344 - 1);
        if (v344 >= 2) {
          unint64_t v344 = v346;
        }
      }
      if (v331 <= v344) {
        size_t v331 = v344;
      }
      if (v331 >= v320) {
        goto LABEL_681;
      }
      if (!v331)
      {
        v351 = *(void **)(v33 + 2304);
        *(void *)(v33 + 2304) = 0;
        if (v351) {
          operator delete(v351);
        }
        *(void *)(v33 + 2312) = 0;
        goto LABEL_681;
      }
    }
    if (v331 >> 61) {
      goto LABEL_702;
    }
    uint64_t v332 = operator new(8 * v331);
    long long v333 = *(void **)(v33 + 2304);
    *(void *)(v33 + 2304) = v332;
    if (v333) {
      operator delete(v333);
    }
    uint64_t v334 = 0;
    *(void *)(v33 + 2312) = v331;
    do
      *(void *)(*(void *)(v33 + 2304) + 8 * v334++) = 0;
    while (v331 != v334);
    uint8x8_t v335 = *(void **)(v33 + 2320);
    if (!v335) {
      goto LABEL_681;
    }
    uint64_t v336 = v33 + 2320;
    size_t v337 = v335[1];
    size_t v338 = v331 - 1;
    if ((v331 & (v331 - 1)) == 0)
    {
      size_t v339 = v337 & v338;
      *(void *)(*(void *)(v33 + 2304) + 8 * v339) = v336;
      while (1)
      {
        v340 = (void *)*v335;
        if (!*v335) {
          break;
        }
        size_t v341 = v340[1] & v338;
        if (v341 == v339)
        {
          uint8x8_t v335 = (void *)*v335;
        }
        else
        {
          uint64_t v342 = *(void *)(v33 + 2304);
          if (*(void *)(v342 + 8 * v341))
          {
            *uint8x8_t v335 = *v340;
            uint64_t v343 = 8 * v341;
            void *v340 = **(void **)(*(void *)(v33 + 2304) + v343);
            **(void **)(*(void *)(v33 + 2304) + v343) = v340;
          }
          else
          {
            *(void *)(v342 + 8 * v341) = v335;
            uint8x8_t v335 = v340;
            size_t v339 = v341;
          }
        }
      }
LABEL_681:
      unint64_t v320 = *(void *)(v33 + 2312);
      if ((v320 & (v320 - 1)) != 0)
      {
        if (v12 >= v320) {
          uint64_t v287 = v12 % v320;
        }
        else {
          uint64_t v287 = v12;
        }
      }
      else
      {
        uint64_t v287 = (v320 - 1) & v12;
      }
      goto LABEL_686;
    }
    if (v337 >= v331) {
      v337 %= v331;
    }
    *(void *)(*(void *)(v33 + 2304) + 8 * v337) = v336;
    v347 = (void *)*v335;
    if (!*v335) {
      goto LABEL_681;
    }
    while (1)
    {
      size_t v349 = v347[1];
      if (v349 >= v331) {
        v349 %= v331;
      }
      if (v349 != v337)
      {
        uint64_t v350 = *(void *)(v33 + 2304);
        if (!*(void *)(v350 + 8 * v349))
        {
          *(void *)(v350 + 8 * v349) = v335;
          goto LABEL_667;
        }
        *uint8x8_t v335 = *v347;
        uint64_t v348 = 8 * v349;
        void *v347 = **(void **)(*(void *)(v33 + 2304) + v348);
        **(void **)(*(void *)(v33 + 2304) + v348) = v347;
        v347 = v335;
      }
      size_t v349 = v337;
LABEL_667:
      uint8x8_t v335 = v347;
      v347 = (void *)*v347;
      size_t v337 = v349;
      if (!v347) {
        goto LABEL_681;
      }
    }
  }
LABEL_686:
  uint64_t v352 = *(void *)(v33 + 2304);
  size_t v353 = *(void **)(v352 + 8 * v287);
  if (v353)
  {
    *unint64_t v323 = *v353;
  }
  else
  {
    *unint64_t v323 = *(void *)(v33 + 2320);
    *(void *)(v33 + 2320) = v323;
    *(void *)(v352 + 8 * v287) = v33 + 2320;
    if (!*v323) {
      goto LABEL_695;
    }
    unint64_t v354 = *(void *)(*v323 + 8);
    if ((v320 & (v320 - 1)) != 0)
    {
      if (v354 >= v320) {
        v354 %= v320;
      }
    }
    else
    {
      v354 &= v320 - 1;
    }
    size_t v353 = (void *)(*(void *)(v33 + 2304) + 8 * v354);
  }
  *size_t v353 = v323;
LABEL_695:
  ++*(void *)(v33 + 2328);
LABEL_696:
  v323[3] = v319;
  unint64_t v357 = v12;
  uint64_t v355 = *(void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  unint64_t v359 = (void (**)(void **))&unk_1EF525B98;
  *(void *)&long long v360 = v12;
  *((void *)&v360 + 1) = v355;
  uint64_t v361 = (void **)&v359;
  int v363 = v362;
  *(void *)int8x16_t v362 = &unk_1EF525B98;
  *(_OWORD *)&v362[8] = v360;
  int v364 = 0;
  ecs2::Runtime::queueCommand(v356, (uint64_t)v362);
  if (v364 != -1) {
    ((void (*)(char *, unsigned char *))off_1EF590BE8[v364])(&v358, v362);
  }
  int v364 = -1;
  if (v361 == (void **)&v359)
  {
    v359[4]((void **)&v359);
  }
  else if (v361)
  {
    (*((void (**)(void))*v361 + 5))();
  }
LABEL_4:
  uint8x8_t v14 = **(void ***)(a1 + 8);
  uint64_t v15 = v14[269];
  if (v13 < (v14[270] - v15) >> 3
    && ((uint64_t v16 = *(void *)(v15 + 8 * v13)) != 0 ? (_ZF = HIDWORD(v12) == HIDWORD(v16)) : (_ZF = 0), _ZF))
  {
    uint64_t v19 = v14[272] + 24 * v16;
    uint64_t v18 = v14[273];
  }
  else
  {
    uint64_t v18 = v14[273];
    uint64_t v19 = v18;
  }
  if (v19 == v18) {
    uint64_t v20 = 0;
  }
  else {
    uint64_t v20 = v19;
  }
  if (v20)
  {
    unint64_t v21 = std::__hash_table<std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>,std::hash<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,true>,std::__unordered_map_equal<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>,std::equal_to<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::CachedKey<md::ColorStyleCacheKey>> const&>,std::tuple<>>((uint64_t)(v14 + 256), v12, &v357);
    ++v21[3];
  }
  if (!*(unsigned char *)(v20 + 20)) {
    *(unsigned char *)(v20 + 20) = 1;
  }
  *(_DWORD *)(v20 + 4) = _S8;
  *(_DWORD *)(v20 + 8) = _S9;
  *(_DWORD *)(v20 + 12) = _S11;
  *(float *)(v20 + 16) = _S10;
  *(unsigned char *)uint64_t v20 = 1;
  uint64_t v22 = std::__hash_table<std::__hash_value_type<md::ColorStyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>,std::__unordered_map_hasher<md::ColorStyleCacheKey,std::__hash_value_type<md::ColorStyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>,md::ColorStyleCacheKeyHasher,std::equal_to<md::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::ColorStyleCacheKey,std::__hash_value_type<md::ColorStyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>,std::equal_to<md::ColorStyleCacheKey>,md::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::ColorStyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleColor>>>>>::find<md::ColorStyleCacheKey>((void *)(**(void **)(a1 + 8) + 1968), v20);
  if (v22)
  {
    unint64_t v23 = *(void *)(v22 + 40);
    uint64_t v24 = **(void **)(a1 + 8);
    if (v23)
    {
      *(void *)int8x16_t v362 = *(void *)(v22 + 40);
      uint64_t v25 = *(void *)(v24 + 1856);
      if (v23 < (unint64_t)((*(void *)(v24 + 1864) - v25) >> 3))
      {
        uint64_t v26 = *(void *)(v25 + 8 * v23);
        if (v26 && HIDWORD(v23) == HIDWORD(v26))
        {
          uint64_t v28 = *(void *)(v24 + 1880);
          uint64_t v29 = (void *)(v28 + 24 * v26);
          if (v29 != *(void **)(v24 + 1888) && v28 != 0)
          {
            uint64_t v31 = std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::StyleRouteLineMask>> const&>,std::tuple<>>(v24 + 1752, v23, v362);
            ++v31[3];
            unint64_t v32 = (void *)*v29;
            if (v32)
            {
              unint64_t v218 = v32[1];
              long long v219 = (_WORD *)v32[9];
              __asm
              {
                FCVT            H0, S8
                FCVT            H1, S9
                FCVT            H2, S11
                FCVT            H3, S10
              }
              *long long v219 = _H0;
              v219[1] = _H1;
              v219[2] = _H2;
              v219[3] = _H3;
              if (v32[8] > v218) {
                unint64_t v218 = v32[8];
              }
              v32[7] = 0;
              v32[8] = v218;
            }
          }
        }
      }
      return;
    }
  }
  else
  {
    uint64_t v24 = **(void **)(a1 + 8);
  }
  memset(v362, 0, sizeof(v362));
  uint64_t v36 = *(void *)(v24 + 1840);
  if (*(void *)(v24 + 1832) == v36)
  {
    uint64_t v39 = (-1431655765 * ((*(void *)(v24 + 1888) - *(void *)(v24 + 1880)) >> 3)) | 0x100000000;
    unint64_t v40 = *(uint64_t **)(v24 + 1864);
    unint64_t v41 = *(void *)(v24 + 1872);
    if ((unint64_t)v40 >= v41)
    {
      float64x2_t v56 = *(char **)(v24 + 1856);
      uint64_t v57 = ((char *)v40 - v56) >> 3;
      unint64_t v58 = v57 + 1;
      if ((unint64_t)(v57 + 1) >> 61) {
        goto LABEL_703;
      }
      uint64_t v59 = v41 - (void)v56;
      if (v59 >> 2 > v58) {
        unint64_t v58 = v59 >> 2;
      }
      if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v60 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v60 = v58;
      }
      if (v60)
      {
        if (v60 >> 61) {
          goto LABEL_702;
        }
        float64x2_t v61 = (char *)operator new(8 * v60);
      }
      else
      {
        float64x2_t v61 = 0;
      }
      float32x4_t v68 = (uint64_t *)&v61[8 * v57];
      uint64_t *v68 = v39;
      unint64_t v42 = v68 + 1;
      if (v40 != (uint64_t *)v56)
      {
        unint64_t v69 = (char *)v40 - v56 - 8;
        if (v69 < 0x58) {
          goto LABEL_710;
        }
        if ((unint64_t)(v56 - v61) < 0x20) {
          goto LABEL_710;
        }
        uint64_t v70 = (v69 >> 3) + 1;
        uint64_t v71 = &v61[(char *)v40 - v56 - 16];
        float v72 = v40 - 2;
        uint64_t v73 = v70 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v74 = *(_OWORD *)v72;
          *((_OWORD *)v71 - 1) = *((_OWORD *)v72 - 1);
          *(_OWORD *)uint64_t v71 = v74;
          v71 -= 32;
          v72 -= 4;
          v73 -= 4;
        }
        while (v73);
        v68 -= v70 & 0x3FFFFFFFFFFFFFFCLL;
        v40 -= v70 & 0x3FFFFFFFFFFFFFFCLL;
        if (v70 != (v70 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_710:
          do
          {
            uint64_t v75 = *--v40;
            *--float32x4_t v68 = v75;
          }
          while (v40 != (uint64_t *)v56);
        }
        unint64_t v40 = *(uint64_t **)(v24 + 1856);
      }
      *(void *)(v24 + 1856) = v68;
      *(void *)(v24 + 1864) = v42;
      *(void *)(v24 + 1872) = &v61[8 * v60];
      if (v40) {
        operator delete(v40);
      }
    }
    else
    {
      *unint64_t v40 = v39;
      unint64_t v42 = v40 + 1;
    }
    *(void *)(v24 + 1864) = v42;
    unint64_t v38 = *(v42 - 1);
  }
  else
  {
    uint64_t v37 = *(void *)(v36 - 8);
    *(void *)(v24 + 1840) = v36 - 8;
    *(_DWORD *)(*(void *)(v24 + 1856) + 8 * v37) = -1431655765
                                                   * ((*(void *)(v24 + 1888) - *(void *)(v24 + 1880)) >> 3);
    *(_DWORD *)(*(void *)(v24 + 1856) + 8 * v37 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(v24 + 1856)
                                                                                             + 8 * v37
                                                                                             + 4) << 32)
                                                        + 0x100000000) >> 32;
    unint64_t v38 = v37 | ((unint64_t)*(unsigned int *)(*(void *)(v24 + 1856) + 8 * v37 + 4) << 32);
  }
  uint64_t v76 = *(char **)(v24 + 1888);
  unint64_t v77 = *(void *)(v24 + 1896);
  if ((unint64_t)v76 >= v77)
  {
    uint64_t v80 = *(char **)(v24 + 1880);
    unint64_t v81 = 0xAAAAAAAAAAAAAAABLL * ((v76 - v80) >> 3) + 1;
    if (v81 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_703;
    }
    unint64_t v82 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v77 - (void)v80) >> 3);
    if (2 * v82 > v81) {
      unint64_t v81 = 2 * v82;
    }
    if (v82 >= 0x555555555555555) {
      unint64_t v83 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v83 = v81;
    }
    if (v83 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_702;
    }
    unint64_t v84 = (char *)operator new(24 * v83);
    float64x2_t v85 = &v84[8 * ((v76 - v80) >> 3)];
    *(_OWORD *)float64x2_t v85 = *(_OWORD *)v362;
    uint64_t v86 = *(void *)&v362[16];
    *((void *)v85 + 2) = *(void *)&v362[16];
    if (v86)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v86 + 8), 1uLL, memory_order_relaxed);
      uint64_t v76 = *(char **)(v24 + 1888);
      uint64_t v80 = *(char **)(v24 + 1880);
    }
    unsigned int v87 = &v84[24 * v83];
    uint64_t v79 = v85 + 24;
    if (v76 == v80)
    {
      *(void *)(v24 + 1880) = v85;
      *(void *)(v24 + 1888) = v79;
      *(void *)(v24 + 1896) = v87;
    }
    else
    {
      do
      {
        long long v88 = *(_OWORD *)(v76 - 24);
        v76 -= 24;
        *(_OWORD *)(v85 - 24) = v88;
        v85 -= 24;
        *((void *)v85 + 2) = *((void *)v76 + 2);
        *((void *)v76 + 1) = 0;
        *((void *)v76 + 2) = 0;
      }
      while (v76 != v80);
      uint64_t v80 = *(char **)(v24 + 1880);
      uint64_t v89 = *(char **)(v24 + 1888);
      *(void *)(v24 + 1880) = v85;
      *(void *)(v24 + 1888) = v79;
      for (*(void *)(v24 + 1896) = v87; v89 != v80; v89 -= 24)
      {
        uint64_t v90 = (std::__shared_weak_count *)*((void *)v89 - 1);
        if (v90 && !atomic_fetch_add(&v90->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
          std::__shared_weak_count::__release_weak(v90);
        }
      }
    }
    if (v80) {
      operator delete(v80);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v76 = *(_OWORD *)v362;
    uint64_t v78 = *(void *)&v362[16];
    *((void *)v76 + 2) = *(void *)&v362[16];
    if (v78) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v78 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v79 = v76 + 24;
  }
  *(void *)(v24 + 1888) = v79;
  unint64_t v91 = *(void *)(v24 + 1912);
  unint64_t v92 = *(void *)(v24 + 1920);
  if (v91 < v92)
  {
    *(void *)unint64_t v91 = v38;
    v91 += 8;
    unint64_t v93 = v91;
    goto LABEL_130;
  }
  float64x2_t v94 = *(unsigned char **)(v24 + 1904);
  uint64_t v95 = (uint64_t)(v91 - (void)v94) >> 3;
  unint64_t v96 = v95 + 1;
  if ((unint64_t)(v95 + 1) >> 61) {
LABEL_703:
  }
    abort();
  uint64_t v97 = v92 - (void)v94;
  if (v97 >> 2 > v96) {
    unint64_t v96 = v97 >> 2;
  }
  if ((unint64_t)v97 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v98 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v98 = v96;
  }
  if (v98)
  {
    if (v98 >> 61) {
      goto LABEL_702;
    }
    long long v99 = operator new(8 * v98);
  }
  else
  {
    long long v99 = 0;
  }
  uint64_t v100 = &v99[8 * v95];
  *uint64_t v100 = v38;
  unint64_t v93 = (unint64_t)(v100 + 1);
  if ((unsigned char *)v91 != v94)
  {
    unint64_t v101 = v91 - (void)v94 - 8;
    if (v101 < 0x58) {
      goto LABEL_711;
    }
    if ((unint64_t)(v94 - v99) < 0x20) {
      goto LABEL_711;
    }
    uint64_t v102 = (v101 >> 3) + 1;
    uint64_t v103 = &v99[v91 - (void)v94 - 16];
    uint64_t v104 = (long long *)(v91 - 16);
    uint64_t v105 = v102 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v106 = *v104;
      *(v103 - 1) = *(v104 - 1);
      *uint64_t v103 = v106;
      v103 -= 2;
      v104 -= 2;
      v105 -= 4;
    }
    while (v105);
    v100 -= v102 & 0x3FFFFFFFFFFFFFFCLL;
    v91 -= 8 * (v102 & 0x3FFFFFFFFFFFFFFCLL);
    if (v102 != (v102 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_711:
      do
      {
        uint64_t v107 = *(void *)(v91 - 8);
        v91 -= 8;
        *--uint64_t v100 = v107;
      }
      while ((unsigned char *)v91 != v94);
    }
  }
  *(void *)(v24 + 1904) = v100;
  *(void *)(v24 + 1912) = v93;
  *(void *)(v24 + 1920) = &v99[8 * v98];
  if (v94) {
    operator delete(v94);
  }
LABEL_130:
  uint64_t v108 = (uint64_t *)(v24 + 1752);
  *(void *)(v24 + 1912) = v93;
  unint64_t v109 = *(void *)(v24 + 1760);
  if (v109)
  {
    uint8x8_t v110 = (uint8x8_t)vcnt_s8((int8x8_t)v109);
    v110.i16[0] = vaddlv_u8(v110);
    if (v110.u32[0] > 1uLL)
    {
      unint64_t v93 = v38;
      if (v38 >= v109) {
        unint64_t v93 = v38 % v109;
      }
    }
    else
    {
      unint64_t v93 = (v109 - 1) & v38;
    }
    uint64_t v111 = *(void **)(*v108 + 8 * v93);
    if (v111)
    {
      uint64_t v112 = (void *)*v111;
      if (v112)
      {
        if (v110.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v114 = v112[1];
            if (v114 == v38)
            {
              if (v112[2] == v38) {
                goto LABEL_189;
              }
            }
            else if ((v114 & (v109 - 1)) != v93)
            {
              goto LABEL_151;
            }
            uint64_t v112 = (void *)*v112;
            if (!v112) {
              goto LABEL_151;
            }
          }
        }
        do
        {
          unint64_t v113 = v112[1];
          if (v113 == v38)
          {
            if (v112[2] == v38) {
              goto LABEL_189;
            }
          }
          else
          {
            if (v113 >= v109) {
              v113 %= v109;
            }
            if (v113 != v93) {
              break;
            }
          }
          uint64_t v112 = (void *)*v112;
        }
        while (v112);
      }
    }
  }
LABEL_151:
  unint64_t v91 = (unint64_t)operator new(0x30uLL);
  *(void *)unint64_t v91 = 0;
  *(void *)(v91 + 8) = v38;
  *(void *)(v91 + 16) = v38;
  *(_OWORD *)(v91 + 24) = xmmword_1A28FCC60;
  *(unsigned char *)(v91 + 40) = 0;
  float v115 = (float)(unint64_t)(*(void *)(v24 + 1776) + 1);
  float v116 = *(float *)(v24 + 1784);
  if (!v109 || (float)(v116 * (float)v109) < v115)
  {
    BOOL v117 = 1;
    if (v109 >= 3) {
      BOOL v117 = (v109 & (v109 - 1)) != 0;
    }
    unint64_t v118 = v117 | (2 * v109);
    unint64_t v119 = vcvtps_u32_f32(v115 / v116);
    if (v118 <= v119) {
      size_t v120 = v119;
    }
    else {
      size_t v120 = v118;
    }
    if (v120 == 1)
    {
      size_t v120 = 2;
    }
    else if ((v120 & (v120 - 1)) != 0)
    {
      size_t v120 = std::__next_prime(v120);
      unint64_t v109 = *(void *)(v24 + 1760);
    }
    if (v120 > v109) {
      goto LABEL_163;
    }
    if (v120 < v109)
    {
      unint64_t v121 = vcvtps_u32_f32((float)*(unint64_t *)(v24 + 1776) / *(float *)(v24 + 1784));
      if (v109 < 3 || (uint8x8_t v122 = (uint8x8_t)vcnt_s8((int8x8_t)v109), v122.i16[0] = vaddlv_u8(v122), v122.u32[0] > 1uLL))
      {
        unint64_t v121 = std::__next_prime(v121);
      }
      else
      {
        uint64_t v123 = 1 << -(char)__clz(v121 - 1);
        if (v121 >= 2) {
          unint64_t v121 = v123;
        }
      }
      if (v120 <= v121) {
        size_t v120 = v121;
      }
      if (v120 < v109) {
LABEL_163:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v24 + 1752, v120);
    }
    unint64_t v109 = *(void *)(v24 + 1760);
    if ((v109 & (v109 - 1)) != 0)
    {
      if (v38 >= v109) {
        unint64_t v93 = v38 % v109;
      }
      else {
        unint64_t v93 = v38;
      }
    }
    else
    {
      unint64_t v93 = (v109 - 1) & v38;
    }
  }
  uint64_t v124 = *v108;
  uint64_t v125 = *(unint64_t **)(*v108 + 8 * v93);
  if (v125)
  {
    *(void *)unint64_t v91 = *v125;
LABEL_187:
    *uint64_t v125 = v91;
    goto LABEL_188;
  }
  *(void *)unint64_t v91 = *(void *)(v24 + 1768);
  *(void *)(v24 + 1768) = v91;
  *(void *)(v124 + 8 * v93) = v24 + 1768;
  if (*(void *)v91)
  {
    unint64_t v126 = *(void *)(*(void *)v91 + 8);
    if ((v109 & (v109 - 1)) != 0)
    {
      if (v126 >= v109) {
        v126 %= v109;
      }
    }
    else
    {
      v126 &= v109 - 1;
    }
    uint64_t v125 = (unint64_t *)(*v108 + 8 * v126);
    goto LABEL_187;
  }
LABEL_188:
  ++*(void *)(v24 + 1776);
LABEL_189:
  uint64_t v127 = *(std::__shared_weak_count **)&v362[16];
  if (*(void *)&v362[16]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v362[16] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v127->__on_zero_shared)(v127);
    std::__shared_weak_count::__release_weak(v127);
  }
  if (!*(unsigned char *)(v20 + 20))
  {
    std::__throw_bad_optional_access[abi:nn180100]();
    __break(1u);
LABEL_705:
    abort();
  }
  float v128 = *(float *)(v20 + 4);
  float v129 = *(float *)(v20 + 8);
  unint64_t v130 = LODWORD(v128) - 0x61C8864680B583EBLL;
  if (v128 == 0.0) {
    unint64_t v130 = 0x9E3779B97F4A7C15;
  }
  uint64_t v131 = LODWORD(v129) - 0x61C8864680B583EBLL;
  if (v129 == 0.0) {
    uint64_t v131 = 0x9E3779B97F4A7C15;
  }
  float v132 = *(float *)(v20 + 12);
  float v133 = *(float *)(v20 + 16);
  int v134 = (void *)(v20 + 4);
  unint64_t v135 = ((v130 >> 2) + (v130 << 6) + v131) ^ v130;
  uint64_t v136 = LODWORD(v132) - 0x61C8864680B583EBLL;
  if (v132 == 0.0) {
    uint64_t v136 = 0x9E3779B97F4A7C15;
  }
  unint64_t v137 = (v136 + (v135 << 6) + (v135 >> 2)) ^ v135;
  uint64_t v138 = LODWORD(v133) - 0x61C8864680B583EBLL;
  if (v133 == 0.0) {
    uint64_t v138 = 0x9E3779B97F4A7C15;
  }
  unint64_t v139 = (v138 + (v137 << 6) + (v137 >> 2)) ^ v137;
  unint64_t v140 = (((v139 << 6) + (v139 >> 2) - 0x61C8864680B583EBLL) ^ v139) - 0x61C8864680B583EBLL;
  unint64_t v141 = *(void *)(v24 + 1976);
  if (v141)
  {
    uint8x8_t v142 = (uint8x8_t)vcnt_s8((int8x8_t)v141);
    v142.i16[0] = vaddlv_u8(v142);
    if (v142.u32[0] > 1uLL)
    {
      unint64_t v91 = (((v139 << 6) + (v139 >> 2) - 0x61C8864680B583EBLL) ^ v139) - 0x61C8864680B583EBLL;
      if (v140 >= v141) {
        unint64_t v91 = v140 % v141;
      }
    }
    else
    {
      unint64_t v91 = v140 & (v141 - 1);
    }
    float32x4_t v143 = *(char ***)(*(void *)(v24 + 1968) + 8 * v91);
    if (v143)
    {
      float32x4_t v144 = *v143;
      if (*v143)
      {
        if (v142.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v147 = *((void *)v144 + 1);
            if (v147 == v140)
            {
              if (v144[36])
              {
                if (*(void *)(v144 + 20) == *v134 && *(void *)(v144 + 28) == *(void *)(v20 + 12)) {
                  goto LABEL_302;
                }
              }
            }
            else if ((v147 & (v141 - 1)) != v91)
            {
              goto LABEL_233;
            }
            float32x4_t v144 = *(char **)v144;
            if (!v144) {
              goto LABEL_233;
            }
          }
        }
        do
        {
          unint64_t v145 = *((void *)v144 + 1);
          if (v145 == v140)
          {
            if (v144[36])
            {
              if (*(void *)(v144 + 20) == *v134 && *(void *)(v144 + 28) == *(void *)(v20 + 12)) {
                goto LABEL_302;
              }
            }
          }
          else
          {
            if (v145 >= v141) {
              v145 %= v141;
            }
            if (v145 != v91) {
              break;
            }
          }
          float32x4_t v144 = *(char **)v144;
        }
        while (v144);
      }
    }
  }
LABEL_233:
  uint64_t v149 = (char *)operator new(0x30uLL);
  float32x4_t v144 = v149;
  *(void *)uint64_t v149 = 0;
  *((void *)v149 + 1) = v140;
  v149[16] = *(unsigned char *)v20;
  v149[20] = 0;
  v149[36] = 0;
  if (*(unsigned char *)(v20 + 20))
  {
    *(_OWORD *)(v149 + 20) = *(_OWORD *)v134;
    v149[36] = 1;
  }
  *((void *)v149 + 5) = 0;
  float v150 = (float)(unint64_t)(*(void *)(v24 + 1992) + 1);
  float v151 = *(float *)(v24 + 2000);
  if (!v141 || (float)(v151 * (float)v141) < v150)
  {
    BOOL v152 = 1;
    if (v141 >= 3) {
      BOOL v152 = (v141 & (v141 - 1)) != 0;
    }
    unint64_t v153 = v152 | (2 * v141);
    unint64_t v154 = vcvtps_u32_f32(v150 / v151);
    if (v153 <= v154) {
      size_t v155 = v154;
    }
    else {
      size_t v155 = v153;
    }
    if (v155 == 1)
    {
      size_t v155 = 2;
    }
    else if ((v155 & (v155 - 1)) != 0)
    {
      size_t v155 = std::__next_prime(v155);
      unint64_t v141 = *(void *)(v24 + 1976);
    }
    if (v155 <= v141)
    {
      if (v155 >= v141) {
        goto LABEL_287;
      }
      unint64_t v168 = vcvtps_u32_f32((float)*(unint64_t *)(v24 + 1992) / *(float *)(v24 + 2000));
      if (v141 < 3 || (uint8x8_t v169 = (uint8x8_t)vcnt_s8((int8x8_t)v141), v169.i16[0] = vaddlv_u8(v169), v169.u32[0] > 1uLL))
      {
        unint64_t v168 = std::__next_prime(v168);
      }
      else
      {
        uint64_t v170 = 1 << -(char)__clz(v168 - 1);
        if (v168 >= 2) {
          unint64_t v168 = v170;
        }
      }
      if (v155 <= v168) {
        size_t v155 = v168;
      }
      if (v155 >= v141) {
        goto LABEL_287;
      }
      if (!v155)
      {
        uint64_t v175 = *(void **)(v24 + 1968);
        *(void *)(v24 + 1968) = 0;
        if (v175) {
          operator delete(v175);
        }
        *(void *)(v24 + 1976) = 0;
        goto LABEL_287;
      }
    }
    if (v155 >> 61) {
      goto LABEL_702;
    }
    int v156 = operator new(8 * v155);
    int v157 = *(void **)(v24 + 1968);
    *(void *)(v24 + 1968) = v156;
    if (v157) {
      operator delete(v157);
    }
    uint64_t v158 = 0;
    *(void *)(v24 + 1976) = v155;
    do
      *(void *)(*(void *)(v24 + 1968) + 8 * v158++) = 0;
    while (v155 != v158);
    unint64_t v159 = *(void **)(v24 + 1984);
    if (!v159) {
      goto LABEL_287;
    }
    uint64_t v160 = v24 + 1984;
    size_t v161 = v159[1];
    size_t v162 = v155 - 1;
    if ((v155 & (v155 - 1)) == 0)
    {
      size_t v163 = v161 & v162;
      *(void *)(*(void *)(v24 + 1968) + 8 * v163) = v160;
      while (1)
      {
        int v164 = (void *)*v159;
        if (!*v159) {
          break;
        }
        size_t v165 = v164[1] & v162;
        if (v165 == v163)
        {
          unint64_t v159 = (void *)*v159;
        }
        else
        {
          uint64_t v166 = *(void *)(v24 + 1968);
          if (*(void *)(v166 + 8 * v165))
          {
            *unint64_t v159 = *v164;
            uint64_t v167 = 8 * v165;
            *int v164 = **(void **)(*(void *)(v24 + 1968) + v167);
            **(void **)(*(void *)(v24 + 1968) + v167) = v164;
          }
          else
          {
            *(void *)(v166 + 8 * v165) = v159;
            unint64_t v159 = v164;
            size_t v163 = v165;
          }
        }
      }
LABEL_287:
      unint64_t v141 = *(void *)(v24 + 1976);
      if ((v141 & (v141 - 1)) != 0)
      {
        if (v140 >= v141) {
          unint64_t v91 = v140 % v141;
        }
        else {
          unint64_t v91 = v140;
        }
      }
      else
      {
        unint64_t v91 = (v141 - 1) & v140;
      }
      goto LABEL_292;
    }
    if (v161 >= v155) {
      v161 %= v155;
    }
    *(void *)(*(void *)(v24 + 1968) + 8 * v161) = v160;
    int v171 = (void *)*v159;
    if (!*v159) {
      goto LABEL_287;
    }
    while (1)
    {
      size_t v173 = v171[1];
      if (v173 >= v155) {
        v173 %= v155;
      }
      if (v173 != v161)
      {
        uint64_t v174 = *(void *)(v24 + 1968);
        if (!*(void *)(v174 + 8 * v173))
        {
          *(void *)(v174 + 8 * v173) = v159;
          goto LABEL_273;
        }
        *unint64_t v159 = *v171;
        uint64_t v172 = 8 * v173;
        *int v171 = **(void **)(*(void *)(v24 + 1968) + v172);
        **(void **)(*(void *)(v24 + 1968) + v172) = v171;
        int v171 = v159;
      }
      size_t v173 = v161;
LABEL_273:
      unint64_t v159 = v171;
      int v171 = (void *)*v171;
      size_t v161 = v173;
      if (!v171) {
        goto LABEL_287;
      }
    }
  }
LABEL_292:
  uint64_t v176 = *(void *)(v24 + 1968);
  float32x4_t v177 = *(void **)(v176 + 8 * v91);
  if (v177)
  {
    *(void *)float32x4_t v144 = *v177;
LABEL_300:
    *float32x4_t v177 = v144;
    goto LABEL_301;
  }
  *(void *)float32x4_t v144 = *(void *)(v24 + 1984);
  *(void *)(v24 + 1984) = v144;
  *(void *)(v176 + 8 * v91) = v24 + 1984;
  if (*(void *)v144)
  {
    unint64_t v178 = *(void *)(*(void *)v144 + 8);
    if ((v141 & (v141 - 1)) != 0)
    {
      if (v178 >= v141) {
        v178 %= v141;
      }
    }
    else
    {
      v178 &= v141 - 1;
    }
    float32x4_t v177 = (void *)(*(void *)(v24 + 1968) + 8 * v178);
    goto LABEL_300;
  }
LABEL_301:
  ++*(void *)(v24 + 1992);
LABEL_302:
  *((void *)v144 + 5) = v38;
  unint64_t v179 = *(void *)(v24 + 2016);
  if (v179)
  {
    uint8x8_t v180 = (uint8x8_t)vcnt_s8((int8x8_t)v179);
    v180.i16[0] = vaddlv_u8(v180);
    if (v180.u32[0] > 1uLL)
    {
      unint64_t v91 = v38;
      if (v38 >= v179) {
        unint64_t v91 = v38 % v179;
      }
    }
    else
    {
      unint64_t v91 = (v179 - 1) & v38;
    }
    uint64_t v181 = *(void ***)(*(void *)(v24 + 2008) + 8 * v91);
    if (v181)
    {
      uint64_t v182 = (char *)*v181;
      if (*v181)
      {
        if (v180.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v184 = *((void *)v182 + 1);
            if (v184 == v38)
            {
              if (*((void *)v182 + 2) == v38) {
                goto LABEL_389;
              }
            }
            else if ((v184 & (v179 - 1)) != v91)
            {
              goto LABEL_323;
            }
            uint64_t v182 = *(char **)v182;
            if (!v182) {
              goto LABEL_323;
            }
          }
        }
        do
        {
          unint64_t v183 = *((void *)v182 + 1);
          if (v183 == v38)
          {
            if (*((void *)v182 + 2) == v38) {
              goto LABEL_389;
            }
          }
          else
          {
            if (v183 >= v179) {
              v183 %= v179;
            }
            if (v183 != v91) {
              break;
            }
          }
          uint64_t v182 = *(char **)v182;
        }
        while (v182);
      }
    }
  }
LABEL_323:
  uint64_t v182 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v182 = 0;
  *((void *)v182 + 1) = v38;
  *((void *)v182 + 2) = v38;
  *((void *)v182 + 3) = 0;
  *((void *)v182 + 4) = 0;
  *((void *)v182 + 5) = 0;
  float v185 = (float)(unint64_t)(*(void *)(v24 + 2032) + 1);
  float v186 = *(float *)(v24 + 2040);
  if ((((float)(v186 * (float)v179) >= v185) & ~(v179 == 0)) == 0)
  {
    BOOL v187 = 1;
    if (v179 >= 3) {
      BOOL v187 = (v179 & (v179 - 1)) != 0;
    }
    unint64_t v188 = v187 | (2 * v179);
    unint64_t v189 = vcvtps_u32_f32(v185 / v186);
    if (v188 <= v189) {
      size_t v190 = v189;
    }
    else {
      size_t v190 = v188;
    }
    if (v190 == 1)
    {
      size_t v190 = 2;
    }
    else if ((v190 & (v190 - 1)) != 0)
    {
      size_t v190 = std::__next_prime(v190);
      unint64_t v179 = *(void *)(v24 + 2016);
    }
    if (v190 <= v179)
    {
      if (v190 >= v179) {
        goto LABEL_374;
      }
      unint64_t v203 = vcvtps_u32_f32((float)*(unint64_t *)(v24 + 2032) / *(float *)(v24 + 2040));
      if (v179 < 3 || (uint8x8_t v204 = (uint8x8_t)vcnt_s8((int8x8_t)v179), v204.i16[0] = vaddlv_u8(v204), v204.u32[0] > 1uLL))
      {
        unint64_t v203 = std::__next_prime(v203);
      }
      else
      {
        uint64_t v205 = 1 << -(char)__clz(v203 - 1);
        if (v203 >= 2) {
          unint64_t v203 = v205;
        }
      }
      if (v190 <= v203) {
        size_t v190 = v203;
      }
      if (v190 >= v179) {
        goto LABEL_374;
      }
      if (!v190)
      {
        unint64_t v210 = *(void **)(v24 + 2008);
        *(void *)(v24 + 2008) = 0;
        if (v210) {
          operator delete(v210);
        }
        *(void *)(v24 + 2016) = 0;
        goto LABEL_374;
      }
    }
    if (!(v190 >> 61))
    {
      float64x2_t v191 = operator new(8 * v190);
      float64x2_t v192 = *(void **)(v24 + 2008);
      *(void *)(v24 + 2008) = v191;
      if (v192) {
        operator delete(v192);
      }
      uint64_t v193 = 0;
      *(void *)(v24 + 2016) = v190;
      do
        *(void *)(*(void *)(v24 + 2008) + 8 * v193++) = 0;
      while (v190 != v193);
      long long v194 = *(void **)(v24 + 2024);
      if (!v194) {
        goto LABEL_374;
      }
      uint64_t v195 = v24 + 2024;
      size_t v196 = v194[1];
      size_t v197 = v190 - 1;
      if ((v190 & (v190 - 1)) == 0)
      {
        size_t v198 = v196 & v197;
        *(void *)(*(void *)(v24 + 2008) + 8 * v198) = v195;
        while (1)
        {
          float64x2_t v199 = (void *)*v194;
          if (!*v194) {
            break;
          }
          size_t v200 = v199[1] & v197;
          if (v200 == v198)
          {
            long long v194 = (void *)*v194;
          }
          else
          {
            uint64_t v201 = *(void *)(v24 + 2008);
            if (*(void *)(v201 + 8 * v200))
            {
              *long long v194 = *v199;
              uint64_t v202 = 8 * v200;
              *float64x2_t v199 = **(void **)(*(void *)(v24 + 2008) + v202);
              **(void **)(*(void *)(v24 + 2008) + v202) = v199;
            }
            else
            {
              *(void *)(v201 + 8 * v200) = v194;
              long long v194 = v199;
              size_t v198 = v200;
            }
          }
        }
LABEL_374:
        unint64_t v179 = *(void *)(v24 + 2016);
        if ((v179 & (v179 - 1)) != 0)
        {
          if (v38 >= v179) {
            unint64_t v91 = v38 % v179;
          }
          else {
            unint64_t v91 = v38;
          }
        }
        else
        {
          unint64_t v91 = (v179 - 1) & v38;
        }
        goto LABEL_379;
      }
      if (v196 >= v190) {
        v196 %= v190;
      }
      *(void *)(*(void *)(v24 + 2008) + 8 * v196) = v195;
      uint64_t v206 = (void *)*v194;
      if (!*v194) {
        goto LABEL_374;
      }
      while (1)
      {
        size_t v208 = v206[1];
        if (v208 >= v190) {
          v208 %= v190;
        }
        if (v208 != v196)
        {
          uint64_t v209 = *(void *)(v24 + 2008);
          if (!*(void *)(v209 + 8 * v208))
          {
            *(void *)(v209 + 8 * v208) = v194;
            goto LABEL_360;
          }
          *long long v194 = *v206;
          uint64_t v207 = 8 * v208;
          *uint64_t v206 = **(void **)(*(void *)(v24 + 2008) + v207);
          **(void **)(*(void *)(v24 + 2008) + v207) = v206;
          uint64_t v206 = v194;
        }
        size_t v208 = v196;
LABEL_360:
        long long v194 = v206;
        uint64_t v206 = (void *)*v206;
        size_t v196 = v208;
        if (!v206) {
          goto LABEL_374;
        }
      }
    }
LABEL_702:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_379:
  uint64_t v211 = *(void *)(v24 + 2008);
  float64x2_t v212 = *(void **)(v211 + 8 * v91);
  if (v212)
  {
    *(void *)uint64_t v182 = *v212;
  }
  else
  {
    *(void *)uint64_t v182 = *(void *)(v24 + 2024);
    *(void *)(v24 + 2024) = v182;
    *(void *)(v211 + 8 * v91) = v24 + 2024;
    if (!*(void *)v182) {
      goto LABEL_388;
    }
    unint64_t v213 = *(void *)(*(void *)v182 + 8);
    if ((v179 & (v179 - 1)) != 0)
    {
      if (v213 >= v179) {
        v213 %= v179;
      }
    }
    else
    {
      v213 &= v179 - 1;
    }
    float64x2_t v212 = (void *)(*(void *)(v24 + 2008) + 8 * v213);
  }
  *float64x2_t v212 = v182;
LABEL_388:
  ++*(void *)(v24 + 2032);
LABEL_389:
  v182[24] = *(unsigned char *)v20;
  if (v182[44] == *(unsigned char *)(v20 + 20))
  {
    if (v182[44])
    {
      *((_DWORD *)v182 + 7) = *(_DWORD *)(v20 + 4);
      *((_DWORD *)v182 + 8) = *(_DWORD *)(v20 + 8);
      *((_DWORD *)v182 + 9) = *(_DWORD *)(v20 + 12);
      *((_DWORD *)v182 + 10) = *(_DWORD *)(v20 + 16);
    }
  }
  else if (v182[44])
  {
    v182[44] = 0;
  }
  else
  {
    *(_OWORD *)(v182 + 28) = *(_OWORD *)v134;
    v182[44] = 1;
  }
  unint64_t v214 = **(void ***)(a1 + 8);
  uint64_t v215 = v214[233];
  uint64_t v216 = v214[232];
  *(void *)int8x16_t v362 = v38;
  if (v38 < (unint64_t)((v215 - v216) >> 3))
  {
    uint64_t v217 = *(void *)(v216 + 8 * v38);
    if (v217)
    {
      if (HIDWORD(v38) == HIDWORD(v217) && v214[235] + 24 * v217 != v214[236]) {
        operator new();
      }
    }
  }
}

void sub_1A2548D50(_Unwind_Exception *a1)
{
  uint64_t v3 = v1[3];
  v1[3] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1A2548DC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  operator delete(v17);
  md::components::Material::~Material((md::components::Material *)&a17);
  _Unwind_Resume(a1);
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::StyleRouteLineMaskDataKeyHandle>(gdc::Entity,md::ls::StyleRouteLineMaskDataKeyHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  int v4 = (void *)gdc::Registry::storage<md::ls::StyleRouteLineMaskDataKeyHandle>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  int v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    unint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v20 = operator new(8 * v19);
      }
      else
      {
        uint64_t v20 = 0;
      }
      unint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *unint64_t v21 = v5;
      uint8x8_t v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        uint64_t v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--unint64_t v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)unint64_t v13 = v5;
      uint8x8_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint8x8_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    *uint8x8_t v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      uint8x8_t v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          uint64_t v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          uint8x8_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  long long v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      uint64_t v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      long long v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::StyleRouteLineMaskDataKeyHandle>(gdc::Entity,md::ls::StyleRouteLineMaskDataKeyHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525B98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::StyleRouteLineMaskDataKeyHandle>(gdc::Entity,md::ls::StyleRouteLineMaskDataKeyHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF525B98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::StyleRouteLineMaskDataKeyHandle>(gdc::Entity,md::ls::StyleRouteLineMaskDataKeyHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::ProcessRenderableForStyleRouteLineMask::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *>)::$_0,std::allocator<md::ita::ProcessRenderableForStyleRouteLineMask::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5208E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::ProcessRenderableForStyleRouteLineMask::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *>)::$_0,std::allocator<md::ita::ProcessRenderableForStyleRouteLineMask::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5208E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::ProcessRenderableForStyleRouteLineMask::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *>)::$_0,std::allocator<md::ita::ProcessRenderableForStyleRouteLineMask::operator()(ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *>)::$_0>,void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *)>::~__func()
{
}

unsigned __int8 *md::Label::updateClusterState(unsigned __int8 *result, uint64_t a2, int a3, int a4)
{
  unsigned int v4 = result[1106];
  int v5 = 2 * (v4 != 1);
  if (a4) {
    char v6 = 1;
  }
  else {
    char v6 = result[1106];
  }
  if (!a4) {
    int v5 = 0;
  }
  if (v4 == 7) {
    int v7 = 0;
  }
  else {
    int v7 = 6;
  }
  if (v4 <= 3) {
    int v8 = 3;
  }
  else {
    int v8 = 0;
  }
  if (v4 >= 5) {
    int v8 = 5;
  }
  if (a3 == 37) {
    LOBYTE(v4) = 4;
  }
  else {
    int v8 = 0;
  }
  if (a3 == 7) {
    LOBYTE(v4) = 7;
  }
  else {
    int v7 = v8;
  }
  if (a3 == 6) {
    LOBYTE(v4) = v6;
  }
  else {
    int v5 = v7;
  }
  if (v5 != result[1107])
  {
    result[1107] = v5;
    result[1108] = v4;
    if (v5 - 2) <= 4 && ((0x1Bu >> (v5 - 2))) {
      operator new();
    }
  }
  return result;
}

uint64_t md::NullLabelPart::publicName(md::NullLabelPart *this)
{
  return 0;
}

void md::NullLabelPart::populateDebugNode(md::NullLabelPart *this, gdc::DebugTreeNode *a2)
{
  v6[23] = 17;
  strcpy(v6, "Is Null LabelPart");
  memset(&__p, 0, sizeof(__p));
  int v5 = 4;
  std::string::__assign_external(&__p, " ");
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v6, (uint64_t)&v3);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void md::NullLabelPart::debugString(char *a1@<X8>)
{
  a1[23] = 13;
  strcpy(a1, "NullLabelPart");
}

uint64_t md::NullLabelPart::needsCrossfade(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t md::NullLabelPart::isNullLabelPart(md::NullLabelPart *this)
{
  return 1;
}

uint64_t md::NullLabelPart::layoutForStaging()
{
  return 37;
}

void sub_1A2549C00(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A2549C8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2549E18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A254A6E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A254A7E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A254A9AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A254AA20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A254AA90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A254AAF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A254B090(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A254B350(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A254C498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1A254C75C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id a23)
{
  uint64_t v25 = v24;

  _Block_object_dispose(&a18, 8);
  a9.super_class = (Class)MDDisplayLayer;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__35668(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__35669(uint64_t a1)
{
}

void sub_1A254C8D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A254C95C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A254C9E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void MDDisplayLayerSwapchainProvider::~MDDisplayLayerSwapchainProvider(MDDisplayLayerSwapchainProvider *this)
{
  *(void *)this = &unk_1EF5130C8;

  uint64_t v2 = (void *)*((void *)this + 34);
  if (v2)
  {
    *((void *)this + 35) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 31);
  if (v3)
  {
    *((void *)this + 32) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *((void *)this + 28);
  if (v4)
  {
    uint64_t v5 = *((void *)this + 29);
    char v6 = (void *)*((void *)this + 28);
    if (v5 != v4)
    {
      do
      {
        uint64_t v7 = *(std::__shared_weak_count **)(v5 - 8);
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        v5 -= 16;
      }
      while (v5 != v4);
      char v6 = (void *)*((void *)this + 28);
    }
    *((void *)this + 29) = v4;
    operator delete(v6);
  }
  int v8 = (void *)*((void *)this + 25);
  if (v8)
  {
    *((void *)this + 26) = v8;
    operator delete(v8);
  }
  uint64_t v9 = (void *)*((void *)this + 22);
  if (v9)
  {
    *((void *)this + 23) = v9;
    operator delete(v9);
  }
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 120));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 72));
  std::mutex::~mutex((std::mutex *)((char *)this + 8));
}

MDDisplayLayerSwapchainProvider **std::unique_ptr<MDDisplayLayerSwapchainProvider>::~unique_ptr[abi:nn180100](MDDisplayLayerSwapchainProvider **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    MDDisplayLayerSwapchainProvider::~MDDisplayLayerSwapchainProvider(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

uint64_t std::__shared_ptr_pointer<MDDisplayLayerRendererProvider *,std::shared_ptr<MDDisplayLayerRendererProvider>::__shared_ptr_default_delete<MDDisplayLayerRendererProvider,MDDisplayLayerRendererProvider>,std::allocator<MDDisplayLayerRendererProvider>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {

    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<MDDisplayLayerRendererProvider *,std::shared_ptr<MDDisplayLayerRendererProvider>::__shared_ptr_default_delete<MDDisplayLayerRendererProvider,MDDisplayLayerRendererProvider>,std::allocator<MDDisplayLayerRendererProvider>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

MDDisplayLayerSwapchainProvider *std::__shared_ptr_pointer<MDDisplayLayerSwapchainProvider *,std::shared_ptr<MDDisplayLayerSwapchainProvider>::__shared_ptr_default_delete<MDDisplayLayerSwapchainProvider,MDDisplayLayerSwapchainProvider>,std::allocator<MDDisplayLayerSwapchainProvider>>::__on_zero_shared(uint64_t a1)
{
  __n128 result = *(MDDisplayLayerSwapchainProvider **)(a1 + 24);
  if (result)
  {
    MDDisplayLayerSwapchainProvider::~MDDisplayLayerSwapchainProvider(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<MDDisplayLayerSwapchainProvider *,std::shared_ptr<MDDisplayLayerSwapchainProvider>::__shared_ptr_default_delete<MDDisplayLayerSwapchainProvider,MDDisplayLayerSwapchainProvider>,std::allocator<MDDisplayLayerSwapchainProvider>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<MDDisplayLayerRenderTargetPreparer *,std::shared_ptr<MDDisplayLayerRenderTargetPreparer>::__shared_ptr_default_delete<MDDisplayLayerRenderTargetPreparer,MDDisplayLayerRenderTargetPreparer>,std::allocator<MDDisplayLayerRenderTargetPreparer>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<MDDisplayLayerRenderTargetPreparer *,std::shared_ptr<MDDisplayLayerRenderTargetPreparer>::__shared_ptr_default_delete<MDDisplayLayerRenderTargetPreparer,MDDisplayLayerRenderTargetPreparer>,std::allocator<MDDisplayLayerRenderTargetPreparer>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t MDDisplayLayerRenderTargetPreparer::prepareSnapshotTargets(id *this)
{
  return [this[1] finalRenderTarget];
}

void MDDisplayLayerRenderTargetPreparer::~MDDisplayLayerRenderTargetPreparer(id *this)
{
  JUMPOUT(0x1A6239270);
}

{
}

void ggl::OuterShadowRibbon::PipelineState::~PipelineState(ggl::OuterShadowRibbon::PipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::OuterShadowRibbon::PipelineSetup::textureIsEnabled(ggl::OuterShadowRibbon::PipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::OuterShadowRibbon::PipelineSetup::constantDataIsEnabled(ggl::OuterShadowRibbon::PipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::OuterShadowRibbon::PipelineSetup::~PipelineSetup(ggl::OuterShadowRibbon::PipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PassToCommandBuffers>(gdc::Entity,md::ls::PassToCommandBuffers &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF523318;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::PassToCommandBuffers>(gdc::Entity,md::ls::PassToCommandBuffers &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void md::HillshadeLogic::debugConsoleString(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void md::HillshadeLogic::~HillshadeLogic(md::HillshadeLogic *this)
{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void sub_1A254D37C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A254D5C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void VKLineDrawWithOuterStroke(const __CTLine *a1, CGContextRef c)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  CGContextSaveGState(c);
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  CTLineGetGlyphRuns(a1);
  obuint64_t j = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v4 = [obj countByEnumeratingWithState:&v29 objects:v33 count:16];
  if (v4)
  {
    uint64_t v27 = *(void *)v30;
    uint64_t v25 = (void *)*MEMORY[0x1E4F247B8];
    key = (void *)*MEMORY[0x1E4F243F0];
    uint64_t v24 = (void *)*MEMORY[0x1E4F24740];
    do
    {
      uint64_t v28 = v4;
      for (uint64_t i = 0; i != v28; ++i)
      {
        if (*(void *)v30 != v27) {
          objc_enumerationMutation(obj);
        }
        char v6 = *(const __CTRun **)(*((void *)&v29 + 1) + 8 * i);
        CFDictionaryRef Attributes = CTRunGetAttributes(v6);
        CFDictionaryRef v8 = CTRunGetAttributes(v6);
        Value = (const __CTFont *)CFDictionaryGetValue(v8, key);
        uint8x8_t v10 = Value;
        if (Value)
        {
          uint64_t v11 = CTFontCopyGraphicsFont(Value, 0);
          if (v11)
          {
            CGContextSetFont(c, v11);
            CFRelease(v11);
          }
          CGFloat Size = CTFontGetSize(v10);
          CGContextSetFontSize(c, Size);
        }
        unint64_t v13 = (CGColor *)CFDictionaryGetValue(Attributes, v25);
        if (v13) {
          CGContextSetStrokeColorWithColor(c, v13);
        }
        uint8x8_t v14 = (CGColor *)CFDictionaryGetValue(Attributes, v24);
        if (v14) {
          CGContextSetFillColorWithColor(c, v14);
        }
        uint64_t v15 = (void *)CFDictionaryGetValue(Attributes, (const void *)kVKOuterStrokeWidthAttributeName);
        uint64_t v16 = v15;
        if (v15)
        {
          [v15 floatValue];
          CGContextSetLineWidth(c, v17);
        }
        CFIndex GlyphCount = CTRunGetGlyphCount(v6);
        PositionsPtr = CTRunGetPositionsPtr(v6);
        if (PositionsPtr)
        {
          uint64_t v20 = 0;
        }
        else
        {
          uint64_t v20 = (CGPoint *)malloc_type_malloc(16 * GlyphCount, 0x1000040451B5BE8uLL);
          v35.location = 0;
          v35.length = 0;
          CTRunGetPositions(v6, v35, v20);
          PositionsPtr = v20;
        }
        GlyphsPtr = CTRunGetGlyphsPtr(v6);
        if (GlyphsPtr)
        {
          uint64_t v22 = 0;
        }
        else
        {
          uint64_t v22 = (CGGlyph *)malloc_type_malloc(16 * GlyphCount, 0x1000040451B5BE8uLL);
          v36.location = 0;
          v36.length = 0;
          CTRunGetGlyphs(v6, v36, v22);
          GlyphsPtr = v22;
        }
        CGContextSetBlendMode(c, kCGBlendModeNormal);
        if (v13 && v16)
        {
          CGContextSetTextDrawingMode(c, kCGTextStroke);
          CGContextShowGlyphsAtPositions(c, GlyphsPtr, PositionsPtr, GlyphCount);
        }
        CGContextSetTextDrawingMode(c, kCGTextFill);
        CGContextShowGlyphsAtPositions(c, GlyphsPtr, PositionsPtr, GlyphCount);
        if (v20) {
          free(v20);
        }
        if (v22) {
          free(v22);
        }
      }
      uint64_t v4 = [obj countByEnumeratingWithState:&v29 objects:v33 count:16];
    }
    while (v4);
  }

  CGContextRestoreGState(c);
}

void sub_1A254D900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

unint64_t md::GEOFlyoverTileResourceFetcher::tileKey(uint64_t a1, void *a2, void *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  char v6 = (int *)a3[1];
  int v8 = *v6;
  int v7 = v6[1];
  int v9 = v6[2];
  int v10 = *(_DWORD *)(a1 + 556);
  if (v10 == 16)
  {
    uint64_t v12 = 0;
  }
  else
  {
    if (v10 == 92)
    {
      unint64_t v11 = GEOTileKeyMake() & 0xFFFFFFFFFFFFFF7FLL;
      goto LABEL_13;
    }
    gdc::ResourceKey::keyData((gdc::ResourceKey *)&v14, a3);
    if (*((void *)&v14 + 1) - (void)v14 < 0x14uLL) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = *(unsigned int *)(a3[1] + 16);
    }
    if ((void)v14 != v15) {
      free((void *)v14);
    }
  }
  gdc::ResourceKey::keyData((gdc::ResourceKey *)&v14, a3);
  if ((void)v14 != v15) {
    free((void *)v14);
  }
  [v5 size];
  [v5 scale];
  LOBYTE(v14) = GEOTileKeyMakeEmpty();
  *(void *)((char *)&v14 + 1) = (v8 << 6) | ((unint64_t)(v7 & 0x3FFFFFF) << 32) | v9 & 0x3F | (v12 << 58);
  unint64_t v11 = v14;
LABEL_13:

  return v11;
}

void sub_1A254DB1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *md::GEOFlyoverTileResourceFetcher::tileSize@<X0>(id *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = this;
  id v4 = this[76];
  if (v4)
  {
    if ([this[76] scale] == 2)
    {
      if (*((float *)v2 + 2) > 1.0) {
        unsigned int v5 = 2;
      }
      else {
        unsigned int v5 = 1;
      }
    }
    else
    {
      unsigned int v5 = 1;
    }
    this = (id *)[v2[76] size];
    unint64_t v7 = 0x20001000080uLL >> (16 * this);
    if (this >= 3) {
      LOWORD(v7) = 0;
    }
    unsigned int v6 = (v7 & 0x380) / v5;
  }
  else
  {
    unsigned int v6 = 256;
  }
  int v8 = *((_DWORD *)v2 + 139);
  if (v8 != 92 && v8 != 16)
  {
    if (v8 == 15)
    {
      this = (id *)v2[76];
      if (this)
      {
        this = (id *)[this size];
        if (this > 2) {
          unsigned int v6 = 0;
        }
        else {
          unsigned int v6 = (float)((float)dword_1A29C5278[this] * 0.5);
        }
        goto LABEL_23;
      }
      unsigned int v6 = (float)((float)v6 * 0.5);
    }
    else
    {
      v6 >>= 1;
    }
    if (!v4) {
      unsigned int v6 = 256;
    }
  }
LABEL_23:
  *(unsigned char *)a2 = 1;
  *(_DWORD *)(a2 + 4) = v6;
  return this;
}

uint64_t md::GEOFlyoverTileResourceFetcher::downloadZoomRange@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  if (*(_DWORD *)(this + 556) == 16)
  {
    *(unsigned char *)a2 = 1;
    *(void *)(a2 + 4) = 0xE0000000ELL;
  }
  else
  {
    *(unsigned char *)a2 = 0;
    if (*(unsigned char *)(this + 592))
    {
      uint64_t v2 = *(void *)(this + 596);
      *(void *)(a2 + 4) = v2;
      *(unsigned char *)a2 = 1;
      if (v2 <= 1) {
        LODWORD(v2) = 1;
      }
      *(_DWORD *)(a2 + 4) = v2;
    }
  }
  return this;
}

uint64_t md::GEOFlyoverTileResourceFetcher::resourceTileForTile@<X0>(uint64_t this@<X0>, const QuadTile *a2@<X1>, uint64_t a3@<X8>, int8x8_t a4@<D0>, int8x8_t a5@<D1>)
{
  int v5 = *(_DWORD *)(this + 556);
  if (v5 == 92)
  {
    a4.i32[0] = 0;
    a5.i32[0] = a2->_level;
    int32x2_t v10 = (int32x2_t)vbic_s8((int8x8_t)0x100000001, vdup_lane_s8(vceq_s8(a5, a4), 0));
    int32x2_t v11 = *(int32x2_t *)&a2->_yIdx;
    if (a2->_level) {
      unsigned __int8 v12 = a2->_level - 1;
    }
    else {
      unsigned __int8 v12 = 0;
    }
    v16._unsigned __int8 type = a2->_type;
    v16._unsigned int level = v12;
    *(int32x2_t *)&v16._yIdx = vshl_s32(v11, vneg_s32(v10));
    return md::TiledGEOResourceFetcher::resourceTileForTile(this, &v16, a3);
  }
  else
  {
    if (v5 == 16)
    {
      unsigned int level = a2->_level;
      if (level >= 0xE)
      {
        unsigned int v7 = (level - 14);
        if (level < v7) {
          unsigned int v7 = a2->_level;
        }
        unsigned __int8 type = a2->_type;
        *(unsigned char *)a3 = 1;
        *(unsigned char *)(a3 + 8) = type;
        *(unsigned char *)(a3 + 9) = level - v7;
        int32x2_t v9 = vshl_s32(*(int32x2_t *)&a2->_yIdx, vneg_s32(vdup_n_s32(v7)));
LABEL_18:
        *(int32x2_t *)(a3 + 12) = v9;
        return this;
      }
    }
    else if (*(unsigned char *)(this + 592))
    {
      unsigned int v13 = a2->_level;
      int32x2_t v9 = *(int32x2_t *)&a2->_yIdx;
      unsigned __int8 v14 = a2->_type;
      if ((int)(v13 - *(_DWORD *)(this + 600)) >= 1 && a2->_level)
      {
        unsigned int v15 = (v13 - *(unsigned char *)(this + 600));
        if (v13 < v15) {
          unsigned int v15 = a2->_level;
        }
        LOBYTE(v13) = v13 - v15;
        int32x2_t v9 = vshl_s32(v9, vneg_s32(vdup_n_s32(v15)));
      }
      *(unsigned char *)a3 = 1;
      *(unsigned char *)(a3 + 8) = v14;
      *(unsigned char *)(a3 + 9) = v13;
      goto LABEL_18;
    }
    *(unsigned char *)a3 = 0;
  }
  return this;
}

void md::GEOFlyoverTileResourceFetcher::~GEOFlyoverTileResourceFetcher(id *this)
{
  md::TiledGEOResourceFetcher::~TiledGEOResourceFetcher(this);
  JUMPOUT(0x1A6239270);
}

void md::C3mResourceDecoder<md::GEOFlyoverTileResource>::decode(uint64_t a1@<X0>, const gdc::ResourceKey *a2@<X1>, unsigned char *a3@<X2>, void *a4@<X8>)
{
  if (*(void *)a3) {
    BOOL v6 = a3[16] == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6
    || (int32x2_t v9 = (unsigned char *)(*(uint64_t (**)(void))(**(void **)a3 + 32))(*(void *)a3),
        unint64_t v10 = (*(uint64_t (**)(void))(**(void **)a3 + 24))(),
        geo::c3m::loadFromChunk((uint64_t *)(a1 + 72), v9, v10, (uint64_t)v54, v11, v12),
        !v54[0]))
  {
    *a4 = 0;
    a4[1] = 0;
    return;
  }
  float32x4_t v51 = 0;
  uint64_t v52 = 0;
  unint64_t v53 = 0;
  std::vector<std::shared_ptr<md::GEOVectorTileResource>>::reserve((uint64_t)&v51, 0x4EC4EC4EC4EC4EC5 * ((v60 - v59) >> 3));
  unsigned int v13 = v59;
  unsigned __int8 v14 = v60;
  if (v59 != v60)
  {
    unsigned int v15 = (id *)(a1 + 8);
    do
    {
      int v16 = *v13;
      if ((v16 - 4) < 2 || v16 == 2)
      {
        uint64_t v18 = (void **)*((void *)v13 + 1);
        if (*((void *)v13 + 2) - (void)v18 == 32)
        {
          uint64_t v46 = 0;
          uint64_t v47 = 0;
          char v48 = 0;
          unint64_t v19 = [MEMORY[0x1E4F1C9B8] dataWithBytesNoCopy:**v18 length:(*v18)[1] - **v18 freeWhenDone:0];
          uint64_t v20 = (std::__shared_weak_count *)operator new(0x38uLL);
          v20->__shared_owners_ = 0;
          v20->__shared_weak_owners_ = 0;
          v20->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582C50;
          uint64_t v46 = gdc::DataObject::DataObject((gdc::DataObject *)&v20[1], v19);
          uint64_t v47 = v20;
          md::ImageResourceDecoder::decode(a2, (const gdc::RawResourceSourceData *)&v46, (uint64_t *)&v45);
          unint64_t v21 = v52;
          if ((unint64_t)v52 < v53) {
            goto LABEL_21;
          }
          goto LABEL_25;
        }
      }
      else if (!*v13)
      {
        uint64_t v22 = (void **)*((void *)v13 + 1);
        if (*((void *)v13 + 2) - (void)v22 == 32)
        {
          uint64_t v46 = 0;
          uint64_t v47 = 0;
          char v48 = 0;
          unint64_t v19 = [MEMORY[0x1E4F1C9B8] dataWithBytesNoCopy:**v22 length:(*v22)[1] - **v22 freeWhenDone:0];
          unint64_t v23 = (std::__shared_weak_count *)operator new(0x38uLL);
          v23->__shared_owners_ = 0;
          v23->__shared_weak_owners_ = 0;
          v23->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582C50;
          uint64_t v46 = gdc::DataObject::DataObject((gdc::DataObject *)&v23[1], v19);
          uint64_t v47 = v23;
          md::TextureResourceDecoder::decode(v15, a2, (const gdc::RawResourceSourceData *)&v46, &v45);
          unint64_t v21 = v52;
          if ((unint64_t)v52 < v53)
          {
LABEL_21:
            *(_OWORD *)unint64_t v21 = v45;
            uint64_t v52 = v21 + 16;
            goto LABEL_28;
          }
LABEL_25:
          uint64_t v27 = std::vector<std::shared_ptr<gdc::LayerDataRequest>>::__push_back_slow_path<std::shared_ptr<gdc::LayerDataRequest>>(&v51, (uint64_t)&v45);
          uint64_t v28 = (std::__shared_weak_count *)*((void *)&v45 + 1);
          uint64_t v52 = v27;
          if (*((void *)&v45 + 1)
            && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v45 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
LABEL_28:

          if (v48)
          {
            if (v49 != v50) {
              free(v49);
            }
            char v48 = 0;
          }
          uint64_t v26 = v47;
          if (!v47) {
            goto LABEL_9;
          }
LABEL_33:
          if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
            std::__shared_weak_count::__release_weak(v26);
          }
          goto LABEL_9;
        }
      }
      uint64_t v46 = 0;
      uint64_t v47 = 0;
      uint64_t v24 = v52;
      if ((unint64_t)v52 < v53)
      {
        *(void *)uint64_t v52 = 0;
        *((void *)v24 + 1) = 0;
        uint64_t v52 = v24 + 16;
      }
      else
      {
        uint64_t v25 = std::vector<std::shared_ptr<gdc::LayerDataRequest>>::__push_back_slow_path<std::shared_ptr<gdc::LayerDataRequest>>(&v51, (uint64_t)&v46);
        uint64_t v26 = v47;
        uint64_t v52 = v25;
        if (v47) {
          goto LABEL_33;
        }
      }
LABEL_9:
      v13 += 104;
    }
    while (v13 != v14);
  }
  long long v29 = (char *)operator new(0x360uLL);
  *((void *)v29 + 1) = 0;
  *((void *)v29 + 2) = 0;
  *(void *)long long v29 = &unk_1EF581520;
  long long v30 = v29 + 32;
  gdc::Resource::Resource((uint64_t)(v29 + 32), (uint64_t)a2);
  *((void *)v29 + 3) = &unk_1EF541500;
  geo::c3m::Model::Model((geo::c3m::Model *)(v29 + 176), (const geo::c3m::Model *)&v55);
  *((void *)v29 + 107) = 0;
  *(_OWORD *)(v29 + 840) = 0u;
  long long v31 = v51;
  long long v32 = v52;
  uint64_t v33 = v52 - v51;
  if (v52 != v51)
  {
    if (v33 < 0) {
      abort();
    }
    uint64_t v34 = (char *)operator new(v52 - v51);
    uint64_t v35 = 0;
    *((void *)v29 + 105) = v34;
    *((void *)v29 + 106) = v34;
    *((void *)v29 + 107) = &v34[16 * (v33 >> 4)];
    do
    {
      CFRange v36 = &v31[v35];
      uint64_t v37 = &v34[v35];
      *(void *)uint64_t v37 = *(void *)&v31[v35];
      uint64_t v38 = *(void *)&v31[v35 + 8];
      *((void *)v37 + 1) = v38;
      if (v38) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v38 + 8), 1uLL, memory_order_relaxed);
      }
      v35 += 16;
    }
    while (v36 + 16 != v32);
    *((void *)v29 + 106) = &v34[v35];
    *a4 = v30;
    a4[1] = v29;
    if (!v31) {
      goto LABEL_54;
    }
    if (v32 != v31)
    {
      do
      {
        uint64_t v39 = (std::__shared_weak_count *)*((void *)v32 - 1);
        if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
          std::__shared_weak_count::__release_weak(v39);
        }
        v32 -= 16;
      }
      while (v32 != v31);
      long long v31 = v51;
    }
    goto LABEL_53;
  }
  *a4 = v30;
  a4[1] = v29;
  if (v31) {
LABEL_53:
  }
    operator delete(v31);
LABEL_54:
  if (v54[0])
  {
    unint64_t v40 = v59;
    unint64_t v41 = v60;
    if (v59 != v60)
    {
      do
      {
        unint64_t v42 = (void *)*((void *)v40 + 1);
        unsigned int v43 = (void *)*((void *)v40 + 2);
        if (v42 != v43)
        {
          do
          {
            unint64_t v44 = (std::__shared_weak_count *)v42[1];
            if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
              std::__shared_weak_count::__release_weak(v44);
            }
            v42 += 4;
          }
          while (v42 != v43);
          unint64_t v42 = (void *)*((void *)v40 + 1);
        }
        if (v42 != *((void **)v40 + 3)) {
          free(v42);
        }
        v40 += 104;
      }
      while (v40 != v41);
      unint64_t v40 = v59;
    }
    if (v40 != v61) {
      free(v40);
    }
    geo::small_vector_base<geo::c3m::Mesh>::runDestructors((uint64_t)v56, v57);
    if (v56 != v58) {
      free(v56);
    }
  }
}

void sub_1A254E3E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,char a30)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);

  gdc::RawResourceSourceData::~RawResourceSourceData((gdc::RawResourceSourceData *)&a12);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)&a27);
  if (a30) {
    geo::c3m::Model::~Model(v30);
  }
  _Unwind_Resume(a1);
}

void md::GEOFlyoverTileResource::~GEOFlyoverTileResource(md::GEOFlyoverTileResource *this)
{
  md::GEOFlyoverTileResource::~GEOFlyoverTileResource(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v5;
  void *v6;

  *(void *)this = &unk_1EF541500;
  uint64_t v2 = *((void *)this + 102);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 103);
    id v4 = (void *)*((void *)this + 102);
    if (v3 != v2)
    {
      do
      {
        int v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      id v4 = (void *)*((void *)this + 102);
    }
    *((void *)this + 103) = v2;
    operator delete(v4);
  }
  geo::c3m::Model::~Model((md::GEOFlyoverTileResource *)((char *)this + 152));
  BOOL v6 = (void *)*((void *)this + 2);
  if (v6 != *((void **)this + 4)) {
    free(v6);
  }
}

uint64_t std::__shared_ptr_emplace<md::GEOFlyoverTileResource>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::GEOFlyoverTileResource>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581520;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::GEOFlyoverTileResource>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581520;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::C3mResourceDecoder<md::GEOFlyoverTileResource>::~C3mResourceDecoder(uint64_t a1)
{
  md::C3mResourceDecoder<md::GEOFlyoverTileResource>::~C3mResourceDecoder(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::C3mResourceDecoder<md::GEOFlyoverTileResource>::~C3mResourceDecoder(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5387B0;
  std::mutex::~mutex((std::mutex *)(a1 + 112));
  uint64_t v2 = *(void ****)(a1 + 88);
  if (v2)
  {
    do
    {
      uint64_t v3 = *v2;
      geo::c3m::EdgebreakerDecodeTable::~EdgebreakerDecodeTable(v2 + 4);
      operator delete(v2);
      uint64_t v2 = (void ***)v3;
    }
    while (v3);
  }
  id v4 = *(void **)(a1 + 72);
  *(void *)(a1 + 72) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)(a1 + 40) = &unk_1EF53D7F8;
  *(void *)(a1 + 48) = &unk_1EF559798;

  *(void *)(a1 + 8) = &unk_1EF5426B0;
  *(void *)(a1 + 16) = &unk_1EF559798;

  return a1;
}

uint64_t std::__shared_ptr_emplace<md::C3mResourceDecoder<md::GEOFlyoverTileResource>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::C3mResourceDecoder<md::GEOFlyoverTileResource>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5806E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::C3mResourceDecoder<md::GEOFlyoverTileResource>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5806E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A254E8FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *md::WaypointLabelPart::populateMeshDescriptor(md::WaypointLabelPart *this, md::IconMeshDescriptor *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  *((unsigned char *)a2 + 1) = 1;
  *((unsigned char *)a2 + 2) = *((unsigned char *)this + 765);
  v3[0] = &unk_1EF573860;
  v3[1] = this;
  id v4 = v3;
  std::__function::__value_func<void ()(md::LabelRenderDescriptor const&,md::IconMeshData &)>::swap[abi:nn180100](v3, (void *)a2 + 1);
  __n128 result = v4;
  if (v4 == v3) {
    return (void *)(*(uint64_t (**)(void *))(v3[0] + 32))(v3);
  }
  if (v4) {
    return (void *)(*(uint64_t (**)(void))(*v4 + 40))();
  }
  return result;
}

_DWORD *std::__function::__func<md::WaypointLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0,std::allocator<md::WaypointLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0>,void ()(md::LabelRenderDescriptor const&,md::IconMeshData &)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v4 + 565)) {
    *(void *)(a3 + 64) = (*(uint64_t (**)(void))(*(void *)v4 + 144))(*(void *)(a1 + 8));
  }
  float v5 = *(float *)(v4 + 608) * *(float *)(v4 + 596);
  *(_DWORD *)(a3 + 48) = *(_DWORD *)(v4 + 552);
  *(float *)(a3 + 52) = v5;
  *(_DWORD *)(a3 + 56) = *(_DWORD *)(v4 + 604);
  *(_DWORD *)a3 = *(_DWORD *)(v4 + 696);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(v4 + 700);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(v4 + 704);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(v4 + 708);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(v4 + 712);
  *(_DWORD *)(a3 + 20) = *(_DWORD *)(v4 + 716);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(v4 + 720);
  *(_DWORD *)(a3 + 28) = *(_DWORD *)(v4 + 724);
  __n128 result = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 928))(v4);
  *(_DWORD *)(a3 + 32) = *result;
  *(_DWORD *)(a3 + 36) = result[1];
  *(_DWORD *)(a3 + 40) = result[2];
  *(_DWORD *)(a3 + 44) = result[3];
  *(_OWORD *)(a3 + 72) = *(_OWORD *)(v4 + 896);
  *(unsigned char *)(a3 + 88) = *(unsigned char *)(v4 + 824);
  *(unsigned char *)(a3 + 89) = *(unsigned char *)(v4 + 825);
  *(unsigned char *)(a3 + 90) = *(unsigned char *)(v4 + 826);
  *(unsigned char *)(a3 + 91) = *(unsigned char *)(v4 + 827);
  *(unsigned char *)(a3 + 92) = *(unsigned char *)(v4 + 828);
  *(unsigned char *)(a3 + 93) = *(unsigned char *)(v4 + 829);
  *(unsigned char *)(a3 + 94) = *(unsigned char *)(v4 + 830);
  *(unsigned char *)(a3 + 95) = *(unsigned char *)(v4 + 831);
  *(unsigned char *)(a3 + 96) = *(unsigned char *)(v4 + 832);
  *(unsigned char *)(a3 + 97) = *(unsigned char *)(v4 + 833);
  *(unsigned char *)(a3 + 98) = *(unsigned char *)(v4 + 834);
  *(unsigned char *)(a3 + 99) = *(unsigned char *)(v4 + 835);
  if (*(unsigned char *)(v4 + 765))
  {
    *(unsigned char *)(a3 + 100) = *(unsigned char *)(v4 + 836);
    *(unsigned char *)(a3 + 101) = *(unsigned char *)(v4 + 837);
    *(unsigned char *)(a3 + 102) = *(unsigned char *)(v4 + 838);
    *(unsigned char *)(a3 + 103) = *(unsigned char *)(v4 + 839);
    *(unsigned char *)(a3 + 104) = *(unsigned char *)(v4 + 840);
    *(unsigned char *)(a3 + 105) = *(unsigned char *)(v4 + 841);
    *(unsigned char *)(a3 + 106) = *(unsigned char *)(v4 + 842);
    *(unsigned char *)(a3 + 107) = *(unsigned char *)(v4 + 843);
    *(unsigned char *)(a3 + 108) = *(unsigned char *)(v4 + 844);
    *(unsigned char *)(a3 + 109) = *(unsigned char *)(v4 + 845);
    *(unsigned char *)(a3 + 110) = *(unsigned char *)(v4 + 846);
    *(unsigned char *)(a3 + 111) = *(unsigned char *)(v4 + 847);
  }
  return result;
}

uint64_t std::__function::__func<md::WaypointLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0,std::allocator<md::WaypointLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0>,void ()(md::LabelRenderDescriptor const&,md::IconMeshData &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF573860;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::WaypointLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0,std::allocator<md::WaypointLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0>,void ()(md::LabelRenderDescriptor const&,md::IconMeshData &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF573860;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::WaypointLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0,std::allocator<md::WaypointLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0>,void ()(md::LabelRenderDescriptor const&,md::IconMeshData &)>::~__func()
{
}

float md::WaypointLabelPart::collisionBounds(md::WaypointLabelPart *this, const md::LabelIcon *a2)
{
  return *((float *)this + 212);
}

uint64_t md::WaypointLabelPart::textureRect(md::WaypointLabelPart *this)
{
  return (uint64_t)this + 864;
}

float md::WaypointLabelPart::meshRect(md::WaypointLabelPart *this)
{
  return *((float *)this + 220);
}

uint64_t md::WaypointLabelPart::styleLayer(md::WaypointLabelPart *this, const md::LabelStyle *a2)
{
  return *(char *)(*((void *)this + 2) + 753);
}

uint64_t md::WaypointLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t *a4, float32x2_t *a5, double a6, double a7, double a8)
{
  uint64_t v8 = *(void *)(a1 + 808);
  HIDWORD(v9) = 0;
  *(float *)&double v9 = fminf(fmaxf(*(float *)(*(void *)(a1 + 32) + 64), 0.0), 23.0);
  unsigned int v10 = (int)*(float *)&v9;
  if ((int)*(float *)&v9 >= 0x17) {
    uint64_t v11 = 23;
  }
  else {
    uint64_t v11 = v10;
  }
  uint64_t v12 = 1 << v11;
  float v13 = *(float *)(v8 + 4 * v11);
  if ((*(void *)(v8 + 96) & (1 << v11)) != 0)
  {
    if (v10 >= 0x16) {
      int v14 = 22;
    }
    else {
      int v14 = (int)*(float *)&v9;
    }
    float v15 = *(float *)(v8 + 4 * (v14 + 1));
    if (*(unsigned char *)(v8 + 104) || (a6 = 0.0, v13 != 0.0) && v15 != 0.0) {
      *(float *)&a6 = v13 + (float)((float)(v15 - v13) * (float)(*(float *)&v9 - (float)v11));
    }
  }
  else
  {
    LODWORD(a6) = *(_DWORD *)(v8 + 4 * v11);
  }
  *(_DWORD *)(v8 + 336) = LODWORD(a6);
  float v16 = *(float *)(v8 + 112 + 4 * v11);
  if ((*(void *)(v8 + 208) & v12) != 0)
  {
    if (v10 >= 0x16) {
      int v17 = 22;
    }
    else {
      int v17 = (int)*(float *)&v9;
    }
    float v18 = *(float *)(v8 + 112 + 4 * (v17 + 1));
    if (*(unsigned char *)(v8 + 216) || (a8 = 0.0, v16 != 0.0) && v18 != 0.0) {
      *(float *)&a8 = v16 + (float)((float)(v18 - v16) * (float)(*(float *)&v9 - (float)v11));
    }
  }
  else
  {
    LODWORD(a8) = *(_DWORD *)(v8 + 112 + 4 * v11);
  }
  *(_DWORD *)(v8 + 340) = LODWORD(a8);
  float v19 = *(float *)(v8 + 224 + 4 * v11);
  if ((*(void *)(v8 + 320) & v12) != 0)
  {
    if (v10 >= 0x16) {
      unsigned int v10 = 22;
    }
    float v20 = *(float *)(v8 + 224 + 4 * (v10 + 1));
    if (*(unsigned char *)(v8 + 328) || (float v21 = 0.0, v19 != 0.0) && v20 != 0.0) {
      float v21 = v19 + (float)((float)(v20 - v19) * (float)(*(float *)&v9 - (float)v11));
    }
  }
  else
  {
    float v21 = *(float *)(v8 + 224 + 4 * v11);
  }
  *(float *)(v8 + 344) = v21;
  *(_DWORD *)(a1 + 896) = LODWORD(a6);
  float v22 = *(float *)&a8 + *(float *)&a6;
  *(float *)(a1 + 900) = *(float *)&a8 + *(float *)&a6;
  *(float *)&double v9 = (float)(*(float *)&a8 + *(float *)&a6) + v21;
  *(_DWORD *)(a1 + 904) = LODWORD(v9);
  if (*(float *)&a8 <= 0.0)
  {
    if (v21 <= 0.0)
    {
      LODWORD(a8) = 1.0;
      *(float *)(a1 + 896) = *(float *)&a6 + 1.0;
      goto LABEL_36;
    }
    goto LABEL_34;
  }
  a8 = 0.0;
  *(float *)&a6 = fmaxf(*(float *)&a6 + -1.0, 0.0);
  *(_DWORD *)(a1 + 896) = LODWORD(a6);
  if (v21 > 0.0)
  {
LABEL_34:
    *(float *)&a8 = v22 + -1.0;
    *(float *)(a1 + 900) = fmaxf(*(float *)&a6, v22 + -1.0);
    *(float *)&double v9 = *(float *)&v9 + 1.0;
    *(_DWORD *)(a1 + 904) = LODWORD(v9);
    goto LABEL_36;
  }
  *(float *)(a1 + 900) = v22 + 1.0;
LABEL_36:
  *(float *)&a6 = *(float *)&v9 + 1.0;
  *(float *)(a1 + 908) = (float)(*(float *)&v9 + 1.0) + (float)(*(float *)&v9 + 1.0);
  *(float *)&double v9 = -(float)(*(float *)&v9 + 1.0);
  *(_DWORD *)(a1 + 880) = LODWORD(v9);
  *(_DWORD *)(a1 + 884) = LODWORD(v9);
  *(_DWORD *)(a1 + 888) = LODWORD(a6);
  *(_DWORD *)(a1 + 892) = LODWORD(a6);
  md::IconLabelPart::layoutForDisplay(a1, a2, a3, a4, a5, a6, v9, a8);
  return 37;
}

double md::WaypointLabelPart::updateForDisplay(md::WaypointLabelPart *this)
{
  uint64_t v2 = (char *)this + 572;
  float v3 = *((float *)this + 147);
  *((float *)this + 153) = v3;
  uint64_t v4 = *(void *)((char *)this + 572);
  *((_DWORD *)this + 151) = *((_DWORD *)this + 145);
  *(void *)((char *)this + 596) = v4;
  *((unsigned char *)this + 617) = *((unsigned char *)this + 593);
  LOBYTE(v4) = *((unsigned char *)this + 633) + 4 * *((unsigned char *)this + 594);
  *((unsigned char *)this + 556) = v4;
  *((unsigned char *)this + 658) = v4;
  LODWORD(v4) = *((unsigned __int8 *)this + 592);
  *((unsigned char *)this + 657) = v4;
  *((unsigned char *)this + 765) = v4 == 4;
  if (v4 == 4) {
    char v5 = 2;
  }
  else {
    char v5 = 1;
  }
  float v6 = *((float *)this + 188);
  *((unsigned char *)this + 685) = v5;
  if (v3 != v6)
  {
    *((float *)this + 188) = v3;
    (*(void (**)(md::WaypointLabelPart *, uint64_t, char *, char *))(*(void *)this + 912))(this, 1, (char *)this + 640, (char *)this + 312);
  }
  uint64_t v7 = *((void *)this + 96);
  uint64_t v8 = *((void *)this + 97);
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)this + 101) = v7;
  double v9 = (std::__shared_weak_count *)*((void *)this + 102);
  *((void *)this + 102) = v8;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  *(_OWORD *)(v2 + 252) = *((_OWORD *)this + 49);
  double result = *((double *)this + 100);
  *((double *)this + 105) = result;
  return result;
}

void md::WaypointLabelPart::prepareForDisplay(md::WaypointLabelPart *this, md::LabelManager *a2)
{
  float v3 = *((float *)this + 153);
  if (v3 != *((float *)this + 188)
    || *((float *)this + 80) < *((float *)this + 78)
    || *((float *)this + 81) < *((float *)this + 79))
  {
    *((float *)this + 188) = v3;
    (*(void (**)(md::WaypointLabelPart *, uint64_t, char *, char *))(*(void *)this + 912))(this, 1, (char *)this + 640, (char *)this + 312);
  }
  if (*((unsigned char *)this + 565)) {
    operator new();
  }
  uint64_t v4 = **((void **)this + 4);
  uint64_t v5 = *(void *)(v4 + 440);
  if (!v5)
  {
    md::LabelStyle::prepareDisplayIconStyleGroup(**((md::LabelStyle ***)this + 4));
    uint64_t v5 = *(void *)(v4 + 440);
    uint64_t v6 = *(void *)(v4 + 448);
    if (!v6) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  uint64_t v6 = *(void *)(v4 + 448);
  if (v6) {
LABEL_9:
  }
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
LABEL_10:
  *((void *)this + 96) = v5;
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 97);
  *((void *)this + 97) = v6;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

float md::WaypointLabelPart::updateWithStyle(md::WaypointLabelPart *this, md::LabelManager *a2)
{
  md::ImageLabelPart::updateWithStyle(this, a2);
  float v3 = (md::LabelStyle **)*((void *)this + 4);
  if (*((void *)this + 96))
  {
    uint64_t v4 = *v3;
    uint64_t v5 = *((void *)*v3 + 55);
    if (!v5)
    {
      md::LabelStyle::prepareDisplayIconStyleGroup(*v3);
      uint64_t v5 = *((void *)v4 + 55);
    }
    uint64_t v6 = *((void *)v4 + 56);
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    *((void *)this + 96) = v5;
    uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 97);
    *((void *)this + 97) = v6;
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  if (*((unsigned char *)this + 592) == 4)
  {
    uint64_t v8 = *v3;
    double v9 = (unsigned char *)*((void *)*v3 + 38);
    if (!v9)
    {
      unsigned int v10 = (void *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>((uint64_t)*v3, 1);
      double v9 = (unsigned char *)*v10;
      *((void *)v8 + 38) = *v10;
    }
    *((unsigned char *)this + 796) = v9[72];
    *((unsigned char *)this + 797) = v9[73];
    *((unsigned char *)this + 798) = v9[74];
    *((unsigned char *)this + 799) = v9[75];
    *((unsigned char *)this + 800) = v9[80];
    *((unsigned char *)this + 801) = v9[81];
    *((unsigned char *)this + 802) = v9[82];
    *((unsigned char *)this + 803) = v9[83];
    *((unsigned char *)this + 804) = v9[84];
    *((unsigned char *)this + 805) = v9[85];
    *((unsigned char *)this + 806) = v9[86];
    *((unsigned char *)this + 807) = v9[87];
  }
  uint64_t v11 = *v3;
  uint64_t v12 = *((void *)*v3 + 37);
  if (!v12)
  {
    float v13 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>((uint64_t)*v3, 0);
    uint64_t v12 = *v13;
    *((void *)v11 + 37) = *v13;
  }
  *((unsigned char *)this + 784) = *(unsigned char *)(v12 + 72);
  *((unsigned char *)this + 785) = *(unsigned char *)(v12 + 73);
  *((unsigned char *)this + 786) = *(unsigned char *)(v12 + 74);
  *((unsigned char *)this + 787) = *(unsigned char *)(v12 + 75);
  *((unsigned char *)this + 788) = *(unsigned char *)(v12 + 80);
  *((unsigned char *)this + 789) = *(unsigned char *)(v12 + 81);
  *((unsigned char *)this + 790) = *(unsigned char *)(v12 + 82);
  *((unsigned char *)this + 791) = *(unsigned char *)(v12 + 83);
  *((unsigned char *)this + 792) = *(unsigned char *)(v12 + 84);
  *((unsigned char *)this + 793) = *(unsigned char *)(v12 + 85);
  *((unsigned char *)this + 794) = *(unsigned char *)(v12 + 86);
  *((unsigned char *)this + 795) = *(unsigned char *)(v12 + 87);
  float result = (float)(*(float *)(v12 + 48) + *(float *)(v12 + 44)) + *(float *)(v12 + 52);
  *((float *)this + 212) = -result;
  *((float *)this + 213) = -result;
  *((float *)this + 214) = result;
  *((float *)this + 215) = result;
  return result;
}

void md::WaypointLabelPart::~WaypointLabelPart(md::WaypointLabelPart *this)
{
  *(void *)this = &unk_1EF5382A0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 102);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  float v3 = (std::__shared_weak_count *)*((void *)this + 97);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  md::IconLabelPart::~IconLabelPart(this);
  {
    operator new();
  }
  uint64_t v4 = *(void (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
  v4();
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF5382A0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 102);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    float v3 = (std::__shared_weak_count *)*((void *)this + 97);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    float v3 = (std::__shared_weak_count *)*((void *)this + 97);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::IconLabelPart::~IconLabelPart(this);
}

void md::StyleFadeLabelPart::debugCompositeClassName(char *a1@<X8>)
{
  a1[23] = 9;
  strcpy(a1, "StyleFade");
}

uint64_t md::StyleFadeLabelPart::needsCrossfade()
{
  return 0;
}

uint64_t md::StyleFadeLabelPart::isTextVisible(md::StyleFadeLabelPart *this)
{
  return (*(uint64_t (**)(void))(**(void **)(*((void *)this + 72) + 8) + 744))();
}

uint64_t md::StyleFadeLabelPart::isCrossFadeNode(md::StyleFadeLabelPart *this)
{
  return 0;
}

uint64_t md::StyleFadeLabelPart::isStyleFadeNode(md::StyleFadeLabelPart *this)
{
  return 1;
}

uint64_t md::StyleFadeLabelPart::isFading(md::StyleFadeLabelPart *this)
{
  return 0;
}

uint64_t md::StyleFadeLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(a2 + 3488);
  if (v10)
  {
    uint64_t v11 = *(void *)(v10 + 520);
    uint64_t v12 = *(std::__shared_weak_count **)(v10 + 528);
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      int v13 = *(_DWORD *)(v11 + 256);
      if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    else
    {
      int v13 = *(_DWORD *)(v11 + 256);
    }
  }
  else
  {
    int v13 = 0;
  }
  *(_DWORD *)(a1 + 632) = v13;
  if ((*(unsigned int (**)(void))(***(void ***)(a1 + 576) + 88))(**(void **)(a1 + 576))) {
    char v14 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(***(void ***)(a1 + 576) + 120))(**(void **)(a1 + 576), a2, a3, a4, a5);
  }
  else {
    char v14 = 32;
  }
  *(unsigned char *)(a1 + 636) = v14;
  if ((*(unsigned int (**)(void))(**(void **)(*(void *)(a1 + 576) + 8) + 88))(*(void *)(*(void *)(a1 + 576) + 8))) {
    LODWORD(result) = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 576) + 8)
  }
                                                                                            + 120))(*(void *)(*(void *)(a1 + 576) + 8), a2, a3, a4, a5);
  else {
    LODWORD(result) = 32;
  }
  *(unsigned char *)(a1 + 637) = result;
  if (*(unsigned char *)(a1 + 636) == 37) {
    return 37;
  }
  else {
    return result;
  }
}

void md::StyleFadeLabelPart::~StyleFadeLabelPart(md::StyleFadeLabelPart *this)
{
  md::CompositeLabelPart::~CompositeLabelPart(this);
  uint64_t v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  uint64_t v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

uint64_t std::__shared_ptr_emplace<md::NamedLabelDedupingGroup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::NamedLabelDedupingGroup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5817F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::NamedLabelDedupingGroup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5817F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<md::LabelSpacingDedupingGroup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::LabelSpacingDedupingGroup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581D38;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelSpacingDedupingGroup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581D38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      int v3 = *(std::__shared_weak_count **)(v2 + 32);
      if (v3)
      {
        if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
          std::__shared_weak_count::__release_weak(v3);
        }
      }
    }
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)a1[1] + 40))(*(void *)a1[1], v2, 40);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<md::MuninPointLabelDedupingGroup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::MuninPointLabelDedupingGroup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5823C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::MuninPointLabelDedupingGroup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5823C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<md::Label>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5829B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::Label>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5829B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

unint64_t std::__hash_table<std::shared_ptr<md::LabelMapTile>,std::hash<std::shared_ptr<md::LabelMapTile>>,std::equal_to<std::shared_ptr<md::LabelMapTile>>,geo::StdAllocator<std::shared_ptr<md::LabelMapTile>,mdm::Allocator>>::__emplace_unique_key_args<std::shared_ptr<md::LabelMapTile>,std::shared_ptr<md::LabelMapTile> const&>(unint64_t result, unint64_t a2, void *a3)
{
  uint64_t v5 = result;
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *(void *)(result + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    uint64_t v11 = *(void **)(*(void *)result + 8 * v3);
    if (v11)
    {
      uint64_t v12 = (void *)*v11;
      if (v12)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v14 = v12[1];
            if (v14 == v8)
            {
              if (v12[2] == a2) {
                return result;
              }
            }
            else if ((v14 & (v9 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == v8)
          {
            if (v12[2] == a2) {
              return result;
            }
          }
          else
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
            if (v13 != v3) {
              break;
            }
          }
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_22:
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(result + 32) + 16))(*(void *)(result + 32), 32, 8);
  unint64_t v15 = result;
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = v8;
  *(void *)(result + 16) = *a3;
  uint64_t v16 = a3[1];
  *(void *)(result + 24) = v16;
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  float v17 = (float)(unint64_t)(*(void *)(v5 + 40) + 1);
  float v18 = *(float *)(v5 + 48);
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    BOOL v19 = 1;
    if (v9 >= 3) {
      BOOL v19 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v9);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    if (v22 == 1)
    {
      size_t v22 = 2;
    }
    else if ((v22 & (v22 - 1)) != 0)
    {
      uint64_t result = std::__next_prime(v22);
      size_t v22 = result;
    }
    int8x8_t v23 = *(int8x8_t *)(v5 + 8);
    if (v22 > *(void *)&v23) {
      goto LABEL_36;
    }
    if (v22 < *(void *)&v23)
    {
      uint64_t result = vcvtps_u32_f32((float)*(unint64_t *)(v5 + 40) / *(float *)(v5 + 48));
      if (*(void *)&v23 < 3uLL || (uint8x8_t v24 = (uint8x8_t)vcnt_s8(v23), v24.i16[0] = vaddlv_u8(v24), v24.u32[0] > 1uLL))
      {
        uint64_t result = std::__next_prime(result);
      }
      else
      {
        uint64_t v25 = 1 << -(char)__clz(result - 1);
        if (result >= 2) {
          uint64_t result = v25;
        }
      }
      if (v22 <= result) {
        size_t v22 = result;
      }
      if (v22 < *(void *)&v23) {
LABEL_36:
      }
        uint64_t result = std::__hash_table<std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,std::__unordered_map_hasher<VKTrafficFeature * {__strong},std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,md::TrafficFeatureHash,std::equal_to<VKTrafficFeature * {__strong}>,true>,std::__unordered_map_equal<VKTrafficFeature * {__strong},std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,std::equal_to<VKTrafficFeature * {__strong}>,md::TrafficFeatureHash,true>,geo::StdAllocator<std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,mdm::Allocator>>::__do_rehash<true>(v5, v22);
    }
    unint64_t v9 = *(void *)(v5 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v26 = *(unint64_t **)(*(void *)v5 + 8 * v3);
  if (v26)
  {
    *(void *)unint64_t v15 = *v26;
LABEL_60:
    *uint64_t v26 = v15;
    goto LABEL_61;
  }
  *(void *)unint64_t v15 = *(void *)(v5 + 24);
  *(void *)(v5 + 24) = v15;
  *(void *)(*(void *)v5 + 8 * v3) = v5 + 24;
  if (*(void *)v15)
  {
    unint64_t v27 = *(void *)(*(void *)v15 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v27 >= v9) {
        v27 %= v9;
      }
    }
    else
    {
      v27 &= v9 - 1;
    }
    uint64_t v26 = (unint64_t *)(*(void *)v5 + 8 * v27);
    goto LABEL_60;
  }
LABEL_61:
  ++*(void *)(v5 + 40);
  return result;
}

void sub_1A254FF34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::shared_ptr<md::LabelMapTile>,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::shared_ptr<md::LabelMapTile>,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void md::LabelPool::setAdoptedLabel(uint64_t a1, uint64_t *a2)
{
  if (*(void *)(a1 + 704))
  {
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 712);
    *(_OWORD *)(a1 + 704) = 0u;
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    *(unsigned char *)(a1 + 760) = 0;
    *(unsigned char *)(a1 + 758) = 1;
  }
  uint64_t v5 = *a2;
  if (*a2)
  {
    uint64_t v6 = a2[1];
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)(a1 + 704) = v5;
    unint64_t v7 = *(std::__shared_weak_count **)(a1 + 712);
    *(void *)(a1 + 712) = v6;
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    *(unsigned char *)(a1 + 760) = 0;
    if (*a2) {
      *(unsigned char *)(a1 + 757) = 0;
    }
  }
}

void md::LabelPool::setPreviouslySelectedLabel(uint64_t a1, uint64_t *a2)
{
  if (*(void *)(a1 + 720))
  {
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 728);
    *(_OWORD *)(a1 + 720) = 0u;
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    *(unsigned char *)(a1 + 760) = 0;
    *(unsigned char *)(a1 + 758) = 1;
  }
  uint64_t v5 = *a2;
  if (*a2)
  {
    uint64_t v6 = a2[1];
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)(a1 + 720) = v5;
    unint64_t v7 = *(std::__shared_weak_count **)(a1 + 728);
    *(void *)(a1 + 728) = v6;
    if (v7)
    {
      if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    *(unsigned char *)(a1 + 760) = 0;
  }
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_1,std::allocator<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_1>,void ()(md::ls::FunctionConstants &,md::ls::IsTransparent const&)>::operator()(uint64_t a1, unsigned char *a2)
{
  *a2 = 1;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_1,std::allocator<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_1>,void ()(md::ls::FunctionConstants &,md::ls::IsTransparent const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF520A50;
}

void *std::__function::__func<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_1,std::allocator<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_1>,void ()(md::ls::FunctionConstants &,md::ls::IsTransparent const&)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF520A50;
  return result;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_1,std::allocator<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_1>,void ()(md::ls::FunctionConstants &,md::ls::IsTransparent const&)>::~__func()
{
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&)>::operator()(uint64_t a1, unsigned char *a2)
{
  *a2 = 1;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF520A08;
}

void *std::__function::__func<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF520A08;
  return result;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorSplined::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsTransparent const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::IsMercator const&,md::ls::IsOpaque const&)>::~__func()
{
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_1,std::allocator<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_1>,void ()(md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  *(unsigned char *)(a2 + 4) = (*a4 | *a5) != 0;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_1,std::allocator<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_1>,void ()(md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5209C0;
}

void *std::__function::__func<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_1,std::allocator<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_1>,void ()(md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF5209C0;
  return result;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_1,std::allocator<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_1>,void ()(md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*)>::~__func()
{
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::UsesShadow const&)>::operator()(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 4) = 1;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::UsesShadow const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF520978;
}

void *std::__function::__func<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::UsesShadow const&)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF520978;
  return result;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorShadows::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::UsesShadow const&)>::~__func()
{
}

void *std::function<void ()(md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorFog::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorFog::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&)>::operator()(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 24) = 1;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorFog::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorFog::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF520780;
}

void *std::__function::__func<md::ita::PrepareFunctionConstantDescriptorFog::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorFog::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF520780;
  return result;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorFog::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorFog::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&)>::~__func()
{
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_1,std::allocator<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_1>,void ()(md::ls::FunctionConstants &,md::ls::IsNotMercator const&)>::operator()(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 15) = 1;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_1,std::allocator<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_1>,void ()(md::ls::FunctionConstants &,md::ls::IsNotMercator const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF520858;
}

void *std::__function::__func<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_1,std::allocator<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_1>,void ()(md::ls::FunctionConstants &,md::ls::IsNotMercator const&)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF520858;
  return result;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_1,std::allocator<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_1>,void ()(md::ls::FunctionConstants &,md::ls::IsNotMercator const&)>::~__func()
{
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::IsMercator const&)>::operator()(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 15) = 0;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::IsMercator const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF520810;
}

void *std::__function::__func<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::IsMercator const&)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF520810;
  return result;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorECEF::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMercator const&>,ecs2::Query<md::ls::FunctionConstants &,md::ls::IsNotMercator const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::IsMercator const&)>::~__func()
{
}

void *std::function<void ()(md::ls::UniqueRenderArrayID const&,md::ls::SharedUniqueID const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::CheckIfRenderableIsUnique::operator()(ecs2::Query<md::ls::UniqueRenderArrayID const&,md::ls::SharedUniqueID const&>)::$_0,std::allocator<md::ita::CheckIfRenderableIsUnique::operator()(ecs2::Query<md::ls::UniqueRenderArrayID const&,md::ls::SharedUniqueID const&>)::$_0>,void ()(md::ls::UniqueRenderArrayID const&,md::ls::SharedUniqueID const&)>::operator()(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a3 + 16)) {
    return;
  }
  uint64_t v5 = **(void **)(a1 + 8) + 40 * *a2 + 64;
  unint64_t v6 = *(void *)a3;
  uint64_t v7 = *(unsigned __int8 *)(a3 + 8);
  if (!std::__hash_table<md::UniqueRenderID,md::UniqueRenderIDHash,md::UniqueRenderIDKeyEqual,std::allocator<md::UniqueRenderID>>::find<md::UniqueRenderID>((void *)v5, *(void *)a3, *(unsigned char *)(a3 + 8)))
  {
    unint64_t v12 = ((v6 >> 34) + v6 + (HIDWORD(v6) << 6) - 0x61C8864680B583EBLL) ^ HIDWORD(v6);
    unint64_t v13 = (v7 + (v12 << 6) + (v12 >> 2) - 0x61C8864680B583EBLL) ^ v12;
    unint64_t v14 = *(void *)(v5 + 8);
    if (v14)
    {
      uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
      v15.i16[0] = vaddlv_u8(v15);
      if (v15.u32[0] > 1uLL)
      {
        uint64_t v3 = (v7 + (v12 << 6) + (v12 >> 2) - 0x61C8864680B583EBLL) ^ v12;
        if (v13 >= v14) {
          uint64_t v3 = v13 % v14;
        }
      }
      else
      {
        uint64_t v3 = v13 & (v14 - 1);
      }
      uint64_t v16 = *(uint64_t ****)(*(void *)v5 + 8 * v3);
      if (v16)
      {
        float v17 = *v16;
        if (v17)
        {
          if (v15.u32[0] < 2uLL)
          {
            while (1)
            {
              unint64_t v21 = v17[1];
              if (v21 == (uint64_t *)v13)
              {
                if (v17[2] == (uint64_t *)v6 && *((unsigned __int8 *)v17 + 24) == v7) {
                  return;
                }
              }
              else if (((unint64_t)v21 & (v14 - 1)) != v3)
              {
                goto LABEL_36;
              }
              float v17 = (uint64_t **)*v17;
              if (!v17) {
                goto LABEL_36;
              }
            }
          }
          do
          {
            unint64_t v19 = (unint64_t)v17[1];
            if (v19 == v13)
            {
              if (v17[2] == (uint64_t *)v6 && *((unsigned __int8 *)v17 + 24) == v7) {
                return;
              }
            }
            else
            {
              if (v19 >= v14) {
                v19 %= v14;
              }
              if (v19 != v3) {
                break;
              }
            }
            float v17 = (uint64_t **)*v17;
          }
          while (v17);
        }
      }
    }
LABEL_36:
    size_t v22 = (_DWORD *)(a3 + 9);
    int8x8_t v23 = (char *)operator new(0x20uLL);
    *(void *)int8x8_t v23 = 0;
    *((void *)v23 + 1) = v13;
    *((void *)v23 + 2) = v6;
    v23[24] = v7;
    *(_DWORD *)(v23 + 25) = *v22;
    *((_DWORD *)v23 + 7) = *(_DWORD *)((char *)v22 + 3);
    float v24 = (float)(unint64_t)(*(void *)(v5 + 24) + 1);
    float v25 = *(float *)(v5 + 32);
    if (!v14 || (float)(v25 * (float)v14) < v24)
    {
      BOOL v26 = 1;
      if (v14 >= 3) {
        BOOL v26 = (v14 & (v14 - 1)) != 0;
      }
      unint64_t v27 = v26 | (2 * v14);
      unint64_t v28 = vcvtps_u32_f32(v24 / v25);
      if (v27 <= v28) {
        size_t prime = v28;
      }
      else {
        size_t prime = v27;
      }
      if (prime == 1)
      {
        size_t prime = 2;
      }
      else if ((prime & (prime - 1)) != 0)
      {
        size_t prime = std::__next_prime(prime);
        unint64_t v14 = *(void *)(v5 + 8);
      }
      if (prime > v14) {
        goto LABEL_48;
      }
      if (prime < v14)
      {
        unint64_t v30 = vcvtps_u32_f32((float)*(unint64_t *)(v5 + 24) / *(float *)(v5 + 32));
        if (v14 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v14), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
        {
          unint64_t v30 = std::__next_prime(v30);
        }
        else
        {
          uint64_t v32 = 1 << -(char)__clz(v30 - 1);
          if (v30 >= 2) {
            unint64_t v30 = v32;
          }
        }
        if (prime <= v30) {
          size_t prime = v30;
        }
        if (prime < v14) {
LABEL_48:
        }
          std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v5, prime);
      }
      unint64_t v14 = *(void *)(v5 + 8);
      if ((v14 & (v14 - 1)) != 0)
      {
        if (v13 >= v14) {
          uint64_t v3 = v13 % v14;
        }
        else {
          uint64_t v3 = v13;
        }
      }
      else
      {
        uint64_t v3 = (v14 - 1) & v13;
      }
    }
    uint64_t v33 = *(void *)v5;
    uint64_t v34 = *(void **)(*(void *)v5 + 8 * v3);
    if (v34)
    {
      *(void *)int8x8_t v23 = *v34;
    }
    else
    {
      *(void *)int8x8_t v23 = *(void *)(v5 + 16);
      *(void *)(v5 + 16) = v23;
      *(void *)(v33 + 8 * v3) = v5 + 16;
      if (!*(void *)v23)
      {
LABEL_73:
        ++*(void *)(v5 + 24);
        return;
      }
      unint64_t v35 = *(void *)(*(void *)v23 + 8);
      if ((v14 & (v14 - 1)) != 0)
      {
        if (v35 >= v14) {
          v35 %= v14;
        }
      }
      else
      {
        v35 &= v14 - 1;
      }
      uint64_t v34 = (void *)(*(void *)v5 + 8 * v35);
    }
    *uint64_t v34 = v23;
    goto LABEL_73;
  }
  unint64_t v8 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  uint64_t v9 = HIDWORD(*v8);
  uint64_t v10 = *v8 << 32;
  v37[0] = &unk_1EF522820;
  v37[1] = v10;
  int v38 = v9;
  unint64_t v42 = v40;
  uint64_t v39 = v37;
  v40[0] = &unk_1EF522820;
  v40[1] = v10;
  int v41 = v9;
  int v43 = 0;
  ecs2::Runtime::queueCommand(v11, (uint64_t)v40);
  if (v43 != -1) {
    ((void (*)(char *, void *))off_1EF590C90[v43])(&v36, v40);
  }
  int v43 = -1;
  if (v39 == v37)
  {
    (*(void (**)(void *))(v37[0] + 32))(v37);
  }
  else if (v39)
  {
    (*(void (**)(void))(*v39 + 40))();
  }
}

void sub_1A2550A94(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<md::UniqueRenderID,md::UniqueRenderIDHash,md::UniqueRenderIDKeyEqual,std::allocator<md::UniqueRenderID>>::find<md::UniqueRenderID>(void *a1, unint64_t a2, unsigned __int8 a3)
{
  int8x8_t v3 = (int8x8_t)a1[1];
  if (!*(void *)&v3) {
    return 0;
  }
  unint64_t v4 = ((a2 >> 34) + a2 + (HIDWORD(a2) << 6) - 0x61C8864680B583EBLL) ^ HIDWORD(a2);
  unint64_t v5 = ((v4 << 6) + a3 + (v4 >> 2) - 0x61C8864680B583EBLL) ^ v4;
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v3);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v3) {
      unint64_t v7 = v5 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v3 - 1);
  }
  unint64_t v8 = *(uint64_t ****)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t result = *v8;
  if (*v8)
  {
    if (v6.u32[0] < 2uLL)
    {
      uint64_t v10 = *(void *)&v3 - 1;
      while (1)
      {
        unint64_t v14 = result[1];
        if (v14 == (uint64_t *)v5)
        {
          if (result[2] == (uint64_t *)a2 && *((unsigned __int8 *)result + 24) == a3) {
            return result;
          }
        }
        else if (((unint64_t)v14 & v10) != v7)
        {
          return 0;
        }
        uint64_t result = (uint64_t **)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v12 = (unint64_t)result[1];
      if (v12 == v5)
      {
        if (result[2] == (uint64_t *)a2 && *((unsigned __int8 *)result + 24) == a3) {
          return result;
        }
      }
      else
      {
        if (v12 >= *(void *)&v3) {
          v12 %= *(void *)&v3;
        }
        if (v12 != v7) {
          return 0;
        }
      }
      uint64_t result = (uint64_t **)*result;
    }
    while (result);
  }
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ShouldSkipRender>(gdc::Entity,md::ls::ShouldSkipRender &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 12);
  ShouldSkip = (void *)gdc::Registry::storage<md::ls::ShouldSkipRender>(a2);
  uint64_t v22 = v2;
  unint64_t v4 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(ShouldSkip + 4, (uint64_t)&v22);
  if (v5)
  {
    uint64_t v10 = (unsigned char *)ShouldSkip[11];
    unint64_t v9 = ShouldSkip[12];
    if ((unint64_t)v10 >= v9)
    {
      unint64_t v12 = (char *)ShouldSkip[10];
      uint64_t v13 = v10 - v12;
      uint64_t v14 = v10 - v12 + 1;
      if (v14 < 0) {
        goto LABEL_28;
      }
      unint64_t v15 = v9 - (void)v12;
      if (2 * v15 > v14) {
        uint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v14;
      }
      if (v16) {
        float v17 = (char *)operator new(v16);
      }
      else {
        float v17 = 0;
      }
      float v18 = &v17[v16];
      uint64_t v11 = (uint64_t)&v17[v13 + 1];
      unint64_t v19 = (char *)(v12 - v10);
      if (v12 == v10) {
        unint64_t v19 = 0;
      }
      ShouldSkip[10] = &v17[v13 + (void)v19];
      ShouldSkip[11] = v11;
      ShouldSkip[12] = v18;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v11 = (uint64_t)(v10 + 1);
    }
    ShouldSkip[11] = v11;
    uint64_t v6 = ShouldSkip[31];
  }
  else
  {
    uint64_t v6 = ShouldSkip[31];
    if (ShouldSkip[10] + (((uint64_t)v4 - ShouldSkip[7]) >> 3) != ShouldSkip[11])
    {
      unint64_t v7 = (void *)ShouldSkip[16];
      if (v7)
      {
        while (1)
        {
          float v24 = &v22;
          uint64_t v25 = 1;
          uint64_t v23 = v6;
          uint64_t v8 = v7[6];
          if (!v8) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v8 + 48))(v8, &v23, &v24);
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return;
          }
        }
LABEL_27:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_28:
        abort();
      }
      return;
    }
  }
  unint64_t v20 = (void *)ShouldSkip[22];
  if (v20)
  {
    while (1)
    {
      float v24 = &v22;
      uint64_t v25 = 1;
      uint64_t v23 = v6;
      uint64_t v21 = v20[6];
      if (!v21) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v21 + 48))(v21, &v23, &v24);
      unint64_t v20 = (void *)*v20;
      if (!v20) {
        return;
      }
    }
    goto LABEL_27;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ShouldSkipRender>(gdc::Entity,md::ls::ShouldSkipRender &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522820;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ShouldSkipRender>(gdc::Entity,md::ls::ShouldSkipRender &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF522820;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::ShouldSkipRender>(gdc::Entity,md::ls::ShouldSkipRender &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::CheckIfRenderableIsUnique::operator()(ecs2::Query<md::ls::UniqueRenderArrayID const&,md::ls::SharedUniqueID const&>)::$_0,std::allocator<md::ita::CheckIfRenderableIsUnique::operator()(ecs2::Query<md::ls::UniqueRenderArrayID const&,md::ls::SharedUniqueID const&>)::$_0>,void ()(md::ls::UniqueRenderArrayID const&,md::ls::SharedUniqueID const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF590C58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::CheckIfRenderableIsUnique::operator()(ecs2::Query<md::ls::UniqueRenderArrayID const&,md::ls::SharedUniqueID const&>)::$_0,std::allocator<md::ita::CheckIfRenderableIsUnique::operator()(ecs2::Query<md::ls::UniqueRenderArrayID const&,md::ls::SharedUniqueID const&>)::$_0>,void ()(md::ls::UniqueRenderArrayID const&,md::ls::SharedUniqueID const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF590C58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::CheckIfRenderableIsUnique::operator()(ecs2::Query<md::ls::UniqueRenderArrayID const&,md::ls::SharedUniqueID const&>)::$_0,std::allocator<md::ita::CheckIfRenderableIsUnique::operator()(ecs2::Query<md::ls::UniqueRenderArrayID const&,md::ls::SharedUniqueID const&>)::$_0>,void ()(md::ls::UniqueRenderArrayID const&,md::ls::SharedUniqueID const&)>::~__func()
{
}

void *std::function<void ()(md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__func<md::ita::PrepareFunctionConstantDescriptorRoutelineMask::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorRoutelineMask::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&)>::operator()(void *result, uint64_t a2, unint64_t *a3)
{
  unint64_t v4 = *(void **)result[1];
  unint64_t v5 = *a3;
  unint64_t v6 = *a3;
  uint64_t v7 = v4[269];
  BOOL v10 = 0;
  if (v6 < (v4[270] - v7) >> 3)
  {
    uint64_t v8 = *(void *)(v7 + 8 * v6);
    if (v8 && HIDWORD(v5) == HIDWORD(v8))
    {
      uint64_t v11 = (unsigned char *)(v4[272] + 24 * v8);
      if (v11 != (unsigned char *)v4[273] && v11 != 0)
      {
        __n128 result = std::__hash_table<std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>,std::hash<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,true>,std::__unordered_map_equal<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>,std::equal_to<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::CachedKey<md::ColorStyleCacheKey>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::CachedKey<md::ColorStyleCacheKey>> const&>,std::tuple<>>((uint64_t)(v4 + 256), v5, a3);
        ++result[3];
        if (*v11) {
          BOOL v10 = 1;
        }
      }
    }
  }
  *(unsigned char *)(a2 + 11) = v10;
  return result;
}

uint64_t std::__function::__func<md::ita::PrepareFunctionConstantDescriptorRoutelineMask::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorRoutelineMask::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF520C00;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ita::PrepareFunctionConstantDescriptorRoutelineMask::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorRoutelineMask::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF520C00;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorRoutelineMask::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorRoutelineMask::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&)>::~__func()
{
}

void *std::function<void ()(md::ls::FunctionConstants &,md::ls::ColorRampDataHandle const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::ita::PrepareFunctionConstantDescriptorBlendedWater::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::ColorRampDataHandle const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorBlendedWater::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::ColorRampDataHandle const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::ColorRampDataHandle const&)>::operator()(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t result = md::VKMRenderResourcesStore::getColorRampData(**(void **)(a1 + 8), *a3);
  if (result && *(unsigned char *)(result + 32) && *(void *)(result + 16))
  {
    if (*(void *)(result + 24)) {
      *(unsigned char *)(a2 + 6) = 1;
    }
  }
  return result;
}

uint64_t std::__function::__func<md::ita::PrepareFunctionConstantDescriptorBlendedWater::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::ColorRampDataHandle const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorBlendedWater::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::ColorRampDataHandle const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::ColorRampDataHandle const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF520BB8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ita::PrepareFunctionConstantDescriptorBlendedWater::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::ColorRampDataHandle const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorBlendedWater::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::ColorRampDataHandle const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::ColorRampDataHandle const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF520BB8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ita::PrepareFunctionConstantDescriptorBlendedWater::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::ColorRampDataHandle const&>)::$_0,std::allocator<md::ita::PrepareFunctionConstantDescriptorBlendedWater::operator()(ecs2::Query<md::ls::FunctionConstants &,md::ls::ColorRampDataHandle const&>)::$_0>,void ()(md::ls::FunctionConstants &,md::ls::ColorRampDataHandle const&)>::~__func()
{
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>(a2);
  unint64_t v4 = *(void *)(a1 + 8);
  gdc::ComponentStorageWrapper<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>::remove(v3, v4);
}

uint64_t std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_1EF526960;
  a2[1] = *(void *)(result + 8);
  return result;
}

void *std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF526960;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>(gdc::Entity,md::ls::TextureHandleForType<DaVinci::Gradient2Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  unint64_t v4 = (void *)gdc::Registry::storage<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  unint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        unint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        BOOL v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          unint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    *uint64_t v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      BOOL v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          uint64_t v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          BOOL v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  unint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      uint64_t v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      unint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>(gdc::Entity,md::ls::TextureHandleForType<DaVinci::Gradient2Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF523558;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>(gdc::Entity,md::ls::TextureHandleForType<DaVinci::Gradient2Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF523558;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<DaVinci::Gradient2Texture>>(gdc::Entity,md::ls::TextureHandleForType<DaVinci::Gradient2Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>(a2);
  unint64_t v4 = *(void *)(a1 + 8);
  gdc::ComponentStorageWrapper<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>::remove(v3, v4);
}

uint64_t std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_1EF526918;
  a2[1] = *(void *)(result + 8);
  return result;
}

void *std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF526918;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>(gdc::Entity,std::type_identity<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>(gdc::Entity,md::ls::TextureHandleForType<DaVinci::Gradient1Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  unint64_t v4 = (void *)gdc::Registry::storage<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  unint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        unint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        BOOL v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          unint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    *uint64_t v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      BOOL v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          uint64_t v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          BOOL v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  unint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      uint64_t v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      unint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>(gdc::Entity,md::ls::TextureHandleForType<DaVinci::Gradient1Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF523510;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>(gdc::Entity,md::ls::TextureHandleForType<DaVinci::Gradient1Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF523510;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::TextureHandleForType<DaVinci::Gradient1Texture>>(gdc::Entity,md::ls::TextureHandleForType<DaVinci::Gradient1Texture> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle2>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle2>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle2>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle2>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::GradientConstantDataHandle2>(a2);
  unint64_t v4 = *(void *)(a1 + 8);
  gdc::ComponentStorageWrapper<md::ls::GradientConstantDataHandle2>::remove(v3, v4);
}

uint64_t std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle2>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle2>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle2>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle2>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_1EF526A80;
  a2[1] = *(void *)(result + 8);
  return result;
}

void *std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle2>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle2>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle2>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle2>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF526A80;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle2>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle2>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle2>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle2>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GradientConstantDataHandle2>(gdc::Entity,md::ls::GradientConstantDataHandle2 &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  unint64_t v4 = (void *)gdc::Registry::storage<md::ls::GradientConstantDataHandle2>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  unint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        unint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        BOOL v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          unint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    *uint64_t v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      BOOL v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          uint64_t v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          BOOL v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  unint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      uint64_t v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      unint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GradientConstantDataHandle2>(gdc::Entity,md::ls::GradientConstantDataHandle2 &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF524A28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GradientConstantDataHandle2>(gdc::Entity,md::ls::GradientConstantDataHandle2 &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF524A28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GradientConstantDataHandle2>(gdc::Entity,md::ls::GradientConstantDataHandle2 &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle1>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle1>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle1>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle1>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::GradientConstantDataHandle1>(a2);
  unint64_t v4 = *(void *)(a1 + 8);
  gdc::ComponentStorageWrapper<md::ls::GradientConstantDataHandle1>::remove(v3, v4);
}

uint64_t std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle1>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle1>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle1>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle1>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_1EF526A38;
  a2[1] = *(void *)(result + 8);
  return result;
}

void *std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle1>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle1>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle1>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle1>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF526A38;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle1>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle1>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::RemoveComponent::RemoveComponent<md::ls::GradientConstantDataHandle1>(gdc::Entity,std::type_identity<md::ls::GradientConstantDataHandle1>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GradientConstantDataHandle1>(gdc::Entity,md::ls::GradientConstantDataHandle1 &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  unint64_t v4 = (void *)gdc::Registry::storage<md::ls::GradientConstantDataHandle1>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  unint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        unint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        BOOL v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          unint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    *uint64_t v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      BOOL v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          uint64_t v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          BOOL v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  unint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      uint64_t v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      unint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GradientConstantDataHandle1>(gdc::Entity,md::ls::GradientConstantDataHandle1 &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5249E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GradientConstantDataHandle1>(gdc::Entity,md::ls::GradientConstantDataHandle1 &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5249E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::GradientConstantDataHandle1>(gdc::Entity,md::ls::GradientConstantDataHandle1 &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::StyleColorConstantDataHandle>(gdc::Entity,md::ls::StyleColorConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  unint64_t v4 = (void *)gdc::Registry::storage<md::ls::StyleColorConstantDataHandle>(a2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v32 = v3;
  unint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    uint64_t v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 3;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v20 = operator new(8 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v5;
      uint64_t v14 = v21 + 1;
      if (v13 == v15)
      {
        unint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = v13 - v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_40;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        BOOL v26 = v13 - 16;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v29 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          unint64_t v15 = (char *)v4[10];
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(void *)uint64_t v13 = v5;
      uint64_t v14 = v13 + 8;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    uint64_t v8 = (void *)((char *)v6 + v4[10] - v4[7]);
    *uint64_t v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (void *)v4[11])
    {
      BOOL v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          uint64_t v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          BOOL v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_35:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_36:
        abort();
      }
      return;
    }
  }
  unint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      uint64_t v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      unint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_35;
  }
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::StyleColorConstantDataHandle>(gdc::Entity,md::ls::StyleColorConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF525688;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::StyleColorConstantDataHandle>(gdc::Entity,md::ls::StyleColorConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF525688;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::StyleColorConstantDataHandle>(gdc::Entity,md::ls::StyleColorConstantDataHandle &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

void std::__list_imp<std::pair<unsigned char,PolylineWithElevation>>::clear(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        unint64_t v6 = (std::__shared_weak_count *)v3[6];
        if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
          char v7 = (std::__shared_weak_count *)v3[4];
          if (v7)
          {
LABEL_8:
            if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
              std::__shared_weak_count::__release_weak(v7);
            }
          }
        }
        else
        {
          char v7 = (std::__shared_weak_count *)v3[4];
          if (v7) {
            goto LABEL_8;
          }
        }
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void sub_1A255371C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, md::DaVinciTrafficBatchKey *a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,char a21)
{
  operator delete(v21);
  md::DaVinciTrafficBatchKey::~DaVinciTrafficBatchKey((md::DaVinciTrafficBatchKey *)&a21);
  md::DaVinciTrafficBatchKey::~DaVinciTrafficBatchKey((md::DaVinciTrafficBatchKey *)&a12);
  md::DaVinciTrafficBatchKey::~DaVinciTrafficBatchKey(a11);
  os_unfair_lock_unlock(v22);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t geo::dpSimplify<geo::Mercator2<double>>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, double a8)
{
  uint64_t v8 = a3 + 1;
  if (a3 + 1 < a4)
  {
    uint64_t v15 = result;
    double v16 = a8 * a8;
    do
    {
      double v17 = *(double *)(a2 + 8 * a3);
      float64x2_t v18 = *(float64x2_t *)(v15 + 16 * a3);
      float64x2_t v19 = vsubq_f64(*(float64x2_t *)(v15 + 16 * a4), v18);
      double v20 = *(double *)(a2 + 8 * a4) - v17;
      float64x2_t v21 = vmulq_f64(v19, v19);
      double v22 = v21.f64[0] + v20 * v20 + v21.f64[1];
      uint64_t v23 = 0;
      if (v22 <= 1.0e-15)
      {
        double v32 = 0.0;
        do
        {
          float64x2_t v33 = vsubq_f64(*(float64x2_t *)(v15 + 16 * v8), v18);
          double v34 = vaddvq_f64(vmulq_f64(v33, v33)) + (*(double *)(a2 + 8 * v8) - v17) * (*(double *)(a2 + 8 * v8) - v17);
          double v31 = fmax(v34, v32);
          if (v34 > v32) {
            uint64_t v23 = v8;
          }
          ++v8;
          double v32 = v31;
        }
        while (a4 != v8);
      }
      else
      {
        double v24 = 0.0;
        double v25 = 1.0 / v22;
        do
        {
          double v26 = *(double *)(a2 + 8 * v8);
          float64x2_t v27 = *(float64x2_t *)(v15 + 16 * v8);
          double v28 = fmin(fmax((vaddvq_f64(vmulq_f64(vsubq_f64(v27, v18), v19)) + (v26 - v17) * v20) * v25, 0.0), 1.0);
          float64x2_t v29 = vsubq_f64(v27, vmlaq_n_f64(v18, v19, v28));
          double v30 = vaddvq_f64(vmulq_f64(v29, v29)) + (v26 - (v17 + v28 * v20)) * (v26 - (v17 + v28 * v20));
          double v31 = fmax(v30, v24);
          if (v30 > v24) {
            uint64_t v23 = v8;
          }
          ++v8;
          double v24 = v31;
        }
        while (a4 != v8);
      }
      if (v31 <= v16) {
        break;
      }
      __n128 result = geo::dpSimplify<geo::Mercator2<double>>(v15, a2, a8);
      uint64_t v35 = (void *)(v15 + 16 * v23);
      uint64_t v36 = *a7;
      uint64_t v37 = (void *)(a5 + 16 * *a7);
      *uint64_t v37 = *v35;
      v37[1] = v35[1];
      uint64_t v38 = *(void *)(a2 + 8 * v23);
      *a7 = v36 + 1;
      *(void *)(a6 + 8 * v36) = v38;
      uint64_t v8 = v23 + 1;
      a3 = v23;
    }
    while (v23 + 1 < a4);
  }
  return result;
}

uint64_t geo::dpSimplify<geo::Mercator2<double>>(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, void *a5, double a6)
{
  uint64_t v6 = a2 + 1;
  if (a2 + 1 < a3)
  {
    uint64_t v11 = result;
    double v12 = a6 * a6;
    __asm { FMOV            V0.2D, #1.0 }
    float64x2_t v33 = _Q0;
    do
    {
      float64x2_t v18 = *(float64x2_t *)(v11 + 16 * a2);
      float64x2_t v19 = vsubq_f64(*(float64x2_t *)(v11 + 16 * a3), v18);
      float64x2_t v20 = vmulq_f64(v19, v19);
      uint64_t v21 = 0;
      if (vaddvq_f64(v20) <= 1.0e-15)
      {
        double v28 = 0.0;
        do
        {
          float64x2_t v29 = vsubq_f64(*(float64x2_t *)(v11 + 16 * v6), v18);
          v29.f64[0] = vaddvq_f64(vmulq_f64(v29, v29));
          double v27 = fmax(v29.f64[0], v28);
          if (v29.f64[0] > v28) {
            uint64_t v21 = v6;
          }
          ++v6;
          double v28 = v27;
        }
        while (a3 != v6);
      }
      else
      {
        float64x2_t v22 = vdivq_f64(v33, vaddq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v20, 1), v20));
        double v23 = 0.0;
        do
        {
          float64x2_t v24 = *(float64x2_t *)(v11 + 16 * v6);
          float64x2_t v25 = vmulq_f64(vsubq_f64(v24, v18), v19);
          float64x2_t v26 = vsubq_f64(v24, vmlaq_n_f64(v18, v19, fmin(fmax(vmulq_f64(vaddq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v25, 1), v25), v22).f64[0], 0.0), 1.0)));
          v25.f64[0] = vaddvq_f64(vmulq_f64(v26, v26));
          double v27 = fmax(v25.f64[0], v23);
          if (v25.f64[0] > v23) {
            uint64_t v21 = v6;
          }
          ++v6;
          double v23 = v27;
        }
        while (a3 != v6);
      }
      if (v27 <= v12) {
        break;
      }
      __n128 result = geo::dpSimplify<geo::Mercator2<double>>(v11, a6);
      double v30 = (void *)(v11 + 16 * v21);
      uint64_t v31 = (*a5)++;
      double v32 = (void *)(a4 + 16 * v31);
      void *v32 = *v30;
      v32[1] = v30[1];
      uint64_t v6 = v21 + 1;
      a2 = v21;
    }
    while (v21 + 1 < a3);
  }
  return result;
}

void std::__shared_ptr_emplace<std::vector<double>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<std::vector<double>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B348;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<std::vector<double>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B348;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<geo::Mercator2<double>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<std::vector<geo::Mercator2<double>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B230;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<std::vector<geo::Mercator2<double>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B230;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A2554208(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A25543E4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A255450C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A2554640(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A2554734(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A2554820(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A2554968(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A2554A84(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A2554BD4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A2555238(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  os_unfair_lock_unlock(v12);
  if (v11) {
    operator delete(v11);
  }

  _Unwind_Resume(a1);
}

void sub_1A2555364(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  BOOL v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VKVectorOverlayPolylineGroup;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A255551C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v3);
  operator delete(v5);

  _Unwind_Resume(a1);
}

void sub_1A2555784(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A25558A0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A25559BC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A2555B0C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A2555DBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VKVectorOverlayCircle;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A2556B44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, unint64_t a10)
{
  unint64_t shared_weak_owners = v13[3].__shared_weak_owners_;
  if (shared_weak_owners <= a10) {
    unint64_t shared_weak_owners = a10;
  }
  v13[3].__shared_owners_ = 0;
  v13[3].__shared_weak_owners_ = shared_weak_owners;
  if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  unint64_t v16 = v12[3].__shared_weak_owners_;
  if (v16 <= 0xC) {
    unint64_t v16 = 12;
  }
  v12[3].__shared_owners_ = 0;
  v12[3].__shared_weak_owners_ = v16;
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  uint64_t v17 = v11[7].__shared_weak_owners_;
  v11[7].__shared_weak_owners_ = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  uint64_t shared_owners = v11[7].__shared_owners_;
  v11[7].__shared_owners_ = 0;
  if (shared_owners) {
    (*(void (**)(uint64_t))(*(void *)shared_owners + 8))(shared_owners);
  }
  float64x2_t v19 = v11[7].__vftable;
  v11[7].__vftable = 0;
  if (v19) {
    (*((void (**)(std::__shared_weak_count_vtbl *))v19->~__shared_weak_count + 1))(v19);
  }
  uint64_t v20 = v11[6].__shared_weak_owners_;
  v11[6].__shared_weak_owners_ = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  uint64_t v21 = v11[6].__shared_owners_;
  v11[6].__shared_owners_ = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  float64x2_t v22 = v11[6].__vftable;
  v11[6].__vftable = 0;
  if (v22) {
    (*((void (**)(std::__shared_weak_count_vtbl *))v22->~__shared_weak_count + 1))(v22);
  }
  uint64_t v23 = v11[5].__shared_weak_owners_;
  v11[5].__shared_weak_owners_ = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  uint64_t v24 = v11[5].__shared_owners_;
  v11[5].__shared_owners_ = 0;
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
  }
  float64x2_t v25 = (std::__shared_weak_count *)v11[5].__vftable;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
  float64x2_t v26 = (std::__shared_weak_count *)v11[4].__shared_owners_;
  if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  uint64_t v27 = v11[3].__shared_weak_owners_;
  v11[3].__shared_weak_owners_ = 0;
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
  }
  double v28 = (std::__shared_weak_count *)v11[2].__shared_weak_owners_;
  if (v28)
  {
    if (!atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  std::__shared_weak_count::~__shared_weak_count(v11);
  operator delete(v29);

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::CircleOverlayRenderable>::__on_zero_shared(void *a1)
{
  uint64_t v2 = a1[23];
  a1[23] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[22];
  a1[22] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[21];
  a1[21] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = a1[20];
  a1[20] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = a1[19];
  a1[19] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = a1[18];
  a1[18] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = a1[17];
  a1[17] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = a1[16];
  a1[16] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  BOOL v10 = (std::__shared_weak_count *)a1[15];
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    uint64_t v11 = (std::__shared_weak_count *)a1[13];
    if (!v11) {
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v11 = (std::__shared_weak_count *)a1[13];
    if (!v11) {
      goto LABEL_23;
    }
  }
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
LABEL_23:
  uint64_t v12 = a1[11];
  a1[11] = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  uint64_t v13 = (std::__shared_weak_count *)a1[8];
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
}

void std::__shared_ptr_emplace<md::CircleOverlayRenderable>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581750;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::CircleOverlayRenderable>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581750;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<md::CircleOverlayRenderable::Style>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581718;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::CircleOverlayRenderable::Style>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581718;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A2558224(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_unfair_lock_t lock, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,char a21)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a21);
  os_unfair_lock_unlock(v21);
  _Unwind_Resume(a1);
}

void geo::Cache<unsigned char,std::shared_ptr<geo::Polygon2<double>>,std::hash<unsigned char>,geo::LRUPolicy>::insert(uint64_t a1, unsigned char *a2, uint64_t a3, std::__shared_weak_count *a4)
{
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (void **)(a1 + 8);
  unint64_t v8 = *a2;
  int8x8_t v9 = *(int8x8_t *)(a1 + 16);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8(v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v11 = *a2;
      if (*(void *)&v9 <= v8) {
        unint64_t v11 = v8 % *(void *)&v9;
      }
    }
    else
    {
      unint64_t v11 = (v9.i32[0] - 1) & v8;
    }
    uint64_t v12 = (uint64_t ***)*((void *)*v7 + v11);
    if (v12)
    {
      uint64_t v13 = *v12;
      if (*v12)
      {
        if (v10.u32[0] < 2uLL)
        {
          uint64_t v14 = *(void *)&v9 - 1;
          while (1)
          {
            unint64_t v16 = v13[1];
            if (v16 == (uint64_t *)v8)
            {
              if (*((unsigned __int8 *)v13 + 16) == v8) {
                goto LABEL_24;
              }
            }
            else if (((unint64_t)v16 & v14) != v11)
            {
              goto LABEL_30;
            }
            uint64_t v13 = (uint64_t **)*v13;
            if (!v13) {
              goto LABEL_30;
            }
          }
        }
        do
        {
          unint64_t v15 = (unint64_t)v13[1];
          if (v15 == v8)
          {
            if (*((unsigned __int8 *)v13 + 16) == v8)
            {
LABEL_24:
              uint64_t v17 = v13[3];
              uint64_t v18 = *v17;
              *(void *)(v18 + 8) = v17[1];
              *(void *)v17[1] = v18;
              --*(void *)(a1 + 64);
              float64x2_t v19 = (std::__shared_weak_count *)v17[4];
              if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
                std::__shared_weak_count::__release_weak(v19);
              }
              operator delete(v17);
              std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)__p, (void *)(a1 + 8), v13);
              if (__p[0]) {
                operator delete(__p[0]);
              }
              LOBYTE(v8) = *a2;
              break;
            }
          }
          else
          {
            if (v15 >= *(void *)&v9) {
              v15 %= *(void *)&v9;
            }
            if (v15 != v11) {
              break;
            }
          }
          uint64_t v13 = (uint64_t **)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_30:
  uint64_t v20 = operator new(0x28uLL);
  uint64_t v21 = v20;
  float64x2_t v22 = (uint64_t **)(a1 + 48);
  v20[16] = v8;
  *((void *)v20 + 3) = a3;
  *((void *)v20 + 4) = a4;
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v23 = *(void **)(a1 + 56);
  *(void *)uint64_t v20 = v22;
  *((void *)v20 + 1) = v23;
  *uint64_t v23 = v20;
  uint64_t v24 = *(void *)(a1 + 64) + 1;
  *(void *)(a1 + 56) = v20;
  *(void *)(a1 + 64) = v24;
  unint64_t v25 = *a2;
  unint64_t v26 = *(void *)(a1 + 16);
  if (v26)
  {
    uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v26);
    v27.i16[0] = vaddlv_u8(v27);
    if (v27.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v26 <= v25) {
        unint64_t v4 = v25 % v26;
      }
    }
    else
    {
      unint64_t v4 = (v26 - 1) & v25;
    }
    double v28 = (uint64_t ***)*((void *)*v7 + v4);
    if (v28)
    {
      float64x2_t v29 = *v28;
      if (v29)
      {
        if (v27.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v31 = v29[1];
            if (v31 == (uint64_t *)v25)
            {
              if (*((unsigned __int8 *)v29 + 16) == v25) {
                goto LABEL_113;
              }
            }
            else if (((unint64_t)v31 & (v26 - 1)) != v4)
            {
              goto LABEL_53;
            }
            float64x2_t v29 = (uint64_t **)*v29;
            if (!v29) {
              goto LABEL_53;
            }
          }
        }
        do
        {
          unint64_t v30 = (unint64_t)v29[1];
          if (v30 == v25)
          {
            if (*((unsigned __int8 *)v29 + 16) == v25) {
              goto LABEL_113;
            }
          }
          else
          {
            if (v30 >= v26) {
              v30 %= v26;
            }
            if (v30 != v4) {
              break;
            }
          }
          float64x2_t v29 = (uint64_t **)*v29;
        }
        while (v29);
      }
    }
  }
LABEL_53:
  double v32 = operator new(0x20uLL);
  void *v32 = 0;
  v32[1] = v25;
  *((unsigned char *)v32 + 16) = v25;
  v32[3] = v21;
  float v33 = (float)(unint64_t)(*(void *)(a1 + 32) + 1);
  float v34 = *(float *)(a1 + 40);
  if (v26 && (float)(v34 * (float)v26) >= v33)
  {
    unint64_t v25 = v4;
    goto LABEL_103;
  }
  BOOL v35 = 1;
  if (v26 >= 3) {
    BOOL v35 = (v26 & (v26 - 1)) != 0;
  }
  unint64_t v36 = v35 | (2 * v26);
  unint64_t v37 = vcvtps_u32_f32(v33 / v34);
  if (v36 <= v37) {
    size_t prime = v37;
  }
  else {
    size_t prime = v36;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v26 = *(void *)(a1 + 16);
  }
  if (prime > v26)
  {
LABEL_66:
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v39 = operator new(8 * prime);
    unint64_t v40 = *v7;
    *uint64_t v7 = v39;
    if (v40) {
      operator delete(v40);
    }
    uint64_t v41 = 0;
    *(void *)(a1 + 16) = prime;
    do
      *((void *)*v7 + v41++) = 0;
    while (prime != v41);
    uint64_t v43 = a1 + 24;
    unint64_t v42 = *(void **)(a1 + 24);
    if (!v42) {
      goto LABEL_90;
    }
    size_t v44 = v42[1];
    size_t v45 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v46 = v44 & v45;
      *((void *)*v7 + v46) = v43;
      for (uint64_t i = (void *)*v42; *v42; uint64_t i = (void *)*v42)
      {
        size_t v48 = i[1] & v45;
        if (v48 == v46)
        {
          unint64_t v42 = i;
        }
        else if (*((void *)*v7 + v48))
        {
          *unint64_t v42 = *i;
          uint64_t v49 = 8 * v48;
          void *i = **(void **)((char *)*v7 + v49);
          **(void **)((char *)*v7 + v49) = i;
        }
        else
        {
          *((void *)*v7 + v48) = v42;
          unint64_t v42 = i;
          size_t v46 = v48;
        }
      }
LABEL_90:
      unint64_t v26 = prime;
      goto LABEL_91;
    }
    if (v44 >= prime) {
      v44 %= prime;
    }
    *((void *)*v7 + v44) = v43;
    unint64_t v53 = (void *)*v42;
    if (!*v42) {
      goto LABEL_90;
    }
    while (1)
    {
      size_t v55 = v53[1];
      if (v55 >= prime) {
        v55 %= prime;
      }
      if (v55 != v44)
      {
        if (!*((void *)*v7 + v55))
        {
          *((void *)*v7 + v55) = v42;
          goto LABEL_95;
        }
        *unint64_t v42 = *v53;
        uint64_t v54 = 8 * v55;
        *unint64_t v53 = **(void **)((char *)*v7 + v54);
        **(void **)((char *)*v7 + v54) = v53;
        unint64_t v53 = v42;
      }
      size_t v55 = v44;
LABEL_95:
      unint64_t v42 = v53;
      unint64_t v53 = (void *)*v53;
      size_t v44 = v55;
      if (!v53) {
        goto LABEL_90;
      }
    }
  }
  if (prime >= v26) {
    goto LABEL_91;
  }
  unint64_t v50 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 32) / *(float *)(a1 + 40));
  if (v26 < 3 || (uint8x8_t v51 = (uint8x8_t)vcnt_s8((int8x8_t)v26), v51.i16[0] = vaddlv_u8(v51), v51.u32[0] > 1uLL))
  {
    unint64_t v50 = std::__next_prime(v50);
  }
  else
  {
    uint64_t v52 = 1 << -(char)__clz(v50 - 1);
    if (v50 >= 2) {
      unint64_t v50 = v52;
    }
  }
  if (prime <= v50) {
    size_t prime = v50;
  }
  if (prime < v26)
  {
    if (!prime)
    {
      uint64_t v73 = *v7;
      *uint64_t v7 = 0;
      if (v73) {
        operator delete(v73);
      }
      unint64_t v26 = 0;
      *(void *)(a1 + 16) = 0;
      goto LABEL_91;
    }
    goto LABEL_66;
  }
  unint64_t v26 = *(void *)(a1 + 16);
LABEL_91:
  if ((v26 & (v26 - 1)) != 0)
  {
    if (v26 <= v25) {
      v25 %= v26;
    }
  }
  else
  {
    unint64_t v25 = (v26 - 1) & v25;
  }
LABEL_103:
  float64x2_t v56 = *v7;
  uint64_t v57 = (void *)*((void *)*v7 + v25);
  if (v57)
  {
    void *v32 = *v57;
LABEL_111:
    *uint64_t v57 = v32;
    goto LABEL_112;
  }
  void *v32 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v32;
  v56[v25] = a1 + 24;
  if (*v32)
  {
    unint64_t v58 = *(void *)(*v32 + 8);
    if ((v26 & (v26 - 1)) != 0)
    {
      if (v58 >= v26) {
        v58 %= v26;
      }
    }
    else
    {
      v58 &= v26 - 1;
    }
    uint64_t v57 = (char *)*v7 + 8 * v58;
    goto LABEL_111;
  }
LABEL_112:
  ++*(void *)(a1 + 32);
LABEL_113:
  if (a4 && !atomic_fetch_add(&a4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a4->__on_zero_shared)(a4);
    std::__shared_weak_count::__release_weak(a4);
  }
  for (unint64_t j = *(void *)(a1 + 64); j > *(void *)a1; unint64_t j = *(void *)(a1 + 64))
  {
    unint64_t v60 = *v22;
    unint64_t v61 = *((unsigned __int8 *)*v22 + 16);
    float64x2_t v62 = (std::__shared_weak_count *)(*v22)[4];
    if (v62)
    {
      atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v60 = *(uint64_t **)(a1 + 48);
      uint64_t v63 = (std::__shared_weak_count *)v60[4];
      unint64_t j = *(void *)(a1 + 64);
    }
    else
    {
      uint64_t v63 = 0;
    }
    uint64_t v64 = *v60;
    *(void *)(v64 + 8) = v60[1];
    *(void *)v60[1] = v64;
    *(void *)(a1 + 64) = j - 1;
    if (v63 && !atomic_fetch_add(&v63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
    operator delete(v60);
    int8x8_t v65 = *(int8x8_t *)(a1 + 16);
    if (v65)
    {
      uint8x8_t v66 = (uint8x8_t)vcnt_s8(v65);
      v66.i16[0] = vaddlv_u8(v66);
      if (v66.u32[0] > 1uLL)
      {
        unint64_t v67 = v61;
        if (*(void *)&v65 <= v61) {
          unint64_t v67 = v61 % *(void *)&v65;
        }
      }
      else
      {
        unint64_t v67 = (v65.i32[0] - 1) & v61;
      }
      float32x4_t v68 = (uint64_t ***)*((void *)*v7 + v67);
      if (v68)
      {
        unint64_t v69 = *v68;
        if (*v68)
        {
          if (v66.u32[0] < 2uLL)
          {
            uint64_t v70 = *(void *)&v65 - 1;
            while (1)
            {
              float v72 = v69[1];
              if (v72 == (uint64_t *)v61)
              {
                if (*((unsigned __int8 *)v69 + 16) == v61) {
                  goto LABEL_146;
                }
              }
              else if (((unint64_t)v72 & v70) != v67)
              {
                goto LABEL_148;
              }
              unint64_t v69 = (uint64_t **)*v69;
              if (!v69) {
                goto LABEL_148;
              }
            }
          }
          do
          {
            unint64_t v71 = (unint64_t)v69[1];
            if (v71 == v61)
            {
              if (*((unsigned __int8 *)v69 + 16) == v61)
              {
LABEL_146:
                std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)__p, (void *)(a1 + 8), v69);
                if (__p[0]) {
                  operator delete(__p[0]);
                }
                break;
              }
            }
            else
            {
              if (v71 >= *(void *)&v65) {
                v71 %= *(void *)&v65;
              }
              if (v71 != v67) {
                break;
              }
            }
            unint64_t v69 = (uint64_t **)*v69;
          }
          while (v69);
        }
      }
    }
LABEL_148:
    if (v62)
    {
      if (!atomic_fetch_add(&v62->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
        std::__shared_weak_count::__release_weak(v62);
      }
    }
  }
}

void sub_1A2558B10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  operator delete(v10);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

__n128 std::__introsort<std::_ClassicAlgPolicy,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::{lambda(BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&)#1} &,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo*,false>(char *a1, unint64_t a2, uint64_t **a3, uint64_t a4, char a5, __n128 result)
{
BOOL geo::Intersect::SHSegmentComparator<double>::operator()(float64x2_t *a1, float64x2_t *a2)
{
  if (*(void *)&a1->f64[0] == *(void *)&a2->f64[0] && *(void *)&a1->f64[1] == *(void *)&a2->f64[1])
  {
    float64x2_t v3 = *a1;
    float64x2_t v5 = vaddq_f64(a1[1], *a1);
    float64x2_t v4 = *a2;
    float64x2_t v6 = vaddq_f64(a2[1], *a2);
    if (*(void *)&v5.f64[0] == *(void *)&v6.f64[0] && *(void *)&v5.f64[1] == *(void *)&v6.f64[1]) {
      return 0;
    }
  }
  else
  {
    v3.f64[0] = a1->f64[0];
    v4.f64[0] = a2->f64[0];
  }
  if (v3.f64[0] > v4.f64[0])
  {
    double v8 = a2[1].f64[0];
    double v9 = a2[1].f64[1];
    double v10 = a1->f64[1] - a2->f64[1];
    double v11 = v3.f64[0] - v4.f64[0];
    double v12 = -(v9 * v11 - v10 * v8);
    BOOL v13 = v12 < 0.0;
    if (v12 == 0.0) {
      return -((v11 + a1[1].f64[0]) * v9 - (v10 + a1[1].f64[1]) * v8) <= 0.0;
    }
    return v13;
  }
  double v16 = a1->f64[1];
  double v15 = a1[1].f64[0];
  double v17 = a1[1].f64[1];
  double v18 = a2->f64[1];
  double v19 = v4.f64[0] - v3.f64[0];
  double v20 = -(v17 * v19 - (v18 - v16) * v15);
  BOOL v21 = v20 <= 0.0;
  if (v20 == 0.0)
  {
    if (v3.f64[0] == v15 + v3.f64[0]) {
      return v16 < v18;
    }
    BOOL v21 = -((v19 + a2[1].f64[0]) * v17 - (v18 - v16 + a2[1].f64[1]) * v15) <= 0.0;
  }
  return !v21;
}

__n128 std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::{lambda(BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&)#1} &,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo*>(void *a1, uint64_t *a2, uint64_t *a3, uint64_t **a4, __n128 result)
{
  int v5 = *((unsigned __int8 *)a2 + 16);
  uint64_t v6 = *a2;
  if (v5 == *((unsigned __int8 *)a1 + 16))
  {
    uint64_t v7 = *a1;
  }
  else
  {
    uint64_t v7 = *a1;
    if (v6 == a1[1] && a2[1] == v7)
    {
      if (!*((unsigned char *)a2 + 16)) {
        goto LABEL_10;
      }
LABEL_16:
      uint64_t v16 = *a3;
      if (*((unsigned __int8 *)a3 + 16) != v5 && v16 == a2[1] && a3[1] == v6)
      {
        if (!*((unsigned char *)a3 + 16)) {
          goto LABEL_25;
        }
      }
      else
      {
        uint64_t v17 = **a4;
        double v18 = (double *)(v17 + 16 * v16);
        double v19 = (double *)(v17 + 16 * v6);
        if (*v18 >= *v19 && (*v18 != *v19 || v18[1] >= v19[1]))
        {
LABEL_25:
          __n128 result = *(__n128 *)a1;
          uint64_t v22 = a1[2];
          char v23 = *((unsigned char *)a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *((unsigned char *)a1 + 16) = v23;
          *((unsigned char *)a2 + 16) = v22;
          *(__n128 *)a2 = result;
          int v24 = v22;
          uint64_t v25 = *a3;
          if (*((unsigned __int8 *)a3 + 16) == v24)
          {
            uint64_t v26 = *a2;
          }
          else
          {
            uint64_t v26 = *a2;
            if (v25 == a2[1] && a3[1] == v26)
            {
              if (!*((unsigned char *)a3 + 16)) {
                return result;
              }
LABEL_39:
              __n128 result = *(__n128 *)a2;
              uint64_t v20 = a2[2];
              char v34 = *((unsigned char *)a3 + 16);
              *(_OWORD *)a2 = *(_OWORD *)a3;
              *((unsigned char *)a2 + 16) = v34;
              goto LABEL_40;
            }
          }
          uint64_t v31 = **a4;
          uint64_t v32 = (unint64_t *)(v31 + 16 * v25);
          float v33 = (double *)(v31 + 16 * v26);
          result.n128_u64[0] = *v32;
          if (*(double *)v32 >= *v33)
          {
            if (*(double *)v32 != *v33) {
              return result;
            }
            result.n128_u64[0] = v32[1];
            if (result.n128_f64[0] >= v33[1]) {
              return result;
            }
          }
          goto LABEL_39;
        }
      }
      __n128 result = *(__n128 *)a1;
      uint64_t v20 = a1[2];
      char v21 = *((unsigned char *)a3 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *((unsigned char *)a1 + 16) = v21;
LABEL_40:
      *((unsigned char *)a3 + 16) = v20;
      *(__n128 *)a3 = result;
      return result;
    }
  }
  uint64_t v9 = **a4;
  double v10 = (unint64_t *)(v9 + 16 * v6);
  double v11 = (double *)(v9 + 16 * v7);
  result.n128_u64[0] = *v10;
  if (*(double *)v10 < *v11) {
    goto LABEL_16;
  }
  if (*(double *)v10 == *v11)
  {
    result.n128_u64[0] = v10[1];
    if (result.n128_f64[0] < v11[1]) {
      goto LABEL_16;
    }
  }
LABEL_10:
  uint64_t v12 = *a3;
  if (*((unsigned __int8 *)a3 + 16) != v5 && v12 == a2[1] && a3[1] == v6)
  {
    if (!*((unsigned char *)a3 + 16)) {
      return result;
    }
  }
  else
  {
    uint64_t v13 = **a4;
    uint64_t v14 = (unint64_t *)(v13 + 16 * v12);
    double v15 = (double *)(v13 + 16 * v6);
    result.n128_u64[0] = *v14;
    if (*(double *)v14 >= *v15)
    {
      if (*(double *)v14 != *v15) {
        return result;
      }
      result.n128_u64[0] = v14[1];
      if (result.n128_f64[0] >= v15[1]) {
        return result;
      }
    }
  }
  __n128 result = *(__n128 *)a2;
  uint64_t v27 = a2[2];
  char v28 = *((unsigned char *)a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *((unsigned char *)a2 + 16) = v28;
  *((unsigned char *)a3 + 16) = v27;
  *(__n128 *)a3 = result;
  uint64_t v29 = *a2;
  if (*((unsigned __int8 *)a2 + 16) == *((unsigned __int8 *)a1 + 16))
  {
    uint64_t v30 = *a1;
    goto LABEL_45;
  }
  uint64_t v30 = *a1;
  if (v29 != a1[1] || a2[1] != v30)
  {
LABEL_45:
    uint64_t v35 = **a4;
    unint64_t v36 = (unint64_t *)(v35 + 16 * v29);
    unint64_t v37 = (double *)(v35 + 16 * v30);
    result.n128_u64[0] = *v36;
    if (*(double *)v36 < *v37) {
      goto LABEL_48;
    }
    if (*(double *)v36 == *v37)
    {
      result.n128_u64[0] = v36[1];
      if (result.n128_f64[0] < v37[1]) {
        goto LABEL_48;
      }
    }
    return result;
  }
  if (*((unsigned char *)a2 + 16))
  {
LABEL_48:
    __n128 result = *(__n128 *)a1;
    uint64_t v38 = a1[2];
    char v39 = *((unsigned char *)a2 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *((unsigned char *)a1 + 16) = v39;
    *((unsigned char *)a2 + 16) = v38;
    *(__n128 *)a2 = result;
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::{lambda(BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&)#1} &,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo*>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t **a5, __n128 a6)
{
  result.n128_u64[0] = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::{lambda(BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&)#1} &,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo*>(a1, (uint64_t *)a2, a3, a5, a6).n128_u64[0];
  uint64_t v12 = *a4;
  if (*((unsigned __int8 *)a4 + 16) == *((unsigned __int8 *)a3 + 16))
  {
    uint64_t v13 = *a3;
  }
  else
  {
    uint64_t v13 = *a3;
    if (v12 == a3[1] && a4[1] == v13)
    {
      if (!*((unsigned char *)a4 + 16)) {
        return result;
      }
LABEL_12:
      __n128 result = *(__n128 *)a3;
      uint64_t v18 = a3[2];
      char v19 = *((unsigned char *)a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *((unsigned char *)a3 + 16) = v19;
      *((unsigned char *)a4 + 16) = v18;
      *(__n128 *)a4 = result;
      uint64_t v20 = *a3;
      if (*((unsigned __int8 *)a3 + 16) == *(unsigned __int8 *)(a2 + 16))
      {
        uint64_t v21 = *(void *)a2;
      }
      else
      {
        uint64_t v21 = *(void *)a2;
        if (v20 == *(void *)(a2 + 8) && a3[1] == v21)
        {
          if (!*((unsigned char *)a3 + 16)) {
            return result;
          }
          goto LABEL_21;
        }
      }
      uint64_t v22 = **a5;
      char v23 = (unint64_t *)(v22 + 16 * v20);
      int v24 = (double *)(v22 + 16 * v21);
      result.n128_u64[0] = *v23;
      if (*(double *)v23 >= *v24)
      {
        if (*(double *)v23 != *v24) {
          return result;
        }
        result.n128_u64[0] = v23[1];
        if (result.n128_f64[0] >= v24[1]) {
          return result;
        }
      }
LABEL_21:
      __n128 result = *(__n128 *)a2;
      uint64_t v25 = *(void *)(a2 + 16);
      char v26 = *((unsigned char *)a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(unsigned char *)(a2 + 16) = v26;
      *((unsigned char *)a3 + 16) = v25;
      *(__n128 *)a3 = result;
      uint64_t v27 = *(void *)a2;
      if (*(unsigned __int8 *)(a2 + 16) == *((unsigned __int8 *)a1 + 16))
      {
        uint64_t v28 = *a1;
      }
      else
      {
        uint64_t v28 = *a1;
        if (v27 == a1[1] && *(void *)(a2 + 8) == v28)
        {
          if (!*(unsigned char *)(a2 + 16)) {
            return result;
          }
          goto LABEL_30;
        }
      }
      uint64_t v29 = **a5;
      uint64_t v30 = (unint64_t *)(v29 + 16 * v27);
      uint64_t v31 = (double *)(v29 + 16 * v28);
      result.n128_u64[0] = *v30;
      if (*(double *)v30 >= *v31)
      {
        if (*(double *)v30 != *v31) {
          return result;
        }
        result.n128_u64[0] = v30[1];
        if (result.n128_f64[0] >= v31[1]) {
          return result;
        }
      }
LABEL_30:
      __n128 result = *(__n128 *)a1;
      uint64_t v32 = a1[2];
      char v33 = *(unsigned char *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *((unsigned char *)a1 + 16) = v33;
      *(unsigned char *)(a2 + 16) = v32;
      *(__n128 *)a2 = result;
      return result;
    }
  }
  uint64_t v15 = **a5;
  uint64_t v16 = (unint64_t *)(v15 + 16 * v12);
  uint64_t v17 = (double *)(v15 + 16 * v13);
  result.n128_u64[0] = *v16;
  if (*(double *)v16 < *v17) {
    goto LABEL_12;
  }
  if (*(double *)v16 == *v17)
  {
    result.n128_u64[0] = v16[1];
    if (result.n128_f64[0] < v17[1]) {
      goto LABEL_12;
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::{lambda(BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&)#1} &,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t **a6, __n128 a7)
{
  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::{lambda(BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&)#1} &,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo*>((uint64_t *)a1, a2, (uint64_t *)a3, a4, a6, a7).n128_u64[0];
  uint64_t v14 = *a5;
  if (*((unsigned __int8 *)a5 + 16) == *((unsigned __int8 *)a4 + 16))
  {
    uint64_t v15 = *a4;
  }
  else
  {
    uint64_t v15 = *a4;
    if (v14 == a4[1] && a5[1] == v15)
    {
      if (!*((unsigned char *)a5 + 16)) {
        return result;
      }
LABEL_12:
      __n128 result = *(__n128 *)a4;
      uint64_t v20 = a4[2];
      char v21 = *((unsigned char *)a5 + 16);
      *(_OWORD *)a4 = *(_OWORD *)a5;
      *((unsigned char *)a4 + 16) = v21;
      *((unsigned char *)a5 + 16) = v20;
      *(__n128 *)a5 = result;
      uint64_t v22 = *a4;
      if (*((unsigned __int8 *)a4 + 16) == *(unsigned __int8 *)(a3 + 16))
      {
        uint64_t v23 = *(void *)a3;
      }
      else
      {
        uint64_t v23 = *(void *)a3;
        if (v22 == *(void *)(a3 + 8) && a4[1] == v23)
        {
          if (!*((unsigned char *)a4 + 16)) {
            return result;
          }
          goto LABEL_21;
        }
      }
      uint64_t v24 = **a6;
      uint64_t v25 = (unint64_t *)(v24 + 16 * v22);
      char v26 = (double *)(v24 + 16 * v23);
      result.n128_u64[0] = *v25;
      if (*(double *)v25 >= *v26)
      {
        if (*(double *)v25 != *v26) {
          return result;
        }
        result.n128_u64[0] = v25[1];
        if (result.n128_f64[0] >= v26[1]) {
          return result;
        }
      }
LABEL_21:
      __n128 result = *(__n128 *)a3;
      uint64_t v27 = *(void *)(a3 + 16);
      char v28 = *((unsigned char *)a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(unsigned char *)(a3 + 16) = v28;
      *((unsigned char *)a4 + 16) = v27;
      *(__n128 *)a4 = result;
      uint64_t v29 = *(void *)a3;
      if (*(unsigned __int8 *)(a3 + 16) == *(unsigned __int8 *)(a2 + 16))
      {
        uint64_t v30 = *(void *)a2;
      }
      else
      {
        uint64_t v30 = *(void *)a2;
        if (v29 == *(void *)(a2 + 8) && *(void *)(a3 + 8) == v30)
        {
          if (!*(unsigned char *)(a3 + 16)) {
            return result;
          }
          goto LABEL_30;
        }
      }
      uint64_t v31 = **a6;
      uint64_t v32 = (unint64_t *)(v31 + 16 * v29);
      char v33 = (double *)(v31 + 16 * v30);
      result.n128_u64[0] = *v32;
      if (*(double *)v32 >= *v33)
      {
        if (*(double *)v32 != *v33) {
          return result;
        }
        result.n128_u64[0] = v32[1];
        if (result.n128_f64[0] >= v33[1]) {
          return result;
        }
      }
LABEL_30:
      __n128 result = *(__n128 *)a2;
      uint64_t v34 = *(void *)(a2 + 16);
      char v35 = *(unsigned char *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(unsigned char *)(a2 + 16) = v35;
      *(unsigned char *)(a3 + 16) = v34;
      *(__n128 *)a3 = result;
      uint64_t v36 = *(void *)a2;
      if (*(unsigned __int8 *)(a2 + 16) == *(unsigned __int8 *)(a1 + 16))
      {
        uint64_t v37 = *(void *)a1;
      }
      else
      {
        uint64_t v37 = *(void *)a1;
        if (v36 == *(void *)(a1 + 8) && *(void *)(a2 + 8) == v37)
        {
          if (!*(unsigned char *)(a2 + 16)) {
            return result;
          }
          goto LABEL_39;
        }
      }
      uint64_t v38 = **a6;
      char v39 = (unint64_t *)(v38 + 16 * v36);
      uint64_t v40 = (double *)(v38 + 16 * v37);
      result.n128_u64[0] = *v39;
      if (*(double *)v39 >= *v40)
      {
        if (*(double *)v39 != *v40) {
          return result;
        }
        result.n128_u64[0] = v39[1];
        if (result.n128_f64[0] >= v40[1]) {
          return result;
        }
      }
LABEL_39:
      __n128 result = *(__n128 *)a1;
      uint64_t v41 = *(void *)(a1 + 16);
      char v42 = *(unsigned char *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(unsigned char *)(a1 + 16) = v42;
      *(unsigned char *)(a2 + 16) = v41;
      *(__n128 *)a2 = result;
      return result;
    }
  }
  uint64_t v17 = **a6;
  uint64_t v18 = (unint64_t *)(v17 + 16 * v14);
  char v19 = (double *)(v17 + 16 * v15);
  result.n128_u64[0] = *v18;
  if (*(double *)v18 < *v19) {
    goto LABEL_12;
  }
  if (*(double *)v18 == *v19)
  {
    result.n128_u64[0] = v18[1];
    if (result.n128_f64[0] < v19[1]) {
      goto LABEL_12;
    }
  }
  return result;
}

__n128 std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::{lambda(BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&)#1} &,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo*>(uint64_t a1, uint64_t a2, uint64_t **a3, __n128 result)
{
  switch(0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3))
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v7 = (_OWORD *)(a2 - 24);
      uint64_t v8 = *(void *)(a2 - 24);
      if (*(unsigned __int8 *)(a2 - 8) == *(unsigned __int8 *)(a1 + 16))
      {
        uint64_t v9 = *(void *)a1;
        goto LABEL_57;
      }
      uint64_t v9 = *(void *)a1;
      if (v8 != *(void *)(a1 + 8) || *(void *)(a2 - 16) != v9)
      {
LABEL_57:
        uint64_t v38 = **a3;
        char v39 = (unint64_t *)(v38 + 16 * v8);
        uint64_t v40 = (double *)(v38 + 16 * v9);
        result.n128_u64[0] = *v39;
        if (*(double *)v39 < *v40) {
          goto LABEL_63;
        }
        if (*(double *)v39 == *v40)
        {
          result.n128_u64[0] = v39[1];
          if (result.n128_f64[0] < v40[1]) {
            goto LABEL_63;
          }
        }
        return result;
      }
      if (*(unsigned char *)(a2 - 8))
      {
LABEL_63:
        __n128 result = *(__n128 *)a1;
        uint64_t v41 = *(void *)(a1 + 16);
        char v42 = *(unsigned char *)(a2 - 8);
        *(_OWORD *)a1 = *v7;
        *(unsigned char *)(a1 + 16) = v42;
        *(unsigned char *)(a2 - 8) = v41;
        *uint64_t v7 = result;
        return result;
      }
      return result;
    case 3uLL:
      result.n128_u64[0] = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::{lambda(BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&)#1} &,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo*>((void *)a1, (uint64_t *)(a1 + 24), (uint64_t *)(a2 - 24), a3, result).n128_u64[0];
      return result;
    case 4uLL:
      result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::{lambda(BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&)#1} &,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo*>((uint64_t *)a1, a1 + 24, (uint64_t *)(a1 + 48), (uint64_t *)(a2 - 24), a3, result).n128_u64[0];
      return result;
    case 5uLL:
      result.n128_u64[0] = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::{lambda(BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&)#1} &,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo*>(a1, a1 + 24, a1 + 48, (uint64_t *)(a1 + 72), (uint64_t *)(a2 - 24), a3, result).n128_u64[0];
      return result;
    default:
      uint64_t v10 = a1 + 48;
      result.n128_u64[0] = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::{lambda(BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo const&)#1} &,BOOL geo::Intersect::isSelfIntersecting<double>(std::vector<gm::Matrix<double,2,1>> const&,BOOL)::EventInfo*>((void *)a1, (uint64_t *)(a1 + 24), (uint64_t *)(a1 + 48), a3, result).n128_u64[0];
      uint64_t v11 = a1 + 72;
      if (a1 + 72 == a2) {
        return result;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      while (2)
      {
        int v15 = *(unsigned __int8 *)(v11 + 16);
        uint64_t v16 = *(void *)v11;
        if (v15 == *(unsigned __int8 *)(v10 + 16))
        {
          uint64_t v17 = *(void *)v10;
        }
        else
        {
          uint64_t v17 = *(void *)v10;
          if (v16 == *(void *)(v10 + 8) && *(void *)(v11 + 8) == v17)
          {
            if (!*(unsigned char *)(v11 + 16)) {
              goto LABEL_8;
            }
            __n128 result = *(__n128 *)v10;
            *(_OWORD *)uint64_t v11 = *(_OWORD *)v10;
            *(unsigned char *)(v11 + 16) = *(unsigned char *)(v10 + 16);
            uint64_t v14 = a1;
            if (v10 == a1) {
              goto LABEL_7;
            }
            goto LABEL_36;
          }
        }
        uint64_t v19 = **a3;
        uint64_t v20 = (unint64_t *)(v19 + 16 * v16);
        char v21 = (double *)(v19 + 16 * v17);
        result.n128_u64[0] = *v20;
        if (*(double *)v20 >= *v21)
        {
          if (*(double *)v20 != *v21) {
            goto LABEL_8;
          }
          result.n128_u64[0] = v20[1];
          if (result.n128_f64[0] >= v21[1]) {
            goto LABEL_8;
          }
        }
        uint64_t v17 = *(void *)(v11 + 8);
        __n128 result = *(__n128 *)v10;
        *(_OWORD *)uint64_t v11 = *(_OWORD *)v10;
        *(unsigned char *)(v11 + 16) = *(unsigned char *)(v10 + 16);
        if (v10 == a1)
        {
LABEL_6:
          uint64_t v14 = a1;
          goto LABEL_7;
        }
        if (!v15)
        {
          uint64_t v22 = v12;
          while (1)
          {
            uint64_t v23 = (__n128 *)(a1 + v22);
            uint64_t v24 = (__n128 *)(a1 + v22 + 24);
            if (*(unsigned char *)(a1 + v22 + 40))
            {
              unint64_t v25 = v24->n128_u64[0];
              if (v16 == v23[2].n128_u64[0] && v17 == v25) {
                goto LABEL_48;
              }
            }
            else
            {
              unint64_t v25 = v24->n128_u64[0];
            }
            uint64_t v27 = **a3;
            char v28 = (unint64_t *)(v27 + 16 * v16);
            uint64_t v29 = (double *)(v27 + 16 * v25);
            result.n128_u64[0] = *v28;
            if (*(double *)v28 >= *v29)
            {
              if (*(double *)v28 != *v29) {
                goto LABEL_47;
              }
              result.n128_u64[0] = v28[1];
              if (result.n128_f64[0] >= v29[1]) {
                goto LABEL_47;
              }
            }
            v10 -= 24;
            __n128 result = *v24;
            v23[3] = *v24;
            v23[4].n128_u8[0] = *(unsigned char *)(a1 + v22 + 40);
            v22 -= 24;
            if (v22 == -48) {
              goto LABEL_6;
            }
          }
        }
LABEL_36:
        uint64_t v22 = v12;
        while (2)
        {
          uint64_t v30 = (__n128 *)(a1 + v22);
          uint64_t v31 = (__n128 *)(a1 + v22 + 24);
          if (v15 == *(unsigned __int8 *)(a1 + v22 + 40))
          {
            unint64_t v32 = v31->n128_u64[0];
          }
          else
          {
            unint64_t v32 = v31->n128_u64[0];
            if (v16 == v30[2].n128_u64[0] && v17 == v32)
            {
LABEL_37:
              v10 -= 24;
              __n128 result = *v31;
              v30[3] = *v31;
              v30[4].n128_u8[0] = *(unsigned char *)(a1 + v22 + 40);
              v22 -= 24;
              if (v22 == -48) {
                goto LABEL_6;
              }
              continue;
            }
          }
          break;
        }
        uint64_t v34 = **a3;
        char v35 = (unint64_t *)(v34 + 16 * v16);
        uint64_t v36 = (double *)(v34 + 16 * v32);
        result.n128_u64[0] = *v35;
        if (*(double *)v35 < *v36) {
          goto LABEL_37;
        }
        if (*(double *)v35 == *v36)
        {
          result.n128_u64[0] = v35[1];
          if (result.n128_f64[0] >= v36[1])
          {
LABEL_47:
            uint64_t v14 = v10;
            goto LABEL_7;
          }
          goto LABEL_37;
        }
LABEL_48:
        uint64_t v14 = a1 + v22 + 48;
LABEL_7:
        *(void *)uint64_t v14 = v16;
        *(void *)(v14 + 8) = v17;
        *(unsigned char *)(v14 + 16) = v15;
        if (++v13 != 8)
        {
LABEL_8:
          uint64_t v10 = v11;
          v12 += 24;
          v11 += 24;
          if (v11 == a2) {
            return result;
          }
          continue;
        }
        return result;
      }
  }
}

void std::__shared_ptr_emplace<geo::Polygon2<double>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<geo::Polygon2<double>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582F98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<geo::Polygon2<double>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582F98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A255AF28(_Unwind_Exception *a1)
{
  float64x2_t v4 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v4;
    operator delete(v4);
  }
  MEMORY[0x1A6239270](v2, 0x20C40960023A9);

  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<geo::Polygon2<double> *,std::shared_ptr<geo::Polygon2<double>>::__shared_ptr_default_delete<geo::Polygon2<double>,geo::Polygon2<double>>,std::allocator<geo::Polygon2<double>>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    uint64_t v2 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + 8) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<geo::Polygon2<double> *,std::shared_ptr<geo::Polygon2<double>>::__shared_ptr_default_delete<geo::Polygon2<double>,geo::Polygon2<double>>,std::allocator<geo::Polygon2<double>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void sub_1A255B1D8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A255B304(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A255B478(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A255B594(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A255B6B0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A255B7E4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A255B8D8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A255BA24(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A255BCFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VKVectorOverlayPolygonGroup;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A255BEE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A255BFF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::Logic<md::ARWorldIntersectorLogic,md::ARWorldIntersectorContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  float64x2_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    int v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      int v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void *md::ARWorldIntersectorLogic::runAfterLayout(uint64_t a1)
{
  __n128 result = (void *)gdc::Registry::storage<arComponents::DidIntersectRaycast>(*(int8x8_t **)(a1 + 120));
  uint64_t v2 = result;
  if (result[29] && (float64x2_t v3 = (void *)result[28]) != 0)
  {
    uint64_t v4 = result[31];
    uint64_t v5 = result[7];
    uint64_t v6 = (result[8] - v5) >> 3;
    while (1)
    {
      v9[0] = v5;
      v9[1] = v6;
      uint64_t v8 = v4;
      uint64_t v7 = v3[6];
      if (!v7) {
        break;
      }
      __n128 result = (void *)(*(uint64_t (**)(uint64_t, uint64_t *, void *))(*(void *)v7 + 48))(v7, &v8, v9);
      float64x2_t v3 = (void *)*v3;
      if (!v3) {
        goto LABEL_6;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    return (void *)md::ARWorldIntersectorLogic::runBeforeLayout();
  }
  else
  {
LABEL_6:
    v2[8] = v2[7];
    v2[11] = v2[10];
  }
  return result;
}

void md::ARWorldIntersectorLogic::runBeforeLayout(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  if (a4[3])
  {
    uint64_t v6 = (void *)a4[2];
    if (v6)
    {
      do
      {
        uint64_t v7 = (void *)*v6;
        operator delete(v6);
        uint64_t v6 = v7;
      }
      while (v7);
    }
    a4[2] = 0;
    uint64_t v8 = a4[1];
    if (v8)
    {
      for (uint64_t i = 0; i != v8; ++i)
        *(void *)(*a4 + 8 * i) = 0;
    }
    a4[3] = 0;
  }
  uint64_t v511 = +[VKDebugSettings sharedSettings];
  uint64_t v525 = *a3;
  uint64_t v10 = a3[2];
  v518 = (uint64_t *)a3[1];
  uint64_t v11 = gdc::Registry::storage<SceneComponents::LayerDataDidEnterView<(md::MapDataType)60>>(*(int8x8_t **)(a1 + 120));
  uint64_t v12 = gdc::Registry::storage<SceneComponents::LayerDataDidExitView<(md::MapDataType)60>>(*(int8x8_t **)(a1 + 120));
  uint64_t v13 = *(int8x8_t **)(a1 + 120);
  uint64_t v14 = gdc::Registry::storage<arComponents::Boundary>(v13);
  uint64_t v15 = gdc::Registry::storage<arComponents::WorldTransform>(v13);
  uint64_t v16 = gdc::Registry::storage<arComponents::UseForOcclusionTest>(v13);
  uint64_t v17 = gdc::Registry::storage<arComponents::AddToWorldIntersectorPending>(v13);
  if (!*(void *)(a1 + 168) || *(unsigned char *)(a1 + 184)) {
    goto LABEL_20;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v14 + 88) - *(void *)(v14 + 80)) >> 3);
  uint64_t v19 = *(void *)(v17 + 80);
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v15 + 88) - *(void *)(v15 + 80)) >> 4) < v18) {
    unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v15 + 88) - *(void *)(v15 + 80)) >> 4);
  }
  if (*(void *)(v16 + 88) - *(void *)(v16 + 80) < v18) {
    unint64_t v18 = *(void *)(v16 + 88) - *(void *)(v16 + 80);
  }
  if (*(void *)(v17 + 88) - v19 < v18) {
    unint64_t v18 = *(void *)(v17 + 88) - v19;
  }
  if (v18
    || *(void *)(v12 + 88) != *(void *)(v12 + 80)
    || *(void *)(v11 + 88) != *(void *)(v11 + 80)
    || *(unsigned char *)(v10 + 2))
  {
LABEL_20:
    uint64_t v20 = *(int8x8_t **)(a1 + 120);
    char v21 = (void *)gdc::Registry::storage<arComponents::Boundary>(v20);
    uint64_t v22 = (void *)gdc::Registry::storage<arComponents::WorldTransform>(v20);
    uint64_t v23 = gdc::Registry::storage<arComponents::UseForOcclusionTest>(v20);
    uint64_t v24 = (void *)v23;
    *(_OWORD *)__p_8 = 0uLL;
    *(double *)&std::string __p = 0.0;
    unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v21[11] - v21[10]) >> 3);
    uint64_t v26 = *(void *)(v23 + 80);
    if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v22[11] - v22[10]) >> 4) < v25) {
      unint64_t v25 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v22[11] - v22[10]) >> 4);
    }
    if (*(void *)(v23 + 88) - v26 >= v25) {
      unint64_t v27 = v25;
    }
    else {
      unint64_t v27 = *(void *)(v23 + 88) - v26;
    }
    if (v27)
    {
      if (v27 >= 0x555555555555556) {
        abort();
      }
      *(double *)&std::string __p = COERCE_DOUBLE(operator new(48 * v27));
      __p_8[0] = __p;
      __p_8[1] = &__p[6 * v27];
    }
    uint64_t v29 = (unint64_t *)v21[7];
    char v28 = (uint64_t *)v21[8];
    if (v22[8] - v22[7] >= (unint64_t)((char *)v28 - (char *)v29)) {
      uint64_t v30 = v21 + 4;
    }
    else {
      uint64_t v30 = v22 + 4;
    }
    if (v24[8] - v24[7] >= v30[4] - v30[3]) {
      uint64_t v31 = v30;
    }
    else {
      uint64_t v31 = v24 + 4;
    }
    if (v21 + 4 == v31)
    {
      double v534 = COERCE_DOUBLE(&__p);
      if (v29 != (unint64_t *)v28)
      {
        int v66 = (float32x2_t *)v21[10];
        do
        {
          unint64_t v343 = *((unsigned int *)v29 + 1);
          unint64_t v344 = v343 >> 7;
          uint64_t v345 = v22[4];
          unint64_t v346 = (v22[5] - v345) >> 3;
          if (v343 >> 7 < v346)
          {
            uint64_t v347 = *(void *)(v345 + 8 * v344);
            if (v347)
            {
              unint64_t v348 = *(unsigned __int16 *)(v347 + 2 * (v343 & 0x7F));
              uint64_t v350 = v22[7];
              uint64_t v349 = v22[8];
              unint64_t v351 = (v349 - v350) >> 3;
              if (v351 > v348)
              {
                uint64_t v352 = v350 + 8 * v348;
                _ZF = v352 != v349 && *(_DWORD *)(v352 + 4) == v343;
                if (_ZF)
                {
                  uint64_t v354 = v24[4];
                  if (v344 < (v24[5] - v354) >> 3)
                  {
                    uint64_t v355 = *(void *)(v354 + 8 * v344);
                    if (v355)
                    {
                      unint64_t v356 = *(unsigned __int16 *)(v355 + 2 * (v343 & 0x7F));
                      uint64_t v358 = v24[7];
                      uint64_t v357 = v24[8];
                      if (v356 < (v357 - v358) >> 3)
                      {
                        uint64_t v359 = v358 + 8 * v356;
                        if (v359 != v357 && *(_DWORD *)(v359 + 4) == v343)
                        {
                          unint64_t v361 = *v29;
                          unint64_t v362 = *v29 >> 39;
                          if (v362 < v346
                            && (uint64_t v363 = *(void *)(v345 + 8 * v362)) != 0
                            && (unint64_t v364 = *(unsigned __int16 *)(v363 + 2 * (HIDWORD(v361) & 0x7F)), v351 > v364)
                            && ((unint64_t v365 = HIDWORD(v361), v366 = v350 + 8 * v364, v366 != v349)
                              ? (BOOL v367 = *(_DWORD *)(v366 + 4) == v365)
                              : (BOOL v367 = 0),
                                v367))
                          {
                            uint64_t v342 = (long long *)(v22[10] + 80 * v364);
                          }
                          else
                          {
                            uint64_t v342 = (long long *)v22[11];
                          }
                          md::ARWorldIntersectorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::ResolvedDependencies const&,md::ARWorldIntersectorContext &)::$_0::operator()((int64x2_t ***)&v534, v66, v342);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          v66 += 3;
          ++v29;
        }
        while (v29 != (unint64_t *)v28);
      }
    }
    if (v22 + 4 == v31)
    {
      double v534 = COERCE_DOUBLE(&__p);
      uint64_t v67 = (unint64_t *)v22[7];
      float32x4_t v68 = (uint64_t *)v22[8];
      if (v67 != (unint64_t *)v68)
      {
        uint64_t v69 = (long long *)v22[10];
        do
        {
          unint64_t v369 = *((unsigned int *)v67 + 1);
          unint64_t v370 = v369 >> 7;
          uint64_t v371 = v21[4];
          unint64_t v372 = (v21[5] - v371) >> 3;
          if (v369 >> 7 < v372)
          {
            uint64_t v373 = *(void *)(v371 + 8 * v370);
            if (v373)
            {
              unint64_t v374 = *(unsigned __int16 *)(v373 + 2 * (v369 & 0x7F));
              uint64_t v376 = v21[7];
              uint64_t v375 = v21[8];
              unint64_t v377 = (v375 - v376) >> 3;
              if (v377 > v374)
              {
                uint64_t v378 = v376 + 8 * v374;
                if (v378 != v375 && *(_DWORD *)(v378 + 4) == v369)
                {
                  uint64_t v380 = v24[4];
                  if (v370 < (v24[5] - v380) >> 3)
                  {
                    uint64_t v381 = *(void *)(v380 + 8 * v370);
                    if (v381)
                    {
                      unint64_t v382 = *(unsigned __int16 *)(v381 + 2 * (v369 & 0x7F));
                      uint64_t v384 = v24[7];
                      uint64_t v383 = v24[8];
                      if (v382 < (v383 - v384) >> 3)
                      {
                        uint64_t v385 = v384 + 8 * v382;
                        if (v385 != v383 && *(_DWORD *)(v385 + 4) == v369)
                        {
                          unint64_t v387 = *v67;
                          unint64_t v388 = *v67 >> 39;
                          if (v388 < v372
                            && (uint64_t v389 = *(void *)(v371 + 8 * v388)) != 0
                            && (unint64_t v390 = *(unsigned __int16 *)(v389 + 2 * (HIDWORD(v387) & 0x7F)), v377 > v390)
                            && ((unint64_t v391 = HIDWORD(v387), v392 = v376 + 8 * v390, v392 != v375)
                              ? (BOOL v393 = *(_DWORD *)(v392 + 4) == v391)
                              : (BOOL v393 = 0),
                                v393))
                          {
                            int8x16_t v368 = (float32x2_t *)(v21[10] + 24 * v390);
                          }
                          else
                          {
                            int8x16_t v368 = (float32x2_t *)v21[11];
                          }
                          md::ARWorldIntersectorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::ResolvedDependencies const&,md::ARWorldIntersectorContext &)::$_0::operator()((int64x2_t ***)&v534, v368, v69);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          v69 += 5;
          ++v67;
        }
        while (v67 != (unint64_t *)v68);
      }
    }
    if (v24 + 4 != v31
      || (double v534 = COERCE_DOUBLE(&__p),
          uint64_t v70 = (unint64_t *)v24[7],
          unint64_t v71 = (uint64_t *)v24[8],
          v70 == (unint64_t *)v71))
    {
LABEL_37:
      unint64_t v32 = (void *)gdc::Registry::storage<arComponents::AddToWorldIntersectorPending>(*(int8x8_t **)(a1 + 120));
      char v33 = v32;
      if (!v32[29] || (uint64_t v34 = (void *)v32[28]) == 0)
      {
LABEL_42:
        v33[8] = v33[7];
        v33[11] = v33[10];
        char v39 = (void *)gdc::Registry::storage<SceneComponents::LayerDataInView<(md::MapDataType)60>>(*(int8x8_t **)(a1 + 120));
        double v535 = 0.0;
        double v536 = 0.0;
        double v534 = COERCE_DOUBLE(&v535);
        uint64_t v40 = v39[7];
        uint64_t v41 = v39[8];
        if (v40 == v41) {
LABEL_94:
        }
          operator new();
        char v42 = (void *)v39[10];
        while (1)
        {
          uint64_t v43 = (void *)*v42;
          if ((void *)*v42 != v42 + 1) {
            break;
          }
LABEL_44:
          v42 += 3;
          v40 += 8;
          if (v40 == v41) {
            goto LABEL_94;
          }
        }
LABEL_48:
        double v44 = v535;
        unint64_t v45 = v43[4];
        size_t v46 = &v535;
        uint64_t v47 = &v535;
        if (v535 != 0.0)
        {
          do
          {
            while (1)
            {
              uint64_t v47 = *(double **)&v44;
              unint64_t v48 = *(void *)(*(void *)&v44 + 32);
              if (v45 >= v48) {
                break;
              }
              double v44 = *v47;
              size_t v46 = v47;
              if (!*(void *)v47) {
                goto LABEL_55;
              }
            }
            if (v48 >= v45) {
              goto LABEL_88;
            }
            double v44 = v47[1];
          }
          while (v44 != 0.0);
          size_t v46 = v47 + 1;
        }
LABEL_55:
        uint64_t v49 = operator new(0x30uLL);
        v49[4] = v45;
        uint64_t v50 = v43[5];
        v49[5] = v50;
        if (v50) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v50 + 8), 1uLL, memory_order_relaxed);
        }
        *uint64_t v49 = 0;
        v49[1] = 0;
        v49[2] = v47;
        *(void *)size_t v46 = v49;
        if (**(void **)&v534)
        {
          double v534 = **(double **)&v534;
          uint64_t v49 = *(void **)v46;
        }
        double v51 = v535;
        _ZF = v49 == *(void **)&v535;
        *((unsigned char *)v49 + 24) = v49 == *(void **)&v535;
        if (_ZF) {
          goto LABEL_87;
        }
        while (1)
        {
          uint64_t v52 = v49[2];
          if (*(unsigned char *)(v52 + 24)) {
            goto LABEL_87;
          }
          unint64_t v53 = *(unsigned char **)(v52 + 16);
          uint64_t v54 = *(void *)v53;
          if (*(void *)v53 == v52)
          {
            uint64_t v57 = *((void *)v53 + 1);
            if (!v57 || (v58 = *(unsigned __int8 *)(v57 + 24), __n128 v55 = (unsigned char *)(v57 + 24), v58))
            {
              if (*(void **)v52 == v49)
              {
                uint64_t v59 = (uint64_t *)v49[2];
              }
              else
              {
                uint64_t v59 = *(uint64_t **)(v52 + 8);
                uint64_t v60 = *v59;
                *(void *)(v52 + 8) = *v59;
                if (v60)
                {
                  *(void *)(v60 + 16) = v52;
                  unint64_t v53 = *(unsigned char **)(v52 + 16);
                }
                v59[2] = (uint64_t)v53;
                *(void *)(*(void *)(v52 + 16) + 8 * (**(void **)(v52 + 16) != v52)) = v59;
                uint64_t *v59 = v52;
                *(void *)(v52 + 16) = v59;
                unint64_t v53 = (unsigned char *)v59[2];
                uint64_t v52 = *(void *)v53;
              }
              *((unsigned char *)v59 + 24) = 1;
              v53[24] = 0;
              uint64_t v63 = *(void *)(v52 + 8);
              *(void *)unint64_t v53 = v63;
              if (v63) {
                *(void *)(v63 + 16) = v53;
              }
              *(void *)(v52 + 16) = *((void *)v53 + 2);
              *(void *)(*((void *)v53 + 2) + 8 * (**((void **)v53 + 2) != (void)v53)) = v52;
              *(void *)(v52 + 8) = v53;
LABEL_86:
              *((void *)v53 + 2) = v52;
LABEL_87:
              ++*(void *)&v536;
LABEL_88:
              BOOL v64 = (void *)v43[1];
              if (v64)
              {
                do
                {
                  uint64_t v65 = v64;
                  BOOL v64 = (void *)*v64;
                }
                while (v64);
              }
              else
              {
                do
                {
                  uint64_t v65 = (void *)v43[2];
                  _ZF = *v65 == (void)v43;
                  uint64_t v43 = v65;
                }
                while (!_ZF);
              }
              uint64_t v43 = v65;
              if (v65 == v42 + 1) {
                goto LABEL_44;
              }
              goto LABEL_48;
            }
          }
          else if (!v54 || (v56 = *(unsigned __int8 *)(v54 + 24), __n128 v55 = (unsigned char *)(v54 + 24), v56))
          {
            if (*(void **)v52 == v49)
            {
              uint64_t v61 = v49[1];
              *(void *)uint64_t v52 = v61;
              if (v61)
              {
                *(void *)(v61 + 16) = v52;
                unint64_t v53 = *(unsigned char **)(v52 + 16);
              }
              v49[2] = v53;
              *(void *)(*(void *)(v52 + 16) + 8 * (**(void **)(v52 + 16) != v52)) = v49;
              v49[1] = v52;
              *(void *)(v52 + 16) = v49;
              unint64_t v53 = (unsigned char *)v49[2];
            }
            else
            {
              uint64_t v49 = (void *)v49[2];
            }
            *((unsigned char *)v49 + 24) = 1;
            v53[24] = 0;
            uint64_t v52 = *((void *)v53 + 1);
            float64x2_t v62 = *(void **)v52;
            *((void *)v53 + 1) = *(void *)v52;
            if (v62) {
              v62[2] = v53;
            }
            *(void *)(v52 + 16) = *((void *)v53 + 2);
            *(void *)(*((void *)v53 + 2) + 8 * (**((void **)v53 + 2) != (void)v53)) = v52;
            *(void *)uint64_t v52 = v53;
            goto LABEL_86;
          }
          *(unsigned char *)(v52 + 24) = 1;
          uint64_t v49 = v53;
          v53[24] = v53 == *(unsigned char **)&v51;
          *__n128 v55 = 1;
          if (v53 == *(unsigned char **)&v51) {
            goto LABEL_87;
          }
        }
      }
      uint64_t v35 = v32[31];
      uint64_t v36 = *((int64x2_t ***)v32 + 7);
      uint64_t v37 = (uint64_t)(v32[8] - (void)v36) >> 3;
      while (1)
      {
        double v534 = *(double *)&v36;
        double v535 = *(double *)&v37;
        uint64_t v561 = v35;
        uint64_t v38 = v34[6];
        if (!v38) {
          break;
        }
        (*(void (**)(uint64_t, uint64_t *, double *))(*(void *)v38 + 48))(v38, &v561, &v534);
        uint64_t v34 = (void *)*v34;
        if (!v34) {
          goto LABEL_42;
        }
      }
      std::__throw_bad_function_call[abi:nn180100]();
      goto LABEL_536;
    }
    while (1)
    {
      unint64_t v395 = *((unsigned int *)v70 + 1);
      unint64_t v396 = v395 >> 7;
      uint64_t v397 = v21[4];
      unint64_t v398 = (v21[5] - v397) >> 3;
      if (v395 >> 7 >= v398) {
        goto LABEL_403;
      }
      uint64_t v399 = *(void *)(v397 + 8 * v396);
      if (!v399) {
        goto LABEL_403;
      }
      unint64_t v400 = *(unsigned __int16 *)(v399 + 2 * (v395 & 0x7F));
      uint64_t v402 = v21[7];
      uint64_t v401 = v21[8];
      unint64_t v403 = (v401 - v402) >> 3;
      if (v403 <= v400) {
        goto LABEL_403;
      }
      uint64_t v404 = v402 + 8 * v400;
      if (v404 == v401 || *(_DWORD *)(v404 + 4) != v395) {
        goto LABEL_403;
      }
      uint64_t v406 = v22[4];
      unint64_t v407 = (v22[5] - v406) >> 3;
      if (v396 >= v407) {
        goto LABEL_403;
      }
      uint64_t v408 = *(void *)(v406 + 8 * v396);
      if (!v408) {
        goto LABEL_403;
      }
      unint64_t v409 = *(unsigned __int16 *)(v408 + 2 * (v395 & 0x7F));
      uint64_t v411 = v22[7];
      uint64_t v410 = v22[8];
      unint64_t v412 = (v410 - v411) >> 3;
      if (v412 <= v409) {
        goto LABEL_403;
      }
      uint64_t v413 = v411 + 8 * v409;
      if (v413 == v410 || *(_DWORD *)(v413 + 4) != v395) {
        goto LABEL_403;
      }
      unint64_t v415 = *v70;
      unint64_t v416 = HIDWORD(*v70);
      unint64_t v417 = *v70 >> 39;
      if (v417 < v398
        && (uint64_t v418 = *(void *)(v397 + 8 * v417)) != 0
        && (unint64_t v419 = *(unsigned __int16 *)(v418 + 2 * (HIDWORD(v415) & 0x7F)), v403 > v419)
        && ((uint64_t v420 = v402 + 8 * v419, v420 != v401) ? (v421 = *(_DWORD *)(v420 + 4) == v416) : (v421 = 0), v421))
      {
        uint64_t v422 = (float32x2_t *)(v21[10] + 24 * v419);
        if (v417 >= v407) {
          goto LABEL_401;
        }
      }
      else
      {
        uint64_t v422 = (float32x2_t *)v21[11];
        if (v417 >= v407) {
          goto LABEL_401;
        }
      }
      uint64_t v423 = *(void *)(v406 + 8 * v417);
      if (v423)
      {
        unint64_t v424 = *(unsigned __int16 *)(v423 + 2 * (HIDWORD(v415) & 0x7F));
        if (v412 > v424)
        {
          uint64_t v425 = v411 + 8 * v424;
          if (v425 != v410 && *(_DWORD *)(v425 + 4) == v416)
          {
            int v394 = (long long *)(v22[10] + 80 * v424);
            goto LABEL_402;
          }
        }
      }
LABEL_401:
      int v394 = (long long *)v22[11];
LABEL_402:
      md::ARWorldIntersectorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::ResolvedDependencies const&,md::ARWorldIntersectorContext &)::$_0::operator()((int64x2_t ***)&v534, v422, v394);
LABEL_403:
      if (++v70 == (unint64_t *)v71) {
        goto LABEL_37;
      }
    }
  }
  uint64_t v72 = +[VKDebugSettings sharedSettings];
  int v73 = [v72 arRenderAvoidanceObjects];

  if (!v73)
  {
    uint64_t v134 = a1;
    if (!*(void *)(a1 + 152)) {
      goto LABEL_344;
    }
    unint64_t v135 = &k;
    *(double *)&std::string __p = COERCE_DOUBLE(&k);
    __p_8[0] = &k;
    __p_8[1] = &k;
    unint64_t v573 = 4;
    uint64_t v136 = *(double **)(a1 + 144);
    if (!v136)
    {
LABEL_137:
      if (*(void *)(v134 + 152))
      {
        uint64_t v159 = *(void **)(v134 + 144);
        if (v159)
        {
          do
          {
            long long v160 = (void *)*v159;
            operator delete(v159);
            uint64_t v159 = v160;
          }
          while (v160);
        }
        *(void *)(v134 + 144) = 0;
        uint64_t v161 = *(void *)(v134 + 136);
        if (v161)
        {
          for (uint64_t j = 0; j != v161; ++j)
            *(void *)(*(void *)(v134 + 128) + 8 * j) = 0;
        }
        *(void *)(v134 + 152) = 0;
      }
      if (__p != __p_8[1]) {
        free(__p);
      }
LABEL_344:
      *(unsigned char *)(v134 + 184) = 0;

      return;
    }
    while (1)
    {
      uint64_t v138 = __p;
      uint64_t v139 = v135 - __p;
      if (v573 < v139 + 1) {
        break;
      }
LABEL_116:
      double *v135 = v136[3];
      uint64_t v137 = (char *)__p_8[0];
      unint64_t v135 = (double *)((char *)__p_8[0] + 8);
      __p_8[0] = (char *)__p_8[0] + 8;
      uint64_t v136 = *(double **)v136;
      if (!v136)
      {
        uint64_t v134 = a1;
        if (__p != v135)
        {
          uint64_t v156 = *(void *)(a1 + 120);
          int v157 = __p - 1;
          do
          {
            unint64_t v158 = *((void *)v157++ + 1);
            gdc::Registry::destroy(v156, v158);
          }
          while (v157 != (double *)v137);
        }
        goto LABEL_137;
      }
    }
    int64_t v140 = (double *)__p_8[1];
    unint64_t v141 = (1 << -(char)__clz(v573 + 1));
    if (v573 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v141 = 1;
    }
    if (v141 <= v139 + 1) {
      uint64_t v142 = v139 + 1;
    }
    else {
      uint64_t v142 = v141;
    }
    int64_t v143 = malloc_type_malloc(8 * v142, 0x100004000313F17uLL);
    uint64_t v144 = (double *)v143;
    uint64_t v145 = __p;
    uint64_t v146 = (double *)__p_8[0];
    if (__p != __p_8[0])
    {
      unint64_t v147 = (char *)__p_8[0] - (char *)__p - 8;
      if (v147 < 0x18)
      {
        uint64_t v148 = v143;
      }
      else
      {
        uint64_t v148 = v143;
        if ((unint64_t)((char *)v143 - (char *)__p) >= 0x20)
        {
          uint64_t v149 = (v147 >> 3) + 1;
          uint64_t v150 = 8 * (v149 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v148 = (void *)((char *)v143 + v150);
          float v151 = (long long *)(__p + 2);
          int v152 = v143 + 1;
          uint64_t v153 = v149 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v154 = *v151;
            *(v152 - 1) = *(v151 - 1);
            _OWORD *v152 = v154;
            v151 += 2;
            v152 += 2;
            v153 -= 4;
          }
          while (v153);
          if (v149 == (v149 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_132;
          }
          uint64_t v145 = (double *)((char *)v145 + v150);
        }
      }
      do
      {
        uint64_t v155 = *(void *)v145++;
        *v148++ = v155;
      }
      while (v145 != v146);
    }
LABEL_132:
    if (v138 != v140) {
      free(__p);
    }
    unint64_t v135 = &v144[v139];
    std::string __p = v144;
    __p_8[0] = v135;
    unint64_t v573 = v142;
    goto LABEL_116;
  }
  char v560 = [v511 arRenderAvoidanceObjectsIntersection];
  if (*(void *)(v525 + 5584)) {
    uint64_t v75 = *(void *)(v525 + 5584);
  }
  else {
    uint64_t v75 = v525;
  }
  double v76 = *(double *)(v525 + 512);
  long long v556 = *(_OWORD *)(v525 + 496);
  uint64_t v77 = *(void *)(v525 + 512);
  long long v558 = *(_OWORD *)(v525 + 3088);
  double v78 = *(double *)(v525 + 3104);
  uint64_t v557 = v77;
  double v559 = v78;
  double v79 = *(double *)(v75 + 808);
  double v80 = *(double *)(v75 + 840);
  double v81 = *(double *)(v75 + 872);
  double v82 = *(double *)(v75 + 904);
  double v83 = *(double *)(v75 + 816);
  double v84 = *(double *)(v75 + 848);
  double v85 = *(double *)(v75 + 880);
  double v86 = *(double *)(v75 + 912);
  double v87 = *(double *)(v75 + 824);
  v74.i64[0] = *(void *)(v75 + 856);
  double v88 = *(double *)(v75 + 888);
  double v89 = *(double *)(v75 + 832);
  v90.f64[0] = *(float64_t *)(v75 + 864);
  double v91 = *(double *)(v75 + 896);
  uint64_t v517 = (double *)v75;
  double v92 = *(double *)(v75 + 928);
  double v93 = v89 + v79;
  float64_t v94 = v90.f64[0] + v80;
  double v95 = v91 + v81;
  double v96 = v92 + v82;
  double v97 = v89 - v79;
  float64_t v98 = v90.f64[0] - v80;
  double v99 = v91 - v81;
  double v100 = v92 - v82;
  double v101 = v89 + v83;
  float64_t v102 = v90.f64[0] + v84;
  double v103 = v91 + v85;
  double v104 = v92 + v86;
  double v105 = v89 - v83;
  float64_t v106 = v90.f64[0] - v84;
  double v107 = v91 - v85;
  double v108 = v92 - v86;
  double v109 = v89 - v87;
  v110.f64[0] = v87;
  v110.f64[1] = v109;
  double v111 = v92 - *(double *)(v75 + 920);
  float64x2_t v112 = vmulq_f64(v110, v110);
  v110.f64[0] = *(float64_t *)(v75 + 920);
  v90.f64[1] = v91;
  *(void *)&v113.f64[0] = v74.i64[0];
  v113.f64[1] = v88;
  float64x2_t v114 = vsubq_f64(v90, v113);
  float64x2_t v115 = (float64x2_t)vzip1q_s64(v74, (int64x2_t)v114);
  float64x2_t v116 = vmlaq_f64(v112, v115, v115);
  v115.f64[1] = v114.f64[1];
  v115.f64[0] = v88;
  __asm { FMOV            V27.2D, #1.0 }
  float64x2_t v121 = vdivq_f64(_Q27, vsqrtq_f64(vmlaq_f64(v116, v115, v115)));
  double v534 = v87 * v121.f64[0];
  double v535 = *(double *)v74.i64 * v121.f64[0];
  double v536 = v88 * v121.f64[0];
  float64x2_t v537 = vmulq_f64(v121, v110);
  float64x2_t v538 = vmulq_laneq_f64(v114, v121, 1);
  double v122 = 1.0 / sqrt(v101 * v101 + v102 * v102 + v103 * v103);
  double v539 = vmuld_lane_f64(v111, v121, 1);
  double v540 = v122 * v101;
  double v541 = v122 * v102;
  double v542 = v122 * v103;
  double v123 = 1.0 / sqrt(v105 * v105 + v106 * v106 + v107 * v107);
  double v543 = v122 * v104;
  double v544 = v123 * v105;
  double v545 = v123 * v106;
  double v546 = v123 * v107;
  double v124 = 1.0 / sqrt(v93 * v93 + v94 * v94 + v95 * v95);
  double v547 = v123 * v108;
  double v548 = v124 * v93;
  double v549 = v124 * v94;
  double v550 = v124 * v95;
  double v125 = 1.0 / sqrt(v97 * v97 + v98 * v98 + v99 * v99);
  double v551 = v124 * v96;
  double v552 = v125 * v97;
  double v553 = v125 * v98;
  double v554 = v125 * v99;
  double v555 = v125 * v100;
  geo::Frustum<double>::calculateCorners(&v534, (double *)(v75 + 808), 0.0);
  *(_OWORD *)v531 = 0u;
  *(_OWORD *)v532 = 0u;
  int v533 = 1065353216;
  unint64_t v126 = *(int8x8_t **)(a1 + 120);
  uint64_t v127 = (void *)gdc::Registry::storage<arComponents::Boundary>(v126);
  unint64_t v128 = (void *)gdc::Registry::storage<arComponents::WorldTransform>(v126);
  uint64_t v129 = gdc::Registry::storage<arComponents::UseForOcclusionTest>(v126);
  uint64_t v130 = (void *)v129;
  uint64_t v131 = (float32x2_t *)v127[10];
  unint64_t v132 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v127[11] - (void)v131) >> 3);
  uint64_t v133 = *(void *)(v129 + 80);
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v128[11] - v128[10]) >> 4) < v132) {
    unint64_t v132 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v128[11] - v128[10]) >> 4);
  }
  if (*(void *)(v129 + 88) - v133 < v132) {
    unint64_t v132 = *(void *)(v129 + 88) - v133;
  }
  if (v132)
  {
    if (v132 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    v510 = operator new(24 * v132);
  }
  else
  {
    v510 = 0;
  }
  uint64_t v164 = v127[7];
  uint64_t v163 = v127[8];
  if (v128[8] - v128[7] >= (unint64_t)(v163 - v164)) {
    size_t v165 = v127 + 4;
  }
  else {
    size_t v165 = v128 + 4;
  }
  if (v130[8] - v130[7] >= v165[4] - v165[3]) {
    uint64_t v166 = v165;
  }
  else {
    uint64_t v166 = v130 + 4;
  }
  if (v127 + 4 == v166)
  {
    *(double *)&std::string __p = COERCE_DOUBLE(&v534);
    __p_8[0] = (void *)a1;
    __p_8[1] = v531;
    unint64_t v573 = (unint64_t)&v560;
    for (double k = COERCE_DOUBLE(&v556); v164 != v163; v164 += 8)
    {
      unint64_t v428 = *(unsigned int *)(v164 + 4);
      unint64_t v429 = v428 >> 7;
      uint64_t v430 = v128[4];
      unint64_t v431 = (v128[5] - v430) >> 3;
      if (v428 >> 7 < v431)
      {
        uint64_t v432 = *(void *)(v430 + 8 * v429);
        if (v432)
        {
          unint64_t v433 = *(unsigned __int16 *)(v432 + 2 * (v428 & 0x7F));
          uint64_t v435 = v128[7];
          uint64_t v434 = v128[8];
          unint64_t v436 = (v434 - v435) >> 3;
          if (v436 > v433)
          {
            uint64_t v437 = v435 + 8 * v433;
            if (v437 != v434 && *(_DWORD *)(v437 + 4) == v428)
            {
              uint64_t v439 = v130[4];
              if (v429 < (v130[5] - v439) >> 3)
              {
                uint64_t v440 = *(void *)(v439 + 8 * v429);
                if (v440)
                {
                  unint64_t v441 = *(unsigned __int16 *)(v440 + 2 * (v428 & 0x7F));
                  uint64_t v443 = v130[7];
                  uint64_t v442 = v130[8];
                  if (v441 < (v442 - v443) >> 3)
                  {
                    uint64_t v444 = v443 + 8 * v441;
                    if (v444 != v442 && *(_DWORD *)(v444 + 4) == v428)
                    {
                      unint64_t v446 = *(void *)v164;
                      unint64_t v447 = *(void *)v164 >> 39;
                      if (v447 < v431
                        && (uint64_t v448 = *(void *)(v430 + 8 * v447)) != 0
                        && (unint64_t v449 = *(unsigned __int16 *)(v448 + 2 * (HIDWORD(v446) & 0x7F)), v436 > v449)
                        && ((uint64_t v450 = v435 + 8 * v449, v450 != v434)
                          ? (BOOL v451 = *(_DWORD *)(v450 + 4) == HIDWORD(v446))
                          : (BOOL v451 = 0),
                            v451))
                      {
                        v427 = (double *)(v128[10] + 80 * v449);
                      }
                      else
                      {
                        v427 = (double *)v128[11];
                      }
                      md::ARWorldIntersectorLogic::generateDebugAvoidancesIntersections(md::CameraContext const&,md::GeometryContext const&,md::ARWorldIntersectorContext &,BOOL)::$_0::operator()((uint64_t)&__p, v446, v131, v427);
                    }
                  }
                }
              }
            }
          }
        }
      }
      v131 += 3;
    }
  }
  if (v128 + 4 == v166)
  {
    *(double *)&std::string __p = COERCE_DOUBLE(&v534);
    __p_8[0] = (void *)a1;
    __p_8[1] = v531;
    unint64_t v573 = (unint64_t)&v560;
    double k = COERCE_DOUBLE(&v556);
    uint64_t v335 = v128[7];
    uint64_t v336 = v128[8];
    if (v335 != v336)
    {
      size_t v337 = (double *)v128[10];
      do
      {
        unint64_t v453 = *(unsigned int *)(v335 + 4);
        unint64_t v454 = v453 >> 7;
        uint64_t v455 = v127[4];
        unint64_t v456 = (v127[5] - v455) >> 3;
        if (v453 >> 7 < v456)
        {
          uint64_t v457 = *(void *)(v455 + 8 * v454);
          if (v457)
          {
            unint64_t v458 = *(unsigned __int16 *)(v457 + 2 * (v453 & 0x7F));
            uint64_t v460 = v127[7];
            uint64_t v459 = v127[8];
            unint64_t v461 = (v459 - v460) >> 3;
            if (v461 > v458)
            {
              uint64_t v462 = v460 + 8 * v458;
              if (v462 != v459 && *(_DWORD *)(v462 + 4) == v453)
              {
                uint64_t v464 = v130[4];
                if (v454 < (v130[5] - v464) >> 3)
                {
                  uint64_t v465 = *(void *)(v464 + 8 * v454);
                  if (v465)
                  {
                    unint64_t v466 = *(unsigned __int16 *)(v465 + 2 * (v453 & 0x7F));
                    uint64_t v468 = v130[7];
                    uint64_t v467 = v130[8];
                    if (v466 < (v467 - v468) >> 3)
                    {
                      uint64_t v469 = v468 + 8 * v466;
                      if (v469 != v467 && *(_DWORD *)(v469 + 4) == v453)
                      {
                        unint64_t v471 = *(void *)v335;
                        unint64_t v472 = *(void *)v335 >> 39;
                        if (v472 < v456
                          && (uint64_t v473 = *(void *)(v455 + 8 * v472)) != 0
                          && (unint64_t v474 = *(unsigned __int16 *)(v473 + 2 * (HIDWORD(v471) & 0x7F)), v461 > v474)
                          && ((uint64_t v475 = v460 + 8 * v474, v475 != v459)
                            ? (BOOL v476 = *(_DWORD *)(v475 + 4) == HIDWORD(v471))
                            : (BOOL v476 = 0),
                              v476))
                        {
                          v452 = (float32x2_t *)(v127[10] + 24 * v474);
                        }
                        else
                        {
                          v452 = (float32x2_t *)v127[11];
                        }
                        md::ARWorldIntersectorLogic::generateDebugAvoidancesIntersections(md::CameraContext const&,md::GeometryContext const&,md::ARWorldIntersectorContext &,BOOL)::$_0::operator()((uint64_t)&__p, v471, v452, v337);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        v337 += 10;
        v335 += 8;
      }
      while (v335 != v336);
    }
  }
  if (v130 + 4 == v166)
  {
    *(double *)&std::string __p = COERCE_DOUBLE(&v534);
    __p_8[0] = (void *)a1;
    __p_8[1] = v531;
    unint64_t v573 = (unint64_t)&v560;
    double k = COERCE_DOUBLE(&v556);
    uint64_t v338 = v130[7];
    for (uint64_t m = v130[8]; v338 != m; v338 += 8)
    {
      unint64_t v478 = *(unsigned int *)(v338 + 4);
      unint64_t v479 = v478 >> 7;
      uint64_t v480 = v127[4];
      unint64_t v481 = (v127[5] - v480) >> 3;
      if (v478 >> 7 >= v481) {
        continue;
      }
      uint64_t v482 = *(void *)(v480 + 8 * v479);
      if (!v482) {
        continue;
      }
      unint64_t v483 = *(unsigned __int16 *)(v482 + 2 * (v478 & 0x7F));
      uint64_t v485 = v127[7];
      uint64_t v484 = v127[8];
      unint64_t v486 = (v484 - v485) >> 3;
      if (v486 <= v483) {
        continue;
      }
      uint64_t v487 = v485 + 8 * v483;
      if (v487 == v484 || *(_DWORD *)(v487 + 4) != v478) {
        continue;
      }
      uint64_t v489 = v128[4];
      unint64_t v490 = (v128[5] - v489) >> 3;
      if (v479 >= v490) {
        continue;
      }
      uint64_t v491 = *(void *)(v489 + 8 * v479);
      if (!v491) {
        continue;
      }
      unint64_t v492 = *(unsigned __int16 *)(v491 + 2 * (v478 & 0x7F));
      uint64_t v494 = v128[7];
      uint64_t v493 = v128[8];
      unint64_t v495 = (v493 - v494) >> 3;
      if (v495 <= v492) {
        continue;
      }
      uint64_t v496 = v494 + 8 * v492;
      if (v496 == v493 || *(_DWORD *)(v496 + 4) != v478) {
        continue;
      }
      unint64_t v498 = *(void *)v338;
      uint64_t v499 = HIDWORD(*(void *)v338);
      unint64_t v500 = *(void *)v338 >> 39;
      if (v500 < v481
        && (uint64_t v501 = *(void *)(v480 + 8 * v500)) != 0
        && (unint64_t v502 = *(unsigned __int16 *)(v501 + 2 * (HIDWORD(v498) & 0x7F)), v486 > v502)
        && ((uint64_t v503 = v485 + 8 * v502, v503 != v484) ? (v504 = *(_DWORD *)(v503 + 4) == v499) : (v504 = 0), v504))
      {
        v505 = (float32x2_t *)(v127[10] + 24 * v502);
        if (v500 >= v490) {
          goto LABEL_494;
        }
      }
      else
      {
        v505 = (float32x2_t *)v127[11];
        if (v500 >= v490) {
          goto LABEL_494;
        }
      }
      uint64_t v506 = *(void *)(v489 + 8 * v500);
      if (v506)
      {
        unint64_t v507 = *(unsigned __int16 *)(v506 + 2 * (HIDWORD(v498) & 0x7F));
        if (v495 > v507)
        {
          uint64_t v508 = v494 + 8 * v507;
          if (v508 != v493 && *(_DWORD *)(v508 + 4) == v499)
          {
            v477 = (double *)(v128[10] + 80 * v507);
            goto LABEL_495;
          }
        }
      }
LABEL_494:
      v477 = (double *)v128[11];
LABEL_495:
      md::ARWorldIntersectorLogic::generateDebugAvoidancesIntersections(md::CameraContext const&,md::GeometryContext const&,md::ARWorldIntersectorContext &,BOOL)::$_0::operator()((uint64_t)&__p, v498, v505, v477);
    }
  }
  uint64_t v167 = (void *)gdc::Registry::storage<SceneComponents::LayerDataInView<(md::MapDataType)60>>(*(int8x8_t **)(a1 + 120));
  uint64_t v168 = v167[7];
  uint64_t v512 = v167[8];
  if (v168 == v512)
  {
LABEL_291:
    uint64_t v134 = a1;
    uint64_t v315 = (void **)(a1 + 144);
    uint64_t v316 = *(void **)(a1 + 144);
    if (!v316) {
      goto LABEL_317;
    }
    while (1)
    {
      while (1)
      {
        if (v531[1])
        {
          unint64_t v317 = v316[2];
          uint8x8_t v318 = (uint8x8_t)vcnt_s8((int8x8_t)v531[1]);
          v318.i16[0] = vaddlv_u8(v318);
          if (v318.u32[0] > 1uLL)
          {
            unint64_t v319 = v316[2];
            if ((void *)v317 >= v531[1]) {
              unint64_t v319 = v317 % (unint64_t)v531[1];
            }
          }
          else
          {
            unint64_t v319 = ((unint64_t)v531[1] - 1) & v317;
          }
          unint64_t v320 = (uint64_t **)*((void *)v531[0] + v319);
          if (v320)
          {
            uint8x8_t v321 = *v320;
            if (v321) {
              break;
            }
          }
        }
LABEL_316:
        gdc::Registry::destroy(*(void *)(a1 + 120), v316[3]);
        uint64_t v316 = (void *)*v316;
        if (!v316) {
          goto LABEL_317;
        }
      }
      unsigned int v322 = (unsigned __int16)v316[2];
      if (v318.u32[0] < 2uLL)
      {
        while (1)
        {
          unint64_t v324 = v321[1];
          if (v317 == v324)
          {
            if (__PAIR64__(*((unsigned __int16 *)v321 + 9), *((unsigned __int16 *)v321 + 8)) == __PAIR64__(WORD1(v317), v322)&& *((_DWORD *)v321 + 5) == HIDWORD(v317))
            {
              goto LABEL_314;
            }
          }
          else if ((v324 & ((unint64_t)v531[1] - 1)) != v319)
          {
            goto LABEL_316;
          }
          uint8x8_t v321 = (uint64_t *)*v321;
          if (!v321) {
            goto LABEL_316;
          }
        }
      }
      while (1)
      {
        unint64_t v323 = v321[1];
        if (v317 == v323) {
          break;
        }
        if ((void *)v323 >= v531[1]) {
          v323 %= (unint64_t)v531[1];
        }
        if (v323 != v319) {
          goto LABEL_316;
        }
LABEL_302:
        uint8x8_t v321 = (uint64_t *)*v321;
        if (!v321) {
          goto LABEL_316;
        }
      }
      if (__PAIR64__(*((unsigned __int16 *)v321 + 9), *((unsigned __int16 *)v321 + 8)) != __PAIR64__(WORD1(v317), v322)
        || *((_DWORD *)v321 + 5) != HIDWORD(v317))
      {
        goto LABEL_302;
      }
LABEL_314:
      uint64_t v316 = (void *)*v316;
      if (!v316)
      {
LABEL_317:
        if (*(void *)(a1 + 152))
        {
          uint64_t v325 = *v315;
          if (*v315)
          {
            do
            {
              float v326 = (void *)*v325;
              operator delete(v325);
              uint64_t v325 = v326;
            }
            while (v326);
          }
          *(void *)(a1 + 144) = 0;
          uint64_t v327 = *(void *)(a1 + 136);
          if (v327)
          {
            for (uint64_t n = 0; n != v327; ++n)
              *(void *)(*(void *)(a1 + 128) + 8 * n) = 0;
          }
          *(void *)(a1 + 152) = 0;
        }
        unint64_t v329 = v531[0];
        v531[0] = 0;
        unint64_t v330 = *(void **)(a1 + 128);
        *(void *)(a1 + 128) = v329;
        if (v330) {
          operator delete(v330);
        }
        unint64_t v332 = (unint64_t)v531[1];
        size_t v331 = v532[0];
        v531[1] = 0;
        long long v333 = v532[1];
        *(void **)(a1 + 144) = v532[0];
        *(void *)(a1 + 152) = v333;
        *(_DWORD *)(a1 + 160) = v533;
        *(void *)(a1 + 136) = v332;
        if (v333)
        {
          unint64_t v334 = v331[1];
          if ((v332 & (v332 - 1)) != 0)
          {
            if (v334 >= v332) {
              v334 %= v332;
            }
          }
          else
          {
            v334 &= v332 - 1;
          }
          size_t v331 = 0;
          *(void *)(*(void *)(a1 + 128) + 8 * v334) = v315;
          v532[0] = 0;
          v532[1] = 0;
        }
        if (v510)
        {
          operator delete(v510);
          size_t v331 = v532[0];
        }
        if (v331)
        {
          do
          {
            v340 = (void *)*v331;
            operator delete(v331);
            size_t v331 = v340;
          }
          while (v340);
        }
        size_t v341 = v531[0];
        v531[0] = 0;
        if (v341) {
          operator delete(v341);
        }
        goto LABEL_344;
      }
    }
  }
  uint64_t v169 = (void *)v167[10];
  float v170 = v76 * 40075017.0;
  double v515 = v170 * 0.0000000249532021;
  __asm { FMOV            V0.2S, #1.0 }
  float32x2_t v516 = _D0;
  while (1)
  {
    v513 = v169;
    uint64_t v514 = v168;
    uint64_t v172 = (void *)*v169;
    v523 = v169 + 1;
    if ((void *)*v169 != v169 + 1) {
      break;
    }
LABEL_158:
    uint64_t v169 = v513 + 3;
    uint64_t v168 = v514 + 8;
    if (v514 + 8 == v512) {
      goto LABEL_291;
    }
  }
  while (2)
  {
    size_t v173 = *(int8x8_t **)(v172[4] + 784);
    int8x8_t v174 = v173[1];
    if (!*(void *)&v174) {
      goto LABEL_185;
    }
    uint8x8_t v175 = (uint8x8_t)vcnt_s8(v174);
    v175.i16[0] = vaddlv_u8(v175);
    if (v175.u32[0] > 1uLL)
    {
      uint64_t v176 = 0x64A448A5CD5D38DBLL;
      if (*(void *)&v174 <= 0x64A448A5CD5D38DBuLL) {
        uint64_t v176 = 0x64A448A5CD5D38DBuLL % *(void *)&v174;
      }
    }
    else
    {
      uint64_t v176 = (*(void *)&v174 - 1) & 0x64A448A5CD5D38DBLL;
    }
    float32x4_t v177 = *(void **)(*(void *)v173 + 8 * v176);
    if (!v177) {
      goto LABEL_185;
    }
    unint64_t v178 = (void *)*v177;
    if (!v178) {
      goto LABEL_185;
    }
    if (v175.u32[0] < 2uLL)
    {
      uint64_t v179 = *(void *)&v174 - 1;
      while (1)
      {
        uint64_t v181 = v178[1];
        if (v181 == 0x64A448A5CD5D38DBLL)
        {
          if (v178[2] == 0x64A448A5CD5D38DBLL) {
            goto LABEL_183;
          }
        }
        else if ((v181 & v179) != v176)
        {
          goto LABEL_185;
        }
        unint64_t v178 = (void *)*v178;
        if (!v178) {
          goto LABEL_185;
        }
      }
    }
    while (1)
    {
      unint64_t v180 = v178[1];
      if (v180 == 0x64A448A5CD5D38DBLL) {
        break;
      }
      if (v180 >= *(void *)&v174) {
        v180 %= *(void *)&v174;
      }
      if (v180 != v176) {
        goto LABEL_185;
      }
LABEL_172:
      unint64_t v178 = (void *)*v178;
      if (!v178) {
        goto LABEL_185;
      }
    }
    if (v178[2] != 0x64A448A5CD5D38DBLL) {
      goto LABEL_172;
    }
LABEL_183:
    uint64_t v182 = v178[5];
    if (*(void *)(v182 + 8) == 0x64A448A5CD5D38DBLL)
    {
      uint64_t v183 = *(void *)(v182 + 32);
      goto LABEL_186;
    }
LABEL_185:
    uint64_t v183 = 0;
LABEL_186:
    if (!geo::Intersect::encloses<double>(&v534, (double *)(v183 + 128))) {
      goto LABEL_285;
    }
    md::GeometryContext::transformConstantData((double *)&v564, v518, (unsigned __int8 *)v183, 0, *(double *)(v183 + 432), *(double *)(v183 + 440));
    char v524 = v172;
    __powidf2();
    double v529 = v184;
    gm::Matrix<double,4,4>::inverted<int,void>((double *)&__p, (double *)(v183 + 304));
    double v185 = v517[101];
    double v186 = *(double *)(v183 + 304);
    double v187 = *(double *)(v183 + 312);
    double v188 = v517[105];
    double v189 = v517[109];
    double v190 = *(double *)(v183 + 320);
    double v191 = *(double *)(v183 + 328);
    double v192 = v517[113];
    double v193 = v186 * v185 + v187 * v188 + v190 * v189 + v191 * v192;
    double v194 = *(double *)(v183 + 336);
    double v195 = *(double *)(v183 + 344);
    double v196 = *(double *)(v183 + 352);
    double v197 = *(double *)(v183 + 360);
    double v198 = v194 * v185 + v195 * v188 + v196 * v189 + v197 * v192;
    double v199 = *(double *)(v183 + 368);
    double v200 = *(double *)(v183 + 376);
    double v201 = *(double *)(v183 + 384);
    double v202 = *(double *)(v183 + 392);
    double v203 = v199 * v185 + v200 * v188 + v201 * v189 + v202 * v192;
    double v204 = *(double *)(v183 + 400);
    double v205 = *(double *)(v183 + 408);
    double v206 = *(double *)(v183 + 416);
    double v207 = *(double *)(v183 + 424);
    double v208 = v204 * v185 + v205 * v188 + v206 * v189 + v207 * v192;
    double v209 = v517[102];
    double v210 = v517[106];
    double v211 = v517[110];
    double v212 = v517[114];
    double v213 = v209 * v186 + v210 * v187 + v211 * v190 + v212 * v191;
    double v214 = v209 * v194 + v210 * v195 + v211 * v196 + v212 * v197;
    double v215 = v209 * v199 + v210 * v200 + v211 * v201 + v212 * v202;
    double v216 = v209 * v204 + v210 * v205 + v211 * v206 + v212 * v207;
    double v217 = v517[103];
    double v218 = v517[107];
    double v219 = v517[111];
    double v220 = v217 * v186 + v218 * v187 + v219 * v190;
    double v221 = v217 * v194 + v218 * v195;
    double v222 = v217 * v199 + v218 * v200;
    double v223 = v217 * v204 + v218 * v205;
    double v224 = v517[115];
    double v225 = v220 + v224 * v191;
    double v226 = v221 + v219 * v196 + v224 * v197;
    double v227 = v222 + v219 * v201 + v224 * v202;
    double v228 = v223 + v219 * v206 + v224 * v207;
    double v229 = v517[104];
    double v230 = v517[108];
    double v231 = v229 * v186 + v230 * v187;
    double v232 = v517[112];
    double v233 = v231 + v232 * v190;
    double v234 = v517[116];
    double v235 = v233 + v234 * v191;
    double v236 = v229 * v194 + v230 * v195 + v232 * v196 + v234 * v197;
    double v237 = v229 * v199 + v230 * v200 + v232 * v201 + v234 * v202;
    double v238 = v229 * v204 + v230 * v205 + v232 * v206 + v234 * v207;
    *(float *)&double v193 = v193;
    *(float *)&double v197 = v213;
    v563[0] = *(float *)&v193;
    v563[1] = *(float *)&v197;
    *(float *)&double v194 = v225;
    *(float *)&double v229 = v235;
    v563[3] = *(float *)&v229;
    *(float *)&double v198 = v198;
    *(float *)&double v204 = v214;
    v563[4] = *(float *)&v198;
    v563[5] = *(float *)&v204;
    *(float *)&double v200 = v226;
    *(float *)&double v205 = v236;
    v563[7] = *(float *)&v205;
    *(float *)&double v203 = v203;
    *(float *)&double v206 = v215;
    v563[8] = *(float *)&v203;
    v563[9] = *(float *)&v206;
    *(float *)&double v199 = v227;
    *(float *)&double v207 = v237;
    v563[11] = *(float *)&v207;
    *(float *)&double v235 = *(float *)&v229 + *(float *)&v193;
    *(float *)&double v232 = *(float *)&v205 + *(float *)&v198;
    *(float *)&double v234 = *(float *)&v207 + *(float *)&v203;
    *(float *)&double v193 = *(float *)&v229 - *(float *)&v193;
    *(float *)&double v198 = *(float *)&v205 - *(float *)&v198;
    *(float *)&double v203 = *(float *)&v207 - *(float *)&v203;
    *(float *)&double v201 = *(float *)&v229 + *(float *)&v197;
    *(float *)&double v225 = *(float *)&v207 + *(float *)&v206;
    *(float *)&double v236 = *(float *)&v229 - *(float *)&v197;
    *(float *)&double v197 = *(float *)&v207 - *(float *)&v206;
    LODWORD(v206) = LODWORD(v194);
    *((float *)&v206 + 1) = *(float *)&v229 - *(float *)&v194;
    v563[2] = *(float *)&v194;
    v563[6] = *(float *)&v200;
    *(float *)&double v208 = v208;
    *(float *)&double v216 = v216;
    v563[12] = *(float *)&v208;
    v563[13] = *(float *)&v216;
    *(float *)&double v228 = v228;
    *(float *)&double v238 = v238;
    v563[14] = *(float *)&v228;
    v563[15] = *(float *)&v238;
    float32x2_t v239 = vdiv_f32(v516, vsqrt_f32(vmla_f32(vmla_f32(vmul_f32(*(float32x2_t *)&v206, *(float32x2_t *)&v206), (float32x2_t)__PAIR64__(*(float *)&v205 - *(float *)&v200, LODWORD(v200)), (float32x2_t)__PAIR64__(*(float *)&v205 - *(float *)&v200, LODWORD(v200))), (float32x2_t)__PAIR64__(*(float *)&v207 - *(float *)&v199, LODWORD(v199)), (float32x2_t)__PAIR64__(*(float *)&v207 - *(float *)&v199, LODWORD(v199)))));
    *(float *)&uint64_t v561 = *(float *)&v194 * v239.f32[0];
    *((float *)&v561 + 1) = *(float *)&v200 * v239.f32[0];
    LODWORD(v206) = LODWORD(v228);
    v563[10] = *(float *)&v199;
    *(float32x2_t *)&v562[1] = vmul_f32(v239, *(float32x2_t *)&v206);
    v562[0] = *(float *)&v199 * v239.f32[0];
    v562[3] = vmuls_lane_f32(*(float *)&v205 - *(float *)&v200, v239, 1);
    v562[4] = vmuls_lane_f32(*(float *)&v207 - *(float *)&v199, v239, 1);
    v562[5] = vmuls_lane_f32(*(float *)&v238 - *(float *)&v228, v239, 1);
    *(float *)&double v228 = 1.0
                    / sqrtf((float)((float)(*(float *)&v201 * *(float *)&v201)+ (float)((float)(*(float *)&v205 + *(float *)&v204)* (float)(*(float *)&v205 + *(float *)&v204)))+ (float)(*(float *)&v225 * *(float *)&v225));
    v562[6] = *(float *)&v228 * *(float *)&v201;
    v562[7] = *(float *)&v228 * (float)(*(float *)&v205 + *(float *)&v204);
    v562[8] = *(float *)&v228 * *(float *)&v225;
    v562[9] = *(float *)&v228 * (float)(*(float *)&v238 + *(float *)&v216);
    *(float *)&double v228 = 1.0
                    / sqrtf((float)((float)(*(float *)&v236 * *(float *)&v236)+ (float)((float)(*(float *)&v205 - *(float *)&v204)* (float)(*(float *)&v205 - *(float *)&v204)))+ (float)(*(float *)&v197 * *(float *)&v197));
    v562[10] = *(float *)&v228 * *(float *)&v236;
    v562[11] = *(float *)&v228 * (float)(*(float *)&v205 - *(float *)&v204);
    v562[12] = *(float *)&v228 * *(float *)&v197;
    v562[13] = *(float *)&v228 * (float)(*(float *)&v238 - *(float *)&v216);
    *(float *)&double v216 = 1.0
                    / sqrtf((float)((float)(*(float *)&v235 * *(float *)&v235) + (float)(*(float *)&v232 * *(float *)&v232))+ (float)(*(float *)&v234 * *(float *)&v234));
    v562[14] = *(float *)&v216 * *(float *)&v235;
    uint64_t v240 = __p;
    double v241 = k;
    v562[15] = *(float *)&v216 * *(float *)&v232;
    double v242 = v578;
    v562[16] = *(float *)&v216 * *(float *)&v234;
    v562[17] = *(float *)&v216 * (float)(*(float *)&v238 + *(float *)&v208);
    *(float *)&double v216 = 1.0
                    / sqrtf((float)((float)(*(float *)&v193 * *(float *)&v193) + (float)(*(float *)&v198 * *(float *)&v198))+ (float)(*(float *)&v203 * *(float *)&v203));
    long long v243 = v558;
    v562[18] = *(float *)&v216 * *(float *)&v193;
    double v522 = v559;
    v562[19] = *(float *)&v216 * *(float *)&v198;
    v562[20] = *(float *)&v216 * *(float *)&v203;
    float64x2_t v519 = *(float64x2_t *)__p_8;
    float64x2_t v520 = v575;
    v562[21] = *(float *)&v216 * (float)(*(float *)&v238 - *(float *)&v208);
    float64x2_t v521 = v579;
    gm::Matrix<float,4,4>::inverted<int,void>((float *)&__p, v563);
    float v244 = 1.0 / (float)(v577 - (float)(*((float *)&v573 + 1) + *((float *)__p_8 + 1)));
    v562[22] = v244 * (float)(*(float *)&v575.f64[1] - (float)(*(float *)&__p_8[1] + *(float *)&__p));
    v562[23] = v244 * (float)(*((float *)&v575.f64[1] + 1) - (float)(*((float *)&__p_8[1] + 1) + *((float *)&__p + 1)));
    float v245 = 1.0
         / (float)((float)(v577 + *((float *)v575.f64 + 1)) - (float)(*((float *)&v573 + 1) + *((float *)__p_8 + 1)));
    v562[24] = v244 * (float)(v576 - (float)(*(float *)&v573 + *(float *)__p_8));
    v562[25] = v245
             * (float)((float)(*(float *)&v575.f64[1] + *(float *)&k) - (float)(*(float *)&__p_8[1] + *(float *)&__p));
    v562[26] = v245
             * (float)((float)(*((float *)&v575.f64[1] + 1) + *((float *)&k + 1))
                     - (float)(*((float *)&__p_8[1] + 1) + *((float *)&__p + 1)));
    v562[27] = v245 * (float)((float)(v576 + *(float *)v575.f64) - (float)(*(float *)&v573 + *(float *)__p_8));
    float v246 = 1.0 / (float)(v577 + (float)(*((float *)&v573 + 1) - *((float *)__p_8 + 1)));
    v562[28] = v246 * (float)(*(float *)&v575.f64[1] + (float)(*(float *)&__p_8[1] - *(float *)&__p));
    v562[29] = v246 * (float)(*((float *)&v575.f64[1] + 1) + (float)(*((float *)&__p_8[1] + 1) - *((float *)&__p + 1)));
    float v247 = 1.0
         / (float)((float)(v577 + *((float *)v575.f64 + 1)) + (float)(*((float *)&v573 + 1) - *((float *)__p_8 + 1)));
    v562[30] = v246 * (float)(v576 + (float)(*(float *)&v573 - *(float *)__p_8));
    v562[31] = v247
             * (float)((float)(*(float *)&v575.f64[1] + *(float *)&k) + (float)(*(float *)&__p_8[1] - *(float *)&__p));
    v562[32] = v247
             * (float)((float)(*((float *)&v575.f64[1] + 1) + *((float *)&k + 1))
                     + (float)(*((float *)&__p_8[1] + 1) - *((float *)&__p + 1)));
    v562[33] = v247 * (float)((float)(v576 + *(float *)v575.f64) + (float)(*(float *)&v573 - *(float *)__p_8));
    float v248 = 1.0 / (float)(v577 + (float)(*((float *)__p_8 + 1) - *((float *)&v573 + 1)));
    v562[34] = v248 * (float)(*(float *)&v575.f64[1] + (float)(*(float *)&__p - *(float *)&__p_8[1]));
    v562[35] = v248 * (float)(*((float *)&v575.f64[1] + 1) + (float)(*((float *)&__p + 1) - *((float *)&__p_8[1] + 1)));
    float v249 = 1.0
         / (float)((float)(v577 + *((float *)v575.f64 + 1)) + (float)(*((float *)__p_8 + 1) - *((float *)&v573 + 1)));
    v562[36] = v248 * (float)(v576 + (float)(*(float *)__p_8 - *(float *)&v573));
    v562[37] = v249
             * (float)((float)(*(float *)&v575.f64[1] + *(float *)&k) + (float)(*(float *)&__p - *(float *)&__p_8[1]));
    v562[38] = v249
             * (float)((float)(*((float *)&v575.f64[1] + 1) + *((float *)&k + 1))
                     + (float)(*((float *)&__p + 1) - *((float *)&__p_8[1] + 1)));
    v562[39] = v249 * (float)((float)(v576 + *(float *)v575.f64) + (float)(*(float *)__p_8 - *(float *)&v573));
    float v250 = 1.0 / (float)(v577 + (float)(*((float *)&v573 + 1) + *((float *)__p_8 + 1)));
    v562[40] = v250 * (float)(*(float *)&v575.f64[1] + (float)(*(float *)&__p_8[1] + *(float *)&__p));
    v562[41] = v250 * (float)(*((float *)&v575.f64[1] + 1) + (float)(*((float *)&__p_8[1] + 1) + *((float *)&__p + 1)));
    float v251 = 1.0
         / (float)((float)(v577 + *((float *)v575.f64 + 1)) + (float)(*((float *)&v573 + 1) + *((float *)__p_8 + 1)));
    v562[42] = v250 * (float)(v576 + (float)(*(float *)&v573 + *(float *)__p_8));
    v562[43] = v251
             * (float)((float)(*(float *)&v575.f64[1] + *(float *)&k) + (float)(*(float *)&__p_8[1] + *(float *)&__p));
    v562[44] = v251
             * (float)((float)(*((float *)&v575.f64[1] + 1) + *((float *)&k + 1))
                     + (float)(*((float *)&__p_8[1] + 1) + *((float *)&__p + 1)));
    v562[45] = v251 * (float)((float)(v576 + *(float *)v575.f64) + (float)(*(float *)&v573 + *(float *)__p_8));
    unint64_t v252 = (void *)gdc::Registry::storage<arComponents::LocalBounds>(v173);
    uint64_t v253 = (unint64_t *)v252[7];
    unint64_t v526 = (unint64_t *)v252[8];
    if (v253 == v526)
    {
LABEL_281:
      uint64_t v312 = v565;
      if (v565 && !atomic_fetch_add(&v565->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v312->__on_zero_shared)(v312);
        std::__shared_weak_count::__release_weak(v312);
      }
      uint64_t v172 = v524;
LABEL_285:
      size_t v313 = (void *)v172[1];
      if (v313)
      {
        do
        {
          uint64_t v314 = v313;
          size_t v313 = (void *)*v313;
        }
        while (v313);
      }
      else
      {
        do
        {
          uint64_t v314 = (void *)v172[2];
          _ZF = *v314 == (void)v172;
          uint64_t v172 = v314;
        }
        while (!_ZF);
      }
      uint64_t v172 = v314;
      if (v314 == v523) {
        goto LABEL_158;
      }
      continue;
    }
    break;
  }
  _S8 = v515 * v529;
  float v255 = *(double *)&v243 * *(double *)&v240 + *((double *)&v243 + 1) * v241 + v522 * v242;
  float32x2_t v256 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v519, *(double *)&v243), v520, *((double *)&v243 + 1)), v521, v522));
  unint64_t v257 = (int *)v252[10];
  v528 = v257 + 1;
  while (2)
  {
    unint64_t v258 = *v253;
    unint64_t v570 = *v253;
    int v259 = *v257;
    int v260 = v257[5];
    int32x4_t v568 = vuzp2q_s32(*(int32x4_t *)(v257 + 1), vrev64q_s32(*(int32x4_t *)(v257 + 1)));
    int v567 = v259;
    int v569 = v260;
    md::GeometryLogic::adjustedMeshBounds((uint64_t)v566, (uint64_t)&v567, v564);
    if (!geo::Intersect::encloses<float>((float *)&v561, v566)) {
      goto LABEL_189;
    }
    int8x8_t v261 = *(int8x8_t *)(a1 + 136);
    if (!*(void *)&v261) {
      goto LABEL_215;
    }
    uint8x8_t v262 = (uint8x8_t)vcnt_s8(v261);
    v262.i16[0] = vaddlv_u8(v262);
    if (v262.u32[0] > 1uLL)
    {
      unint64_t v263 = v258;
      if (v258 >= *(void *)&v261) {
        unint64_t v263 = v258 % *(void *)&v261;
      }
    }
    else
    {
      unint64_t v263 = (*(void *)&v261 - 1) & v258;
    }
    uint64_t v264 = *(void *)(a1 + 128);
    unint64_t v265 = *(void ***)(v264 + 8 * v263);
    if (!v265 || (uint8x8_t v266 = *v265) == 0)
    {
LABEL_215:
      uint64_t v270 = *(gdc::Registry **)(a1 + 120);
      arComponents::LocalBounds::LocalBounds((arComponents::LocalBounds *)&__p, (const arComponents::LocalBounds *)v257);
      gdc::Registry::create(v270);
    }
    uint64_t v267 = *(void *)&v261 - 1;
    if (v262.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v268 = v266[1];
        if (v268 == v258)
        {
          if (__PAIR64__(*((unsigned __int16 *)v266 + 9), *((unsigned __int16 *)v266 + 8)) == __PAIR64__(WORD1(v258), (unsigned __int16)v258)&& *((_DWORD *)v266 + 5) == HIDWORD(v258))
          {
            goto LABEL_205;
          }
        }
        else if ((v268 & v267) != v263)
        {
          goto LABEL_215;
        }
        uint8x8_t v266 = (void *)*v266;
        if (!v266) {
          goto LABEL_215;
        }
      }
    }
    while (2)
    {
      unint64_t v269 = v266[1];
      if (v269 != v258)
      {
        if (v269 >= *(void *)&v261) {
          v269 %= *(void *)&v261;
        }
        if (v269 != v263) {
          goto LABEL_215;
        }
        goto LABEL_208;
      }
      if (__PAIR64__(*((unsigned __int16 *)v266 + 9), *((unsigned __int16 *)v266 + 8)) != __PAIR64__(WORD1(v258), (unsigned __int16)v258)|| *((_DWORD *)v266 + 5) != HIDWORD(v258))
      {
LABEL_208:
        uint8x8_t v266 = (void *)*v266;
        if (!v266) {
          goto LABEL_215;
        }
        continue;
      }
      break;
    }
LABEL_205:
    if (v262.u32[0] > 1uLL)
    {
      if (v258 >= *(void *)&v261) {
        v258 %= *(void *)&v261;
      }
    }
    else
    {
      v258 &= v267;
    }
    uint64_t v530 = v266[3];
    uint64_t v306 = *(void **)(v264 + 8 * v258);
    do
    {
      uint64_t v307 = v306;
      uint64_t v306 = (void *)*v306;
    }
    while (v306 != v266);
    if (v307 == (void *)(a1 + 144)) {
      goto LABEL_271;
    }
    unint64_t v308 = v307[1];
    if (v262.u32[0] > 1uLL)
    {
      if (v308 >= *(void *)&v261) {
        v308 %= *(void *)&v261;
      }
    }
    else
    {
      v308 &= v267;
    }
    if (v308 != v258)
    {
LABEL_271:
      if (!*v266) {
        goto LABEL_272;
      }
      unint64_t v309 = *(void *)(*v266 + 8);
      if (v262.u32[0] > 1uLL)
      {
        if (v309 >= *(void *)&v261) {
          v309 %= *(void *)&v261;
        }
      }
      else
      {
        v309 &= v267;
      }
      if (v309 != v258) {
LABEL_272:
      }
        *(void *)(v264 + 8 * v258) = 0;
    }
    uint64_t v310 = *v266;
    if (*v266)
    {
      unint64_t v311 = *(void *)(v310 + 8);
      if (v262.u32[0] > 1uLL)
      {
        if (v311 >= *(void *)&v261) {
          v311 %= *(void *)&v261;
        }
      }
      else
      {
        v311 &= v267;
      }
      if (v311 != v258)
      {
        *(void *)(*(void *)(a1 + 128) + 8 * v311) = v307;
        uint64_t v310 = *v266;
      }
    }
    *uint64_t v307 = v310;
    --*(void *)(a1 + 152);
    operator delete(v266);
    std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::Entity>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::Entity>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::Entity>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::Entity>>>::__emplace_unique_key_args<gdc::Entity,std::piecewise_construct_t const&,std::tuple<gdc::Entity const&>,std::tuple<>>((float *)v531, v570, &v570)[3] = v530;
    if (!v560) {
      goto LABEL_189;
    }
    uint64_t v271 = 0;
    uint64_t v272 = 0;
    BOOL v273 = v528;
    do
    {
      long long v580 = xmmword_1A28FCEA0;
      long long v581 = xmmword_1A28FCEA0;
      long long v582 = xmmword_1A28FCFB0;
      long long v583 = xmmword_1A28FCFC0;
      long long v584 = xmmword_1A28FCFD0;
      long long v585 = xmmword_1A28FCFE0;
      long long v586 = xmmword_1A28FCFF0;
      long long v587 = xmmword_1A28FD000;
      long long v588 = xmmword_1A28FD010;
      uint64_t v589 = 0x3E8483EDBF7746EDLL;
      int v590 = 0;
      unint64_t v274 = &__p_8[v271 - 1];
      unint64_t v275 = *(void **)((char *)&v580 + v272);
      v276.i32[0] = *(v273 - 1);
      *((_DWORD *)v274 + 2) = *(_DWORD *)((char *)&v580 + v272 + 8);
      *unint64_t v274 = v275;
      long long v580 = xmmword_1A28FCEA0;
      long long v581 = xmmword_1A28FCEA0;
      long long v582 = xmmword_1A28FCFB0;
      long long v583 = xmmword_1A28FCFC0;
      long long v584 = xmmword_1A28FCFD0;
      long long v585 = xmmword_1A28FCFE0;
      long long v586 = xmmword_1A28FCFF0;
      long long v587 = xmmword_1A28FD000;
      long long v588 = xmmword_1A28FD010;
      uint64_t v589 = 0x3E8483EDBF7746EDLL;
      int v590 = 0;
      v276.i32[1] = *(_DWORD *)((char *)&v580 + v272);
      int v277 = *v273;
      v273 += 2;
      v276.i64[1] = *(void *)((char *)&v580 + v272 + 4);
      *(float32x4_t *)((char *)v274 + 12) = vnegq_f32(v276);
      *((_DWORD *)v274 + 7) = v277;
      v272 += 12;
      v271 += 4;
    }
    while (v272 != 156);
    uint64_t v278 = 0;
    float v279 = 0.0;
    float v280 = 3.4028e38;
    while (2)
    {
      _D4 = *(float32x2_t *)((char *)&__p_8[v278 - 1] + 4);
      float32x2_t v282 = vmul_f32(_D4, v256);
      float v283 = (float)(v282.f32[0] + (float)(*(float *)&__p_8[v278 - 1] * v255)) + v282.f32[1];
      __asm { FMLA            S3, S8, V4.S[1] }
      BOOL v285 = v283 <= 0.0;
      if (v283 == 0.0)
      {
        if (_S3 < 0.0) {
          goto LABEL_189;
        }
        goto LABEL_225;
      }
      float v286 = (float)-_S3 / v283;
      if (v285)
      {
        float v280 = fminf(v286, v280);
        if (v279 > v280) {
          goto LABEL_189;
        }
      }
      else
      {
        float v279 = fmaxf(v279, v286);
LABEL_225:
        if (v279 > v280) {
          goto LABEL_189;
        }
      }
      v278 += 2;
      if (v278 != 52) {
        continue;
      }
      break;
    }
    uint64_t v287 = (void *)gdc::Registry::storage<arComponents::DidIntersectRaycast>(*(int8x8_t **)(a1 + 120));
    v591[0] = v530;
    unint64_t v288 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v287 + 4, (uint64_t)v591);
    if ((v289 & 1) == 0)
    {
      uint64_t v290 = v287[31];
      if (v287[10] + (((uint64_t)v288 - v287[7]) >> 3) == v287[11]) {
        goto LABEL_252;
      }
      for (iuint64_t i = (void *)v287[16]; ii; iuint64_t i = (void *)*ii)
      {
        *(double *)&std::string __p = COERCE_DOUBLE(v591);
        __p_8[0] = (void *)1;
        *(void *)&long long v580 = v290;
        uint64_t v292 = ii[6];
        if (!v292) {
          goto LABEL_531;
        }
        (*(void (**)(uint64_t, long long *, double **))(*(void *)v292 + 48))(v292, &v580, &__p);
      }
LABEL_189:
      v257 += 42;
      ++v253;
      v528 += 42;
      if (v253 == v526) {
        goto LABEL_281;
      }
      continue;
    }
    break;
  }
  unint64_t v294 = (unsigned char *)v287[11];
  unint64_t v293 = v287[12];
  if ((unint64_t)v294 >= v293)
  {
    int8x16x2_t v296 = (char *)v287[10];
    uint64_t v297 = v294 - v296;
    uint64_t v298 = v294 - v296 + 1;
    if (v298 < 0) {
      abort();
    }
    unint64_t v299 = v293 - (void)v296;
    if (2 * v299 > v298) {
      uint64_t v298 = 2 * v299;
    }
    if (v299 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v300 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v300 = v298;
    }
    if (v300) {
      size_t v301 = (char *)operator new(v300);
    }
    else {
      size_t v301 = 0;
    }
    size_t v302 = &v301[v297];
    uint64_t v295 = (uint64_t)&v301[v297 + 1];
    size_t v303 = (char *)(v296 - v294);
    if (v296 == v294) {
      size_t v303 = 0;
    }
    v287[10] = &v303[(void)v302];
    v287[11] = v295;
    v287[12] = &v301[v300];
    if (v296) {
      operator delete(v296);
    }
  }
  else
  {
    uint64_t v295 = (uint64_t)(v294 + 1);
  }
  v287[11] = v295;
  uint64_t v290 = v287[31];
LABEL_252:
  uint64_t v304 = (void *)v287[22];
  if (!v304) {
    goto LABEL_189;
  }
  while (1)
  {
    *(double *)&std::string __p = COERCE_DOUBLE(v591);
    __p_8[0] = (void *)1;
    *(void *)&long long v580 = v290;
    uint64_t v305 = v304[6];
    if (!v305) {
      break;
    }
    (*(void (**)(uint64_t, long long *, double **))(*(void *)v305 + 48))(v305, &v580, &__p);
    uint64_t v304 = (void *)*v304;
    if (!v304) {
      goto LABEL_189;
    }
  }
LABEL_531:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_536:
  __break(1u);
}

void sub_1A255F0F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,void *a43)
{
  if (__p) {
    operator delete(__p);
  }
  double v44 = a43;
  if (a43)
  {
    do
    {
      unint64_t v45 = (void *)*v44;
      operator delete(v44);
      double v44 = v45;
    }
    while (v45);
  }
  if (a41) {
    operator delete(a41);
  }

  _Unwind_Resume(a1);
}

void md::ARWorldIntersectorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::ResolvedDependencies const&,md::ARWorldIntersectorContext &)::$_0::operator()(int64x2_t ***a1, float32x2_t *a2, long long *a3)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  float64x2_t v4 = vcvtq_f64_f32(a2[1]);
  v36[0] = vcvtq_f64_f32(*a2);
  v36[1] = v4;
  v36[2] = vcvtq_f64_f32(a2[2]);
  double v5 = *((double *)a3 + 4);
  v4.f64[0] = *((float64_t *)a3 + 5);
  double v6 = v5 + v5;
  double v7 = (v5 + v5) * v5;
  float64_t v8 = (v4.f64[0] + v4.f64[0]) * v4.f64[0];
  uint64_t v10 = *((void *)a3 + 2);
  double v9 = *((double *)a3 + 3);
  double v11 = (v9 + v9) * v5;
  double v12 = *((double *)a3 + 6);
  uint64_t v13 = (void (**)(void **, double))*((void *)a3 + 7);
  float64_t v14 = (v4.f64[0] + v4.f64[0]) * v12;
  float64_t v15 = v4.f64[0] * (v9 + v9);
  double v16 = 1.0 - (v9 + v9) * v9;
  v4.f64[0] = v6 * v4.f64[0];
  *(double *)v37.i64 = 1.0 - (v7 + v8);
  *(double *)&v37.i64[1] = v14 + v11;
  *(double *)v39.i64 = v11 - v14;
  *(double *)&v39.i64[1] = v16 - v8;
  double v42 = v12 * v6 + v15;
  double v43 = v4.f64[0] - v12 * (v9 + v9);
  long long v38 = COERCE_UNSIGNED_INT64(v15 - v12 * v6);
  double v40 = v12 * (v9 + v9) + v4.f64[0];
  double v44 = v16 - v7;
  uint64_t v41 = 0;
  uint64_t v45 = 0;
  long long v46 = *a3;
  uint64_t v47 = v10;
  uint64_t v48 = 0x3FF0000000000000;
  long long v52 = 0u;
  long long v54 = 0u;
  long long v56 = 0u;
  long long v55 = 0u;
  long long v53 = 0u;
  long long v51 = 0u;
  long long v50 = 0u;
  uint64_t v57 = 0x3FF0000000000000;
  uint64_t v17 = *((void *)a3 + 8);
  v4.f64[0] = *((float64_t *)a3 + 9);
  uint64_t v49 = v13;
  *(void *)&long long v52 = v17;
  *((void *)&v54 + 1) = *(void *)&v4.f64[0];
  gm::operator*<double,4,4,4>(v35, (double *)v37.i64, (double *)&v49);
  int64x2_t v37 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  long long v38 = xmmword_1A28FC720;
  int64x2_t v39 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  uint64_t v49 = (void (**)(void **, double))&unk_1EF57D5A8;
  *(void *)&long long v50 = &v37;
  *((void *)&v50 + 1) = v35;
  *(void *)&long long v51 = &v49;
  double v18 = gm::Box<double,3>::forEachCorner((uint64_t)v36, (uint64_t)&v49);
  if ((void (***)(void **, double))v51 == &v49)
  {
    v49[4]((void **)&v49, v18);
  }
  else if ((void)v51)
  {
    (*(void (**)(void, double))(*(void *)v51 + 40))(v51, v18);
  }
  uint64_t v19 = *a1;
  char v21 = (*a1)[1];
  unint64_t v20 = (unint64_t)v19[2];
  if ((unint64_t)v21 >= v20)
  {
    unint64_t v25 = *v19;
    unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * (v21 - *v19);
    unint64_t v27 = v26 + 1;
    if (v26 + 1 > 0x555555555555555) {
      abort();
    }
    unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - (void)v25) >> 4);
    if (2 * v28 > v27) {
      unint64_t v27 = 2 * v28;
    }
    if (v28 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v29 = 0x555555555555555;
    }
    else {
      unint64_t v29 = v27;
    }
    if (v29)
    {
      if (v29 > 0x555555555555555) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v30 = (char *)operator new(48 * v29);
    }
    else
    {
      uint64_t v30 = 0;
    }
    uint64_t v31 = (int64x2_t *)&v30[48 * v26];
    long long v32 = v38;
    *uint64_t v31 = v37;
    v31[1] = (int64x2_t)v32;
    v31[2] = v39;
    uint64_t v24 = v31 + 3;
    if (v21 != v25)
    {
      do
      {
        int64x2_t v33 = v21[-3];
        int64x2_t v34 = v21[-1];
        v31[-2] = v21[-2];
        v31[-1] = v34;
        v31[-3] = v33;
        v31 -= 3;
        v21 -= 3;
      }
      while (v21 != v25);
      char v21 = *v19;
    }
    *uint64_t v19 = v31;
    v19[1] = v24;
    v19[2] = (int64x2_t *)&v30[48 * v29];
    if (v21) {
      operator delete(v21);
    }
  }
  else
  {
    int64x2_t v22 = v37;
    int64x2_t v23 = v39;
    v21[1] = (int64x2_t)v38;
    v21[2] = v23;
    *char v21 = v22;
    uint64_t v24 = v21 + 3;
  }
  v19[1] = v24;
}

uint64_t std::default_delete<md::ARWorldIntersector>::operator()[abi:nn180100](uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void **)(result + 104);
    if (v2)
    {
      *(void *)(v1 + 112) = v2;
      operator delete(v2);
    }
    float64x2_t v3 = *(std::__shared_weak_count **)(v1 + 96);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    float64x2_t v4 = *(void **)(v1 + 64);
    if (v4)
    {
      do
      {
        double v7 = (void *)*v4;
        uint64_t v8 = v4[3];
        if (v8)
        {
          uint64_t v9 = v4[4];
          double v6 = (void *)v4[3];
          if (v9 != v8)
          {
            do
            {
              if (*(unsigned char *)(v9 - 8))
              {
                uint64_t v10 = *(void **)(v9 - 32);
                if (v10)
                {
                  *(void *)(v9 - 24) = v10;
                  operator delete(v10);
                }
              }
              if (*(unsigned char *)(v9 - 40))
              {
                double v11 = *(void **)(v9 - 64);
                if (v11)
                {
                  *(void *)(v9 - 56) = v11;
                  operator delete(v11);
                }
              }
              v9 -= 168;
            }
            while (v9 != v8);
            double v6 = (void *)v4[3];
          }
          v4[4] = v8;
          operator delete(v6);
        }
        operator delete(v4);
        float64x2_t v4 = v7;
      }
      while (v7);
    }
    double v5 = *(void **)(v1 + 48);
    *(void *)(v1 + 48) = 0;
    if (v5) {
      operator delete(v5);
    }
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(v1 + 32));
    std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(v1 + 8));
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void md::ARWorldIntersectorLogic::generateDebugAvoidancesIntersections(md::CameraContext const&,md::GeometryContext const&,md::ARWorldIntersectorContext &,BOOL)::$_0::operator()(uint64_t a1, unint64_t a2, float32x2_t *a3, double *a4)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  unint64_t v62 = a2;
  uint64_t v5 = *(void *)(a1 + 8);
  float64x2_t v6 = vcvtq_f64_f32(a3[1]);
  v61[0] = vcvtq_f64_f32(*a3);
  v61[1] = v6;
  v61[2] = vcvtq_f64_f32(a3[2]);
  double v7 = a4[4];
  v6.f64[0] = a4[5];
  double v8 = v7 + v7;
  double v9 = (v7 + v7) * v7;
  float64_t v10 = (v6.f64[0] + v6.f64[0]) * v6.f64[0];
  uint64_t v12 = *((void *)a4 + 2);
  double v11 = a4[3];
  double v13 = (v11 + v11) * v7;
  double v14 = a4[6];
  uint64_t v15 = *((void *)a4 + 7);
  float64_t v16 = (v6.f64[0] + v6.f64[0]) * v14;
  float64_t v17 = v6.f64[0] * (v11 + v11);
  double v18 = 1.0 - (v11 + v11) * v11;
  v6.f64[0] = v8 * v6.f64[0];
  *(double *)v63.i64 = 1.0 - (v9 + v10);
  *(double *)&v63.i64[1] = v16 + v13;
  *(double *)v65.i64 = v13 - v16;
  *(double *)&v65.i64[1] = v18 - v10;
  double v68 = v14 * v8 + v17;
  double v69 = v6.f64[0] - v14 * (v11 + v11);
  long long v64 = COERCE_UNSIGNED_INT64(v17 - v14 * v8);
  double v66 = v14 * (v11 + v11) + v6.f64[0];
  double v70 = v18 - v9;
  uint64_t v67 = 0;
  uint64_t v71 = 0;
  long long v72 = *(_OWORD *)a4;
  uint64_t v73 = v12;
  uint64_t v74 = 0x3FF0000000000000;
  *(_OWORD *)&v75[40] = 0u;
  long long v77 = 0u;
  long long v79 = 0u;
  long long v78 = 0u;
  long long v76 = 0u;
  memset(&v75[8], 0, 32);
  uint64_t v80 = 0x3FF0000000000000;
  uint64_t v19 = *((void *)a4 + 8);
  v6.f64[0] = a4[9];
  *(void *)uint64_t v75 = v15;
  *(void *)&v75[40] = v19;
  *((void *)&v77 + 1) = *(void *)&v6.f64[0];
  gm::operator*<double,4,4,4>(v60, (double *)v63.i64, (double *)v75);
  int64x2_t v63 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  long long v64 = xmmword_1A28FC720;
  int64x2_t v65 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  *(void *)uint64_t v75 = &unk_1EF57D5A8;
  *(void *)&v75[8] = &v63;
  *(void *)&v75[16] = v60;
  *(void *)&v75[24] = v75;
  double v20 = gm::Box<double,3>::forEachCorner((uint64_t)v61, (uint64_t)v75);
  if (*(unsigned char **)&v75[24] == v75)
  {
    (*(void (**)(unsigned char *, double))(*(void *)v75 + 32))(v75, v20);
  }
  else if (*(void *)&v75[24])
  {
    (*(void (**)(double))(**(void **)&v75[24] + 40))(v20);
  }
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  if (!geo::Intersect::encloses<double>(*(double **)a1, (double *)v63.i64)) {
    return;
  }
  unint64_t v21 = v62;
  int8x8_t v22 = *(int8x8_t *)(v5 + 136);
  if (!*(void *)&v22) {
    goto LABEL_30;
  }
  uint8x8_t v23 = (uint8x8_t)vcnt_s8(v22);
  v23.i16[0] = vaddlv_u8(v23);
  if (v23.u32[0] > 1uLL)
  {
    unint64_t v24 = v62;
    if (v62 >= *(void *)&v22) {
      unint64_t v24 = v62 % *(void *)&v22;
    }
  }
  else
  {
    unint64_t v24 = (*(void *)&v22 - 1) & v62;
  }
  uint64_t v25 = *(void *)(v5 + 128);
  unint64_t v26 = *(void ***)(v25 + 8 * v24);
  if (!v26 || (unint64_t v27 = *v26) == 0) {
LABEL_30:
  }
    gdc::Registry::create(*(gdc::Registry **)(v5 + 120));
  uint64_t v28 = *(void *)&v22 - 1;
  if (v23.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v29 = v27[1];
      if (v29 == v62)
      {
        if (__PAIR64__(*((unsigned __int16 *)v27 + 9), *((unsigned __int16 *)v27 + 8)) == __PAIR64__(WORD1(v62), (unsigned __int16)v62)&& *((_DWORD *)v27 + 5) == HIDWORD(v62))
        {
          goto LABEL_20;
        }
      }
      else if ((v29 & v28) != v24)
      {
        goto LABEL_30;
      }
      unint64_t v27 = (void *)*v27;
      if (!v27) {
        goto LABEL_30;
      }
    }
  }
  while (1)
  {
    unint64_t v31 = v27[1];
    if (v31 == v62) {
      break;
    }
    if (v31 >= *(void *)&v22) {
      v31 %= *(void *)&v22;
    }
    if (v31 != v24) {
      goto LABEL_30;
    }
LABEL_23:
    unint64_t v27 = (void *)*v27;
    if (!v27) {
      goto LABEL_30;
    }
  }
  if (__PAIR64__(*((unsigned __int16 *)v27 + 9), *((unsigned __int16 *)v27 + 8)) != __PAIR64__(WORD1(v62), (unsigned __int16)v62)|| *((_DWORD *)v27 + 5) != HIDWORD(v62))
  {
    goto LABEL_23;
  }
LABEL_20:
  uint64_t v30 = v27[3];
  if (v23.u32[0] > 1uLL)
  {
    if (v62 >= *(void *)&v22) {
      unint64_t v21 = v62 % *(void *)&v22;
    }
  }
  else
  {
    unint64_t v21 = v28 & v62;
  }
  long long v52 = *(void **)(v25 + 8 * v21);
  do
  {
    long long v53 = v52;
    long long v52 = (void *)*v52;
  }
  while (v52 != v27);
  if (v53 == (void *)(v5 + 144)) {
    goto LABEL_74;
  }
  unint64_t v54 = v53[1];
  if (v23.u32[0] > 1uLL)
  {
    if (v54 >= *(void *)&v22) {
      v54 %= *(void *)&v22;
    }
  }
  else
  {
    v54 &= v28;
  }
  if (v54 != v21)
  {
LABEL_74:
    if (!*v27) {
      goto LABEL_75;
    }
    unint64_t v55 = *(void *)(*v27 + 8);
    if (v23.u32[0] > 1uLL)
    {
      if (v55 >= *(void *)&v22) {
        v55 %= *(void *)&v22;
      }
    }
    else
    {
      v55 &= v28;
    }
    if (v55 != v21) {
LABEL_75:
    }
      *(void *)(v25 + 8 * v21) = 0;
  }
  uint64_t v56 = *v27;
  if (*v27)
  {
    unint64_t v57 = *(void *)(v56 + 8);
    if (v23.u32[0] > 1uLL)
    {
      if (v57 >= *(void *)&v22) {
        v57 %= *(void *)&v22;
      }
    }
    else
    {
      v57 &= v28;
    }
    if (v57 != v21)
    {
      *(void *)(*(void *)(v5 + 128) + 8 * v57) = v53;
      uint64_t v56 = *v27;
    }
  }
  *long long v53 = v56;
  *unint64_t v27 = 0;
  --*(void *)(v5 + 152);
  operator delete(v27);
  std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::Entity>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::Entity>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::Entity>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::Entity>>>::__emplace_unique_key_args<gdc::Entity,std::piecewise_construct_t const&,std::tuple<gdc::Entity const&>,std::tuple<>>(*(float **)(a1 + 16), v62, &v62)[3] = v30;
  if (!**(unsigned char **)(a1 + 24)) {
    return;
  }
  long long v32 = *(double **)(a1 + 32);
  *(int64x2_t *)uint64_t v75 = v63;
  *(_OWORD *)&v75[16] = v64;
  *(int64x2_t *)&v75[32] = v65;
  if (!gm::Ray<double,3>::segmentIntersectsBox(v32, (double *)v75, (double *)&v59, (double *)&v58, 1.79769313e308)) {
    return;
  }
  int64x2_t v33 = (double *)gdc::Registry::storage<arComponents::DidIntersectRaycast>(*(int8x8_t **)(v5 + 120));
  *(void *)&v61[0] = v30;
  int64x2_t v34 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert((void *)v33 + 4, (uint64_t)v61);
  if (v35)
  {
    double v40 = (unsigned char *)*((void *)v33 + 11);
    unint64_t v39 = *((void *)v33 + 12);
    if ((unint64_t)v40 >= v39)
    {
      double v42 = (char *)*((void *)v33 + 10);
      uint64_t v43 = v40 - v42;
      uint64_t v44 = v40 - v42 + 1;
      if (v44 < 0) {
        abort();
      }
      unint64_t v45 = v39 - (void)v42;
      if (2 * v45 > v44) {
        uint64_t v44 = 2 * v45;
      }
      if (v45 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v46 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v46 = v44;
      }
      if (v46) {
        uint64_t v47 = (char *)operator new(v46);
      }
      else {
        uint64_t v47 = 0;
      }
      uint64_t v48 = &v47[v46];
      uint64_t v41 = (uint64_t)&v47[v43 + 1];
      uint64_t v49 = (char *)(v42 - v40);
      if (v42 == v40) {
        uint64_t v49 = 0;
      }
      *((void *)v33 + 10) = &v47[v43 + (void)v49];
      *((void *)v33 + 11) = v41;
      *((void *)v33 + 12) = v48;
      if (v42) {
        operator delete(v42);
      }
    }
    else
    {
      uint64_t v41 = (uint64_t)(v40 + 1);
    }
    *((void *)v33 + 11) = v41;
    double v36 = v33[31];
  }
  else
  {
    double v36 = v33[31];
    if (*((void *)v33 + 10) + (((uint64_t)v34 - *((void *)v33 + 7)) >> 3) != *((void *)v33 + 11))
    {
      int64x2_t v37 = (void *)*((void *)v33 + 16);
      if (v37)
      {
        while (1)
        {
          *(void *)uint64_t v75 = v61;
          *(void *)&v75[8] = 1;
          v60[0] = v36;
          uint64_t v38 = v37[6];
          if (!v38) {
            break;
          }
          (*(void (**)(uint64_t, double *, unsigned char *))(*(void *)v38 + 48))(v38, v60, v75);
          int64x2_t v37 = (void *)*v37;
          if (!v37) {
            return;
          }
        }
        goto LABEL_84;
      }
      return;
    }
  }
  long long v50 = (void *)*((void *)v33 + 22);
  if (v50)
  {
    while (1)
    {
      *(void *)uint64_t v75 = v61;
      *(void *)&v75[8] = 1;
      v60[0] = v36;
      uint64_t v51 = v50[6];
      if (!v51) {
        break;
      }
      (*(void (**)(uint64_t, double *, unsigned char *))(*(void *)v51 + 48))(v51, v60, v75);
      long long v50 = (void *)*v50;
      if (!v50) {
        return;
      }
    }
LABEL_84:
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
}

void *std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::Entity>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::Entity>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::Entity>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::Entity>>>::__emplace_unique_key_args<gdc::Entity,std::piecewise_construct_t const&,std::tuple<gdc::Entity const&>,std::tuple<>>(float *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    double v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      float64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (__PAIR64__(*((unsigned __int16 *)v10 + 9), *((unsigned __int16 *)v10 + 8)) == __PAIR64__(WORD1(a2), (unsigned __int16)a2)&& *((_DWORD *)v10 + 5) == HIDWORD(a2))
              {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_25;
            }
            float64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_25;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (__PAIR64__(*((unsigned __int16 *)v10 + 9), *((unsigned __int16 *)v10 + 8)) == __PAIR64__(WORD1(a2), (unsigned __int16)a2)&& *((_DWORD *)v10 + 5) == HIDWORD(a2))
            {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          float64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_25:
  float64_t v10 = operator new(0x20uLL);
  *float64_t v10 = 0;
  v10[1] = v5;
  void v10[2] = *a3;
  v10[3] = 0xFFFFFFFF00000000;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
    goto LABEL_75;
  }
  BOOL v15 = 1;
  if (v7 >= 3) {
    BOOL v15 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v16 = v15 | (2 * v7);
  unint64_t v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17) {
    size_t prime = v17;
  }
  else {
    size_t prime = v16;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v7 = *((void *)a1 + 1);
  }
  if (prime > v7)
  {
LABEL_38:
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v19 = operator new(8 * prime);
    double v20 = *(void **)a1;
    *(void *)a1 = v19;
    if (v20) {
      operator delete(v20);
    }
    uint64_t v21 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v21++) = 0;
    while (prime != v21);
    uint8x8_t v23 = (uint64_t *)(a1 + 4);
    int8x8_t v22 = (void *)*((void *)a1 + 2);
    if (!v22) {
      goto LABEL_62;
    }
    size_t v24 = v22[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*(void *)a1 + 8 * v26) = v23;
      for (uint64_t i = (void *)*v22; *v22; uint64_t i = (void *)*v22)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          int8x8_t v22 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v28))
        {
          *int8x8_t v22 = *i;
          uint64_t v29 = 8 * v28;
          void *i = **(void **)(*(void *)a1 + v29);
          **(void **)(*(void *)a1 + v29) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v28) = v22;
          int8x8_t v22 = i;
          size_t v26 = v28;
        }
      }
LABEL_62:
      unint64_t v7 = prime;
      goto LABEL_63;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v24) = v23;
    int64x2_t v33 = (void *)*v22;
    if (!*v22) {
      goto LABEL_62;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*(void *)a1 + 8 * v35))
        {
          *(void *)(*(void *)a1 + 8 * v35) = v22;
          goto LABEL_67;
        }
        *int8x8_t v22 = *v33;
        uint64_t v34 = 8 * v35;
        *int64x2_t v33 = **(void **)(*(void *)a1 + v34);
        **(void **)(*(void *)a1 + v34) = v33;
        int64x2_t v33 = v22;
      }
      size_t v35 = v24;
LABEL_67:
      int8x8_t v22 = v33;
      int64x2_t v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_62;
      }
    }
  }
  if (prime >= v7) {
    goto LABEL_63;
  }
  unint64_t v30 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
  if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
  {
    unint64_t v30 = std::__next_prime(v30);
  }
  else
  {
    uint64_t v32 = 1 << -(char)__clz(v30 - 1);
    if (v30 >= 2) {
      unint64_t v30 = v32;
    }
  }
  if (prime <= v30) {
    size_t prime = v30;
  }
  if (prime < v7)
  {
    if (!prime)
    {
      double v40 = *(void **)a1;
      *(void *)a1 = 0;
      if (v40) {
        operator delete(v40);
      }
      unint64_t v7 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_63;
    }
    goto LABEL_38;
  }
  unint64_t v7 = *((void *)a1 + 1);
LABEL_63:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_75:
  double v36 = *(void **)a1;
  int64x2_t v37 = *(void **)(*(void *)a1 + 8 * v5);
  if (v37)
  {
    *float64_t v10 = *v37;
LABEL_83:
    *int64x2_t v37 = v10;
    goto LABEL_84;
  }
  *float64_t v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v36[v5] = a1 + 4;
  if (*v10)
  {
    unint64_t v38 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    int64x2_t v37 = (void *)(*(void *)a1 + 8 * v38);
    goto LABEL_83;
  }
LABEL_84:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A256063C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<md::ARWorldIntersector *,std::shared_ptr<md::ARWorldIntersector>::__shared_ptr_default_delete<md::ARWorldIntersector,md::ARWorldIntersector>,std::allocator<md::ARWorldIntersector>>::__on_zero_shared(uint64_t a1)
{
  return std::default_delete<md::ARWorldIntersector>::operator()[abi:nn180100](*(void *)(a1 + 24));
}

void std::__shared_ptr_pointer<md::ARWorldIntersector *,std::shared_ptr<md::ARWorldIntersector>::__shared_ptr_default_delete<md::ARWorldIntersector,md::ARWorldIntersector>,std::allocator<md::ARWorldIntersector>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::Logic<md::ARWorldIntersectorLogic,md::ARWorldIntersectorContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

double md::Logic<md::ARWorldIntersectorLogic,md::ARWorldIntersectorContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::allocateContext@<D0>(uint64_t a1@<X8>)
{
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  return result;
}

uint64_t md::Logic<md::ARWorldIntersectorLogic,md::ARWorldIntersectorContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x6DBE9777D7FEDAAELL && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::resolveDependencies(v7, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v7, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

void *md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::resolveDependencies(void *result, uint64_t a2, unint64_t a3)
{
  if (!a3)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    goto LABEL_94;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    uint64_t v4 = 0x1AF456233693CD46;
    if (a3 <= 0x1AF456233693CD46) {
      uint64_t v4 = 0x1AF456233693CD46 % a3;
    }
  }
  else
  {
    uint64_t v4 = (a3 - 1) & 0x1AF456233693CD46;
  }
  uint8x8_t v8 = *(void **)(a2 + 8 * v4);
  if (!v8) {
    goto LABEL_25;
  }
  double v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_25;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v11 = v9[1];
      if (v11 == 0x1AF456233693CD46)
      {
        if (v9[2] == 0x1AF456233693CD46) {
          goto LABEL_23;
        }
      }
      else if ((v11 & (a3 - 1)) != v4)
      {
        goto LABEL_25;
      }
      double v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v9[1];
    if (v10 == 0x1AF456233693CD46) {
      break;
    }
    if (v10 >= a3) {
      v10 %= a3;
    }
    if (v10 != v4) {
      goto LABEL_25;
    }
LABEL_12:
    double v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_25;
    }
  }
  if (v9[2] != 0x1AF456233693CD46) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v12 = v9[5];
  if (*(void *)(v12 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v7 = *(void *)(v12 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v7 = 0;
LABEL_26:
  if (v3.u32[0] > 1uLL)
  {
    uint64_t v13 = 0x3070CB6B3C7F21D3;
    if (a3 <= 0x3070CB6B3C7F21D3) {
      uint64_t v13 = 0x3070CB6B3C7F21D3 % a3;
    }
  }
  else
  {
    uint64_t v13 = (a3 - 1) & 0x3070CB6B3C7F21D3;
  }
  float v14 = *(void **)(a2 + 8 * v13);
  if (!v14) {
    goto LABEL_48;
  }
  BOOL v15 = (void *)*v14;
  if (!v15) {
    goto LABEL_48;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v17 = v15[1];
      if (v17 == 0x3070CB6B3C7F21D3)
      {
        if (v15[2] == 0x3070CB6B3C7F21D3) {
          goto LABEL_46;
        }
      }
      else if ((v17 & (a3 - 1)) != v13)
      {
        goto LABEL_48;
      }
      BOOL v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_48;
      }
    }
  }
  while (2)
  {
    unint64_t v16 = v15[1];
    if (v16 != 0x3070CB6B3C7F21D3)
    {
      if (v16 >= a3) {
        v16 %= a3;
      }
      if (v16 != v13) {
        goto LABEL_48;
      }
      goto LABEL_35;
    }
    if (v15[2] != 0x3070CB6B3C7F21D3)
    {
LABEL_35:
      BOOL v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_48;
      }
      continue;
    }
    break;
  }
LABEL_46:
  uint64_t v18 = v15[5];
  if (*(void *)(v18 + 8) == 0x3070CB6B3C7F21D3)
  {
    uint64_t v6 = *(void *)(v18 + 32);
    goto LABEL_49;
  }
LABEL_48:
  uint64_t v6 = 0;
LABEL_49:
  if (v3.u32[0] > 1uLL)
  {
    uint64_t v19 = 0x18CA739B45F5362ALL;
    if (a3 <= 0x18CA739B45F5362ALL) {
      uint64_t v19 = 0x18CA739B45F5362ALL % a3;
    }
  }
  else
  {
    uint64_t v19 = (a3 - 1) & 0x18CA739B45F5362ALL;
  }
  double v20 = *(void **)(a2 + 8 * v19);
  if (!v20) {
    goto LABEL_71;
  }
  uint64_t v21 = (void *)*v20;
  if (!v21) {
    goto LABEL_71;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v23 = v21[1];
      if (v23 == 0x18CA739B45F5362ALL)
      {
        if (v21[2] == 0x18CA739B45F5362ALL) {
          goto LABEL_69;
        }
      }
      else if ((v23 & (a3 - 1)) != v19)
      {
        goto LABEL_71;
      }
      uint64_t v21 = (void *)*v21;
      if (!v21) {
        goto LABEL_71;
      }
    }
  }
  while (2)
  {
    unint64_t v22 = v21[1];
    if (v22 != 0x18CA739B45F5362ALL)
    {
      if (v22 >= a3) {
        v22 %= a3;
      }
      if (v22 != v19) {
        goto LABEL_71;
      }
      goto LABEL_58;
    }
    if (v21[2] != 0x18CA739B45F5362ALL)
    {
LABEL_58:
      uint64_t v21 = (void *)*v21;
      if (!v21) {
        goto LABEL_71;
      }
      continue;
    }
    break;
  }
LABEL_69:
  uint64_t v24 = v21[5];
  if (*(void *)(v24 + 8) == 0x18CA739B45F5362ALL)
  {
    uint64_t v5 = *(void *)(v24 + 32);
    goto LABEL_72;
  }
LABEL_71:
  uint64_t v5 = 0;
LABEL_72:
  if (v3.u32[0] > 1uLL)
  {
    uint64_t v25 = 0xF9EFCB105DF83E4;
    if (a3 <= 0xF9EFCB105DF83E4) {
      uint64_t v25 = 0xF9EFCB105DF83E4 % a3;
    }
  }
  else
  {
    uint64_t v25 = (a3 - 1) & 0xF9EFCB105DF83E4;
  }
  size_t v26 = *(void **)(a2 + 8 * v25);
  if (!v26) {
    goto LABEL_94;
  }
  unint64_t v27 = (void *)*v26;
  if (!v27) {
    goto LABEL_94;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v29 = v27[1];
      if (v29 == 0xF9EFCB105DF83E4)
      {
        if (v27[2] == 0xF9EFCB105DF83E4) {
          goto LABEL_92;
        }
      }
      else if ((v29 & (a3 - 1)) != v25)
      {
        goto LABEL_94;
      }
      unint64_t v27 = (void *)*v27;
      if (!v27) {
        goto LABEL_94;
      }
    }
  }
  while (1)
  {
    unint64_t v28 = v27[1];
    if (v28 == 0xF9EFCB105DF83E4) {
      break;
    }
    if (v28 >= a3) {
      v28 %= a3;
    }
    if (v28 != v25) {
      goto LABEL_94;
    }
LABEL_81:
    unint64_t v27 = (void *)*v27;
    if (!v27) {
      goto LABEL_94;
    }
  }
  if (v27[2] != 0xF9EFCB105DF83E4) {
    goto LABEL_81;
  }
LABEL_92:
  uint64_t v30 = v27[5];
  if (*(void *)(v30 + 8) != 0xF9EFCB105DF83E4)
  {
LABEL_94:
    uint64_t v31 = 0;
    goto LABEL_95;
  }
  uint64_t v31 = *(void *)(v30 + 32);
LABEL_95:
  *double result = v7;
  result[1] = v6;
  result[2] = v5;
  result[3] = v31;
  return result;
}

uint64_t md::Logic<md::ARWorldIntersectorLogic,md::ARWorldIntersectorContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x6DBE9777D7FEDAAELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::resolveDependencies(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 152))(v5, a2, v6, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARWorldIntersectorLogic,md::ARWorldIntersectorContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x6DBE9777D7FEDAAELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::resolveDependencies(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 144))(v5, a2, v6, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARWorldIntersectorLogic,md::ARWorldIntersectorContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x6DBE9777D7FEDAAELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::resolveDependencies(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 136))(v5, a2, v6, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARWorldIntersectorLogic,md::ARWorldIntersectorContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x6DBE9777D7FEDAAELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>::resolveDependencies(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 128))(v5, a2, v6, v3);
    }
  }
  return result;
}

void md::Logic<md::ARWorldIntersectorLogic,md::ARWorldIntersectorContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext,md::ARAssetOcclusionMeshDataContext>,gdc::TypeList<md::CollectMapDataContext<(md::MapDataType)60>>>>::_allocateContext()
{
}

void sub_1A2560F30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  md::ARWorldIntersectorContext::~ARWorldIntersectorContext((md::ARWorldIntersectorContext *)va);
  MEMORY[0x1A6239270](v2, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

void md::ARWorldIntersectorContext::~ARWorldIntersectorContext(md::ARWorldIntersectorContext *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (void *)*((void *)this + 2);
    if (v3)
    {
      do
      {
LABEL_4:
        uint64_t v4 = (void *)*v3;
        operator delete(v3);
        uint64_t v3 = v4;
      }
      while (v4);
    }
  }
  else
  {
    uint64_t v3 = (void *)*((void *)this + 2);
    if (v3) {
      goto LABEL_4;
    }
  }
  uint64_t v5 = *(void **)this;
  *(void *)this = 0;
  if (v5) {
    operator delete(v5);
  }
}

uint64_t gdc::ObjectHolder<md::ARWorldIntersectorContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ARWorldIntersectorContext>::~ManagedObjectHolder(void *a1)
{
  gdc::ManagedObjectHolder<md::ARWorldIntersectorContext>::~ManagedObjectHolder(a1);
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ARWorldIntersectorContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555AA0;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 48);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    uint64_t v4 = *(void **)(v2 + 16);
    if (v4)
    {
      do
      {
        uint64_t v5 = (void *)*v4;
        operator delete(v4);
        uint64_t v4 = v5;
      }
      while (v5);
    }
    uint64_t v6 = *(void **)v2;
    *(void *)uint64_t v2 = 0;
    if (v6) {
      operator delete(v6);
    }
    MEMORY[0x1A6239270](v2, 0x10A0C407175AC86);
  }
  return a1;
}

void md::ARWorldIntersectorLogic::didBecomeInactive(md::ARWorldIntersectorLogic *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 22);
  *((void *)this + 21) = 0;
  *((void *)this + 22) = 0;
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = v31;
  unint64_t v28 = v31;
  uint64_t v29 = v31;
  unint64_t v30 = 4;
  uint64_t v4 = (void *)*((void *)this + 18);
  if (v4)
  {
    while (1)
    {
      uint64_t v6 = (v3 - v28) >> 3;
      if (v30 < v6 + 1) {
        break;
      }
LABEL_7:
      *(void *)uint64_t v3 = v4[3];
      uint64_t v5 = v29;
      uint64_t v3 = v29 + 8;
      v29 += 8;
      uint64_t v4 = (void *)*v4;
      if (!v4)
      {
        if (v28 != v3)
        {
          uint64_t v21 = *((void *)this + 15);
          unint64_t v22 = v28 - 8;
          do
          {
            unint64_t v23 = *((void *)v22 + 1);
            v22 += 8;
            gdc::Registry::destroy(v21, v23);
          }
          while (v22 != v5);
        }
        goto LABEL_28;
      }
    }
    unint64_t v7 = (1 << -(char)__clz(v30 + 1));
    if (v30 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v7 = 1;
    }
    if (v7 <= v6 + 1) {
      uint64_t v8 = v6 + 1;
    }
    else {
      uint64_t v8 = v7;
    }
    double v9 = (char *)malloc_type_malloc(8 * v8, 0x100004000313F17uLL);
    unint64_t v10 = v9;
    uint64_t v11 = v28;
    if (v28 != v29)
    {
      unint64_t v12 = v29 - v28 - 8;
      if (v12 < 0x18)
      {
        uint64_t v13 = v9;
      }
      else
      {
        uint64_t v13 = v9;
        if ((unint64_t)(v9 - v28) >= 0x20)
        {
          uint64_t v14 = (v12 >> 3) + 1;
          uint64_t v15 = 8 * (v14 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v13 = &v9[v15];
          unint64_t v16 = (long long *)(v28 + 16);
          uint64_t v17 = v9 + 16;
          uint64_t v18 = v14 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v19 = *v16;
            *(v17 - 1) = *(v16 - 1);
            *uint64_t v17 = v19;
            v16 += 2;
            v17 += 2;
            v18 -= 4;
          }
          while (v18);
          if (v14 == (v14 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_23;
          }
          uint64_t v11 = &v28[v15];
        }
      }
      do
      {
        uint64_t v20 = *(void *)v11;
        v11 += 8;
        *(void *)uint64_t v13 = v20;
        v13 += 8;
      }
      while (v11 != v29);
    }
LABEL_23:
    if (v28 != v31) {
      free(v28);
    }
    uint64_t v3 = &v10[8 * v6];
    unint64_t v28 = v10;
    uint64_t v29 = v3;
    unint64_t v30 = v8;
    goto LABEL_7;
  }
LABEL_28:
  if (*((void *)this + 19))
  {
    uint64_t v24 = (void *)*((void *)this + 18);
    if (v24)
    {
      do
      {
        uint64_t v25 = (void *)*v24;
        operator delete(v24);
        uint64_t v24 = v25;
      }
      while (v25);
    }
    *((void *)this + 18) = 0;
    uint64_t v26 = *((void *)this + 17);
    if (v26)
    {
      for (uint64_t i = 0; i != v26; ++i)
        *(void *)(*((void *)this + 16) + 8 * i) = 0;
    }
    *((void *)this + 19) = 0;
  }
  if (v28 != v31) {
    free(v28);
  }
}

void sub_1A256137C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *a11)
{
  if (a9 != a11) {
    free(a9);
  }
  _Unwind_Resume(exception_object);
}

void md::ARWorldIntersectorLogic::~ARWorldIntersectorLogic(md::ARWorldIntersectorLogic *this)
{
  md::ARWorldIntersectorLogic::~ARWorldIntersectorLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  void *v3;
  void *v4;
  void *v5;

  *(void *)this = &unk_1EF542940;
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 272);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 192);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 22);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (void *)*((void *)this + 18);
    if (!v3) {
      goto LABEL_5;
    }
  }
  else
  {
    uint64_t v3 = (void *)*((void *)this + 18);
    if (!v3) {
      goto LABEL_5;
    }
  }
  do
  {
    uint64_t v4 = (void *)*v3;
    operator delete(v3);
    uint64_t v3 = v4;
  }
  while (v4);
LABEL_5:
  uint64_t v5 = (void *)*((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v5) {
    operator delete(v5);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

uint64_t std::__function::__func<md::ARWorldIntersectorLogic::ARWorldIntersectorLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_1,std::allocator<md::ARWorldIntersectorLogic::ARWorldIntersectorLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_1>,void ()(BOOL)>::operator()(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 184) = 1;
  return result;
}

void *std::__function::__func<md::ARWorldIntersectorLogic::ARWorldIntersectorLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_1,std::allocator<md::ARWorldIntersectorLogic::ARWorldIntersectorLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_1>,void ()(BOOL)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EF575EE8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ARWorldIntersectorLogic::ARWorldIntersectorLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_1,std::allocator<md::ARWorldIntersectorLogic::ARWorldIntersectorLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_1>,void ()(BOOL)>::~__func()
{
}

uint64_t std::__function::__func<md::ARWorldIntersectorLogic::ARWorldIntersectorLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::ARWorldIntersectorLogic::ARWorldIntersectorLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,void ()(BOOL)>::operator()(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 184) = 1;
  return result;
}

void *std::__function::__func<md::ARWorldIntersectorLogic::ARWorldIntersectorLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::ARWorldIntersectorLogic::ARWorldIntersectorLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,void ()(BOOL)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EF575EA0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ARWorldIntersectorLogic::ARWorldIntersectorLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::ARWorldIntersectorLogic::ARWorldIntersectorLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,void ()(BOOL)>::~__func()
{
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::createLines(std::shared_ptr<md::LabelLineStore const> const&)::$_0 &,std::unique_ptr<md::LabelLine,mdm::TypeDeleter<md::LabelLine>> *>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      unsigned int v7 = *(unsigned __int8 *)(v6 + 2);
      uint64_t v8 = *a1;
      unsigned int v9 = *(unsigned __int8 *)(*a1 + 2);
      if (v7 != v9)
      {
        if (v7 >= v9) {
          return result;
        }
        goto LABEL_39;
      }
      if (*(unsigned char *)(v6 + 2))
      {
        double v10 = *(double *)(v6 + 104);
        uint64_t v11 = (double *)(v8 + 104);
      }
      else
      {
        double v10 = **(double **)(**(void **)(v6 + 40) + 16);
        uint64_t v11 = *(double **)(**(void **)(v8 + 40) + 16);
      }
      if (v10 > *v11)
      {
LABEL_39:
        *a1 = v6;
        *(a2 - 1) = v8;
        return result;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::createLines(std::shared_ptr<md::LabelLineStore const> const&)::$_0 &,std::unique_ptr<md::LabelLine,mdm::TypeDeleter<md::LabelLine>> *>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::createLines(std::shared_ptr<md::LabelLineStore const> const&)::$_0 &,std::unique_ptr<md::LabelLine,mdm::TypeDeleter<md::LabelLine>> *>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::createLines(std::shared_ptr<md::LabelLineStore const> const&)::$_0 &,std::unique_ptr<md::LabelLine,mdm::TypeDeleter<md::LabelLine>> *,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v12 = (uint64_t)(a1 + 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::createLines(std::shared_ptr<md::LabelLineStore const> const&)::$_0 &,std::unique_ptr<md::LabelLine,mdm::TypeDeleter<md::LabelLine>> *>(a1, a1 + 1, a1 + 2);
      uint64_t v13 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v14 = 0;
      int v15 = 0;
      while (2)
      {
        uint64_t v16 = *v13;
        unsigned int v17 = *(unsigned __int8 *)(*v13 + 2);
        uint64_t v18 = *(void *)v12;
        unsigned int v19 = *(unsigned __int8 *)(*(void *)v12 + 2);
        if (v17 == v19)
        {
          if (*(unsigned char *)(*v13 + 2))
          {
            double v20 = *(double *)(v16 + 104);
            uint64_t v21 = (double *)(v18 + 104);
          }
          else
          {
            double v20 = **(double **)(**(void **)(v16 + 40) + 16);
            uint64_t v21 = *(double **)(**(void **)(v18 + 40) + 16);
          }
          if (v20 <= *v21) {
            goto LABEL_8;
          }
        }
        else if (v17 >= v19)
        {
          goto LABEL_8;
        }
        uint64_t v22 = 0;
        *uint64_t v13 = 0;
        for (uint64_t i = v14; ; i -= 8)
        {
          uint64_t v24 = (char *)a1 + i;
          *((void *)v24 + 2) = 0;
          *((void *)v24 + 3) = v18;
          if (v22) {
            mdm::TypeDeleter<md::LabelLine>::operator()(v22);
          }
          if (i == -16) {
            break;
          }
          unsigned int v25 = *(unsigned __int8 *)(v16 + 2);
          uint64_t v18 = *(uint64_t *)((char *)a1 + i + 8);
          unsigned int v26 = *(unsigned __int8 *)(v18 + 2);
          if (v25 == v26)
          {
            if (*(unsigned char *)(v16 + 2))
            {
              double v27 = *(double *)(v16 + 104);
              unint64_t v28 = (double *)(v18 + 104);
            }
            else
            {
              double v27 = **(double **)(**(void **)(v16 + 40) + 16);
              unint64_t v28 = *(double **)(**(void **)(v18 + 40) + 16);
            }
            if (v27 <= *v28)
            {
              uint64_t v12 = (uint64_t)a1 + i + 16;
              goto LABEL_29;
            }
          }
          else if (v25 >= v26)
          {
            goto LABEL_29;
          }
          v12 -= 8;
          uint64_t v22 = *((void *)v24 + 2);
        }
        uint64_t v12 = (uint64_t)a1;
LABEL_29:
        uint64_t v29 = *(void *)v12;
        *(void *)uint64_t v12 = v16;
        if (v29) {
          mdm::TypeDeleter<md::LabelLine>::operator()(v29);
        }
        if (++v15 != 8)
        {
LABEL_8:
          uint64_t v12 = (uint64_t)v13;
          v14 += 8;
          if (++v13 == a2) {
            return 1;
          }
          continue;
        }
        return v13 + 1 == a2;
      }
  }
}

uint64_t *std::vector<md::SegmentConnectionPoint,geo::StdAllocator<md::SegmentConnectionPoint,mdm::Allocator>>::~vector[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(void *)(v3 - 32);
        if (v5)
        {
          *(void *)(v3 - 24) = v5;
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v3 - 8) + 40))(*(void *)(v3 - 8), v5, *(void *)(v3 - 16) - v5);
        }
        v3 -= 80;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v4, a1[2] - v4);
  }
  return a1;
}

__n128 std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::connectTileLabelLineSegments(std::vector<md::SegmentConnectionEntry,geo::StdAllocator<md::SegmentConnectionEntry,mdm::Allocator>> &,double,std::vector<std::pair<unsigned long,unsigned long>> &)::$_0 &,md::SegmentConnectionEntry*>(_WORD *a1, _WORD *a2, _WORD *a3)
{
  uint64_t v3 = *(void *)(*(void *)a2 + 8);
  uint64_t v4 = *(void *)(*(void *)a1 + 8);
  int v5 = *(unsigned __int8 *)(v3 + 60);
  if ((*(unsigned char *)(v3 + 60) != 0) == (*(unsigned char *)(v4 + 60) != 0))
  {
    if (*(void *)(*(void *)(v3 + 16) + 24) >= *(void *)(*(void *)(v4 + 16) + 24)) {
      goto LABEL_3;
    }
LABEL_7:
    BOOL v8 = v5 != 0;
    uint64_t v9 = *(void *)(*(void *)a3 + 8);
    if (v8 == (*(unsigned char *)(v9 + 60) != 0))
    {
      if (*(void *)(*(void *)(v9 + 16) + 24) >= *(void *)(*(void *)(v3 + 16) + 24)) {
        goto LABEL_9;
      }
    }
    else if (*(unsigned char *)(v9 + 60))
    {
LABEL_9:
      __n128 result = *(__n128 *)a1;
      long long v20 = *(_OWORD *)a1;
      __int16 v11 = a2[4];
      *(void *)a1 = *(void *)a2;
      a1[4] = v11;
      *(void *)a2 = v20;
      a2[4] = WORD4(v20);
      uint64_t v12 = *(void *)(*(void *)a3 + 8);
      uint64_t v13 = *(void *)(*(void *)a2 + 8);
      if ((*(unsigned char *)(v12 + 60) != 0) == (*(unsigned char *)(v13 + 60) != 0))
      {
        if (*(void *)(*(void *)(v12 + 16) + 24) >= *(void *)(*(void *)(v13 + 16) + 24)) {
          return result;
        }
      }
      else if (*(unsigned char *)(v12 + 60))
      {
        return result;
      }
      __n128 result = *(__n128 *)a2;
      long long v22 = *(_OWORD *)a2;
      __int16 v18 = a3[4];
      *(void *)a2 = *(void *)a3;
      a2[4] = v18;
LABEL_20:
      *(void *)a3 = v22;
      a3[4] = WORD4(v22);
      return result;
    }
    __n128 result = *(__n128 *)a1;
    long long v22 = *(_OWORD *)a1;
    __int16 v17 = a3[4];
    *(void *)a1 = *(void *)a3;
    a1[4] = v17;
    goto LABEL_20;
  }
  if (!*(unsigned char *)(v3 + 60)) {
    goto LABEL_7;
  }
LABEL_3:
  BOOL v6 = v5 != 0;
  uint64_t v7 = *(void *)(*(void *)a3 + 8);
  if (v6 == (*(unsigned char *)(v7 + 60) != 0))
  {
    if (*(void *)(*(void *)(v7 + 16) + 24) >= *(void *)(*(void *)(v3 + 16) + 24)) {
      return result;
    }
  }
  else if (*(unsigned char *)(v7 + 60))
  {
    return result;
  }
  __n128 result = *(__n128 *)a2;
  long long v21 = *(_OWORD *)a2;
  __int16 v14 = a3[4];
  *(void *)a2 = *(void *)a3;
  a2[4] = v14;
  *(void *)a3 = v21;
  a3[4] = WORD4(v21);
  uint64_t v15 = *(void *)(*(void *)a2 + 8);
  uint64_t v16 = *(void *)(*(void *)a1 + 8);
  if ((*(unsigned char *)(v15 + 60) != 0) == (*(unsigned char *)(v16 + 60) != 0))
  {
    if (*(void *)(*(void *)(v15 + 16) + 24) < *(void *)(*(void *)(v16 + 16) + 24))
    {
LABEL_22:
      __n128 result = *(__n128 *)a1;
      long long v23 = *(_OWORD *)a1;
      __int16 v19 = a2[4];
      *(void *)a1 = *(void *)a2;
      a1[4] = v19;
      *(void *)a2 = v23;
      a2[4] = WORD4(v23);
    }
  }
  else if (!*(unsigned char *)(v15 + 60))
  {
    goto LABEL_22;
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::connectTileLabelLineSegments(std::vector<md::SegmentConnectionEntry,geo::StdAllocator<md::SegmentConnectionEntry,mdm::Allocator>> &,double,std::vector<std::pair<unsigned long,unsigned long>> &)::$_0 &,md::SegmentConnectionEntry*>(_WORD *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  result.n128_u64[0] = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::connectTileLabelLineSegments(std::vector<md::SegmentConnectionEntry,geo::StdAllocator<md::SegmentConnectionEntry,mdm::Allocator>> &,double,std::vector<std::pair<unsigned long,unsigned long>> &)::$_0 &,md::SegmentConnectionEntry*>(a1, a2, a3).n128_u64[0];
  uint64_t v9 = *(void *)(*(void *)a4 + 8);
  uint64_t v10 = *(void *)(*(void *)a3 + 8);
  if ((*(unsigned char *)(v9 + 60) != 0) == (*(unsigned char *)(v10 + 60) != 0))
  {
    if (*(void *)(*(void *)(v9 + 16) + 24) >= *(void *)(*(void *)(v10 + 16) + 24)) {
      return result;
    }
  }
  else if (*(unsigned char *)(v9 + 60))
  {
    return result;
  }
  __n128 result = *(__n128 *)a3;
  long long v18 = *(_OWORD *)a3;
  __int16 v11 = a4[4];
  *(void *)a3 = *(void *)a4;
  a3[4] = v11;
  *(void *)a4 = v18;
  a4[4] = WORD4(v18);
  uint64_t v12 = *(void *)(*(void *)a3 + 8);
  uint64_t v13 = *(void *)(*(void *)a2 + 8);
  if ((*(unsigned char *)(v12 + 60) != 0) == (*(unsigned char *)(v13 + 60) != 0))
  {
    if (*(void *)(*(void *)(v12 + 16) + 24) >= *(void *)(*(void *)(v13 + 16) + 24)) {
      return result;
    }
  }
  else if (*(unsigned char *)(v12 + 60))
  {
    return result;
  }
  __n128 result = *(__n128 *)a2;
  long long v19 = *(_OWORD *)a2;
  __int16 v14 = a3[4];
  *(void *)a2 = *(void *)a3;
  a2[4] = v14;
  *(void *)a3 = v19;
  a3[4] = WORD4(v19);
  uint64_t v15 = *(void *)(*(void *)a2 + 8);
  uint64_t v16 = *(void *)(*(void *)a1 + 8);
  if ((*(unsigned char *)(v15 + 60) != 0) == (*(unsigned char *)(v16 + 60) != 0))
  {
    if (*(void *)(*(void *)(v15 + 16) + 24) >= *(void *)(*(void *)(v16 + 16) + 24)) {
      return result;
    }
  }
  else if (*(unsigned char *)(v15 + 60))
  {
    return result;
  }
  __n128 result = *(__n128 *)a1;
  long long v20 = *(_OWORD *)a1;
  __int16 v17 = a2[4];
  *(void *)a1 = *(void *)a2;
  a1[4] = v17;
  *(void *)a2 = v20;
  a2[4] = WORD4(v20);
  return result;
}

__n128 std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::connectTileLabelLineSegments(std::vector<md::SegmentConnectionEntry,geo::StdAllocator<md::SegmentConnectionEntry,mdm::Allocator>> &,double,std::vector<std::pair<unsigned long,unsigned long>> &)::$_0 &,md::SegmentConnectionEntry*,0>(_WORD *a1, _WORD *a2, _WORD *a3, _WORD *a4, _WORD *a5)
{
  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::connectTileLabelLineSegments(std::vector<md::SegmentConnectionEntry,geo::StdAllocator<md::SegmentConnectionEntry,mdm::Allocator>> &,double,std::vector<std::pair<unsigned long,unsigned long>> &)::$_0 &,md::SegmentConnectionEntry*>(a1, a2, a3, a4).n128_u64[0];
  uint64_t v11 = *(void *)(*(void *)a5 + 8);
  uint64_t v12 = *(void *)(*(void *)a4 + 8);
  if ((*(unsigned char *)(v11 + 60) != 0) == (*(unsigned char *)(v12 + 60) != 0))
  {
    if (*(void *)(*(void *)(v11 + 16) + 24) >= *(void *)(*(void *)(v12 + 16) + 24)) {
      return result;
    }
  }
  else if (*(unsigned char *)(v11 + 60))
  {
    return result;
  }
  __n128 result = *(__n128 *)a4;
  long long v23 = *(_OWORD *)a4;
  __int16 v13 = a5[4];
  *(void *)a4 = *(void *)a5;
  a4[4] = v13;
  *(void *)a5 = v23;
  a5[4] = WORD4(v23);
  uint64_t v14 = *(void *)(*(void *)a4 + 8);
  uint64_t v15 = *(void *)(*(void *)a3 + 8);
  if ((*(unsigned char *)(v14 + 60) != 0) == (*(unsigned char *)(v15 + 60) != 0))
  {
    if (*(void *)(*(void *)(v14 + 16) + 24) >= *(void *)(*(void *)(v15 + 16) + 24)) {
      return result;
    }
  }
  else if (*(unsigned char *)(v14 + 60))
  {
    return result;
  }
  __n128 result = *(__n128 *)a3;
  long long v24 = *(_OWORD *)a3;
  __int16 v16 = a4[4];
  *(void *)a3 = *(void *)a4;
  a3[4] = v16;
  *(void *)a4 = v24;
  a4[4] = WORD4(v24);
  uint64_t v17 = *(void *)(*(void *)a3 + 8);
  uint64_t v18 = *(void *)(*(void *)a2 + 8);
  if ((*(unsigned char *)(v17 + 60) != 0) == (*(unsigned char *)(v18 + 60) != 0))
  {
    if (*(void *)(*(void *)(v17 + 16) + 24) >= *(void *)(*(void *)(v18 + 16) + 24)) {
      return result;
    }
  }
  else if (*(unsigned char *)(v17 + 60))
  {
    return result;
  }
  __n128 result = *(__n128 *)a2;
  long long v25 = *(_OWORD *)a2;
  __int16 v19 = a3[4];
  *(void *)a2 = *(void *)a3;
  a2[4] = v19;
  *(void *)a3 = v25;
  a3[4] = WORD4(v25);
  uint64_t v20 = *(void *)(*(void *)a2 + 8);
  uint64_t v21 = *(void *)(*(void *)a1 + 8);
  if ((*(unsigned char *)(v20 + 60) != 0) == (*(unsigned char *)(v21 + 60) != 0))
  {
    if (*(void *)(*(void *)(v20 + 16) + 24) >= *(void *)(*(void *)(v21 + 16) + 24)) {
      return result;
    }
  }
  else if (*(unsigned char *)(v20 + 60))
  {
    return result;
  }
  __n128 result = *(__n128 *)a1;
  long long v26 = *(_OWORD *)a1;
  __int16 v22 = a2[4];
  *(void *)a1 = *(void *)a2;
  a1[4] = v22;
  *(void *)a2 = v26;
  a2[4] = WORD4(v26);
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::connectTileLabelLineSegments(std::vector<md::SegmentConnectionEntry,geo::StdAllocator<md::SegmentConnectionEntry,mdm::Allocator>> &,double,std::vector<std::pair<unsigned long,unsigned long>> &)::$_0 &,md::SegmentConnectionEntry*>(char *a1, char *a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      BOOL v6 = a2 - 16;
      uint64_t v7 = *(void *)(*((void *)a2 - 2) + 8);
      uint64_t v8 = *(void *)(*(void *)a1 + 8);
      if ((*(unsigned char *)(v7 + 60) != 0) == (*(unsigned char *)(v8 + 60) != 0))
      {
        if (*(void *)(*(void *)(v7 + 16) + 24) >= *(void *)(*(void *)(v8 + 16) + 24)) {
          return result;
        }
      }
      else if (*(unsigned char *)(v7 + 60))
      {
        return result;
      }
      long long v22 = *(_OWORD *)a1;
      __int16 v21 = *((_WORD *)a2 - 4);
      *(void *)a1 = *(void *)v6;
      *((_WORD *)a1 + 4) = v21;
      *(void *)BOOL v6 = v22;
      *((_WORD *)a2 - 4) = WORD4(v22);
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::connectTileLabelLineSegments(std::vector<md::SegmentConnectionEntry,geo::StdAllocator<md::SegmentConnectionEntry,mdm::Allocator>> &,double,std::vector<std::pair<unsigned long,unsigned long>> &)::$_0 &,md::SegmentConnectionEntry*>(a1, (_WORD *)a1 + 8, (_WORD *)a2 - 8);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::connectTileLabelLineSegments(std::vector<md::SegmentConnectionEntry,geo::StdAllocator<md::SegmentConnectionEntry,mdm::Allocator>> &,double,std::vector<std::pair<unsigned long,unsigned long>> &)::$_0 &,md::SegmentConnectionEntry*>(a1, (_WORD *)a1 + 8, (_WORD *)a1 + 16, (_WORD *)a2 - 8);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::connectTileLabelLineSegments(std::vector<md::SegmentConnectionEntry,geo::StdAllocator<md::SegmentConnectionEntry,mdm::Allocator>> &,double,std::vector<std::pair<unsigned long,unsigned long>> &)::$_0 &,md::SegmentConnectionEntry*,0>(a1, (_WORD *)a1 + 8, (_WORD *)a1 + 16, (_WORD *)a1 + 24, (_WORD *)a2 - 8);
      return 1;
    default:
      uint64_t v9 = a1 + 32;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelLineZSet::connectTileLabelLineSegments(std::vector<md::SegmentConnectionEntry,geo::StdAllocator<md::SegmentConnectionEntry,mdm::Allocator>> &,double,std::vector<std::pair<unsigned long,unsigned long>> &)::$_0 &,md::SegmentConnectionEntry*>(a1, (_WORD *)a1 + 8, (_WORD *)a1 + 16);
      uint64_t v10 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (2)
  {
    uint64_t v14 = *(void *)v10;
    uint64_t v15 = *(void *)(*(void *)v10 + 8);
    uint64_t v16 = *(void *)(*(void *)v9 + 8);
    if ((*(unsigned char *)(v15 + 60) != 0) == (*(unsigned char *)(v16 + 60) != 0))
    {
      if (*(void *)(*(void *)(v15 + 16) + 24) >= *(void *)(*(void *)(v16 + 16) + 24)) {
        goto LABEL_9;
      }
    }
    else if (*(unsigned char *)(v15 + 60))
    {
      goto LABEL_9;
    }
    __int16 v17 = *((_WORD *)v10 + 4);
    *(void *)uint64_t v10 = *(void *)v9;
    *((_WORD *)v10 + 4) = *((_WORD *)v9 + 4);
    uint64_t v13 = (uint64_t)a1;
    if (v9 == a1) {
      goto LABEL_8;
    }
    uint64_t v18 = v11;
    while (1)
    {
      uint64_t v19 = *(void *)(v14 + 8);
      uint64_t v20 = *(void *)(*(void *)&a1[v18 + 16] + 8);
      if ((*(unsigned char *)(v19 + 60) != 0) == (*(unsigned char *)(v20 + 60) != 0)) {
        break;
      }
      if (*(unsigned char *)(v19 + 60))
      {
        uint64_t v13 = (uint64_t)v9;
        goto LABEL_8;
      }
LABEL_17:
      v9 -= 16;
      *(void *)&a1[v18 + 32] = *(void *)&a1[v18 + 16];
      *(_WORD *)&a1[v18 + 40] = *(_WORD *)&a1[v18 + 24];
      v18 -= 16;
      if (v18 == -32)
      {
        uint64_t v13 = (uint64_t)a1;
        goto LABEL_8;
      }
    }
    if (*(void *)(*(void *)(v19 + 16) + 24) < *(void *)(*(void *)(v20 + 16) + 24)) {
      goto LABEL_17;
    }
    uint64_t v13 = (uint64_t)&a1[v18 + 32];
LABEL_8:
    *(void *)uint64_t v13 = v14;
    *(_WORD *)(v13 + 8) = v17;
    if (++v12 == 8) {
      return v10 + 16 == a2;
    }
LABEL_9:
    uint64_t v9 = v10;
    v11 += 16;
    v10 += 16;
    if (v10 != a2) {
      continue;
    }
    return 1;
  }
}

void non-virtual thunk to'ggl::Ribbon::BaseMesh::~BaseMesh(ggl::Ribbon::BaseMesh *this)
{
  ggl::Mesh::~Mesh((ggl::Ribbon::BaseMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Ribbon::BaseMesh *)((char *)this - 16));
}

void ggl::Ribbon::BaseMesh::~BaseMesh(ggl::Ribbon::BaseMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::Ribbon::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::Ribbon::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void md::StandardPassList::buildFrameGraph(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4, md::FrameGraphBuilder *a5)
{
  uint64_t v171 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void **)(a2 + 8);
  int8x8_t v10 = (int8x8_t)v9[1];
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8(v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      uint64_t v12 = 0x41E8D6E445F4145;
      if (*(void *)&v10 <= 0x41E8D6E445F4145uLL) {
        uint64_t v12 = 0x41E8D6E445F4145uLL % *(void *)&v10;
      }
    }
    else
    {
      uint64_t v12 = (*(void *)&v10 - 1) & 0x41E8D6E445F4145;
    }
    uint64_t v13 = *(void **)(*v9 + 8 * v12);
    if (v13)
    {
      uint64_t v14 = (void *)*v13;
      if (v14)
      {
        if (v11.u32[0] < 2uLL)
        {
          uint64_t v15 = *(void *)&v10 - 1;
          while (1)
          {
            uint64_t v17 = v14[1];
            if (v17 == 0x41E8D6E445F4145)
            {
              if (v14[2] == 0x41E8D6E445F4145) {
                goto LABEL_22;
              }
            }
            else if ((v17 & v15) != v12)
            {
              goto LABEL_29;
            }
            uint64_t v14 = (void *)*v14;
            if (!v14) {
              goto LABEL_29;
            }
          }
        }
        do
        {
          unint64_t v16 = v14[1];
          if (v16 == 0x41E8D6E445F4145)
          {
            if (v14[2] == 0x41E8D6E445F4145)
            {
LABEL_22:
              uint64_t v18 = v14[5];
              if (*(void *)(v18 + 8) != 0x41E8D6E445F4145) {
                break;
              }
              uint64_t v19 = *(void *)(v18 + 32);
              if (!v19) {
                break;
              }
              int v20 = *(unsigned __int8 *)(v19 + 227);
              v147[0] = *(unsigned char *)(v19 + 227);
              if (*(unsigned char *)(v19 + 224))
              {
                __int16 v21 = +[VKDebugSettings sharedSettings];
                long long v22 = (const BOOL *)[v21 enableDOF];
              }
              else
              {
                long long v22 = 0;
              }
              if (!v20 && (v22 & 1) == 0) {
                break;
              }
              v168[0].i32[0] = 1065353216;
              if (v20)
              {
                long long v53 = +[VKDebugSettings sharedSettings];
                [v53 daVinciSSAODepthTextureScale];
                v168[0].i32[0] = v54;
              }
              md::StandardPassList::_buildSSAODOFCommonFrameGraph((uint64_t)a1, v147, v22, (const float *)v168, a5);
LABEL_30:
              long long v23 = *(void **)(a2 + 8);
              int8x8_t v24 = (int8x8_t)v23[1];
              if (!*(void *)&v24) {
                goto LABEL_54;
              }
              uint8x8_t v25 = (uint8x8_t)vcnt_s8(v24);
              v25.i16[0] = vaddlv_u8(v25);
              if (v25.u32[0] > 1uLL)
              {
                uint64_t v26 = 0x41E8D6E445F4145;
                if (*(void *)&v24 <= 0x41E8D6E445F4145uLL) {
                  uint64_t v26 = 0x41E8D6E445F4145uLL % *(void *)&v24;
                }
              }
              else
              {
                uint64_t v26 = (*(void *)&v24 - 1) & 0x41E8D6E445F4145;
              }
              double v27 = *(void **)(*v23 + 8 * v26);
              if (!v27) {
                goto LABEL_54;
              }
              unint64_t v28 = (void *)*v27;
              if (!v28) {
                goto LABEL_54;
              }
              if (v25.u32[0] < 2uLL)
              {
                uint64_t v29 = *(void *)&v24 - 1;
                while (1)
                {
                  uint64_t v31 = v28[1];
                  if (v31 == 0x41E8D6E445F4145)
                  {
                    if (v28[2] == 0x41E8D6E445F4145) {
                      goto LABEL_51;
                    }
                  }
                  else if ((v31 & v29) != v26)
                  {
                    goto LABEL_54;
                  }
                  unint64_t v28 = (void *)*v28;
                  if (!v28) {
                    goto LABEL_54;
                  }
                }
              }
              while (1)
              {
                unint64_t v30 = v28[1];
                if (v30 == 0x41E8D6E445F4145)
                {
                  if (v28[2] == 0x41E8D6E445F4145)
                  {
LABEL_51:
                    uint64_t v32 = v28[5];
                    if (*(void *)(v32 + 8) == 0x41E8D6E445F4145)
                    {
                      uint64_t v33 = *(void *)(v32 + 32);
                      if (v33)
                      {
                        char v34 = *(unsigned char *)(v33 + 227) != 0;
                        goto LABEL_55;
                      }
                    }
LABEL_54:
                    char v34 = 0;
LABEL_55:
                    size_t v35 = +[VKDebugSettings sharedSettings];
                    [v35 daVinciSSAOTextureScale];
                    int v37 = v36;

                    *(_DWORD *)unint64_t v147 = v37;
                    unint64_t v38 = +[VKDebugSettings sharedSettings];
                    char v39 = [v38 daVinciSSAOEnableBlur];

                    LOBYTE(v138[0]) = v39;
                    if (*((unsigned char *)a4 + 72)) {
                      double v40 = (_DWORD *)a4 + 19;
                    }
                    else {
                      double v40 = &md::FrameGraphRenderTarget::size(void)const::fallback;
                    }
                    v168[0] = (int32x2_t)__PAIR64__(v40[3], v40[1]);
                    double v41 = md::StandardPassList::_buildSSAOFrameGraph((uint64_t)a1, v34, (float *)v147, (uint64_t)v138, v168, (uint64_t)a5);
                    double v42 = *(uint64_t **)(a2 + 8);
                    int8x8_t v43 = (int8x8_t)v42[1];
                    if (!*(void *)&v43) {
                      goto LABEL_133;
                    }
                    double v41 = COERCE_DOUBLE(vcnt_s8(v43));
                    LOWORD(v41) = vaddlv_u8(*(uint8x8_t *)&v41);
                    if (LODWORD(v41) > 1uLL)
                    {
                      uint64_t v44 = 0x41E8D6E445F4145;
                      if (*(void *)&v43 <= 0x41E8D6E445F4145uLL) {
                        uint64_t v44 = 0x41E8D6E445F4145uLL % *(void *)&v43;
                      }
                    }
                    else
                    {
                      uint64_t v44 = (*(void *)&v43 - 1) & 0x41E8D6E445F4145;
                    }
                    uint64_t v45 = *v42;
                    size_t v46 = *(void **)(*v42 + 8 * v44);
                    if (!v46) {
                      goto LABEL_110;
                    }
                    uint64_t v47 = (void *)*v46;
                    if (!*v46) {
                      goto LABEL_110;
                    }
                    uint64_t v48 = *(void *)&v43 - 1;
                    if (LODWORD(v41) < 2uLL)
                    {
                      while (1)
                      {
                        uint64_t v49 = v47[1];
                        if (v49 == 0x41E8D6E445F4145)
                        {
                          if (v47[2] == 0x41E8D6E445F4145) {
                            goto LABEL_79;
                          }
                        }
                        else if ((v49 & v48) != v44)
                        {
                          goto LABEL_109;
                        }
                        uint64_t v47 = (void *)*v47;
                        if (!v47) {
                          goto LABEL_109;
                        }
                      }
                    }
                    while (1)
                    {
                      unint64_t v50 = v47[1];
                      if (v50 == 0x41E8D6E445F4145)
                      {
                        if (v47[2] == 0x41E8D6E445F4145)
                        {
LABEL_79:
                          uint64_t v51 = v47[5];
                          if (*(void *)(v51 + 8) != 0x41E8D6E445F4145 || !*(void *)(v51 + 32)) {
                            goto LABEL_109;
                          }
                          if (LODWORD(v41) > 1uLL)
                          {
                            uint64_t v52 = 0x41E8D6E445F4145;
                            if (*(void *)&v43 <= 0x41E8D6E445F4145uLL) {
                              uint64_t v52 = 0x41E8D6E445F4145uLL % *(void *)&v43;
                            }
                          }
                          else
                          {
                            uint64_t v52 = v48 & 0x41E8D6E445F4145;
                          }
                          unint64_t v55 = *(void **)(v45 + 8 * v52);
                          if (!v55) {
                            goto LABEL_107;
                          }
                          uint64_t v56 = (void *)*v55;
                          if (!v56) {
                            goto LABEL_107;
                          }
                          if (LODWORD(v41) < 2uLL)
                          {
                            while (1)
                            {
                              uint64_t v57 = v56[1];
                              if (v57 == 0x41E8D6E445F4145)
                              {
                                if (v56[2] == 0x41E8D6E445F4145) {
                                  goto LABEL_104;
                                }
                              }
                              else if ((v57 & v48) != v52)
                              {
                                goto LABEL_107;
                              }
                              uint64_t v56 = (void *)*v56;
                              if (!v56) {
                                goto LABEL_107;
                              }
                            }
                          }
                          while (1)
                          {
                            unint64_t v58 = v56[1];
                            if (v58 == 0x41E8D6E445F4145)
                            {
                              if (v56[2] == 0x41E8D6E445F4145)
                              {
LABEL_104:
                                uint64_t v59 = v56[5];
                                if (*(void *)(v59 + 8) == 0x41E8D6E445F4145)
                                {
                                  uint64_t v60 = *(void *)(v59 + 32);
                                  if (v60)
                                  {
                                    BOOL v61 = *(unsigned __int8 *)(v60 + 225) != 0;
                                    goto LABEL_108;
                                  }
                                }
LABEL_107:
                                BOOL v61 = 0;
LABEL_108:
                                md::StandardPassList::_buildShadowFrameGraph(a1, (const BOOL *)v61, a5);
                                double v42 = *(uint64_t **)(a2 + 8);
                                int8x8_t v43 = (int8x8_t)v42[1];
LABEL_109:
                                if (!*(void *)&v43) {
                                  goto LABEL_133;
                                }
LABEL_110:
                                double v41 = COERCE_DOUBLE(vcnt_s8(v43));
                                LOWORD(v41) = vaddlv_u8(*(uint8x8_t *)&v41);
                                if (LODWORD(v41) > 1uLL)
                                {
                                  unint64_t v62 = 0xDFC317497CF9A4BFLL;
                                  if (*(void *)&v43 <= 0xDFC317497CF9A4BFLL) {
                                    unint64_t v62 = 0xDFC317497CF9A4BFLL % *(void *)&v43;
                                  }
                                }
                                else
                                {
                                  unint64_t v62 = (*(void *)&v43 - 1) & 0xDFC317497CF9A4BFLL;
                                }
                                int64x2_t v63 = *(void **)(*v42 + 8 * v62);
                                if (!v63) {
                                  goto LABEL_133;
                                }
                                long long v64 = (void *)*v63;
                                if (!v64) {
                                  goto LABEL_133;
                                }
                                if (LODWORD(v41) < 2uLL)
                                {
                                  uint64_t v65 = *(void *)&v43 - 1;
                                  while (1)
                                  {
                                    uint64_t v67 = v64[1];
                                    if (v67 == 0xDFC317497CF9A4BFLL)
                                    {
                                      if (v64[2] == 0xDFC317497CF9A4BFLL) {
                                        goto LABEL_130;
                                      }
                                    }
                                    else if ((v67 & v65) != v62)
                                    {
                                      goto LABEL_133;
                                    }
                                    long long v64 = (void *)*v64;
                                    if (!v64) {
                                      goto LABEL_133;
                                    }
                                  }
                                }
                                while (1)
                                {
                                  unint64_t v66 = v64[1];
                                  if (v66 == 0xDFC317497CF9A4BFLL)
                                  {
                                    if (v64[2] == 0xDFC317497CF9A4BFLL)
                                    {
LABEL_130:
                                      uint64_t v68 = v64[5];
                                      if (*(void *)(v68 + 8) == 0xDFC317497CF9A4BFLL)
                                      {
                                        uint64_t v69 = *(void *)(v68 + 32);
                                        if (v69)
                                        {
                                          char v70 = *(unsigned char *)(v69 + 64) != 0;
                                          goto LABEL_134;
                                        }
                                      }
LABEL_133:
                                      char v70 = 0;
LABEL_134:
                                      uint64_t v71 = +[VKDebugSettings sharedSettings];
                                      [v71 daVinciRouteLineMaskScale];
                                      int v73 = v72;

                                      *(_DWORD *)unint64_t v147 = v73;
                                      LOBYTE(v138[0]) = [*(id *)(a3 + 104) supportsFramebufferFetch];
                                      uint64_t v74 = (_DWORD *)a4 + 19;
                                      if (!*((unsigned char *)a4 + 72)) {
                                        uint64_t v74 = &md::FrameGraphRenderTarget::size(void)const::fallback;
                                      }
                                      v168[0] = (int32x2_t)__PAIR64__(v74[3], v74[1]);
                                      md::StandardPassList::_buildRouteLineMaskFrameGraph((uint64_t)a1, v70, (int *)v147, (uint64_t)v138, (uint64_t)v168, (uint64_t)a5);
                                      id v75 = *(id *)(a3 + 104);
                                      if ([v75 supportsFramebufferFetch])
                                      {
                                        long long v76 = +[VKDebugSettings sharedSettings];
                                        int v77 = [v76 enableDOF];

                                        if (v77)
                                        {
                                          uint64_t v78 = *a4;
                                          if (*a4
                                            && *(unsigned char *)(v78 + 112)
                                            && (uint64_t v79 = *(unsigned int *)(v78 + 108), v79))
                                          {
                                            uint64_t v80 = v79 | 0x100000000;
                                          }
                                          else
                                          {
                                            uint64_t v80 = 0;
                                          }
                                          v168[0].i16[0] = 1;
                                          *(int32x2_t *)((char *)v168 + 4) = (int32x2_t)0x3F00000000000000;
                                          *(int32x2_t *)((char *)&v168[1] + 4) = (int32x2_t)0x3F00000000000000;
                                          *(int32x2_t *)((char *)&v168[2] + 4) = (int32x2_t)v80;
                                          v168[3].i8[4] = 0;
                                          BYTE4(v169) = 0;
                                          *((void *)&v169 + 1) = 0x100000000;
                                          v170[0] = 1;
                                          LOBYTE(v170[1]) = 0;
                                          if (v78
                                            && *(unsigned char *)(v78 + 112)
                                            && (uint64_t v89 = *(unsigned int *)(v78 + 108), v89))
                                          {
                                            uint64_t v90 = v89 | 0x100000000;
                                          }
                                          else
                                          {
                                            uint64_t v90 = 0;
                                          }
                                          *(_WORD *)unint64_t v147 = 1;
                                          *(void *)&v147[4] = 0x3F80000000000000;
                                          *(void *)&v147[12] = 0x3F80000000000000;
                                          *(void *)&v147[20] = v90;
                                          v147[28] = 0;
                                          BYTE4(v148) = 0;
                                          *((void *)&v148 + 1) = 0x100000001;
                                          LODWORD(v149) = 4;
                                          BYTE4(v149) = 0;
                                          if (v78
                                            && *(unsigned char *)(v78 + 112)
                                            && (uint64_t v91 = *(unsigned int *)(v78 + 108), v91))
                                          {
                                            uint64_t v92 = v91 | 0x100000000;
                                          }
                                          else
                                          {
                                            uint64_t v92 = 0;
                                          }
                                          v138[0] = 1;
                                          uint64_t v139 = 0x3F80000000000000;
                                          uint64_t v140 = 0x3F80000000000000;
                                          uint64_t v141 = v92;
                                          LOBYTE(v142) = 0;
                                          char v143 = 0;
                                          uint64_t v144 = 0x100000000;
                                          int v145 = 1;
                                          char v146 = 2;
                                          uint64_t v93 = a4[8];
                                          if (v93
                                            && *(unsigned char *)(v93 + 112)
                                            && (uint64_t v94 = *(unsigned int *)(v93 + 108), v94))
                                          {
                                            uint64_t v95 = v94 | 0x100000000;
                                          }
                                          else
                                          {
                                            uint64_t v95 = 0;
                                          }
                                          LOWORD(v135[0]) = 1;
                                          *(void *)&v135[1] = 0x3F80000000000000;
                                          *(void *)&v135[3] = 0x3F80000000000000;
                                          *(void *)&v135[5] = v95;
                                          LOBYTE(v136[0]) = 0;
                                          LOBYTE(v136[2]) = 0;
                                          *(void *)&v136[3] = 0x100000001;
                                          v136[5] = 4;
                                          char v137 = 1;
                                          __int16 v159 = 1;
                                          uint64_t v160 = 0x3E00000000000000;
                                          uint64_t v161 = 0x3E00000000000000;
                                          uint64_t v162 = 0x100000002;
                                          char v163 = 0;
                                          char v164 = 0;
                                          uint64_t v165 = 0x100000000;
                                          int v166 = 1;
                                          char v167 = 0;
                                          a1[26] = md::FrameGraphBuilder::createResource((uint64_t)a5, (uint64_t)v147, "Primary Scene Color", 0x8BC3D4C00000013uLL, 0);
                                          a1[28] = md::FrameGraphBuilder::createResource((uint64_t)a5, (uint64_t)v135, "Primary Scene Depth", 0x944969CC00000013, 0);
                                          a1[27] = md::FrameGraphBuilder::createResource((uint64_t)a5, (uint64_t)v138, "Primary Scene Color Resolve", 0x429E541E0000001BuLL, 0);
                                          a1[30] = md::FrameGraphBuilder::createResource((uint64_t)a5, (uint64_t)v168, "FG Color CoC", 0x138985420000000CuLL, 0);
                                          a1[31] = md::FrameGraphBuilder::createResource((uint64_t)a5, (uint64_t)v168, "BG Color CoC", 0x108FBE3D0000000CuLL, 0);
                                          a1[29] = md::FrameGraphBuilder::createResource((uint64_t)a5, (uint64_t)&v159, "FG Color Downsampled CoC", 0x4C9E23D800000018uLL, 0);
                                          a1[32] = md::FrameGraphBuilder::createResource((uint64_t)a5, (uint64_t)v168, "FG Blur", 0xF5B8B5BC00000007, 0);
                                          a1[33] = md::FrameGraphBuilder::createResource((uint64_t)a5, (uint64_t)v168, "BG Blur", 0x1F791AF00000007uLL, 0);
                                          a1[34] = md::FrameGraphBuilder::createResource((uint64_t)a5, (uint64_t)v168, "FG Tent Blur", 0xB5780D5C0000000CLL, 0);
                                          a1[35] = md::FrameGraphBuilder::createResource((uint64_t)a5, (uint64_t)v168, "BG Tent Blur", 0xB67E36230000000CLL, 0);
                                          v158[0] = &unk_1EF5726F0;
                                          v158[1] = a1;
                                          v158[3] = v158;
                                          md::FrameGraphBuilder::addRenderPass<md::StandardCommandBufferIdInfo>();
                                        }
                                      }
                                      else
                                      {
                                      }
                                      *((_OWORD *)a1 + 16) = 0u;
                                      *((_OWORD *)a1 + 17) = 0u;
                                      *((_OWORD *)a1 + 14) = 0u;
                                      *((_OWORD *)a1 + 15) = 0u;
                                      *((_OWORD *)a1 + 13) = 0u;
                                      uint64_t v81 = *(uint64_t **)(a2 + 8);
                                      int8x8_t v82 = (int8x8_t)v81[1];
                                      if (!*(void *)&v82) {
                                        goto LABEL_206;
                                      }
                                      uint8x8_t v83 = (uint8x8_t)vcnt_s8(v82);
                                      v83.i16[0] = vaddlv_u8(v83);
                                      if (v83.u32[0] > 1uLL)
                                      {
                                        uint64_t v84 = 0x41E8D6E445F4145;
                                        if (*(void *)&v82 <= 0x41E8D6E445F4145uLL) {
                                          uint64_t v84 = 0x41E8D6E445F4145uLL % *(void *)&v82;
                                        }
                                      }
                                      else
                                      {
                                        uint64_t v84 = (*(void *)&v82 - 1) & 0x41E8D6E445F4145;
                                      }
                                      uint64_t v85 = *v81;
                                      double v86 = *(uint64_t **)(*v81 + 8 * v84);
                                      if (v86)
                                      {
                                        double v86 = (uint64_t *)*v86;
                                        if (v86)
                                        {
                                          if (v83.u32[0] < 2uLL)
                                          {
                                            while (1)
                                            {
                                              uint64_t v88 = v86[1];
                                              if (v88 == 0x41E8D6E445F4145)
                                              {
                                                if (v86[2] == 0x41E8D6E445F4145) {
                                                  goto LABEL_181;
                                                }
                                              }
                                              else if ((v88 & (*(void *)&v82 - 1)) != v84)
                                              {
                                                goto LABEL_185;
                                              }
                                              double v86 = (uint64_t *)*v86;
                                              if (!v86) {
                                                goto LABEL_183;
                                              }
                                            }
                                          }
                                          do
                                          {
                                            unint64_t v87 = v86[1];
                                            if (v87 == 0x41E8D6E445F4145)
                                            {
                                              if (v86[2] == 0x41E8D6E445F4145)
                                              {
LABEL_181:
                                                uint64_t v96 = v86[5];
                                                if (*(void *)(v96 + 8) == 0x41E8D6E445F4145)
                                                {
                                                  double v86 = *(uint64_t **)(v96 + 32);
                                                  break;
                                                }
LABEL_185:
                                                double v86 = 0;
                                                if (v83.u32[0] > 1uLL)
                                                {
LABEL_186:
                                                  unint64_t v97 = 0xDFC317497CF9A4BFLL;
                                                  if (*(void *)&v82 <= 0xDFC317497CF9A4BFLL) {
                                                    unint64_t v97 = 0xDFC317497CF9A4BFLL % *(void *)&v82;
                                                  }
                                                  goto LABEL_188;
                                                }
LABEL_184:
                                                unint64_t v97 = (*(void *)&v82 - 1) & 0xDFC317497CF9A4BFLL;
LABEL_188:
                                                float64_t v98 = *(void **)(v85 + 8 * v97);
                                                if (!v98) {
                                                  goto LABEL_214;
                                                }
                                                double v99 = (void *)*v98;
                                                if (!v99) {
                                                  goto LABEL_214;
                                                }
                                                if (v83.u32[0] < 2uLL)
                                                {
                                                  uint64_t v100 = *(void *)&v82 - 1;
                                                  while (1)
                                                  {
                                                    uint64_t v102 = v99[1];
                                                    if (v102 == 0xDFC317497CF9A4BFLL)
                                                    {
                                                      if (v99[2] == 0xDFC317497CF9A4BFLL) {
                                                        goto LABEL_204;
                                                      }
                                                    }
                                                    else if ((v102 & v100) != v97)
                                                    {
                                                      goto LABEL_214;
                                                    }
                                                    double v99 = (void *)*v99;
                                                    if (!v99) {
                                                      goto LABEL_214;
                                                    }
                                                  }
                                                }
                                                while (1)
                                                {
                                                  unint64_t v101 = v99[1];
                                                  if (v101 == 0xDFC317497CF9A4BFLL)
                                                  {
                                                    if (v99[2] == 0xDFC317497CF9A4BFLL)
                                                    {
LABEL_204:
                                                      double v103 = (int8x8_t *)v99[5];
                                                      if (*(void *)&v103[1] == 0xDFC317497CF9A4BFLL)
                                                      {
                                                        int8x8_t v82 = v103[4];
                                                        if (!v86) {
                                                          goto LABEL_206;
                                                        }
LABEL_215:
                                                        char v104 = 0;
                                                        char v157 = *((unsigned char *)v86 + 227);
                                                        BOOL v156 = *((unsigned char *)v86 + 225) != 0;
                                                        if (!*(void *)&v82)
                                                        {
LABEL_208:
                                                          __int8 v155 = v82.i8[0];
                                                          if ((v104 & 1) != 0 || !*((unsigned char *)v86 + 224))
                                                          {
                                                            char v106 = 0;
                                                          }
                                                          else
                                                          {
                                                            double v105 = +[VKDebugSettings sharedSettings];
                                                            char v106 = [v105 enableDOF];
                                                          }
                                                          char v154 = v106;
                                                          if ([*(id *)(a3 + 104) supportsFramebufferFetch])
                                                          {
                                                            double v107 = operator new(0x38uLL);
                                                            void *v107 = &unk_1EF572AE0;
                                                            v107[1] = &v156;
                                                            v107[2] = a1;
                                                            v107[3] = &v157;
                                                            v107[4] = &v155;
                                                            v107[5] = &v154;
                                                            v107[6] = a4;
                                                            v168[3] = (int32x2_t)v107;
                                                            md::FrameGraphBuilder::addRenderPass<md::StandardCommandBufferIdInfo>();
                                                          }
                                                          id v108 = *(id *)(a3 + 104);
                                                          uint64_t v109 = [v108 finalRenderTarget];
                                                          uint64_t v110 = [v108 linearRenderTarget];
                                                          if (v110)
                                                          {
                                                            uint64_t v112 = a1[3];
                                                            float64x2_t v113 = *(_DWORD **)(v110 + 336);
                                                            if (v113)
                                                            {
                                                              LODWORD(v114) = v113[9];
                                                              LODWORD(v113) = v113[10];
                                                              goto LABEL_242;
                                                            }
                                                            uint64_t v114 = *(void *)(v110 + 88);
                                                            if (v114)
                                                            {
                                                              float64x2_t v115 = (_DWORD *)(v110 + 96);
                                                              goto LABEL_224;
                                                            }
                                                            uint64_t v114 = *(void *)(v110 + 280);
                                                            if (v114)
                                                            {
                                                              float64x2_t v115 = (_DWORD *)(v110 + 288);
LABEL_224:
                                                              uint64_t v116 = 80;
                                                              if (*(_DWORD *)(v114 + 56) == 3) {
                                                                uint64_t v116 = 196;
                                                              }
                                                              unsigned int v117 = *(_DWORD *)(v114 + v116);
                                                              unsigned int v118 = v117 >> *v115;
                                                              if (v118 <= 1) {
                                                                unsigned int v118 = 1;
                                                              }
                                                              if (v117) {
                                                                LODWORD(v114) = v118;
                                                              }
                                                              else {
                                                                LODWORD(v114) = 0;
                                                              }
                                                            }
                                                            float64x2_t v113 = *(_DWORD **)(v110 + 88);
                                                            if (v113)
                                                            {
                                                              uint64_t v119 = (_DWORD *)(v110 + 96);
                                                              goto LABEL_235;
                                                            }
                                                            float64x2_t v113 = *(_DWORD **)(v110 + 280);
                                                            if (v113)
                                                            {
                                                              uint64_t v119 = (_DWORD *)(v110 + 288);
LABEL_235:
                                                              uint64_t v120 = 21;
                                                              if (v113[14] == 3) {
                                                                uint64_t v120 = 49;
                                                              }
                                                              unsigned int v121 = v113[v120];
                                                              unsigned int v122 = v121 >> *v119;
                                                              if (v122 <= 1) {
                                                                unsigned int v122 = 1;
                                                              }
                                                              if (v121) {
                                                                LODWORD(v113) = v122;
                                                              }
                                                              else {
                                                                LODWORD(v113) = 0;
                                                              }
                                                            }
LABEL_242:
                                                            *(_DWORD *)(v112 + 40) = v114;
                                                            *(_DWORD *)(v112 + 44) = v113;
                                                            long long v123 = *(_OWORD *)(v110 + 72);
                                                            *(_OWORD *)(v112 + 48) = *(_OWORD *)(v110 + 56);
                                                            *(_OWORD *)(v112 + 64) = v123;
                                                          }
                                                          memset(v170, 0, 25);
                                                          long long v169 = 0u;
                                                          memset(v168, 0, sizeof(v168));
                                                          md::FrameGraphUtils::prepareGraphBuilderForRenderTarget((uint64_t)v168, (uint64_t)a5, (void *)v110, "renderTarget_linearColorBuffer", 0x6F1219E0000001EuLL, "renderTarget_linearDepthStencilBuffer", 0xE3A8F65400000025, v111, "renderTarget_linearMsaaResolveBuffer", 0xEECC3D6200000024);
                                                          long long v124 = *((_OWORD *)a4 + 3);
                                                          long long v148 = *((_OWORD *)a4 + 2);
                                                          long long v149 = v124;
                                                          uint64_t v150 = a4[8];
                                                          long long v125 = *((_OWORD *)a4 + 1);
                                                          *(_OWORD *)unint64_t v147 = *(_OWORD *)a4;
                                                          *(_OWORD *)&v147[16] = v125;
                                                          char v151 = 0;
                                                          if (*((unsigned char *)a4 + 72))
                                                          {
                                                            long long v152 = *(_OWORD *)((char *)a4 + 76);
                                                            int v153 = *((_DWORD *)a4 + 23);
                                                            char v151 = 1;
                                                          }
                                                          unint64_t v126 = *(unsigned int **)(v109 + 88);
                                                          unsigned int v127 = v126[20];
                                                          unsigned int v128 = v126[21];
                                                          uint64_t v129 = v126[17];
                                                          int v130 = v126[18];
                                                          if (v129) {
                                                            uint64_t v131 = v129 | 0x100000000;
                                                          }
                                                          else {
                                                            uint64_t v131 = 0;
                                                          }
                                                          v138[0] = 0;
                                                          uint64_t v139 = v127;
                                                          uint64_t v140 = v128;
                                                          uint64_t v141 = v131;
                                                          uint64_t v144 = 0x100000000;
                                                          int v145 = v130;
                                                          char v146 = 0;
                                                          char v143 = 1;
                                                          uint64_t v142 = 0x200000001;
                                                          uint64_t Resource = md::FrameGraphBuilder::createResource((uint64_t)a5, (uint64_t)v138, "renderTarget_colorBuffer_first", 0xE22C27790000001ELL, 0);
                                                          *(void *)unint64_t v147 = Resource;
                                                          if (!v151)
                                                          {
                                                            long long v133 = *(_OWORD *)(Resource + 88);
                                                            int v153 = *(_DWORD *)(Resource + 104);
                                                            long long v152 = v133;
                                                            char v151 = 1;
                                                          }
                                                          *(void *)unint64_t v135 = Resource;
                                                          operator new();
                                                        }
LABEL_207:
                                                        v82.i8[0] = *(unsigned char *)(*(void *)&v82 + 64) != 0;
                                                        goto LABEL_208;
                                                      }
LABEL_214:
                                                      int8x8_t v82 = 0;
                                                      if (v86) {
                                                        goto LABEL_215;
                                                      }
LABEL_206:
                                                      double v86 = 0;
                                                      char v157 = 0;
                                                      char v104 = 1;
                                                      BOOL v156 = 0;
                                                      if (!*(void *)&v82) {
                                                        goto LABEL_208;
                                                      }
                                                      goto LABEL_207;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    if (v101 >= *(void *)&v82) {
                                                      v101 %= *(void *)&v82;
                                                    }
                                                    if (v101 != v97) {
                                                      goto LABEL_214;
                                                    }
                                                  }
                                                  double v99 = (void *)*v99;
                                                  if (!v99) {
                                                    goto LABEL_214;
                                                  }
                                                }
                                              }
                                            }
                                            else
                                            {
                                              if (v87 >= *(void *)&v82) {
                                                v87 %= *(void *)&v82;
                                              }
                                              if (v87 != v84) {
                                                goto LABEL_185;
                                              }
                                            }
                                            double v86 = (uint64_t *)*v86;
                                          }
                                          while (v86);
                                        }
                                      }
LABEL_183:
                                      if (v83.u32[0] > 1uLL) {
                                        goto LABEL_186;
                                      }
                                      goto LABEL_184;
                                    }
                                  }
                                  else
                                  {
                                    if (v66 >= *(void *)&v43) {
                                      v66 %= *(void *)&v43;
                                    }
                                    if (v66 != v62) {
                                      goto LABEL_133;
                                    }
                                  }
                                  long long v64 = (void *)*v64;
                                  if (!v64) {
                                    goto LABEL_133;
                                  }
                                }
                              }
                            }
                            else
                            {
                              if (v58 >= *(void *)&v43) {
                                v58 %= *(void *)&v43;
                              }
                              if (v58 != v52) {
                                goto LABEL_107;
                              }
                            }
                            uint64_t v56 = (void *)*v56;
                            if (!v56) {
                              goto LABEL_107;
                            }
                          }
                        }
                      }
                      else
                      {
                        if (v50 >= *(void *)&v43) {
                          v50 %= *(void *)&v43;
                        }
                        if (v50 != v44) {
                          goto LABEL_109;
                        }
                      }
                      uint64_t v47 = (void *)*v47;
                      if (!v47) {
                        goto LABEL_109;
                      }
                    }
                  }
                }
                else
                {
                  if (v30 >= *(void *)&v24) {
                    v30 %= *(void *)&v24;
                  }
                  if (v30 != v26) {
                    goto LABEL_54;
                  }
                }
                unint64_t v28 = (void *)*v28;
                if (!v28) {
                  goto LABEL_54;
                }
              }
            }
          }
          else
          {
            if (v16 >= *(void *)&v10) {
              v16 %= *(void *)&v10;
            }
            if (v16 != v12) {
              break;
            }
          }
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_29:
  a1[13] = 0;
  a1[21] = 0;
  goto LABEL_30;
}

void sub_1A2564980(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2564C18()
{
  md::RenderQueueBase::~RenderQueueBase(v0);
  JUMPOUT(0x1A2564C24);
}

void sub_1A2564C44()
{
  md::RenderQueueBase::~RenderQueueBase(v0);
  JUMPOUT(0x1A2564C50);
}

void md::FrameGraphBuilder::addRenderPass<md::StandardBelowOverlaysCommandBufferIdInfo>()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1A2564F98(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_1A2564FCC(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v2);
  MEMORY[0x1A6239270](v1, 0xA1C4084DA3AFDLL);
  _Unwind_Resume(a1);
}

void md::RenderQueue<md::StandardAboveOverlaysCommandBufferIdInfo>::~RenderQueue(void *a1)
{
  *a1 = &unk_1EF535298;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = (void *)a1[3];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v4);
  }
  uint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  JUMPOUT(0x1A6239270);
}

void *md::RenderQueue<md::StandardAboveOverlaysCommandBufferIdInfo>::~RenderQueue(void *a1)
{
  *a1 = &unk_1EF535298;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = (void *)a1[3];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v4);
  }
  uint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  HIBYTE(v10) = 14;
  strcpy((char *)&__src, "Above Overlays");
  uint64_t v4 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__assign_no_alias<false>(v4, &__src, 0xEuLL);
  }
  else
  {
    *(_OWORD *)uint64_t v4 = __src;
    *(void *)(a2 + 48) = v10;
  }
  md::FrameGraphPassBuilder::dependsOn((uint64_t *)a2, **(unsigned __int8 ***)(a1 + 8));
  uint64_t v5 = *(void *)(a1 + 16);
  *(_OWORD *)(a2 + 104) = *(_OWORD *)v5;
  __n128 result = *(__n128 *)(v5 + 16);
  long long v7 = *(_OWORD *)(v5 + 32);
  long long v8 = *(_OWORD *)(v5 + 48);
  *(void *)(a2 + 168) = *(void *)(v5 + 64);
  *(_OWORD *)(a2 + 152) = v8;
  *(_OWORD *)(a2 + 136) = v7;
  *(__n128 *)(a2 + 120) = result;
  if (*(unsigned char *)(v5 + 72))
  {
    __n128 result = *(__n128 *)(v5 + 76);
    if (*(unsigned char *)(a2 + 176))
    {
      *(_DWORD *)(a2 + 196) = *(_DWORD *)(v5 + 92);
      *(__n128 *)(a2 + 180) = result;
    }
    else
    {
      *(_DWORD *)(a2 + 196) = *(_DWORD *)(v5 + 92);
      *(__n128 *)(a2 + 180) = result;
      *(unsigned char *)(a2 + 176) = 1;
    }
  }
  else if (*(unsigned char *)(a2 + 176))
  {
    *(unsigned char *)(a2 + 176) = 0;
  }
  return result;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF572C48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF572C48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

void md::RenderQueue<md::StandardOverlaysAboveCommandBufferIdInfo>::~RenderQueue(void *a1)
{
  *a1 = &unk_1EF535298;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = (void *)a1[3];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v4);
  }
  long long v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  JUMPOUT(0x1A6239270);
}

void *md::RenderQueue<md::StandardOverlaysAboveCommandBufferIdInfo>::~RenderQueue(void *a1)
{
  *a1 = &unk_1EF535298;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = (void *)a1[3];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v4);
  }
  long long v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  BYTE7(v9[1]) = 21;
  strcpy((char *)v9, "Overlays Above Labels");
  uint64_t v4 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__assign_no_alias<false>(v4, v9, 0x15uLL);
  }
  else
  {
    *(_OWORD *)uint64_t v4 = v9[0];
    *(void *)(a2 + 48) = *(void *)&v9[1];
  }
  md::FrameGraphPassBuilder::dependsOn((uint64_t *)a2, **(unsigned __int8 ***)(a1 + 8));
  uint64_t v5 = *(void *)(a1 + 16);
  *(_OWORD *)(a2 + 104) = *(_OWORD *)v5;
  __n128 result = *(__n128 *)(v5 + 16);
  long long v7 = *(_OWORD *)(v5 + 32);
  long long v8 = *(_OWORD *)(v5 + 48);
  *(void *)(a2 + 168) = *(void *)(v5 + 64);
  *(_OWORD *)(a2 + 152) = v8;
  *(_OWORD *)(a2 + 136) = v7;
  *(__n128 *)(a2 + 120) = result;
  if (*(unsigned char *)(v5 + 72))
  {
    __n128 result = *(__n128 *)(v5 + 76);
    if (*(unsigned char *)(a2 + 176))
    {
      *(_DWORD *)(a2 + 196) = *(_DWORD *)(v5 + 92);
      *(__n128 *)(a2 + 180) = result;
    }
    else
    {
      *(_DWORD *)(a2 + 196) = *(_DWORD *)(v5 + 92);
      *(__n128 *)(a2 + 180) = result;
      *(unsigned char *)(a2 + 176) = 1;
    }
  }
  else if (*(unsigned char *)(a2 + 176))
  {
    *(unsigned char *)(a2 + 176) = 0;
  }
  return result;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF572C00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF572C00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

void md::RenderQueue<md::StandardBetweenOverlaysCommandBufferIdInfo>::~RenderQueue(void *a1)
{
  *a1 = &unk_1EF535298;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = (void *)a1[3];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v4);
  }
  long long v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  JUMPOUT(0x1A6239270);
}

void *md::RenderQueue<md::StandardBetweenOverlaysCommandBufferIdInfo>::~RenderQueue(void *a1)
{
  *a1 = &unk_1EF535298;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = (void *)a1[3];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v4);
  }
  long long v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  BYTE7(v9[1]) = 16;
  strcpy((char *)v9, "Between Overlays");
  uint64_t v4 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__assign_no_alias<false>(v4, v9, 0x10uLL);
  }
  else
  {
    *(_OWORD *)uint64_t v4 = v9[0];
    *(void *)(a2 + 48) = *(void *)&v9[1];
  }
  md::FrameGraphPassBuilder::dependsOn((uint64_t *)a2, **(unsigned __int8 ***)(a1 + 8));
  uint64_t v5 = *(void *)(a1 + 16);
  *(_OWORD *)(a2 + 104) = *(_OWORD *)v5;
  __n128 result = *(__n128 *)(v5 + 16);
  long long v7 = *(_OWORD *)(v5 + 32);
  long long v8 = *(_OWORD *)(v5 + 48);
  *(void *)(a2 + 168) = *(void *)(v5 + 64);
  *(_OWORD *)(a2 + 152) = v8;
  *(_OWORD *)(a2 + 136) = v7;
  *(__n128 *)(a2 + 120) = result;
  if (*(unsigned char *)(v5 + 72))
  {
    __n128 result = *(__n128 *)(v5 + 76);
    if (*(unsigned char *)(a2 + 176))
    {
      *(_DWORD *)(a2 + 196) = *(_DWORD *)(v5 + 92);
      *(__n128 *)(a2 + 180) = result;
    }
    else
    {
      *(_DWORD *)(a2 + 196) = *(_DWORD *)(v5 + 92);
      *(__n128 *)(a2 + 180) = result;
      *(unsigned char *)(a2 + 176) = 1;
    }
  }
  else if (*(unsigned char *)(a2 + 176))
  {
    *(unsigned char *)(a2 + 176) = 0;
  }
  return result;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF572BB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF572BB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

void md::RenderQueue<md::StandardOverlaysBelowCommandBufferIdInfo>::~RenderQueue(void *a1)
{
  *a1 = &unk_1EF535298;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = (void *)a1[3];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v4);
  }
  long long v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  JUMPOUT(0x1A6239270);
}

void *md::RenderQueue<md::StandardOverlaysBelowCommandBufferIdInfo>::~RenderQueue(void *a1)
{
  *a1 = &unk_1EF535298;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = (void *)a1[3];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v4);
  }
  long long v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  BYTE7(v9[1]) = 21;
  strcpy((char *)v9, "Overlays Below Labels");
  uint64_t v4 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__assign_no_alias<false>(v4, v9, 0x15uLL);
  }
  else
  {
    *(_OWORD *)uint64_t v4 = v9[0];
    *(void *)(a2 + 48) = *(void *)&v9[1];
  }
  md::FrameGraphPassBuilder::dependsOn((uint64_t *)a2, **(unsigned __int8 ***)(a1 + 8));
  uint64_t v5 = *(void *)(a1 + 16);
  *(_OWORD *)(a2 + 104) = *(_OWORD *)v5;
  __n128 result = *(__n128 *)(v5 + 16);
  long long v7 = *(_OWORD *)(v5 + 32);
  long long v8 = *(_OWORD *)(v5 + 48);
  *(void *)(a2 + 168) = *(void *)(v5 + 64);
  *(_OWORD *)(a2 + 152) = v8;
  *(_OWORD *)(a2 + 136) = v7;
  *(__n128 *)(a2 + 120) = result;
  if (*(unsigned char *)(v5 + 72))
  {
    __n128 result = *(__n128 *)(v5 + 76);
    if (*(unsigned char *)(a2 + 176))
    {
      *(_DWORD *)(a2 + 196) = *(_DWORD *)(v5 + 92);
      *(__n128 *)(a2 + 180) = result;
    }
    else
    {
      *(_DWORD *)(a2 + 196) = *(_DWORD *)(v5 + 92);
      *(__n128 *)(a2 + 180) = result;
      *(unsigned char *)(a2 + 176) = 1;
    }
  }
  else if (*(unsigned char *)(a2 + 176))
  {
    *(unsigned char *)(a2 + 176) = 0;
  }
  return result;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF572B70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF572B70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

void md::RenderQueue<md::StandardBelowOverlaysCommandBufferIdInfo>::~RenderQueue(void *a1)
{
  *a1 = &unk_1EF535298;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = (void *)a1[3];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v4);
  }
  long long v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  JUMPOUT(0x1A6239270);
}

void *md::RenderQueue<md::StandardBelowOverlaysCommandBufferIdInfo>::~RenderQueue(void *a1)
{
  *a1 = &unk_1EF535298;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = (void *)a1[3];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v4);
  }
  long long v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  HIBYTE(v14) = 14;
  strcpy((char *)&__src, "Below Overlays");
  uint64_t v5 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__assign_no_alias<false>(v5, &__src, 0xEuLL);
  }
  else
  {
    *(_OWORD *)uint64_t v5 = __src;
    *(void *)(a2 + 48) = v14;
  }
  if (**(unsigned char **)(a1 + 8)) {
    md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v4 + 96));
  }
  if (**(unsigned char **)(a1 + 24))
  {
    uint64_t v6 = +[VKDebugSettings sharedSettings];
    int v7 = [v6 daVinciSSAODepthAwareUpsampleEnabled];

    uint64_t v8 = 136;
    if (v7) {
      uint64_t v8 = 152;
    }
    md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v4 + v8));
  }
  if (**(unsigned char **)(a1 + 32)) {
    md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v4 + 160));
  }
  uint64_t v9 = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 104) = *(_OWORD *)v9;
  __n128 result = *(__n128 *)(v9 + 16);
  long long v11 = *(_OWORD *)(v9 + 32);
  long long v12 = *(_OWORD *)(v9 + 48);
  *(void *)(a2 + 168) = *(void *)(v9 + 64);
  *(_OWORD *)(a2 + 152) = v12;
  *(_OWORD *)(a2 + 136) = v11;
  *(__n128 *)(a2 + 120) = result;
  if (*(unsigned char *)(v9 + 72))
  {
    __n128 result = *(__n128 *)(v9 + 76);
    if (*(unsigned char *)(a2 + 176))
    {
      *(_DWORD *)(a2 + 196) = *(_DWORD *)(v9 + 92);
      *(__n128 *)(a2 + 180) = result;
    }
    else
    {
      *(_DWORD *)(a2 + 196) = *(_DWORD *)(v9 + 92);
      *(__n128 *)(a2 + 180) = result;
      *(unsigned char *)(a2 + 176) = 1;
    }
  }
  else if (*(unsigned char *)(a2 + 176))
  {
    *(unsigned char *)(a2 + 176) = 0;
  }
  return result;
}

void sub_1A25661E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF572B28;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1EF572B28;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

void *md::RenderQueue<md::StandardCommandBufferIdInfo>::~RenderQueue(void *a1)
{
  *a1 = &unk_1EF535298;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    long long v3 = (void *)a1[4];
    uint64_t v4 = (void *)a1[3];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *long long v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v4);
  }
  int v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2, __n128 result)
{
  uint64_t v5 = *(void *)(a1 + 16);
  HIBYTE(v12) = 7;
  strcpy((char *)&__src, "Primary");
  uint64_t v6 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__assign_no_alias<false>(v6, &__src, 7uLL);
  }
  else
  {
    result.n128_u64[0] = __src;
    *(_OWORD *)uint64_t v6 = __src;
    *(void *)(a2 + 48) = v12;
  }
  if (**(unsigned char **)(a1 + 8)) {
    md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v5 + 96));
  }
  if (**(unsigned char **)(a1 + 24)) {
    md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v5 + 120));
  }
  if (**(unsigned char **)(a1 + 32)) {
    md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v5 + 160));
  }
  if (**(unsigned char **)(a1 + 40))
  {
    uint64_t v7 = *(void *)(v5 + 208);
    *(void *)(a2 + 104) = v7;
    if (!*(unsigned char *)(a2 + 176))
    {
      __n128 result = *(__n128 *)(v7 + 88);
      *(_DWORD *)(a2 + 196) = *(_DWORD *)(v7 + 104);
      *(__n128 *)(a2 + 180) = result;
      *(unsigned char *)(a2 + 176) = 1;
    }
    *(void *)(a2 + 168) = *(void *)(v5 + 224);
    *(void *)(a2 + 136) = *(void *)(v5 + 216);
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 48);
    *(_OWORD *)(a2 + 104) = *(_OWORD *)v8;
    __n128 result = *(__n128 *)(v8 + 16);
    long long v9 = *(_OWORD *)(v8 + 32);
    long long v10 = *(_OWORD *)(v8 + 48);
    *(void *)(a2 + 168) = *(void *)(v8 + 64);
    *(_OWORD *)(a2 + 136) = v9;
    *(_OWORD *)(a2 + 152) = v10;
    *(__n128 *)(a2 + 120) = result;
    if (*(unsigned char *)(v8 + 72))
    {
      __n128 result = *(__n128 *)(v8 + 76);
      if (*(unsigned char *)(a2 + 176))
      {
        *(_DWORD *)(a2 + 196) = *(_DWORD *)(v8 + 92);
        *(__n128 *)(a2 + 180) = result;
      }
      else
      {
        *(_DWORD *)(a2 + 196) = *(_DWORD *)(v8 + 92);
        *(__n128 *)(a2 + 180) = result;
        *(unsigned char *)(a2 + 176) = 1;
      }
    }
    else if (*(unsigned char *)(a2 + 176))
    {
      *(unsigned char *)(a2 + 176) = 0;
    }
  }
  return result;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF572AE0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_1EF572AE0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildPrimaryFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_6,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_6>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(_OWORD *)(a2 + 104) = *(_OWORD *)v2;
  __n128 result = *(__n128 *)(v2 + 16);
  long long v4 = *(_OWORD *)(v2 + 32);
  long long v5 = *(_OWORD *)(v2 + 48);
  *(void *)(a2 + 168) = *(void *)(v2 + 64);
  *(_OWORD *)(a2 + 152) = v5;
  *(_OWORD *)(a2 + 136) = v4;
  *(__n128 *)(a2 + 120) = result;
  if (*(unsigned char *)(v2 + 72))
  {
    __n128 result = *(__n128 *)(v2 + 76);
    if (*(unsigned char *)(a2 + 176))
    {
      *(_DWORD *)(a2 + 196) = *(_DWORD *)(v2 + 92);
      *(__n128 *)(a2 + 180) = result;
    }
    else
    {
      *(_DWORD *)(a2 + 196) = *(_DWORD *)(v2 + 92);
      *(__n128 *)(a2 + 180) = result;
      *(unsigned char *)(a2 + 176) = 1;
    }
  }
  else if (*(unsigned char *)(a2 + 176))
  {
    *(unsigned char *)(a2 + 176) = 0;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_6,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_6>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5728A0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_6,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_6>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF5728A0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_6,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_6>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 280);
  *(void *)(a2 + 104) = v2;
  if (!*(unsigned char *)(a2 + 176))
  {
    __n128 result = *(__n128 *)(v2 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v2 + 104);
    *(__n128 *)(a2 + 180) = result;
    *(unsigned char *)(a2 + 176) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572858;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572858;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_5>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 272);
  *(void *)(a2 + 104) = v2;
  if (!*(unsigned char *)(a2 + 176))
  {
    __n128 result = *(__n128 *)(v2 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v2 + 104);
    *(__n128 *)(a2 + 180) = result;
    *(unsigned char *)(a2 + 176) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572810;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572810;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_4>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 264);
  *(void *)(a2 + 104) = v2;
  if (!*(unsigned char *)(a2 + 176))
  {
    __n128 result = *(__n128 *)(v2 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v2 + 104);
    *(__n128 *)(a2 + 180) = result;
    *(unsigned char *)(a2 + 176) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5727C8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF5727C8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_3>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 256);
  *(void *)(a2 + 104) = v2;
  if (!*(unsigned char *)(a2 + 176))
  {
    __n128 result = *(__n128 *)(v2 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v2 + 104);
    *(__n128 *)(a2 + 180) = result;
    *(unsigned char *)(a2 + 176) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572780;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572780;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_2>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 232);
  *(void *)(a2 + 104) = v2;
  if (!*(unsigned char *)(a2 + 176))
  {
    __n128 result = *(__n128 *)(v2 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v2 + 104);
    *(__n128 *)(a2 + 180) = result;
    *(unsigned char *)(a2 + 176) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572738;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572738;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

uint64_t std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  uint64_t v3 = *(void *)(v2 + 240);
  *(void *)(a2 + 104) = v3;
  if (!*(unsigned char *)(a2 + 176))
  {
    long long v4 = *(_OWORD *)(v3 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v3 + 104);
    *(_OWORD *)(a2 + 180) = v4;
    *(unsigned char *)(a2 + 176) = 1;
  }
  *(void *)(a2 + 112) = *(void *)(v2 + 248);
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5726F0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF5726F0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildDOFFrameGraph(md::LayoutContext const&,md::Renderer &,md::FrameGraphRenderTarget const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  long long v4 = (char *)operator new(0x19uLL);
  strcpy(v4, "RouteLine DistanceField");
  long long v5 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0) {
    std::string::__assign_no_alias<false>(v5, v4, 0x17uLL);
  }
  else {
    std::string::__assign_no_alias<true>(v5, v4, 0x17uLL);
  }
  operator delete(v4);
  uint64_t v7 = *(void *)(v3 + 160);
  *(void *)(a2 + 104) = v7;
  if (!*(unsigned char *)(a2 + 176))
  {
    __n128 result = *(__n128 *)(v7 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v7 + 104);
    *(__n128 *)(a2 + 180) = result;
    *(unsigned char *)(a2 + 176) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572CD8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572CD8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  long long v4 = (char *)operator new(0x19uLL);
  strcpy(v4, "RouteLine DistanceField");
  long long v5 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0) {
    std::string::__assign_no_alias<false>(v5, v4, 0x17uLL);
  }
  else {
    std::string::__assign_no_alias<true>(v5, v4, 0x17uLL);
  }
  operator delete(v4);
  uint64_t v7 = *(void *)(v3 + 160);
  *(void *)(a2 + 104) = v7;
  if (!*(unsigned char *)(a2 + 176))
  {
    __n128 result = *(__n128 *)(v7 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v7 + 104);
    *(__n128 *)(a2 + 180) = result;
    *(unsigned char *)(a2 + 176) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572C90;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572C90;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildRouteLineMaskFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

void *md::StandardPassList::_buildShadowFrameGraph(void *this, const BOOL *a2, md::FrameGraphBuilder *a3)
{
  uint64_t v3 = this;
  v32[4] = *MEMORY[0x1E4F143B8];
  if ((_BYTE)a2)
  {
    v23[0] = 258;
    uint64_t v24 = 0x3E80000000000000;
    uint64_t v25 = 0x3E80000000000000;
    uint64_t v26 = 0x100000015;
    char v27 = 0;
    char v28 = 0;
    uint64_t v29 = 0x100000001;
    int v30 = 4;
    char v31 = 1;
    v14[0] = 258;
    uint64_t v15 = 0x3E80000000000000;
    uint64_t v16 = 0x3E80000000000000;
    uint64_t v17 = 0x100000004;
    char v18 = 0;
    char v19 = 0;
    uint64_t v20 = 0x100000001;
    int v21 = 4;
    char v22 = 0;
    v5[0] = 258;
    uint64_t v6 = 0x3E80000000000000;
    uint64_t v7 = 0x3E80000000000000;
    uint64_t v8 = 0x100000004;
    char v9 = 0;
    char v10 = 0;
    uint64_t v11 = 0x100000000;
    int v12 = 1;
    char v13 = 2;
    this[10] = md::FrameGraphBuilder::createResource((uint64_t)a3, (uint64_t)v23, "DV Shadow", 0xFA9BA3C000000009, 0);
    v3[11] = md::FrameGraphBuilder::createResource((uint64_t)a3, (uint64_t)v14, "DV Shadow Color", 0x23A65F340000000FuLL, 0);
    v3[12] = md::FrameGraphBuilder::createResource((uint64_t)a3, (uint64_t)v5, "DV Shadow Color Resolve", 0x355EBC1F00000017uLL, 0);
    v32[0] = &unk_1EF572A98;
    v32[1] = v3;
    v32[3] = v32;
    md::FrameGraphBuilder::addRenderPass<md::DaVinciShadowCommandBufferIdInfo>();
  }
  this[10] = 0;
  this[11] = 0;
  this[12] = 0;
  return this;
}

void sub_1A2566FF0(_Unwind_Exception *a1)
{
  std::function<void ()(md::FrameGraphRenderPassBuilder &)>::~function((void *)(v1 - 72));
  _Unwind_Resume(a1);
}

void md::FrameGraphBuilder::addRenderPass<md::DaVinciShadowCommandBufferIdInfo>()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1A2567490(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_1A25674C4(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v2);
  MEMORY[0x1A6239270](v1, 0xA1C4084DA3AFDLL);
  _Unwind_Resume(a1);
}

void md::RenderQueue<md::DaVinciShadowCommandBufferIdInfo>::~RenderQueue(void *a1)
{
  *a1 = &unk_1EF535298;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    long long v4 = (void *)a1[3];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      long long v4 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v4);
  }
  uint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  JUMPOUT(0x1A6239270);
}

void *md::RenderQueue<md::DaVinciShadowCommandBufferIdInfo>::~RenderQueue(void *a1)
{
  *a1 = &unk_1EF535298;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    long long v4 = (void *)a1[3];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      long long v4 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v4);
  }
  uint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

void **std::__function::__func<md::StandardPassList::_buildShadowFrameGraph(BOOL const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildShadowFrameGraph(BOOL const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a1 + 8);
  HIBYTE(v8) = 11;
  strcpy((char *)&__src, "Shadow Pass");
  __n128 result = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    __n128 result = std::string::__assign_no_alias<false>(result, &__src, 0xBuLL);
  }
  else
  {
    *(_OWORD *)__n128 result = __src;
    *(void *)(a2 + 48) = v8;
  }
  uint64_t v5 = v3[10];
  *(void *)(a2 + 168) = v5;
  if (!*(unsigned char *)(a2 + 176))
  {
    long long v6 = *(_OWORD *)(v5 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v5 + 104);
    *(_OWORD *)(a2 + 180) = v6;
    *(unsigned char *)(a2 + 176) = 1;
  }
  *(void *)(a2 + 104) = v3[11];
  *(void *)(a2 + 136) = v3[12];
  *(unsigned char *)(a2 + 200) = 1;
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildShadowFrameGraph(BOOL const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildShadowFrameGraph(BOOL const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572A98;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildShadowFrameGraph(BOOL const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildShadowFrameGraph(BOOL const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572A98;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildShadowFrameGraph(BOOL const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildShadowFrameGraph(BOOL const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_5,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_5>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  HIBYTE(v8) = 12;
  strcpy((char *)&__src, "SSAO Rescale");
  long long v4 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__assign_no_alias<false>(v4, &__src, 0xCuLL);
  }
  else
  {
    *(_OWORD *)long long v4 = __src;
    *(void *)(a2 + 48) = v8;
  }
  md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v3 + 120));
  md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v3 + 144));
  md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v3 + 104));
  uint64_t v6 = *(void *)(v3 + 152);
  *(void *)(a2 + 104) = v6;
  if (!*(unsigned char *)(a2 + 176))
  {
    __n128 result = *(__n128 *)(v6 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v6 + 104);
    *(__n128 *)(a2 + 180) = result;
    *(unsigned char *)(a2 + 176) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_5,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_5>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572A50;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_5,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_5>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572A50;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_5,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_5>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_4,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_4>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  HIBYTE(v8) = 12;
  strcpy((char *)&__src, "SSAO Rescale");
  long long v4 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__assign_no_alias<false>(v4, &__src, 0xCuLL);
  }
  else
  {
    *(_OWORD *)long long v4 = __src;
    *(void *)(a2 + 48) = v8;
  }
  md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v3 + 136));
  md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v3 + 144));
  md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v3 + 104));
  uint64_t v6 = *(void *)(v3 + 152);
  *(void *)(a2 + 104) = v6;
  if (!*(unsigned char *)(a2 + 176))
  {
    __n128 result = *(__n128 *)(v6 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v6 + 104);
    *(__n128 *)(a2 + 180) = result;
    *(unsigned char *)(a2 + 176) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_4,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_4>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572A08;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_4,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_4>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572A08;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_4,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_4>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_3,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_3>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  HIBYTE(v8) = 10;
  strcpy((char *)&__src, "SSAO Blur2");
  long long v4 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__assign_no_alias<false>(v4, &__src, 0xAuLL);
  }
  else
  {
    *(_OWORD *)long long v4 = __src;
    *(void *)(a2 + 48) = v8;
  }
  md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v3 + 128));
  md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v3 + 144));
  uint64_t v6 = *(void *)(v3 + 136);
  *(void *)(a2 + 104) = v6;
  if (!*(unsigned char *)(a2 + 176))
  {
    __n128 result = *(__n128 *)(v6 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v6 + 104);
    *(__n128 *)(a2 + 180) = result;
    *(unsigned char *)(a2 + 176) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_3,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_3>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5729C0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_3,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_3>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF5729C0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_3,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_3>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_2,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_2>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  HIBYTE(v8) = 9;
  strcpy((char *)&__src, "SSAO Blur");
  long long v4 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__assign_no_alias<false>(v4, &__src, 9uLL);
  }
  else
  {
    *(_OWORD *)long long v4 = __src;
    *(void *)(a2 + 48) = v8;
  }
  md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v3 + 120));
  md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v3 + 144));
  uint64_t v6 = *(void *)(v3 + 128);
  *(void *)(a2 + 104) = v6;
  if (!*(unsigned char *)(a2 + 176))
  {
    __n128 result = *(__n128 *)(v6 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v6 + 104);
    *(__n128 *)(a2 + 180) = result;
    *(unsigned char *)(a2 + 176) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_2,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_2>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572978;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_2,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_2>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572978;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_2,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_2>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  HIBYTE(v8) = 4;
  strcpy((char *)&__src, "SSAO");
  long long v4 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__assign_no_alias<false>(v4, &__src, 4uLL);
  }
  else
  {
    *(_OWORD *)long long v4 = __src;
    *(void *)(a2 + 48) = v8;
  }
  md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v3 + 168));
  uint64_t v6 = *(void *)(v3 + 120);
  *(void *)(a2 + 104) = v6;
  if (!*(unsigned char *)(a2 + 176))
  {
    __n128 result = *(__n128 *)(v6 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v6 + 104);
    *(__n128 *)(a2 + 180) = result;
    *(unsigned char *)(a2 + 176) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572930;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572930;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  BYTE7(v7[1]) = 21;
  strcpy((char *)v7, "Scene depth downscale");
  long long v4 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__assign_no_alias<false>(v4, v7, 0x15uLL);
  }
  else
  {
    *(_OWORD *)long long v4 = v7[0];
    *(void *)(a2 + 48) = *(void *)&v7[1];
  }
  md::FrameGraphPassBuilder::addAttachmentInput((uint64_t *)a2, *(unsigned __int8 **)(v3 + 104));
  uint64_t v6 = *(void *)(v3 + 144);
  *(void *)(a2 + 104) = v6;
  if (!*(unsigned char *)(a2 + 176))
  {
    __n128 result = *(__n128 *)(v6 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v6 + 104);
    *(__n128 *)(a2 + 180) = result;
    *(unsigned char *)(a2 + 176) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5728E8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF5728E8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildSSAOFrameGraph(BOOL const&,float const&,BOOL const&,gm::Matrix<int,2,1> const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

__n128 std::__function::__func<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  HIBYTE(v8) = 11;
  strcpy((char *)&__src, "Scene Depth");
  long long v4 = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__assign_no_alias<false>(v4, &__src, 0xBuLL);
  }
  else
  {
    result.n128_u64[0] = __src;
    *(_OWORD *)long long v4 = __src;
    *(void *)(a2 + 48) = v8;
  }
  uint64_t v6 = *(void *)(v3 + 104);
  *(void *)(a2 + 168) = v6;
  if (!*(unsigned char *)(a2 + 176))
  {
    __n128 result = *(__n128 *)(v6 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v6 + 104);
    *(__n128 *)(a2 + 180) = result;
    *(unsigned char *)(a2 + 176) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572D68;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572D68;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_1,std::allocator<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_1>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

void **std::__function::__func<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  HIBYTE(v8) = 11;
  strcpy((char *)&__src, "Scene Depth");
  __n128 result = (void **)(a2 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    __n128 result = std::string::__assign_no_alias<false>(result, &__src, 0xBuLL);
  }
  else
  {
    *(_OWORD *)__n128 result = __src;
    *(void *)(a2 + 48) = v8;
  }
  uint64_t v5 = *(void *)(v3 + 168);
  *(void *)(a2 + 104) = v5;
  if (!*(unsigned char *)(a2 + 176))
  {
    long long v6 = *(_OWORD *)(v5 + 88);
    *(_DWORD *)(a2 + 196) = *(_DWORD *)(v5 + 104);
    *(_OWORD *)(a2 + 180) = v6;
    *(unsigned char *)(a2 + 176) = 1;
  }
  *(void *)(a2 + 168) = *(void *)(v3 + 104);
  return result;
}

uint64_t std::__function::__func<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572D20;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572D20;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildSSAODOFCommonFrameGraph(BOOL const&,BOOL const&,float const&,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

void md::StandardPassList::~StandardPassList(md::StandardPassList *this)
{
  md::StandardPassList::~StandardPassList(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  ggl::RenderQueue *v12;
  md::FrameGraph *v13;

  *(void *)this = &unk_1EF536A58;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 43);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 41);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 41);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  long long v4 = *((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  long long v6 = *((void *)this + 36);
  *((void *)this + 36) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *((void *)this + 25);
  *((void *)this + 25) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 24);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  char v9 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  char v10 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 5);
    if (!v11) {
      goto LABEL_27;
    }
  }
  else
  {
    uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 5);
    if (!v11) {
      goto LABEL_27;
    }
  }
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
LABEL_27:
  *(void *)this = &unk_1EF553DD8;
  int v12 = (ggl::RenderQueue *)*((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v12)
  {
    ggl::RenderQueue::~RenderQueue(v12);
    MEMORY[0x1A6239270]();
  }
  char v13 = (md::FrameGraph *)*((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v13)
  {
    md::FrameGraph::~FrameGraph(v13);
    MEMORY[0x1A6239270]();
  }
}

void ggl::ConstantDataTyped<ggl::DaVinci::LightingDebugOptions>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::DaVinci::LightingDebugOptions>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::LightingDebugOptions>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::LightingDebugOptions>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587598;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::LightingDebugOptions>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587598;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5874B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5874B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

__n128 std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraphWithFrameBufferFetch(BOOL const&,BOOL const&,BOOL const&,md::FrameGraphRenderTarget const*,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildPrimaryFrameGraphWithFrameBufferFetch(BOOL const&,BOOL const&,BOOL const&,md::FrameGraphRenderTarget const*,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF572DB0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<md::StandardPassList::_buildPrimaryFrameGraphWithFrameBufferFetch(BOOL const&,BOOL const&,BOOL const&,md::FrameGraphRenderTarget const*,md::FrameGraphBuilder *)::$_0,std::allocator<md::StandardPassList::_buildPrimaryFrameGraphWithFrameBufferFetch(BOOL const&,BOOL const&,BOOL const&,md::FrameGraphRenderTarget const*,md::FrameGraphBuilder *)::$_0>,void ()(md::FrameGraphRenderPassBuilder &)>::~__func()
{
}

uint64_t std::__hash_table<std::__hash_value_type<gdc::LayerDataWithWorld,std::shared_ptr<gdc::SubtileClipMask>>,std::__unordered_map_hasher<gdc::LayerDataWithWorld,std::__hash_value_type<gdc::LayerDataWithWorld,std::shared_ptr<gdc::SubtileClipMask>>,gdc::LayerDataWithWorldHash,std::equal_to<gdc::LayerDataWithWorld>,true>,std::__unordered_map_equal<gdc::LayerDataWithWorld,std::__hash_value_type<gdc::LayerDataWithWorld,std::shared_ptr<gdc::SubtileClipMask>>,std::equal_to<gdc::LayerDataWithWorld>,gdc::LayerDataWithWorldHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataWithWorld,std::shared_ptr<gdc::SubtileClipMask>>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  while (v2)
  {
    long long v3 = v2;
    uint64_t v2 = (void *)*v2;
    long long v4 = (std::__shared_weak_count *)v3[6];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
      uint64_t v5 = (std::__shared_weak_count *)v3[3];
      if (v5)
      {
LABEL_7:
        if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
    }
    else
    {
      uint64_t v5 = (std::__shared_weak_count *)v3[3];
      if (v5) {
        goto LABEL_7;
      }
    }
    operator delete(v3);
  }
  long long v6 = *(void **)a1;
  *(void *)a1 = 0;
  if (v6) {
    operator delete(v6);
  }
  return a1;
}

void *std::pair<md::TileSelectionTileSetType,md::SceneTileSet>::~pair(void *a1)
{
  uint64_t v2 = (gdc::LayerDataCollector *)a1[13];
  a1[13] = 0;
  if (v2)
  {
    gdc::LayerDataCollector::~LayerDataCollector(v2);
    MEMORY[0x1A6239270]();
  }
  long long v3 = (void *)a1[10];
  if (v3)
  {
    do
    {
      long long v4 = (void *)*v3;
      operator delete(v3);
      long long v3 = v4;
    }
    while (v4);
  }
  uint64_t v5 = (void *)a1[8];
  a1[8] = 0;
  if (v5) {
    operator delete(v5);
  }
  long long v6 = (void *)a1[4];
  if (v6)
  {
    do
    {
      uint64_t v7 = (void *)*v6;
      operator delete(v6);
      long long v6 = v7;
    }
    while (v7);
  }
  uint64_t v8 = (void *)a1[2];
  a1[2] = 0;
  if (v8) {
    operator delete(v8);
  }
  return a1;
}

uint64_t std::__split_buffer<std::pair<md::TileSelectionTileSetType,md::SceneTileSet>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 112;
    std::__destroy_at[abi:nn180100]<std::pair<md::TileSelectionTileSetType,md::SceneTileSet>,0>((void *)(i - 112));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void md::SceneStateManager::~SceneStateManager(md::SceneStateManager *this)
{
  md::SceneStateManager::~SceneStateManager(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;

  *(void *)this = &unk_1EF537DA0;
  std::__hash_table<std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>,std::__unordered_map_hasher<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>,std::hash<md::TileSelectionTileSetType>,std::equal_to<md::TileSelectionTileSetType>,true>,std::__unordered_map_equal<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>,std::equal_to<md::TileSelectionTileSetType>,std::hash<md::TileSelectionTileSetType>,true>,std::allocator<std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>>>::__deallocate_node(*((void **)this + 56));
  uint64_t v2 = (void *)*((void *)this + 54);
  *((void *)this + 54) = 0;
  if (v2) {
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 51);
  if (v3)
  {
    do
    {
      uint64_t v29 = (void *)*v3;
      int v30 = (void *)v3[5];
      if (v30)
      {
        do
        {
          char v31 = (void *)*v30;
          operator delete(v30);
          int v30 = v31;
        }
        while (v31);
      }
      uint64_t v32 = (void *)v3[3];
      void v3[3] = 0;
      if (v32) {
        operator delete(v32);
      }
      operator delete(v3);
      uint64_t v3 = v29;
    }
    while (v29);
  }
  long long v4 = (void *)*((void *)this + 49);
  *((void *)this + 49) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 46);
  if (v5)
  {
    do
    {
      uint64_t v33 = (void *)*v5;
      char v34 = (void *)v5[5];
      if (v34)
      {
        do
        {
          size_t v35 = (void *)*v34;
          operator delete(v34);
          char v34 = v35;
        }
        while (v35);
      }
      int v36 = (void *)v5[3];
      v5[3] = 0;
      if (v36) {
        operator delete(v36);
      }
      operator delete(v5);
      uint64_t v5 = v33;
    }
    while (v33);
  }
  long long v6 = (void *)*((void *)this + 44);
  *((void *)this + 44) = 0;
  if (v6) {
    operator delete(v6);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 42));
  uint64_t v7 = (void *)*((void *)this + 38);
  if (v7)
  {
    do
    {
      uint64_t v8 = (void *)*v7;
      operator delete(v7);
      uint64_t v7 = v8;
    }
    while (v8);
  }
  char v9 = (void *)*((void *)this + 36);
  *((void *)this + 36) = 0;
  if (v9) {
    operator delete(v9);
  }
  char v10 = (void *)*((void *)this + 32);
  if (v10)
  {
    *((void *)this + 33) = v10;
    operator delete(v10);
  }
  uint64_t v11 = (void *)*((void *)this + 29);
  if (v11)
  {
    *((void *)this + 30) = v11;
    operator delete(v11);
  }
  int v12 = (void *)*((void *)this + 26);
  if (v12)
  {
    *((void *)this + 27) = v12;
    operator delete(v12);
  }
  char v13 = (void *)*((void *)this + 23);
  if (v13)
  {
    *((void *)this + 24) = v13;
    operator delete(v13);
  }
  uint64_t v14 = (void *)*((void *)this + 20);
  if (v14)
  {
    uint64_t v15 = (void *)*((void *)this + 21);
    uint64_t v16 = (void *)*((void *)this + 20);
    if (v15 != v14)
    {
      do
      {
        v15 -= 14;
        std::__destroy_at[abi:nn180100]<std::pair<md::TileSelectionTileSetType,md::SceneTileSet>,0>(v15);
      }
      while (v15 != v14);
      uint64_t v16 = (void *)*((void *)this + 20);
    }
    *((void *)this + 21) = v14;
    operator delete(v16);
  }
  uint64_t v17 = (void *)*((void *)this + 17);
  if (v17)
  {
    char v18 = (void *)*((void *)this + 18);
    char v19 = (void *)*((void *)this + 17);
    if (v18 != v17)
    {
      do
      {
        v18 -= 14;
        std::__destroy_at[abi:nn180100]<std::pair<md::TileSelectionTileSetType,md::SceneTileSet>,0>(v18);
      }
      while (v18 != v17);
      char v19 = (void *)*((void *)this + 17);
    }
    *((void *)this + 18) = v17;
    operator delete(v19);
  }
  uint64_t v20 = (void *)*((void *)this + 14);
  if (v20)
  {
    int v21 = (void *)*((void *)this + 15);
    char v22 = (void *)*((void *)this + 14);
    if (v21 != v20)
    {
      do
      {
        v21 -= 14;
        std::__destroy_at[abi:nn180100]<std::pair<md::TileSelectionTileSetType,md::SceneTileSet>,0>(v21);
      }
      while (v21 != v20);
      char v22 = (void *)*((void *)this + 14);
    }
    *((void *)this + 15) = v20;
    operator delete(v22);
  }
  std::__hash_table<std::__hash_value_type<gdc::LayerDataWithWorld,std::shared_ptr<gdc::SubtileClipMask>>,std::__unordered_map_hasher<gdc::LayerDataWithWorld,std::__hash_value_type<gdc::LayerDataWithWorld,std::shared_ptr<gdc::SubtileClipMask>>,gdc::LayerDataWithWorldHash,std::equal_to<gdc::LayerDataWithWorld>,true>,std::__unordered_map_equal<gdc::LayerDataWithWorld,std::__hash_value_type<gdc::LayerDataWithWorld,std::shared_ptr<gdc::SubtileClipMask>>,std::equal_to<gdc::LayerDataWithWorld>,gdc::LayerDataWithWorldHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataWithWorld,std::shared_ptr<gdc::SubtileClipMask>>>>::~__hash_table((uint64_t)this + 72);
  long long v23 = *((void *)this + 6);
  if (v23)
  {
    uint64_t v24 = *((void *)this + 7);
    uint64_t v25 = (void *)*((void *)this + 6);
    if (v24 != v23)
    {
      do
      {
        uint64_t v26 = v24 - 32;
        std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(v24 - 16));
        uint64_t v24 = v26;
      }
      while (v26 != v23);
      uint64_t v25 = (void *)*((void *)this + 6);
    }
    *((void *)this + 7) = v23;
    operator delete(v25);
  }
  char v27 = (void *)*((void *)this + 3);
  if (v27)
  {
    do
    {
      int v37 = (void *)*v27;
      unint64_t v38 = (void *)v27[16];
      if (v38 != (void *)v27[18]) {
        free(v38);
      }
      if (*((unsigned char *)v27 + 112)) {
        *((unsigned char *)v27 + 112) = 0;
      }
      char v39 = (void *)v27[4];
      if (v39 != (void *)v27[6]) {
        free(v39);
      }
      operator delete(v27);
      char v27 = v37;
    }
    while (v37);
  }
  char v28 = (void *)*((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v28) {
    operator delete(v28);
  }
}

uint64_t std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100](uint64_t a1)
{
  return a1;
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::LayerDataWithWorld,std::shared_ptr<gdc::SubtileClipMask>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::LayerDataWithWorld,std::shared_ptr<gdc::SubtileClipMask>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = (std::__shared_weak_count *)v2[6];
      if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
      long long v4 = (std::__shared_weak_count *)v2[3];
      if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void std::__shared_ptr_emplace<gdc::SubtileClipMask>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582D30;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gdc::SubtileClipMask>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582D30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::function<void ()(md::MapDataType)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,geo::small_vector<geo::QuadTile,8ul>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,geo::small_vector<geo::QuadTile,8ul>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      uint64_t v3 = *(void **)(v2 + 128);
      if (v3 != *(void **)(v2 + 144)) {
        free(v3);
      }
      if (*(unsigned char *)(v2 + 112)) {
        *(unsigned char *)(v2 + 112) = 0;
      }
      long long v4 = *(void **)(v2 + 32);
      if (v4 != *(void **)(v2 + 48)) {
        free(v4);
      }
    }
    operator delete((void *)v2);
  }
  return a1;
}

uint64_t std::__function::__func<gdc::FragmentCollector<md::MapDataType,82ul>::validFragmentsForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1},std::allocator<gdc::FragmentCollector<md::MapDataType,82ul>::validFragmentsForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1}>,BOOL ()(std::bitset<82ul> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF52DF38;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<gdc::FragmentCollector<md::MapDataType,82ul>::validFragmentsForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1},std::allocator<gdc::FragmentCollector<md::MapDataType,82ul>::validFragmentsForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1}>,BOOL ()(std::bitset<82ul> const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF52DF38;
  result[1] = v3;
  return result;
}

void std::__function::__func<gdc::FragmentCollector<md::MapDataType,82ul>::validFragmentsForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1},std::allocator<gdc::FragmentCollector<md::MapDataType,82ul>::validFragmentsForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1}>,BOOL ()(std::bitset<82ul> const&)>::~__func()
{
}

BOOL std::__function::__func<gdc::FragmentCollector<md::MapDataType,82ul>::validSubtilesForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1},std::allocator<gdc::FragmentCollector<md::MapDataType,82ul>::validSubtilesForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1}>,BOOL ()(std::bitset<82ul> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  return *(void *)a2 == *(void *)v2 && ((*(_DWORD *)(v2 + 8) ^ *(_DWORD *)(a2 + 8)) & 0x3FFFFLL) == 0;
}

uint64_t std::__function::__func<gdc::FragmentCollector<md::MapDataType,82ul>::validSubtilesForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1},std::allocator<gdc::FragmentCollector<md::MapDataType,82ul>::validSubtilesForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1}>,BOOL ()(std::bitset<82ul> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF52DEF0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<gdc::FragmentCollector<md::MapDataType,82ul>::validSubtilesForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1},std::allocator<gdc::FragmentCollector<md::MapDataType,82ul>::validSubtilesForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1}>,BOOL ()(std::bitset<82ul> const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF52DEF0;
  result[1] = v3;
  return result;
}

void std::__function::__func<gdc::FragmentCollector<md::MapDataType,82ul>::validSubtilesForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1},std::allocator<gdc::FragmentCollector<md::MapDataType,82ul>::validSubtilesForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1}>,BOOL ()(std::bitset<82ul> const&)>::~__func()
{
}

uint64_t std::__function::__func<md::SceneStateManager::updateSceneTileSet(md::SceneTileSet &,md::TileSelectionTileSetType)::$_0,std::allocator<md::SceneStateManager::updateSceneTileSet(md::SceneTileSet &,md::TileSelectionTileSetType)::$_0>,void ()(md::MapDataType)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF573818;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::SceneStateManager::updateSceneTileSet(md::SceneTileSet &,md::TileSelectionTileSetType)::$_0,std::allocator<md::SceneStateManager::updateSceneTileSet(md::SceneTileSet &,md::TileSelectionTileSetType)::$_0>,void ()(md::MapDataType)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF573818;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::SceneStateManager::updateSceneTileSet(md::SceneTileSet &,md::TileSelectionTileSetType)::$_0,std::allocator<md::SceneStateManager::updateSceneTileSet(md::SceneTileSet &,md::TileSelectionTileSetType)::$_0>,void ()(md::MapDataType)>::~__func()
{
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>,void *>>>::operator()[abi:nn180100](char a1, void *__p)
{
  if (a1)
  {
    uint64_t v3 = (void *)__p[5];
    if (v3)
    {
      do
      {
        uint64_t v5 = (void *)*v3;
        long long v6 = (void *)v3[5];
        if (v6)
        {
          do
          {
            uint64_t v7 = (void *)*v6;
            operator delete(v6);
            long long v6 = v7;
          }
          while (v7);
        }
        uint64_t v8 = (void *)v3[3];
        void v3[3] = 0;
        if (v8) {
          operator delete(v8);
        }
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5);
    }
    long long v4 = (void *)__p[3];
    __p[3] = 0;
    if (v4) {
      operator delete(v4);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void *md::SceneStateManager::setHasLayerDataDependency(void *result, uint64_t a2)
{
  uint64_t v2 = (int8x8_t *)result[59];
  int8x8_t v3 = v2[17];
  if (!*(void *)&v3) {
    return result;
  }
  unint64_t v4 = *(unsigned __int16 *)(a2 + 8);
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v6 = *(unsigned __int16 *)(a2 + 8);
    if (*(void *)&v3 <= v4) {
      unint64_t v6 = v4 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v6 = (v3.i32[0] - 1) & v4;
  }
  int8x8_t v7 = v2[16];
  uint64_t v8 = *(uint64_t ****)(*(void *)&v7 + 8 * v6);
  if (!v8) {
    return result;
  }
  char v9 = *v8;
  if (!*v8) {
    return result;
  }
  uint64_t v10 = *(void *)&v3 - 1;
  if (v5.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v11 = v9[1];
      if (v11 == (uint64_t *)v4)
      {
        if (*((unsigned __int16 *)v9 + 8) == v4) {
          goto LABEL_22;
        }
      }
      else if (((unint64_t)v11 & v10) != v6)
      {
        return result;
      }
      char v9 = (uint64_t **)*v9;
      if (!v9) {
        return result;
      }
    }
  }
  while (1)
  {
    unint64_t v12 = (unint64_t)v9[1];
    if (v12 == v4) {
      break;
    }
    if (v12 >= *(void *)&v3) {
      v12 %= *(void *)&v3;
    }
    if (v12 != v6) {
      return result;
    }
LABEL_16:
    char v9 = (uint64_t **)*v9;
    if (!v9) {
      return result;
    }
  }
  if (*((unsigned __int16 *)v9 + 8) != v4) {
    goto LABEL_16;
  }
LABEL_22:
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v13 = *(unsigned __int16 *)(a2 + 8);
    if (*(void *)&v3 <= v4) {
      unint64_t v13 = v4 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v13 = (v3.i32[0] - 1) & v4;
  }
  uint64_t v14 = *(uint64_t ****)(*(void *)&v7 + 8 * v13);
  if (!v14 || (uint64_t v15 = *v14) == 0)
  {
LABEL_41:
    int v18 = 0;
    goto LABEL_42;
  }
  if (v5.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v16 = v15[1];
      if (v16 == (uint64_t *)v4)
      {
        if (*((unsigned __int16 *)v15 + 8) == v4) {
          goto LABEL_51;
        }
      }
      else if (((unint64_t)v16 & v10) != v13)
      {
        goto LABEL_41;
      }
      uint64_t v15 = (uint64_t **)*v15;
      if (!v15) {
        goto LABEL_41;
      }
    }
  }
  while (2)
  {
    unint64_t v17 = (unint64_t)v15[1];
    if (v17 != v4)
    {
      if (v17 >= *(void *)&v3) {
        v17 %= *(void *)&v3;
      }
      if (v17 != v13) {
        goto LABEL_41;
      }
      goto LABEL_36;
    }
    if (*((unsigned __int16 *)v15 + 8) != v4)
    {
LABEL_36:
      uint64_t v15 = (uint64_t **)*v15;
      if (!v15) {
        goto LABEL_41;
      }
      continue;
    }
    break;
  }
LABEL_51:
  int v18 = *((unsigned __int16 *)v15 + 10);
LABEL_42:
  char v19 = (unsigned __int16 *)result[14];
  uint64_t v20 = (unsigned __int16 *)result[15];
  if (v19 != v20)
  {
    while (*v19 != v18)
    {
      v19 += 56;
      if (v19 == v20)
      {
        char v19 = (unsigned __int16 *)result[15];
        break;
      }
    }
  }
  uint64_t v21 = *((void *)v19 + 13);
  if (v21)
  {
    __n128 result = std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::find<gdc::LayerDataRequestKey>((void *)(v21 + 48), (unsigned __int8 *)a2);
    if (result)
    {
      unint64_t v22 = result[16];
      __n128 result = geo::linear_map<unsigned short,std::vector<gdc::LayerDataHolder>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>,std::vector<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>>::operator[]((unsigned __int16 **)(v21 + 24), v4);
      if (0x8E38E38E38E38E39 * ((uint64_t)(result[1] - *result) >> 4) <= v22) {
        abort();
      }
      *(void *)(*result + 144 * v22 + 136) |= 1uLL;
    }
  }
  return result;
}

void md::SceneStateManager::setHasTileSelectionDependency(uint64_t a1, unsigned __int16 a2, unsigned int a3, unsigned __int8 *a4)
{
  unsigned __int16 v88 = a2;
  uint64_t v8 = std::__hash_table<std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>,std::__unordered_map_hasher<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>,std::hash<md::TileSelectionTileSetType>,std::equal_to<md::TileSelectionTileSetType>,true>,std::__unordered_map_equal<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>,std::equal_to<md::TileSelectionTileSetType>,std::hash<md::TileSelectionTileSetType>,true>,std::allocator<std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>>>::__emplace_unique_key_args<md::TileSelectionTileSetType,std::piecewise_construct_t const&,std::tuple<md::TileSelectionTileSetType const&>,std::tuple<>>((uint64_t *)(a1 + 432), a2, &v88);
  char v9 = v8;
  unint64_t v10 = a3;
  unint64_t v11 = *((void *)v8 + 4);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = a3;
      if (v11 <= a3) {
        unint64_t v4 = a3 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & a3;
    }
    unint64_t v13 = *(void ***)(*((void *)v8 + 3) + 8 * v4);
    if (v13)
    {
      uint64_t v14 = (unsigned __int16 *)*v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v16 = *((void *)v14 + 1);
            if (v16 == v10)
            {
              if (v14[8] == v10) {
                goto LABEL_82;
              }
            }
            else if ((v16 & (v11 - 1)) != v4)
            {
              goto LABEL_22;
            }
            uint64_t v14 = *(unsigned __int16 **)v14;
            if (!v14) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v15 = *((void *)v14 + 1);
          if (v15 == v10)
          {
            if (v14[8] == v10) {
              goto LABEL_82;
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v4) {
              break;
            }
          }
          uint64_t v14 = *(unsigned __int16 **)v14;
        }
        while (v14);
      }
    }
  }
LABEL_22:
  uint64_t v5 = (uint64_t)(v8 + 20);
  uint64_t v14 = (unsigned __int16 *)operator new(0x40uLL);
  uint64_t v89 = v14;
  uint64_t v90 = v9 + 20;
  *(void *)uint64_t v14 = 0;
  *((void *)v14 + 1) = v10;
  v14[8] = v10;
  *(_OWORD *)(v14 + 12) = 0u;
  *(_OWORD *)(v14 + 20) = 0u;
  *((_DWORD *)v14 + 14) = 1065353216;
  char v91 = 1;
  float v17 = (float)(unint64_t)(*((void *)v9 + 6) + 1);
  float v18 = *((float *)v9 + 14);
  if (v11 && (float)(v18 * (float)v11) >= v17)
  {
    unint64_t v10 = v4;
    goto LABEL_72;
  }
  BOOL v19 = 1;
  if (v11 >= 3) {
    BOOL v19 = (v11 & (v11 - 1)) != 0;
  }
  unint64_t v20 = v19 | (2 * v11);
  unint64_t v21 = vcvtps_u32_f32(v17 / v18);
  if (v20 <= v21) {
    size_t prime = v21;
  }
  else {
    size_t prime = v20;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v11 = *((void *)v9 + 4);
  }
  if (prime > v11)
  {
LABEL_35:
    if (prime >> 61) {
      goto LABEL_183;
    }
    long long v23 = operator new(8 * prime);
    uint64_t v24 = (void *)*((void *)v9 + 3);
    *((void *)v9 + 3) = v23;
    if (v24) {
      operator delete(v24);
    }
    uint64_t v25 = 0;
    *((void *)v9 + 4) = prime;
    do
      *(void *)(*((void *)v9 + 3) + 8 * v25++) = 0;
    while (prime != v25);
    uint64_t v26 = *(void **)v5;
    if (!*(void *)v5) {
      goto LABEL_59;
    }
    size_t v27 = v26[1];
    size_t v28 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v29 = v27 & v28;
      *(void *)(*((void *)v9 + 3) + 8 * v29) = v5;
      for (uint64_t i = (void *)*v26; *v26; uint64_t i = (void *)*v26)
      {
        size_t v31 = i[1] & v28;
        if (v31 == v29)
        {
          uint64_t v26 = i;
        }
        else
        {
          uint64_t v32 = *((void *)v9 + 3);
          if (*(void *)(v32 + 8 * v31))
          {
            *uint64_t v26 = *i;
            uint64_t v33 = 8 * v31;
            void *i = **(void **)(*((void *)v9 + 3) + v33);
            **(void **)(*((void *)v9 + 3) + v33) = i;
          }
          else
          {
            *(void *)(v32 + 8 * v31) = v26;
            uint64_t v26 = i;
            size_t v29 = v31;
          }
        }
      }
LABEL_59:
      unint64_t v11 = prime;
      goto LABEL_60;
    }
    if (v27 >= prime) {
      v27 %= prime;
    }
    *(void *)(*((void *)v9 + 3) + 8 * v27) = v5;
    int v37 = (void *)*v26;
    if (!*v26) {
      goto LABEL_59;
    }
    while (1)
    {
      size_t v39 = v37[1];
      if (v39 >= prime) {
        v39 %= prime;
      }
      if (v39 != v27)
      {
        uint64_t v40 = *((void *)v9 + 3);
        if (!*(void *)(v40 + 8 * v39))
        {
          *(void *)(v40 + 8 * v39) = v26;
          goto LABEL_64;
        }
        *uint64_t v26 = *v37;
        uint64_t v38 = 8 * v39;
        *int v37 = **(void **)(*((void *)v9 + 3) + v38);
        **(void **)(*((void *)v9 + 3) + v38) = v37;
        int v37 = v26;
      }
      size_t v39 = v27;
LABEL_64:
      uint64_t v26 = v37;
      int v37 = (void *)*v37;
      size_t v27 = v39;
      if (!v37) {
        goto LABEL_59;
      }
    }
  }
  if (prime >= v11) {
    goto LABEL_60;
  }
  unint64_t v34 = vcvtps_u32_f32((float)*((unint64_t *)v9 + 6) / *((float *)v9 + 14));
  if (v11 < 3 || (uint8x8_t v35 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v35.i16[0] = vaddlv_u8(v35), v35.u32[0] > 1uLL))
  {
    unint64_t v34 = std::__next_prime(v34);
  }
  else
  {
    uint64_t v36 = 1 << -(char)__clz(v34 - 1);
    if (v34 >= 2) {
      unint64_t v34 = v36;
    }
  }
  if (prime <= v34) {
    size_t prime = v34;
  }
  if (prime < v11)
  {
    if (!prime)
    {
      unint64_t v87 = (void *)*((void *)v9 + 3);
      *((void *)v9 + 3) = 0;
      if (v87) {
        operator delete(v87);
      }
      unint64_t v11 = 0;
      *((void *)v9 + 4) = 0;
      goto LABEL_60;
    }
    goto LABEL_35;
  }
  unint64_t v11 = *((void *)v9 + 4);
LABEL_60:
  if ((v11 & (v11 - 1)) != 0)
  {
    if (v11 <= v10) {
      v10 %= v11;
    }
  }
  else
  {
    unint64_t v10 = (v11 - 1) & v10;
  }
LABEL_72:
  uint64_t v41 = *((void *)v9 + 3);
  double v42 = *(void **)(v41 + 8 * v10);
  if (v42)
  {
    *(void *)uint64_t v14 = *v42;
LABEL_80:
    *double v42 = v14;
    goto LABEL_81;
  }
  *(void *)uint64_t v14 = *(void *)v5;
  *(void *)uint64_t v5 = v14;
  *(void *)(v41 + 8 * v10) = v5;
  if (*(void *)v14)
  {
    unint64_t v43 = *(void *)(*(void *)v14 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v43 >= v11) {
        v43 %= v11;
      }
    }
    else
    {
      v43 &= v11 - 1;
    }
    double v42 = (void *)(*((void *)v9 + 3) + 8 * v43);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)v9 + 6);
LABEL_82:
  uint64_t v44 = *a4;
  uint64_t v45 = a4[1];
  unint64_t v46 = (v45
       + ((v44 - 0x61C8864680B583EBLL) << 6)
       + ((unint64_t)(v44 - 0x61C8864680B583EBLL) >> 2)
       - 0x61C8864680B583EBLL) ^ (v44 - 0x61C8864680B583EBLL);
  uint64_t v47 = *((int *)a4 + 1);
  uint64_t v48 = *((int *)a4 + 2);
  unint64_t v49 = (v47 + (v46 << 6) + (v46 >> 2) - 0x61C8864680B583EBLL) ^ v46;
  unint64_t v50 = v48 + (v49 << 6) + (v49 >> 2);
  unint64_t v51 = (v50 - 0x61C8864680B583EBLL) ^ v49;
  unint64_t v52 = *((void *)v14 + 4);
  if (v52)
  {
    uint8x8_t v53 = (uint8x8_t)vcnt_s8((int8x8_t)v52);
    v53.i16[0] = vaddlv_u8(v53);
    if (v53.u32[0] > 1uLL)
    {
      uint64_t v5 = (v50 - 0x61C8864680B583EBLL) ^ v49;
      if (v51 >= v52) {
        uint64_t v5 = v51 % v52;
      }
    }
    else
    {
      uint64_t v5 = v51 & (v52 - 1);
    }
    __int32 v54 = *(void ***)(*((void *)v14 + 3) + 8 * v5);
    if (v54)
    {
      unint64_t v55 = *v54;
      if (*v54)
      {
        if (v53.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v57 = v55[1];
            if (v57 == v51)
            {
              if (__PAIR64__(*((unsigned __int8 *)v55 + 17), *((unsigned __int8 *)v55 + 16)) == __PAIR64__(v45, v44)
                && *(void *)((char *)v55 + 20) == __PAIR64__(v48, v47))
              {
                goto LABEL_173;
              }
            }
            else if ((v57 & (v52 - 1)) != v5)
            {
              goto LABEL_106;
            }
            unint64_t v55 = (void *)*v55;
            if (!v55) {
              goto LABEL_106;
            }
          }
        }
        do
        {
          unint64_t v56 = v55[1];
          if (v56 == v51)
          {
            if (__PAIR64__(*((unsigned __int8 *)v55 + 17), *((unsigned __int8 *)v55 + 16)) == __PAIR64__(v45, v44)
              && *(void *)((char *)v55 + 20) == __PAIR64__(v48, v47))
            {
              goto LABEL_173;
            }
          }
          else
          {
            if (v56 >= v52) {
              v56 %= v52;
            }
            if (v56 != v5) {
              break;
            }
          }
          unint64_t v55 = (void *)*v55;
        }
        while (v55);
      }
    }
  }
LABEL_106:
  unint64_t v55 = operator new(0x30uLL);
  *unint64_t v55 = 0;
  v55[1] = v51;
  *((unsigned char *)v55 + 16) = v44;
  *((unsigned char *)v55 + 17) = v45;
  *(void *)((char *)v55 + 20) = *(void *)(a4 + 4);
  v55[5] = 0;
  float v58 = (float)(unint64_t)(*((void *)v14 + 6) + 1);
  float v59 = *((float *)v14 + 14);
  if (!v52 || (float)(v59 * (float)v52) < v58)
  {
    BOOL v60 = 1;
    if (v52 >= 3) {
      BOOL v60 = (v52 & (v52 - 1)) != 0;
    }
    unint64_t v61 = v60 | (2 * v52);
    unint64_t v62 = vcvtps_u32_f32(v58 / v59);
    if (v61 <= v62) {
      size_t v63 = v62;
    }
    else {
      size_t v63 = v61;
    }
    if (v63 == 1)
    {
      size_t v63 = 2;
    }
    else if ((v63 & (v63 - 1)) != 0)
    {
      size_t v63 = std::__next_prime(v63);
      unint64_t v52 = *((void *)v14 + 4);
    }
    if (v63 <= v52)
    {
      if (v63 >= v52) {
        goto LABEL_158;
      }
      unint64_t v76 = vcvtps_u32_f32((float)*((unint64_t *)v14 + 6) / *((float *)v14 + 14));
      if (v52 < 3 || (uint8x8_t v77 = (uint8x8_t)vcnt_s8((int8x8_t)v52), v77.i16[0] = vaddlv_u8(v77), v77.u32[0] > 1uLL))
      {
        unint64_t v76 = std::__next_prime(v76);
      }
      else
      {
        uint64_t v78 = 1 << -(char)__clz(v76 - 1);
        if (v76 >= 2) {
          unint64_t v76 = v78;
        }
      }
      if (v63 <= v76) {
        size_t v63 = v76;
      }
      if (v63 >= v52) {
        goto LABEL_158;
      }
      if (!v63)
      {
        uint8x8_t v83 = (void *)*((void *)v14 + 3);
        *((void *)v14 + 3) = 0;
        if (v83) {
          operator delete(v83);
        }
        *((void *)v14 + 4) = 0;
        goto LABEL_158;
      }
    }
    if (!(v63 >> 61))
    {
      long long v64 = operator new(8 * v63);
      uint64_t v65 = (void *)*((void *)v14 + 3);
      *((void *)v14 + 3) = v64;
      if (v65) {
        operator delete(v65);
      }
      uint64_t v66 = 0;
      *((void *)v14 + 4) = v63;
      do
        *(void *)(*((void *)v14 + 3) + 8 * v66++) = 0;
      while (v63 != v66);
      uint64_t v68 = (char *)(v14 + 20);
      uint64_t v67 = (void *)*((void *)v14 + 5);
      if (!v67) {
        goto LABEL_158;
      }
      size_t v69 = v67[1];
      size_t v70 = v63 - 1;
      if ((v63 & (v63 - 1)) == 0)
      {
        size_t v71 = v69 & v70;
        *(void *)(*((void *)v14 + 3) + 8 * v71) = v68;
        while (1)
        {
          int v72 = (void *)*v67;
          if (!*v67) {
            break;
          }
          size_t v73 = v72[1] & v70;
          if (v73 == v71)
          {
            uint64_t v67 = (void *)*v67;
          }
          else
          {
            uint64_t v74 = *((void *)v14 + 3);
            if (*(void *)(v74 + 8 * v73))
            {
              *uint64_t v67 = *v72;
              uint64_t v75 = 8 * v73;
              void *v72 = **(void **)(*((void *)v14 + 3) + v75);
              **(void **)(*((void *)v14 + 3) + v75) = v72;
            }
            else
            {
              *(void *)(v74 + 8 * v73) = v67;
              uint64_t v67 = v72;
              size_t v71 = v73;
            }
          }
        }
LABEL_158:
        unint64_t v52 = *((void *)v14 + 4);
        if ((v52 & (v52 - 1)) != 0)
        {
          if (v51 >= v52) {
            uint64_t v5 = v51 % v52;
          }
          else {
            uint64_t v5 = v51;
          }
        }
        else
        {
          uint64_t v5 = (v52 - 1) & v51;
        }
        goto LABEL_163;
      }
      if (v69 >= v63) {
        v69 %= v63;
      }
      *(void *)(*((void *)v14 + 3) + 8 * v69) = v68;
      uint64_t v79 = (void *)*v67;
      if (!*v67) {
        goto LABEL_158;
      }
      while (1)
      {
        size_t v81 = v79[1];
        if (v81 >= v63) {
          v81 %= v63;
        }
        if (v81 != v69)
        {
          uint64_t v82 = *((void *)v14 + 3);
          if (!*(void *)(v82 + 8 * v81))
          {
            *(void *)(v82 + 8 * v81) = v67;
            goto LABEL_144;
          }
          *uint64_t v67 = *v79;
          uint64_t v80 = 8 * v81;
          *uint64_t v79 = **(void **)(*((void *)v14 + 3) + v80);
          **(void **)(*((void *)v14 + 3) + v80) = v79;
          uint64_t v79 = v67;
        }
        size_t v81 = v69;
LABEL_144:
        uint64_t v67 = v79;
        uint64_t v79 = (void *)*v79;
        size_t v69 = v81;
        if (!v79) {
          goto LABEL_158;
        }
      }
    }
LABEL_183:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_163:
  uint64_t v84 = *((void *)v14 + 3);
  uint64_t v85 = *(void **)(v84 + 8 * v5);
  if (v85)
  {
    *unint64_t v55 = *v85;
LABEL_171:
    *uint64_t v85 = v55;
    goto LABEL_172;
  }
  *unint64_t v55 = *((void *)v14 + 5);
  *((void *)v14 + 5) = v55;
  *(void *)(v84 + 8 * v5) = v14 + 20;
  if (*v55)
  {
    unint64_t v86 = *(void *)(*v55 + 8);
    if ((v52 & (v52 - 1)) != 0)
    {
      if (v86 >= v52) {
        v86 %= v52;
      }
    }
    else
    {
      v86 &= v52 - 1;
    }
    uint64_t v85 = (void *)(*((void *)v14 + 3) + 8 * v86);
    goto LABEL_171;
  }
LABEL_172:
  ++*((void *)v14 + 6);
LABEL_173:
  v55[5] |= 2uLL;
}

void sub_1A256A014(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A256A028(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void md::RoadRenderLayer::featureMarker(uint64_t a1@<X1>, double *a2@<X2>, void *a3@<X8>)
{
  int8x8_t v3 = *(geo::codec::VectorTile **)(a1 + 640);
  *a3 = 0;
  a3[1] = 0;
  if (!v3) {
    return;
  }
  unint64_t v7 = geo::codec::VectorTile::linesCount(v3);
  uint64_t v8 = geo::codec::VectorTile::lines(*(geo::codec::VectorTile **)(a1 + 640));
  if (!v7) {
    return;
  }
  uint64_t v9 = v8;
  uint64_t v10 = 0;
  atomic_ullong v11 = 0;
  float v12 = *a2;
  float v13 = a2[1];
  float v14 = 1.0;
  do
  {
    uint64_t v15 = v9 + 168 * v10;
    if (*(_DWORD *)(v15 + 100)) {
      BOOL v16 = v11 == v15;
    }
    else {
      BOOL v16 = 1;
    }
    if (!v16)
    {
      for (unint64_t i = 0; i < *(unsigned int *)(v15 + 100); ++i)
      {
        uint64_t v34 = 0;
        float v18 = geo::codec::multiSectionFeaturePoints((void *)(v9 + 168 * v10), i, &v34);
        uint64_t v19 = v34;
        unint64_t v20 = (float *)(v18 + 1);
        while (--v19)
        {
          float v24 = v20[1];
          float v26 = *(v20 - 2);
          float v25 = *(v20 - 1);
          float v27 = *v20 - v26;
          float v28 = v24 - v25;
          float v29 = (float)((float)((float)(v12 - v26) * v27) + (float)((float)(v13 - v25) * (float)(v24 - v25)))
              / (float)((float)(v27 * v27) + (float)(v28 * v28));
          if (v29 < 0.0)
          {
            float v21 = v26 - v12;
            float v22 = v25 - v13;
          }
          else
          {
            if (v29 > 1.0)
            {
              float v23 = (float)((float)(*v20 - v12) * (float)(*v20 - v12))
                  + (float)((float)(v24 - v13) * (float)(v24 - v13));
              goto LABEL_14;
            }
            float v21 = (float)(v26 - v12) + (float)(v29 * v27);
            float v22 = (float)(v25 - v13) + (float)(v29 * v28);
          }
          float v23 = (float)(v21 * v21) + (float)(v22 * v22);
LABEL_14:
          v20 += 2;
          if (v23 < v14)
          {
            atomic_ullong v11 = v9 + 168 * v10;
            float v14 = v23;
            goto LABEL_5;
          }
        }
      }
    }
LABEL_5:
    ++v10;
  }
  while (v10 != v7);
  if (v14 < 0.0001)
  {
    int v30 = (atomic_ullong *)operator new(0x40uLL);
    size_t v31 = (std::__shared_weak_count *)v30;
    v30[2] = 0;
    v30[1] = 0;
    atomic_ullong *v30 = (atomic_ullong)&unk_1EF580E20;
    v30[5] = 0;
    v30[6] = 0;
    v30[3] = (atomic_ullong)&unk_1EF53CC50;
    v30[4] = 0;
    v30[7] = v11;
    *(void *)&long long v32 = v30 + 3;
    *((void *)&v32 + 1) = v30;
    atomic_fetch_add_explicit(v30 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(v30 + 2, 1uLL, memory_order_relaxed);
    v30[4] = (atomic_ullong)(v30 + 3);
    v30[5] = (atomic_ullong)v30;
    if (!atomic_fetch_add(v30 + 1, 0xFFFFFFFFFFFFFFFFLL))
    {
      long long v33 = v32;
      (*(void (**)(atomic_ullong *))(*v30 + 16))(v30);
      std::__shared_weak_count::__release_weak(v31);
      long long v32 = v33;
    }
    *(_OWORD *)a3 = v32;
  }
}

void sub_1A256A298(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void md::RoadRenderLayer::renderablesWillEnterView(uint64_t a1, __n128 a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4 = *a4;
  uint64_t v5 = a4[1];
  if (*a4 != v5)
  {
    do
    {
      uint64_t v7 = *(void *)(*(void *)v4 + 384);
      uint64_t v8 = *(md::RoadLayer **)(v7 + 720);
      if (v8) {
        a2 = md::RoadStyling::subscribeLayer((__n128 **)*(void *)(a1 + 480), v8, a2);
      }
      uint64_t v9 = *(md::RoadLayer **)(v7 + 736);
      if (v9) {
        a2 = md::RoadStyling::subscribeLayer((__n128 **)*(void *)(a1 + 480), v9, a2);
      }
      v4 += 8;
    }
    while (v4 != v5);
  }
}

char *md::RoadRenderLayer::reserveStencilRange(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  unsigned __int8 v6 = *(unsigned char *)(a1 + 49) - *(unsigned char *)(a1 + 48) + 1;
  uint64_t v7 = *(char **)(a1 + 416);
  uint64_t v8 = *(char **)(a1 + 424);
  if (v7 != v8)
  {
    while (*a3 != *v7 || a3[1] != v7[1])
    {
      v7 += 16;
      if (v7 == v8) {
        goto LABEL_9;
      }
    }
  }
  if (v7 == v8)
  {
LABEL_9:
    *(_WORD *)float v23 = *(_WORD *)a3;
    uint64_t v25 = 0;
    uint64_t v7 = geo::linear_map<md::CommandBufferLocation,ggl::ClearItem *,std::equal_to<md::CommandBufferLocation>,std::allocator<std::pair<md::CommandBufferLocation,ggl::ClearItem *>>,std::vector<std::pair<md::CommandBufferLocation,ggl::ClearItem *>>>::insert(a1 + 416, v23);
  }
  uint64_t v10 = *(unsigned __int8 **)(a2 + 24);
  int v11 = *v10;
  unsigned int v12 = v11 + v6;
  unsigned int v13 = v10[1];
  BOOL v14 = v12 > v13;
  if (v12 <= v13) {
    uint64_t v15 = 0;
  }
  else {
    uint64_t v15 = v10 + 4;
  }
  *((void *)v7 + 1) = v15;
  if (v14)
  {
    v10[1] = v10[2];
    int v11 = 1;
  }
  *uint64_t v10 = v11 + v6;
  int v16 = v11 - *(unsigned __int8 *)(a1 + 48);
  float v17 = *(char **)(a1 + 368);
  float v18 = *(char **)(a1 + 376);
  if (v17 != v18)
  {
    while (*a3 != *v17 || a3[1] != v17[1])
    {
      v17 += 8;
      if (v17 == v18) {
        goto LABEL_24;
      }
    }
  }
  if (v17 == v18)
  {
LABEL_24:
    *(_WORD *)float v23 = *(_WORD *)a3;
    int v24 = 0;
    float v17 = geo::linear_map<md::CommandBufferLocation,int,std::equal_to<md::CommandBufferLocation>,std::allocator<std::pair<md::CommandBufferLocation,int>>,std::vector<std::pair<md::CommandBufferLocation,int>>>::insert(a1 + 368, v23);
  }
  *((_DWORD *)v17 + 1) = v16;
  __n128 result = *(char **)(a1 + 392);
  float v21 = *(char **)(a1 + 400);
  if (result != v21)
  {
    while (*a3 != *result || a3[1] != result[1])
    {
      result += 8;
      if (result == v21) {
        goto LABEL_33;
      }
    }
  }
  if (result == v21)
  {
LABEL_33:
    *(_WORD *)float v23 = *(_WORD *)a3;
    int v24 = 0;
    __n128 result = geo::linear_map<md::CommandBufferLocation,int,std::equal_to<md::CommandBufferLocation>,std::allocator<std::pair<md::CommandBufferLocation,int>>,std::vector<std::pair<md::CommandBufferLocation,int>>>::insert(a1 + 392, v23);
  }
  *((_DWORD *)result + 1) = 0;
  return result;
}

void *md::RoadRenderLayer::layout(md::RoadRenderLayer *this, const md::LayoutContext *a2)
{
  uint64_t v425 = *MEMORY[0x1E4F143B8];
  v414[0] = &unk_1EF5714A8;
  v414[1] = a2;
  unint64_t v415 = v414;
  v412[0] = &unk_1EF5714F0;
  v412[1] = a2;
  uint64_t v413 = v412;
  unint64_t v417 = v416;
  v416[0] = &unk_1EF5714F0;
  v416[1] = a2;
  std::__function::__func<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()((uint64_t)v414);
  if (v413 == v412)
  {
    (*(void (**)(void *))(v412[0] + 32))(v412);
  }
  else if (v413)
  {
    (*(void (**)(void))(*v413 + 40))();
  }
  if (v415 == v414)
  {
    (*(void (**)(void *))(v414[0] + 32))(v414);
  }
  else if (v415)
  {
    (*(void (**)(void))(*v415 + 40))();
  }
  uint64_t v3 = mach_absolute_time();
  uint64_t v4 = *((void *)this + 44);
  *(void *)(v4 + 112) = 0;
  *(void *)(v4 + 120) = 0;
  uint64_t v5 = (void *)*((void *)a2 + 1);
  int8x8_t v6 = (int8x8_t)v5[1];
  if (!*(void *)&v6) {
    goto LABEL_32;
  }
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v8 = 0xC97B9E962ADF4AD4;
    if (*(void *)&v6 <= 0xC97B9E962ADF4AD4) {
      unint64_t v8 = 0xC97B9E962ADF4AD4 % *(void *)&v6;
    }
  }
  else
  {
    unint64_t v8 = (*(void *)&v6 - 1) & 0xC97B9E962ADF4AD4;
  }
  uint64_t v9 = *(void **)(*v5 + 8 * v8);
  if (!v9) {
    goto LABEL_32;
  }
  uint64_t v10 = (void *)*v9;
  if (!v10) {
    goto LABEL_32;
  }
  if (v7.u32[0] < 2uLL)
  {
    uint64_t v11 = *(void *)&v6 - 1;
    while (1)
    {
      uint64_t v13 = v10[1];
      if (v13 == 0xC97B9E962ADF4AD4)
      {
        if (v10[2] == 0xC97B9E962ADF4AD4) {
          goto LABEL_30;
        }
      }
      else if ((v13 & v11) != v8)
      {
        goto LABEL_32;
      }
      uint64_t v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_32;
      }
    }
  }
  while (1)
  {
    unint64_t v12 = v10[1];
    if (v12 == 0xC97B9E962ADF4AD4) {
      break;
    }
    if (v12 >= *(void *)&v6) {
      v12 %= *(void *)&v6;
    }
    if (v12 != v8) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v10 = (void *)*v10;
    if (!v10) {
      goto LABEL_32;
    }
  }
  if (v10[2] != 0xC97B9E962ADF4AD4) {
    goto LABEL_19;
  }
LABEL_30:
  uint64_t v14 = v10[5];
  if (*(void *)(v14 + 8) != 0xC97B9E962ADF4AD4)
  {
LABEL_32:
    uint64_t v15 = 0;
    goto LABEL_33;
  }
  uint64_t v15 = *(uint64_t **)(v14 + 32);
LABEL_33:
  int v16 = (unsigned __int8 *)*((void *)this + 61);
  int v17 = *v16;
  float v18 = *(void **)(*(void *)(*((void *)this + 5) + 24) + 8);
  uint64_t v19 = v18[3];
  uint64_t v20 = v18[4];
  uint64_t v21 = v20 - v19;
  uint64_t v353 = v3;
  if (v20 == v19) {
    goto LABEL_40;
  }
  uint64_t v22 = 0;
  unint64_t v23 = v21 >> 3;
  while (1)
  {
    int v24 = *(unsigned __int8 **)(v19 + 8 * v22);
    if (*v24 == v17)
    {
      unint64_t v25 = *((void *)v24 + 1);
      uint64_t v26 = v18[15];
      if (v25 < (v18[16] - v26) >> 3) {
        break;
      }
    }
    if (++v22 >= v23) {
      goto LABEL_40;
    }
  }
  uint64_t v27 = *(void *)(v26 + 8 * v25);
  if (!v27) {
LABEL_40:
  }
    uint64_t v28 = 0;
  else {
    uint64_t v28 = *(void *)(*(void *)(v27 + 24) + 8 * v16[1]);
  }
  uint64_t v355 = (char *)this + 368;
  float v29 = (char *)*((void *)this + 46);
  int v30 = (char *)*((void *)this + 47);
  if (v29 != v30)
  {
    while (1)
    {
      BOOL v31 = v17 == *v29 && v16[1] == v29[1];
      if (v31) {
        break;
      }
      v29 += 8;
      if (v29 == v30) {
        goto LABEL_50;
      }
    }
  }
  if (v29 == v30)
  {
LABEL_50:
    LOWORD(v390[0]) = *(_WORD *)v16;
    DWORD1(v390[0]) = 0;
    float v29 = geo::linear_map<md::CommandBufferLocation,int,std::equal_to<md::CommandBufferLocation>,std::allocator<std::pair<md::CommandBufferLocation,int>>,std::vector<std::pair<md::CommandBufferLocation,int>>>::insert((uint64_t)v355, (unsigned __int8 *)v390);
    long long v32 = this;
    int v16 = (unsigned __int8 *)*((void *)this + 61);
  }
  else
  {
    long long v32 = this;
  }
  int v357 = *((_DWORD *)v29 + 1);
  uint64_t v33 = (uint64_t)v32 + 392;
  uint64_t v34 = (char *)*((void *)v32 + 49);
  uint8x8_t v35 = (char *)*((void *)v32 + 50);
  if (v34 != v35)
  {
    while (*v16 != *v34 || v16[1] != v34[1])
    {
      v34 += 8;
      if (v34 == v35) {
        goto LABEL_59;
      }
    }
  }
  if (v34 == v35)
  {
LABEL_59:
    LOWORD(v390[0]) = *(_WORD *)v16;
    DWORD1(v390[0]) = 0;
    uint64_t v34 = geo::linear_map<md::CommandBufferLocation,int,std::equal_to<md::CommandBufferLocation>,std::allocator<std::pair<md::CommandBufferLocation,int>>,std::vector<std::pair<md::CommandBufferLocation,int>>>::insert(v33, (unsigned __int8 *)v390);
  }
  int v362 = *((_DWORD *)v34 + 1);
  uint64_t v37 = *(void *)(v28 + 72);
  if (*(void *)(v28 + 80) != v37) {
    *(void *)(v28 + 80) = v37;
  }
  LOBYTE(v390[0]) = 0;
  md::CartographicTiledVectorRenderLayer<md::RoadTileDataRenderable>::layoutStencilTiles((uint64_t)this, a2, v28, v357, v390);
  uint64_t v38 = *((void *)this + 61);
  if ((unint64_t)(*((void *)this + 62) - v38) < 3)
  {
    uint64_t v363 = 0;
    int v354 = 0;
    LOBYTE(v356) = 0;
  }
  else
  {
    int v39 = *(unsigned __int8 *)(v38 + 2);
    uint64_t v40 = *(void **)(*(void *)(*((void *)this + 5) + 24) + 8);
    uint64_t v41 = v40[3];
    uint64_t v42 = v40[4];
    uint64_t v43 = v42 - v41;
    if (v42 == v41) {
      goto LABEL_71;
    }
    uint64_t v44 = 0;
    unint64_t v45 = v43 >> 3;
    while (1)
    {
      unint64_t v46 = *(unsigned __int8 **)(v41 + 8 * v44);
      if (*v46 == v39)
      {
        unint64_t v47 = *((void *)v46 + 1);
        uint64_t v48 = v40[15];
        if (v47 < (v40[16] - v48) >> 3) {
          break;
        }
      }
      if (++v44 >= v45) {
        goto LABEL_71;
      }
    }
    uint64_t v49 = *(void *)(v48 + 8 * v47);
    if (!v49) {
LABEL_71:
    }
      uint64_t v50 = 0;
    else {
      uint64_t v50 = *(void *)(*(void *)(v49 + 24) + 8 * *(unsigned __int8 *)(v38 + 3));
    }
    uint64_t v51 = *(void *)(v50 + 72);
    if (*(void *)(v50 + 80) != v51) {
      *(void *)(v50 + 80) = v51;
    }
    uint64_t v363 = v50;
    unint64_t v52 = (char *)*((void *)this + 46);
    uint8x8_t v53 = (char *)*((void *)this + 47);
    if (v52 != v53)
    {
      while (v39 != *v52 || *(unsigned __int8 *)(v38 + 3) != v52[1])
      {
        v52 += 8;
        if (v52 == v53) {
          goto LABEL_83;
        }
      }
    }
    if (v52 == v53)
    {
LABEL_83:
      LOWORD(v390[0]) = *(_WORD *)(v38 + 2);
      DWORD1(v390[0]) = 0;
      unint64_t v52 = geo::linear_map<md::CommandBufferLocation,int,std::equal_to<md::CommandBufferLocation>,std::allocator<std::pair<md::CommandBufferLocation,int>>,std::vector<std::pair<md::CommandBufferLocation,int>>>::insert((uint64_t)v355, (unsigned __int8 *)v390);
      unint64_t v55 = this;
      uint64_t v38 = *((void *)this + 61);
    }
    else
    {
      unint64_t v55 = this;
    }
    int v354 = *((_DWORD *)v52 + 1);
    unint64_t v56 = (char *)*((void *)v55 + 49);
    uint64_t v57 = (char *)*((void *)v55 + 50);
    if (v56 != v57)
    {
      while (*(unsigned __int8 *)(v38 + 2) != *v56
           || *(unsigned __int8 *)(v38 + 3) != v56[1])
      {
        v56 += 8;
        if (v56 == v57) {
          goto LABEL_92;
        }
      }
    }
    if (v56 == v57)
    {
LABEL_92:
      LOWORD(v390[0]) = *(_WORD *)(v38 + 2);
      DWORD1(v390[0]) = 0;
      unint64_t v56 = geo::linear_map<md::CommandBufferLocation,int,std::equal_to<md::CommandBufferLocation>,std::allocator<std::pair<md::CommandBufferLocation,int>>,std::vector<std::pair<md::CommandBufferLocation,int>>>::insert(v33, (unsigned __int8 *)v390);
    }
    int v356 = *((_DWORD *)v56 + 1);
  }
  md::RibbonLayoutContext::RibbonLayoutContext((md::RibbonLayoutContext *)v378, a2);
  int v385 = 0x10000;
  int v386 = 1065353216;
  __int16 v387 = 0;
  uint64_t v388 = 0;
  char v379 = *((unsigned char *)this + 360);
  float v59 = +[VKDebugSettings sharedSettings];
  [v59 ribbonCrispness];
  int v381 = v60;

  uint64_t v368 = v28;
  uint64_t v61 = *((void *)this + 55);
  int v382 = *(_DWORD *)(*(void *)(v61 + 120) + 8);
  uint64_t v388 = v61;
  uint64_t v62 = *((void *)a2 + 3);
  unsigned int v63 = *(unsigned __int8 *)(v62 + 1);
  unsigned int v64 = *(unsigned __int8 *)(v62 + 2);
  int v65 = *((unsigned __int8 *)this + 360);
  md::RibbonLayoutContext::RibbonLayoutContext((md::RibbonLayoutContext *)v369, a2);
  uint64_t v374 = 0;
  uint64_t v375 = 0;
  memset_pattern16(&v376, &unk_1A28FFCB0, 0x10uLL);
  BOOL v66 = v65 == 0;
  v377[21] = 0;
  *(void *)unint64_t v377 = 0;
  *(void *)&v377[8] = 0;
  *(_DWORD *)&v377[15] = 0;
  if (v63 >= v64) {
    BOOL v66 = 0;
  }
  BYTE8(v370) = *((unsigned char *)this + 360) | (v63 < v64);
  v377[16] = **((unsigned char **)a2 + 92);
  v377[17] = 1;
  v377[18] = v66;
  +[VKDebugSettings sharedSettings];
  v68 = uint64_t v67 = v28;
  [v68 ribbonCrispness];
  DWORD1(v371) = v69;

  v377[19] = 1;
  size_t v70 = +[VKDebugSettings sharedSettings];
  v377[21] = [v70 showTrafficOffset];

  size_t v71 = (void *)*((void *)a2 + 1);
  int8x8_t v72 = (int8x8_t)v71[1];
  if (!*(void *)&v72)
  {
    LOBYTE(v76) = 0;
    uint64_t v74 = this;
    goto LABEL_122;
  }
  uint8x8_t v73 = (uint8x8_t)vcnt_s8(v72);
  v73.i16[0] = vaddlv_u8(v73);
  uint64_t v74 = this;
  if (v73.u32[0] > 1uLL)
  {
    unint64_t v75 = 0xDFC317497CF9A4BFLL;
    if (*(void *)&v72 <= 0xDFC317497CF9A4BFLL) {
      unint64_t v75 = 0xDFC317497CF9A4BFLL % *(void *)&v72;
    }
  }
  else
  {
    unint64_t v75 = (*(void *)&v72 - 1) & 0xDFC317497CF9A4BFLL;
  }
  uint8x8_t v77 = *(void **)(*v71 + 8 * v75);
  if (!v77) {
    goto LABEL_121;
  }
  uint64_t v78 = (void *)*v77;
  if (!v78) {
    goto LABEL_121;
  }
  if (v73.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v80 = v78[1];
      if (v80 == 0xDFC317497CF9A4BFLL)
      {
        if (v78[2] == 0xDFC317497CF9A4BFLL) {
          goto LABEL_118;
        }
      }
      else if ((v80 & (*(void *)&v72 - 1)) != v75)
      {
        goto LABEL_121;
      }
      uint64_t v78 = (void *)*v78;
      if (!v78) {
        goto LABEL_121;
      }
    }
  }
  while (1)
  {
    unint64_t v79 = v78[1];
    if (v79 == 0xDFC317497CF9A4BFLL) {
      break;
    }
    if (v79 >= *(void *)&v72) {
      v79 %= *(void *)&v72;
    }
    if (v79 != v75) {
      goto LABEL_121;
    }
LABEL_107:
    uint64_t v78 = (void *)*v78;
    if (!v78) {
      goto LABEL_121;
    }
  }
  if (v78[2] != 0xDFC317497CF9A4BFLL) {
    goto LABEL_107;
  }
LABEL_118:
  uint64_t v81 = v78[5];
  if (*(void *)(v81 + 8) != 0xDFC317497CF9A4BFLL)
  {
LABEL_121:
    LOBYTE(v76) = 0;
    goto LABEL_122;
  }
  uint64_t v76 = *(void *)(v81 + 32);
  if (v76) {
    LOBYTE(v76) = *(unsigned char *)(v76 + 64) != 0;
  }
LABEL_122:
  char v383 = v76;
  uint64_t v82 = *(void *)(*((void *)v74 + 5) + 24);
  uint64_t v83 = *(void *)(v82 + 160);
  if (v83
    && (uint64_t v84 = *(void *)(v82 + 8),
        unint64_t v85 = *(void *)(v83 + 32),
        uint64_t v86 = *(void *)(v84 + 96),
        v85 < (*(void *)(v84 + 104) - v86) >> 3))
  {
    uint64_t v87 = *(void *)(*(void *)(v86 + 8 * v85) + 16);
    uint64_t v384 = v87;
    if (!*(void *)&v72) {
      goto LABEL_157;
    }
  }
  else
  {
    uint64_t v87 = 0;
    uint64_t v384 = 0;
    if (!*(void *)&v72) {
      goto LABEL_157;
    }
  }
  uint8x8_t v88 = (uint8x8_t)vcnt_s8(v72);
  v88.i16[0] = vaddlv_u8(v88);
  if (v88.u32[0] > 1uLL)
  {
    unint64_t v89 = 0xA60DDA5A69582425;
    if (*(void *)&v72 <= 0xA60DDA5A69582425) {
      unint64_t v89 = 0xA60DDA5A69582425 % *(void *)&v72;
    }
  }
  else
  {
    unint64_t v89 = (*(void *)&v72 - 1) & 0xA60DDA5A69582425;
  }
  uint64_t v90 = *(void **)(*v71 + 8 * v89);
  if (v90)
  {
    char v91 = (void *)*v90;
    if (v91)
    {
      if (v88.u32[0] < 2uLL)
      {
        uint64_t v92 = *(void *)&v72 - 1;
        while (1)
        {
          uint64_t v94 = v91[1];
          if (v94 == 0xA60DDA5A69582425)
          {
            if (v91[2] == 0xA60DDA5A69582425) {
              goto LABEL_147;
            }
          }
          else if ((v94 & v92) != v89)
          {
            goto LABEL_157;
          }
          char v91 = (void *)*v91;
          if (!v91) {
            goto LABEL_157;
          }
        }
      }
      do
      {
        unint64_t v93 = v91[1];
        if (v93 == 0xA60DDA5A69582425)
        {
          if (v91[2] == 0xA60DDA5A69582425)
          {
LABEL_147:
            uint64_t v95 = v91[5];
            if (*(void *)(v95 + 8) == 0xA60DDA5A69582425)
            {
              uint64_t v96 = *(id **)(v95 + 32);
              if (v96 && v87 == 0)
              {
                id v98 = *v96;
                [v98 textureManager];
                double v99 = (std::__shared_weak_count *)*((void *)&v390[0] + 1);
                uint64_t v384 = **(void **)&v390[0];
                if (*((void *)&v390[0] + 1)
                  && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v390[0] + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v99->__on_zero_shared)(v99);
                  std::__shared_weak_count::__release_weak(v99);
                }

                uint64_t v74 = this;
              }
            }
            break;
          }
        }
        else
        {
          if (v93 >= *(void *)&v72) {
            v93 %= *(void *)&v72;
          }
          if (v93 != v89) {
            break;
          }
        }
        char v91 = (void *)*v91;
      }
      while (v91);
    }
  }
LABEL_157:
  unint64_t v361 = a2;
  uint64_t v100 = (uint64_t *)*((void *)v74 + 60);
  uint64_t v101 = *v100;
  uint64_t v102 = v100[1];
  if (*v100 != v102)
  {
    do
    {
      md::RoadStyle::layout(*(void *)(v101 + 32), (uint64_t)v378);
      v101 += 48;
    }
    while (v101 != v102);
  }
  if (!v15)
  {
    BOOL v360 = 0;
    char v106 = a2;
    goto LABEL_183;
  }
  uint64_t v103 = *v15;
  uint64_t v104 = v15[1];
  uint64_t v105 = *v15;
  BOOL v31 = *v15 == v104;
  char v106 = a2;
  double v107 = this;
  if (!v31)
  {
    uint64_t v105 = v103;
    while (*(unsigned char *)v105 != 2)
    {
      v105 += 16;
      if (v105 == v104) {
        goto LABEL_168;
      }
    }
  }
  if (v105 == v104 || !*(void *)(v105 + 8))
  {
LABEL_168:
    if (v103 != v104)
    {
      while (*(unsigned char *)v103 != 4)
      {
        v103 += 16;
        if (v103 == v104) {
          goto LABEL_175;
        }
      }
    }
    if (v103 == v104) {
LABEL_175:
    }
      uint64_t v109 = 0;
    else {
      uint64_t v109 = *(void *)(v103 + 8);
    }
    BOOL v108 = v109 != 0;
  }
  else
  {
    BOOL v108 = 1;
  }
  BOOL v360 = 0;
  if (*((void *)this + 58) && v108)
  {
    uint64_t v110 = +[VKDebugSettings sharedSettings];
    if ([v110 showTrafficCasing]) {
      BOOL v360 = *((_DWORD *)this + 91) == 2;
    }
    else {
      BOOL v360 = 0;
    }

LABEL_183:
    double v107 = this;
  }
  uint64_t v111 = (uint64_t *)*((void *)v107 + 34);
  uint64_t v359 = (uint64_t *)*((void *)v107 + 35);
  if (v111 != v359)
  {
    char v358 = 0;
LABEL_187:
    uint64_t v366 = v111;
    uint64_t v112 = *v111;
    uint64_t v113 = *(void *)(*v111 + 384);
    uint64_t v114 = *(void *)(v113 + 752);
    if (v114) {
      LOBYTE(v114) = *(void *)(v114 + 16) != *(void *)(v114 + 8);
    }
    HIBYTE(v385) = v114;
    md::RoadTileData::updateWithContext(v113, v106, *(char *)(v112 + 48), (uint64_t *)(v112 + 232));
    char v115 = v362;
    if (v379) {
      char v115 = v357 + *(unsigned char *)(v113 + 169);
    }
    char v380 = v115;
    uint64_t v116 = *(void *)(v113 + 720);
    if (v116)
    {
      uint64_t v117 = *(void *)(v116 + 200);
      uint64_t v118 = *((void *)v107 + 55);
      if (v117) {
        BOOL v119 = v117 == v118;
      }
      else {
        BOOL v119 = 0;
      }
      if (!v119) {
        md::RoadLayer::setSharedResources(*(void **)(v113 + 720), v118);
      }
      md::RoadLayer::layout(v116, (uint64_t)v378);
      md::Ribbons::RibbonLayer<md::Ribbons::RoadRibbonDescriptor>::collectRenderItemsForPasses(*(void **)(v116 + 8), *(void **)(v116 + 16), v67, v120);
    }
    uint64_t v121 = *(void *)(v113 + 736);
    if (v121)
    {
      uint64_t v122 = *(void *)(v121 + 200);
      uint64_t v123 = *((void *)v107 + 55);
      if (v122) {
        BOOL v124 = v122 == v123;
      }
      else {
        BOOL v124 = 0;
      }
      if (!v124) {
        md::RoadLayer::setSharedResources(*(void **)(v113 + 736), v123);
      }
      if (v363)
      {
        char v125 = v356;
        if (v379) {
          char v125 = v354 + *(unsigned char *)(v113 + 169);
        }
        char v380 = v125;
        md::RoadLayer::layout(v121, (uint64_t)v378);
        md::Ribbons::RibbonLayer<md::Ribbons::RoadRibbonDescriptor>::collectRenderItemsForPasses(*(void **)(v121 + 8), *(void **)(v121 + 16), v363, v126);
      }
      else
      {
        md::RoadLayer::layout(v121, (uint64_t)v378);
        md::Ribbons::RibbonLayer<md::Ribbons::RoadRibbonDescriptor>::collectRenderItemsForPasses(*(void **)(v121 + 8), *(void **)(v121 + 16), v67, v127);
      }
      char v358 = 1;
    }
    uint64_t v128 = *(void *)(v113 + 728);
    uint64_t v129 = *(void *)(v113 + 744);
    if (v128 | v129)
    {
      md::RibbonLayoutContext::RibbonLayoutContext((md::RibbonLayoutContext *)v390, v106);
      *(_WORD *)((char *)&v394 + 9) = 0;
      BYTE11(v394) = 0;
      HIDWORD(v394) = 1065353216;
      v395.i8[0] = 0;
      int v130 = *((unsigned __int8 *)v107 + 360);
      BYTE8(v391) = *((unsigned char *)v107 + 360);
      if (v128)
      {
        uint64_t v131 = *(void *)(v128 + 192);
        uint64_t v132 = *((void *)v107 + 59);
        if (v131) {
          BOOL v133 = v131 == v132;
        }
        else {
          BOOL v133 = 0;
        }
        if (!v133) {
          *(void *)(v128 + 192) = v132;
        }
        char v134 = v362;
        if (v130) {
          char v134 = v357 + *(unsigned char *)(v113 + 169);
        }
        BYTE9(v391) = v134;
        md::PatternedLayer::layout(v128, (uint64_t)v390);
        md::Ribbons::RibbonLayer<md::Ribbons::PatternedRibbonDescriptor>::collectRenderItemsForPasses(*(void **)(v128 + 8), *(void **)(v128 + 16), v67, v135);
      }
      if (v129)
      {
        uint64_t v136 = *(void *)(v129 + 192);
        uint64_t v137 = *((void *)v107 + 59);
        if (v136) {
          BOOL v138 = v136 == v137;
        }
        else {
          BOOL v138 = 0;
        }
        if (!v138) {
          *(void *)(v129 + 192) = v137;
        }
        if (v363)
        {
          char v139 = v356;
          if (BYTE8(v391)) {
            char v139 = v354 + *(unsigned char *)(v113 + 169);
          }
          BYTE9(v391) = v139;
          md::PatternedLayer::layout(v129, (uint64_t)v390);
          md::Ribbons::RibbonLayer<md::Ribbons::PatternedRibbonDescriptor>::collectRenderItemsForPasses(*(void **)(v129 + 8), *(void **)(v129 + 16), v363, v140);
        }
        else
        {
          md::PatternedLayer::layout(v129, (uint64_t)v390);
          md::Ribbons::RibbonLayer<md::Ribbons::PatternedRibbonDescriptor>::collectRenderItemsForPasses(*(void **)(v129 + 8), *(void **)(v129 + 16), v67, v141);
        }
        char v358 = 1;
      }
    }
    if (!v360) {
      goto LABEL_186;
    }
    uint64_t v142 = (uint64_t *)*((void *)v106 + 1);
    int8x8_t v143 = (int8x8_t)v142[1];
    uint8x8_t v144 = (uint8x8_t)vcnt_s8(v143);
    v144.i16[0] = vaddlv_u8(v144);
    if (v144.u32[0] > 1uLL)
    {
      unint64_t v145 = 0xE42D19AFCA302E68;
      if (*(void *)&v143 <= 0xE42D19AFCA302E68) {
        unint64_t v145 = 0xE42D19AFCA302E68 % *(void *)&v143;
      }
    }
    else
    {
      unint64_t v145 = (*(void *)&v143 - 1) & 0xE42D19AFCA302E68;
    }
    uint64_t v146 = *v142;
    unint64_t v147 = *(void **)(v146 + 8 * v145);
    if (!v147) {
      goto LABEL_259;
    }
    long long v148 = (void *)*v147;
    if (!v148) {
      goto LABEL_259;
    }
    if (v144.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v150 = v148[1];
        if (v150 == 0xE42D19AFCA302E68)
        {
          if (v148[2] == 0xE42D19AFCA302E68) {
            goto LABEL_253;
          }
        }
        else if ((v150 & (*(void *)&v143 - 1)) != v145)
        {
          goto LABEL_259;
        }
        long long v148 = (void *)*v148;
        if (!v148) {
          goto LABEL_259;
        }
      }
    }
    while (1)
    {
      unint64_t v149 = v148[1];
      if (v149 == 0xE42D19AFCA302E68) {
        break;
      }
      if (v149 >= *(void *)&v143) {
        v149 %= *(void *)&v143;
      }
      if (v149 != v145) {
        goto LABEL_259;
      }
LABEL_242:
      long long v148 = (void *)*v148;
      if (!v148) {
        goto LABEL_259;
      }
    }
    if (v148[2] != 0xE42D19AFCA302E68) {
      goto LABEL_242;
    }
LABEL_253:
    uint64_t v151 = v148[5];
    if (*(void *)(v151 + 8) == 0xE42D19AFCA302E68)
    {
      long long v152 = *(uint64_t **)(v151 + 32);
      if (v144.u32[0] > 1uLL) {
        goto LABEL_255;
      }
LABEL_260:
      unint64_t v153 = (*(void *)&v143 - 1) & 0x8BD499FBD96FBB9ELL;
      char v154 = *(void **)(v146 + 8 * v153);
      if (v154) {
        goto LABEL_261;
      }
LABEL_278:
      uint64_t v160 = 0;
      goto LABEL_279;
    }
LABEL_259:
    long long v152 = 0;
    if (v144.u32[0] <= 1uLL) {
      goto LABEL_260;
    }
LABEL_255:
    unint64_t v153 = 0x8BD499FBD96FBB9ELL;
    if (*(void *)&v143 <= 0x8BD499FBD96FBB9ELL) {
      unint64_t v153 = 0x8BD499FBD96FBB9ELL % *(void *)&v143;
    }
    char v154 = *(void **)(v146 + 8 * v153);
    if (!v154) {
      goto LABEL_278;
    }
LABEL_261:
    __int8 v155 = (void *)*v154;
    if (!v155) {
      goto LABEL_278;
    }
    if (v144.u32[0] < 2uLL)
    {
      uint64_t v156 = *(void *)&v143 - 1;
      while (1)
      {
        uint64_t v158 = v155[1];
        if (v158 == 0x8BD499FBD96FBB9ELL)
        {
          if (v155[2] == 0x8BD499FBD96FBB9ELL) {
            goto LABEL_276;
          }
        }
        else if ((v158 & v156) != v153)
        {
          goto LABEL_278;
        }
        __int8 v155 = (void *)*v155;
        if (!v155) {
          goto LABEL_278;
        }
      }
    }
    while (2)
    {
      unint64_t v157 = v155[1];
      if (v157 != 0x8BD499FBD96FBB9ELL)
      {
        if (v157 >= *(void *)&v143) {
          v157 %= *(void *)&v143;
        }
        if (v157 != v153) {
          goto LABEL_278;
        }
        goto LABEL_265;
      }
      if (v155[2] != 0x8BD499FBD96FBB9ELL)
      {
LABEL_265:
        __int8 v155 = (void *)*v155;
        if (!v155) {
          goto LABEL_278;
        }
        continue;
      }
      break;
    }
LABEL_276:
    uint64_t v159 = v155[5];
    if (*(void *)(v159 + 8) != 0x8BD499FBD96FBB9ELL) {
      goto LABEL_278;
    }
    uint64_t v160 = *(unsigned __int8 **)(v159 + 32);
LABEL_279:
    uint64_t v161 = *v152;
    *(void *)((char *)v390 + 7) = 0;
    *(void *)&v390[0] = 0;
    HIBYTE(v390[0]) = 1;
    gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes(&v400, v161, (gss::FeatureAttributeSet *)(v113 + 824), (gss::QueryOverrides *)v390);
    uint64_t v162 = (unsigned __int8 *)*((void *)v107 + 61);
    char v164 = (char *)*((void *)v107 + 46);
    char v163 = (char *)*((void *)v107 + 47);
    memset_pattern16(&__b, &unk_1A28FFCB0, 0x10uLL);
    if (v164 == v163) {
      goto LABEL_287;
    }
    while (*v162 != *v164 || v162[1] != v164[1])
    {
      v164 += 8;
      if (v164 == v163) {
        goto LABEL_287;
      }
    }
    if (v164 == v163)
    {
LABEL_287:
      LOWORD(v390[0]) = *(_WORD *)v162;
      DWORD1(v390[0]) = 0;
      char v164 = geo::linear_map<md::CommandBufferLocation,int,std::equal_to<md::CommandBufferLocation>,std::allocator<std::pair<md::CommandBufferLocation,int>>,std::vector<std::pair<md::CommandBufferLocation,int>>>::insert((uint64_t)v355, (unsigned __int8 *)v390);
    }
    int v166 = *((_DWORD *)v164 + 1);
    long long v392 = v371;
    long long v393 = v372;
    long long v394 = v373;
    v390[0] = v369[0];
    v390[1] = v369[1];
    v390[2] = v369[2];
    long long v391 = v370;
    char v167 = v375;
    if (v375) {
      atomic_fetch_add_explicit(&v375->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    long long v397 = v376;
    *(_OWORD *)unint64_t v398 = *(_OWORD *)v377;
    *(void *)&v398[14] = *(void *)&v377[14];
    uint64_t v168 = v400;
    long long v169 = v401;
    if (v401) {
      atomic_fetch_add_explicit(&v401->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint16x4_t v395 = (uint16x4_t)v168;
    unint64_t v396 = v169;
    if (v167 && !atomic_fetch_add(&v167->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v167->__on_zero_shared)(v167);
      std::__shared_weak_count::__release_weak(v167);
    }
    if (*((unsigned char *)this + 360)) {
      char v170 = v166 + *(unsigned char *)(v113 + 169);
    }
    else {
      char v170 = *(unsigned char *)(*((void *)v361 + 3) + 1);
    }
    BYTE9(v391) = v170;
    long long v397 = __b;
    uint64_t v171 = +[VKDebugSettings sharedSettings];
    int v172 = [v171 loadGreenTraffic];

    uint64_t v173 = *(void *)(v113 + 752);
    uint64_t v174 = *(void *)(v113 + 760);
    if (v173)
    {
      uint64_t v176 = *(uint64_t **)(v173 + 8);
      uint8x8_t v175 = *(uint64_t **)(v173 + 16);
      if (v175 != v176)
      {
        memset_pattern16(&__b, &unk_1A28FFCC0, 0x10uLL);
        int v177 = *v160;
        v398[20] = v177 ^ 1;
        if (v177) {
          float v178 = 0.0;
        }
        else {
          float v178 = 1.0;
        }
        *(float *)&v398[12] = v178;
        uint64_t v179 = *(void *)(v173 + 152);
        uint64_t v180 = *((void *)this + 58);
        if (!v179 || v179 != v180)
        {
          *(void *)(v173 + 152) = v180;
          do
          {
            uint64_t v181 = *v176++;
            **(void **)(*(void *)(v181 + 328) + 96) = *(void *)(*(void *)(*(void *)(*(void *)(v181 + 8)
                                                                                              + 152)
                                                                                  + 128)
                                                                      + 16);
          }
          while (v176 != v175);
        }
        md::DaVinciTrafficLayer::layout((md::DaVinciTrafficLayer *)v173, (const md::TrafficContext *)v390);
        md::Ribbons::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::collectRenderItemsForPasses(*(uint64_t **)(v173 + 8), *(uint64_t **)(v173 + 16), v67, v182);
      }
    }
    if (!v174 || *(void *)(v174 + 16) == *(void *)(v174 + 8))
    {
      char v106 = v361;
      double v107 = this;
      double v198 = v396;
      if (v396) {
        goto LABEL_572;
      }
      goto LABEL_573;
    }
    uint64_t v183 = v400;
    double v184 = v401;
    uint64_t v404 = (void (**)(ggl::RenderItem *__hidden))v400;
    *(void *)&long long v405 = v401;
    if (v401) {
      atomic_fetch_add_explicit(&v401->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v389, (uint64_t)v183, (uint64_t)v184);
    if (v184 && !atomic_fetch_add(&v184->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v184->__on_zero_shared)(v184);
      std::__shared_weak_count::__release_weak(v184);
    }
    md::TrafficMeshStyle::overrideSetup((int *)&__b, (uint64_t)v389, v172, 3);
    double v185 = *(void **)(v174 + 152);
    double v186 = (void *)*((void *)this + 58);
    if (v185 && v185 == v186
      || (*(void *)(v174 + 152) = v186,
          double v187 = *(uint64_t **)(v174 + 8),
          double v188 = *(uint64_t **)(v174 + 16),
          double v185 = v186,
          v187 == v188))
    {
LABEL_345:
      if (v398[18])
      {
        double v199 = v185 + 13;
        double v200 = v185 + 14;
      }
      else
      {
        double v199 = v185 + 9;
        if (BYTE8(v391)) {
          double v199 = v185 + 11;
        }
        double v201 = v185 + 10;
        double v200 = v185 + 12;
        if (!BYTE8(v391)) {
          double v200 = v201;
        }
      }
      if (!v398[16]) {
        double v200 = v199;
      }
      *(void *)(v174 + 56) = *v200;
      double v202 = *(void **)(*(void *)&v390[0] + 8);
      int8x8_t v203 = (int8x8_t)v202[1];
      if (v203)
      {
        uint8x8_t v204 = (uint8x8_t)vcnt_s8(v203);
        v204.i16[0] = vaddlv_u8(v204);
        if (v204.u32[0] > 1uLL)
        {
          uint64_t v205 = 0x1AF456233693CD46;
          if (*(void *)&v203 <= 0x1AF456233693CD46uLL) {
            uint64_t v205 = 0x1AF456233693CD46uLL % *(void *)&v203;
          }
        }
        else
        {
          uint64_t v205 = (*(void *)&v203 - 1) & 0x1AF456233693CD46;
        }
        double v206 = *(void **)(*v202 + 8 * v205);
        if (v206)
        {
          double v207 = (void *)*v206;
          if (v207)
          {
            if (v204.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v209 = v207[1];
                if (v209 == 0x1AF456233693CD46)
                {
                  if (v207[2] == 0x1AF456233693CD46) {
                    goto LABEL_374;
                  }
                }
                else if ((v209 & (*(void *)&v203 - 1)) != v205)
                {
                  goto LABEL_381;
                }
                double v207 = (void *)*v207;
                if (!v207) {
                  goto LABEL_381;
                }
              }
            }
            do
            {
              unint64_t v208 = v207[1];
              if (v208 == 0x1AF456233693CD46)
              {
                if (v207[2] == 0x1AF456233693CD46)
                {
LABEL_374:
                  uint64_t v210 = v207[5];
                  if (*(void *)(v210 + 8) != 0x1AF456233693CD46) {
                    break;
                  }
                  uint64_t v211 = *(void *)(v210 + 32);
                  if (!*(unsigned char *)(v211 + 3776)) {
                    goto LABEL_376;
                  }
LABEL_382:
                  uint64_t v213 = *(void *)(v174 + 72);
                  if (v213)
                  {
                    int v214 = gdc::GlobeTileGrid::intersectWithFrustum(v213, (const double *)(v211 + 984), *(double *)(v211 + 24));
LABEL_401:
                    double v223 = *(uint64_t **)(v174 + 8);
                    double v222 = *(uint64_t **)(v174 + 16);
                    if (v223 == v222) {
                      goto LABEL_497;
                    }
                    do
                    {
                      uint64_t v225 = *v223;
                      double v226 = *(uint64_t **)(*v223 + 248);
                      double v227 = *(uint64_t **)(*v223 + 256);
                      if (v226 == v227)
                      {
                        char v224 = 0;
                      }
                      else
                      {
                        char v224 = 0;
                        do
                        {
                          uint64_t v228 = *v226++;
                          BOOL v229 = (*(_DWORD *)(v228 + 96) & v214) != 0;
                          v224 |= v229;
                          *(unsigned char *)(v228 + 48) = v229;
                        }
                        while (v226 != v227);
                      }
                      *(unsigned char *)(v225 + 136) = v224 & 1;
                      *(unsigned char *)(v225 + 272) = v224 & 1;
                      ++v223;
                    }
                    while (v223 != v222);
                    double v230 = *(uint64_t **)(v174 + 8);
                    double v223 = *(uint64_t **)(v174 + 16);
                    if (v230 == v223)
                    {
LABEL_497:
                      float32x2_t v282 = (void (**)(void *))&unk_1EF578FD8;
                      v418[0] = &unk_1EF578FD8;
                      v418[1] = v67;
                      unint64_t v419 = v418;
                      float v283 = *(uint64_t **)(v174 + 8);
                      if (v283 == v223)
                      {
                        char v106 = v361;
                        double v107 = this;
                        goto LABEL_570;
                      }
                      unint64_t v284 = (float *)v418;
                      while (2)
                      {
                        uint64_t v285 = *v283;
                        if (v284)
                        {
                          if (v284 != (float *)v418)
                          {
                            unint64_t v284 = (float *)(*(uint64_t (**)(float *))(*(void *)v284 + 16))(v284);
                            goto LABEL_504;
                          }
                          BOOL v421 = v420;
                          (*(void (**)(void *, float *))(v418[0] + 24))(v418, v420);
                        }
                        else
                        {
LABEL_504:
                          BOOL v421 = v284;
                        }
                        if (*(unsigned char *)(v285 + 272))
                        {
                          uint64_t v287 = *(void *)(v285 + 168);
                          uint64_t v286 = *(void *)(v285 + 176);
                          if (v286 != v287)
                          {
                            uint64_t v288 = *(void *)(v285 + 176);
                            do
                            {
                              uint64_t v290 = *(void **)(v288 - 24);
                              v288 -= 24;
                              char v289 = v290;
                              if (v290)
                              {
                                *(void *)(v286 - 16) = v289;
                                operator delete(v289);
                              }
                              uint64_t v286 = v288;
                            }
                            while (v288 != v287);
                          }
                          *(void *)(v285 + 176) = v287;
                          *(void *)(v285 + 152) = *(void *)(v285 + 144);
                          float v291 = *(void **)(v285 + 224);
                          if (v291)
                          {
                            do
                            {
                              if (v291[1])
                              {
                                unint64_t v293 = 0;
                                unint64_t v294 = v291 + 2;
                                uint64_t v295 = v291 + 2;
                                int8x16x2_t v296 = (void (***)(void))(v291 + 2);
                                do
                                {
                                  uint64_t v297 = (void (**)(void *))*v296;
                                  v296 += 15;
                                  (*v297)(v295);
                                  ++v293;
                                  v294 += 15;
                                  uint64_t v295 = v296;
                                }
                                while (v293 < v291[1]);
                              }
                              v291[1] = 0;
                              float v291 = (void *)*v291;
                            }
                            while (v291);
                            uint64_t v292 = *(void *)(v285 + 224);
                          }
                          else
                          {
                            uint64_t v292 = 0;
                          }
                          *(void *)(v285 + 232) = v292;
                          uint64_t v298 = (uint64_t)v421;
                          if (v421)
                          {
                            if (v421 != v420)
                            {
                              uint64_t v298 = (*(uint64_t (**)(void))(*(void *)v421 + 16))();
                              goto LABEL_523;
                            }
                            unint64_t v424 = (uint16x4_t *)&v422;
                            (*(void (**)(float *, uint64_t **))(*(void *)v420 + 24))(v420, &v422);
                          }
                          else
                          {
LABEL_523:
                            unint64_t v424 = (uint16x4_t *)v298;
                          }
                          if (*(unsigned char *)(v285 + 272))
                          {
                            if (*(unsigned char *)(v285 + 136))
                            {
                              uint64_t v299 = *(void *)(*(void *)(v285 + 8) + 56);
                              *(void *)(v285 + 40) = v299;
                              BOOL v300 = *(unsigned __int8 *)(v299 + 58) == 1;
                            }
                            else
                            {
                              BOOL v300 = 0;
                            }
                            size_t v302 = *(uint64_t **)(v285 + 248);
                            size_t v301 = *(uint64_t **)(v285 + 256);
                            if (v302 != v301)
                            {
                              uint64_t v303 = 0;
                              while (1)
                              {
                                uint64_t v304 = *v302;
                                if (*(unsigned char *)(*v302 + 48))
                                {
                                  if (*(void *)(v304 + 88) != v303)
                                  {
                                    if (v303)
                                    {
                                      uint64_t v305 = ggl::Batcher::commit((long long **)(v285 + 144), 0xC8u, v215);
                                      if (v305[1] != *v305)
                                      {
                                        if (*(unsigned char *)(v285 + 136))
                                        {
                                          uint64_t v306 = v305;
                                          long long v308 = *(_OWORD *)(v285 + 24);
                                          long long v307 = *(_OWORD *)(v285 + 40);
                                          long long v309 = *(_OWORD *)(v285 + 56);
                                          long long v310 = *(_OWORD *)(v285 + 72);
                                          long long v311 = *(_OWORD *)(v285 + 88);
                                          long long v312 = *(_OWORD *)(v285 + 120);
                                          long long v410 = *(_OWORD *)(v285 + 104);
                                          long long v411 = v312;
                                          uint64_t v404 = &off_1EF55A458;
                                          long long v405 = v308;
                                          long long v406 = v307;
                                          long long v408 = v310;
                                          long long v409 = v311;
                                          long long v407 = v309;
                                          size_t v313 = *(void **)(v285 + 232);
                                          uint64_t v314 = v313[1];
                                          if (v314 == *(void *)(v285 + 240))
                                          {
                                            size_t v313 = (void *)*v313;
                                            if (!v313)
                                            {
                                              size_t v313 = malloc_type_malloc(120 * v314 + 16, 0xB644C221uLL);
                                              void *v313 = 0;
                                              v313[1] = 0;
                                              **(void **)(v285 + 232) = v313;
                                            }
                                            *(void *)(v285 + 232) = v313;
                                            uint64_t v314 = v313[1];
                                          }
                                          uint64_t v315 = &v313[15 * v314];
                                          v313[1] = v314 + 1;
                                          v315[2] = &off_1EF55A458;
                                          long long v316 = v410;
                                          long long v317 = v411;
                                          long long v318 = v409;
                                          *(_OWORD *)(v315 + 9) = v408;
                                          long long v319 = v405;
                                          long long v320 = v406;
                                          *(_OWORD *)(v315 + 7) = v407;
                                          *(_OWORD *)(v315 + 5) = v320;
                                          *(_OWORD *)(v315 + 3) = v319;
                                          *(_OWORD *)(v315 + 15) = v317;
                                          *(_OWORD *)(v315 + 13) = v316;
                                          *(_OWORD *)(v315 + 11) = v318;
                                          v315[10] = v303;
                                          uint8x8_t v321 = *v306;
                                          v315[13] = *v306;
                                          v315[14] = (v306[1] - v321) >> 4;
                                          int v403 = 0;
                                          uint64_t v404 = (void (**)(ggl::RenderItem *__hidden))(v315 + 2);
                                          if (!v424) {
                                            goto LABEL_599;
                                          }
                                          (*(void (**)(uint16x4_t *, int *, void (***)(ggl::RenderItem *__hidden)))(*(void *)v424 + 48))(v424, &v403, &v404);
                                        }
                                      }
                                    }
                                    uint64_t v304 = *v302;
                                    uint64_t v303 = *(void *)(*v302 + 88);
                                  }
                                  uint64_t v322 = 16;
                                  if (v300)
                                  {
                                    uint64_t v322 = 32;
                                    uint64_t v323 = v304 + 32;
                                  }
                                  else
                                  {
                                    uint64_t v323 = v304 + 16;
                                  }
                                  if (*(void *)(v323 + 8) != *(void *)(v304 + v322)) {
                                    gm::MultiRange<unsigned long>::push_back((char **)(v285 + 144), (_OWORD *)v323);
                                  }
                                }
                                if (++v302 == v301) {
                                  goto LABEL_550;
                                }
                              }
                            }
                            uint64_t v303 = 0;
LABEL_550:
                            unint64_t v324 = ggl::Batcher::commit((long long **)(v285 + 144), 0xC8u, v215);
                            uint64_t v67 = v368;
                            if (v324[1] != *v324)
                            {
                              if (*(unsigned char *)(v285 + 136))
                              {
                                uint64_t v325 = v324;
                                long long v326 = *(_OWORD *)(v285 + 40);
                                long long v327 = *(_OWORD *)(v285 + 24);
                                long long v328 = *(_OWORD *)(v285 + 56);
                                long long v329 = *(_OWORD *)(v285 + 72);
                                long long v330 = *(_OWORD *)(v285 + 88);
                                long long v331 = *(_OWORD *)(v285 + 120);
                                long long v410 = *(_OWORD *)(v285 + 104);
                                long long v411 = v331;
                                uint64_t v404 = &off_1EF55A458;
                                long long v405 = v327;
                                long long v406 = v326;
                                long long v408 = v329;
                                long long v409 = v330;
                                long long v407 = v328;
                                unint64_t v332 = *(void **)(v285 + 232);
                                uint64_t v333 = v332[1];
                                if (v333 == *(void *)(v285 + 240))
                                {
                                  unint64_t v332 = (void *)*v332;
                                  if (!v332)
                                  {
                                    unint64_t v332 = malloc_type_malloc(120 * v333 + 16, 0xB644C221uLL);
                                    *unint64_t v332 = 0;
                                    v332[1] = 0;
                                    **(void **)(v285 + 232) = v332;
                                  }
                                  *(void *)(v285 + 232) = v332;
                                  uint64_t v333 = v332[1];
                                }
                                unint64_t v334 = &v332[15 * v333];
                                v332[1] = v333 + 1;
                                v334[2] = &off_1EF55A458;
                                long long v335 = v410;
                                long long v336 = v411;
                                long long v337 = v409;
                                *(_OWORD *)(v334 + 9) = v408;
                                long long v338 = v405;
                                long long v339 = v406;
                                *(_OWORD *)(v334 + 7) = v407;
                                *(_OWORD *)(v334 + 5) = v339;
                                *(_OWORD *)(v334 + 3) = v338;
                                *(_OWORD *)(v334 + 15) = v336;
                                *(_OWORD *)(v334 + 13) = v335;
                                *(_OWORD *)(v334 + 11) = v337;
                                v334[10] = v303;
                                v340 = *v325;
                                v334[13] = *v325;
                                v334[14] = (v325[1] - v340) >> 4;
                                int v403 = 0;
                                uint64_t v404 = (void (**)(ggl::RenderItem *__hidden))(v334 + 2);
                                if (!v424) {
                                  goto LABEL_599;
                                }
                                (*(void (**)(uint16x4_t *, int *, void (***)(ggl::RenderItem *__hidden)))(*(void *)v424 + 48))(v424, &v403, &v404);
                                uint64_t v67 = v368;
                              }
                            }
                          }
                          if (v424 == (uint16x4_t *)&v422)
                          {
                            ((void (*)(uint64_t **))v422[4])(&v422);
                          }
                          else if (v424)
                          {
                            (*(void (**)(void))(*(void *)v424 + 40))();
                          }
                        }
                        if (v421 == v420)
                        {
                          (*(void (**)(float *))(*(void *)v420 + 32))(v420);
                        }
                        else if (v421)
                        {
                          (*(void (**)(void))(*(void *)v421 + 40))();
                        }
                        ++v283;
                        unint64_t v284 = (float *)v419;
                        if (v283 == v223)
                        {
                          if (v419 != v418)
                          {
                            char v106 = v361;
                            double v107 = this;
                            if (v419) {
                              (*(void (**)(void))(*v419 + 40))();
                            }
LABEL_571:
                            gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v389);
                            double v198 = v396;
                            if (v396)
                            {
LABEL_572:
                              if (atomic_fetch_add(&v198->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
                                goto LABEL_573;
                              }
                              ((void (*)(std::__shared_weak_count *))v198->__on_zero_shared)(v198);
                              std::__shared_weak_count::__release_weak(v198);
                              size_t v341 = v401;
                              if (!v401)
                              {
LABEL_186:
                                uint64_t v111 = v366 + 1;
                                if (v366 + 1 == v359) {
                                  goto LABEL_579;
                                }
                                goto LABEL_187;
                              }
LABEL_574:
                              if (!atomic_fetch_add(&v341->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                              {
                                ((void (*)(std::__shared_weak_count *))v341->__on_zero_shared)(v341);
                                std::__shared_weak_count::__release_weak(v341);
                              }
                              goto LABEL_186;
                            }
LABEL_573:
                            size_t v341 = v401;
                            if (!v401) {
                              goto LABEL_186;
                            }
                            goto LABEL_574;
                          }
                          float32x2_t v282 = (void (**)(void *))v418[0];
                          char v106 = v361;
                          double v107 = this;
LABEL_570:
                          v282[4](v418);
                          goto LABEL_571;
                        }
                        continue;
                      }
                    }
                    while (2)
                    {
                      uint64_t v231 = *v230;
                      if (*(unsigned char *)(*v230 + 272))
                      {
                        uint64_t v232 = (uint64_t)v395;
                        double v233 = v396;
                        uint64_t v422 = (uint64_t *)v395;
                        uint64_t v423 = v396;
                        if (v396) {
                          atomic_fetch_add_explicit(&v396->__shared_owners_, 1uLL, memory_order_relaxed);
                        }
                        gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)&v404, v232, (uint64_t)v233);
                        if (v233 && !atomic_fetch_add(&v233->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v233->__on_zero_shared)(v233);
                          std::__shared_weak_count::__release_weak(v233);
                        }
                        int v234 = *(unsigned __int8 *)(v231 + 300);
                        if (BYTE8(v406))
                        {
                          int8x8_t v235 = v364;
                          v235.i8[0] = BYTE12(v390[0]);
                          float32x4_t v236 = (float32x4_t)vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(v235));
                          v236.f32[0] = (float)v236.i32[0];
                          switch(*(unsigned char *)(v231 + 300))
                          {
                            case 0:
                              gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v422, (uint64_t)v404[3], 0x2Bu, 2u, fminf(fmaxf(v236.f32[0], 0.0), 23.0));
                              goto LABEL_428;
                            case 1:
                              gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v422, (uint64_t)v404[3], 0x36u, 2u, fminf(fmaxf(v236.f32[0], 0.0), 23.0));
                              goto LABEL_428;
                            case 2:
                              gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v422, (uint64_t)v404[3], 0x41u, 2u, fminf(fmaxf(v236.f32[0], 0.0), 23.0));
                              goto LABEL_428;
                            case 3:
                              gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v422, (uint64_t)v404[3], 0x4Cu, 2u, fminf(fmaxf(v236.f32[0], 0.0), 23.0));
LABEL_428:
                              float32x4_t v236 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)v422)), (float32x4_t)vdupq_n_s32(0x37800080u));
                              int8x8_t v364 = *(int8x8_t *)v236.f32;
                              break;
                            default:
                              break;
                          }
                        }
                        else if (v234 == 3)
                        {
                          float32x4_t v236 = (float32x4_t)xmmword_1A28FF6F0;
                        }
                        else if (v234 == 2)
                        {
                          float32x4_t v236 = (float32x4_t)xmmword_1A28FF6E0;
                        }
                        else
                        {
                          float32x4_t v236 = (float32x4_t)xmmword_1A28FF6D0;
                        }
                        float32x4_t v367 = v236;
                        gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v404);
                        v420[0] = 0.0;
                        uint64_t v237 = *(void *)(v231 + 280);
                        uint64_t v422 = (uint64_t *)v237;
                        double v238 = *(std::__shared_weak_count **)(v231 + 288);
                        uint64_t v423 = v238;
                        if (v238) {
                          atomic_fetch_add_explicit(&v238->__shared_owners_, 1uLL, memory_order_relaxed);
                        }
                        gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)&v404, v237, (uint64_t)v238);
                        if (v238 && !atomic_fetch_add(&v238->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v238->__on_zero_shared)(v238);
                          std::__shared_weak_count::__release_weak(v238);
                          if (BYTE8(v406)) {
                            goto LABEL_436;
                          }
LABEL_411:
                          gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v404);
                          *(unsigned char *)(v231 + 272) = 0;
                        }
                        else
                        {
                          if (!BYTE8(v406)) {
                            goto LABEL_411;
                          }
LABEL_436:
                          float v239 = *((float *)v390 + 2);
                          uint64_t v240 = v404[3];
                          if ((int)*((float *)v390 + 2) >= 0x17) {
                            unsigned int v241 = 23;
                          }
                          else {
                            unsigned int v241 = (int)*((float *)v390 + 2);
                          }
                          double v242 = *(float **)v240;
                          if (*(void *)v240
                            && (float v243 = *v242, LODWORD(v242) = *v242 == 1.0, *((unsigned char *)v240 + 10))
                            && (v243 != 0.0 ? (BOOL v244 = v243 == 1.0) : (BOOL v244 = 1), !v244)
                            || (v245 = *((unsigned __int8 *)v240 + v242 + 11), float v243 = 0.0, v245 == 2))
                          {
                            LOBYTE(v422) = 1;
                            LOBYTE(v418[0]) = 1;
                            char v246 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v240, 0x5Bu, v241, 0, &v422);
                            char v247 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v240, 0x5Bu, v241, 1, v418);
                            if (v243 < 1.0) {
                              char v247 = v246;
                            }
                            if (!v247) {
                              goto LABEL_411;
                            }
                          }
                          else if (!*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v404[3], 0x5Bu, v241, v245, 0))
                          {
                            goto LABEL_411;
                          }
                          LODWORD(v422) = 0;
                          char v402 = 0;
                          md::getRoadWidths((uint64_t)&v404, v420, (float *)&v422, &v402, v239);
                          unint64_t v248 = (unint64_t)v404[3];
                          float v249 = fminf(fmaxf(v239, 0.0), 23.0);
                          float v250 = *(float **)v248;
                          if (*(void *)v248
                            && (float v251 = *v250, LODWORD(v250) = *v250 == 1.0, *(unsigned char *)(v248 + 10))
                            && (v251 != 0.0 ? (BOOL v252 = v251 == 1.0) : (BOOL v252 = 1), !v252)
                            || (v253 = *(unsigned __int8 *)(v248 + v250 + 11), float v251 = 0.0, v253 == 2))
                          {
                            LOBYTE(v418[0]) = 1;
                            LOBYTE(v403) = 1;
                            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v248, 0x12Eu, 0, (BOOL *)v418, v249);
                            float v255 = v254;
                            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v248, 0x12Eu, 1u, (BOOL *)&v403, v249);
                            float v257 = v255 + (float)((float)(v256 - v255) * v251);
                          }
                          else
                          {
                            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>((unint64_t)v404[3], 0x12Eu, v253, 0, v249);
                            float v257 = v258;
                          }
                          unint64_t v259 = (unint64_t)v404[3];
                          int v260 = *(float **)v259;
                          if (*(void *)v259
                            && (float v261 = *v260, LODWORD(v260) = *v260 == 1.0, *(unsigned char *)(v259 + 10))
                            && v261 != 0.0
                            && v261 != 1.0
                            || (v262 = *(unsigned __int8 *)(v259 + v260 + 11), float v261 = 0.0, v262 == 2))
                          {
                            LOBYTE(v418[0]) = 1;
                            LOBYTE(v403) = 1;
                            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v259, 0x175u, 0, (BOOL *)v418, v249);
                            float v264 = v263;
                            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v259, 0x175u, 1u, (BOOL *)&v403, v249);
                            float v266 = v264 + (float)((float)(v265 - v264) * v261);
                          }
                          else
                          {
                            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>((unint64_t)v404[3], 0x175u, v262, 0, v249);
                            float v266 = v267;
                          }
                          gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v404);
                          if (v266 != 0.0 && v257 <= 3.5 && v257 >= 0.25) {
                            float v257 = v257 + 0.5;
                          }
                          float v269 = v420[0];
                          if (v266 == 0.0) {
                            float v270 = v257 + (float)(v420[0] * 0.5);
                          }
                          else {
                            float v270 = v257 * 0.5;
                          }
                          uint64_t v271 = *(void *)(*(void *)(*(void *)(v231 + 8) + 152) + 128);
                          unsigned int v272 = *(_DWORD *)v271;
                          float v273 = *((float *)&v392 + 1);
                          uint64_t v274 = 312;
                          if (!*(unsigned char *)(v231 + 329)) {
                            uint64_t v274 = 320;
                          }
                          uint64_t v275 = *(void *)(v231 + v274);
                          *(void *)(v231 + 48) = v275;
                          float32x4_t v276 = *(void **)(*(void *)(v275 + 64) + 32);
                          unint64_t v277 = v276[1];
                          if (v277) {
                            uint64_t v278 = (float32x4_t *)v276[9];
                          }
                          else {
                            uint64_t v278 = 0;
                          }
                          *uint64_t v278 = v367;
                          v278[1].f32[0] = *(float *)(v271 + 8) * v270;
                          if (v266 == 0.0)
                          {
                            float v280 = -1.0;
                            if (*(float *)(v231 + 296) <= 0.0) {
                              float v280 = 1.0;
                            }
                            float v281 = 0.0;
                          }
                          else
                          {
                            float v279 = v266 + (float)((float)(v269 + v257) * 0.5);
                            float v280 = 0.0;
                            float v281 = fmaxf(v279, 0.0);
                          }
                          v278[1].i32[2] = 0;
                          v215.n128_f32[0] = v273 * (float)v272;
                          v278[1].i32[1] = v215.n128_u32[0];
                          v278[1].f32[3] = v281;
                          v278[2].f32[0] = v280;
                          if (v277)
                          {
                            if (v276[8] > v277) {
                              unint64_t v277 = v276[8];
                            }
                            v276[7] = 0;
                            v276[8] = v277;
                          }
                          *(unsigned char *)(v231 + 272) = 1;
                          if (*(unsigned char *)(v231 + 136))
                          {
                            *(_DWORD *)(v231 + 56) = BYTE9(v391);
                            md::RoadBatch::setRenderOrdersForStrokeAndFill(0, 0, 0, 0, 0, v231 + 16, *(_DWORD *)(v231 + 304), 1, *(void *)(v231 + 280), *(std::__shared_weak_count **)(v231 + 288), (uint64_t)v390, *(unsigned char *)(v231 + 328));
                          }
                        }
                      }
                      if (++v230 == v223)
                      {
                        double v223 = *(uint64_t **)(v174 + 16);
                        goto LABEL_497;
                      }
                      continue;
                    }
                  }
                  uint64_t v216 = *(void *)(v174 + 112);
                  if ((*(unsigned char *)(v216 + 16) & 2) == 0
                    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
                  {
                    uint64_t v404 = (void (**)(ggl::RenderItem *__hidden))v420;
                    uint64_t v422 = (uint64_t *)&v404;
                    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v422, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
                  }
                  double v217 = *(float **)(v216 + 72);
                  double v218 = 0.0;
LABEL_400:
                  int v214 = ggl::CullingGrid::intersectedCellsForView(v217, v218);
                  goto LABEL_401;
                }
              }
              else
              {
                if (v208 >= *(void *)&v203) {
                  v208 %= *(void *)&v203;
                }
                if (v208 != v205) {
                  break;
                }
              }
              double v207 = (void *)*v207;
            }
            while (v207);
          }
        }
      }
LABEL_381:
      uint64_t v211 = 0;
      if (MEMORY[0xEC0]) {
        goto LABEL_382;
      }
LABEL_376:
      if ((*(void *)&v203 & (*(void *)&v203 - 1)) != 0)
      {
        unint64_t v219 = 0x8BD499FBD96FBB9ELL;
        if (*(void *)&v203 <= 0x8BD499FBD96FBB9ELL) {
          unint64_t v219 = 0x8BD499FBD96FBB9ELL % *(void *)&v203;
        }
        double v212 = *(void **)(*v202 + 8 * v219);
        do
        {
          do
            double v212 = (void *)*v212;
          while (v212[1] != 0x8BD499FBD96FBB9ELL);
        }
        while (v212[2] != 0x8BD499FBD96FBB9ELL);
      }
      else
      {
        double v212 = *(void **)(*v202 + 8 * ((*(void *)&v203 - 1) & 0x8BD499FBD96FBB9ELL));
        do
        {
          do
            double v212 = (void *)*v212;
          while (v212[1] != 0x8BD499FBD96FBB9ELL);
        }
        while (v212[2] != 0x8BD499FBD96FBB9ELL);
      }
      double v220 = 0.0;
      if (**(unsigned char **)(v212[5] + 32) && *(unsigned char *)(v174 + 104)) {
        double v220 = *(double *)(v211 + 24) * 0.0000000249532021 * (double)(1 << *(unsigned char *)(v174 + 81));
      }
      uint64_t v221 = *(void *)(v174 + 112);
      if ((*(unsigned char *)(v221 + 16) & 2) == 0
        && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
      {
        uint64_t v404 = (void (**)(ggl::RenderItem *__hidden))v420;
        uint64_t v422 = (uint64_t *)&v404;
        std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v422, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
      }
      double v217 = *(float **)(v221 + 72);
      double v218 = v220;
      goto LABEL_400;
    }
    while (1)
    {
      uint64_t v190 = *v187;
      uint64_t v191 = *(void *)(*(void *)(*v187 + 8) + 152);
      if (!*(unsigned char *)(v191 + 136))
      {
        uint64_t v189 = v190 + 320;
        ggl::Flyover::FlyoverPipelineSetup::setState(*(ggl::PipelineSetup **)(v190 + 320), *(void *)v191, *(std::__shared_weak_count **)(v191 + 8));
        goto LABEL_320;
      }
      double v192 = *(void **)(v190 + 312);
      uint64_t v194 = *(void *)(v191 + 16);
      double v193 = *(std::__shared_weak_count **)(v191 + 24);
      if (v193) {
        atomic_fetch_add_explicit(&v193->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v194 && **(void **)(v194 + 40) == v192[1])
      {
        uint64_t v196 = v192[2];
        if (v196) {
          BOOL v197 = v196 == v194;
        }
        else {
          BOOL v197 = 1;
        }
        if (!v197) {
          ggl::PipelineSetup::resetData((uint64_t)v192);
        }
        if (v193) {
          atomic_fetch_add_explicit(&v193->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        double v195 = (std::__shared_weak_count *)v192[3];
        v192[2] = v194;
        v192[3] = v193;
        if (!v195)
        {
LABEL_337:
          uint64_t v189 = v190 + 312;
          if (v193) {
            goto LABEL_338;
          }
          goto LABEL_320;
        }
      }
      else
      {
        double v195 = (std::__shared_weak_count *)v192[3];
        v192[2] = 0;
        v192[3] = 0;
        if (!v195) {
          goto LABEL_337;
        }
      }
      if (atomic_fetch_add(&v195->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_337;
      }
      ((void (*)(std::__shared_weak_count *))v195->__on_zero_shared)(v195);
      std::__shared_weak_count::__release_weak(v195);
      uint64_t v189 = v190 + 312;
      if (v193)
      {
LABEL_338:
        if (!atomic_fetch_add(&v193->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v193->__on_zero_shared)(v193);
          std::__shared_weak_count::__release_weak(v193);
        }
      }
LABEL_320:
      **(void **)(*(void *)v189 + 96) = *(void *)(*(void *)(v191 + 128) + 16);
      if (++v187 == v188)
      {
        double v185 = *(void **)(v174 + 152);
        uint64_t v67 = v368;
        goto LABEL_345;
      }
    }
  }
  char v358 = 0;
LABEL_579:
  unint64_t v342 = *(void *)(v67 + 72);
  unint64_t v343 = *(uint64_t **)(v67 + 80);
  unint64_t v344 = 126 - 2 * __clz((uint64_t)((uint64_t)v343 - v342) >> 3);
  if (v343 == (uint64_t *)v342) {
    uint64_t v345 = 0;
  }
  else {
    uint64_t v345 = v344;
  }
  std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v342, v343, v345, 1);
  if ((v358 & 1) != 0 && v363)
  {
    LOBYTE(v390[0]) = 0;
    md::CartographicTiledVectorRenderLayer<md::RoadTileDataRenderable>::layoutStencilTiles((uint64_t)v107, v106, v363, v354, v390);
    unint64_t v346 = *(void *)(v363 + 72);
    uint64_t v347 = *(uint64_t **)(v363 + 80);
    unint64_t v348 = 126 - 2 * __clz((uint64_t)((uint64_t)v347 - v346) >> 3);
    if (v347 == (uint64_t *)v346) {
      uint64_t v349 = 0;
    }
    else {
      uint64_t v349 = v348;
    }
    std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v346, v347, v349, 1);
  }
  uint64_t v350 = v375;
  if (v375 && !atomic_fetch_add(&v375->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v350->__on_zero_shared)(v350);
    std::__shared_weak_count::__release_weak(v350);
  }
  unint64_t v351 = mach_absolute_time() - v353;
  if (ggl::Performance::Counters::instance(void)::onceToken[0] != -1) {
    dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_53878);
  }
  atomic_fetch_add((atomic_ullong *volatile)(*(void *)(ggl::Performance::Counters::instance(void)::counters + 32) + 104), v351);
  if (!v417)
  {
LABEL_599:
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
  (*(void (**)(void *))(*v417 + 48))(v417);
  __n128 result = v417;
  if (v417 == v416) {
    return (void *)(*(uint64_t (**)(void *))(v416[0] + 32))(v416);
  }
  if (v417) {
    return (void *)(*(uint64_t (**)(void))(*v417 + 40))();
  }
  return result;
}

void sub_1A256CC0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  md::TrafficContext::~TrafficContext((md::TrafficContext *)&a41);
  unint64_t v43 = mach_absolute_time() - a14;
  if (ggl::Performance::Counters::instance(void)::onceToken[0] != -1) {
    dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_53878);
  }
  atomic_fetch_add((atomic_ullong *volatile)(*(void *)(ggl::Performance::Counters::instance(void)::counters + 32) + 104), v43);
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)&STACK[0x3D8]);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "RoadLayout", "", v5, 2u);
  }
}

void *std::function<void ()(md::Ribbons::CasedTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::CasedTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::CasedTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::CasedTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::CasedTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::CasedTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return ggl::CommandBuffer::pushRenderItem(*(void *)(a1 + 8), *a3);
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::CasedTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::CasedTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::CasedTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::CasedTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::CasedTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF578FD8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::CasedTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::CasedTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::CasedTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::CasedTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::CasedTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF578FD8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::CasedTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::CasedTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::CasedTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::CasedTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::CasedTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::~__func()
{
}

void std::__function::__func<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "RoadLayout", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5714F0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF5714F0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5714A8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF5714A8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::RoadRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::~__func()
{
}

void md::RoadRenderLayer::~RoadRenderLayer(md::RoadRenderLayer *this)
{
  md::RoadRenderLayer::~RoadRenderLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  void *v3;
  md::PatternedSharedResources *v4;
  std::__shared_weak_count *v5;
  md::RoadSharedResources *v6;
  void *v7;
  void *v8;
  void *v9;
  void **v10;
  uint64_t vars8;

  *(void *)this = &unk_1EF5352B8;
  uint64_t v2 = *((void *)this + 60);
  if (v2)
  {
    uint64_t v10 = (void **)*((void *)this + 60);
    std::vector<md::RoadStyling::Entry>::__destroy_vector::operator()[abi:nn180100](&v10);
    MEMORY[0x1A6239270](v2, 0x20C40960023A9);
  }
  uint64_t v3 = (void *)*((void *)this + 61);
  if (v3)
  {
    *((void *)this + 62) = v3;
    operator delete(v3);
  }
  os_signpost_id_t v4 = (md::PatternedSharedResources *)*((void *)this + 59);
  *((void *)this + 59) = 0;
  if (v4)
  {
    md::PatternedSharedResources::~PatternedSharedResources(v4);
    MEMORY[0x1A6239270]();
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 57);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  int8x8_t v6 = (md::RoadSharedResources *)*((void *)this + 55);
  *((void *)this + 55) = 0;
  if (v6)
  {
    md::RoadSharedResources::~RoadSharedResources(v6);
    MEMORY[0x1A6239270]();
  }
  uint8x8_t v7 = (void *)*((void *)this + 52);
  if (v7)
  {
    *((void *)this + 53) = v7;
    operator delete(v7);
  }
  unint64_t v8 = (void *)*((void *)this + 49);
  if (v8)
  {
    *((void *)this + 50) = v8;
    operator delete(v8);
  }
  uint64_t v9 = (void *)*((void *)this + 46);
  if (v9)
  {
    *((void *)this + 47) = v9;
    operator delete(v9);
  }
  md::CartographicTiledVectorRenderLayer<md::RoadTileDataRenderable>::~CartographicTiledVectorRenderLayer(this);
}

void md::CompositeLabeler::debugDraw(md::CompositeLabeler *this, NSMutableString *a2, md::DebugConsole *a3)
{
  unint64_t v8 = a2;
  uint64_t v5 = (void *)*((void *)this + 1);
  int8x8_t v6 = (void *)*((void *)this + 2);
  while (v5 != v6)
  {
    uint64_t v7 = *v5;
    if ((*(unsigned int (**)(void))(*(void *)*v5 + 296))(*v5)) {
      (*(void (**)(uint64_t, NSMutableString *, md::DebugConsole *))(*(void *)v7 + 304))(v7, v8, a3);
    }
    ++v5;
  }
}

void sub_1A256D500(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t md::CompositeLabeler::populateDebugNode(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(uint64_t **)(result + 8);
  for (unint64_t i = *(uint64_t **)(result + 16);
        v3 != i;
        __n128 result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 288))(v7, a2, a3))
  {
    uint64_t v7 = *v3++;
  }
  return result;
}

uint64_t md::CompositeLabeler::debugString@<X0>(md::CompositeLabeler *this@<X0>, unsigned char *a2@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v23);
  uint64_t v5 = *((void *)this + 1);
  uint64_t v4 = *((void *)this + 2);
  if (v4 != v5)
  {
    unint64_t v6 = 0;
    unint64_t v7 = (v4 - v5) >> 3;
    do
    {
      unint64_t v8 = *((unsigned __int8 *)this + 40);
      if (v7 <= v8 || v6 == v8)
      {
        (*(void (**)(void **__return_ptr))(**(void **)(v5 + 8 * v6) + 280))(__p);
        unsigned __int8 v10 = v22;
        if ((v22 & 0x80u) == 0) {
          uint64_t v11 = v22;
        }
        else {
          uint64_t v11 = (uint64_t)__p[1];
        }
        if (v11)
        {
          if ((v22 & 0x80u) == 0) {
            unint64_t v12 = __p;
          }
          else {
            unint64_t v12 = (void **)__p[0];
          }
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v23, (uint64_t)v12, v11);
          unsigned __int8 v10 = v22;
        }
        if ((v10 & 0x80) != 0) {
          operator delete(__p[0]);
        }
        uint64_t v5 = *((void *)this + 1);
        uint64_t v4 = *((void *)this + 2);
      }
      ++v6;
      unint64_t v7 = (v4 - v5) >> 3;
    }
    while (v6 < v7);
  }
  if ((v30 & 0x10) != 0)
  {
    unint64_t v14 = v29;
    if (v29 < v26)
    {
      unint64_t v29 = v26;
      unint64_t v14 = v26;
    }
    uint64_t v15 = (const void **)&v25;
  }
  else
  {
    if ((v30 & 8) == 0)
    {
      size_t v13 = 0;
      a2[23] = 0;
      goto LABEL_35;
    }
    uint64_t v15 = (const void **)v24;
    unint64_t v14 = v24[2];
  }
  int v16 = *v15;
  size_t v13 = v14 - (void)*v15;
  if (v13 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v13 >= 0x17)
  {
    uint64_t v17 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v17 = v13 | 7;
    }
    uint64_t v18 = v17 + 1;
    uint64_t v19 = operator new(v17 + 1);
    *((void *)a2 + 1) = v13;
    *((void *)a2 + 2) = v18 | 0x8000000000000000;
    *(void *)a2 = v19;
    a2 = v19;
    goto LABEL_34;
  }
  a2[23] = v13;
  if (v13) {
LABEL_34:
  }
    memmove(a2, v16, v13);
LABEL_35:
  a2[v13] = 0;
  v23[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v23 + *(void *)(v23[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v23[1] = MEMORY[0x1E4FBA470] + 16;
  if (v28 < 0) {
    operator delete(v27);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v31);
}

void sub_1A256D828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

uint64_t md::CompositeLabeler::debugHighlightFeatureMarker(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(result + 8);
  for (unint64_t i = *(uint64_t **)(result + 16);
        v2 != i;
        __n128 result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 264))(v5, a2))
  {
    uint64_t v5 = *v2++;
  }
  return result;
}

uint64_t md::CompositeLabeler::debugHighlightLabelAtPixel(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t ***)(a1 + 8);
  uint64_t v3 = *(uint64_t ***)(a1 + 16);
  if (v2 == v3) {
    return 0;
  }
  LOBYTE(result) = 0;
  do
  {
    unint64_t v6 = *v2;
    uint64_t v7 = **v2;
    if (result)
    {
      (*(void (**)(uint64_t *))(v7 + 272))(v6);
      uint64_t result = 1;
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t))(v7 + 256))(v6, a2);
    }
    ++v2;
  }
  while (v2 != v3);
  return result;
}

void md::CompositeLabeler::labelMarkerForLabel(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = *(void **)(a1 + 8);
  uint64_t v5 = *(void **)(a1 + 16);
  if (v4 == v5)
  {
LABEL_8:
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    while (1)
    {
      (*(void (**)(void, uint64_t))(*(void *)*v4 + 240))(*v4, a2);
      if (*a3) {
        break;
      }
      uint64_t v7 = (std::__shared_weak_count *)a3[1];
      if (v7)
      {
        if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      if (++v4 == v5) {
        goto LABEL_8;
      }
    }
  }
}

void md::CompositeLabeler::roadMarkerForSelectionAtPixel(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = *(void **)(a1 + 8);
  uint64_t v5 = *(void **)(a1 + 16);
  if (v4 == v5)
  {
LABEL_8:
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    while (1)
    {
      (*(void (**)(void, uint64_t))(*(void *)*v4 + 232))(*v4, a2);
      if (*a3) {
        break;
      }
      uint64_t v7 = (std::__shared_weak_count *)a3[1];
      if (v7)
      {
        if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      if (++v4 == v5) {
        goto LABEL_8;
      }
    }
  }
}

uint64_t md::CompositeLabeler::isLabelHitAtPixel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  if (v4 == v5) {
    return 0;
  }
  uint64_t v9 = v4 + 8;
  do
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v9 - 8) + 224))(*(void *)(v9 - 8), a2, a3, a4);
    if (result) {
      break;
    }
    BOOL v11 = v9 == v5;
    v9 += 8;
  }
  while (!v11);
  return result;
}

uint64_t md::CompositeLabeler::getLabelMarkers(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(result + 8);
  for (unint64_t i = *(uint64_t **)(result + 16);
        v2 != i;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 216))(v5, a2))
  {
    uint64_t v5 = *v2++;
  }
  return result;
}

uint64_t md::CompositeLabeler::setPreviouslySelectedLabelMarker(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(result + 8);
  for (unint64_t i = *(uint64_t **)(result + 16);
        v2 != i;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 208))(v5, a2))
  {
    uint64_t v5 = *v2++;
  }
  return result;
}

uint64_t md::CompositeLabeler::releaseAdoptedSelectedLabelMarker(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 8);
  for (unint64_t i = *(uint64_t **)(this + 16); v1 != i; this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 192))(v3))
    uint64_t v3 = *v1++;
  return this;
}

uint64_t md::CompositeLabeler::adoptSelectedLabelMarker(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v2 == v3) {
    return 0;
  }
  uint64_t v5 = v2 + 8;
  do
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v5 - 8) + 184))(*(void *)(v5 - 8), a2);
    if (result) {
      break;
    }
    BOOL v7 = v5 == v3;
    v5 += 8;
  }
  while (!v7);
  return result;
}

uint64_t md::CompositeLabeler::setSelectedLabelMarker(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(result + 8);
  for (unint64_t i = *(uint64_t **)(result + 16);
        v2 != i;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 176))(v5, a2))
  {
    uint64_t v5 = *v2++;
  }
  return result;
}

void md::CompositeLabeler::labelMarkerForCustomFeatureAnnotation(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  id v11 = a2;
  id v7 = a3;
  unint64_t v8 = *(void **)(a1 + 8);
  uint64_t v9 = *(void **)(a1 + 16);
  if (v8 == v9)
  {
LABEL_8:
    *a4 = 0;
    a4[1] = 0;
  }
  else
  {
    while (1)
    {
      (*(void (**)(void, id, id))(*(void *)*v8 + 168))(*v8, v11, v7);
      if (*a4) {
        break;
      }
      unsigned __int8 v10 = (std::__shared_weak_count *)a4[1];
      if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
      if (++v8 == v9) {
        goto LABEL_8;
      }
    }
  }
}

void sub_1A256DEE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void md::CompositeLabeler::labelMarkerForSelectionAtPixel(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v5 = *(void **)(a1 + 8);
  unint64_t v6 = *(void **)(a1 + 16);
  if (v5 == v6)
  {
LABEL_8:
    *a4 = 0;
    a4[1] = 0;
  }
  else
  {
    while (1)
    {
      (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v5 + 160))(*v5, a2, a3);
      if (*a4) {
        break;
      }
      uint64_t v9 = (std::__shared_weak_count *)a4[1];
      if (v9)
      {
        if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
      if (++v5 == v6) {
        goto LABEL_8;
      }
    }
  }
}

uint64_t md::CompositeLabeler::updateOcclusionQueries(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 8);
  for (unint64_t i = *(uint64_t **)(this + 16); v1 != i; this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 128))(v3))
    uint64_t v3 = *v1++;
  return this;
}

uint64_t md::CompositeLabeler::resetOcclusionQueries(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 8);
  for (unint64_t i = *(uint64_t **)(this + 16); v1 != i; this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 120))(v3))
    uint64_t v3 = *v1++;
  return this;
}

void md::CompositeLabeler::~CompositeLabeler(md::CompositeLabeler *this)
{
  *(void *)this = &unk_1EF536078;
  uint64_t v1 = *((void *)this + 1);
  if (v1)
  {
    *((void *)this + 2) = v1;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v1, *((void *)this + 3) - v1);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v1;

  *(void *)this = &unk_1EF536078;
  uint64_t v1 = *((void *)this + 1);
  if (v1)
  {
    *((void *)this + 2) = v1;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v1, *((void *)this + 3) - v1);
  }
}

void **md::MapEngineSyncAccessor::configurationDidChange(md::MapEngineSyncAccessor *this)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)*((void *)this + 112);
  uint64_t v3 = *(void *)(v2[3] + 56);
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 32);
    for (uint64_t i = *(void *)(v3 + 40); v4 != i; v4 += 16)
      (*(void (**)(void))(**(void **)(v4 + 8) + 104))(*(void *)(v4 + 8));
  }
  unint64_t v6 = (uint64_t **)v2[42];
  if (v6)
  {
    id v7 = *v6;
    unint64_t v8 = (std::mutex *)(*v6 + 12);
    std::mutex::lock(v8);
    if (v7[4])
    {
      uint64_t v9 = (void *)v7[3];
      if (v9)
      {
        do
        {
          unsigned __int8 v10 = (void *)*v9;
          operator delete(v9);
          uint64_t v9 = v10;
        }
        while (v10);
      }
      v7[3] = 0;
      uint64_t v11 = v7[2];
      if (v11)
      {
        for (uint64_t j = 0; j != v11; ++j)
          *(void *)(v7[1] + 8 * j) = 0;
      }
      void v7[4] = 0;
    }
    std::__list_imp<std::pair<geo::QuadTile,geo::small_vector<md::FlyoverRegionManager::RegionArea,2ul>>>::clear(v7 + 6);
    md::FlyoverRegionManager::Internal::updateTriggers((md::FlyoverRegionManager::Internal *)v7);
    std::mutex::unlock(v8);
  }
  v2[39] = 0;
  uint64_t v13 = *(void *)(v2[3] + 56);
  uint64_t v14 = *(void *)(v13 + 32);
  uint64_t v15 = *(void *)(v13 + 40);
  if (v14 != v15)
  {
    while (*(_WORD *)v14 != 9)
    {
      v14 += 16;
      if (v14 == v15) {
        goto LABEL_21;
      }
    }
  }
  if (v14 != v15)
  {
    (*(void (**)(void **__return_ptr))(**(void **)(v14 + 8) + 72))((void **)&v57);
    if ((_BYTE)v57)
    {
      if (v2[39] < (unint64_t)HIDWORD(v57)) {
        v2[39] = HIDWORD(v57);
      }
    }
  }
LABEL_21:
  uint64_t v16 = *(void *)(v13 + 32);
  uint64_t v17 = *(void *)(v13 + 40);
  if (v16 != v17)
  {
    while (*(_WORD *)v16 != 1)
    {
      v16 += 16;
      if (v16 == v17) {
        goto LABEL_29;
      }
    }
  }
  if (v16 == v17)
  {
LABEL_29:
    unint64_t v18 = v2[39];
    goto LABEL_30;
  }
  (*(void (**)(void **__return_ptr))(**(void **)(v16 + 8) + 72))((void **)&v57);
  unint64_t v18 = v2[39];
  if (!(_BYTE)v57 || v18 >= HIDWORD(v57))
  {
LABEL_30:
    if (!v18) {
      v2[39] = 256;
    }
    goto LABEL_32;
  }
  v2[39] = HIDWORD(v57);
LABEL_32:
  uint64_t v19 = +[VKDebugSettings sharedSettings];
  char v20 = [v19 forceFlyoverUnificationMode];
  if ((v20 & 1) != 0 || !GEOConfigGetBOOL())
  {
    *((unsigned char *)this + 1241) = v20;
  }
  else
  {
    uint64_t v21 = [MEMORY[0x1E4F64918] modernManager];
    unsigned __int8 v22 = [v21 activeTileGroup];
    unint64_t v23 = [v22 activeTileSetForTileType:92 scale:1];
    *((unsigned char *)this + 1241) = v23 != 0;
  }
  int v24 = (int8x8_t *)*((void *)this + 140);
  int8x8_t v25 = v24[2];
  if ((*(void *)&v25 & (*(void *)&v25 - 1)) != 0)
  {
    unint64_t v27 = 0x20A1ED17D78F322BLL;
    if (*(void *)&v25 <= 0x20A1ED17D78F322BuLL) {
      unint64_t v27 = 0x20A1ED17D78F322BuLL % *(void *)&v25;
    }
    unint64_t v26 = *(void **)(*(void *)&v24[1] + 8 * v27);
    do
    {
      do
        unint64_t v26 = (void *)*v26;
      while (v26[1] != 0x20A1ED17D78F322BLL);
    }
    while (v26[2] != 0x20A1ED17D78F322BLL);
  }
  else
  {
    unint64_t v26 = *(void **)(*(void *)&v24[1] + 8 * ((*(void *)&v25 - 1) & 0x20A1ED17D78F322BLL));
    do
    {
      do
        unint64_t v26 = (void *)*v26;
      while (v26[1] != 0x20A1ED17D78F322BLL);
    }
    while (v26[2] != 0x20A1ED17D78F322BLL);
  }
  char v28 = *(void **)(v26[5] + 192);
  if (v28)
  {
    do
    {
      unint64_t v29 = (md::LabelManager *)v28[3];
      uint64_t v57 = (void (**)(void **))&unk_1EF56ED00;
      float v58 = v29;
      float v59 = (void **)&v57;
      md::LabelManager::queueCommand(v29, 0, 1, &v57);
      if (v59 == (void **)&v57)
      {
        v57[4]((void **)&v57);
      }
      else if (v59)
      {
        (*((void (**)(void))*v59 + 5))();
      }
      char v28 = (void *)*v28;
    }
    while (v28);
    int v24 = (int8x8_t *)*((void *)this + 140);
    int8x8_t v25 = v24[2];
    if (!*(void *)&v25) {
      goto LABEL_108;
    }
  }
  uint8x8_t v30 = (uint8x8_t)vcnt_s8(v25);
  v30.i16[0] = vaddlv_u8(v30);
  unint64_t v31 = v30.u32[0];
  if (v30.u32[0] > 1uLL)
  {
    uint64_t v32 = 0x669A8EDAC04FCBF1;
    if (*(void *)&v25 <= 0x669A8EDAC04FCBF1uLL) {
      uint64_t v32 = 0x669A8EDAC04FCBF1uLL % *(void *)&v25;
    }
  }
  else
  {
    uint64_t v32 = (*(void *)&v25 - 1) & 0x669A8EDAC04FCBF1;
  }
  uint64_t v33 = *(void **)(*(void *)&v24[1] + 8 * v32);
  if (!v33) {
    goto LABEL_86;
  }
  uint64_t v34 = (void *)*v33;
  if (!v34) {
    goto LABEL_86;
  }
  if (v30.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v36 = v34[1];
      if (v36 == 0x669A8EDAC04FCBF1)
      {
        if (v34[2] == 0x669A8EDAC04FCBF1) {
          goto LABEL_74;
        }
      }
      else if ((v36 & (*(void *)&v25 - 1)) != v32)
      {
        goto LABEL_84;
      }
      uint64_t v34 = (void *)*v34;
      if (!v34) {
        goto LABEL_84;
      }
    }
  }
  while (1)
  {
    unint64_t v35 = v34[1];
    if (v35 == 0x669A8EDAC04FCBF1) {
      break;
    }
    if (v35 >= *(void *)&v25) {
      v35 %= *(void *)&v25;
    }
    if (v35 != v32) {
      goto LABEL_84;
    }
LABEL_63:
    uint64_t v34 = (void *)*v34;
    if (!v34) {
      goto LABEL_84;
    }
  }
  if (v34[2] != 0x669A8EDAC04FCBF1) {
    goto LABEL_63;
  }
LABEL_74:
  uint64_t v37 = v34[5];
  if (v37)
  {
    uint64_t v38 = *(void *)(v37 + 144);
    uint64_t v39 = *(void *)(v38 + 56);
    uint64_t v40 = *(void *)(v38 + 64);
    if (v39 != v40)
    {
      while (*(_WORD *)v39 != 35)
      {
        v39 += 16;
        if (v39 == v40) {
          goto LABEL_84;
        }
      }
    }
    if (v39 != v40)
    {
      uint64_t v41 = *(void *)(v39 + 8);
      if (v41)
      {
        (*(void (**)(void **__return_ptr))(**(void **)(v41 + 8) + 24))((void **)&v57);
        if ((_BYTE)v57) {
          atomic_store(v58, (unsigned __int8 *)(*(void *)(v37 + 168) + 24));
        }
        int v24 = (int8x8_t *)*((void *)this + 140);
        int8x8_t v25 = v24[2];
      }
    }
  }
LABEL_84:
  if (!*(void *)&v25) {
    goto LABEL_108;
  }
  uint8x8_t v42 = (uint8x8_t)vcnt_s8(v25);
  v42.i16[0] = vaddlv_u8(v42);
  unint64_t v31 = v42.u32[0];
LABEL_86:
  if (v31 > 1)
  {
    unint64_t v43 = 0xEA624BC935BAF297;
    if (*(void *)&v25 <= 0xEA624BC935BAF297) {
      unint64_t v43 = 0xEA624BC935BAF297 % *(void *)&v25;
    }
  }
  else
  {
    unint64_t v43 = (*(void *)&v25 - 1) & 0xEA624BC935BAF297;
  }
  uint64_t v44 = *(void **)(*(void *)&v24[1] + 8 * v43);
  if (v44)
  {
    unint64_t v45 = (void *)*v44;
    if (v45)
    {
      if (v31 < 2)
      {
        uint64_t v46 = *(void *)&v25 - 1;
        while (1)
        {
          uint64_t v48 = v45[1];
          if (v48 == 0xEA624BC935BAF297)
          {
            if (v45[2] == 0xEA624BC935BAF297) {
              goto LABEL_106;
            }
          }
          else if ((v48 & v46) != v43)
          {
            goto LABEL_108;
          }
          unint64_t v45 = (void *)*v45;
          if (!v45) {
            goto LABEL_108;
          }
        }
      }
      do
      {
        unint64_t v47 = v45[1];
        if (v47 == 0xEA624BC935BAF297)
        {
          if (v45[2] == 0xEA624BC935BAF297)
          {
LABEL_106:
            uint64_t v49 = v45[5];
            if (v49)
            {
              uint64_t v50 = [MEMORY[0x1E4F64918] modernManager];
              *(unsigned char *)(v49 + 184) = [v50 isMuninEnabled];
            }
            break;
          }
        }
        else
        {
          if (v47 >= *(void *)&v25) {
            v47 %= *(void *)&v25;
          }
          if (v47 != v43) {
            break;
          }
        }
        unint64_t v45 = (void *)*v45;
      }
      while (v45);
    }
  }
LABEL_108:
  uint64_t v51 = *((void *)this + 112);
  uint64_t v52 = *(void *)(v51 + 56);
  uint64_t v53 = *(void *)(v51 + 64);
  if (v52 != v53)
  {
    while (*(_WORD *)v52 != 54)
    {
      v52 += 16;
      if (v52 == v53) {
        goto LABEL_115;
      }
    }
  }
  if (v52 == v53)
  {
LABEL_115:
    LOBYTE(v54) = 0;
  }
  else
  {
    uint64_t v54 = *(void *)(v52 + 8);
    if (v54)
    {
      (*(void (**)(void **__return_ptr))(**(void **)(v54 + 8) + 24))((void **)&v57);
      LOBYTE(v54) = (_BYTE)v57 != 0;
    }
  }
  *((unsigned char *)this + 1240) = v54;
  md::MapEngine::updateDaVinciPOILabelsAvailable(this);
  uint64_t v55 = *(void *)(*((void *)this + 1) + 8);
  uint64_t v57 = (void (**)(void **))&unk_1EF579530;
  float v58 = this;
  float v59 = (void **)&v57;
  geo::TaskQueue::barrierSync(v55, &v57);
  uint64_t result = v59;
  if (v59 == (void **)&v57) {
    return (void **)((uint64_t (*)(void **))v57[4])((void **)&v57);
  }
  if (v59) {
    return (void **)(*((uint64_t (**)(void))*v59 + 5))();
  }
  return result;
}

void sub_1A256E968(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A256E9C4(_Unwind_Exception *exception_object)
{
}

void sub_1A256E9D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10) {
    JUMPOUT(0x1A256E9E8);
  }
  JUMPOUT(0x1A256EA14);
}

BOOL karo::media::JpegLoaderPwin::loadFromChunk(_DWORD *a1, pwin_jpg *this, unsigned __int8 *a3, uint64_t a4, int *a5)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (*a1 > 0x1Du || ((1 << *a1) & 0x20004047) == 0)
  {
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    unint64_t v8 = GEOGetVectorKitVKDefaultLog_log;
    BOOL result = os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1A1780000, v8, OS_LOG_TYPE_ERROR, "Unsupported output format for jpeg loader.", buf, 2u);
      return 0;
    }
  }
  else
  {
    *(void *)uint64_t v9 = 0;
    int v6 = pwin_jpg::p_info_mem_jpg(this, a3, &v9[1], v9, a5);
    BOOL result = 0;
    if (v6 && v9[1])
    {
      if (v9[0]) {
        operator new[]();
      }
    }
  }
  return result;
}

uint64_t md::CameraLogic::debugConsoleString@<X0>(id *a1@<X1>, double *a2@<X3>, unsigned char *a3@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v24);
  md::CameraContext::toString((md::CameraContext *)__p, a2);
  if ((v23 & 0x80u) == 0) {
    int v6 = __p;
  }
  else {
    int v6 = (void **)__p[0];
  }
  if ((v23 & 0x80u) == 0) {
    uint64_t v7 = v23;
  }
  else {
    uint64_t v7 = (uint64_t)__p[1];
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)v6, v7);
  if ((char)v23 < 0) {
    operator delete(__p[0]);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)"\n=== Canvas ===\n", 16);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)"Size: ", 6);
  id v8 = *a1;
  [v8 size];
  uint64_t v9 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)", ", 2);
  id v10 = *a1;
  [v10 size];
  uint64_t v11 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)"\n", 1);

  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)"Content Scale: ", 15);
  id v12 = *a1;
  [v12 contentScale];
  uint64_t v13 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)"\n", 1);

  if ((v31 & 0x10) != 0)
  {
    unint64_t v15 = v30;
    if (v30 < v27)
    {
      unint64_t v30 = v27;
      unint64_t v15 = v27;
    }
    uint64_t v16 = (const void **)&v26;
  }
  else
  {
    if ((v31 & 8) == 0)
    {
      size_t v14 = 0;
      a3[23] = 0;
      goto LABEL_24;
    }
    uint64_t v16 = (const void **)v25;
    unint64_t v15 = v25[2];
  }
  uint64_t v17 = *v16;
  size_t v14 = v15 - (void)*v16;
  if (v14 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v14 >= 0x17)
  {
    uint64_t v18 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v18 = v14 | 7;
    }
    uint64_t v19 = v18 + 1;
    char v20 = operator new(v18 + 1);
    *((void *)a3 + 1) = v14;
    *((void *)a3 + 2) = v19 | 0x8000000000000000;
    *(void *)a3 = v20;
    a3 = v20;
    goto LABEL_23;
  }
  a3[23] = v14;
  if (v14) {
LABEL_23:
  }
    memmove(a3, v17, v14);
LABEL_24:
  a3[v14] = 0;
  v24[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v24 + *(void *)(v24[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v24[1] = MEMORY[0x1E4FBA470] + 16;
  if (v29 < 0) {
    operator delete(v28);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v32);
}

void sub_1A257147C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t md::CameraContext::toString(md::CameraContext *this, double *a2)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v52);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"=== Camera Frame ===\n", 21);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"Target Lat/Long: ", 17);
  uint64_t v4 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v4, (uint64_t)", ", 2);
  uint64_t v5 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"Target Altitude: ", 17);
  int v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"Near/Far: ", 10);
  uint64_t v7 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)" / ", 3);
  id v8 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"Distance From Target: ", 22);
  uint64_t v9 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"Pitch: ", 7);
  id v10 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"Heading: ", 9);
  uint64_t v11 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"Roll: ", 6);
  id v12 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"=== Camera Limits ===\n", 22);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"Pitch min/max: ", 15);
  uint64_t v13 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)" / ", 3);
  size_t v14 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"Zoom min/max: ", 14);
  unint64_t v15 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)" / ", 3);
  uint64_t v16 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"\n=== Camera ===\n", 16);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"Position: ", 10);
  uint64_t v17 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)", ", 2);
  uint64_t v18 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)", ", 2);
  uint64_t v19 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"FoV (V/H): ", 11);
  double v21 = a2[46];
  double v20 = a2[47];
  if (v20 < v21)
  {
    double v22 = v20 * v21;
    double v23 = v20 / v21;
    if (v22 <= 0.0) {
      double v24 = 1.0;
    }
    else {
      double v24 = v23;
    }
    long double v25 = tan(a2[57] * 0.5);
    atan(v24 * v25);
  }
  uint64_t v26 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v26, (uint64_t)" / ", 3);
  double v27 = a2[46];
  double v28 = a2[47];
  if (v27 < v28)
  {
    double v29 = v28 * v27;
    double v30 = v27 / v28;
    if (v29 <= 0.0) {
      double v31 = 1.0;
    }
    else {
      double v31 = v30;
    }
    long double v32 = tan(a2[57] * 0.5);
    atan(v31 * v32);
  }
  uint64_t v33 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"\n=== Vectors ===\n", 17);
  uint64_t v34 = v52[0];
  *(void *)((char *)&v52[2] + *(void *)(v52[0] - 24)) = 2;
  *(void *)((char *)&v52[3] + *(void *)(v34 - 24)) = 5;
  *(_DWORD *)((char *)&v52[1] + *(void *)(v34 - 24)) = *(_DWORD *)((unsigned char *)&v52[1] + *(void *)(v34 - 24)) & 0xFFFFFEFB | 4;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"U:", 2);
  unint64_t v35 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, (uint64_t)",", 1);
  uint64_t v36 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v36, (uint64_t)",", 1);
  uint64_t v37 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v37, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"F:", 2);
  uint64_t v38 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v38, (uint64_t)",", 1);
  uint64_t v39 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v39, (uint64_t)",", 1);
  uint64_t v40 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v40, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"R:", 2);
  uint64_t v41 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v41, (uint64_t)",", 1);
  uint8x8_t v42 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v42, (uint64_t)",", 1);
  unint64_t v43 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)"\n", 1);
  if ((v59 & 0x10) != 0)
  {
    unint64_t v45 = v58;
    if (v58 < v55)
    {
      unint64_t v58 = v55;
      unint64_t v45 = v55;
    }
    uint64_t v46 = (const void **)&v54;
  }
  else
  {
    if ((v59 & 8) == 0)
    {
      size_t v44 = 0;
      *((unsigned char *)this + 23) = 0;
      goto LABEL_26;
    }
    uint64_t v46 = (const void **)v53;
    unint64_t v45 = v53[2];
  }
  unint64_t v47 = *v46;
  size_t v44 = v45 - (void)*v46;
  if (v44 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v44 >= 0x17)
  {
    uint64_t v48 = (v44 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v44 | 7) != 0x17) {
      uint64_t v48 = v44 | 7;
    }
    uint64_t v49 = v48 + 1;
    uint64_t v50 = (md::CameraContext *)operator new(v48 + 1);
    *((void *)this + 1) = v44;
    *((void *)this + 2) = v49 | 0x8000000000000000;
    *(void *)this = v50;
    this = v50;
    goto LABEL_25;
  }
  *((unsigned char *)this + 23) = v44;
  if (v44) {
LABEL_25:
  }
    memmove(this, v47, v44);
LABEL_26:
  *((unsigned char *)this + v44) = 0;
  v52[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v52 + *(void *)(v52[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v52[1] = MEMORY[0x1E4FBA470] + 16;
  if (v57 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v60);
}

void sub_1A2571C0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

double std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,geo::ConvexHull2<double>::getConvexHullPoints(std::vector<gm::Matrix<double,2,1>> const&,std::vector<gm::Matrix<double,2,1>>&)::{lambda(gm::Matrix<double,2,1> const&,gm::Matrix<double,2,1> const&)#1} &,gm::Matrix<double,2,1>*>(double *a1, double *a2, double *a3, double *a4, double *a5)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,geo::ConvexHull2<double>::getConvexHullPoints(std::vector<gm::Matrix<double,2,1>> const&,std::vector<gm::Matrix<double,2,1>>&)::{lambda(gm::Matrix<double,2,1> const&,gm::Matrix<double,2,1> const&)#1} &,gm::Matrix<double,2,1>*>(a1, a2, a3, a5);
  double result = *a4;
  double v11 = a4[1];
  double v12 = a5[1];
  double v13 = v11 - v12;
  double v14 = *a3;
  double v15 = a3[1];
  double v16 = v15 - v12;
  double v17 = v13 / (*a4 - *a5);
  if (vabdd_f64(*a4, *a5) < 2.22044605e-16) {
    double v17 = 1.79769313e308;
  }
  double v18 = v16 / (*a3 - *a5);
  if (vabdd_f64(v14, *a5) >= 2.22044605e-16) {
    double v19 = v18;
  }
  else {
    double v19 = 1.79769313e308;
  }
  if (v17 < v19 || v17 == v19 && (result < v14 || result == v14 && v11 < v15))
  {
    *a3 = result;
    a3[1] = a4[1];
    *a4 = v14;
    a4[1] = v15;
    double result = *a3;
    double v20 = a3[1];
    double v21 = a5[1];
    double v22 = v20 - v21;
    double v23 = *a2;
    double v24 = a2[1];
    double v25 = v24 - v21;
    double v26 = v22 / (*a3 - *a5);
    if (vabdd_f64(*a3, *a5) < 2.22044605e-16) {
      double v26 = 1.79769313e308;
    }
    double v27 = v25 / (*a2 - *a5);
    if (vabdd_f64(v23, *a5) >= 2.22044605e-16) {
      double v28 = v27;
    }
    else {
      double v28 = 1.79769313e308;
    }
    if (v26 < v28 || v26 == v28 && (result < v23 || result == v23 && v20 < v24))
    {
      *a2 = result;
      a2[1] = a3[1];
      *a3 = v23;
      a3[1] = v24;
      double result = *a2;
      double v29 = a2[1];
      double v30 = a5[1];
      double v31 = v29 - v30;
      double v32 = *a1;
      double v33 = a1[1];
      double v34 = v33 - v30;
      double v35 = v31 / (*a2 - *a5);
      if (vabdd_f64(*a2, *a5) < 2.22044605e-16) {
        double v35 = 1.79769313e308;
      }
      double v36 = v34 / (*a1 - *a5);
      if (vabdd_f64(v32, *a5) >= 2.22044605e-16) {
        double v37 = v36;
      }
      else {
        double v37 = 1.79769313e308;
      }
      if (v35 < v37 || v35 == v37 && (result < v32 || result == v32 && v29 < v33))
      {
        *a1 = result;
        double result = a2[1];
        a1[1] = result;
        *a2 = v32;
        a2[1] = v33;
      }
    }
  }
  return result;
}

double std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,geo::ConvexHull2<double>::getConvexHullPoints(std::vector<gm::Matrix<double,2,1>> const&,std::vector<gm::Matrix<double,2,1>>&)::{lambda(gm::Matrix<double,2,1> const&,gm::Matrix<double,2,1> const&)#1} &,gm::Matrix<double,2,1>*>(double *a1, double *a2, double *a3, double *a4, double *a5, double *a6)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,geo::ConvexHull2<double>::getConvexHullPoints(std::vector<gm::Matrix<double,2,1>> const&,std::vector<gm::Matrix<double,2,1>>&)::{lambda(gm::Matrix<double,2,1> const&,gm::Matrix<double,2,1> const&)#1} &,gm::Matrix<double,2,1>*>(a1, a2, a3, a4, a6);
  double result = *a5;
  double v13 = a5[1];
  double v14 = a6[1];
  double v15 = v13 - v14;
  double v16 = *a4;
  double v17 = a4[1];
  double v18 = v17 - v14;
  double v19 = v15 / (*a5 - *a6);
  if (vabdd_f64(*a5, *a6) < 2.22044605e-16) {
    double v19 = 1.79769313e308;
  }
  double v20 = v18 / (*a4 - *a6);
  if (vabdd_f64(v16, *a6) >= 2.22044605e-16) {
    double v21 = v20;
  }
  else {
    double v21 = 1.79769313e308;
  }
  if (v19 < v21 || v19 == v21 && (result < v16 || result == v16 && v13 < v17))
  {
    *a4 = result;
    a4[1] = a5[1];
    *a5 = v16;
    a5[1] = v17;
    double result = *a4;
    double v22 = a4[1];
    double v23 = a6[1];
    double v24 = v22 - v23;
    double v25 = *a3;
    double v26 = a3[1];
    double v27 = v26 - v23;
    double v28 = v24 / (*a4 - *a6);
    if (vabdd_f64(*a4, *a6) < 2.22044605e-16) {
      double v28 = 1.79769313e308;
    }
    double v29 = v27 / (*a3 - *a6);
    if (vabdd_f64(v25, *a6) >= 2.22044605e-16) {
      double v30 = v29;
    }
    else {
      double v30 = 1.79769313e308;
    }
    if (v28 < v30 || v28 == v30 && (result < v25 || result == v25 && v22 < v26))
    {
      *a3 = result;
      a3[1] = a4[1];
      *a4 = v25;
      a4[1] = v26;
      double result = *a3;
      double v31 = a3[1];
      double v32 = a6[1];
      double v33 = v31 - v32;
      double v34 = *a2;
      double v35 = a2[1];
      double v36 = v35 - v32;
      double v37 = v33 / (*a3 - *a6);
      if (vabdd_f64(*a3, *a6) < 2.22044605e-16) {
        double v37 = 1.79769313e308;
      }
      double v38 = v36 / (*a2 - *a6);
      if (vabdd_f64(v34, *a6) >= 2.22044605e-16) {
        double v39 = v38;
      }
      else {
        double v39 = 1.79769313e308;
      }
      if (v37 < v39 || v37 == v39 && (result < v34 || result == v34 && v31 < v35))
      {
        *a2 = result;
        a2[1] = a3[1];
        *a3 = v34;
        a3[1] = v35;
        double result = *a2;
        double v40 = a2[1];
        double v41 = a6[1];
        double v42 = v40 - v41;
        double v43 = *a1;
        double v44 = a1[1];
        double v45 = v44 - v41;
        double v46 = v42 / (*a2 - *a6);
        if (vabdd_f64(*a2, *a6) < 2.22044605e-16) {
          double v46 = 1.79769313e308;
        }
        double v47 = v45 / (*a1 - *a6);
        if (vabdd_f64(v43, *a6) >= 2.22044605e-16) {
          double v48 = v47;
        }
        else {
          double v48 = 1.79769313e308;
        }
        if (v46 < v48 || v46 == v48 && (result < v43 || result == v43 && v40 < v44))
        {
          *a1 = result;
          double result = a2[1];
          a1[1] = result;
          *a2 = v43;
          a2[1] = v44;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,geo::ConvexHull2<double>::getConvexHullPoints(std::vector<gm::Matrix<double,2,1>> const&,std::vector<gm::Matrix<double,2,1>>&)::{lambda(gm::Matrix<double,2,1> const&,gm::Matrix<double,2,1> const&)#1} &,gm::Matrix<double,2,1>*>(double *a1, double *a2, double *a3)
{
  uint64_t v6 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      double v8 = *(a2 - 2);
      double v9 = *(a2 - 1);
      double v10 = a3[1];
      double v11 = v9 - v10;
      double v12 = *a1;
      double v13 = a1[1];
      double v14 = v13 - v10;
      double v15 = v11 / (v8 - *a3);
      if (vabdd_f64(v8, *a3) < 2.22044605e-16) {
        double v15 = 1.79769313e308;
      }
      double v16 = v14 / (*a1 - *a3);
      if (vabdd_f64(v12, *a3) >= 2.22044605e-16) {
        double v17 = v16;
      }
      else {
        double v17 = 1.79769313e308;
      }
      if (v15 < v17 || v15 == v17 && (v8 < v12 || v8 == v12 && v9 < v13))
      {
        *a1 = v8;
        a1[1] = *(a2 - 1);
        *(a2 - 2) = v12;
        *(a2 - 1) = v13;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,geo::ConvexHull2<double>::getConvexHullPoints(std::vector<gm::Matrix<double,2,1>> const&,std::vector<gm::Matrix<double,2,1>>&)::{lambda(gm::Matrix<double,2,1> const&,gm::Matrix<double,2,1> const&)#1} &,gm::Matrix<double,2,1>*>(a1, a1 + 2, a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,geo::ConvexHull2<double>::getConvexHullPoints(std::vector<gm::Matrix<double,2,1>> const&,std::vector<gm::Matrix<double,2,1>>&)::{lambda(gm::Matrix<double,2,1> const&,gm::Matrix<double,2,1> const&)#1} &,gm::Matrix<double,2,1>*>(a1, a1 + 2, a1 + 4, a2 - 2, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,geo::ConvexHull2<double>::getConvexHullPoints(std::vector<gm::Matrix<double,2,1>> const&,std::vector<gm::Matrix<double,2,1>>&)::{lambda(gm::Matrix<double,2,1> const&,gm::Matrix<double,2,1> const&)#1} &,gm::Matrix<double,2,1>*>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2, a3);
      return 1;
    default:
      double v18 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,geo::ConvexHull2<double>::getConvexHullPoints(std::vector<gm::Matrix<double,2,1>> const&,std::vector<gm::Matrix<double,2,1>>&)::{lambda(gm::Matrix<double,2,1> const&,gm::Matrix<double,2,1> const&)#1} &,gm::Matrix<double,2,1>*>(a1, a1 + 2, a1 + 4, a3);
      double v19 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v20 = 0;
      int v21 = 0;
      double v22 = *a3;
      break;
  }
  while (1)
  {
    double v24 = *v19;
    double v25 = v19[1];
    double v26 = a3[1];
    double v27 = v25 - v26;
    double v28 = *v18;
    double v29 = v18[1];
    double v30 = v29 - v26;
    double v31 = v27 / (*v19 - v22);
    if (vabdd_f64(*v19, v22) < 2.22044605e-16) {
      double v31 = 1.79769313e308;
    }
    double v32 = v30 / (*v18 - v22);
    if (vabdd_f64(v28, v22) < 2.22044605e-16) {
      double v32 = 1.79769313e308;
    }
    if (v31 >= v32 && (v31 != v32 || v24 >= v28 && (v24 != v28 || v25 >= v29))) {
      goto LABEL_18;
    }
    *double v19 = v28;
    v19[1] = v18[1];
    double v23 = a1;
    if (v18 != a1)
    {
      uint64_t v33 = v20;
      while (1)
      {
        double v34 = (double *)((char *)a1 + v33);
        double v35 = a3[1];
        double v36 = v25 - v35;
        double v37 = *(double *)((char *)a1 + v33 + 16);
        double v38 = *(double *)((char *)a1 + v33 + 24);
        double v39 = v38 - v35;
        double v40 = v36 / (v24 - *a3);
        if (vabdd_f64(v24, *a3) < 2.22044605e-16) {
          double v40 = 1.79769313e308;
        }
        double v41 = v39 / (v37 - *a3);
        double v42 = vabdd_f64(v37, *a3) >= 2.22044605e-16 ? v41 : 1.79769313e308;
        if (v40 >= v42)
        {
          if (v40 != v42)
          {
            double v23 = (double *)((char *)a1 + v33 + 32);
            goto LABEL_16;
          }
          if (v24 >= v37 && (v24 != v37 || v25 >= v38)) {
            break;
          }
        }
        v18 -= 2;
        v34[4] = v37;
        v34[5] = v38;
        v33 -= 16;
        if (v33 == -32)
        {
          double v23 = a1;
          goto LABEL_16;
        }
      }
      double v23 = v18;
    }
LABEL_16:
    *double v23 = v24;
    v23[1] = v25;
    if (++v21 == 8) {
      return v19 + 2 == a2;
    }
    double v22 = *a3;
LABEL_18:
    double v18 = v19;
    v20 += 16;
    v19 += 2;
    if (v19 == a2) {
      return 1;
    }
  }
}

uint64_t _ZNKSt3__110__function6__funcIZN2md11CameraLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_16ElevationContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_13CameraContextEE3__1NS_9allocatorISJ_EEFvvEE7__cloneEPNS0_6__baseISM_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56D830;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md11CameraLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_16ElevationContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_13CameraContextEE3__1NS_9allocatorISJ_EEFvvEE7__cloneEv(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1EF56D830;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md11CameraLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_16ElevationContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_13CameraContextEE3__1NS_9allocatorISJ_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md11CameraLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_16ElevationContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_13CameraContextEE3__0NS_9allocatorISJ_EEFvvEE7__cloneEPNS0_6__baseISM_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56D7E8;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md11CameraLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_16ElevationContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_13CameraContextEE3__0NS_9allocatorISJ_EEFvvEE7__cloneEv(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1EF56D7E8;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md11CameraLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_16ElevationContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_13CameraContextEE3__0NS_9allocatorISJ_EEFvvEED0Ev()
{
}

uint64_t md::Logic<md::CameraLogic,md::CameraContext,md::LogicDependencies<gdc::TypeList<md::ElevationContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::CameraLogic,md::CameraContext,md::LogicDependencies<gdc::TypeList<md::ElevationContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) != 0x1AF456233693CD46 || !*(void *)(a3 + 32))
  {
    a4[23] = 0;
    *a4 = 0;
    return result;
  }
  uint64_t v4 = *(void **)(a2 + 8);
  int8x8_t v5 = (int8x8_t)v4[1];
  if (!*(void *)&v5) {
    goto LABEL_27;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = 0x8BD499FBD96FBB9ELL;
    if (*(void *)&v5 <= 0x8BD499FBD96FBB9ELL) {
      unint64_t v7 = 0x8BD499FBD96FBB9ELL % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v5 - 1) & 0x8BD499FBD96FBB9ELL;
  }
  double v8 = *(void **)(*v4 + 8 * v7);
  if (!v8) {
    goto LABEL_27;
  }
  double v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_27;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v10 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v12 = v9[1];
      if (v12 == 0x8BD499FBD96FBB9ELL)
      {
        if (v9[2] == 0x8BD499FBD96FBB9ELL) {
          goto LABEL_25;
        }
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_27;
      }
      double v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_27;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v9[1];
    if (v11 == 0x8BD499FBD96FBB9ELL) {
      break;
    }
    if (v11 >= *(void *)&v5) {
      v11 %= *(void *)&v5;
    }
    if (v11 != v7) {
      goto LABEL_27;
    }
LABEL_14:
    double v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_27;
    }
  }
  if (v9[2] != 0x8BD499FBD96FBB9ELL) {
    goto LABEL_14;
  }
LABEL_25:
  uint64_t v13 = v9[5];
  if (*(void *)(v13 + 8) == 0x8BD499FBD96FBB9ELL)
  {
    uint64_t v14 = *(void *)(v13 + 32);
    goto LABEL_28;
  }
LABEL_27:
  uint64_t v14 = 0;
LABEL_28:
  uint64_t v15 = v14;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 160))(result);
}

void md::CameraContext::~CameraContext(md::CameraContext *this)
{
  uint64_t v2 = (char *)this + 4128;
  uint64_t v3 = *((void *)this + 698);
  *((void *)this + 698) = 0;
  if (v3)
  {
    uint64_t v4 = *(void **)(v3 + 2960);
    if (v4)
    {
      *(void *)(v3 + 2968) = v4;
      operator delete(v4);
    }
    if (*(unsigned char *)(v3 + 1752)) {
      *(unsigned char *)(v3 + 1752) = 0;
    }
    if (*(unsigned char *)(v3 + 1736)) {
      *(unsigned char *)(v3 + 1736) = 0;
    }
    if (*(unsigned char *)(v3 + 352)) {
      *(unsigned char *)(v3 + 352) = 0;
    }
    if (*(unsigned char *)(v3 + 336)) {
      *(unsigned char *)(v3 + 336) = 0;
    }
    MEMORY[0x1A6239270](v3, 0x1060C409A3A3550);
  }
  if (v2[16]) {
    v2[16] = 0;
  }
  if (*v2) {
    *uint64_t v2 = 0;
  }
  int8x8_t v5 = (void *)*((void *)this + 370);
  if (v5)
  {
    *((void *)this + 371) = v5;
    operator delete(v5);
  }
  if (*((unsigned char *)this + 1752)) {
    *((unsigned char *)this + 1752) = 0;
  }
  if (*((unsigned char *)this + 1736)) {
    *((unsigned char *)this + 1736) = 0;
  }
  if (*((unsigned char *)this + 352)) {
    *((unsigned char *)this + 352) = 0;
  }
  if (*((unsigned char *)this + 336)) {
    *((unsigned char *)this + 336) = 0;
  }
}

uint64_t gdc::ObjectHolder<md::CameraContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::CameraContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555370;
  uint64_t v1 = (md::CameraContext *)a1[4];
  if (v1)
  {
    md::CameraContext::~CameraContext(v1);
    MEMORY[0x1A6239270]();
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::CameraContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555370;
  uint64_t v2 = (md::CameraContext *)a1[4];
  if (v2)
  {
    md::CameraContext::~CameraContext(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void md::CameraLogic::~CameraLogic(md::CameraLogic *this)
{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void md::Logic<md::CameraLogic,md::CameraContext,md::LogicDependencies<gdc::TypeList<md::ElevationContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    int8x8_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      int8x8_t v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

double md::CameraContext::groundPointFromScreenPoint(md::CameraContext *this, const CGPoint *a2, double a3, double a4)
{
  double v4 = -(*((double *)this + 470) - (a3 - *((float *)this + 122) + a3 - *((float *)this + 122)) * *((double *)this + 470));
  double v5 = -(*((double *)this + 469) - (a4 + a4) * *((double *)this + 469));
  double v6 = 1.0 / sqrt(v4 * v4 + 1.0 + v5 * v5);
  double v7 = v6 * v4;
  double v8 = *((double *)this + 66);
  double v9 = *((double *)this + 67);
  double v10 = -(v6 * v5 * v9 + v6 * v8);
  double v11 = *((double *)this + 65);
  double v12 = v10 + v10;
  double v13 = v6 * v11 + v7 * v9 + v6 * v11 + v7 * v9;
  double v14 = -(v7 * v8 - v6 * v5 * v11) - (v7 * v8 - v6 * v5 * v11);
  double v15 = *((double *)this + 68);
  double v16 = v14 * v15 + v13 * v11;
  double v17 = v6 + (v10 + v10) * v8;
  double result = *((double *)this + 62);
  if (vabdd_f64(v16, v17) > 2.22044605e-16) {
    return result + -*((double *)this + 64) / (v16 - v17) * (v7 + v12 * v15 + v14 * v8 - v13 * v9);
  }
  return result;
}

void md::Logic<md::ARCameraRouteLocationProviderLogic,md::ARCameraRouteLocationProviderContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    double v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      double v5 = __p;
    }
    double v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void md::ARCameraRouteLocationProviderLogic::runBeforeLayout(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a1 + 128))
  {
    uint64_t v4 = [*(id *)(*(void *)a3 + 40) routeInfo];
    double v5 = [v4 route];

    md::ARCameraRouteLocationProvider::setRoute(*(md::ARCameraRouteLocationProvider **)(a1 + 128), v5);
  }
}

void sub_1A2572BA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t md::Logic<md::ARCameraRouteLocationProviderLogic,md::ARCameraRouteLocationProviderContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::ARCameraRouteLocationProviderLogic,md::ARCameraRouteLocationProviderContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) != 0x2A64A6E0A1B666D6 || !*(void *)(a3 + 32))
  {
    a4[23] = 0;
    *a4 = 0;
    return result;
  }
  uint64_t v4 = *(void **)(a2 + 8);
  int8x8_t v5 = (int8x8_t)v4[1];
  if (!*(void *)&v5) {
    goto LABEL_27;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    uint64_t v7 = 0x1B8B241A8D896A1DLL;
    if (*(void *)&v5 <= 0x1B8B241A8D896A1DuLL) {
      uint64_t v7 = 0x1B8B241A8D896A1DuLL % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v7 = (*(void *)&v5 - 1) & 0x1B8B241A8D896A1DLL;
  }
  double v8 = *(void **)(*v4 + 8 * v7);
  if (!v8) {
    goto LABEL_27;
  }
  char v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_27;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v10 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v12 = v9[1];
      if (v12 == 0x1B8B241A8D896A1DLL)
      {
        if (v9[2] == 0x1B8B241A8D896A1DLL) {
          goto LABEL_25;
        }
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_27;
      }
      char v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_27;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v9[1];
    if (v11 == 0x1B8B241A8D896A1DLL) {
      break;
    }
    if (v11 >= *(void *)&v5) {
      v11 %= *(void *)&v5;
    }
    if (v11 != v7) {
      goto LABEL_27;
    }
LABEL_14:
    char v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_27;
    }
  }
  if (v9[2] != 0x1B8B241A8D896A1DLL) {
    goto LABEL_14;
  }
LABEL_25:
  uint64_t v13 = v9[5];
  if (*(void *)(v13 + 8) == 0x1B8B241A8D896A1DLL)
  {
    uint64_t v14 = *(void *)(v13 + 32);
    goto LABEL_28;
  }
LABEL_27:
  uint64_t v14 = 0;
LABEL_28:
  uint64_t v15 = v14;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 160))(result);
}

uint64_t md::Logic<md::ARCameraRouteLocationProviderLogic,md::ARCameraRouteLocationProviderContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x2A64A6E0A1B666D6 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x1B8B241A8D896A1DLL;
    if (*(void *)&v4 <= 0x1B8B241A8D896A1DuLL) {
      uint64_t v6 = 0x1B8B241A8D896A1DuLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x1B8B241A8D896A1DLL;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  double v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x1B8B241A8D896A1DLL)
      {
        if (v8[2] == 0x1B8B241A8D896A1DLL) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      double v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x1B8B241A8D896A1DLL) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    double v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x1B8B241A8D896A1DLL) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x1B8B241A8D896A1DLL)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 152))(result);
}

uint64_t md::Logic<md::ARCameraRouteLocationProviderLogic,md::ARCameraRouteLocationProviderContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x2A64A6E0A1B666D6 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x1B8B241A8D896A1DLL;
    if (*(void *)&v4 <= 0x1B8B241A8D896A1DuLL) {
      uint64_t v6 = 0x1B8B241A8D896A1DuLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x1B8B241A8D896A1DLL;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  double v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x1B8B241A8D896A1DLL)
      {
        if (v8[2] == 0x1B8B241A8D896A1DLL) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      double v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x1B8B241A8D896A1DLL) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    double v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x1B8B241A8D896A1DLL) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x1B8B241A8D896A1DLL)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 144))(result);
}

uint64_t md::Logic<md::ARCameraRouteLocationProviderLogic,md::ARCameraRouteLocationProviderContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x2A64A6E0A1B666D6 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x1B8B241A8D896A1DLL;
    if (*(void *)&v4 <= 0x1B8B241A8D896A1DuLL) {
      uint64_t v6 = 0x1B8B241A8D896A1DuLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x1B8B241A8D896A1DLL;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  double v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x1B8B241A8D896A1DLL)
      {
        if (v8[2] == 0x1B8B241A8D896A1DLL) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      double v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x1B8B241A8D896A1DLL) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    double v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x1B8B241A8D896A1DLL) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x1B8B241A8D896A1DLL)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 136))(result);
}

uint64_t md::Logic<md::ARCameraRouteLocationProviderLogic,md::ARCameraRouteLocationProviderContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x2A64A6E0A1B666D6 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x1B8B241A8D896A1DLL;
    if (*(void *)&v4 <= 0x1B8B241A8D896A1DuLL) {
      uint64_t v6 = 0x1B8B241A8D896A1DuLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x1B8B241A8D896A1DLL;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  double v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x1B8B241A8D896A1DLL)
      {
        if (v8[2] == 0x1B8B241A8D896A1DLL) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      double v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x1B8B241A8D896A1DLL) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    double v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x1B8B241A8D896A1DLL) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x1B8B241A8D896A1DLL)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 128))(result);
}

void md::Logic<md::ARCameraRouteLocationProviderLogic,md::ARCameraRouteLocationProviderContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext>,gdc::TypeList<>>>::_allocateContext()
{
}

void sub_1A25733FC(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

uint64_t gdc::ObjectHolder<md::ARCameraRouteLocationProviderContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ARCameraRouteLocationProviderContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555E88;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0xC400A2AC0F1);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ARCameraRouteLocationProviderContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555E88;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0xC400A2AC0F1);
  }
  return a1;
}

void md::ARCameraRouteLocationProviderLogic::didBecomeInactive(md::ARCameraRouteLocationProviderLogic *this)
{
  uint64_t v1 = (md::ARCameraRouteLocationProvider *)*((void *)this + 16);
  if (v1) {
    md::ARCameraRouteLocationProvider::setRoute(v1, 0);
  }
}

void md::ARCameraRouteLocationProviderLogic::~ARCameraRouteLocationProviderLogic(md::ARCameraRouteLocationProviderLogic *this)
{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

uint64_t gss::QueryableLocker<gss::PropertyID>::value<(gss::PropertyID)263>(uint64_t a1)
{
  uint64_t v2 = *(float **)a1;
  if (!*(void *)a1
    || (float v3 = *v2, LODWORD(v2) = *v2 == 1.0, !*(unsigned char *)(a1 + 10))
    || (v3 != 0.0 ? (BOOL v4 = v3 == 1.0) : (BOOL v4 = 1), v4))
  {
    unsigned int v5 = *(unsigned __int8 *)(a1 + v2 + 11);
    if (v5 != 2) {
      return gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(a1, 0x107u, v5, 0);
    }
  }
  char v8 = 1;
  char v7 = 1;
  gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(a1, 0x107u, 0, &v8);
  return gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(a1, 0x107u, 1u, &v7);
}

void ___ZN2md16RouteRenderLayer21updateRouteLineMeshesERKNS_13LayoutContextERKNSt3__16vectorINS4_10shared_ptrINS_16RouteLineOverlayEEENS4_9allocatorIS8_EEEEb_block_invoke(uint64_t a1, void **a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = (uint64_t)(*a2 + 1);
  if (!*a2) {
    uint64_t v3 = 0;
  }
  if (!*(_DWORD *)(v3 + 192))
  {
    uint64_t v6 = **(void **)(a1 + 32);
    if (v2) {
      ++*v2;
    }
    char v7 = *(void **)(v6 + 504);
    if (v7)
    {
      if ((*v7)-- == 1)
      {
        md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v7 + 1));
        uint64_t v9 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
        {
          uint64_t v9 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
          if (v17) {
            operator new();
          }
        }
        (*(void (**)(void, void, uint64_t))(**((void **)v9 + 91) + 40))(*((void *)v9 + 91), *(void *)(v6 + 504), 400);
        *(void *)(v6 + 504) = 0;
        uint64_t v2 = *a2;
      }
    }
    *(void *)(v6 + 504) = v2;
    unint64_t v10 = *(uint64_t **)(a1 + 40);
    uint64_t v11 = **(void **)(a1 + 32);
    uint64_t v12 = *(void *)(v11 + 504);
    if (v12) {
      uint64_t v13 = v12 + 8;
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v15 = *v10;
    uint64_t v14 = (std::__shared_weak_count *)v10[1];
    uint64_t v18 = v15;
    double v19 = v14;
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v11 = **(void **)(a1 + 32);
    }
    md::RouteLineSection::updateStyleQueryIfNecessary(v13, &v18, *(unsigned __int8 **)(a1 + 48), *(unsigned __int8 *)(v11 + 620), *(unsigned __int8 *)(v11 + 621), *(unsigned __int8 *)(v11 + 622), (gss::FeatureAttributeSet *)(v11 + 536), (gss::FeatureAttributeSet *)(v11 + 568), *(float *)(a1 + 56), *(unsigned char *)(a1 + 60), 0xFFFFFFFF, 0xFFFFFFFF);
    double v16 = v19;
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

void sub_1A25738B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__hash_table<md::NavigationLogicEvent,std::hash<md::NavigationLogicEvent>,std::equal_to<md::NavigationLogicEvent>,std::allocator<md::NavigationLogicEvent>>::__emplace_unique_key_args<md::NavigationLogicEvent,md::NavigationLogicEvent const&>(uint64_t a1, int a2, int a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            unint64_t v10 = (uint64_t *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v13 = operator new(0x18uLL);
  *uint64_t v13 = 0;
  v13[1] = v6;
  *((_DWORD *)v13 + 4) = a3;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_34;
    }
    if (prime < v7)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (prime <= v20) {
        size_t prime = v20;
      }
      if (prime < v7) {
LABEL_34:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v23 = *(void *)a1;
  double v24 = *(void **)(*(void *)a1 + 8 * v3);
  if (v24)
  {
    *uint64_t v13 = *v24;
LABEL_58:
    *double v24 = v13;
    goto LABEL_59;
  }
  *uint64_t v13 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v13;
  *(void *)(v23 + 8 * v3) = a1 + 16;
  if (*v13)
  {
    unint64_t v25 = *(void *)(*v13 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v25 >= v7) {
        v25 %= v7;
      }
    }
    else
    {
      v25 &= v7 - 1;
    }
    double v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
}

void sub_1A2573B8C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<md::RouteRenderLayer::runLayoutLogic(md::LayoutContext const&)::$_0,std::allocator<md::RouteRenderLayer::runLayoutLogic(md::LayoutContext const&)::$_0>,void ()(md::StyleManagerEvent)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF572468;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::RouteRenderLayer::runLayoutLogic(md::LayoutContext const&)::$_0,std::allocator<md::RouteRenderLayer::runLayoutLogic(md::LayoutContext const&)::$_0>,void ()(md::StyleManagerEvent)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF572468;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::RouteRenderLayer::runLayoutLogic(md::LayoutContext const&)::$_0,std::allocator<md::RouteRenderLayer::runLayoutLogic(md::LayoutContext const&)::$_0>,void ()(md::StyleManagerEvent)>::~__func()
{
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::DaVinci::ElevationCompressedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::DaVinci::ElevationCompressedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::DaVinci::ElevationCompressedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void non-virtual thunk to'ggl::DaVinci::ElevationCompressedMesh::~ElevationCompressedMesh(ggl::DaVinci::ElevationCompressedMesh *this)
{
  ggl::Mesh::~Mesh((ggl::DaVinci::ElevationCompressedMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::DaVinci::ElevationCompressedMesh *)((char *)this - 16));
}

void ggl::DaVinci::ElevationCompressedMesh::~ElevationCompressedMesh(ggl::DaVinci::ElevationCompressedMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::DaVinci::ElevationCompressedVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::DaVinci::ElevationCompressedVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::DaVinci::ElevationVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::DaVinci::ElevationVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::DaVinci::ElevationVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void non-virtual thunk to'ggl::DaVinci::ElevationMesh::~ElevationMesh(ggl::DaVinci::ElevationMesh *this)
{
  ggl::Mesh::~Mesh((ggl::DaVinci::ElevationMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::DaVinci::ElevationMesh *)((char *)this - 16));
}

void ggl::DaVinci::ElevationMesh::~ElevationMesh(ggl::DaVinci::ElevationMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::DaVinci::ElevationVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::DaVinci::ElevationVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::DiffuseBuildingPointyRoof::BuildingPipelineState::~BuildingPipelineState(ggl::DiffuseBuildingPointyRoof::BuildingPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  BOOL v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  BOOL v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::DiffuseBuildingPointyRoof::BuildingPipelineSetup::textureIsEnabled(ggl::DiffuseBuildingPointyRoof::BuildingPipelineSetup *this)
{
  return 0;
}

BOOL ggl::DiffuseBuildingPointyRoof::BuildingPipelineSetup::constantDataIsEnabled(ggl::DiffuseBuildingPointyRoof::BuildingPipelineSetup *this, unint64_t a2)
{
  return a2 < 7;
}

void ggl::DiffuseBuildingPointyRoof::BuildingPipelineSetup::~BuildingPipelineSetup(ggl::DiffuseBuildingPointyRoof::BuildingPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void md::PassList::didPrepareForLayout(md::PassList *this, const md::LayoutContext *a2, id *a3)
{
  uint64_t v6 = *(void *)(*((void *)this + 3) + 128);
  *(void *)(*((void *)this + 3) + 128) = (unint64_t)(*(double *)(md::LayoutContext::frameState(a2) + 88)
                                                                * 1000.0);
  uint64_t v7 = [a3[13] finalRenderTarget];
  if (v7)
  {
    uint64_t v9 = *((void *)this + 3);
    unint64_t v10 = *(_DWORD **)(v7 + 336);
    if (v10)
    {
      LODWORD(v11) = v10[9];
      LODWORD(v10) = v10[10];
LABEL_26:
      *(_DWORD *)(v9 + 40) = v11;
      *(_DWORD *)(v9 + 44) = v10;
      long long v20 = *(_OWORD *)(v7 + 72);
      *(_OWORD *)(v9 + 48) = *(_OWORD *)(v7 + 56);
      *(_OWORD *)(v9 + 64) = v20;
      goto LABEL_27;
    }
    uint64_t v11 = *(void *)(v7 + 88);
    if (v11)
    {
      uint64_t v12 = (_DWORD *)(v7 + 96);
    }
    else
    {
      uint64_t v11 = *(void *)(v7 + 280);
      if (!v11) {
        goto LABEL_15;
      }
      uint64_t v12 = (_DWORD *)(v7 + 288);
    }
    uint64_t v13 = 80;
    if (*(_DWORD *)(v11 + 56) == 3) {
      uint64_t v13 = 196;
    }
    unsigned int v14 = *(_DWORD *)(v11 + v13);
    unsigned int v15 = v14 >> *v12;
    if (v15 <= 1) {
      unsigned int v15 = 1;
    }
    if (v14) {
      LODWORD(v11) = v15;
    }
    else {
      LODWORD(v11) = 0;
    }
LABEL_15:
    unint64_t v10 = *(_DWORD **)(v7 + 88);
    if (v10)
    {
      BOOL v16 = (_DWORD *)(v7 + 96);
    }
    else
    {
      unint64_t v10 = *(_DWORD **)(v7 + 280);
      if (!v10) {
        goto LABEL_26;
      }
      BOOL v16 = (_DWORD *)(v7 + 288);
    }
    uint64_t v17 = 21;
    if (v10[14] == 3) {
      uint64_t v17 = 49;
    }
    unsigned int v18 = v10[v17];
    unsigned int v19 = v18 >> *v16;
    if (v19 <= 1) {
      unsigned int v19 = 1;
    }
    if (v18) {
      LODWORD(v10) = v19;
    }
    else {
      LODWORD(v10) = 0;
    }
    goto LABEL_26;
  }
LABEL_27:
  memset(v22, 0, sizeof(v22));
  long long v24 = 0u;
  long long v25 = 0u;
  int v23 = 1065353216;
  int v26 = 1065353216;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v27 = 0;
  char v30 = 0;
  memset(v21, 0, 73);
  md::FrameGraphUtils::prepareGraphBuilderForRenderTarget((uint64_t)v21, (uint64_t)v22, (void *)v7, "renderTarget_colorBuffer", 0xC1B9767C00000018, "renderTarget_depthStencilBuffer", 0xE505BC120000001FLL, v8, "renderTarget_msaaResolveBuffer", 0xF53364270000001ELL);
  (*(void (**)(md::PassList *, const md::LayoutContext *, id *, _OWORD *, _OWORD *))(*(void *)this + 24))(this, a2, a3, v21, v22);
  md::PassList::updateGraphState(this, (md::FrameGraphBuilder *)v22, v6);
  md::FrameGraphBuilder::~FrameGraphBuilder((md::FrameGraphBuilder *)v22);
}

void sub_1A25749C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  md::FrameGraphBuilder::~FrameGraphBuilder((md::FrameGraphBuilder *)va);
  _Unwind_Resume(a1);
}

md::FrameGraph **std::unique_ptr<md::FrameGraph>::~unique_ptr[abi:nn180100](md::FrameGraph **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::FrameGraph::~FrameGraph(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

uint64_t std::__function::__func<md::PassList::transferItems(md::FrameGraph *,md::FrameGraph *)::$_0,std::allocator<md::PassList::transferItems(md::FrameGraph *,md::FrameGraph *)::$_0>,void ()(md::FrameGraphPass const&,md::RenderQueueBase &,ggl::RenderTarget *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5791D0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::PassList::transferItems(md::FrameGraph *,md::FrameGraph *)::$_0,std::allocator<md::PassList::transferItems(md::FrameGraph *,md::FrameGraph *)::$_0>,void ()(md::FrameGraphPass const&,md::RenderQueueBase &,ggl::RenderTarget *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF5791D0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PassList::transferItems(md::FrameGraph *,md::FrameGraph *)::$_0,std::allocator<md::PassList::transferItems(md::FrameGraph *,md::FrameGraph *)::$_0>,void ()(md::FrameGraphPass const&,md::RenderQueueBase &,ggl::RenderTarget *)>::~__func()
{
}

uint64_t md::PassList::renderQueueForId(md::PassList *this, int a2)
{
  uint64_t v2 = *((void *)this + 3);
  uint64_t v3 = *((void *)this + 4);
  uint64_t v4 = v3 - v2;
  if (v3 == v2) {
    return 0;
  }
  uint64_t v5 = 0;
  unint64_t v6 = v4 >> 3;
  while (1)
  {
    uint64_t v7 = *(unsigned __int8 **)(v2 + 8 * v5);
    if (*v7 == a2)
    {
      unint64_t v8 = *((void *)v7 + 1);
      uint64_t v9 = *((void *)this + 15);
      if (v8 < (*((void *)this + 16) - v9) >> 3) {
        break;
      }
    }
    if (++v5 >= v6) {
      return 0;
    }
  }
  return *(void *)(v9 + 8 * v8);
}

uint64_t std::__function::__func<md::PassList::rootRenderQueue(void)::$_0,std::allocator<md::PassList::rootRenderQueue(void)::$_0>,void ()(md::FrameGraphPass const&,md::RenderQueueBase &,ggl::RenderTarget *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579218;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::PassList::rootRenderQueue(void)::$_0,std::allocator<md::PassList::rootRenderQueue(void)::$_0>,void ()(md::FrameGraphPass const&,md::RenderQueueBase &,ggl::RenderTarget *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF579218;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PassList::rootRenderQueue(void)::$_0,std::allocator<md::PassList::rootRenderQueue(void)::$_0>,void ()(md::FrameGraphPass const&,md::RenderQueueBase &,ggl::RenderTarget *)>::~__func()
{
}

void sub_1A2575078(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL27GEOGetVectorKitVKMapViewLogv_block_invoke_37290()
{
  os_log_t v0 = os_log_create("com.apple.VectorKit", "VKMapView");
  uint64_t v1 = (void *)GEOGetVectorKitVKMapViewLog(void)::log;
  GEOGetVectorKitVKMapViewLog(void)::log = (uint64_t)v0;
}

void md::TrafficSegmentsAlongRoute::addSegmentAt(md::TrafficSegmentsAlongRoute *this, unsigned int a2, uint64_t a3)
{
  uint64_t v7 = (unint64_t *)*((void *)this + 1);
  unint64_t v6 = *((void *)this + 2);
  unint64_t v8 = v7;
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v10 = *(unint64_t **)this;
    uint64_t v11 = (uint64_t)v7 - *(void *)this;
    uint64_t v12 = v11 >> 3;
    unint64_t v13 = (v11 >> 3) + 1;
    if (v13 >> 61) {
      abort();
    }
    uint64_t v14 = v6 - (void)v10;
    if (v14 >> 2 > v13) {
      unint64_t v13 = v14 >> 2;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15)
    {
      if (v15 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      BOOL v16 = operator new(8 * v15);
    }
    else
    {
      BOOL v16 = 0;
    }
    uint64_t v17 = (unint64_t *)&v16[8 * v12];
    *uint64_t v17 = a2 | (unint64_t)(a3 << 32);
    uint64_t v9 = v17 + 1;
    if (v7 == v10)
    {
      unint64_t v10 = v7;
    }
    else
    {
      unint64_t v18 = (char *)v7 - (char *)v10 - 8;
      if (v18 < 0x58) {
        goto LABEL_29;
      }
      if ((unint64_t)((char *)v7 - v16 - v11) < 0x20) {
        goto LABEL_29;
      }
      uint64_t v19 = (v18 >> 3) + 1;
      unint64_t v8 = &v7[-(v19 & 0x3FFFFFFFFFFFFFFCLL)];
      long long v20 = &v16[8 * v12 - 16];
      uint8x8_t v21 = (long long *)(v7 - 2);
      uint64_t v22 = v19 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v23 = *v21;
        *(v20 - 1) = *(v21 - 1);
        *long long v20 = v23;
        v20 -= 2;
        v21 -= 2;
        v22 -= 4;
      }
      while (v22);
      v17 -= v19 & 0x3FFFFFFFFFFFFFFCLL;
      if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_29:
        do
        {
          unint64_t v24 = *--v8;
          *--uint64_t v17 = v24;
        }
        while (v8 != v10);
        unint64_t v10 = *(unint64_t **)this;
      }
    }
    *(void *)this = v17;
    *((void *)this + 1) = v9;
    *((void *)this + 2) = &v16[8 * v15];
    if (v10) {
      operator delete(v10);
    }
  }
  else
  {
    *uint64_t v7 = a2 | (unint64_t)(a3 << 32);
    uint64_t v9 = v7 + 1;
  }
  *((void *)this + 1) = v9;
}

void sub_1A257539C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void generateSpecularRenderItemsForLandmarkGroup(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t a6, uint64_t a7, __int32 *a8, float a9, float a10, float a11, float a12, float a13, char a14, unsigned __int8 a15, char a16, char a17, uint64_t a18)
{
  uint64_t v24 = *a2 + 72;
  uint64_t v25 = 56;
  if (a17 == 1) {
    uint64_t v25 = 72;
  }
  else {
    uint64_t v24 = *a2 + 56;
  }
  uint64_t v26 = *(void *)(*a2 + v25);
  uint64_t v27 = *(std::__shared_weak_count **)(v24 + 8);
  v290[0] = (uint16x4_t)v26;
  v290[1] = (uint16x4_t)v27;
  if (v27) {
    atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v291, v26, (uint64_t)v27);
  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  uint64_t v28 = *(void **)(a6 + 8);
  int8x8_t v29 = (int8x8_t)v28[1];
  if (!*(void *)&v29) {
    goto LABEL_33;
  }
  uint8x8_t v30 = (uint8x8_t)vcnt_s8(v29);
  v30.i16[0] = vaddlv_u8(v30);
  if (v30.u32[0] > 1uLL)
  {
    uint64_t v31 = 0x41E8D6E445F4145;
    if (*(void *)&v29 <= 0x41E8D6E445F4145uLL) {
      uint64_t v31 = 0x41E8D6E445F4145uLL % *(void *)&v29;
    }
  }
  else
  {
    uint64_t v31 = (*(void *)&v29 - 1) & 0x41E8D6E445F4145;
  }
  double v32 = *(void **)(*v28 + 8 * v31);
  if (!v32) {
    goto LABEL_33;
  }
  uint64_t v33 = (void *)*v32;
  if (!v33) {
    goto LABEL_33;
  }
  if (v30.u32[0] < 2uLL)
  {
    uint64_t v34 = *(void *)&v29 - 1;
    while (1)
    {
      uint64_t v36 = v33[1];
      if (v36 == 0x41E8D6E445F4145)
      {
        if (v33[2] == 0x41E8D6E445F4145) {
          goto LABEL_30;
        }
      }
      else if ((v36 & v34) != v31)
      {
        goto LABEL_33;
      }
      uint64_t v33 = (void *)*v33;
      if (!v33) {
        goto LABEL_33;
      }
    }
  }
  while (1)
  {
    unint64_t v35 = v33[1];
    if (v35 == 0x41E8D6E445F4145) {
      break;
    }
    if (v35 >= *(void *)&v29) {
      v35 %= *(void *)&v29;
    }
    if (v35 != v31) {
      goto LABEL_33;
    }
LABEL_19:
    uint64_t v33 = (void *)*v33;
    if (!v33) {
      goto LABEL_33;
    }
  }
  if (v33[2] != 0x41E8D6E445F4145) {
    goto LABEL_19;
  }
LABEL_30:
  uint64_t v37 = v33[5];
  if (*(void *)(v37 + 8) != 0x41E8D6E445F4145)
  {
LABEL_33:
    float v279 = 0;
    if (v292) {
      goto LABEL_34;
    }
LABEL_32:
    float32x4_t v38 = 0uLL;
    float v39 = 0.0;
    float v40 = 1.0;
    float v41 = 7.875;
    float v42 = 0.065;
    float32x4_t v43 = 0uLL;
    goto LABEL_98;
  }
  float v279 = *(uint64_t **)(v37 + 32);
  if (!v292) {
    goto LABEL_32;
  }
LABEL_34:
  if ((int)a12 >= 0x17) {
    unsigned int v44 = 23;
  }
  else {
    unsigned int v44 = (int)a12;
  }
  gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v290, *(void *)(v291[0] + 24), 0xA2u, v44, 2u, 0);
  float32x4_t v283 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v290[0])), (float32x4_t)vdupq_n_s32(0x37800080u));
  uint64_t v45 = *(void *)(v291[0] + 24);
  double v46 = *(float **)v45;
  if (*(void *)v45)
  {
    float v47 = *v46;
    BOOL v48 = *v46 == 1.0;
    if (*(unsigned char *)(v45 + 10))
    {
      if (v47 != 0.0 && v47 != 1.0)
      {
LABEL_47:
        if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v291[0] + 24), 0x12Fu, v44, 0) & 1) == 0)
        {
          unsigned int v50 = 1;
          goto LABEL_49;
        }
        goto LABEL_50;
      }
    }
  }
  else
  {
    BOOL v48 = 0;
  }
  unsigned int v50 = *(unsigned __int8 *)(v45 + v48 + 11);
  if (v50 == 2) {
    goto LABEL_47;
  }
LABEL_49:
  if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v45, 0x12Fu, v44, v50))
  {
    float32x4_t v277 = v283;
    if (v46) {
      goto LABEL_51;
    }
    goto LABEL_59;
  }
LABEL_50:
  gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v290, v45, 0x12Fu, v44, 2u, 0);
  float32x4_t v277 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v290[0])), (float32x4_t)vdupq_n_s32(0x37800080u));
  uint64_t v45 = *(void *)(v291[0] + 24);
  double v46 = *(float **)v45;
  if (!*(void *)v45)
  {
LABEL_59:
    BOOL v52 = 0;
    goto LABEL_60;
  }
LABEL_51:
  float v51 = *v46;
  BOOL v52 = *v46 == 1.0;
  if (*(unsigned char *)(v45 + 10))
  {
    if (v51 != 0.0 && v51 != 1.0)
    {
LABEL_61:
      v290[0].i8[0] = 1;
      v293[0] = 1;
      float v55 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v45, 0x118u, v44, 0, v290);
      float v39 = v55
          + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v45, 0x118u, v44, 1u, v293)- v55)* v51);
      goto LABEL_63;
    }
  }
LABEL_60:
  unsigned int v54 = *(unsigned __int8 *)(v45 + v52 + 11);
  float v51 = 0.0;
  if (v54 == 2) {
    goto LABEL_61;
  }
  float v39 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v45, 0x118u, v44, v54, 0);
LABEL_63:
  uint64_t v56 = *(void *)(v291[0] + 24);
  char v57 = *(float **)v56;
  if (*(void *)v56
    && (float v58 = *v57, LODWORD(v57) = *v57 == 1.0, *(unsigned char *)(v56 + 10))
    && (v58 != 0.0 ? (BOOL v59 = v58 == 1.0) : (BOOL v59 = 1), !v59)
    || (v60 = *(unsigned __int8 *)(v56 + v57 + 11), float v58 = 0.0, v60 == 2))
  {
    v290[0].i8[0] = 1;
    v293[0] = 1;
    float v61 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v56, 0x12Bu, v44, 0, v290);
    float v62 = v61
        + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v56, 0x12Bu, v44, 1u, v293)- v61)* v58);
  }
  else
  {
    float v62 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v291[0] + 24), 0x12Bu, v44, v60, 0);
  }
  uint64_t v63 = *(void *)(v291[0] + 24);
  unsigned int v64 = *(float **)v63;
  if (*(void *)v63
    && (float v65 = *v64, LODWORD(v64) = *v64 == 1.0, *(unsigned char *)(v63 + 10))
    && (v65 != 0.0 ? (BOOL v66 = v65 == 1.0) : (BOOL v66 = 1), !v66)
    || (v67 = *(unsigned __int8 *)(v63 + v64 + 11), float v65 = 0.0, v67 == 2))
  {
    v290[0].i8[0] = 1;
    v293[0] = 1;
    float v68 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v63, 0x137u, v44, 0, v290);
    float v69 = v68
        + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v63, 0x137u, v44, 1u, v293)- v68)* v65);
  }
  else
  {
    float v69 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v291[0] + 24), 0x137u, v44, v67, 0);
  }
  uint64_t v70 = *(void *)(v291[0] + 24);
  size_t v71 = *(float **)v70;
  if (*(void *)v70 && (float v72 = *v71, LODWORD(v71) = *v71 == 1.0, *(unsigned char *)(v70 + 10)) && v72 != 0.0 && v72 != 1.0
    || (v73 = *(unsigned __int8 *)(v70 + v71 + 11), float v72 = 0.0, v73 == 2))
  {
    v290[0].i8[0] = 1;
    v293[0] = 1;
    float v74 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v70, 0x14Au, v44, 0, v290);
    float v42 = v74
        + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v70, 0x14Au, v44, 1u, v293)- v74)* v72);
  }
  else
  {
    float v42 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v291[0] + 24), 0x14Au, v44, v73, 0);
  }
  float v40 = v62 + (float)((float)(v69 - v62) * a10);
  uint64_t v75 = *(void *)(v291[0] + 24);
  uint64_t v76 = *(float **)v75;
  if (*(void *)v75 && (float v77 = *v76, LODWORD(v76) = *v76 == 1.0, *(unsigned char *)(v75 + 10)) && v77 != 0.0 && v77 != 1.0
    || (v78 = *(unsigned __int8 *)(v75 + v76 + 11), float v77 = 0.0, v78 == 2))
  {
    v290[0].i8[0] = 1;
    v293[0] = 1;
    float v79 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v75, 0x14Bu, v44, 0, v290);
    float v41 = v79
        + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v75, 0x14Bu, v44, 1u, v293)- v79)* v77);
  }
  else
  {
    float v41 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v291[0] + 24), 0x14Bu, v44, v78, 0);
  }
  float32x4_t v43 = v283;
  float32x4_t v38 = v277;
LABEL_98:
  int v80 = a15;
  int8x16_t v81 = (int8x16_t)vsubq_f32(v38, v43);
  v82.f32[0] = a13;
  v82.f32[1] = a13 * a9;
  float32x2_t v83 = vmul_f32(vmla_n_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v43, (int8x16_t)v43, 8uLL), (float32x2_t)*(_OWORD *)&vextq_s8(v81, v81, 8uLL), a10), v82);
  float32x2_t v275 = v83;
  if (v83.f32[1] <= 0.999) {
    int v80 = 1;
  }
  int v278 = v80;
  uint64_t v84 = *(void **)(*a2 + 32);
  float32x4_t v276 = *(void **)(*a2 + 40);
  if (v84 == v276)
  {
LABEL_321:
    gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v291);
    return;
  }
  uint64_t v85 = 0;
  uint64_t v86 = 0;
  *(float32x2_t *)&long long v87 = vmul_n_f32(vmla_n_f32(*(float32x2_t *)v43.f32, *(float32x2_t *)v81.i8, a10), a13);
  float v88 = fmaxf(a11, 0.1);
  float v89 = fmaxf(a10, 0.1);
  float v90 = 1.0 - v40;
  if (v39 >= 0.0001) {
    float v91 = 1.0;
  }
  else {
    float v91 = 0.0;
  }
  if (v39 < 0.0001) {
    float v39 = 1.0;
  }
  float v92 = v42 * 40075017.0 / (v41 * (double)(unint64_t)(1 << a14));
  float v93 = 1.0 - v42;
  float32x2_t v273 = (float32x2_t)v87;
  *((float32x2_t *)&v87 + 1) = v83;
  long long v272 = v87;
  while (1)
  {
    if (a16)
    {
      uint64_t v94 = *(void *)(a1 + 40);
      uint64_t v95 = *(void *)(v94 + 8);
      if (v95 == *(void *)v94)
      {
        uint64_t v112 = *(void *)(v94 + 88);
        if (!v112) {
          break;
        }
        uint64_t v288 = (*(uint64_t (**)(uint64_t))(*(void *)v112 + 48))(v112);
        unint64_t v97 = *(uint64_t **)(v94 + 40);
        unint64_t v113 = *(void *)(v94 + 48);
        if ((unint64_t)v97 < v113)
        {
          if (v97) {
            *unint64_t v97 = v288;
          }
          goto LABEL_128;
        }
        uint64_t v126 = *(void *)(v94 + 32);
        uint64_t v127 = ((uint64_t)v97 - v126) >> 3;
        unint64_t v128 = v127 + 1;
        if ((unint64_t)(v127 + 1) >> 61) {
          goto LABEL_325;
        }
        uint64_t v129 = v113 - v126;
        if (v129 >> 2 > v128) {
          unint64_t v128 = v129 >> 2;
        }
        if ((unint64_t)v129 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v130 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v130 = v128;
        }
        if (v130)
        {
          uint64_t v131 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v94 + 56) + 16))(*(void *)(v94 + 56), 8 * v130, 8);
          BOOL v124 = (uint64_t *)(v131 + 8 * v127);
          uint64_t v125 = v131 + 8 * v130;
          if (v131) {
            *BOOL v124 = v288;
          }
        }
        else
        {
          uint64_t v125 = 0;
          BOOL v124 = (uint64_t *)(8 * v127);
        }
        uint64_t v158 = *(void *)(v94 + 32);
        uint64_t v148 = *(void *)(v94 + 40);
        uint64_t v159 = v148 - v158;
        if (v148 != v158)
        {
          unint64_t v160 = v159 - 8;
          if ((unint64_t)(v159 - 8) < 0x38)
          {
            long long v152 = v124;
          }
          else
          {
            long long v152 = v124;
            if ((unint64_t)(v148 - (void)v124) >= 0x20)
            {
              uint64_t v161 = (v160 >> 3) + 1;
              uint64_t v162 = v124 - 2;
              char v163 = (long long *)(v148 - 16);
              uint64_t v164 = v161 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v165 = *v163;
                *((_OWORD *)v162 - 1) = *(v163 - 1);
                *(_OWORD *)uint64_t v162 = v165;
                v162 -= 4;
                v163 -= 2;
                v164 -= 4;
              }
              while (v164);
              long long v152 = &v124[-(v161 & 0x3FFFFFFFFFFFFFFCLL)];
              v148 -= 8 * (v161 & 0x3FFFFFFFFFFFFFFCLL);
              if (v161 == (v161 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_203;
              }
            }
          }
          do
          {
            uint64_t v176 = *(void *)(v148 - 8);
            v148 -= 8;
            *--long long v152 = v176;
          }
          while (v148 != v158);
          goto LABEL_203;
        }
      }
      else
      {
        uint64_t v96 = *(void *)(v95 - 8);
        *(void *)(v94 + 8) = v95 - 8;
        unint64_t v97 = *(uint64_t **)(v94 + 40);
        unint64_t v98 = *(void *)(v94 + 48);
        uint64_t v288 = v96;
        if ((unint64_t)v97 < v98)
        {
          if (v97) {
            *unint64_t v97 = v96;
          }
LABEL_128:
          uint64_t v114 = v97 + 1;
          goto LABEL_206;
        }
        uint64_t v118 = *(void *)(v94 + 32);
        uint64_t v119 = ((uint64_t)v97 - v118) >> 3;
        unint64_t v120 = v119 + 1;
        if ((unint64_t)(v119 + 1) >> 61) {
          goto LABEL_325;
        }
        uint64_t v121 = v98 - v118;
        if (v121 >> 2 > v120) {
          unint64_t v120 = v121 >> 2;
        }
        if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v122 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v122 = v120;
        }
        if (v122)
        {
          uint64_t v123 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v94 + 56) + 16))(*(void *)(v94 + 56), 8 * v122, 8);
          BOOL v124 = (uint64_t *)(v123 + 8 * v119);
          uint64_t v125 = v123 + 8 * v122;
          if (v123) {
            *BOOL v124 = v288;
          }
        }
        else
        {
          uint64_t v125 = 0;
          BOOL v124 = (uint64_t *)(8 * v119);
        }
        uint64_t v149 = *(void *)(v94 + 32);
        uint64_t v148 = *(void *)(v94 + 40);
        uint64_t v150 = v148 - v149;
        if (v148 != v149)
        {
          unint64_t v151 = v150 - 8;
          if ((unint64_t)(v150 - 8) < 0x38)
          {
            long long v152 = v124;
          }
          else
          {
            long long v152 = v124;
            if ((unint64_t)(v148 - (void)v124) >= 0x20)
            {
              uint64_t v153 = (v151 >> 3) + 1;
              char v154 = v124 - 2;
              __int8 v155 = (long long *)(v148 - 16);
              uint64_t v156 = v153 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v157 = *v155;
                *((_OWORD *)v154 - 1) = *(v155 - 1);
                *(_OWORD *)char v154 = v157;
                v154 -= 4;
                v155 -= 2;
                v156 -= 4;
              }
              while (v156);
              long long v152 = &v124[-(v153 & 0x3FFFFFFFFFFFFFFCLL)];
              v148 -= 8 * (v153 & 0x3FFFFFFFFFFFFFFCLL);
              if (v153 == (v153 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_203;
              }
            }
          }
          do
          {
            uint64_t v175 = *(void *)(v148 - 8);
            v148 -= 8;
            *--long long v152 = v175;
          }
          while (v148 != v149);
LABEL_203:
          uint64_t v148 = *(void *)(v94 + 32);
LABEL_204:
          uint64_t v114 = v124 + 1;
          *(void *)(v94 + 32) = v152;
          *(void *)(v94 + 40) = v124 + 1;
          uint64_t v177 = *(void *)(v94 + 48);
          *(void *)(v94 + 48) = v125;
          if (v148) {
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v94 + 56) + 40))(*(void *)(v94 + 56), v148, v177 - v148);
          }
LABEL_206:
          *(void *)(v94 + 40) = v114;
          v290[0] = (uint16x4_t)v288;
          uint64_t v178 = *(void *)(v94 + 120);
          if (!v178) {
            break;
          }
          (*(void (**)(uint64_t, uint16x4_t *))(*(void *)v178 + 48))(v178, v290);
          uint64_t v181 = *(void *)(v288 + 64);
          *(void *)(v181 + 24) = 0;
          uint64_t v182 = *a4;
          *(void *)(v181 + 16) = *a4;
          uint64_t v183 = *(void *)(v288 + 160);
          uint64_t v184 = a4[1];
          if (v184) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v184 + 8), 1uLL, memory_order_relaxed);
          }
          double v185 = *(std::__shared_weak_count **)(v183 + 24);
          *(void *)(v183 + 16) = v182;
          *(void *)(v183 + 24) = v184;
          if (v185 && !atomic_fetch_add(&v185->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v185->__on_zero_shared)(v185);
            std::__shared_weak_count::__release_weak(v185);
          }
          **(void **)(v288 + 96) = *v84;
          double v186 = *(void **)(v288 + 64);
          double v187 = (void *)v186[4];
          unint64_t v188 = v187[1];
          uint64_t v189 = v187[9];
          *(float *)uint64_t v189 = v89;
          *(float *)(v189 + 4) = v88;
          uint64_t v190 = *a2;
          *(_DWORD *)(v189 + 16) = *(_DWORD *)(*a2 + 92);
          *(_DWORD *)(v189 + 20) = *(_DWORD *)(v190 + 96);
          *(_DWORD *)(v189 + 24) = *(_DWORD *)(v190 + 100);
          v179.i64[0] = *(void *)(v190 + 104);
          v179.i32[2] = *(_DWORD *)(v190 + 112);
          v180.i64[0] = *(void *)(v190 + 92);
          v180.i32[2] = *(_DWORD *)(v190 + 100);
          float32x4_t v191 = vmaxnmq_f32(vsubq_f32(v179, v180), (float32x4_t)0);
          *(_DWORD *)(v189 + 40) = v191.i32[2];
          *(void *)(v189 + 32) = v191.i64[0];
          if (v187[8] > v188) {
            unint64_t v188 = v187[8];
          }
          v187[7] = 0;
          v187[8] = v188;
          double v192 = (void *)v186[6];
          unint64_t v193 = v192[1];
          uint64_t v194 = (float32x2_t *)v192[9];
          *uint64_t v194 = v273;
          v194[1] = v275;
          v194[46].i32[0] = *a8;
          v194[46].i32[1] = a8[1];
          v194[47].i32[0] = a8[2];
          v194[44].i32[1] = 1065353216;
          v194[44].f32[0] = v90;
          v194[32].f32[0] = v39;
          v194[32].f32[1] = v91;
          if (v192[8] > v193) {
            unint64_t v193 = v192[8];
          }
          v192[7] = 0;
          v192[8] = v193;
          double v195 = (void *)v186[8];
          unint64_t v196 = v195[1];
          BOOL v197 = (float *)v195[9];
          *BOOL v197 = v92;
          v197[1] = v93;
          if (v195[8] > v196) {
            unint64_t v196 = v195[8];
          }
          v195[7] = 0;
          v195[8] = v196;
          v186[11] = 0;
          uint64_t v198 = *v279;
          v186[10] = *v279;
          uint64_t v199 = *(void *)(v288 + 160);
          uint64_t v200 = v279[1];
          if (v200) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v200 + 8), 1uLL, memory_order_relaxed);
          }
          double v201 = *(std::__shared_weak_count **)(v199 + 88);
          *(void *)(v199 + 80) = v198;
          *(void *)(v199 + 88) = v200;
          if (v201 && !atomic_fetch_add(&v201->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v201->__on_zero_shared)(v201);
            std::__shared_weak_count::__release_weak(v201);
          }
          double v202 = *(uint64_t **)(v288 + 64);
          v202[1] = 0;
          uint64_t v203 = *a5;
          *double v202 = *a5;
          uint8x8_t v204 = *(void **)(v288 + 160);
          uint64_t v205 = a5[1];
          if (v205) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v205 + 8), 1uLL, memory_order_relaxed);
          }
          double v206 = (std::__shared_weak_count *)v204[1];
          *uint8x8_t v204 = v203;
          v204[1] = v205;
          if (v206 && !atomic_fetch_add(&v206->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v206->__on_zero_shared)(v206);
            std::__shared_weak_count::__release_weak(v206);
          }
          uint64_t v286 = v85;
          if (v278)
          {
            uint64_t v208 = *(void *)(a1 + 192);
            double v207 = *(std::__shared_weak_count **)(a1 + 200);
            if (v207) {
              atomic_fetch_add_explicit(&v207->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v208 && **(void **)(v208 + 40) == *(void *)(v288 + 8))
            {
              uint64_t v210 = *(void *)(v288 + 16);
              if (v210 && v210 != v208) {
                ggl::PipelineSetup::resetData(v288);
              }
              if (v207) {
                atomic_fetch_add_explicit(&v207->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              uint64_t v209 = *(std::__shared_weak_count **)(v288 + 24);
              *(void *)(v288 + 16) = v208;
              *(void *)(v288 + 24) = v207;
              if (!v209) {
                goto LABEL_278;
              }
            }
            else
            {
              uint64_t v209 = *(std::__shared_weak_count **)(v288 + 24);
              *(void *)(v288 + 16) = 0;
              *(void *)(v288 + 24) = 0;
              if (!v209) {
                goto LABEL_278;
              }
            }
            goto LABEL_277;
          }
          goto LABEL_282;
        }
      }
      long long v152 = v124;
      goto LABEL_204;
    }
    uint64_t v99 = *(void *)(a1 + 16);
    uint64_t v100 = *(void *)(v99 + 8);
    uint64_t v288 = v86;
    if (v100 == *(void *)v99)
    {
      uint64_t v115 = *(void *)(v99 + 88);
      if (!v115) {
        break;
      }
      uint64_t v101 = (*(uint64_t (**)(uint64_t))(*(void *)v115 + 48))(v115);
      uint64_t v102 = *(uint64_t **)(v99 + 40);
      unint64_t v116 = *(void *)(v99 + 48);
      if ((unint64_t)v102 >= v116)
      {
        uint64_t v132 = *(void *)(v99 + 32);
        uint64_t v133 = ((uint64_t)v102 - v132) >> 3;
        unint64_t v134 = v133 + 1;
        if ((unint64_t)(v133 + 1) >> 61) {
LABEL_325:
        }
          abort();
        uint64_t v135 = v116 - v132;
        if (v135 >> 2 > v134) {
          unint64_t v134 = v135 >> 2;
        }
        if ((unint64_t)v135 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v136 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v136 = v134;
        }
        if (v136)
        {
          uint64_t v137 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v99 + 56) + 16))(*(void *)(v99 + 56), 8 * v136, 8);
          uint64_t v110 = (uint64_t *)(v137 + 8 * v133);
          uint64_t v111 = v137 + 8 * v136;
          if (v137) {
            *uint64_t v110 = v101;
          }
        }
        else
        {
          uint64_t v111 = 0;
          uint64_t v110 = (uint64_t *)(8 * v133);
        }
        uint64_t v166 = *(void *)(v99 + 32);
        uint64_t v138 = *(void *)(v99 + 40);
        uint64_t v167 = v138 - v166;
        if (v138 != v166)
        {
          unint64_t v168 = v167 - 8;
          if ((unint64_t)(v167 - 8) < 0x38)
          {
            uint64_t v142 = v110;
          }
          else
          {
            uint64_t v142 = v110;
            if ((unint64_t)(v138 - (void)v110) >= 0x20)
            {
              uint64_t v169 = (v168 >> 3) + 1;
              char v170 = v110 - 2;
              uint64_t v171 = (long long *)(v138 - 16);
              uint64_t v172 = v169 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v173 = *v171;
                *((_OWORD *)v170 - 1) = *(v171 - 1);
                *(_OWORD *)char v170 = v173;
                v170 -= 4;
                v171 -= 2;
                v172 -= 4;
              }
              while (v172);
              uint64_t v142 = &v110[-(v169 & 0x3FFFFFFFFFFFFFFCLL)];
              v138 -= 8 * (v169 & 0x3FFFFFFFFFFFFFFCLL);
              if (v169 == (v169 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_244;
              }
            }
          }
          do
          {
            uint64_t v211 = *(void *)(v138 - 8);
            v138 -= 8;
            *--uint64_t v142 = v211;
          }
          while (v138 != v166);
          goto LABEL_244;
        }
LABEL_194:
        uint64_t v142 = v110;
        goto LABEL_245;
      }
    }
    else
    {
      uint64_t v101 = *(void *)(v100 - 8);
      *(void *)(v99 + 8) = v100 - 8;
      uint64_t v102 = *(uint64_t **)(v99 + 40);
      unint64_t v103 = *(void *)(v99 + 48);
      if ((unint64_t)v102 >= v103)
      {
        uint64_t v104 = *(void *)(v99 + 32);
        uint64_t v105 = ((uint64_t)v102 - v104) >> 3;
        unint64_t v106 = v105 + 1;
        if ((unint64_t)(v105 + 1) >> 61) {
          goto LABEL_325;
        }
        uint64_t v107 = v103 - v104;
        if (v107 >> 2 > v106) {
          unint64_t v106 = v107 >> 2;
        }
        if ((unint64_t)v107 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v108 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v108 = v106;
        }
        if (v108)
        {
          uint64_t v109 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v99 + 56) + 16))(*(void *)(v99 + 56), 8 * v108, 8);
          uint64_t v110 = (uint64_t *)(v109 + 8 * v105);
          uint64_t v111 = v109 + 8 * v108;
          if (v109) {
            *uint64_t v110 = v101;
          }
        }
        else
        {
          uint64_t v111 = 0;
          uint64_t v110 = (uint64_t *)(8 * v105);
        }
        uint64_t v139 = *(void *)(v99 + 32);
        uint64_t v138 = *(void *)(v99 + 40);
        uint64_t v140 = v138 - v139;
        if (v138 != v139)
        {
          unint64_t v141 = v140 - 8;
          if ((unint64_t)(v140 - 8) < 0x38)
          {
            uint64_t v142 = v110;
          }
          else
          {
            uint64_t v142 = v110;
            if ((unint64_t)(v138 - (void)v110) >= 0x20)
            {
              uint64_t v143 = (v141 >> 3) + 1;
              uint8x8_t v144 = v110 - 2;
              unint64_t v145 = (long long *)(v138 - 16);
              uint64_t v146 = v143 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v147 = *v145;
                *((_OWORD *)v144 - 1) = *(v145 - 1);
                *(_OWORD *)uint8x8_t v144 = v147;
                v144 -= 4;
                v145 -= 2;
                v146 -= 4;
              }
              while (v146);
              uint64_t v142 = &v110[-(v143 & 0x3FFFFFFFFFFFFFFCLL)];
              v138 -= 8 * (v143 & 0x3FFFFFFFFFFFFFFCLL);
              if (v143 == (v143 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_244;
              }
            }
          }
          do
          {
            uint64_t v174 = *(void *)(v138 - 8);
            v138 -= 8;
            *--uint64_t v142 = v174;
          }
          while (v138 != v139);
LABEL_244:
          uint64_t v138 = *(void *)(v99 + 32);
LABEL_245:
          uint64_t v117 = v110 + 1;
          *(void *)(v99 + 32) = v142;
          *(void *)(v99 + 40) = v110 + 1;
          uint64_t v212 = *(void *)(v99 + 48);
          *(void *)(v99 + 48) = v111;
          if (v138) {
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v99 + 56) + 40))(*(void *)(v99 + 56), v138, v212 - v138);
          }
          goto LABEL_247;
        }
        goto LABEL_194;
      }
    }
    if (v102) {
      *uint64_t v102 = v101;
    }
    uint64_t v117 = v102 + 1;
LABEL_247:
    *(void *)(v99 + 40) = v117;
    v290[0] = (uint16x4_t)v101;
    uint64_t v213 = *(void *)(v99 + 120);
    if (!v213) {
      break;
    }
    (*(void (**)(uint64_t, uint16x4_t *))(*(void *)v213 + 48))(v213, v290);
    uint64_t v216 = *(void *)(v101 + 64);
    *(void *)(v216 + 24) = 0;
    uint64_t v217 = *a4;
    *(void *)(v216 + 16) = *a4;
    uint64_t v218 = *(void *)(v101 + 160);
    uint64_t v219 = a4[1];
    if (v219) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v219 + 8), 1uLL, memory_order_relaxed);
    }
    double v220 = *(std::__shared_weak_count **)(v218 + 24);
    *(void *)(v218 + 16) = v217;
    *(void *)(v218 + 24) = v219;
    if (v220 && !atomic_fetch_add(&v220->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v220->__on_zero_shared)(v220);
      std::__shared_weak_count::__release_weak(v220);
    }
    **(void **)(v101 + 96) = *v84;
    uint64_t v221 = *(void **)(v101 + 64);
    double v222 = (void *)v221[4];
    unint64_t v223 = v222[1];
    uint64_t v224 = v222[9];
    *(float *)uint64_t v224 = v89;
    *(float *)(v224 + 4) = v88;
    uint64_t v225 = *a2;
    *(_DWORD *)(v224 + 16) = *(_DWORD *)(*a2 + 92);
    *(_DWORD *)(v224 + 20) = *(_DWORD *)(v225 + 96);
    *(_DWORD *)(v224 + 24) = *(_DWORD *)(v225 + 100);
    v214.i64[0] = *(void *)(v225 + 104);
    v214.i32[2] = *(_DWORD *)(v225 + 112);
    v215.i64[0] = *(void *)(v225 + 92);
    v215.i32[2] = *(_DWORD *)(v225 + 100);
    float32x4_t v226 = vmaxnmq_f32(vsubq_f32(v214, v215), (float32x4_t)0);
    *(_DWORD *)(v224 + 40) = v226.i32[2];
    *(void *)(v224 + 32) = v226.i64[0];
    if (v222[8] > v223) {
      unint64_t v223 = v222[8];
    }
    v222[7] = 0;
    v222[8] = v223;
    double v227 = (void *)v221[6];
    unint64_t v228 = v227[1];
    uint64_t v229 = v227[9];
    *(_OWORD *)uint64_t v229 = v272;
    *(_DWORD *)(v229 + 368) = *a8;
    *(_DWORD *)(v229 + 372) = a8[1];
    *(_DWORD *)(v229 + 376) = a8[2];
    *(_DWORD *)(v229 + 356) = 1065353216;
    *(float *)(v229 + 352) = v90;
    *(float *)(v229 + 256) = v39;
    *(float *)(v229 + 260) = v91;
    if (v227[8] > v228) {
      unint64_t v228 = v227[8];
    }
    v227[7] = 0;
    v227[8] = v228;
    double v230 = (void *)v221[8];
    unint64_t v231 = v230[1];
    uint64_t v232 = (float *)v230[9];
    *uint64_t v232 = v92;
    v232[1] = v93;
    if (v230[8] > v231) {
      unint64_t v231 = v230[8];
    }
    v230[7] = 0;
    v230[8] = v231;
    v221[11] = 0;
    uint64_t v233 = *v279;
    v221[10] = *v279;
    uint64_t v234 = *(void *)(v101 + 160);
    uint64_t v235 = v279[1];
    if (v235) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v235 + 8), 1uLL, memory_order_relaxed);
    }
    float32x4_t v236 = *(std::__shared_weak_count **)(v234 + 88);
    *(void *)(v234 + 80) = v233;
    *(void *)(v234 + 88) = v235;
    if (v236 && !atomic_fetch_add(&v236->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v236->__on_zero_shared)(v236);
      std::__shared_weak_count::__release_weak(v236);
    }
    uint64_t v286 = v101;
    if (v278)
    {
      uint64_t v237 = *(void *)(a1 + 176);
      double v207 = *(std::__shared_weak_count **)(a1 + 184);
      if (v207) {
        atomic_fetch_add_explicit(&v207->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v237 && **(void **)(v237 + 40) == *(void *)(v101 + 8))
      {
        uint64_t v238 = *(void *)(v101 + 16);
        if (v238 && v238 != v237) {
          ggl::PipelineSetup::resetData(v101);
        }
        if (v207) {
          atomic_fetch_add_explicit(&v207->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v209 = *(std::__shared_weak_count **)(v101 + 24);
        *(void *)(v101 + 16) = v237;
        *(void *)(v101 + 24) = v207;
        if (!v209) {
          goto LABEL_278;
        }
      }
      else
      {
        uint64_t v209 = *(std::__shared_weak_count **)(v101 + 24);
        *(void *)(v101 + 16) = 0;
        *(void *)(v101 + 24) = 0;
        if (!v209) {
          goto LABEL_278;
        }
      }
LABEL_277:
      if (atomic_fetch_add(&v209->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
LABEL_278:
        if (!v207) {
          goto LABEL_282;
        }
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v209->__on_zero_shared)(v209);
        std::__shared_weak_count::__release_weak(v209);
        if (!v207) {
          goto LABEL_282;
        }
      }
      if (!atomic_fetch_add(&v207->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v207->__on_zero_shared)(v207);
        std::__shared_weak_count::__release_weak(v207);
      }
    }
LABEL_282:
    uint64_t v240 = (void *)v84[2];
    float v239 = (void *)v84[3];
    unint64_t v284 = v84;
    if (v240 != v239)
    {
      if (v286) {
        uint64_t v241 = v286;
      }
      else {
        uint64_t v241 = v288;
      }
      while (1)
      {
        float v243 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(a1 + 88));
        v243[3] = a3;
        v243[4] = v241;
        v243[8] = *v240;
        v243[6] = 2;
        *(void *)(a1 + 288) = *(void *)(a1 + 280);
        uint64_t v246 = v240[1];
        uint64_t v245 = v240[2];
        while (v246 != v245)
        {
          v290[0] = *(uint16x4_t *)(v246 + 16);
          uint64_t v247 = *(void *)(a18 + 24);
          if (!v247) {
            goto LABEL_322;
          }
          if ((*(unsigned int (**)(uint64_t, uint16x4_t *))(*(void *)v247 + 48))(v247, v290))
          {
            if (*(void *)(v246 + 8) != *(void *)v246) {
              gm::MultiRange<unsigned long>::push_back((char **)(a1 + 280), (_OWORD *)v246);
            }
          }
          v246 += 24;
        }
        unint64_t v248 = ggl::Batcher::commit((long long **)(a1 + 280), 0, v244);
        float v249 = *v248;
        v243[11] = *v248;
        v243[12] = (v248[1] - v249) >> 4;
        float v250 = *(void **)(a7 + 80);
        unint64_t v251 = *(void *)(a7 + 88);
        if ((unint64_t)v250 >= v251) {
          break;
        }
        if (v250) {
          *float v250 = v243;
        }
        double v242 = v250 + 1;
LABEL_287:
        *(void *)(a7 + 80) = v242;
        v240 += 4;
        if (v240 == v239) {
          goto LABEL_107;
        }
      }
      uint64_t v252 = *(void *)(a7 + 72);
      uint64_t v253 = ((uint64_t)v250 - v252) >> 3;
      unint64_t v254 = v253 + 1;
      if ((unint64_t)(v253 + 1) >> 61) {
        abort();
      }
      uint64_t v255 = v251 - v252;
      if (v255 >> 2 > v254) {
        unint64_t v254 = v255 >> 2;
      }
      if ((unint64_t)v255 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v256 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v256 = v254;
      }
      if (v256)
      {
        uint64_t v257 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a7 + 96) + 16))(*(void *)(a7 + 96), 8 * v256, 8);
        float v258 = (void *)(v257 + 8 * v253);
        uint64_t v259 = v257 + 8 * v256;
        if (v257) {
          *float v258 = v243;
        }
      }
      else
      {
        uint64_t v259 = 0;
        float v258 = (void *)(8 * v253);
      }
      uint64_t v261 = *(void *)(a7 + 72);
      uint64_t v260 = *(void *)(a7 + 80);
      uint64_t v262 = v260 - v261;
      if (v260 != v261)
      {
        unint64_t v263 = v262 - 8;
        if ((unint64_t)(v262 - 8) < 0x38)
        {
          float v264 = v258;
        }
        else
        {
          float v264 = v258;
          if ((unint64_t)(v260 - (void)v258) >= 0x20)
          {
            uint64_t v265 = (v263 >> 3) + 1;
            float v266 = v258 - 2;
            float v267 = (long long *)(v260 - 16);
            uint64_t v268 = v265 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v269 = *v267;
              *(v266 - 1) = *(v267 - 1);
              *float v266 = v269;
              v266 -= 2;
              v267 -= 2;
              v268 -= 4;
            }
            while (v268);
            float v264 = &v258[-(v265 & 0x3FFFFFFFFFFFFFFCLL)];
            v260 -= 8 * (v265 & 0x3FFFFFFFFFFFFFFCLL);
            if (v265 == (v265 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_318:
              uint64_t v260 = *(void *)(a7 + 72);
LABEL_319:
              double v242 = v258 + 1;
              *(void *)(a7 + 72) = v264;
              *(void *)(a7 + 80) = v258 + 1;
              uint64_t v271 = *(void *)(a7 + 88);
              *(void *)(a7 + 88) = v259;
              if (v260) {
                (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a7 + 96) + 40))(*(void *)(a7 + 96), v260, v271 - v260);
              }
              goto LABEL_287;
            }
          }
        }
        do
        {
          uint64_t v270 = *(void *)(v260 - 8);
          v260 -= 8;
          *--float v264 = v270;
        }
        while (v260 != v261);
        goto LABEL_318;
      }
      float v264 = v258;
      goto LABEL_319;
    }
LABEL_107:
    uint64_t v84 = v284 + 5;
    uint64_t v85 = v286;
    uint64_t v86 = v288;
    if (v284 + 5 == v276) {
      goto LABEL_321;
    }
  }
LABEL_322:
  std::__throw_bad_function_call[abi:nn180100]();
  __break(1u);
}

void sub_1A2576BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
}

void generateDiffuseRenderItemsForLandmarkGroup(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t a6, uint64_t a7, __int32 *a8, float a9, float a10, float a11, float a12, float a13, char a14, unsigned __int8 a15, char a16, char a17, uint64_t a18)
{
  uint64_t v24 = *a2 + 72;
  uint64_t v25 = 56;
  if (a17 == 1) {
    uint64_t v25 = 72;
  }
  else {
    uint64_t v24 = *a2 + 56;
  }
  uint64_t v26 = *(void *)(*a2 + v25);
  uint64_t v27 = *(std::__shared_weak_count **)(v24 + 8);
  v283[0] = (uint16x4_t)v26;
  v283[1] = (uint16x4_t)v27;
  if (v27) {
    atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v284, v26, (uint64_t)v27);
  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  uint64_t v28 = *(void **)(a6 + 8);
  int8x8_t v29 = (int8x8_t)v28[1];
  if (!*(void *)&v29) {
    goto LABEL_33;
  }
  uint8x8_t v30 = (uint8x8_t)vcnt_s8(v29);
  v30.i16[0] = vaddlv_u8(v30);
  if (v30.u32[0] > 1uLL)
  {
    uint64_t v31 = 0x41E8D6E445F4145;
    if (*(void *)&v29 <= 0x41E8D6E445F4145uLL) {
      uint64_t v31 = 0x41E8D6E445F4145uLL % *(void *)&v29;
    }
  }
  else
  {
    uint64_t v31 = (*(void *)&v29 - 1) & 0x41E8D6E445F4145;
  }
  double v32 = *(void **)(*v28 + 8 * v31);
  if (!v32) {
    goto LABEL_33;
  }
  uint64_t v33 = (void *)*v32;
  if (!v33) {
    goto LABEL_33;
  }
  if (v30.u32[0] < 2uLL)
  {
    uint64_t v34 = *(void *)&v29 - 1;
    while (1)
    {
      uint64_t v36 = v33[1];
      if (v36 == 0x41E8D6E445F4145)
      {
        if (v33[2] == 0x41E8D6E445F4145) {
          goto LABEL_30;
        }
      }
      else if ((v36 & v34) != v31)
      {
        goto LABEL_33;
      }
      uint64_t v33 = (void *)*v33;
      if (!v33) {
        goto LABEL_33;
      }
    }
  }
  while (1)
  {
    unint64_t v35 = v33[1];
    if (v35 == 0x41E8D6E445F4145) {
      break;
    }
    if (v35 >= *(void *)&v29) {
      v35 %= *(void *)&v29;
    }
    if (v35 != v31) {
      goto LABEL_33;
    }
LABEL_19:
    uint64_t v33 = (void *)*v33;
    if (!v33) {
      goto LABEL_33;
    }
  }
  if (v33[2] != 0x41E8D6E445F4145) {
    goto LABEL_19;
  }
LABEL_30:
  uint64_t v37 = v33[5];
  if (*(void *)(v37 + 8) != 0x41E8D6E445F4145)
  {
LABEL_33:
    long long v272 = 0;
    if (v285) {
      goto LABEL_34;
    }
LABEL_32:
    float32x4_t v38 = 0uLL;
    float v39 = 1.0;
    float v40 = 0.065;
    float v41 = 7.875;
    float32x4_t v42 = 0uLL;
    goto LABEL_91;
  }
  long long v272 = *(uint64_t **)(v37 + 32);
  if (!v285) {
    goto LABEL_32;
  }
LABEL_34:
  if ((int)a12 >= 0x17) {
    unsigned int v43 = 23;
  }
  else {
    unsigned int v43 = (int)a12;
  }
  gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v283, *(void *)(v284[0] + 24), 0xA2u, v43, 2u, 0);
  float32x4_t v276 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v283[0])), (float32x4_t)vdupq_n_s32(0x37800080u));
  uint64_t v44 = *(void *)(v284[0] + 24);
  uint64_t v45 = *(float **)v44;
  if (*(void *)v44)
  {
    float v46 = *v45;
    BOOL v47 = *v45 == 1.0;
    if (*(unsigned char *)(v44 + 10))
    {
      if (v46 != 0.0 && v46 != 1.0)
      {
LABEL_47:
        if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v284[0] + 24), 0x12Fu, v43, 0) & 1) == 0)
        {
          unsigned int v49 = 1;
          goto LABEL_49;
        }
        goto LABEL_50;
      }
    }
  }
  else
  {
    BOOL v47 = 0;
  }
  unsigned int v49 = *(unsigned __int8 *)(v44 + v47 + 11);
  if (v49 == 2) {
    goto LABEL_47;
  }
LABEL_49:
  if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v44, 0x12Fu, v43, v49))
  {
    float32x4_t v270 = v276;
    if (v45) {
      goto LABEL_51;
    }
    goto LABEL_59;
  }
LABEL_50:
  gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)v283, v44, 0x12Fu, v43, 2u, 0);
  float32x4_t v270 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v283[0])), (float32x4_t)vdupq_n_s32(0x37800080u));
  uint64_t v44 = *(void *)(v284[0] + 24);
  uint64_t v45 = *(float **)v44;
  if (!*(void *)v44)
  {
LABEL_59:
    BOOL v51 = 0;
    goto LABEL_60;
  }
LABEL_51:
  float v50 = *v45;
  BOOL v51 = *v45 == 1.0;
  if (*(unsigned char *)(v44 + 10))
  {
    if (v50 != 0.0 && v50 != 1.0)
    {
LABEL_61:
      v283[0].i8[0] = 1;
      v286[0] = 1;
      float v54 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v44, 0x12Bu, v43, 0, v283);
      float v55 = v54
          + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v44, 0x12Bu, v43, 1u, v286)- v54)* v50);
      goto LABEL_63;
    }
  }
LABEL_60:
  unsigned int v53 = *(unsigned __int8 *)(v44 + v51 + 11);
  float v50 = 0.0;
  if (v53 == 2) {
    goto LABEL_61;
  }
  float v55 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v44, 0x12Bu, v43, v53, 0);
LABEL_63:
  uint64_t v56 = *(void *)(v284[0] + 24);
  char v57 = *(float **)v56;
  if (*(void *)v56
    && (float v58 = *v57, LODWORD(v57) = *v57 == 1.0, *(unsigned char *)(v56 + 10))
    && (v58 != 0.0 ? (BOOL v59 = v58 == 1.0) : (BOOL v59 = 1), !v59)
    || (v60 = *(unsigned __int8 *)(v56 + v57 + 11), float v58 = 0.0, v60 == 2))
  {
    v283[0].i8[0] = 1;
    v286[0] = 1;
    float v61 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v56, 0x137u, v43, 0, v283);
    float v62 = v61
        + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v56, 0x137u, v43, 1u, v286)- v61)* v58);
  }
  else
  {
    float v62 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v284[0] + 24), 0x137u, v43, v60, 0);
  }
  uint64_t v63 = *(void *)(v284[0] + 24);
  unsigned int v64 = *(float **)v63;
  if (*(void *)v63
    && (float v65 = *v64, LODWORD(v64) = *v64 == 1.0, *(unsigned char *)(v63 + 10))
    && (v65 != 0.0 ? (BOOL v66 = v65 == 1.0) : (BOOL v66 = 1), !v66)
    || (v67 = *(unsigned __int8 *)(v63 + v64 + 11), float v65 = 0.0, v67 == 2))
  {
    v283[0].i8[0] = 1;
    v286[0] = 1;
    float v68 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v63, 0x14Au, v43, 0, v283);
    float v40 = v68
        + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v63, 0x14Au, v43, 1u, v286)- v68)* v65);
  }
  else
  {
    float v40 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v284[0] + 24), 0x14Au, v43, v67, 0);
  }
  float v39 = v55 + (float)((float)(v62 - v55) * a10);
  uint64_t v69 = *(void *)(v284[0] + 24);
  uint64_t v70 = *(float **)v69;
  if (*(void *)v69 && (float v71 = *v70, LODWORD(v70) = *v70 == 1.0, *(unsigned char *)(v69 + 10)) && v71 != 0.0 && v71 != 1.0
    || (v72 = *(unsigned __int8 *)(v69 + v70 + 11), float v71 = 0.0, v72 == 2))
  {
    v283[0].i8[0] = 1;
    v286[0] = 1;
    float v73 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v69, 0x14Bu, v43, 0, v283);
    float v41 = v73
        + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v69, 0x14Bu, v43, 1u, v286)- v73)* v71);
  }
  else
  {
    float v41 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v284[0] + 24), 0x14Bu, v43, v72, 0);
  }
  float32x4_t v42 = v276;
  float32x4_t v38 = v270;
LABEL_91:
  int v74 = a15;
  int8x16_t v75 = (int8x16_t)vsubq_f32(v38, v42);
  v76.f32[0] = a13;
  v76.f32[1] = a13 * a9;
  float32x2_t v77 = vmul_f32(vmla_n_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v42, (int8x16_t)v42, 8uLL), (float32x2_t)*(_OWORD *)&vextq_s8(v75, v75, 8uLL), a10), v76);
  float32x2_t v268 = v77;
  if (v77.f32[1] <= 0.999) {
    int v74 = 1;
  }
  int v271 = v74;
  unsigned int v78 = *(void **)(*a2 + 32);
  long long v269 = *(void **)(*a2 + 40);
  if (v78 == v269)
  {
LABEL_309:
    gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v284);
    return;
  }
  uint64_t v79 = 0;
  uint64_t v80 = 0;
  *(float32x2_t *)&long long v81 = vmul_n_f32(vmla_n_f32(*(float32x2_t *)v42.f32, *(float32x2_t *)v75.i8, a10), a13);
  float v82 = fmaxf(a11, 0.1);
  float v83 = fmaxf(a10, 0.1);
  float v84 = 1.0 - v39;
  float v85 = v40 * 40075017.0 / (v41 * (double)(unint64_t)(1 << a14));
  float v86 = 1.0 - v40;
  float32x2_t v266 = (float32x2_t)v81;
  *((float32x2_t *)&v81 + 1) = v77;
  long long v265 = v81;
  while (1)
  {
    if (a16)
    {
      uint64_t v87 = *(void *)(a1 + 8);
      uint64_t v88 = *(void *)(v87 + 8);
      uint64_t v281 = v80;
      if (v88 == *(void *)v87)
      {
        uint64_t v105 = *(void *)(v87 + 88);
        if (!v105) {
          break;
        }
        uint64_t v89 = (*(uint64_t (**)(uint64_t))(*(void *)v105 + 48))(v105);
        float v90 = *(uint64_t **)(v87 + 40);
        unint64_t v106 = *(void *)(v87 + 48);
        if ((unint64_t)v90 >= v106)
        {
          uint64_t v119 = *(void *)(v87 + 32);
          uint64_t v120 = ((uint64_t)v90 - v119) >> 3;
          unint64_t v121 = v120 + 1;
          if ((unint64_t)(v120 + 1) >> 61) {
            goto LABEL_313;
          }
          uint64_t v122 = v106 - v119;
          if (v122 >> 2 > v121) {
            unint64_t v121 = v122 >> 2;
          }
          if ((unint64_t)v122 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v123 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v123 = v121;
          }
          if (v123)
          {
            uint64_t v124 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v87 + 56) + 16))(*(void *)(v87 + 56), 8 * v123, 8);
            unint64_t v98 = (uint64_t *)(v124 + 8 * v120);
            uint64_t v99 = v124 + 8 * v123;
            if (v124) {
              *unint64_t v98 = v89;
            }
          }
          else
          {
            uint64_t v99 = 0;
            unint64_t v98 = (uint64_t *)(8 * v120);
          }
          uint64_t v151 = *(void *)(v87 + 32);
          uint64_t v131 = *(void *)(v87 + 40);
          uint64_t v152 = v131 - v151;
          if (v131 != v151)
          {
            unint64_t v153 = v152 - 8;
            if ((unint64_t)(v152 - 8) < 0x38)
            {
              uint64_t v135 = v98;
            }
            else
            {
              uint64_t v135 = v98;
              if ((unint64_t)(v131 - (void)v98) >= 0x20)
              {
                uint64_t v154 = (v153 >> 3) + 1;
                __int8 v155 = v98 - 2;
                uint64_t v156 = (long long *)(v131 - 16);
                uint64_t v157 = v154 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v158 = *v156;
                  *((_OWORD *)v155 - 1) = *(v156 - 1);
                  *(_OWORD *)__int8 v155 = v158;
                  v155 -= 4;
                  v156 -= 2;
                  v157 -= 4;
                }
                while (v157);
                uint64_t v135 = &v98[-(v154 & 0x3FFFFFFFFFFFFFFCLL)];
                v131 -= 8 * (v154 & 0x3FFFFFFFFFFFFFFCLL);
                if (v154 == (v154 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_191;
                }
              }
            }
            do
            {
              uint64_t v169 = *(void *)(v131 - 8);
              v131 -= 8;
              *--uint64_t v135 = v169;
            }
            while (v131 != v151);
            goto LABEL_191;
          }
LABEL_173:
          uint64_t v135 = v98;
          goto LABEL_192;
        }
      }
      else
      {
        uint64_t v89 = *(void *)(v88 - 8);
        *(void *)(v87 + 8) = v88 - 8;
        float v90 = *(uint64_t **)(v87 + 40);
        unint64_t v91 = *(void *)(v87 + 48);
        if ((unint64_t)v90 >= v91)
        {
          uint64_t v92 = *(void *)(v87 + 32);
          uint64_t v93 = ((uint64_t)v90 - v92) >> 3;
          unint64_t v94 = v93 + 1;
          if ((unint64_t)(v93 + 1) >> 61) {
            goto LABEL_313;
          }
          uint64_t v95 = v91 - v92;
          if (v95 >> 2 > v94) {
            unint64_t v94 = v95 >> 2;
          }
          if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v96 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v96 = v94;
          }
          if (v96)
          {
            uint64_t v97 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v87 + 56) + 16))(*(void *)(v87 + 56), 8 * v96, 8);
            unint64_t v98 = (uint64_t *)(v97 + 8 * v93);
            uint64_t v99 = v97 + 8 * v96;
            if (v97) {
              *unint64_t v98 = v89;
            }
          }
          else
          {
            uint64_t v99 = 0;
            unint64_t v98 = (uint64_t *)(8 * v93);
          }
          uint64_t v132 = *(void *)(v87 + 32);
          uint64_t v131 = *(void *)(v87 + 40);
          uint64_t v133 = v131 - v132;
          if (v131 != v132)
          {
            unint64_t v134 = v133 - 8;
            if ((unint64_t)(v133 - 8) < 0x38)
            {
              uint64_t v135 = v98;
            }
            else
            {
              uint64_t v135 = v98;
              if ((unint64_t)(v131 - (void)v98) >= 0x20)
              {
                uint64_t v136 = (v134 >> 3) + 1;
                uint64_t v137 = v98 - 2;
                uint64_t v138 = (long long *)(v131 - 16);
                uint64_t v139 = v136 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v140 = *v138;
                  *((_OWORD *)v137 - 1) = *(v138 - 1);
                  *(_OWORD *)uint64_t v137 = v140;
                  v137 -= 4;
                  v138 -= 2;
                  v139 -= 4;
                }
                while (v139);
                uint64_t v135 = &v98[-(v136 & 0x3FFFFFFFFFFFFFFCLL)];
                v131 -= 8 * (v136 & 0x3FFFFFFFFFFFFFFCLL);
                if (v136 == (v136 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_191;
                }
              }
            }
            do
            {
              uint64_t v167 = *(void *)(v131 - 8);
              v131 -= 8;
              *--uint64_t v135 = v167;
            }
            while (v131 != v132);
LABEL_191:
            uint64_t v131 = *(void *)(v87 + 32);
LABEL_192:
            uint64_t v107 = v98 + 1;
            *(void *)(v87 + 32) = v135;
            *(void *)(v87 + 40) = v98 + 1;
            uint64_t v170 = *(void *)(v87 + 48);
            *(void *)(v87 + 48) = v99;
            if (v131) {
              (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v87 + 56) + 40))(*(void *)(v87 + 56), v131, v170 - v131);
            }
            goto LABEL_194;
          }
          goto LABEL_173;
        }
      }
      if (v90) {
        uint64_t *v90 = v89;
      }
      uint64_t v107 = v90 + 1;
LABEL_194:
      *(void *)(v87 + 40) = v107;
      v283[0] = (uint16x4_t)v89;
      uint64_t v171 = *(void *)(v87 + 120);
      if (!v171) {
        break;
      }
      (*(void (**)(uint64_t, uint16x4_t *))(*(void *)v171 + 48))(v171, v283);
      uint64_t v174 = *(void *)(v89 + 64);
      *(void *)(v174 + 24) = 0;
      uint64_t v175 = *a4;
      *(void *)(v174 + 16) = *a4;
      uint64_t v176 = *(void *)(v89 + 160);
      uint64_t v177 = a4[1];
      if (v177) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v177 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v178 = *(std::__shared_weak_count **)(v176 + 24);
      *(void *)(v176 + 16) = v175;
      *(void *)(v176 + 24) = v177;
      if (v178 && !atomic_fetch_add(&v178->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v178->__on_zero_shared)(v178);
        std::__shared_weak_count::__release_weak(v178);
      }
      **(void **)(v89 + 96) = *v78;
      float32x4_t v179 = *(void **)(v89 + 64);
      float32x4_t v180 = (void *)v179[4];
      unint64_t v181 = v180[1];
      uint64_t v182 = v180[9];
      *(float *)uint64_t v182 = v83;
      *(float *)(v182 + 4) = v82;
      uint64_t v183 = *a2;
      *(_DWORD *)(v182 + 16) = *(_DWORD *)(*a2 + 92);
      *(_DWORD *)(v182 + 20) = *(_DWORD *)(v183 + 96);
      *(_DWORD *)(v182 + 24) = *(_DWORD *)(v183 + 100);
      v172.i64[0] = *(void *)(v183 + 104);
      v172.i32[2] = *(_DWORD *)(v183 + 112);
      v173.i64[0] = *(void *)(v183 + 92);
      v173.i32[2] = *(_DWORD *)(v183 + 100);
      float32x4_t v184 = vmaxnmq_f32(vsubq_f32(v172, v173), (float32x4_t)0);
      *(_DWORD *)(v182 + 40) = v184.i32[2];
      *(void *)(v182 + 32) = v184.i64[0];
      if (v180[8] > v181) {
        unint64_t v181 = v180[8];
      }
      v180[7] = 0;
      v180[8] = v181;
      double v185 = (void *)v179[6];
      unint64_t v186 = v185[1];
      double v187 = (float32x2_t *)v185[9];
      *double v187 = v266;
      v187[1] = v268;
      v187[46].i32[0] = *a8;
      v187[46].i32[1] = a8[1];
      v187[47].i32[0] = a8[2];
      v187[44].i32[1] = 1065353216;
      v187[44].f32[0] = v84;
      if (v185[8] > v186) {
        unint64_t v186 = v185[8];
      }
      v185[7] = 0;
      v185[8] = v186;
      unint64_t v188 = (void *)v179[8];
      unint64_t v189 = v188[1];
      uint64_t v190 = (float *)v188[9];
      *uint64_t v190 = v85;
      v190[1] = v86;
      if (v188[8] > v189) {
        unint64_t v189 = v188[8];
      }
      v188[7] = 0;
      v188[8] = v189;
      v179[11] = 0;
      uint64_t v191 = *v272;
      v179[10] = *v272;
      uint64_t v192 = *(void *)(v89 + 160);
      uint64_t v193 = v272[1];
      if (v193) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v193 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v194 = *(std::__shared_weak_count **)(v192 + 88);
      *(void *)(v192 + 80) = v191;
      *(void *)(v192 + 88) = v193;
      if (v194 && !atomic_fetch_add(&v194->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v194->__on_zero_shared)(v194);
        std::__shared_weak_count::__release_weak(v194);
      }
      uint64_t v279 = v89;
      if (v271)
      {
        uint64_t v196 = *(void *)(a1 + 240);
        double v195 = *(std::__shared_weak_count **)(a1 + 248);
        if (v195) {
          atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v196 && **(void **)(v196 + 40) == *(void *)(v89 + 8))
        {
          uint64_t v198 = *(void *)(v89 + 16);
          if (v198 && v198 != v196) {
            ggl::PipelineSetup::resetData(v89);
          }
          if (v195) {
            atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          BOOL v197 = *(std::__shared_weak_count **)(v89 + 24);
          *(void *)(v89 + 16) = v196;
          *(void *)(v89 + 24) = v195;
          if (!v197) {
            goto LABEL_266;
          }
        }
        else
        {
          BOOL v197 = *(std::__shared_weak_count **)(v89 + 24);
          *(void *)(v89 + 16) = 0;
          *(void *)(v89 + 24) = 0;
          if (!v197) {
            goto LABEL_266;
          }
        }
        goto LABEL_265;
      }
      goto LABEL_270;
    }
    uint64_t v100 = *(void *)(a1 + 32);
    uint64_t v101 = *(void *)(v100 + 8);
    if (v101 == *(void *)v100)
    {
      uint64_t v108 = *(void *)(v100 + 88);
      if (!v108) {
        break;
      }
      uint64_t v281 = (*(uint64_t (**)(uint64_t))(*(void *)v108 + 48))(v108);
      unint64_t v103 = *(uint64_t **)(v100 + 40);
      unint64_t v109 = *(void *)(v100 + 48);
      if ((unint64_t)v103 < v109)
      {
        if (v103) {
          *unint64_t v103 = v281;
        }
        goto LABEL_121;
      }
      uint64_t v125 = *(void *)(v100 + 32);
      uint64_t v126 = ((uint64_t)v103 - v125) >> 3;
      unint64_t v127 = v126 + 1;
      if ((unint64_t)(v126 + 1) >> 61) {
LABEL_313:
      }
        abort();
      uint64_t v128 = v109 - v125;
      if (v128 >> 2 > v127) {
        unint64_t v127 = v128 >> 2;
      }
      if ((unint64_t)v128 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v129 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v129 = v127;
      }
      if (v129)
      {
        uint64_t v130 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v100 + 56) + 16))(*(void *)(v100 + 56), 8 * v129, 8);
        uint64_t v117 = (uint64_t *)(v130 + 8 * v126);
        uint64_t v118 = v130 + 8 * v129;
        if (v130) {
          *uint64_t v117 = v281;
        }
      }
      else
      {
        uint64_t v118 = 0;
        uint64_t v117 = (uint64_t *)(8 * v126);
      }
      uint64_t v159 = *(void *)(v100 + 32);
      uint64_t v141 = *(void *)(v100 + 40);
      uint64_t v160 = v141 - v159;
      if (v141 == v159)
      {
LABEL_182:
        unint64_t v145 = v117;
        goto LABEL_228;
      }
      unint64_t v161 = v160 - 8;
      if ((unint64_t)(v160 - 8) < 0x38)
      {
        unint64_t v145 = v117;
      }
      else
      {
        unint64_t v145 = v117;
        if ((unint64_t)(v141 - (void)v117) >= 0x20)
        {
          uint64_t v162 = (v161 >> 3) + 1;
          char v163 = v117 - 2;
          uint64_t v164 = (long long *)(v141 - 16);
          uint64_t v165 = v162 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v166 = *v164;
            *((_OWORD *)v163 - 1) = *(v164 - 1);
            *(_OWORD *)char v163 = v166;
            v163 -= 4;
            v164 -= 2;
            v165 -= 4;
          }
          while (v165);
          unint64_t v145 = &v117[-(v162 & 0x3FFFFFFFFFFFFFFCLL)];
          v141 -= 8 * (v162 & 0x3FFFFFFFFFFFFFFCLL);
          if (v162 == (v162 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_227;
          }
        }
      }
      do
      {
        uint64_t v199 = *(void *)(v141 - 8);
        v141 -= 8;
        *--unint64_t v145 = v199;
      }
      while (v141 != v159);
    }
    else
    {
      uint64_t v102 = *(void *)(v101 - 8);
      *(void *)(v100 + 8) = v101 - 8;
      unint64_t v103 = *(uint64_t **)(v100 + 40);
      unint64_t v104 = *(void *)(v100 + 48);
      uint64_t v281 = v102;
      if ((unint64_t)v103 < v104)
      {
        if (v103) {
          *unint64_t v103 = v102;
        }
LABEL_121:
        uint64_t v110 = v103 + 1;
        goto LABEL_230;
      }
      uint64_t v111 = *(void *)(v100 + 32);
      uint64_t v112 = ((uint64_t)v103 - v111) >> 3;
      unint64_t v113 = v112 + 1;
      if ((unint64_t)(v112 + 1) >> 61) {
        goto LABEL_313;
      }
      uint64_t v114 = v104 - v111;
      if (v114 >> 2 > v113) {
        unint64_t v113 = v114 >> 2;
      }
      if ((unint64_t)v114 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v115 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v115 = v113;
      }
      if (v115)
      {
        uint64_t v116 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v100 + 56) + 16))(*(void *)(v100 + 56), 8 * v115, 8);
        uint64_t v117 = (uint64_t *)(v116 + 8 * v112);
        uint64_t v118 = v116 + 8 * v115;
        if (v116) {
          *uint64_t v117 = v281;
        }
      }
      else
      {
        uint64_t v118 = 0;
        uint64_t v117 = (uint64_t *)(8 * v112);
      }
      uint64_t v142 = *(void *)(v100 + 32);
      uint64_t v141 = *(void *)(v100 + 40);
      uint64_t v143 = v141 - v142;
      if (v141 == v142) {
        goto LABEL_182;
      }
      unint64_t v144 = v143 - 8;
      if ((unint64_t)(v143 - 8) < 0x38)
      {
        unint64_t v145 = v117;
      }
      else
      {
        unint64_t v145 = v117;
        if ((unint64_t)(v141 - (void)v117) >= 0x20)
        {
          uint64_t v146 = (v144 >> 3) + 1;
          long long v147 = v117 - 2;
          uint64_t v148 = (long long *)(v141 - 16);
          uint64_t v149 = v146 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v150 = *v148;
            *((_OWORD *)v147 - 1) = *(v148 - 1);
            *(_OWORD *)long long v147 = v150;
            v147 -= 4;
            v148 -= 2;
            v149 -= 4;
          }
          while (v149);
          unint64_t v145 = &v117[-(v146 & 0x3FFFFFFFFFFFFFFCLL)];
          v141 -= 8 * (v146 & 0x3FFFFFFFFFFFFFFCLL);
          if (v146 == (v146 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_227;
          }
        }
      }
      do
      {
        uint64_t v168 = *(void *)(v141 - 8);
        v141 -= 8;
        *--unint64_t v145 = v168;
      }
      while (v141 != v142);
    }
LABEL_227:
    uint64_t v141 = *(void *)(v100 + 32);
LABEL_228:
    uint64_t v110 = v117 + 1;
    *(void *)(v100 + 32) = v145;
    *(void *)(v100 + 40) = v117 + 1;
    uint64_t v200 = *(void *)(v100 + 48);
    *(void *)(v100 + 48) = v118;
    if (v141) {
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v100 + 56) + 40))(*(void *)(v100 + 56), v141, v200 - v141);
    }
LABEL_230:
    *(void *)(v100 + 40) = v110;
    v283[0] = (uint16x4_t)v281;
    uint64_t v201 = *(void *)(v100 + 120);
    if (!v201) {
      break;
    }
    (*(void (**)(uint64_t, uint16x4_t *))(*(void *)v201 + 48))(v201, v283);
    uint64_t v204 = *(void *)(v281 + 64);
    *(void *)(v204 + 24) = 0;
    uint64_t v205 = *a4;
    *(void *)(v204 + 16) = *a4;
    uint64_t v206 = *(void *)(v281 + 160);
    uint64_t v207 = a4[1];
    if (v207) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v207 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v208 = *(std::__shared_weak_count **)(v206 + 24);
    *(void *)(v206 + 16) = v205;
    *(void *)(v206 + 24) = v207;
    if (v208 && !atomic_fetch_add(&v208->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v208->__on_zero_shared)(v208);
      std::__shared_weak_count::__release_weak(v208);
    }
    **(void **)(v281 + 96) = *v78;
    uint64_t v209 = *(void **)(v281 + 64);
    uint64_t v210 = (void *)v209[4];
    unint64_t v211 = v210[1];
    uint64_t v212 = v210[9];
    *(float *)uint64_t v212 = v83;
    *(float *)(v212 + 4) = v82;
    uint64_t v213 = *a2;
    *(_DWORD *)(v212 + 16) = *(_DWORD *)(*a2 + 92);
    *(_DWORD *)(v212 + 20) = *(_DWORD *)(v213 + 96);
    *(_DWORD *)(v212 + 24) = *(_DWORD *)(v213 + 100);
    v202.i64[0] = *(void *)(v213 + 104);
    v202.i32[2] = *(_DWORD *)(v213 + 112);
    v203.i64[0] = *(void *)(v213 + 92);
    v203.i32[2] = *(_DWORD *)(v213 + 100);
    float32x4_t v214 = vmaxnmq_f32(vsubq_f32(v202, v203), (float32x4_t)0);
    *(_DWORD *)(v212 + 40) = v214.i32[2];
    *(void *)(v212 + 32) = v214.i64[0];
    if (v210[8] > v211) {
      unint64_t v211 = v210[8];
    }
    v210[7] = 0;
    v210[8] = v211;
    float32x4_t v215 = (void *)v209[6];
    unint64_t v216 = v215[1];
    uint64_t v217 = v215[9];
    *(_OWORD *)uint64_t v217 = v265;
    *(_DWORD *)(v217 + 368) = *a8;
    *(_DWORD *)(v217 + 372) = a8[1];
    *(_DWORD *)(v217 + 376) = a8[2];
    *(_DWORD *)(v217 + 356) = 1065353216;
    *(float *)(v217 + 352) = v84;
    if (v215[8] > v216) {
      unint64_t v216 = v215[8];
    }
    v215[7] = 0;
    v215[8] = v216;
    uint64_t v218 = (void *)v209[8];
    unint64_t v219 = v218[1];
    double v220 = (float *)v218[9];
    *double v220 = v85;
    v220[1] = v86;
    if (v218[8] > v219) {
      unint64_t v219 = v218[8];
    }
    v218[7] = 0;
    v218[8] = v219;
    v209[11] = 0;
    uint64_t v221 = *v272;
    v209[10] = *v272;
    uint64_t v222 = *(void *)(v281 + 160);
    uint64_t v223 = v272[1];
    if (v223) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v223 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v224 = *(std::__shared_weak_count **)(v222 + 88);
    *(void *)(v222 + 80) = v221;
    *(void *)(v222 + 88) = v223;
    if (v224 && !atomic_fetch_add(&v224->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v224->__on_zero_shared)(v224);
      std::__shared_weak_count::__release_weak(v224);
    }
    uint64_t v225 = *(uint64_t **)(v281 + 64);
    v225[1] = 0;
    uint64_t v226 = *a5;
    *uint64_t v225 = *a5;
    double v227 = *(void **)(v281 + 160);
    uint64_t v228 = a5[1];
    if (v228) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v228 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v229 = (std::__shared_weak_count *)v227[1];
    *double v227 = v226;
    v227[1] = v228;
    if (v229 && !atomic_fetch_add(&v229->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v229->__on_zero_shared)(v229);
      std::__shared_weak_count::__release_weak(v229);
    }
    uint64_t v279 = v79;
    if (v271)
    {
      uint64_t v230 = *(void *)(a1 + 256);
      double v195 = *(std::__shared_weak_count **)(a1 + 264);
      if (v195) {
        atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v230 && **(void **)(v230 + 40) == *(void *)(v281 + 8))
      {
        uint64_t v231 = *(void *)(v281 + 16);
        if (v231 && v231 != v230) {
          ggl::PipelineSetup::resetData(v281);
        }
        if (v195) {
          atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        BOOL v197 = *(std::__shared_weak_count **)(v281 + 24);
        *(void *)(v281 + 16) = v230;
        *(void *)(v281 + 24) = v195;
        if (!v197) {
          goto LABEL_266;
        }
      }
      else
      {
        BOOL v197 = *(std::__shared_weak_count **)(v281 + 24);
        *(void *)(v281 + 16) = 0;
        *(void *)(v281 + 24) = 0;
        if (!v197) {
          goto LABEL_266;
        }
      }
LABEL_265:
      if (atomic_fetch_add(&v197->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
LABEL_266:
        if (!v195) {
          goto LABEL_270;
        }
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v197->__on_zero_shared)(v197);
        std::__shared_weak_count::__release_weak(v197);
        if (!v195) {
          goto LABEL_270;
        }
      }
      if (!atomic_fetch_add(&v195->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v195->__on_zero_shared)(v195);
        std::__shared_weak_count::__release_weak(v195);
      }
    }
LABEL_270:
    uint64_t v233 = (void *)v78[2];
    uint64_t v232 = (void *)v78[3];
    float32x4_t v277 = v78;
    if (v233 != v232)
    {
      if (v279) {
        uint64_t v234 = v279;
      }
      else {
        uint64_t v234 = v281;
      }
      while (1)
      {
        float32x4_t v236 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(a1 + 88));
        v236[3] = a3;
        v236[4] = v234;
        v236[8] = *v233;
        v236[6] = 2;
        *(void *)(a1 + 288) = *(void *)(a1 + 280);
        uint64_t v239 = v233[1];
        uint64_t v238 = v233[2];
        while (v239 != v238)
        {
          v283[0] = *(uint16x4_t *)(v239 + 16);
          uint64_t v240 = *(void *)(a18 + 24);
          if (!v240) {
            goto LABEL_310;
          }
          if ((*(unsigned int (**)(uint64_t, uint16x4_t *))(*(void *)v240 + 48))(v240, v283))
          {
            if (*(void *)(v239 + 8) != *(void *)v239) {
              gm::MultiRange<unsigned long>::push_back((char **)(a1 + 280), (_OWORD *)v239);
            }
          }
          v239 += 24;
        }
        uint64_t v241 = ggl::Batcher::commit((long long **)(a1 + 280), 0, v237);
        double v242 = *v241;
        v236[11] = *v241;
        v236[12] = (v241[1] - v242) >> 4;
        float v243 = *(void **)(a7 + 80);
        unint64_t v244 = *(void *)(a7 + 88);
        if ((unint64_t)v243 >= v244) {
          break;
        }
        if (v243) {
          *float v243 = v236;
        }
        uint64_t v235 = v243 + 1;
LABEL_275:
        *(void *)(a7 + 80) = v235;
        v233 += 4;
        if (v233 == v232) {
          goto LABEL_95;
        }
      }
      uint64_t v245 = *(void *)(a7 + 72);
      uint64_t v246 = ((uint64_t)v243 - v245) >> 3;
      unint64_t v247 = v246 + 1;
      if ((unint64_t)(v246 + 1) >> 61) {
        abort();
      }
      uint64_t v248 = v244 - v245;
      if (v248 >> 2 > v247) {
        unint64_t v247 = v248 >> 2;
      }
      if ((unint64_t)v248 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v249 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v249 = v247;
      }
      if (v249)
      {
        uint64_t v250 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a7 + 96) + 16))(*(void *)(a7 + 96), 8 * v249, 8);
        unint64_t v251 = (void *)(v250 + 8 * v246);
        uint64_t v252 = v250 + 8 * v249;
        if (v250) {
          *unint64_t v251 = v236;
        }
      }
      else
      {
        uint64_t v252 = 0;
        unint64_t v251 = (void *)(8 * v246);
      }
      uint64_t v254 = *(void *)(a7 + 72);
      uint64_t v253 = *(void *)(a7 + 80);
      uint64_t v255 = v253 - v254;
      if (v253 != v254)
      {
        unint64_t v256 = v255 - 8;
        if ((unint64_t)(v255 - 8) < 0x38)
        {
          uint64_t v257 = v251;
        }
        else
        {
          uint64_t v257 = v251;
          if ((unint64_t)(v253 - (void)v251) >= 0x20)
          {
            uint64_t v258 = (v256 >> 3) + 1;
            uint64_t v259 = v251 - 2;
            uint64_t v260 = (long long *)(v253 - 16);
            uint64_t v261 = v258 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v262 = *v260;
              *(v259 - 1) = *(v260 - 1);
              *uint64_t v259 = v262;
              v259 -= 2;
              v260 -= 2;
              v261 -= 4;
            }
            while (v261);
            uint64_t v257 = &v251[-(v258 & 0x3FFFFFFFFFFFFFFCLL)];
            v253 -= 8 * (v258 & 0x3FFFFFFFFFFFFFFCLL);
            if (v258 == (v258 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_306:
              uint64_t v253 = *(void *)(a7 + 72);
LABEL_307:
              uint64_t v235 = v251 + 1;
              *(void *)(a7 + 72) = v257;
              *(void *)(a7 + 80) = v251 + 1;
              uint64_t v264 = *(void *)(a7 + 88);
              *(void *)(a7 + 88) = v252;
              if (v253) {
                (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a7 + 96) + 40))(*(void *)(a7 + 96), v253, v264 - v253);
              }
              goto LABEL_275;
            }
          }
        }
        do
        {
          uint64_t v263 = *(void *)(v253 - 8);
          v253 -= 8;
          *--uint64_t v257 = v263;
        }
        while (v253 != v254);
        goto LABEL_306;
      }
      uint64_t v257 = v251;
      goto LABEL_307;
    }
LABEL_95:
    unsigned int v78 = v277 + 5;
    uint64_t v79 = v279;
    uint64_t v80 = v281;
    if (v277 + 5 == v269) {
      goto LABEL_309;
    }
  }
LABEL_310:
  std::__throw_bad_function_call[abi:nn180100]();
  __break(1u);
}

void sub_1A2578228(_Unwind_Exception *a1)
{
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker(v1 - 184);
  _Unwind_Resume(a1);
}

void md::BuildingRenderLayer::layout3DLandmarks(void *a1, uint64_t **a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v241 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(uint64_t **)(a4 + 8);
  int8x8_t v6 = (int8x8_t)v5[1];
  if (v6)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8(v6);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      uint64_t v12 = 0x7C7EC6C7C111B0D0;
      if (*(void *)&v6 <= 0x7C7EC6C7C111B0D0uLL) {
        uint64_t v12 = 0x7C7EC6C7C111B0D0uLL % *(void *)&v6;
      }
    }
    else
    {
      uint64_t v12 = (*(void *)&v6 - 1) & 0x7C7EC6C7C111B0D0;
    }
    uint64_t v13 = *v5;
    uint64_t v14 = *(void **)(v13 + 8 * v12);
    if (!v14) {
      goto LABEL_24;
    }
    unint64_t v15 = (void *)*v14;
    if (!v15) {
      goto LABEL_24;
    }
    if (v11.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v17 = v15[1];
        if (v17 == 0x7C7EC6C7C111B0D0)
        {
          if (v15[2] == 0x7C7EC6C7C111B0D0) {
            goto LABEL_22;
          }
        }
        else if ((v17 & (*(void *)&v6 - 1)) != v12)
        {
          goto LABEL_24;
        }
        unint64_t v15 = (void *)*v15;
        if (!v15) {
          goto LABEL_24;
        }
      }
    }
    while (1)
    {
      unint64_t v16 = v15[1];
      if (v16 == 0x7C7EC6C7C111B0D0) {
        break;
      }
      if (v16 >= *(void *)&v6) {
        v16 %= *(void *)&v6;
      }
      if (v16 != v12) {
        goto LABEL_24;
      }
LABEL_11:
      unint64_t v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_24;
      }
    }
    if (v15[2] != 0x7C7EC6C7C111B0D0) {
      goto LABEL_11;
    }
LABEL_22:
    uint64_t v18 = v15[5];
    if (*(void *)(v18 + 8) == 0x7C7EC6C7C111B0D0)
    {
      uint64_t v212 = *(void *)(v18 + 32);
      goto LABEL_25;
    }
LABEL_24:
    uint64_t v212 = 0;
LABEL_25:
    if (v11.u32[0] > 1uLL)
    {
      uint64_t v19 = 0x401D4CCE847AB1D1;
      if (*(void *)&v6 <= 0x401D4CCE847AB1D1uLL) {
        uint64_t v19 = 0x401D4CCE847AB1D1uLL % *(void *)&v6;
      }
    }
    else
    {
      uint64_t v19 = (*(void *)&v6 - 1) & 0x401D4CCE847AB1D1;
    }
    long long v20 = *(void **)(v13 + 8 * v19);
    if (!v20) {
      goto LABEL_47;
    }
    uint8x8_t v21 = (void *)*v20;
    if (!v21) {
      goto LABEL_47;
    }
    if (v11.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v23 = v21[1];
        if (v23 == 0x401D4CCE847AB1D1)
        {
          if (v21[2] == 0x401D4CCE847AB1D1) {
            goto LABEL_45;
          }
        }
        else if ((v23 & (*(void *)&v6 - 1)) != v19)
        {
          goto LABEL_47;
        }
        uint8x8_t v21 = (void *)*v21;
        if (!v21) {
          goto LABEL_47;
        }
      }
    }
    while (2)
    {
      unint64_t v22 = v21[1];
      if (v22 != 0x401D4CCE847AB1D1)
      {
        if (v22 >= *(void *)&v6) {
          v22 %= *(void *)&v6;
        }
        if (v22 != v19) {
          goto LABEL_47;
        }
        goto LABEL_34;
      }
      if (v21[2] != 0x401D4CCE847AB1D1)
      {
LABEL_34:
        uint8x8_t v21 = (void *)*v21;
        if (!v21) {
          goto LABEL_47;
        }
        continue;
      }
      break;
    }
LABEL_45:
    uint64_t v24 = v21[5];
    if (*(void *)(v24 + 8) == 0x401D4CCE847AB1D1)
    {
      uint64_t v25 = *(void *)(v24 + 32);
      goto LABEL_48;
    }
LABEL_47:
    uint64_t v25 = 0;
LABEL_48:
    if (v11.u32[0] > 1uLL)
    {
      uint64_t v26 = 0x4927EB92E562CC46;
      if (*(void *)&v6 <= 0x4927EB92E562CC46uLL) {
        uint64_t v26 = 0x4927EB92E562CC46uLL % *(void *)&v6;
      }
    }
    else
    {
      uint64_t v26 = (*(void *)&v6 - 1) & 0x4927EB92E562CC46;
    }
    uint64_t v27 = *(void **)(v13 + 8 * v26);
    if (!v27) {
      goto LABEL_71;
    }
    uint64_t v28 = (void *)*v27;
    if (!v28) {
      goto LABEL_71;
    }
    if (v11.u32[0] < 2uLL)
    {
      uint64_t v29 = *(void *)&v6 - 1;
      while (1)
      {
        uint64_t v31 = v28[1];
        if (v31 == 0x4927EB92E562CC46)
        {
          if (v28[2] == 0x4927EB92E562CC46) {
            goto LABEL_68;
          }
        }
        else if ((v31 & v29) != v26)
        {
          goto LABEL_71;
        }
        uint64_t v28 = (void *)*v28;
        if (!v28) {
          goto LABEL_71;
        }
      }
    }
    while (1)
    {
      unint64_t v30 = v28[1];
      if (v30 == 0x4927EB92E562CC46) {
        break;
      }
      if (v30 >= *(void *)&v6) {
        v30 %= *(void *)&v6;
      }
      if (v30 != v26) {
        goto LABEL_71;
      }
LABEL_57:
      uint64_t v28 = (void *)*v28;
      if (!v28) {
        goto LABEL_71;
      }
    }
    if (v28[2] != 0x4927EB92E562CC46) {
      goto LABEL_57;
    }
LABEL_68:
    uint64_t v32 = v28[5];
    if (*(void *)(v32 + 8) == 0x4927EB92E562CC46)
    {
      uint64_t v33 = *(void *)(v32 + 32);
      if (!v212) {
        return;
      }
LABEL_72:
      if (v25 && *(unsigned char *)(v25 + 16)) {
        uint64_t v209 = *(void *)(v25 + 8);
      }
      else {
        uint64_t v209 = 0;
      }
      *(_OWORD *)uint64_t v223 = 0u;
      *(_OWORD *)std::string __p = 0u;
      int v225 = 1065353216;
      uint64_t v210 = a1 + 52;
      if (a1[55])
      {
        uint64_t v34 = (void *)a1[54];
        if (v34)
        {
          do
          {
            unint64_t v35 = (void *)*v34;
            operator delete(v34);
            uint64_t v34 = v35;
          }
          while (v35);
        }
        a1[54] = 0;
        uint64_t v36 = a1[53];
        if (v36)
        {
          for (uint64_t i = 0; i != v36; ++i)
            *(void *)(*v210 + 8 * i) = 0;
        }
        a1[55] = 0;
      }
      float v38 = 1.0;
      if (a5 != 1
        || ((md::LayoutContext::zoomAtCentrePoint(*(int8x8_t **)(a4 + 8)),
             float v40 = fmaxf((float)(v39 * 2.0) + -31.0, 0.0),
             v40 <= 1.0)
          ? (float v38 = 1.0 - v40)
          : (float v38 = 0.0),
            v38 >= 0.00000011921))
      {
        if (v33) {
          float v41 = *(float *)(v33 + 280);
        }
        else {
          float v41 = 0.0;
        }
        float32x4_t v42 = *(void **)(a4 + 8);
        int8x8_t v43 = (int8x8_t)v42[1];
        if (!*(void *)&v43) {
          goto LABEL_114;
        }
        uint8x8_t v44 = (uint8x8_t)vcnt_s8(v43);
        v44.i16[0] = vaddlv_u8(v44);
        if (v44.u32[0] > 1uLL)
        {
          uint64_t v45 = 0x1AF456233693CD46;
          if (*(void *)&v43 <= 0x1AF456233693CD46uLL) {
            uint64_t v45 = 0x1AF456233693CD46uLL % *(void *)&v43;
          }
        }
        else
        {
          uint64_t v45 = (*(void *)&v43 - 1) & 0x1AF456233693CD46;
        }
        float v46 = *(void **)(*v42 + 8 * v45);
        if (!v46) {
          goto LABEL_114;
        }
        BOOL v47 = (void *)*v46;
        if (!v47) {
          goto LABEL_114;
        }
        if (v44.u32[0] < 2uLL)
        {
          uint64_t v48 = *(void *)&v43 - 1;
          while (1)
          {
            uint64_t v50 = v47[1];
            if (v50 == 0x1AF456233693CD46)
            {
              if (v47[2] == 0x1AF456233693CD46) {
                goto LABEL_112;
              }
            }
            else if ((v50 & v48) != v45)
            {
              goto LABEL_114;
            }
            BOOL v47 = (void *)*v47;
            if (!v47) {
              goto LABEL_114;
            }
          }
        }
        while (2)
        {
          unint64_t v49 = v47[1];
          if (v49 != 0x1AF456233693CD46)
          {
            if (v49 >= *(void *)&v43) {
              v49 %= *(void *)&v43;
            }
            if (v49 != v45) {
              goto LABEL_114;
            }
            goto LABEL_101;
          }
          if (v47[2] != 0x1AF456233693CD46)
          {
LABEL_101:
            BOOL v47 = (void *)*v47;
            if (!v47) {
              goto LABEL_114;
            }
            continue;
          }
          break;
        }
LABEL_112:
        uint64_t v51 = v47[5];
        if (*(void *)(v51 + 8) == 0x1AF456233693CD46)
        {
          uint64_t v206 = *(void *)(v51 + 32);
          goto LABEL_115;
        }
LABEL_114:
        uint64_t v206 = 0;
LABEL_115:
        BOOL v52 = *a2;
        uint64_t v205 = a2[1];
        if (*a2 != v205)
        {
          float v53 = 1.0 - v41;
          float v54 = fmaxf(*(float *)(v206 + 3080) + *(float *)(v206 + 3076), 1.0);
          float v55 = 0.5;
          double v56 = 1.0;
          int v204 = a5;
          uint64_t v203 = v33;
          while (1)
          {
            uint64_t v57 = *v52;
            uint64_t v58 = *(void *)(*v52 + 384);
            uint64_t v59 = *v52 + 480;
            uint64_t v60 = 216;
            if (a5 == 1) {
              uint64_t v60 = 480;
            }
            else {
              uint64_t v59 = *v52 + 216;
            }
            float v61 = *(std::__shared_weak_count **)(v59 + 8);
            uint64_t v221 = *(void *)(v57 + v60);
            uint64_t v222 = v61;
            if (v61) {
              atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            unsigned int v214 = *(unsigned __int8 *)(v58 + 169);
            float v62 = operator new(0x20uLL);
            uint64_t v207 = v52;
            if (a5) {
              uint64_t v63 = &unk_1EF577910;
            }
            else {
              uint64_t v63 = &unk_1EF577958;
            }
            *float v62 = v63;
            v62[1] = v33;
            *((unsigned char *)v62 + 16) = v214;
            v62[3] = v223;
            uint64_t v240 = v62;
            md::featureIdPredicate((uint64_t)v237, 1, a5, v214, v209, v33, (uint64_t)v210);
            md::featureIdPredicate((uint64_t)v235, 0, a5, v214, v209, v33, (uint64_t)v210);
            float v64 = 1.0;
            if (a5 != 1) {
              float v64 = *(float *)(v57 + 412);
            }
            float v65 = *(float *)(v57 + 400);
            float v66 = *(float *)(v57 + 404);
            float v67 = *(float *)(v57 + 408);
            uint64_t v68 = a1[50];
            uint64_t v69 = 48;
            if (v65 > v55) {
              uint64_t v69 = 56;
            }
            uint64_t v70 = 72;
            if (v65 > v55) {
              uint64_t v70 = 80;
            }
            uint64_t v211 = *(void *)(v68 + v70);
            uint64_t v71 = *(void *)(v68 + v69);
            md::FogInfo::updateFogUniformsWithLayoutContext((uint64_t *)(v57 + 496), a4, (double *)(v57 + 88));
            unsigned int v72 = *(std::__shared_weak_count **)(v57 + 504);
            uint64_t v219 = *(void *)(v57 + 496);
            double v220 = v72;
            if (v72) {
              atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            double v73 = *(double *)(v206 + 496);
            double v74 = *(double *)(v206 + 504);
            double v75 = *(double *)(v206 + 512);
            double v76 = v56
                / (*(double *)(v57 + 632)
                 + *(double *)(v57 + 536) * v73
                 + *(double *)(v57 + 568) * v74
                 + *(double *)(v57 + 600) * v75);
            double v77 = v76
                * (*(double *)(v57 + 624)
                 + *(double *)(v57 + 528) * v73
                 + *(double *)(v57 + 560) * v74
                 + *(double *)(v57 + 592) * v75);
            float32x2_t v217 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(v57 + 608), *(float64x2_t *)(v57 + 512), v73), *(float64x2_t *)(v57 + 544), v74), *(float64x2_t *)(v57 + 576), v75), v76));
            *(float *)&double v73 = v77;
            int v218 = LODWORD(v73);
            unsigned int v78 = *(uint64_t **)(v58 + 936);
            uint64_t v208 = *(uint64_t **)(v58 + 944);
            if (v78 != v208) {
              break;
            }
LABEL_291:
            a5 = v204;
            uint64_t v33 = v203;
            if (v72 && !atomic_fetch_add(&v72->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
              std::__shared_weak_count::__release_weak(v72);
            }
            if (v236 == v235)
            {
              (*(void (**)(void *))(v235[0] + 32))(v235);
            }
            else if (v236)
            {
              (*(void (**)(void))(*v236 + 40))();
            }
            if (v238 == v237)
            {
              (*(void (**)(void *))(v237[0] + 32))(v237);
            }
            else if (v238)
            {
              (*(void (**)(void))(*v238 + 40))();
            }
            if (v240 != v239)
            {
              if (v240) {
                (*(void (**)(void))(*v240 + 40))();
              }
              BOOL v197 = v222;
              if (!v222) {
                goto LABEL_117;
              }
              goto LABEL_308;
            }
            (*(void (**)(void *))(v239[0] + 32))(v239);
            BOOL v197 = v222;
            if (v222)
            {
LABEL_308:
              if (!atomic_fetch_add(&v197->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v197->__on_zero_shared)(v197);
                std::__shared_weak_count::__release_weak(v197);
              }
            }
LABEL_117:
            BOOL v52 = v207 + 1;
            if (v207 + 1 == v205) {
              goto LABEL_310;
            }
          }
          float v79 = v66 * v38;
          float v80 = v67 * v64;
          float v81 = fmaxf(v80, 0.1);
          float v82 = fmaxf(v64, 0.1);
          while (1)
          {
            uint64_t v83 = *(void *)(*v78 + 32);
            uint64_t v215 = *(void *)(*v78 + 40);
            unint64_t v216 = v78;
            if (v83 != v215) {
              break;
            }
LABEL_137:
            uint64_t v84 = a1[50];
            int v85 = *(unsigned __int8 *)(a1[47] + 18);
            int v86 = *(unsigned __int8 *)(v212 + 32);
            uint64_t v87 = (uint64_t)v236;
            if (!*(unsigned char *)(v84 + 272))
            {
              if (v236)
              {
                if (v236 == v235)
                {
                  uint64_t v230 = v229;
                  (*(void (**)(void *, void *))(v235[0] + 24))(v235, v229);
LABEL_262:
                  char v202 = v86 != 0;
                  unsigned int v175 = v214;
                  generateDiffuseRenderItemsForLandmarkGroup(v84, v78, v211, &v221, &v219, a4, a3, (__int32 *)&v217, v79, v64, v80, v54, v53, v214, v85 != 0, v202, 0, (uint64_t)v229);
                  if (v230 == v229)
                  {
                    (*(void (**)(void *))(v229[0] + 32))(v229);
                    if (v209) {
                      goto LABEL_268;
                    }
                    goto LABEL_289;
                  }
                  if (v230) {
                    (*(void (**)(void))(*v230 + 40))();
                  }
                  if (!v209) {
                    goto LABEL_289;
                  }
LABEL_268:
                  uint64_t v186 = *(void *)(*v78 + 32);
                  uint64_t v187 = *(void *)(*v78 + 40);
                  if (v186 == v187) {
                    goto LABEL_289;
                  }
                  while (1)
                  {
                    uint64_t v188 = *(void *)(v186 + 16);
                    uint64_t v189 = *(void *)(v186 + 24);
                    if (v188 != v189) {
                      break;
                    }
LABEL_274:
                    v186 += 40;
                    if (v186 == v187) {
                      goto LABEL_289;
                    }
                  }
                  while (1)
                  {
                    uint64_t v190 = *(void *)(v188 + 8);
                    uint64_t v191 = *(void *)(v188 + 16);
                    if (v190 != v191) {
                      break;
                    }
LABEL_273:
                    v188 += 32;
                    if (v188 == v189) {
                      goto LABEL_274;
                    }
                  }
                  while (*(void *)(v190 + 16) != v209)
                  {
                    v190 += 24;
                    if (v190 == v191) {
                      goto LABEL_273;
                    }
                  }
                  uint64_t v192 = a1[50];
                  int v193 = *(unsigned __int8 *)(a1[47] + 18);
                  int v194 = *(unsigned __int8 *)(v212 + 32);
                  uint64_t v195 = (uint64_t)v238;
                  if (v238)
                  {
                    if (v238 == v237)
                    {
                      uint64_t v228 = v227;
                      (*(void (**)(void *, void *))(v237[0] + 24))(v237, v227);
                      goto LABEL_284;
                    }
                    uint64_t v195 = (*(uint64_t (**)(void))(*v238 + 16))();
                  }
                  uint64_t v228 = (void *)v195;
LABEL_284:
                  generateDiffuseRenderItemsForLandmarkGroup(v192, v78, v211, &v221, &v219, a4, a3, (__int32 *)&v217, v79, v64, v80, v54, v53, v214, v193 != 0, v194 != 0, 1, (uint64_t)v227);
                  uint64_t v196 = v228;
                  if (v228 != v227)
                  {
LABEL_285:
                    unsigned int v175 = v214;
                    if (v196) {
                      (*(void (**)(void *))(*v196 + 40))(v196);
                    }
                    goto LABEL_289;
                  }
                  (*(void (**)(void *))(v227[0] + 32))(v227);
                  goto LABEL_288;
                }
                uint64_t v87 = (*(uint64_t (**)(void))(*v236 + 16))();
              }
              uint64_t v230 = (void *)v87;
              goto LABEL_262;
            }
            if (v236)
            {
              if (v236 == v235)
              {
                uint64_t v234 = v233;
                (*(void (**)(void *, void *))(v235[0] + 24))(v235, v233);
                goto LABEL_243;
              }
              uint64_t v87 = (*(uint64_t (**)(void))(*v236 + 16))();
            }
            uint64_t v234 = (void *)v87;
LABEL_243:
            char v201 = v86 != 0;
            unsigned int v175 = v214;
            generateSpecularRenderItemsForLandmarkGroup(v84, v78, v211, &v221, &v219, a4, a3, (__int32 *)&v217, v79, v64, v80, v54, v53, v214, v85 != 0, v201, 0, (uint64_t)v233);
            if (v234 == v233)
            {
              (*(void (**)(void *))(v233[0] + 32))(v233);
              if (!v209) {
                goto LABEL_289;
              }
            }
            else
            {
              if (v234) {
                (*(void (**)(void))(*v234 + 40))();
              }
              if (!v209) {
                goto LABEL_289;
              }
            }
            uint64_t v176 = *(void *)(*v78 + 32);
            uint64_t v177 = *(void *)(*v78 + 40);
            if (v176 != v177)
            {
              while (1)
              {
                uint64_t v178 = *(void *)(v176 + 16);
                uint64_t v179 = *(void *)(v176 + 24);
                if (v178 != v179) {
                  break;
                }
LABEL_255:
                v176 += 40;
                if (v176 == v177) {
                  goto LABEL_289;
                }
              }
              while (1)
              {
                uint64_t v180 = *(void *)(v178 + 8);
                uint64_t v181 = *(void *)(v178 + 16);
                if (v180 != v181) {
                  break;
                }
LABEL_254:
                v178 += 32;
                if (v178 == v179) {
                  goto LABEL_255;
                }
              }
              while (*(void *)(v180 + 16) != v209)
              {
                v180 += 24;
                if (v180 == v181) {
                  goto LABEL_254;
                }
              }
              uint64_t v182 = a1[50];
              int v183 = *(unsigned __int8 *)(a1[47] + 18);
              int v184 = *(unsigned __int8 *)(v212 + 32);
              uint64_t v185 = (uint64_t)v238;
              if (v238)
              {
                if (v238 == v237)
                {
                  uint64_t v232 = v231;
                  (*(void (**)(void *, void *))(v237[0] + 24))(v237, v231);
                  goto LABEL_281;
                }
                uint64_t v185 = (*(uint64_t (**)(void))(*v238 + 16))();
              }
              uint64_t v232 = (void *)v185;
LABEL_281:
              generateSpecularRenderItemsForLandmarkGroup(v182, v78, v211, &v221, &v219, a4, a3, (__int32 *)&v217, v79, v64, v80, v54, v53, v214, v183 != 0, v184 != 0, 1, (uint64_t)v231);
              uint64_t v196 = v232;
              if (v232 != v231) {
                goto LABEL_285;
              }
              (*(void (**)(void *))(v231[0] + 32))(v231);
LABEL_288:
              unsigned int v175 = v214;
            }
LABEL_289:
            md::ObjectGroup::addFeatureIds(*(void *)(*v78 + 32), *(void *)(*v78 + 40), v210, v175);
            v78 += 2;
            if (v78 == v208)
            {
              unsigned int v72 = v220;
              float v55 = 0.5;
              double v56 = 1.0;
              goto LABEL_291;
            }
          }
LABEL_143:
          uint64_t v88 = *(void *)a1[50];
          uint64_t v89 = *(void *)(v88 + 8);
          if (v89 == *(void *)v88)
          {
            uint64_t v101 = *(void *)(v88 + 88);
            if (!v101) {
              goto LABEL_315;
            }
            uint64_t v90 = (*(uint64_t (**)(uint64_t))(*(void *)v101 + 48))(v101);
            unint64_t v91 = *(uint64_t **)(v88 + 40);
            unint64_t v102 = *(void *)(v88 + 48);
            if ((unint64_t)v91 >= v102)
            {
              uint64_t v104 = *(void *)(v88 + 32);
              uint64_t v105 = ((uint64_t)v91 - v104) >> 3;
              unint64_t v106 = v105 + 1;
              if ((unint64_t)(v105 + 1) >> 61) {
LABEL_318:
              }
                abort();
              uint64_t v107 = v102 - v104;
              if (v107 >> 2 > v106) {
                unint64_t v106 = v107 >> 2;
              }
              if ((unint64_t)v107 >= 0x7FFFFFFFFFFFFFF8) {
                uint64_t v108 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                uint64_t v108 = v106;
              }
              if (v108)
              {
                uint64_t v109 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v88 + 56) + 16))(*(void *)(v88 + 56), 8 * v108, 8);
                uint64_t v99 = (uint64_t *)(v109 + 8 * v105);
                uint64_t v100 = v109 + 8 * v108;
                if (v109) {
                  *uint64_t v99 = v90;
                }
              }
              else
              {
                uint64_t v100 = 0;
                uint64_t v99 = (uint64_t *)(8 * v105);
              }
              uint64_t v120 = *(void *)(v88 + 32);
              uint64_t v110 = *(void *)(v88 + 40);
              uint64_t v121 = v110 - v120;
              if (v110 != v120)
              {
                unint64_t v122 = v121 - 8;
                if ((unint64_t)(v121 - 8) < 0x38)
                {
                  uint64_t v114 = v99;
                }
                else
                {
                  uint64_t v114 = v99;
                  if ((unint64_t)(v110 - (void)v99) >= 0x20)
                  {
                    uint64_t v123 = (v122 >> 3) + 1;
                    uint64_t v124 = v99 - 2;
                    uint64_t v125 = (long long *)(v110 - 16);
                    uint64_t v126 = v123 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v127 = *v125;
                      *((_OWORD *)v124 - 1) = *(v125 - 1);
                      *(_OWORD *)uint64_t v124 = v127;
                      v124 -= 4;
                      v125 -= 2;
                      v126 -= 4;
                    }
                    while (v126);
                    uint64_t v114 = &v99[-(v123 & 0x3FFFFFFFFFFFFFFCLL)];
                    v110 -= 8 * (v123 & 0x3FFFFFFFFFFFFFFCLL);
                    if (v123 == (v123 & 0x3FFFFFFFFFFFFFFCLL)) {
                      goto LABEL_190;
                    }
                  }
                }
                do
                {
                  uint64_t v129 = *(void *)(v110 - 8);
                  v110 -= 8;
                  *--uint64_t v114 = v129;
                }
                while (v110 != v120);
                goto LABEL_190;
              }
LABEL_184:
              uint64_t v114 = v99;
              goto LABEL_191;
            }
          }
          else
          {
            uint64_t v90 = *(void *)(v89 - 8);
            *(void *)(v88 + 8) = v89 - 8;
            unint64_t v91 = *(uint64_t **)(v88 + 40);
            unint64_t v92 = *(void *)(v88 + 48);
            if ((unint64_t)v91 >= v92)
            {
              uint64_t v93 = *(void *)(v88 + 32);
              uint64_t v94 = ((uint64_t)v91 - v93) >> 3;
              unint64_t v95 = v94 + 1;
              if ((unint64_t)(v94 + 1) >> 61) {
                goto LABEL_318;
              }
              uint64_t v96 = v92 - v93;
              if (v96 >> 2 > v95) {
                unint64_t v95 = v96 >> 2;
              }
              if ((unint64_t)v96 >= 0x7FFFFFFFFFFFFFF8) {
                uint64_t v97 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                uint64_t v97 = v95;
              }
              if (v97)
              {
                uint64_t v98 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v88 + 56) + 16))(*(void *)(v88 + 56), 8 * v97, 8);
                uint64_t v99 = (uint64_t *)(v98 + 8 * v94);
                uint64_t v100 = v98 + 8 * v97;
                if (v98) {
                  *uint64_t v99 = v90;
                }
              }
              else
              {
                uint64_t v100 = 0;
                uint64_t v99 = (uint64_t *)(8 * v94);
              }
              uint64_t v111 = *(void *)(v88 + 32);
              uint64_t v110 = *(void *)(v88 + 40);
              uint64_t v112 = v110 - v111;
              if (v110 != v111)
              {
                unint64_t v113 = v112 - 8;
                if ((unint64_t)(v112 - 8) < 0x38)
                {
                  uint64_t v114 = v99;
                }
                else
                {
                  uint64_t v114 = v99;
                  if ((unint64_t)(v110 - (void)v99) >= 0x20)
                  {
                    uint64_t v115 = (v113 >> 3) + 1;
                    uint64_t v116 = v99 - 2;
                    uint64_t v117 = (long long *)(v110 - 16);
                    uint64_t v118 = v115 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v119 = *v117;
                      *((_OWORD *)v116 - 1) = *(v117 - 1);
                      *(_OWORD *)uint64_t v116 = v119;
                      v116 -= 4;
                      v117 -= 2;
                      v118 -= 4;
                    }
                    while (v118);
                    uint64_t v114 = &v99[-(v115 & 0x3FFFFFFFFFFFFFFCLL)];
                    v110 -= 8 * (v115 & 0x3FFFFFFFFFFFFFFCLL);
                    if (v115 == (v115 & 0x3FFFFFFFFFFFFFFCLL)) {
                      goto LABEL_190;
                    }
                  }
                }
                do
                {
                  uint64_t v128 = *(void *)(v110 - 8);
                  v110 -= 8;
                  *--uint64_t v114 = v128;
                }
                while (v110 != v111);
LABEL_190:
                uint64_t v110 = *(void *)(v88 + 32);
LABEL_191:
                unint64_t v103 = v99 + 1;
                *(void *)(v88 + 32) = v114;
                *(void *)(v88 + 40) = v99 + 1;
                uint64_t v130 = *(void *)(v88 + 48);
                *(void *)(v88 + 48) = v100;
                if (v110) {
                  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v88 + 56) + 40))(*(void *)(v88 + 56), v110, v130 - v110);
                }
LABEL_193:
                *(void *)(v88 + 40) = v103;
                uint64_t v226 = v90;
                uint64_t v131 = *(void *)(v88 + 120);
                if (!v131)
                {
LABEL_315:
                  std::__throw_bad_function_call[abi:nn180100]();
                  __break(1u);
                }
                (*(void (**)(uint64_t, uint64_t *))(*(void *)v131 + 48))(v131, &v226);
                unint64_t v134 = *(void **)(v90 + 64);
                uint64_t v135 = v221;
                uint64_t v136 = v222;
                *unint64_t v134 = v221;
                v134[1] = 0;
                uint64_t v137 = *(uint64_t **)(v90 + 160);
                if (v136) {
                  atomic_fetch_add_explicit(&v136->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v138 = (std::__shared_weak_count *)v137[1];
                uint64_t *v137 = v135;
                v137[1] = (uint64_t)v136;
                if (v138 && !atomic_fetch_add(&v138->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v138->__on_zero_shared)(v138);
                  std::__shared_weak_count::__release_weak(v138);
                }
                uint64_t v139 = *(void **)(*(void *)(v90 + 64) + 16);
                unint64_t v140 = v139[1];
                uint64_t v141 = v139[9];
                *(float *)uint64_t v141 = v82;
                *(float *)(v141 + 4) = v81;
                uint64_t v142 = *v78;
                *(_DWORD *)(v141 + 16) = *(_DWORD *)(*v78 + 92);
                *(_DWORD *)(v141 + 20) = *(_DWORD *)(v142 + 96);
                *(_DWORD *)(v141 + 24) = *(_DWORD *)(v142 + 100);
                v132.i64[0] = *(void *)(v142 + 104);
                v132.i32[2] = *(_DWORD *)(v142 + 112);
                v133.i64[0] = *(void *)(v142 + 92);
                v133.i32[2] = *(_DWORD *)(v142 + 100);
                float32x4_t v143 = vmaxnmq_f32(vsubq_f32(v132, v133), (float32x4_t)0);
                *(_DWORD *)(v141 + 40) = v143.i32[2];
                *(void *)(v141 + 32) = v143.i64[0];
                if (v139[8] > v140) {
                  unint64_t v140 = v139[8];
                }
                v139[7] = 0;
                v139[8] = v140;
                unint64_t v145 = *(void **)(v83 + 16);
                unint64_t v144 = *(void **)(v83 + 24);
                while (1)
                {
                  if (v145 == v144)
                  {
                    v83 += 40;
                    unsigned int v78 = v216;
                    if (v83 == v215) {
                      goto LABEL_137;
                    }
                    goto LABEL_143;
                  }
                  long long v147 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(a1[50] + 88));
                  v147[3] = v71;
                  v147[4] = v90;
                  v147[8] = *v145;
                  v147[6] = 0;
                  *(void *)(a1[50] + 288) = *(void *)(a1[50] + 280);
                  uint64_t v149 = v145[1];
                  uint64_t v150 = v145[2];
                  while (v149 != v150)
                  {
                    uint64_t v226 = *(void *)(v149 + 16);
                    if (!v240) {
                      goto LABEL_315;
                    }
                    if ((*(unsigned int (**)(void *, uint64_t *))(*v240 + 48))(v240, &v226)
                      && *(void *)(v149 + 8) != *(void *)v149)
                    {
                      gm::MultiRange<unsigned long>::push_back((char **)(a1[50] + 280), (_OWORD *)v149);
                    }
                    v149 += 24;
                  }
                  uint64_t v151 = ggl::Batcher::commit((long long **)(a1[50] + 280), 0, v148);
                  uint64_t v152 = *v151;
                  v147[11] = *v151;
                  v147[12] = (v151[1] - v152) >> 4;
                  unint64_t v153 = *(void **)(a3 + 80);
                  unint64_t v154 = *(void *)(a3 + 88);
                  if ((unint64_t)v153 < v154)
                  {
                    if (v153) {
                      *unint64_t v153 = v147;
                    }
                    uint64_t v146 = v153 + 1;
                    goto LABEL_203;
                  }
                  uint64_t v155 = *(void *)(a3 + 72);
                  uint64_t v156 = ((uint64_t)v153 - v155) >> 3;
                  unint64_t v157 = v156 + 1;
                  if ((unint64_t)(v156 + 1) >> 61) {
                    abort();
                  }
                  uint64_t v158 = v154 - v155;
                  if (v158 >> 2 > v157) {
                    unint64_t v157 = v158 >> 2;
                  }
                  if ((unint64_t)v158 >= 0x7FFFFFFFFFFFFFF8) {
                    uint64_t v159 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    uint64_t v159 = v157;
                  }
                  if (v159)
                  {
                    uint64_t v160 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a3 + 96) + 16))(*(void *)(a3 + 96), 8 * v159, 8);
                    unint64_t v161 = (void *)(v160 + 8 * v156);
                    uint64_t v162 = v160 + 8 * v159;
                    if (v160) {
                      *unint64_t v161 = v147;
                    }
                  }
                  else
                  {
                    uint64_t v162 = 0;
                    unint64_t v161 = (void *)(8 * v156);
                  }
                  uint64_t v164 = *(void *)(a3 + 72);
                  uint64_t v163 = *(void *)(a3 + 80);
                  uint64_t v165 = v163 - v164;
                  if (v163 == v164)
                  {
                    uint64_t v167 = v161;
                    goto LABEL_236;
                  }
                  unint64_t v166 = v165 - 8;
                  if ((unint64_t)(v165 - 8) < 0x38)
                  {
                    uint64_t v167 = v161;
                  }
                  else
                  {
                    uint64_t v167 = v161;
                    if ((unint64_t)(v163 - (void)v161) >= 0x20)
                    {
                      uint64_t v168 = (v166 >> 3) + 1;
                      uint64_t v169 = v161 - 2;
                      uint64_t v170 = (long long *)(v163 - 16);
                      uint64_t v171 = v168 & 0x3FFFFFFFFFFFFFFCLL;
                      do
                      {
                        long long v172 = *v170;
                        *(v169 - 1) = *(v170 - 1);
                        *uint64_t v169 = v172;
                        v169 -= 2;
                        v170 -= 2;
                        v171 -= 4;
                      }
                      while (v171);
                      uint64_t v167 = &v161[-(v168 & 0x3FFFFFFFFFFFFFFCLL)];
                      v163 -= 8 * (v168 & 0x3FFFFFFFFFFFFFFCLL);
                      if (v168 == (v168 & 0x3FFFFFFFFFFFFFFCLL)) {
                        goto LABEL_235;
                      }
                    }
                  }
                  do
                  {
                    uint64_t v173 = *(void *)(v163 - 8);
                    v163 -= 8;
                    *--uint64_t v167 = v173;
                  }
                  while (v163 != v164);
LABEL_235:
                  uint64_t v163 = *(void *)(a3 + 72);
LABEL_236:
                  uint64_t v146 = v161 + 1;
                  *(void *)(a3 + 72) = v167;
                  *(void *)(a3 + 80) = v161 + 1;
                  uint64_t v174 = *(void *)(a3 + 88);
                  *(void *)(a3 + 88) = v162;
                  if (v163) {
                    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a3 + 96) + 40))(*(void *)(a3 + 96), v163, v174 - v163);
                  }
LABEL_203:
                  *(void *)(a3 + 80) = v146;
                  v145 += 4;
                }
              }
              goto LABEL_184;
            }
          }
          if (v91) {
            *unint64_t v91 = v90;
          }
          unint64_t v103 = v91 + 1;
          goto LABEL_193;
        }
      }
LABEL_310:
      uint64_t v198 = __p[0];
      if (__p[0])
      {
        do
        {
          uint64_t v199 = (void *)*v198;
          operator delete(v198);
          uint64_t v198 = v199;
        }
        while (v199);
      }
      uint64_t v200 = v223[0];
      v223[0] = 0;
      if (v200) {
        operator delete(v200);
      }
    }
    else
    {
LABEL_71:
      uint64_t v33 = 0;
      if (v212) {
        goto LABEL_72;
      }
    }
  }
}

void sub_1A2579904(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30,void *a31,uint64_t a32,void *__p,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  uint64_t v51 = *(void *)(v49 - 232);
  if (v51 == v49 - 256)
  {
    (*(void (**)(uint64_t))(*(void *)(v49 - 256) + 32))(v49 - 256);
  }
  else if (v51)
  {
    (*(void (**)(uint64_t))(*(void *)v51 + 40))(v51);
  }
  uint64_t v52 = *(void *)(v49 - 200);
  if (v52 == v49 - 224)
  {
    (*(void (**)(uint64_t))(*(void *)(v49 - 224) + 32))(v49 - 224);
  }
  else if (v52)
  {
    (*(void (**)(uint64_t))(*(void *)v52 + 40))(v52);
  }
  uint64_t v53 = *(void *)(v49 - 168);
  if (v53 == v49 - 192)
  {
    (*(void (**)(uint64_t))(*(void *)(v49 - 192) + 32))(v49 - 192);
  }
  else if (v53)
  {
    (*(void (**)(uint64_t))(*(void *)v53 + 40))(v53);
  }
  if (a30 && !atomic_fetch_add(&a30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a30->__on_zero_shared)(a30);
    std::__shared_weak_count::__release_weak(a30);
  }
  float v54 = __p;
  if (__p)
  {
    do
    {
      float v55 = (void *)*v54;
      operator delete(v54);
      float v54 = v55;
    }
    while (v55);
  }
  if (a31) {
    operator delete(a31);
  }
  _Unwind_Resume(a1);
}

md::CompositeLabelPart *md::TransitAccessPointLabelFeature::newGraphicAnnotationPart(md::TransitAccessPointLabelFeature *this, const md::PartCreationContext *a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 85) == *((void *)this + 86)) {
    return 0;
  }
  _ZNSt3__115allocate_sharedB8nn180100I22FeatureStyleAttributesNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v38);
  {
    operator new();
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 696, 8);
  uint64_t v5 = md::StackLabelPart::StackLabelPart(v4, 1, 0, 0, 0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 176))(v5, 7);
  uint64_t v34 = (md::CompositeLabelPart *)v4;
  *(unsigned char *)(v4 + 630) = 1;
  int8x8_t v6 = (unsigned __int8 *)*((void *)this + 85);
  uint64_t v7 = (unsigned __int8 *)*((void *)this + 86);
  if (v6 == v7) {
    goto LABEL_43;
  }
  int v8 = 0;
  do
  {
    uint64_t v9 = *v6;
    uint64_t v10 = v38;
    uint64_t v11 = *(unsigned __int8 *)(v38 + 33);
    uint64_t v12 = *(int **)v38;
    if (*(unsigned char *)(v38 + 33))
    {
      if (v11 >= 0x20)
      {
        uint64_t v13 = 0;
        uint64_t v17 = *(int **)v38;
        while (1)
        {
          int v18 = *v17;
          v17 += 2;
          if (v18 == 45) {
            break;
          }
          if (v11 == ++v13) {
            goto LABEL_17;
          }
        }
      }
      else
      {
        uint64_t v13 = 0;
        uint64_t v14 = *(int **)v38;
        while (1)
        {
          int v15 = *v14;
          v14 += 2;
          if (v15 == 45) {
            break;
          }
          if (v11 == ++v13) {
            goto LABEL_11;
          }
        }
      }
      v12[2 * v13 + 1] = v9;
    }
    else
    {
LABEL_11:
      *(void *)&v12[2 * v11] = (v9 << 32) | 0x2D;
      unsigned __int8 v16 = *(unsigned char *)(v10 + 33) + 1;
      *(unsigned char *)(v10 + 33) = v16;
      qsort(*(void **)v10, v16, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
    }
LABEL_17:
    uint64_t v20 = *((void *)a2 + 1);
    uint64_t v19 = (md::LabelStyle *)*((void *)a2 + 2);
    uint64_t v21 = *(void *)a2;
    unint64_t v22 = (std::__shared_weak_count *)v39;
    v35[0] = v10;
    v35[1] = v39;
    uint64_t v23 = (uint64_t)v19;
    if (v39)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v39 + 8), 1uLL, memory_order_relaxed);
      uint64_t v23 = *((void *)a2 + 2);
    }
    uint64_t v24 = *(void *)(v23 + 296);
    if (!v24)
    {
      uint64_t v25 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(v23, 0);
      uint64_t v24 = *v25;
      *(void *)(v23 + 296) = *v25;
    }
    char v26 = *(unsigned char *)(v24 + 93);
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v41 = 0;
    int8x8_t v43 = 0;
    md::LabelStyle::pointIcon(&v36, v19, v21, v20, v35, 0, 0, 45, 0, v26, 0, (uint64_t)__p);
    if (v43 == v42)
    {
      (*(void (**)(void *))(v42[0] + 32))(v42);
      if ((SHIBYTE(v41) & 0x80000000) == 0) {
        goto LABEL_25;
      }
    }
    else
    {
      if (v43) {
        (*(void (**)(void))(*v43 + 40))();
      }
      if ((SHIBYTE(v41) & 0x80000000) == 0)
      {
LABEL_25:
        if (!v22) {
          goto LABEL_30;
        }
        goto LABEL_29;
      }
    }
    operator delete(__p[0]);
    if (!v22) {
      goto LABEL_30;
    }
LABEL_29:
    if (atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
LABEL_30:
      if (!v36) {
        goto LABEL_33;
      }
      goto LABEL_31;
    }
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
    if (!v36) {
      goto LABEL_33;
    }
LABEL_31:
    {
      operator new();
    }
    uint64_t v27 = (md::LabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                + 16))(mdm::Allocator::instance(void)::alloc, 768, 8);
    double v28 = md::IconLabelPart::IconLabelPart((uint64_t)v27, &v36);
    (*(void (**)(uint64_t, uint64_t, double))(*(void *)v29 + 176))(v29, 10, v28);
    md::CompositeLabelPart::addLabelPart((uint64_t)v34, v27);
    ++v8;
LABEL_33:
    unint64_t v30 = v37;
    if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
    ++v6;
  }
  while (v6 != v7);
  if (!v8)
  {
LABEL_43:
    (*(void (**)(md::CompositeLabelPart *))(*(void *)v34 + 8))(v34);
    uint64_t v31 = 0;
    uint64_t v32 = (std::__shared_weak_count *)v39;
    if (v39) {
      goto LABEL_44;
    }
    return v31;
  }
  uint64_t v31 = v34;
  uint64_t v32 = (std::__shared_weak_count *)v39;
  if (!v39) {
    return v31;
  }
LABEL_44:
  if (!atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
    std::__shared_weak_count::__release_weak(v32);
  }
  return v31;
}

void sub_1A257A0E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

md::BalloonLabelPart *md::TransitAccessPointLabelFeature::newIconPart(md::TransitAccessPointLabelFeature *this, const md::PartCreationContext *a2)
{
  uint64_t v4 = **((void **)a2 + 8);
  if (!v4 || !*(unsigned char *)(v4 + 72)) {
    return md::PointLabelFeature::newIconPart(this, a2);
  }
  uint64_t v26 = 0;
  unsigned __int8 v5 = atomic_load((unsigned __int8 *)(*(void *)a2 + 3392));
  int v6 = v5 & 1;
  *(void *)&long long __dst = 0;
  geo::codec::featureGetNativeShield(v4, 0, &__dst, &v26, 0);
  localizedLabel((unint64_t)&v23, (uint64_t *)v4, (char *)__dst, v6, 0);
  uint64_t v8 = v26;
  if (!v26) {
    goto LABEL_22;
  }
  uint64_t v4 = *((void *)a2 + 2);
  uint64_t v9 = *(void *)(v4 + 296);
  if (!v9)
  {
    uint64_t v10 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*((void *)a2 + 2), 0);
    uint64_t v9 = *v10;
    *(void *)(v4 + 296) = *v10;
  }
  uint64_t v19 = v25;
  if (SHIBYTE(v24) < 0)
  {
    std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)&__dst, (void *)v23, *((unint64_t *)&v23 + 1));
  }
  else
  {
    long long __dst = v23;
    uint64_t v18 = v24;
  }
  uint64_t v20 = v8;
  int v21 = *(_DWORD *)(v9 + 72);
  char v22 = 2;
  md::LabelStyle::shieldIcon(&v15, *((void *)a2 + 2), *(void *)a2, *((void *)a2 + 1), (void **)&__dst, 1, -1);
  uint64_t v11 = v15;
  if (!v15)
  {
    uint64_t v12 = v16;
    if (!v16) {
      goto LABEL_17;
    }
    goto LABEL_15;
  }
  {
    operator new();
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 768, 8);
  v7.n128_f64[0] = md::IconLabelPart::IconLabelPart(v4, &v15);
  uint64_t v12 = v16;
  if (v16)
  {
LABEL_15:
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *, __n128))v12->__on_zero_shared)(v12, v7);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
LABEL_17:
  if ((SHIBYTE(v18) & 0x80000000) == 0)
  {
    if (v11) {
      goto LABEL_19;
    }
LABEL_22:
    int v13 = 1;
    if ((SHIBYTE(v24) & 0x80000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  (*(void (**)(uint64_t, void, uint64_t, __n128))(*(void *)v19 + 40))(v19, __dst, v18 & 0x7FFFFFFFFFFFFFFFLL, v7);
  if (!v11) {
    goto LABEL_22;
  }
LABEL_19:
  int v13 = 0;
  if ((SHIBYTE(v24) & 0x80000000) == 0) {
    goto LABEL_24;
  }
LABEL_23:
  (*(void (**)(uint64_t, void, uint64_t, __n128))(*(void *)v25 + 40))(v25, v23, v24 & 0x7FFFFFFFFFFFFFFFLL, v7);
LABEL_24:
  if (v13) {
    return md::PointLabelFeature::newIconPart(this, a2);
  }
  return (md::BalloonLabelPart *)v4;
}

void sub_1A257A3F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (SHIBYTE(a13) < 0)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a14 + 40))(a14, a11, a13 & 0x7FFFFFFFFFFFFFFFLL);
    if ((SHIBYTE(a20) & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(a1);
  }
  else if ((SHIBYTE(a20) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a21 + 40))(a21, a18, a20 & 0x7FFFFFFFFFFFFFFFLL);
  _Unwind_Resume(a1);
}

void md::TransitAccessPointLabelFeature::populateStyleQueries(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v57 = 0;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 488))(a1)
    && (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 480))(a1, 0))
  {
    operator new();
  }
  uint64_t v53 = 0;
  float v54 = 0;
  unint64_t v55 = 0;
  {
    operator new();
  }
  uint64_t v56 = mdm::Allocator::instance(void)::alloc;
  (*(void (**)(uint64_t, char **))(*(void *)a1 + 544))(a1, &v53);
  if (*(unsigned char *)(a1 + 712))
  {
    int v6 = v54;
    if ((unint64_t)v54 < v55)
    {
      if (v54) {
        *(void *)float v54 = 0x200010007;
      }
      __n128 v7 = v6 + 8;
LABEL_33:
      float v54 = v7;
      goto LABEL_34;
    }
    uint64_t v8 = (v54 - v53) >> 3;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61) {
      abort();
    }
    uint64_t v10 = v55 - (void)v53;
    if ((uint64_t)(v55 - (void)v53) >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v11 = v9;
    }
    if (v11)
    {
      uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v56 + 16))(v56, 8 * v11, 4);
      int v13 = (char *)(v12 + 8 * v8);
      uint64_t v14 = v12 + 8 * v11;
      if (v12) {
        *(void *)int v13 = 0x200010007;
      }
    }
    else
    {
      uint64_t v14 = 0;
      int v13 = (char *)(8 * v8);
    }
    __n128 v7 = v13 + 8;
    unsigned __int8 v16 = v53;
    uint64_t v15 = v54;
    if (v54 == v53)
    {
LABEL_31:
      uint64_t v53 = v13;
      float v54 = v7;
      unint64_t v25 = v55;
      unint64_t v55 = v14;
      if (v15) {
        (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v56 + 40))(v56, v15, v25 - (void)v15);
      }
      goto LABEL_33;
    }
    unint64_t v17 = v54 - v53 - 8;
    if (v17 < 0x38)
    {
      uint64_t v19 = v54;
    }
    else if ((unint64_t)(v54 - v13) < 0x20)
    {
      uint64_t v19 = v54;
    }
    else
    {
      uint64_t v18 = (v17 >> 3) + 1;
      uint64_t v19 = &v54[-8 * (v18 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v20 = v13 - 16;
      int v21 = v54 - 16;
      uint64_t v22 = v18 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v23 = *(_OWORD *)v21;
        *((_OWORD *)v20 - 1) = *((_OWORD *)v21 - 1);
        *(_OWORD *)uint64_t v20 = v23;
        v20 -= 32;
        v21 -= 32;
        v22 -= 4;
      }
      while (v22);
      v13 -= 8 * (v18 & 0x3FFFFFFFFFFFFFFCLL);
      if (v18 == (v18 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_30;
      }
    }
    do
    {
      uint64_t v24 = *((void *)v19 - 1);
      v19 -= 8;
      *((void *)v13 - 1) = v24;
      v13 -= 8;
    }
    while (v19 != v16);
LABEL_30:
    uint64_t v15 = v53;
    goto LABEL_31;
  }
LABEL_34:
  uint64_t v26 = *(const FeatureStyleAttributes **)(a1 + 656);
  uint64_t v27 = (std::__shared_weak_count *)operator new(0x40uLL);
  v27->__shared_owners_ = 0;
  v27->__shared_weak_owners_ = 0;
  v27->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F680;
  double v28 = (void **)&v27[1].__vftable;
  FeatureStyleAttributes::FeatureStyleAttributes((FeatureStyleAttributes *)&v27[1], v26);
  uint64_t v51 = v27 + 1;
  uint64_t v52 = v27;
  uint64_t v29 = v53;
  if (((v54 - v53) & 0x7FFFFFFF8) != 0)
  {
    uint64_t v30 = 0;
    char v31 = 0;
    uint64_t v32 = ((unint64_t)(v54 - v53) >> 3);
    unsigned __int8 v33 = BYTE1(v27[2].__shared_owners_);
    while (1)
    {
      size_t v34 = v33;
      unint64_t v35 = *v28;
      if (v33) {
        break;
      }
LABEL_36:
      v35[v34] = *(void *)&v29[8 * v30];
      unsigned __int8 v33 = BYTE1(v27[2].__shared_owners_) + 1;
      BYTE1(v27[2].__shared_owners_) = v33;
      ++v30;
      char v31 = 1;
      if (v30 == v32)
      {
        unint64_t v35 = *v28;
        size_t v34 = v33;
LABEL_53:
        qsort(v35, v34, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
        goto LABEL_54;
      }
    }
    if (v33 > 0x1Fu)
    {
      do
      {
        uint64_t v39 = 0;
        float v40 = (int *)v35;
        while (1)
        {
          int v41 = *v40;
          v40 += 2;
          if (v41 == *(_DWORD *)&v29[8 * v30]) {
            break;
          }
          if (v34 == ++v39) {
            goto LABEL_47;
          }
        }
        HIDWORD(v35[v39]) = *(_DWORD *)&v29[8 * v30 + 4];
LABEL_47:
        ++v30;
      }
      while (v30 != v32);
    }
    else
    {
      do
      {
        uint64_t v36 = 0;
        uint64_t v37 = (int *)v35;
        while (1)
        {
          int v38 = *v37;
          v37 += 2;
          if (v38 == *(_DWORD *)&v29[8 * v30]) {
            break;
          }
          if (v34 == ++v36) {
            goto LABEL_36;
          }
        }
        HIDWORD(v35[v36]) = *(_DWORD *)&v29[8 * v30++ + 4];
      }
      while (v30 != v32);
    }
    if (v31) {
      goto LABEL_53;
    }
  }
LABEL_54:
  uint64_t v48 = (char *)&v27[1];
  uint64_t v49 = v27;
  atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  md::createFeatureAttributeSet((gss::Allocator *)v58, (uint64_t *)&v48);
  md::LabelStyleCache::styleQueryForFeatureAttributes((uint64_t)&v50, a3, v58, 0);
  if (v58[0])
  {
    v58[1] = v58[0];
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v59 + 40))(v59, v58[0], v58[2] - v58[0]);
  }
  float32x4_t v42 = *(_OWORD **)(a2 + 8);
  if ((unint64_t)v42 >= *(void *)(a2 + 16))
  {
    int8x8_t v43 = std::vector<std::shared_ptr<md::RouteAnnotationLabelFeature>,geo::StdAllocator<std::shared_ptr<md::RouteAnnotationLabelFeature>,mdm::Allocator>>::__emplace_back_slow_path<std::shared_ptr<md::RouteAnnotationLabelFeature>>(a2, (uint64_t)&v50);
  }
  else
  {
    if (v42)
    {
      *float32x4_t v42 = v50;
      long long v50 = 0uLL;
    }
    int8x8_t v43 = v42 + 1;
  }
  *(void *)(a2 + 8) = v43;
  uint64_t v44 = (std::__shared_weak_count *)*((void *)&v50 + 1);
  if (*((void *)&v50 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v50 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
    std::__shared_weak_count::__release_weak(v44);
  }
  uint64_t v45 = v49;
  if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
    std::__shared_weak_count::__release_weak(v45);
  }
  float v46 = v52;
  if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
    std::__shared_weak_count::__release_weak(v46);
  }
  if (v53)
  {
    float v54 = v53;
    (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v56 + 40))(v56, v53, v55 - (void)v53);
  }
  uint64_t v47 = v57;
  if (v57)
  {
    if (*(char *)(v57 + 23) < 0) {
      (*(void (**)(void, void, uint64_t))(**(void **)(v57 + 24) + 40))(*(void *)(v57 + 24), *(void *)v57, *(void *)(v57 + 16) & 0x7FFFFFFFFFFFFFFFLL);
    }
    MEMORY[0x1A6239270](v47, 0x1032C402ED93987);
  }
}

void sub_1A257AB80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  if (v10)
  {
    uint64_t v11 = v10;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v13 + 40))(v13, v10, v12 - v10);
  }
  std::unique_ptr<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>::~unique_ptr[abi:nn180100]((uint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t md::TransitAccessPointLabelFeature::labelFeatureType(md::TransitAccessPointLabelFeature *this)
{
  return 11;
}

uint64_t md::TransitAccessPointLabelFeature::updateDynamicStyling(md::TransitAccessPointLabelFeature *this, LabelManager *a2, md::Label *a3)
{
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(*((void *)a2 + 21) + 64) + 8))(*(void *)(*((void *)a2 + 21) + 64));
  if (!v5) {
    return 0;
  }
  int v6 = *(void **)(v5 + 328);
  if (!v6) {
    goto LABEL_10;
  }
  int v6 = (void *)v6[20];
  if (!v6) {
    goto LABEL_10;
  }
  unint64_t v7 = *((void *)this + 84);
  while (1)
  {
    unint64_t v8 = v6[4];
    if (v8 <= v7) {
      break;
    }
LABEL_5:
    int v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_10;
    }
  }
  if (v8 < v7)
  {
    ++v6;
    goto LABEL_5;
  }
  LODWORD(v6) = 1;
LABEL_10:
  if (*((unsigned __int8 *)this + 712) != v6)
  {
    *((unsigned char *)this + 712) = (_BYTE)v6;
    (*(void (**)(md::TransitAccessPointLabelFeature *, LabelManager *))(*(void *)this + 536))(this, a2);
  }
  return 0;
}

void md::TransitAccessPointLabelFeature::~TransitAccessPointLabelFeature(md::TransitAccessPointLabelFeature *this)
{
  *(void *)this = &unk_1EF54C678;
  uint64_t v2 = *((void *)this + 85);
  if (v2)
  {
    *((void *)this + 86) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 88) + 40))(*((void *)this + 88), v2, *((void *)this + 87) - v2);
  }
  md::PointLabelFeature::~PointLabelFeature(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF54C678;
  uint64_t v2 = *((void *)this + 85);
  if (v2)
  {
    *((void *)this + 86) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 88) + 40))(*((void *)this + 88), v2, *((void *)this + 87) - v2);
  }
  md::PointLabelFeature::~PointLabelFeature(this);
}

uint64_t std::__shared_ptr_pointer<altitude::TrafficSuperTile *,std::shared_ptr<altitude::TrafficSuperTile>::__shared_ptr_default_delete<altitude::TrafficSuperTile,altitude::TrafficSuperTile>,std::allocator<altitude::TrafficSuperTile>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 168);
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    uint64_t v3 = *(void *)(v1 + 88);
    *(void *)(v1 + 88) = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = *(void *)(v1 + 64);
    if (!v4) {
      goto LABEL_20;
    }
    uint64_t v5 = *(void *)(v1 + 72);
    int v6 = *(void **)(v1 + 64);
    if (v5 == v4) {
      goto LABEL_19;
    }
    while (1)
    {
      unint64_t v7 = *(std::__shared_weak_count **)(v5 - 8);
      if (v7)
      {
        if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
          break;
        }
      }
      unint64_t v8 = *(void **)(v5 - 40);
      if (v8) {
        goto LABEL_14;
      }
LABEL_10:
      v5 -= 72;
      if (v5 == v4)
      {
        int v6 = *(void **)(v1 + 64);
LABEL_19:
        *(void *)(v1 + 72) = v4;
        operator delete(v6);
LABEL_20:
        std::mutex::~mutex((std::mutex *)v1);
        JUMPOUT(0x1A6239270);
      }
    }
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    unint64_t v8 = *(void **)(v5 - 40);
    if (!v8) {
      goto LABEL_10;
    }
LABEL_14:
    *(void *)(v5 - 32) = v8;
    operator delete(v8);
    goto LABEL_10;
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::TrafficSuperTile *,std::shared_ptr<altitude::TrafficSuperTile>::__shared_ptr_default_delete<altitude::TrafficSuperTile,altitude::TrafficSuperTile>,std::allocator<altitude::TrafficSuperTile>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::PolygonCommonStroke::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::PolygonCommonStroke::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::PolygonCommonStroke::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void non-virtual thunk to'ggl::PolygonCommonStroke::MeshMesh::~MeshMesh(ggl::PolygonCommonStroke::MeshMesh *this)
{
  ggl::Mesh::~Mesh((ggl::PolygonCommonStroke::MeshMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::PolygonCommonStroke::MeshMesh *)((char *)this - 16));
}

void ggl::PolygonCommonStroke::MeshMesh::~MeshMesh(ggl::PolygonCommonStroke::MeshMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::PolygonCommonStroke::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::PolygonCommonStroke::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::MeshVendor<ggl::PolygonShadowedStroke::ShadowPathMesh>::_allocateNewMesh()
{
}

void ggl::MeshVendor<ggl::Glow::MeshMesh>::_allocateNewMesh()
{
}

void md::CoastlineGroup::~CoastlineGroup(md::CoastlineGroup *this)
{
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2)
  {
    uint64_t v3 = *(void **)v2;
    if (*(void *)v2)
    {
      uint64_t v4 = *(void **)(v2 + 8);
      uint64_t v5 = *(void **)v2;
      if (v4 != v3)
      {
        do
        {
          uint64_t v7 = *--v4;
          uint64_t v6 = v7;
          *uint64_t v4 = 0;
          if (v7) {
            (*(void (**)(uint64_t, void *))(*(void *)v6 + 8))(v6, v5);
          }
        }
        while (v4 != v3);
        uint64_t v5 = *(void **)v2;
      }
      *(void *)(v2 + 8) = v3;
      (*(void (**)(void, void *, void))(**(void **)(v2 + 24) + 40))(*(void *)(v2 + 24), v5, *(void *)(v2 + 16) - (void)v5);
    }
    MEMORY[0x1A6239270](v2, 0x20C40DC1BFBCFLL);
  }
  uint64_t v8 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v8)
  {
    uint64_t v9 = *(void **)v8;
    if (*(void *)v8)
    {
      uint64_t v10 = *(void **)(v8 + 8);
      uint64_t v11 = *(void **)v8;
      if (v10 != v9)
      {
        do
        {
          uint64_t v13 = *--v10;
          uint64_t v12 = v13;
          *uint64_t v10 = 0;
          if (v13) {
            (*(void (**)(uint64_t, void *))(*(void *)v12 + 8))(v12, v11);
          }
        }
        while (v10 != v9);
        uint64_t v11 = *(void **)v8;
      }
      *(void *)(v8 + 8) = v9;
      (*(void (**)(void, void *, void))(**(void **)(v8 + 24) + 40))(*(void *)(v8 + 24), v11, *(void *)(v8 + 16) - (void)v11);
    }
    MEMORY[0x1A6239270](v8, 0x20C40DC1BFBCFLL);
  }
  uint64_t v14 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v14)
  {
    if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void md::CoastlineGroup::addCoastlineFeature(uint64_t a1, uint64_t a2)
{
  v404[1] = *MEMORY[0x1E4F143B8];
  uint64_t v384 = *(unsigned int *)(a2 + 100);
  if (!v384) {
    return;
  }
  uint64_t v2 = (void *)a2;
  uint64_t v3 = a1;
  unint64_t v4 = 0;
  int8x8_t v364 = (void *)a2;
  uint64_t v363 = a1;
  while (2)
  {
    v404[0] = 0;
    long long v392 = (float *)geo::codec::multiSectionFeaturePoints(v2, v4, v404);
    uint64_t v5 = v404[0] - 2;
    if (v404[0] < 2uLL) {
      goto LABEL_5;
    }
    unint64_t v386 = v4;
    uint64_t v382 = v404[0];
    float v6 = *v392;
    float v7 = v392[1];
    float v8 = v392[2];
    float v9 = v392[3];
    uint64_t v391 = v404[0] - 1;
    uint64_t v10 = *(void *)(*(void *)(*(void *)(v3 + 16) + 8) - 8);
    uint64_t v11 = **(void **)(v10 + 64);
    unint64_t v12 = *(void *)(v11 + 8);
    unint64_t v13 = (*(void *)(v11 + 48) - *(void *)(v11 + 40)) / v12;
    unint64_t v14 = v13 + 4 * (v404[0] - 1);
    if (v14 >= 0x10000) {
      ggl::MeshVendor<ggl::PolygonShadowedStroke::ShadowPathMesh>::_allocateNewMesh();
    }
    unint64_t v15 = v12 * v14;
    uint64_t v16 = *(void *)(v11 + 72);
    unint64_t v17 = *(void *)(v11 + 80) - v16;
    if (v15 != v17)
    {
      if (v15 <= v17)
      {
        if (v15 < v17) {
          *(void *)(v11 + 80) = v16 + v15;
        }
      }
      else
      {
        std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v11 + 72, v15 - v17);
      }
      uint64_t v18 = *(std::__shared_weak_count **)(v11 + 32);
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0;
      if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
      *(void *)(v11 + 120) = 0;
      *(_DWORD *)(v11 + 112) = 0;
      uint64_t v19 = *(void *)(v11 + 80) - *(void *)(v11 + 72);
      *(void *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = v19;
      *(void *)(v11 + 56) = 0;
      *(void *)(v11 + 64) = v19;
      uint64_t v11 = **(void **)(v10 + 64);
    }
    uint64_t v20 = 0;
    long long v399 = 0uLL;
    uint64_t v21 = *(void *)(v11 + 8);
    uint64_t v22 = v21 * v13;
    unint64_t v23 = v21 * v14;
    if (v23 != v22) {
      uint64_t v20 = *(void *)(v11 + 72) + v22;
    }
    *(void *)&long long v24 = 0;
    *((void *)&v24 + 1) = v11;
    long long v399 = v24;
    unint64_t v400 = v22;
    unint64_t v401 = v23;
    uint64_t v403 = v20;
    __int16 v402 = 1;
    uint64_t v25 = *(void *)(v10 + 96);
    unint64_t v26 = *(void *)(v25 + 8);
    unint64_t v27 = (*(void *)(v25 + 48) - *(void *)(v25 + 40)) / v26;
    uint64_t v393 = 6 * v391;
    unint64_t v28 = v27 + 6 * v391;
    unint64_t v29 = v26 * v28;
    uint64_t v30 = *(void *)(v25 + 72);
    unint64_t v31 = *(void *)(v25 + 80) - v30;
    if (v26 * v28 != v31)
    {
      if (v29 <= v31)
      {
        if (v29 < v31) {
          *(void *)(v25 + 80) = v30 + v29;
        }
      }
      else
      {
        std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v25 + 72, v29 - v31);
      }
      uint64_t v32 = *(std::__shared_weak_count **)(v25 + 32);
      *(void *)(v25 + 24) = 0;
      *(void *)(v25 + 32) = 0;
      if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
      *(void *)(v25 + 120) = 0;
      *(_DWORD *)(v25 + 112) = 0;
      uint64_t v30 = *(void *)(v25 + 72);
      uint64_t v33 = *(void *)(v25 + 80) - v30;
      *(void *)(v25 + 40) = 0;
      *(void *)(v25 + 48) = v33;
      *(void *)(v25 + 56) = 0;
      *(void *)(v25 + 64) = v33;
      unint64_t v26 = *(void *)(v25 + 8);
      unint64_t v29 = v26 * v28;
    }
    float v34 = 1.0 / sqrtf((float)((float)(v8 - v6) * (float)(v8 - v6)) + (float)((float)(v9 - v7) * (float)(v9 - v7)));
    float v35 = v34 * (float)(v9 - v7);
    float v36 = -(float)((float)(v8 - v6) * v34);
    long long v394 = 0uLL;
    *(void *)&long long v37 = 0;
    *((void *)&v37 + 1) = v25;
    uint64_t v38 = v26 * v27;
    uint64_t v39 = v30 + v26 * v27;
    if (v29 == v26 * v27) {
      uint64_t v40 = 0;
    }
    else {
      uint64_t v40 = v39;
    }
    long long v394 = v37;
    unint64_t v395 = v38;
    unint64_t v396 = v29;
    uint64_t v398 = v40;
    __int16 v397 = 1;
    float v41 = v35;
    float v42 = v36;
    uint64_t v43 = v386;
    if (v403)
    {
      float v41 = v35;
      float v42 = v36;
      if (v40)
      {
        uint64_t v44 = v392 + 2;
        uint64_t v45 = (_WORD *)(v403 + 16);
        float v46 = (_WORD *)(v40 + 6);
        uint64_t v47 = v391;
        do
        {
          float v48 = *(v44 - 2);
          float v49 = *(v44 - 1);
          float v50 = *v44;
          float v51 = v44[1];
          v44 += 2;
          float v52 = 1.0
              / sqrtf((float)((float)(v50 - v48) * (float)(v50 - v48)) + (float)((float)(v51 - v49) * (float)(v51 - v49)));
          float v53 = v52 * (float)(v50 - v48);
          float v41 = v52 * (float)(v51 - v49);
          int v54 = (int)(float)(v48 * 65535.0);
          int v55 = (int)(float)(v49 * 65535.0);
          *(v45 - 8) = v54;
          *(v45 - 7) = v55;
          *(v45 - 4) = v54;
          int v56 = (int)(float)(v50 * 65535.0);
          int v57 = (int)(float)(v51 * 65535.0);
          *(v45 - 3) = v55;
          *uint64_t v45 = v56;
          v45[4] = v56;
          v45[1] = v57;
          v45[5] = v57;
          LOWORD(v56) = (int)(v41 * 127.5 + 127.5) | ((unsigned __int16)(int)(v53 * 127.5 + 127.5) << 8);
          *(v45 - 6) = v56;
          *(v45 - 5) = 0;
          *(v45 - 1) = -1;
          *(v45 - 2) = v56;
          v45[2] = v56;
          v45[3] = 0;
          v45[6] = v56;
          v45[7] = -1;
          *(v46 - 3) = v13;
          *(v46 - 2) = v13 + 1;
          *float v46 = v13 + 1;
          *(v46 - 1) = v13 + 2;
          v46[1] = v13 + 3;
          v46[2] = v13 + 2;
          v13 += 4;
          v45 += 16;
          v46 += 6;
          --v47;
        }
        while (v47);
        float v42 = -v53;
      }
    }
    uint64_t v58 = +[VKPlatform sharedPlatform];
    unint64_t v59 = [(id)v58 supportsCoastlineGlows];

    if (!v59)
    {
LABEL_231:
      if (!v398) {
        goto LABEL_248;
      }
      goto LABEL_232;
    }
    size_t v61 = 8 * v391;
    if ((unint64_t)(8 * v391) > 0x2000)
    {
      float v62 = (float *)malloc_type_malloc(8 * v391, 0x100004000313F17uLL);
    }
    else
    {
      MEMORY[0x1F4188790](v60);
      float v62 = (float *)((char *)&v357 - ((v61 + 15) & 0xFFFFFFFFFFFFFFF0));
      bzero(v62, v61);
    }
    unint64_t v378 = v61;
    bzero(v62, v61);
    uint64_t v63 = v392;
    float v64 = v63[3] - v63[1];
    float v65 = v63[2] - *v63;
    float v66 = 1.0 / sqrtf((float)(v65 * v65) + (float)(v64 * v64));
    float v67 = acosf(fminf((float)((float)(v66 * v64) * (float)(v66 * v64))+ (float)((float)-(float)(v65 * v66) * (float)-(float)(v65 * v66)), 1.0));
    LODWORD(v61) = vcvtps_u32_f32(v67 * 2.8648);
    if (v61) {
      v62[1] = v67 / (float)v61;
    }
    *(float *)&uint64_t v390 = v35;
    float v381 = v42;
    *(_DWORD *)float v62 = v61;
    if (v391 != 1)
    {
      uint64_t v58 = (uint64_t)(v62 + 3);
      unint64_t v59 = (unint64_t)(v392 + 3);
      do
      {
        float v75 = *(float *)v59 - *(float *)(v59 - 8);
        float v76 = *(float *)(v59 - 4);
        float v77 = v76 - *(float *)(v59 - 12);
        float v78 = *(float *)(v59 + 4) - v76;
        float v79 = *(float *)(v59 + 8) - *(float *)v59;
        float v80 = 1.0 / sqrtf((float)(v77 * v77) + (float)(v75 * v75));
        float v81 = v80 * v75;
        float v82 = -(float)(v77 * v80);
        float v83 = 1.0 / sqrtf((float)(v78 * v78) + (float)(v79 * v79));
        float v84 = v83 * v79;
        float v85 = -(float)(v78 * v83);
        float v86 = acosf(fminf(fmaxf((float)((float)(v83 * v79) * v81) + (float)(v85 * v82), -1.0), 1.0));
        unsigned int v87 = vcvtps_u32_f32(v86 * 2.8648);
        if (v87)
        {
          if ((float)-(float)((float)(v84 * v82) - (float)(v85 * v81)) < 0.0) {
            float v86 = -v86;
          }
          *(float *)uint64_t v58 = v86 / (float)v87;
        }
        *(_DWORD *)(v58 - 4) = v87;
        v61 += v87;
        v58 += 8;
        v59 += 8;
        --v5;
      }
      while (v5);
    }
    uint64_t v68 = &v392[2 * v391];
    float v69 = *v392;
    float v70 = vabds_f32(*v392, *v68);
    float v71 = 0.0;
    if ((v70 <= (float)(fabsf(*v68 + *v392) * 0.000011921) || v70 <= 1.1755e-38)
      && ((float v72 = v392[1], v73 = v68[1], v74 = vabds_f32(v72, v73), v74 <= (float)(fabsf(v73 + v72) * 0.000011921))
       || v74 <= 1.1755e-38))
    {
      uint64_t v88 = &v392[2 * v382];
      float v89 = v69 - *(v88 - 4);
      float v90 = v392[2] - v69;
      float v91 = v72 - *(v88 - 3);
      float v92 = v392[3] - v72;
      float v93 = 1.0 / sqrtf((float)(v89 * v89) + (float)(v91 * v91));
      float v94 = v93 * v91;
      float v95 = -(float)(v89 * v93);
      float v96 = 1.0 / sqrtf((float)(v90 * v90) + (float)(v92 * v92));
      float v97 = v96 * v92;
      float v98 = -(float)(v90 * v96);
      float v99 = acosf(fminf(fmaxf((float)((float)(v96 * v92) * (float)(v93 * v91)) + (float)(v98 * v95), -1.0), 1.0));
      LODWORD(v59) = vcvtps_u32_f32(v99 * 2.8648);
      if (v59)
      {
        if ((float)-(float)((float)(v97 * v95) - (float)(v98 * v94)) < 0.0) {
          float v99 = -v99;
        }
        float v71 = v99 / (float)v59;
      }
      else
      {
        float v71 = 0.0;
      }
      v61 += v59;
      int v380 = 1;
    }
    else
    {
      int v380 = 0;
      unint64_t v59 = 0;
    }
    GhostPoint = (float *)geo::codec::multiSectionFeatureGetGhostPoint((uint64_t)v2, v43, 0);
    float v365 = v71;
    char v379 = GhostPoint;
    if (GhostPoint)
    {
      float v101 = GhostPoint[1];
      float v102 = *v392;
      float v103 = v392[1];
      float v361 = *GhostPoint;
      float v104 = v102 - v361;
      float v105 = v392[3];
      float v106 = v392[2] - v102;
      float v360 = v101;
      float v107 = v103 - v101;
      float v108 = v105 - v103;
      float v109 = 1.0 / sqrtf((float)(v104 * v104) + (float)(v107 * v107));
      float v110 = v109 * v107;
      float v111 = -(float)(v104 * v109);
      float v112 = 1.0 / sqrtf((float)(v106 * v106) + (float)(v108 * v108));
      float v113 = v112 * v108;
      float v114 = -(float)(v106 * v112);
      float v115 = acosf(fminf(fmaxf((float)((float)(v112 * v108) * (float)(v109 * v107)) + (float)(v114 * v111), -1.0), 1.0));
      LODWORD(v58) = vcvtps_u32_f32(v115 * 2.8648);
      if (v58)
      {
        if ((float)-(float)((float)(v113 * v111) - (float)(v114 * v110)) < 0.0) {
          float v115 = -v115;
        }
        float v116 = v115 / (float)v58;
      }
      else
      {
        float v116 = 0.0;
      }
      float v370 = v116;
      float v117 = v381;
      float v118 = *(float *)&v390;
      v61 += v58;
    }
    else
    {
      uint64_t v58 = 0;
      float v370 = 0.0;
      float v117 = v381;
      float v118 = *(float *)&v390;
    }
    long long v119 = (float *)geo::codec::multiSectionFeatureGetGhostPoint((uint64_t)v2, v43, v391);
    unint64_t v371 = v59;
    long long v372 = v68;
    unint64_t v366 = v58;
    uint64_t v368 = v119;
    if (v119)
    {
      uint64_t v120 = &v392[2 * v382];
      float v121 = v68[1];
      float v122 = *v68 - *(v120 - 4);
      float v123 = v121 - *(v120 - 3);
      float v124 = *v119 - *v68;
      float v125 = v119[1] - v121;
      float v126 = 1.0 / sqrtf((float)(v122 * v122) + (float)(v123 * v123));
      float v127 = v126 * v123;
      float v128 = -(float)(v122 * v126);
      float v129 = 1.0 / sqrtf((float)(v124 * v124) + (float)(v125 * v125));
      float v130 = v129 * v125;
      float v131 = -(float)(v124 * v129);
      float v132 = acosf(fminf(fmaxf((float)(v127 * (float)(v129 * v125)) + (float)(v128 * v131), -1.0), 1.0));
      LODWORD(v133) = vcvtps_u32_f32(v132 * 2.8648);
      if (v133)
      {
        if ((float)-(float)((float)(v128 * v130) - (float)(v127 * v131)) < 0.0) {
          float v132 = -v132;
        }
        float v134 = v132 / (float)v133;
      }
      else
      {
        float v134 = 0.0;
      }
      float v117 = v381;
      float v118 = *(float *)&v390;
      unint64_t v369 = v133;
      v61 += v133;
      uint64_t v135 = 2;
    }
    else
    {
      uint64_t v135 = 0;
      unint64_t v369 = 0;
      float v134 = 0.0;
    }
    uint64_t v136 = 2;
    if (!v380) {
      uint64_t v136 = 0;
    }
    uint64_t v137 = v136 + 2 * v391 + 2 * (v379 != 0) + v135 + v61 + 2;
    uint64_t v138 = *(void *)(*(void *)(*(void *)(v3 + 24) + 8) - 8);
    uint64_t v139 = **(void **)(v138 + 64);
    unint64_t v140 = *(void *)(v139 + 8);
    unint64_t v389 = (*(void *)(v139 + 48) - *(void *)(v139 + 40)) / v140;
    unint64_t v141 = v389 + v137;
    if (v389 + v137 >= 0x10000) {
      ggl::MeshVendor<ggl::Glow::MeshMesh>::_allocateNewMesh();
    }
    unint64_t v142 = v140 * v141;
    uint64_t v143 = *(void *)(v139 + 72);
    unint64_t v144 = *(void *)(v139 + 80) - v143;
    if (v140 * v141 != v144)
    {
      if (v140 * v141 <= v144)
      {
        if (v142 < v144) {
          *(void *)(v139 + 80) = v143 + v142;
        }
      }
      else
      {
        std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v139 + 72, v140 * v141 - v144);
      }
      unint64_t v145 = *(std::__shared_weak_count **)(v139 + 32);
      *(void *)(v139 + 24) = 0;
      *(void *)(v139 + 32) = 0;
      if (v145 && !atomic_fetch_add(&v145->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v145->__on_zero_shared)(v145);
        std::__shared_weak_count::__release_weak(v145);
      }
      *(void *)(v139 + 120) = 0;
      *(_DWORD *)(v139 + 112) = 0;
      uint64_t v146 = *(void *)(v139 + 80) - *(void *)(v139 + 72);
      *(void *)(v139 + 40) = 0;
      *(void *)(v139 + 48) = v146;
      *(void *)(v139 + 56) = 0;
      *(void *)(v139 + 64) = v146;
      uint64_t v139 = **(void **)(v138 + 64);
      unint64_t v140 = *(void *)(v139 + 8);
      unint64_t v142 = v140 * v141;
    }
    uint64_t v376 = v140 * v389;
    if (v142 == v140 * v389) {
      uint64_t v390 = 0;
    }
    else {
      uint64_t v390 = *(void *)(v139 + 72) + v140 * v389;
    }
    uint64_t v147 = *(void *)(v138 + 96);
    unint64_t v148 = *(void *)(v147 + 8);
    unint64_t v149 = (*(void *)(v147 + 48) - *(void *)(v147 + 40)) / v148;
    size_t v150 = 3 * v61 + v393 + v149;
    size_t v151 = v148 * v150;
    uint64_t v152 = *(void *)(v147 + 72);
    size_t v153 = *(void *)(v147 + 80) - v152;
    unint64_t v377 = v142;
    uint64_t v375 = (void *)v147;
    if (v148 * v150 != v153)
    {
      if (v148 * v150 <= v153)
      {
        if (v151 < v153) {
          *(void *)(v147 + 80) = v152 + v151;
        }
      }
      else
      {
        std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v147 + 72, v148 * v150 - v153);
      }
      unint64_t v154 = *(std::__shared_weak_count **)(v147 + 32);
      *(void *)(v147 + 24) = 0;
      *(void *)(v147 + 32) = 0;
      if (v154 && !atomic_fetch_add(&v154->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v154->__on_zero_shared)(v154);
        std::__shared_weak_count::__release_weak(v154);
      }
      *(void *)(v147 + 120) = 0;
      *(_DWORD *)(v147 + 112) = 0;
      uint64_t v152 = *(void *)(v147 + 72);
      uint64_t v155 = *(void *)(v147 + 80) - v152;
      *(void *)(v147 + 40) = 0;
      *(void *)(v147 + 48) = v155;
      *(void *)(v147 + 56) = 0;
      *(void *)(v147 + 64) = v155;
      unint64_t v148 = *(void *)(v147 + 8);
      size_t v151 = v148 * v150;
    }
    uint64_t v156 = v148 * v149;
    uint64_t v157 = v152 + v156;
    size_t v374 = v151;
    unint64_t v373 = v156;
    if (v151 == v156) {
      uint64_t v158 = 0;
    }
    else {
      uint64_t v158 = v157;
    }
    if (!v390 || !v158) {
      goto LABEL_207;
    }
    float v362 = v134;
    uint64_t v367 = v139;
    uint64_t v159 = 0;
    uint64_t v160 = 0;
    uint64_t v161 = 0;
    int v359 = (int)(float)(v41 * 127.0);
    int v358 = (int)(float)(v117 * 127.0);
    int v162 = (int)(float)(v36 * 127.0);
    int v163 = (int)(float)(v118 * 127.0);
    uint64_t v383 = v158 + 2;
    uint64_t v385 = v158 + 4;
    uint64_t v387 = v390 + 23;
    uint64_t v388 = v62;
    do
    {
      float v164 = v36;
      uint64_t v165 = &v392[2 * v159];
      float v167 = *v165;
      float v166 = v165[1];
      uint64_t v168 = v159 + 1;
      uint64_t v169 = &v392[2 * v159 + 2];
      float v170 = *v169 - v167;
      float v171 = v169[1] - v166;
      float v172 = sqrtf((float)(v170 * v170) + (float)(v171 * v171));
      if (v172 == 0.0)
      {
        float v36 = 1.0;
        float v173 = 0.0;
      }
      else
      {
        float v173 = fminf(fmaxf(v171 / v172, -1.0), 1.0);
        float v36 = fminf(fmaxf((float)-v170 / v172, -1.0), 1.0);
      }
      uint64_t v174 = &v62[2 * v159];
      float v175 = v174[1];
      unint64_t v176 = *(unsigned int *)v174;
      uint64_t v177 = v161 + v389;
      uint64_t v393 = v168;
      if (!v176)
      {
        uint64_t v182 = v160;
        goto LABEL_131;
      }
      unint64_t v178 = v177 + 1;
      unint64_t v179 = v177 + 2;
      if (v176 < 0x18)
      {
        LOWORD(v180) = 0;
        int v181 = 0;
LABEL_129:
        uint64_t v182 = v160;
        do
        {
          uint64_t v198 = (_WORD *)(v158 + 2 * v182);
          *uint64_t v198 = v177;
          v198[1] = v178 + v180;
          v198[2] = v179 + v180;
          v182 += 3;
          LOWORD(v180) = ++v181;
        }
        while (v181 < v176);
        goto LABEL_131;
      }
      int v181 = 0;
      LOWORD(v180) = 0;
      uint64_t v183 = 2 * v160;
      BOOL v184 = !is_mul_ok(v176 - 1, 6uLL);
      uint64_t v185 = (__int16 *)(v158 + 2 * v160);
      BOOL v186 = v158 + v183 + 6 * (v176 - 1) >= v158 + v183 && v385 + 2 * v160 + 6 * (v176 - 1) >= v385 + 2 * v160;
      if (!v186) {
        goto LABEL_129;
      }
      if ((v176 - 1) == 255) {
        goto LABEL_129;
      }
      if (v176 - 1 > 0xFF) {
        goto LABEL_129;
      }
      if (v383 + v183 + 6 * (v176 - 1) < v383 + v183) {
        goto LABEL_129;
      }
      if (v184) {
        goto LABEL_129;
      }
      uint64_t v180 = v176 & 0xFFFFFFF8;
      int64x2_t v187 = vdupq_n_s64(v178);
      int64x2_t v188 = vdupq_n_s64(v179);
      int64x2_t v189 = (int64x2_t)xmmword_1A28FC8F0;
      int64x2_t v190 = (int64x2_t)xmmword_1A28FC900;
      int64x2_t v191 = (int64x2_t)xmmword_1A28FC910;
      int64x2_t v192 = (int64x2_t)xmmword_1A28FC760;
      uint64_t v193 = v180;
      int16x8_t v194 = vdupq_n_s16(v177);
      do
      {
        int16x8_t v195 = vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v187, v192), (int32x4_t)vaddq_s64(v187, v191)), (int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v187, v190), (int32x4_t)vaddq_s64(v187, v189)));
        int16x8_t v196 = vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v188, v192), (int32x4_t)vaddq_s64(v188, v191)), (int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v188, v190), (int32x4_t)vaddq_s64(v188, v189)));
        vst3q_s16(v185, *(int16x8x3_t *)v194.i8);
        v185 += 24;
        int64x2_t v197 = vdupq_n_s64(8uLL);
        int64x2_t v190 = vaddq_s64(v190, v197);
        int64x2_t v191 = vaddq_s64(v191, v197);
        int64x2_t v192 = vaddq_s64(v192, v197);
        int64x2_t v189 = vaddq_s64(v189, v197);
        v193 -= 8;
      }
      while (v193);
      v160 += 3 * (v176 & 0xFFFFFFF8);
      int v181 = v176 & 0xFFFFFFF8;
      uint64_t v182 = v160;
      if (v180 != v176) {
        goto LABEL_129;
      }
LABEL_131:
      int v199 = (int)(float)(v167 * 65535.0);
      int v200 = (int)(float)(v166 * 65535.0);
      char v201 = (_WORD *)(v158 + 2 * v182);
      *char v201 = v177;
      v201[1] = v177 + v176 + 3;
      v201[2] = v177 + v176 + 2;
      v201[3] = v177;
      v201[4] = v177 + v176 + 1;
      v201[5] = v177 + v176 + 3;
      uint64_t v202 = v390 + 8 * v161;
      *(_WORD *)uint64_t v202 = v199;
      *(_WORD *)(v202 + 2) = v200;
      *(unsigned char *)(v202 + 4) = v163;
      *(unsigned char *)(v202 + 5) = v162;
      *(_WORD *)(v202 + 6) = 0;
      *(_WORD *)(v202 + 8) = v199;
      *(_WORD *)(v202 + 10) = v200;
      *(unsigned char *)(v202 + 12) = v163;
      *(unsigned char *)(v202 + 13) = v162;
      *(_WORD *)(v202 + 14) = 127;
      if (v176)
      {
        uint64_t v203 = v387 + 8 * v161;
        unsigned __int8 v204 = 1;
        v161 += 2;
        do
        {
          __float2 v205 = __sincosf_stret(v175 * (float)v204);
          float v206 = fmaxf(-(float)((float)(v205.__sinval * v164) - (float)(v205.__cosval * v118)), -1.0);
          if (v206 <= 1.0) {
            float v207 = v206 * 127.0;
          }
          else {
            float v207 = 127.0;
          }
          float v208 = fmaxf((float)(v205.__sinval * v118) + (float)(v205.__cosval * v164), -1.0);
          if (v208 <= 1.0) {
            float v209 = v208 * 127.0;
          }
          else {
            float v209 = 127.0;
          }
          *(_WORD *)(v203 - 7) = v199;
          *(_WORD *)(v203 - 5) = v200;
          *(unsigned char *)(v203 - 3) = (int)v207;
          *(unsigned char *)(v203 - 2) = (int)v209;
          *(_WORD *)(v203 - 1) = 127;
          ++v161;
          ++v204;
          v203 += 8;
        }
        while (v176 >= v204);
      }
      else
      {
        v161 += 2;
      }
      uint64_t v160 = v182 + 6;
      float v118 = v173;
      int v162 = (int)(float)(v36 * 127.0);
      int v163 = (int)(float)(v173 * 127.0);
      uint64_t v159 = v393;
      float v62 = v388;
    }
    while (v393 != v391);
    int v210 = (int)(float)(*v372 * 65535.0);
    int v211 = (int)(float)(v372[1] * 65535.0);
    uint64_t v212 = v390 + 8 * v161;
    *(_WORD *)uint64_t v212 = v210;
    *(_WORD *)(v212 + 2) = v211;
    *(unsigned char *)(v212 + 4) = v163;
    *(unsigned char *)(v212 + 5) = v162;
    *(_WORD *)(v212 + 6) = 0;
    *(_WORD *)(v212 + 8) = v210;
    *(_WORD *)(v212 + 10) = v211;
    *(unsigned char *)(v212 + 12) = v163;
    *(unsigned char *)(v212 + 13) = v162;
    *(_WORD *)(v212 + 14) = 127;
    uint64_t v213 = v161 + 2;
    if (v380)
    {
      float v214 = v370;
      float v215 = v362;
      unint64_t v216 = v371;
      if (v371)
      {
        unsigned int v217 = v213 + v389;
        unint64_t v218 = v213 + v389 + 1;
        unint64_t v219 = v213 + v389 + 2;
        float v220 = v365;
        char v221 = v359;
        char v222 = v358;
        if (v371 < 0x18)
        {
          LOWORD(v223) = 0;
          int v224 = 0;
          uint64_t v139 = v367;
          float v225 = v381;
          goto LABEL_159;
        }
        int v224 = 0;
        LOWORD(v223) = 0;
        uint64_t v226 = v158 + 2 * v182;
        uint64_t v227 = 6 * (v371 - 1);
        uint64_t v228 = (__int16 *)(v226 + 12);
        float v225 = v381;
        if (v226 + 12 + v227 < (unint64_t)(v226 + 12))
        {
          uint64_t v139 = v367;
LABEL_158:
          unint64_t v216 = v371;
          goto LABEL_159;
        }
        uint64_t v139 = v367;
        if (v226 + 16 + v227 < (unint64_t)(v226 + 16) || (v371 - 1) == 255 || v371 - 1 > 0xFF) {
          goto LABEL_158;
        }
        BOOL v186 = v226 + 14 + v227 >= (unint64_t)(v226 + 14);
        unint64_t v216 = v371;
        if (!v186) {
          goto LABEL_283;
        }
        uint64_t v223 = v371 & 0xFFFFFFF8;
        int64x2_t v229 = vdupq_n_s64(v218);
        int64x2_t v230 = vdupq_n_s64(v219);
        int64x2_t v231 = (int64x2_t)xmmword_1A28FC8F0;
        int64x2_t v232 = (int64x2_t)xmmword_1A28FC900;
        int64x2_t v233 = (int64x2_t)xmmword_1A28FC910;
        int64x2_t v234 = (int64x2_t)xmmword_1A28FC760;
        uint64_t v235 = v223;
        int16x8_t v236 = vdupq_n_s16(v217);
        do
        {
          int16x8_t v237 = vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v229, v234), (int32x4_t)vaddq_s64(v229, v233)), (int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v229, v232), (int32x4_t)vaddq_s64(v229, v231)));
          int16x8_t v238 = vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v230, v234), (int32x4_t)vaddq_s64(v230, v233)), (int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v230, v232), (int32x4_t)vaddq_s64(v230, v231)));
          vst3q_s16(v228, *(int16x8x3_t *)v236.i8);
          v228 += 24;
          int64x2_t v239 = vdupq_n_s64(8uLL);
          int64x2_t v232 = vaddq_s64(v232, v239);
          int64x2_t v233 = vaddq_s64(v233, v239);
          int64x2_t v234 = vaddq_s64(v234, v239);
          int64x2_t v231 = vaddq_s64(v231, v239);
          v235 -= 8;
        }
        while (v235);
        v160 += 3 * v223;
        int v224 = v223;
        unint64_t v216 = v371;
        if (v371 != v223)
        {
LABEL_283:
          do
          {
LABEL_159:
            uint64_t v240 = (_WORD *)(v158 + 2 * v160);
            *uint64_t v240 = v217;
            v240[1] = v218 + v223;
            v240[2] = v219 + v223;
            v160 += 3;
            LOWORD(v223) = ++v224;
          }
          while (v216 > v224);
        }
      }
      else
      {
        uint64_t v139 = v367;
        float v225 = v381;
        float v220 = v365;
        char v221 = v359;
        char v222 = v358;
      }
      uint64_t v241 = v390;
      uint64_t v242 = v390 + 8 * v213;
      *(_WORD *)uint64_t v242 = v210;
      *(_WORD *)(v242 + 2) = v211;
      *(unsigned char *)(v242 + 4) = v221;
      *(unsigned char *)(v242 + 5) = v222;
      *(_WORD *)(v242 + 6) = 0;
      uint64_t v243 = v241 + 8 * v161;
      *(_WORD *)(v243 + 24) = v210;
      *(_WORD *)(v243 + 26) = v211;
      *(unsigned char *)(v243 + 28) = v221;
      *(unsigned char *)(v243 + 29) = v222;
      uint64_t v213 = v161 + 4;
      *(_WORD *)(v243 + 30) = 127;
      if (v216)
      {
        uint64_t v244 = v243 + 39;
        unsigned __int8 v245 = 1;
        int v246 = v210;
        int v247 = v211;
        unint64_t v248 = v371;
        do
        {
          __float2 v249 = __sincosf_stret(v220 * (float)v245);
          float v250 = fmaxf(-(float)((float)(v249.__sinval * v225) - (float)(v249.__cosval * v41)), -1.0);
          if (v250 <= 1.0) {
            float v251 = v250 * 127.0;
          }
          else {
            float v251 = 127.0;
          }
          float v252 = fmaxf((float)(v249.__sinval * v41) + (float)(v249.__cosval * v225), -1.0);
          if (v252 <= 1.0) {
            float v253 = v252 * 127.0;
          }
          else {
            float v253 = 127.0;
          }
          *(_WORD *)(v244 - 7) = v246;
          *(_WORD *)(v244 - 5) = v247;
          *(unsigned char *)(v244 - 3) = (int)v251;
          *(unsigned char *)(v244 - 2) = (int)v253;
          *(_WORD *)(v244 - 1) = 127;
          ++v213;
          ++v245;
          v244 += 8;
        }
        while (v248 >= v245);
        uint64_t v139 = v367;
        int v211 = v247;
        int v210 = v246;
      }
    }
    else
    {
      uint64_t v139 = v367;
      float v214 = v370;
      float v215 = v362;
    }
    if (v379)
    {
      float v254 = *v392;
      float v255 = v392[1];
      float v256 = *v392 - v361;
      float v257 = v255 - v360;
      if (((vabds_f32(*v392, v361) < 0.0001) & (vabds_f32(v255, v360) < 0.0001)) != 0)
      {
        float v256 = 0.0;
        float v257 = 1.0;
      }
      unint64_t v258 = v366;
      LODWORD(v393) = v211;
      if (v366)
      {
        unsigned int v259 = v213 + v389;
        unint64_t v260 = v213 + v389 + 1;
        unint64_t v261 = v213 + v389 + 2;
        if (v366 < 0x18)
        {
          LOWORD(v262) = 0;
          int v263 = 0;
          goto LABEL_176;
        }
        int v263 = 0;
        LOWORD(v262) = 0;
        uint64_t v329 = 2 * v160;
        uint64_t v330 = 6 * (v366 - 1);
        long long v331 = (__int16 *)(v158 + 2 * v160);
        if (&v331[(unint64_t)v330 / 2] < v331) {
          goto LABEL_284;
        }
        if (v385 + v329 + v330 < (unint64_t)(v385 + v329)) {
          goto LABEL_284;
        }
        if ((v366 - 1) == 255) {
          goto LABEL_284;
        }
        if (v366 - 1 > 0xFF) {
          goto LABEL_284;
        }
        if (v383 + v329 + v330 < (unint64_t)(v383 + v329)) {
          goto LABEL_284;
        }
        uint64_t v262 = v366 & 0xFFFFFFF8;
        int64x2_t v332 = vdupq_n_s64(v260);
        int64x2_t v333 = vdupq_n_s64(v261);
        int64x2_t v334 = (int64x2_t)xmmword_1A28FC8F0;
        int64x2_t v335 = (int64x2_t)xmmword_1A28FC900;
        int64x2_t v336 = (int64x2_t)xmmword_1A28FC910;
        int64x2_t v337 = (int64x2_t)xmmword_1A28FC760;
        uint64_t v338 = v262;
        int16x8_t v339 = vdupq_n_s16(v259);
        do
        {
          int16x8_t v340 = vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v332, v337), (int32x4_t)vaddq_s64(v332, v336)), (int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v332, v335), (int32x4_t)vaddq_s64(v332, v334)));
          int16x8_t v341 = vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v333, v337), (int32x4_t)vaddq_s64(v333, v336)), (int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v333, v335), (int32x4_t)vaddq_s64(v333, v334)));
          vst3q_s16(v331, *(int16x8x3_t *)v339.i8);
          v331 += 24;
          int64x2_t v342 = vdupq_n_s64(8uLL);
          int64x2_t v335 = vaddq_s64(v335, v342);
          int64x2_t v336 = vaddq_s64(v336, v342);
          int64x2_t v337 = vaddq_s64(v337, v342);
          int64x2_t v334 = vaddq_s64(v334, v342);
          v338 -= 8;
        }
        while (v338);
        v160 += 3 * (v258 & 0xFFFFFFF8);
        int v263 = v258 & 0xFFFFFFF8;
        if (v258 != v262)
        {
LABEL_284:
          do
          {
LABEL_176:
            uint64_t v264 = (_WORD *)(v158 + 2 * v160);
            *uint64_t v264 = v259;
            v264[1] = v260 + v262;
            v264[2] = v261 + v262;
            v160 += 3;
            LOWORD(v262) = ++v263;
          }
          while (v258 > v263);
        }
      }
      float v265 = 1.0 / sqrtf((float)(v256 * v256) + (float)(v257 * v257));
      float v266 = v265 * v257;
      float v267 = -(float)(v256 * v265);
      int v268 = (int)(float)((float)(v265 * v257) * 127.0);
      int v269 = (int)(float)(v267 * 127.0);
      int v270 = (int)(float)(v254 * 65535.0);
      int v271 = (int)(float)(v255 * 65535.0);
      uint64_t v272 = v390 + 8 * v213;
      *(_WORD *)uint64_t v272 = v270;
      *(_WORD *)(v272 + 2) = v271;
      *(unsigned char *)(v272 + 4) = v268;
      *(unsigned char *)(v272 + 5) = v269;
      *(_WORD *)(v272 + 6) = 0;
      *(_WORD *)(v272 + 8) = v270;
      *(_WORD *)(v272 + 10) = v271;
      *(unsigned char *)(v272 + 12) = v268;
      *(unsigned char *)(v272 + 13) = v269;
      *(_WORD *)(v272 + 14) = 127;
      v213 += 2;
      if (v258)
      {
        unint64_t v273 = v258;
        LODWORD(v391) = v210;
        uint64_t v274 = v272 + 23;
        for (unsigned __int8 i = 1; i <= v273; ++i)
        {
          __float2 v276 = __sincosf_stret(v214 * (float)i);
          float v277 = fmaxf(-(float)((float)(v276.__sinval * v267) - (float)(v276.__cosval * v266)), -1.0);
          if (v277 <= 1.0) {
            float v278 = v277 * 127.0;
          }
          else {
            float v278 = 127.0;
          }
          float v279 = fmaxf((float)(v276.__sinval * v266) + (float)(v276.__cosval * v267), -1.0);
          if (v279 <= 1.0) {
            float v280 = v279 * 127.0;
          }
          else {
            float v280 = 127.0;
          }
          *(_WORD *)(v274 - 7) = v270;
          *(_WORD *)(v274 - 5) = v271;
          *(unsigned char *)(v274 - 3) = (int)v278;
          *(unsigned char *)(v274 - 2) = (int)v280;
          *(_WORD *)(v274 - 1) = 127;
          ++v213;
          v274 += 8;
        }
        float v62 = v388;
        uint64_t v139 = v367;
        LOWORD(v210) = v391;
      }
      else
      {
        float v62 = v388;
        uint64_t v139 = v367;
      }
      LOWORD(v211) = v393;
    }
    unint64_t v281 = v369;
    if (v368)
    {
      float32x2_t v282 = &v392[2 * v382];
      float v283 = v372[1];
      float v284 = *(v282 - 4);
      float v285 = *(v282 - 3);
      float v286 = 0.0;
      if (((vabds_f32(*v372, v284) < 0.0001) & (vabds_f32(v283, v285) < 0.0001)) != 0)
      {
        float v287 = 1.0;
      }
      else
      {
        float v286 = *v372 - v284;
        float v287 = v283 - v285;
      }
      if (v369)
      {
        unsigned int v288 = v213 + v389;
        unint64_t v289 = v213 + v389 + 1;
        unint64_t v290 = v213 + v389 + 2;
        if (v369 < 0x18)
        {
          LOWORD(v291) = 0;
          int v292 = 0;
          goto LABEL_196;
        }
        int v292 = 0;
        LOWORD(v291) = 0;
        uint64_t v343 = 2 * v160;
        uint64_t v344 = 6 * (v369 - 1);
        uint64_t v345 = (__int16 *)(v158 + 2 * v160);
        if (&v345[(unint64_t)v344 / 2] < v345
          || v385 + v343 + v344 < (unint64_t)(v385 + v343)
          || (v369 - 1) == 255
          || v369 - 1 > 0xFF
          || v383 + v343 + v344 < (unint64_t)(v383 + v343))
        {
LABEL_196:
          unint64_t v293 = (_WORD *)(v158 + 2 * v160 + 4);
          do
          {
            *(v293 - 2) = v288;
            *(v293 - 1) = v289 + v291;
            _WORD *v293 = v290 + v291;
            v293 += 3;
            LOWORD(v291) = ++v292;
          }
          while (v281 > v292);
        }
        else
        {
          uint64_t v291 = v369 & 0xFFFFFFF8;
          int64x2_t v346 = vdupq_n_s64(v289);
          int64x2_t v347 = vdupq_n_s64(v290);
          int64x2_t v348 = (int64x2_t)xmmword_1A28FC8F0;
          int64x2_t v349 = (int64x2_t)xmmword_1A28FC900;
          int64x2_t v350 = (int64x2_t)xmmword_1A28FC910;
          int64x2_t v351 = (int64x2_t)xmmword_1A28FC760;
          uint64_t v352 = v291;
          int16x8_t v353 = vdupq_n_s16(v288);
          do
          {
            int16x8_t v354 = vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v346, v351), (int32x4_t)vaddq_s64(v346, v350)), (int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v346, v349), (int32x4_t)vaddq_s64(v346, v348)));
            int16x8_t v355 = vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v347, v351), (int32x4_t)vaddq_s64(v347, v350)), (int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v347, v349), (int32x4_t)vaddq_s64(v347, v348)));
            vst3q_s16(v345, *(int16x8x3_t *)v353.i8);
            v345 += 24;
            int64x2_t v356 = vdupq_n_s64(8uLL);
            int64x2_t v349 = vaddq_s64(v349, v356);
            int64x2_t v350 = vaddq_s64(v350, v356);
            int64x2_t v351 = vaddq_s64(v351, v356);
            int64x2_t v348 = vaddq_s64(v348, v356);
            v352 -= 8;
          }
          while (v352);
          if (v281 != v291)
          {
            v160 += 3 * (v281 & 0xFFFFFFF8);
            int v292 = v281 & 0xFFFFFFF8;
            goto LABEL_196;
          }
        }
      }
      float v294 = 1.0 / sqrtf((float)(v286 * v286) + (float)(v287 * v287));
      float v295 = v294 * v287;
      float v296 = -(float)(v286 * v294);
      int v297 = (int)(float)((float)(v294 * v287) * 127.0);
      int v298 = (int)(float)(v296 * 127.0);
      uint64_t v299 = v390 + 8 * v213;
      *(_WORD *)uint64_t v299 = v210;
      *(_WORD *)(v299 + 2) = v211;
      *(unsigned char *)(v299 + 4) = v297;
      *(unsigned char *)(v299 + 5) = v298;
      *(_WORD *)(v299 + 6) = 0;
      *(_WORD *)(v299 + 8) = v210;
      *(_WORD *)(v299 + 10) = v211;
      *(unsigned char *)(v299 + 12) = v297;
      *(unsigned char *)(v299 + 13) = v298;
      *(_WORD *)(v299 + 14) = 127;
      if (v281)
      {
        unint64_t v300 = v281;
        uint64_t v301 = v299 + 23;
        for (unsigned __int8 j = 1; j <= v300; ++j)
        {
          __float2 v303 = __sincosf_stret(v215 * (float)j);
          float v304 = fmaxf(-(float)((float)(v303.__sinval * v296) - (float)(v303.__cosval * v295)), -1.0);
          if (v304 <= 1.0) {
            float v305 = v304 * 127.0;
          }
          else {
            float v305 = 127.0;
          }
          float v306 = fmaxf((float)(v303.__sinval * v295) + (float)(v303.__cosval * v296), -1.0);
          if (v306 <= 1.0) {
            float v307 = v306 * 127.0;
          }
          else {
            float v307 = 127.0;
          }
          *(_WORD *)(v301 - 7) = v210;
          *(_WORD *)(v301 - 5) = v211;
          *(unsigned char *)(v301 - 3) = (int)v305;
          *(unsigned char *)(v301 - 2) = (int)v307;
          *(_WORD *)(v301 - 1) = 127;
          v301 += 8;
        }
      }
    }
LABEL_207:
    if (v378 > 0x2000) {
      free(v62);
    }
    unint64_t v308 = v377;
    unint64_t v309 = v376;
    long long v310 = v375;
    if (v158 && v374 != v373)
    {
      unint64_t v311 = v375[7];
      unint64_t v312 = v375[8];
      if (v312 == v311) {
        unint64_t v311 = v375[10] - v375[9];
      }
      if (v373 < v311) {
        unint64_t v311 = v373;
      }
      if (v312 <= v374) {
        unint64_t v312 = v374;
      }
      if (v312 == v311) {
        unint64_t v312 = v311 + v375[10] - v375[9];
      }
      v375[7] = v311;
      v310[8] = v312;
    }
    if (v390)
    {
      uint64_t v2 = v364;
      uint64_t v3 = v363;
      if (v308 != v309)
      {
        unint64_t v313 = *(void *)(v139 + 56);
        unint64_t v314 = *(void *)(v139 + 64);
        if (v314 == v313) {
          unint64_t v313 = *(void *)(v139 + 80) - *(void *)(v139 + 72);
        }
        if (v309 < v313) {
          unint64_t v313 = v309;
        }
        if (v314 <= v308) {
          unint64_t v314 = v308;
        }
        if (v314 == v313) {
          unint64_t v314 = v313 + *(void *)(v139 + 80) - *(void *)(v139 + 72);
        }
        *(void *)(v139 + 56) = v313;
        *(void *)(v139 + 64) = v314;
      }
      goto LABEL_231;
    }
    uint64_t v2 = v364;
    uint64_t v3 = v363;
    if (v398)
    {
LABEL_232:
      unint64_t v316 = v395;
      unint64_t v315 = v396;
      if (v396 != v395)
      {
        long long v317 = (void *)*((void *)&v394 + 1);
        int v318 = v397;
        int v319 = HIBYTE(v397);
        if ((void)v394 && *(unsigned char *)(*((void *)&v394 + 1) + 17) != 2) {
          (*(void (**)(void))(*(void *)v394 + 64))();
        }
        if (v318 && !v319)
        {
          unint64_t v320 = v317[7];
          unint64_t v321 = v317[8];
          if (v321 == v320) {
            unint64_t v320 = v317[10] - v317[9];
          }
          if (v316 < v320) {
            unint64_t v320 = v316;
          }
          if (v321 <= v315) {
            unint64_t v321 = v315;
          }
          if (v321 == v320) {
            unint64_t v321 = v320 + v317[10] - v317[9];
          }
          v317[7] = v320;
          v317[8] = v321;
        }
      }
    }
LABEL_248:
    if (v403)
    {
      unint64_t v323 = v400;
      unint64_t v322 = v401;
      if (v401 != v400)
      {
        unint64_t v324 = (void *)*((void *)&v399 + 1);
        int v325 = v402;
        int v326 = HIBYTE(v402);
        if ((void)v399 && *(unsigned char *)(*((void *)&v399 + 1) + 17) != 2) {
          (*(void (**)(void))(*(void *)v399 + 64))();
        }
        if (v325 && !v326)
        {
          unint64_t v327 = v324[7];
          unint64_t v328 = v324[8];
          if (v328 == v327) {
            unint64_t v327 = v324[10] - v324[9];
          }
          if (v323 < v327) {
            unint64_t v327 = v323;
          }
          if (v328 <= v322) {
            unint64_t v328 = v322;
          }
          if (v328 == v327) {
            unint64_t v328 = v327 + v324[10] - v324[9];
          }
          v324[7] = v327;
          v324[8] = v328;
        }
      }
    }
    unint64_t v4 = v386;
LABEL_5:
    if (++v4 != v384) {
      continue;
    }
    break;
  }
}

void sub_1A257E5E0(_Unwind_Exception *a1)
{
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)(v1 - 272));
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)(v1 - 224));
  _Unwind_Resume(a1);
}

uint64_t md::PhysicalLabelFeature::debugString@<X0>(md::LineLabelFeature *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, unsigned int a4@<W3>, unsigned char *a5@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v64);
  uint64_t v10 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v10 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v58) {
      operator new();
    }
  }
  uint64_t v61 = *((void *)v10 + 91);
  HIBYTE(v60) = 15;
  strcpy((char *)v59, "PhysicalFeature");
  md::LineLabelFeature::debugRoadString(__p, a1, a2, a3, a4, (uint64_t)v59);
  if ((v63 & 0x80u) == 0) {
    uint64_t v11 = __p;
  }
  else {
    uint64_t v11 = (void **)__p[0];
  }
  if ((v63 & 0x80u) == 0) {
    uint64_t v12 = v63;
  }
  else {
    uint64_t v12 = (uint64_t)__p[1];
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v64, (uint64_t)v11, v12);
  if ((char)v63 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v60) & 0x80000000) == 0) {
      goto LABEL_10;
    }
  }
  else if ((SHIBYTE(v60) & 0x80000000) == 0)
  {
    goto LABEL_10;
  }
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v61 + 40))(v61, v59[0], v60 & 0x7FFFFFFFFFFFFFFFLL);
LABEL_10:
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v64, (uint64_t)"Physical Feature Attributes:\n", 29);
  float v13 = *(float *)(a2 + 472);
  uint64_t v14 = *((void *)a1 + 24);
  LODWORD(v15) = v13;
  if (v13 >= 0x17) {
    uint64_t v15 = 23;
  }
  else {
    uint64_t v15 = v15;
  }
  int v16 = atomic_load((unsigned __int8 *)(v14 + 224 + v15));
  if (v16 != 254)
  {
    if ((char)v16 < 0) {
      goto LABEL_66;
    }
    goto LABEL_40;
  }
  if (*(unsigned char *)(v14 + 289)) {
    unsigned int v17 = 24;
  }
  else {
    unsigned int v17 = 5;
  }
  uint64_t v18 = *(unsigned __int8 **)(v14 + 128);
  uint64_t v19 = *(void *)(v14 + 136) - (void)v18;
  if (v19)
  {
    uint64_t v20 = 0;
    unint64_t v21 = v19 / 112;
    if (v21 <= 1) {
      uint64_t v22 = 1;
    }
    else {
      uint64_t v22 = v21;
    }
    int v23 = -1;
    float v24 = 1000.0;
    while (1)
    {
      int v26 = *v18;
      v18 += 112;
      int v25 = v26;
      if (v15 == v26) {
        break;
      }
      int v27 = v15 - v25;
      if (v27 >= 0) {
        unsigned int v28 = v27;
      }
      else {
        unsigned int v28 = -v27;
      }
      if (v28 <= v17)
      {
        float v29 = (float)v27;
        if (v27 < 0) {
          float v29 = (float)v27 * -0.8;
        }
        if (v29 < v24) {
          int v23 = v20;
        }
        float v24 = fminf(v29, v24);
      }
      if (v22 == ++v20) {
        goto LABEL_39;
      }
    }
    int v23 = v20;
  }
  else
  {
    int v23 = -1;
  }
LABEL_39:
  atomic_store(v23, (unsigned __int8 *)(v14 + 224 + v15));
  if ((v23 & 0x80000000) == 0)
  {
LABEL_40:
    if (*(void *)(v14 + 128))
    {
      uint64_t v30 = *((void *)a1 + 24);
      uint64_t v31 = v30 + 224;
      int v32 = atomic_load((unsigned __int8 *)(v30 + 224 + v15));
      if (v32 == 254)
      {
        if (*(unsigned char *)(v30 + 289)) {
          unsigned int v33 = 24;
        }
        else {
          unsigned int v33 = 5;
        }
        uint64_t v35 = v30 + 128;
        float v34 = *(unsigned __int8 **)(v30 + 128);
        uint64_t v36 = *(void *)(v35 + 8) - (void)v34;
        if (v36)
        {
          uint64_t v37 = 0;
          unint64_t v38 = v36 / 112;
          if (v38 <= 1) {
            uint64_t v39 = 1;
          }
          else {
            uint64_t v39 = v38;
          }
          unsigned __int8 v40 = -1;
          float v41 = 1000.0;
          float v42 = v34;
          while (1)
          {
            int v44 = *v42;
            v42 += 112;
            int v43 = v44;
            if (v15 == v44) {
              break;
            }
            int v45 = v15 - v43;
            if (v45 >= 0) {
              unsigned int v46 = v45;
            }
            else {
              unsigned int v46 = -v45;
            }
            if (v46 <= v33)
            {
              float v47 = (float)v45;
              if (v45 < 0) {
                float v47 = (float)v45 * -0.8;
              }
              if (v47 < v41) {
                unsigned __int8 v40 = v37;
              }
              float v41 = fminf(v47, v41);
            }
            if (v39 == ++v37) {
              goto LABEL_64;
            }
          }
          unsigned __int8 v40 = v37;
        }
        else
        {
          unsigned __int8 v40 = -1;
        }
LABEL_64:
        atomic_store(v40, (unsigned __int8 *)(v31 + v15));
      }
      exp2f(v13);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v64, (uint64_t)" Length:", 8);
      float v48 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v48, (uint64_t)" Pixels=", 8);
      float v49 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v49, (uint64_t)"\n", 1);
    }
  }
LABEL_66:
  if ((v71 & 0x10) != 0)
  {
    unint64_t v51 = v70;
    if (v70 < v67)
    {
      unint64_t v70 = v67;
      unint64_t v51 = v67;
    }
    float v52 = (const void **)&v66;
  }
  else
  {
    if ((v71 & 8) == 0)
    {
      size_t v50 = 0;
      a5[23] = 0;
      goto LABEL_81;
    }
    float v52 = (const void **)v65;
    unint64_t v51 = v65[2];
  }
  float v53 = *v52;
  size_t v50 = v51 - (void)*v52;
  if (v50 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v50 >= 0x17)
  {
    uint64_t v54 = (v50 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v50 | 7) != 0x17) {
      uint64_t v54 = v50 | 7;
    }
    uint64_t v55 = v54 + 1;
    int v56 = operator new(v54 + 1);
    *((void *)a5 + 1) = v50;
    *((void *)a5 + 2) = v55 | 0x8000000000000000;
    *(void *)a5 = v56;
    a5 = v56;
    goto LABEL_80;
  }
  a5[23] = v50;
  if (v50) {
LABEL_80:
  }
    memmove(a5, v53, v50);
LABEL_81:
  a5[v50] = 0;
  v64[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v64 + *(void *)(v64[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v64[1] = MEMORY[0x1E4FBA470] + 16;
  if (v69 < 0) {
    operator delete(v68);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v72);
}

void sub_1A257EBE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
}

id md::PhysicalLabelFeature::customFeatureAnnotation(id *this)
{
  return this[67];
}

uint64_t md::PhysicalLabelFeature::hasValidCustomFeatureAnnotation(md::PhysicalLabelFeature *this)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)this + 552);
  return v1 & 1;
}

uint64_t md::PhysicalLabelFeature::featureID(md::PhysicalLabelFeature *this)
{
  return *((void *)this + 56);
}

uint64_t md::PhysicalLabelFeature::resetCustomFeatureAnnotation(uint64_t this)
{
  return this;
}

uint64_t md::PhysicalLabelFeature::externalLineFeature(md::PhysicalLabelFeature *this)
{
  return *((void *)this + 58);
}

__n128 std::__function::__func<md::PhysicalLabelFeature::updateText(void const*,BOOL)::$_1,std::allocator<md::PhysicalLabelFeature::updateText(void const*,BOOL)::$_1>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51E410;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::PhysicalLabelFeature::updateText(void const*,BOOL)::$_1,std::allocator<md::PhysicalLabelFeature::updateText(void const*,BOOL)::$_1>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51E410;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::PhysicalLabelFeature::updateText(void const*,BOOL)::$_1,std::allocator<md::PhysicalLabelFeature::updateText(void const*,BOOL)::$_1>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::~__func()
{
}

uint64_t std::__function::__func<md::PhysicalLabelFeature::updateText(void const*,BOOL)::$_0,std::allocator<md::PhysicalLabelFeature::updateText(void const*,BOOL)::$_0>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t result = (*(uint64_t (**)(void, void, void))(**(void **)(a1 + 8) + 664))(*(void *)(a1 + 8), 0, *(unsigned __int8 *)(a1 + 16));
  *(unsigned char *)(v2 + 38) = result;
  return result;
}

__n128 std::__function::__func<md::PhysicalLabelFeature::updateText(void const*,BOOL)::$_0,std::allocator<md::PhysicalLabelFeature::updateText(void const*,BOOL)::$_0>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51E3C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::PhysicalLabelFeature::updateText(void const*,BOOL)::$_0,std::allocator<md::PhysicalLabelFeature::updateText(void const*,BOOL)::$_0>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51E3C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::PhysicalLabelFeature::updateText(void const*,BOOL)::$_0,std::allocator<md::PhysicalLabelFeature::updateText(void const*,BOOL)::$_0>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::~__func()
{
}

void md::PhysicalLabelFeature::~PhysicalLabelFeature(md::PhysicalLabelFeature *this)
{
  *(void *)this = &unk_1EF53E8C8;
  *((void *)this + 55) = &unk_1EF53EB80;
  *((void *)this + 66) = &unk_1EF55A018;

  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 59);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::LineLabelFeature::~LineLabelFeature(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF53E8C8;
  *((void *)this + 55) = &unk_1EF53EB80;
  *((void *)this + 66) = &unk_1EF55A018;

  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 59);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::LineLabelFeature::~LineLabelFeature(this);
}

void md::Logic<md::NavigationLogic,md::NavigationContext,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::ElevationContext,md::CameraContext>,gdc::TypeList<md::RouteOverlayContext>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void md::NavigationLogic::_updatePolygonSelection(md::NavigationLogic *this)
{
  uint64_t v1 = *((void *)this + 27);
  uint64_t v2 = *(void *)(v1 + 32);
  uint64_t v3 = *(void *)(v1 + 40);
  uint64_t v4 = v2;
  if (v2 != v3)
  {
    uint64_t v4 = v2;
    while (*(_WORD *)v4 != 41)
    {
      v4 += 16;
      if (v4 == v3) {
        goto LABEL_8;
      }
    }
  }
  if (v4 == v3) {
LABEL_8:
  }
    uint64_t v5 = 0;
  else {
    uint64_t v5 = *(void *)(v4 + 8);
  }
  uint64_t v6 = v2;
  if (v2 != v3)
  {
    uint64_t v6 = v2;
    while (*(_WORD *)v6 != 58)
    {
      v6 += 16;
      if (v6 == v3) {
        goto LABEL_16;
      }
    }
  }
  if (v6 == v3) {
LABEL_16:
  }
    uint64_t v7 = 0;
  else {
    uint64_t v7 = *(void *)(v6 + 8);
  }
  uint64_t v8 = v2;
  if (v2 != v3)
  {
    uint64_t v8 = v2;
    while (*(_WORD *)v8 != 42)
    {
      v8 += 16;
      if (v8 == v3) {
        goto LABEL_25;
      }
    }
  }
  if (v8 == v3)
  {
LABEL_25:
    uint64_t v9 = 0;
    if (v2 != v3)
    {
LABEL_26:
      while (*(_WORD *)v2 != 49)
      {
        v2 += 16;
        if (v2 == v3) {
          goto LABEL_32;
        }
      }
    }
  }
  else
  {
    uint64_t v9 = *(void *)(v8 + 8);
    if (v2 != v3) {
      goto LABEL_26;
    }
  }
  if (v2 == v3)
  {
LABEL_32:
    uint64_t v10 = 0;
    if (v5) {
      goto LABEL_36;
    }
LABEL_33:
    if (!v7 && !v9 && !v10) {
      return;
    }
    goto LABEL_36;
  }
  uint64_t v10 = *(void *)(v2 + 8);
  if (!v5) {
    goto LABEL_33;
  }
LABEL_36:
  uint64_t v26 = 0;
  int v27 = &v26;
  uint64_t v28 = 0x5812000000;
  float v29 = __Block_byref_object_copy__37554;
  uint64_t v30 = __Block_byref_object_dispose__37555;
  *(_OWORD *)uint64_t v31 = 0u;
  *(_OWORD *)std::string __p = 0u;
  uint64_t v33 = 0;
  int v34 = 1065353216;
  uint64_t v11 = (void *)*((void *)this + 23);
  if (v11)
  {
    int v12 = *((unsigned __int8 *)this + 225);
    if (v12 == 1 || v12 == 2 && !*((unsigned char *)this + 224))
    {
      v25[0] = MEMORY[0x1E4F143A8];
      v25[1] = 3221225472;
      v25[2] = ___ZN2md15NavigationLogic23_updatePolygonSelectionEv_block_invoke;
      void v25[3] = &unk_1E5A95C60;
      v25[4] = &v26;
      [v11 forEachRouteInfo:v25];
    }
  }
  if (v5)
  {
    uint64_t v13 = v27;
    uint64_t v14 = v27 + 6;
    if (!std::operator==[abi:nn180100]<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>(*(void **)(v5 + 824), *(void *)(v5 + 832), v27 + 6))
    {
      uint64_t v15 = (void *)(v5 + 808);
      gdc::LayerDataSource::cancelAllLayerDataRequests((gdc::LayerDataSource *)v5);
      int v16 = *(void **)(v5 + 16);
      std::__list_imp<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry,std::allocator<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry>>::clear(v16);
      if (v16[6])
      {
        unsigned int v17 = (unsigned char *)v16[5];
        if (v17)
        {
          do
          {
            if (v17[112]) {
              v17[112] = 0;
            }
            int v23 = *(unsigned char **)v17;
            float v24 = (void *)*((void *)v17 + 4);
            if (v24 != *((void **)v17 + 6)) {
              free(v24);
            }
            operator delete(v17);
            unsigned int v17 = v23;
          }
          while (v23);
        }
        v16[5] = 0;
        uint64_t v18 = v16[4];
        if (v18)
        {
          for (uint64_t i = 0; i != v18; ++i)
            *(void *)(v16[3] + 8 * i) = 0;
        }
        v16[6] = 0;
        uint64_t v15 = (void *)(v5 + 808);
      }
      v16[8] = v16;
      v16[9] = 0;
      if (v15 != v14)
      {
        *(_DWORD *)(v5 + 840) = *((_DWORD *)v13 + 20);
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(v15, (void *)v13[8]);
      }
    }
  }
  if (v7) {
    md::SelectedDaVinciPolygonLayerDataSource::setSelectedPolygons(v7, (uint64_t)(v27 + 6));
  }
  if (v9) {
    md::SelectedRoadLayerDataSource::setSelectedRoads(v9, (uint64_t)(v27 + 6));
  }
  if (v10) {
    md::SelectedDaVinciRoadsLayerDataSource::setSelectedRoads(v10, (uint64_t)(v27 + 6));
  }
  _Block_object_dispose(&v26, 8);
  uint64_t v20 = __p[1];
  if (__p[1])
  {
    do
    {
      unint64_t v21 = (void *)*v20;
      operator delete(v20);
      uint64_t v20 = v21;
    }
    while (v21);
  }
  uint64_t v22 = v31[1];
  v31[1] = 0;
  if (v22) {
    operator delete(v22);
  }
}

void sub_1A257F42C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v8 + 48);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__37554(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    *uint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

void __Block_byref_object_dispose__37555(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v4)
  {
    operator delete(v4);
  }
}

void ___ZN2md15NavigationLogic23_updatePolygonSelectionEv_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v15 = a2;
  uint64_t v3 = [v15 route];

  if (v3)
  {
    uint64_t v4 = [v15 route];
    uint64_t v5 = [v4 restrictionZoneInfo];

    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    uint64_t v6 = [v5 zoneIDs];
    uint64_t v7 = [v6 countByEnumeratingWithState:&v16 objects:v22 count:16];
    if (v7)
    {
      uint64_t v8 = *(void *)v17;
      do
      {
        uint64_t v9 = 0;
        do
        {
          if (*(void *)v17 != v8) {
            objc_enumerationMutation(v6);
          }
          uint64_t v10 = *(void **)(*((void *)&v16 + 1) + 8 * v9);
          if (GEOGetVectorKitRouteLog_onceToken != -1) {
            dispatch_once(&GEOGetVectorKitRouteLog_onceToken, &__block_literal_global_33);
          }
          uint64_t v11 = (id)GEOGetVectorKitRouteLog_log;
          if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
          {
            uint64_t v12 = [v10 identifier];
            *(_DWORD *)buf = 134217984;
            uint64_t v21 = v12;
            _os_log_impl(&dword_1A1780000, v11, OS_LOG_TYPE_INFO, "Selecting restricted zone polygon: %llx", buf, 0xCu);
          }

          uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8);
          uint64_t v14 = [v10 identifier];
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>(v13 + 48, v14, v14);
          ++v9;
        }
        while (v7 != v9);
        uint64_t v7 = [v6 countByEnumeratingWithState:&v16 objects:v22 count:16];
      }
      while (v7);
    }
  }
}

void sub_1A257F728(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t md::Logic<md::NavigationLogic,md::NavigationContext,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::ElevationContext,md::CameraContext>,gdc::TypeList<md::RouteOverlayContext>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::NavigationLogic,md::NavigationContext,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::ElevationContext,md::CameraContext>,gdc::TypeList<md::RouteOverlayContext>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x1B8B241A8D896A1DLL && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::ElevationContext,md::CameraContext>,gdc::TypeList<md::RouteOverlayContext>>::resolveDependencies(v7, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v7, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

void md::NavigationContext::~NavigationContext(md::NavigationContext *this)
{
  uint64_t v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)*((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v4) {
    operator delete(v4);
  }

  if (*((unsigned char *)this + 32)) {
    *((unsigned char *)this + 32) = 0;
  }
}

uint64_t gdc::ObjectHolder<md::NavigationContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::NavigationContext>::~ManagedObjectHolder(void *a1)
{
  gdc::ManagedObjectHolder<md::NavigationContext>::~ManagedObjectHolder(a1);
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::NavigationContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555690;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 120);
    if (v3)
    {
      do
      {
        uint64_t v4 = (void *)*v3;
        operator delete(v3);
        uint64_t v3 = v4;
      }
      while (v4);
    }
    uint64_t v5 = *(void **)(v2 + 104);
    *(void *)(v2 + 104) = 0;
    if (v5) {
      operator delete(v5);
    }

    if (*(unsigned char *)(v2 + 32)) {
      *(unsigned char *)(v2 + 32) = 0;
    }
    MEMORY[0x1A6239270](v2, 0x10A0C40CCC90A93);
  }
  return a1;
}

void md::NavigationLogic::~NavigationLogic(id *this)
{
  md::NavigationLogic::~NavigationLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  id v4;

  *this = &unk_1EF535098;
  [this[20] destroyAnimationRunner];
  [this[37] stop];
  this[36] = &unk_1EF5595B8;

  uint64_t v2 = this[33];
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = this[31];
  this[31] = 0;
  if (v4) {
    operator delete(v4);
  }
  this[22] = &unk_1EF5595D8;

  this[19] = &unk_1EF5596B8;
  *this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(this[13]);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(this[10]);
}

void sub_1A257FAFC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 288) = &unk_1EF5595B8;

  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v1 + 248);
  *(void *)(v1 + 176) = &unk_1EF5595D8;

  *(void *)(v1 + 152) = &unk_1EF5596B8;
  md::Logic<md::DrapingLogic,md::DrapingContext,md::LogicDependencies<gdc::TypeList<md::OverlaysContext,md::CameraContext,md::PendingSceneContext,md::ElevationContext>,gdc::TypeList<>>>::~Logic(v1);
  _Unwind_Resume(a1);
}

void geo::_retain_ptr<VKNavigationPuck * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5596B8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKNavigationPuck * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5596B8;

  return a1;
}

void geo::_retain_ptr<VKPuckAnimator * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5595B8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKPuckAnimator * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5595B8;

  return a1;
}

void md::NavigationLogic::setRouteContext(md::NavigationLogic *this, VKRouteContext *a2)
{
  uint64_t v7 = a2;
  if (*((VKRouteContext **)this + 23) != v7)
  {
    uint64_t v3 = v7;
    uint64_t v4 = v3;
    if (v3) {
      uint64_t v5 = v3;
    }
    uint64_t v6 = (void *)*((void *)this + 23);
    *((void *)this + 23) = v4;

    std::__hash_table<md::NavigationLogicEvent,std::hash<md::NavigationLogicEvent>,std::equal_to<md::NavigationLogicEvent>,std::allocator<md::NavigationLogicEvent>>::__emplace_unique_key_args<md::NavigationLogicEvent,md::NavigationLogicEvent const&>((uint64_t)this + 248, 1, 1);
  }
  md::NavigationLogic::_updatePolygonSelection(this);
}

void sub_1A257FD8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587560;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587560;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::Tile::LinearDepth>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::Tile::LinearDepth>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586D80;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586D80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::DaVinci::Shadow>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::DaVinci::Shadow>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587608;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587608;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::DaVinciGroundRenderable::~DaVinciGroundRenderable(md::DaVinciGroundRenderable *this)
{
  md::DaVinciGroundRenderable::~DaVinciGroundRenderable(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  uint64_t vars8;

  *(void *)this = &unk_1EF5139E8;
  uint64_t v2 = (void *)*((void *)this + 99);
  if (v2)
  {
    *((void *)this + 100) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 96);
  if (v3)
  {
    *((void *)this + 97) = v3;
    operator delete(v3);
  }
  if (*((unsigned char *)this + 760)) {
    *((unsigned char *)this + 760) = 0;
  }
  uint64_t v4 = (void *)*((void *)this + 92);
  if (v4)
  {
    *((void *)this + 93) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 89);
  if (v5)
  {
    *((void *)this + 90) = v5;
    operator delete(v5);
  }
  if (*((unsigned char *)this + 704)) {
    *((unsigned char *)this + 704) = 0;
  }
  uint64_t v6 = (void *)*((void *)this + 85);
  if (v6)
  {
    *((void *)this + 86) = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)*((void *)this + 82);
  if (v7)
  {
    *((void *)this + 83) = v7;
    operator delete(v7);
  }
  if (*((unsigned char *)this + 648)) {
    *((unsigned char *)this + 648) = 0;
  }
  uint64_t v8 = (void *)*((void *)this + 78);
  if (v8)
  {
    *((void *)this + 79) = v8;
    operator delete(v8);
  }
  uint64_t v9 = (void *)*((void *)this + 75);
  if (v9)
  {
    *((void *)this + 76) = v9;
    operator delete(v9);
  }
  if (*((unsigned char *)this + 592)) {
    *((unsigned char *)this + 592) = 0;
  }
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 57);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 55);
    if (!v11) {
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 55);
    if (!v11) {
      goto LABEL_31;
    }
  }
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
LABEL_31:
  uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 53);
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
    uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 51);
    if (!v13) {
      goto LABEL_37;
    }
  }
  else
  {
    uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 51);
    if (!v13) {
      goto LABEL_37;
    }
  }
  if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
LABEL_37:
  *(void *)this = &unk_1EF513508;
  uint64_t v14 = (std::__shared_weak_count *)*((void *)this + 49);
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  md::BaseMapTileDataRenderable::~BaseMapTileDataRenderable(this);
}

void sub_1A25808F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2580A50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2580CD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

md::CompositeLabelPart *md::TransitNodeLabelFeature::newGraphicAnnotationPart(md::TransitNodeLabelFeature *this, const md::PartCreationContext *a2)
{
  uint64_t v2 = this;
  if ((*(uint64_t (**)(md::TransitNodeLabelFeature *))(*(void *)this + 64))(this))
  {
    uint64_t v3 = *((void *)v2 + 63);
    uint64_t v4 = *(std::__shared_weak_count **)(v3 + 312);
    if (!v4) {
      return 0;
    }
    *(void *)&long long __dst = v2;
    *((void *)&__dst + 1) = a2;
    float v122 = 0;
    float v123 = 0;
    uint64_t v5 = *((void *)a2 + 1);
    switch(*(unsigned char *)(v5 + 1223))
    {
      case 0:
        float v75 = *(std::__shared_weak_count **)(v3 + 320);
        if (v75)
        {
          atomic_fetch_add_explicit(&v75->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v5 = *((void *)a2 + 1);
          int v76 = *(unsigned __int8 *)(v5 + 1223);
          float v122 = v4;
          float v123 = v75;
          if (v76 == 3) {
            goto LABEL_149;
          }
        }
        else
        {
          float v122 = v4;
          float v123 = 0;
        }
        *(unsigned char *)(v5 + 1223) = 1;
        goto LABEL_149;
      case 1:
      case 3:
        uint64_t v4 = (std::__shared_weak_count *)*((void *)v2 + 111);
        uint64_t v6 = (std::__shared_weak_count *)*((void *)v2 + 112);
        if (v6) {
          atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        float v122 = v4;
        float v123 = v6;
        if (!v4) {
          goto LABEL_155;
        }
        __n128 result = md::TransitNodeLabelFeature::newGraphicAnnotationPartForExternalFeature(md::PartCreationContext const&)::$_0::operator()((uint64_t)&__dst, (void **)&v122);
        goto LABEL_164;
      case 2:
        uint64_t v77 = *((void *)v2 + 111);
        if (v77)
        {
          uint64_t v4 = *(std::__shared_weak_count **)(v77 + 32);
          float v78 = *(std::__shared_weak_count **)(v77 + 40);
          if (v78)
          {
            atomic_fetch_add_explicit(&v78->__shared_owners_, 1uLL, memory_order_relaxed);
            uint64_t v5 = *((void *)a2 + 1);
            int v79 = *(unsigned __int8 *)(v5 + 1223);
            float v122 = v4;
            float v123 = v78;
            if (v79 == 3) {
              goto LABEL_145;
            }
LABEL_144:
            *(unsigned char *)(v5 + 1223) = 1;
LABEL_145:
            if (v4)
            {
LABEL_149:
              while (1)
              {
                __n128 result = md::TransitNodeLabelFeature::newGraphicAnnotationPartForExternalFeature(md::PartCreationContext const&)::$_0::operator()((uint64_t)&__dst, (void **)&v122);
                if (result) {
                  break;
                }
                uint64_t shared_owners = (std::__shared_weak_count *)v4[1].__shared_owners_;
                unint64_t shared_weak_owners = (std::__shared_weak_count *)v4[1].__shared_weak_owners_;
                if (shared_weak_owners) {
                  atomic_fetch_add_explicit(&shared_weak_owners->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                float v84 = v123;
                float v122 = shared_owners;
                float v123 = shared_weak_owners;
                if (v84)
                {
                  if (!atomic_fetch_add(&v84->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
                    std::__shared_weak_count::__release_weak(v84);
                  }
                  uint64_t shared_owners = v122;
                }
                uint64_t v4 = shared_owners;
                if (!shared_owners) {
                  goto LABEL_155;
                }
              }
            }
            else
            {
LABEL_155:
              uint64_t v85 = *((void *)a2 + 1);
              if (*(unsigned char *)(v85 + 1223) != 3) {
                *(unsigned char *)(v85 + 1223) = 3;
              }
              float v86 = (std::__shared_weak_count *)*((void *)v2 + 113);
              if (!v86)
              {
                uint64_t v4 = 0;
                __n128 result = 0;
                float v89 = v123;
                if (!v123) {
                  goto LABEL_166;
                }
                goto LABEL_165;
              }
              unsigned int v87 = (std::__shared_weak_count *)*((void *)v2 + 114);
              if (v87) {
                atomic_fetch_add_explicit(&v87->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              uint64_t v88 = v123;
              float v122 = v86;
              float v123 = v87;
              if (v88 && !atomic_fetch_add(&v88->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
                std::__shared_weak_count::__release_weak(v88);
              }
              __n128 result = md::TransitNodeLabelFeature::newGraphicAnnotationPartForExternalFeature(md::PartCreationContext const&)::$_0::operator()((uint64_t)&__dst, (void **)&v122);
              uint64_t v4 = v122;
            }
LABEL_164:
            float v89 = v123;
            if (!v123)
            {
LABEL_166:
              *((void *)v2 + 111) = v4;
              float v90 = (std::__shared_weak_count *)*((void *)v2 + 112);
              *((void *)v2 + 112) = v89;
              if (v90 && !atomic_fetch_add(&v90->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                float v92 = result;
                ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
                std::__shared_weak_count::__release_weak(v90);
                __n128 result = v92;
                if (*((void *)v2 + 113)) {
                  goto LABEL_169;
                }
              }
              else if (*((void *)v2 + 113))
              {
                goto LABEL_169;
              }
              float v94 = &v122->__vftable;
              float v93 = v123;
              if (v123) {
                atomic_fetch_add_explicit(&v123->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              *((void *)v2 + 113) = v94;
              float v95 = (std::__shared_weak_count *)*((void *)v2 + 114);
              *((void *)v2 + 114) = v93;
              if (v95 && !atomic_fetch_add(&v95->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                float v96 = result;
                ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
                std::__shared_weak_count::__release_weak(v95);
                __n128 result = v96;
              }
LABEL_169:
              float v81 = v123;
              if (!v123) {
                return result;
              }
              goto LABEL_170;
            }
LABEL_165:
            atomic_fetch_add_explicit(&v89->__shared_owners_, 1uLL, memory_order_relaxed);
            goto LABEL_166;
          }
        }
        else
        {
          uint64_t v4 = 0;
        }
        float v122 = v4;
        float v123 = 0;
        goto LABEL_144;
      default:
        goto LABEL_155;
    }
  }
  float v126 = 0;
  float v127 = 0;
  std::mutex::lock((std::mutex *)((char *)v2 + 8));
  uint64_t v8 = *((void *)v2 + 19);
  if (!v8)
  {
    std::mutex::unlock((std::mutex *)((char *)v2 + 8));
    __n128 result = 0;
    goto LABEL_136;
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, geo::codec::VectorTile **))(*(void *)v8 + 16))(v8, &v126);
  std::mutex::unlock((std::mutex *)((char *)v2 + 8));
  __n128 result = 0;
  if (!v126 || !v9) {
    goto LABEL_136;
  }
  float v122 = 0;
  float v123 = 0;
  uint64_t v124 = 0;
  {
    operator new();
  }
  uint64_t v125 = mdm::Allocator::instance(void)::alloc;
  md::TransitNodeLabelFeature::populateAnnotationInfos(v9, (uint64_t *)&v122);
  uint64_t v11 = v122;
  uint64_t v10 = v123;
  if (v122 == v123)
  {
    __n128 result = 0;
    if (v122) {
      goto LABEL_135;
    }
    goto LABEL_136;
  }
  int v12 = *(_DWORD *)(*((void *)a2 + 2) + 160);
  if (v12 >= 0) {
    int v13 = *(_DWORD *)(*((void *)a2 + 2) + 160);
  }
  else {
    int v13 = -v12;
  }
  int v105 = v13;
  {
    operator new();
  }
  float v104 = (md::CompositeLabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                        + 16))(mdm::Allocator::instance(void)::alloc, 696, 8);
  md::StackLabelPart::StackLabelPart((uint64_t)v104, 1, 0, 0, 0);
  (*(void (**)(md::CompositeLabelPart *, uint64_t))(*(void *)v104 + 176))(v104, 7);
  *((unsigned char *)v104 + 630) = 1;
  v121[0] = 0;
  {
    operator new();
  }
  uint64_t v14 = 0;
  v121[1] = mdm::Allocator::instance(void)::alloc;
  v121[2] = 0;
  uint64_t v120 = v121;
  id v15 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  float v98 = v2;
  int v16 = v105;
  if (v12 <= 0) {
    int v16 = 0;
  }
  unsigned int v100 = v16;
  float v101 = v10;
  while (2)
  {
    long long v119 = 0uLL;
    int v18 = (int)v11->__vftable;
    if (LODWORD(v11->__vftable) == 1)
    {
      long long v19 = (uint64_t *)geo::codec::VectorTile::transitLineForFeatureID(v126, v11->__shared_owners_);
      if (!v19) {
        goto LABEL_109;
      }
      goto LABEL_31;
    }
    if (v18 == 3)
    {
      uint64_t v22 = v11->__shared_owners_;
      if (!v22) {
        goto LABEL_109;
      }
      uint64_t v23 = v14;
      {
        operator new();
      }
      uint64_t v24 = *((void *)v15 + 91);
      uint64_t v25 = *((void *)a2 + 2);
      uint64_t v26 = *(float **)(v25 + 280);
      if (v26)
      {
        if (vabds_f32(v26[2], *(float *)(v25 + 104)) >= 0.01)
        {
          md::LabelStyle::updateStyleGroup<md::LabelTextStyleGroup>(*((unsigned __int8 **)a2 + 2), (uint64_t)v26, 0);
          uint64_t v26 = *(float **)(v25 + 280);
        }
      }
      else
      {
        uint64_t v26 = (float *)md::LabelStyle::prepareStyleGroup<md::LabelTextStyleGroup>(*((void *)a2 + 2), 0);
        *(void *)(v25 + 280) = v26;
      }
      unsigned int v27 = *(_DWORD *)(*(void *)v26 + 8);
      v102 &= 0xFFFFFFFFFFFFFFuLL;
      v103 &= 0xFFFFFFFFFFFFFF00;
      *(void *)&long long __dst = v103;
      uint64_t v110 = v102;
      uint64_t v111 = v24;
      uint64_t v112 = v22;
      unsigned int v113 = v27;
      unsigned __int8 v114 = 0;
      uint64_t v29 = *((void *)a2 + 1);
      uint64_t v28 = *((void *)a2 + 2);
      uint64_t v30 = *(void *)a2;
      uint64_t v31 = *(void *)(v28 + 296);
      uint64_t v10 = v101;
      uint64_t v14 = v23;
      if (!v31)
      {
        int v32 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*((void *)a2 + 2), 0);
        uint64_t v31 = *v32;
        *(void *)(v28 + 296) = *v32;
      }
      md::LabelStyle::shieldIcon((uint64_t *)&v115, v28, v30, v29, (void **)&__dst, 0, *(char *)(v31 + 93));
      long long v33 = v115;
      long long v115 = 0uLL;
      int v34 = (std::__shared_weak_count *)*((void *)&v119 + 1);
      long long v119 = v33;
      if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
        uint64_t v35 = (std::__shared_weak_count *)*((void *)&v115 + 1);
        if (!*((void *)&v115 + 1)) {
          goto LABEL_49;
        }
      }
      else
      {
        uint64_t v35 = (std::__shared_weak_count *)*((void *)&v115 + 1);
        if (!*((void *)&v115 + 1)) {
          goto LABEL_49;
        }
      }
      if (!atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
        if ((SHIBYTE(v110) & 0x80000000) == 0) {
          goto LABEL_109;
        }
        goto LABEL_50;
      }
LABEL_49:
      if ((SHIBYTE(v110) & 0x80000000) == 0) {
        goto LABEL_109;
      }
LABEL_50:
      uint64_t v36 = __dst;
      uint64_t v38 = v110;
      uint64_t v37 = v111;
      goto LABEL_108;
    }
    if (v18 != 2) {
      goto LABEL_113;
    }
    long long v19 = (uint64_t *)v11->__shared_owners_;
    if (!v19) {
      goto LABEL_109;
    }
LABEL_31:
    if (!geo::codec::featureGetNativeShieldCount((uint64_t)v19)) {
      goto LABEL_109;
    }
    uint64_t v118 = 0;
    unsigned __int8 v20 = atomic_load((unsigned __int8 *)(*(void *)a2 + 3392));
    *(void *)&long long __dst = 0;
    geo::codec::featureGetNativeShield((uint64_t)v19, 0, &__dst, &v118, 0);
    localizedLabel((unint64_t)&v115, v19, (char *)__dst, v20 & 1, 0);
    uint64_t v21 = v118;
    if (!v118)
    {
      id v15 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      if (v116 < 0) {
        goto LABEL_107;
      }
      goto LABEL_109;
    }
    uint64_t v111 = v117;
    if (SHIBYTE(v116) < 0)
    {
      std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)&__dst, (void *)v115, *((unint64_t *)&v115 + 1));
    }
    else
    {
      long long __dst = v115;
      uint64_t v110 = v116;
    }
    unsigned int v99 = v14;
    uint64_t v112 = v21;
    unsigned int v113 = 0;
    unsigned __int8 v114 = 2;
    uint64_t v39 = *(void *)(*(void *)(*(void *)a2 + 168) + 56);
    (*(void (**)(uint64_t, uint64_t *, unsigned int *, void))(*(void *)v39 + 24))(v39, v19, &v113, *((unsigned __int8 *)v2 + 876));
    uint64_t v40 = v121[0];
    if (!v121[0])
    {
LABEL_90:
      std::__tree<md::LabelShieldEntry,std::less<md::LabelShieldEntry>,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>>::__emplace_unique_key_args<md::LabelShieldEntry,md::LabelShieldEntry const&>(&v120, (void **)&__dst, &__dst);
      uint64_t v63 = *((void *)a2 + 1);
      uint64_t v62 = *((void *)a2 + 2);
      uint64_t v64 = *(void *)a2;
      uint64_t v65 = *(void *)(v62 + 296);
      uint64_t v2 = v98;
      id v15 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      uint64_t v10 = v101;
      uint64_t v14 = v99;
      if (!v65)
      {
        uint64_t v66 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*((void *)a2 + 2), 0);
        uint64_t v65 = *v66;
        *(void *)(v62 + 296) = *v66;
      }
      md::LabelStyle::shieldIcon((uint64_t *)&v108, v62, v64, v63, (void **)&__dst, 1, *(char *)(v65 + 93));
      long long v67 = v108;
      long long v108 = 0uLL;
      uint64_t v68 = (std::__shared_weak_count *)*((void *)&v119 + 1);
      long long v119 = v67;
      if (v68 && !atomic_fetch_add(&v68->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
        std::__shared_weak_count::__release_weak(v68);
      }
      char v69 = (std::__shared_weak_count *)*((void *)&v108 + 1);
      if (*((void *)&v108 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v108 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
        std::__shared_weak_count::__release_weak(v69);
      }
      if ((v110 & 0x8000000000000000) == 0) {
        goto LABEL_99;
      }
LABEL_106:
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v111 + 40))(v111, __dst, v110 & 0x7FFFFFFFFFFFFFFFLL);
      if ((v116 & 0x8000000000000000) == 0) {
        goto LABEL_109;
      }
LABEL_107:
      uint64_t v36 = v115;
      uint64_t v38 = v116;
      uint64_t v37 = v117;
LABEL_108:
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v37 + 40))(v37, v36, v38 & 0x7FFFFFFFFFFFFFFFLL);
      goto LABEL_109;
    }
    uint64_t v41 = v112;
    unsigned int v42 = v114;
    p_dst = (long long *)__dst;
    char v97 = HIBYTE(v110);
    if (v110 >= 0) {
      p_dst = &__dst;
    }
    __s1 = p_dst;
    if (v110 >= 0) {
      size_t v44 = HIBYTE(v110);
    }
    else {
      size_t v44 = *((void *)&__dst + 1);
    }
    while (1)
    {
      uint64_t v50 = *(void *)(v40 + 64);
      if (v41 < v50) {
        goto LABEL_63;
      }
      unsigned int v51 = *(unsigned __int8 *)(v40 + 76);
      if (v42 < v51) {
        goto LABEL_63;
      }
      int v52 = *(char *)(v40 + 55);
      if (v52 >= 0) {
        float v53 = (const void *)(v40 + 32);
      }
      else {
        float v53 = *(const void **)(v40 + 32);
      }
      if (v52 >= 0) {
        size_t v54 = *(unsigned __int8 *)(v40 + 55);
      }
      else {
        size_t v54 = *(void *)(v40 + 40);
      }
      if (v54 >= v44) {
        size_t v55 = v44;
      }
      else {
        size_t v55 = v54;
      }
      int v56 = memcmp(__s1, v53, v55);
      if (v56)
      {
        if (v56 < 0) {
          goto LABEL_63;
        }
      }
      else if (v44 < v54)
      {
        goto LABEL_63;
      }
      unsigned int v57 = bswap32(v113);
      unsigned int v58 = bswap32(*(_DWORD *)(v40 + 72));
      BOOL v47 = v57 >= v58;
      BOOL v59 = v57 > v58;
      int v60 = !v47;
      if (v59 - v60 < 0) {
        goto LABEL_63;
      }
      if (v50 < v41 || v51 < v42) {
        goto LABEL_62;
      }
      int v61 = memcmp(v53, __s1, v55);
      if (!v61) {
        break;
      }
      if ((v61 & 0x80000000) == 0) {
        goto LABEL_58;
      }
LABEL_62:
      v40 += 8;
LABEL_63:
      uint64_t v40 = *(void *)v40;
      if (!v40) {
        goto LABEL_90;
      }
    }
    if (v54 < v44) {
      goto LABEL_62;
    }
LABEL_58:
    unsigned int v45 = bswap32(*(_DWORD *)(v40 + 72));
    unsigned int v46 = bswap32(v113);
    BOOL v47 = v45 >= v46;
    BOOL v48 = v45 > v46;
    int v49 = !v47;
    if (v48 - v49 < 0) {
      goto LABEL_62;
    }
    uint64_t v2 = v98;
    id v15 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    uint64_t v10 = v101;
    uint64_t v14 = v99;
    if (v97 < 0) {
      goto LABEL_106;
    }
LABEL_99:
    if (v116 < 0) {
      goto LABEL_107;
    }
LABEL_109:
    if (!(void)v119)
    {
LABEL_113:
      char v70 = 0;
      int v71 = (std::__shared_weak_count *)*((void *)&v119 + 1);
      if (*((void *)&v119 + 1)) {
        goto LABEL_117;
      }
      goto LABEL_21;
    }
    if (v14 == v105)
    {
      char v70 = 1;
      uint64_t v14 = v100;
      int v71 = (std::__shared_weak_count *)*((void *)&v119 + 1);
      if (!*((void *)&v119 + 1)) {
        goto LABEL_21;
      }
LABEL_117:
      if (!atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
        std::__shared_weak_count::__release_weak(v71);
      }
    }
    else
    {
      {
        operator new();
      }
      uint64_t v72 = (md::LabelPart *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v15 + 91) + 16))(*((void *)v15 + 91), 768, 8);
      double v73 = md::IconLabelPart::IconLabelPart((uint64_t)v72, &v119);
      (*(void (**)(uint64_t, uint64_t, double))(*(void *)v74 + 176))(v74, 10, v73);
      md::CompositeLabelPart::addLabelPart((uint64_t)v104, v72);
      char v70 = 0;
      uint64_t v14 = (v14 + 1);
      int v71 = (std::__shared_weak_count *)*((void *)&v119 + 1);
      if (*((void *)&v119 + 1)) {
        goto LABEL_117;
      }
    }
LABEL_21:
    uint64_t v11 = (std::__shared_weak_count *)((char *)v11 + 16);
    if (v11 == v10) {
      char v17 = 1;
    }
    else {
      char v17 = v70;
    }
    if ((v17 & 1) == 0) {
      continue;
    }
    break;
  }
  if (!v14)
  {
    (*(void (**)(md::CompositeLabelPart *))(*(void *)v104 + 8))(v104);
    float v104 = 0;
  }
  std::__tree<md::LabelShieldEntry,std::less<md::LabelShieldEntry>,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>>::destroy((uint64_t)&v120, v121[0]);
  uint64_t v11 = v122;
  __n128 result = v104;
  if (v122)
  {
LABEL_135:
    float v123 = v11;
    float v80 = result;
    (*(void (**)(uint64_t, std::__shared_weak_count *, uint64_t))(*(void *)v125 + 40))(v125, v11, v124 - (void)v11);
    __n128 result = v80;
  }
LABEL_136:
  float v81 = v127;
  if (v127)
  {
LABEL_170:
    if (!atomic_fetch_add(&v81->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      float v91 = result;
      ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
      std::__shared_weak_count::__release_weak(v81);
      return v91;
    }
  }
  return result;
}

void sub_1A2581B80(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 - 136);
  _Unwind_Resume(a1);
}

uint64_t md::TransitNodeLabelFeature::populateAnnotationInfos(uint64_t result, uint64_t *a2)
{
  if (*(unsigned char *)(result + 274))
  {
    uint64_t v3 = result;
    for (unsigned __int8 i = 0; *(unsigned __int8 *)(v3 + 274) > i; ++i)
    {
      if (*(unsigned __int8 *)(v3 + 275) == i)
      {
        unint64_t v6 = a2[1];
        unint64_t v7 = a2[2];
        if (v6 >= v7)
        {
          uint64_t v10 = (uint64_t)(v6 - *a2) >> 4;
          unint64_t v11 = v10 + 1;
          if ((unint64_t)(v10 + 1) >> 60) {
            goto LABEL_45;
          }
          uint64_t v12 = v7 - *a2;
          if (v12 >> 3 > v11) {
            unint64_t v11 = v12 >> 3;
          }
          if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
          }
          if (v11)
          {
            uint64_t v13 = 16 * v11;
            uint64_t v14 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2[3] + 16))(a2[3], 16 * v11, 8);
            uint64_t v15 = v14 + 16 * v10;
            unint64_t v11 = v14 + v13;
            if (v14)
            {
              uint64_t v16 = *(unsigned int *)(v3 + 296);
              *(_DWORD *)uint64_t v15 = 3;
              *(void *)(v15 + 8) = v16;
            }
          }
          else
          {
            uint64_t v15 = 16 * v10;
          }
          uint64_t v18 = *a2;
          uint64_t v17 = a2[1];
          uint64_t v19 = v15;
          if (v17 != *a2)
          {
            do
            {
              *(_OWORD *)(v19 - 16) = *(_OWORD *)(v17 - 16);
              v19 -= 16;
              v17 -= 16;
            }
            while (v17 != v18);
            uint64_t v17 = *a2;
          }
          uint64_t v9 = v15 + 16;
          *a2 = v19;
          a2[1] = v15 + 16;
          uint64_t v20 = a2[2];
          a2[2] = v11;
          if (v17) {
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2[3] + 40))(a2[3], v17, v20 - v17);
          }
        }
        else
        {
          if (v6)
          {
            uint64_t v8 = *(unsigned int *)(v3 + 296);
            *(_DWORD *)unint64_t v6 = 3;
            *(void *)(v6 + 8) = v8;
          }
          uint64_t v9 = v6 + 16;
        }
        a2[1] = v9;
      }
      __n128 result = geo::codec::vectorTransitLineForTransitNodeSubtitleIndex(v3, i);
      if (result)
      {
        uint64_t v21 = result;
        unint64_t v22 = a2[1];
        unint64_t v23 = a2[2];
        if (v22 >= v23)
        {
          uint64_t v24 = (uint64_t)(v22 - *a2) >> 4;
          unint64_t v25 = v24 + 1;
          if ((unint64_t)(v24 + 1) >> 60) {
LABEL_45:
          }
            abort();
          uint64_t v26 = v23 - *a2;
          if (v26 >> 3 > v25) {
            unint64_t v25 = v26 >> 3;
          }
          if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
          }
          if (v25)
          {
            uint64_t v27 = 16 * v25;
            __n128 result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2[3] + 16))(a2[3], 16 * v25, 8);
            uint64_t v28 = result + 16 * v24;
            unint64_t v25 = result + v27;
            if (result)
            {
              *(_DWORD *)uint64_t v28 = 2;
              *(void *)(v28 + 8) = v21;
            }
          }
          else
          {
            uint64_t v28 = 16 * v24;
          }
          uint64_t v30 = *a2;
          uint64_t v29 = a2[1];
          uint64_t v31 = v28;
          if (v29 != *a2)
          {
            do
            {
              *(_OWORD *)(v31 - 16) = *(_OWORD *)(v29 - 16);
              v31 -= 16;
              v29 -= 16;
            }
            while (v29 != v30);
            uint64_t v29 = *a2;
          }
          uint64_t v5 = v28 + 16;
          *a2 = v31;
          a2[1] = v28 + 16;
          uint64_t v32 = a2[2];
          a2[2] = v25;
          if (v29) {
            __n128 result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2[3] + 40))(a2[3], v29, v32 - v29);
          }
        }
        else
        {
          if (v22)
          {
            *(_DWORD *)unint64_t v22 = 2;
            *(void *)(v22 + 8) = result;
          }
          uint64_t v5 = v22 + 16;
        }
        a2[1] = v5;
      }
    }
  }
  return result;
}

md::CompositeLabelPart *md::TransitNodeLabelFeature::newGraphicAnnotationPartForExternalFeature(md::PartCreationContext const&)::$_0::operator()(uint64_t a1, void **a2)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    operator new();
  }
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 704, 8);
  char v6 = *((unsigned char *)*a2 + 24);
  uint64_t v7 = md::StackLabelPart::StackLabelPart(v5, 1);
  *(void *)uint64_t v7 = &unk_1EF54ECD8;
  *(unsigned char *)(v7 + 694) = v6;
  *(_WORD *)(v7 + 695) = 1;
  uint64_t v8 = (geo::codec::Allocator *)md::LabelPart::setContentType(v7, 7);
  uint64_t v66 = (md::CompositeLabelPart *)v5;
  *(unsigned char *)(v5 + 630) = 1;
  int v60 = (void *)(*a2)[1];
  if ((void *)**a2 != v60)
  {
    uint64_t v9 = (void *)**a2;
    while (1)
    {
      int v61 = v9;
      uint64_t v10 = (std::__shared_weak_count *)v9[1];
      uint64_t v63 = (unsigned __int8 ***)*v9;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v62 = v10;
      unint64_t v11 = *v63;
      char v69 = v63[1];
      if (*v63 != v69) {
        break;
      }
      int v12 = 0;
LABEL_67:
      if (v12 != ((char *)v63[1] - (char *)*v63) >> 4)
      {
        (*(void (**)(md::CompositeLabelPart *))(*(void *)v66 + 8))(v66);
        if (v62 && !atomic_fetch_add(&v62->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
          std::__shared_weak_count::__release_weak(v62);
        }
        return 0;
      }
      if (v62 && !atomic_fetch_add(&v62->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
        std::__shared_weak_count::__release_weak(v62);
      }
      uint64_t v9 = v61 + 2;
      if (v61 + 2 == v60) {
        return v66;
      }
    }
    int v12 = 0;
    uint64_t v68 = *(uint64_t **)(a1 + 8);
    while (1)
    {
      long long v80 = 0uLL;
      uint64_t v13 = *v11;
      int v14 = **v11;
      if (v14 == 3) {
        break;
      }
      if (v14 == 2)
      {
        uint64_t v21 = *((void *)v13 + 5);
        uint64_t v76 = geo::codec::Allocator::instance(v8);
        unint64_t v22 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v76 + 16))(v76, 8, 4);
        *(void *)&long long __dst = v22;
        int64_t v75 = (int64_t)(v22 + 1);
        if (v22) {
          *unint64_t v22 = v21;
        }
        unint64_t v23 = v4;
        *((void *)&__dst + 1) = v22 + 1;
        uint64_t v24 = (std::__shared_weak_count *)operator new(0x40uLL);
        unint64_t v25 = v3;
        v24->__shared_owners_ = 0;
        v24->__shared_weak_owners_ = 0;
        v24->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F680;
        *(void *)&long long v73 = FeatureStyleAttributes::FeatureStyleAttributes((uint64_t)&v24[1], (uint64_t *)&__dst);
        *((void *)&v73 + 1) = v24;
        uint64_t v26 = v68[1];
        uint64_t v27 = (md::LabelStyle *)v68[2];
        uint64_t v28 = *v68;
        uint64_t v70 = v73;
        int v71 = v24;
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        int v29 = *((_DWORD *)v13 + 10);
        uint64_t v30 = *((void *)v27 + 37);
        if (!v30)
        {
          uint64_t v31 = v28;
          uint64_t v32 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>((uint64_t)v27, 0);
          uint64_t v30 = *v32;
          *((void *)v27 + 37) = *v32;
          uint64_t v28 = v31;
        }
        char v33 = *(unsigned char *)(v30 + 93);
        v81[0] = 0;
        v81[1] = 0;
        uint64_t v82 = 0;
        float v84 = 0;
        v67 &= 0xFFFFFF00;
        md::LabelStyle::pointIcon((uint64_t *)&v72, v27, v28, v26, &v70, v67, 0, v29, 1, v33, 1, (uint64_t)v81);
        long long v34 = v72;
        long long v72 = 0uLL;
        long long v80 = v34;
        uint64_t v8 = v84;
        uint64_t v3 = v25;
        if (v84 == (geo::codec::Allocator *)v83)
        {
          uint64_t v8 = (geo::codec::Allocator *)(*(uint64_t (**)(void *))(v83[0] + 32))(v83);
          uint64_t v4 = v23;
        }
        else
        {
          uint64_t v4 = v23;
          if (v84) {
            uint64_t v8 = (geo::codec::Allocator *)(*(uint64_t (**)(geo::codec::Allocator *))(*(void *)v84 + 40))(v84);
          }
        }
        if (SHIBYTE(v82) < 0)
        {
          operator delete(v81[0]);
          int v43 = v71;
          if (!v71) {
            goto LABEL_39;
          }
        }
        else
        {
          int v43 = v71;
          if (!v71)
          {
LABEL_39:
            size_t v44 = (std::__shared_weak_count *)*((void *)&v73 + 1);
            if (*((void *)&v73 + 1)) {
              goto LABEL_40;
            }
            goto LABEL_51;
          }
        }
        if (atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
          goto LABEL_39;
        }
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
        size_t v44 = (std::__shared_weak_count *)*((void *)&v73 + 1);
        if (*((void *)&v73 + 1))
        {
LABEL_40:
          if (!atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
            std::__shared_weak_count::__release_weak(v44);
          }
        }
LABEL_51:
        uint64_t v40 = __dst;
        if ((void)__dst)
        {
          uint64_t v41 = v76;
          uint64_t v42 = v75 - __dst;
LABEL_53:
          uint64_t v8 = (geo::codec::Allocator *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v41 + 40))(v41, v40, v42);
        }
        goto LABEL_54;
      }
      if (v14 == 1)
      {
        uint64_t v15 = *((void *)v13 + 6);
        uint64_t v76 = *((void *)v13 + 4);
        if ((char)v13[31] < 0)
        {
          std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)&__dst, *((void **)v13 + 1), *((void *)v13 + 2));
        }
        else
        {
          long long v16 = *(_OWORD *)(v13 + 8);
          int64_t v75 = *((void *)v13 + 3);
          long long __dst = v16;
        }
        uint64_t v77 = v15;
        int v78 = *((_DWORD *)v13 + 14);
        char v79 = 2;
        uint64_t v36 = v68[1];
        uint64_t v35 = v68[2];
        uint64_t v37 = *v68;
        uint64_t v38 = *(void *)(v35 + 296);
        if (!v38)
        {
          uint64_t v39 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(v68[2], 0);
          uint64_t v38 = *v39;
          *(void *)(v35 + 296) = *v39;
        }
        md::LabelStyle::shieldIcon((uint64_t *)&v73, v35, v37, v36, (void **)&__dst, 0, *(char *)(v38 + 93));
        long long v80 = v73;
        goto LABEL_31;
      }
LABEL_57:
      unsigned int v57 = (std::__shared_weak_count *)*((void *)&v80 + 1);
      if (*((void *)&v80 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v80 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
        std::__shared_weak_count::__release_weak(v57);
      }
      v11 += 2;
      if (v11 == v69) {
        goto LABEL_67;
      }
    }
    uint64_t v17 = *((void *)v13 + 6);
    if (v17)
    {
      if ((atomic_load_explicit(v3, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire((__guard *)v3)) {
        operator new();
      }
      uint64_t v18 = *((void *)v4 + 91);
      uint64_t v19 = v68[2];
      uint64_t v20 = *(float **)(v19 + 280);
      if (v20)
      {
        if (vabds_f32(v20[2], *(float *)(v19 + 104)) >= 0.01)
        {
          md::LabelStyle::updateStyleGroup<md::LabelTextStyleGroup>((unsigned __int8 *)v68[2], (uint64_t)v20, 0);
          uint64_t v20 = *(float **)(v19 + 280);
        }
      }
      else
      {
        uint64_t v20 = (float *)md::LabelStyle::prepareStyleGroup<md::LabelTextStyleGroup>(v68[2], 0);
        *(void *)(v19 + 280) = v20;
      }
      int v45 = *(_DWORD *)(*(void *)v20 + 8);
      v64 &= 0xFFFFFFFFFFFFFFuLL;
      v65 &= 0xFFFFFFFFFFFFFF00;
      *(void *)&long long __dst = v65;
      int64_t v75 = v64;
      uint64_t v76 = v18;
      uint64_t v77 = v17;
      int v78 = v45;
      char v79 = 0;
      uint64_t v47 = v68[1];
      uint64_t v46 = v68[2];
      uint64_t v48 = *v68;
      uint64_t v49 = *(void *)(v46 + 296);
      if (!v49)
      {
        uint64_t v50 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(v68[2], 0);
        uint64_t v49 = *v50;
        *(void *)(v46 + 296) = *v50;
      }
      md::LabelStyle::shieldIcon((uint64_t *)&v73, v46, v48, v47, (void **)&__dst, 0, *(char *)(v49 + 93));
      long long v51 = v73;
      long long v73 = 0uLL;
      int v52 = (std::__shared_weak_count *)*((void *)&v80 + 1);
      long long v80 = v51;
      if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
        float v53 = (std::__shared_weak_count *)*((void *)&v73 + 1);
        if (!*((void *)&v73 + 1)) {
          goto LABEL_31;
        }
      }
      else
      {
        float v53 = (std::__shared_weak_count *)*((void *)&v73 + 1);
        if (!*((void *)&v73 + 1)) {
          goto LABEL_31;
        }
      }
      if (!atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
      }
LABEL_31:
      if (SHIBYTE(v75) < 0)
      {
        uint64_t v40 = __dst;
        uint64_t v41 = v76;
        uint64_t v42 = v75 & 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_53;
      }
    }
LABEL_54:
    if ((void)v80)
    {
      if ((atomic_load_explicit(v3, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire((__guard *)v3)) {
        operator new();
      }
      size_t v54 = (md::LabelPart *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v4 + 91) + 16))(*((void *)v4 + 91), 768, 8);
      double v55 = md::IconLabelPart::IconLabelPart((uint64_t)v54, &v80);
      (*(void (**)(uint64_t, uint64_t, double))(*(void *)v56 + 176))(v56, 10, v55);
      uint64_t v8 = (geo::codec::Allocator *)md::CompositeLabelPart::addLabelPart((uint64_t)v66, v54);
      ++v12;
    }
    goto LABEL_57;
  }
  return v66;
}

void sub_1A25828DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v15 - 176);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t md::TransitNodeLabelFeature::annotationTextIndex(uint64_t a1, void *a2, int a3)
{
  if (!(*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1))
  {
    if (*(unsigned char *)(a1 + 877)) {
      return *(unsigned __int8 *)(a1 + 878);
    }
    *(_WORD *)(a1 + 877) = -255;
    uint64_t v107 = 0;
    long long v108 = 0;
    std::mutex::lock((std::mutex *)(a1 + 8));
    uint64_t v8 = *(void *)(a1 + 152);
    if (!v8)
    {
      std::mutex::unlock((std::mutex *)(a1 + 8));
      goto LABEL_192;
    }
    uint64_t v9 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v8 + 16))(v8, &v107);
    std::mutex::unlock((std::mutex *)(a1 + 8));
    if (!v107 || !v9)
    {
LABEL_192:
      int64_t v75 = v108;
      if (v108 && !atomic_fetch_add(&v108->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
        std::__shared_weak_count::__release_weak(v75);
      }
      return *(unsigned __int8 *)(a1 + 878);
    }
    uint64_t v103 = 0;
    uint64_t v104 = 0;
    uint64_t v105 = 0;
    {
      operator new();
    }
    uint64_t v106 = mdm::Allocator::instance(void)::alloc;
    md::TransitNodeLabelFeature::populateAnnotationInfos((uint64_t)v9, &v103);
    uint64_t v10 = v103;
    if (v103 == v104) {
      goto LABEL_190;
    }
    float v101 = 0;
    uint64_t v102 = 0;
    unsigned int v99 = 0;
    unsigned int v100 = 0;
    unsigned __int8 v11 = atomic_load((unsigned __int8 *)(*a2 + 3392));
    if (v11) {
      geo::codec::transitNodeFeatureGetLocalizedParentheticalLabels(v9, (unint64_t *)&v102, (unint64_t *)&v101, (unint64_t *)&v100, &v99);
    }
    int v12 = v102;
    if (!v102 || (uint64_t v13 = v101) == 0 || (v14 = v100) == 0)
    {
      geo::codec::transitNodeFeatureGetNativeParentheticalLabels(v9, &v102, &v101, &v100, &v99);
      uint64_t v13 = v101;
      int v12 = v102;
      int v14 = v100;
    }
    if (!v12 || !v13 || !v14) {
      goto LABEL_189;
    }
    int v15 = *(_DWORD *)(a2[2] + 160);
    BOOL v76 = v15 < 1;
    if (v15 < 0) {
      int v15 = -v15;
    }
    int v80 = v15;
    {
      operator new();
    }
    uint64_t v98 = mdm::Allocator::instance(void)::alloc;
    size_t v16 = strlen(v13);
    if (v16 > 0x7FFFFFFFFFFFFFF7) {
      abort();
    }
    size_t v17 = v16;
    if (v16 >= 0x17)
    {
      uint64_t v19 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v16 | 7) != 0x17) {
        uint64_t v19 = v16 | 7;
      }
      uint64_t v20 = v19 + 1;
      p_dst = (long long *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                               + 16))(mdm::Allocator::instance(void)::alloc, v19 + 1, 1);
      *((void *)&__dst + 1) = v17;
      int64_t v97 = v20 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v97) = v16;
      p_dst = &__dst;
      if (!v16)
      {
LABEL_33:
        *((unsigned char *)p_dst + v17) = 0;
        float v93 = 0;
        {
          operator new();
        }
        uint64_t v94 = mdm::Allocator::instance(void)::alloc;
        uint64_t v95 = 0;
        float v92 = &v93;
        uint64_t v21 = v103;
        uint64_t v22 = v104;
        if (v103 == v104) {
          goto LABEL_187;
        }
        char v78 = 0;
        int v82 = 0;
        LOBYTE(v23) = 0;
        uint64_t v79 = v104;
        while (1)
        {
          if (v23) {
            goto LABEL_187;
          }
          if (*(_DWORD *)v21 != 2)
          {
            LOBYTE(v23) = 0;
            goto LABEL_37;
          }
          uint64_t v23 = *(void *)(v21 + 8);
          if (!v23) {
            goto LABEL_37;
          }
          unsigned __int8 v24 = atomic_load((unsigned __int8 *)(*a2 + 3392));
          __s[0] = 0;
          geo::codec::transitLineGetSubtitleNativeLabel(v23, __s, 0);
          localizedLabel((unint64_t)__src, (uint64_t *)v23, __s[0], v24 & 1, 0);
          int v25 = SHIBYTE(v87);
          if (v87 >= 0) {
            uint64_t v26 = (void *)HIBYTE(v87);
          }
          else {
            uint64_t v26 = __src[1];
          }
          if (!v26)
          {
            LOBYTE(v23) = 0;
            goto LABEL_145;
          }
          uint64_t v77 = __src[1];
          uint64_t v27 = v93;
          int v81 = SHIBYTE(v87);
          if (!v93)
          {
            uint64_t v37 = &v93;
            uint64_t v38 = &v93;
            if (v82 != v80) {
              goto LABEL_99;
            }
            char v36 = 0;
            LOBYTE(v23) = v76;
            int v82 = v80;
LABEL_74:
            uint64_t v22 = v79;
            int v25 = v81;
            goto LABEL_146;
          }
          if (v87 >= 0) {
            uint64_t v28 = __src;
          }
          else {
            uint64_t v28 = (void **)__src[0];
          }
          int v29 = v93;
          do
          {
            int v30 = *((char *)v29 + 55);
            if (v30 >= 0) {
              uint64_t v31 = v29 + 4;
            }
            else {
              uint64_t v31 = (const void *)v29[4];
            }
            if (v30 >= 0) {
              size_t v32 = *((unsigned __int8 *)v29 + 55);
            }
            else {
              size_t v32 = v29[5];
            }
            if (v32 >= (unint64_t)v26) {
              size_t v33 = (size_t)v26;
            }
            else {
              size_t v33 = v32;
            }
            int v34 = memcmp(v28, v31, v33);
            if (v34)
            {
              if (v34 < 0) {
                goto LABEL_52;
              }
            }
            else if ((unint64_t)v26 < v32)
            {
              goto LABEL_52;
            }
            int v35 = memcmp(v31, v28, v33);
            if (v35)
            {
              if ((v35 & 0x80000000) == 0)
              {
LABEL_68:
                LOBYTE(v23) = 0;
                char v36 = 1;
                goto LABEL_74;
              }
            }
            else if (v32 >= (unint64_t)v26)
            {
              goto LABEL_68;
            }
            ++v29;
LABEL_52:
            int v29 = (uint64_t *)*v29;
          }
          while (v29);
          if (v82 == v80)
          {
            char v36 = 0;
            LOBYTE(v23) = v76;
            int v82 = v80;
            goto LABEL_74;
          }
          uint64_t v37 = &v93;
          uint64_t v38 = &v93;
          if (v27)
          {
            if (v81 >= 0) {
              uint64_t v39 = __src;
            }
            else {
              uint64_t v39 = (void **)__src[0];
            }
            while (1)
            {
              uint64_t v38 = (uint64_t **)v27;
              int v40 = *((char *)v27 + 55);
              if (v40 >= 0) {
                uint64_t v41 = v27 + 4;
              }
              else {
                uint64_t v41 = (const void *)v27[4];
              }
              if (v40 >= 0) {
                size_t v42 = *((unsigned __int8 *)v27 + 55);
              }
              else {
                size_t v42 = v27[5];
              }
              if (v42 >= (unint64_t)v26) {
                size_t v43 = (size_t)v26;
              }
              else {
                size_t v43 = v42;
              }
              int v44 = memcmp(v39, v41, v43);
              if (v44)
              {
                if (v44 < 0) {
                  goto LABEL_79;
                }
LABEL_93:
                int v45 = memcmp(v41, v39, v43);
                if (v45)
                {
                  if ((v45 & 0x80000000) == 0) {
                    goto LABEL_105;
                  }
                }
                else if (v42 >= (unint64_t)v26)
                {
                  goto LABEL_105;
                }
                uint64_t v27 = v38[1];
                if (!v27)
                {
                  uint64_t v37 = v38 + 1;
                  break;
                }
              }
              else
              {
                if ((unint64_t)v26 >= v42) {
                  goto LABEL_93;
                }
LABEL_79:
                uint64_t v27 = *v38;
                uint64_t v37 = v38;
                if (!*v38) {
                  break;
                }
              }
            }
          }
LABEL_99:
          uint64_t v46 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v94 + 16))(v94, 64, 8);
          uint64_t v47 = (void **)(v46 + 4);
          v46[7] = v88;
          if (v81 < 0)
          {
            std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external(v47, __src[0], (unint64_t)v77);
          }
          else
          {
            *(_OWORD *)uint64_t v47 = *(_OWORD *)__src;
            v46[6] = v87;
          }
          *uint64_t v46 = 0;
          v46[1] = 0;
          v46[2] = (uint64_t)v38;
          *uint64_t v37 = v46;
          if (*v92)
          {
            float v92 = (uint64_t **)*v92;
            uint64_t v46 = *v37;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v93, v46);
          ++v95;
LABEL_105:
          uint64_t v22 = v79;
          if (v78)
          {
            size_t v48 = strlen(v102);
            size_t v49 = v48;
            if (v97 >= 0) {
              unint64_t v50 = 22;
            }
            else {
              unint64_t v50 = (v97 & 0x7FFFFFFFFFFFFFFFLL) - 1;
            }
            if (v97 >= 0) {
              size_t v51 = HIBYTE(v97);
            }
            else {
              size_t v51 = *((void *)&__dst + 1);
            }
            if (v50 - v51 >= v48)
            {
              if (v48)
              {
                if (v97 >= 0) {
                  int v52 = &__dst;
                }
                else {
                  int v52 = (long long *)__dst;
                }
                memmove((char *)v52 + v51, v102, v48);
                size_t v53 = v51 + v49;
                if (SHIBYTE(v97) < 0) {
                  *((void *)&__dst + 1) = v51 + v49;
                }
                else {
                  HIBYTE(v97) = v53 & 0x7F;
                }
                *((unsigned char *)v52 + v53) = 0;
              }
            }
            else
            {
              std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__grow_by_and_replace((char **)&__dst, v50, v48 - v50 + v51, v51, v51, v48, v102);
            }
          }
          int v25 = SHIBYTE(v87);
          if (v87 >= 0) {
            size_t v54 = __src;
          }
          else {
            size_t v54 = (void **)__src[0];
          }
          if (v87 >= 0) {
            size_t v55 = HIBYTE(v87);
          }
          else {
            size_t v55 = (size_t)__src[1];
          }
          if (v97 >= 0) {
            unint64_t v56 = 22;
          }
          else {
            unint64_t v56 = (v97 & 0x7FFFFFFFFFFFFFFFLL) - 1;
          }
          if (v97 >= 0) {
            size_t v57 = HIBYTE(v97);
          }
          else {
            size_t v57 = *((void *)&__dst + 1);
          }
          if (v56 - v57 >= v55)
          {
            if (v55)
            {
              if (v97 >= 0) {
                unsigned int v58 = &__dst;
              }
              else {
                unsigned int v58 = (long long *)__dst;
              }
              memmove((char *)v58 + v57, v54, v55);
              size_t v59 = v57 + v55;
              if (SHIBYTE(v97) < 0) {
                *((void *)&__dst + 1) = v57 + v55;
              }
              else {
                HIBYTE(v97) = v59 & 0x7F;
              }
              *((unsigned char *)v58 + v59) = 0;
            }
          }
          else
          {
            std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__grow_by_and_replace((char **)&__dst, v56, v55 - v56 + v57, v57, v57, v55, v54);
          }
          LOBYTE(v23) = 0;
          ++v82;
          char v78 = 1;
LABEL_145:
          char v36 = 1;
LABEL_146:
          if (v25 < 0) {
            (*(void (**)(uint64_t, void *, int64_t))(*(void *)v88 + 40))(v88, __src[0], v87 & 0x7FFFFFFFFFFFFFFFLL);
          }
          if ((v36 & 1) == 0)
          {
LABEL_149:
            if (v78 & 1) == 0 || (v23) {
              goto LABEL_187;
            }
            int v60 = (mdm::Allocator *)strlen(v100);
            int v61 = v60;
            if (v97 >= 0) {
              unint64_t v62 = 22;
            }
            else {
              unint64_t v62 = (v97 & 0x7FFFFFFFFFFFFFFFLL) - 1;
            }
            if (v97 >= 0) {
              size_t v63 = HIBYTE(v97);
            }
            else {
              size_t v63 = *((void *)&__dst + 1);
            }
            if (v62 - v63 >= (unint64_t)v60)
            {
              if (v60)
              {
                if (v97 >= 0) {
                  unint64_t v64 = &__dst;
                }
                else {
                  unint64_t v64 = (long long *)__dst;
                }
                int v60 = (mdm::Allocator *)memmove((char *)v64 + v63, v100, (size_t)v60);
                size_t v65 = (size_t)v61 + v63;
                if (SHIBYTE(v97) < 0) {
                  *((void *)&__dst + 1) = (char *)v61 + v63;
                }
                else {
                  HIBYTE(v97) = v65 & 0x7F;
                }
                *((unsigned char *)v64 + v65) = 0;
              }
            }
            else
            {
              int v60 = (mdm::Allocator *)std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__grow_by_and_replace((char **)&__dst, v62, (unint64_t)v60 + v63 - v62, v63, v63, (size_t)v60, v100);
            }
            if (v99) {
              uint64_t v66 = v99;
            }
            else {
              uint64_t v66 = "";
            }
            uint64_t v67 = mdm::Allocator::instance(v60);
            uint64_t v85 = v67;
            size_t v68 = strlen(v66);
            if (v68 > 0x7FFFFFFFFFFFFFF7) {
              abort();
            }
            char v69 = (char *)v68;
            if (v68 >= 0x17)
            {
              uint64_t v71 = (v68 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v68 | 7) != 0x17) {
                uint64_t v71 = v68 | 7;
              }
              uint64_t v72 = v71 + 1;
              uint64_t v70 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v67 + 16))(v67, v71 + 1, 1);
              __s[1] = v69;
              unint64_t v84 = v72 | 0x8000000000000000;
              __s[0] = v70;
            }
            else
            {
              HIBYTE(v84) = v68;
              uint64_t v70 = (char *)__s;
              if (!v68)
              {
LABEL_178:
                v69[(void)v70] = 0;
                uint64_t v88 = v98;
                if (SHIBYTE(v97) < 0)
                {
                  std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)__src, (void *)__dst, *((unint64_t *)&__dst + 1));
                }
                else
                {
                  *(_OWORD *)long long __src = __dst;
                  int64_t v87 = v97;
                }
                uint64_t v73 = v85;
                uint64_t v91 = v85;
                int v74 = SHIBYTE(v84);
                if (SHIBYTE(v84) < 0)
                {
                  std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)&v89, __s[0], (unint64_t)__s[1]);
                }
                else
                {
                  long long v89 = *(_OWORD *)__s;
                  unint64_t v90 = v84;
                }
                *(unsigned char *)(a1 + 878) = md::PointLabelFeature::indexForTextEntry((void *)a1, (uint64_t)__src);
                if (SHIBYTE(v90) < 0)
                {
                  (*(void (**)(uint64_t, void, unint64_t))(*(void *)v91 + 40))(v91, v89, v90 & 0x7FFFFFFFFFFFFFFFLL);
                  if (SHIBYTE(v87) < 0) {
                    goto LABEL_196;
                  }
LABEL_186:
                  if (v74 < 0) {
LABEL_197:
                  }
                    (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v73 + 40))(v73, __s[0], v84 & 0x7FFFFFFFFFFFFFFFLL);
                }
                else
                {
                  if ((SHIBYTE(v87) & 0x80000000) == 0) {
                    goto LABEL_186;
                  }
LABEL_196:
                  (*(void (**)(uint64_t, void *, int64_t))(*(void *)v88 + 40))(v88, __src[0], v87 & 0x7FFFFFFFFFFFFFFFLL);
                  if (v74 < 0) {
                    goto LABEL_197;
                  }
                }
LABEL_187:
                std::__tree<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::less<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,geo::StdAllocator<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,mdm::Allocator>>::destroy((uint64_t)&v92, (uint64_t)v93);
                if (SHIBYTE(v97) < 0) {
                  (*(void (**)(uint64_t, void, int64_t))(*(void *)v98 + 40))(v98, __dst, v97 & 0x7FFFFFFFFFFFFFFFLL);
                }
LABEL_189:
                uint64_t v10 = v103;
LABEL_190:
                if (v10)
                {
                  uint64_t v104 = v10;
                  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v106 + 40))(v106, v10, v105 - v10);
                }
                goto LABEL_192;
              }
            }
            memmove(v70, v66, (size_t)v69);
            goto LABEL_178;
          }
LABEL_37:
          v21 += 16;
          if (v21 == v22) {
            goto LABEL_149;
          }
        }
      }
    }
    memmove(p_dst, v13, v17);
    goto LABEL_33;
  }
  return md::PointLabelFeature::annotationTextIndex(a1, (uint64_t)a2, a3, v6);
}

void sub_1A25835C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
  if (SHIBYTE(a23) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a24 + 40))(a24, a21, a23 & 0x7FFFFFFFFFFFFFFFLL);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v37 + 40))(v37, v38, a19 & 0x7FFFFFFFFFFFFFFFLL);
  std::__tree<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::less<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,geo::StdAllocator<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,mdm::Allocator>>::destroy((uint64_t)&a30, a31);
  if (SHIBYTE(a36) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a37 + 40))(a37, a34, a36 & 0x7FFFFFFFFFFFFFFFLL);
  }
  uint64_t v41 = *(void *)(v39 - 136);
  if (v41) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v39 - 112) + 40))(*(void *)(v39 - 112), v41, *(void *)(v39 - 120) - v41);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v39 - 104);
  _Unwind_Resume(a1);
}

char *std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__grow_by_and_replace(char **a1, unint64_t a2, unint64_t a3, uint64_t a4, size_t a5, size_t a6, const void *a7)
{
  if (0x7FFFFFFFFFFFFFF6 - a2 < a3) {
    abort();
  }
  uint64_t v13 = (char *)a1;
  if (*((char *)a1 + 23) < 0) {
    uint64_t v13 = *a1;
  }
  unint64_t v14 = a3 + a2;
  if (a3 + a2 <= 2 * a2) {
    unint64_t v14 = 2 * a2;
  }
  uint64_t v15 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v14 | 7) != 0x17) {
    uint64_t v15 = v14 | 7;
  }
  if (v14 >= 0x17) {
    uint64_t v16 = v15 + 1;
  }
  else {
    uint64_t v16 = 23;
  }
  if (a2 > 0x3FFFFFFFFFFFFFF2) {
    uint64_t v17 = 0x7FFFFFFFFFFFFFF7;
  }
  else {
    uint64_t v17 = v16;
  }
  __n128 result = (char *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], v17, 1);
  uint64_t v19 = result;
  if (a5) {
    __n128 result = (char *)memmove(result, v13, a5);
  }
  if (a6) {
    __n128 result = (char *)memmove(&v19[a5], a7, a6);
  }
  if (a4 != a5) {
    __n128 result = (char *)memmove(&v19[a5 + a6], &v13[a5], a4 - a5);
  }
  if (a2 != 22) {
    __n128 result = (char *)(*(uint64_t (**)(char *, char *))(*(void *)a1[3] + 40))(a1[3], v13);
  }
  *a1 = v19;
  a1[1] = (char *)(a6 + a4);
  a1[2] = (char *)(v17 | 0x8000000000000000);
  v19[a6 + a4] = 0;
  return result;
}

uint64_t md::TransitNodeLabelFeature::iconColor@<X0>(md::TransitNodeLabelFeature *this@<X0>, const md::LabelIconStyleGroup *a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = (*(uint64_t (**)(md::TransitNodeLabelFeature *))(*(void *)this + 64))(this);
  int v7 = *((unsigned __int8 *)a2 + 89);
  if (!result
    || (v7 != 3 ? (BOOL v8 = v7 == 0) : (BOOL v8 = 1),
        !v8 || ((*(_DWORD *)a3 = *((_DWORD *)this + 218), a3[4] = 1, v7) ? (BOOL v9 = v7 == 3) : (BOOL v9 = 1), !v9)))
  {
    if ((v7 & 0xFFFFFFFD) != 0)
    {
      char v10 = 0;
      *a3 = 0;
    }
    else
    {
      *(_DWORD *)a3 = *((_DWORD *)a2 + 18);
      char v10 = 1;
    }
    a3[4] = v10;
  }
  return result;
}

uint64_t md::TransitNodeLabelFeature::newMultiPoiIconPart(md::TransitNodeLabelFeature *this, const md::PartCreationContext *a2)
{
  uint64_t v153 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)a2 + 2);
  uint64_t v4 = *(void *)(v3 + 296);
  if (!v4)
  {
    uint64_t v5 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*((void *)a2 + 2), 0);
    uint64_t v4 = *v5;
    *(void *)(v3 + 296) = *v5;
  }
  int v6 = *(_DWORD *)(v4 + 68);
  float v127 = 0;
  float v128 = 0;
  unint64_t v129 = 0;
  int v7 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    operator new();
  }
  uint64_t v130 = mdm::Allocator::instance(void)::alloc;
  long long __dst = 0;
  *(void *)uint64_t v124 = 0;
  uint64_t v125 = 0;
  {
    operator new();
  }
  uint64_t v126 = mdm::Allocator::instance(void)::alloc;
  switch(v6)
  {
    case '%':
      int v115 = 37;
      unint64_t v56 = (char *)*((void *)this + 100);
      size_t v57 = (char *)*((void *)this + 101);
      int64_t v58 = v57 - v56;
      unint64_t v59 = (v57 - v56) >> 2;
      int v60 = (char *)__dst;
      if (v59 <= (v125 - (uint64_t)__dst) >> 2)
      {
        unint64_t v66 = (uint64_t)(*(void *)v124 - (void)__dst) >> 2;
        if (v66 < v59)
        {
          uint64_t v67 = &v56[4 * v66];
          size_t v68 = __dst;
          char v69 = (char *)__dst;
          if (v67 != v57)
          {
            char v69 = (char *)__dst;
            do
            {
              if (v69) {
                *(_DWORD *)char v69 = *(_DWORD *)v67;
              }
              v67 += 4;
              v69 += 4;
            }
            while (v67 != v57);
          }
          int64_t v58 = v69 - v68;
LABEL_145:
          *(void *)uint64_t v124 = &v68[v58];
          if (v60 == &v68[v58]) {
            goto LABEL_204;
          }
LABEL_146:
          _ZNSt3__115allocate_sharedB8nn180100I22FeatureStyleAttributesNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v148);
          int v70 = v115;
          if (v127 == v128) {
            int v70 = 37;
          }
          int v115 = v70;
          std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>();
          uint64_t v71 = (unsigned int *)__dst;
          uint64_t v72 = *(void *)v124;
          if (__dst == *(void **)v124) {
            goto LABEL_157;
          }
          uint64_t v73 = (int *)((char *)__dst + 4);
          do
          {
            if (v73 == *(int **)v124) {
              goto LABEL_157;
            }
            int v74 = v73 - 1;
            int v75 = *(v73 - 1);
            int v76 = *v73++;
          }
          while (v75 != v76);
          for (unsigned __int8 i = v74 + 2; i != (int *)v72; ++i)
          {
            int v78 = v75;
            int v75 = *i;
            if (v78 != *i)
            {
              v74[1] = v75;
              ++v74;
            }
          }
          uint64_t v79 = (char *)(v74 + 1);
          uint64_t v80 = v72 - (void)(v74 + 1);
          if (!v80)
          {
LABEL_157:
            if (v71 != (unsigned int *)v72) {
              goto LABEL_165;
            }
          }
          else
          {
            uint64_t v81 = v72 - (void)&v79[v80];
            if ((char *)v72 != &v79[v80]) {
              memmove(v79, &v79[v80], v72 - (void)&v79[v80]);
            }
            uint64_t v72 = (uint64_t)&v79[v81];
            *(void *)uint64_t v124 = &v79[v81];
            while (v71 != (unsigned int *)v72)
            {
LABEL_165:
              uint64_t v82 = *v71;
              float v83 = v148;
              uint64_t v84 = *((unsigned __int8 *)v148 + 33);
              uint64_t v85 = *v148;
              if (*((unsigned char *)v148 + 33))
              {
                if (v84 >= 0x20)
                {
                  uint64_t v86 = 0;
                  unint64_t v90 = (int *)*v148;
                  while (1)
                  {
                    int v91 = *v90;
                    v90 += 2;
                    if (v91 == 37) {
                      break;
                    }
                    if (v84 == ++v86) {
                      goto LABEL_176;
                    }
                  }
                }
                else
                {
                  uint64_t v86 = 0;
                  int64_t v87 = (int *)*v148;
                  while (1)
                  {
                    int v88 = *v87;
                    v87 += 2;
                    if (v88 == 37) {
                      break;
                    }
                    if (v84 == ++v86) {
                      goto LABEL_170;
                    }
                  }
                }
                *(_DWORD *)(v85 + 8 * v86 + 4) = v82;
              }
              else
              {
LABEL_170:
                *(void *)(v85 + 8 * v84) = (v82 << 32) | 0x25;
                unsigned __int8 v89 = *((unsigned char *)v83 + 33) + 1;
                *((unsigned char *)v83 + 33) = v89;
                qsort((void *)*v83, v89, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
              }
LABEL_176:
              uint64_t v93 = *((void *)a2 + 1);
              float v92 = (md::LabelStyle *)*((void *)a2 + 2);
              uint64_t v94 = *(void *)a2;
              uint64_t v95 = (std::__shared_weak_count *)v149;
              uint64_t v136 = v83;
              uint64_t v137 = v149;
              if (v149) {
                atomic_fetch_add_explicit(v149 + 1, 1uLL, memory_order_relaxed);
              }
              __p[0] = 0;
              __p[1] = 0;
              uint64_t v141 = 0;
              uint64_t v143 = 0;
              md::LabelStyle::pointIcon((uint64_t *)&v144, v92, v94, v93, (uint64_t *)&v136, 0, 0, 37, 0, 255, 0, (uint64_t)__p);
              if (v143 == v142)
              {
                (*(void (**)(void *))(v142[0] + 32))(v142);
                if ((SHIBYTE(v141) & 0x80000000) == 0) {
                  goto LABEL_182;
                }
              }
              else
              {
                if (v143) {
                  (*(void (**)(void))(*v143 + 40))();
                }
                if ((SHIBYTE(v141) & 0x80000000) == 0)
                {
LABEL_182:
                  if (!v95) {
                    goto LABEL_187;
                  }
                  goto LABEL_186;
                }
              }
              operator delete(__p[0]);
              if (!v95) {
                goto LABEL_187;
              }
LABEL_186:
              if (atomic_fetch_add(&v95->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
LABEL_187:
                uint64_t v96 = v144;
                if ((void)v144) {
                  goto LABEL_188;
                }
                goto LABEL_195;
              }
              ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
              std::__shared_weak_count::__release_weak(v95);
              uint64_t v96 = v144;
              if ((void)v144)
              {
LABEL_188:
                int64_t v97 = v128;
                if ((unint64_t)v128 >= v129)
                {
                  unsigned int v99 = (char *)std::vector<std::shared_ptr<md::LabelMarker>,geo::StdAllocator<std::shared_ptr<md::LabelMarker>,mdm::Allocator>>::__push_back_slow_path<std::shared_ptr<md::LabelMarker> const&>((uint64_t)&v127, &v144);
                }
                else
                {
                  if (v128)
                  {
                    *(void *)float v128 = v96;
                    uint64_t v98 = *((void *)&v144 + 1);
                    *((void *)v97 + 1) = *((void *)&v144 + 1);
                    if (v98) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v98 + 8), 1uLL, memory_order_relaxed);
                    }
                  }
                  unsigned int v99 = v97 + 16;
                }
                float v128 = v99;
              }
LABEL_195:
              unsigned int v100 = (std::__shared_weak_count *)*((void *)&v144 + 1);
              if (*((void *)&v144 + 1)
                && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v144 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
                std::__shared_weak_count::__release_weak(v100);
              }
              ++v71;
            }
          }
          float v101 = (std::__shared_weak_count *)v149;
          if (v149 && !atomic_fetch_add(v149 + 1, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
            std::__shared_weak_count::__release_weak(v101);
          }
          int v7 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
          goto LABEL_204;
        }
        if (v57 != v56) {
          memmove(__dst, v56, v57 - v56);
        }
      }
      else
      {
        if (v58 < 0) {
          goto LABEL_234;
        }
        unint64_t v61 = v125 >> 1;
        if (v125 >> 1 <= v59) {
          unint64_t v61 = (v57 - v56) >> 2;
        }
        unint64_t v62 = v61;
        if (v61 >> 62) {
LABEL_234:
        }
          abort();
        size_t v63 = (char *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                    + 16))(mdm::Allocator::instance(void)::alloc, 4 * v61, 4);
        int v60 = v63;
        long long __dst = v63;
        uint64_t v125 = (uint64_t)&v63[4 * v62];
        unint64_t v64 = v63;
        if (v56 != v57)
        {
          unint64_t v64 = v63;
          do
          {
            if (v64) {
              *(_DWORD *)unint64_t v64 = *(_DWORD *)v56;
            }
            v56 += 4;
            v64 += 4;
          }
          while (v56 != v57);
        }
        int64_t v58 = v64 - v63;
      }
      size_t v68 = v60;
      goto LABEL_145;
    case '1':
      int v8 = 0;
      break;
    case '2':
      int v8 = 1;
      break;
    default:
      uint64_t v65 = 0;
      goto LABEL_218;
  }
  BOOL v9 = (md::LabelStyle *)*((void *)a2 + 2);
  uint64_t v121 = *((void *)a2 + 1);
  uint64_t v122 = *(void *)a2;
  uint64_t v137 = 0;
  {
    operator new();
  }
  int v115 = v6;
  uint64_t v138 = mdm::Allocator::instance(void)::alloc;
  uint64_t v139 = 0;
  uint64_t v136 = (uint64_t *)&v137;
  char v10 = (unsigned int *)*((void *)this + 88);
  unsigned __int8 v11 = (unsigned int *)*((void *)this + 89);
  if (v10 != v11)
  {
    int v117 = v8;
    uint64_t v116 = (unsigned int *)*((void *)this + 89);
    while (1)
    {
      if (v8 && *((_WORD *)v10 + 3))
      {
        _ZNSt3__115allocate_sharedB8nn180100I22FeatureStyleAttributesNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v134);
        unsigned __int16 v12 = *((_WORD *)v10 + 3);
        if (v12)
        {
          char v120 = 0;
          uint64_t v13 = 0;
          while (1)
          {
            uint64_t v14 = *(unsigned int *)(*((void *)this + 96) + 4 * (v13 + *((unsigned __int16 *)v10 + 2)));
            for (unsigned __int8 j = v137; j; unsigned __int8 j = (uint64_t *)*j)
            {
              unsigned int v23 = *((_DWORD *)j + 7);
              if (v14 >= v23)
              {
                if (v23 >= v14) {
                  goto LABEL_20;
                }
                ++j;
              }
            }
            uint64_t v16 = v134;
            uint64_t v17 = *(unsigned __int8 *)(v134 + 33);
            uint64_t v18 = *(int **)v134;
            if (*(unsigned char *)(v134 + 33))
            {
              if (v17 >= 0x20)
              {
                uint64_t v19 = 0;
                unsigned __int8 v24 = *(int **)v134;
                while (1)
                {
                  int v25 = *v24;
                  v24 += 2;
                  if (v25 == 50) {
                    break;
                  }
                  if (v17 == ++v19) {
                    goto LABEL_37;
                  }
                }
              }
              else
              {
                uint64_t v19 = 0;
                uint64_t v20 = *(int **)v134;
                while (1)
                {
                  int v21 = *v20;
                  v20 += 2;
                  if (v21 == 50) {
                    break;
                  }
                  if (v17 == ++v19) {
                    goto LABEL_27;
                  }
                }
              }
              v18[2 * v19 + 1] = v14;
            }
            else
            {
LABEL_27:
              *(void *)&v18[2 * v17] = (v14 << 32) | 0x32;
              unsigned __int8 v22 = *(unsigned char *)(v16 + 33) + 1;
              *(unsigned char *)(v16 + 33) = v22;
              qsort(*(void **)v16, v22, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
            }
LABEL_37:
            uint64_t v26 = v135;
            uint64_t v131 = v16;
            float v132 = v135;
            if (v135) {
              atomic_fetch_add_explicit(&v135->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            v6 &= 0xFFFFFF00;
            unint64_t v148 = 0;
            unint64_t v149 = 0;
            uint64_t v150 = 0;
            uint64_t v152 = 0;
            md::LabelStyle::pointIcon((uint64_t *)&v133, v9, v122, v121, &v131, v6, 0, 50, 0, 255, 0, (uint64_t)&v148);
            if (v152 == v151)
            {
              (*(void (**)(void *))(v151[0] + 32))(v151);
              if ((SHIBYTE(v150) & 0x80000000) == 0) {
                goto LABEL_43;
              }
            }
            else
            {
              if (v152) {
                (*(void (**)(void *))(*v152 + 40))(v152);
              }
              if ((SHIBYTE(v150) & 0x80000000) == 0)
              {
LABEL_43:
                if (!v26) {
                  goto LABEL_48;
                }
                goto LABEL_47;
              }
            }
            operator delete(v148);
            if (!v26) {
              goto LABEL_48;
            }
LABEL_47:
            if (atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
LABEL_48:
              uint64_t v27 = v133;
              if (!(void)v133) {
                goto LABEL_68;
              }
              goto LABEL_49;
            }
            ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
            std::__shared_weak_count::__release_weak(v26);
            uint64_t v27 = v133;
            if (!(void)v133)
            {
LABEL_68:
              char v120 = 1;
              char v36 = (std::__shared_weak_count *)*((void *)&v133 + 1);
              if (!*((void *)&v133 + 1)) {
                goto LABEL_19;
              }
LABEL_69:
              if (!atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
                std::__shared_weak_count::__release_weak(v36);
              }
              goto LABEL_19;
            }
LABEL_49:
            uint64_t v28 = v128;
            if ((unint64_t)v128 >= v129)
            {
              int v30 = (char *)std::vector<std::shared_ptr<md::LabelMarker>,geo::StdAllocator<std::shared_ptr<md::LabelMarker>,mdm::Allocator>>::__push_back_slow_path<std::shared_ptr<md::LabelMarker> const&>((uint64_t)&v127, &v133);
            }
            else
            {
              if (v128)
              {
                *(void *)float v128 = v27;
                uint64_t v29 = *((void *)&v133 + 1);
                *((void *)v28 + 1) = *((void *)&v133 + 1);
                if (v29) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v29 + 8), 1uLL, memory_order_relaxed);
                }
              }
              int v30 = v28 + 16;
            }
            float v128 = v30;
            uint64_t v31 = v137;
            size_t v32 = &v137;
            size_t v33 = &v137;
            if (v137)
            {
              while (1)
              {
                while (1)
                {
                  size_t v33 = (uint64_t **)v31;
                  unsigned int v34 = *((_DWORD *)v31 + 7);
                  if (v14 >= v34) {
                    break;
                  }
                  uint64_t v31 = *v33;
                  size_t v32 = v33;
                  if (!*v33) {
                    goto LABEL_62;
                  }
                }
                if (v34 >= v14) {
                  break;
                }
                uint64_t v31 = v33[1];
                if (!v31)
                {
                  size_t v32 = v33 + 1;
                  goto LABEL_62;
                }
              }
            }
            else
            {
LABEL_62:
              uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v138 + 16))(v138, 32, 8);
              *(_DWORD *)(v35 + 28) = v14;
              *(void *)uint64_t v35 = 0;
              *(void *)(v35 + 8) = 0;
              *(void *)(v35 + 16) = v33;
              uint64_t *v32 = (uint64_t *)v35;
              if (*v136)
              {
                uint64_t v136 = (uint64_t *)*v136;
                uint64_t v35 = (uint64_t)*v32;
              }
              std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v137, (uint64_t *)v35);
              ++v139;
            }
            char v36 = (std::__shared_weak_count *)*((void *)&v133 + 1);
            if (*((void *)&v133 + 1)) {
              goto LABEL_69;
            }
LABEL_19:
            unsigned __int16 v12 = *((_WORD *)v10 + 3);
LABEL_20:
            if (++v13 >= (unint64_t)v12) {
              goto LABEL_72;
            }
          }
        }
        char v120 = 0;
LABEL_72:
        uint64_t v37 = v135;
        if (v135 && !atomic_fetch_add(&v135->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
        int v8 = v117;
        unsigned __int8 v11 = v116;
        if ((v120 & 1) == 0) {
          goto LABEL_14;
        }
      }
      if (!*v10)
      {
LABEL_83:
        if (*((unsigned char *)v10 + 9)) {
          std::vector<unsigned int,geo::StdAllocator<unsigned int,mdm::Allocator>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned int *>,std::__wrap_iter<unsigned int *>>((uint64_t *)&__dst, *(uint64_t *)v124, (char *)(*((void *)this + 92) + 4 * *((unsigned __int8 *)v10 + 8)), (char *)(*((void *)this + 92)+ 4 * (*((unsigned __int8 *)v10 + 8) + (unint64_t)*((unsigned __int8 *)v10 + 9))), *((unsigned __int8 *)v10 + 9));
        }
        goto LABEL_14;
      }
      _ZNSt3__115allocate_sharedB8nn180100I22FeatureStyleAttributesNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v134);
      uint64_t v38 = *v10;
      uint64_t v39 = v134;
      uint64_t v40 = *(unsigned __int8 *)(v134 + 33);
      uint64_t v41 = *(int **)v134;
      if (*(unsigned char *)(v134 + 33))
      {
        if (v40 >= 0x20)
        {
          uint64_t v42 = 0;
          uint64_t v46 = *(int **)v134;
          while (1)
          {
            int v47 = *v46;
            v46 += 2;
            if (v47 == 49) {
              break;
            }
            if (v40 == ++v42) {
              goto LABEL_90;
            }
          }
        }
        else
        {
          uint64_t v42 = 0;
          size_t v43 = *(int **)v134;
          while (1)
          {
            int v44 = *v43;
            v43 += 2;
            if (v44 == 49) {
              break;
            }
            if (v40 == ++v42) {
              goto LABEL_82;
            }
          }
        }
        v41[2 * v42 + 1] = v38;
      }
      else
      {
LABEL_82:
        *(void *)&v41[2 * v40] = (v38 << 32) | 0x31;
        unsigned __int8 v45 = *(unsigned char *)(v39 + 33) + 1;
        *(unsigned char *)(v39 + 33) = v45;
        qsort(*(void **)v39, v45, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
      }
LABEL_90:
      size_t v48 = v135;
      uint64_t v131 = v39;
      float v132 = v135;
      if (v135) {
        atomic_fetch_add_explicit(&v135->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      long long v144 = 0uLL;
      uint64_t v145 = 0;
      uint64_t v147 = 0;
      md::LabelStyle::pointIcon((uint64_t *)&v133, v9, v122, v121, &v131, v118 & 0xFFFFFF00, 0, 49, 0, 255, 0, (uint64_t)&v144);
      if (v147 == v146)
      {
        (*(void (**)(void *))(v146[0] + 32))(v146);
        if ((SHIBYTE(v145) & 0x80000000) == 0) {
          goto LABEL_96;
        }
      }
      else
      {
        if (v147) {
          (*(void (**)(void *))(*v147 + 40))(v147);
        }
        if ((SHIBYTE(v145) & 0x80000000) == 0)
        {
LABEL_96:
          v118 &= 0xFFFFFF00;
          if (!v48) {
            goto LABEL_101;
          }
          goto LABEL_100;
        }
      }
      operator delete((void *)v144);
      v118 &= 0xFFFFFF00;
      if (!v48) {
        goto LABEL_101;
      }
LABEL_100:
      if (atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
LABEL_101:
        uint64_t v49 = v133;
        if (!(void)v133) {
          goto LABEL_109;
        }
        goto LABEL_102;
      }
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
      uint64_t v49 = v133;
      if (!(void)v133) {
        goto LABEL_109;
      }
LABEL_102:
      unint64_t v50 = v128;
      if ((unint64_t)v128 >= v129)
      {
        int v52 = (char *)std::vector<std::shared_ptr<md::LabelMarker>,geo::StdAllocator<std::shared_ptr<md::LabelMarker>,mdm::Allocator>>::__push_back_slow_path<std::shared_ptr<md::LabelMarker> const&>((uint64_t)&v127, &v133);
      }
      else
      {
        if (v128)
        {
          *(void *)float v128 = v49;
          uint64_t v51 = *((void *)&v133 + 1);
          *((void *)v50 + 1) = *((void *)&v133 + 1);
          if (v51) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v51 + 8), 1uLL, memory_order_relaxed);
          }
        }
        int v52 = v50 + 16;
      }
      float v128 = v52;
LABEL_109:
      size_t v53 = (std::__shared_weak_count *)*((void *)&v133 + 1);
      if (*((void *)&v133 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v133 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
        size_t v54 = v135;
        if (!v135) {
          goto LABEL_13;
        }
      }
      else
      {
        size_t v54 = v135;
        if (!v135) {
          goto LABEL_13;
        }
      }
      if (!atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
        std::__shared_weak_count::__release_weak(v54);
      }
LABEL_13:
      if (!v49) {
        goto LABEL_83;
      }
LABEL_14:
      v10 += 3;
      if (v10 == v11)
      {
        size_t v55 = v137;
        int v7 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
        goto LABEL_131;
      }
    }
  }
  size_t v55 = 0;
LABEL_131:
  std::__tree<unsigned int,std::less<unsigned int>,geo::StdAllocator<unsigned int,mdm::Allocator>>::destroy((uint64_t)&v136, v55);
  if (__dst != *(void **)v124) {
    goto LABEL_146;
  }
LABEL_204:
  if (v127 == v128)
  {
    uint64_t v65 = 0;
  }
  else
  {
    int64_t v102 = v128 - v127;
    if (v102 == 16)
    {
        operator new();
      uint64_t v65 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v7 + 91) + 16))(*((void *)v7 + 91), 840, 8);
      md::PointIconLabelPart::PointIconLabelPart(v65, v127, *(void *)a2, *((void *)a2 + 1), *((md::LabelStyle **)a2 + 2), v115);
    }
    else
    {
        operator new();
      uint64_t v65 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v7 + 91) + 16))(*((void *)v7 + 91), 760, 8);
      uint64_t v104 = *((void *)a2 + 2);
      uint64_t v105 = (void *)md::StackLabelPart::StackLabelPart(v65, 1);
      *uint64_t v105 = &unk_1EF53FAC8;
      md::LabelIconStyleMonitor::LabelIconStyleMonitor((uint64_t)(v105 + 87), v104);
      *(_DWORD *)(v65 + 752) = v115;
      *(unsigned char *)(v65 + 756) = 1;
      *(unsigned char *)(v65 + 630) = 1;
      uint64_t v106 = v127;
      for (double k = v128; v106 != k; v106 += 16)
      {
        {
          operator new();
        }
        long long v108 = (md::LabelPart *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v7 + 91) + 16))(*((void *)v7 + 91), 768, 8);
        double v109 = md::IconLabelPart::IconLabelPart((uint64_t)v108, v106);
        (*(void (**)(uint64_t, uint64_t, double))(*(void *)v110 + 176))(v110, 4, v109);
        md::CompositeLabelPart::addLabelPart(v65, v108);
      }
    }
  }
  if (__dst)
  {
    *(void *)uint64_t v124 = __dst;
    (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v126 + 40))(v126, __dst, v125 - (void)__dst);
  }
LABEL_218:
  uint64_t v111 = v127;
  if (v127)
  {
    uint64_t v112 = v128;
    if (v128 != v127)
    {
      do
      {
        unsigned int v113 = (std::__shared_weak_count *)*((void *)v112 - 1);
        if (v113 && !atomic_fetch_add(&v113->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
          std::__shared_weak_count::__release_weak(v113);
        }
        v112 -= 16;
      }
      while (v112 != v111);
      uint64_t v111 = v127;
    }
    (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v130 + 40))(v130, v111, v129 - (void)v111);
  }
  return v65;
}

void sub_1A2584C28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,char a30,uint64_t a31,char a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  md::CompositeLabelPart::~CompositeLabelPart(v38);
  uint64_t v41 = mdm::Allocator::instance(v40);
  (*(void (**)(uint64_t, md::CompositeLabelPart *, uint64_t))(*(void *)v41 + 40))(v41, v38, 760);
  if (a20) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a23 + 40))(a23, a20, a22 - a20);
  }
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100](&a24);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<unsigned int,geo::StdAllocator<unsigned int,mdm::Allocator>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned int *>,std::__wrap_iter<unsigned int *>>(uint64_t *result, uint64_t a2, char *__src, char *a4, uint64_t a5)
{
  if (a5 < 1) {
    return result;
  }
  int v6 = __src;
  uint64_t v7 = (uint64_t)result;
  uint64_t v9 = *result;
  unint64_t v8 = result[1];
  uint64_t v10 = a2 - *result;
  unsigned __int8 v11 = (int *)(*result + (v10 & 0xFFFFFFFFFFFFFFFCLL));
  uint64_t v12 = result[2];
  if (a5 > (uint64_t)(v12 - v8) >> 2)
  {
    unint64_t v13 = a5 + ((uint64_t)(v8 - v9) >> 2);
    if (v13 >> 62) {
      abort();
    }
    uint64_t v14 = v10 >> 2;
    uint64_t v15 = v12 - v9;
    if (v15 >> 1 > v13) {
      unint64_t v13 = v15 >> 1;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL) {
      uint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v16 = v13;
    }
    if (v16) {
      uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)result[3] + 16))(result[3], 4 * v16, 4);
    }
    else {
      uint64_t result = 0;
    }
    int v21 = (_DWORD *)result + v14;
    uint64_t v22 = 4 * a5;
    unsigned int v23 = &v21[a5];
    uint64_t v24 = 4 * a5;
    int v25 = v21;
    do
    {
      if (v25) {
        *int v25 = *(_DWORD *)v6;
      }
      ++v25;
      v6 += 4;
      v24 -= 4;
    }
    while (v24);
    uint64_t v26 = *(int **)v7;
    if (*(int **)v7 == v11) {
      goto LABEL_31;
    }
    uint64_t v27 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + v9;
    unint64_t v28 = v27 - (void)v26 - 4;
    if (v28 >= 0x3C)
    {
      uint64_t v29 = v11;
      if (v27 - ((unint64_t)result + (v10 & 0xFFFFFFFFFFFFFFFCLL)) >= 0x20)
      {
        uint64_t v30 = (v28 >> 2) + 1;
        uint64_t v29 = &v11[-(v30 & 0x7FFFFFFFFFFFFFF8)];
        uint64_t v31 = 4 * v14 - 16;
        size_t v32 = (long long *)(v9 + v31);
        size_t v33 = (_OWORD *)((char *)result + v31);
        uint64_t v34 = v30 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v35 = *v32;
          *(v33 - 1) = *(v32 - 1);
          *size_t v33 = v35;
          v32 -= 2;
          v33 -= 2;
          v34 -= 8;
        }
        while (v34);
        v21 -= v30 & 0x7FFFFFFFFFFFFFF8;
        if (v30 == (v30 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_31;
        }
      }
    }
    else
    {
      uint64_t v29 = v11;
    }
    do
    {
      int v36 = *--v29;
      *--int v21 = v36;
    }
    while (v29 != v26);
LABEL_31:
    uint64_t v37 = *(int **)(v7 + 8);
    if (v37 != v11)
    {
      uint64_t v38 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + v9;
      unint64_t v39 = (unint64_t)v37 - v38 - 4;
      if (v39 < 0x3C) {
        goto LABEL_59;
      }
      if ((unint64_t)result + (v10 & 0xFFFFFFFFFFFFFFFCLL) + v22 - v38 < 0x20) {
        goto LABEL_59;
      }
      uint64_t v40 = (v39 >> 2) + 1;
      uint64_t v41 = 4 * (v40 & 0x7FFFFFFFFFFFFFF8);
      unsigned __int8 v11 = (int *)((char *)v11 + v41);
      uint64_t v42 = (_OWORD *)((char *)result + 4 * v14 + v22 + 16);
      size_t v43 = (long long *)(4 * v14 + v9 + 16);
      uint64_t v44 = v40 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v45 = *v43;
        *(v42 - 1) = *(v43 - 1);
        *uint64_t v42 = v45;
        v42 += 2;
        v43 += 2;
        v44 -= 8;
      }
      while (v44);
      unsigned int v23 = (_DWORD *)((char *)v23 + v41);
      if (v40 != (v40 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_59:
        do
        {
          int v46 = *v11++;
          *v23++ = v46;
        }
        while (v11 != v37);
      }
    }
    *(void *)uint64_t v7 = v21;
    *(void *)(v7 + 8) = v23;
    *(void *)(v7 + 16) = (char *)result + 4 * v16;
    if (v26)
    {
      int v47 = *(uint64_t (**)(void))(**(void **)(v7 + 24) + 40);
      return (uint64_t *)v47();
    }
    return result;
  }
  uint64_t v17 = (uint64_t)(v8 - (void)v11) >> 2;
  if (v17 >= a5)
  {
    uint64_t v18 = &__src[4 * a5];
    uint64_t v20 = (char *)result[1];
LABEL_44:
    size_t v48 = (char *)&v11[a5];
    uint64_t v49 = &v20[-4 * a5];
    unint64_t v50 = v20;
    if ((unint64_t)v49 < v8)
    {
      unint64_t v50 = v20;
      do
      {
        if (v50) {
          *(_DWORD *)unint64_t v50 = *(_DWORD *)v49;
        }
        v49 += 4;
        v50 += 4;
      }
      while ((unint64_t)v49 < v8);
    }
    result[1] = (uint64_t)v50;
    if (v20 != v48) {
      uint64_t result = (uint64_t *)memmove(&v20[-4 * ((v20 - v48) >> 2)], v11, v20 - v48);
    }
    if (v18 != v6)
    {
      return (uint64_t *)memmove(v11, v6, v18 - v6);
    }
    return result;
  }
  uint64_t v18 = &__src[4 * v17];
  if (v18 == a4)
  {
    uint64_t v20 = (char *)result[1];
  }
  else
  {
    uint64_t v19 = &__src[4 * v17];
    uint64_t v20 = (char *)result[1];
    do
    {
      if (v20) {
        *(_DWORD *)uint64_t v20 = *(_DWORD *)v19;
      }
      v19 += 4;
      v20 += 4;
    }
    while (v19 != a4);
  }
  result[1] = (uint64_t)v20;
  if ((uint64_t)(v8 - (void)v11) >= 1) {
    goto LABEL_44;
  }
  return result;
}

md::BalloonLabelPart *md::TransitNodeLabelFeature::newIconPart(md::TransitNodeLabelFeature *this, const md::PartCreationContext *a2)
{
  uint64_t v4 = *((void *)a2 + 2);
  uint64_t v5 = *(void *)(v4 + 296);
  if (!v5)
  {
    int v6 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*((void *)a2 + 2), 0);
    uint64_t v5 = *v6;
    *(void *)(v4 + 296) = *v6;
  }
  if (*(unsigned char *)(v5 + 88) == 6)
  {
    if ((*(uint64_t (**)(md::TransitNodeLabelFeature *))(*(void *)this + 64))(this)) {
      return 0;
    }
    {
      operator new();
    }
    uint64_t v7 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                      + 16))(mdm::Allocator::instance(void)::alloc, 824, 8);
    size_t v57 = (uint64_t *)**((void **)a2 + 8);
    uint64_t v59 = *((void *)a2 + 1);
    uint64_t v58 = *((void *)a2 + 2);
    uint64_t v60 = *(void *)a2;
    *((_DWORD *)v7 + 2) = 1065353216;
    *((void *)v7 + 2) = 0;
    *((void *)v7 + 3) = v7;
    *((void *)v7 + 8) = 0;
    *(_OWORD *)(v7 + 72) = xmmword_1A28FC750;
    *((_OWORD *)v7 + 2) = 0u;
    *((_OWORD *)v7 + 3) = 0u;
    *((void *)v7 + 11) = 1065353216;
    *((_DWORD *)v7 + 24) = 1065353216;
    *((_DWORD *)v7 + 29) = 0;
    *(void *)(v7 + 100) = 0;
    *(void *)(v7 + 108) = 0;
    *(_OWORD *)(v7 + 120) = xmmword_1A28FC750;
    *(_OWORD *)(v7 + 136) = xmmword_1A28FC750;
    *(_OWORD *)(v7 + 152) = xmmword_1A28FC750;
    *(_OWORD *)(v7 + 168) = xmmword_1A28FCDA0;
    v7[224] = 0;
    *((void *)v7 + 23) = 0;
    *((void *)v7 + 24) = 0;
    v7[200] = 0;
    *(_OWORD *)(v7 + 232) = 0u;
    *(_OWORD *)(v7 + 248) = 0u;
    *(_OWORD *)(v7 + 257) = 0u;
    *(_OWORD *)(v7 + 280) = xmmword_1A28FCE90;
    *(_OWORD *)(v7 + 296) = xmmword_1A28FCEA0;
    *(_OWORD *)(v7 + 312) = xmmword_1A28FC750;
    *((void *)v7 + 41) = 1065353216;
    *((_DWORD *)v7 + 84) = 1065353216;
    *(void *)(v7 + 348) = 0;
    *(void *)(v7 + 340) = 0;
    *((_DWORD *)v7 + 89) = 0;
    *(_OWORD *)(v7 + 360) = xmmword_1A28FC750;
    *(_OWORD *)(v7 + 376) = xmmword_1A28FC750;
    *(_OWORD *)(v7 + 392) = xmmword_1A28FC750;
    *(_OWORD *)(v7 + 408) = xmmword_1A28FCDA0;
    v7[464] = 0;
    v7[440] = 0;
    *((void *)v7 + 53) = 0;
    *((void *)v7 + 54) = 0;
    *(_OWORD *)(v7 + 497) = 0u;
    *(_OWORD *)(v7 + 472) = 0u;
    *(_OWORD *)(v7 + 488) = 0u;
    *(_OWORD *)(v7 + 520) = xmmword_1A28FCE90;
    *((_DWORD *)v7 + 134) = 1065353216;
    *(void *)(v7 + 540) = 0;
    *(void *)(v7 + 548) = 0;
    *((_WORD *)v7 + 278) = 512;
    v7[562] = 0;
    *(_DWORD *)(v7 + 558) = 0;
    *(_WORD *)(v7 + 563) = -1;
    *(_DWORD *)(v7 + 565) = 0;
    __asm { FMOV            V2.4S, #1.0 }
    *(_OWORD *)(v7 + 572) = _Q2;
    *((_DWORD *)v7 + 147) = 1065353216;
    *((_WORD *)v7 + 296) = 256;
    v7[594] = 0;
    *(_OWORD *)(v7 + 596) = _Q2;
    *((_DWORD *)v7 + 153) = 1065353216;
    *((_WORD *)v7 + 308) = 256;
    v7[618] = 0;
    *(void *)(v7 + 620) = 0;
    *((_DWORD *)v7 + 157) = 257;
    *((_WORD *)v7 + 316) = 1;
    *(void *)uint64_t v7 = &unk_1EF545CB0;
    *(_OWORD *)(v7 + 636) = xmmword_1A28FCDA0;
    *((_DWORD *)v7 + 163) = 1065353216;
    *((_WORD *)v7 + 328) = 0;
    v7[658] = 0;
    v7[663] = -1;
    *(_DWORD *)(v7 + 659) = -1;
    *((_DWORD *)v7 + 166) = 0;
    *((_WORD *)v7 + 338) = 256;
    v7[678] = 1;
    *(_OWORD *)(v7 + 680) = xmmword_1A28FCDA0;
    *((_DWORD *)v7 + 174) = 1065353216;
    *((_WORD *)v7 + 350) = 0;
    v7[702] = 0;
    v7[707] = -1;
    *(_DWORD *)(v7 + 703) = -1;
    *((_DWORD *)v7 + 177) = 0;
    *((_WORD *)v7 + 360) = 256;
    v7[722] = 1;
    *(_OWORD *)(v7 + 728) = 0u;
    *(_OWORD *)(v7 + 744) = 0u;
    uint64_t v65 = (uint64_t *)(v7 + 744);
    *((void *)v7 + 97) = 0;
    *(_OWORD *)(v7 + 760) = 0u;
    {
      operator new();
    }
    *((void *)v7 + 98) = mdm::Allocator::instance(void)::alloc;
    *((void *)v7 + 99) = 0;
    *((_DWORD *)v7 + 203) = *(_DWORD *)(v60 + 176);
    *((_DWORD *)v7 + 204) = 1;
    unint64_t v66 = (grl *)(*(uint64_t (**)(void))(**(void **)(*(void *)(v60 + 168) + 64) + 16))(*(void *)(*(void *)(v60 + 168) + 64));
    if (v66)
    {
      uint64_t v67 = *(void **)(v59 + 1232);
      if (v67 && *v67)
      {
        uint64_t v68 = *(void *)((*(uint64_t (**)(void))(**(void **)(*(void *)(v60 + 168) + 64) + 16))(*(void *)(*(void *)(v60 + 168) + 64))
                        + 32);
        if (v68)
        {
          (*(void (**)(long long *__return_ptr))(*(void *)v68 + 8))(&v166);
          long long v69 = v166;
        }
        else
        {
          long long v69 = 0uLL;
        }
        long long v166 = 0uLL;
        uint64_t v107 = (std::__shared_weak_count *)*((void *)v7 + 94);
        *(_OWORD *)uint64_t v65 = v69;
        if (v107 && !atomic_fetch_add(&v107->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v107->__on_zero_shared)(v107);
          std::__shared_weak_count::__release_weak(v107);
        }
        long long v108 = (std::__shared_weak_count *)*((void *)&v166 + 1);
        if (*((void *)&v166 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v166 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v108->__on_zero_shared)(v108);
          std::__shared_weak_count::__release_weak(v108);
        }
        if (*v65)
        {
          unint64_t v109 = (*(uint64_t (**)(void))(**(void **)(*(void *)(v60 + 168) + 64) + 16))(*(void *)(*(void *)(v60 + 168) + 64));
          md::LabelExternalObjectsModerator::registerIconForAsynchModeUpdates(v109, v65);
          atomic_store(1u, (unsigned __int8 *)v7 + 819);
        }
      }
      else
      {
        uint64_t v72 = *(void *)(v58 + 296);
        if (!v72)
        {
          unint64_t v66 = (grl *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(v58, 0);
          uint64_t v72 = *(void *)v66;
          *(void *)(v58 + 296) = *(void *)v66;
        }
        if (*(unsigned __int8 *)(v72 + 92) - 1 > 8) {
          int v73 = 0;
        }
        else {
          int v73 = dword_1A29003B0[(*(unsigned char *)(v72 + 92) - 1)];
        }
        __int16 v97 = *(unsigned __int8 *)(v72 + 94);
        int v98 = *(unsigned __int8 *)(v60 + 3360);
        unsigned int v99 = (grl *)grl::SizeGroupMin(v66);
        int v100 = (int)v99;
        int v101 = grl::SizeGroupMax(v99);
        int v102 = v73 + v98;
        if (v73 + v98 >= v101) {
          int v102 = v101;
        }
        if (v102 <= v100) {
          __int16 v103 = v100;
        }
        else {
          __int16 v103 = v102;
        }
        if (v57)
        {
          *(void *)&long long v104 = v57;
          uint64_t v105 = (std::__shared_weak_count *)v57[1];
          if (v105)
          {
            uint64_t v156 = std::__shared_weak_count::lock(v105);
            if (v156)
            {
              uint64_t v106 = *v57;
            }
            else
            {
              uint64_t v106 = 0;
              uint64_t v156 = 0;
            }
            *(void *)&long long v104 = v57;
          }
          else
          {
            uint64_t v106 = 0;
            uint64_t v156 = 0;
          }
          *((void *)&v104 + 1) = v106;
        }
        else
        {
          uint64_t v156 = 0;
          long long v104 = 0uLL;
        }
        long long v158 = v104;
        int v110 = *(_DWORD *)(*(void *)(v60 + 432) + 44);
        char v111 = *(unsigned char *)(v60 + 3057);
        uint64_t v112 = (*(uint64_t (**)(void))(**(void **)(*(void *)(v60 + 168) + 64) + 16))(*(void *)(*(void *)(v60 + 168) + 64));
        float v113 = *(float *)(v59 + 392);
        unsigned __int8 v114 = (char *)operator new(0x58uLL);
        int v115 = v114;
        *((void *)v114 + 1) = 0;
        *((void *)v114 + 2) = 0;
        *(void *)unsigned __int8 v114 = &unk_1EF5825F8;
        *(_OWORD *)(v114 + 72) = 0u;
        *(_OWORD *)(v114 + 24) = 0u;
        *(_OWORD *)(v114 + 40) = 0u;
        *((void *)v114 + 7) = 0;
        *((void *)v114 + 8) = 0;
        *((_DWORD *)v114 + 18) = 1065353216;
        v114[80] = 0;
        *(void *)&long long v166 = v114 + 24;
        *((void *)&v166 + 1) = v114;
        *((_WORD *)v114 + 20) = v97 | (v103 << 8);
        *((void *)v114 + 6) = v158;
        uint64_t v116 = v156;
        if (v156)
        {
          atomic_fetch_add_explicit(&v156->__shared_owners_, 1uLL, memory_order_relaxed);
          int v117 = (std::__shared_weak_count *)*((void *)v114 + 8);
          *((void *)v114 + 7) = *((void *)&v158 + 1);
          *((void *)v114 + 8) = v156;
          if (v117 && !atomic_fetch_add(&v117->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
            std::__shared_weak_count::__release_weak(v117);
          }
        }
        else
        {
          *((void *)v114 + 7) = *((void *)&v158 + 1);
          *((void *)v114 + 8) = 0;
        }
        *((_DWORD *)v115 + 18) = v110;
        v115[76] = v111;
        uint64_t v118 = v166;
        *(unsigned char *)(v166 + 56) = (int)v113;
        if (*(unsigned char *)(v112 + 432) | v111)
        {
          md::LabelExternalObjectsModerator::runIconCreateRequest(*(void (****)(long long *__return_ptr))(v112 + 32), (uint64_t *)&v166);
        }
        else
        {
          long long v119 = *(void **)(v112 + 48);
          unint64_t v120 = *(void *)(v112 + 56);
          if ((unint64_t)v119 >= v120)
          {
            uint64_t v123 = *(void *)(v112 + 40);
            uint64_t v124 = ((uint64_t)v119 - v123) >> 4;
            unint64_t v125 = v124 + 1;
            if ((unint64_t)(v124 + 1) >> 60) {
              abort();
            }
            uint64_t v126 = v120 - v123;
            if (v126 >> 3 > v125) {
              unint64_t v125 = v126 >> 3;
            }
            if ((unint64_t)v126 >= 0x7FFFFFFFFFFFFFF0) {
              uint64_t v127 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v127 = v125;
            }
            if (v127)
            {
              uint64_t v128 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v112 + 64) + 16))(*(void *)(v112 + 64), 16 * v127, 8);
              unint64_t v129 = (_OWORD *)(v128 + 16 * v124);
              uint64_t v130 = v128 + 16 * v127;
              if (v128)
              {
                uint64_t v131 = *((void *)&v166 + 1);
                *unint64_t v129 = v166;
                if (v131) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v131 + 8), 1uLL, memory_order_relaxed);
                }
              }
            }
            else
            {
              uint64_t v130 = 0;
              unint64_t v129 = (_OWORD *)(16 * v124);
            }
            uint64_t v122 = v129 + 1;
            float v132 = *(void **)(v112 + 40);
            long long v133 = *(void **)(v112 + 48);
            if (v133 == v132)
            {
              *(void *)(v112 + 40) = v129;
              *(void *)(v112 + 48) = v122;
              uint64_t v136 = *(void *)(v112 + 56);
              *(void *)(v112 + 56) = v130;
            }
            else
            {
              do
              {
                long long v134 = *((_OWORD *)v133 - 1);
                v133 -= 2;
                *--unint64_t v129 = v134;
                *long long v133 = 0;
                v133[1] = 0;
              }
              while (v133 != v132);
              long long v133 = *(void **)(v112 + 40);
              uint64_t v135 = *(void **)(v112 + 48);
              *(void *)(v112 + 40) = v129;
              *(void *)(v112 + 48) = v122;
              uint64_t v136 = *(void *)(v112 + 56);
              *(void *)(v112 + 56) = v130;
              if (v135 != v133)
              {
                do
                {
                  uint64_t v137 = (std::__shared_weak_count *)*(v135 - 1);
                  if (v137 && !atomic_fetch_add(&v137->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v137->__on_zero_shared)(v137);
                    std::__shared_weak_count::__release_weak(v137);
                  }
                  v135 -= 2;
                }
                while (v135 != v133);
                uint64_t v116 = v156;
              }
            }
            if (v133) {
              (*(void (**)(void, void *, uint64_t))(**(void **)(v112 + 64) + 40))(*(void *)(v112 + 64), v133, v136 - (void)v133);
            }
          }
          else
          {
            if (v119)
            {
              *long long v119 = v118;
              uint64_t v121 = *((void *)&v166 + 1);
              v119[1] = *((void *)&v166 + 1);
              if (v121) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v121 + 8), 1uLL, memory_order_relaxed);
              }
            }
            uint64_t v122 = v119 + 2;
          }
          *(void *)(v112 + 48) = v122;
        }
        long long v138 = v166;
        long long v166 = 0uLL;
        uint64_t v139 = (std::__shared_weak_count *)*((void *)v7 + 92);
        *(_OWORD *)(v7 + 728) = v138;
        if (v139 && !atomic_fetch_add(&v139->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v139->__on_zero_shared)(v139);
          std::__shared_weak_count::__release_weak(v139);
        }
        unint64_t v140 = (std::__shared_weak_count *)*((void *)&v166 + 1);
        if (*((void *)&v166 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v166 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v140->__on_zero_shared)(v140);
          std::__shared_weak_count::__release_weak(v140);
        }
        if (v116 && !atomic_fetch_add(&v116->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v116->__on_zero_shared)(v116);
          std::__shared_weak_count::__release_weak(v116);
        }
      }
    }
    uint64_t v141 = *(void *)(v58 + 296);
    if (!v141)
    {
      unint64_t v142 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(v58, 0);
      uint64_t v141 = *v142;
      *(void *)(v58 + 296) = *v142;
    }
    *((_DWORD *)v7 + 143) = *(_DWORD *)(v141 + 28);
    (*(void (**)(char *))(*(void *)v7 + 152))(v7);
    uint64_t v143 = *(void *)(v58 + 272);
    if (!v143)
    {
      long long v144 = md::LabelStyle::prepareStyleGroup<md::LabelPointStyleGroup>(v58);
      uint64_t v143 = *v144;
      *(void *)(v58 + 272) = *v144;
    }
    uint64_t v145 = (void **)(v7 + 760);
    if (*(char *)(v143 + 263) < 0) {
      uint64_t v146 = *(void *)(v143 + 248);
    }
    else {
      uint64_t v146 = *(unsigned __int8 *)(v143 + 263);
    }
    uint64_t v147 = 80;
    if (v146)
    {
      uint64_t v147 = 240;
      unint64_t v148 = (void **)(v143 + 240);
    }
    else
    {
      unint64_t v148 = (void **)(v143 + 80);
    }
    if (v145 != v148)
    {
      char v149 = *((unsigned char *)v148 + 23);
      if (v7[783] < 0)
      {
        size_t v151 = *(void ***)(v143 + v147);
        if (v149 >= 0) {
          uint64_t v152 = v148;
        }
        else {
          uint64_t v152 = v151;
        }
        if (v149 >= 0) {
          size_t v153 = *((unsigned __int8 *)v148 + 23);
        }
        else {
          size_t v153 = (size_t)v148[1];
        }
        std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_no_alias<false>(v145, v152, v153);
      }
      else if ((*((unsigned char *)v148 + 23) & 0x80) != 0)
      {
        std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_no_alias<true>((void **)v145, *(void **)(v143 + v147), (size_t)v148[1]);
      }
      else
      {
        long long v150 = *(_OWORD *)v148;
        *((void *)v7 + 97) = v148[2];
        *(_OWORD *)uint64_t v145 = v150;
      }
    }
    uint64_t v154 = *(void *)(v58 + 296);
    if (!v154)
    {
      uint64_t v155 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(v58, 0);
      uint64_t v154 = *v155;
      *(void *)(v58 + 296) = *v155;
    }
    v7[800] = *(unsigned char *)(v154 + 92);
    *((void *)v7 + 99) = *(void *)(v154 + 56);
    return (md::BalloonLabelPart *)v7;
  }
  if (!*((unsigned char *)this + 140)) {
    goto LABEL_148;
  }
  std::string __p = 0;
  float v170 = 0;
  float v171 = 0;
  uint64_t v7 = (char *)&v166 + 8;
  *((void *)&v166 + 1) = 0;
  {
    operator new();
  }
  uint64_t v167 = mdm::Allocator::instance(void)::alloc;
  uint64_t v168 = 0;
  *(void *)&long long v166 = (char *)&v166 + 8;
  unint64_t v8 = (int *)*((void *)this + 88);
  uint64_t v157 = (int *)*((void *)this + 89);
  if (v8 == v157)
  {
    size_t v55 = 0;
    unint64_t v56 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    goto LABEL_93;
  }
  do
  {
    __n128 v165 = 0uLL;
    int v9 = *v8;
    if (*v8)
    {
      uint64_t v10 = operator new(0x38uLL);
      v10[1] = 0;
      void v10[2] = 0;
      *uint64_t v10 = &unk_1EF5825C0;
      v10[5] = 0;
      v10[6] = 0;
      v10[4] = 0;
      *((_DWORD *)v10 + 6) = 49;
      v165.n128_u64[0] = (unint64_t)(v10 + 3);
      v165.n128_u64[1] = (unint64_t)v10;
      int v11 = *((unsigned __int8 *)v8 + 9);
      *((_DWORD *)v10 + 7) = v9;
      if (v11)
      {
        unint64_t v12 = 0;
        do
        {
          unint64_t v13 = (char *)operator new(0x38uLL);
          uint64_t v14 = (atomic_ullong *)v13;
          *((void *)v13 + 1) = 0;
          *((void *)v13 + 2) = 0;
          *(void *)unint64_t v13 = &unk_1EF5825C0;
          *(_OWORD *)(v13 + 24) = 0u;
          uint64_t v15 = v13 + 24;
          *(_OWORD *)(v13 + 40) = 0u;
          int v163 = (std::__shared_weak_count *)(v13 + 24);
          float v164 = (std::__shared_weak_count *)v13;
          *((_DWORD *)v13 + 6) = 37;
          *((_DWORD *)v13 + 7) = *(_DWORD *)(*((void *)this + 92) + 4 * (v12 + *((unsigned __int8 *)v8 + 8)));
          uint64_t v16 = (void *)v165.n128_u64[0];
          uint64_t v17 = *(void **)(v165.n128_u64[0] + 16);
          unint64_t v18 = *(void *)(v165.n128_u64[0] + 24);
          if ((unint64_t)v17 >= v18)
          {
            uint64_t v20 = *(void *)(v165.n128_u64[0] + 8);
            uint64_t v21 = ((uint64_t)v17 - v20) >> 4;
            unint64_t v22 = v21 + 1;
            if ((unint64_t)(v21 + 1) >> 60) {
              abort();
            }
            uint64_t v23 = v18 - v20;
            if (v23 >> 3 > v22) {
              unint64_t v22 = v23 >> 3;
            }
            if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v24 = v22;
            }
            if (v24 >> 60) {
LABEL_246:
            }
              std::__throw_bad_array_new_length[abi:nn180100]();
            int v25 = (char *)operator new(16 * v24);
            uint64_t v26 = &v25[16 * v21];
            uint64_t v27 = &v25[16 * v24];
            *(void *)uint64_t v26 = v15;
            *((void *)v26 + 1) = v14;
            atomic_fetch_add_explicit(v14 + 1, 1uLL, memory_order_relaxed);
            unint64_t v28 = (void *)v16[1];
            uint64_t v29 = (void *)v16[2];
            uint64_t v19 = v26 + 16;
            if (v29 == v28)
            {
              v16[1] = v26;
              v16[2] = v19;
              v16[3] = v27;
            }
            else
            {
              do
              {
                long long v30 = *((_OWORD *)v29 - 1);
                v29 -= 2;
                *((_OWORD *)v26 - 1) = v30;
                v26 -= 16;
                *uint64_t v29 = 0;
                v29[1] = 0;
              }
              while (v29 != v28);
              uint64_t v29 = (void *)v16[1];
              uint64_t v31 = (void *)v16[2];
              v16[1] = v26;
              v16[2] = v19;
              v16[3] = v27;
              while (v31 != v29)
              {
                size_t v32 = (std::__shared_weak_count *)*(v31 - 1);
                if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
                  std::__shared_weak_count::__release_weak(v32);
                }
                v31 -= 2;
              }
            }
            if (v29) {
              operator delete(v29);
            }
          }
          else
          {
            *uint64_t v17 = v15;
            v17[1] = v13;
            atomic_fetch_add_explicit((atomic_ullong *volatile)v13 + 1, 1uLL, memory_order_relaxed);
            uint64_t v19 = v17 + 2;
          }
          v16[2] = v19;
          if (v164 && !atomic_fetch_add(&v164->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v164->__on_zero_shared)(v164);
            std::__shared_weak_count::__release_weak(v164);
          }
          ++v12;
        }
        while (v12 < *((unsigned __int8 *)v8 + 9));
      }
    }
    unsigned __int16 v33 = *((_WORD *)v8 + 3);
    if (v33)
    {
      uint64_t v34 = 0;
      while (1)
      {
        unsigned int v35 = *(_DWORD *)(*((void *)this + 96) + 4 * (v34 + *((unsigned __int16 *)v8 + 2)));
        int v36 = (uint64_t *)*((void *)&v166 + 1);
        if (*((void *)&v166 + 1))
        {
          do
          {
            unsigned int v41 = *((_DWORD *)v36 + 7);
            if (v35 >= v41)
            {
              if (v41 >= v35) {
                goto LABEL_41;
              }
              ++v36;
            }
            int v36 = (uint64_t *)*v36;
          }
          while (v36);
        }
        uint64_t v37 = (std::__shared_weak_count *)operator new(0x38uLL);
        v37->__shared_owners_ = 0;
        v37->__shared_weak_owners_ = 0;
        v37->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5825C0;
        LODWORD(v37[1].__vftable) = 50;
        uint64_t v38 = v37 + 1;
        v37[1].__shared_owners_ = 0;
        v37[1].__shared_weak_owners_ = 0;
        v37[2].__vftable = 0;
        int v163 = v37 + 1;
        float v164 = v37;
        HIDWORD(v37[1].__vftable) = v35;
        if (v165.n128_u64[0]) {
          v37[1].__shared_weak_owners_ = (uint64_t)std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)&v37[1].__shared_owners_, v165);
        }
        unint64_t v39 = v170;
        if (v170 >= v171)
        {
          uint64_t v42 = (__n128 *)__p;
          uint64_t v43 = ((char *)v170 - (unsigned char *)__p) >> 4;
          unint64_t v44 = v43 + 1;
          if ((unint64_t)(v43 + 1) >> 60) {
            abort();
          }
          uint64_t v45 = (char *)v171 - (unsigned char *)__p;
          if (((char *)v171 - (unsigned char *)__p) >> 3 > v44) {
            unint64_t v44 = v45 >> 3;
          }
          if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v46 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v46 = v44;
          }
          if (v46 >> 60) {
            goto LABEL_246;
          }
          int v47 = (char *)operator new(16 * v46);
          size_t v48 = &v47[16 * v43];
          *(void *)size_t v48 = v38;
          *((void *)v48 + 1) = v37;
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v40 = (__n128 *)(v48 + 16);
          if (v39 == v42)
          {
            std::string __p = &v47[16 * v43];
            float v170 = (__n128 *)(v48 + 16);
            float v171 = (__n128 *)&v47[16 * v46];
            if (!v39) {
              goto LABEL_68;
            }
LABEL_67:
            operator delete(v39);
            goto LABEL_68;
          }
          uint64_t v49 = v39;
          do
          {
            __n128 v50 = v49[-1];
            --v49;
            *((__n128 *)v48 - 1) = v50;
            v48 -= 16;
            v49->n128_u64[0] = 0;
            v49->n128_u64[1] = 0;
          }
          while (v49 != v42);
          std::string __p = v48;
          float v170 = v40;
          float v171 = (__n128 *)&v47[16 * v46];
          do
          {
            uint64_t v51 = (std::__shared_weak_count *)v39[-1].n128_u64[1];
            if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
              std::__shared_weak_count::__release_weak(v51);
            }
            --v39;
          }
          while (v39 != v42);
          unint64_t v39 = v42;
          if (v42) {
            goto LABEL_67;
          }
        }
        else
        {
          v170->n128_u64[0] = (unint64_t)v38;
          v39->n128_u64[1] = (unint64_t)v37;
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v40 = v39 + 1;
        }
LABEL_68:
        float v170 = v40;
        if (v164 && !atomic_fetch_add(&v164->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v164->__on_zero_shared)(v164);
          std::__shared_weak_count::__release_weak(v164);
        }
        unsigned __int16 v33 = *((_WORD *)v8 + 3);
LABEL_41:
        if (++v34 >= (unint64_t)v33) {
          goto LABEL_80;
        }
      }
    }
    if (v165.n128_u64[0])
    {
      int v52 = v170;
      if (v170 >= v171)
      {
        size_t v54 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)&__p, v165);
      }
      else
      {
        v170->n128_u64[0] = v165.n128_u64[0];
        unint64_t v53 = v165.n128_u64[1];
        v52->n128_u64[1] = v165.n128_u64[1];
        if (v53) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v53 + 8), 1uLL, memory_order_relaxed);
        }
        size_t v54 = v52 + 1;
      }
      float v170 = v54;
    }
LABEL_80:
    uint64_t v7 = (char *)v165.n128_u64[1];
    if (v165.n128_u64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v165.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(unint64_t))(*(void *)v165.n128_u64[1] + 16))(v165.n128_u64[1]);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v165.n128_u64[1]);
    }
    v8 += 3;
  }
  while (v8 != v157);
  size_t v55 = (__n128 *)__p;
  unint64_t v56 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
  if (__p == v170)
  {
LABEL_93:
    int v70 = (_DWORD *)*((void *)this + 100);
    if (v70 != *((_DWORD **)this + 101))
    {
      uint64_t v71 = (char *)operator new(0x38uLL);
      uint64_t v7 = v71;
      *((void *)v71 + 1) = 0;
      *((void *)v71 + 2) = 0;
      *(void *)uint64_t v71 = &unk_1EF5825C0;
      *(_OWORD *)(v71 + 24) = 0u;
      *(_OWORD *)(v71 + 40) = 0u;
      v165.n128_u64[0] = (unint64_t)(v71 + 24);
      v165.n128_u64[1] = (unint64_t)v71;
      *((_DWORD *)v71 + 6) = 37;
      *((_DWORD *)v71 + 7) = *v70;
      if (v55 >= v171)
      {
        uint64_t v7 = (char *)v165.n128_u64[1];
        float v170 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)&__p, v165);
        if (v165.n128_u64[1]) {
          goto LABEL_101;
        }
      }
      else
      {
        v55->n128_u64[0] = (unint64_t)(v71 + 24);
        v55->n128_u64[1] = (unint64_t)v71;
        atomic_fetch_add_explicit((atomic_ullong *volatile)v71 + 1, 1uLL, memory_order_relaxed);
        float v170 = v55 + 1;
LABEL_101:
        if (!atomic_fetch_add((atomic_ullong *volatile)v7 + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          (*(void (**)(char *))(*(void *)v7 + 16))(v7);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v7);
        }
      }
      size_t v55 = (__n128 *)__p;
    }
  }
  if (v55 == v170) {
    goto LABEL_137;
  }
  md::LabelStyle::multiPOIBalloonIcon(&v165, *((md::LabelStyle **)a2 + 2), *(void *)a2, *((void *)a2 + 1), 1, (uint64_t *)&__p);
  md::LabelStyle::multiPOIBalloonIcon(&v163, *((md::LabelStyle **)a2 + 2), *(void *)a2, *((void *)a2 + 1), 2, (uint64_t *)&__p);
  md::LabelStyle::multiPOIBalloonIcon(&v161, *((md::LabelStyle **)a2 + 2), *(void *)a2, *((void *)a2 + 1), 3, (uint64_t *)&__p);
  md::LabelStyle::multiPOIBalloonIcon(&v159, *((md::LabelStyle **)a2 + 2), *(void *)a2, *((void *)a2 + 1), 5, (uint64_t *)&__p);
  if (v165.n128_u64[0]) {
    _ZF = v163 == 0;
  }
  else {
    _ZF = 1;
  }
  BOOL v76 = _ZF || v161 == 0 || v159 == 0;
  char v77 = !v76;
  if (!v76)
  {
    {
      operator new();
    }
    uint64_t v7 = (char *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v56 + 91) + 16))(*((void *)v56 + 91), 640, 8);
    {
      operator new();
    }
    int v78 = (md::IconLabelPart *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v56 + 91) + 16))(*((void *)v56 + 91), 768, 8);
    v79.n128_f64[0] = md::IconLabelPart::IconLabelPart((uint64_t)v78, &v165);
    {
      operator new();
    }
    uint64_t v80 = (md::IconLabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __n128))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                            + 16))(mdm::Allocator::instance(void)::alloc, 768, 8, v79);
    v81.n128_f64[0] = md::IconLabelPart::IconLabelPart((uint64_t)v80, &v163);
    {
      operator new();
    }
    uint64_t v82 = (md::IconLabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __n128))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                            + 16))(mdm::Allocator::instance(void)::alloc, 768, 8, v81);
    v83.n128_f64[0] = md::IconLabelPart::IconLabelPart((uint64_t)v82, &v161);
    {
      operator new();
    }
    uint64_t v84 = (md::IconLabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __n128))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                            + 16))(mdm::Allocator::instance(void)::alloc, 768, 8, v83);
    md::IconLabelPart::IconLabelPart((uint64_t)v84, &v159);
    md::BalloonLabelPart::BalloonLabelPart((md::BalloonLabelPart *)v7, v78, v80, v82, v84, v85, v86, v87);
    v7[632] = (unint64_t)((char *)v170 - (unsigned char *)__p) < 0x20;
  }
  int v88 = v160;
  if (v160 && !atomic_fetch_add(&v160->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
    std::__shared_weak_count::__release_weak(v88);
  }
  unsigned __int8 v89 = v162;
  if (v162 && !atomic_fetch_add(&v162->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
    std::__shared_weak_count::__release_weak(v89);
  }
  unint64_t v90 = v164;
  if (v164 && !atomic_fetch_add(&v164->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
    std::__shared_weak_count::__release_weak(v90);
  }
  int v91 = (std::__shared_weak_count *)v165.n128_u64[1];
  if (v165.n128_u64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v165.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
    std::__shared_weak_count::__release_weak(v91);
  }
  if ((v77 & 1) == 0) {
LABEL_137:
  }
    uint64_t v7 = 0;
  std::__tree<unsigned int,std::less<unsigned int>,geo::StdAllocator<unsigned int,mdm::Allocator>>::destroy((uint64_t)&v166, *((void **)&v166 + 1));
  float v92 = (__n128 *)__p;
  if (__p)
  {
    uint64_t v93 = v170;
    uint64_t v94 = __p;
    if (v170 != __p)
    {
      do
      {
        uint64_t v95 = (std::__shared_weak_count *)v93[-1].n128_u64[1];
        if (v95 && !atomic_fetch_add(&v95->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
          std::__shared_weak_count::__release_weak(v95);
        }
        --v93;
      }
      while (v93 != v92);
      uint64_t v94 = __p;
    }
    float v170 = v92;
    operator delete(v94);
  }
  if (v7) {
    return (md::BalloonLabelPart *)v7;
  }
LABEL_148:
  return md::PointLabelFeature::newIconPart(this, a2);
}

void sub_1A2586908(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 783) < 0) {
    (*(void (**)(void, void, uint64_t))(**(void **)(v1 + 784) + 40))(*(void *)(v1 + 784), *(void *)(v1 + 760), *(void *)(v1 + 776) & 0x7FFFFFFFFFFFFFFFLL);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 752);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 736);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  *(void *)uint64_t v1 = &unk_1EF5540C8;
  free(*(void **)(v1 + 472));
  free(*(void **)(v1 + 480));
  free(*(void **)(v1 + 496));
  free(*(void **)(v1 + 232));
  free(*(void **)(v1 + 240));
  free(*(void **)(v1 + 256));
  uint64_t v6 = mdm::Allocator::instance(v5);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 40))(v6, v1, 824);
  _Unwind_Resume(a1);
}

void sub_1A2586BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va2, a11);
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void *);
  uint64_t v18 = va_arg(va2, void);
  uint64_t v19 = va_arg(va2, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::__tree<unsigned int,std::less<unsigned int>,geo::StdAllocator<unsigned int,mdm::Allocator>>::destroy((uint64_t)va1, v17);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)va2);
  _Unwind_Resume(a1);
}

void sub_1A2586BB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  JUMPOUT(0x1A2586BC4);
}

void std::__shared_ptr_emplace<md::LabelAttributePairWithFallback>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(void **)(a1 + 32);
    if (v3 != v1)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v1);
      uint64_t v4 = *(void **)(a1 + 32);
    }
    *(void *)(a1 + 40) = v1;
    operator delete(v4);
  }
}

void std::__shared_ptr_emplace<md::LabelAttributePairWithFallback>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5825C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelAttributePairWithFallback>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5825C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void **md::TransitNodeLabelFeature::populateTransitLinesFeatureIDs(void **result, void **a2)
{
  if (result + 104 != a2) {
    return std::vector<unsigned long long,geo::StdAllocator<unsigned long long,mdm::Allocator>>::__assign_with_size[abi:nn180100]<unsigned long long *,unsigned long long *>(a2, (char *)result[104], (char *)result[105], ((unsigned char *)result[105] - (unsigned char *)result[104]) >> 3);
  }
  return result;
}

void md::TransitNodeLabelFeature::populateStyleQueries(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v74 = 0;
  if ((*(uint64_t (**)(uint64_t *))(*a1 + 488))(a1)
    && (*(uint64_t (**)(uint64_t *, void))(*a1 + 480))(a1, 0))
  {
    operator new();
  }
  int v70 = 0;
  uint64_t v71 = 0;
  unint64_t v72 = 0;
  {
    operator new();
  }
  uint64_t v73 = mdm::Allocator::instance(void)::alloc;
  (*(void (**)(uint64_t *, uint64_t **))(*a1 + 544))(a1, &v70);
  uint64_t v6 = v71;
  if (*((unsigned char *)a1 + 876))
  {
    if ((unint64_t)v71 < v72)
    {
      if (v71) {
        *uint64_t v71 = 0x100010002;
      }
      ++v6;
LABEL_33:
      uint64_t v71 = v6;
      goto LABEL_34;
    }
    uint64_t v7 = v71 - v70;
    if ((unint64_t)(v7 + 1) >> 61) {
      abort();
    }
    unint64_t v8 = (uint64_t)(v72 - (void)v70) >> 2;
    if (v8 <= v7 + 1) {
      unint64_t v8 = v7 + 1;
    }
    if (v72 - (unint64_t)v70 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v9 = v8;
    }
    if (v9)
    {
      uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v73 + 16))(v73, 8 * v9, 4);
      int v11 = (uint64_t *)(v10 + 8 * v7);
      uint64_t v12 = v10 + 8 * v9;
      if (v10) {
        uint64_t *v11 = 0x100010002;
      }
    }
    else
    {
      uint64_t v12 = 0;
      int v11 = (uint64_t *)(8 * v7);
    }
    uint64_t v6 = v11 + 1;
    uint64_t v14 = v70;
    unint64_t v13 = v71;
    if (v71 == v70)
    {
LABEL_31:
      int v70 = v11;
      uint64_t v71 = v6;
      unint64_t v23 = v72;
      unint64_t v72 = v12;
      if (v13) {
        (*(void (**)(uint64_t, uint64_t *, unint64_t))(*(void *)v73 + 40))(v73, v13, v23 - (void)v13);
      }
      goto LABEL_33;
    }
    unint64_t v15 = (char *)v71 - (char *)v70 - 8;
    if (v15 < 0x38)
    {
      uint64_t v17 = v71;
    }
    else if ((unint64_t)((char *)v71 - (char *)v11) < 0x20)
    {
      uint64_t v17 = v71;
    }
    else
    {
      uint64_t v16 = (v15 >> 3) + 1;
      uint64_t v17 = &v71[-(v16 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v18 = v11 - 2;
      uint64_t v19 = v71 - 2;
      uint64_t v20 = v16 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v21 = *(_OWORD *)v19;
        *((_OWORD *)v18 - 1) = *((_OWORD *)v19 - 1);
        *(_OWORD *)uint64_t v18 = v21;
        v18 -= 4;
        v19 -= 4;
        v20 -= 4;
      }
      while (v20);
      v11 -= v16 & 0x3FFFFFFFFFFFFFFCLL;
      if (v16 == (v16 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_30;
      }
    }
    do
    {
      uint64_t v22 = *--v17;
      *--int v11 = v22;
    }
    while (v17 != v14);
LABEL_30:
    unint64_t v13 = v70;
    goto LABEL_31;
  }
LABEL_34:
  uint64_t v24 = *((unsigned __int8 *)a1 + 881);
  if (v24 == 5) {
    goto LABEL_63;
  }
  if ((unint64_t)v6 >= v72)
  {
    uint64_t v25 = v6 - v70;
    if ((unint64_t)(v25 + 1) >> 61) {
      abort();
    }
    unint64_t v26 = (uint64_t)(v72 - (void)v70) >> 2;
    if (v26 <= v25 + 1) {
      unint64_t v26 = v25 + 1;
    }
    if (v72 - (unint64_t)v70 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v27 = v26;
    }
    if (v27)
    {
      uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v73 + 16))(v73, 8 * v27, 4);
      uint64_t v29 = (uint64_t *)(v28 + 8 * v25);
      uint64_t v30 = v28 + 8 * v27;
      if (v28) {
        *uint64_t v29 = (v24 << 32) | 0x1002B;
      }
    }
    else
    {
      uint64_t v30 = 0;
      uint64_t v29 = (uint64_t *)(8 * v25);
    }
    uint64_t v6 = v29 + 1;
    size_t v32 = v70;
    uint64_t v31 = v71;
    if (v71 == v70) {
      goto LABEL_60;
    }
    unint64_t v33 = (char *)v71 - (char *)v70 - 8;
    if (v33 < 0x38)
    {
      unsigned int v35 = v71;
    }
    else if ((unint64_t)((char *)v71 - (char *)v29) < 0x20)
    {
      unsigned int v35 = v71;
    }
    else
    {
      uint64_t v34 = (v33 >> 3) + 1;
      unsigned int v35 = &v71[-(v34 & 0x3FFFFFFFFFFFFFFCLL)];
      int v36 = v29 - 2;
      uint64_t v37 = v71 - 2;
      uint64_t v38 = v34 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v39 = *(_OWORD *)v37;
        *((_OWORD *)v36 - 1) = *((_OWORD *)v37 - 1);
        *(_OWORD *)int v36 = v39;
        v36 -= 4;
        v37 -= 4;
        v38 -= 4;
      }
      while (v38);
      v29 -= v34 & 0x3FFFFFFFFFFFFFFCLL;
      if (v34 == (v34 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_59;
      }
    }
    do
    {
      uint64_t v40 = *--v35;
      *--uint64_t v29 = v40;
    }
    while (v35 != v32);
LABEL_59:
    uint64_t v31 = v70;
LABEL_60:
    int v70 = v29;
    uint64_t v71 = v6;
    unint64_t v41 = v72;
    unint64_t v72 = v30;
    if (v31) {
      (*(void (**)(uint64_t, uint64_t *, unint64_t))(*(void *)v73 + 40))(v73, v31, v41 - (void)v31);
    }
    goto LABEL_62;
  }
  if (v6) {
    uint64_t *v6 = (v24 << 32) | 0x1002B;
  }
  ++v6;
LABEL_62:
  uint64_t v71 = v6;
LABEL_63:
  uint64_t v42 = a1 + 82;
  if (v70 == v6)
  {
    md::createFeatureAttributeSet((gss::Allocator *)&v75, v42);
    md::LabelStyleCache::styleQueryForFeatureAttributes((uint64_t)&v69, a3, &v75, 0);
    if (v75)
    {
      uint64_t v76 = v75;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v78 + 40))(v78, v75, v77 - v75);
    }
    uint64_t v59 = *(_OWORD **)(a2 + 8);
    if ((unint64_t)v59 >= *(void *)(a2 + 16))
    {
      *(void *)(a2 + 8) = std::vector<std::shared_ptr<md::RouteAnnotationLabelFeature>,geo::StdAllocator<std::shared_ptr<md::RouteAnnotationLabelFeature>,mdm::Allocator>>::__emplace_back_slow_path<std::shared_ptr<md::RouteAnnotationLabelFeature>>(a2, (uint64_t)&v69);
    }
    else
    {
      if (v59)
      {
        _OWORD *v59 = v69;
        long long v69 = 0uLL;
      }
      *(void *)(a2 + 8) = v59 + 1;
    }
  }
  else
  {
    uint64_t v43 = (const FeatureStyleAttributes *)*v42;
    unint64_t v44 = (std::__shared_weak_count *)operator new(0x40uLL);
    v44->__shared_owners_ = 0;
    v44->__shared_weak_owners_ = 0;
    v44->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F680;
    uint64_t v45 = (void **)&v44[1].__vftable;
    FeatureStyleAttributes::FeatureStyleAttributes((FeatureStyleAttributes *)&v44[1], v43);
    *(void *)&long long v69 = v44 + 1;
    *((void *)&v69 + 1) = v44;
    unint64_t v46 = v70;
    if ((((char *)v71 - (char *)v70) & 0x7FFFFFFF8) != 0)
    {
      uint64_t v47 = 0;
      char v48 = 0;
      uint64_t v49 = ((unint64_t)((char *)v71 - (char *)v70) >> 3);
      unsigned __int8 v50 = BYTE1(v44[2].__shared_owners_);
      while (1)
      {
        size_t v51 = v50;
        int v52 = *v45;
        if (v50) {
          break;
        }
LABEL_66:
        v52[v51] = v46[v47];
        unsigned __int8 v50 = BYTE1(v44[2].__shared_owners_) + 1;
        BYTE1(v44[2].__shared_owners_) = v50;
        ++v47;
        char v48 = 1;
        if (v47 == v49)
        {
          int v52 = *v45;
          size_t v51 = v50;
LABEL_90:
          qsort(v52, v51, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
          goto LABEL_91;
        }
      }
      if (v50 > 0x1Fu)
      {
        do
        {
          uint64_t v56 = 0;
          size_t v57 = (int *)v52;
          while (1)
          {
            int v58 = *v57;
            v57 += 2;
            if (v58 == LODWORD(v46[v47])) {
              break;
            }
            if (v51 == ++v56) {
              goto LABEL_77;
            }
          }
          HIDWORD(v52[v56]) = HIDWORD(v46[v47]);
LABEL_77:
          ++v47;
        }
        while (v47 != v49);
      }
      else
      {
        do
        {
          uint64_t v53 = 0;
          size_t v54 = (int *)v52;
          while (1)
          {
            int v55 = *v54;
            v54 += 2;
            if (v55 == LODWORD(v46[v47])) {
              break;
            }
            if (v51 == ++v53) {
              goto LABEL_66;
            }
          }
          HIDWORD(v52[v53]) = HIDWORD(v46[v47++]);
        }
        while (v47 != v49);
      }
      if (v48) {
        goto LABEL_90;
      }
    }
LABEL_91:
    unint64_t v66 = (char *)&v44[1];
    uint64_t v67 = v44;
    atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    md::createFeatureAttributeSet((gss::Allocator *)&v75, (uint64_t *)&v66);
    md::LabelStyleCache::styleQueryForFeatureAttributes((uint64_t)&v68, a3, &v75, 0);
    if (v75)
    {
      uint64_t v76 = v75;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v78 + 40))(v78, v75, v77 - v75);
    }
    uint64_t v60 = *(_OWORD **)(a2 + 8);
    if ((unint64_t)v60 >= *(void *)(a2 + 16))
    {
      unint64_t v61 = std::vector<std::shared_ptr<md::RouteAnnotationLabelFeature>,geo::StdAllocator<std::shared_ptr<md::RouteAnnotationLabelFeature>,mdm::Allocator>>::__emplace_back_slow_path<std::shared_ptr<md::RouteAnnotationLabelFeature>>(a2, (uint64_t)&v68);
    }
    else
    {
      if (v60)
      {
        *uint64_t v60 = v68;
        long long v68 = 0uLL;
      }
      unint64_t v61 = v60 + 1;
    }
    *(void *)(a2 + 8) = v61;
    unint64_t v62 = (std::__shared_weak_count *)*((void *)&v68 + 1);
    if (*((void *)&v68 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v68 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
      std::__shared_weak_count::__release_weak(v62);
    }
    size_t v63 = v67;
    if (v67 && !atomic_fetch_add(&v67->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }
  }
  unint64_t v64 = (std::__shared_weak_count *)*((void *)&v69 + 1);
  if (*((void *)&v69 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v69 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
    std::__shared_weak_count::__release_weak(v64);
  }
  if (v70)
  {
    uint64_t v71 = v70;
    (*(void (**)(uint64_t, uint64_t *, unint64_t))(*(void *)v73 + 40))(v73, v70, v72 - (void)v70);
  }
  uint64_t v65 = v74;
  if (v74)
  {
    if (*(char *)(v74 + 23) < 0) {
      (*(void (**)(void, void, uint64_t))(**(void **)(v74 + 24) + 40))(*(void *)(v74 + 24), *(void *)v74, *(void *)(v74 + 16) & 0x7FFFFFFFFFFFFFFFLL);
    }
    MEMORY[0x1A6239270](v65, 0x1032C402ED93987);
  }
}

void sub_1A2587690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  if (v10)
  {
    uint64_t v11 = v10;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v13 + 40))(v13, v10, v12 - v10);
  }
  std::unique_ptr<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>::~unique_ptr[abi:nn180100]((uint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t md::TransitNodeLabelFeature::debugString@<X0>(void *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, char a4@<W3>, void *a5@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v122);
  md::PointLabelFeature::debugString((uint64_t)a1, a2, a3, a4, &__p);
  if (v120 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if (v120 >= 0) {
    uint64_t v11 = HIBYTE(v120);
  }
  else {
    uint64_t v11 = (uint64_t)v119;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v122, (uint64_t)p_p, v11);
  if (SHIBYTE(v120) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  long long v119 = 0;
  int64_t v120 = 0;
  {
    operator new();
  }
  long long v104 = a5;
  uint64_t v121 = mdm::Allocator::instance(void)::alloc;
  unsigned __int8 v114 = 0;
  int v115 = 0;
  uint64_t v116 = 0;
  {
    operator new();
  }
  uint64_t v106 = mdm::Allocator::instance(void)::alloc;
  uint64_t v117 = mdm::Allocator::instance(void)::alloc;
  uint64_t v12 = a1[88];
  uint64_t v108 = a1[89];
  if (v12 != v108)
  {
    unint64_t v13 = v120;
    uint64_t v107 = v121;
    uint64_t v110 = v116;
    unint64_t v15 = (char *)__p;
    uint64_t v14 = v119;
    uint64_t v105 = a1;
    while ((unint64_t)v14 < v13)
    {
      if (v14) {
        *(_DWORD *)uint64_t v14 = *(_DWORD *)v12;
      }
      v14 += 4;
      uint64_t v16 = *(unsigned __int16 *)(v12 + 6);
      if (!*(_WORD *)(v12 + 6)) {
        goto LABEL_14;
      }
LABEL_42:
      unint64_t v109 = v13;
      size_t v32 = (char *)(a1[96] + 4 * *(unsigned __int16 *)(v12 + 4));
      uint64_t v34 = (uint64_t)v114;
      unint64_t v33 = v115;
      uint64_t v35 = v115 - v114;
      int v36 = &v114[(v115 - v114) & 0xFFFFFFFFFFFFFFFCLL];
      if (v16 > (v110 - (uint64_t)v115) >> 2)
      {
        uint64_t v37 = v35 >> 2;
        unint64_t v38 = (v35 >> 2) + v16;
        if (v38 >> 62)
        {
          std::string __p = v15;
          long long v119 = v14;
          int64_t v120 = v109;
          uint64_t v116 = v110;
          abort();
        }
        if ((v110 - (uint64_t)v114) >> 1 > v38) {
          unint64_t v38 = (v110 - (uint64_t)v114) >> 1;
        }
        if ((unint64_t)(v110 - (void)v114) >= 0x7FFFFFFFFFFFFFFCLL) {
          uint64_t v39 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v39 = v38;
        }
        if (v39)
        {
          uint64_t v40 = v14;
          uint64_t v41 = v35 >> 2;
          uint64_t v42 = v39;
          uint64_t v43 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v106 + 16))(v106, 4 * v39, 4);
          uint64_t v39 = v42;
          uint64_t v37 = v41;
          uint64_t v14 = v40;
          uint64_t v35 = v115 - v114;
        }
        else
        {
          uint64_t v43 = 0;
        }
        uint64_t v55 = v43 + 4 * v37;
        uint64_t v56 = (char *)(v55 + 4 * v16);
        uint64_t v57 = 4 * v16;
        int v58 = (_DWORD *)v55;
        do
        {
          if (v58) {
            *int v58 = *(_DWORD *)v32;
          }
          ++v58;
          v32 += 4;
          v57 -= 4;
        }
        while (v57);
        uint64_t v59 = (uint64_t)v114;
        if (v114 == v36)
        {
          unint64_t v13 = v109;
        }
        else
        {
          unint64_t v60 = (v35 & 0xFFFFFFFFFFFFFFFCLL) + v34;
          unint64_t v61 = v60 - (void)v114 - 4;
          unint64_t v13 = v109;
          if (v61 < 0x3C)
          {
            unint64_t v62 = v36;
            goto LABEL_80;
          }
          unint64_t v62 = v36;
          if (v60 - ((v35 & 0xFFFFFFFFFFFFFFFCLL) + v43) < 0x20) {
            goto LABEL_161;
          }
          uint64_t v63 = (v61 >> 2) + 1;
          unint64_t v62 = &v36[-4 * (v63 & 0x7FFFFFFFFFFFFFF8)];
          unint64_t v64 = (long long *)(v34 + 4 * v37 - 16);
          uint64_t v65 = (_OWORD *)(v43 + 4 * v37 - 16);
          uint64_t v66 = v63 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v67 = *v64;
            *(v65 - 1) = *(v64 - 1);
            *uint64_t v65 = v67;
            v64 -= 2;
            v65 -= 2;
            v66 -= 8;
          }
          while (v66);
          v55 -= 4 * (v63 & 0x7FFFFFFFFFFFFFF8);
          if (v63 != (v63 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_161:
            do
            {
LABEL_80:
              int v68 = *((_DWORD *)v62 - 1);
              v62 -= 4;
              *(_DWORD *)(v55 - 4) = v68;
              v55 -= 4;
            }
            while (v62 != (char *)v59);
          }
        }
        if (v33 != v36)
        {
          unint64_t v69 = (v35 & 0xFFFFFFFFFFFFFFFCLL) + v34;
          unint64_t v70 = (unint64_t)&v33[-v69 - 4];
          if (v70 < 0x3C) {
            goto LABEL_162;
          }
          if ((v35 & 0xFFFFFFFFFFFFFFFCLL) + v43 + 4 * v16 - v69 < 0x20) {
            goto LABEL_162;
          }
          uint64_t v71 = (v70 >> 2) + 1;
          uint64_t v72 = 4 * (v71 & 0x7FFFFFFFFFFFFFF8);
          v36 += v72;
          uint64_t v73 = (_OWORD *)(v43 + 4 * v16 + 4 * v37 + 16);
          uint64_t v74 = (long long *)(v34 + 4 * v37 + 16);
          uint64_t v75 = v71 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v76 = *v74;
            *(v73 - 1) = *(v74 - 1);
            _OWORD *v73 = v76;
            v73 += 2;
            v74 += 2;
            v75 -= 8;
          }
          while (v75);
          v56 += v72;
          if (v71 != (v71 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_162:
            do
            {
              int v77 = *(_DWORD *)v36;
              v36 += 4;
              *(_DWORD *)uint64_t v56 = v77;
              v56 += 4;
            }
            while (v36 != v33);
          }
        }
        uint64_t v78 = v43 + 4 * v39;
        unsigned __int8 v114 = (char *)v55;
        int v115 = v56;
        if (v59) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v106 + 40))(v106, v59, v110 - v59);
        }
        uint64_t v110 = v78;
        a1 = v105;
        goto LABEL_14;
      }
      uint64_t v44 = v115 - v36;
      uint64_t v45 = (v115 - v36) >> 2;
      uint64_t v46 = 4 * v16;
      if (v45 >= v16)
      {
        char v48 = &v32[4 * v16];
        size_t v51 = v115;
      }
      else
      {
        uint64_t v47 = 4 * v45;
        char v48 = &v32[v47];
        uint64_t v49 = v46 - v47;
        unsigned __int8 v50 = &v32[v47];
        size_t v51 = v115;
        do
        {
          if (v51) {
            *(_DWORD *)size_t v51 = *(_DWORD *)v50;
          }
          v50 += 4;
          v51 += 4;
          v49 -= 4;
        }
        while (v49);
        int v115 = v51;
        if (v44 < 1) {
          goto LABEL_13;
        }
      }
      int v52 = &v51[-v46];
      uint64_t v53 = v51;
      while (v52 < v33)
      {
        if (v53) {
          *(_DWORD *)uint64_t v53 = *(_DWORD *)v52;
        }
        v52 += 4;
        v53 += 4;
      }
      size_t v54 = &v36[v46];
      int v115 = v53;
      if (v51 != v54) {
        memmove(&v51[-4 * ((v51 - v54) >> 2)], v36, v51 - v54);
      }
      if (v48 != v32) {
        memmove(v36, v32, v48 - v32);
      }
LABEL_13:
      unint64_t v13 = v109;
LABEL_14:
      v12 += 12;
      if (v12 == v108)
      {
        std::string __p = v15;
        long long v119 = v14;
        int64_t v120 = v13;
        uint64_t v116 = v110;
        goto LABEL_92;
      }
    }
    uint64_t v17 = (v14 - v15) >> 2;
    unint64_t v18 = v17 + 1;
    if ((unint64_t)(v17 + 1) >> 62)
    {
      std::string __p = v15;
      long long v119 = v14;
      int64_t v120 = v13;
      uint64_t v116 = v110;
      abort();
    }
    unint64_t v19 = v13 - (void)v15;
    if ((uint64_t)(v13 - (void)v15) >> 1 > v18) {
      unint64_t v18 = (uint64_t)(v13 - (void)v15) >> 1;
    }
    if (v19 >= 0x7FFFFFFFFFFFFFFCLL) {
      uint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v20 = v18;
    }
    if (v20)
    {
      uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v107 + 16))(v107, 4 * v20, 4);
      uint64_t v22 = (char *)(v21 + 4 * v17);
      unint64_t v13 = v21 + 4 * v20;
      if (v21) {
        *(_DWORD *)uint64_t v22 = *(_DWORD *)v12;
      }
    }
    else
    {
      unint64_t v13 = 0;
      uint64_t v22 = (char *)(4 * v17);
    }
    unint64_t v23 = v22;
    if (v14 != v15)
    {
      unint64_t v24 = v14 - v15 - 4;
      if (v24 < 0x1C || (unint64_t)(v14 - v22) < 0x20)
      {
        unint64_t v26 = v14;
        unint64_t v23 = v22;
      }
      else
      {
        uint64_t v25 = (v24 >> 2) + 1;
        unint64_t v26 = &v14[-4 * (v25 & 0x7FFFFFFFFFFFFFF8)];
        uint64_t v27 = v22 - 16;
        uint64_t v28 = v14 - 16;
        uint64_t v29 = v25 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v30 = *(_OWORD *)v28;
          *((_OWORD *)v27 - 1) = *((_OWORD *)v28 - 1);
          *(_OWORD *)uint64_t v27 = v30;
          v27 -= 32;
          v28 -= 32;
          v29 -= 8;
        }
        while (v29);
        unint64_t v23 = &v22[-4 * (v25 & 0x7FFFFFFFFFFFFFF8)];
        if (v25 == (v25 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_39;
        }
      }
      do
      {
        int v31 = *((_DWORD *)v26 - 1);
        v26 -= 4;
        *((_DWORD *)v23 - 1) = v31;
        v23 -= 4;
      }
      while (v26 != v15);
    }
LABEL_39:
    uint64_t v14 = v22 + 4;
    if (v15) {
      (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v107 + 40))(v107, v15, v19);
    }
    unint64_t v15 = v23;
    uint64_t v16 = *(unsigned __int16 *)(v12 + 6);
    if (!*(_WORD *)(v12 + 6)) {
      goto LABEL_14;
    }
    goto LABEL_42;
  }
LABEL_92:
  __n128 v79 = v115;
  std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>();
  uint64_t v80 = v104;
  if (v114 != v115)
  {
    __n128 v81 = v114 + 4;
    while (v81 != v115)
    {
      uint64_t v82 = v81 - 4;
      int v83 = *((_DWORD *)v81 - 1);
      int v84 = *(_DWORD *)v81;
      v81 += 4;
      if (v83 == v84)
      {
        for (unsigned __int8 i = v82 + 8; i != v79; i += 4)
        {
          int v86 = v83;
          int v83 = *(_DWORD *)i;
          if (v86 != *(_DWORD *)i)
          {
            *((_DWORD *)v82 + 1) = v83;
            v82 += 4;
          }
        }
        int64_t v87 = v82 + 4;
        int64_t v88 = v79 - (v82 + 4);
        if (v88)
        {
          size_t v89 = v79 - &v87[v88];
          if (v89) {
            memmove(v87, &v87[v88], v89);
          }
          int v115 = &v87[v89];
        }
        break;
      }
    }
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v122, (uint64_t)" SystemTypes:", 13);
  ArrayToCommaSeparatedString<unsigned int>(&v111, (uint64_t *)&__p);
  if ((v113 & 0x80u) == 0) {
    unint64_t v90 = &v111;
  }
  else {
    unint64_t v90 = v111;
  }
  if ((v113 & 0x80u) == 0) {
    uint64_t v91 = v113;
  }
  else {
    uint64_t v91 = v112;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v122, (uint64_t)v90, v91);
  if ((char)v113 < 0) {
    operator delete(v111);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v122, (uint64_t)" LineTypes:", 11);
  ArrayToCommaSeparatedString<unsigned int>(&v111, (uint64_t *)&v114);
  if ((v113 & 0x80u) == 0) {
    float v92 = &v111;
  }
  else {
    float v92 = v111;
  }
  if ((v113 & 0x80u) == 0) {
    uint64_t v93 = v113;
  }
  else {
    uint64_t v93 = v112;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v122, (uint64_t)v92, v93);
  if ((char)v113 < 0) {
    operator delete(v111);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v122, (uint64_t)" TransitTypes:", 14);
  ArrayToCommaSeparatedString<unsigned int>(&v111, a1 + 100);
  if ((v113 & 0x80u) == 0) {
    uint64_t v94 = &v111;
  }
  else {
    uint64_t v94 = v111;
  }
  if ((v113 & 0x80u) == 0) {
    uint64_t v95 = v113;
  }
  else {
    uint64_t v95 = v112;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v122, (uint64_t)v94, v95);
  if ((char)v113 < 0) {
    operator delete(v111);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v122, (uint64_t)"\n", 1);
  if ((v129 & 0x10) != 0)
  {
    unint64_t v97 = v128;
    if (v128 < v125)
    {
      unint64_t v128 = v125;
      unint64_t v97 = v125;
    }
    int v98 = (const void **)&v124;
  }
  else
  {
    if ((v129 & 8) == 0)
    {
      size_t v96 = 0;
      *((unsigned char *)v104 + 23) = 0;
      goto LABEL_145;
    }
    int v98 = (const void **)v123;
    unint64_t v97 = v123[2];
  }
  unsigned int v99 = *v98;
  size_t v96 = v97 - (void)*v98;
  if (v96 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v96 >= 0x17)
  {
    uint64_t v100 = (v96 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v96 | 7) != 0x17) {
      uint64_t v100 = v96 | 7;
    }
    uint64_t v101 = v100 + 1;
    int v102 = operator new(v100 + 1);
    v104[1] = v96;
    v104[2] = v101 | 0x8000000000000000;
    *long long v104 = v102;
    uint64_t v80 = v102;
    goto LABEL_144;
  }
  *((unsigned char *)v104 + 23) = v96;
  if (v96) {
LABEL_144:
  }
    memmove(v80, v99, v96);
LABEL_145:
  *((unsigned char *)v80 + v96) = 0;
  if (v114) {
    (*(void (**)(uint64_t, char *, uint64_t))(*(void *)v117 + 40))(v117, v114, v116 - (void)v114);
  }
  if (__p) {
    (*(void (**)(uint64_t, void *, int64_t))(*(void *)v121 + 40))(v121, __p, v120 - (void)__p);
  }
  v122[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v122 + *(void *)(v122[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v122[1] = MEMORY[0x1E4FBA470] + 16;
  if (v127 < 0) {
    operator delete(v126);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v130);
}

void sub_1A258829C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  if (a23 < 0)
  {
    operator delete(__p);
    uint64_t v33 = a24;
    if (a24)
    {
LABEL_7:
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a27 + 40))(a27, v33, a26 - v33);
      uint64_t v34 = a28;
      if (!a28) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v33 = a24;
    if (a24) {
      goto LABEL_7;
    }
  }
  uint64_t v34 = a28;
  if (!a28)
  {
LABEL_9:
    std::ostringstream::~ostringstream((uint64_t)&a32);
    _Unwind_Resume(a1);
  }
LABEL_8:
  (*(void (**)(uint64_t, void *, uint64_t))(*(void *)a31 + 40))(a31, v34, a30 - (void)v34);
  goto LABEL_9;
}

uint64_t ArrayToCommaSeparatedString<unsigned int>(unsigned char *a1, uint64_t *a2)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v15);
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (*a2 != v4)
  {
    std::ostream::operator<<();
    for (uint64_t i = v5 + 4; i != v4; i += 4)
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)",", 1);
      std::ostream::operator<<();
    }
  }
  if ((v22 & 0x10) != 0)
  {
    unint64_t v8 = v21;
    if (v21 < v18)
    {
      unint64_t v21 = v18;
      unint64_t v8 = v18;
    }
    uint64_t v9 = (const void **)&v17;
  }
  else
  {
    if ((v22 & 8) == 0)
    {
      size_t v7 = 0;
      a1[23] = 0;
      goto LABEL_19;
    }
    uint64_t v9 = (const void **)v16;
    unint64_t v8 = v16[2];
  }
  uint64_t v10 = *v9;
  size_t v7 = v8 - (void)*v9;
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v7 >= 0x17)
  {
    uint64_t v11 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v11 = v7 | 7;
    }
    uint64_t v12 = v11 + 1;
    unint64_t v13 = operator new(v11 + 1);
    *((void *)a1 + 1) = v7;
    *((void *)a1 + 2) = v12 | 0x8000000000000000;
    *(void *)a1 = v13;
    a1 = v13;
    goto LABEL_18;
  }
  a1[23] = v7;
  if (v7) {
LABEL_18:
  }
    memmove(a1, v10, v7);
LABEL_19:
  a1[v7] = 0;
  v15[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v15 + *(void *)(v15[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v15[1] = MEMORY[0x1E4FBA470] + 16;
  if (v20 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v23);
}

void sub_1A25885F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t md::TransitNodeLabelFeature::labelFeatureType(md::TransitNodeLabelFeature *this)
{
  return *((unsigned __int8 *)this + 879);
}

BOOL md::TransitNodeLabelFeature::updateDynamicStyling(md::TransitNodeLabelFeature *this, LabelManager *a2, md::Label *a3)
{
  if ((*(uint64_t (**)(md::TransitNodeLabelFeature *, LabelManager *, md::Label *))(*(void *)this + 64))(this, a2, a3))
  {
    uint64_t v5 = *((void *)this + 63);
    uint64_t v6 = *(void *)(v5 + 32);
    size_t v7 = *(std::__shared_weak_count **)(v5 + 40);
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      if (v6 != *((void *)this + 82))
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        goto LABEL_13;
      }
    }
    else if (v6 != *((void *)this + 82))
    {
LABEL_13:
      *((void *)this + 82) = v6;
      uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 83);
      *((void *)this + 83) = v7;
      if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
      int v13 = 1;
LABEL_18:
      int v14 = *(unsigned __int8 *)(*((void *)this + 63) + 236);
      int v15 = *((unsigned __int8 *)this + 880);
      BOOL v16 = v14 != v15;
      if (v14 != v15) {
        *((unsigned char *)this + 880) = v14;
      }
      if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
        if ((v13 & 1) == 0) {
          return v16;
        }
        goto LABEL_37;
      }
      goto LABEL_36;
    }
    int v13 = 0;
    goto LABEL_18;
  }
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(*((void *)a2 + 21) + 64) + 16))(*(void *)(*((void *)a2 + 21) + 64));
  if (!v8) {
    return 0;
  }
  unint64_t v9 = *((void *)this + 108);
  for (uint64_t i = *(void **)(v8 + 136); i; uint64_t i = (void *)*i)
  {
    unint64_t v11 = i[4];
    if (v11 <= v9)
    {
      if (v11 >= v9)
      {
        LODWORD(i) = 1;
        break;
      }
      ++i;
    }
  }
  if (*((unsigned __int8 *)this + 876) == i)
  {
    int v13 = 0;
  }
  else
  {
    *((unsigned char *)this + 876) = (_BYTE)i;
    int v13 = 1;
  }
  md::LabelExternalObjectsModerator::externalTransitNode((md::LabelExternalObjectsModerator *)&v21, v8, v9);
  if (v21)
  {
    int v17 = atomic_load((unsigned __int8 *)(v21 + 25));
    if (v17 != *((unsigned __int8 *)this + 881))
    {
      unsigned __int8 v18 = atomic_load((unsigned __int8 *)(v21 + 25));
      *((unsigned char *)this + 881) = v18;
      int v13 = 1;
    }
  }
  unint64_t v19 = v22;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  BOOL v16 = 0;
LABEL_36:
  if (v13) {
LABEL_37:
  }
    (*(void (**)(md::TransitNodeLabelFeature *, LabelManager *))(*(void *)this + 536))(this, a2);
  return v16;
}

void md::TransitNodeLabelFeature::updateText(md::TransitNodeLabelFeature *this, const void *a2, char a3)
{
  *(_WORD *)((char *)this + 877) = -256;
}

void md::TransitNodeLabelFeature::~TransitNodeLabelFeature(md::TransitNodeLabelFeature *this)
{
  md::TransitNodeLabelFeature::~TransitNodeLabelFeature(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t vars8;

  *(void *)this = &unk_1EF544508;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 114);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 112);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 112);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = *((void *)this + 104);
  if (v4)
  {
    *((void *)this + 105) = v4;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 107) + 40))(*((void *)this + 107), v4, *((void *)this + 106) - v4);
  }
  uint64_t v5 = *((void *)this + 100);
  if (v5)
  {
    *((void *)this + 101) = v5;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 103) + 40))(*((void *)this + 103), v5, *((void *)this + 102) - v5);
  }
  uint64_t v6 = *((void *)this + 96);
  if (v6)
  {
    *((void *)this + 97) = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 99) + 40))(*((void *)this + 99), v6, *((void *)this + 98) - v6);
  }
  size_t v7 = *((void *)this + 92);
  if (v7)
  {
    *((void *)this + 93) = v7;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 95) + 40))(*((void *)this + 95), v7, *((void *)this + 94) - v7);
  }
  uint64_t v8 = *((void *)this + 88);
  if (v8)
  {
    *((void *)this + 89) = v8;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 91) + 40))(*((void *)this + 91), v8, *((void *)this + 90) - v8);
  }
  unint64_t v9 = *((void *)this + 84);
  if (v9)
  {
    *((void *)this + 85) = v9;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 87) + 40))(*((void *)this + 87), v9, *((void *)this + 86) - v9);
  }
  md::PointLabelFeature::~PointLabelFeature(this);
}

void md::mun::MuninRoadNetworkLayerDataSource::resourceKeyForType(uint64_t a1@<X0>, char a2@<W1>, unsigned __int8 *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  __int16 v8 = *(_WORD *)(a1 + 584);
  if (*(unsigned char *)a5) {
    int v9 = *(_DWORD *)(a5 + 4);
  }
  else {
    int v9 = 2147483646;
  }
  uint64_t v10 = *(void *)(a3 + 4);
  int v18 = v10;
  int v11 = a3[1];
  int v12 = *a3;
  *(unsigned char *)a6 = a2;
  *(_WORD *)(a6 + 2) = v8;
  *(_DWORD *)(a6 + 4) = v9;
  *(void *)(a6 + 8) = a6 + 40;
  *(void *)(a6 + 16) = a6 + 40;
  *(void *)(a6 + 24) = a6 + 40;
  *(void *)(a6 + 32) = 32;
  *(void *)(a6 + 72) = 0;
  int v19 = HIDWORD(v10);
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v18;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v11;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v12;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v13 = *(unsigned __int8 **)(a6 + 16);
  int v14 = *(unsigned __int8 **)(a6 + 8);
  unint64_t v15 = v13 - v14;
  if (v13 == v14)
  {
    unint64_t v16 = 0;
  }
  else
  {
    unint64_t v16 = 0;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    do
    {
      unsigned int v17 = *v14++;
      v16 ^= (v16 << 6) + (v16 >> 2) - 0x61C8864680B583EBLL + v17;
      --v15;
    }
    while (v15);
  }
  *(void *)(a6 + 72) = v16;
  *(void *)(a6 + 88) = a4;
}

void md::mun::MuninRoadNetworkLayerDataSource::createLayerData(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a3;
  uint64_t v5 = a3[1];
  if (*a3 != v5)
  {
    while (*(_WORD *)v4 != 14)
    {
      v4 += 48;
      if (v4 == v5) {
        goto LABEL_10;
      }
    }
  }
  if (v4 == v5 || *(void *)(v4 + 32) != 1)
  {
LABEL_10:
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v6 = *(void *)(v4 + 24);
    uint64_t v7 = *(void *)(v6 + 112);
    __int16 v8 = *(std::__shared_weak_count **)(v6 + 120);
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v11 = v7;
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
LABEL_12:
      int v9 = (char *)operator new(0x390uLL);
      *((void *)v9 + 1) = 0;
      *((void *)v9 + 2) = 0;
      *(void *)int v9 = &unk_1EF580F70;
      v12[0] = 0;
      v12[1] = 0;
      v13[0] = 0;
      md::MapTileData::MapTileData((uint64_t)(v9 + 24), a2, (uint64_t)v12, (uint64_t *)(v11 + 144), 1);
      *((void *)v9 + 3) = &unk_1EF53DCC8;
      *((void *)v9 + 82) = &unk_1EF53DD08;
      *(_OWORD *)(v9 + 744) = 0u;
      *((void *)v9 + 95) = *(void *)(v11 + 144);
      uint64_t v10 = *(void *)(v11 + 152);
      *((void *)v9 + 96) = v10;
      if (v10) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
      }
      *(_OWORD *)(v9 + 872) = 0uLL;
      *(_OWORD *)(v9 + 888) = 0uLL;
      *(_OWORD *)(v9 + 840) = 0uLL;
      *(_OWORD *)(v9 + 856) = 0uLL;
      *(_OWORD *)(v9 + 808) = 0uLL;
      *(_OWORD *)(v9 + 824) = 0uLL;
      *(_OWORD *)(v9 + 776) = 0uLL;
      *(_OWORD *)(v9 + 792) = 0uLL;
      *((_DWORD *)v9 + 226) = 1065353216;
      operator new();
    }
  }
  uint64_t v11 = v7;
  goto LABEL_12;
}

void sub_1A2589488(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,void *a27)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v27 + 8));
  std::__shared_weak_count::~__shared_weak_count(v28);
  operator delete(v30);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<md::MuninRoadNetworkData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::MuninRoadNetworkData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580F70;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::MuninRoadNetworkData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580F70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::mun::MuninRoadNetworkLayerDataSource::~MuninRoadNetworkLayerDataSource(md::mun::MuninRoadNetworkLayerDataSource *this)
{
  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

void *std::function<void ()(md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle &)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::UpdateShadowConstants::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateShadowConstants::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle &>)::$_0>,void ()(md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle &)>::operator()(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  uint64_t v5 = (void *)md::VKMRenderResourcesStore::getConstantData<ggl::DaVinci::Shadow>(**(void **)(a1 + 8), *a3);
  uint64_t v6 = **(void ***)(a1 + 8);
  unint64_t v7 = *a2;
  *(void *)&v25[0] = v7;
  uint64_t v8 = v6[1166];
  if (v7 < (unint64_t)((v6[1167] - v8) >> 3)
    && ((v9 = *(void *)(v8 + 8 * v7)) != 0 ? (BOOL v10 = HIDWORD(v7) == HIDWORD(v9)) : (BOOL v10 = 0), v10))
  {
    unint64_t v12 = v6[1169] + ((unint64_t)*(void *)(v8 + 8 * v7) << 8);
    unint64_t v11 = v6[1170];
  }
  else
  {
    unint64_t v11 = v6[1170];
    unint64_t v12 = v11;
  }
  if (v12 == v11) {
    int v13 = 0;
  }
  else {
    int v13 = (_OWORD *)v12;
  }
  if (v13)
  {
    uint64_t v14 = std::__hash_table<std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::TileMatrix>,std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::hash<geo::handle<md::TileMatrix>>,std::equal_to<geo::handle<md::TileMatrix>>,true>,std::__unordered_map_equal<geo::handle<md::TileMatrix>,std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::equal_to<geo::handle<md::TileMatrix>>,std::hash<geo::handle<md::TileMatrix>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::TileMatrix>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::TileMatrix> const&>,std::tuple<>>((uint64_t)(v6 + 1158), v7, v25);
    ++v14[3];
  }
  long long v15 = v13[5];
  v25[4] = v13[4];
  void v25[5] = v15;
  long long v16 = v13[7];
  v25[6] = v13[6];
  v25[7] = v16;
  long long v17 = v13[1];
  v25[0] = *v13;
  v25[1] = v17;
  long long v18 = v13[3];
  v25[2] = v13[2];
  void v25[3] = v18;
  unint64_t v19 = v5[1];
  uint64_t v20 = (float32x4_t *)v5[9];
  gm::operator*<double,4,4,4>(v24[0].f64, *(double **)(a1 + 16), (double *)v25);
  float32x4_t v21 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v24[2]), v24[3]);
  *uint64_t v20 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v24[0]), v24[1]);
  v20[1] = v21;
  float32x4_t v22 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v24[6]), v24[7]);
  v20[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v24[4]), v24[5]);
  v20[3] = v22;
  unint64_t v23 = v5[8];
  if (v23 <= v19) {
    unint64_t v23 = v19;
  }
  v5[7] = 0;
  v5[8] = v23;
}

__n128 std::__function::__func<md::ita::UpdateShadowConstants::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateShadowConstants::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle &>)::$_0>,void ()(md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51FAD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::UpdateShadowConstants::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateShadowConstants::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle &>)::$_0>,void ()(md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51FAD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::UpdateShadowConstants::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateShadowConstants::operator()(ecs2::Query<md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle &>)::$_0>,void ()(md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle &)>::~__func()
{
}

void std::__function::__func<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_1,std::allocator<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &)>::operator()(uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t v6 = (void *)md::VKMRenderResourcesStore::getConstantData<ggl::Tile::LinearDepth>(**(void **)(a1 + 8), *a4);
  unint64_t v7 = **(void ***)(a1 + 8);
  unint64_t v8 = *a3;
  *(void *)&v29[0] = v8;
  uint64_t v9 = v7[1166];
  if (v8 < (unint64_t)((v7[1167] - v9) >> 3)
    && ((uint64_t v10 = *(void *)(v9 + 8 * v8)) != 0 ? (v11 = HIDWORD(v8) == HIDWORD(v10)) : (v11 = 0), v11))
  {
    unint64_t v13 = v7[1169] + ((unint64_t)*(void *)(v9 + 8 * v8) << 8);
    unint64_t v12 = v7[1170];
  }
  else
  {
    unint64_t v12 = v7[1170];
    unint64_t v13 = v12;
  }
  if (v13 == v12) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = (_OWORD *)v13;
  }
  if (v14)
  {
    long long v15 = std::__hash_table<std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::TileMatrix>,std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::hash<geo::handle<md::TileMatrix>>,std::equal_to<geo::handle<md::TileMatrix>>,true>,std::__unordered_map_equal<geo::handle<md::TileMatrix>,std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>,std::equal_to<geo::handle<md::TileMatrix>>,std::hash<geo::handle<md::TileMatrix>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::TileMatrix>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::TileMatrix>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::TileMatrix> const&>,std::tuple<>>((uint64_t)(v7 + 1158), v8, v29);
    ++v15[3];
  }
  long long v16 = v14[5];
  v29[4] = v14[4];
  v29[5] = v16;
  long long v17 = v14[7];
  v29[6] = v14[6];
  v29[7] = v17;
  long long v18 = v14[1];
  v29[0] = *v14;
  v29[1] = v18;
  long long v19 = v14[3];
  v29[2] = v14[2];
  v29[3] = v19;
  unint64_t v20 = v6[1];
  uint64_t v21 = **(void **)(a1 + 16);
  float32x4_t v22 = (float32x4_t *)v6[9];
  gm::operator*<double,4,4,4>(v28[0].f64, (double *)(v21 + 3160), (double *)v29);
  float32x4_t v23 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v28[2]), v28[3]);
  float32x4_t v24 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v28[4]), v28[5]);
  float32x4_t v25 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v28[6]), v28[7]);
  *float32x4_t v22 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v28[0]), v28[1]);
  v22[1] = v23;
  v22[2] = v24;
  v22[3] = v25;
  float32_t v26 = 1.0 / *(double *)(v21 + 976);
  v22[4].f32[0] = v26;
  unint64_t v27 = v6[8];
  if (v27 <= v20) {
    unint64_t v27 = v20;
  }
  v6[7] = 0;
  v6[8] = v27;
}

__n128 std::__function::__func<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_1,std::allocator<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51FFE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_1,std::allocator<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51FFE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_1,std::allocator<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &)>::~__func()
{
}

_DWORD *std::__function::__func<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &)>::operator()(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, unint64_t *a5)
{
  unint64_t v7 = (void *)md::VKMRenderResourcesStore::getConstantData<ggl::DaVinci::Shadow>(**(void **)(a1 + 8), *a5);
  __n128 result = (_DWORD *)md::VKMRenderResourcesStore::getRenderableData(**(void **)(a1 + 8), *a3);
  unint64_t v10 = v7[8];
  uint64_t v9 = (_DWORD *)v7[9];
  _DWORD *v9 = result[48];
  v9[1] = result[49];
  int v9[2] = result[50];
  v9[3] = result[51];
  v9[4] = result[52];
  v9[5] = result[53];
  v9[6] = result[54];
  v9[7] = result[55];
  v9[8] = result[56];
  v9[9] = result[57];
  v9[10] = result[58];
  v9[11] = result[59];
  v9[12] = result[60];
  v9[13] = result[61];
  v9[14] = result[62];
  unint64_t v11 = v7[1];
  v9[15] = result[63];
  if (v10 <= v11) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = v10;
  }
  v7[7] = 0;
  v7[8] = v12;
  return result;
}

uint64_t std::__function::__func<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51FFA0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF51FFA0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_0,std::allocator<md::ita::UpdateDepthPrePassConstants::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedTileMatrix const&,md::ls::PrepassConstantDataHandle &>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::SharedRenderableDataHandle const&,md::ls::InView const&,md::ls::PrepassShadowConstantDataHandle &)>::~__func()
{
}

uint64_t altitude::Context::getDebugRenderUtil(altitude::Context *this)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 1);
  if (v2 && !*((void *)this + 2))
  {
    uint64_t v4 = **(void **)(*(void *)(v2 + 112) + 24);
    uint64_t v5 = operator new(0x160uLL);
    v5[1] = 0;
    __int16 v5[2] = 0;
    *uint64_t v5 = &unk_1EF58AC10;
    v5[3] = &unk_1EF569000;
    v5[4] = 0;
    v5[7] = 0;
    v5[5] = 0;
    v5[6] = v5 + 7;
    v5[9] = 0;
    v5[10] = 0;
    v5[8] = 0;
    v5[43] = v4;
    uint64_t v6 = operator new(0xE8uLL);
    v6[1] = 0;
    v6[2] = 0;
    void *v6 = &unk_1EF586220;
    uint64_t v7 = ggl::BufferData::BufferData((uint64_t)(v6 + 3), qword_1E957CBC0, 2, 1, 6, 1);
    v6[28] = ggl::DebugRenderUtil::Global::reflection(void)::reflection;
    v6[3] = &unk_1EF55DB78;
    unint64_t v8 = (std::__shared_weak_count *)v5[10];
    v5[9] = v7;
    v5[10] = v6;
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    uint64_t v9 = *(void *)(v5[43] + 80);
    uint64_t v11 = *(void *)(v9 + 152);
    unint64_t v10 = *(std::__shared_weak_count **)(v9 + 160);
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    DWORD2(v21) = 0;
    *(void *)&long long v21 = 0;
    unint64_t v12 = (char *)operator new(0x198uLL);
    *((void *)v12 + 1) = 0;
    *((void *)v12 + 2) = 0;
    *(void *)unint64_t v12 = &unk_1EF583580;
    {
      if (v18)
      {
        {
          if (v18)
          {
            {
              {
                ggl::MeshTyped<ggl::DebugRenderUtil::P3NVbo>::attributesReflection(void)::r = (uint64_t)&ggl::DebugRenderUtil::p3NVboReflection;
              }
              ggl::MeshTyped<ggl::DebugRenderUtil::P3NVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::DebugRenderUtil::P3NVbo>::attributesReflection(void)::r;
              *(void *)algn_1E957D610 = 1;
            }
            ggl::ShadedColor::P3NPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::DebugRenderUtil::P3NVbo>::typedReflection(void)::r;
            *(void *)algn_1E9594F18 = &ggl::ShadedColor::pipelineDataP3NPipelineDeviceStructs(void)::ref;
            qword_1E9594F20 = 0;
            {
              ggl::ShadedColor::pipelineDataP3NPipelineConstantStructs(void)::ref = (uint64_t)ggl::DebugRenderUtil::Global::reflection(void)::reflection;
              unk_1E9595010 = ggl::ShadedColor::Props::reflection(void)::reflection;
            }
            qword_1E9594F28 = (uint64_t)&ggl::ShadedColor::pipelineDataP3NPipelineConstantStructs(void)::ref;
            *(_OWORD *)algn_1E9594F30 = xmmword_1A28FCED0;
          }
        }
        ggl::ShadedColor::P3NPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::ShadedColor::P3NPipelineSetup::typedReflection(void)::ref;
        ggl::ShadedColorShader::typedReflection(v18);
        qword_1E9594EC0 = (uint64_t)&ggl::ShadedColorShader::typedReflection(void)::ref;
        {
          ggl::ShadedColor::pipelineStateP3NPipelineAttributeStructBinding(void)::attr = 0;
          unk_1E9594F60 = 0;
          qword_1E9594F68 = (uint64_t)"";
          dword_1E9594F70 = 0;
          qword_1E9594F78 = (uint64_t)&ggl::ShadedColor::pipelineStateP3NPipelineAttributeBinding_0(void)::attr;
          unk_1E9594F80 = 2;
        }
        qword_1E9594EC8 = (uint64_t)&ggl::ShadedColor::pipelineStateP3NPipelineAttributeStructBinding(void)::attr;
        unk_1E9594ED0 = 1;
        qword_1E9594ED8 = 0;
        unk_1E9594EE0 = 0;
        qword_1E9594EE8 = (uint64_t)&ggl::ShadedColor::pipelineStateP3NPipelineDeviceStructBinding(void)::ref;
        unk_1E9594EF0 = 0;
        {
          ggl::ShadedColor::pipelineStateP3NPipelineConstantStructBinding(void)::ref = 0;
          unk_1E9594FA0 = 0;
          qword_1E9594FA8 = (uint64_t)"global";
          dword_1E9594FB0 = 3;
          qword_1E9594FB8 = (uint64_t)&ggl::ShadedColor::pipelineStateP3NPipelineConstantGlobalBinding(void)::reflection;
          unk_1E9594FC0 = xmmword_1A28FCEB0;
          qword_1E9594FD0 = 1;
          unk_1E9594FD8 = "props";
          dword_1E9594FE0 = 3;
          qword_1E9594FE8 = (uint64_t)&ggl::ShadedColor::pipelineStateP3NPipelineConstantPropsBinding(void)::reflection;
          unk_1E9594FF0 = 4;
        }
        qword_1E9594EF8 = (uint64_t)&ggl::ShadedColor::pipelineStateP3NPipelineConstantStructBinding(void)::ref;
        unk_1E9594F00 = 2;
      }
    }
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *((void *)v12 + 4) = 0;
    *((void *)v12 + 5) = 0;
    *((_DWORD *)v12 + 14) = 0;
    *((void *)v12 + 6) = 0;
    *((void *)v12 + 3) = &unk_1EF55B208;
    *((void *)v12 + 8) = &ggl::ShadedColor::P3NPipelineState::typedReflection(void)::ref;
    *((void *)v12 + 9) = v11;
    *((void *)v12 + 10) = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v12[136] = 0;
    *(_OWORD *)(v12 + 140) = xmmword_1A28FC970;
    *(void *)(v12 + 156) = 0;
    *(void *)(v12 + 172) = 0;
    *(void *)(v12 + 164) = 0;
    v12[184] = 0;
    *(_OWORD *)(v12 + 188) = xmmword_1A28FC970;
    *(void *)(v12 + 204) = 0;
    *(void *)(v12 + 220) = 0;
    *(void *)(v12 + 212) = 0;
    v12[232] = 0;
    *(_OWORD *)(v12 + 236) = xmmword_1A28FC970;
    *(void *)(v12 + 252) = 0;
    *(void *)(v12 + 268) = 0;
    *(void *)(v12 + 260) = 0;
    *((_DWORD *)v12 + 70) = 15;
    uint64_t v13 = v21;
    *((_DWORD *)v12 + 73) = DWORD2(v21);
    *(void *)(v12 + 284) = v13;
    *((void *)v12 + 37) = 1;
    *((void *)v12 + 38) = 1;
    v12[312] = 0;
    *((void *)v12 + 48) = 0;
    *((_OWORD *)v12 + 22) = 0u;
    *((_OWORD *)v12 + 23) = 0u;
    *((_OWORD *)v12 + 20) = 0u;
    *((_OWORD *)v12 + 21) = 0u;
    *((void *)v12 + 49) = 0x100000001;
    v12[400] = 0;
    v12[88] = 1;
    *(_WORD *)(v12 + 89) = v19;
    v12[91] = v20;
    *(_OWORD *)(v12 + 92) = xmmword_1A28FCEC0;
    *((_DWORD *)v12 + 27) = 7;
    *((void *)v12 + 14) = 0;
    *((void *)v12 + 15) = 0;
    *((_DWORD *)v12 + 32) = 0;
    v12[132] = 15;
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    *((void *)v12 + 3) = &unk_1EF55A8E0;
    uint64_t v14 = (std::__shared_weak_count *)v5[5];
    v5[4] = v12 + 24;
    v5[5] = v12;
    if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    long long v15 = (std::__shared_weak_count *)*((void *)this + 3);
    *((void *)this + 2) = v5 + 3;
    *((void *)this + 3) = v5;
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    uint64_t v16 = [*(id *)(*((void *)this + 1) + 104) renderer];
    long long v17 = (std::__shared_weak_count *)*((void *)this + 3);
    *(void *)&long long v21 = *((void *)this + 2);
    *((void *)&v21 + 1) = v17;
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      ggl::Renderer::addDebugRenderer(v16, &v21);
      if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    else
    {
      ggl::Renderer::addDebugRenderer(v16, &v21);
    }
  }
  return *((void *)this + 2);
}

uint64_t std::__shared_ptr_emplace<altitude::DebugRenderUtil>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<altitude::DebugRenderUtil>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AC10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<altitude::DebugRenderUtil>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AC10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A258B13C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::vector<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,geo::StdAllocator<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,mdm::Allocator>>::~vector[abi:nn180100]((uint64_t *)va1);

  _Unwind_Resume(a1);
}

double std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>> *,false>(void *a1, const void **a2, uint64_t a3, char a4)
{
__n128 std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>> *>(const void **a1, const void **a2, const void **a3)
{
  int v6 = *((char *)a2 + 23);
  if (v6 >= 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = *a2;
  }
  if (v6 >= 0) {
    size_t v8 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v8 = (size_t)a2[1];
  }
  int v9 = *((char *)a1 + 23);
  if (v9 >= 0) {
    unint64_t v10 = a1;
  }
  else {
    unint64_t v10 = *a1;
  }
  if (v9 >= 0) {
    size_t v11 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v11 = (size_t)a1[1];
  }
  if (v11 >= v8) {
    size_t v12 = v8;
  }
  else {
    size_t v12 = v11;
  }
  int v13 = memcmp(v7, v10, v12);
  if (v13)
  {
    if ((v13 & 0x80000000) == 0) {
      goto LABEL_18;
    }
LABEL_31:
    int v20 = *((char *)a3 + 23);
    if (v20 >= 0) {
      long long v21 = a3;
    }
    else {
      long long v21 = *a3;
    }
    if (v20 >= 0) {
      size_t v22 = *((unsigned __int8 *)a3 + 23);
    }
    else {
      size_t v22 = (size_t)a3[1];
    }
    if (v8 >= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v8;
    }
    int v24 = memcmp(v21, v7, v23);
    if (v24)
    {
      if ((v24 & 0x80000000) == 0)
      {
LABEL_42:
        size_t v25 = a1[2];
        __n128 v26 = *(__n128 *)a1;
        int v27 = a2[2];
        *(_OWORD *)a1 = *(_OWORD *)a2;
        a1[2] = v27;
        *(__n128 *)a2 = v26;
        a2[2] = v25;
        int v28 = *((char *)a3 + 23);
        if (v28 >= 0) {
          uint64_t v29 = a3;
        }
        else {
          uint64_t v29 = *a3;
        }
        if (v28 >= 0) {
          size_t v30 = *((unsigned __int8 *)a3 + 23);
        }
        else {
          size_t v30 = (size_t)a3[1];
        }
        int v31 = *((char *)a2 + 23);
        if (v31 >= 0) {
          int v32 = a2;
        }
        else {
          int v32 = *a2;
        }
        if (v31 >= 0) {
          size_t v33 = *((unsigned __int8 *)a2 + 23);
        }
        else {
          size_t v33 = (size_t)a2[1];
        }
        if (v33 >= v30) {
          size_t v34 = v30;
        }
        else {
          size_t v34 = v33;
        }
        int v35 = memcmp(v29, v32, v34);
        if (v35)
        {
          if ((v35 & 0x80000000) == 0) {
            return result;
          }
        }
        else if (v30 >= v33)
        {
          return result;
        }
        long long v47 = a2[2];
        __n128 result = *(__n128 *)a2;
        uint64_t v49 = a3[2];
        *(_OWORD *)a2 = *(_OWORD *)a3;
        a2[2] = v49;
        goto LABEL_83;
      }
    }
    else if (v22 >= v8)
    {
      goto LABEL_42;
    }
    long long v47 = a1[2];
    __n128 result = *(__n128 *)a1;
    long long v48 = a3[2];
    *(_OWORD *)a1 = *(_OWORD *)a3;
    a1[2] = v48;
LABEL_83:
    *(__n128 *)a3 = result;
    a3[2] = v47;
    return result;
  }
  if (v8 < v11) {
    goto LABEL_31;
  }
LABEL_18:
  int v14 = *((char *)a3 + 23);
  if (v14 >= 0) {
    unint64_t v15 = a3;
  }
  else {
    unint64_t v15 = *a3;
  }
  if (v14 >= 0) {
    size_t v16 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v16 = (size_t)a3[1];
  }
  if (v8 >= v16) {
    size_t v17 = v16;
  }
  else {
    size_t v17 = v8;
  }
  int v18 = memcmp(v15, v7, v17);
  if (v18)
  {
    if ((v18 & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v16 >= v8)
  {
    return result;
  }
  int v36 = a2[2];
  long long v37 = *(_OWORD *)a2;
  unint64_t v38 = a3[2];
  *(_OWORD *)a2 = *(_OWORD *)a3;
  a2[2] = v38;
  *(_OWORD *)a3 = v37;
  a3[2] = v36;
  int v39 = *((char *)a2 + 23);
  if (v39 >= 0) {
    uint64_t v40 = a2;
  }
  else {
    uint64_t v40 = *a2;
  }
  if (v39 >= 0) {
    size_t v41 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v41 = (size_t)a2[1];
  }
  int v42 = *((char *)a1 + 23);
  if (v42 >= 0) {
    size_t v43 = a1;
  }
  else {
    size_t v43 = *a1;
  }
  if (v42 >= 0) {
    size_t v44 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v44 = (size_t)a1[1];
  }
  if (v44 >= v41) {
    size_t v45 = v41;
  }
  else {
    size_t v45 = v44;
  }
  int v46 = memcmp(v40, v43, v45);
  if (v46)
  {
    if ((v46 & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v41 >= v44)
  {
    return result;
  }
  unint64_t v50 = a1[2];
  __n128 result = *(__n128 *)a1;
  unint64_t v51 = a2[2];
  *(_OWORD *)a1 = *(_OWORD *)a2;
  a1[2] = v51;
  *(__n128 *)a2 = result;
  a2[2] = v50;
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>> *>(uint64_t a1, long long *a2, long long *a3, const void **a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>> *>((const void **)a1, (const void **)a2, (const void **)a3);
  int v8 = *((char *)a4 + 23);
  if (v8 >= 0) {
    int v9 = a4;
  }
  else {
    int v9 = *a4;
  }
  if (v8 >= 0) {
    size_t v10 = *((unsigned __int8 *)a4 + 23);
  }
  else {
    size_t v10 = (size_t)a4[1];
  }
  int v11 = *((char *)a3 + 23);
  if (v11 >= 0) {
    size_t v12 = a3;
  }
  else {
    size_t v12 = *(const void **)a3;
  }
  if (v11 >= 0) {
    size_t v13 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v13 = *((void *)a3 + 1);
  }
  if (v13 >= v10) {
    size_t v14 = v10;
  }
  else {
    size_t v14 = v13;
  }
  int v15 = memcmp(v9, v12, v14);
  if (v15)
  {
    if ((v15 & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v10 >= v13)
  {
    return result;
  }
  size_t v17 = (const void *)*((void *)a3 + 2);
  long long v18 = *a3;
  long long v19 = a4[2];
  *a3 = *(_OWORD *)a4;
  *((void *)a3 + 2) = v19;
  *(_OWORD *)a4 = v18;
  a4[2] = v17;
  int v20 = *((char *)a3 + 23);
  if (v20 >= 0) {
    long long v21 = a3;
  }
  else {
    long long v21 = *(const void **)a3;
  }
  if (v20 >= 0) {
    size_t v22 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v22 = *((void *)a3 + 1);
  }
  int v23 = *((char *)a2 + 23);
  if (v23 >= 0) {
    int v24 = a2;
  }
  else {
    int v24 = *(const void **)a2;
  }
  if (v23 >= 0) {
    size_t v25 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v25 = *((void *)a2 + 1);
  }
  if (v25 >= v22) {
    size_t v26 = v22;
  }
  else {
    size_t v26 = v25;
  }
  int v27 = memcmp(v21, v24, v26);
  if (v27)
  {
    if ((v27 & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v22 >= v25)
  {
    return result;
  }
  uint64_t v28 = *((void *)a2 + 2);
  long long v29 = *a2;
  uint64_t v30 = *((void *)a3 + 2);
  *a2 = *a3;
  *((void *)a2 + 2) = v30;
  *a3 = v29;
  *((void *)a3 + 2) = v28;
  int v31 = *((char *)a2 + 23);
  if (v31 >= 0) {
    int v32 = a2;
  }
  else {
    int v32 = *(const void **)a2;
  }
  if (v31 >= 0) {
    size_t v33 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v33 = *((void *)a2 + 1);
  }
  int v34 = *(char *)(a1 + 23);
  if (v34 >= 0) {
    int v35 = (const void *)a1;
  }
  else {
    int v35 = *(const void **)a1;
  }
  if (v34 >= 0) {
    size_t v36 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    size_t v36 = *(void *)(a1 + 8);
  }
  if (v36 >= v33) {
    size_t v37 = v33;
  }
  else {
    size_t v37 = v36;
  }
  int v38 = memcmp(v32, v35, v37);
  if (v38)
  {
    if ((v38 & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v33 >= v36)
  {
    return result;
  }
  uint64_t v39 = *(void *)(a1 + 16);
  __n128 result = *(__n128 *)a1;
  uint64_t v40 = *((void *)a2 + 2);
  *(_OWORD *)a1 = *a2;
  *(void *)(a1 + 16) = v40;
  *a2 = (__int128)result;
  *((void *)a2 + 2) = v39;
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>> *>(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, const void **a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>> *>(a1, (long long *)a2, (long long *)a3, (const void **)a4);
  int v10 = *((char *)a5 + 23);
  if (v10 >= 0) {
    int v11 = a5;
  }
  else {
    int v11 = *a5;
  }
  if (v10 >= 0) {
    size_t v12 = *((unsigned __int8 *)a5 + 23);
  }
  else {
    size_t v12 = (size_t)a5[1];
  }
  int v13 = *((char *)a4 + 23);
  if (v13 >= 0) {
    size_t v14 = a4;
  }
  else {
    size_t v14 = *(long long **)a4;
  }
  if (v13 >= 0) {
    size_t v15 = *((unsigned __int8 *)a4 + 23);
  }
  else {
    size_t v15 = *((void *)a4 + 1);
  }
  if (v15 >= v12) {
    size_t v16 = v12;
  }
  else {
    size_t v16 = v15;
  }
  int v17 = memcmp(v11, v14, v16);
  if (v17)
  {
    if ((v17 & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v12 >= v15)
  {
    return result;
  }
  long long v19 = (const void *)*((void *)a4 + 2);
  long long v20 = *a4;
  long long v21 = a5[2];
  *a4 = *(_OWORD *)a5;
  *((void *)a4 + 2) = v21;
  *(_OWORD *)a5 = v20;
  a5[2] = v19;
  int v22 = *((char *)a4 + 23);
  if (v22 >= 0) {
    int v23 = a4;
  }
  else {
    int v23 = *(long long **)a4;
  }
  if (v22 >= 0) {
    size_t v24 = *((unsigned __int8 *)a4 + 23);
  }
  else {
    size_t v24 = *((void *)a4 + 1);
  }
  int v25 = *(char *)(a3 + 23);
  if (v25 >= 0) {
    size_t v26 = (const void *)a3;
  }
  else {
    size_t v26 = *(const void **)a3;
  }
  if (v25 >= 0) {
    size_t v27 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    size_t v27 = *(void *)(a3 + 8);
  }
  if (v27 >= v24) {
    size_t v28 = v24;
  }
  else {
    size_t v28 = v27;
  }
  int v29 = memcmp(v23, v26, v28);
  if (v29)
  {
    if ((v29 & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v24 >= v27)
  {
    return result;
  }
  uint64_t v30 = *(void *)(a3 + 16);
  long long v31 = *(_OWORD *)a3;
  uint64_t v32 = *((void *)a4 + 2);
  *(_OWORD *)a3 = *a4;
  *(void *)(a3 + 16) = v32;
  *a4 = v31;
  *((void *)a4 + 2) = v30;
  int v33 = *(char *)(a3 + 23);
  if (v33 >= 0) {
    int v34 = (const void *)a3;
  }
  else {
    int v34 = *(const void **)a3;
  }
  if (v33 >= 0) {
    size_t v35 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    size_t v35 = *(void *)(a3 + 8);
  }
  int v36 = *(char *)(a2 + 23);
  if (v36 >= 0) {
    size_t v37 = (const void *)a2;
  }
  else {
    size_t v37 = *(const void **)a2;
  }
  if (v36 >= 0) {
    size_t v38 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v38 = *(void *)(a2 + 8);
  }
  if (v38 >= v35) {
    size_t v39 = v35;
  }
  else {
    size_t v39 = v38;
  }
  int v40 = memcmp(v34, v37, v39);
  if (v40)
  {
    if ((v40 & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v35 >= v38)
  {
    return result;
  }
  uint64_t v41 = *(void *)(a2 + 16);
  long long v42 = *(_OWORD *)a2;
  uint64_t v43 = *(void *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(void *)(a2 + 16) = v43;
  *(_OWORD *)a3 = v42;
  *(void *)(a3 + 16) = v41;
  int v44 = *(char *)(a2 + 23);
  if (v44 >= 0) {
    size_t v45 = (const void *)a2;
  }
  else {
    size_t v45 = *(const void **)a2;
  }
  if (v44 >= 0) {
    size_t v46 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v46 = *(void *)(a2 + 8);
  }
  int v47 = *(char *)(a1 + 23);
  if (v47 >= 0) {
    long long v48 = (const void *)a1;
  }
  else {
    long long v48 = *(const void **)a1;
  }
  if (v47 >= 0) {
    size_t v49 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    size_t v49 = *(void *)(a1 + 8);
  }
  if (v49 >= v46) {
    size_t v50 = v46;
  }
  else {
    size_t v50 = v49;
  }
  int v51 = memcmp(v45, v48, v50);
  if (v51)
  {
    if ((v51 & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v46 >= v49)
  {
    return result;
  }
  uint64_t v52 = *(void *)(a1 + 16);
  __n128 result = *(__n128 *)a1;
  uint64_t v53 = *(void *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = v53;
  *(__n128 *)a2 = result;
  *(void *)(a2 + 16) = v52;
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>> *>(uint64_t a1, const void **a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = ((uint64_t)a2 - a1) >> 5;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v6 = a2 - 4;
      int v7 = *((char *)a2 - 9);
      if (v7 >= 0) {
        int v8 = a2 - 4;
      }
      else {
        int v8 = (const void **)*(a2 - 4);
      }
      if (v7 >= 0) {
        size_t v9 = *((unsigned __int8 *)a2 - 9);
      }
      else {
        size_t v9 = (size_t)*(a2 - 3);
      }
      int v10 = *(char *)(a1 + 23);
      if (v10 >= 0) {
        int v11 = (const void *)a1;
      }
      else {
        int v11 = *(const void **)a1;
      }
      if (v10 >= 0) {
        size_t v12 = *(unsigned __int8 *)(a1 + 23);
      }
      else {
        size_t v12 = *(void *)(a1 + 8);
      }
      if (v12 >= v9) {
        size_t v13 = v9;
      }
      else {
        size_t v13 = v12;
      }
      int v14 = memcmp(v8, v11, v13);
      if (v14)
      {
        if ((v14 & 0x80000000) == 0) {
          return 1;
        }
      }
      else if (v9 >= v12)
      {
        return 1;
      }
      int v40 = *(const void **)(a1 + 16);
      long long v41 = *(_OWORD *)a1;
      long long v42 = v6[2];
      *(_OWORD *)a1 = *(_OWORD *)v6;
      *(void *)(a1 + 16) = v42;
      *(_OWORD *)int v6 = v41;
      v6[2] = v40;
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>> *>((const void **)a1, (const void **)(a1 + 32), a2 - 4);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>> *>(a1, (long long *)(a1 + 32), (long long *)(a1 + 64), a2 - 4);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>> *>(a1, a1 + 32, a1 + 64, (long long *)(a1 + 96), a2 - 4);
      return 1;
    default:
      size_t v15 = (const void **)(a1 + 64);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>> *>((const void **)a1, (const void **)(a1 + 32), (const void **)(a1 + 64));
      size_t v16 = (const void **)(a1 + 96);
      if ((const void **)(a1 + 96) == v2) {
        return 1;
      }
      uint64_t v17 = 0;
      int v18 = 0;
      uint64_t v43 = v2;
      break;
  }
  while (2)
  {
    int v21 = *((char *)v16 + 23);
    if (v21 >= 0) {
      int v22 = v16;
    }
    else {
      int v22 = *v16;
    }
    if (v21 >= 0) {
      size_t v23 = *((unsigned __int8 *)v16 + 23);
    }
    else {
      size_t v23 = (size_t)v16[1];
    }
    int v24 = *((char *)v15 + 23);
    if (v24 >= 0) {
      int v25 = v15;
    }
    else {
      int v25 = *v15;
    }
    if (v24 >= 0) {
      size_t v26 = *((unsigned __int8 *)v15 + 23);
    }
    else {
      size_t v26 = (size_t)v15[1];
    }
    if (v26 >= v23) {
      size_t v27 = v23;
    }
    else {
      size_t v27 = v26;
    }
    int v28 = memcmp(v22, v25, v27);
    if (v28)
    {
      if ((v28 & 0x80000000) == 0) {
        goto LABEL_25;
      }
    }
    else if (v23 >= v26)
    {
      goto LABEL_25;
    }
    long long v29 = *((_OWORD *)v16 + 1);
    long long v44 = *(_OWORD *)v16;
    long long v45 = v29;
    *(_OWORD *)size_t v16 = *(_OWORD *)v15;
    v16[2] = v15[2];
    *((unsigned char *)v15 + 23) = 0;
    *(unsigned char *)size_t v15 = 0;
    uint64_t v19 = a1;
    if (v15 == (const void **)a1) {
      goto LABEL_24;
    }
    uint64_t v30 = v17;
    while (1)
    {
      uint64_t v31 = a1 + v30;
      uint64_t v32 = (_OWORD *)(a1 + v30 + 32);
      int v33 = (SBYTE7(v45) & 0x80u) == 0 ? &v44 : (long long *)v44;
      unint64_t v34 = (SBYTE7(v45) & 0x80u) == 0 ? BYTE7(v45) : *((void *)&v44 + 1);
      int v35 = *(char *)(v31 + 55);
      int v36 = v35 >= 0 ? (const void *)(a1 + v30 + 32) : *(const void **)(a1 + v30 + 32);
      unint64_t v37 = v35 >= 0 ? *(unsigned __int8 *)(v31 + 55) : *(void *)(v31 + 40);
      size_t v38 = v37 >= v34 ? v34 : v37;
      int v39 = memcmp(v33, v36, v38);
      if (!v39) {
        break;
      }
      if ((v39 & 0x80000000) == 0)
      {
        uint64_t v19 = a1 + v30 + 64;
        goto LABEL_23;
      }
LABEL_48:
      v15 -= 4;
      *(_OWORD *)(v31 + 64) = *v32;
      *(void *)(v31 + 80) = *(void *)(a1 + v30 + 48);
      *(unsigned char *)(v31 + 55) = 0;
      *(unsigned char *)uint64_t v32 = 0;
      v30 -= 32;
      if (v30 == -64)
      {
        uint64_t v19 = a1;
        goto LABEL_23;
      }
    }
    if (v34 < v37) {
      goto LABEL_48;
    }
    uint64_t v19 = (uint64_t)v15;
LABEL_23:
    uint64_t v2 = v43;
LABEL_24:
    long long v20 = v44;
    *(void *)(v19 + 16) = v45;
    *(_OWORD *)uint64_t v19 = v20;
    if (++v18 == 8) {
      return v16 + 4 == v2;
    }
LABEL_25:
    size_t v15 = v16;
    v17 += 32;
    v16 += 4;
    if (v16 != v2) {
      continue;
    }
    return 1;
  }
}

void sub_1A258D03C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (SHIBYTE(a15) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a16 + 40))(a16, a13, a15 & 0x7FFFFFFFFFFFFFFFLL);
  }

  _Unwind_Resume(a1);
}

void sub_1A258D294(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A258D620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A258D7AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A258D93C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void sub_1A258DA90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a15 == v15)
  {
    (*(void (**)(uint64_t *))(a12 + 32))(&a12);
    _Unwind_Resume(exception_object);
  }
  if (a15)
  {
    (*(void (**)(void))(*(void *)a15 + 40))();
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A258DC00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A258DDC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A258DF04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A258E040(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A258E5A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A258E7EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A258EB30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A258ED14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A258ED38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A258EE1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A258F084(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A258F1C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2590248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,id a36)
{
  *(void *)(v38 + 72) = v37;
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a30);
  NavRoadSegment::~NavRoadSegment(&a36);

  _Unwind_Resume(a1);
}

void *std::vector<NavRoadSegment,geo::StdAllocator<NavRoadSegment,mdm::Allocator>>::__push_back_slow_path<NavRoadSegment const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x492492492492492) {
    abort();
  }
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3);
  }
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 3)) >= 0x249249249249249) {
    uint64_t v6 = 0x492492492492492;
  }
  else {
    uint64_t v6 = v3;
  }
  uint64_t v30 = a1 + 3;
  if (v6) {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 56 * v6, 8);
  }
  else {
    uint64_t v7 = 0;
  }
  int v8 = (void *)(v7 + 56 * v2);
  uint64_t v9 = v7 + 56 * v6;
  if (v7)
  {
    *int v8 = 0;
    v8[1] = 0;
    uint64_t v10 = *(void *)(a2 + 24);
    uint64_t v8[2] = 0;
    v8[3] = v10;
    int v11 = *(char **)a2;
    size_t v12 = *(char **)(a2 + 8);
    uint64_t v13 = (uint64_t)&v12[-*(void *)a2];
    if (v12 != *(char **)a2)
    {
      if (v13 < 0) {
        abort();
      }
      int v14 = (_OWORD *)(*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)v10 + 16))(v10, &v12[-*(void *)a2], 8);
      *int v8 = v14;
      v8[1] = v14;
      uint64_t v8[2] = &v14[v13 >> 4];
      do
      {
        if (v14) {
          *int v14 = *(_OWORD *)v11;
        }
        v11 += 16;
        ++v14;
      }
      while (v11 != v12);
      v8[1] = v14;
    }
    uint64_t v15 = v7 + 56 * v2;
    *(void *)(v15 + 32) = *(id *)(a2 + 32);
    *(void *)(v15 + 40) = *(id *)(a2 + 40);
    *(unsigned char *)(v15 + 48) = *(unsigned char *)(a2 + 48);
  }
  size_t v16 = v8 + 7;
  uint64_t v17 = *a1;
  uint64_t v18 = a1[1];
  if (v18 == *a1)
  {
    *a1 = (uint64_t)v8;
    a1[1] = (uint64_t)v16;
    uint64_t v25 = a1[2];
    a1[2] = v9;
  }
  else
  {
    unint64_t v19 = 0;
    do
    {
      long long v20 = &v8[v19 / 8];
      uint64_t v21 = v18 + v19;
      *(v20 - 7) = 0;
      *(v20 - 6) = 0;
      *(v20 - 5) = 0;
      *(v20 - 4) = *(void *)(v18 + v19 - 32);
      *(_OWORD *)(v20 - 7) = *(_OWORD *)(v18 + v19 - 56);
      *(v20 - 5) = *(void *)(v18 + v19 - 40);
      *(void *)(v21 - 56) = 0;
      *(void *)(v21 - 48) = 0;
      *(void *)(v21 - 40) = 0;
      long long v22 = *(_OWORD *)(v18 + v19 - 24);
      *(void *)(v21 - 24) = 0;
      *(void *)(v21 - 16) = 0;
      *(_OWORD *)(v20 - 3) = v22;
      *((unsigned char *)v20 - 8) = *(unsigned char *)(v18 + v19 - 8);
      v19 -= 56;
    }
    while (v18 + v19 != v17);
    size_t v23 = &v8[v19 / 8];
    uint64_t v18 = *a1;
    uint64_t v24 = a1[1];
    *a1 = (uint64_t)v23;
    a1[1] = (uint64_t)v16;
    uint64_t v25 = a1[2];
    a1[2] = v9;
    if (v24 != v18)
    {
      uint64_t v26 = v24;
      do
      {

        uint64_t v28 = *(void *)(v26 - 56);
        v26 -= 56;
        uint64_t v27 = v28;
        if (v28)
        {
          *(void *)(v24 - 48) = v27;
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v24 - 32) + 40))(*(void *)(v24 - 32), v27, *(void *)(v24 - 40) - v27);
        }
        uint64_t v24 = v26;
      }
      while (v26 != v18);
    }
  }
  if (v18) {
    (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v30 + 40))(*v30, v18, v25 - v18);
  }
  return v16;
}

void sub_1A25906EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<NavRoadSegment,geo::StdAllocator<NavRoadSegment,mdm::Allocator> &>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void NavRoadFeature::~NavRoadFeature(NavRoadFeature *this)
{
  uint64_t v2 = *((void *)this + 8);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 9);
    uint64_t v4 = *((void *)this + 8);
    if (v3 != v2)
    {
      uint64_t v5 = *((void *)this + 9);
      do
      {

        uint64_t v7 = *(void *)(v5 - 56);
        v5 -= 56;
        uint64_t v6 = v7;
        if (v7)
        {
          *(void *)(v3 - 48) = v6;
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v3 - 32) + 40))(*(void *)(v3 - 32), v6, *(void *)(v3 - 40) - v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = *((void *)this + 8);
    }
    *((void *)this + 9) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 11) + 40))(*((void *)this + 11), v4, *((void *)this + 10) - v4);
  }
  if ((*((char *)this + 55) & 0x80000000) == 0)
  {
    if ((*((char *)this + 23) & 0x80000000) == 0) {
      return;
    }
LABEL_13:
    (*(void (**)(void, void, uint64_t))(**((void **)this + 3) + 40))(*((void *)this + 3), *(void *)this, *((void *)this + 2) & 0x7FFFFFFFFFFFFFFFLL);
    return;
  }
  (*(void (**)(void, void, uint64_t))(**((void **)this + 7) + 40))(*((void *)this + 7), *((void *)this + 4), *((void *)this + 6) & 0x7FFFFFFFFFFFFFFFLL);
  if (*((char *)this + 23) < 0) {
    goto LABEL_13;
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<NavRoadFeature>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<NavRoadFeature>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<NavRoadFeature>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,geo::StdAllocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<NavRoadFeature>>,mdm::Allocator>>::__emplace_unique_key_args<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>&&>,std::tuple<>>(float *a1, uint64_t a2, _OWORD **a3)
{
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    uint64_t v7 = (uint64_t *)a2;
  }
  else {
    uint64_t v7 = *(uint64_t **)a2;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a2 + 8);
  }
  unint64_t v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
  unint64_t v10 = v9;
  unint64_t v11 = *((void *)a1 + 1);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v3 = v9;
      if (v9 >= v11) {
        unint64_t v3 = v9 % v11;
      }
    }
    else
    {
      unint64_t v3 = (v11 - 1) & v9;
    }
    uint64_t v13 = *(uint64_t **)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      uint64_t v14 = *v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v19 = *(void *)(v14 + 8);
            if (v19 == v10)
            {
              uint64_t v20 = *(unsigned __int8 *)(v14 + 39);
              if ((v20 & 0x80u) == 0) {
                uint64_t v21 = *(unsigned __int8 *)(v14 + 39);
              }
              else {
                uint64_t v21 = *(void *)(v14 + 24);
              }
              if (v21 == v8)
              {
                if ((v20 & 0x80) != 0)
                {
                  if (!memcmp(*(const void **)(v14 + 16), v7, *(void *)(v14 + 24))) {
                    return v14;
                  }
                }
                else
                {
                  if (!*(unsigned char *)(v14 + 39)) {
                    return v14;
                  }
                  uint64_t v22 = 0;
                  while (*(unsigned __int8 *)(v14 + v22 + 16) == *((unsigned __int8 *)v7 + v22))
                  {
                    if (v20 == ++v22) {
                      return v14;
                    }
                  }
                }
              }
            }
            else if ((v19 & (v11 - 1)) != v3)
            {
              goto LABEL_49;
            }
            uint64_t v14 = *(void *)v14;
            if (!v14) {
              goto LABEL_49;
            }
          }
        }
        do
        {
          unint64_t v15 = *(void *)(v14 + 8);
          if (v15 == v10)
          {
            uint64_t v16 = *(unsigned __int8 *)(v14 + 39);
            if ((v16 & 0x80u) == 0) {
              uint64_t v17 = *(unsigned __int8 *)(v14 + 39);
            }
            else {
              uint64_t v17 = *(void *)(v14 + 24);
            }
            if (v17 == v8)
            {
              if ((v16 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v14 + 16), v7, *(void *)(v14 + 24))) {
                  return v14;
                }
              }
              else
              {
                if (!*(unsigned char *)(v14 + 39)) {
                  return v14;
                }
                uint64_t v18 = 0;
                while (*(unsigned __int8 *)(v14 + v18 + 16) == *((unsigned __int8 *)v7 + v18))
                {
                  if (v16 == ++v18) {
                    return v14;
                  }
                }
              }
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v3) {
              break;
            }
          }
          uint64_t v14 = *(void *)v14;
        }
        while (v14);
      }
    }
  }
LABEL_49:
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 4) + 16))(*((void *)a1 + 4), 64, 8);
  *(void *)uint64_t v14 = 0;
  *(void *)(v14 + 8) = v10;
  size_t v23 = *a3;
  long long v24 = (*a3)[1];
  *(_OWORD *)(v14 + 16) = **a3;
  *(_OWORD *)(v14 + 32) = v24;
  v23[1] = 0;
  __int16 v23[2] = 0;
  *size_t v23 = 0;
  *(void *)(v14 + 48) = 0;
  *(void *)(v14 + 56) = 0;
  float v25 = (float)(unint64_t)(*((void *)a1 + 5) + 1);
  float v26 = a1[12];
  if (!v11 || (float)(v26 * (float)v11) < v25)
  {
    BOOL v27 = 1;
    if (v11 >= 3) {
      BOOL v27 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v28 = v27 | (2 * v11);
    unint64_t v29 = vcvtps_u32_f32(v25 / v26);
    if (v28 <= v29) {
      size_t prime = v29;
    }
    else {
      size_t prime = v28;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v11 = *((void *)a1 + 1);
    if (prime <= v11)
    {
      if (prime >= v11) {
        goto LABEL_85;
      }
      unint64_t v42 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 5) / a1[12]);
      if (v11 < 3 || (uint8x8_t v43 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v43.i16[0] = vaddlv_u8(v43), v43.u32[0] > 1uLL))
      {
        unint64_t v42 = std::__next_prime(v42);
      }
      else
      {
        uint64_t v44 = 1 << -(char)__clz(v42 - 1);
        if (v42 >= 2) {
          unint64_t v42 = v44;
        }
      }
      if (prime <= v42) {
        size_t prime = v42;
      }
      if (prime >= v11)
      {
        unint64_t v11 = *((void *)a1 + 1);
LABEL_85:
        if ((v11 & (v11 - 1)) != 0)
        {
          if (v10 >= v11) {
            unint64_t v3 = v10 % v11;
          }
          else {
            unint64_t v3 = v10;
          }
        }
        else
        {
          unint64_t v3 = (v11 - 1) & v10;
        }
        goto LABEL_98;
      }
      if (!prime)
      {
        uint64_t v51 = *(void *)a1;
        *(void *)a1 = 0;
        if (v51) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 2) + 40))(*((void *)a1 + 2), v51, 8 * *((void *)a1 + 1));
        }
        unint64_t v11 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_85;
      }
    }
    uint64_t v31 = (*(uint64_t (**)(uint64_t, size_t, uint64_t))(**((void **)a1 + 2) + 16))(*((void *)a1 + 2), 8 * prime, 8);
    uint64_t v32 = *(void *)a1;
    *(void *)a1 = v31;
    if (v32) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 2) + 40))(*((void *)a1 + 2), v32, 8 * *((void *)a1 + 1));
    }
    uint64_t v33 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v33++) = 0;
    while (prime != v33);
    int v35 = (uint64_t *)(a1 + 6);
    unint64_t v34 = (void *)*((void *)a1 + 3);
    if (!v34)
    {
LABEL_84:
      unint64_t v11 = prime;
      goto LABEL_85;
    }
    size_t v36 = v34[1];
    size_t v37 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v38 = v36 & v37;
      *(void *)(*(void *)a1 + 8 * v38) = v35;
      for (uint64_t i = (void *)*v34; *v34; uint64_t i = (void *)*v34)
      {
        size_t v40 = i[1] & v37;
        if (v40 == v38)
        {
          unint64_t v34 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v40))
        {
          *unint64_t v34 = *i;
          uint64_t v41 = 8 * v40;
          void *i = **(void **)(*(void *)a1 + v41);
          **(void **)(*(void *)a1 + v41) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v40) = v34;
          unint64_t v34 = i;
          size_t v38 = v40;
        }
      }
      goto LABEL_84;
    }
    if (v36 >= prime) {
      v36 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v36) = v35;
    long long v45 = (void *)*v34;
    if (!*v34) {
      goto LABEL_84;
    }
    while (1)
    {
      size_t v47 = v45[1];
      if (v47 >= prime) {
        v47 %= prime;
      }
      if (v47 != v36)
      {
        if (!*(void *)(*(void *)a1 + 8 * v47))
        {
          *(void *)(*(void *)a1 + 8 * v47) = v34;
          goto LABEL_89;
        }
        *unint64_t v34 = *v45;
        uint64_t v46 = 8 * v47;
        *long long v45 = **(void **)(*(void *)a1 + v46);
        **(void **)(*(void *)a1 + v46) = v45;
        long long v45 = v34;
      }
      size_t v47 = v36;
LABEL_89:
      unint64_t v34 = v45;
      long long v45 = (void *)*v45;
      size_t v36 = v47;
      if (!v45) {
        goto LABEL_84;
      }
    }
  }
LABEL_98:
  long long v48 = *(uint64_t **)(*(void *)a1 + 8 * v3);
  if (v48)
  {
    *(void *)uint64_t v14 = *v48;
LABEL_106:
    *long long v48 = v14;
    goto LABEL_107;
  }
  *(void *)uint64_t v14 = *((void *)a1 + 3);
  *((void *)a1 + 3) = v14;
  *(void *)(*(void *)a1 + 8 * v3) = a1 + 6;
  if (*(void *)v14)
  {
    unint64_t v49 = *(void *)(*(void *)v14 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v49 >= v11) {
        v49 %= v11;
      }
    }
    else
    {
      v49 &= v11 - 1;
    }
    long long v48 = (uint64_t *)(*(void *)a1 + 8 * v49);
    goto LABEL_106;
  }
LABEL_107:
  ++*((void *)a1 + 5);
  return v14;
}

void sub_1A2590E38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void NavRoadSegment::~NavRoadSegment(id *this)
{
  id v2 = *this;
  if (*this)
  {
    this[1] = v2;
    (*(void (**)(id, id, int64_t))(*(void *)this[3] + 40))(this[3], v2, (unsigned char *)this[2] - (unsigned char *)v2);
  }
}

NavRoadFeature *std::__shared_ptr_pointer<NavRoadFeature *,std::shared_ptr<NavRoadFeature>::__shared_ptr_default_delete<NavRoadFeature,NavRoadFeature>,std::allocator<NavRoadFeature>>::__on_zero_shared(uint64_t a1)
{
  BOOL result = *(NavRoadFeature **)(a1 + 24);
  if (result)
  {
    NavRoadFeature::~NavRoadFeature(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<NavRoadFeature *,std::shared_ptr<NavRoadFeature>::__shared_ptr_default_delete<NavRoadFeature,NavRoadFeature>,std::allocator<NavRoadFeature>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__split_buffer<NavRoadSegment,geo::StdAllocator<NavRoadSegment,mdm::Allocator> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 56;

    uint64_t v4 = *(void *)(i - 56);
    if (v4)
    {
      *(void *)(i - 48) = v4;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(i - 32) + 40))(*(void *)(i - 32), v4, *(void *)(i - 40) - v4);
    }
  }
  if (*(void *)a1) {
    (*(void (**)(void, void, void))(***(void ***)(a1 + 32) + 40))(**(void **)(a1 + 32), *(void *)a1, *(void *)(a1 + 24) - *(void *)a1);
  }
  return a1;
}

void sub_1A2591408(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t lineSegmentIntersectsRectangle(float *a1, float a2, float a3, float a4, float a5)
{
  float v5 = *a1;
  if (*a1 >= a2)
  {
    int v6 = 1;
  }
  else if (a1[2] <= a2)
  {
    int v6 = 4;
  }
  else
  {
    int v6 = 0;
  }
  float v7 = a1[3];
  if (v7 <= a3)
  {
    v6 |= 2u;
    if (v5 >= a4) {
      goto LABEL_10;
    }
  }
  else
  {
    if (a1[1] >= a3) {
      v6 |= 8u;
    }
    if (v5 >= a4)
    {
LABEL_10:
      int v8 = 1;
      if (v7 <= a5) {
        goto LABEL_11;
      }
LABEL_18:
      if (a1[1] >= a5) {
        v8 |= 8u;
      }
      if ((v8 & v6) != 0) {
        return 0;
      }
      goto LABEL_22;
    }
  }
  if (a1[2] <= a4) {
    int v8 = 4;
  }
  else {
    int v8 = 0;
  }
  if (v7 > a5) {
    goto LABEL_18;
  }
LABEL_11:
  v8 |= 2u;
  if ((v8 & v6) != 0) {
    return 0;
  }
LABEL_22:
  if (v8 | v6)
  {
    float v11 = a1[1];
    float v10 = a1[2];
    float v12 = a4 - a2;
    float v13 = a5 - a3;
    float v14 = (float)(v7 - v11) * v12;
    if (fabsf(v14) < 0.00000011921) {
      goto LABEL_33;
    }
    float v15 = (float)((float)(v7 - v11) * (float)(v5 - a2)) / v14;
    if (v15 >= 0.0)
    {
      BOOL v16 = v15 == 1.0;
      BOOL v17 = v15 < 1.0;
    }
    else
    {
      BOOL v16 = 0;
      BOOL v17 = 0;
    }
    if (!v17 && !v16
      || ((float v18 = (float)((float)((float)(a3 - v11) * v12) + (float)((float)(v5 - a2) * v13)) / v14, v18 >= 0.0)
        ? (BOOL v19 = v18 == 1.0, v20 = v18 < 1.0)
        : (BOOL v19 = 0, v20 = 0),
          !v20 && !v19))
    {
LABEL_33:
      float v21 = v13 * (float)(v5 - v10);
      if (fabsf(v21) < 0.00000011921) {
        goto LABEL_62;
      }
      float v22 = (float)((float)(v7 - a3) * (float)(v5 - v10)) / v21;
      if (v22 >= 0.0)
      {
        BOOL v23 = v22 == 1.0;
        BOOL v24 = v22 < 1.0;
      }
      else
      {
        BOOL v23 = 0;
        BOOL v24 = 0;
      }
      if (!v24 && !v23
        || ((float v25 = (float)-(float)((float)((float)(v7 - a3) * v12) + (float)((float)(a2 - v5) * v13)) / v21, v25 >= 0.0)
          ? (BOOL v26 = v25 == 1.0, v27 = v25 < 1.0)
          : (BOOL v26 = 0, v27 = 0),
            !v27 && !v26))
      {
LABEL_62:
        float v28 = (float)(v11 - v7) * v12;
        if (fabsf(v28) < 0.00000011921) {
          goto LABEL_67;
        }
        float v29 = (float)((float)(v11 - v7) * (float)(v10 - a2)) / v28;
        if (v29 >= 0.0)
        {
          BOOL v30 = v29 == 1.0;
          BOOL v31 = v29 < 1.0;
        }
        else
        {
          BOOL v30 = 0;
          BOOL v31 = 0;
        }
        if (!v31 && !v30
          || ((float v32 = (float)((float)((float)(a3 - v7) * v12) + (float)((float)(v10 - a2) * v13)) / v28, v32 >= 0.0)
            ? (v33 = v32 == 1.0, BOOL v34 = v32 < 1.0)
            : (v33 = 0, BOOL v34 = 0),
              !v34 && !v33))
        {
LABEL_67:
          float v35 = v10 - v5;
          float v36 = v13 * (float)(v10 - v5);
          if (fabsf(v36) < 0.00000011921) {
            return 0;
          }
          float v37 = v11 - a3;
          float v38 = (float)(v37 * v35) / v36;
          if (v38 >= 0.0)
          {
            BOOL v39 = v38 == 1.0;
            BOOL v40 = v38 < 1.0;
          }
          else
          {
            BOOL v39 = 0;
            BOOL v40 = 0;
          }
          if (!v40 && !v39) {
            return 0;
          }
          float v41 = (float)-(float)((float)(v37 * v12) + (float)((float)(a2 - v10) * v13)) / v36;
          if (v41 >= 0.0)
          {
            BOOL v42 = v41 == 1.0;
            BOOL v43 = v41 < 1.0;
          }
          else
          {
            BOOL v42 = 0;
            BOOL v43 = 0;
          }
          if (!v43 && !v42) {
            return 0;
          }
        }
      }
    }
  }
  return 1;
}

void sub_1A2592024(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 88);
  if (v3)
  {
    *(void *)(v1 + 96) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 112) + 40))(*(void *)(v1 + 112), v3, *(void *)(v1 + 104) - v3);
  }
  uint64_t v4 = *(void *)(v1 + 120);
  if (v4)
  {
    *(void *)(v1 + 128) = v4;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 144) + 40))(*(void *)(v1 + 144), v4, *(void *)(v1 + 136) - v4);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A259227C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2592474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_1A25924FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2592D40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  std::vector<OffRouteJunctionInfo,geo::StdAllocator<OffRouteJunctionInfo,mdm::Allocator>>::~vector[abi:nn180100](&a29);

  _Unwind_Resume(a1);
}

uint64_t *std::vector<OffRouteJunctionInfo,geo::StdAllocator<OffRouteJunctionInfo,mdm::Allocator>>::~vector[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        float v5 = *(void **)(v3 - 16);
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v4, a1[2] - v4);
  }
  return a1;
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,-[VKLabelNavRoadGraph(junctionlist) offRouteGraphJunctionsWithNavContext:maxJunctions:isOnRoute:]::$_2 &,OffRouteJunctionInfo *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = *(unsigned __int8 *)(a2 + 8);
  float v7 = *(float *)(a2 + 12);
  unsigned int v8 = *(unsigned __int8 *)(a1 + 8);
  BOOL v9 = v6 == v8;
  BOOL v10 = v6 < v8;
  if (v9) {
    BOOL v10 = v7 < *(float *)(a1 + 12);
  }
  unsigned int v11 = *(unsigned __int8 *)(a3 + 8);
  BOOL v9 = v11 == v6;
  BOOL v12 = v11 < v6;
  if (v9) {
    BOOL v12 = *(float *)(a3 + 12) < v7;
  }
  if (v10)
  {
    float v14 = *(void **)a1;
    uint64_t v13 = *(void *)(a1 + 8);
    *(void *)a1 = 0;
    if (v12)
    {
      float v15 = *(void **)a3;
      *(void *)a3 = 0;
      BOOL v16 = *(void **)a1;
      *(void *)a1 = v15;

      *(void *)(a1 + 8) = *(void *)(a3 + 8);
      BOOL v17 = *(void **)a3;
      *(void *)a3 = v14;
LABEL_17:

      *(void *)(a3 + 8) = v13;
      return;
    }
    BOOL v31 = *(void **)a2;
    *(void *)a2 = 0;
    float v32 = *(void **)a1;
    *(void *)a1 = v31;

    *(void *)(a1 + 8) = *(void *)(a2 + 8);
    BOOL v33 = *(void **)a2;
    *(void *)a2 = v14;

    *(void *)(a2 + 8) = v13;
    unsigned int v34 = *(unsigned __int8 *)(a3 + 8);
    BOOL v9 = v34 == v13;
    BOOL v35 = v34 < v13;
    if (v9) {
      BOOL v35 = *(float *)(a3 + 12) < *((float *)&v13 + 1);
    }
    if (v35)
    {
      float v36 = *(void **)a2;
      *(void *)a2 = 0;
      float v37 = *(void **)a3;
      *(void *)a3 = 0;
      float v38 = *(void **)a2;
      *(void *)a2 = v37;

      *(void *)(a2 + 8) = *(void *)(a3 + 8);
      BOOL v17 = *(void **)a3;
      *(void *)a3 = v36;
      goto LABEL_17;
    }
  }
  else if (v12)
  {
    float v18 = *(void **)a2;
    uint64_t v19 = *(void *)(a2 + 8);
    *(void *)a2 = 0;
    BOOL v20 = *(void **)a3;
    *(void *)a3 = 0;
    float v21 = *(void **)a2;
    *(void *)a2 = v20;

    *(void *)(a2 + 8) = *(void *)(a3 + 8);
    float v22 = *(void **)a3;
    *(void *)a3 = v18;

    *(void *)(a3 + 8) = v19;
    unsigned int v23 = *(unsigned __int8 *)(a2 + 8);
    unsigned int v24 = *(unsigned __int8 *)(a1 + 8);
    BOOL v9 = v23 == v24;
    BOOL v25 = v23 < v24;
    if (v9) {
      BOOL v25 = *(float *)(a2 + 12) < *(float *)(a1 + 12);
    }
    if (v25)
    {
      BOOL v26 = *(void **)a1;
      uint64_t v27 = *(void *)(a1 + 8);
      *(void *)a1 = 0;
      float v28 = *(void **)a2;
      *(void *)a2 = 0;
      float v29 = *(void **)a1;
      *(void *)a1 = v28;

      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      BOOL v30 = *(void **)a2;
      *(void *)a2 = v26;

      *(void *)(a2 + 8) = v27;
    }
  }
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,-[VKLabelNavRoadGraph(junctionlist) offRouteGraphJunctionsWithNavContext:maxJunctions:isOnRoute:]::$_2 &,OffRouteJunctionInfo *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,-[VKLabelNavRoadGraph(junctionlist) offRouteGraphJunctionsWithNavContext:maxJunctions:isOnRoute:]::$_2 &,OffRouteJunctionInfo *>(a1, a2, a3);
  unsigned int v8 = *(unsigned __int8 *)(a4 + 8);
  unsigned int v9 = *(unsigned __int8 *)(a3 + 8);
  BOOL v10 = v8 == v9;
  BOOL v11 = v8 < v9;
  if (v10) {
    BOOL v11 = *(float *)(a4 + 12) < *(float *)(a3 + 12);
  }
  if (v11)
  {
    BOOL v12 = *(void **)a3;
    uint64_t v13 = *(void *)(a3 + 8);
    *(void *)a3 = 0;
    float v14 = *(void **)a4;
    *(void *)a4 = 0;
    float v15 = *(void **)a3;
    *(void *)a3 = v14;

    *(void *)(a3 + 8) = *(void *)(a4 + 8);
    BOOL v16 = *(void **)a4;
    *(void *)a4 = v12;

    *(void *)(a4 + 8) = v13;
    unsigned int v17 = *(unsigned __int8 *)(a3 + 8);
    unsigned int v18 = *(unsigned __int8 *)(a2 + 8);
    BOOL v10 = v17 == v18;
    BOOL v19 = v17 < v18;
    if (v10) {
      BOOL v19 = *(float *)(a3 + 12) < *(float *)(a2 + 12);
    }
    if (v19)
    {
      BOOL v20 = *(void **)a2;
      uint64_t v21 = *(void *)(a2 + 8);
      *(void *)a2 = 0;
      float v22 = *(void **)a3;
      *(void *)a3 = 0;
      unsigned int v23 = *(void **)a2;
      *(void *)a2 = v22;

      *(void *)(a2 + 8) = *(void *)(a3 + 8);
      unsigned int v24 = *(void **)a3;
      *(void *)a3 = v20;

      *(void *)(a3 + 8) = v21;
      unsigned int v25 = *(unsigned __int8 *)(a2 + 8);
      unsigned int v26 = *(unsigned __int8 *)(a1 + 8);
      BOOL v10 = v25 == v26;
      BOOL v27 = v25 < v26;
      if (v10) {
        BOOL v27 = *(float *)(a2 + 12) < *(float *)(a1 + 12);
      }
      if (v27)
      {
        float v28 = *(void **)a1;
        uint64_t v29 = *(void *)(a1 + 8);
        *(void *)a1 = 0;
        BOOL v30 = *(void **)a2;
        *(void *)a2 = 0;
        BOOL v31 = *(void **)a1;
        *(void *)a1 = v30;

        *(void *)(a1 + 8) = *(void *)(a2 + 8);
        float v32 = *(void **)a2;
        *(void *)a2 = v28;

        *(void *)(a2 + 8) = v29;
      }
    }
  }
}

void std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,-[VKLabelNavRoadGraph(junctionlist) offRouteGraphJunctionsWithNavContext:maxJunctions:isOnRoute:]::$_2 &,OffRouteJunctionInfo *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,-[VKLabelNavRoadGraph(junctionlist) offRouteGraphJunctionsWithNavContext:maxJunctions:isOnRoute:]::$_2 &,OffRouteJunctionInfo *>(a1, a2, a3, a4);
  unsigned int v10 = *(unsigned __int8 *)(a5 + 8);
  unsigned int v11 = *(unsigned __int8 *)(a4 + 8);
  BOOL v12 = v10 == v11;
  BOOL v13 = v10 < v11;
  if (v12) {
    BOOL v13 = *(float *)(a5 + 12) < *(float *)(a4 + 12);
  }
  if (v13)
  {
    float v14 = *(void **)a4;
    uint64_t v15 = *(void *)(a4 + 8);
    *(void *)a4 = 0;
    BOOL v16 = *(void **)a5;
    *(void *)a5 = 0;
    unsigned int v17 = *(void **)a4;
    *(void *)a4 = v16;

    *(void *)(a4 + 8) = *(void *)(a5 + 8);
    unsigned int v18 = *(void **)a5;
    *(void *)a5 = v14;

    *(void *)(a5 + 8) = v15;
    unsigned int v19 = *(unsigned __int8 *)(a4 + 8);
    unsigned int v20 = *(unsigned __int8 *)(a3 + 8);
    BOOL v12 = v19 == v20;
    BOOL v21 = v19 < v20;
    if (v12) {
      BOOL v21 = *(float *)(a4 + 12) < *(float *)(a3 + 12);
    }
    if (v21)
    {
      float v22 = *(void **)a3;
      uint64_t v23 = *(void *)(a3 + 8);
      *(void *)a3 = 0;
      unsigned int v24 = *(void **)a4;
      *(void *)a4 = 0;
      unsigned int v25 = *(void **)a3;
      *(void *)a3 = v24;

      *(void *)(a3 + 8) = *(void *)(a4 + 8);
      unsigned int v26 = *(void **)a4;
      *(void *)a4 = v22;

      *(void *)(a4 + 8) = v23;
      unsigned int v27 = *(unsigned __int8 *)(a3 + 8);
      unsigned int v28 = *(unsigned __int8 *)(a2 + 8);
      BOOL v12 = v27 == v28;
      BOOL v29 = v27 < v28;
      if (v12) {
        BOOL v29 = *(float *)(a3 + 12) < *(float *)(a2 + 12);
      }
      if (v29)
      {
        BOOL v30 = *(void **)a2;
        uint64_t v31 = *(void *)(a2 + 8);
        *(void *)a2 = 0;
        float v32 = *(void **)a3;
        *(void *)a3 = 0;
        BOOL v33 = *(void **)a2;
        *(void *)a2 = v32;

        *(void *)(a2 + 8) = *(void *)(a3 + 8);
        unsigned int v34 = *(void **)a3;
        *(void *)a3 = v30;

        *(void *)(a3 + 8) = v31;
        unsigned int v35 = *(unsigned __int8 *)(a2 + 8);
        unsigned int v36 = *(unsigned __int8 *)(a1 + 8);
        BOOL v12 = v35 == v36;
        BOOL v37 = v35 < v36;
        if (v12) {
          BOOL v37 = *(float *)(a2 + 12) < *(float *)(a1 + 12);
        }
        if (v37)
        {
          float v38 = *(void **)a1;
          uint64_t v39 = *(void *)(a1 + 8);
          *(void *)a1 = 0;
          BOOL v40 = *(void **)a2;
          *(void *)a2 = 0;
          float v41 = *(void **)a1;
          *(void *)a1 = v40;

          *(void *)(a1 + 8) = *(void *)(a2 + 8);
          BOOL v42 = *(void **)a2;
          *(void *)a2 = v38;

          *(void *)(a2 + 8) = v39;
        }
      }
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,-[VKLabelNavRoadGraph(junctionlist) offRouteGraphJunctionsWithNavContext:maxJunctions:isOnRoute:]::$_2 &,OffRouteJunctionInfo *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(unsigned __int8 *)(a2 - 8);
      unsigned int v7 = *(unsigned __int8 *)(a1 + 8);
      BOOL v8 = v6 == v7;
      BOOL v9 = v6 < v7;
      if (v8) {
        BOOL v9 = *(float *)(a2 - 4) < *(float *)(a1 + 12);
      }
      if (v9)
      {
        unsigned int v10 = *(void **)a1;
        uint64_t v11 = *(void *)(a1 + 8);
        *(void *)a1 = 0;
        uint64_t v12 = *(void *)(a2 - 16);
        *(void *)(a2 - 16) = 0;
        BOOL v13 = *(void **)a1;
        *(void *)a1 = v12;

        *(void *)(a1 + 8) = *(void *)(a2 - 8);
        float v14 = *(void **)(a2 - 16);
        *(void *)(a2 - 16) = v10;

        *(void *)(a2 - 8) = v11;
        return 1;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,-[VKLabelNavRoadGraph(junctionlist) offRouteGraphJunctionsWithNavContext:maxJunctions:isOnRoute:]::$_2 &,OffRouteJunctionInfo *>(a1, a1 + 16, a2 - 16);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,-[VKLabelNavRoadGraph(junctionlist) offRouteGraphJunctionsWithNavContext:maxJunctions:isOnRoute:]::$_2 &,OffRouteJunctionInfo *>(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,[(VKLabelNavRoadGraph(junctionlist) *)a1 offRouteGraphJunctionsWithNavContext:a1 + 32 maxJunctions:a1 + 48 isOnRoute:a2 - 16];
      return 1;
    default:
      uint64_t v15 = a1 + 32;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,-[VKLabelNavRoadGraph(junctionlist) offRouteGraphJunctionsWithNavContext:maxJunctions:isOnRoute:]::$_2 &,OffRouteJunctionInfo *>(a1, a1 + 16, a1 + 32);
      uint64_t v16 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v17 = 0;
      int v18 = 0;
      break;
  }
  while (1)
  {
    unsigned int v21 = *(unsigned __int8 *)(v16 + 8);
    float v22 = *(float *)(v16 + 12);
    unsigned int v23 = *(unsigned __int8 *)(v15 + 8);
    BOOL v8 = v21 == v23;
    BOOL v24 = v21 < v23;
    if (v8) {
      BOOL v24 = v22 < *(float *)(v15 + 12);
    }
    if (v24)
    {
      uint64_t v25 = *(void *)v16;
      *(void *)uint64_t v16 = 0;
      int v26 = *(_DWORD *)(v16 + 8);
      uint64_t v27 = v17;
      do
      {
        uint64_t v28 = a1 + v27;
        uint64_t v29 = *(void *)(a1 + v27 + 32);
        *(void *)(v28 + 32) = 0;
        BOOL v30 = *(void **)(a1 + v27 + 48);
        *(void *)(v28 + 48) = v29;

        *(void *)(v28 + 56) = *(void *)(v28 + 40);
        if (v27 == -32)
        {
          uint64_t v19 = a1;
          goto LABEL_9;
        }
        unsigned int v31 = *(unsigned __int8 *)(v28 + 24);
        BOOL v8 = v31 == v26;
        BOOL v32 = v31 > v26;
        if (v8) {
          BOOL v32 = *(float *)(v28 + 28) > v22;
        }
        v27 -= 16;
      }
      while (v32);
      uint64_t v19 = a1 + v27 + 48;
LABEL_9:
      unsigned int v20 = *(void **)v19;
      *(void *)uint64_t v19 = v25;

      *(_DWORD *)(v19 + 8) = v26;
      *(float *)(v19 + 12) = v22;
      if (++v18 == 8) {
        return v16 + 16 == a2;
      }
    }
    uint64_t v15 = v16;
    v17 += 16;
    v16 += 16;
    if (v16 == a2) {
      return 1;
    }
  }
}

void sub_1A2594390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A25944E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2595090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  _Unwind_Resume(a1);
}

void sub_1A259566C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1A25959A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A2595AE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void md::FontGlyph::~FontGlyph(md::FontGlyph *this)
{
  *(void *)this = &unk_1EF553F80;
  *((void *)this + 1) = &unk_1EF5590B8;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1A6239270);
}

{
  const void *v1;

  *(void *)this = &unk_1EF553F80;
  *((void *)this + 1) = &unk_1EF5590B8;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t std::__shared_ptr_emplace<md::FontGlyph,geo::StdAllocator<md::FontGlyph,mdm::Allocator>>::__on_zero_shared_weak(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a1, 96);
}

uint64_t std::__shared_ptr_emplace<md::FontGlyph,geo::StdAllocator<md::FontGlyph,mdm::Allocator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))();
}

void std::__shared_ptr_emplace<md::FontGlyph,geo::StdAllocator<md::FontGlyph,mdm::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582A58;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::FontGlyph,geo::StdAllocator<md::FontGlyph,mdm::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582A58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::AtlasFontGlyph::~AtlasFontGlyph(md::AtlasFontGlyph *this)
{
  *(void *)this = &unk_1EF5338B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF553F80;
  *((void *)this + 1) = &unk_1EF5590B8;
  uint64_t v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  const void *v3;

  *(void *)this = &unk_1EF5338B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF553F80;
  *((void *)this + 1) = &unk_1EF5590B8;
  uint64_t v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
}

uint64_t std::__shared_ptr_emplace<md::AtlasFontGlyph,geo::StdAllocator<md::AtlasFontGlyph,mdm::Allocator>>::__on_zero_shared_weak(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a1, 144);
}

uint64_t std::__shared_ptr_emplace<md::AtlasFontGlyph,geo::StdAllocator<md::AtlasFontGlyph,mdm::Allocator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))();
}

void std::__shared_ptr_emplace<md::AtlasFontGlyph,geo::StdAllocator<md::AtlasFontGlyph,mdm::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FBF8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::AtlasFontGlyph,geo::StdAllocator<md::AtlasFontGlyph,mdm::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FBF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::FontGlyphCache::eraseGlyph(uint64_t a1, float *a2)
{
  unint64_t v4 = *((void *)a2 + 4);
  *(unsigned char *)(v4 + 61) = 0;
  float v5 = (void *)(a1 + 32);
  unsigned int v6 = std::__hash_table<std::__hash_value_type<GlyphCacheKey,std::__list_iterator<md::FontGlyphCache::CachedItem,void *>>,std::__unordered_map_hasher<GlyphCacheKey,std::__hash_value_type<GlyphCacheKey,std::__list_iterator<md::FontGlyphCache::CachedItem,void *>>,std::hash<GlyphCacheKey>,std::equal_to<GlyphCacheKey>,true>,std::__unordered_map_equal<GlyphCacheKey,std::__hash_value_type<GlyphCacheKey,std::__list_iterator<md::FontGlyphCache::CachedItem,void *>>,std::equal_to<GlyphCacheKey>,std::hash<GlyphCacheKey>,true>,geo::StdAllocator<std::__hash_value_type<GlyphCacheKey,std::__list_iterator<md::FontGlyphCache::CachedItem,void *>>,mdm::Allocator>>::find<GlyphCacheKey>((void *)(a1 + 32), a2 + 4);
  if (v6)
  {
    int8x8_t v7 = *(int8x8_t *)(a1 + 40);
    unint64_t v8 = *((void *)v6 + 1);
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      if (v8 >= *(void *)&v7) {
        v8 %= *(void *)&v7;
      }
    }
    else
    {
      v8 &= *(void *)&v7 - 1;
    }
    unsigned int v10 = *(float **)(*v5 + 8 * v8);
    do
    {
      uint64_t v11 = v10;
      unsigned int v10 = *(float **)v10;
    }
    while (v10 != v6);
    if (v11 == (float *)(a1 + 56)) {
      goto LABEL_19;
    }
    unint64_t v12 = *((void *)v11 + 1);
    if (v9.u32[0] > 1uLL)
    {
      if (v12 >= *(void *)&v7) {
        v12 %= *(void *)&v7;
      }
    }
    else
    {
      v12 &= *(void *)&v7 - 1;
    }
    if (v12 != v8)
    {
LABEL_19:
      if (!*(void *)v6) {
        goto LABEL_20;
      }
      unint64_t v13 = *(void *)(*(void *)v6 + 8);
      if (v9.u32[0] > 1uLL)
      {
        if (v13 >= *(void *)&v7) {
          v13 %= *(void *)&v7;
        }
      }
      else
      {
        v13 &= *(void *)&v7 - 1;
      }
      if (v13 != v8) {
LABEL_20:
      }
        *(void *)(*v5 + 8 * v8) = 0;
    }
    uint64_t v14 = *(void *)v6;
    if (*(void *)v6)
    {
      unint64_t v15 = *(void *)(v14 + 8);
      if (v9.u32[0] > 1uLL)
      {
        if (v15 >= *(void *)&v7) {
          v15 %= *(void *)&v7;
        }
      }
      else
      {
        v15 &= *(void *)&v7 - 1;
      }
      if (v15 != v8)
      {
        *(void *)(*v5 + 8 * v15) = v11;
        uint64_t v14 = *(void *)v6;
      }
    }
    *(void *)uint64_t v11 = v14;
    *(void *)unsigned int v6 = 0;
    uint64_t v16 = *(void *)(a1 + 64);
    --*(void *)(a1 + 72);
    (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
    unint64_t v4 = *((void *)a2 + 4);
  }
  uint64_t v17 = (void *)(a1 + 88);
  int v18 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>((void *)(a1 + 88), v4);
  if (v18)
  {
    int8x8_t v19 = *(int8x8_t *)(a1 + 96);
    unint64_t v20 = v18[1];
    uint8x8_t v21 = (uint8x8_t)vcnt_s8(v19);
    v21.i16[0] = vaddlv_u8(v21);
    if (v21.u32[0] > 1uLL)
    {
      if (v20 >= *(void *)&v19) {
        v20 %= *(void *)&v19;
      }
    }
    else
    {
      v20 &= *(void *)&v19 - 1;
    }
    float v22 = *(void **)(*v17 + 8 * v20);
    do
    {
      unsigned int v23 = v22;
      float v22 = (void *)*v22;
    }
    while (v22 != v18);
    if (v23 == (void *)(a1 + 112)) {
      goto LABEL_47;
    }
    unint64_t v24 = v23[1];
    if (v21.u32[0] > 1uLL)
    {
      if (v24 >= *(void *)&v19) {
        v24 %= *(void *)&v19;
      }
    }
    else
    {
      v24 &= *(void *)&v19 - 1;
    }
    if (v24 != v20)
    {
LABEL_47:
      if (!*v18) {
        goto LABEL_48;
      }
      unint64_t v25 = *(void *)(*v18 + 8);
      if (v21.u32[0] > 1uLL)
      {
        if (v25 >= *(void *)&v19) {
          v25 %= *(void *)&v19;
        }
      }
      else
      {
        v25 &= *(void *)&v19 - 1;
      }
      if (v25 != v20) {
LABEL_48:
      }
        *(void *)(*v17 + 8 * v20) = 0;
    }
    uint64_t v26 = *v18;
    if (*v18)
    {
      unint64_t v27 = *(void *)(v26 + 8);
      if (v21.u32[0] > 1uLL)
      {
        if (v27 >= *(void *)&v19) {
          v27 %= *(void *)&v19;
        }
      }
      else
      {
        v27 &= *(void *)&v19 - 1;
      }
      if (v27 != v20)
      {
        *(void *)(*v17 + 8 * v27) = v23;
        uint64_t v26 = *v18;
      }
    }
    *unsigned int v23 = v26;
    *int v18 = 0;
    uint64_t v28 = *(void *)(a1 + 120);
    --*(void *)(a1 + 128);
    (*(void (**)(uint64_t))(*(void *)v28 + 40))(v28);
  }
  uint64_t v29 = *(void *)a2;
  *(void *)(v29 + 8) = *((void *)a2 + 1);
  **((void **)a2 + 1) = v29;
  --*(void *)(a1 + 16);
  BOOL v30 = (std::__shared_weak_count *)*((void *)a2 + 5);
  if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
  }
  uint64_t result = (*(uint64_t (**)(void, float *, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2, 48);
  --*(_DWORD *)(a1 + 152);
  return result;
}

void md::VKMRenderResourceStoreSerializer::serializeWith(void *a1, uint64_t a2)
{
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_globeMatrices");
  HIBYTE(__dst[2]) = 14;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v4 = *(unsigned int *)(a2 + 9072);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v4;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v5 = *(unsigned int *)(a2 + 9112);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v5;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v6 = *(void *)(a2 + 9184);
  uint64_t v7 = *(void *)(a2 + 9176);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = ((unint64_t)(v6 - v7) >> 7);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  unint64_t v8 = (char *)__dst[9];
  if (__dst[9])
  {
    uint8x8_t v9 = (char *)__dst[10];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v9 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v9);
      }
      while (v9 != v8);
    }
    __dst[10] = v8;
    operator delete(v8);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_7;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }
  operator delete(__dst[0]);
LABEL_7:
  memset(__dst, 0, 96);
  unsigned int v10 = (char *)operator new(0x19uLL);
  strcpy(v10, "_associationItemStorage");
  std::string::__assign_no_alias<true>(__dst, v10, 0x17uLL);
  operator delete(v10);
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v11 = *(unsigned int *)(a2 + 10128);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v11;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v12 = *(unsigned int *)(a2 + 10168);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v12;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v13 = *(void *)(a2 + 10240);
  uint64_t v14 = *(void *)(a2 + 10232);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1227133513 * ((unint64_t)(v13 - v14) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  unint64_t v15 = (char *)__dst[9];
  if (__dst[9])
  {
    uint64_t v16 = (char *)__dst[10];
    uint64_t v17 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v16 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v16);
      }
      while (v16 != v15);
      uint64_t v17 = __dst[9];
    }
    __dst[10] = v15;
    operator delete(v17);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(__dst[0]);
LABEL_14:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_tileMatrices");
  HIBYTE(__dst[2]) = 13;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v18 = *(unsigned int *)(a2 + 9248);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v18;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v19 = *(unsigned int *)(a2 + 9288);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v19;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v20 = *(void *)(a2 + 9360);
  uint64_t v21 = *(void *)(a2 + 9352);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = ((unint64_t)(v20 - v21) >> 8);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  float v22 = (char *)__dst[9];
  if (__dst[9])
  {
    unsigned int v23 = (char *)__dst[10];
    unint64_t v24 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v23 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v23);
      }
      while (v23 != v22);
      unint64_t v24 = __dst[9];
    }
    __dst[10] = v22;
    operator delete(v24);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_21;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_21;
  }
  operator delete(__dst[0]);
LABEL_21:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_renderableDataItems");
  HIBYTE(__dst[2]) = 20;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v25 = *(unsigned int *)(a2 + 9424);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v25;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v26 = *(unsigned int *)(a2 + 9464);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v26;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v27 = *(void *)(a2 + 9536);
  uint64_t v28 = *(void *)(a2 + 9528);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1963413621 * ((unint64_t)(v27 - v28) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  uint64_t v29 = (char *)__dst[9];
  if (__dst[9])
  {
    BOOL v30 = (char *)__dst[10];
    unsigned int v31 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v30 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v30);
      }
      while (v30 != v29);
      unsigned int v31 = __dst[9];
    }
    __dst[10] = v29;
    operator delete(v31);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_28;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_28;
  }
  operator delete(__dst[0]);
LABEL_28:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_colorRampData");
  HIBYTE(__dst[2]) = 14;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v32 = *(unsigned int *)(a2 + 9600);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v32;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v33 = *(unsigned int *)(a2 + 9640);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v33;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v34 = *(void *)(a2 + 9712);
  uint64_t v35 = *(void *)(a2 + 9704);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -858993459 * ((unint64_t)(v34 - v35) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  unsigned int v36 = (char *)__dst[9];
  if (__dst[9])
  {
    BOOL v37 = (char *)__dst[10];
    float v38 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v37 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v37);
      }
      while (v37 != v36);
      float v38 = __dst[9];
    }
    __dst[10] = v36;
    operator delete(v38);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_35;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_35;
  }
  operator delete(__dst[0]);
LABEL_35:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_renderStateItems");
  HIBYTE(__dst[2]) = 17;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v39 = *(unsigned int *)(a2 + 672);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v39;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v40 = *(unsigned int *)(a2 + 712);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v40;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v41 = *(void *)(a2 + 784);
  uint64_t v42 = *(void *)(a2 + 776);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = ((unint64_t)(v41 - v42) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  BOOL v43 = (char *)__dst[9];
  if (__dst[9])
  {
    uint64_t v44 = (char *)__dst[10];
    long long v45 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v44 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v44);
      }
      while (v44 != v43);
      long long v45 = __dst[9];
    }
    __dst[10] = v43;
    operator delete(v45);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0) {
    operator delete(__dst[3]);
  }
  if (SHIBYTE(__dst[2]) < 0) {
    operator delete(__dst[0]);
  }
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_landCoverSettings");
  HIBYTE(__dst[2]) = 18;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v46 = *(unsigned int *)(a2 + 2960);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v46;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v47 = *(unsigned int *)(a2 + 3000);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v47;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v48 = *(void *)(a2 + 3072);
  uint64_t v49 = *(void *)(a2 + 3064);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v48 - v49) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v50 = *(unsigned int *)(a2 + 3136);
  char v342 = 4;
  strcpy(v340, "pool");
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v353 = 1;
  uint64_t v350 = 0;
  uint64_t v348 = v50;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v340, (uint64_t)v347);
  uint64_t v51 = *(unsigned int *)(a2 + 3176);
  char v333 = 11;
  strcpy((char *)v332, "keyToHandle");
  uint64_t v344 = 0;
  uint64_t v345 = 0;
  int v346 = 1;
  uint64_t v343 = 0;
  uint64_t v341 = v51;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v332, (uint64_t)v340);
  uint64_t v52 = *(unsigned int *)(a2 + 3216);
  char v339 = 11;
  strcpy(v338, "handleToKey");
  uint64_t v335 = 0;
  uint64_t v336 = 0;
  int v337 = 1;
  uint64_t v334 = 0;
  v332[1] = v52;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v338, (uint64_t)v332);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  uint64_t v53 = (char *)__dst[9];
  if (__dst[9])
  {
    unint64_t v54 = (char *)__dst[10];
    size_t v55 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v54 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v54);
      }
      while (v54 != v53);
      size_t v55 = __dst[9];
    }
    __dst[10] = v53;
    operator delete(v55);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_51;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_51;
  }
  operator delete(__dst[0]);
LABEL_51:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_tileTypeItems");
  HIBYTE(__dst[2]) = 14;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v56 = *(unsigned int *)(a2 + 8544);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v56;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v57 = *(unsigned int *)(a2 + 8584);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v57;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  int v58 = *(_DWORD *)(a2 + 8656);
  int v59 = *(_DWORD *)(a2 + 8648);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = (v58 - v59);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  unint64_t v60 = (char *)__dst[9];
  if (__dst[9])
  {
    size_t v61 = (char *)__dst[10];
    int v62 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v61 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v61);
      }
      while (v61 != v60);
      int v62 = __dst[9];
    }
    __dst[10] = v60;
    operator delete(v62);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_58;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_58;
  }
  operator delete(__dst[0]);
LABEL_58:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_layerTypeItems");
  HIBYTE(__dst[2]) = 15;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v63 = *(unsigned int *)(a2 + 8720);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v63;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v64 = *(unsigned int *)(a2 + 8760);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v64;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  int v65 = *(_DWORD *)(a2 + 8832);
  int v66 = *(_DWORD *)(a2 + 8824);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = (v65 - v66);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  size_t v67 = (char *)__dst[9];
  if (__dst[9])
  {
    int v68 = (char *)__dst[10];
    unint64_t v69 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v68 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v68);
      }
      while (v68 != v67);
      unint64_t v69 = __dst[9];
    }
    __dst[10] = v67;
    operator delete(v69);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_65;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_65;
  }
  operator delete(__dst[0]);
LABEL_65:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_mapDataTypeItems");
  HIBYTE(__dst[2]) = 17;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v70 = *(unsigned int *)(a2 + 8896);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v70;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v71 = *(unsigned int *)(a2 + 8936);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v71;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v72 = *(void *)(a2 + 9008);
  uint64_t v73 = *(void *)(a2 + 9000);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = ((unint64_t)(v72 - v73) >> 1);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  long long v74 = (char *)__dst[9];
  if (__dst[9])
  {
    uint64_t v75 = (char *)__dst[10];
    size_t v76 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v75 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v75);
      }
      while (v75 != v74);
      size_t v76 = __dst[9];
    }
    __dst[10] = v74;
    operator delete(v76);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_72;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_72;
  }
  operator delete(__dst[0]);
LABEL_72:
  memset(__dst, 0, 96);
  size_t v77 = (char *)operator new(0x20uLL);
  strcpy(v77, "_transformConstantDataItems");
  std::string::__assign_no_alias<true>(__dst, v77, 0x1BuLL);
  operator delete(v77);
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v78 = *(unsigned int *)(a2 + 3256);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v78;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v79 = *(unsigned int *)(a2 + 3296);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v79;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v80 = *(void *)(a2 + 3368);
  uint64_t v81 = *(void *)(a2 + 3360);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v80 - v81) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  size_t v82 = (char *)__dst[9];
  if (__dst[9])
  {
    size_t v83 = (char *)__dst[10];
    int v84 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v83 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v83);
      }
      while (v83 != v82);
      int v84 = __dst[9];
    }
    __dst[10] = v82;
    operator delete(v84);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_79;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_79;
  }
  operator delete(__dst[0]);
LABEL_79:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_viewConstantDataItems");
  HIBYTE(__dst[2]) = 22;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v85 = *(unsigned int *)(a2 + 3432);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v85;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v86 = *(unsigned int *)(a2 + 3472);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v86;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v87 = *(void *)(a2 + 3544);
  uint64_t v88 = *(void *)(a2 + 3536);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v87 - v88) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  int v89 = (char *)__dst[9];
  if (__dst[9])
  {
    unint64_t v90 = (char *)__dst[10];
    uint64_t v91 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v90 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v90);
      }
      while (v90 != v89);
      uint64_t v91 = __dst[9];
    }
    __dst[10] = v89;
    operator delete(v91);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_86;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_86;
  }
  operator delete(__dst[0]);
LABEL_86:
  memset(__dst, 0, 96);
  float v92 = (char *)operator new(0x20uLL);
  strcpy(v92, "_linearDepthConstantDataItems");
  std::string::__assign_no_alias<true>(__dst, v92, 0x1DuLL);
  operator delete(v92);
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v93 = *(unsigned int *)(a2 + 3608);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v93;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v94 = *(unsigned int *)(a2 + 3648);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v94;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v95 = *(void *)(a2 + 3720);
  uint64_t v96 = *(void *)(a2 + 3712);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v95 - v96) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  unint64_t v97 = (char *)__dst[9];
  if (__dst[9])
  {
    int v98 = (char *)__dst[10];
    size_t v99 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v98 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v98);
      }
      while (v98 != v97);
      size_t v99 = __dst[9];
    }
    __dst[10] = v97;
    operator delete(v99);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_93;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_93;
  }
  operator delete(__dst[0]);
LABEL_93:
  memset(__dst, 0, 96);
  int v100 = (char *)operator new(0x20uLL);
  strcpy(v100, "_clippingConstantDataItems");
  std::string::__assign_no_alias<true>(__dst, v100, 0x1AuLL);
  operator delete(v100);
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v101 = *(unsigned int *)(a2 + 3784);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v101;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v102 = *(unsigned int *)(a2 + 3824);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v102;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v103 = *(void *)(a2 + 3896);
  uint64_t v104 = *(void *)(a2 + 3888);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v103 - v104) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  unint64_t v105 = (char *)__dst[9];
  if (__dst[9])
  {
    unint64_t v106 = (char *)__dst[10];
    uint64_t v107 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v106 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v106);
      }
      while (v106 != v105);
      uint64_t v107 = __dst[9];
    }
    __dst[10] = v105;
    operator delete(v107);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_100;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_100;
  }
  operator delete(__dst[0]);
LABEL_100:
  memset(__dst, 0, 96);
  uint64_t v108 = (char *)operator new(0x20uLL);
  strcpy(v108, "_shadowConstantDataItems");
  std::string::__assign_no_alias<true>(__dst, v108, 0x18uLL);
  operator delete(v108);
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v109 = *(unsigned int *)(a2 + 3960);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v109;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v110 = *(unsigned int *)(a2 + 4000);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v110;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v111 = *(void *)(a2 + 4072);
  uint64_t v112 = *(void *)(a2 + 4064);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v111 - v112) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  unsigned __int8 v113 = (char *)__dst[9];
  if (__dst[9])
  {
    unsigned __int8 v114 = (char *)__dst[10];
    int v115 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v114 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v114);
      }
      while (v114 != v113);
      int v115 = __dst[9];
    }
    __dst[10] = v113;
    operator delete(v115);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_107;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_107;
  }
  operator delete(__dst[0]);
LABEL_107:
  memset(__dst, 0, 96);
  size_t v116 = (char *)operator new(0x20uLL);
  strcpy(v116, "_styleEmissiveColorDataItems");
  std::string::__assign_no_alias<true>(__dst, v116, 0x1CuLL);
  operator delete(v116);
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v117 = *(unsigned int *)(a2 + 2368);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v117;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v118 = *(unsigned int *)(a2 + 2408);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v118;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v119 = *(void *)(a2 + 2480);
  uint64_t v120 = *(void *)(a2 + 2472);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v119 - v120) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v121 = *(unsigned int *)(a2 + 2544);
  char v342 = 4;
  strcpy(v340, "pool");
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v353 = 1;
  uint64_t v350 = 0;
  uint64_t v348 = v121;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v340, (uint64_t)v347);
  uint64_t v122 = *(unsigned int *)(a2 + 2584);
  char v333 = 11;
  strcpy((char *)v332, "keyToHandle");
  uint64_t v344 = 0;
  uint64_t v345 = 0;
  int v346 = 1;
  uint64_t v343 = 0;
  uint64_t v341 = v122;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v332, (uint64_t)v340);
  uint64_t v123 = *(unsigned int *)(a2 + 2624);
  char v339 = 11;
  strcpy(v338, "handleToKey");
  uint64_t v335 = 0;
  uint64_t v336 = 0;
  int v337 = 1;
  uint64_t v334 = 0;
  v332[1] = v123;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v338, (uint64_t)v332);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  uint64_t v124 = (char *)__dst[9];
  if (__dst[9])
  {
    size_t v125 = (char *)__dst[10];
    size_t v126 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v125 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v125);
      }
      while (v125 != v124);
      size_t v126 = __dst[9];
    }
    __dst[10] = v124;
    operator delete(v126);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_114;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_114;
  }
  operator delete(__dst[0]);
LABEL_114:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_styleCameraLighting");
  HIBYTE(__dst[2]) = 20;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v127 = *(unsigned int *)(a2 + 5432);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v127;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v128 = *(unsigned int *)(a2 + 5472);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v128;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v129 = *(void *)(a2 + 5544);
  uint64_t v130 = *(void *)(a2 + 5536);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v129 - v130) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  int64_t v131 = (char *)__dst[9];
  if (__dst[9])
  {
    int64_t v132 = (char *)__dst[10];
    long long v133 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v132 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v132);
      }
      while (v132 != v131);
      long long v133 = __dst[9];
    }
    __dst[10] = v131;
    operator delete(v133);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_121;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_121;
  }
  operator delete(__dst[0]);
LABEL_121:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_styleDataItems");
  HIBYTE(__dst[2]) = 15;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v134 = *(unsigned int *)(a2 + 1184);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v134;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v135 = *(unsigned int *)(a2 + 1224);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v135;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v136 = *(void *)(a2 + 1296);
  uint64_t v137 = *(void *)(a2 + 1288);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v136 - v137) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v138 = *(unsigned int *)(a2 + 1360);
  char v342 = 4;
  strcpy(v340, "pool");
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v353 = 1;
  uint64_t v350 = 0;
  uint64_t v348 = v138;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v340, (uint64_t)v347);
  uint64_t v139 = *(unsigned int *)(a2 + 1400);
  char v333 = 11;
  strcpy((char *)v332, "keyToHandle");
  uint64_t v344 = 0;
  uint64_t v345 = 0;
  int v346 = 1;
  uint64_t v343 = 0;
  uint64_t v341 = v139;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v332, (uint64_t)v340);
  uint64_t v140 = *(unsigned int *)(a2 + 1440);
  char v339 = 11;
  strcpy(v338, "handleToKey");
  uint64_t v335 = 0;
  uint64_t v336 = 0;
  int v337 = 1;
  uint64_t v334 = 0;
  v332[1] = v140;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v338, (uint64_t)v332);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  int v141 = (char *)__dst[9];
  if (__dst[9])
  {
    unint64_t v142 = (char *)__dst[10];
    size_t v143 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v142 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v142);
      }
      while (v142 != v141);
      size_t v143 = __dst[9];
    }
    __dst[10] = v141;
    operator delete(v143);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_128;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_128;
  }
  operator delete(__dst[0]);
LABEL_128:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_styleDataKeys");
  HIBYTE(__dst[2]) = 14;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v144 = *(unsigned int *)(a2 + 1480);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v144;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v145 = *(unsigned int *)(a2 + 1520);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v145;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v146 = *(void *)(a2 + 1592);
  uint64_t v147 = *(void *)(a2 + 1584);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -858993459 * ((unint64_t)(v146 - v147) >> 2);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v148 = *(unsigned int *)(a2 + 1656);
  char v342 = 4;
  strcpy(v340, "pool");
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v353 = 1;
  uint64_t v350 = 0;
  uint64_t v348 = v148;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v340, (uint64_t)v347);
  uint64_t v149 = *(unsigned int *)(a2 + 1696);
  char v333 = 11;
  strcpy((char *)v332, "keyToHandle");
  uint64_t v344 = 0;
  uint64_t v345 = 0;
  int v346 = 1;
  uint64_t v343 = 0;
  uint64_t v341 = v149;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v332, (uint64_t)v340);
  uint64_t v150 = *(unsigned int *)(a2 + 1736);
  char v339 = 11;
  strcpy(v338, "handleToKey");
  uint64_t v335 = 0;
  uint64_t v336 = 0;
  int v337 = 1;
  uint64_t v334 = 0;
  v332[1] = v150;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v338, (uint64_t)v332);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  size_t v151 = (char *)__dst[9];
  if (__dst[9])
  {
    size_t v152 = (char *)__dst[10];
    size_t v153 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v152 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v152);
      }
      while (v152 != v151);
      size_t v153 = __dst[9];
    }
    __dst[10] = v151;
    operator delete(v153);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_135;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_135;
  }
  operator delete(__dst[0]);
LABEL_135:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_styleColor");
  HIBYTE(__dst[2]) = 11;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v154 = *(unsigned int *)(a2 + 6296);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v154;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v155 = *(unsigned int *)(a2 + 6336);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v155;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v156 = *(void *)(a2 + 6408);
  uint64_t v157 = *(void *)(a2 + 6400);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v156 - v157) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v158 = *(unsigned int *)(a2 + 6472);
  char v342 = 4;
  strcpy(v340, "pool");
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v353 = 1;
  uint64_t v350 = 0;
  uint64_t v348 = v158;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v340, (uint64_t)v347);
  uint64_t v159 = *(unsigned int *)(a2 + 6512);
  char v333 = 11;
  strcpy((char *)v332, "keyToHandle");
  uint64_t v344 = 0;
  uint64_t v345 = 0;
  int v346 = 1;
  uint64_t v343 = 0;
  uint64_t v341 = v159;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v332, (uint64_t)v340);
  uint64_t v160 = *(unsigned int *)(a2 + 6552);
  char v339 = 11;
  strcpy(v338, "handleToKey");
  uint64_t v335 = 0;
  uint64_t v336 = 0;
  int v337 = 1;
  uint64_t v334 = 0;
  v332[1] = v160;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v338, (uint64_t)v332);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  uint64_t v161 = (char *)__dst[9];
  if (__dst[9])
  {
    int v162 = (char *)__dst[10];
    int v163 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v162 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v162);
      }
      while (v162 != v161);
      int v163 = __dst[9];
    }
    __dst[10] = v161;
    operator delete(v163);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_142;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_142;
  }
  operator delete(__dst[0]);
LABEL_142:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_positionScaleInfo");
  HIBYTE(__dst[2]) = 18;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v164 = *(unsigned int *)(a2 + 5608);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v164;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v165 = *(unsigned int *)(a2 + 5648);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v165;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v166 = *(void *)(a2 + 5720);
  uint64_t v167 = *(void *)(a2 + 5712);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v166 - v167) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v168 = *(unsigned int *)(a2 + 5784);
  char v360 = 4;
  strcpy((char *)v359, "pool");
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v168;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  int v169 = (char *)__dst[9];
  if (__dst[9])
  {
    int v170 = (char *)__dst[10];
    float v171 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v170 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v170);
      }
      while (v170 != v169);
      float v171 = __dst[9];
    }
    __dst[10] = v169;
    operator delete(v171);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_149;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_149;
  }
  operator delete(__dst[0]);
LABEL_149:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_colorCorrectionFactor");
  HIBYTE(__dst[2]) = 22;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v172 = *(unsigned int *)(a2 + 7952);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v172;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v173 = *(unsigned int *)(a2 + 7992);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v173;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v174 = *(void *)(a2 + 8064);
  uint64_t v175 = *(void *)(a2 + 8056);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v174 - v175) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v176 = *(unsigned int *)(a2 + 8128);
  char v342 = 4;
  strcpy(v340, "pool");
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v353 = 1;
  uint64_t v350 = 0;
  uint64_t v348 = v176;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v340, (uint64_t)v347);
  uint64_t v177 = *(unsigned int *)(a2 + 8168);
  char v333 = 11;
  strcpy((char *)v332, "keyToHandle");
  uint64_t v344 = 0;
  uint64_t v345 = 0;
  int v346 = 1;
  uint64_t v343 = 0;
  uint64_t v341 = v177;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v332, (uint64_t)v340);
  uint64_t v178 = *(unsigned int *)(a2 + 8208);
  char v339 = 11;
  strcpy(v338, "handleToKey");
  uint64_t v335 = 0;
  uint64_t v336 = 0;
  int v337 = 1;
  uint64_t v334 = 0;
  v332[1] = v178;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v338, (uint64_t)v332);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  size_t v179 = (char *)__dst[9];
  if (__dst[9])
  {
    int v180 = (char *)__dst[10];
    int v181 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v180 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v180);
      }
      while (v180 != v179);
      int v181 = __dst[9];
    }
    __dst[10] = v179;
    operator delete(v181);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_156;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_156;
  }
  operator delete(__dst[0]);
LABEL_156:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_styleSSAO");
  HIBYTE(__dst[2]) = 10;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v182 = *(unsigned int *)(a2 + 8248);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v182;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v183 = *(unsigned int *)(a2 + 8288);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v183;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v184 = *(void *)(a2 + 8360);
  uint64_t v185 = *(void *)(a2 + 8352);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v184 - v185) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v186 = *(unsigned int *)(a2 + 8424);
  char v342 = 4;
  strcpy(v340, "pool");
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v353 = 1;
  uint64_t v350 = 0;
  uint64_t v348 = v186;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v340, (uint64_t)v347);
  uint64_t v187 = *(unsigned int *)(a2 + 8464);
  char v333 = 11;
  strcpy((char *)v332, "keyToHandle");
  uint64_t v344 = 0;
  uint64_t v345 = 0;
  int v346 = 1;
  uint64_t v343 = 0;
  uint64_t v341 = v187;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v332, (uint64_t)v340);
  uint64_t v188 = *(unsigned int *)(a2 + 8504);
  char v339 = 11;
  strcpy(v338, "handleToKey");
  uint64_t v335 = 0;
  uint64_t v336 = 0;
  int v337 = 1;
  uint64_t v334 = 0;
  v332[1] = v188;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v338, (uint64_t)v332);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  int64x2_t v189 = (char *)__dst[9];
  if (__dst[9])
  {
    int v190 = (char *)__dst[10];
    int64x2_t v191 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v190 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v190);
      }
      while (v190 != v189);
      int64x2_t v191 = __dst[9];
    }
    __dst[10] = v189;
    operator delete(v191);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_163;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_163;
  }
  operator delete(__dst[0]);
LABEL_163:
  memset(__dst, 0, 96);
  size_t v192 = (char *)operator new(0x20uLL);
  strcpy(v192, "_flyoverSharedConstantDataItems");
  std::string::__assign_no_alias<true>(__dst, v192, 0x1FuLL);
  operator delete(v192);
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v193 = *(unsigned int *)(a2 + 4136);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v193;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v194 = *(unsigned int *)(a2 + 4176);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v194;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v195 = *(void *)(a2 + 4248);
  uint64_t v196 = *(void *)(a2 + 4240);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v195 - v196) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v197 = *(unsigned int *)(a2 + 4312);
  char v360 = 4;
  strcpy((char *)v359, "pool");
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v197;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  uint64_t v198 = (char *)__dst[9];
  if (__dst[9])
  {
    int v199 = (char *)__dst[10];
    uint64_t v200 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v199 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v199);
      }
      while (v199 != v198);
      uint64_t v200 = __dst[9];
    }
    __dst[10] = v198;
    operator delete(v200);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_170;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_170;
  }
  operator delete(__dst[0]);
LABEL_170:
  memset(__dst, 0, 96);
  uint64_t v201 = (char *)operator new(0x20uLL);
  strcpy(v201, "_flyoverClipConstantDataItems");
  std::string::__assign_no_alias<true>(__dst, v201, 0x1DuLL);
  operator delete(v201);
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v202 = *(unsigned int *)(a2 + 4352);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v202;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v203 = *(unsigned int *)(a2 + 4392);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v203;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v204 = *(void *)(a2 + 4464);
  uint64_t v205 = *(void *)(a2 + 4456);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v204 - v205) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v206 = *(unsigned int *)(a2 + 4528);
  char v360 = 4;
  strcpy((char *)v359, "pool");
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v206;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  float v207 = (char *)__dst[9];
  if (__dst[9])
  {
    size_t v208 = (char *)__dst[10];
    size_t v209 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v208 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v208);
      }
      while (v208 != v207);
      size_t v209 = __dst[9];
    }
    __dst[10] = v207;
    operator delete(v209);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_177;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_177;
  }
  operator delete(__dst[0]);
LABEL_177:
  memset(__dst, 0, 96);
  int v210 = (char *)operator new(0x28uLL);
  strcpy(v210, "_flyoverTransformConstantDataItems");
  std::string::__assign_no_alias<true>(__dst, v210, 0x22uLL);
  operator delete(v210);
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v211 = *(unsigned int *)(a2 + 4568);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v211;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v212 = *(unsigned int *)(a2 + 4608);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v212;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v213 = *(void *)(a2 + 4680);
  uint64_t v214 = *(void *)(a2 + 4672);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v213 - v214) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v215 = *(unsigned int *)(a2 + 4744);
  char v360 = 4;
  strcpy((char *)v359, "pool");
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v215;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  unint64_t v216 = (char *)__dst[9];
  if (__dst[9])
  {
    size_t v217 = (char *)__dst[10];
    int v218 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v217 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v217);
      }
      while (v217 != v216);
      int v218 = __dst[9];
    }
    __dst[10] = v216;
    operator delete(v218);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_184;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_184;
  }
  operator delete(__dst[0]);
LABEL_184:
  memset(__dst, 0, 96);
  unint64_t v219 = (char *)operator new(0x28uLL);
  strcpy(v219, "_flyoverS2TransformConstantDataItems");
  std::string::__assign_no_alias<true>(__dst, v219, 0x24uLL);
  operator delete(v219);
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v220 = *(unsigned int *)(a2 + 4784);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v220;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v221 = *(unsigned int *)(a2 + 4824);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v221;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v222 = *(void *)(a2 + 4896);
  uint64_t v223 = *(void *)(a2 + 4888);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v222 - v223) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v224 = *(unsigned int *)(a2 + 4960);
  char v360 = 4;
  strcpy((char *)v359, "pool");
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v224;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  size_t v225 = (char *)__dst[9];
  if (__dst[9])
  {
    long long v226 = (char *)__dst[10];
    long long v227 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v226 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v226);
      }
      while (v226 != v225);
      long long v227 = __dst[9];
    }
    __dst[10] = v225;
    operator delete(v227);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_191;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_191;
  }
  operator delete(__dst[0]);
LABEL_191:
  memset(__dst, 0, 96);
  unint64_t v228 = (char *)operator new(0x28uLL);
  strcpy(v228, "_flyoverTexcoordsConstantDataItems");
  std::string::__assign_no_alias<true>(__dst, v228, 0x22uLL);
  operator delete(v228);
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v229 = *(unsigned int *)(a2 + 5000);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v229;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v230 = *(unsigned int *)(a2 + 5040);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v230;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v231 = *(void *)(a2 + 5112);
  uint64_t v232 = *(void *)(a2 + 5104);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v231 - v232) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v233 = *(unsigned int *)(a2 + 5176);
  char v360 = 4;
  strcpy((char *)v359, "pool");
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v233;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  int v234 = (char *)__dst[9];
  if (__dst[9])
  {
    uint64_t v235 = (char *)__dst[10];
    uint64_t v236 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v235 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v235);
      }
      while (v235 != v234);
      uint64_t v236 = __dst[9];
    }
    __dst[10] = v234;
    operator delete(v236);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_198;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_198;
  }
  operator delete(__dst[0]);
LABEL_198:
  memset(__dst, 0, 96);
  int16x8_t v237 = (char *)operator new(0x28uLL);
  strcpy(v237, "_flyoverMaterialConstantDataItems");
  std::string::__assign_no_alias<true>(__dst, v237, 0x21uLL);
  operator delete(v237);
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v238 = *(unsigned int *)(a2 + 5216);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v238;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v239 = *(unsigned int *)(a2 + 5256);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v239;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v240 = *(void *)(a2 + 5328);
  uint64_t v241 = *(void *)(a2 + 5320);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v240 - v241) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v242 = *(unsigned int *)(a2 + 5392);
  char v360 = 4;
  strcpy((char *)v359, "pool");
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v242;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  size_t v243 = (char *)__dst[9];
  if (__dst[9])
  {
    size_t v244 = (char *)__dst[10];
    int v245 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v244 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v244);
      }
      while (v244 != v243);
      int v245 = __dst[9];
    }
    __dst[10] = v243;
    operator delete(v245);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_205;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_205;
  }
  operator delete(__dst[0]);
LABEL_205:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_sRGBBlendStyle");
  HIBYTE(__dst[2]) = 15;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v246 = *(unsigned int *)(a2 + 5824);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v246;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v247 = *(unsigned int *)(a2 + 5864);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v247;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v248 = *(void *)(a2 + 5936);
  uint64_t v249 = *(void *)(a2 + 5928);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v248 - v249) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  int v250 = (char *)__dst[9];
  if (__dst[9])
  {
    float v251 = (char *)__dst[10];
    size_t v252 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v251 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v251);
      }
      while (v251 != v250);
      size_t v252 = __dst[9];
    }
    __dst[10] = v250;
    operator delete(v252);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_212;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_212;
  }
  operator delete(__dst[0]);
LABEL_212:
  memset(__dst, 0, 96);
  size_t v253 = (char *)operator new(0x20uLL);
  strcpy(v253, "_styleRouteLineMaskDataItems");
  std::string::__assign_no_alias<true>(__dst, v253, 0x1CuLL);
  operator delete(v253);
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v254 = *(unsigned int *)(a2 + 1776);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v254;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v255 = *(unsigned int *)(a2 + 1816);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v255;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v256 = *(void *)(a2 + 1888);
  uint64_t v257 = *(void *)(a2 + 1880);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v256 - v257) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v258 = *(unsigned int *)(a2 + 1952);
  char v342 = 4;
  strcpy(v340, "pool");
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v353 = 1;
  uint64_t v350 = 0;
  uint64_t v348 = v258;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v340, (uint64_t)v347);
  uint64_t v259 = *(unsigned int *)(a2 + 1992);
  char v333 = 11;
  strcpy((char *)v332, "keyToHandle");
  uint64_t v344 = 0;
  uint64_t v345 = 0;
  int v346 = 1;
  uint64_t v343 = 0;
  uint64_t v341 = v259;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v332, (uint64_t)v340);
  uint64_t v260 = *(unsigned int *)(a2 + 2032);
  char v339 = 11;
  strcpy(v338, "handleToKey");
  uint64_t v335 = 0;
  uint64_t v336 = 0;
  int v337 = 1;
  uint64_t v334 = 0;
  v332[1] = v260;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v338, (uint64_t)v332);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  unint64_t v261 = (char *)__dst[9];
  if (__dst[9])
  {
    uint64_t v262 = (char *)__dst[10];
    int v263 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v262 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v262);
      }
      while (v262 != v261);
      int v263 = __dst[9];
    }
    __dst[10] = v261;
    operator delete(v263);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_219;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_219;
  }
  operator delete(__dst[0]);
LABEL_219:
  memset(__dst, 0, 96);
  uint64_t v264 = (char *)operator new(0x20uLL);
  strcpy(v264, "_styleRouteLineMaskDataKeys");
  std::string::__assign_no_alias<true>(__dst, v264, 0x1BuLL);
  operator delete(v264);
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v265 = *(unsigned int *)(a2 + 2072);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v265;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v266 = *(unsigned int *)(a2 + 2112);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v266;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v267 = *(void *)(a2 + 2184);
  uint64_t v268 = *(void *)(a2 + 2176);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v267 - v268) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v269 = *(unsigned int *)(a2 + 2248);
  char v342 = 4;
  strcpy(v340, "pool");
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v353 = 1;
  uint64_t v350 = 0;
  uint64_t v348 = v269;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v340, (uint64_t)v347);
  uint64_t v270 = *(unsigned int *)(a2 + 2288);
  char v333 = 11;
  strcpy((char *)v332, "keyToHandle");
  uint64_t v344 = 0;
  uint64_t v345 = 0;
  int v346 = 1;
  uint64_t v343 = 0;
  uint64_t v341 = v270;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v332, (uint64_t)v340);
  uint64_t v271 = *(unsigned int *)(a2 + 2328);
  char v339 = 11;
  strcpy(v338, "handleToKey");
  uint64_t v335 = 0;
  uint64_t v336 = 0;
  int v337 = 1;
  uint64_t v334 = 0;
  v332[1] = v271;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v338, (uint64_t)v332);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  uint64_t v272 = (char *)__dst[9];
  if (__dst[9])
  {
    unint64_t v273 = (char *)__dst[10];
    uint64_t v274 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v273 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v273);
      }
      while (v273 != v272);
      uint64_t v274 = __dst[9];
    }
    __dst[10] = v272;
    operator delete(v274);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_226;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_226;
  }
  operator delete(__dst[0]);
LABEL_226:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_planarParameters");
  HIBYTE(__dst[2]) = 17;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v275 = *(unsigned int *)(a2 + 6000);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v275;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v276 = *(unsigned int *)(a2 + 6040);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v276;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v277 = *(void *)(a2 + 6112);
  uint64_t v278 = *(void *)(a2 + 6104);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v277 - v278) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v279 = *(unsigned int *)(a2 + 6176);
  char v342 = 4;
  strcpy(v340, "pool");
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v353 = 1;
  uint64_t v350 = 0;
  uint64_t v348 = v279;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v340, (uint64_t)v347);
  uint64_t v280 = *(unsigned int *)(a2 + 6216);
  char v333 = 11;
  strcpy((char *)v332, "keyToHandle");
  uint64_t v344 = 0;
  uint64_t v345 = 0;
  int v346 = 1;
  uint64_t v343 = 0;
  uint64_t v341 = v280;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v332, (uint64_t)v340);
  uint64_t v281 = *(unsigned int *)(a2 + 6256);
  char v339 = 11;
  strcpy(v338, "handleToKey");
  uint64_t v335 = 0;
  uint64_t v336 = 0;
  int v337 = 1;
  uint64_t v334 = 0;
  v332[1] = v281;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v338, (uint64_t)v332);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  float32x2_t v282 = (char *)__dst[9];
  if (__dst[9])
  {
    float v283 = (char *)__dst[10];
    float v284 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v283 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v283);
      }
      while (v283 != v282);
      float v284 = __dst[9];
    }
    __dst[10] = v282;
    operator delete(v284);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_233;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_233;
  }
  operator delete(__dst[0]);
LABEL_233:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_elevatedStroke");
  HIBYTE(__dst[2]) = 15;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v285 = *(unsigned int *)(a2 + 6592);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v285;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v286 = *(unsigned int *)(a2 + 6632);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v286;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v287 = *(void *)(a2 + 6704);
  uint64_t v288 = *(void *)(a2 + 6696);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v287 - v288) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v289 = *(unsigned int *)(a2 + 6768);
  char v342 = 4;
  strcpy(v340, "pool");
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v353 = 1;
  uint64_t v350 = 0;
  uint64_t v348 = v289;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v340, (uint64_t)v347);
  uint64_t v290 = *(unsigned int *)(a2 + 6808);
  char v333 = 11;
  strcpy((char *)v332, "keyToHandle");
  uint64_t v344 = 0;
  uint64_t v345 = 0;
  int v346 = 1;
  uint64_t v343 = 0;
  uint64_t v341 = v290;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v332, (uint64_t)v340);
  uint64_t v291 = *(unsigned int *)(a2 + 6848);
  char v339 = 11;
  strcpy(v338, "handleToKey");
  uint64_t v335 = 0;
  uint64_t v336 = 0;
  int v337 = 1;
  uint64_t v334 = 0;
  v332[1] = v291;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v338, (uint64_t)v332);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  int v292 = (char *)__dst[9];
  if (__dst[9])
  {
    unint64_t v293 = (char *)__dst[10];
    float v294 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v293 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v293);
      }
      while (v293 != v292);
      float v294 = __dst[9];
    }
    __dst[10] = v292;
    operator delete(v294);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_240;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_240;
  }
  operator delete(__dst[0]);
LABEL_240:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_rasterOverlay");
  HIBYTE(__dst[2]) = 14;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v295 = *(unsigned int *)(a2 + 6888);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v295;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v296 = *(unsigned int *)(a2 + 6928);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v296;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v297 = *(void *)(a2 + 7000);
  uint64_t v298 = *(void *)(a2 + 6992);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v297 - v298) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  uint64_t v299 = (char *)__dst[9];
  if (__dst[9])
  {
    unint64_t v300 = (char *)__dst[10];
    uint64_t v301 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v300 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v300);
      }
      while (v300 != v299);
      uint64_t v301 = __dst[9];
    }
    __dst[10] = v299;
    operator delete(v301);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_247;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_247;
  }
  operator delete(__dst[0]);
LABEL_247:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_styleGroundOcclusion");
  HIBYTE(__dst[2]) = 21;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v302 = *(unsigned int *)(a2 + 7064);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v302;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v303 = *(unsigned int *)(a2 + 7104);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v303;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v304 = *(void *)(a2 + 7176);
  uint64_t v305 = *(void *)(a2 + 7168);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v304 - v305) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v306 = *(unsigned int *)(a2 + 7240);
  char v342 = 4;
  strcpy(v340, "pool");
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v353 = 1;
  uint64_t v350 = 0;
  uint64_t v348 = v306;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v340, (uint64_t)v347);
  uint64_t v307 = *(unsigned int *)(a2 + 7280);
  char v333 = 11;
  strcpy((char *)v332, "keyToHandle");
  uint64_t v344 = 0;
  uint64_t v345 = 0;
  int v346 = 1;
  uint64_t v343 = 0;
  uint64_t v341 = v307;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v332, (uint64_t)v340);
  uint64_t v308 = *(unsigned int *)(a2 + 7320);
  char v339 = 11;
  strcpy(v338, "handleToKey");
  uint64_t v335 = 0;
  uint64_t v336 = 0;
  int v337 = 1;
  uint64_t v334 = 0;
  v332[1] = v308;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v338, (uint64_t)v332);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  unint64_t v309 = (char *)__dst[9];
  if (__dst[9])
  {
    long long v310 = (char *)__dst[10];
    unint64_t v311 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v310 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v310);
      }
      while (v310 != v309);
      unint64_t v311 = __dst[9];
    }
    __dst[10] = v309;
    operator delete(v311);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_254;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_254;
  }
  operator delete(__dst[0]);
LABEL_254:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_gradientParameters");
  HIBYTE(__dst[2]) = 19;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v312 = *(unsigned int *)(a2 + 7360);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v312;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v313 = *(unsigned int *)(a2 + 7400);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v313;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v314 = *(void *)(a2 + 7472);
  uint64_t v315 = *(void *)(a2 + 7464);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = -1431655765 * ((unint64_t)(v314 - v315) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v316 = *(unsigned int *)(a2 + 7536);
  char v342 = 4;
  strcpy(v340, "pool");
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v353 = 1;
  uint64_t v350 = 0;
  uint64_t v348 = v316;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v340, (uint64_t)v347);
  uint64_t v317 = *(unsigned int *)(a2 + 7576);
  char v333 = 11;
  strcpy((char *)v332, "keyToHandle");
  uint64_t v344 = 0;
  uint64_t v345 = 0;
  int v346 = 1;
  uint64_t v343 = 0;
  uint64_t v341 = v317;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v332, (uint64_t)v340);
  uint64_t v318 = *(unsigned int *)(a2 + 7616);
  char v339 = 11;
  strcpy(v338, "handleToKey");
  uint64_t v335 = 0;
  uint64_t v336 = 0;
  int v337 = 1;
  uint64_t v334 = 0;
  v332[1] = v318;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v338, (uint64_t)v332);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  int v319 = (char *)__dst[9];
  if (__dst[9])
  {
    unint64_t v320 = (char *)__dst[10];
    unint64_t v321 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v320 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v320);
      }
      while (v320 != v319);
      unint64_t v321 = __dst[9];
    }
    __dst[10] = v319;
    operator delete(v321);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if (SHIBYTE(__dst[5]) < 0)
  {
    operator delete(__dst[3]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_261;
    }
  }
  else if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
  {
    goto LABEL_261;
  }
  operator delete(__dst[0]);
LABEL_261:
  memset(&__dst[3], 0, 72);
  strcpy((char *)__dst, "_materialStyle");
  HIBYTE(__dst[2]) = 14;
  char v360 = 8;
  strcpy((char *)v359, "counters");
  uint64_t v322 = *(unsigned int *)(a2 + 7656);
  uint64_t v368 = 0;
  uint64_t v369 = 0;
  int v370 = 1;
  uint64_t v367 = 0;
  uint64_t v366 = v322;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v359, (uint64_t)v365);
  uint64_t v323 = *(unsigned int *)(a2 + 7696);
  HIBYTE(v354[2]) = 16;
  strcpy((char *)v354, "countersRetained");
  uint64_t v362 = 0;
  uint64_t v363 = 0;
  int v364 = 1;
  uint64_t v361 = 0;
  v359[1] = v323;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v354, (uint64_t)v359);
  uint64_t v324 = -1431655765 * ((*(void *)(a2 + 7768) - *(void *)(a2 + 7760)) >> 3);
  char v349 = 5;
  strcpy(v347, "items");
  uint64_t v356 = 0;
  uint64_t v357 = 0;
  int v358 = 1;
  uint64_t v355 = 0;
  v354[1] = v324;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v347, (uint64_t)v354);
  uint64_t v325 = *(unsigned int *)(a2 + 7832);
  char v342 = 4;
  strcpy(v340, "pool");
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v353 = 1;
  uint64_t v350 = 0;
  uint64_t v348 = v325;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v340, (uint64_t)v347);
  uint64_t v326 = *(unsigned int *)(a2 + 7872);
  char v333 = 11;
  strcpy((char *)v332, "keyToHandle");
  uint64_t v344 = 0;
  uint64_t v345 = 0;
  int v346 = 1;
  uint64_t v343 = 0;
  uint64_t v341 = v326;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v332, (uint64_t)v340);
  uint64_t v327 = *(unsigned int *)(a2 + 7912);
  char v339 = 11;
  strcpy(v338, "handleToKey");
  uint64_t v335 = 0;
  uint64_t v336 = 0;
  int v337 = 1;
  uint64_t v334 = 0;
  v332[1] = v327;
  gdc::DebugTreeNode::addProperty((uint64_t)__dst, (uint64_t)v338, (uint64_t)v332);
  gdc::DebugTreeNode::addChildNode(a1, (long long *)__dst);
  unint64_t v328 = (char *)__dst[9];
  if (__dst[9])
  {
    uint64_t v329 = (char *)__dst[10];
    uint64_t v330 = __dst[9];
    if (__dst[10] != __dst[9])
    {
      do
      {
        v329 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>((uint64_t)v329);
      }
      while (v329 != v328);
      uint64_t v330 = __dst[9];
    }
    __dst[10] = v328;
    operator delete(v330);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__dst[6]);
  if ((SHIBYTE(__dst[5]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_342:
    operator delete(__dst[0]);
    return;
  }
  operator delete(__dst[3]);
  if (SHIBYTE(__dst[2]) < 0) {
    goto LABEL_342;
  }
}

void sub_1A259A820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  gdc::DebugTreeNode::~DebugTreeNode((gdc::DebugTreeNode *)va);
  _Unwind_Resume(a1);
}

void md::DaVinciCenterLineRoadsTileData::~DaVinciCenterLineRoadsTileData(md::DaVinciCenterLineRoadsTileData *this)
{
  md::DaVinciCenterLineRoadsTileData::~DaVinciCenterLineRoadsTileData(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t vars8;

  *(void *)this = &unk_1EF54C198;
  *((void *)this + 79) = &unk_1EF54C1D8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 106);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 104);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 104);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = *((void *)this + 102);
  *((void *)this + 102) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::StdAllocator<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,mdm::Allocator>>::~__hash_table((uint64_t *)this + 95);
  uint64_t v5 = *((void *)this + 93);
  *((void *)this + 93) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 92);
  *((void *)this + 92) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *((void *)this + 91);
  *((void *)this + 91) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  unint64_t v8 = *((void *)this + 90);
  *((void *)this + 90) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  md::MapTileData::~MapTileData(this);
}

void anonymous namespace'::addContourLinesToBatches(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, double a5)
{
  uint64_t v5 = *a3;
  uint64_t v46 = a3[1];
  if (*a3 != v46)
  {
    uint64_t v9 = a3[4];
    uint64_t v10 = *(void *)(v9 + 8);
    uint64_t v45 = *(void *)(v9 + 32);
    do
    {
      uint64_t v11 = *a4;
      md::createFeatureAttributeSet((gss::Allocator *)v60, (uint64_t *)(v5 + 32));
      *(void *)((char *)&v55 + 7) = 0;
      *(void *)&long long v55 = 0;
      HIBYTE(v55) = 1;
      gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)&v63, v11, (gss::FeatureAttributeSet *)v60, (gss::QueryOverrides *)&v55);
      if (v60[0])
      {
        v60[1] = v60[0];
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v61 + 40))(v61, v60[0], v60[2] - v60[0]);
      }
      long long v12 = v63;
      long long v55 = v63;
      if (*((void *)&v63 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v63 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v60, v12, *((uint64_t *)&v12 + 1));
      if (*((void *)&v12 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v12 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        (*(void (**)(void))(**((void **)&v12 + 1) + 16))(*((void *)&v12 + 1));
        std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v12 + 1));
        if (v62)
        {
LABEL_11:
          uint64_t v13 = *(void *)(v60[0] + 24);
          uint64_t v14 = *(float **)v13;
          if (*(void *)v13)
          {
            float v15 = *v14;
            BOOL v16 = *v14 == 1.0;
            if (*(unsigned char *)(v13 + 10))
            {
              if (v15 != 0.0 && v15 != 1.0)
              {
LABEL_24:
                char hasValueForKeyAtEnd = gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v13, 0x12Cu, 0);
                unsigned int v20 = 1;
                if ((hasValueForKeyAtEnd & 1) == 0) {
                  goto LABEL_25;
                }
LABEL_55:
                uint64_t v18 = (unsigned int *)(v5 + 20);
                if (*(_DWORD *)(v5 + 20))
                {
                  uint64_t v19 = (uint64_t *)(v45 + 16 * *(unsigned int *)(v5 + 16));
                  if (!v20) {
                    goto LABEL_64;
                  }
                  unsigned int v34 = 0;
                  do
                  {
                    uint64_t v35 = *v19;
                    uint64_t v36 = *(void *)(a3[4] + 24);
                    BOOL v37 = (std::__shared_weak_count *)*((void *)&v63 + 1);
                    long long v59 = v63;
                    if (*((void *)&v63 + 1)) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v63 + 1) + 8), 1uLL, memory_order_relaxed);
                    }
                    unint64_t v38 = v19[1];
                    LOBYTE(v57) = 0;
                    char v58 = 0;
                    v56[0] = 0;
                    v56[1] = 0;
                    LOWORD(v55) = 255;
                    *(void *)((char *)&v55 + 4) = 0;
                    if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
                      std::__shared_weak_count::__release_weak(v37);
                    }
                    ++v34;
                    v19 += 2;
                  }
                  while (v34 < *v18);
                }
                goto LABEL_71;
              }
            }
          }
          else
          {
            BOOL v16 = 0;
          }
          unsigned int v20 = *(unsigned __int8 *)(v13 + v16 + 11);
          if (v20 == 2) {
            goto LABEL_24;
          }
LABEL_25:
          if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v13, 0x12Cu, v20)) {
            goto LABEL_38;
          }
          if (v14)
          {
            float v22 = *v14;
            BOOL v23 = *v14 == 1.0;
            if (*(unsigned char *)(v13 + 10))
            {
              if (v22 != 0.0 && v22 != 1.0) {
                goto LABEL_36;
              }
            }
          }
          else
          {
            BOOL v23 = 0;
          }
          unsigned int v20 = *(unsigned __int8 *)(v13 + v23 + 11);
          if (v20 == 2)
          {
LABEL_36:
            char v25 = gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v13, 0x12Du, 0);
            unsigned int v20 = 1;
            if (v25) {
              goto LABEL_55;
            }
          }
          if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v13, 0x12Du, v20))
          {
LABEL_38:
            unsigned int v20 = 1;
            goto LABEL_55;
          }
          if (v14)
          {
            float v26 = *v14;
            BOOL v27 = *v14 == 1.0;
            if (*(unsigned char *)(v13 + 10))
            {
              if (v26 != 0.0 && v26 != 1.0)
              {
LABEL_49:
                LOBYTE(v55) = 1;
                v53[0] = 1;
                uint64_t v30 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v13, 0x96u, 0, &v55);
                uint64_t v31 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v13, 0x96u, 1u, v53);
                if (v26 >= 1.0) {
                  uint64_t v32 = (int *)v31;
                }
                else {
                  uint64_t v32 = (int *)v30;
                }
                int v33 = *v32;
                goto LABEL_54;
              }
            }
          }
          else
          {
            BOOL v27 = 0;
          }
          unsigned int v29 = *(unsigned __int8 *)(v13 + v27 + 11);
          float v26 = 0.0;
          if (v29 == 2) {
            goto LABEL_49;
          }
          LOBYTE(v33) = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v13, 0x96u, v29, 0);
LABEL_54:
          unsigned int v20 = v33 == 1;
          goto LABEL_55;
        }
      }
      else if (v62)
      {
        goto LABEL_11;
      }
      uint64_t v18 = (unsigned int *)(v5 + 20);
      if (*(_DWORD *)(v5 + 20))
      {
        uint64_t v19 = (uint64_t *)(v45 + 16 * *(unsigned int *)(v5 + 16));
LABEL_64:
        unsigned int v39 = 0;
        do
        {
          uint64_t v40 = *v19;
          uint64_t v41 = *(void *)(a3[4] + 24);
          uint64_t v42 = (std::__shared_weak_count *)*((void *)&v63 + 1);
          long long v54 = v63;
          if (*((void *)&v63 + 1)) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v63 + 1) + 8), 1uLL, memory_order_relaxed);
          }
          unint64_t v43 = v19[1];
          v53[0] = 0;
          v52[0] = 0;
          LOBYTE(v50) = 0;
          char v51 = 0;
          v49[0] = 0;
          v49[1] = 0;
          LOWORD(v55) = 255;
          *(void *)((char *)&v55 + 4) = 0;
          if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
            std::__shared_weak_count::__release_weak(v42);
          }
          ++v39;
          v19 += 2;
        }
        while (v39 < *v18);
      }
LABEL_71:
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v60);
      uint64_t v44 = (std::__shared_weak_count *)*((void *)&v63 + 1);
      if (*((void *)&v63 + 1))
      {
        if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v63 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
          std::__shared_weak_count::__release_weak(v44);
        }
      }
      v5 += 56;
    }
    while (v5 != v46);
  }
}

void sub_1A259AFE0(_Unwind_Exception *a1)
{
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker(v1 - 176);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 - 136);
  _Unwind_Resume(a1);
}

void anonymous namespace'::addPatternedRibbonToBatches(uint64_t *a1, uint64_t *a2, unint64_t a3, unint64_t a4, uint64_t a5, long long *a6, uint64_t *a7, uint64_t a8, double a9)
{
  uint64_t v17 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    operator new();
  }
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 120, 8);
  uint64_t v19 = v18;
  *(_OWORD *)(v18 + 49) = 0u;
  *(_OWORD *)(v18 + 8) = 0u;
  *(_OWORD *)(v18 + 24) = 0u;
  *(_OWORD *)(v18 + 40) = 0u;
  *(void *)(v18 + 56) = a3;
  *(void *)uint64_t v18 = &unk_1EF553D90;
  *(void *)(v18 + 80) = 0;
  *(void *)(v18 + 88) = 0;
  *(void *)(v18 + 72) = 0;
  if (!a3)
  {
    *(void *)uint64_t v18 = &unk_1EF5351A8;
    *(_WORD *)(v18 + 96) = 0;
    uint64_t v64 = v18;
    uint64_t v32 = *a2;
    int v33 = (std::__shared_weak_count *)a2[1];
    if (!v33) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  *(void *)(v18 + 88) = a3;
  {
    operator new();
  }
  unint64_t v20 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                      + 16))(mdm::Allocator::instance(void)::alloc, 12 * a3, 8);
  *(void *)(v19 + 72) = v20;
  *(unsigned char *)(v19 + 64) = 1;
  *(void *)uint64_t v19 = &unk_1EF5351A8;
  *(_WORD *)(v19 + 96) = 0;
  uint64_t v64 = v19;
  if (!a5)
  {
    if (a3 < 0x1C) {
      goto LABEL_52;
    }
    int v39 = 0;
    unint64_t v40 = 0;
    BOOL v41 = !is_mul_ok(a3 - 1, 0xCuLL);
    BOOL v45 = v20 + 12 * (a3 - 1) >= v20
       && v20 + 8 + 12 * (a3 - 1) >= v20 + 8
       && a3 != 0x100000000
       && (a3 - 1) >> 32 == 0
       && v20 + 4 + 12 * (a3 - 1) >= v20 + 4;
    if (!v45 || v41) {
      goto LABEL_53;
    }
    if (v20 < a4 + 8 * a3 && v20 + 12 * a3 > a4)
    {
LABEL_52:
      unint64_t v40 = 0;
      int v39 = 0;
    }
    else
    {
      unint64_t v40 = a3 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v47 = (const float *)(a4 + 32);
      long long v48 = 0uLL;
      uint64_t v49 = (float *)v20;
      unint64_t v50 = a3 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        char v51 = v47 - 8;
        float32x4x2_t v65 = vld2q_f32(v51);
        *(float32x4x2_t *)v66.val[0].f32 = vld2q_f32(v47);
        v66.val[2] = 0uLL;
        uint64_t v52 = v49 + 24;
        vst3q_f32(v49, *(float32x4x3_t *)(&v48 - 2));
        uint64_t v53 = v49 + 12;
        vst3q_f32(v53, v66);
        v47 += 16;
        uint64_t v49 = v52;
        v50 -= 8;
      }
      while (v50);
      int v39 = a3 & 0xFFFFFFF8;
      if (v40 == a3)
      {
LABEL_55:
        uint64_t v32 = *a2;
        int v33 = (std::__shared_weak_count *)a2[1];
        if (!v33) {
          goto LABEL_16;
        }
LABEL_15:
        atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
        goto LABEL_16;
      }
    }
LABEL_53:
    unsigned int v54 = v39 + 1;
    do
    {
      uint64_t v55 = *(void *)(a4 + 8 * v40);
      unint64_t v56 = v20 + 12 * v40;
      *(void *)unint64_t v56 = v55;
      *(_DWORD *)(v56 + 8) = 0;
      unint64_t v40 = v54++;
    }
    while (v40 < a3);
    goto LABEL_55;
  }
  long long v57 = a1;
  unint64_t v24 = 0;
  unsigned int v25 = 1;
  do
  {
    long long v27 = a6[1];
    v63[0] = *a6;
    v63[1] = v27;
    uint64_t v28 = *a7;
    unsigned int v29 = (std::__shared_weak_count *)a7[1];
    uint64_t v61 = *a7;
    char v62 = v29;
    if (v29) {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v30 = (float *)(a4 + 8 * v24);
    float v31 = md::drape(v63, v28, v29, a8, *v30, v30[1], *(float *)(a5 + 4 * v24), a9, v21, v22, v23);
    if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
    uint64_t v19 = v64;
    uint64_t v26 = *(void *)(v64 + 72) + 12 * v24;
    *(void *)uint64_t v26 = *(void *)v30;
    *(float *)(v26 + 8) = v31;
    unint64_t v24 = v25++;
  }
  while (v24 < a3);
  uint64_t v17 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
  a1 = v57;
  uint64_t v32 = *a2;
  int v33 = (std::__shared_weak_count *)a2[1];
  if (v33) {
    goto LABEL_15;
  }
LABEL_16:
  v59[0] = v32;
  v59[1] = v33;
  int v60 = -1;
  unsigned int v34 = std::__hash_table<std::__hash_value_type<md::PatternedBatchKey,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>,std::__unordered_map_hasher<md::PatternedBatchKey,std::__hash_value_type<md::PatternedBatchKey,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>,std::hash<md::PatternedBatchKey>,std::equal_to<md::PatternedBatchKey>,true>,std::__unordered_map_equal<md::PatternedBatchKey,std::__hash_value_type<md::PatternedBatchKey,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>,std::equal_to<md::PatternedBatchKey>,std::hash<md::PatternedBatchKey>,true>,std::allocator<std::__hash_value_type<md::PatternedBatchKey,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>>>::__emplace_unique_key_args<md::PatternedBatchKey,std::piecewise_construct_t const&,std::tuple<md::PatternedBatchKey const&>,std::tuple<>>(a1, v32, 0xFFFFFFFF, (uint64_t)v59);
  uint64_t v35 = v34;
  uint64_t v36 = (uint64_t *)v34[6];
  if ((unint64_t)v36 >= v34[7])
  {
    BOOL v37 = std::vector<std::unique_ptr<md::RoadRibbon,mdm::TypeDeleter<md::RoadRibbon>>,geo::StdAllocator<std::unique_ptr<md::RoadRibbon,mdm::TypeDeleter<md::RoadRibbon>>,mdm::Allocator>>::__push_back_slow_path<std::unique_ptr<md::RoadRibbon,mdm::TypeDeleter<md::RoadRibbon>>>((uint64_t)(v34 + 5), &v64);
  }
  else
  {
    if (v36)
    {
      uint64_t v64 = 0;
      *uint64_t v36 = v19;
    }
    BOOL v37 = v36 + 1;
  }
  v35[6] = v37;
  if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
  unint64_t v38 = (void (***)(void))v64;
  uint64_t v64 = 0;
  if (v38)
  {
    (**v38)(v38);
    {
        operator new();
    }
    (*(void (**)(void, void (***)(void), uint64_t))(**((void **)v17 + 91) + 40))(*((void *)v17 + 91), v38, 120);
  }
}

void sub_1A259B620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::unique_ptr<md::RoadRibbon,mdm::TypeDeleter<md::RoadRibbon>>::~unique_ptr[abi:nn180100]((void (****)(void))va1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<md::DaVinciCenterLineRoadsTileData::DaVinciCenterLineRoadsTileData(md::MapDataType,gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOVectorTileResource>> const&,BOOL,BOOL,std::vector<gdc::Resource::LoadMetadata> &&<gss::StylesheetManager<std::vector<std::shared_ptr<md::GEOVectorTileResource>> const&::PropertyID>>,VKSharedResources *,std::function<BOOL ()(std::shared_ptr const&,GeoCodecsRoadFeature const&,md::MapDataType)>,BOOL,std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>)::$_0,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF590DB0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::DaVinciCenterLineRoadsTileData::DaVinciCenterLineRoadsTileData(md::MapDataType,gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOVectorTileResource>> const&,BOOL,BOOL,std::vector<gdc::Resource::LoadMetadata> &&<gss::StylesheetManager<std::vector<std::shared_ptr<md::GEOVectorTileResource>> const&::PropertyID>>,VKSharedResources *,std::function<BOOL ()(std::shared_ptr const&,GeoCodecsRoadFeature const&,md::MapDataType)>,BOOL,std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>)::$_0,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_1EF590DB0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

void std::__function::__func<md::DaVinciCenterLineRoadsTileData::DaVinciCenterLineRoadsTileData(md::MapDataType,gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOVectorTileResource>> const&,BOOL,BOOL,std::vector<gdc::Resource::LoadMetadata> &&<gss::StylesheetManager<std::vector<std::shared_ptr<md::GEOVectorTileResource>> const&::PropertyID>>,VKSharedResources *,std::function<BOOL ()(std::shared_ptr const&,GeoCodecsRoadFeature const&,md::MapDataType)>,BOOL,std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>)::$_0,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<gss::FeatureAttributeSet,std::vector<GeoCodecsRoadFeature const*>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gss::FeatureAttributeSet,std::vector<GeoCodecsRoadFeature const*>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      long long v3 = *(void **)(v2 + 48);
      if (v3)
      {
        *(void *)(v2 + 56) = v3;
        operator delete(v3);
      }
      uint64_t v4 = *(void *)(v2 + 16);
      if (v4)
      {
        *(void *)(v2 + 24) = v4;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 40) + 40))(*(void *)(v2 + 40), v4, *(void *)(v2 + 32) - v4);
      }
    }
    operator delete((void *)v2);
  }
  return a1;
}

void std::vector<md::TransitLink::Section>::__append(void **a1, unint64_t a2)
{
  uint64_t v4 = (char *)a1[1];
  uint64_t v5 = a1[2];
  if (0xAAAAAAAAAAAAAAABLL * ((v5 - v4) >> 5) >= a2)
  {
    uint64_t v11 = &v4[96 * a2];
    do
    {
      *((_OWORD *)v4 + 2) = 0uLL;
      *((_OWORD *)v4 + 3) = 0uLL;
      *((_OWORD *)v4 + 4) = 0uLL;
      *((_OWORD *)v4 + 5) = 0uLL;
      *(_OWORD *)uint64_t v4 = 0uLL;
      *((_OWORD *)v4 + 1) = 0uLL;
      v4[33] = 4;
      *(_OWORD *)(v4 + 40) = 0uLL;
      *(_OWORD *)(v4 + 56) = 0uLL;
      *((_WORD *)v4 + 36) = 1024;
      *((void *)v4 + 10) = 0;
      *(void *)(v4 + 86) = 0;
      v4 += 96;
    }
    while (v4 != v11);
    a1[1] = v11;
  }
  else
  {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v4 - (unsigned char *)*a1) >> 5);
    unint64_t v7 = v6 + a2;
    if (v6 + a2 > 0x2AAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (unsigned char *)*a1) >> 5);
    if (2 * v8 > v7) {
      unint64_t v7 = 2 * v8;
    }
    if (v8 >= 0x155555555555555) {
      unint64_t v9 = 0x2AAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v9 = v7;
    }
    if (v9)
    {
      if (v9 > 0x2AAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v10 = (char *)operator new(96 * v9);
    }
    else
    {
      uint64_t v10 = 0;
    }
    uint64_t v12 = &v10[96 * v6];
    uint64_t v13 = &v12[96 * a2];
    uint64_t v14 = v12;
    do
    {
      *((_OWORD *)v14 + 2) = 0uLL;
      *((_OWORD *)v14 + 3) = 0uLL;
      *((_OWORD *)v14 + 4) = 0uLL;
      *((_OWORD *)v14 + 5) = 0uLL;
      *(_OWORD *)uint64_t v14 = 0uLL;
      *((_OWORD *)v14 + 1) = 0uLL;
      v14[33] = 4;
      *(_OWORD *)(v14 + 40) = 0uLL;
      *(_OWORD *)(v14 + 56) = 0uLL;
      *((_WORD *)v14 + 36) = 1024;
      *((void *)v14 + 10) = 0;
      *(void *)(v14 + 86) = 0;
      v14 += 96;
    }
    while (v14 != v13);
    uint64_t v15 = &v10[96 * v9];
    uint64_t v17 = (char *)*a1;
    BOOL v16 = (char *)a1[1];
    if (v16 != *a1)
    {
      do
      {
        long long v18 = *((_OWORD *)v16 - 5);
        *((_OWORD *)v12 - 6) = *((_OWORD *)v16 - 6);
        *((_OWORD *)v12 - 5) = v18;
        long long v19 = *((_OWORD *)v16 - 4);
        long long v20 = *((_OWORD *)v16 - 3);
        long long v21 = *((_OWORD *)v16 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v16 - 2);
        *((_OWORD *)v12 - 1) = v21;
        *((_OWORD *)v12 - 4) = v19;
        *((_OWORD *)v12 - 3) = v20;
        v12 -= 96;
        v16 -= 96;
      }
      while (v16 != v17);
      BOOL v16 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v13;
    a1[2] = v15;
    if (v16)
    {
      operator delete(v16);
    }
  }
}

uint64_t *md::TransitLink::TransitLink(uint64_t *a1, uint64_t *a2)
{
  a1[1] = 0;
  long long v3 = (geo::codec::VectorTile **)(a1 + 1);
  a1[2] = 0;
  *a1 = (uint64_t)a2;
  if (a2)
  {
    uint64_t v5 = (std::__shared_weak_count *)a2[1];
    if (v5 && (uint64_t v5 = std::__shared_weak_count::lock(v5)) != 0) {
      uint64_t v6 = *a2;
    }
    else {
      uint64_t v6 = 0;
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
  }
  unint64_t v7 = (std::__shared_weak_count *)a1[2];
  a1[1] = v6;
  a1[2] = (uint64_t)v5;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  *(_OWORD *)(a1 + 7) = 0u;
  a1[18] = 0;
  a1[17] = 0;
  *(_OWORD *)(a1 + 3) = 0u;
  *(_OWORD *)(a1 + 5) = 0u;
  *(_OWORD *)(a1 + 9) = 0u;
  *(_OWORD *)(a1 + 11) = 0u;
  *(_OWORD *)(a1 + 13) = 0u;
  a1[15] = 0;
  a1[16] = (uint64_t)(a1 + 17);
  *((_DWORD *)a1 + 38) = 0;
  a1[20] = 0;
  *((unsigned char *)a1 + 168) = 0;
  *((_OWORD *)a1 + 11) = 0u;
  *((_OWORD *)a1 + 12) = 0u;
  *((_DWORD *)a1 + 52) = 1065353216;
  *(_OWORD *)(a1 + 27) = xmmword_1A28FE960;
  a1[29] = 0;
  unint64_t v8 = (float *)(a1 + 29);
  *(uint64_t *)((char *)a1 + 237) = 0;
  unint64_t v9 = *(unsigned int *)(*a1 + 20);
  if (!v9)
  {
    std::vector<md::TransitLink::Section>::__append((void **)a1 + 7, 1uLL);
    return a1;
  }
  std::vector<md::TransitLink::Section>::__append((void **)a1 + 7, v9);
  if (*v3)
  {
    uint64_t v10 = geo::codec::VectorTile::transitLinkSections(*v3);
    uint64_t v11 = a1[7];
    uint64_t v12 = a1[8];
    if (v12 != v11)
    {
      unint64_t v13 = 0;
      float v14 = *v8;
      float v15 = 0.0;
      uint64_t v12 = a1[7];
      while (1)
      {
        unint64_t v17 = v12 + 96 * v13;
        *(float *)(v17 + 80) = v14;
        unint64_t v70 = 0;
        unint64_t v18 = geo::codec::transitLinkPoints(*a1, v13, &v70);
        unint64_t v19 = v70;
        if (!v70) {
          goto LABEL_30;
        }
        *(_DWORD *)(v17 + 16) = *(_DWORD *)v18;
        *(_DWORD *)(v17 + 20) = *(_DWORD *)(v18 + 4);
        unint64_t v20 = v12 + 96 * v13;
        *(unsigned char *)(v20 + 92) = 1;
        unint64_t v21 = v19 - 1;
        double v22 = (float *)(v18 + 8 * (v19 - 1));
        *(float *)(v20 + 56) = *v22;
        *(float *)(v20 + 60) = v22[1];
        if (v19 == 1) {
          goto LABEL_30;
        }
        float v23 = *(float *)(v18 + 8) - *(float *)v18;
        float v24 = *(float *)(v18 + 12) - *(float *)(v18 + 4);
        float v25 = 1.0 / sqrtf((float)(v23 * v23) + (float)(v24 * v24));
        float v26 = v25 * v23;
        *(float *)unint64_t v17 = v26;
        *(float *)(v17 + 4) = v25 * v24;
        *(float *)(v17 + 8) = -(float)(v25 * v24);
        *(float *)(v17 + 12) = v26;
        if ((uint64_t)(v19 - 2) < 0)
        {
          unint64_t v36 = v12 + 96 * v13;
          float v37 = *(float *)(v36 + 88);
          unint64_t v33 = v36 + 88;
          float v35 = v37;
          *(unsigned char *)(v33 + 5) = 0;
        }
        else
        {
          long long v27 = (float *)(v18 + 8 * (v19 - 2));
          float v28 = *v22 - *v27;
          float v29 = v22[1] - v27[1];
          float v30 = 1.0 / sqrtf((float)(v28 * v28) + (float)(v29 * v29));
          float v31 = v30 * v28;
          unint64_t v32 = v12 + 96 * v13;
          float v34 = *(float *)(v32 + 88);
          unint64_t v33 = v32 + 88;
          float v35 = v34;
          *(float *)(v33 - 48) = v31;
          *(float *)(v33 - 44) = v30 * v29;
          *(float *)(v33 - 40) = -(float)(v30 * v29);
          *(float *)(v33 - 36) = v31;
          *(unsigned char *)(v33 + 5) = 1;
          if (v19 < 9) {
            goto LABEL_23;
          }
        }
        if (v33 < v18 + 8 * v19 && v18 < v12 + 96 * v13 + 92)
        {
LABEL_23:
          uint64_t v38 = 1;
          goto LABEL_28;
        }
        unint64_t v39 = v21 & 0xFFFFFFFFFFFFFFF8;
        float32x4_t v40 = 0uLL;
        float32x4_t v41 = (float32x4_t)LODWORD(v35);
        unint64_t v42 = v18 + 40;
        unint64_t v43 = v21 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          float32x4_t v44 = vsubq_f32(*(float32x4_t *)(v42 - 32), *(float32x4_t *)(v42 - 40));
          float32x4_t v45 = vsubq_f32(*(float32x4_t *)(v42 - 16), *(float32x4_t *)(v42 - 24));
          float32x4_t v46 = vsubq_f32(*(float32x4_t *)v42, *(float32x4_t *)(v42 - 8));
          float32x4_t v47 = vsubq_f32(*(float32x4_t *)(v42 + 16), *(float32x4_t *)(v42 + 8));
          int32x4_t v48 = (int32x4_t)vmulq_f32(v45, v45);
          int32x4_t v49 = (int32x4_t)vmulq_f32(v44, v44);
          int32x4_t v50 = (int32x4_t)vmulq_f32(v47, v47);
          int32x4_t v51 = (int32x4_t)vmulq_f32(v46, v46);
          float32x4_t v41 = vaddq_f32(vsqrtq_f32(vaddq_f32((float32x4_t)vuzp2q_s32(v49, v48), (float32x4_t)vuzp1q_s32(v49, v48))), v41);
          float32x4_t v40 = vaddq_f32(vsqrtq_f32(vaddq_f32((float32x4_t)vuzp2q_s32(v51, v50), (float32x4_t)vuzp1q_s32(v51, v50))), v40);
          v42 += 64;
          v43 -= 8;
        }
        while (v43);
        float32x4_t v52 = vaddq_f32(v40, v41);
        float v35 = vaddv_f32((float32x2_t)*(_OWORD *)&vpaddq_f32(v52, v52));
        *(float *)unint64_t v33 = v35;
        if (v21 == v39) {
          goto LABEL_30;
        }
        uint64_t v38 = v39 | 1;
LABEL_28:
        unint64_t v53 = v19 - v38;
        unsigned int v54 = (float32x2_t *)(v18 + 8 * v38);
        do
        {
          float32x2_t v55 = vsub_f32(*v54, v54[-1]);
          float v35 = sqrtf(vaddv_f32(vmul_f32(v55, v55))) + v35;
          *(float *)unint64_t v33 = v35;
          ++v54;
          --v53;
        }
        while (v53);
LABEL_30:
        float v14 = *v8 + *(float *)(v12 + 96 * v13 + 88);
        *unint64_t v8 = v14;
        if (v10)
        {
          unint64_t v56 = (float *)(v10 + 8 * *(unsigned int *)(*a1 + 16) + 8 * v13);
          float v15 = (float)(v56[1] + v15) - *v56;
        }
        ++v13;
        uint64_t v12 = a1[7];
        unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((a1[8] - v12) >> 5);
        if (v13 >= v16) {
          goto LABEL_34;
        }
      }
    }
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v11) >> 5);
    float v15 = 0.0;
LABEL_34:
    if (v10 && v16)
    {
      float v57 = *v8 + (float)(*v8 * (float)(1.0 - v15));
      uint64_t v58 = *(unsigned int *)(*a1 + 16);
      if (v16 == 1)
      {
        unint64_t v59 = 0;
LABEL_41:
        unint64_t v65 = v16 - v59;
        float32x4x3_t v66 = (float *)(v12 + 96 * v59 + 84);
        size_t v67 = (float *)(v10 + 8 * v59 + 8 * v58);
        do
        {
          float v68 = *v67;
          v67 += 2;
          *float32x4x3_t v66 = v68 * v57;
          v66 += 24;
          --v65;
        }
        while (v65);
        return a1;
      }
      unint64_t v59 = v16 & 0xFFFFFFFFFFFFFFFELL;
      int v60 = (float *)(v12 + 180);
      uint64_t v61 = (float *)(v10 + 8 * v58 + 8);
      unint64_t v62 = v16 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        float v63 = *(v61 - 2);
        float v64 = *v61;
        v61 += 4;
        *(v60 - 24) = v63 * v57;
        *int v60 = v64 * v57;
        v60 += 48;
        v62 -= 2;
      }
      while (v62);
      if (v16 != v59) {
        goto LABEL_41;
      }
    }
  }
  return a1;
}

void sub_1A259BDEC(_Unwind_Exception *a1)
{
  unint64_t v20 = v2;
  uint64_t v5 = *(void **)(v1 + 192);
  if (v5)
  {
    do
    {
      uint64_t v6 = (void *)*v5;
      operator delete(v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  unint64_t v7 = *v3;
  *long long v3 = 0;
  if (v7) {
    operator delete(v7);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 136));
  unint64_t v8 = *(void **)(v1 + 104);
  if (v8)
  {
    *(void *)(v1 + 112) = v8;
    operator delete(v8);
  }
  uint64_t v9 = *(void *)(v1 + 80);
  if (v9)
  {
    uint64_t v10 = *(void *)(v1 + 88);
    uint64_t v11 = *(void **)(v1 + 80);
    if (v10 != v9)
    {
      uint64_t v12 = *(void *)(v1 + 88);
      do
      {
        float v14 = *(void **)(v12 - 8);
        v12 -= 8;
        unint64_t v13 = v14;
        if (v14)
        {
          if ((*v13)-- == 1)
          {
            operator delete(v13);
            *(void *)(v10 - 8) = 0;
          }
        }
        uint64_t v10 = v12;
      }
      while (v12 != v9);
      uint64_t v11 = *(void **)(v1 + 80);
    }
    *(void *)(v1 + 88) = v9;
    operator delete(v11);
  }
  unint64_t v16 = *v20;
  if (*v20)
  {
    *(void *)(v1 + 64) = v16;
    operator delete(v16);
  }
  unint64_t v17 = *(std::__shared_weak_count **)(v1 + 48);
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  unint64_t v18 = *(std::__shared_weak_count **)(v1 + 32);
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  unint64_t v19 = *(std::__shared_weak_count **)(v1 + 16);
  if (v19)
  {
    if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  _Unwind_Resume(a1);
}

void md::TransitLink::~TransitLink(md::TransitLink *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 4);
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    long long v3 = (void *)*((void *)this + 24);
    if (!v3) {
      goto LABEL_5;
    }
  }
  else
  {
    long long v3 = (void *)*((void *)this + 24);
    if (!v3) {
      goto LABEL_5;
    }
  }
  do
  {
    uint64_t v4 = (void *)*v3;
    operator delete(v3);
    long long v3 = v4;
  }
  while (v4);
LABEL_5:
  uint64_t v5 = (void *)*((void *)this + 22);
  *((void *)this + 22) = 0;
  if (v5) {
    operator delete(v5);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 17));
  uint64_t v6 = (void *)*((void *)this + 13);
  if (v6)
  {
    *((void *)this + 14) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *((void *)this + 10);
  if (v7)
  {
    uint64_t v8 = *((void *)this + 11);
    uint64_t v9 = (void *)*((void *)this + 10);
    if (v8 != v7)
    {
      uint64_t v10 = *((void *)this + 11);
      do
      {
        uint64_t v12 = *(void **)(v10 - 8);
        v10 -= 8;
        uint64_t v11 = v12;
        if (v12)
        {
          if ((*v11)-- == 1)
          {
            operator delete(v11);
            *(void *)(v8 - 8) = 0;
          }
        }
        uint64_t v8 = v10;
      }
      while (v10 != v7);
      uint64_t v9 = (void *)*((void *)this + 10);
    }
    *((void *)this + 11) = v7;
    operator delete(v9);
  }
  float v14 = (void *)*((void *)this + 7);
  if (v14)
  {
    *((void *)this + 8) = v14;
    operator delete(v14);
  }
  float v15 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
    unint64_t v16 = (std::__shared_weak_count *)*((void *)this + 4);
    if (!v16) {
      goto LABEL_29;
    }
  }
  else
  {
    unint64_t v16 = (std::__shared_weak_count *)*((void *)this + 4);
    if (!v16) {
      goto LABEL_29;
    }
  }
  if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
LABEL_29:
  unint64_t v17 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v17)
  {
    if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,md::TransitLink::updateLineStyles(int,md::TransitLineMergeDisable,BOOL &)::$_0 &,md::TransitLineSegment **,false>(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v9 = (uint64_t *)result;
LABEL_2:
  uint64_t v10 = a2 - 1;
  uint64_t v11 = v9;
  while (1)
  {
    uint64_t v9 = v11;
    uint64_t v12 = (char *)a2 - (char *)v11;
    uint64_t v13 = a2 - v11;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v81 = *v11;
          if (*(_DWORD *)(*v10 + 40) < *(_DWORD *)(*v11 + 40))
          {
            uint64_t *v11 = *v10;
            *uint64_t v10 = v81;
          }
          return result;
        case 3:
          uint64_t v82 = *v11;
          uint64_t v83 = v11[1];
          unsigned int v84 = *(_DWORD *)(v83 + 40);
          unsigned int v85 = *(_DWORD *)(*v11 + 40);
          uint64_t v86 = *v10;
          unsigned int v87 = *(_DWORD *)(*v10 + 40);
          if (v84 >= v85)
          {
            if (v87 < v84)
            {
              v11[1] = v86;
              *uint64_t v10 = v83;
              uint64_t v138 = *v11;
              uint64_t v137 = v11[1];
              if (*(_DWORD *)(v137 + 40) < *(_DWORD *)(*v11 + 40))
              {
                uint64_t *v11 = v137;
                v11[1] = v138;
              }
            }
          }
          else
          {
            if (v87 >= v84)
            {
              uint64_t *v11 = v83;
              v11[1] = v82;
              if (*(_DWORD *)(*v10 + 40) >= v85) {
                return result;
              }
              v11[1] = *v10;
            }
            else
            {
              uint64_t *v11 = v86;
            }
            *uint64_t v10 = v82;
          }
          return result;
        case 4:
          uint64_t v88 = v11 + 1;
          uint64_t v89 = v11[1];
          unint64_t v90 = v11 + 2;
          uint64_t v91 = v11[2];
          uint64_t v92 = *v11;
          unsigned int v93 = *(_DWORD *)(v89 + 40);
          unsigned int v94 = *(_DWORD *)(*v11 + 40);
          unsigned int v95 = *(_DWORD *)(v91 + 40);
          if (v93 >= v94)
          {
            if (v95 >= v93) {
              goto LABEL_169;
            }
            *uint64_t v88 = v91;
            uint64_t *v90 = v89;
            uint64_t v96 = v11;
            unint64_t v97 = v11 + 1;
            __n128 result = v89;
            if (v95 >= v94) {
              goto LABEL_170;
            }
          }
          else
          {
            uint64_t v96 = v11;
            unint64_t v97 = v11 + 2;
            __n128 result = *v11;
            if (v95 >= v93)
            {
              uint64_t *v11 = v89;
              v11[1] = v92;
              uint64_t v96 = v11 + 1;
              unint64_t v97 = v11 + 2;
              __n128 result = v92;
              if (v95 >= v94)
              {
LABEL_169:
                uint64_t v89 = v91;
LABEL_170:
                if (*(_DWORD *)(*v10 + 40) < *(_DWORD *)(v89 + 40))
                {
                  uint64_t *v90 = *v10;
                  *uint64_t v10 = v89;
                  uint64_t v142 = *v90;
                  uint64_t v143 = *v88;
                  unsigned int v144 = *(_DWORD *)(v142 + 40);
                  if (v144 < *(_DWORD *)(v143 + 40))
                  {
                    v11[1] = v142;
                    void v11[2] = v143;
                    uint64_t v145 = *v11;
                    if (v144 < *(_DWORD *)(*v11 + 40))
                    {
                      uint64_t *v11 = v142;
                      v11[1] = v145;
                    }
                  }
                }
                return result;
              }
            }
          }
          *uint64_t v96 = v91;
          *unint64_t v97 = v92;
          uint64_t v89 = result;
          goto LABEL_170;
        case 5:
          return (uint64_t)std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,altitude::ObjectTreeLoader::cleanupModels(void)::OldestFirst &,altitude::ObjectTreeModel::LodLevel **,0>(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
        default:
          JUMPOUT(0);
      }
    }
    if (v12 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v11 != a2)
      {
        int64_t v109 = (unint64_t)(v13 - 2) >> 1;
        int64_t v110 = v109;
        do
        {
          if (v109 >= v110)
          {
            uint64_t v112 = (2 * v110) | 1;
            unsigned __int8 v113 = &v11[v112];
            uint64_t v114 = *v113;
            if (2 * v110 + 2 < v13)
            {
              __n128 result = *(unsigned int *)(v114 + 40);
              if (result < *(_DWORD *)(v113[1] + 40))
              {
                uint64_t v114 = v113[1];
                ++v113;
                uint64_t v112 = 2 * v110 + 2;
              }
            }
            int v115 = &v11[v110];
            uint64_t v116 = *v115;
            unsigned int v117 = *(_DWORD *)(*v115 + 40);
            if (*(_DWORD *)(v114 + 40) >= v117)
            {
              do
              {
                uint64_t v118 = v113;
                *int v115 = v114;
                if (v109 < v112) {
                  break;
                }
                __n128 result = (2 * v112) | 1;
                unsigned __int8 v113 = &v11[result];
                uint64_t v119 = 2 * v112 + 2;
                uint64_t v114 = *v113;
                if (v119 < v13 && *(_DWORD *)(v114 + 40) < *(_DWORD *)(v113[1] + 40))
                {
                  uint64_t v114 = v113[1];
                  ++v113;
                  __n128 result = v119;
                }
                int v115 = v118;
                uint64_t v112 = result;
              }
              while (*(_DWORD *)(v114 + 40) >= v117);
              *uint64_t v118 = v116;
            }
          }
          BOOL v111 = v110-- <= 0;
        }
        while (!v111);
        uint64_t v120 = (unint64_t)v12 >> 3;
        do
        {
          uint64_t v121 = 0;
          uint64_t v122 = *v11;
          uint64_t v123 = v11;
          do
          {
            uint64_t v124 = &v123[v121];
            uint64_t v127 = v124[1];
            size_t v125 = v124 + 1;
            uint64_t v126 = v127;
            uint64_t v128 = (2 * v121) | 1;
            uint64_t v129 = 2 * v121 + 2;
            if (v129 < v120)
            {
              __n128 result = *(unsigned int *)(v126 + 40);
              if (result < *(_DWORD *)(v125[1] + 40))
              {
                uint64_t v126 = v125[1];
                ++v125;
                uint64_t v128 = v129;
              }
            }
            uint64_t *v123 = v126;
            uint64_t v123 = v125;
            uint64_t v121 = v128;
          }
          while (v128 <= (uint64_t)((unint64_t)(v120 - 2) >> 1));
          if (v125 == --a2)
          {
            *size_t v125 = v122;
          }
          else
          {
            *size_t v125 = *a2;
            *a2 = v122;
            uint64_t v130 = (char *)v125 - (char *)v11 + 8;
            if (v130 >= 9)
            {
              unint64_t v131 = (((unint64_t)v130 >> 3) - 2) >> 1;
              int64_t v132 = &v11[v131];
              uint64_t v133 = *v132;
              uint64_t v134 = *v125;
              unsigned int v135 = *(_DWORD *)(*v125 + 40);
              if (*(_DWORD *)(*v132 + 40) < v135)
              {
                do
                {
                  uint64_t v136 = v132;
                  *size_t v125 = v133;
                  if (!v131) {
                    break;
                  }
                  unint64_t v131 = (v131 - 1) >> 1;
                  int64_t v132 = &v11[v131];
                  uint64_t v133 = *v132;
                  size_t v125 = v136;
                }
                while (*(_DWORD *)(*v132 + 40) < v135);
                *uint64_t v136 = v134;
              }
            }
          }
          BOOL v111 = v120-- <= 2;
        }
        while (!v111);
      }
      return result;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    float v15 = &v11[(unint64_t)v13 >> 1];
    uint64_t v16 = *v10;
    unsigned int v17 = *(_DWORD *)(*v10 + 40);
    if ((unint64_t)v12 >= 0x401)
    {
      uint64_t v18 = *v15;
      uint64_t v19 = *v11;
      unsigned int v20 = *(_DWORD *)(*v15 + 40);
      unsigned int v21 = *(_DWORD *)(*v11 + 40);
      if (v20 >= v21)
      {
        if (v17 < v20)
        {
          uint64_t *v15 = v16;
          *uint64_t v10 = v18;
          uint64_t v26 = *v11;
          if (*(_DWORD *)(*v15 + 40) < *(_DWORD *)(*v11 + 40))
          {
            uint64_t *v11 = *v15;
            uint64_t *v15 = v26;
          }
        }
      }
      else
      {
        if (v17 < v20)
        {
          uint64_t *v11 = v16;
          goto LABEL_22;
        }
        uint64_t *v11 = v18;
        uint64_t *v15 = v19;
        if (*(_DWORD *)(*v10 + 40) < v21)
        {
          uint64_t *v15 = *v10;
LABEL_22:
          *uint64_t v10 = v19;
        }
      }
      float v28 = &v11[v14];
      uint64_t v31 = *(v28 - 1);
      float v29 = v28 - 1;
      uint64_t v30 = v31;
      uint64_t v32 = v11[1];
      unsigned int v33 = *(_DWORD *)(v31 + 40);
      unsigned int v34 = *(_DWORD *)(v32 + 40);
      uint64_t v35 = *(a2 - 2);
      unsigned int v36 = *(_DWORD *)(v35 + 40);
      if (v33 >= v34)
      {
        if (v36 < v33)
        {
          *float v29 = v35;
          *(a2 - 2) = v30;
          uint64_t v37 = v11[1];
          if (*(_DWORD *)(*v29 + 40) < *(_DWORD *)(v37 + 40))
          {
            v11[1] = *v29;
            *float v29 = v37;
          }
        }
      }
      else
      {
        if (v36 < v33)
        {
          v11[1] = v35;
          goto LABEL_34;
        }
        v11[1] = v30;
        *float v29 = v32;
        uint64_t v38 = *(a2 - 2);
        if (*(_DWORD *)(v38 + 40) < v34)
        {
          *float v29 = v38;
LABEL_34:
          *(a2 - 2) = v32;
        }
      }
      unint64_t v39 = &v11[v14];
      uint64_t v42 = v39[1];
      float32x4_t v40 = v39 + 1;
      uint64_t v41 = v42;
      uint64_t v43 = v11[2];
      unsigned int v44 = *(_DWORD *)(v42 + 40);
      unsigned int v45 = *(_DWORD *)(v43 + 40);
      uint64_t v46 = *(a2 - 3);
      unsigned int v47 = *(_DWORD *)(v46 + 40);
      if (v44 >= v45)
      {
        if (v47 < v44)
        {
          *float32x4_t v40 = v46;
          *(a2 - 3) = v41;
          uint64_t v48 = v11[2];
          if (*(_DWORD *)(*v40 + 40) < *(_DWORD *)(v48 + 40))
          {
            void v11[2] = *v40;
            *float32x4_t v40 = v48;
          }
        }
      }
      else
      {
        if (v47 < v44)
        {
          void v11[2] = v46;
          goto LABEL_43;
        }
        void v11[2] = v41;
        *float32x4_t v40 = v43;
        uint64_t v49 = *(a2 - 3);
        if (*(_DWORD *)(v49 + 40) < v45)
        {
          *float32x4_t v40 = v49;
LABEL_43:
          *(a2 - 3) = v43;
        }
      }
      uint64_t v50 = *v15;
      uint64_t v51 = *v29;
      unsigned int v52 = *(_DWORD *)(*v15 + 40);
      unsigned int v53 = *(_DWORD *)(*v29 + 40);
      uint64_t v54 = *v40;
      unsigned int v55 = *(_DWORD *)(*v40 + 40);
      if (v52 >= v53)
      {
        if (v55 >= v52) {
          goto LABEL_51;
        }
        uint64_t *v15 = v54;
        *float32x4_t v40 = v50;
        float32x4_t v40 = v15;
        uint64_t v50 = v51;
        if (v55 >= v53)
        {
          uint64_t v50 = v54;
          goto LABEL_51;
        }
      }
      else if (v55 >= v52)
      {
        *float v29 = v50;
        uint64_t *v15 = v51;
        float v29 = v15;
        uint64_t v50 = v54;
        if (v55 >= v53)
        {
          uint64_t v50 = v51;
LABEL_51:
          uint64_t v56 = *v11;
          uint64_t *v11 = v50;
          uint64_t *v15 = v56;
          goto LABEL_52;
        }
      }
      *float v29 = v54;
      *float32x4_t v40 = v51;
      goto LABEL_51;
    }
    uint64_t v22 = *v11;
    uint64_t v23 = *v15;
    unsigned int v24 = *(_DWORD *)(*v11 + 40);
    unsigned int v25 = *(_DWORD *)(*v15 + 40);
    if (v24 >= v25)
    {
      if (v17 < v24)
      {
        uint64_t *v11 = v16;
        *uint64_t v10 = v22;
        uint64_t v27 = *v15;
        if (*(_DWORD *)(*v11 + 40) < *(_DWORD *)(*v15 + 40))
        {
          uint64_t *v15 = *v11;
          uint64_t *v11 = v27;
        }
      }
      goto LABEL_52;
    }
    if (v17 < v24)
    {
      uint64_t *v15 = v16;
LABEL_31:
      *uint64_t v10 = v23;
      goto LABEL_52;
    }
    uint64_t *v15 = v22;
    uint64_t *v11 = v23;
    if (*(_DWORD *)(*v10 + 40) < v25)
    {
      uint64_t *v11 = *v10;
      goto LABEL_31;
    }
LABEL_52:
    --a3;
    uint64_t v57 = *v11;
    if (a4)
    {
      unsigned int v58 = *(_DWORD *)(v57 + 40);
LABEL_55:
      unint64_t v59 = v11;
      do
      {
        int v60 = v59;
        uint64_t v62 = v59[1];
        ++v59;
        uint64_t v61 = v62;
      }
      while (*(_DWORD *)(v62 + 40) < v58);
      float v63 = a2;
      if (v60 == v11)
      {
        float v63 = a2;
        do
        {
          if (v59 >= v63) {
            break;
          }
          uint64_t v65 = *--v63;
        }
        while (*(_DWORD *)(v65 + 40) >= v58);
      }
      else
      {
        do
          uint64_t v64 = *--v63;
        while (*(_DWORD *)(v64 + 40) >= v58);
      }
      if (v59 < v63)
      {
        uint64_t v66 = *v63;
        size_t v67 = v59;
        float v68 = v63;
        do
        {
          *size_t v67 = v66;
          uint64_t *v68 = v61;
          do
          {
            int v60 = v67;
            uint64_t v69 = v67[1];
            ++v67;
            uint64_t v61 = v69;
          }
          while (*(_DWORD *)(v69 + 40) < v58);
          do
          {
            uint64_t v70 = *--v68;
            uint64_t v66 = v70;
          }
          while (*(_DWORD *)(v70 + 40) >= v58);
        }
        while (v67 < v68);
      }
      if (v60 != v11) {
        uint64_t *v11 = *v60;
      }
      *int v60 = v57;
      if (v59 < v63) {
        goto LABEL_74;
      }
      BOOL v71 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLink::updateLineStyles(int,md::TransitLineMergeDisable,BOOL &)::$_0 &,md::TransitLineSegment **>(v11, v60);
      uint64_t v11 = v60 + 1;
      __n128 result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLink::updateLineStyles(int,md::TransitLineMergeDisable,BOOL &)::$_0 &,md::TransitLineSegment **>(v60 + 1, a2);
      if (result)
      {
        a2 = v60;
        if (v71) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v71)
      {
LABEL_74:
        __n128 result = std::__introsort<std::_ClassicAlgPolicy,md::TransitLink::updateLineStyles(int,md::TransitLineMergeDisable,BOOL &)::$_0 &,md::TransitLineSegment **,false>(v9, v60, a3, a4 & 1);
        a4 = 0;
        uint64_t v11 = v60 + 1;
      }
    }
    else
    {
      unsigned int v58 = *(_DWORD *)(v57 + 40);
      if (*(_DWORD *)(*(v11 - 1) + 40) < v58) {
        goto LABEL_55;
      }
      if (v58 < *(_DWORD *)(*v10 + 40))
      {
        do
        {
          uint64_t v72 = v11[1];
          ++v11;
        }
        while (v58 >= *(_DWORD *)(v72 + 40));
      }
      else
      {
        uint64_t v73 = v11 + 1;
        do
        {
          uint64_t v11 = v73;
          if (v73 >= a2) {
            break;
          }
          ++v73;
        }
        while (v58 >= *(_DWORD *)(*v11 + 40));
      }
      long long v74 = a2;
      if (v11 < a2)
      {
        long long v74 = a2;
        do
          uint64_t v75 = *--v74;
        while (v58 < *(_DWORD *)(v75 + 40));
      }
      if (v11 < v74)
      {
        uint64_t v76 = *v11;
        uint64_t v77 = *v74;
        do
        {
          uint64_t *v11 = v77;
          uint64_t *v74 = v76;
          do
          {
            uint64_t v78 = v11[1];
            ++v11;
            uint64_t v76 = v78;
          }
          while (v58 >= *(_DWORD *)(v78 + 40));
          do
          {
            uint64_t v79 = *--v74;
            uint64_t v77 = v79;
          }
          while (v58 < *(_DWORD *)(v79 + 40));
        }
        while (v11 < v74);
      }
      uint64_t v80 = v11 - 1;
      BOOL v4 = v11 - 1 >= v9;
      BOOL v5 = v11 - 1 == v9;
      if (v11 - 1 != v9) {
        uint64_t *v9 = *v80;
      }
      a4 = 0;
      *uint64_t v80 = v57;
    }
  }
  int v98 = v11 + 1;
  BOOL v100 = v11 == a2 || v98 == a2;
  if (a4)
  {
    if (!v100)
    {
      uint64_t v101 = 8;
      uint64_t v102 = v11;
      do
      {
        uint64_t v105 = *v102;
        uint64_t v104 = v102[1];
        uint64_t v102 = v98;
        unsigned int v106 = *(_DWORD *)(v104 + 40);
        if (v106 < *(_DWORD *)(v105 + 40))
        {
          uint64_t v107 = v101;
          do
          {
            *(uint64_t *)((char *)v11 + v107) = v105;
            uint64_t v108 = v107 - 8;
            if (v107 == 8)
            {
              uint64_t v103 = v11;
              goto LABEL_118;
            }
            uint64_t v105 = *(uint64_t *)((char *)v11 + v107 - 16);
            v107 -= 8;
          }
          while (v106 < *(_DWORD *)(v105 + 40));
          uint64_t v103 = (uint64_t *)((char *)v11 + v108);
LABEL_118:
          *uint64_t v103 = v104;
        }
        int v98 = v102 + 1;
        v101 += 8;
      }
      while (v102 + 1 != a2);
    }
  }
  else if (!v100)
  {
    do
    {
      uint64_t v140 = *v9;
      uint64_t v139 = v9[1];
      uint64_t v9 = v98;
      unsigned int v141 = *(_DWORD *)(v139 + 40);
      if (v141 < *(_DWORD *)(v140 + 40))
      {
        do
        {
          *int v98 = v140;
          uint64_t v140 = *(v98 - 2);
          --v98;
        }
        while (v141 < *(_DWORD *)(v140 + 40));
        *int v98 = v139;
      }
      int v98 = v9 + 1;
    }
    while (v9 + 1 != a2);
  }
  return result;
}

void std::__tree<std::__value_type<unsigned int,MergeGroup>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,MergeGroup>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,MergeGroup>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,MergeGroup>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,MergeGroup>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,MergeGroup>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,MergeGroup>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,MergeGroup>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,MergeGroup>>>::destroy(a1[1]);
    uint64_t v2 = (void *)a1[6];
    if (v2 != (void *)a1[8]) {
      free(v2);
    }
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<md::TransitSystemAndColor,MergeGroup>,std::__map_value_compare<md::TransitSystemAndColor,std::__value_type<md::TransitSystemAndColor,MergeGroup>,std::less<md::TransitSystemAndColor>,true>,std::allocator<std::__value_type<md::TransitSystemAndColor,MergeGroup>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<md::TransitSystemAndColor,MergeGroup>,std::__map_value_compare<md::TransitSystemAndColor,std::__value_type<md::TransitSystemAndColor,MergeGroup>,std::less<md::TransitSystemAndColor>,true>,std::allocator<std::__value_type<md::TransitSystemAndColor,MergeGroup>>>::destroy(*a1);
    std::__tree<std::__value_type<md::TransitSystemAndColor,MergeGroup>,std::__map_value_compare<md::TransitSystemAndColor,std::__value_type<md::TransitSystemAndColor,MergeGroup>,std::less<md::TransitSystemAndColor>,true>,std::allocator<std::__value_type<md::TransitSystemAndColor,MergeGroup>>>::destroy(a1[1]);
    uint64_t v2 = (void *)a1[7];
    if (v2 != (void *)a1[9]) {
      free(v2);
    }
    operator delete(a1);
  }
}

void md::TransitLink::populateMergedLinesAtIndex(void *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4 = a2;
  uint64_t v6 = a1[13];
  if (a2 >= (a1[14] - v6) >> 3)
  {
    uint64_t v7 = 0;
    goto LABEL_23;
  }
  uint64_t v7 = *(void *)(v6 + 8 * a2);
  if (!v7) {
    goto LABEL_23;
  }
  uint64_t v9 = *(char **)a3;
  uint64_t v8 = *(char **)(a3 + 8);
  uint64_t v10 = (uint64_t)&v8[-*(void *)a3] >> 3;
  unint64_t v11 = *(void *)(a3 + 24);
  if (v11 < v10 + 1)
  {
    uint64_t v12 = *(char **)(a3 + 16);
    unint64_t v13 = (1 << -(char)__clz(v11 + 1));
    if (v11 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v13 = 1;
    }
    if (v13 <= v10 + 1) {
      unint64_t v14 = v10 + 1;
    }
    else {
      unint64_t v14 = v13;
    }
    float v15 = (char *)malloc_type_malloc(8 * v14, 0x2004093837F09uLL);
    uint64_t v16 = v15;
    unsigned int v17 = *(uint64_t **)a3;
    uint64_t v18 = *(char **)(a3 + 8);
    if (*(char **)a3 == v18) {
      goto LABEL_19;
    }
    unint64_t v19 = v18 - (char *)v17 - 8;
    if (v19 < 0x18)
    {
      unsigned int v20 = v15;
    }
    else
    {
      unsigned int v20 = v15;
      if ((unint64_t)(v15 - (char *)v17) >= 0x20)
      {
        uint64_t v21 = (v19 >> 3) + 1;
        uint64_t v22 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
        unsigned int v20 = &v15[v22];
        uint64_t v23 = (long long *)(v17 + 2);
        unsigned int v24 = v15 + 16;
        uint64_t v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v26 = *v23;
          *(v24 - 1) = *(v23 - 1);
          *unsigned int v24 = v26;
          v23 += 2;
          v24 += 2;
          v25 -= 4;
        }
        while (v25);
        if (v21 == (v21 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_19;
        }
        unsigned int v17 = (uint64_t *)((char *)v17 + v22);
      }
    }
    do
    {
      uint64_t v27 = *v17++;
      *(void *)unsigned int v20 = v27;
      v20 += 8;
    }
    while (v17 != (uint64_t *)v18);
LABEL_19:
    if (v9 != v12) {
      free(*(void **)a3);
    }
    uint64_t v8 = &v16[8 * v10];
    *(void *)a3 = v16;
    *(void *)(a3 + 8) = v8;
    *(void *)(a3 + 24) = v14;
  }
  *(void *)uint64_t v8 = v7;
  *(void *)(a3 + 8) += 8;
LABEL_23:
  float v28 = (void *)a1[10];
  float v29 = (void *)a1[11];
  if (v28 != v29)
  {
    unint64_t v51 = v4;
    while (1)
    {
      if (*v28) {
        uint64_t v31 = *v28 + 8;
      }
      else {
        uint64_t v31 = 0;
      }
      if (v31 == v7 || *(_DWORD *)(v31 + 40) != v4) {
        goto LABEL_27;
      }
      uint64_t v32 = *(char **)a3;
      uint64_t v30 = *(uint64_t **)(a3 + 8);
      uint64_t v33 = ((uint64_t)v30 - *(void *)a3) >> 3;
      unint64_t v34 = *(void *)(a3 + 24);
      if (v34 < v33 + 1) {
        break;
      }
LABEL_26:
      uint64_t *v30 = v31;
      *(void *)(a3 + 8) += 8;
LABEL_27:
      if (++v28 == v29) {
        return;
      }
    }
    uint64_t v35 = *(char **)(a3 + 16);
    unint64_t v36 = (1 << -(char)__clz(v34 + 1));
    if (v34 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v36 = 1;
    }
    if (v36 <= v33 + 1) {
      unint64_t v37 = v33 + 1;
    }
    else {
      unint64_t v37 = v36;
    }
    uint64_t v38 = (char *)malloc_type_malloc(8 * v37, 0x2004093837F09uLL);
    unint64_t v39 = v38;
    float32x4_t v40 = *(uint64_t **)a3;
    uint64_t v41 = *(char **)(a3 + 8);
    if (*(char **)a3 != v41)
    {
      unint64_t v42 = v41 - (char *)v40 - 8;
      if (v42 < 0x18)
      {
        uint64_t v43 = v38;
        do
        {
LABEL_47:
          uint64_t v50 = *v40++;
          *(void *)uint64_t v43 = v50;
          v43 += 8;
        }
        while (v40 != (uint64_t *)v41);
        goto LABEL_48;
      }
      uint64_t v43 = v38;
      if ((unint64_t)(v38 - (char *)v40) < 0x20) {
        goto LABEL_47;
      }
      uint64_t v44 = (v42 >> 3) + 1;
      uint64_t v45 = 8 * (v44 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v43 = &v38[v45];
      uint64_t v46 = (long long *)(v40 + 2);
      unsigned int v47 = v38 + 16;
      uint64_t v48 = v44 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v49 = *v46;
        *(v47 - 1) = *(v46 - 1);
        *unsigned int v47 = v49;
        v46 += 2;
        v47 += 2;
        v48 -= 4;
      }
      while (v48);
      if (v44 != (v44 & 0x3FFFFFFFFFFFFFFCLL))
      {
        float32x4_t v40 = (uint64_t *)((char *)v40 + v45);
        goto LABEL_47;
      }
    }
LABEL_48:
    if (v32 != v35) {
      free(*(void **)a3);
    }
    uint64_t v30 = (uint64_t *)&v39[8 * v33];
    *(void *)a3 = v39;
    *(void *)(a3 + 8) = v30;
    *(void *)(a3 + 24) = v37;
    unint64_t v4 = v51;
    goto LABEL_26;
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLink::updateLineStyles(int,md::TransitLineMergeDisable,BOOL &)::$_0 &,md::TransitLineSegment **>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      uint64_t v3 = *(a2 - 1);
      uint64_t v4 = *a1;
      if (*(_DWORD *)(v3 + 40) < *(_DWORD *)(*a1 + 40))
      {
        *a1 = v3;
        *(a2 - 1) = v4;
      }
      return 1;
    case 3:
      uint64_t v14 = *a1;
      uint64_t v15 = a1[1];
      unsigned int v16 = *(_DWORD *)(v15 + 40);
      unsigned int v17 = *(_DWORD *)(*a1 + 40);
      uint64_t v18 = *(a2 - 1);
      unsigned int v19 = *(_DWORD *)(v18 + 40);
      if (v16 >= v17)
      {
        if (v19 < v16)
        {
          a1[1] = v18;
          *(a2 - 1) = v15;
          uint64_t v41 = *a1;
          uint64_t v40 = a1[1];
          if (*(_DWORD *)(v40 + 40) < *(_DWORD *)(*a1 + 40))
          {
            *a1 = v40;
            a1[1] = v41;
          }
        }
      }
      else
      {
        if (v19 >= v16)
        {
          *a1 = v15;
          a1[1] = v14;
          uint64_t v47 = *(a2 - 1);
          if (*(_DWORD *)(v47 + 40) >= v17) {
            return 1;
          }
          a1[1] = v47;
        }
        else
        {
          *a1 = v18;
        }
        *(a2 - 1) = v14;
      }
      return 1;
    case 4:
      unsigned int v20 = a1 + 1;
      uint64_t v21 = a1[1];
      uint64_t v22 = a1 + 2;
      uint64_t v23 = a1[2];
      uint64_t v24 = *a1;
      unsigned int v25 = *(_DWORD *)(v21 + 40);
      unsigned int v26 = *(_DWORD *)(*a1 + 40);
      unsigned int v27 = *(_DWORD *)(v23 + 40);
      if (v25 < v26)
      {
        float v28 = a1;
        float v29 = a1 + 2;
        uint64_t v30 = *a1;
        if (v27 >= v25)
        {
          *a1 = v21;
          a1[1] = v24;
          float v28 = a1 + 1;
          float v29 = a1 + 2;
          uint64_t v30 = v24;
          if (v27 >= v26) {
            goto LABEL_35;
          }
        }
LABEL_34:
        *float v28 = v23;
        *float v29 = v24;
        uint64_t v21 = v30;
        goto LABEL_36;
      }
      if (v27 < v25)
      {
        *unsigned int v20 = v23;
        *uint64_t v22 = v21;
        float v28 = a1;
        float v29 = a1 + 1;
        uint64_t v30 = v21;
        if (v27 >= v26) {
          goto LABEL_36;
        }
        goto LABEL_34;
      }
LABEL_35:
      uint64_t v21 = v23;
LABEL_36:
      uint64_t v42 = *(a2 - 1);
      if (*(_DWORD *)(v42 + 40) < *(_DWORD *)(v21 + 40))
      {
        *uint64_t v22 = v42;
        *(a2 - 1) = v21;
        uint64_t v43 = *v22;
        uint64_t v44 = *v20;
        unsigned int v45 = *(_DWORD *)(v43 + 40);
        if (v45 < *(_DWORD *)(v44 + 40))
        {
          a1[1] = v43;
          a1[2] = v44;
          uint64_t v46 = *a1;
          if (v45 < *(_DWORD *)(*a1 + 40))
          {
            *a1 = v43;
            a1[1] = v46;
          }
        }
      }
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,altitude::ObjectTreeLoader::cleanupModels(void)::OldestFirst &,altitude::ObjectTreeModel::LodLevel **,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v6 = a1 + 2;
      uint64_t v5 = a1[2];
      uint64_t v7 = a1[1];
      uint64_t v8 = *a1;
      unsigned int v9 = *(_DWORD *)(v7 + 40);
      unsigned int v10 = *(_DWORD *)(*a1 + 40);
      unsigned int v11 = *(_DWORD *)(v5 + 40);
      if (v9 >= v10)
      {
        if (v11 >= v9) {
          goto LABEL_19;
        }
        a1[1] = v5;
        uint64_t *v6 = v7;
        uint64_t v12 = a1;
        unint64_t v13 = a1 + 1;
      }
      else
      {
        uint64_t v12 = a1;
        unint64_t v13 = a1 + 2;
        if (v11 < v9) {
          goto LABEL_18;
        }
        *a1 = v7;
        a1[1] = v8;
        uint64_t v12 = a1 + 1;
        unint64_t v13 = a1 + 2;
      }
      if (v11 >= v10) {
        goto LABEL_19;
      }
LABEL_18:
      *uint64_t v12 = v5;
      *unint64_t v13 = v8;
LABEL_19:
      uint64_t v31 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v32 = 0;
      for (uint64_t i = 24; ; i += 8)
      {
        uint64_t v35 = *v31;
        uint64_t v36 = *v6;
        unsigned int v37 = *(_DWORD *)(*v31 + 40);
        if (v37 < *(_DWORD *)(v36 + 40))
        {
          uint64_t v38 = i;
          do
          {
            *(uint64_t *)((char *)a1 + v38) = v36;
            uint64_t v39 = v38 - 8;
            if (v38 == 8)
            {
              unint64_t v34 = a1;
              goto LABEL_22;
            }
            uint64_t v36 = *(uint64_t *)((char *)a1 + v38 - 16);
            v38 -= 8;
          }
          while (v37 < *(_DWORD *)(v36 + 40));
          unint64_t v34 = (uint64_t *)((char *)a1 + v39);
LABEL_22:
          *unint64_t v34 = v35;
          if (++v32 == 8) {
            break;
          }
        }
        uint64_t v6 = v31++;
        if (v31 == a2) {
          return 1;
        }
      }
      return v31 + 1 == a2;
  }
}

uint64_t md::TransitLink::isSuperset(md::TransitLink *this, const md::TransitLink *a2, const md::TransitLink *a3)
{
  if (*((void *)this + 14) - *((void *)this + 13) < (unint64_t)(a3 - a2)) {
    return 0;
  }
  if (a2 != a3)
  {
    unint64_t v4 = *((void *)this + 23);
    if (v4)
    {
      unint64_t v5 = v4 - 1;
      uint64_t v6 = *((void *)this + 22);
      uint64_t result = 1;
      if ((v4 & (v4 - 1)) != 0)
      {
LABEL_17:
        unint64_t v11 = *(void *)(*(void *)(**(void **)a2 + 16) + 40);
        unint64_t v12 = v11;
        if (v4 <= v11) {
          unint64_t v12 = v11 % v4;
        }
        unint64_t v13 = *(void **)(v6 + 8 * v12);
        if (v13)
        {
          while (1)
          {
            unint64_t v13 = (void *)*v13;
            if (!v13) {
              break;
            }
            unint64_t v14 = v13[1];
            if (v14 == v11)
            {
              if (v13[2] == v11)
              {
                uint64_t v15 = v13[3];
                if (!v15 || *(unsigned char *)(v15 + 55)) {
                  return 0;
                }
                a2 = (const md::TransitLink *)((char *)a2 + 8);
                if (a2 != a3) {
                  goto LABEL_17;
                }
                return result;
              }
            }
            else
            {
              if (v14 >= v4) {
                v14 %= v4;
              }
              if (v14 != v12) {
                return 0;
              }
            }
          }
        }
      }
      else
      {
LABEL_6:
        uint64_t v7 = *(void *)(*(void *)(**(void **)a2 + 16) + 40);
        uint64_t v8 = *(void **)(v6 + 8 * (v5 & v7));
        if (v8)
        {
          while (1)
          {
            uint64_t v8 = (void *)*v8;
            if (!v8) {
              break;
            }
            uint64_t v9 = v8[1];
            if (v9 == v7)
            {
              if (v8[2] == v7)
              {
                uint64_t v10 = v8[3];
                if (!v10 || *(unsigned char *)(v10 + 55)) {
                  return 0;
                }
                a2 = (const md::TransitLink *)((char *)a2 + 8);
                if (a2 != a3) {
                  goto LABEL_6;
                }
                return result;
              }
            }
            else if ((v9 & v5) != (v5 & v7))
            {
              return 0;
            }
          }
        }
      }
    }
    return 0;
  }
  return 1;
}

float md::TransitLink::populateEndPoints(uint64_t a1, int a2, unint64_t *a3)
{
  int v3 = *(_DWORD *)(a1 + 20);
  if (v3)
  {
    uint64_t v6 = v3 - 1;
    if (a2) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = v6;
    }
    unint64_t v15 = 0;
    unint64_t v8 = geo::codec::transitLinkPoints(a1, v7, &v15);
    if (v15 >= 5) {
      size_t v9 = 5;
    }
    else {
      size_t v9 = v15;
    }
    if (a2)
    {
      std::vector<gm::Matrix<float,2,1>>::__assign_with_size[abi:nn180100]<gm::Matrix<float,2,1> const*,gm::Matrix<float,2,1> const*>((uint64_t)a3, v8, (char *)(v8 + 8 * v9), v9);
    }
    else
    {
      std::vector<gm::Matrix<float,2,1>>::__assign_with_size[abi:nn180100]<gm::Matrix<float,2,1> const*,gm::Matrix<float,2,1> const*>((uint64_t)a3, v8 + 8 * v15 - 8 * v9, (char *)(v8 + 8 * v15), (uint64_t)(8 * v9) >> 3);
      unint64_t v11 = *a3;
      unint64_t v12 = a3[1];
      if (*a3 != v12)
      {
        for (uint64_t i = (_DWORD *)(v12 - 8); v11 < (unint64_t)i; v11 += 8)
        {
          float result = *(float *)v11;
          int v14 = *(_DWORD *)(v11 + 4);
          *(_DWORD *)unint64_t v11 = *i;
          *(_DWORD *)(v11 + 4) = i[1];
          *(float *)uint64_t i = result;
          i[1] = v14;
          i -= 2;
        }
      }
    }
  }
  return result;
}

_DWORD *std::vector<gm::Matrix<float,2,1>>::__assign_with_size[abi:nn180100]<gm::Matrix<float,2,1> const*,gm::Matrix<float,2,1> const*>(uint64_t a1, unint64_t a2, char *a3, size_t __sz)
{
  uint64_t v6 = (char *)a2;
  uint64_t v8 = *(void *)(a1 + 16);
  float result = *(_DWORD **)a1;
  if (__sz <= (v8 - (uint64_t)result) >> 3)
  {
    uint64_t v18 = *(_DWORD **)(a1 + 8);
    unsigned int v17 = (void *)(a1 + 8);
    int v14 = v18;
    int64_t v19 = (char *)v18 - (char *)result;
    unint64_t v20 = ((char *)v18 - (char *)result) >> 3;
    if (v20 < __sz)
    {
      uint64_t v21 = (uint64_t *)(a2 + 8 * v20);
      if (v14 == result) {
        goto LABEL_30;
      }
      if ((unint64_t)(v19 - 8) >= 0x58)
      {
        BOOL v25 = (unint64_t)result < a2 + (v19 & 0xFFFFFFFFFFFFFFF8)
           && (unint64_t)result + (v19 & 0xFFFFFFFFFFFFFFF8) > a2;
        uint64_t v22 = (uint64_t *)a2;
        if (!v25)
        {
          unint64_t v26 = ((unint64_t)(v19 - 8) >> 3) + 1;
          uint64_t v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFF8);
          float v28 = (long long *)(a2 + 32);
          float v29 = result + 8;
          uint64_t v30 = v26 & 0x3FFFFFFFFFFFFFF8;
          do
          {
            long long v32 = *(v28 - 2);
            long long v31 = *(v28 - 1);
            long long v34 = *v28;
            long long v33 = v28[1];
            v28 += 4;
            *(v29 - 2) = v32;
            *(v29 - 1) = v31;
            *float v29 = v34;
            v29[1] = v33;
            v29 += 4;
            v30 -= 8;
          }
          while (v30);
          if (v26 == (v26 & 0x3FFFFFFFFFFFFFF8))
          {
LABEL_30:
            if (v21 == (uint64_t *)a3)
            {
              int64_t v16 = 0;
              goto LABEL_50;
            }
            unint64_t v35 = v19 + a2;
            unint64_t v36 = (unint64_t)&a3[-v35 - 8];
            if (v36 < 0x38)
            {
              uint64_t v38 = (char *)v14;
            }
            else
            {
              unint64_t v37 = (unint64_t)v14 - v35;
              uint64_t v38 = (char *)v14;
              if (v37 >= 0x20)
              {
                uint64_t v39 = (v36 >> 3) + 1;
                uint64_t v40 = 2 * (v39 & 0x3FFFFFFFFFFFFFFCLL);
                uint64_t v21 = (uint64_t *)((char *)v21 + v40 * 4);
                uint64_t v41 = v14 + 4;
                uint64_t v42 = (long long *)(a2 + 8 * v20 + 16);
                uint64_t v43 = v39 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v44 = *v42;
                  *(v41 - 1) = *(v42 - 1);
                  *uint64_t v41 = v44;
                  v41 += 2;
                  v42 += 2;
                  v43 -= 4;
                }
                while (v43);
                uint64_t v38 = (char *)&v14[v40];
                if (v39 == (v39 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_43;
                }
              }
            }
            do
            {
              uint64_t v46 = *v21++;
              *(void *)uint64_t v38 = v46;
              v38 += 8;
            }
            while (v21 != (uint64_t *)a3);
LABEL_43:
            int64_t v16 = v38 - (char *)v14;
            goto LABEL_50;
          }
          uint64_t v22 = (uint64_t *)(a2 + v27);
          float result = (_DWORD *)((char *)result + v27);
        }
      }
      else
      {
        uint64_t v22 = (uint64_t *)a2;
      }
      do
      {
        *float result = *(_DWORD *)v22;
        result[1] = *((_DWORD *)v22++ + 1);
        result += 2;
      }
      while (v22 != v21);
      goto LABEL_30;
    }
    if ((char *)a2 == a3)
    {
      uint64_t v24 = (char *)result;
    }
    else
    {
      unint64_t v23 = (unint64_t)&a3[-a2 - 8];
      if (v23 >= 0x58)
      {
        unint64_t v45 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((unint64_t)result >= a2 + v45 || (unint64_t)result + v45 <= a2)
        {
          uint64_t v47 = (v23 >> 3) + 1;
          uint64_t v48 = 2 * (v47 & 0x3FFFFFFFFFFFFFF8);
          uint64_t v24 = (char *)&result[v48];
          long long v49 = (long long *)(a2 + 32);
          uint64_t v50 = result + 8;
          uint64_t v51 = v47 & 0x3FFFFFFFFFFFFFF8;
          do
          {
            long long v53 = *(v49 - 2);
            long long v52 = *(v49 - 1);
            long long v55 = *v49;
            long long v54 = v49[1];
            v49 += 4;
            *(v50 - 2) = v53;
            *(v50 - 1) = v52;
            *uint64_t v50 = v55;
            v50[1] = v54;
            v50 += 4;
            v51 -= 8;
          }
          while (v51);
          if (v47 == (v47 & 0x3FFFFFFFFFFFFFF8)) {
            goto LABEL_49;
          }
          uint64_t v6 = (char *)(a2 + v48 * 4);
        }
        else
        {
          uint64_t v24 = (char *)result;
        }
      }
      else
      {
        uint64_t v24 = (char *)result;
      }
      do
      {
        *(_DWORD *)uint64_t v24 = *(_DWORD *)v6;
        *((_DWORD *)v24 + 1) = *((_DWORD *)v6 + 1);
        v24 += 8;
        v6 += 8;
      }
      while (v6 != a3);
    }
LABEL_49:
    int64_t v16 = v24 - (char *)result;
    int v14 = result;
    goto LABEL_50;
  }
  if (result)
  {
    *(void *)(a1 + 8) = result;
    operator delete(result);
    uint64_t v8 = 0;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  if (__sz >> 61) {
    goto LABEL_51;
  }
  uint64_t v10 = v8 >> 2;
  if (v8 >> 2 <= __sz) {
    uint64_t v10 = __sz;
  }
  BOOL v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8;
  unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
  if (!v11) {
    unint64_t v12 = v10;
  }
  if (v12 >> 61) {
LABEL_51:
  }
    abort();
  uint64_t v13 = 2 * v12;
  float result = operator new(8 * v12);
  int v14 = result;
  *(void *)a1 = result;
  *(void *)(a1 + 8) = result;
  *(void *)(a1 + 16) = &result[v13];
  unint64_t v15 = (char *)result;
  if (v6 != a3)
  {
    float result = memcpy(result, v6, ((a3 - v6 - 8) & 0xFFFFFFFFFFFFFFF8) + 8);
    unint64_t v15 = (char *)v14 + ((a3 - v6 - 8) & 0xFFFFFFFFFFFFFFF8) + 8;
  }
  int64_t v16 = v15 - (char *)v14;
  unsigned int v17 = (void *)(a1 + 8);
LABEL_50:
  *unsigned int v17 = (char *)v14 + v16;
  return result;
}

id md::TransitLink::Section::debugString(md::TransitLink::Section *this)
{
  uint64_t v2 = [MEMORY[0x1E4F28E78] string];
  [v2 appendFormat:@"validPoint=%i validTangent=%i offset=%.2f offsetOutside = %.2f length=%.2f\n", *((unsigned __int8 *)this + 92), *((unsigned __int8 *)this + 93), *((float *)this + 20), *((float *)this + 21), *((float *)this + 22)];
  double v3 = *((float *)this + 4);
  double v4 = *((float *)this + 5);
  float v5 = atan2f(*((float *)this + 1), *(float *)this) * 57.2957795;
  float v6 = atan2f(*((float *)this + 3), *((float *)this + 2)) * 57.2957795;
  [v2 appendFormat:@"    pt=(%f,%f) tngt,nrml=(%.2f,%.2f) jctn=%p type=%i sr=%i\n", *(void *)&v3, *(void *)&v4, v5, v6, *((void *)this + 3), *((unsigned __int8 *)this + 32), *((unsigned __int8 *)this + 34)];
  double v7 = *((float *)this + 14);
  double v8 = *((float *)this + 15);
  float v9 = atan2f(*((float *)this + 11), *((float *)this + 10)) * 57.2957795;
  float v10 = atan2f(*((float *)this + 13), *((float *)this + 12)) * 57.2957795;
  [v2 appendFormat:@"    pt=(%f,%f) tngt,nrml=(%.2f,%.2f) jctn=%p type=%i sr=%i\n", *(void *)&v7, *(void *)&v8, v9, v10, *((void *)this + 8), *((unsigned __int8 *)this + 72), *((unsigned __int8 *)this + 74)];
  return v2;
}

void sub_1A259D8B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id md::TransitLink::debugStringForJunction(md::TransitLink *this, int8x8_t *a2, char a3, int a4)
{
  double v8 = [MEMORY[0x1E4F28E78] string];
  float v9 = v8;
  if (a4) {
    int v10 = 200;
  }
  else {
    int v10 = 10;
  }
  [v8 appendFormat:@"MergedLines:\n"];
  BOOL v11 = (unint64_t *)*((void *)this + 13);
  unint64_t v12 = (unint64_t *)*((void *)this + 14);
  if (v11 != v12)
  {
    uint64_t v13 = 0;
    if (a3)
    {
      while (v10 != v13)
      {
        int v14 = (md::TransitLine **)*v11;
        uint64_t v15 = *(unsigned int *)(*v11 + 48);
        int64_t v16 = (float *)md::TransitJunction::normalForLineSegment(a2, *v11);
        if (v16) {
          float v17 = atan2f(v16[1], *v16) * 57.2957795;
        }
        else {
          float v17 = 999.0;
        }
        uint64_t v18 = [NSString stringWithFormat:@"uid:%llu, %s, %s", *(void *)(*((void *)*v14 + 2) + 40), md::TransitLine::debugSystemName(*v14), *(void *)(*((void *)*v14 + 2) + 16)];
        [v9 appendFormat:@" %i:%@, slot:%d normal:%.02f\n", v13, v18, v15, v17];

        uint64_t v13 = (v13 + 1);
        if (++v11 == v12) {
          goto LABEL_19;
        }
      }
    }
    else
    {
      while (v10 != v13)
      {
        int64_t v19 = (md::TransitLine **)*v11;
        uint64_t v20 = *(unsigned int *)(*v11 + 44);
        uint64_t v21 = (float *)md::TransitJunction::normalForLineSegment(a2, *v11);
        if (v21) {
          float v22 = atan2f(v21[1], *v21) * 57.2957795;
        }
        else {
          float v22 = 999.0;
        }
        unint64_t v23 = [NSString stringWithFormat:@"uid:%llu, %s, %s", *(void *)(*((void *)*v19 + 2) + 40), md::TransitLine::debugSystemName(*v19), *(void *)(*((void *)*v19 + 2) + 16)];
        [v9 appendFormat:@" %i:%@, slot:%d normal:%.02f\n", v13, v23, v20, v22];

        uint64_t v13 = (v13 + 1);
        if (++v11 == v12) {
          goto LABEL_19;
        }
      }
    }
    [v9 appendString:@" Lines Truncated...\n"];
  }
LABEL_19:
  return v9;
}

void sub_1A259DB18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::TransitLink::debugDrawWithSelectedJunction(md::TransitLink *this, const md::TransitJunction *a2, int a3, float32x2_t *a4, const md::HighlightHelper *a5)
{
  uint64_t result = *(void *)this;
  if (*(_DWORD *)(result + 20))
  {
    unint64_t v10 = 0;
    if (a3) {
      char v11 = 2;
    }
    else {
      char v11 = 4;
    }
    char v21 = v11;
    if (a3) {
      char v12 = 1;
    }
    else {
      char v12 = 3;
    }
    do
    {
      unint64_t v25 = 0;
      uint64_t v15 = geo::codec::transitLinkPoints(result, v10, &v25);
      if (v25 < 2) {
        goto LABEL_11;
      }
      float v22 = 0;
      unint64_t v23 = 0;
      uint64_t v24 = 0;
      memset(__p, 0, sizeof(__p));
      md::HighlightHelper::tileToMercatorPoints(*(void *)a5, v15, v25, (uint64_t)__p);
      md::HighlightHelper::mercatorToScreenPoints((uint64_t)a5, (double **)__p, (uint64_t)&v22);
      if (__p[0]) {
        operator delete(__p[0]);
      }
      int64_t v16 = v22;
      float v17 = v23;
      if (v22)
      {
        if (v23 != v22)
        {
          a4[1].i32[0] = *v22;
          a4[1].i32[1] = v16[1];
          if ((unint64_t)((char *)v17 - (char *)v16) >= 9)
          {
            uint64_t v18 = (((char *)v17 - (char *)v16) >> 3) - 1;
            int64_t v19 = (float *)(v16 + 2);
            do
            {
              ggl::DebugConsole::drawLine((uint64_t)a4, v19);
              v19 += 2;
              --v18;
            }
            while (v18);
          }
        }
      }
      float32x2_t v20 = *(float32x2_t *)v16;
      __p[0] = *((void **)v17 - 1);
      a4[1] = v20;
      ggl::DebugConsole::drawLine((uint64_t)a4, (float *)__p);
      if (*(const md::TransitJunction **)(*((void *)this + 8) - 32) == a2)
      {
        uint64_t v13 = v16 + 1;
        a4[1].i32[0] = *v16;
        char v14 = v12;
      }
      else
      {
        if (*(const md::TransitJunction **)(*((void *)this + 7) + 24) != a2) {
          goto LABEL_10;
        }
        a4[1].i32[0] = *(v17 - 2);
        uint64_t v13 = v17 - 1;
        char v14 = v21;
      }
      a4[1].i32[1] = *v13;
      ggl::DebugConsole::drawSymbol(a4, v14);
LABEL_10:
      operator delete(v16);
LABEL_11:
      ++v10;
      uint64_t result = *(void *)this;
    }
    while (v10 < *(unsigned int *)(*(void *)this + 20));
  }
  return result;
}

void sub_1A259DCFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p)
  {
    operator delete(__p);
    uint64_t v15 = a10;
    if (!a10) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    uint64_t v15 = a10;
    if (!a10) {
      goto LABEL_3;
    }
  }
  operator delete(v15);
  _Unwind_Resume(exception_object);
}

void md::BuildingLayerDataSource::resourceKeyForType(uint64_t a1@<X0>, char a2@<W1>, unsigned __int8 *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  __int16 v8 = *(_WORD *)(a1 + 584);
  if (*(unsigned char *)a5) {
    int v9 = *(_DWORD *)(a5 + 4);
  }
  else {
    int v9 = 2147483646;
  }
  uint64_t v10 = *(void *)(a3 + 4);
  int v18 = v10;
  int v11 = a3[1];
  int v12 = *a3;
  *(unsigned char *)a6 = a2;
  *(_WORD *)(a6 + 2) = v8;
  *(_DWORD *)(a6 + 4) = v9;
  *(void *)(a6 + 8) = a6 + 40;
  *(void *)(a6 + 16) = a6 + 40;
  *(void *)(a6 + 24) = a6 + 40;
  *(void *)(a6 + 32) = 32;
  *(void *)(a6 + 72) = 0;
  int v19 = HIDWORD(v10);
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v18;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v11;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v12;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  uint64_t v13 = *(unsigned __int8 **)(a6 + 16);
  char v14 = *(unsigned __int8 **)(a6 + 8);
  unint64_t v15 = v13 - v14;
  if (v13 == v14)
  {
    unint64_t v16 = 0;
  }
  else
  {
    unint64_t v16 = 0;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    do
    {
      unsigned int v17 = *v14++;
      v16 ^= (v16 << 6) + (v16 >> 2) - 0x61C8864680B583EBLL + v17;
      --v15;
    }
    while (v15);
  }
  *(void *)(a6 + 72) = v16;
  *(void *)(a6 + 88) = a4;
}

void md::BuildingLayerDataSource::createLayerData(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  uint64_t v626 = *MEMORY[0x1E4F143B8];
  unsigned int v563 = *(unsigned __int8 *)(*(void *)(a2 + 16) + 8);
  float v6 = (unsigned __int16 *)*a3;
  float v5 = (unsigned __int16 *)a3[1];
  if ((unsigned __int16 *)*a3 != v5)
  {
    while (*v6 != *(unsigned __int16 *)(a1 + 584))
    {
      v6 += 24;
      if (v6 == v5) {
        goto LABEL_10;
      }
    }
  }
  if (v6 == v5 || *((void *)v6 + 4) != 1)
  {
LABEL_10:
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v7 = *((void *)v6 + 3);
    uint64_t v8 = *(void *)(v7 + 112);
    int v9 = *(std::__shared_weak_count **)(v7 + 120);
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v583 = v8;
      long long v584 = v9;
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
      goto LABEL_12;
    }
  }
  uint64_t v583 = v8;
  long long v584 = 0;
LABEL_12:
  memset(v582, 0, sizeof(v582));
  gdc::LayerDataSource::populateLoadMetadataListFromMap(*a3, a3[1], v582);
  uint64_t v10 = a1;
  float v11 = COERCE_FLOAT(atomic_load((unsigned int *)(a1 + 768)));
  sp_mut = std::__get_sp_mut((const void *)(v10 + 752));
  std::__sp_mut::lock(sp_mut);
  uint64_t v13 = *(std::__shared_weak_count **)(v10 + 760);
  uint64_t v580 = *(void *)(v10 + 752);
  long long v581 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  float v539 = v11;
  std::__sp_mut::unlock(sp_mut);
  v578[0] = 0;
  v578[1] = 0;
  float64x2_t v579 = 0;
  if (!*(unsigned char *)(a1 + 800)) {
    goto LABEL_47;
  }
  if (v11 <= 1.0) {
    float v14 = 1.0;
  }
  else {
    float v14 = 2.0;
  }
  strcpy(&src[23], "\tbtHORIZPINSTRIPE");
  strcpy(src, "btCHECKER");
  src[47] = 16;
  char v618 = 15;
  strcpy((char *)__p, "btVERTPINSTRIPE");
  unint64_t v15 = operator new(0x30uLL);
  v15[1] = 0u;
  v15[2] = 0u;
  _OWORD *v15 = 0u;
  v578[0] = v15;
  v578[1] = v15 + 3;
  float64x2_t v579 = v15 + 3;
  unint64_t v16 = (char *)operator new(0x58uLL);
  uint64_t v17 = 0;
  *((void *)v16 + 1) = 0;
  *((void *)v16 + 2) = 0;
  *(void *)unint64_t v16 = &unk_1EF583858;
  *((void *)v16 + 5) = 0;
  *((void *)v16 + 6) = 0;
  *((_DWORD *)v16 + 14) = 0;
  *((void *)v16 + 3) = &unk_1EF55AE58;
  *((void *)v16 + 4) = 0;
  *(_OWORD *)(v16 + 60) = xmmword_1A28FC760;
  *(void *)(v16 + 76) = 0x100000000;
  *((_DWORD *)v16 + 21) = 0;
  int v18 = src;
  dest.data = v16 + 24;
  dest.height = (vImagePixelCount)v16;
  uint64_t v19 = a1;
  do
  {
    id v20 = *(id *)(v19 + 784);
    char v21 = v20;
    if (v20)
    {
      [v20 textureManager];
      float v22 = *(void **)components;
    }
    else
    {
      float v22 = 0;
      *(void *)components = 0;
      *(void *)&components[8] = 0;
    }
    height = (std::__shared_weak_count *)dest.height;
    v577[0] = (uint64_t)dest.data;
    v577[1] = dest.height;
    if (dest.height) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(dest.height + 8), 1uLL, memory_order_relaxed);
    }
    md::TextureManager::texture(obj, v22, (uint64_t)v18, v577, 0, v14);
    if (height && !atomic_fetch_add(&height->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))height->__on_zero_shared)(height);
      std::__shared_weak_count::__release_weak(height);
      uint64_t v24 = *(std::__shared_weak_count **)&components[8];
      if (!*(void *)&components[8]) {
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v24 = *(std::__shared_weak_count **)&components[8];
      if (!*(void *)&components[8]) {
        goto LABEL_31;
      }
    }
    if (!atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
LABEL_31:

    unint64_t v25 = (atomic_ullong *)obj[0];
    if (obj[0])
    {
      uint64_t v26 = *((void *)obj[0] + 4);
      unint64_t v25 = (atomic_ullong *)*((void *)obj[0] + 5);
      if (v25) {
        atomic_fetch_add_explicit(v25 + 1, 1uLL, memory_order_relaxed);
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    uint64_t v27 = (char *)v578[0] + v17;
    float v28 = *(std::__shared_weak_count **)((char *)v578[0] + v17 + 8);
    *uint64_t v27 = v26;
    v27[1] = v25;
    if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
      float v29 = (std::__shared_weak_count *)obj[1];
      if (!obj[1]) {
        goto LABEL_19;
      }
    }
    else
    {
      float v29 = (std::__shared_weak_count *)obj[1];
      if (!obj[1]) {
        goto LABEL_19;
      }
    }
    if (!atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
LABEL_19:
    v17 += 16;
    v18 += 24;
    uint64_t v19 = a1;
  }
  while (v17 != 48);
  uint64_t v30 = (std::__shared_weak_count *)dest.height;
  if (!dest.height || atomic_fetch_add((atomic_ullong *volatile)(dest.height + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((v618 & 0x80000000) == 0) {
      goto LABEL_45;
    }
LABEL_71:
    operator delete(__p[0]);
    if ((src[47] & 0x80000000) != 0) {
      goto LABEL_72;
    }
LABEL_46:
    if ((src[23] & 0x80000000) == 0) {
      goto LABEL_47;
    }
LABEL_73:
    operator delete(*(void **)src);
    goto LABEL_47;
  }
  ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
  std::__shared_weak_count::__release_weak(v30);
  if (v618 < 0) {
    goto LABEL_71;
  }
LABEL_45:
  if ((src[47] & 0x80000000) == 0) {
    goto LABEL_46;
  }
LABEL_72:
  operator delete(*(void **)&src[24]);
  if ((src[23] & 0x80000000) != 0) {
    goto LABEL_73;
  }
LABEL_47:
  v575[0] = 0;
  v575[1] = 0;
  float v576 = 0;
  uint64_t v520 = v583;
  long long v31 = (geo::codec::VectorTile **)(v583 + 144);
  uint64_t v32 = geo::codec::VectorTile::polygonsCount(*(geo::codec::VectorTile **)(v583 + 144));
  double v536 = v31;
  float v548 = 0.0;
  float v549 = 0.0;
  float v546 = 0.0;
  float v547 = 0.0;
  float v544 = 0.0;
  float v545 = 0.0;
  float v542 = 0.0;
  float v543 = 0.0;
  float v540 = 0.0;
  float v541 = 0.0;
  float v33 = 0.0;
  float v34 = 0.0;
  float v35 = 0.0;
  float v36 = 0.0;
  float v37 = 0.0;
  float v38 = 0.0;
  if (!(v32 + geo::codec::VectorTile::totalBuildingFootprintsCount(*v31))) {
    goto LABEL_216;
  }
  *(void *)&src[8] = 0;
  *(void *)src = &src[8];
  *(_OWORD *)&src[24] = xmmword_1A28FE9A0;
  uint64_t v619 = 0;
  *(void *)&src[16] = 0;
  *(void *)&src[40] = 0;
  __p[1] = 0;
  __p[0] = 0;
  int v617 = 0;
  int v620 = 4;
  uint64_t v623 = 0;
  v621 = 0;
  v622 = 0;
  id v550 = *(id *)(a1 + 784);
  uint64_t v533 = [v550 gglDevice];
  LODWORD(color[0]) = *(unsigned __int8 *)(a1 + 800);
  unint64_t v39 = geo::codec::VectorTile::totalBuildingFootprintsCount(*v31);
  unint64_t v40 = v39;
  if (!v39)
  {
    float v548 = 0.0;
    float v549 = 0.0;
    float v546 = 0.0;
    float v547 = 0.0;
    float v544 = 0.0;
    float v545 = 0.0;
    float v542 = 0.0;
    float v543 = 0.0;
    float v540 = 0.0;
    float v541 = 0.0;
    uint64_t v50 = v550;
    goto LABEL_213;
  }
  uint64_t v41 = (void **)v575[1];
  int64_t v42 = (char *)v575[1] - (char *)v575[0];
  unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * (((char *)v575[1] - (char *)v575[0]) >> 3);
  unint64_t v557 = v39;
  if (v43 > 2)
  {
    if (v42 != 72)
    {
      uint64_t v51 = (void **)((char *)v575[0] + 72);
      if (v575[1] != (char *)v575[0] + 72)
      {
        long long v52 = (void **)v575[1];
        do
        {
          long long v54 = (char *)*(v52 - 3);
          v52 -= 3;
          long long v53 = v54;
          if (v54)
          {
            long long v55 = (char *)*(v41 - 2);
            uint64_t v56 = v53;
            if (v55 != v53)
            {
              uint64_t v57 = v55 - 24;
              unsigned int v58 = v55 - 24;
              unint64_t v59 = v55 - 24;
              do
              {
                int v60 = *(void (***)(char *))v59;
                v59 -= 24;
                (*v60)(v58);
                v57 -= 24;
                _ZF = v58 == v53;
                unsigned int v58 = v59;
              }
              while (!_ZF);
              uint64_t v56 = *v52;
              unint64_t v40 = v557;
            }
            *(v41 - 2) = v53;
            operator delete(v56);
          }
          uint64_t v41 = v52;
        }
        while (v52 != v51);
      }
      v575[1] = v51;
    }
  }
  else if (0xAAAAAAAAAAAAAAABLL * ((v576 - (char *)v575[1]) >> 3) >= 3 - v43)
  {
    bzero(v575[1], 24 * ((48 - v42) / 0x18uLL) + 24);
    v575[1] = (char *)v575[1] + 24 * ((48 - v42) / 0x18uLL) + 24;
  }
  else
  {
    unint64_t v44 = 0x5555555555555556 * ((v576 - (char *)v575[0]) >> 3);
    if (v44 <= 3) {
      unint64_t v44 = 3;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((v576 - (char *)v575[0]) >> 3) >= 0x555555555555555) {
      unint64_t v45 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v45 = v44;
    }
    if (v45 > 0xAAAAAAAAAAAAAAALL) {
LABEL_665:
    }
      std::__throw_bad_array_new_length[abi:nn180100]();
    uint64_t v46 = (char *)operator new(24 * v45);
    uint64_t v47 = &v46[8 * (((char *)v575[1] - (char *)v575[0]) >> 3)];
    uint64_t v48 = &v46[24 * v45];
    size_t v49 = 24 * ((48 - v42) / 0x18uLL) + 24;
    bzero(v47, v49);
    v575[0] = v47;
    v575[1] = &v47[v49];
    float v576 = v48;
  }
  std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::reserve((void **)v575[0]);
  std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::reserve((void **)v575[0] + 3);
  std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::reserve((void **)v575[0] + 6);
  __powidf2();
  dest.data = 0;
  dest.height = (vImagePixelCount)&dest;
  dest.vImagePixelCount width = 0x4812000000;
  dest.size_t rowBytes = (size_t)__Block_byref_object_copy__38271;
  v594 = __Block_byref_object_dispose__38272;
  v595 = "";
  v598 = 0;
  v596 = 0;
  v597 = 0;
  if (v40 >> 60) {
    abort();
  }
  unint64_t v63 = 0;
  float v64 = v62 * 0.0250000004;
  v596 = operator new(16 * v40);
  v597 = v596;
  v598 = (char *)v596 + 16 * v40;
  if (v40 <= 1) {
    uint64_t v65 = 1;
  }
  else {
    uint64_t v65 = v40;
  }
  do
  {
    uint64_t v67 = geo::codec::buildingFootprintFeatureAtIndex((uint64_t)v536, v63);
    uint64_t v68 = v67;
    if (*(_DWORD *)(v67 + 100))
    {
      obj[0] = 0;
      uint64_t v69 = (float *)geo::codec::multiSectionFeaturePoints((void *)v67, 0, obj);
      unsigned __int8 v70 = ggl::CullingGrid::intersectedCellsForRibbon((unint64_t)obj[0], v69, 1);
      BOOL v71 = (void *)dest.height;
      char v72 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v70 & 0xF] | (16
                                                                                            * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v70 >> 4]);
      long long v74 = *(char **)(dest.height + 56);
      unint64_t v73 = *(void *)(dest.height + 64);
      if ((unint64_t)v74 < v73)
      {
        *(void *)long long v74 = v68;
        v74[8] = v72;
        uint64_t v66 = v74 + 16;
      }
      else
      {
        uint64_t v75 = *(unsigned char **)(dest.height + 48);
        uint64_t v76 = (v74 - v75) >> 4;
        unint64_t v77 = v76 + 1;
        if ((unint64_t)(v76 + 1) >> 60) {
          abort();
        }
        uint64_t v78 = v73 - (void)v75;
        if (v78 >> 3 > v77) {
          unint64_t v77 = v78 >> 3;
        }
        if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v79 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v79 = v77;
        }
        if (v79 >> 60) {
          goto LABEL_665;
        }
        uint64_t v80 = (char *)operator new(16 * v79);
        uint64_t v81 = &v80[16 * v76];
        *(void *)uint64_t v81 = v68;
        v81[8] = v72;
        if (v74 == v75)
        {
          uint64_t v83 = &v80[16 * v76];
        }
        else
        {
          uint64_t v82 = &v80[16 * v76];
          do
          {
            uint64_t v83 = v82 - 16;
            *((_OWORD *)v82 - 1) = *((_OWORD *)v74 - 1);
            v74 -= 16;
            v82 -= 16;
          }
          while (v74 != v75);
        }
        uint64_t v66 = v81 + 16;
        v71[6] = v83;
        v71[7] = v81 + 16;
        v71[8] = &v80[16 * v79];
        if (v75) {
          operator delete(v75);
        }
      }
      v71[7] = v66;
    }
    ++v63;
  }
  while (v63 != v65);
  unsigned int v84 = *(uint64_t **)(dest.height + 48);
  unint64_t v85 = *(void *)(dest.height + 56);
  unint64_t v86 = 126 - 2 * __clz((uint64_t)(v85 - (void)v84) >> 4);
  if ((uint64_t *)v85 == v84) {
    uint64_t v87 = 0;
  }
  else {
    uint64_t v87 = v86;
  }
  std::__introsort<std::_ClassicAlgPolicy,_buildMeshes(std::vector<std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>> &,ggl::CullingGridWithHeight &,md::Triangulator<float> &,ggl::Device *,BOOL,std::shared_ptr<md::GEOVectorTileResource> const&,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&,float,geo::QuadTile const&)::$_0 &,std::pair<GeoCodecsBuildingFootprintFeature *,unsigned char> *,false>(v84, v85, v87, 1);
  uint64_t v89 = *(uint64_t **)(dest.height + 48);
  uint64_t v88 = *(uint64_t **)(dest.height + 56);
  if (v89 != v88)
  {
    unint64_t v572 = 0;
    float v531 = (float)v563;
    HIDWORD(v90) = 0;
    float v548 = 0.0;
    float v549 = 0.0;
    float v546 = 0.0;
    float v547 = 0.0;
    float v544 = 0.0;
    float v545 = 0.0;
    float v542 = 0.0;
    float v543 = 0.0;
    float v540 = 0.0;
    float v541 = 0.0;
    float v33 = 0.0;
    float v34 = 0.0;
    float v35 = 0.0;
    float v36 = 0.0;
    float v37 = 0.0;
    float v38 = 0.0;
    char v560 = *(uint64_t **)(dest.height + 56);
    while (2)
    {
      uint64_t v91 = *v89;
      if (*(unsigned char *)(*v89 + 128)) {
        goto LABEL_105;
      }
      if (!*(_DWORD *)(v91 + 100)) {
        goto LABEL_104;
      }
      uint64_t v564 = (void ***)((char *)v575[0] + 24 * (v572 % 3));
      uint64_t v92 = *v564;
      unsigned int v93 = v564 + 1;
      unsigned int v94 = v564[1];
      if (*v564 == v94)
      {
LABEL_111:
        unint64_t v97 = 0;
      }
      else
      {
        while (1)
        {
          id v95 = v92[1];
          int v96 = [v95 canAcceptPolygon:v91];

          if (v96) {
            break;
          }
          v92 += 3;
          if (v92 == v94) {
            goto LABEL_111;
          }
        }
        unint64_t v97 = v92[1];
      }
      int v98 = (uint64_t *)(v91 + 24);
      if (!LODWORD(color[0]))
      {
        BOOL v100 = 0;
        goto LABEL_120;
      }
      uint64_t v99 = *(unsigned __int8 *)(*v98 + 33);
      if (*(unsigned char *)(*v98 + 33))
      {
        BOOL v100 = 0;
        uint64_t v101 = (_DWORD *)(*(void *)*v98 + 4);
        do
        {
          if (*(v101 - 1) == 19) {
            BOOL v100 = *v101 == 0;
          }
          v101 += 2;
          --v99;
        }
        while (v99);
LABEL_120:
        if (v97)
        {
LABEL_121:
          if (!*(_DWORD *)(v91 + 100)) {
            goto LABEL_192;
          }
LABEL_153:
          unint64_t v135 = 0;
          do
          {
            obj[0] = 0;
            uint64_t v136 = (float *)geo::codec::multiSectionFeaturePoints((void *)v91, v135, obj);
            float v137 = geo::codec::buildingFootprintExtrusionHeight(v91, v135);
            __int16 v138 = ggl::CullingGrid::intersectedCellsForRibbon((unint64_t)obj[0], v136, 1);
            *(float *)&double v90 = fmaxf(v549, v137);
            if (v138) {
              float v139 = *(float *)&v90;
            }
            else {
              float v139 = v549;
            }
            float v140 = fmaxf(v545, v137);
            if ((v138 & 8) != 0) {
              float v141 = v140;
            }
            else {
              float v141 = v545;
            }
            float v142 = fmaxf(v541, v137);
            if ((v138 & 0x1000) != 0) {
              float v143 = v142;
            }
            else {
              float v143 = v541;
            }
            float v144 = fmaxf(v35, v137);
            if (v138 < 0) {
              float v35 = v144;
            }
            float v145 = v548;
            float v146 = fmaxf(v548, v137);
            if ((v138 & 2) != 0) {
              float v145 = v146;
            }
            float v548 = v145;
            float v549 = v139;
            float v147 = v544;
            float v148 = fmaxf(v544, v137);
            if ((v138 & 4) != 0) {
              float v147 = v148;
            }
            float v544 = v147;
            float v545 = v141;
            float v149 = v540;
            float v150 = fmaxf(v540, v137);
            if ((v138 & 0x2000) != 0) {
              float v149 = v150;
            }
            float v540 = v149;
            float v541 = v143;
            float v151 = fmaxf(v36, v137);
            if ((v138 & 0x4000) != 0) {
              float v36 = v151;
            }
            float v152 = fmaxf(v547, v137);
            if ((v138 & 0x10) != 0) {
              float v153 = v152;
            }
            else {
              float v153 = v547;
            }
            float v154 = fmaxf(v543, v137);
            if ((v138 & 0x80) != 0) {
              float v155 = v154;
            }
            else {
              float v155 = v543;
            }
            float v156 = fmaxf(v33, v137);
            if ((v138 & 0x100) != 0) {
              float v33 = v156;
            }
            float v157 = fmaxf(v37, v137);
            if ((v138 & 0x800) != 0) {
              float v37 = v157;
            }
            float v158 = v546;
            float v159 = fmaxf(v546, v137);
            if ((v138 & 0x20) != 0) {
              float v158 = v159;
            }
            float v546 = v158;
            float v547 = v153;
            float v160 = v542;
            float v161 = fmaxf(v542, v137);
            if ((v138 & 0x40) != 0) {
              float v160 = v161;
            }
            float v542 = v160;
            float v543 = v155;
            float v162 = fmaxf(v34, v137);
            if ((v138 & 0x200) != 0) {
              float v34 = v162;
            }
            float v163 = fmaxf(v38, v137);
            if ((v138 & 0x400) != 0) {
              float v38 = v163;
            }
            ++v135;
          }
          while (v135 < *(unsigned int *)(v91 + 100));
LABEL_192:
          *(float *)&double v90 = v64;
          [(VKBuildingGroup *)v97 prepareForBuilding:v91 forRoofStyle:v100 scaleThreshold:v90];

          uint64_t v88 = v560;
LABEL_104:
          ++v572;
LABEL_105:
          v89 += 2;
          if (v89 == v88) {
            goto LABEL_198;
          }
          continue;
        }
      }
      else
      {
        BOOL v100 = 0;
        if (v97) {
          goto LABEL_121;
        }
      }
      break;
    }
    uint64_t v102 = v580;
    if (v580)
    {
      md::createFeatureAttributeSet((gss::Allocator *)obj, v98);
      *(void *)&components[7] = 0;
      *(void *)components = 0;
      components[15] = 1;
      gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)v607, v102, (gss::FeatureAttributeSet *)obj, (gss::QueryOverrides *)components);
      if (obj[0])
      {
        obj[1] = obj[0];
        (*(void (**)(void, id, int64_t))(*(void *)v587 + 40))(v587, obj[0], (char *)v586 - (char *)obj[0]);
      }
    }
    else
    {
      *(_OWORD *)v607 = 0uLL;
    }
    uint64_t v103 = [VKBuildingGroup alloc];
    *(float *)&double v104 = v531;
    *(float *)&double v105 = v539;
    unsigned int v106 = [(VKBuildingGroup *)v103 initWithStyleQuery:v607 tileZoom:0 fixedAroundCentroid:v104 contentScale:v105];
    uint64_t v107 = v106;
    obj[0] = &unk_1EF559618;
    obj[1] = v107;
    uint64_t v108 = *v93;
    int64_t v109 = (char *)v575[0] + 24 * (v572 % 3);
    unint64_t v112 = *((void *)v109 + 2);
    BOOL v111 = (char **)(v109 + 16);
    unint64_t v110 = v112;
    double v554 = v107;
    if ((unint64_t)*v93 < v112)
    {
      char *v108 = &unk_1EF559618;
      v108[1] = 0;
      objc_storeStrong(v108 + 1, obj[1]);
      id v113 = obj[1];
      obj[1] = 0;

      uint64_t v114 = v108 + 3;
      goto LABEL_149;
    }
    unint64_t v115 = 0xAAAAAAAAAAAAAAABLL * (v108 - *v564);
    unint64_t v116 = v115 + 1;
    if (v115 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v117 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v110 - (void)*v564) >> 3);
    if (2 * v117 > v116) {
      unint64_t v116 = 2 * v117;
    }
    if (v117 >= 0x555555555555555) {
      unint64_t v118 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v118 = v116;
    }
    if (v118)
    {
      if (v118 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_665;
      }
      uint64_t v119 = (char *)operator new(24 * v118);
    }
    else
    {
      uint64_t v119 = 0;
    }
    uint64_t v120 = &v119[24 * v115];
    *(void *)uint64_t v120 = &unk_1EF559618;
    *((void *)v120 + 1) = 0;
    objc_storeStrong((id *)v120 + 1, v106);
    id v121 = obj[1];
    obj[1] = 0;

    uint64_t v122 = &v119[24 * v118];
    uint64_t v123 = *v93;
    uint64_t v124 = *v564;
    if (*v93 == *v564)
    {
      *uint64_t v564 = (void **)v120;
      *unsigned int v93 = (void **)(v120 + 24);
      *BOOL v111 = v122;
      uint64_t v114 = (void **)(v120 + 24);
      if (!v123) {
        goto LABEL_149;
      }
    }
    else
    {
      v527 = v122;
      uint64_t v125 = (uint64_t)&v119[24 * v115 - 24];
      uint64_t v114 = (void **)(v120 + 24);
      do
      {
        *((void *)v120 - 3) = &unk_1EF559618;
        v120 -= 24;
        *((void *)v120 + 1) = 0;
        uint64_t v127 = *(v123 - 2);
        uint64_t v126 = v123 - 2;
        objc_storeStrong((id *)v120 + 1, v127);
        uint64_t v128 = *v126;
        *uint64_t v126 = 0;

        uint64_t v123 = v126 - 1;
        v125 -= 24;
      }
      while (v123 != v124);
      uint64_t v123 = *v564;
      uint64_t v129 = *v93;
      *uint64_t v564 = (void **)v120;
      *unsigned int v93 = v114;
      *BOOL v111 = v527;
      if (v129 == v123)
      {
        if (!v123) {
          goto LABEL_149;
        }
      }
      else
      {
        uint64_t v130 = v129 - 3;
        unint64_t v131 = v129 - 3;
        int64_t v132 = v129 - 3;
        do
        {
          uint64_t v133 = (void (**)(void **))*v132;
          v132 -= 3;
          (*v133)(v131);
          v130 -= 3;
          _ZF = v131 == v123;
          unint64_t v131 = v132;
        }
        while (!_ZF);
        if (!v123)
        {
LABEL_149:
          *unsigned int v93 = v114;
          obj[0] = &unk_1EF559618;

          uint64_t v134 = (std::__shared_weak_count *)v607[1];
          if (v607[1] && !atomic_fetch_add((atomic_ullong *volatile)v607[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v134->__on_zero_shared)(v134);
            std::__shared_weak_count::__release_weak(v134);
          }
          unint64_t v97 = v554;
          if (*(_DWORD *)(v91 + 100)) {
            goto LABEL_153;
          }
          goto LABEL_192;
        }
      }
    }
    operator delete(v123);
    goto LABEL_149;
  }
  float v548 = 0.0;
  float v549 = 0.0;
  float v546 = 0.0;
  float v547 = 0.0;
  float v544 = 0.0;
  float v545 = 0.0;
  float v542 = 0.0;
  float v543 = 0.0;
  float v540 = 0.0;
  float v541 = 0.0;
  float v33 = 0.0;
  float v34 = 0.0;
  float v35 = 0.0;
  float v36 = 0.0;
  float v37 = 0.0;
  float v38 = 0.0;
LABEL_198:
  (*(void (**)(void **__return_ptr))(*(void *)v533 + 24))(v605);
  obj[0] = (id)MEMORY[0x1E4F143A8];
  obj[1] = (id)3221225472;
  long long v586 = ___Z12_buildMeshesRNSt3__16vectorINS0_IN3geo11_retain_ptrIU8__strongP15VKBuildingGroupNS1_16_retain_objc_arcENS1_17_release_objc_arcENS1_10_hash_objcENS1_11_equal_objcEEENS_9allocatorISA_EEEENSB_ISD_EEEERN3ggl21CullingGridWithHeightERN2md12TriangulatorIfEEPNSH_6DeviceEbRKNS_10shared_ptrINSK_21GEOVectorTileResourceEEERKNSQ_IN3gss17StylesheetManagerINSV_10PropertyIDEEEEEfRKNS1_8QuadTileE_block_invoke;
  *(void *)&long long v587 = &unk_1E5A95CA8;
  long long v588 = v575;
  *((void *)&v587 + 1) = &dest;
  char v592 = (char)color[0];
  unint64_t v589 = v557;
  int v590 = src;
  float v591 = v64;
  *(void *)&components[24] = 0;
  *(void *)components = &unk_1EF56BC58;
  *(void *)&components[8] = MEMORY[0x1A6239EB0](obj);
  *(void *)&components[24] = components;
  *(_OWORD *)v607 = 0uLL;
  (*(void (**)(void *, unsigned char *, void **))(*(void *)v605[0] + 16))(v605[0], components, v607);
  uint64_t v164 = (std::__shared_weak_count *)v607[1];
  if (v607[1] && !atomic_fetch_add((atomic_ullong *volatile)v607[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v164->__on_zero_shared)(v164);
    std::__shared_weak_count::__release_weak(v164);
  }
  if (*(unsigned char **)&components[24] == components)
  {
    (*(void (**)(unsigned char *))(*(void *)components + 32))(components);
    uint64_t v50 = v550;
    uint64_t v165 = v605[0];
    if (!v605[0]) {
      goto LABEL_211;
    }
    goto LABEL_207;
  }
  uint64_t v50 = v550;
  if (*(void *)&components[24]) {
    (*(void (**)(void))(**(void **)&components[24] + 40))();
  }
  uint64_t v165 = v605[0];
  if (v605[0])
  {
LABEL_207:
    uint64_t v166 = (*(uint64_t (**)(void *))(*(void *)v165 + 24))(v165);
    uint64_t v167 = v605[0];
    v605[0] = 0;
    *(void *)components = v167;
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v166 + 48))(v166, components);
    uint64_t v168 = *(void *)components;
    *(void *)components = 0;
    if (v168) {
      (*(void (**)(uint64_t))(*(void *)v168 + 8))(v168);
    }
    int v169 = v605[0];
    v605[0] = 0;
    if (v169) {
      (*(void (**)(void *))(*(void *)v169 + 8))(v169);
    }
  }
LABEL_211:
  _Block_object_dispose(&dest, 8);
  if (v596)
  {
    v597 = v596;
    operator delete(v596);
  }
LABEL_213:

  if (v621)
  {
    v622 = v621;
    operator delete(v621);
  }
  geo::Pool<geo::Triangulator<float,unsigned short>::Node>::disposeElements((uint64_t)src);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)&src[8]);
LABEL_216:
  int v170 = +[VKPlatform sharedPlatform];
  int v171 = [v170 supportsBuildingShadows];

  if (v171)
  {
    uint64_t v172 = (geo::codec::VectorTile **)(v583 + 144);
    unint64_t v173 = geo::codec::VectorTile::nonOverlappingBuildingFootprintsCount(*(geo::codec::VectorTile **)(v583 + 144));
    if (!v173)
    {
      v555.i32[0] = 1.0;
      v561.i32[0] = 0;
      v558.i32[0] = 0;
      v551.i32[0] = 1.0;
LABEL_238:
      uint64_t v199 = geo::codec::VectorTile::nonOverlappingThreeDBuildingsCount(*v172);
      if (v199)
      {
        unint64_t v200 = 0;
        float v534 = 1.0;
        float v565 = 1.0;
        do
        {
          uint64_t v201 = geo::codec::threeDBuildingFeatureAtIndex((uint64_t)v172, v200);
          uint64_t v202 = (geo *)geo::A3DFileCreate(*(geo **)(v201 + 80), (const unsigned __int8 *)(*(void *)(v201 + 88) - *(void *)(v201 + 80)));
          uint64_t v203 = v202;
          if (v202)
          {
            uint64_t v204 = *(geo **)v202;
            uint64_t v205 = (const unsigned __int8 *)*((void *)v202 + 1);
            unsigned int v207 = geo::A3DGetMetadataHeaderCount(*(geo **)v202, v205);
            if (v207)
            {
              uint64_t v208 = geo::A3DGetMetadataHeaders(v204, v205);
              if (v208)
              {
                uint64_t v209 = 0;
                uint64_t v210 = 0;
                uint64_t v211 = v207;
                do
                {
                  if (!*(unsigned char *)v208)
                  {
                    v209 += *(unsigned int *)(v208 + 5);
                    ++v210;
                  }
                  v208 += 17;
                  --v211;
                }
                while (v211);
                if (v210) {
                  operator new[]();
                }
              }
            }
            geo::A3DFileDelete(v203, v206);
          }
          ++v200;
        }
        while (v200 != v199);
      }
      else
      {
        float v565 = 1.0;
        float v534 = 1.0;
      }
      uint64_t v212 = operator new(0x60uLL);
      v212[1] = 0;
      v212[2] = 0;
      *uint64_t v212 = &unk_1EF583AF8;
      uint64_t v213 = ggl::TextureData2D::TextureData2D((uint64_t)(v212 + 3), 512, 512, 1u, 2, 1);
      obj[0] = v212 + 3;
      obj[1] = v212;
      data = (void *)(*(uint64_t (**)(void *, void))(v212[3] + 16))(v213, 0);
      if (_grayscaleColorSpace(void)::onceToken != -1) {
        dispatch_once(&_grayscaleColorSpace(void)::onceToken, &__block_literal_global_38268);
      }
      uint64_t v214 = CGBitmapContextCreate(data, 0x200uLL, 0x200uLL, 8uLL, 0x200uLL, (CGColorSpaceRef)_grayscaleColorSpace(void)::colorspace, 0);
      CGContextSetBlendMode(v214, kCGBlendModeCopy);
      CGContextScaleCTM(v214, 512.0, 512.0);
      CGContextTranslateCTM(v214, 0.0, 1.0);
      CGContextScaleCTM(v214, 1.0, -1.0);
      v215.i64[0] = __PAIR64__(v558.u32[0], v561.u32[0]);
      v215.i64[1] = __PAIR64__(v551.u32[0], v555.u32[0]);
      v216.i64[1] = __PAIR64__(v551.u32[0], v555.u32[0]);
      v216.i64[0] = 0;
      v217.i64[0] = __PAIR64__(v558.u32[0], v561.u32[0]);
      v217.i64[1] = __PAIR64__(LODWORD(v534), LODWORD(v565));
      int8x16_t v218 = (int8x16_t)vcgtq_f32(v217, v216);
      v216.i64[1] = __PAIR64__(LODWORD(v534), LODWORD(v565));
      float32x4_t v219 = vaddq_f32((float32x4_t)vbslq_s8(v218, (int8x16_t)v216, v215), (float32x4_t)xmmword_1A28FF710);
      float v220 = v219.f32[1];
      float v519 = v219.f32[0];
      CGContextScaleCTM(v214, (float)(1.0 / vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v219, 2), v219).f32[0]), (float)(1.0 / (float)(v219.f32[3] - v219.f32[1])));
      CGContextTranslateCTM(v214, (float)-v519, (float)-v220);
      *(_OWORD *)components = xmmword_1A28FFCD0;
      if (_grayscaleColorSpace(void)::onceToken != -1) {
        dispatch_once(&_grayscaleColorSpace(void)::onceToken, &__block_literal_global_38268);
      }
      colora = CGColorCreate((CGColorSpaceRef)_grayscaleColorSpace(void)::colorspace, (const CGFloat *)components);
      CGContextSetAllowsAntialiasing(v214, 0);
      CGContextSetFillColorWithColor(v214, colora);
      unint64_t v221 = geo::codec::VectorTile::nonOverlappingBuildingFootprintsCount(*v172);
      if (v221)
      {
        for (unint64_t i = 0; i != v221; ++i)
        {
          uint64_t v223 = geo::codec::buildingFootprintFeatureAtIndex((uint64_t)v172, i);
          uint64_t v224 = v223;
          if (!*(unsigned char *)(v223 + 128) && *(_DWORD *)(v223 + 100))
          {
            unint64_t v225 = 0;
            do
            {
              float v226 = geo::codec::buildingFootprintExtrusionHeight(v224, v225);
              *(void *)src = 0;
              long long v227 = (float *)geo::codec::multiSectionFeaturePoints((void *)v224, v225, src);
              if (v226 > 0.0 && *(void *)src >= 3uLL)
              {
                uint64_t v229 = v227;
                CGContextBeginPath(v214);
                CGContextMoveToPoint(v214, *v229, v229[1]);
                if (*(void *)src >= 2uLL)
                {
                  uint64_t v230 = v229 + 3;
                  unint64_t v231 = 1;
                  do
                  {
                    CGContextAddLineToPoint(v214, *(v230 - 1), *v230);
                    ++v231;
                    v230 += 2;
                  }
                  while (v231 < *(void *)src);
                }
                CGContextClosePath(v214);
                CGContextFillPath(v214);
              }
              ++v225;
            }
            while (v225 < *(unsigned int *)(v224 + 100));
          }
        }
      }
      uint64_t v232 = geo::codec::VectorTile::nonOverlappingThreeDBuildingsCount(*v172);
      if (v232)
      {
        for (unint64_t j = 0; j != v232; ++j)
        {
          uint64_t v234 = geo::codec::threeDBuildingFeatureAtIndex((uint64_t)v172, j);
          uint64_t v235 = (geo *)geo::A3DFileCreate(*(geo **)(v234 + 80), (const unsigned __int8 *)(*(void *)(v234 + 88) - *(void *)(v234 + 80)));
          uint64_t v236 = v235;
          if (v235)
          {
            uint64_t v238 = *(geo **)v235;
            int16x8_t v237 = (const unsigned __int8 *)*((void *)v235 + 1);
            unsigned int v240 = geo::A3DGetMetadataHeaderCount(*(geo **)v235, v237);
            if (v240)
            {
              uint64_t v241 = geo::A3DGetMetadataHeaders(v238, v237);
              if (v241)
              {
                uint64_t v242 = 0;
                uint64_t v243 = 0;
                uint64_t v244 = v240;
                do
                {
                  if (!*(unsigned char *)v241)
                  {
                    v242 += *(unsigned int *)(v241 + 5);
                    ++v243;
                  }
                  v241 += 17;
                  --v244;
                }
                while (v244);
                if (v243) {
                  operator new[]();
                }
              }
            }
            geo::A3DFileDelete(v236, v239);
          }
        }
      }
      CGContextRelease(v214);
      CGColorRelease(colora);
      *(void *)src = data;
      int v245 = malloc_type_malloc(0x40000uLL, 0x2C50054DuLL);
      uint64_t v246 = v245;
      if (v245)
      {
        *(int64x2_t *)&dest.height = vdupq_n_s64(0x200uLL);
        *(_OWORD *)&src[8] = *(_OWORD *)&dest.height;
        dest.data = v245;
        dest.size_t rowBytes = 512;
        *(void *)&src[24] = 512;
        vImageConvolve_Planar8((const vImage_Buffer *)src, &dest, 0, 0, 0, _blurTexture(unsigned char *)::kernel, 0xBu, 1u, 0x7FFF, 0, 4u);
        vImageConvolve_Planar8(&dest, (const vImage_Buffer *)src, 0, 0, 0, _blurTexture(unsigned char *)::kernel, 1u, 0xBu, 0x7FFF, 0, 4u);
        free(v246);
      }
      uint64_t v247 = (char *)operator new(0x58uLL);
      *((void *)v247 + 1) = 0;
      *((void *)v247 + 2) = 0;
      *(void *)uint64_t v247 = &unk_1EF583858;
      *((void *)v247 + 5) = 0;
      *((void *)v247 + 6) = 0;
      *((_DWORD *)v247 + 14) = 0;
      *((void *)v247 + 3) = &unk_1EF55AE58;
      *((void *)v247 + 4) = 0;
      *(void *)&long long v248 = 0x100000001;
      *((void *)&v248 + 1) = 0x100000001;
      *(_OWORD *)(v247 + 60) = v248;
      *(void *)(v247 + 76) = 0x100000001;
      *((_DWORD *)v247 + 21) = 0;
      *(void *)src = v247 + 24;
      *(void *)&src[8] = v247;
      operator new();
    }
    unint64_t v175 = 0;
    v174.i64[0] = 0;
    float32x4_t v558 = v174;
    v174.i32[0] = 1.0;
    float32x4_t v551 = v174;
    v174.i32[0] = 1.0;
    float32x4_t v555 = v174;
    v174.i64[0] = 0;
    float32x4_t v561 = v174;
    while (1)
    {
      uint64_t v176 = geo::codec::buildingFootprintFeatureAtIndex((uint64_t)v172, v175);
      uint64_t v177 = v176;
      if (!*(unsigned char *)(v176 + 128))
      {
        if (*(_DWORD *)(v176 + 100)) {
          break;
        }
      }
LABEL_219:
      if (++v175 == v173) {
        goto LABEL_238;
      }
    }
    unint64_t v178 = 0;
    while (2)
    {
      if (geo::codec::buildingFootprintExtrusionHeight(v177, v178) != 0.0)
      {
        *(void *)src = 0;
        uint64_t v183 = geo::codec::multiSectionFeaturePoints((void *)v177, v178, src);
        if (*(void *)src)
        {
          if (*(void *)src <= 7uLL)
          {
            unint64_t v184 = 0;
            float32x4_t v179 = v558;
            float32x4_t v180 = v561;
            float32x4_t v182 = v551;
            float32x4_t v181 = v555;
            goto LABEL_233;
          }
          unint64_t v184 = *(void *)src & 0xFFFFFFFFFFFFFFF8;
          float32x4_t v185 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v551.f32, 0);
          float32x4_t v186 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v555.f32, 0);
          float32x4_t v187 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v558.f32, 0);
          uint64_t v188 = (const float *)(v183 + 4);
          unint64_t v189 = *(void *)src & 0xFFFFFFFFFFFFFFF8;
          float32x4_t v190 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v561.f32, 0);
          float32x4_t v182 = v185;
          float32x4_t v191 = v186;
          float32x4_t v192 = v187;
          float32x4_t v193 = v190;
          do
          {
            uint64_t v194 = v188 - 8;
            float32x4x2_t v627 = vld2q_f32(v194);
            float32x4x2_t v628 = vld2q_f32(v188);
            float32x4_t v190 = vminnmq_f32(v627.val[0], v190);
            float32x4_t v193 = vminnmq_f32(v628.val[0], v193);
            float32x4_t v186 = vmaxnmq_f32(v186, v627.val[0]);
            float32x4_t v191 = vmaxnmq_f32(v191, v628.val[0]);
            float32x4_t v187 = vminnmq_f32(v627.val[1], v187);
            float32x4_t v192 = vminnmq_f32(v628.val[1], v192);
            float32x4_t v185 = vmaxnmq_f32(v185, v627.val[1]);
            float32x4_t v182 = vmaxnmq_f32(v182, v628.val[1]);
            v188 += 16;
            v189 -= 8;
          }
          while (v189);
          float32x4_t v180 = vminnmq_f32(v190, v193);
          v180.f32[0] = vminnmvq_f32(v180);
          float32x4_t v179 = vminnmq_f32(v187, v192);
          v179.f32[0] = vminnmvq_f32(v179);
          float32x4_t v181 = vmaxnmq_f32(v186, v191);
          v181.f32[0] = vmaxnmvq_f32(v181);
          v182.f32[0] = vmaxnmvq_f32(vmaxnmq_f32(v185, v182));
          if (*(void *)src != v184)
          {
LABEL_233:
            unint64_t v195 = *(void *)src - v184;
            uint64_t v196 = (float *)&v183[v184] + 1;
            do
            {
              float v197 = *(v196 - 1);
              v180.f32[0] = fminf(v197, v180.f32[0]);
              v181.f32[0] = fmaxf(v181.f32[0], v197);
              float v198 = *v196;
              v196 += 2;
              v179.f32[0] = fminf(v198, v179.f32[0]);
              v182.f32[0] = fmaxf(v182.f32[0], v198);
              --v195;
            }
            while (v195);
          }
        }
        else
        {
          float32x4_t v179 = v558;
          float32x4_t v180 = v561;
          float32x4_t v182 = v551;
          float32x4_t v181 = v555;
        }
        float32x4_t v551 = v182;
        float32x4_t v555 = v181;
        float32x4_t v558 = v179;
        float32x4_t v561 = v180;
      }
      if (++v178 >= *(unsigned int *)(v177 + 100)) {
        goto LABEL_219;
      }
      continue;
    }
  }
  id v532 = *(id *)(a1 + 784);
  v605[1] = 0;
  v605[0] = 0;
  v606 = 0;
  uint64_t v249 = geo::codec::VectorTile::totalThreeDBuildingsCount(*v536);
  uint64_t v251 = v249;
  v603 = 0;
  v602 = 0;
  unint64_t v604 = 0;
  v600 = 0;
  v599 = 0;
  uint64_t v601 = 0;
  if (!v249)
  {
    uint64_t v315 = 0;
    size_t v252 = 0;
    long long v467 = 0uLL;
    goto LABEL_593;
  }
  size_t v252 = 0;
  unint64_t v253 = 0;
  int8x16_t v573 = v250;
  long long v559 = 0u;
  while (2)
  {
    uint64_t v254 = geo::codec::threeDBuildingFeatureAtIndex((uint64_t)v536, v253);
    uint64_t v255 = *(geo **)(v254 + 40);
    uint64_t v256 = (geo *)geo::A3DFileCreate(*(geo **)(v254 + 80), (const unsigned __int8 *)(*(void *)(v254 + 88) - *(void *)(v254 + 80)));
    if (v256)
    {
      uint64_t v257 = v580;
      md::createFeatureAttributeSet((gss::Allocator *)src, (uint64_t *)(v254 + 24));
      *(void **)((char *)&dest.data + 7) = 0;
      dest.data = 0;
      HIBYTE(dest.height) = 1;
      gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)components, v257, (gss::FeatureAttributeSet *)src, (gss::QueryOverrides *)&dest);
      uint64_t v260 = *(void **)src;
      if (*(void *)src)
      {
        *(void *)&src[8] = *(void *)src;
        (*(void (**)(void, void, void))(**(void **)&src[24] + 40))(*(void *)&src[24], *(void *)src, *(void *)&src[16] - *(void *)src);
      }
      unint64_t v261 = v599;
      double v552 = v252;
      if (v599 != v600)
      {
        do
        {
          if (*(void *)components == *v261) {
            goto LABEL_298;
          }
          v261 += 4;
        }
        while (v261 != v600);
        dest.height = 0;
        dest.data = 0;
LABEL_301:
        *(void **)((char *)v607 + 7) = 0;
        v607[0] = 0;
        HIBYTE(v607[1]) = 1;
        *(_WORD *)geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[]((uint64_t *)v607, 0x10002u) = 1;
        uint64_t v264 = v580;
        md::createFeatureAttributeSet((gss::Allocator *)src, (uint64_t *)(v254 + 24));
        gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes(&v613, v264, (gss::FeatureAttributeSet *)src, (gss::QueryOverrides *)v607);
        if (*(void *)src)
        {
          *(void *)&src[8] = *(void *)src;
          (*(void (**)(void, void, void))(**(void **)&src[24] + 40))(*(void *)&src[24], *(void *)src, *(void *)&src[16] - *(void *)src);
        }
        uint64_t v265 = operator new(0x90uLL);
        v265[1] = 0;
        v265[2] = 0;
        *uint64_t v265 = &unk_1EF57F878;
        v265[3] = 0;
        v265[4] = 0;
        v265[5] = 0;
        {
          operator new();
        }
        v265[6] = ggl::Allocator::instance(void)::alloc;
        ggl::MeshVendor<ggl::Landmark::LandmarkMesh>::_allocateNewMesh();
      }
LABEL_298:
      dest.height = 0;
      dest.data = 0;
      if (v261 == v600) {
        goto LABEL_301;
      }
      int v263 = (void *)v261[2];
      vImagePixelCount v262 = v261[3];
      if (v262)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v262 + 8), 1uLL, memory_order_relaxed);
        dest.data = v263;
        dest.height = v262;
      }
      else
      {
        dest.data = v263;
      }
      uint64_t v266 = *((void *)v256 + 3);
      if (v266)
      {
LABEL_309:
        v258.i32[0] = *(_DWORD *)(v266 + 8);
        v259.i64[0] = *(void *)v266;
        unint64_t v269 = *((void *)v256 + 2);
        if (v269 < 2)
        {
          int8x16_t v268 = vextq_s8(vextq_s8(v258, v258, 4uLL), v259, 0xCuLL);
          v268.i32[3] = v268.i32[0];
        }
        else
        {
          int8x16_t v268 = vextq_s8(v258, v259, 0xCuLL);
          v268.i32[0] = *(_DWORD *)(v266 + 8);
          v268.i32[3] = v268.i32[0];
          unsigned int v270 = 2;
          for (unint64_t k = 1; k < v269; unint64_t k = v270++)
          {
            uint64_t v272 = (float32x2_t *)(v266 + 32 * k);
            *(float32x2_t *)v258.i8 = *v272;
            float32x4_t v273 = (float32x4_t)v268;
            v273.i32[0] = v272[1].i32[0];
            int8x16_t v274 = vextq_s8(v258, v258, 0xCuLL);
            float32x4_t v275 = (float32x4_t)v274;
            v275.i32[0] = v268.i32[0];
            *(float32x2_t *)v259.i8 = vminnm_f32(*v272, *(float32x2_t *)v259.i8);
            v275.i32[3] = v273.i32[0];
            int8x16_t v258 = (int8x16_t)vcgtq_f32(v275, v273);
            v274.i32[0] = v273.i32[0];
            v274.i32[3] = v273.i32[0];
            int8x16_t v268 = vbslq_s8(v258, v274, v268);
          }
        }
      }
      else
      {
        int v267 = geo::prepareAlignedVertices(v256, v260);
        int8x16_t v268 = *(int8x16_t *)color;
        int8x16_t v259 = v573;
        if (v267)
        {
          uint64_t v266 = *((void *)v256 + 3);
          goto LABEL_309;
        }
      }
      *(int8x16_t *)color = v268;
      int8x16_t v573 = v259;
      uint64_t v276 = (char *)dest.data;
      if (*((unsigned char *)dest.data + 88))
      {
        int8x16_t v277 = v259;
        v277.i32[2] = v268.i32[0];
        float32x4_t v278 = (float32x4_t)v277;
        v278.i32[3] = HIDWORD(*(_OWORD *)((char *)dest.data + 92));
        float32x4_t v279 = *(float32x4_t *)((char *)dest.data + 92);
        v279.i32[3] = v268.i32[1];
        v277.i32[3] = v268.i32[1];
        *(int8x16_t *)((char *)dest.data + 92) = vbslq_s8((int8x16_t)vcgtq_f32(v279, v278), v277, *(int8x16_t *)((char *)dest.data + 92));
        *(float32x2_t *)(v276 + 108) = vmaxnm_f32(*(float32x2_t *)(v276 + 108), (float32x2_t)*(_OWORD *)&vextq_s8(v268, v268, 8uLL));
      }
      else
      {
        *((unsigned char *)dest.data + 88) = 1;
        *(void *)(v276 + 92) = v259.i64[0];
        *(int8x16_t *)(v276 + 100) = v268;
      }
      vImagePixelCount v280 = dest.height;
      *(void *)src = v276;
      *(void *)&src[8] = dest.height;
      if (dest.height) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(dest.height + 8), 1uLL, memory_order_relaxed);
      }
      *(void *)&src[16] = v255;
      uint64_t v281 = v603;
      if ((unint64_t)v603 < v604)
      {
        *v603 = v256;
        v281[1] = (geo *)v276;
        v281[2] = (geo *)v280;
        v281[3] = v255;
        v603 = v281 + 4;
        goto LABEL_341;
      }
      float32x2_t v282 = (geo **)v602;
      uint64_t v283 = ((char *)v603 - (unsigned char *)v602) >> 5;
      unint64_t v284 = v283 + 1;
      if ((unint64_t)(v283 + 1) >> 59) {
        abort();
      }
      if ((uint64_t)(v604 - (void)v602) >> 4 > v284) {
        unint64_t v284 = (uint64_t)(v604 - (void)v602) >> 4;
      }
      if (v604 - (unint64_t)v602 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v285 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v285 = v284;
      }
      if (v285 >> 59) {
        goto LABEL_665;
      }
      uint64_t v286 = (char *)operator new(32 * v285);
      uint64_t v287 = &v286[32 * v283];
      *(void *)uint64_t v287 = v256;
      *(_OWORD *)(v287 + 8) = *(_OWORD *)src;
      uint64_t v288 = &v286[32 * v285];
      *(void *)src = 0;
      *(void *)&src[8] = 0;
      *((void *)v287 + 3) = v255;
      uint64_t v289 = (geo **)(v287 + 32);
      if (v281 == v282)
      {
        v602 = &v286[32 * v283];
        unint64_t v604 = (unint64_t)v288;
        size_t v252 = v552;
        if (v281) {
          goto LABEL_337;
        }
      }
      else
      {
        uint64_t v290 = 0;
        do
        {
          uint64_t v291 = &v287[v290 * 8];
          int v292 = &v281[v290];
          *((_OWORD *)v291 - 2) = *(_OWORD *)&v281[v290 - 4];
          *((void *)v291 - 2) = v281[v290 - 2];
          *(v292 - 3) = 0;
          *(v292 - 2) = 0;
          *((void *)v291 - 1) = v281[v290 - 1];
          v290 -= 4;
        }
        while (&v281[v290] != v282);
        v602 = &v287[v290 * 8];
        v603 = (geo **)(v287 + 32);
        unint64_t v604 = (unint64_t)v288;
        do
        {
          unint64_t v293 = (std::__shared_weak_count *)*(v281 - 2);
          if (v293 && !atomic_fetch_add(&v293->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v293->__on_zero_shared)(v293);
            std::__shared_weak_count::__release_weak(v293);
          }
          v281 -= 4;
        }
        while (v281 != v282);
        uint64_t v281 = v282;
        size_t v252 = v552;
        if (v281) {
LABEL_337:
        }
          operator delete(v281);
      }
      float v294 = *(std::__shared_weak_count **)&src[8];
      v603 = v289;
      if (*(void *)&src[8]
        && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&src[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v294->__on_zero_shared)(v294);
        std::__shared_weak_count::__release_weak(v294);
      }
LABEL_341:
      uint64_t v295 = (char *)*((void *)&v559 + 1);
      if (*((void *)&v559 + 1) >= (unint64_t)v252)
      {
        uint64_t v297 = (void *)v559;
        unint64_t v298 = 0x84BDA12F684BDA13 * ((uint64_t)(*((void *)&v559 + 1) - v559) >> 4) + 1;
        if (v298 > 0x97B425ED097B42) {
          abort();
        }
        if (0x97B425ED097B426 * ((uint64_t)((uint64_t)v252 - v559) >> 4) > v298) {
          unint64_t v298 = 0x97B425ED097B426 * ((uint64_t)((uint64_t)v252 - v559) >> 4);
        }
        if (0x84BDA12F684BDA13 * ((uint64_t)((uint64_t)v252 - v559) >> 4) >= 0x4BDA12F684BDA1) {
          unint64_t v299 = 0x97B425ED097B42;
        }
        else {
          unint64_t v299 = v298;
        }
        if (v299 > 0x97B425ED097B42) {
          goto LABEL_665;
        }
        unint64_t v300 = (char *)operator new(432 * v299);
        uint64_t v301 = &v300[16 * ((uint64_t)(*((void *)&v559 + 1) - v559) >> 4)];
        *((void *)v301 + 52) = 0;
        *((_OWORD *)v301 + 24) = 0u;
        *((_OWORD *)v301 + 25) = 0u;
        *((_OWORD *)v301 + 22) = 0u;
        *((_OWORD *)v301 + 23) = 0u;
        *((_OWORD *)v301 + 20) = 0u;
        *((_OWORD *)v301 + 21) = 0u;
        *((_OWORD *)v301 + 18) = 0u;
        *((_OWORD *)v301 + 19) = 0u;
        *((_OWORD *)v301 + 16) = 0u;
        *((_OWORD *)v301 + 17) = 0u;
        *((_OWORD *)v301 + 14) = 0u;
        *((_OWORD *)v301 + 15) = 0u;
        *((_OWORD *)v301 + 12) = 0u;
        *((_OWORD *)v301 + 13) = 0u;
        *((_OWORD *)v301 + 10) = 0u;
        *((_OWORD *)v301 + 11) = 0u;
        *((_OWORD *)v301 + 8) = 0u;
        *((_OWORD *)v301 + 9) = 0u;
        *((_OWORD *)v301 + 6) = 0u;
        *((_OWORD *)v301 + 7) = 0u;
        *((_OWORD *)v301 + 4) = 0u;
        *((_OWORD *)v301 + 5) = 0u;
        *((_OWORD *)v301 + 2) = 0u;
        *((_OWORD *)v301 + 3) = 0u;
        *(_OWORD *)uint64_t v301 = 0u;
        *((_OWORD *)v301 + 1) = 0u;
        *((void *)v301 + 53) = *(void *)(v254 + 40);
        uint64_t v302 = v301;
        if (*((void *)&v559 + 1) != (void)v559)
        {
          do
          {
            v302 -= 432;
            v295 -= 432;
            memcpy(v302, v295, 0x1B0uLL);
          }
          while (v295 != (char *)v559);
        }
        double v552 = (void **)&v300[432 * v299];
        uint64_t v296 = (uint64_t)(v301 + 432);
        *(void *)&long long v559 = v302;
        if (v297) {
          operator delete(v297);
        }
      }
      else
      {
        *(void *)(*((void *)&v559 + 1) + 416) = 0;
        *(_OWORD *)(*((void *)&v559 + 1) + 384) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 400) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 352) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 368) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 320) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 336) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 288) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 304) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 256) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 272) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 224) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 240) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 192) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 208) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 160) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 176) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 128) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 144) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 96) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 112) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 64) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 80) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 32) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 48) = 0u;
        **((_OWORD **)&v559 + 1) = 0u;
        *(_OWORD *)(*((void *)&v559 + 1) + 16) = 0u;
        *(void *)(*((void *)&v559 + 1) + 424) = *(void *)(v254 + 40);
        uint64_t v296 = *((void *)&v559 + 1) + 432;
      }
      *(void *)&long long v303 = v559;
      *((void *)&v303 + 1) = v296;
      long long v559 = v303;
      uint64_t v304 = *(geo **)v256;
      uint64_t v305 = (const unsigned __int8 *)*((void *)v256 + 1);
      int v306 = geo::A3DGetMetadataHeaderCount(*(geo **)v256, v305);
      uint64_t v307 = (void *)(v296 - 432);
      size_t v252 = v552;
      if (v306 && (v308 = geo::A3DGetMetadataHeaders(v304, v305), size_t v252 = v552, v308))
      {
        uint64_t v309 = 0;
        long long v310 = (unsigned __int8 *)v308;
        while (1)
        {
          int v311 = *v310;
          v310 += 17;
          if (v311 == 1) {
            break;
          }
          if (v306 == ++v309) {
            goto LABEL_359;
          }
        }
        memcpy(v307, (char *)v304 + *(unsigned int *)(v308 + 17 * v309 + 1), 0x1A8uLL);
        uint64_t v313 = (std::__shared_weak_count *)dest.height;
        if (!dest.height)
        {
LABEL_363:
          uint64_t v314 = *(std::__shared_weak_count **)&components[8];
          if (*(void *)&components[8]
            && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&components[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v314->__on_zero_shared)(v314);
            std::__shared_weak_count::__release_weak(v314);
          }
          goto LABEL_290;
        }
      }
      else
      {
LABEL_359:
        *(void *)&long long v312 = v559;
        *((void *)&v312 + 1) = v307;
        long long v559 = v312;
        uint64_t v313 = (std::__shared_weak_count *)dest.height;
        if (!dest.height) {
          goto LABEL_363;
        }
      }
      if (!atomic_fetch_add(&v313->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v313->__on_zero_shared)(v313);
        std::__shared_weak_count::__release_weak(v313);
      }
      goto LABEL_363;
    }
LABEL_290:
    if (++v253 != v251) {
      continue;
    }
    break;
  }
  uint64_t v315 = (geo **)v602;
  unint64_t v526 = v603;
  if (v602 == v603) {
    goto LABEL_591;
  }
  __asm { FMOV            V1.4S, #1.0 }
  int32x4_t v319 = vdupq_n_s32(0x477FFF00u);
  float32x4_t v523 = _Q1;
  float32x4_t v524 = (float32x4_t)v319;
  while (2)
  {
    float64x2x4_t v562 = v315[3];
    unint64_t v320 = *v315;
    unint64_t v321 = v315[1];
    double v535 = v315;
    v319.i64[0] = *(void *)((char *)v321 + 92);
    v319.i32[2] = *((_DWORD *)v321 + 25);
    *(int32x4_t *)colorb = v319;
    v319.i64[0] = *((void *)v321 + 13);
    v319.i32[2] = *((_DWORD *)v321 + 28);
    float32x4_t v566 = (float32x4_t)v319;
    id v323 = v532;
    float64x2_t v538 = v320;
    if (!v320) {
      goto LABEL_589;
    }
    uint64_t v324 = *(void *)v320;
    if (!*((void *)v320 + 3) && (geo::prepareAlignedVertices(v320, v322) & 1) == 0) {
      goto LABEL_589;
    }
    uint64_t v325 = *((void *)v320 + 2);
    uint64_t v326 = *(void *)(*((void *)v321 + 1) - 8);
    uint64_t v327 = **(void **)(v326 + 64);
    unint64_t v328 = *(void *)(v327 + 8);
    unint64_t v329 = (*(void *)(v327 + 48) - *(void *)(v327 + 40)) / v328;
    uint64_t v330 = v329 + v325;
    if (v329 + v325 >= 0x10000) {
      ggl::MeshVendor<ggl::Landmark::LandmarkMesh>::_allocateNewMesh();
    }
    unint64_t v331 = v328 * v330;
    uint64_t v332 = *(void *)(v327 + 72);
    unint64_t v333 = *(void *)(v327 + 80) - v332;
    if (v331 != v333)
    {
      if (v331 <= v333)
      {
        if (v331 < v333) {
          *(void *)(v327 + 80) = v332 + v331;
        }
      }
      else
      {
        std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v327 + 72, v331 - v333);
      }
      uint64_t v334 = *(std::__shared_weak_count **)(v327 + 32);
      *(void *)(v327 + 24) = 0;
      *(void *)(v327 + 32) = 0;
      if (v334 && !atomic_fetch_add(&v334->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v334->__on_zero_shared)(v334);
        std::__shared_weak_count::__release_weak(v334);
      }
      *(void *)(v327 + 120) = 0;
      *(_DWORD *)(v327 + 112) = 0;
      uint64_t v335 = *(void *)(v327 + 80) - *(void *)(v327 + 72);
      *(void *)(v327 + 40) = 0;
      *(void *)(v327 + 48) = v335;
      *(void *)(v327 + 56) = 0;
      *(void *)(v327 + 64) = v335;
      uint64_t v327 = **(void **)(v326 + 64);
      uint64_t v325 = *((void *)v538 + 2);
      uint64_t v330 = v325 + v329;
    }
    uint64_t v336 = 0;
    *(void *)&src[8] = 0;
    *(void *)src = 0;
    uint64_t v337 = *(void *)(v327 + 8);
    uint64_t v338 = v337 * v330;
    if (v338 != v337 * v329) {
      uint64_t v336 = *(void *)(v327 + 72) + v337 * v329;
    }
    *(void *)&long long v339 = 0;
    *((void *)&v339 + 1) = v327;
    *(_OWORD *)src = v339;
    *(void *)&src[16] = v337 * v329;
    *(void *)&src[24] = v338;
    *(void *)&src[40] = v336;
    *(_WORD *)&src[32] = 1;
    if (v325)
    {
      unint64_t v340 = 0;
      v341.i32[3] = v523.i32[3];
      float32x4_t v342 = vdivq_f32(v523, vsubq_f32(v566, *(float32x4_t *)colorb));
      unsigned int v343 = 1;
      do
      {
        uint64_t v344 = *((void *)v538 + 3) + 32 * v340;
        float v345 = *(float *)(v344 + 20);
        int v346 = (int)(float)(*(float *)(v344 + 24) * 65535.0);
        int v347 = (int)(float)(*(float *)(v344 + 28) * 65535.0);
        float v348 = *(float *)(v344 + 16);
        int v349 = (int)(float)(*(float *)(v344 + 12) * 127.0);
        unint64_t v350 = v336 + 16 * v340;
        v341.i64[0] = *(void *)v344;
        v341.i32[2] = *(_DWORD *)(v344 + 8);
        float32x4_t v341 = (float32x4_t)vcvtq_u32_f32(vmulq_f32(vsubq_f32(v341, *(float32x4_t *)colorb), vmulq_f32(v524, v342)));
        *(int16x4_t *)v341.f32 = vmovn_s32((int32x4_t)v341);
        *(_WORD *)(v350 + 4) = v341.i16[2];
        *(_DWORD *)unint64_t v350 = v341.i32[0];
        *(_WORD *)(v350 + 6) = -1;
        *(_WORD *)(v350 + 8) = v346;
        *(_WORD *)(v350 + 10) = v347;
        *(unsigned char *)(v350 + 12) = v349;
        *(unsigned char *)(v350 + 13) = (int)(float)(v348 * 127.0);
        *(_WORD *)(v350 + 14) = (int)(float)(v345 * 127.0);
        unint64_t v340 = v343++;
      }
      while (*((void *)v538 + 2) > v340);
    }
    if (v532)
    {
      objc_msgSend(v323, "textureManager", v538);
    }
    else
    {
      v614 = 0;
      v613 = 0;
    }
    uint64_t v351 = (std::__shared_weak_count *)operator new(0x58uLL);
    v351->__shared_owners_ = 0;
    v351->__shared_weak_owners_ = 0;
    v351->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583858;
    v351[1].__shared_weak_owners_ = 0;
    v351[2].__vftable = 0;
    LODWORD(v351[2].__shared_owners_) = 0;
    v351[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55AE58;
    v351[1].__shared_owners_ = 0;
    *(void *)&long long v352 = 0x100000001;
    *((void *)&v352 + 1) = 0x100000001;
    *(_OWORD *)((char *)&v351[2].__shared_owners_ + 4) = v352;
    *(std::__shared_weak_count_vtbl **)((char *)&v351[3].__vftable + 4) = (std::__shared_weak_count_vtbl *)0x100000001;
    HIDWORD(v351[3].__shared_owners_) = 0;
    uint64_t v611 = (uint64_t)&v351[1];
    uint64_t v612 = (uint64_t)v351;
    if (*(_WORD *)(v324 + 12))
    {
      id v525 = v323;
      double v553 = v252;
      unint64_t v353 = 0;
      uint64_t v354 = v324 + 14;
      int16x8_t dataa = vdupq_n_s16(v329);
      int v567 = (int64x2_t *)v321;
      long long v556 = (void *)((char *)v321 + 48);
      uint64_t v528 = v324 + 16;
      uint64_t v574 = v324;
      uint64_t colorc = v324 + 14;
      while (1)
      {
        uint64_t v355 = (unsigned int *)(v354 + 145 * v353);
        uint64_t v356 = *v355;
        unint64_t v357 = v355[1];
        uint64_t v358 = *(void *)(v326 + 96);
        unint64_t v359 = *(void *)(v358 + 8);
        unint64_t v360 = (*(void *)(v358 + 48) - *(void *)(v358 + 40)) / v359;
        unint64_t v361 = v360 + (v357 >> 1);
        size_t v362 = v359 * v361;
        uint64_t v363 = *(void *)(v358 + 72);
        size_t v364 = *(void *)(v358 + 80) - v363;
        if (v359 * v361 != v364)
        {
          if (v359 * v361 <= v364)
          {
            if (v362 < v364) {
              *(void *)(v358 + 80) = v363 + v362;
            }
          }
          else
          {
            std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v358 + 72, v359 * v361 - v364);
          }
          float v365 = *(std::__shared_weak_count **)(v358 + 32);
          *(void *)(v358 + 24) = 0;
          *(void *)(v358 + 32) = 0;
          if (v365 && !atomic_fetch_add(&v365->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v365->__on_zero_shared)(v365);
            std::__shared_weak_count::__release_weak(v365);
          }
          *(void *)(v358 + 120) = 0;
          *(_DWORD *)(v358 + 112) = 0;
          uint64_t v363 = *(void *)(v358 + 72);
          uint64_t v366 = *(void *)(v358 + 80) - v363;
          *(void *)(v358 + 40) = 0;
          *(void *)(v358 + 48) = v366;
          *(void *)(v358 + 56) = 0;
          *(void *)(v358 + 64) = v366;
          unint64_t v359 = *(void *)(v358 + 8);
          size_t v362 = v359 * v361;
        }
        dest.height = 0;
        dest.data = 0;
        vImagePixelCount v367 = v359 * v360;
        *(void *)&long long v368 = 0;
        *((void *)&v368 + 1) = v358;
        uint64_t v369 = (int16x8_t *)(v363 + v367);
        if (v362 == v367) {
          uint64_t v369 = 0;
        }
        *(_OWORD *)&dest.data = v368;
        dest.vImagePixelCount width = v367;
        dest.size_t rowBytes = v362;
        v595 = (const char *)v369;
        LOWORD(v594) = 1;
        if (v357 >= 2)
        {
          if (v357 >> 1 <= 1) {
            unint64_t v370 = 1;
          }
          else {
            unint64_t v370 = v357 >> 1;
          }
          if (v370 <= 0xF || (unint64_t)v369 - v574 - v356 < 0x20)
          {
            unint64_t v371 = 0;
LABEL_416:
            unint64_t v372 = v370 - v371;
            uint64_t v373 = v371;
            size_t v374 = &v369->i16[v373];
            uint64_t v375 = (__int16 *)(v574 + v356 + v373 * 2);
            do
            {
              __int16 v376 = *v375++;
              *v374++ = v376 + v329;
              --v372;
            }
            while (v372);
            goto LABEL_418;
          }
          unint64_t v371 = v370 & 0x7FFFFFF0;
          unint64_t v395 = v369 + 1;
          unint64_t v396 = (int16x8_t *)(v528 + v356);
          unint64_t v397 = v371;
          do
          {
            int16x8_t v398 = vaddq_s16(*v396, dataa);
            v395[-1] = vaddq_s16(v396[-1], dataa);
            *unint64_t v395 = v398;
            v395 += 2;
            v396 += 2;
            v397 -= 16;
          }
          while (v397);
          if (v370 != v371) {
            goto LABEL_416;
          }
        }
LABEL_418:
        long long v610 = 0uLL;
        uint64_t v377 = colorc + 145 * v353;
        int v379 = *(_DWORD *)(v377 + 13);
        unint64_t v378 = (unsigned int *)(v377 + 13);
        if (v379)
        {
          int v380 = v567;
          float v381 = (void *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBytes:v574 + *(unsigned int *)(colorc + 145 * v353 + 9) length:*v378];
          uint64_t v382 = (std::__shared_weak_count *)v612;
          v608[0] = v611;
          v608[1] = v612;
          if (v612) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v612 + 8), 1uLL, memory_order_relaxed);
          }
          textureWithData(components, v381, v608, 1);
          long long v383 = *(_OWORD *)components;
          *(void *)components = 0;
          *(void *)&components[8] = 0;
          long long v610 = v383;
          if (v382 && !atomic_fetch_add(&v382->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v382->__on_zero_shared)(v382);
            std::__shared_weak_count::__release_weak(v382);
          }

          goto LABEL_452;
        }
        size_t v384 = strlen((const char *)(colorc + 145 * v353 + 17));
        if (v384 >= 0x7FFFFFFFFFFFFFF8) {
          abort();
        }
        size_t v385 = v384;
        if (v384 >= 0x17)
        {
          uint64_t v387 = (v384 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v384 | 7) != 0x17) {
            uint64_t v387 = v384 | 7;
          }
          uint64_t v388 = v387 + 1;
          unint64_t v386 = operator new(v387 + 1);
          *(void *)&components[8] = v385;
          *(void *)&components[16] = v388 | 0x8000000000000000;
          *(void *)components = v386;
LABEL_432:
          memmove(v386, (const void *)(colorc + 145 * v353 + 17), v385);
          goto LABEL_433;
        }
        components[23] = v384;
        unint64_t v386 = components;
        if (v384) {
          goto LABEL_432;
        }
LABEL_433:
        v386[v385] = 0;
        unint64_t v389 = v613;
        uint64_t v390 = (std::__shared_weak_count *)v612;
        v609[0] = v611;
        v609[1] = v612;
        if (v612) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v612 + 8), 1uLL, memory_order_relaxed);
        }
        md::TextureManager::texture(v607, v389, (uint64_t)components, v609, 0, v539);
        int v380 = v567;
        if (v390 && !atomic_fetch_add(&v390->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v390->__on_zero_shared)(v390);
          std::__shared_weak_count::__release_weak(v390);
          uint64_t v391 = v607[0];
          if (v607[0])
          {
LABEL_438:
            uint64_t v393 = v391[4];
            uint64_t v392 = v391[5];
            if (v392) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v392 + 8), 1uLL, memory_order_relaxed);
            }
            long long v394 = (std::__shared_weak_count *)*((void *)&v610 + 1);
            *(void *)&long long v610 = v393;
            *((void *)&v610 + 1) = v392;
            if (v394 && !atomic_fetch_add(&v394->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v394->__on_zero_shared)(v394);
              std::__shared_weak_count::__release_weak(v394);
            }
          }
        }
        else
        {
          uint64_t v391 = v607[0];
          if (v607[0]) {
            goto LABEL_438;
          }
        }
        long long v399 = (std::__shared_weak_count *)v607[1];
        if (!v607[1] || atomic_fetch_add((atomic_ullong *volatile)v607[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          if ((components[23] & 0x80000000) == 0) {
            goto LABEL_452;
          }
LABEL_451:
          operator delete(*(void **)components);
          goto LABEL_452;
        }
        ((void (*)(std::__shared_weak_count *))v399->__on_zero_shared)(v399);
        std::__shared_weak_count::__release_weak(v399);
        if ((components[23] & 0x80000000) != 0) {
          goto LABEL_451;
        }
LABEL_452:
        unint64_t v400 = (void *)v380[2].i64[0];
        unint64_t v401 = (void *)v380[2].i64[1];
        __int16 v402 = v400;
        if (v400 != v401)
        {
          __int16 v402 = (void *)v380[2].i64[0];
          while ((void)v610 != *v402)
          {
            v402 += 5;
            if (v402 == v401) {
              goto LABEL_458;
            }
          }
        }
        if (v402 == v401)
        {
LABEL_458:
          memset(v607, 0, sizeof(v607));
          if (v400 == v401)
          {
            __int16 v402 = v400;
          }
          else
          {
            __int16 v402 = v400;
            while ((void)v610 != *v402)
            {
              v402 += 5;
              if (v402 == v401) {
                goto LABEL_465;
              }
            }
          }
          if (v402 == v401)
          {
LABEL_465:
            if ((unint64_t)v401 >= *v556)
            {
              unint64_t v404 = 0xCCCCCCCCCCCCCCCDLL * (v401 - v400);
              if (v404 + 1 > 0x666666666666666) {
                abort();
              }
              unint64_t v405 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*v556 - (void)v400) >> 3);
              uint64_t v406 = 2 * v405;
              if (2 * v405 <= v404 + 1) {
                uint64_t v406 = v404 + 1;
              }
              if (v405 >= 0x333333333333333) {
                unint64_t v407 = 0x666666666666666;
              }
              else {
                unint64_t v407 = v406;
              }
              v625 = v556;
              if (v407)
              {
                if (v407 > 0x666666666666666) {
                  goto LABEL_665;
                }
                long long v408 = (char *)operator new(40 * v407);
              }
              else
              {
                long long v408 = 0;
              }
              long long v409 = &v408[40 * v404];
              *(void *)components = v408;
              *(void *)&components[8] = v409;
              *(void *)&components[16] = v409;
              *(void *)&components[24] = &v408[40 * v407];
              uint64_t v410 = *((void *)&v610 + 1);
              *(void *)long long v409 = v610;
              *((void *)v409 + 1) = v410;
              if (v410) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v410 + 8), 1uLL, memory_order_relaxed);
              }
              long long v411 = &v408[40 * v404];
              *((void *)v411 + 2) = 0;
              *((void *)v411 + 3) = 0;
              v411 += 16;
              *((void *)v411 + 2) = 0;
              std::vector<std::pair<ggl::Landmark::LandmarkMesh *,std::vector<md::ObjectGroupFeatureRange>>>::__init_with_size[abi:nn180100]<std::pair<ggl::Landmark::LandmarkMesh *,std::vector<md::ObjectGroupFeatureRange>>*,std::pair<ggl::Landmark::LandmarkMesh *,std::vector<md::ObjectGroupFeatureRange>>*>(v411, 0, 0, 0);
              unint64_t v412 = *(void **)&components[8];
              uint64_t v413 = *(void *)&components[16] + 40;
              *(void *)&components[16] += 40;
              uint64_t v415 = v567[2].i64[0];
              unint64_t v414 = v567[2].u64[1];
              if (v414 == v415)
              {
                int64x2_t v417 = vdupq_n_s64(v414);
              }
              else
              {
                do
                {
                  long long v416 = *(_OWORD *)(v414 - 40);
                  v414 -= 40;
                  *(_OWORD *)(v412 - 5) = v416;
                  v412 -= 5;
                  *(void *)unint64_t v414 = 0;
                  *(void *)(v414 + 8) = 0;
                  v412[2] = 0;
                  void v412[3] = 0;
                  v412[4] = 0;
                  *((_OWORD *)v412 + 1) = *(_OWORD *)(v414 + 16);
                  v412[4] = *(void *)(v414 + 32);
                  *(void *)(v414 + 16) = 0;
                  *(void *)(v414 + 24) = 0;
                  *(void *)(v414 + 32) = 0;
                }
                while (v414 != v415);
                int64x2_t v417 = v567[2];
                uint64_t v413 = *(void *)&components[16];
              }
              v567[2].i64[0] = (uint64_t)v412;
              v567[2].i64[1] = v413;
              *(int64x2_t *)&components[8] = v417;
              uint64_t v418 = v567[3].i64[0];
              v567[3].i64[0] = *(void *)&components[24];
              *(void *)&components[24] = v418;
              *(void *)components = v417.i64[0];
              std::__split_buffer<std::pair<std::shared_ptr<ggl::Texture2D>,geo::linear_map<ggl::Landmark::LandmarkMesh *,std::vector<md::ObjectGroupFeatureRange>,std::equal_to<ggl::Landmark::LandmarkMesh *>,std::allocator<std::pair<ggl::Landmark::LandmarkMesh *,std::vector<md::ObjectGroupFeatureRange>>>,std::vector<std::pair<ggl::Landmark::LandmarkMesh *,std::vector<md::ObjectGroupFeatureRange>>>>>>::~__split_buffer((uint64_t)components);
              unint64_t v419 = (char *)v607[0];
              v567[2].i64[1] = v413;
              __int16 v402 = (void *)(v413 - 40);
              if (v419)
              {
                for (unint64_t m = (char *)v607[1]; m != v419; m -= 32)
                {
                  BOOL v421 = (void *)*((void *)m - 3);
                  if (v421)
                  {
                    *((void *)m - 2) = v421;
                    operator delete(v421);
                  }
                }
                v607[1] = v419;
                operator delete(v419);
              }
            }
            else
            {
              *unint64_t v401 = v610;
              uint64_t v403 = *((void *)&v610 + 1);
              v401[1] = *((void *)&v610 + 1);
              if (v403) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v403 + 8), 1uLL, memory_order_relaxed);
              }
              v401[2] = 0;
              v401[3] = 0;
              v401[4] = 0;
              std::vector<std::pair<ggl::Landmark::LandmarkMesh *,std::vector<md::ObjectGroupFeatureRange>>>::__init_with_size[abi:nn180100]<std::pair<ggl::Landmark::LandmarkMesh *,std::vector<md::ObjectGroupFeatureRange>>*,std::pair<ggl::Landmark::LandmarkMesh *,std::vector<md::ObjectGroupFeatureRange>>*>(v401 + 2, 0, 0, 0);
              v567[2].i64[1] = (uint64_t)(v401 + 5);
              __int16 v402 = v401;
            }
          }
        }
        uint64_t v422 = (char *)v402[2];
        uint64_t v423 = (char *)v402[3];
        unint64_t v424 = v422;
        if (v422 != v423)
        {
          unint64_t v424 = (char *)v402[2];
          while (v326 != *(void *)v424)
          {
            v424 += 32;
            if (v424 == v423) {
              goto LABEL_500;
            }
          }
        }
        if (v424 == v423)
        {
LABEL_500:
          unint64_t v424 = (char *)v402[2];
          if (v422 != v423)
          {
            unint64_t v424 = (char *)v402[2];
            while (v326 != *(void *)v424)
            {
              v424 += 32;
              if (v424 == v423) {
                goto LABEL_506;
              }
            }
          }
          if (v424 == v423)
          {
LABEL_506:
            unint64_t v425 = v402[4];
            if ((unint64_t)v423 >= v425)
            {
              uint64_t v427 = (v423 - v422) >> 5;
              unint64_t v428 = v427 + 1;
              if ((unint64_t)(v427 + 1) >> 59) {
                abort();
              }
              uint64_t v429 = v425 - (void)v422;
              if (v429 >> 4 > v428) {
                unint64_t v428 = v429 >> 4;
              }
              if ((unint64_t)v429 >= 0x7FFFFFFFFFFFFFE0) {
                unint64_t v430 = 0x7FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v430 = v428;
              }
              v625 = v402 + 4;
              if (v430)
              {
                if (v430 >> 59) {
                  goto LABEL_665;
                }
                unint64_t v431 = (char *)operator new(32 * v430);
              }
              else
              {
                unint64_t v431 = 0;
              }
              uint64_t v432 = &v431[32 * v427];
              *(void *)components = v431;
              *(void *)&components[8] = v432;
              *(void *)uint64_t v432 = v326;
              *((void *)v432 + 1) = 0;
              *((void *)v432 + 2) = 0;
              *((void *)v432 + 3) = 0;
              v426 = v432 + 32;
              *(void *)&components[16] = v432 + 32;
              *(void *)&components[24] = &v431[32 * v430];
              if (v422 == v423)
              {
                v402[2] = v432;
                v402[3] = v426;
                v402[4] = &v431[32 * v430];
              }
              else
              {
                uint64_t v433 = 0;
                do
                {
                  uint64_t v434 = &v432[v433];
                  uint64_t v435 = &v423[v433];
                  *((void *)v434 - 4) = *(void *)&v423[v433 - 32];
                  *((void *)v434 - 2) = 0;
                  *((void *)v434 - 1) = 0;
                  *(_OWORD *)(v434 - 24) = *(_OWORD *)&v423[v433 - 24];
                  *((void *)v434 - 1) = *(void *)&v423[v433 - 8];
                  *((void *)v435 - 3) = 0;
                  *((void *)v435 - 2) = 0;
                  *((void *)v435 - 1) = 0;
                  v433 -= 32;
                }
                while (&v423[v433] != v422);
                uint64_t v422 = (char *)v402[2];
                unint64_t v436 = (char *)v402[3];
                long long v437 = *(_OWORD *)&components[16];
                v402[2] = &v432[v433];
                *(_OWORD *)(v402 + 3) = v437;
                v426 = (void *)v437;
                while (v436 != v422)
                {
                  uint64_t v438 = (void *)*((void *)v436 - 3);
                  if (v438)
                  {
                    *((void *)v436 - 2) = v438;
                    operator delete(v438);
                  }
                  v436 -= 32;
                }
              }
              if (v422) {
                operator delete(v422);
              }
            }
            else
            {
              *(void *)uint64_t v423 = v326;
              *((void *)v423 + 1) = 0;
              *((void *)v423 + 2) = 0;
              *((void *)v423 + 3) = 0;
              v426 = v423 + 32;
              v402[3] = v423 + 32;
            }
            v402[3] = v426;
            unint64_t v424 = (char *)(v426 - 4);
          }
        }
        uint64_t v440 = (unint64_t *)*((void *)v424 + 2);
        unint64_t v439 = *((void *)v424 + 3);
        if ((unint64_t)v440 >= v439)
        {
          uint64_t v442 = (void *)*((void *)v424 + 1);
          unint64_t v443 = 0xAAAAAAAAAAAAAAABLL * (v440 - v442) + 1;
          if (v443 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          unint64_t v444 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v439 - (void)v442) >> 3);
          if (2 * v444 > v443) {
            unint64_t v443 = 2 * v444;
          }
          if (v444 >= 0x555555555555555) {
            unint64_t v445 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v445 = v443;
          }
          if (v445)
          {
            if (v445 > 0xAAAAAAAAAAAAAAALL) {
              goto LABEL_665;
            }
            unint64_t v446 = (char *)operator new(24 * v445);
          }
          else
          {
            unint64_t v446 = 0;
          }
          unint64_t v447 = &v446[8 * (v440 - v442)];
          *(void *)unint64_t v447 = v360;
          *((void *)v447 + 1) = v361;
          *((void *)v447 + 2) = v562;
          uint64_t v448 = v447;
          if (v440 != v442)
          {
            do
            {
              long long v449 = *(_OWORD *)(v440 - 3);
              *((void *)v448 - 1) = *(v440 - 1);
              *(_OWORD *)(v448 - 24) = v449;
              v448 -= 24;
              v440 -= 3;
            }
            while (v440 != v442);
            uint64_t v440 = (unint64_t *)*((void *)v424 + 1);
          }
          unint64_t v441 = v447 + 24;
          *((void *)v424 + 1) = v448;
          *((void *)v424 + 2) = v447 + 24;
          *((void *)v424 + 3) = &v446[24 * v445];
          if (v440) {
            operator delete(v440);
          }
        }
        else
        {
          unint64_t *v440 = v360;
          v440[1] = v361;
          unint64_t v441 = v440 + 3;
          v440[2] = (unint64_t)v562;
        }
        *((void *)v424 + 2) = v441;
        uint64_t v450 = (std::__shared_weak_count *)*((void *)&v610 + 1);
        if (*((void *)&v610 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v610 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v450->__on_zero_shared)(v450);
          std::__shared_weak_count::__release_weak(v450);
          if (v595)
          {
LABEL_550:
            vImagePixelCount width = dest.width;
            size_t rowBytes = dest.rowBytes;
            if (dest.rowBytes != dest.width)
            {
              unint64_t v453 = (void *)dest.height;
              int v454 = v594;
              int v455 = BYTE1(v594);
              if (dest.data && *(unsigned char *)(dest.height + 17) != 2) {
                (*(void (**)(void))(*(void *)dest.data + 64))();
              }
              if (v454 && !v455)
              {
                vImagePixelCount v456 = v453[7];
                size_t v457 = v453[8];
                if (v457 == v456) {
                  vImagePixelCount v456 = v453[10] - v453[9];
                }
                if (width < v456) {
                  vImagePixelCount v456 = width;
                }
                if (v457 <= rowBytes) {
                  size_t v457 = rowBytes;
                }
                if (v457 == v456) {
                  size_t v457 = v456 + v453[10] - v453[9];
                }
                v453[7] = v456;
                v453[8] = v457;
              }
            }
          }
        }
        else if (v595)
        {
          goto LABEL_550;
        }
        ++v353;
        uint64_t v354 = colorc;
        if (v353 >= *(unsigned __int16 *)(v574 + 12))
        {
          uint64_t v351 = (std::__shared_weak_count *)v612;
          size_t v252 = v553;
          id v323 = v525;
          if (v612) {
            break;
          }
LABEL_568:
          unint64_t v458 = v614;
          if (!v614) {
            goto LABEL_572;
          }
LABEL_571:
          if (atomic_fetch_add(&v458->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_572;
          }
          ((void (*)(std::__shared_weak_count *))v458->__on_zero_shared)(v458);
          std::__shared_weak_count::__release_weak(v458);
          if (!*(void *)&src[40]) {
            goto LABEL_589;
          }
LABEL_573:
          unint64_t v459 = *(void *)&src[16];
          unint64_t v460 = *(void *)&src[24];
          if (*(void *)&src[24] != *(void *)&src[16])
          {
            unint64_t v461 = *(void **)&src[8];
            int v462 = src[32];
            int v463 = src[33];
            if (*(void *)src && *(unsigned char *)(*(void *)&src[8] + 17) != 2) {
              (*(void (**)(void))(**(void **)src + 64))();
            }
            if (v462 && !v463)
            {
              unint64_t v464 = v461[7];
              unint64_t v465 = v461[8];
              if (v465 == v464) {
                unint64_t v464 = v461[10] - v461[9];
              }
              if (v459 < v464) {
                unint64_t v464 = v459;
              }
              if (v465 <= v460) {
                unint64_t v465 = v460;
              }
              if (v465 == v464) {
                unint64_t v465 = v464 + v461[10] - v461[9];
              }
              v461[7] = v464;
              v461[8] = v465;
            }
          }
          goto LABEL_589;
        }
      }
    }
    if (atomic_fetch_add(&v351->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_568;
    }
    ((void (*)(std::__shared_weak_count *))v351->__on_zero_shared)(v351);
    std::__shared_weak_count::__release_weak(v351);
    unint64_t v458 = v614;
    if (v614) {
      goto LABEL_571;
    }
LABEL_572:
    if (*(void *)&src[40]) {
      goto LABEL_573;
    }
LABEL_589:

    geo::A3DFileDelete(v538, v466);
    uint64_t v315 = v535 + 4;
    if (v535 + 4 != v526) {
      continue;
    }
    break;
  }
  uint64_t v315 = (geo **)v602;
LABEL_591:
  long long v467 = v559;
LABEL_593:
  *(_OWORD *)obunint64_t j = *(_OWORD *)v605;
  uint64_t v468 = v606;
  v606 = 0;
  v605[1] = 0;
  v605[0] = 0;
  long long v587 = v467;
  long long v586 = v468;
  long long v588 = v252;
  *(void *)src = &v599;
  std::vector<altitude::QuickSurfaceManager::Tile>::__destroy_vector::operator()[abi:nn180100]((void ***)src);
  if (v315)
  {
    uint64_t v469 = v603;
    uint64_t v470 = v315;
    unint64_t v471 = v315;
    if (v603 != v315)
    {
      do
      {
        unint64_t v472 = (std::__shared_weak_count *)*(v469 - 2);
        if (v472 && !atomic_fetch_add(&v472->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v472->__on_zero_shared)(v472);
          std::__shared_weak_count::__release_weak(v472);
        }
        v469 -= 4;
      }
      while (v469 != v471);
      uint64_t v470 = v602;
    }
    v603 = v471;
    operator delete(v470);
  }
  uint64_t v473 = (char *)v605[0];
  if (v605[0])
  {
    unint64_t v474 = (char *)v605[1];
    if (v605[1] != v605[0])
    {
      do
      {
        uint64_t v475 = (std::__shared_weak_count *)*((void *)v474 - 1);
        if (v475 && !atomic_fetch_add(&v475->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v475->__on_zero_shared)(v475);
          std::__shared_weak_count::__release_weak(v475);
        }
        v474 -= 16;
      }
      while (v474 != v473);
      uint64_t v473 = (char *)v605[0];
    }
    operator delete(v473);
  }

  BOOL v476 = (char *)operator new(0x3F0uLL);
  *((void *)v476 + 1) = 0;
  *((void *)v476 + 2) = 0;
  *(void *)BOOL v476 = &unk_1EF5801A8;
  md::MapTileData::MapTileData((uint64_t)(v476 + 24), a2, (uint64_t)v582, (uint64_t *)v536, 1);
  *((void *)v476 + 3) = &unk_1EF535FB0;
  *((void *)v476 + 82) = &unk_1EF535FF0;
  *(_OWORD *)(v476 + 744) = *(_OWORD *)v575;
  *((void *)v476 + 95) = v576;
  v575[0] = 0;
  v575[1] = 0;
  float v576 = 0;
  *((_DWORD *)v476 + 192) = 0;
  *((float *)v476 + 193) = v549;
  *((_DWORD *)v476 + 194) = 0;
  *((float *)v476 + 195) = v548;
  *((_DWORD *)v476 + 196) = 0;
  *((float *)v476 + 197) = v547;
  *((_DWORD *)v476 + 198) = 0;
  *((float *)v476 + 199) = v546;
  *((_DWORD *)v476 + 200) = 0;
  *((float *)v476 + 201) = v545;
  *((_DWORD *)v476 + 202) = 0;
  *((float *)v476 + 203) = v544;
  *((_DWORD *)v476 + 204) = 0;
  *((float *)v476 + 205) = v543;
  *((_DWORD *)v476 + 206) = 0;
  *((float *)v476 + 207) = v542;
  *((_DWORD *)v476 + 208) = 0;
  *((float *)v476 + 209) = v541;
  *((_DWORD *)v476 + 210) = 0;
  *((float *)v476 + 211) = v540;
  *((_DWORD *)v476 + 212) = 0;
  *((float *)v476 + 213) = v33;
  *((_DWORD *)v476 + 214) = 0;
  *((float *)v476 + 215) = v34;
  *((_DWORD *)v476 + 216) = 0;
  *((float *)v476 + 217) = v35;
  *((_DWORD *)v476 + 218) = 0;
  *((float *)v476 + 219) = v36;
  *((_DWORD *)v476 + 220) = 0;
  *((float *)v476 + 221) = v37;
  *((_DWORD *)v476 + 222) = 0;
  *((float *)v476 + 223) = v38;
  *((_OWORD *)v476 + 56) = *(_OWORD *)v578;
  *((void *)v476 + 114) = v579;
  v578[1] = 0;
  float64x2_t v579 = 0;
  v578[0] = 0;
  *((void *)v476 + 115) = 0;
  *((void *)v476 + 116) = *(void *)(v520 + 144);
  uint64_t v477 = *(void *)(v520 + 152);
  *((void *)v476 + 117) = v477;
  if (v477) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v477 + 8), 1uLL, memory_order_relaxed);
  }
  *((_OWORD *)v476 + 59) = v518;
  *((void *)v476 + 120) = 0;
  *((void *)v476 + 122) = 0;
  *((void *)v476 + 121) = 0;
  unint64_t v478 = obj[0];
  unint64_t v479 = obj[1];
  int64_t v480 = (char *)obj[1] - (char *)obj[0];
  if (obj[1] != obj[0])
  {
    if (v480 < 0) {
      abort();
    }
    unint64_t v481 = operator new((char *)obj[1] - (char *)obj[0]);
    *((void *)v476 + 120) = v481;
    *((void *)v476 + 121) = v481;
    *((void *)v476 + 122) = &v481[2 * (v480 >> 4)];
    uint64_t v482 = v478;
    do
    {
      *unint64_t v481 = *v482;
      uint64_t v483 = v482[1];
      v481[1] = v483;
      if (v483) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v483 + 8), 1uLL, memory_order_relaxed);
      }
      v481 += 2;
      v482 += 2;
    }
    while (v482 != v479);
    *((void *)v476 + 121) = v481;
  }
  *((void *)v476 + 125) = 0;
  *(_OWORD *)(v476 + 984) = 0u;
  uint64_t v484 = (void *)v587;
  uint64_t v485 = *((void *)&v587 + 1) - v587;
  if (*((void *)&v587 + 1) != (void)v587)
  {
    if (0x84BDA12F684BDA13 * (v485 >> 4) > 0x97B425ED097B42) {
      abort();
    }
    unint64_t v486 = (char *)operator new(*((void *)&v587 + 1) - v587);
    *((void *)v476 + 123) = v486;
    *((void *)v476 + 124) = v486;
    *((void *)v476 + 125) = &v486[16 * (v485 >> 4)];
    size_t v487 = 432 * ((v485 - 432) / 0x1B0uLL) + 432;
    memcpy(v486, v484, v487);
    *((void *)v476 + 124) = &v486[v487];
  }
  int v488 = 1 << v476[193];
  double v489 = 1.0 / (double)v488;
  long double v490 = exp(v489 * 6.28318531 * ((double)(v488 + ~*((_DWORD *)v476 + 49)) + 0.5) + -3.14159265);
  long double v491 = atan(v490) * 114.591559 + -90.0;
  long double v492 = cos(v491 * 0.034906585) * -559.82 + 111132.92;
  long double v493 = v492 + cos(v491 * 0.0698131701) * 1.175;
  long double v494 = v493 + cos(v491 * 0.104719755) * -0.0023;
  long double v495 = v491 * 0.00872664626;
  long double v496 = tan(v491 * 0.00872664626 + 0.78103484);
  double v497 = log(v496);
  long double v498 = tan(v495 + 0.789761487);
  long double v499 = log(v498);
  *(void *)src = 0;
  *(double *)&dest.data = v494 * v489 / fabs((v499 - v497) * 0.159154943);
  gdc::Tiled::setZBoundsInMeters((unsigned __int8 *)v476 + 192, (double *)src, (double *)&dest);
  *a4 = v476 + 24;
  a4[1] = v476;
  if (v484)
  {
    *((void *)&v587 + 1) = v484;
    operator delete(v484);
  }
  if (v478)
  {
    if (v479 != v478)
    {
      do
      {
        unint64_t v500 = (std::__shared_weak_count *)*(v479 - 1);
        if (v500 && !atomic_fetch_add(&v500->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v500->__on_zero_shared)(v500);
          std::__shared_weak_count::__release_weak(v500);
        }
        v479 -= 2;
      }
      while (v479 != v478);
      unint64_t v478 = obj[0];
    }
    operator delete(v478);
  }
  uint64_t v501 = (void **)v575[0];
  if (v575[0])
  {
    unint64_t v502 = (void **)v575[1];
    uint64_t v503 = v575[0];
    if (v575[1] != v575[0])
    {
      BOOL v504 = (void **)v575[1];
      do
      {
        uint64_t v506 = (char *)*(v504 - 3);
        v504 -= 3;
        v505 = v506;
        if (v506)
        {
          unint64_t v507 = (char *)*(v502 - 2);
          uint64_t v508 = v505;
          if (v507 != v505)
          {
            v509 = v507 - 24;
            v510 = v507 - 24;
            uint64_t v511 = v507 - 24;
            do
            {
              uint64_t v512 = *(void (***)(char *))v511;
              v511 -= 24;
              (*v512)(v510);
              v509 -= 24;
              _ZF = v510 == v505;
              v510 = v511;
            }
            while (!_ZF);
            uint64_t v508 = *v504;
          }
          *(v502 - 2) = v505;
          operator delete(v508);
        }
        unint64_t v502 = v504;
      }
      while (v504 != v501);
      uint64_t v503 = v575[0];
    }
    v575[1] = v501;
    operator delete(v503);
  }
  v513 = (char *)v578[0];
  if (v578[0])
  {
    uint64_t v514 = (char *)v578[1];
    if (v578[1] != v578[0])
    {
      do
      {
        double v515 = (std::__shared_weak_count *)*((void *)v514 - 1);
        if (v515 && !atomic_fetch_add(&v515->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v515->__on_zero_shared)(v515);
          std::__shared_weak_count::__release_weak(v515);
        }
        v514 -= 16;
      }
      while (v514 != v513);
      v513 = (char *)v578[0];
    }
    operator delete(v513);
  }
  float32x2_t v516 = v581;
  if (v581 && !atomic_fetch_add(&v581->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v516->__on_zero_shared)(v516);
    std::__shared_weak_count::__release_weak(v516);
  }
  if (v582[0]) {
    operator delete(v582[0]);
  }
  uint64_t v517 = v584;
  if (v584 && !atomic_fetch_add(&v584->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v517->__on_zero_shared)(v517);
    std::__shared_weak_count::__release_weak(v517);
  }
}

void sub_1A25A2434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void **a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  a71 = a27;

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&STACK[0x2D8]);
  _Block_object_dispose(&STACK[0x240], 8);
  char v72 = (void *)STACK[0x270];
  if (STACK[0x270])
  {
    STACK[0x278] = (unint64_t)v72;
    operator delete(v72);
  }

  md::Triangulator<float>::~Triangulator((uint64_t)&STACK[0x340]);
  std::vector<std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>::~vector[abi:nn180100](&a55);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)&a61);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a64);
  if (a66) {
    operator delete(a66);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a69);
  _Unwind_Resume(a1);
}

void ***std::vector<std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>::~vector[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    double v3 = a1[1];
    double v4 = *a1;
    if (v3 != v2)
    {
      float v5 = a1[1];
      do
      {
        uint64_t v7 = (char *)*(v5 - 3);
        v5 -= 3;
        float v6 = v7;
        if (v7)
        {
          uint64_t v8 = (char *)*(v3 - 2);
          int v9 = v6;
          if (v8 != v6)
          {
            uint64_t v10 = v8 - 24;
            float v11 = v8 - 24;
            int v12 = v8 - 24;
            do
            {
              uint64_t v13 = *(void (***)(char *))v12;
              v12 -= 24;
              (*v13)(v11);
              v10 -= 24;
              BOOL v14 = v11 == v6;
              float v11 = v12;
            }
            while (!v14);
            int v9 = *v5;
          }
          *(v3 - 2) = v6;
          operator delete(v9);
        }
        double v3 = v5;
      }
      while (v5 != v2);
      double v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<md::BuildingTileData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::BuildingTileData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5801A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::BuildingTileData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5801A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void **std::vector<std::pair<void *,std::pair<std::shared_ptr<md::ObjectGroup>,unsigned long long>>>::~vector[abi:nn180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    double v3 = (char *)a1[1];
    double v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        float v5 = (std::__shared_weak_count *)*((void *)v3 - 2);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 32;
      }
      while (v3 != v2);
      double v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void ggl::MeshVendor<ggl::Landmark::LandmarkMesh>::_allocateNewMesh()
{
}

void std::__shared_ptr_emplace<md::ObjectGroup>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 104);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    double v3 = *(std::__shared_weak_count **)(a1 + 88);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    double v3 = *(std::__shared_weak_count **)(a1 + 88);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = *(void *)(a1 + 56);
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 64);
    float v6 = *(void **)(a1 + 56);
    if (v5 != v4)
    {
      do
      {
        uint64_t v7 = *(void *)(v5 - 24);
        if (v7)
        {
          uint64_t v8 = *(void *)(v5 - 16);
          int v9 = *(void **)(v5 - 24);
          if (v8 != v7)
          {
            do
            {
              uint64_t v10 = *(void **)(v8 - 24);
              if (v10)
              {
                *(void *)(v8 - 16) = v10;
                operator delete(v10);
              }
              v8 -= 32;
            }
            while (v8 != v7);
            int v9 = *(void **)(v5 - 24);
          }
          *(void *)(v5 - 16) = v7;
          operator delete(v9);
        }
        float v11 = *(std::__shared_weak_count **)(v5 - 32);
        if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
        v5 -= 40;
      }
      while (v5 != v4);
      float v6 = *(void **)(a1 + 56);
    }
    *(void *)(a1 + 64) = v4;
    operator delete(v6);
  }
  int v12 = *(void **)(a1 + 24);
  if (v12)
  {
    uint64_t v13 = *(void **)(a1 + 32);
    uint64_t v14 = *(void *)(a1 + 24);
    while (v13 != v12)
    {
      uint64_t v16 = *--v13;
      uint64_t v15 = v16;
      *uint64_t v13 = 0;
      if (v16) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 8))(v15, v14);
      }
    }
    *(void *)(a1 + 32) = v12;
    uint64_t v17 = *(void (**)(void))(**(void **)(a1 + 48) + 40);
    v17();
  }
}

void std::__shared_ptr_emplace<md::ObjectGroup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F878;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::ObjectGroup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F878;
  std::__shared_weak_count::~__shared_weak_count(this);
}

CGColorSpaceRef ___ZL20_grayscaleColorSpacev_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateDeviceGray();
  _grayscaleColorSpace(void)::colorspace = (uint64_t)result;
  return result;
}

void std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::reserve(void **a1)
{
  uint64_t v1 = (char *)a1[2];
  if (v1 != *a1) {
    return;
  }
  double v3 = (id *)a1[1];
  uint64_t v4 = ((char *)v3 - (unsigned char *)*a1) / 24;
  uint64_t v5 = (char *)operator new(0x18uLL);
  float v6 = &v5[24 * v4];
  uint64_t v7 = v5 + 24;
  if (v3 == (id *)v1)
  {
    *a1 = v6;
    a1[1] = v6;
    a1[2] = v7;
    if (!v1) {
      return;
    }
    goto LABEL_13;
  }
  uint64_t v8 = (uint64_t)&v5[24 * v4 - 24];
  int v9 = &v5[24 * v4];
  do
  {
    *((void *)v9 - 3) = &unk_1EF559618;
    v9 -= 24;
    *((void *)v9 + 1) = 0;
    objc_storeStrong((id *)v9 + 1, *(v3 - 2));
    uint64_t v10 = *(v3 - 2);
    *(v3 - 2) = 0;

    v8 -= 24;
    v3 -= 3;
  }
  while (v3 != (id *)v1);
  uint64_t v1 = (char *)*a1;
  float v11 = (char *)a1[1];
  *a1 = v9;
  a1[1] = v6;
  a1[2] = v7;
  if (v11 != v1)
  {
    int v12 = v11 - 24;
    uint64_t v13 = v11 - 24;
    uint64_t v14 = v11 - 24;
    do
    {
      uint64_t v15 = *(void (***)(char *))v14;
      v14 -= 24;
      (*v15)(v13);
      v12 -= 24;
      BOOL v16 = v13 == v1;
      uint64_t v13 = v14;
    }
    while (!v16);
  }
  if (v1)
  {
LABEL_13:
    operator delete(v1);
  }
}

__n128 __Block_byref_object_copy__38271(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__38272(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

uint64_t *std::__introsort<std::_ClassicAlgPolicy,_buildMeshes(std::vector<std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>> &,ggl::CullingGridWithHeight &,md::Triangulator<float> &,ggl::Device *,BOOL,std::shared_ptr<md::GEOVectorTileResource> const&,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&,float,geo::QuadTile const&)::$_0 &,std::pair<GeoCodecsBuildingFootprintFeature *,unsigned char> *,false>(uint64_t *result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = (unint64_t)result;
LABEL_2:
  uint64_t v10 = (uint64_t *)(a2 - 16);
  float v11 = (unsigned char *)(a2 - 8);
  float v160 = (unsigned __int8 *)(a2 - 24);
  int v12 = (unsigned __int8 *)(a2 - 40);
  unint64_t v13 = v9;
  while (1)
  {
    unint64_t v9 = v13;
    uint64_t v14 = a2 - v13;
    uint64_t v15 = (uint64_t)(a2 - v13) >> 4;
    if (v5 || !v4)
    {
      switch(v15)
      {
        case 0:
        case 1:
          return result;
        case 2:
          if (*v11 < *(unsigned __int8 *)(v13 + 8))
          {
            uint64_t v93 = *(void *)v13;
            *(void *)unint64_t v13 = *v10;
            *uint64_t v10 = v93;
            LOBYTE(v93) = *(unsigned char *)(v13 + 8);
            *(unsigned char *)(v13 + 8) = *v11;
            unsigned char *v11 = v93;
          }
          return result;
        case 3:
          unsigned int v94 = (char *)(v13 + 8);
          unsigned int v95 = *(unsigned __int8 *)(v13 + 8);
          int v96 = (char *)(v13 + 24);
          unsigned int v97 = *(unsigned __int8 *)(v13 + 24);
          unsigned int v98 = *v11;
          if (v97 >= v95)
          {
            if (v98 >= v97) {
              return result;
            }
            uint64_t v151 = *(void *)(v13 + 16);
            *(void *)(v13 + 16) = *v10;
            *uint64_t v10 = v151;
            LOBYTE(v151) = *(unsigned char *)(v13 + 24);
            *(unsigned char *)(v13 + 24) = *v11;
            unsigned char *v11 = v151;
            if (*(unsigned __int8 *)(v13 + 24) >= *(unsigned __int8 *)(v13 + 8)) {
              return result;
            }
            uint64_t v152 = *(void *)v13;
            *(void *)unint64_t v13 = *(void *)(v13 + 16);
            *(void *)(v13 + 16) = v152;
          }
          else
          {
            uint64_t v99 = *(void *)v13;
            if (v98 >= v97)
            {
              *(void *)unint64_t v13 = *(void *)(v13 + 16);
              *(void *)(v13 + 16) = v99;
              *(unsigned char *)(v13 + 8) = v97;
              *(unsigned char *)(v13 + 24) = v95;
              if (*v11 >= v95) {
                return result;
              }
              *(void *)(v13 + 16) = *v10;
              *uint64_t v10 = v99;
              unsigned int v94 = (char *)(v13 + 24);
            }
            else
            {
              *(void *)unint64_t v13 = *v10;
              *uint64_t v10 = v99;
            }
            int v96 = (char *)(a2 - 8);
          }
          char v159 = *v94;
          *unsigned int v94 = *v96;
          *int v96 = v159;
          return result;
        case 4:
          return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,_buildMeshes(std::vector<std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>> &,ggl::CullingGridWithHeight &,md::Triangulator<float> &,ggl::Device *,BOOL,std::shared_ptr<md::GEOVectorTileResource> const&,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&,float,geo::QuadTile const&)::$_0 &,std::pair<GeoCodecsBuildingFootprintFeature *,unsigned char> *>((uint64_t *)v13, (uint64_t *)(v13 + 16), (uint64_t *)(v13 + 32), (uint64_t *)(a2 - 16));
        case 5:
          __n128 result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,_buildMeshes(std::vector<std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>> &,ggl::CullingGridWithHeight &,md::Triangulator<float> &,ggl::Device *,BOOL,std::shared_ptr<md::GEOVectorTileResource> const&,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&,float,geo::QuadTile const&)::$_0 &,std::pair<GeoCodecsBuildingFootprintFeature *,unsigned char> *>((uint64_t *)v13, (uint64_t *)(v13 + 16), (uint64_t *)(v13 + 32), (uint64_t *)(v13 + 48));
          if (*v11 < *(unsigned __int8 *)(v13 + 56))
          {
            uint64_t v100 = *(void *)(v13 + 48);
            *(void *)(v13 + 48) = *v10;
            *uint64_t v10 = v100;
            LOBYTE(v100) = *(unsigned char *)(v13 + 56);
            *(unsigned char *)(v13 + 56) = *v11;
            unsigned char *v11 = v100;
            unsigned int v101 = *(unsigned __int8 *)(v13 + 56);
            unsigned int v102 = *(unsigned __int8 *)(v13 + 40);
            if (v101 < v102)
            {
              uint64_t v103 = *(void *)(v13 + 32);
              uint64_t v104 = *(void *)(v13 + 48);
              *(void *)(v13 + 32) = v104;
              *(void *)(v13 + 48) = v103;
              *(unsigned char *)(v13 + 40) = v101;
              *(unsigned char *)(v13 + 56) = v102;
              unsigned int v105 = *(unsigned __int8 *)(v13 + 24);
              if (v101 < v105)
              {
                uint64_t v106 = *(void *)(v13 + 16);
                *(void *)(v13 + 16) = v104;
                *(void *)(v13 + 32) = v106;
                *(unsigned char *)(v13 + 24) = v101;
                *(unsigned char *)(v13 + 40) = v105;
                unsigned int v107 = *(unsigned __int8 *)(v13 + 8);
                if (v101 < v107)
                {
                  uint64_t v108 = *(void *)v13;
                  *(void *)unint64_t v13 = v104;
                  *(void *)(v13 + 16) = v108;
                  *(unsigned char *)(v13 + 8) = v101;
                  *(unsigned char *)(v13 + 24) = v107;
                }
              }
            }
          }
          return result;
        default:
          JUMPOUT(0);
      }
    }
    if (v14 <= 383) {
      break;
    }
    if (!a3)
    {
      if (v13 != a2)
      {
        int64_t v120 = (unint64_t)(v15 - 2) >> 1;
        int64_t v121 = v120;
        do
        {
          if (v120 >= v121)
          {
            uint64_t v123 = (2 * v121) | 1;
            unint64_t v124 = v13 + 16 * v123;
            if (2 * v121 + 2 < v15)
            {
              unsigned int v125 = *(unsigned __int8 *)(v124 + 8);
              unsigned int v126 = *(unsigned __int8 *)(v124 + 24);
              v124 += 16 * (v125 < v126);
              if (v125 < v126) {
                uint64_t v123 = 2 * v121 + 2;
              }
            }
            unint64_t v127 = v13 + 16 * v121;
            unsigned int v128 = *(unsigned __int8 *)(v127 + 8);
            if (*(unsigned __int8 *)(v124 + 8) >= v128)
            {
              uint64_t v129 = *(void *)v127;
              do
              {
                unint64_t v130 = v127;
                unint64_t v127 = v124;
                *(void *)unint64_t v130 = *(void *)v124;
                *(unsigned char *)(v130 + 8) = *(unsigned char *)(v124 + 8);
                if (v120 < v123) {
                  break;
                }
                uint64_t v131 = (2 * v123) | 1;
                unint64_t v124 = v13 + 16 * v131;
                uint64_t v132 = 2 * v123 + 2;
                if (v132 < v15)
                {
                  unsigned int v133 = *(unsigned __int8 *)(v124 + 8);
                  unsigned int v134 = *(unsigned __int8 *)(v124 + 24);
                  v124 += 16 * (v133 < v134);
                  if (v133 < v134) {
                    uint64_t v131 = v132;
                  }
                }
                __n128 result = (uint64_t *)*(unsigned __int8 *)(v124 + 8);
                uint64_t v123 = v131;
              }
              while (result >= v128);
              *(void *)unint64_t v127 = v129;
              *(unsigned char *)(v127 + 8) = v128;
            }
          }
          BOOL v122 = v121-- <= 0;
        }
        while (!v122);
        uint64_t v135 = (unint64_t)v14 >> 4;
        do
        {
          uint64_t v136 = 0;
          uint64_t v137 = *(void *)v13;
          char v138 = *(unsigned char *)(v13 + 8);
          unint64_t v139 = v13;
          do
          {
            uint64_t v140 = v139 + 16 * v136 + 16;
            uint64_t v141 = (2 * v136) | 1;
            uint64_t v142 = 2 * v136 + 2;
            if (v142 < v135)
            {
              unsigned int v143 = *(unsigned __int8 *)(v140 + 8);
              unsigned int v144 = *(unsigned __int8 *)(v140 + 24);
              v140 += 16 * (v143 < v144);
              if (v143 < v144) {
                uint64_t v141 = v142;
              }
            }
            *(void *)unint64_t v139 = *(void *)v140;
            *(unsigned char *)(v139 + 8) = *(unsigned char *)(v140 + 8);
            unint64_t v139 = v140;
            uint64_t v136 = v141;
          }
          while (v141 <= (uint64_t)((unint64_t)(v135 - 2) >> 1));
          if (v140 == a2 - 16)
          {
            *(void *)uint64_t v140 = v137;
            *(unsigned char *)(v140 + 8) = v138;
          }
          else
          {
            *(void *)uint64_t v140 = *(void *)(a2 - 16);
            *(unsigned char *)(v140 + 8) = *(unsigned char *)(a2 - 8);
            *(void *)(a2 - 16) = v137;
            *(unsigned char *)(a2 - 8) = v138;
            uint64_t v145 = v140 - v13 + 16;
            if (v145 >= 17)
            {
              unint64_t v146 = (((unint64_t)v145 >> 4) - 2) >> 1;
              uint64_t v147 = v13 + 16 * v146;
              unsigned int v148 = *(unsigned __int8 *)(v140 + 8);
              if (*(unsigned __int8 *)(v147 + 8) < v148)
              {
                uint64_t v149 = *(void *)v140;
                do
                {
                  uint64_t v150 = v140;
                  uint64_t v140 = v147;
                  *(void *)uint64_t v150 = *(void *)v147;
                  *(unsigned char *)(v150 + 8) = *(unsigned char *)(v147 + 8);
                  if (!v146) {
                    break;
                  }
                  unint64_t v146 = (v146 - 1) >> 1;
                  uint64_t v147 = v13 + 16 * v146;
                }
                while (*(unsigned __int8 *)(v147 + 8) < v148);
                *(void *)uint64_t v140 = v149;
                *(unsigned char *)(v140 + 8) = v148;
              }
            }
          }
          a2 -= 16;
          BOOL v122 = v135-- <= 2;
        }
        while (!v122);
      }
      return result;
    }
    unint64_t v16 = (unint64_t)v15 >> 1;
    unint64_t v17 = v13 + 16 * ((unint64_t)v15 >> 1);
    unsigned int v18 = *v11;
    if ((unint64_t)v14 < 0x801)
    {
      uint64_t v24 = (unsigned __int8 *)(v13 + 8);
      unsigned int v25 = *(unsigned __int8 *)(v13 + 8);
      uint64_t v26 = (unsigned __int8 *)(v17 + 8);
      unsigned int v27 = *(unsigned __int8 *)(v17 + 8);
      if (v25 < v27)
      {
        float v28 = *(uint64_t **)v17;
        if (v18 >= v25)
        {
          *(void *)unint64_t v17 = *(void *)v13;
          *(void *)unint64_t v13 = v28;
          *(unsigned char *)(v17 + 8) = v25;
          *(unsigned char *)(v13 + 8) = v27;
          if (*v11 >= v27) {
            goto LABEL_34;
          }
          *(void *)unint64_t v13 = *v10;
          *uint64_t v10 = (uint64_t)v28;
          uint64_t v26 = (unsigned __int8 *)(v13 + 8);
        }
        else
        {
          *(void *)unint64_t v17 = *v10;
          *uint64_t v10 = (uint64_t)v28;
        }
        uint64_t v24 = (unsigned __int8 *)(a2 - 8);
        goto LABEL_33;
      }
      if (v18 < v25)
      {
        uint64_t v32 = *(void *)v13;
        *(void *)unint64_t v13 = *v10;
        *uint64_t v10 = v32;
        LOBYTE(v32) = *(unsigned char *)(v13 + 8);
        *(unsigned char *)(v13 + 8) = *v11;
        unsigned char *v11 = v32;
        if (*(unsigned __int8 *)(v13 + 8) < *v26)
        {
          float v33 = *(uint64_t **)v17;
          *(void *)unint64_t v17 = *(void *)v13;
          *(void *)unint64_t v13 = v33;
LABEL_33:
          unsigned __int8 v47 = *v26;
          *uint64_t v26 = *v24;
          *uint64_t v24 = v47;
        }
      }
LABEL_34:
      --a3;
      if ((a4 & 1) == 0) {
        goto LABEL_61;
      }
LABEL_35:
      uint64_t v48 = *(void *)v13;
      unsigned int v49 = *(unsigned __int8 *)(v13 + 8);
LABEL_62:
      unint64_t v71 = v13;
      do
      {
        unint64_t v72 = v71;
        v71 += 16;
      }
      while (*(unsigned __int8 *)(v72 + 24) < v49);
      unint64_t v73 = a2;
      if (v72 == v13)
      {
        unint64_t v76 = a2;
        while (v71 < v76)
        {
          unint64_t v74 = v76 - 16;
          unsigned int v77 = *(unsigned __int8 *)(v76 - 8);
          v76 -= 16;
          if (v77 < v49) {
            goto LABEL_71;
          }
        }
        unint64_t v74 = v76;
      }
      else
      {
        do
        {
          unint64_t v74 = v73 - 16;
          unsigned int v75 = *(unsigned __int8 *)(v73 - 8);
          v73 -= 16;
        }
        while (v75 >= v49);
      }
LABEL_71:
      unint64_t v13 = v71;
      if (v71 < v74)
      {
        unint64_t v78 = v74;
        do
        {
          uint64_t v79 = *(void *)v13;
          *(void *)unint64_t v13 = *(void *)v78;
          *(void *)unint64_t v78 = v79;
          LOBYTE(v79) = *(unsigned char *)(v13 + 8);
          *(unsigned char *)(v13 + 8) = *(unsigned char *)(v78 + 8);
          *(unsigned char *)(v78 + 8) = v79;
          do
          {
            unsigned int v80 = *(unsigned __int8 *)(v13 + 24);
            v13 += 16;
          }
          while (v80 < v49);
          do
          {
            unsigned int v81 = *(unsigned __int8 *)(v78 - 8);
            v78 -= 16;
          }
          while (v81 >= v49);
        }
        while (v13 < v78);
      }
      if (v13 - 16 != v9)
      {
        *(void *)unint64_t v9 = *(void *)(v13 - 16);
        *(unsigned char *)(v9 + 8) = *(unsigned char *)(v13 - 8);
      }
      *(void *)(v13 - 16) = v48;
      *(unsigned char *)(v13 - 8) = v49;
      if (v71 < v74) {
        goto LABEL_82;
      }
      BOOL v82 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,_buildMeshes(std::vector<std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>> &,ggl::CullingGridWithHeight &,md::Triangulator<float> &,ggl::Device *,BOOL,std::shared_ptr<md::GEOVectorTileResource> const&,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&,float,geo::QuadTile const&)::$_0 &,std::pair<GeoCodecsBuildingFootprintFeature *,unsigned char> *>(v9, v13 - 16);
      __n128 result = (uint64_t *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,_buildMeshes(std::vector<std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>> &,ggl::CullingGridWithHeight &,md::Triangulator<float> &,ggl::Device *,BOOL,std::shared_ptr<md::GEOVectorTileResource> const&,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&,float,geo::QuadTile const&)::$_0 &,std::pair<GeoCodecsBuildingFootprintFeature *,unsigned char> *>(v13, a2);
      if (result)
      {
        a2 = v13 - 16;
        if (v82) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v82)
      {
LABEL_82:
        __n128 result = (uint64_t *)std::__introsort<std::_ClassicAlgPolicy,_buildMeshes(std::vector<std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>> &,ggl::CullingGridWithHeight &,md::Triangulator<float> &,ggl::Device *,BOOL,std::shared_ptr<md::GEOVectorTileResource> const&,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&,float,geo::QuadTile const&)::$_0 &,std::pair<GeoCodecsBuildingFootprintFeature *,unsigned char> *,false>(v9, v13 - 16, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v19 = (unsigned __int8 *)(v17 + 8);
      unsigned int v20 = *(unsigned __int8 *)(v17 + 8);
      char v21 = (unsigned __int8 *)(v13 + 8);
      unsigned int v22 = *(unsigned __int8 *)(v13 + 8);
      if (v20 < v22)
      {
        uint64_t v23 = *(void *)v13;
        if (v18 >= v20)
        {
          *(void *)unint64_t v13 = *(void *)v17;
          *(void *)unint64_t v17 = v23;
          *(unsigned char *)(v13 + 8) = v20;
          *(unsigned char *)(v17 + 8) = v22;
          if (*v11 >= v22) {
            goto LABEL_24;
          }
          *(void *)unint64_t v17 = *v10;
          *uint64_t v10 = v23;
          char v21 = (unsigned __int8 *)(v17 + 8);
        }
        else
        {
          *(void *)unint64_t v13 = *v10;
          *uint64_t v10 = v23;
        }
        long long v31 = (unsigned __int8 *)(a2 - 8);
        goto LABEL_23;
      }
      if (v18 < v20)
      {
        float v29 = *(uint64_t **)v17;
        *(void *)unint64_t v17 = *v10;
        *uint64_t v10 = (uint64_t)v29;
        LOBYTE(v29) = *(unsigned char *)(v17 + 8);
        *(unsigned char *)(v17 + 8) = *v11;
        unsigned char *v11 = (_BYTE)v29;
        if (*(unsigned __int8 *)(v17 + 8) < *v21)
        {
          uint64_t v30 = *(void *)v13;
          *(void *)unint64_t v13 = *(void *)v17;
          *(void *)unint64_t v17 = v30;
          long long v31 = (unsigned __int8 *)(v17 + 8);
LABEL_23:
          unsigned __int8 v34 = *v21;
          *char v21 = *v31;
          *long long v31 = v34;
        }
      }
LABEL_24:
      unint64_t v35 = v13 + 16 * v16;
      unsigned int v38 = *(unsigned __int8 *)(v35 - 8);
      float v36 = (unsigned __int8 *)(v35 - 8);
      unsigned int v37 = v38;
      unint64_t v39 = (uint64_t **)(v36 - 8);
      unint64_t v40 = (unsigned __int8 *)(v13 + 24);
      unsigned int v41 = *(unsigned __int8 *)(v13 + 24);
      unsigned int v42 = *v160;
      if (v38 < v41)
      {
        unint64_t v43 = *(uint64_t **)(v13 + 16);
        if (v42 >= v37)
        {
          *(void *)(v13 + 16) = *v39;
          char *v39 = v43;
          *(unsigned char *)(v13 + 24) = v37;
          *float v36 = v41;
          if (*v160 >= v41) {
            goto LABEL_40;
          }
          char *v39 = *(uint64_t **)(a2 - 32);
          *(void *)(a2 - 32) = v43;
          unint64_t v40 = v36;
        }
        else
        {
          *(void *)(v13 + 16) = *(void *)(a2 - 32);
          *(void *)(a2 - 32) = v43;
        }
        uint64_t v46 = (unsigned __int8 *)(a2 - 24);
        goto LABEL_39;
      }
      if (v42 < v37)
      {
        unint64_t v44 = *v39;
        char *v39 = *(uint64_t **)(a2 - 32);
        *(void *)(a2 - 32) = v44;
        LOBYTE(v44) = *v36;
        *float v36 = *(unsigned char *)(a2 - 24);
        *(unsigned char *)(a2 - 24) = (_BYTE)v44;
        if (*v36 < *v40)
        {
          unint64_t v45 = *(uint64_t **)(v13 + 16);
          *(void *)(v13 + 16) = *v39;
          char *v39 = v45;
          uint64_t v46 = v36;
LABEL_39:
          unsigned __int8 v50 = *v40;
          *unint64_t v40 = *v46;
          *uint64_t v46 = v50;
        }
      }
LABEL_40:
      unint64_t v51 = v13 + 16 * v16;
      unsigned int v54 = *(unsigned __int8 *)(v51 + 24);
      long long v52 = (unsigned __int8 *)(v51 + 24);
      unsigned int v53 = v54;
      long long v55 = v52 - 8;
      uint64_t v57 = (unsigned __int8 *)(v13 + 40);
      unsigned int v56 = *(unsigned __int8 *)(v13 + 40);
      unsigned int v58 = *v12;
      if (v54 < v56)
      {
        uint64_t v59 = *(void *)(v13 + 32);
        if (v58 >= v53)
        {
          *(void *)(v13 + 32) = *(void *)v55;
          *(void *)long long v55 = v59;
          *(unsigned char *)(v13 + 40) = v53;
          *long long v52 = v56;
          unsigned int v53 = v56;
          if (*v12 >= v56) {
            goto LABEL_50;
          }
          *(void *)long long v55 = *(void *)(a2 - 48);
          *(void *)(a2 - 48) = v59;
          uint64_t v57 = v52;
        }
        else
        {
          *(void *)(v13 + 32) = *(void *)(a2 - 48);
          *(void *)(a2 - 48) = v59;
        }
        double v62 = (unsigned __int8 *)(a2 - 40);
        goto LABEL_49;
      }
      if (v58 < v53)
      {
        uint64_t v60 = *(void *)v55;
        *(void *)long long v55 = *(void *)(a2 - 48);
        *(void *)(a2 - 48) = v60;
        LOBYTE(v60) = *v52;
        *long long v52 = *(unsigned char *)(a2 - 40);
        *(unsigned char *)(a2 - 40) = v60;
        unsigned int v53 = *v52;
        if (v53 < *v57)
        {
          uint64_t v61 = *(void *)(v13 + 32);
          *(void *)(v13 + 32) = *(void *)v55;
          *(void *)long long v55 = v61;
          double v62 = v52;
LABEL_49:
          unsigned __int8 v63 = *v57;
          *uint64_t v57 = *v62;
          *double v62 = v63;
          unsigned int v53 = *v52;
        }
      }
LABEL_50:
      unsigned int v64 = *v19;
      unsigned int v65 = *v36;
      if (v64 >= v65)
      {
        __n128 result = *(uint64_t **)v17;
        if (v53 >= v64) {
          goto LABEL_60;
        }
        uint64_t v66 = *(uint64_t **)v55;
        *(void *)unint64_t v17 = *(void *)v55;
        *(void *)long long v55 = result;
        *(unsigned char *)(v17 + 8) = v53;
        v55[8] = v64;
        if (v53 < v65)
        {
          uint64_t v67 = *v39;
          char *v39 = v66;
          *(void *)unint64_t v17 = v67;
LABEL_59:
          *float v36 = v53;
          *uint64_t v19 = v65;
          __n128 result = *(uint64_t **)v17;
          LOBYTE(v64) = *(unsigned char *)(v13 + 16 * v16 + 8);
          goto LABEL_60;
        }
        LOBYTE(v64) = v53;
        __n128 result = v66;
      }
      else
      {
        __n128 result = *v39;
        if (v53 < v64)
        {
          char *v39 = *(uint64_t **)v55;
          *(void *)long long v55 = result;
LABEL_58:
          uint64_t v19 = v52;
          goto LABEL_59;
        }
        char *v39 = *(uint64_t **)v17;
        *(void *)unint64_t v17 = result;
        *float v36 = v64;
        *(unsigned char *)(v17 + 8) = v65;
        if (v53 < v65)
        {
          *(void *)unint64_t v17 = *(void *)v55;
          *(void *)long long v55 = result;
          float v36 = (unsigned __int8 *)(v17 + 8);
          goto LABEL_58;
        }
        LOBYTE(v64) = v65;
      }
LABEL_60:
      uint64_t v68 = *(void *)v13;
      *(void *)unint64_t v13 = result;
      *(void *)unint64_t v17 = v68;
      unint64_t v69 = v13 + 16 * v16;
      char v70 = *(unsigned char *)(v13 + 8);
      *(unsigned char *)(v13 + 8) = v64;
      *(unsigned char *)(v69 + 8) = v70;
      --a3;
      if (a4) {
        goto LABEL_35;
      }
LABEL_61:
      unsigned int v49 = *(unsigned __int8 *)(v13 + 8);
      uint64_t v48 = *(void *)v13;
      if (*(unsigned __int8 *)(v13 - 8) < v49) {
        goto LABEL_62;
      }
      if (v49 < *v11)
      {
        unint64_t v83 = v13;
        do
        {
          unint64_t v13 = v83 + 16;
          unsigned int v84 = *(unsigned __int8 *)(v83 + 24);
          v83 += 16;
        }
        while (v49 >= v84);
      }
      else
      {
        unint64_t v85 = v13 + 16;
        do
        {
          unint64_t v13 = v85;
          if (v85 >= a2) {
            break;
          }
          unsigned int v86 = *(unsigned __int8 *)(v85 + 8);
          v85 += 16;
        }
        while (v49 >= v86);
      }
      unint64_t v87 = a2;
      if (v13 < a2)
      {
        unint64_t v88 = a2;
        do
        {
          unint64_t v87 = v88 - 16;
          unsigned int v89 = *(unsigned __int8 *)(v88 - 8);
          v88 -= 16;
        }
        while (v49 < v89);
      }
      while (v13 < v87)
      {
        uint64_t v90 = *(void *)v13;
        *(void *)unint64_t v13 = *(void *)v87;
        *(void *)unint64_t v87 = v90;
        LOBYTE(v90) = *(unsigned char *)(v13 + 8);
        *(unsigned char *)(v13 + 8) = *(unsigned char *)(v87 + 8);
        *(unsigned char *)(v87 + 8) = v90;
        do
        {
          unsigned int v91 = *(unsigned __int8 *)(v13 + 24);
          v13 += 16;
        }
        while (v49 >= v91);
        do
        {
          unsigned int v92 = *(unsigned __int8 *)(v87 - 8);
          v87 -= 16;
        }
        while (v49 < v92);
      }
      BOOL v4 = v13 - 16 >= v9;
      BOOL v5 = v13 - 16 == v9;
      if (v13 - 16 != v9)
      {
        *(void *)unint64_t v9 = *(void *)(v13 - 16);
        *(unsigned char *)(v9 + 8) = *(unsigned char *)(v13 - 8);
      }
      a4 = 0;
      *(void *)(v13 - 16) = v48;
      *(unsigned char *)(v13 - 8) = v49;
    }
  }
  int64_t v109 = (void *)(v13 + 16);
  BOOL v111 = v13 == a2 || v109 == (void *)a2;
  if (a4)
  {
    if (!v111)
    {
      uint64_t v112 = 0;
      id v113 = (void *)v13;
      do
      {
        unsigned int v115 = *((unsigned __int8 *)v113 + 24);
        unsigned int v116 = *((unsigned __int8 *)v113 + 8);
        id v113 = v109;
        if (v115 < v116)
        {
          uint64_t v117 = *v109;
          uint64_t v118 = v112;
          do
          {
            uint64_t v119 = v13 + v118;
            *(void *)(v119 + 16) = *(void *)(v13 + v118);
            *(unsigned char *)(v119 + 24) = *(unsigned char *)(v13 + v118 + 8);
            if (!v118)
            {
              uint64_t v114 = v13;
              goto LABEL_129;
            }
            v118 -= 16;
          }
          while (v115 < *(unsigned __int8 *)(v119 - 8));
          uint64_t v114 = v13 + v118 + 16;
LABEL_129:
          *(void *)uint64_t v114 = v117;
          *(unsigned char *)(v114 + 8) = v115;
        }
        int64_t v109 = v113 + 2;
        v112 += 16;
      }
      while (v113 + 2 != (void *)a2);
    }
  }
  else if (!v111)
  {
    unint64_t v153 = v13 + 8;
    do
    {
      unsigned int v154 = *(unsigned __int8 *)(v9 + 24);
      unsigned int v155 = *(unsigned __int8 *)(v9 + 8);
      unint64_t v9 = (unint64_t)v109;
      if (v154 < v155)
      {
        uint64_t v156 = *v109;
        unint64_t v157 = v153;
        do
        {
          *(void *)(v157 + 8) = *(void *)(v157 - 8);
          *(unsigned char *)(v157 + 16) = *(unsigned char *)v157;
          unsigned int v158 = *(unsigned __int8 *)(v157 - 16);
          v157 -= 16;
        }
        while (v154 < v158);
        *(void *)(v157 + 8) = v156;
        *(unsigned char *)(v157 + 16) = v154;
      }
      int64_t v109 = (void *)(v9 + 16);
      v153 += 16;
    }
    while (v9 + 16 != a2);
  }
  return result;
}

void ___Z12_buildMeshesRNSt3__16vectorINS0_IN3geo11_retain_ptrIU8__strongP15VKBuildingGroupNS1_16_retain_objc_arcENS1_17_release_objc_arcENS1_10_hash_objcENS1_11_equal_objcEEENS_9allocatorISA_EEEENSB_ISD_EEEERN3ggl21CullingGridWithHeightERN2md12TriangulatorIfEEPNSH_6DeviceEbRKNS_10shared_ptrINSK_21GEOVectorTileResourceEEERKNSQ_IN3gss17StylesheetManagerINSV_10PropertyIDEEEEEfRKNS1_8QuadTileE_block_invoke(uint64_t a1, uint64_t a2, double a3)
{
  BOOL v5 = **(uint64_t ***)(a1 + 40);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (*v5 != v7)
  {
    do
    {
      id v8 = *(id *)(v6 + 8);
      [v8 willAddDataWithAccessor:a2];

      v6 += 24;
    }
    while (v6 != v7);
    BOOL v5 = **(uint64_t ***)(a1 + 40);
  }
  uint64_t v9 = v5[3];
  uint64_t v10 = v5[4];
  if (v9 != v10)
  {
    do
    {
      id v11 = *(id *)(v9 + 8);
      [v11 willAddDataWithAccessor:a2];

      v9 += 24;
    }
    while (v9 != v10);
    BOOL v5 = **(uint64_t ***)(a1 + 40);
  }
  uint64_t v12 = v5[6];
  for (uint64_t i = v5[7]; v12 != i; v12 += 24)
  {
    id v14 = *(id *)(v12 + 8);
    [v14 willAddDataWithAccessor:a2];
  }
  uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8);
  unint64_t v16 = *(uint64_t **)(v15 + 48);
  unint64_t v17 = *(uint64_t **)(v15 + 56);
  if (v16 != v17)
  {
    unint64_t v18 = 0;
    while (1)
    {
      uint64_t v19 = *v16;
      if (*(unsigned char *)(*v16 + 128)) {
        goto LABEL_12;
      }
      if (*(_DWORD *)(v19 + 100)) {
        break;
      }
LABEL_11:
      ++v18;
LABEL_12:
      v16 += 2;
      if (v16 == v17) {
        goto LABEL_28;
      }
    }
    unsigned int v20 = (uint64_t *)(**(void **)(a1 + 40) + 24 * (v18 % 3));
    uint64_t v21 = *v20;
    uint64_t v22 = v20[1];
    if (*v20 == v22)
    {
LABEL_18:
      id v25 = 0;
      int v26 = *(unsigned __int8 *)(a1 + 68);
      if (!*(unsigned char *)(a1 + 68)) {
        goto LABEL_26;
      }
    }
    else
    {
      while (1)
      {
        id v23 = *(id *)(v21 + 8);
        int v24 = [v23 canAcceptPolygon:v19];

        if (v24) {
          break;
        }
        v21 += 24;
        if (v21 == v22) {
          goto LABEL_18;
        }
      }
      id v25 = *(id *)(v21 + 8);
      int v26 = *(unsigned __int8 *)(a1 + 68);
      if (!*(unsigned char *)(a1 + 68)) {
        goto LABEL_26;
      }
    }
    unsigned int v27 = *(unsigned __int8 **)(v19 + 24);
    uint64_t v28 = v27[33];
    if (v27[33])
    {
      BOOL v29 = 0;
      uint64_t v30 = (_DWORD *)(*(void *)v27 + 4);
      do
      {
        if (*(v30 - 1) == 19) {
          BOOL v29 = *v30 == 0;
        }
        v30 += 2;
        --v28;
      }
      while (v28);
      goto LABEL_27;
    }
LABEL_26:
    BOOL v29 = 0;
LABEL_27:
    LODWORD(a3) = *(_DWORD *)(a1 + 64);
    LOBYTE(v41) = v29;
    [v25 addBuilding:v19 index:v18 ofTotal:*(void *)(a1 + 48) accessor:a2 triangulator:*(void *)(a1 + 56) prepareExtrusion:v26 != 0 forRoofStyle:a3 scaleThreshold:v41];

    goto LABEL_11;
  }
LABEL_28:
  long long v31 = **(uint64_t ***)(a1 + 40);
  uint64_t v32 = *v31;
  uint64_t v33 = v31[1];
  if (*v31 != v33)
  {
    do
    {
      id v34 = *(id *)(v32 + 8);
      [v34 didFinishAddingData];

      v32 += 24;
    }
    while (v32 != v33);
    long long v31 = **(uint64_t ***)(a1 + 40);
  }
  uint64_t v35 = v31[3];
  uint64_t v36 = v31[4];
  if (v35 != v36)
  {
    do
    {
      id v37 = *(id *)(v35 + 8);
      [v37 didFinishAddingData];

      v35 += 24;
    }
    while (v35 != v36);
    long long v31 = **(uint64_t ***)(a1 + 40);
  }
  uint64_t v38 = v31[6];
  for (uint64_t j = v31[7]; v38 != j; v38 += 24)
  {
    id v40 = *(id *)(v38 + 8);
    [v40 didFinishAddingData];
  }
}

void sub_1A25A4BAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559618;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559618;

  return a1;
}

uint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,_buildMeshes(std::vector<std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>> &,ggl::CullingGridWithHeight &,md::Triangulator<float> &,ggl::Device *,BOOL,std::shared_ptr<md::GEOVectorTileResource> const&,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&,float,geo::QuadTile const&)::$_0 &,std::pair<GeoCodecsBuildingFootprintFeature *,unsigned char> *>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  unsigned int v4 = *((unsigned __int8 *)a2 + 8);
  BOOL v5 = (unsigned __int8 *)(result + 1);
  uint64_t v6 = (unsigned __int8 *)(a3 + 1);
  unsigned int v7 = *((unsigned __int8 *)a3 + 8);
  if (v4 >= *((unsigned __int8 *)result + 8))
  {
    if (v7 < v4)
    {
      uint64_t v10 = *a2;
      *a2 = *a3;
      *a3 = v10;
      unsigned int v7 = *((unsigned __int8 *)a2 + 8);
      *((unsigned char *)a2 + 8) = *((unsigned char *)a3 + 8);
      *((unsigned char *)a3 + 8) = v7;
      if (*((unsigned __int8 *)a2 + 8) < *v5)
      {
        uint64_t v11 = *result;
        *__n128 result = *a2;
        *a2 = v11;
        uint64_t v9 = (char *)(result + 1);
        uint64_t v12 = (char *)(a2 + 1);
LABEL_10:
        char v15 = *v9;
        char *v9 = *v12;
        *uint64_t v12 = v15;
        unsigned int v7 = *v6;
      }
    }
  }
  else
  {
    uint64_t v8 = *result;
    if (v7 < v4)
    {
      *__n128 result = *a3;
      *a3 = v8;
      uint64_t v9 = (char *)(result + 1);
LABEL_9:
      uint64_t v12 = (char *)(a3 + 1);
      goto LABEL_10;
    }
    *__n128 result = *a2;
    *a2 = v8;
    unsigned int v13 = *((unsigned __int8 *)result + 8);
    *((unsigned char *)result + 8) = *((unsigned char *)a2 + 8);
    *((unsigned char *)a2 + 8) = v13;
    unsigned int v7 = *v6;
    if (v7 < v13)
    {
      uint64_t v14 = *a2;
      *a2 = *a3;
      *a3 = v14;
      uint64_t v9 = (char *)(a2 + 1);
      goto LABEL_9;
    }
  }
  if (*((unsigned __int8 *)a4 + 8) < v7)
  {
    uint64_t v16 = *a3;
    *a3 = *a4;
    *a4 = v16;
    LOBYTE(v16) = *((unsigned char *)a3 + 8);
    *((unsigned char *)a3 + 8) = *((unsigned char *)a4 + 8);
    *((unsigned char *)a4 + 8) = v16;
    if (*((unsigned __int8 *)a3 + 8) < *((unsigned __int8 *)a2 + 8))
    {
      uint64_t v17 = *a2;
      *a2 = *a3;
      *a3 = v17;
      LOBYTE(v17) = *((unsigned char *)a2 + 8);
      *((unsigned char *)a2 + 8) = *((unsigned char *)a3 + 8);
      *((unsigned char *)a3 + 8) = v17;
      if (*((unsigned __int8 *)a2 + 8) < *v5)
      {
        uint64_t v18 = *result;
        *__n128 result = *a2;
        *a2 = v18;
        LOBYTE(v18) = *((unsigned char *)result + 8);
        *((unsigned char *)result + 8) = *((unsigned char *)a2 + 8);
        *((unsigned char *)a2 + 8) = v18;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,_buildMeshes(std::vector<std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>> &,ggl::CullingGridWithHeight &,md::Triangulator<float> &,ggl::Device *,BOOL,std::shared_ptr<md::GEOVectorTileResource> const&,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&,float,geo::QuadTile const&)::$_0 &,std::pair<GeoCodecsBuildingFootprintFeature *,unsigned char> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(unsigned __int8 *)(a2 - 8) < *(unsigned __int8 *)(a1 + 8))
      {
        uint64_t v6 = *(void *)a1;
        *(void *)a1 = *(void *)(a2 - 16);
        *(void *)(a2 - 16) = v6;
        LOBYTE(v6) = *(unsigned char *)(a1 + 8);
        *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 - 8);
        *(unsigned char *)(a2 - 8) = v6;
      }
      return result;
    case 3:
      unsigned int v7 = (char *)(a1 + 8);
      unsigned int v8 = *(unsigned __int8 *)(a1 + 8);
      uint64_t v9 = (char *)(a1 + 24);
      unsigned int v10 = *(unsigned __int8 *)(a1 + 24);
      unsigned int v11 = *(unsigned __int8 *)(a2 - 8);
      if (v10 < v8)
      {
        uint64_t v12 = *(void *)a1;
        if (v11 >= v10)
        {
          *(void *)a1 = *(void *)(a1 + 16);
          *(void *)(a1 + 16) = v12;
          *(unsigned char *)(a1 + 8) = v10;
          *(unsigned char *)(a1 + 24) = v8;
          if (*(unsigned __int8 *)(a2 - 8) >= v8) {
            return result;
          }
          *(void *)(a1 + 16) = *(void *)(a2 - 16);
          *(void *)(a2 - 16) = v12;
          unsigned int v7 = (char *)(a1 + 24);
        }
        else
        {
          *(void *)a1 = *(void *)(a2 - 16);
          *(void *)(a2 - 16) = v12;
        }
        uint64_t v9 = (char *)(a2 - 8);
        goto LABEL_25;
      }
      if (v11 < v10)
      {
        uint64_t v28 = *(void *)(a1 + 16);
        *(void *)(a1 + 16) = *(void *)(a2 - 16);
        *(void *)(a2 - 16) = v28;
        LOBYTE(v28) = *(unsigned char *)(a1 + 24);
        *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 - 8);
        *(unsigned char *)(a2 - 8) = v28;
        if (*(unsigned __int8 *)(a1 + 24) < *(unsigned __int8 *)(a1 + 8))
        {
          uint64_t v29 = *(void *)a1;
          *(void *)a1 = *(void *)(a1 + 16);
          *(void *)(a1 + 16) = v29;
LABEL_25:
          char v33 = *v7;
          *unsigned int v7 = *v9;
          char *v9 = v33;
          return result;
        }
      }
      return result;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,_buildMeshes(std::vector<std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>> &,ggl::CullingGridWithHeight &,md::Triangulator<float> &,ggl::Device *,BOOL,std::shared_ptr<md::GEOVectorTileResource> const&,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&,float,geo::QuadTile const&)::$_0 &,std::pair<GeoCodecsBuildingFootprintFeature *,unsigned char> *>((uint64_t *)a1, (uint64_t *)(a1 + 16), (uint64_t *)(a1 + 32), (uint64_t *)(a2 - 16));
      return 1;
    case 5:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,_buildMeshes(std::vector<std::vector<geo::_retain_ptr<VKBuildingGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>> &,ggl::CullingGridWithHeight &,md::Triangulator<float> &,ggl::Device *,BOOL,std::shared_ptr<md::GEOVectorTileResource> const&,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&,float,geo::QuadTile const&)::$_0 &,std::pair<GeoCodecsBuildingFootprintFeature *,unsigned char> *>((uint64_t *)a1, (uint64_t *)(a1 + 16), (uint64_t *)(a1 + 32), (uint64_t *)(a1 + 48));
      if (*(unsigned __int8 *)(a2 - 8) < *(unsigned __int8 *)(a1 + 56))
      {
        uint64_t v19 = *(void *)(a1 + 48);
        *(void *)(a1 + 48) = *(void *)(a2 - 16);
        *(void *)(a2 - 16) = v19;
        LOBYTE(v19) = *(unsigned char *)(a1 + 56);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 - 8);
        *(unsigned char *)(a2 - 8) = v19;
        unsigned int v20 = *(unsigned __int8 *)(a1 + 56);
        unsigned int v21 = *(unsigned __int8 *)(a1 + 40);
        if (v20 < v21)
        {
          uint64_t v22 = *(void *)(a1 + 32);
          uint64_t v23 = *(void *)(a1 + 48);
          *(void *)(a1 + 32) = v23;
          *(void *)(a1 + 48) = v22;
          *(unsigned char *)(a1 + 40) = v20;
          *(unsigned char *)(a1 + 56) = v21;
          unsigned int v24 = *(unsigned __int8 *)(a1 + 24);
          if (v20 < v24)
          {
            uint64_t v25 = *(void *)(a1 + 16);
            *(void *)(a1 + 16) = v23;
            *(void *)(a1 + 32) = v25;
            *(unsigned char *)(a1 + 24) = v20;
            *(unsigned char *)(a1 + 40) = v24;
            unsigned int v26 = *(unsigned __int8 *)(a1 + 8);
            if (v20 < v26)
            {
              uint64_t v27 = *(void *)a1;
              *(void *)a1 = v23;
              *(void *)(a1 + 16) = v27;
              *(unsigned char *)(a1 + 8) = v20;
              *(unsigned char *)(a1 + 24) = v26;
            }
          }
        }
      }
      return 1;
    default:
      unsigned int v13 = *(unsigned __int8 *)(a1 + 8);
      uint64_t v14 = (unsigned char *)(a1 + 24);
      unsigned int v15 = *(unsigned __int8 *)(a1 + 24);
      unsigned int v16 = *(unsigned __int8 *)(a1 + 40);
      if (v15 < v13)
      {
        uint64_t v17 = *(void *)a1;
        if (v16 >= v15)
        {
          *(void *)a1 = *(void *)(a1 + 16);
          *(void *)(a1 + 16) = v17;
          *(unsigned char *)(a1 + 8) = v15;
          *(unsigned char *)(a1 + 24) = v13;
          if (v16 >= v13) {
            goto LABEL_30;
          }
          *(void *)(a1 + 16) = *(void *)(a1 + 32);
          *(void *)(a1 + 32) = v17;
          uint64_t v18 = (unsigned char *)(a1 + 24);
        }
        else
        {
          *(void *)a1 = *(void *)(a1 + 32);
          *(void *)(a1 + 32) = v17;
          uint64_t v18 = (unsigned char *)(a1 + 8);
        }
        uint64_t v14 = (unsigned char *)(a1 + 40);
        goto LABEL_29;
      }
      if (v16 < v15)
      {
        uint64_t v30 = *(void *)(a1 + 16);
        uint64_t v31 = *(void *)(a1 + 32);
        *(void *)(a1 + 16) = v31;
        *(void *)(a1 + 32) = v30;
        *(unsigned char *)(a1 + 24) = v16;
        *(unsigned char *)(a1 + 40) = v15;
        if (v16 < v13)
        {
          uint64_t v32 = *(void *)a1;
          *(void *)a1 = v31;
          *(void *)(a1 + 16) = v32;
          uint64_t v18 = (unsigned char *)(a1 + 8);
LABEL_29:
          *uint64_t v18 = v16;
          *uint64_t v14 = v13;
        }
      }
LABEL_30:
      uint64_t v34 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v35 = 0;
      int v36 = 0;
      uint64_t v37 = a1 + 32;
      while (1)
      {
        unsigned int v39 = *(unsigned __int8 *)(v34 + 8);
        if (v39 < *(unsigned __int8 *)(v37 + 8))
        {
          uint64_t v40 = *(void *)v34;
          uint64_t v41 = v35;
          do
          {
            uint64_t v42 = a1 + v41;
            *(void *)(v42 + 48) = *(void *)(a1 + v41 + 32);
            *(unsigned char *)(v42 + 56) = *(unsigned char *)(a1 + v41 + 40);
            if (v41 == -32)
            {
              uint64_t v38 = a1;
              goto LABEL_33;
            }
            v41 -= 16;
          }
          while (v39 < *(unsigned __int8 *)(v42 + 24));
          uint64_t v38 = a1 + v41 + 48;
LABEL_33:
          *(void *)uint64_t v38 = v40;
          *(unsigned char *)(v38 + 8) = v39;
          if (++v36 == 8) {
            return v34 + 16 == a2;
          }
        }
        uint64_t v37 = v34;
        v35 += 16;
        v34 += 16;
        if (v34 == a2) {
          return 1;
        }
      }
  }
}

void md::BuildingLayerDataSource::~BuildingLayerDataSource(md::BuildingLayerDataSource *this)
{
  *(void *)this = &unk_1EF5429F8;
  *((void *)this + 97) = &unk_1EF559798;

  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 95);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF5429F8;
  *((void *)this + 97) = &unk_1EF559798;

  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 95);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
}

void colorLerp(float *a1, float *a2, float *a3, float a4)
{
  float v7 = *a2;
  float v8 = a2[1];
  float v9 = a2[2];
  float v10 = fmaxf(fmaxf(*a2, v8), v9);
  float v11 = v10 - fminf(v9, fminf(v8, *a2));
  float v12 = 0.0;
  float v13 = 0.0;
  float v14 = 0.0;
  if (v11 > 0.0)
  {
    if (v10 == v7)
    {
      float v14 = fmod((float)((float)(v8 - v9) / v11), 6.0) * 60.0;
    }
    else
    {
      if (v10 == v8)
      {
        float v15 = (float)((float)(v9 - v7) * 60.0) / v11;
        float v16 = 120.0;
      }
      else
      {
        if (v10 != v9)
        {
          if (v10 <= 0.0) {
            float v13 = 0.0;
          }
          else {
            float v13 = v11 / v10;
          }
          goto LABEL_14;
        }
        float v15 = (float)((float)(v7 - v8) * 60.0) / v11;
        float v16 = 240.0;
      }
      float v14 = v15 + v16;
    }
    if (v10 <= 0.0) {
      float v13 = 0.0;
    }
    else {
      float v13 = v11 / v10;
    }
    if (v14 < 0.0) {
      float v14 = v14 + 360.0;
    }
  }
LABEL_14:
  float v17 = *a3;
  float v18 = a3[1];
  float v19 = a3[2];
  float v20 = fmaxf(fmaxf(*a3, v18), v19);
  float v21 = v20 - fminf(v19, fminf(v18, *a3));
  float v22 = 0.0;
  if (v21 > 0.0)
  {
    if (v20 == v17)
    {
      float v22 = fmod((float)((float)(v18 - v19) / v21), 6.0) * 60.0;
    }
    else
    {
      if (v20 == v18)
      {
        float v23 = (float)((float)(v19 - v17) * 60.0) / v21;
        float v24 = 120.0;
      }
      else
      {
        if (v20 != v19)
        {
          if (v20 <= 0.0) {
            float v12 = 0.0;
          }
          else {
            float v12 = v21 / v20;
          }
          goto LABEL_27;
        }
        float v23 = (float)((float)(v17 - v18) * 60.0) / v21;
        float v24 = 240.0;
      }
      float v22 = v23 + v24;
    }
    if (v20 <= 0.0) {
      float v12 = 0.0;
    }
    else {
      float v12 = v21 / v20;
    }
    if (v22 < 0.0) {
      float v22 = v22 + 360.0;
    }
  }
LABEL_27:
  float v25 = v14 + (float)((float)(v22 - v14) * a4);
  float v26 = v13 + (float)((float)(v12 - v13) * a4);
  float v27 = v10 + (float)((float)(v20 - v10) * a4);
  float v28 = v26 * v27;
  float v29 = fmod(v25 * 0.0166666667, 6.0);
  float v30 = v28 - fabs(fmod(v29, 2.0) + -1.0) * v28;
  float v31 = v27 - v28;
  if (v29 >= 0.0 && v29 < 1.0)
  {
    float v44 = v31 + v30;
    float v43 = v27;
  }
  else if (v29 >= 1.0 && v29 < 2.0)
  {
    float v43 = v31 + v30;
    float v44 = v27;
  }
  else if (v29 >= 2.0 && v29 < 3.0)
  {
    float v43 = v27 - v28;
    float v31 = v31 + v30;
    float v44 = v27;
  }
  else if (v29 >= 3.0 && v29 < 4.0)
  {
    float v44 = v31 + v30;
    float v43 = v27 - v28;
    float v31 = v27;
  }
  else
  {
    BOOL v36 = v29 >= 5.0;
    BOOL v37 = v29 < 6.0;
    if (v36 && v37) {
      float v38 = v27;
    }
    else {
      float v38 = v27 - v28;
    }
    float v39 = -0.0;
    if (v36 && v37) {
      float v39 = v30;
    }
    float v40 = v39 + v31;
    float v41 = v31 + v30;
    BOOL v42 = v29 >= 4.0 && v29 < 5.0;
    if (v42) {
      float v43 = v41;
    }
    else {
      float v43 = v38;
    }
    float v44 = v27 - v28;
    if (v42) {
      float v31 = v27;
    }
    else {
      float v31 = v40;
    }
  }
  *a1 = v43;
  a1[1] = v44;
  a1[2] = v31;
}

void md::MuninRoadLabeler::updateDebugSettings(md::MuninRoadLabeler *this)
{
  id v2 = +[VKDebugSettings sharedSettings];
  *((unsigned char *)this + 49) = [v2 enableMuninRoadNetworkMiniMap];
}

void sub_1A25A5BC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

BOOL md::MuninRoadLabeler::needsDebugDraw(md::MuninRoadLabeler *this)
{
  uint64_t v2 = *((void *)this + 7);
  if (v2)
  {
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v2 + 298));
    if ((v3 & 1) == 0)
    {
      v5[0] = 0;
      v5[1] = 0;
      md::MuninRoadLabeler::setDebugHighlight((uint64_t)this, v5);
    }
  }
  return *((unsigned char *)this + 49) || *((void *)this + 7) != 0;
}

void md::MuninRoadLabeler::setDebugHighlight(uint64_t a1, uint64_t *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = *a2;
  if (v3 != *a2)
  {
    if (v3)
    {
      atomic_store(0, (unsigned __int8 *)(v3 + 298));
      uint64_t v4 = *a2;
    }
    uint64_t v5 = a2[1];
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 64);
    *(void *)(a1 + 56) = v4;
    *(void *)(a1 + 64) = v5;
    if (v6)
    {
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
      uint64_t v4 = *(void *)(a1 + 56);
    }
    if (v4) {
      atomic_store(1u, (unsigned __int8 *)(v4 + 298));
    }
    uint64_t v7 = *(void *)(*(void *)(a1 + 8) + 136);
    if (v7)
    {
      uint64_t v8 = *(void *)(v7 + 24);
      if (v8)
      {
        __p[0] = *(void **)(a1 + 8);
        buf[0] = 9;
        (*(void (**)(uint64_t, void **, uint8_t *))(*(void *)v8 + 48))(v8, __p, buf);
      }
    }
    uint64_t v3 = *(void *)(a1 + 56);
  }
  if (v3)
  {
    if (GEOGetVectorKitLabelHighlightLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitLabelHighlightLog(void)::onceToken, &__block_literal_global_38319);
    }
    float v9 = (id)GEOGetVectorKitLabelHighlightLog(void)::log;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      md::MuninRoadLabel::debugString((md::MuninRoadLabel *)__p, *(md::LabelManager **)(a1 + 56), *(void *)(a1 + 8));
      if (v12 >= 0) {
        float v10 = __p;
      }
      else {
        float v10 = (void **)__p[0];
      }
      *(_DWORD *)buf = 136315138;
      float v14 = v10;
      _os_log_impl(&dword_1A1780000, v9, OS_LOG_TYPE_INFO, "\n%s", buf, 0xCu);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_1A25A5E30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL32GEOGetVectorKitLabelHighlightLogv_block_invoke_38324()
{
  os_log_t v0 = os_log_create("com.apple.VectorKit", "LabelHighlight");
  uint64_t v1 = (void *)GEOGetVectorKitLabelHighlightLog(void)::log;
  GEOGetVectorKitLabelHighlightLog(void)::log = (uint64_t)v0;
}

void md::MuninRoadLabeler::clearDebugHighlight(md::MuninRoadLabeler *this)
{
  v1[0] = 0;
  v1[1] = 0;
  md::MuninRoadLabeler::setDebugHighlight((uint64_t)this, v1);
}

void sub_1A25A5EBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t md::MuninRoadLabeler::debugHighlightLabelAtPixel(uint64_t a1, float *a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 104);
  uint64_t v3 = *(uint64_t **)(a1 + 112);
  if (v2 == v3) {
    return 0;
  }
  float v4 = *a2;
  float v5 = a2[1];
  while (1)
  {
    uint64_t v6 = *v2;
    uint64_t v7 = *(float **)(*(void *)(*v2 + 64) + 24);
    if (v4 >= v7[98] && v4 < v7[100] && v5 >= v7[99] && v5 < v7[101]) {
      break;
    }
    v2 += 2;
    if (v2 == v3) {
      return 0;
    }
  }
  float v10 = (std::__shared_weak_count *)v2[1];
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v12[0] = v6;
  v12[1] = (uint64_t)v10;
  md::MuninRoadLabeler::setDebugHighlight(a1, v12);
  if (v10)
  {
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  return 1;
}

void sub_1A25A5FC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  geo::optional<md::RoadSearchResult>::~optional((uint64_t)va);
  _Unwind_Resume(a1);
}

void md::MuninRoadLabeler::debugDraw(md::MuninRoadLabeler *this, NSMutableString *a2, float32x2_t *a3)
{
  float v5 = a2;
  uint64_t v6 = +[VKDebugSettings sharedSettings];
  uint64_t v7 = *((void *)this + 7);
  if (v7)
  {
    uint64_t v8 = *((void *)this + 1);
    if (*(unsigned char *)(v8 + 3643))
    {
      md::MuninRoadLabel::debugDraw(v7, (uint64_t)a3);
    }
    else
    {
      [(NSMutableString *)v5 appendFormat:@"LayoutZoom:%.2f\n", *(float *)(v8 + 472)];
      uint64_t v10 = *((void *)this + 7);
      if (v10)
      {
        md::MuninRoadLabel::debugDraw(v10, (uint64_t)a3);
        float v11 = NSString;
        md::MuninRoadLabel::debugString((md::MuninRoadLabel *)__p, *((md::LabelManager **)this + 7), *((void *)this + 1));
        char v12 = v15 >= 0 ? __p : (void **)__p[0];
        float v13 = [v11 stringWithUTF8String:v12];
        [(NSMutableString *)v5 appendString:v13];

        if (v15 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
  if ([v6 enableMuninRoadNetworkMiniMap])
  {
    [v6 muninRoadNetworkMiniMapAreaInMeters];
    md::MuninRoadLabeler::debugDrawRoadNetworkMiniMap(this, a3, v9);
  }
}

void sub_1A25A6108(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void md::MuninRoadLabeler::debugDrawRoadNetworkMiniMap(md::MuninRoadLabeler *this, float32x2_t *a2, double a3)
{
  uint64_t v655 = *MEMORY[0x1E4F143B8];
  int v623 = -16776961;
  uint64_t v7 = *((void *)this + 1);
  float v574 = *(float *)(v7 + 176);
  uint64_t v8 = (double *)*((void *)this + 35);
  double v9 = v8[3];
  double v10 = v8[4];
  double v575 = v8[102];
  float v11 = *(float *)(v7 + 1508);
  LODWORD(v7) = *(_DWORD *)(v7 + 1504);
  v622[0] = 0;
  *(float *)&v622[1] = v11 * 0.25;
  v622[2] = v7;
  *(float *)&v622[3] = v11 * 0.75;
  double v572 = v10;
  double v573 = v9;
  *(double *)&long long v627 = v9;
  *((double *)&v627 + 1) = v10;
  double v600 = a3;
  double v601 = a3;
  md::DebugConsoleMapRect::DebugConsoleMapRect((uint64_t)&v602, (uint64_t)a2, (uint64_t)v622, (double *)&v627, &v601, &v600);
  a2[12].i32[0] = 0x80000000;
  float32_t v12 = v603.f32[0];
  a2[1] = v603;
  ggl::DebugConsole::drawRectangleWithFill(a2, &v604, v12);
  a2[12].i32[0] = -1;
  *(_OWORD *)v597 = 0u;
  *(_OWORD *)v598 = 0u;
  float v599 = 1.0;
  float v13 = (char *)*((void *)this + 21);
  long long v581 = (char *)this + 176;
  if (v13 != (char *)this + 176)
  {
    float v14 = 0;
    unint64_t v15 = 0;
    do
    {
      unint64_t v4 = **((void **)v13 + 4);
      unint64_t v16 = 0x9DDFEA08EB382D69 * (((8 * v4) + 8) ^ HIDWORD(v4));
      unint64_t v17 = 0x9DDFEA08EB382D69 * (HIDWORD(v4) ^ (v16 >> 47) ^ v16);
      unint64_t v18 = v17 ^ (v17 >> 47);
      unint64_t v19 = 0x9DDFEA08EB382D69 * v18;
      if (v15)
      {
        uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v15);
        v20.i16[0] = vaddlv_u8(v20);
        if (v20.u32[0] > 1uLL)
        {
          unint64_t v3 = 0x9DDFEA08EB382D69 * v18;
          if (v19 >= v15) {
            unint64_t v3 = v19 % v15;
          }
        }
        else
        {
          unint64_t v3 = v19 & (v15 - 1);
        }
        float v21 = (void *)*((void *)v597[0] + v3);
        if (v21)
        {
          float v22 = (void *)*v21;
          if (v22)
          {
            if (v20.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v24 = v22[1];
                if (v24 == v19)
                {
                  if (v22[2] == v4) {
                    goto LABEL_62;
                  }
                }
                else if ((v24 & (v15 - 1)) != v3)
                {
                  goto LABEL_24;
                }
                float v22 = (void *)*v22;
                if (!v22) {
                  goto LABEL_24;
                }
              }
            }
            do
            {
              unint64_t v23 = v22[1];
              if (v23 == v19)
              {
                if (v22[2] == v4) {
                  goto LABEL_62;
                }
              }
              else
              {
                if (v23 >= v15) {
                  v23 %= v15;
                }
                if (v23 != v3) {
                  break;
                }
              }
              float v22 = (void *)*v22;
            }
            while (v22);
          }
        }
      }
LABEL_24:
      float v25 = operator new(0x18uLL);
      *float v25 = 0;
      v25[1] = v19;
      v25[2] = v4;
      float v26 = (float)((unint64_t)v14 + 1);
      if (!v15 || (float)(v599 * (float)v15) < v26)
      {
        BOOL v27 = (v15 & (v15 - 1)) != 0;
        if (v15 < 3) {
          BOOL v27 = 1;
        }
        unint64_t v28 = v27 | (2 * v15);
        unint64_t v29 = vcvtps_u32_f32(v26 / v599);
        if (v28 <= v29) {
          size_t prime = v29;
        }
        else {
          size_t prime = v28;
        }
        if (prime == 1)
        {
          size_t prime = 2;
        }
        else if ((prime & (prime - 1)) != 0)
        {
          size_t prime = std::__next_prime(prime);
          unint64_t v15 = (unint64_t)v597[1];
        }
        if (prime > v15) {
          goto LABEL_36;
        }
        if (prime < v15)
        {
          unint64_t v31 = vcvtps_u32_f32((float)(unint64_t)v598[1] / v599);
          if (v15 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v15), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
          {
            unint64_t v31 = std::__next_prime(v31);
          }
          else
          {
            uint64_t v33 = 1 << -(char)__clz(v31 - 1);
            if (v31 >= 2) {
              unint64_t v31 = v33;
            }
          }
          if (prime <= v31) {
            size_t prime = v31;
          }
          if (prime < v15) {
LABEL_36:
          }
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)v597, prime);
        }
        unint64_t v15 = (unint64_t)v597[1];
        if (((unint64_t)v597[1] & ((unint64_t)v597[1] - 1)) != 0)
        {
          if ((void *)v19 >= v597[1]) {
            unint64_t v3 = v19 % (unint64_t)v597[1];
          }
          else {
            unint64_t v3 = v19;
          }
        }
        else
        {
          unint64_t v3 = ((unint64_t)v597[1] - 1) & v19;
        }
      }
      uint64_t v34 = v597[0];
      uint64_t v35 = (void *)*((void *)v597[0] + v3);
      if (v35)
      {
        *float v25 = *v35;
      }
      else
      {
        *float v25 = v598[0];
        v598[0] = v25;
        v34[v3] = v598;
        if (!*v25) {
          goto LABEL_61;
        }
        unint64_t v36 = *(void *)(*v25 + 8);
        if ((v15 & (v15 - 1)) != 0)
        {
          if (v36 >= v15) {
            v36 %= v15;
          }
        }
        else
        {
          v36 &= v15 - 1;
        }
        uint64_t v35 = (char *)v597[0] + 8 * v36;
      }
      *uint64_t v35 = v25;
LABEL_61:
      float v14 = ++v598[1];
LABEL_62:
      BOOL v37 = (char *)*((void *)v13 + 1);
      if (v37)
      {
        do
        {
          float v38 = v37;
          BOOL v37 = *(char **)v37;
        }
        while (v37);
      }
      else
      {
        do
        {
          float v38 = (char *)*((void *)v13 + 2);
          _ZF = *(void *)v38 == (void)v13;
          float v13 = v38;
        }
        while (!_ZF);
      }
      float v13 = v38;
    }
    while (v38 != v581);
  }
  float v40 = +[VKDebugSettings sharedSettings];
  int v579 = [v40 enableMuninMiniMapComposedEdgeRoadColoring];

  float v41 = +[VKDebugSettings sharedSettings];
  int v580 = [v41 enableMuninMiniMapRoadZData];

  BOOL v42 = +[VKDebugSettings sharedSettings];
  int v43 = [v42 enableMuninMiniMapCollectionPoints];

  if (v43)
  {
    if (*((void *)this + 18))
    {
      float v44 = (uint64_t *)*((void *)this + 27);
      unint64_t v45 = (uint64_t *)*((void *)this + 28);
      if (v44 != v45)
      {
        unint64_t v4 = (unint64_t)&v602;
        do
        {
          uint64_t v46 = *v44;
          uint64_t v47 = *(void *)(*v44 + 300);
          int v48 = 1 << *(unsigned char *)(*v44 + 297);
          double v49 = 1.0 / (double)v48;
          double v50 = v49 * (double)SHIDWORD(v47);
          if (v50 + v49 > v605.f64[0])
          {
            double v51 = v49 * (double)(v48 + ~v47);
            double v52 = v51 + v49;
            BOOL v53 = v50 >= v606.f64[0] || v52 <= v605.f64[1];
            if (!v53 && v51 < v606.f64[1])
            {
              long long v55 = *(double **)(v46 + 168);
              unsigned int v56 = *(double **)(v46 + 176);
              while (v55 != v56)
              {
                double v57 = v55[7];
                if (v57 >= v605.f64[0])
                {
                  double v58 = v55[8];
                  BOOL v59 = v57 >= v606.f64[0] || v58 < v605.f64[1];
                  if (!v59 && v58 < v606.f64[1])
                  {
                    double v61 = (v55[9] - *(double *)(*((void *)this + 18) + 160))
                        / fmax(*(double *)(*((void *)this + 18) + 168) - *(double *)(*((void *)this + 18) + 160), 40.0);
                    DWORD2(v627) = 1065353216;
                    *(void *)&long long v627 = 0;
                    *(float *)&double v61 = v61;
                    LODWORD(v642) = 0;
                    v641 = (void *)1065353216;
                    colorLerp((float *)&v644, (float *)&v627, (float *)&v641, *(float *)&v61);
                    _Q0 = *(float32x4_t *)(v55 + 7);
                    LOBYTE(v641) = (int)(float)(*(float *)&v644 * 255.0);
                    BYTE1(v641) = (int)(float)(*((float *)&v644 + 1) * 255.0);
                    BYTE2(v641) = (int)(float)(*(float *)&v645 * 255.0);
                    BYTE3(v641) = -1;
                    _D1 = v610.f64[0];
                    __asm { FMLA            D3, D1, V0.D[1] }
                    _D1 = v610.f64[1];
                    _D2 = *(float32x2_t *)&v611;
                    __asm
                    {
                      FMLA            D4, D1, V0.D[1]
                      FMLA            D1, D2, V0.D[1]
                    }
                    *(double *)_Q0.i64 = 1.0 / _D1;
                    *(float *)&_D1 = 1.0 / _D1 * _D3;
                    _Q0.f32[0] = *(double *)_Q0.i64 * _D4;
                    _D2.f32[0] = v616 * _Q0.f32[0];
                    _D2.f32[1] = v620;
                    *(float *)&_D4 = v619;
                    float64x2_t v71 = vdivq_f64(vcvtq_f64_f32(vsub_f32(v604, v603)), v607);
                    *((float *)&_D4 + 1) = v617 * _Q0.f32[0];
                    *(float32x2_t *)_Q0.f32 = vmul_n_f32(vadd_f32(vmla_n_f32(*(float32x2_t *)&_D4, v614, *(float *)&_D1), _D2), 1.0/ (float)((float)(v621 + (float)(v615 * *(float *)&_D1))+ (float)(v618 * _Q0.f32[0])));
                    _Q0.i64[1] = _Q0.i64[0];
                    float32x4_t v72 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v71), v71);
                    *(void *)&long long v73 = vsubq_f32(_Q0, v72).u64[0];
                    *((void *)&v73 + 1) = vaddq_f32(_Q0, v72).i64[1];
                    long long v627 = v73;
                    md::DebugConsoleMapRect::drawPixelRect((uint64_t)&v602, (float *)&v627, (__int8 *)&v641, 1);
                  }
                }
                v55 += 233;
              }
            }
          }
          v44 += 2;
        }
        while (v44 != v45);
      }
    }
  }
  if (!v580) {
    goto LABEL_484;
  }
  uint64_t v74 = *((void *)this + 18);
  if (!v74) {
    goto LABEL_484;
  }
  uint64_t v75 = *((void *)this + 17);
  if (!v75) {
    goto LABEL_484;
  }
  unint64_t v76 = *(double **)(v74 + 96);
  if (v76)
  {
    __asm { FMOV            V10.2S, #2.5 }
    do
    {
      uint64_t v88 = *((void *)v76 + 2);
      double v89 = *(double *)(v88 + 16);
      if (v89 >= v605.f64[0] && v89 < v606.f64[0])
      {
        double v91 = *(double *)(v88 + 24);
        if (v91 >= v605.f64[1] && v91 < v606.f64[1])
        {
          double v93 = v76[3];
          if (v93 == -1.79769313e308)
          {
            char v78 = -65;
            float v79 = 0.25;
            float v80 = 0.25;
            float v81 = 0.25;
          }
          else if (v93 == 1.79769313e308)
          {
            char v78 = -65;
            float v79 = 1.0;
            float v80 = 1.0;
            float v81 = 1.0;
          }
          else
          {
            double v94 = (v93 - *(double *)(*((void *)this + 18) + 160))
                / fmax(*(double *)(*((void *)this + 18) + 168) - *(double *)(*((void *)this + 18) + 160), 40.0);
            LODWORD(v645) = 1065353216;
            v644 = 0;
            *(float *)&double v94 = v94;
            LODWORD(v642) = 0;
            v641 = (void *)1065353216;
            double __srcd = v91;
            double __nc = v89;
            colorLerp((float *)&v627, (float *)&v644, (float *)&v641, *(float *)&v94);
            double v91 = __srcd;
            double v89 = __nc;
            float v80 = *((float *)&v627 + 1);
            float v79 = *(float *)&v627;
            char v78 = -1;
            float v81 = *((float *)&v627 + 2);
          }
          LOBYTE(v644) = (int)(float)(v79 * 255.0);
          BYTE1(v644) = (int)(float)(v80 * 255.0);
          BYTE2(v644) = (int)(float)(v81 * 255.0);
          v82.f32[0] = v619;
          float32x2_t v83 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v612, v608, v89), v610, v91), 1.0 / (v613 + v609 * v89 + v611 * v91)));
          v84.f32[0] = vmuls_lane_f32(v616, v83, 1);
          v84.f32[1] = v620;
          v82.i32[1] = vmuls_lane_f32(v617, v83, 1);
          *(float32x2_t *)v85.f32 = vmul_n_f32(vadd_f32(vmla_n_f32(v82, v614, v83.f32[0]), v84), 1.0/ (float)(vaddv_f32(vmul_f32((float32x2_t)__PAIR64__(LODWORD(v618), LODWORD(v615)), v83))+ v621));
          v85.i64[1] = v85.i64[0];
          *(float32x2_t *)v86.f32 = vmul_f32(vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(vsub_f32(v604, v603)), v607)), _D10);
          v86.i64[1] = v86.i64[0];
          BYTE3(v644) = v78;
          *(void *)&long long v87 = vsubq_f32(v85, v86).u64[0];
          *((void *)&v87 + 1) = vaddq_f32(v85, v86).i64[1];
          long long v627 = v87;
          md::DebugConsoleMapRect::drawPixelRect((uint64_t)&v602, (float *)&v627, (__int8 *)&v644, 1);
        }
      }
      unint64_t v76 = *(double **)v76;
    }
    while (v76);
    uint64_t v75 = *((void *)this + 17);
  }
  int v96 = *(unsigned char **)(v75 + 56);
  unsigned int v95 = *(unsigned char **)(v75 + 64);
  int64_t v97 = v95 - v96;
  if (v95 == v96) {
    goto LABEL_484;
  }
  if (v97 < 0) {
    abort();
  }
  unsigned int v98 = (char *)operator new(v95 - v96);
  uint64_t v99 = &v98[8 * (v97 >> 3)];
  memcpy(v98, v96, v97);
  unint64_t v4 = (unint64_t)&v602;
  __asm { FMOV            V13.2S, #2.5 }
  long long v582 = v98;
  uint64_t v583 = v99;
  while (2)
  {
    unsigned int v101 = *(double **)v98;
    if (v606.f64[0] <= *(double *)(*(void *)v98 + 104)
      || v605.f64[0] >= v101[15]
      || v606.f64[1] <= v101[14]
      || v605.f64[1] >= v101[16])
    {
      goto LABEL_121;
    }
    LOBYTE(v644) = 0;
    long long v645 = 0u;
    long long v646 = 0u;
    long long v647 = 0u;
    long long v648 = 0u;
    long long v649 = 0u;
    long long v650 = 0u;
    unint64_t v651 = 0;
    unsigned int v102 = std::__hash_table<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::__unordered_map_hasher<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::hash<md::mun::CollectionPoint const*>,std::equal_to<md::mun::CollectionPoint const*>,true>,std::__unordered_map_equal<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::equal_to<md::mun::CollectionPoint const*>,std::hash<md::mun::CollectionPoint const*>,true>,std::allocator<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>>>::find<md::mun::CollectionPoint const*>((void *)(*((void *)this + 18) + 40), (unint64_t)v101);
    if (!v102) {
      goto LABEL_477;
    }
    uint64_t v104 = v102;
    LOBYTE(v644) = *((unsigned char *)v102 + 24);
    if (v102 + 3 == &v644)
    {
      uint64_t v114 = 0;
      unsigned int v115 = 0;
      goto LABEL_153;
    }
    std::vector<gm::Range<double>>::__assign_with_size[abi:nn180100]<gm::Range<double>*,gm::Range<double>*>(&v645, (char *)v102[4], (char *)v102[5], (uint64_t)(v102[5] - v102[4]) >> 4);
    unsigned int v105 = (char *)v104[7];
    uint64_t v106 = (unsigned char *)v104[8];
    __uint64_t n = v106 - v105;
    unint64_t v107 = (v106 - v105) >> 4;
    uint64_t v108 = *((void *)&v647 + 1);
    int64_t v109 = (char *)*((void *)&v646 + 1);
    if (v107 <= (uint64_t)(*((void *)&v647 + 1) - *((void *)&v646 + 1)) >> 4)
    {
      __srca = v104;
      unint64_t v116 = (uint64_t)(v647 - *((void *)&v646 + 1)) >> 4;
      if (v116 >= v107)
      {
        if (v106 == v105)
        {
          uint64_t v104 = __srca;
LABEL_151:
          size_t v113 = __n;
          goto LABEL_152;
        }
        uint64_t v118 = (void *)*((void *)&v646 + 1);
        size_t v113 = v106 - v105;
      }
      else
      {
        if ((void)v647 != *((void *)&v646 + 1))
        {
          uint64_t v117 = v105;
          memmove(*((void **)&v646 + 1), v105, v647 - *((void *)&v646 + 1));
          unsigned int v105 = v117;
          int64_t v109 = (char *)v647;
        }
        v105 += 16 * v116;
        size_t v113 = v106 - v105;
        if (!v113) {
          goto LABEL_149;
        }
        uint64_t v118 = v109;
      }
      memmove(v118, v105, v113);
LABEL_149:
      uint64_t v104 = __srca;
      goto LABEL_152;
    }
    long long __src = (unsigned char *)v104[7];
    if (*((void *)&v646 + 1))
    {
      *(void *)&long long v647 = *((void *)&v646 + 1);
      operator delete(*((void **)&v646 + 1));
      uint64_t v108 = 0;
      *((void *)&v646 + 1) = 0;
      long long v647 = 0uLL;
    }
    if ((__n & 0x8000000000000000) != 0) {
      goto LABEL_825;
    }
    uint64_t v110 = v108 >> 3;
    if (v108 >> 3 <= v107) {
      uint64_t v110 = v107;
    }
    unint64_t v111 = (unint64_t)v108 >= 0x7FFFFFFFFFFFFFF0 ? 0xFFFFFFFFFFFFFFFLL : v110;
    if (v111 >> 60) {
LABEL_825:
    }
      abort();
    uint64_t v112 = (char *)operator new(16 * v111);
    int64_t v109 = v112;
    *((void *)&v646 + 1) = v112;
    *(void *)&long long v647 = v112;
    *((void *)&v647 + 1) = &v112[16 * v111];
    if (v106 == __src) {
      goto LABEL_151;
    }
    size_t v113 = __n;
    memcpy(v112, __src, __n);
LABEL_152:
    *(void *)&long long v647 = &v109[v113];
    std::vector<gm::Range<double>>::__assign_with_size[abi:nn180100]<gm::Range<double>*,gm::Range<double>*>(&v648, (char *)v104[10], (char *)v104[11], (uint64_t)(v104[11] - v104[10]) >> 4);
    std::vector<gm::Range<double>>::__assign_with_size[abi:nn180100]<gm::Range<double>*,gm::Range<double>*>((void *)&v649 + 1, (char *)v104[13], (char *)v104[14], (uint64_t)(v104[14] - v104[13]) >> 4);
    uint64_t v114 = (unsigned char *)*((void *)&v648 + 1);
    unsigned int v115 = (unsigned char *)v648;
LABEL_153:
    v103.n128_u64[0] = v104[16];
    unint64_t v651 = v103.n128_u64[0];
    v642 = 0;
    v641 = 0;
    v643 = 0;
    int64_t v119 = v114 - v115;
    if (v114 == v115)
    {
      int64_t v121 = 0;
      BOOL v122 = 0;
    }
    else
    {
      if (v119 < 0) {
        abort();
      }
      int64_t v120 = v115;
      int64_t v121 = (char *)operator new(v114 - v115);
      BOOL v122 = (__n128 *)&v121[16 * (v119 >> 4)];
      v641 = v121;
      v643 = v122;
      memcpy(v121, v120, v119);
      v642 = v122;
    }
    uint64_t v123 = (__n128 *)*((void *)&v649 + 1);
    uint64_t v124 = v650 - *((void *)&v649 + 1);
    if ((uint64_t)(v650 - *((void *)&v649 + 1)) >= 1)
    {
      uint64_t v125 = v124 >> 4;
      __na = v121;
      uint64_t v126 = (char *)v122 - v121;
      unint64_t v127 = (v126 >> 4) + (v124 >> 4);
      if (v127 >> 60) {
        abort();
      }
      if (v126 >> 3 > v127) {
        unint64_t v127 = v126 >> 3;
      }
      unint64_t v128 = 0xFFFFFFFFFFFFFFFLL;
      if ((unint64_t)v126 < 0x7FFFFFFFFFFFFFF0) {
        unint64_t v128 = v127;
      }
      unint64_t __srcb = v128;
      if (v128)
      {
        if (v128 >> 60) {
          goto LABEL_823;
        }
        uint64_t v129 = (char *)operator new(16 * v128);
      }
      else
      {
        uint64_t v129 = 0;
      }
      unint64_t v130 = &__na[v126 & 0xFFFFFFFFFFFFFFF0];
      uint64_t v131 = &v129[16 * (v126 >> 4)];
      uint64_t v132 = 16 * v125;
      unsigned int v133 = &v131[16 * v125];
      unsigned int v134 = (__n128 *)v131;
      do
      {
        __n128 v135 = *v123++;
        __n128 v103 = v135;
        *v134++ = v135;
        v132 -= 16;
      }
      while (v132);
      uint64_t v136 = (__n128 *)v641;
      if (v641 != v130)
      {
        uint64_t v137 = (__n128 *)v130;
        do
        {
          __n128 v103 = v137[-1];
          *((__n128 *)v131 - 1) = v103;
          v131 -= 16;
          --v137;
        }
        while (v137 != v136);
        BOOL v122 = v642;
      }
      size_t v138 = (char *)v122 - v130;
      if (v122 != (__n128 *)v130)
      {
        unint64_t v139 = v129;
        memcpy(v133, v130, v138);
        uint64_t v129 = v139;
      }
      uint64_t v140 = (__n128 *)&v129[16 * __srcb];
      uint64_t v141 = v641;
      v641 = v131;
      v642 = (__n128 *)&v133[v138];
      v643 = v140;
      if (v141) {
        operator delete(v141);
      }
    }
    unint64_t v142 = 126 - 2 * __clz(((char *)v642 - (unsigned char *)v641) >> 4);
    if (v642 == v641) {
      uint64_t v143 = 0;
    }
    else {
      uint64_t v143 = v142;
    }
    std::__introsort<std::_ClassicAlgPolicy,md::MuninRoadLabeler::debugDrawZData(md::DebugConsoleMapRect *)::$_0 &,gm::Range<double> *,false>((__n128 *)v641, v642, v143, 1, v103);
    long long v627 = xmmword_1A28FCCC0;
    md::MuninLabelingUtils::clipRange(&v638, &v627, (uint64_t *)&v641);
    md::ComposedRoadEdge::walker((md::ComposedRoadEdge *)&v627, (uint64_t)v101, (char)v644);
    uint64_t v145 = (double *)*((void *)&v648 + 1);
    unsigned int v144 = (double *)v648;
    double v146 = 15.0 / v101[18];
    if ((void)v648 == *((void *)&v648 + 1)) {
      goto LABEL_268;
    }
    while (2)
    {
      double v155 = *v144;
      double v154 = v144[1];
      if (*v144 >= 0.0 && v155 <= 1.0)
      {
        double v160 = 0.0;
        if (v637 > 0.0) {
          double v160 = v636 / v637;
        }
        double v161 = (v155 - v160) * v637;
        double v157 = v633;
        if (v633 + v161 < 0.0)
        {
          unsigned int v158 = (char *)v630;
          unint64_t v159 = v632;
          uint64_t v162 = 56 * v632 - 8;
          while (v159)
          {
            double v161 = v157 + v161;
            unint64_t v632 = --v159;
            double v157 = *(double *)((char *)v630 + v162);
            double v633 = v157;
            v162 -= 56;
            if (v157 + v161 >= 0.0)
            {
              double v163 = v157;
              double v157 = v157 + v161;
              goto LABEL_203;
            }
          }
          goto LABEL_226;
        }
        unint64_t v164 = v632;
        unsigned int v158 = (char *)v630;
        double v163 = *((double *)v630 + 7 * v632 + 6);
        if (v633 + v161 > v163)
        {
          uint64_t v165 = (v631 - (unsigned char *)v630) / 56;
          uint64_t v166 = v165 - 1;
          if (v632 != v165 - 1)
          {
            double v157 = v633 - v163 + v161;
            double v633 = 0.0;
            uint64_t v167 = 56 * v632 + 104;
            uint64_t v168 = v165 - 2;
            while (1)
            {
              unint64_t v159 = v164 + 1;
              double v163 = *(double *)((char *)v630 + v167);
              if (v157 <= v163)
              {
                unint64_t v632 = v164 + 1;
                goto LABEL_203;
              }
              if (v168 == v164) {
                break;
              }
              double v157 = v157 - v163;
              v167 += 56;
              ++v164;
            }
            unint64_t v632 = v164 + 1;
            double v157 = 0.0;
          }
          unint64_t v159 = v166;
          goto LABEL_226;
        }
        unint64_t v159 = v632;
        double v157 = v633 + v161;
LABEL_203:
        double v633 = v157;
        BOOL v169 = v157 < 0.0 || v163 < v157;
        if (v169
          || (uint64_t v170 = *(void *)&v158[56 * v159 + 24],
              uint64_t v171 = *(void *)&v158[56 * v159 + 32],
              uint64_t v172 = v171 - v170,
              v171 == v170))
        {
LABEL_213:
          double v636 = v157;
          if (!v159) {
            goto LABEL_226;
          }
        }
        else
        {
          uint64_t v173 = 0;
          unint64_t v174 = v172 >> 3;
          if (v174 <= 1) {
            unint64_t v174 = 1;
          }
          double v175 = 0.0;
          while (1)
          {
            double v176 = *(double *)(v170 + 8 * v173);
            if (v176 + v175 >= v157) {
              break;
            }
            ++v173;
            double v175 = v176 + v175;
            if (v174 == v173) {
              goto LABEL_213;
            }
          }
          uint64_t v188 = (float64x2_t *)(*(void *)&v158[56 * v159] + 16 * v173);
          float64x2_t v634 = vmlaq_n_f64(*v188, vsubq_f64(v188[1], *v188), (v157 - v175) / v176);
          float64x2_t v189 = vsubq_f64(v188[1], *v188);
          float64x2_t v635 = vmulq_n_f64(v189, 1.0 / sqrt(vaddvq_f64(vmulq_f64(v189, v189))));
          double v636 = v157;
          if (!v159) {
            goto LABEL_226;
          }
        }
        if (v159 == 1)
        {
          unint64_t v177 = 0;
          double v178 = v157;
        }
        else
        {
          unint64_t v177 = v159 & 0xFFFFFFFFFFFFFFFELL;
          float32x4_t v179 = (double *)(v158 + 104);
          double v180 = 0.0;
          unint64_t v181 = v159 & 0xFFFFFFFFFFFFFFFELL;
          double v182 = v157;
          do
          {
            double v183 = *(v179 - 7);
            double v184 = *v179;
            v179 += 14;
            double v182 = v182 + v183;
            double v180 = v180 + v184;
            v181 -= 2;
          }
          while (v181);
          double v178 = v180 + v182;
          if (v159 == v177) {
            goto LABEL_221;
          }
        }
        float32x4_t v185 = (double *)&v158[56 * v177 + 48];
        unint64_t v186 = v159 - v177;
        do
        {
          double v187 = *v185;
          v185 += 7;
          double v178 = v178 + v187;
          --v186;
        }
        while (v186);
LABEL_221:
        double v636 = v178;
        goto LABEL_226;
      }
      double v157 = v633;
      unsigned int v158 = (char *)v630;
      unint64_t v159 = v632;
LABEL_226:
      uint64_t v190 = 0;
      unint64_t v191 = (unint64_t)((v154 - v155) * (1.0 / v146));
      uint64_t v192 = (v631 - v158) / 56;
      uint64_t v193 = v192 - 1;
      if (v191 + 1 > 1) {
        uint64_t v194 = v191 + 1;
      }
      else {
        uint64_t v194 = 1;
      }
      double v195 = v637 * v146;
      uint64_t v196 = v192 - 2;
      do
      {
        double v197 = v157 + v195;
        if (v157 + v195 < 0.0)
        {
          float v198 = (double *)&v158[56 * v159 - 8];
          double v199 = v637 * v146;
          while (v159)
          {
            double v199 = v157 + v199;
            unint64_t v632 = --v159;
            double v200 = *v198;
            v198 -= 7;
            double v157 = v200;
            double v633 = v200;
            double v197 = v200 + v199;
            if (v200 + v199 >= 0.0) {
              goto LABEL_246;
            }
          }
          goto LABEL_231;
        }
        double v201 = *(double *)&v158[56 * v159 + 48];
        if (v197 <= v201)
        {
          double v157 = *(double *)&v158[56 * v159 + 48];
LABEL_246:
          double v633 = v197;
          BOOL v203 = v197 < 0.0 || v157 < v197;
          if (v203
            || (uint64_t v205 = *(void *)&v158[56 * v159 + 24],
                uint64_t v204 = *(void *)&v158[56 * v159 + 32],
                uint64_t v206 = v204 - v205,
                v204 == v205))
          {
LABEL_256:
            double v636 = v197;
            if (!v159) {
              goto LABEL_232;
            }
LABEL_257:
            if (v159 == 1)
            {
              unint64_t v211 = 0;
              double v212 = v197;
              goto LABEL_262;
            }
            unint64_t v211 = v159 & 0xFFFFFFFFFFFFFFFELL;
            double v213 = 0.0;
            unint64_t v214 = v159 & 0xFFFFFFFFFFFFFFFELL;
            int8x16_t v215 = (double *)(v158 + 104);
            double v216 = v197;
            do
            {
              double v217 = *(v215 - 7);
              double v218 = *v215;
              v215 += 14;
              double v216 = v216 + v217;
              double v213 = v213 + v218;
              v214 -= 2;
            }
            while (v214);
            double v212 = v213 + v216;
            if (v159 != v211)
            {
LABEL_262:
              float32x4_t v219 = (double *)&v158[56 * v211 + 48];
              unint64_t v220 = v159 - v211;
              do
              {
                double v221 = *v219;
                v219 += 7;
                double v212 = v212 + v221;
                --v220;
              }
              while (v220);
            }
            double v636 = v212;
            goto LABEL_232;
          }
          uint64_t v207 = 0;
          unint64_t v208 = v206 >> 3;
          if (v208 <= 1) {
            unint64_t v208 = 1;
          }
          double v209 = 0.0;
          while (1)
          {
            double v210 = *(double *)(v205 + 8 * v207);
            if (v210 + v209 >= v197) {
              break;
            }
            ++v207;
            double v209 = v210 + v209;
            if (v208 == v207) {
              goto LABEL_256;
            }
          }
          uint64_t v222 = (float64x2_t *)(*(void *)&v158[56 * v159] + 16 * v207);
          float64x2_t v634 = vmlaq_n_f64(*v222, vsubq_f64(v222[1], *v222), (v197 - v209) / v210);
          float64x2_t v223 = vsubq_f64(v222[1], *v222);
          float64x2_t v635 = vmulq_n_f64(v223, 1.0 / sqrt(vaddvq_f64(vmulq_f64(v223, v223))));
          double v636 = v197;
          if (v159) {
            goto LABEL_257;
          }
        }
        else
        {
          if (v159 == v193)
          {
            unint64_t v159 = v193;
LABEL_231:
            double v197 = v157;
            goto LABEL_232;
          }
          double v197 = v157 - v201 + v195;
          double v633 = 0.0;
          for (uint64_t i = (double *)&v158[56 * v159 + 104]; ; i += 7)
          {
            double v157 = *i;
            if (v197 <= *i)
            {
              unint64_t v632 = ++v159;
              goto LABEL_246;
            }
            if (v196 == v159) {
              break;
            }
            double v197 = v197 - v157;
            ++v159;
          }
          unint64_t v632 = v159 + 1;
          double v197 = 0.0;
          unint64_t v159 = v193;
        }
LABEL_232:
        ++v190;
        double v157 = v197;
      }
      while (v190 != v194);
      double v147 = 1.0 / (v613 + v609 * v634.f64[0] + v611 * v634.f64[1]);
      float v148 = v147 * (v612.f64[0] + v608.f64[0] * v634.f64[0] + v610.f64[0] * v634.f64[1]);
      *(float *)&double v147 = v147 * (v612.f64[1] + v608.f64[1] * v634.f64[0] + v610.f64[1] * v634.f64[1]);
      v149.f32[0] = v616 * *(float *)&v147;
      v149.f32[1] = v620;
      v150.f32[0] = v619;
      v150.f32[1] = v617 * *(float *)&v147;
      *(float32x2_t *)v151.f32 = vmul_n_f32(vadd_f32(vmla_n_f32(v150, v614, v148), v149), 1.0 / (float)((float)(v621 + (float)(v615 * v148)) + (float)(v618 * *(float *)&v147)));
      v151.i64[1] = v151.i64[0];
      *(float32x2_t *)v152.f32 = vmul_f32(vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(vsub_f32(v604, v603)), v607)), _D13);
      v152.i64[1] = v152.i64[0];
      v626[0] = NAN;
      *(void *)&long long v153 = vsubq_f32(v151, v152).u64[0];
      *((void *)&v153 + 1) = vaddq_f32(v151, v152).i64[1];
      long long v652 = v153;
      md::DebugConsoleMapRect::drawPixelRect((uint64_t)&v602, (float *)&v652, (__int8 *)v626, 1);
      v144 += 2;
      if (v144 != v145) {
        continue;
      }
      break;
    }
LABEL_268:
    uint64_t v224 = (double *)*((void *)&v649 + 1);
    unint64_t v225 = (double *)v650;
    if (*((void *)&v649 + 1) == (void)v650) {
      goto LABEL_356;
    }
    while (2)
    {
      double v234 = *v224;
      double v233 = v224[1];
      if (*v224 < 0.0 || v234 > 1.0)
      {
        double v236 = v633;
        int16x8_t v237 = (char *)v630;
        unint64_t v238 = v632;
        goto LABEL_314;
      }
      double v239 = 0.0;
      if (v637 > 0.0) {
        double v239 = v636 / v637;
      }
      double v240 = (v234 - v239) * v637;
      double v236 = v633;
      if (v633 + v240 < 0.0)
      {
        int16x8_t v237 = (char *)v630;
        unint64_t v238 = v632;
        uint64_t v241 = 56 * v632 - 8;
        while (v238)
        {
          double v240 = v236 + v240;
          unint64_t v632 = --v238;
          double v236 = *(double *)((char *)v630 + v241);
          double v633 = v236;
          v241 -= 56;
          if (v236 + v240 >= 0.0)
          {
            double v242 = v236;
            double v236 = v236 + v240;
            goto LABEL_291;
          }
        }
        goto LABEL_314;
      }
      unint64_t v243 = v632;
      int16x8_t v237 = (char *)v630;
      double v242 = *((double *)v630 + 7 * v632 + 6);
      if (v633 + v240 <= v242)
      {
        unint64_t v238 = v632;
        double v236 = v633 + v240;
LABEL_291:
        double v633 = v236;
        BOOL v248 = v236 < 0.0 || v242 < v236;
        if (v248
          || (uint64_t v249 = *(void *)&v237[56 * v238 + 24],
              uint64_t v250 = *(void *)&v237[56 * v238 + 32],
              uint64_t v251 = v250 - v249,
              v250 == v249))
        {
LABEL_301:
          double v636 = v236;
          if (!v238) {
            goto LABEL_314;
          }
        }
        else
        {
          uint64_t v252 = 0;
          unint64_t v253 = v251 >> 3;
          if (v253 <= 1) {
            unint64_t v253 = 1;
          }
          double v254 = 0.0;
          while (1)
          {
            double v255 = *(double *)(v249 + 8 * v252);
            if (v255 + v254 >= v236) {
              break;
            }
            ++v252;
            double v254 = v255 + v254;
            if (v253 == v252) {
              goto LABEL_301;
            }
          }
          int v267 = (float64x2_t *)(*(void *)&v237[56 * v238] + 16 * v252);
          float64x2_t v634 = vmlaq_n_f64(*v267, vsubq_f64(v267[1], *v267), (v236 - v254) / v255);
          float64x2_t v268 = vsubq_f64(v267[1], *v267);
          float64x2_t v635 = vmulq_n_f64(v268, 1.0 / sqrt(vaddvq_f64(vmulq_f64(v268, v268))));
          double v636 = v236;
          if (!v238) {
            goto LABEL_314;
          }
        }
        if (v238 == 1)
        {
          unint64_t v256 = 0;
          double v257 = v236;
        }
        else
        {
          unint64_t v256 = v238 & 0xFFFFFFFFFFFFFFFELL;
          int8x16_t v258 = (double *)(v237 + 104);
          double v259 = 0.0;
          unint64_t v260 = v238 & 0xFFFFFFFFFFFFFFFELL;
          double v261 = v236;
          do
          {
            double v262 = *(v258 - 7);
            double v263 = *v258;
            v258 += 14;
            double v261 = v261 + v262;
            double v259 = v259 + v263;
            v260 -= 2;
          }
          while (v260);
          double v257 = v259 + v261;
          if (v238 == v256) {
            goto LABEL_309;
          }
        }
        uint64_t v264 = (double *)&v237[56 * v256 + 48];
        unint64_t v265 = v238 - v256;
        do
        {
          double v266 = *v264;
          v264 += 7;
          double v257 = v257 + v266;
          --v265;
        }
        while (v265);
LABEL_309:
        double v636 = v257;
        goto LABEL_314;
      }
      uint64_t v244 = (v631 - (unsigned char *)v630) / 56;
      uint64_t v245 = v244 - 1;
      if (v632 != v244 - 1)
      {
        double v236 = v633 - v242 + v240;
        double v633 = 0.0;
        uint64_t v246 = 56 * v632 + 104;
        uint64_t v247 = v244 - 2;
        while (1)
        {
          unint64_t v238 = v243 + 1;
          double v242 = *(double *)((char *)v630 + v246);
          if (v236 <= v242)
          {
            unint64_t v632 = v243 + 1;
            goto LABEL_291;
          }
          if (v247 == v243) {
            break;
          }
          double v236 = v236 - v242;
          v246 += 56;
          ++v243;
        }
        unint64_t v632 = v243 + 1;
        double v236 = 0.0;
      }
      unint64_t v238 = v245;
LABEL_314:
      uint64_t v269 = 0;
      unint64_t v270 = (unint64_t)((v233 - v234) * (1.0 / v146));
      uint64_t v271 = (v631 - v237) / 56;
      uint64_t v272 = v271 - 1;
      if (v270 + 1 > 1) {
        uint64_t v273 = v270 + 1;
      }
      else {
        uint64_t v273 = 1;
      }
      double v274 = v637 * v146;
      uint64_t v275 = v271 - 2;
      while (2)
      {
        double v276 = v236 + v274;
        if (v236 + v274 < 0.0)
        {
          int8x16_t v277 = (double *)&v237[56 * v238 - 8];
          double v278 = v637 * v146;
          while (v238)
          {
            double v278 = v236 + v278;
            unint64_t v632 = --v238;
            double v279 = *v277;
            v277 -= 7;
            double v236 = v279;
            double v633 = v279;
            double v276 = v279 + v278;
            if (v279 + v278 >= 0.0) {
              goto LABEL_334;
            }
          }
LABEL_319:
          double v276 = v236;
          goto LABEL_320;
        }
        double v280 = *(double *)&v237[56 * v238 + 48];
        if (v276 <= v280)
        {
          double v236 = *(double *)&v237[56 * v238 + 48];
LABEL_334:
          double v633 = v276;
          BOOL v282 = v276 < 0.0 || v236 < v276;
          if (v282
            || (uint64_t v284 = *(void *)&v237[56 * v238 + 24],
                uint64_t v283 = *(void *)&v237[56 * v238 + 32],
                uint64_t v285 = v283 - v284,
                v283 == v284))
          {
LABEL_344:
            double v636 = v276;
            if (!v238) {
              goto LABEL_320;
            }
          }
          else
          {
            uint64_t v286 = 0;
            unint64_t v287 = v285 >> 3;
            if (v287 <= 1) {
              unint64_t v287 = 1;
            }
            double v288 = 0.0;
            while (1)
            {
              double v289 = *(double *)(v284 + 8 * v286);
              if (v289 + v288 >= v276) {
                break;
              }
              ++v286;
              double v288 = v289 + v288;
              if (v287 == v286) {
                goto LABEL_344;
              }
            }
            uint64_t v301 = (float64x2_t *)(*(void *)&v237[56 * v238] + 16 * v286);
            float64x2_t v634 = vmlaq_n_f64(*v301, vsubq_f64(v301[1], *v301), (v276 - v288) / v289);
            float64x2_t v302 = vsubq_f64(v301[1], *v301);
            float64x2_t v635 = vmulq_n_f64(v302, 1.0 / sqrt(vaddvq_f64(vmulq_f64(v302, v302))));
            double v636 = v276;
            if (!v238) {
              goto LABEL_320;
            }
          }
          if (v238 == 1)
          {
            unint64_t v290 = 0;
            double v291 = v276;
          }
          else
          {
            unint64_t v290 = v238 & 0xFFFFFFFFFFFFFFFELL;
            double v292 = 0.0;
            unint64_t v293 = v238 & 0xFFFFFFFFFFFFFFFELL;
            float v294 = (double *)(v237 + 104);
            double v295 = v276;
            do
            {
              double v296 = *(v294 - 7);
              double v297 = *v294;
              v294 += 14;
              double v295 = v295 + v296;
              double v292 = v292 + v297;
              v293 -= 2;
            }
            while (v293);
            double v291 = v292 + v295;
            if (v238 == v290) {
              goto LABEL_352;
            }
          }
          unint64_t v298 = (double *)&v237[56 * v290 + 48];
          unint64_t v299 = v238 - v290;
          do
          {
            double v300 = *v298;
            v298 += 7;
            double v291 = v291 + v300;
            --v299;
          }
          while (v299);
LABEL_352:
          double v636 = v291;
          goto LABEL_320;
        }
        if (v238 == v272)
        {
          unint64_t v238 = v272;
          goto LABEL_319;
        }
        double v276 = v236 - v280 + v274;
        double v633 = 0.0;
        for (uint64_t j = (double *)&v237[56 * v238 + 104]; ; j += 7)
        {
          double v236 = *j;
          if (v276 <= *j)
          {
            unint64_t v632 = ++v238;
            goto LABEL_334;
          }
          if (v275 == v238) {
            break;
          }
          double v276 = v276 - v236;
          ++v238;
        }
        unint64_t v632 = v238 + 1;
        double v276 = 0.0;
        unint64_t v238 = v272;
LABEL_320:
        ++v269;
        double v236 = v276;
        if (v269 != v273) {
          continue;
        }
        break;
      }
      double v226 = 1.0 / (v613 + v609 * v634.f64[0] + v611 * v634.f64[1]);
      float v227 = v226 * (v612.f64[0] + v608.f64[0] * v634.f64[0] + v610.f64[0] * v634.f64[1]);
      *(float *)&double v226 = v226 * (v612.f64[1] + v608.f64[1] * v634.f64[0] + v610.f64[1] * v634.f64[1]);
      v228.f32[0] = v616 * *(float *)&v226;
      v228.f32[1] = v620;
      v229.f32[0] = v619;
      v229.f32[1] = v617 * *(float *)&v226;
      *(float32x2_t *)v230.f32 = vmul_n_f32(vadd_f32(vmla_n_f32(v229, v614, v227), v228), 1.0 / (float)((float)(v621 + (float)(v615 * v227)) + (float)(v618 * *(float *)&v226)));
      v230.i64[1] = v230.i64[0];
      *(float32x2_t *)v231.f32 = vmul_f32(vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(vsub_f32(v604, v603)), v607)), _D13);
      v231.i64[1] = v231.i64[0];
      v626[0] = -1.7014e38;
      *(void *)&long long v232 = vsubq_f32(v230, v231).u64[0];
      *((void *)&v232 + 1) = vaddq_f32(v230, v231).i64[1];
      long long v652 = v232;
      md::DebugConsoleMapRect::drawPixelRect((uint64_t)&v602, (float *)&v652, (__int8 *)v626, 1);
      v224 += 2;
      if (v224 != v225) {
        continue;
      }
      break;
    }
LABEL_356:
    long long v303 = (double *)v639;
    if (v639 == &v638) {
      goto LABEL_458;
    }
    while (2)
    {
      double v305 = v303[2];
      double v304 = v303[3];
      if (v305 < 0.0 || v305 > 1.0)
      {
LABEL_363:
        unint64_t v307 = 0;
        goto LABEL_398;
      }
      double v308 = 0.0;
      if (v637 > 0.0) {
        double v308 = v636 / v637;
      }
      double v309 = (v305 - v308) * v637;
      double v310 = v633;
      double v311 = v633 + v309;
      if (v633 + v309 < 0.0)
      {
        long long v312 = (char *)v630;
        unint64_t v307 = v632;
        uint64_t v313 = 56 * v632 - 8;
        while (v307)
        {
          double v309 = v310 + v309;
          unint64_t v632 = --v307;
          double v310 = *(double *)((char *)v630 + v313);
          double v633 = v310;
          double v311 = v310 + v309;
          v313 -= 56;
          if (v310 + v309 >= 0.0)
          {
            double v314 = v310;
            goto LABEL_379;
          }
        }
        goto LABEL_398;
      }
      unint64_t v315 = v632;
      long long v312 = (char *)v630;
      double v314 = *((double *)v630 + 7 * v632 + 6);
      if (v311 <= v314)
      {
        unint64_t v307 = v632;
LABEL_379:
        double v633 = v311;
        BOOL v319 = v311 < 0.0 || v314 < v311;
        if (v319
          || (uint64_t v320 = *(void *)&v312[56 * v307 + 24],
              uint64_t v321 = *(void *)&v312[56 * v307 + 32],
              uint64_t v322 = v321 - v320,
              v321 == v320))
        {
LABEL_389:
          double v636 = v311;
          if (!v307) {
            goto LABEL_398;
          }
        }
        else
        {
          uint64_t v323 = 0;
          unint64_t v324 = v322 >> 3;
          if (v324 <= 1) {
            unint64_t v324 = 1;
          }
          double v325 = 0.0;
          while (1)
          {
            double v326 = *(double *)(v320 + 8 * v323);
            if (v326 + v325 >= v311) {
              break;
            }
            ++v323;
            double v325 = v326 + v325;
            if (v324 == v323) {
              goto LABEL_389;
            }
          }
          long long v383 = (float64x2_t *)(*(void *)&v312[56 * v307] + 16 * v323);
          float64x2_t v634 = vmlaq_n_f64(*v383, vsubq_f64(v383[1], *v383), (v311 - v325) / v326);
          float64x2_t v384 = vsubq_f64(v383[1], *v383);
          float64x2_t v635 = vmulq_n_f64(v384, 1.0 / sqrt(vaddvq_f64(vmulq_f64(v384, v384))));
          double v636 = v311;
          if (!v307) {
            goto LABEL_398;
          }
        }
        if (v307 == 1)
        {
          unint64_t v327 = 0;
        }
        else
        {
          unint64_t v327 = v307 & 0xFFFFFFFFFFFFFFFELL;
          unint64_t v328 = (double *)(v312 + 104);
          double v329 = 0.0;
          unint64_t v330 = v307 & 0xFFFFFFFFFFFFFFFELL;
          do
          {
            double v331 = *(v328 - 7);
            double v332 = *v328;
            v328 += 14;
            double v311 = v311 + v331;
            double v329 = v329 + v332;
            v330 -= 2;
          }
          while (v330);
          double v311 = v329 + v311;
          if (v307 == v327) {
            goto LABEL_397;
          }
        }
        unint64_t v333 = (double *)&v312[56 * v327 + 48];
        unint64_t v334 = v307 - v327;
        do
        {
          double v335 = *v333;
          v333 += 7;
          double v311 = v311 + v335;
          --v334;
        }
        while (v334);
LABEL_397:
        unint64_t v307 = 0;
        double v636 = v311;
        goto LABEL_398;
      }
      uint64_t v316 = (v631 - (unsigned char *)v630) / 56;
      if (v632 == v316 - 1) {
        goto LABEL_363;
      }
      double v311 = v633 - v314 + v309;
      double v633 = 0.0;
      uint64_t v317 = 56 * v632 + 104;
      uint64_t v318 = v316 - 2;
      while (1)
      {
        unint64_t v307 = v315 + 1;
        double v314 = *(double *)((char *)v630 + v317);
        if (v311 <= v314)
        {
          unint64_t v632 = v315 + 1;
          goto LABEL_379;
        }
        if (v318 == v315) {
          break;
        }
        double v311 = v311 - v314;
        v317 += 56;
        ++v315;
      }
      unint64_t v632 = v315 + 1;
      unint64_t v307 = 0;
LABEL_398:
      unint64_t v336 = (unint64_t)((v304 - v305) * (1.0 / v146));
      while (2)
      {
        double v347 = v633;
        double v348 = v637 * v146;
        double v349 = v633 + v637 * v146;
        if (v349 < 0.0)
        {
          unint64_t v350 = (char *)v630;
          unint64_t v351 = v632;
          uint64_t v352 = 56 * v632 - 8;
          while (v351)
          {
            double v348 = v347 + v348;
            unint64_t v632 = --v351;
            double v347 = *(double *)((char *)v630 + v352);
            double v633 = v347;
            double v349 = v347 + v348;
            v352 -= 56;
            if (v347 + v348 >= 0.0)
            {
              double v353 = v347;
              goto LABEL_416;
            }
          }
          goto LABEL_435;
        }
        unint64_t v354 = v632;
        unint64_t v350 = (char *)v630;
        double v353 = *((double *)v630 + 7 * v632 + 6);
        if (v349 <= v353)
        {
          unint64_t v351 = v632;
LABEL_416:
          double v633 = v349;
          BOOL v358 = v349 < 0.0 || v353 < v349;
          if (v358
            || (uint64_t v359 = *(void *)&v350[56 * v351 + 24],
                uint64_t v360 = *(void *)&v350[56 * v351 + 32],
                uint64_t v361 = v360 - v359,
                v360 == v359))
          {
LABEL_426:
            double v636 = v349;
            if (!v351) {
              goto LABEL_435;
            }
          }
          else
          {
            uint64_t v362 = 0;
            unint64_t v363 = v361 >> 3;
            if (v363 <= 1) {
              unint64_t v363 = 1;
            }
            double v364 = 0.0;
            while (1)
            {
              double v365 = *(double *)(v359 + 8 * v362);
              if (v365 + v364 >= v349) {
                break;
              }
              ++v362;
              double v364 = v365 + v364;
              if (v363 == v362) {
                goto LABEL_426;
              }
            }
            float v381 = (float64x2_t *)(*(void *)&v350[56 * v351] + 16 * v362);
            float64x2_t v634 = vmlaq_n_f64(*v381, vsubq_f64(v381[1], *v381), (v349 - v364) / v365);
            float64x2_t v382 = vsubq_f64(v381[1], *v381);
            float64x2_t v635 = vmulq_n_f64(v382, 1.0 / sqrt(vaddvq_f64(vmulq_f64(v382, v382))));
            double v636 = v349;
            if (!v351) {
              goto LABEL_435;
            }
          }
          if (v351 == 1)
          {
            unint64_t v366 = 0;
          }
          else
          {
            unint64_t v366 = v351 & 0xFFFFFFFFFFFFFFFELL;
            vImagePixelCount v367 = (double *)(v350 + 104);
            double v368 = 0.0;
            unint64_t v369 = v351 & 0xFFFFFFFFFFFFFFFELL;
            do
            {
              double v370 = *(v367 - 7);
              double v371 = *v367;
              v367 += 14;
              double v349 = v349 + v370;
              double v368 = v368 + v371;
              v369 -= 2;
            }
            while (v369);
            double v349 = v368 + v349;
            if (v351 == v366) {
              goto LABEL_434;
            }
          }
          unint64_t v372 = (double *)&v350[56 * v366 + 48];
          unint64_t v373 = v351 - v366;
          do
          {
            double v374 = *v372;
            v372 += 7;
            double v349 = v349 + v374;
            --v373;
          }
          while (v373);
LABEL_434:
          double v636 = v349;
          goto LABEL_435;
        }
        uint64_t v355 = (v631 - (unsigned char *)v630) / 56;
        if (v632 != v355 - 1)
        {
          double v349 = v633 - v353 + v348;
          double v633 = 0.0;
          uint64_t v356 = 56 * v632 + 104;
          uint64_t v357 = v355 - 2;
          while (1)
          {
            unint64_t v351 = v354 + 1;
            double v353 = *(double *)((char *)v630 + v356);
            if (v349 <= v353)
            {
              unint64_t v632 = v354 + 1;
              goto LABEL_416;
            }
            if (v357 == v354) {
              break;
            }
            double v349 = v349 - v353;
            v356 += 56;
            ++v354;
          }
          unint64_t v632 = v354 + 1;
        }
LABEL_435:
        if (v634.f64[0] >= v605.f64[0]
          && v634.f64[0] < v606.f64[0]
          && v634.f64[1] >= v605.f64[1]
          && v634.f64[1] < v606.f64[1])
        {
          double __srcc = v634.f64[1];
          double __nb = v634.f64[0];
          if ((void)v645 == *((void *)&v645 + 1))
          {
            double v338 = 0.0;
          }
          else
          {
            double v377 = v146 * (double)v307;
            uint64_t v378 = (uint64_t)(*((void *)&v645 + 1) - v645) >> 4;
            uint64_t v379 = v378 - 1;
            if (v378 == 1)
            {
              uint64_t v337 = 0;
            }
            else
            {
              uint64_t v337 = 0;
              int v380 = (double *)v645;
              while (*v380 < v377)
              {
                ++v337;
                v380 += 2;
                if (v379 == v337)
                {
                  uint64_t v337 = v379;
                  break;
                }
              }
            }
            double v338 = *(double *)(*((void *)&v646 + 1) + 16 * v337 + 8)
                 + *(double *)(*((void *)&v646 + 1) + 16 * v337) * v377;
          }
          BOOL v339 = (void)v645 != *((void *)&v645 + 1);
          double v340 = (v338 - *(double *)(*((void *)this + 18) + 160))
               / fmax(*(double *)(*((void *)this + 18) + 168) - *(double *)(*((void *)this + 18) + 160), 40.0);
          DWORD2(v652) = 1065353216;
          *(void *)&long long v652 = 0;
          *(float *)&double v340 = v340;
          int v625 = 0;
          uint64_t v624 = 1065353216;
          colorLerp(v626, (float *)&v652, (float *)&v624, *(float *)&v340);
          LOBYTE(v624) = (int)(float)(v626[0] * 255.0);
          BYTE1(v624) = (int)(float)(v626[1] * 255.0);
          BYTE2(v624) = (int)(float)(v626[2] * 255.0);
          v341.f32[0] = v619;
          unint64_t v4 = (unint64_t)&v602;
          float32x2_t v342 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v612, v608, __nb), v610, __srcc), 1.0 / (v613 + v609 * __nb + v611 * __srcc)));
          v343.f32[0] = vmuls_lane_f32(v616, v342, 1);
          v343.f32[1] = v620;
          v341.i32[1] = vmuls_lane_f32(v617, v342, 1);
          *(float32x2_t *)v344.f32 = vmul_n_f32(vadd_f32(vmla_n_f32(v341, v614, v342.f32[0]), v343), 1.0/ (float)(vaddv_f32(vmul_f32((float32x2_t)__PAIR64__(LODWORD(v618), LODWORD(v615)), v342))+ v621));
          v344.i64[1] = v344.i64[0];
          *(float32x2_t *)v345.f32 = vmul_f32(vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(vsub_f32(v604, v603)), v607)), _D13);
          v345.i64[1] = v345.i64[0];
          BYTE3(v624) = 64;
          *(void *)&long long v346 = vsubq_f32(v344, v345).u64[0];
          *((void *)&v346 + 1) = vaddq_f32(v344, v345).i64[1];
          long long v652 = v346;
          md::DebugConsoleMapRect::drawPixelRect((uint64_t)&v602, (float *)&v652, (__int8 *)&v624, v339);
        }
        if (++v307 <= v336) {
          continue;
        }
        break;
      }
      long long v303 = (double *)*((void *)v303 + 1);
      if (v303 != (double *)&v638) {
        continue;
      }
      break;
    }
LABEL_458:
    size_t v385 = (char *)v630;
    if (v630)
    {
      unint64_t v386 = v631;
      uint64_t v387 = v630;
      if (v631 != v630)
      {
        do
        {
          uint64_t v388 = (void *)*((void *)v386 - 4);
          if (v388)
          {
            *((void *)v386 - 3) = v388;
            operator delete(v388);
          }
          unint64_t v389 = (void *)*((void *)v386 - 7);
          if (v389)
          {
            *((void *)v386 - 6) = v389;
            operator delete(v389);
          }
          v386 -= 56;
        }
        while (v386 != v385);
        uint64_t v387 = v630;
      }
      v631 = v385;
      operator delete(v387);
    }
    if ((void)v628)
    {
      *((void *)&v628 + 1) = v628;
      operator delete((void *)v628);
    }
    if (v640)
    {
      uint64_t v390 = (MuninRoadEdge **)v639;
      uint64_t v391 = v638;
      uint64_t v392 = *(void *)v639;
      *(void *)(v392 + 8) = *((void *)v638 + 1);
      **((void **)v391 + 1) = v392;
      uint64_t v640 = 0;
      if (v390 != &v638)
      {
        do
        {
          uint64_t v393 = (MuninRoadEdge **)v390[1];
          operator delete(v390);
          uint64_t v390 = v393;
        }
        while (v393 != &v638);
      }
    }
    if (v641) {
      operator delete(v641);
    }
    uint64_t v99 = v583;
    if (*((void *)&v649 + 1))
    {
      *(void *)&long long v650 = *((void *)&v649 + 1);
      operator delete(*((void **)&v649 + 1));
    }
LABEL_477:
    if ((void)v648)
    {
      *((void *)&v648 + 1) = v648;
      operator delete((void *)v648);
    }
    if (*((void *)&v646 + 1))
    {
      *(void *)&long long v647 = *((void *)&v646 + 1);
      operator delete(*((void **)&v646 + 1));
    }
    if ((void)v645)
    {
      *((void *)&v645 + 1) = v645;
      operator delete((void *)v645);
    }
LABEL_121:
    v98 += 8;
    if (v98 != v99) {
      continue;
    }
    break;
  }
  operator delete(v582);
LABEL_484:
  LODWORD(v652) = -1;
  long long v645 = 0uLL;
  v644 = 0;
  unint64_t v395 = (uint64_t *)*((void *)this + 24);
  long long v394 = (uint64_t *)*((void *)this + 25);
  if (v395 == v394) {
    goto LABEL_816;
  }
  char v578 = 0;
  unsigned int v396 = (float)(v574 + v574);
  float v577 = (void *)((char *)this + 256);
  __asm { FMOV            V0.2D, #0.5 }
  float64x2_t v584 = _Q0;
  float64x2_t v585 = (float64x2_t)vdupq_n_s64(0x3FC45F306DC9C883uLL);
  float v576 = (uint64_t *)*((void *)this + 25);
  while (2)
  {
    uint64_t v398 = *v395;
    int v399 = 1 << *(unsigned char *)(*v395 + 169);
    double v400 = 1.0 / (double)v399;
    double v401 = v400 * (double)*(int *)(*v395 + 176);
    if (v401 + v400 <= v605.f64[0]) {
      goto LABEL_487;
    }
    double v402 = v400 * (double)(v399 + ~*(_DWORD *)(v398 + 172));
    double v403 = v402 + v400;
    BOOL v404 = v401 >= v606.f64[0] || v403 <= v605.f64[1];
    if (v404 || v402 >= v606.f64[1]) {
      goto LABEL_487;
    }
    LODWORD(v652) = -1;
    uint64_t v406 = *(MuninRoadEdge ***)(v398 + 752);
    unint64_t v407 = *(MuninRoadEdge ***)(v398 + 760);
    if (v406 == v407) {
      goto LABEL_707;
    }
    while (2)
    {
      v638 = 0;
      long long v408 = *v406;
      v638 = *v406;
      v642 = 0;
      v641 = 0;
      if (!v579)
      {
        if (v408 != *((MuninRoadEdge **)this + 19))
        {
          if (*((unsigned char *)v408 + 112))
          {
            int v417 = -1;
            goto LABEL_509;
          }
          goto LABEL_512;
        }
        double v403 = -5.82767265e303;
LABEL_561:
        LODWORD(v652) = LODWORD(v403);
        if (!v580) {
          goto LABEL_686;
        }
        goto LABEL_615;
      }
      unint64_t v409 = md::MuninRoadGraph::composedEdgeForEdge(*((int8x8_t **)this + 17), (unint64_t)v408);
      if (!v409)
      {
        if (*((unsigned char *)v408 + 112))
        {
LABEL_512:
          double v403 = -4.09174166e149;
          goto LABEL_561;
        }
        *(void *)&double v403 = 541081664;
        goto LABEL_561;
      }
      unint64_t v410 = v409;
      unint64_t v411 = 0x9DDFEA08EB382D69 * (((8 * v409) + 8) ^ HIDWORD(v409));
      unint64_t v412 = 0x9DDFEA08EB382D69 * (HIDWORD(v409) ^ (v411 >> 47) ^ v411);
      unint64_t v413 = v412 ^ (v412 >> 47);
      unint64_t v414 = 0x9DDFEA08EB382D69 * v413;
      unint64_t v415 = *((void *)this + 31);
      if (!v415) {
        goto LABEL_531;
      }
      double v403 = COERCE_DOUBLE(vcnt_s8((int8x8_t)v415));
      LOWORD(v403) = vaddlv_u8(*(uint8x8_t *)&v403);
      if (LODWORD(v403) > 1uLL)
      {
        unint64_t v416 = 0x9DDFEA08EB382D69 * v413;
        if (v414 >= v415) {
          unint64_t v416 = v414 % v415;
        }
      }
      else
      {
        unint64_t v416 = (v415 - 1) & v414;
      }
      uint64_t v418 = *(uint64_t ***)(*((void *)this + 30) + 8 * v416);
      if (!v418 || (unint64_t v419 = *v418) == 0)
      {
LABEL_531:
        int v422 = kDebugColors[v578 & 0x3F];
        LOBYTE(v652) = BYTE2(v422);
        BYTE1(v652) = BYTE1(v422);
        BYTE2(v652) = v422;
        BYTE3(v652) = -1;
        if (v415)
        {
          double v403 = COERCE_DOUBLE(vcnt_s8((int8x8_t)v415));
          LOWORD(v403) = vaddlv_u8(*(uint8x8_t *)&v403);
          if (LODWORD(v403) > 1uLL)
          {
            unint64_t v4 = v414;
            if (v414 >= v415) {
              unint64_t v4 = v414 % v415;
            }
          }
          else
          {
            unint64_t v4 = v414 & (v415 - 1);
          }
          uint64_t v423 = *(void **)(*((void *)this + 30) + 8 * v4);
          if (v423)
          {
            unint64_t v424 = (void *)*v423;
            if (v424)
            {
              if (LODWORD(v403) < 2uLL)
              {
                while (1)
                {
                  uint64_t v426 = v424[1];
                  if (v426 == v414)
                  {
                    if (v424[2] == v409) {
                      goto LABEL_614;
                    }
                  }
                  else if ((v426 & (v415 - 1)) != v4)
                  {
                    goto LABEL_551;
                  }
                  unint64_t v424 = (void *)*v424;
                  if (!v424) {
                    goto LABEL_551;
                  }
                }
              }
              do
              {
                unint64_t v425 = v424[1];
                if (v425 == v414)
                {
                  if (v424[2] == v409) {
                    goto LABEL_614;
                  }
                }
                else
                {
                  if (v425 >= v415) {
                    v425 %= v415;
                  }
                  if (v425 != v4) {
                    break;
                  }
                }
                unint64_t v424 = (void *)*v424;
              }
              while (v424);
            }
          }
        }
LABEL_551:
        uint64_t v427 = operator new(0x20uLL);
        void *v427 = 0;
        v427[1] = v414;
        v427[2] = v410;
        *((_DWORD *)v427 + 6) = v652;
        *(float *)&double v403 = (float)(unint64_t)(*((void *)this + 33) + 1);
        float v428 = *((float *)this + 68);
        if (v415 && (float)(v428 * (float)v415) >= *(float *)&v403)
        {
LABEL_604:
          uint64_t v450 = *((void *)this + 30);
          BOOL v451 = *(void **)(v450 + 8 * v4);
          if (v451)
          {
            void *v427 = *v451;
          }
          else
          {
            void *v427 = *v577;
            *float v577 = v427;
            *(void *)(v450 + 8 * v4) = v577;
            if (!*v427)
            {
LABEL_613:
              ++*((void *)this + 33);
LABEL_614:
              ++v578;
              if (!v580) {
                goto LABEL_686;
              }
              goto LABEL_615;
            }
            unint64_t v452 = *(void *)(*v427 + 8);
            if ((v415 & (v415 - 1)) != 0)
            {
              if (v452 >= v415) {
                v452 %= v415;
              }
            }
            else
            {
              v452 &= v415 - 1;
            }
            BOOL v451 = (void *)(*((void *)this + 30) + 8 * v452);
          }
          *BOOL v451 = v427;
          goto LABEL_613;
        }
        BOOL v429 = (v415 & (v415 - 1)) != 0;
        if (v415 < 3) {
          BOOL v429 = 1;
        }
        unint64_t v430 = v429 | (2 * v415);
        *(float *)&double v403 = *(float *)&v403 / v428;
        unint64_t v431 = vcvtps_u32_f32(*(float *)&v403);
        if (v430 <= v431) {
          size_t v432 = v431;
        }
        else {
          size_t v432 = v430;
        }
        if (v432 == 1)
        {
          size_t v432 = 2;
        }
        else if ((v432 & (v432 - 1)) != 0)
        {
          size_t v432 = std::__next_prime(v432);
          unint64_t v415 = *((void *)this + 31);
        }
        if (v432 <= v415)
        {
          if (v432 >= v415) {
            goto LABEL_591;
          }
          unint64_t v444 = vcvtps_u32_f32((float)*((unint64_t *)this + 33) / *((float *)this + 68));
          if (v415 < 3
            || (double v403 = COERCE_DOUBLE(vcnt_s8((int8x8_t)v415)),
                LOWORD(v403) = vaddlv_u8(*(uint8x8_t *)&v403),
                LODWORD(v403) > 1uLL))
          {
            unint64_t v444 = std::__next_prime(v444);
          }
          else
          {
            uint64_t v445 = 1 << -(char)__clz(v444 - 1);
            if (v444 >= 2) {
              unint64_t v444 = v445;
            }
          }
          if (v432 <= v444) {
            size_t v432 = v444;
          }
          if (v432 >= v415)
          {
            unint64_t v415 = *((void *)this + 31);
LABEL_591:
            if ((v415 & (v415 - 1)) != 0)
            {
              if (v414 >= v415) {
                unint64_t v4 = v414 % v415;
              }
              else {
                unint64_t v4 = v414;
              }
            }
            else
            {
              unint64_t v4 = (v415 - 1) & v414;
            }
            goto LABEL_604;
          }
          if (!v432)
          {
            double v489 = (void *)*((void *)this + 30);
            *((void *)this + 30) = 0;
            if (v489) {
              operator delete(v489);
            }
            unint64_t v415 = 0;
            *((void *)this + 31) = 0;
            goto LABEL_591;
          }
        }
        if (v432 >> 61) {
          goto LABEL_823;
        }
        uint64_t v433 = operator new(8 * v432);
        uint64_t v434 = (void *)*((void *)this + 30);
        *((void *)this + 30) = v433;
        if (v434) {
          operator delete(v434);
        }
        uint64_t v435 = 0;
        *((void *)this + 31) = v432;
        do
          *(void *)(*((void *)this + 30) + 8 * v435++) = 0;
        while (v432 != v435);
        unint64_t v436 = (void *)*v577;
        if (!*v577)
        {
LABEL_590:
          unint64_t v415 = v432;
          goto LABEL_591;
        }
        size_t v437 = v436[1];
        size_t v438 = v432 - 1;
        if ((v432 & (v432 - 1)) == 0)
        {
          size_t v439 = v437 & v438;
          *(void *)(*((void *)this + 30) + 8 * v439) = v577;
          for (unint64_t k = (void *)*v436; *v436; unint64_t k = (void *)*v436)
          {
            size_t v441 = k[1] & v438;
            if (v441 == v439)
            {
              unint64_t v436 = k;
            }
            else
            {
              uint64_t v442 = *((void *)this + 30);
              if (*(void *)(v442 + 8 * v441))
              {
                *unint64_t v436 = *k;
                uint64_t v443 = 8 * v441;
                void *k = **(void **)(*((void *)this + 30) + v443);
                **(void **)(*((void *)this + 30) + v443) = k;
              }
              else
              {
                *(void *)(v442 + 8 * v441) = v436;
                unint64_t v436 = k;
                size_t v439 = v441;
              }
            }
          }
          goto LABEL_590;
        }
        if (v437 >= v432) {
          v437 %= v432;
        }
        *(void *)(*((void *)this + 30) + 8 * v437) = v577;
        unint64_t v446 = (void *)*v436;
        if (!*v436) {
          goto LABEL_590;
        }
        while (1)
        {
          size_t v448 = v446[1];
          if (v448 >= v432) {
            v448 %= v432;
          }
          if (v448 != v437)
          {
            uint64_t v449 = *((void *)this + 30);
            if (!*(void *)(v449 + 8 * v448))
            {
              *(void *)(v449 + 8 * v448) = v436;
              goto LABEL_595;
            }
            *unint64_t v436 = *v446;
            uint64_t v447 = 8 * v448;
            *unint64_t v446 = **(void **)(*((void *)this + 30) + v447);
            **(void **)(*((void *)this + 30) + v447) = v446;
            unint64_t v446 = v436;
          }
          size_t v448 = v437;
LABEL_595:
          unint64_t v436 = v446;
          unint64_t v446 = (void *)*v446;
          size_t v437 = v448;
          if (!v446) {
            goto LABEL_590;
          }
        }
      }
      if (LODWORD(v403) < 2uLL)
      {
        while (1)
        {
          uint64_t v421 = v419[1];
          if (v421 == v414)
          {
            if (v419[2] == v409) {
              goto LABEL_692;
            }
          }
          else if ((v421 & (v415 - 1)) != v416)
          {
            goto LABEL_531;
          }
          unint64_t v419 = (uint64_t *)*v419;
          if (!v419) {
            goto LABEL_531;
          }
        }
      }
      while (1)
      {
        unint64_t v420 = v419[1];
        if (v420 == v414) {
          break;
        }
        if (v420 >= v415) {
          v420 %= v415;
        }
        if (v420 != v416) {
          goto LABEL_531;
        }
LABEL_521:
        unint64_t v419 = (uint64_t *)*v419;
        if (!v419) {
          goto LABEL_531;
        }
      }
      if (v419[2] != v409) {
        goto LABEL_521;
      }
LABEL_692:
      int v417 = *((_DWORD *)v419 + 6);
LABEL_509:
      LODWORD(v652) = v417;
      if (v580)
      {
LABEL_615:
        unint64_t v453 = md::MuninRoadGraph::composedEdgeForEdge(*((int8x8_t **)this + 17), (unint64_t)v638);
        uint64_t v454 = *((void *)this + 18);
        double v403 = 0.0;
        long long v627 = 0u;
        long long v628 = 0u;
        float v629 = *(float *)(v454 + 152);
        size_t v455 = *(void *)(v454 + 128);
        if (v455 == 1)
        {
          size_t v455 = 2;
LABEL_633:
          unint64_t v460 = operator new(8 * v455);
          unint64_t v461 = (void *)v627;
          *(void *)&long long v627 = v460;
          if (v461) {
            operator delete(v461);
          }
          uint64_t v462 = 0;
          *((void *)&v627 + 1) = v455;
          do
            *(void *)(v627 + 8 * v462++) = 0;
          while (v455 != v462);
          int v463 = (void **)v628;
          if (!(void)v628) {
            goto LABEL_649;
          }
          size_t v464 = *(void *)(v628 + 8);
          size_t v465 = v455 - 1;
          if ((v455 & (v455 - 1)) == 0)
          {
            size_t v466 = v464 & v465;
            *(void *)(v627 + 8 * v466) = &v628;
            while (1)
            {
              long long v467 = *v463;
              if (!*v463) {
                break;
              }
              size_t v468 = v467[1] & v465;
              if (v468 == v466)
              {
                int v463 = (void **)*v463;
              }
              else if (*(void *)(v627 + 8 * v468))
              {
                *int v463 = (void *)*v467;
                uint64_t v469 = 8 * v468;
                void *v467 = **(void **)(v627 + v469);
                **(void **)(v627 + v469) = v467;
              }
              else
              {
                *(void *)(v627 + 8 * v468) = v463;
                int v463 = (void **)v467;
                size_t v466 = v468;
              }
            }
            goto LABEL_649;
          }
          if (v464 >= v455) {
            v464 %= v455;
          }
          *(void *)(v627 + 8 * v464) = &v628;
          uint64_t v470 = *v463;
          if (!*v463)
          {
LABEL_649:
            unint64_t v471 = *(void **)(v454 + 136);
            if (!v471) {
              goto LABEL_651;
            }
            goto LABEL_650;
          }
          while (1)
          {
            size_t v477 = v470[1];
            if (v477 >= v455) {
              v477 %= v455;
            }
            if (v477 != v464)
            {
              if (!*(void *)(v627 + 8 * v477))
              {
                *(void *)(v627 + 8 * v477) = v463;
                goto LABEL_656;
              }
              *int v463 = (void *)*v470;
              uint64_t v476 = 8 * v477;
              *uint64_t v470 = **(void **)(v627 + v476);
              **(void **)(v627 + v476) = v470;
              uint64_t v470 = v463;
            }
            size_t v477 = v464;
LABEL_656:
            int v463 = (void **)v470;
            uint64_t v470 = (void *)*v470;
            size_t v464 = v477;
            if (!v470) {
              goto LABEL_649;
            }
          }
        }
        if ((v455 & (v455 - 1)) != 0)
        {
          size_t v455 = std::__next_prime(*(void *)(v454 + 128));
          int8x8_t v456 = *(int8x8_t *)((char *)&v627 + 8);
          _CF = v455 >= *((void *)&v627 + 1);
          if (v455 > *((void *)&v627 + 1)) {
            goto LABEL_632;
          }
        }
        else
        {
          int8x8_t v456 = 0;
          _CF = 1;
          if (v455) {
            goto LABEL_632;
          }
        }
        if (_CF) {
          goto LABEL_649;
        }
        unint64_t v458 = vcvtps_u32_f32((float)*((unint64_t *)&v628 + 1) / v629);
        if (*(void *)&v456 < 3uLL
          || (double v403 = COERCE_DOUBLE(vcnt_s8(v456)), LOWORD(v403) = vaddlv_u8(*(uint8x8_t *)&v403), LODWORD(v403) > 1uLL))
        {
          unint64_t v458 = std::__next_prime(v458);
        }
        else
        {
          uint64_t v459 = 1 << -(char)__clz(v458 - 1);
          if (v458 >= 2) {
            unint64_t v458 = v459;
          }
        }
        if (v455 <= v458) {
          size_t v455 = v458;
        }
        if (v455 >= *(void *)&v456) {
          goto LABEL_649;
        }
        if (!v455)
        {
          long double v490 = (void *)v627;
          *(void *)&long long v627 = 0;
          if (v490) {
            operator delete(v490);
          }
          *((void *)&v627 + 1) = 0;
          unint64_t v471 = *(void **)(v454 + 136);
          if (!v471) {
            goto LABEL_651;
          }
          do
          {
LABEL_650:
            std::__hash_table<md::ComposedRoadEdge const*,std::hash<md::ComposedRoadEdge const*>,std::equal_to<md::ComposedRoadEdge const*>,std::allocator<md::ComposedRoadEdge const*>>::__emplace_unique_key_args<md::ComposedRoadEdge const*,md::ComposedRoadEdge const* const&>((uint64_t)&v627, v471[2], v471[2]);
            unint64_t v471 = (void *)*v471;
          }
          while (v471);
          if (!*((void *)&v627 + 1)) {
            goto LABEL_679;
          }
LABEL_651:
          unint64_t v472 = 0x9DDFEA08EB382D69 * (((8 * v453) + 8) ^ HIDWORD(v453));
          unint64_t v473 = 0x9DDFEA08EB382D69 * (HIDWORD(v453) ^ (v472 >> 47) ^ v472);
          unint64_t v474 = 0x9DDFEA08EB382D69 * (v473 ^ (v473 >> 47));
          double v403 = COERCE_DOUBLE(vcnt_s8(*(int8x8_t *)((char *)&v627 + 8)));
          LOWORD(v403) = vaddlv_u8(*(uint8x8_t *)&v403);
          if (LODWORD(v403) > 1uLL)
          {
            unint64_t v475 = v474;
            if (v474 >= *((void *)&v627 + 1)) {
              unint64_t v475 = v474 % *((void *)&v627 + 1);
            }
          }
          else
          {
            unint64_t v475 = (*((void *)&v627 + 1) - 1) & v474;
          }
          unint64_t v478 = *(void **)(v627 + 8 * v475);
          if (v478)
          {
            unint64_t v479 = (void *)*v478;
            if (*v478)
            {
              if (LODWORD(v403) < 2uLL)
              {
                while (1)
                {
                  uint64_t v481 = v479[1];
                  if (v474 == v481)
                  {
                    if (v479[2] == v453) {
                      goto LABEL_680;
                    }
                  }
                  else if ((v481 & (*((void *)&v627 + 1) - 1)) != v475)
                  {
                    goto LABEL_679;
                  }
                  unint64_t v479 = (void *)*v479;
                  if (!v479) {
                    goto LABEL_680;
                  }
                }
              }
              do
              {
                unint64_t v480 = v479[1];
                if (v474 == v480)
                {
                  if (v479[2] == v453) {
                    break;
                  }
                }
                else
                {
                  if (v480 >= *((void *)&v627 + 1)) {
                    v480 %= *((void *)&v627 + 1);
                  }
                  if (v480 != v475) {
                    goto LABEL_679;
                  }
                }
                unint64_t v479 = (void *)*v479;
              }
              while (v479);
            }
          }
          else
          {
LABEL_679:
            unint64_t v479 = 0;
          }
LABEL_680:
          uint64_t v482 = (void *)v628;
          if ((void)v628)
          {
            do
            {
              uint64_t v483 = (void *)*v482;
              operator delete(v482);
              uint64_t v482 = v483;
            }
            while (v483);
          }
          uint64_t v484 = (void *)v627;
          *(void *)&long long v627 = 0;
          if (v484) {
            operator delete(v484);
          }
          if (v479)
          {
            double v403 = -5.48746343e303;
            LODWORD(v652) = -16776961;
          }
          goto LABEL_686;
        }
LABEL_632:
        if (!(v455 >> 61)) {
          goto LABEL_633;
        }
LABEL_823:
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
LABEL_686:
      LOBYTE(v627) = 0;
      uint64_t v485 = +[VKDebugSettings sharedSettings];
      if ([v485 enableMuninMiniMapRoadWidths]) {
        BOOL v486 = *((unsigned char *)v638 + 112) != 0;
      }
      else {
        BOOL v486 = 0;
      }

      LOBYTE(v627) = v486;
      size_t v487 = (uint64_t *)v638;
      v654 = 0;
      int v488 = operator new(0x40uLL);
      *int v488 = &unk_1EF57DB48;
      v488[1] = &v641;
      v488[2] = &v644;
      v488[3] = &v627;
      v488[4] = &v638;
      v488[5] = this;
      v488[6] = &v602;
      v488[7] = &v652;
      v654 = v488;
      md::MuninRoadEdge::walkEdgeGeometry(v487, 1, (uint64_t)v653);
      if (v654 == v653)
      {
        (*(void (**)(void *))(v653[0] + 32))(v653);
      }
      else if (v654)
      {
        (*(void (**)(void))(*v654 + 40))();
      }
      if (++v406 != v407) {
        continue;
      }
      break;
    }
    uint64_t v398 = *v395;
LABEL_707:
    long double v491 = *(unint64_t **)(v398 + 776);
    long double v492 = *(uint64_t **)(v398 + 784);
    while (2)
    {
      if (v491 != (unint64_t *)v492)
      {
        unint64_t v493 = *v491;
        double v494 = *(double *)(*v491 + 16);
        if (v494 < v605.f64[0] || v494 >= v606.f64[0]) {
          goto LABEL_710;
        }
        double v496 = *(double *)(v493 + 24);
        if (v496 < v605.f64[1] || v496 >= v606.f64[1]) {
          goto LABEL_710;
        }
        if (v597[1])
        {
          unint64_t v498 = 0x9DDFEA08EB382D69 * (((8 * v493) + 8) ^ HIDWORD(v493));
          unint64_t v499 = 0x9DDFEA08EB382D69 * (HIDWORD(v493) ^ (v498 >> 47) ^ v498);
          unint64_t v500 = 0x9DDFEA08EB382D69 * (v499 ^ (v499 >> 47));
          uint8x8_t v501 = (uint8x8_t)vcnt_s8((int8x8_t)v597[1]);
          v501.i16[0] = vaddlv_u8(v501);
          if (v501.u32[0] > 1uLL)
          {
            unint64_t v502 = v500;
            if ((void *)v500 >= v597[1]) {
              unint64_t v502 = v500 % (unint64_t)v597[1];
            }
          }
          else
          {
            unint64_t v502 = ((unint64_t)v597[1] - 1) & v500;
          }
          uint64_t v503 = (void *)*((void *)v597[0] + v502);
          if (v503)
          {
            BOOL v504 = (void *)*v503;
            if (v504)
            {
              if (v501.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v506 = v504[1];
                  if (v500 == v506)
                  {
                    if (v504[2] == v493) {
                      goto LABEL_791;
                    }
                  }
                  else if ((v506 & ((uint64_t)v597[1] - 1)) != v502)
                  {
                    goto LABEL_742;
                  }
                  BOOL v504 = (void *)*v504;
                  if (!v504) {
                    goto LABEL_742;
                  }
                }
              }
              do
              {
                unint64_t v505 = v504[1];
                if (v500 == v505)
                {
                  if (v504[2] == v493)
                  {
LABEL_791:
                    char v508 = 0;
                    LODWORD(v627) = -16711936;
                    unint64_t v4 = 255;
                    goto LABEL_747;
                  }
                }
                else
                {
                  if ((void *)v505 >= v597[1]) {
                    v505 %= (unint64_t)v597[1];
                  }
                  if (v505 != v502) {
                    break;
                  }
                }
                BOOL v504 = (void *)*v504;
              }
              while (v504);
            }
          }
        }
LABEL_742:
        unsigned int v507 = *(unsigned __int8 *)(v493 + 69);
        if (v507 > 2 || v507 - 1 <= 1 && *(unsigned __int8 *)(v493 + 68) >= 3u)
        {
          LODWORD(v627) = -1;
          unint64_t v4 = 255;
          char v508 = -1;
        }
        else
        {
          LODWORD(v627) = -553648128;
          char v508 = -1;
          unint64_t v4 = 32;
        }
LABEL_747:
        v509 = +[VKDebugSettings sharedSettings];
        if (![v509 enableMuninMiniMapRoadWidths]) {
          goto LABEL_708;
        }
        unsigned int v510 = *(unsigned __int8 *)(v493 + 69);
        if (v510 >= 3)
        {

          goto LABEL_750;
        }
        if (v510 - 1 < 2)
        {
          BOOL v515 = *(unsigned __int8 *)(v493 + 68) > 2u;

          if (v515)
          {
LABEL_750:
            uint64_t v511 = *(char **)(v493 + 40);
            uint64_t v512 = *(char **)(v493 + 48);
            if (v511 == v512)
            {
              double v514 = 0.0;
            }
            else
            {
              unint64_t v513 = v512 - v511 - 8;
              if (v513 > 7)
              {
                uint64_t v516 = (v513 >> 3) + 1;
                uint64_t v517 = v511 + 8;
                double v518 = 0.0;
                uint64_t v519 = v516 & 0x3FFFFFFFFFFFFFFELL;
                double v520 = 0.0;
                do
                {
                  double v518 = fmax(v518, *(float *)(*(v517 - 1) + 8));
                  double v520 = fmax(v520, *(float *)(*v517 + 8));
                  v517 += 2;
                  v519 -= 2;
                }
                while (v519);
                double v514 = fmax(v518, v520);
                if (v516 != (v516 & 0x3FFFFFFFFFFFFFFELL))
                {
                  v511 += 8 * (v516 & 0x3FFFFFFFFFFFFFFELL);
                  goto LABEL_762;
                }
              }
              else
              {
                double v514 = 0.0;
                do
                {
LABEL_762:
                  uint64_t v521 = *(void *)v511;
                  v511 += 8;
                  double v514 = fmax(v514, *(float *)(v521 + 8));
                }
                while (v511 != v512);
              }
            }
            if (v606.f64[0] >= v605.f64[0] && v606.f64[1] >= v605.f64[1])
            {
              double v522 = v514 * v575;
              double v523 = *(double *)(v493 + 16);
              double v524 = *(double *)(v493 + 24);
              double v525 = fmax(v523 - v606.f64[0], v605.f64[0] - v523);
              double v526 = fmax(v524 - v606.f64[1], v605.f64[1] - v524);
              BOOL v527 = v522 != 0.0 && v525 < v522;
              BOOL v528 = v527 && v526 < v522;
              if (v528
                && (v525 <= 0.0 || v526 <= 0.0 || v525 * v525 + v526 * v526 < v522 * v522)
                && (vcgt_f32(v603, v604).u8[0] & 1) == 0
                && v604.f32[1] >= v603.f32[1])
              {
                float32x2_t v529 = vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(vsub_f32(v604, v603)), vsubq_f64(v606, v605)));
                float v530 = v522 * fminf(v529.f32[1], v529.f32[0]);
                if (v530 != 0.0)
                {
                  float64_t v531 = v612.f64[0] + v608.f64[0] * v523 + v610.f64[0] * v524;
                  float64_t v532 = v612.f64[1] + v608.f64[1] * v523 + v610.f64[1] * v524;
                  double v533 = 1.0 / (v613 + v609 * v523 + v611 * v524);
                  float v534 = v533 * v531;
                  *(float *)&double v533 = v533 * v532;
                  *(float *)&float64_t v531 = (float)(v619 + (float)(v614.f32[0] * v534)) + (float)(v616 * *(float *)&v533);
                  *(float *)&float64_t v532 = (float)(v620 + (float)(v614.f32[1] * v534)) + (float)(v617 * *(float *)&v533);
                  float v535 = 1.0 / (float)((float)(v621 + (float)(v615 * v534)) + (float)(v618 * *(float *)&v533));
                  float v536 = v535 * *(float *)&v531;
                  float v537 = v535 * *(float *)&v532;
                  float v538 = fmaxf(v536 - v604.f32[0], v603.f32[0] - v536);
                  float v539 = fmaxf(v537 - v604.f32[1], v603.f32[1] - v537);
                  if (v538 < v530 && v539 < v530)
                  {
                    if (v538 <= 0.0
                      || ((float v541 = (float)(v538 * v538) + (float)(v539 * v539), v539 > 0.0)
                        ? (BOOL v542 = v541 < (float)(v530 * v530))
                        : (BOOL v542 = 1),
                          v542))
                    {
                      float v543 = v602;
                      *((unsigned char *)v602 + 96) = v508;
                      *((unsigned char *)v543 + 97) = -1;
                      *((unsigned char *)v543 + 98) = v508;
                      *((unsigned char *)v543 + 99) = v4;
                      *((float *)v543 + 2) = v536;
                      *((float *)v543 + 3) = v537;
                      ggl::DebugConsole::drawCircle(v543, v530);
                    }
                  }
                }
              }
            }
          }
        }
        else
        {
LABEL_708:
        }
        md::DebugConsoleMapRect::drawWorldCircleWithPixelRadius((uint64_t)&v602, v396, &v627, 1, *(double *)(v493 + 16), *(double *)(v493 + 24));
LABEL_710:
        ++v491;
        continue;
      }
      break;
    }
    float v544 = (char *)*((void *)this + 21);
    if (v544 != v581)
    {
      do
      {
        float v545 = (void *)*((void *)v544 + 4);
        double v546 = *(double *)(*v545 + 16);
        if (v546 >= v605.f64[0] && v546 < v606.f64[0])
        {
          double v548 = *(double *)(*v545 + 24);
          if (v548 >= v605.f64[1] && v548 < v606.f64[1])
          {
            uint64_t v550 = v545[7];
            for (uint64_t m = v545[8]; v550 != m; v550 += 16)
            {
              long long v552 = *(_OWORD *)(*(uint64_t (**)(void))(**(void **)v550 + 16))();
              LODWORD(v627) = -65281;
              md::DebugConsoleMapRect::drawWorldCircleWithPixelRadius((uint64_t)&v602, v396, &v627, 1, *(double *)&v552, *((double *)&v552 + 1));
              double v553 = *(double ***)(*(void *)v550 + 16);
              double v554 = *(double ***)(*(void *)v550 + 24);
              while (v553 != v554)
              {
                float32x4_t v555 = *v553;
                v553 += 2;
                long double v556 = v555[27];
                long double v557 = v555[28];
                long double v558 = v555[29];
                double v559 = sqrt(v556 * v556 + v557 * v557);
                double v560 = atan2(v558, v559 * 0.996647189);
                long double __nd = atan2(v557, v556);
                __double2 v561 = __sincos_stret(v560);
                long double v562 = atan2(v558 + v561.__sinval * v561.__sinval * 42841.3115 * v561.__sinval, v559 + v561.__cosval * v561.__cosval * -42697.6727 * v561.__cosval);
                long double v563 = tan(v562 * 0.5 + 0.785398163);
                long double v564 = log(v563);
                v565.f64[0] = __nd;
                v565.f64[1] = v564;
                float64x2_t v566 = vmlaq_f64(v584, v585, v565);
                LODWORD(v627) = -256;
                md::DebugConsoleMapRect::drawWorldCircleWithPixelRadius((uint64_t)&v602, v396, &v627, 1, v566.f64[0], v566.f64[1]);
              }
            }
          }
        }
        int v567 = (char *)*((void *)v544 + 1);
        if (v567)
        {
          do
          {
            int32x4_t v568 = v567;
            int v567 = *(char **)v567;
          }
          while (v567);
        }
        else
        {
          do
          {
            int32x4_t v568 = (char *)*((void *)v544 + 2);
            _ZF = *(void *)v568 == (void)v544;
            float v544 = v568;
          }
          while (!_ZF);
        }
        float v544 = v568;
      }
      while (v568 != v581);
    }
    long long v394 = v576;
LABEL_487:
    v395 += 2;
    if (v395 != v394) {
      continue;
    }
    break;
  }
LABEL_816:
  uint64_t v596 = *(void *)(*((void *)this + 35) + 1288);
  md::DebugConsoleMapRect::drawWorldArrow((uint64_t)&v602, (double *)&v596, &v623, v573, v572, v574 * 22.0, v574 * 12.0);
  if (v644)
  {
    *(void *)&long long v645 = v644;
    operator delete(v644);
  }
  int v569 = v598[0];
  if (v598[0])
  {
    do
    {
      unint64_t v570 = (void *)*v569;
      operator delete(v569);
      int v569 = v570;
    }
    while (v570);
  }
  v571 = v597[0];
  v597[0] = 0;
  if (v571) {
    operator delete(v571);
  }
}

void sub_1A25A9484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,void *a35)
{
  if (__p)
  {
    STACK[0x2E8] = (unint64_t)__p;
    operator delete(__p);
  }
  md::ComposedRoadEdgeZInfo::~ComposedRoadEdgeZInfo((md::ComposedRoadEdgeZInfo *)&STACK[0x300]);
  operator delete(a20);
  unint64_t v36 = a35;
  if (a35)
  {
    do
    {
      BOOL v37 = (void *)*v36;
      operator delete(v36);
      unint64_t v36 = v37;
    }
    while (v37);
  }
  if (!a33) {
    _Unwind_Resume(a1);
  }
  operator delete(a33);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::MuninRoadLabeler::debugDrawRoadNetworkMiniMap(md::DebugConsole *,double)::$_0,std::allocator<md::MuninRoadLabeler::debugDrawRoadNetworkMiniMap(md::DebugConsole *,double)::$_0>,BOOL ()(gm::Matrix<double,2,1> const&)>::operator()(uint64_t a1, float64x2_t *a2)
{
  unint64_t v4 = *(float64x2_t **)(a1 + 8);
  if (*v4 == 0) {
    goto LABEL_42;
  }
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(float64x2_t **)v6;
  *(void *)(v6 + 8) = *(void *)v6;
  if (!**(unsigned char **)(a1 + 24))
  {
    unint64_t v21 = *(void *)(v6 + 16);
    if ((unint64_t)v7 >= v21)
    {
      uint64_t v48 = v21 - (void)v7;
      uint64_t v49 = v48 >> 4;
      if ((unint64_t)(v48 >> 4) <= 1) {
        uint64_t v49 = 1;
      }
      BOOL v26 = (unint64_t)v48 >= 0x7FFFFFFFFFFFFFE0;
      unint64_t v50 = 0x7FFFFFFFFFFFFFFLL;
      if (!v26) {
        unint64_t v50 = v49;
      }
      if (v50 >> 59) {
        goto LABEL_43;
      }
      uint64_t v51 = 2 * v50;
      double v52 = operator new(32 * v50);
      BOOL v53 = &v52[v51];
      float64x2_t v54 = vsubq_f64(*a2, *v4);
      *double v52 = *v4;
      v52[1] = v54;
      f64 = v52 + 2;
      *(void *)uint64_t v6 = v52;
      *(void *)(v6 + 8) = v52 + 2;
      *(void *)(v6 + 16) = v53;
      if (v7) {
        operator delete(v7);
      }
    }
    else
    {
      float64x2_t v22 = vsubq_f64(*a2, *v4);
      *uint64_t v7 = *v4;
      v7[1] = v22;
      f64 = (_OWORD *)v7[2].f64;
    }
    *(void *)(v6 + 8) = f64;
    goto LABEL_40;
  }
  double v9 = v4->f64[0];
  double v8 = v4->f64[1];
  double v11 = a2->f64[0];
  double v10 = a2->f64[1];
  float64_t v12 = v4->f64[0] - a2->f64[0];
  double v13 = 1.0 / sqrt(v12 * v12 + (v8 - v10) * (v8 - v10));
  double v14 = *(double *)(*(void *)(v5 + 280) + 816) * (float)(*(float *)(**(void **)(a1 + 32) + 8) * 0.5);
  double v15 = -((v8 - v10) * v13) * v14;
  double v16 = v13 * (v12 * v14);
  double v17 = v15 + v4->f64[0];
  double v18 = v16 + v8;
  unint64_t v19 = *(void *)(v6 + 16);
  if ((unint64_t)v7 >= v19)
  {
    uint64_t v24 = v19 - (void)v7;
    uint64_t v25 = v24 >> 4;
    if ((unint64_t)(v24 >> 4) <= 1) {
      uint64_t v25 = 1;
    }
    BOOL v26 = (unint64_t)v24 >= 0x7FFFFFFFFFFFFFE0;
    unint64_t v27 = 0x7FFFFFFFFFFFFFFLL;
    if (!v26) {
      unint64_t v27 = v25;
    }
    if (v27 >> 59) {
      goto LABEL_43;
    }
    uint64_t v28 = 4 * v27;
    unint64_t v29 = (double *)operator new(32 * v27);
    float v30 = &v29[v28];
    *unint64_t v29 = v17;
    v29[1] = v18;
    v29[2] = v11 - v9;
    v29[3] = v10 - v8;
    uint8x8_t v20 = v29 + 4;
    *(void *)uint64_t v6 = v29;
    *(void *)(v6 + 8) = v29 + 4;
    *(void *)(v6 + 16) = v30;
    if (v7) {
      operator delete(v7);
    }
  }
  else
  {
    v7->f64[0] = v17;
    v7->f64[1] = v18;
    v7[1].f64[0] = v11 - v9;
    v7[1].f64[1] = v10 - v8;
    uint8x8_t v20 = v7[2].f64;
  }
  *(void *)(v6 + 8) = v20;
  unint64_t v31 = *(double **)(a1 + 8);
  uint8x8_t v32 = *(double ***)(a1 + 16);
  double v34 = *v31;
  double v33 = v31[1];
  double v35 = *v31 - v15;
  double v36 = v33 - v16;
  double v38 = a2->f64[0];
  double v37 = a2->f64[1];
  float v40 = v32[1];
  unint64_t v39 = (unint64_t)v32[2];
  if ((unint64_t)v40 >= v39)
  {
    BOOL v42 = *v32;
    uint64_t v43 = ((char *)v40 - (char *)*v32) >> 5;
    unint64_t v44 = v43 + 1;
    if ((unint64_t)(v43 + 1) >> 59) {
      abort();
    }
    uint64_t v45 = v39 - (void)v42;
    if (v45 >> 4 > v44) {
      unint64_t v44 = v45 >> 4;
    }
    if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v46 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v46 = v44;
    }
    if (!v46)
    {
      uint64_t v47 = 0;
      goto LABEL_34;
    }
    if (!(v46 >> 59))
    {
      uint64_t v47 = (char *)operator new(32 * v46);
LABEL_34:
      long long v55 = (double *)&v47[32 * v43];
      *long long v55 = v35;
      v55[1] = v36;
      v55[2] = v38 - v34;
      v55[3] = v37 - v33;
      float v41 = v55 + 4;
      if (v40 != v42)
      {
        do
        {
          long long v56 = *((_OWORD *)v40 - 1);
          *((_OWORD *)v55 - 2) = *((_OWORD *)v40 - 2);
          *((_OWORD *)v55 - 1) = v56;
          v55 -= 4;
          v40 -= 4;
        }
        while (v40 != v42);
        float v40 = *v32;
      }
      char *v32 = v55;
      v32[1] = v41;
      v32[2] = (double *)&v47[32 * v46];
      if (v40) {
        operator delete(v40);
      }
      goto LABEL_39;
    }
LABEL_43:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  *float v40 = v35;
  v40[1] = v36;
  void v40[2] = v38 - v34;
  v40[3] = v37 - v33;
  float v41 = v40 + 4;
LABEL_39:
  v32[1] = v41;
LABEL_40:
  double v57 = *(double ***)(a1 + 16);
  double v58 = *v57;
  BOOL v59 = v57[1];
  if (*v57 != v59)
  {
    do
    {
      md::DebugConsoleMapRect::drawWorldSegment(*(void *)(a1 + 48), v58, *(unsigned char **)(a1 + 56));
      v58 += 4;
    }
    while (v58 != v59);
  }
LABEL_42:
  uint64_t v60 = *(void **)(a1 + 8);
  *uint64_t v60 = *(void *)&a2->f64[0];
  v60[1] = *(void *)&a2->f64[1];
  return 1;
}

__n128 std::__function::__func<md::MuninRoadLabeler::debugDrawRoadNetworkMiniMap(md::DebugConsole *,double)::$_0,std::allocator<md::MuninRoadLabeler::debugDrawRoadNetworkMiniMap(md::DebugConsole *,double)::$_0>,BOOL ()(gm::Matrix<double,2,1> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF57DB48;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::MuninRoadLabeler::debugDrawRoadNetworkMiniMap(md::DebugConsole *,double)::$_0,std::allocator<md::MuninRoadLabeler::debugDrawRoadNetworkMiniMap(md::DebugConsole *,double)::$_0>,BOOL ()(gm::Matrix<double,2,1> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_1EF57DB48;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

void std::__function::__func<md::MuninRoadLabeler::debugDrawRoadNetworkMiniMap(md::DebugConsole *,double)::$_0,std::allocator<md::MuninRoadLabeler::debugDrawRoadNetworkMiniMap(md::DebugConsole *,double)::$_0>,BOOL ()(gm::Matrix<double,2,1> const&)>::~__func()
{
}

double std::__introsort<std::_ClassicAlgPolicy,md::MuninRoadLabeler::debugDrawZData(md::DebugConsoleMapRect *)::$_0 &,gm::Range<double> *,false>(__n128 *a1, __n128 *a2, uint64_t a3, char a4, __n128 a5)
{
  while (2)
  {
    n128_u64 = a2[-1].n128_u64;
    n128_f64 = a2[-2].n128_f64;
    double v13 = a2[-3].n128_f64;
    double v14 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v14;
          uint64_t v15 = (char *)a2 - (char *)v14;
          uint64_t v16 = a2 - v14;
          if (v6 || !v5)
          {
            switch(v16)
            {
              case 0:
              case 1:
                return a5.n128_f64[0];
              case 2:
                a5.n128_u64[0] = *n128_u64;
                if (*(double *)n128_u64 >= v14->n128_f64[0]) {
                  return a5.n128_f64[0];
                }
                goto LABEL_100;
              case 3:
                double v62 = v14 + 1;
                a5.n128_u64[0] = v14[1].n128_u64[0];
                double v63 = *(double *)n128_u64;
                if (a5.n128_f64[0] < v14->n128_f64[0])
                {
                  if (v63 >= a5.n128_f64[0])
                  {
                    __n128 v126 = *v14;
                    *double v14 = *v62;
                    *double v62 = v126;
                    a5.n128_u64[0] = *n128_u64;
                    if (*(double *)n128_u64 >= v14[1].n128_f64[0]) {
                      return a5.n128_f64[0];
                    }
                    a5 = *v62;
                    *double v62 = *(__n128 *)n128_u64;
                  }
                  else
                  {
LABEL_100:
                    __n128 v122 = *v14;
                    *double v14 = *(__n128 *)n128_u64;
                    a5 = v122;
                  }
                  *(__n128 *)n128_u64 = a5;
                  return a5.n128_f64[0];
                }
                if (v63 < a5.n128_f64[0])
                {
                  a5 = *v62;
                  *double v62 = *(__n128 *)n128_u64;
                  *(__n128 *)n128_u64 = a5;
                  a5.n128_u64[0] = v14[1].n128_u64[0];
                  if (a5.n128_f64[0] < v14->n128_f64[0])
                  {
                    __n128 v125 = *v14;
                    *double v14 = *v62;
                    a5.n128_u64[0] = v125.n128_u64[0];
                    *double v62 = v125;
                  }
                }
                break;
              case 4:
                a5.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,-[LabelNavRouteLabeler(Debug) drawNavOverlayDebugView:navContext:]::$_0 &,gm::Range<double> *>(v14, v14[1].n128_f64, v14[2].n128_f64, a2[-1].n128_u64, a5).n128_u64[0];
                return a5.n128_f64[0];
              case 5:
                unsigned int v64 = v14 + 1;
                unsigned int v65 = v14 + 2;
                uint64_t v66 = v14 + 3;
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,-[LabelNavRouteLabeler(Debug) drawNavOverlayDebugView:navContext:]::$_0 &,gm::Range<double> *>(v14, v14[1].n128_f64, v14[2].n128_f64, v14[3].n128_u64, a5);
                a5.n128_u64[0] = *n128_u64;
                if (*(double *)n128_u64 < v14[3].n128_f64[0])
                {
                  a5 = *v66;
                  *uint64_t v66 = *(__n128 *)n128_u64;
                  *(__n128 *)n128_u64 = a5;
                  a5.n128_u64[0] = v66->n128_u64[0];
                  if (v66->n128_f64[0] < v65->n128_f64[0])
                  {
                    a5 = *v65;
                    *unsigned int v65 = *v66;
                    *uint64_t v66 = a5;
                    a5.n128_u64[0] = v65->n128_u64[0];
                    if (v65->n128_f64[0] < v64->n128_f64[0])
                    {
                      a5 = *v64;
                      *unsigned int v64 = *v65;
                      *unsigned int v65 = a5;
                      a5.n128_u64[0] = v14[1].n128_u64[0];
                      if (a5.n128_f64[0] < v14->n128_f64[0])
                      {
                        __n128 v123 = *v14;
                        *double v14 = *v64;
                        a5.n128_u64[0] = v123.n128_u64[0];
                        *unsigned int v64 = v123;
                      }
                    }
                  }
                }
                return a5.n128_f64[0];
              default:
                JUMPOUT(0);
            }
            return a5.n128_f64[0];
          }
          if (v15 <= 383)
          {
            uint64_t v67 = v14 + 1;
            BOOL v69 = v14 == a2 || v67 == a2;
            if (a4)
            {
              if (!v69)
              {
                uint64_t v70 = 0;
                float64x2_t v71 = v14;
                do
                {
                  long long v73 = v67;
                  a5.n128_u64[0] = v71[1].n128_u64[0];
                  if (a5.n128_f64[0] < v71->n128_f64[0])
                  {
                    unint64_t v74 = v71[1].n128_u64[1];
                    uint64_t v75 = v70;
                    do
                    {
                      *(__n128 *)((char *)v14 + v75 + 16) = *(__n128 *)((char *)v14 + v75);
                      if (!v75)
                      {
                        float32x4_t v72 = v14;
                        goto LABEL_120;
                      }
                      double v76 = *(double *)((char *)v14[-1].n128_f64 + v75);
                      v75 -= 16;
                    }
                    while (a5.n128_f64[0] < v76);
                    float32x4_t v72 = (__n128 *)((char *)v14 + v75 + 16);
LABEL_120:
                    v72->n128_u64[0] = a5.n128_u64[0];
                    v72->n128_u64[1] = v74;
                  }
                  uint64_t v67 = v73 + 1;
                  v70 += 16;
                  float64x2_t v71 = v73;
                }
                while (&v73[1] != a2);
              }
            }
            else if (!v69)
            {
              do
              {
                uint64_t v99 = v67;
                a5.n128_u64[0] = a1[1].n128_u64[0];
                if (a5.n128_f64[0] < a1->n128_f64[0])
                {
                  unint64_t v100 = a1[1].n128_u64[1];
                  unsigned int v101 = v67;
                  do
                  {
                    *unsigned int v101 = v101[-1];
                    double v102 = v101[-2].n128_f64[0];
                    --v101;
                  }
                  while (a5.n128_f64[0] < v102);
                  v101->n128_u64[0] = a5.n128_u64[0];
                  v101->n128_u64[1] = v100;
                }
                ++v67;
                a1 = v99;
              }
              while (&v99[1] != a2);
            }
            return a5.n128_f64[0];
          }
          if (!a3)
          {
            if (v14 != a2)
            {
              int64_t v77 = (unint64_t)(v16 - 2) >> 1;
              int64_t v78 = v77;
              do
              {
                if (v77 >= v78)
                {
                  uint64_t v80 = (2 * v78) | 1;
                  float v81 = v14[v80].n128_f64;
                  if (2 * v78 + 2 < v16 && *v81 < v81[2])
                  {
                    v81 += 2;
                    uint64_t v80 = 2 * v78 + 2;
                  }
                  float32x2_t v82 = &v14[v78];
                  double v83 = v82->n128_f64[0];
                  if (*v81 >= v82->n128_f64[0])
                  {
                    unint64_t v84 = v82->n128_u64[1];
                    do
                    {
                      float32x4_t v85 = v82;
                      float32x2_t v82 = (__n128 *)v81;
                      *float32x4_t v85 = *(__n128 *)v81;
                      if (v77 < v80) {
                        break;
                      }
                      uint64_t v86 = 2 * v80;
                      uint64_t v80 = (2 * v80) | 1;
                      float v81 = v14[v80].n128_f64;
                      uint64_t v87 = v86 + 2;
                      if (v87 < v16 && *v81 < v81[2])
                      {
                        v81 += 2;
                        uint64_t v80 = v87;
                      }
                    }
                    while (*v81 >= v83);
                    v82->n128_f64[0] = v83;
                    v82->n128_u64[1] = v84;
                  }
                }
                BOOL v79 = v78-- <= 0;
              }
              while (!v79);
              uint64_t v88 = (unint64_t)v15 >> 4;
              do
              {
                uint64_t v89 = 0;
                __n128 v124 = *v14;
                uint64_t v90 = v14;
                do
                {
                  double v91 = v90;
                  v90 += v89 + 1;
                  uint64_t v92 = 2 * v89;
                  uint64_t v89 = (2 * v89) | 1;
                  uint64_t v93 = v92 + 2;
                  if (v93 < v88 && v90->n128_f64[0] < v90[1].n128_f64[0])
                  {
                    ++v90;
                    uint64_t v89 = v93;
                  }
                  *double v91 = *v90;
                }
                while (v89 <= (uint64_t)((unint64_t)(v88 - 2) >> 1));
                if (v90 == --a2)
                {
                  a5.n128_u64[0] = v124.n128_u64[0];
                  __n128 *v90 = v124;
                }
                else
                {
                  __n128 *v90 = *a2;
                  a5.n128_u64[0] = v124.n128_u64[0];
                  *a2 = v124;
                  uint64_t v94 = (char *)v90 - (char *)v14 + 16;
                  if (v94 >= 17)
                  {
                    unint64_t v95 = (((unint64_t)v94 >> 4) - 2) >> 1;
                    int v96 = &v14[v95];
                    a5.n128_u64[0] = v90->n128_u64[0];
                    if (v96->n128_f64[0] < v90->n128_f64[0])
                    {
                      unint64_t v97 = v90->n128_u64[1];
                      do
                      {
                        unsigned int v98 = v90;
                        uint64_t v90 = v96;
                        *unsigned int v98 = *v96;
                        if (!v95) {
                          break;
                        }
                        unint64_t v95 = (v95 - 1) >> 1;
                        int v96 = &v14[v95];
                      }
                      while (v96->n128_f64[0] < a5.n128_f64[0]);
                      v90->n128_u64[0] = a5.n128_u64[0];
                      v90->n128_u64[1] = v97;
                    }
                  }
                }
                BOOL v79 = v88-- <= 2;
              }
              while (!v79);
            }
            return a5.n128_f64[0];
          }
          unint64_t v17 = (unint64_t)v16 >> 1;
          double v18 = v14[(unint64_t)v16 >> 1].n128_f64;
          double v19 = *(double *)n128_u64;
          if ((unint64_t)v15 >= 0x801)
          {
            double v20 = *v18;
            if (*v18 >= v14->n128_f64[0])
            {
              if (v19 < v20)
              {
                __n128 v106 = *(__n128 *)v18;
                *(_OWORD *)double v18 = *(_OWORD *)n128_u64;
                *(__n128 *)n128_u64 = v106;
                if (*v18 < v14->n128_f64[0])
                {
                  __n128 v107 = *v14;
                  *double v14 = *(__n128 *)v18;
                  *(__n128 *)double v18 = v107;
                }
              }
            }
            else
            {
              if (v19 >= v20)
              {
                __n128 v110 = *v14;
                *double v14 = *(__n128 *)v18;
                *(__n128 *)double v18 = v110;
                if (*(double *)n128_u64 >= *v18) {
                  goto LABEL_22;
                }
                __n128 v104 = *(__n128 *)v18;
                *(_OWORD *)double v18 = *(_OWORD *)n128_u64;
              }
              else
              {
                __n128 v104 = *v14;
                *double v14 = *(__n128 *)n128_u64;
              }
              *(__n128 *)n128_u64 = v104;
            }
LABEL_22:
            float64x2_t v22 = v14 + 1;
            unint64_t v23 = &v14[v17];
            double v25 = v23[-1].n128_f64[0];
            uint64_t v24 = v23 - 1;
            double v26 = v25;
            double v27 = *n128_f64;
            if (v25 >= v14[1].n128_f64[0])
            {
              if (v27 < v26)
              {
                __n128 v111 = *v24;
                *uint64_t v24 = *(__n128 *)n128_f64;
                *(__n128 *)n128_f64 = v111;
                if (v24->n128_f64[0] < v22->n128_f64[0])
                {
                  __n128 v29 = *v22;
                  *float64x2_t v22 = *v24;
                  *uint64_t v24 = v29;
                }
              }
            }
            else
            {
              if (v27 >= v26)
              {
                __n128 v30 = *v22;
                *float64x2_t v22 = *v24;
                *uint64_t v24 = v30;
                if (*n128_f64 >= v24->n128_f64[0]) {
                  goto LABEL_34;
                }
                __n128 v113 = *v24;
                *uint64_t v24 = *(__n128 *)n128_f64;
                __n128 v28 = v113;
              }
              else
              {
                __n128 v28 = *v22;
                *float64x2_t v22 = *(__n128 *)n128_f64;
              }
              *(__n128 *)n128_f64 = v28;
            }
LABEL_34:
            unint64_t v31 = v14 + 2;
            uint8x8_t v32 = &v14[v17];
            double v34 = v32[1].n128_f64[0];
            double v33 = v32 + 1;
            double v35 = v34;
            double v36 = *v13;
            if (v34 >= v14[2].n128_f64[0])
            {
              if (v36 < v35)
              {
                __n128 v114 = *v33;
                *double v33 = *(__n128 *)v13;
                *(__n128 *)double v13 = v114;
                if (v33->n128_f64[0] < v31->n128_f64[0])
                {
                  __n128 v38 = *v31;
                  *unint64_t v31 = *v33;
                  *double v33 = v38;
                }
              }
            }
            else
            {
              if (v36 >= v35)
              {
                __n128 v39 = *v31;
                *unint64_t v31 = *v33;
                *double v33 = v39;
                if (*v13 >= v33->n128_f64[0]) {
                  goto LABEL_43;
                }
                __n128 v115 = *v33;
                *double v33 = *(__n128 *)v13;
                __n128 v37 = v115;
              }
              else
              {
                __n128 v37 = *v31;
                *unint64_t v31 = *(__n128 *)v13;
              }
              *(__n128 *)double v13 = v37;
            }
LABEL_43:
            double v40 = *v18;
            double v41 = v33->n128_f64[0];
            if (*v18 >= v24->n128_f64[0])
            {
              if (v41 < v40)
              {
                __n128 v117 = *(__n128 *)v18;
                *(__n128 *)double v18 = *v33;
                *double v33 = v117;
                if (*v18 < v24->n128_f64[0])
                {
                  __n128 v118 = *v24;
                  *uint64_t v24 = *(__n128 *)v18;
                  *(__n128 *)double v18 = v118;
                }
              }
              goto LABEL_52;
            }
            if (v41 >= v40)
            {
              __n128 v119 = *v24;
              *uint64_t v24 = *(__n128 *)v18;
              *(__n128 *)double v18 = v119;
              if (v33->n128_f64[0] >= *v18)
              {
LABEL_52:
                __n128 v120 = *v14;
                *double v14 = *(__n128 *)v18;
                a5.n128_u64[1] = v120.n128_u64[1];
                *(__n128 *)double v18 = v120;
                goto LABEL_53;
              }
              __n128 v116 = *(__n128 *)v18;
              *(__n128 *)double v18 = *v33;
            }
            else
            {
              __n128 v116 = *v24;
              *uint64_t v24 = *v33;
            }
            *double v33 = v116;
            goto LABEL_52;
          }
          double v21 = v14->n128_f64[0];
          if (v14->n128_f64[0] >= *v18)
          {
            if (v19 < v21)
            {
              __n128 v108 = *v14;
              *double v14 = *(__n128 *)n128_u64;
              a5.n128_u64[1] = v108.n128_u64[1];
              *(__n128 *)n128_u64 = v108;
              if (v14->n128_f64[0] < *v18)
              {
                __n128 v109 = *(__n128 *)v18;
                *(__n128 *)double v18 = *v14;
                a5.n128_u64[1] = v109.n128_u64[1];
                *double v14 = v109;
              }
            }
          }
          else
          {
            if (v19 < v21)
            {
              __n128 v105 = *(__n128 *)v18;
              *(_OWORD *)double v18 = *(_OWORD *)n128_u64;
LABEL_30:
              a5.n128_u64[1] = v105.n128_u64[1];
              *(__n128 *)n128_u64 = v105;
              goto LABEL_53;
            }
            __n128 v112 = *(__n128 *)v18;
            *(__n128 *)double v18 = *v14;
            a5.n128_u64[1] = v112.n128_u64[1];
            *double v14 = v112;
            if (*(double *)n128_u64 < v14->n128_f64[0])
            {
              __n128 v105 = *v14;
              *double v14 = *(__n128 *)n128_u64;
              goto LABEL_30;
            }
          }
LABEL_53:
          --a3;
          a5.n128_u64[0] = v14->n128_u64[0];
          if ((a4 & 1) != 0 || v14[-1].n128_f64[0] < a5.n128_f64[0]) {
            break;
          }
          if (a5.n128_f64[0] < *(double *)n128_u64)
          {
            do
            {
              double v55 = v14[1].n128_f64[0];
              ++v14;
            }
            while (a5.n128_f64[0] >= v55);
          }
          else
          {
            long long v56 = v14 + 1;
            do
            {
              double v14 = v56;
              if (v56 >= a2) {
                break;
              }
              ++v56;
            }
            while (a5.n128_f64[0] >= v14->n128_f64[0]);
          }
          double v57 = a2;
          if (v14 < a2)
          {
            double v57 = a2;
            do
            {
              double v58 = v57[-1].n128_f64[0];
              --v57;
            }
            while (a5.n128_f64[0] < v58);
          }
          unint64_t v59 = a1->n128_u64[1];
          while (v14 < v57)
          {
            __n128 v121 = *v14;
            *double v14 = *v57;
            *double v57 = v121;
            do
            {
              double v60 = v14[1].n128_f64[0];
              ++v14;
            }
            while (a5.n128_f64[0] >= v60);
            do
            {
              double v61 = v57[-1].n128_f64[0];
              --v57;
            }
            while (a5.n128_f64[0] < v61);
          }
          BOOL v5 = &v14[-1] >= a1;
          BOOL v6 = &v14[-1] == a1;
          if (&v14[-1] != a1) {
            *a1 = v14[-1];
          }
          a4 = 0;
          v14[-1].n128_u64[0] = a5.n128_u64[0];
          v14[-1].n128_u64[1] = v59;
        }
        unint64_t v42 = v14->n128_u64[1];
        uint64_t v43 = v14;
        do
        {
          unint64_t v44 = v43;
          double v45 = v43[1].n128_f64[0];
          ++v43;
        }
        while (v45 < a5.n128_f64[0]);
        unint64_t v46 = a2;
        if (v44 == v14)
        {
          unint64_t v46 = a2;
          do
          {
            if (v43 >= v46) {
              break;
            }
            double v48 = v46[-1].n128_f64[0];
            --v46;
          }
          while (v48 >= a5.n128_f64[0]);
        }
        else
        {
          do
          {
            double v47 = v46[-1].n128_f64[0];
            --v46;
          }
          while (v47 >= a5.n128_f64[0]);
        }
        double v14 = v43;
        if (v43 < v46)
        {
          uint64_t v49 = v46;
          do
          {
            __n128 v50 = *v14;
            *double v14 = *v49;
            *uint64_t v49 = v50;
            do
            {
              double v51 = v14[1].n128_f64[0];
              ++v14;
            }
            while (v51 < a5.n128_f64[0]);
            do
            {
              double v52 = v49[-1].n128_f64[0];
              --v49;
            }
            while (v52 >= a5.n128_f64[0]);
          }
          while (v14 < v49);
        }
        if (&v14[-1] != a1) {
          *a1 = v14[-1];
        }
        v14[-1].n128_u64[0] = a5.n128_u64[0];
        v14[-1].n128_u64[1] = v42;
        if (v43 >= v46) {
          break;
        }
LABEL_74:
        std::__introsort<std::_ClassicAlgPolicy,md::MuninRoadLabeler::debugDrawZData(md::DebugConsoleMapRect *)::$_0 &,gm::Range<double> *,false>(a1, &v14[-1], a3, a4 & 1);
        a4 = 0;
      }
      BOOL v53 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::debugDrawZData(md::DebugConsoleMapRect *)::$_0 &,gm::Range<double> *>(a1, v14 - 1, a5);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::debugDrawZData(md::DebugConsoleMapRect *)::$_0 &,gm::Range<double> *>(v14, a2, v54))
      {
        break;
      }
      if (!v53) {
        goto LABEL_74;
      }
    }
    a2 = v14 - 1;
    if (!v53) {
      continue;
    }
    return a5.n128_f64[0];
  }
}

void md::ComposedRoadEdgeZInfo::~ComposedRoadEdgeZInfo(md::ComposedRoadEdgeZInfo *this)
{
  uint64_t v2 = (void *)*((void *)this + 10);
  if (v2)
  {
    *((void *)this + 11) = v2;
    operator delete(v2);
  }
  long long v3 = (void *)*((void *)this + 7);
  if (v3)
  {
    *((void *)this + 8) = v3;
    operator delete(v3);
  }
  long long v4 = (void *)*((void *)this + 4);
  if (v4)
  {
    *((void *)this + 5) = v4;
    operator delete(v4);
  }
  BOOL v5 = (void *)*((void *)this + 1);
  if (v5)
  {
    *((void *)this + 2) = v5;
    operator delete(v5);
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninRoadLabeler::debugDrawZData(md::DebugConsoleMapRect *)::$_0 &,gm::Range<double> *>(__n128 *a1, __n128 *a2, __n128 a3)
{
  uint64_t v5 = a2 - a1;
  BOOL result = 1;
  switch(v5)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v7 = a2 - 1;
      if (a2[-1].n128_f64[0] < a1->n128_f64[0]) {
        goto LABEL_6;
      }
      return result;
    case 3:
      double v8 = a1 + 1;
      double v9 = a1[1].n128_f64[0];
      uint64_t v7 = a2 - 1;
      double v10 = a2[-1].n128_f64[0];
      if (v9 >= a1->n128_f64[0])
      {
        if (v10 < v9)
        {
          __n128 v27 = *v8;
          *double v8 = *v7;
          *uint64_t v7 = v27;
          if (a1[1].n128_f64[0] < a1->n128_f64[0])
          {
            __n128 v28 = *a1;
            *a1 = *v8;
            *double v8 = v28;
          }
        }
      }
      else if (v10 >= v9)
      {
        __n128 v31 = *a1;
        *a1 = *v8;
        *double v8 = v31;
        if (v7->n128_f64[0] < a1[1].n128_f64[0])
        {
          __n128 v32 = *v8;
          *double v8 = *v7;
          *uint64_t v7 = v32;
        }
      }
      else
      {
LABEL_6:
        __n128 v11 = *a1;
        *a1 = *v7;
        *uint64_t v7 = v11;
      }
      return result;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,-[LabelNavRouteLabeler(Debug) drawNavOverlayDebugView:navContext:]::$_0 &,gm::Range<double> *>(a1, a1[1].n128_f64, a1[2].n128_f64, a2[-1].n128_u64, a3);
      return 1;
    case 5:
      double v18 = a1 + 1;
      double v19 = a1 + 2;
      double v20 = a1 + 3;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,-[LabelNavRouteLabeler(Debug) drawNavOverlayDebugView:navContext:]::$_0 &,gm::Range<double> *>(a1, a1[1].n128_f64, a1[2].n128_f64, a1[3].n128_u64, a3);
      double v22 = a2[-1].n128_f64[0];
      double v21 = a2 - 1;
      if (v22 < a1[3].n128_f64[0])
      {
        __n128 v23 = *v20;
        *double v20 = *v21;
        *double v21 = v23;
        if (v20->n128_f64[0] < v19->n128_f64[0])
        {
          __n128 v24 = *v19;
          *double v19 = *v20;
          *double v20 = v24;
          if (v19->n128_f64[0] < v18->n128_f64[0])
          {
            __n128 v25 = *v18;
            *double v18 = *v19;
            *double v19 = v25;
            if (a1[1].n128_f64[0] < a1->n128_f64[0])
            {
              __n128 v26 = *a1;
              *a1 = *v18;
              *double v18 = v26;
            }
          }
        }
      }
      return 1;
    default:
      float64_t v12 = a1 + 2;
      double v13 = a1[2].n128_f64[0];
      double v14 = a1 + 1;
      double v15 = a1[1].n128_f64[0];
      double v16 = a1->n128_f64[0];
      if (v15 >= a1->n128_f64[0])
      {
        if (v13 < v15)
        {
          __n128 v29 = *v14;
          *double v14 = *v12;
          *float64_t v12 = v29;
          if (v14->n128_f64[0] < v16)
          {
            __n128 v30 = *a1;
            *a1 = *v14;
            *double v14 = v30;
          }
        }
      }
      else
      {
        if (v13 >= v15)
        {
          __n128 v33 = *a1;
          *a1 = *v14;
          *double v14 = v33;
          if (v13 >= a1[1].n128_f64[0]) {
            goto LABEL_27;
          }
          __n128 v17 = *v14;
          *double v14 = *v12;
        }
        else
        {
          __n128 v17 = *a1;
          *a1 = *v12;
        }
        *float64_t v12 = v17;
      }
LABEL_27:
      double v34 = a1 + 3;
      if (&a1[3] == a2) {
        return 1;
      }
      uint64_t v35 = 0;
      int v36 = 0;
      break;
  }
  while (1)
  {
    double v38 = v34->n128_f64[0];
    if (v34->n128_f64[0] < v12->n128_f64[0])
    {
      unint64_t v39 = v34->n128_u64[1];
      uint64_t v40 = v35;
      do
      {
        *(__n128 *)((char *)a1 + v40 + 48) = *(__n128 *)((char *)a1 + v40 + 32);
        if (v40 == -32)
        {
          uint64_t v37 = (uint64_t)a1;
          goto LABEL_30;
        }
        double v41 = *(double *)((char *)a1[1].n128_f64 + v40);
        v40 -= 16;
      }
      while (v38 < v41);
      uint64_t v37 = (uint64_t)&a1[3] + v40;
LABEL_30:
      *(double *)uint64_t v37 = v38;
      *(void *)(v37 + 8) = v39;
      if (++v36 == 8) {
        return &v34[1] == a2;
      }
    }
    float64_t v12 = v34;
    v35 += 16;
    if (++v34 == a2) {
      return 1;
    }
  }
}

uint64_t md::MuninRoadLabeler::debugString@<X0>(md::MuninRoadLabeler *this@<X0>, unsigned char *a2@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v21);
  md::LabelSettingsStyleCache::muninRoadStyle(*(md::LabelSettingsStyleCache **)(*(void *)(*((void *)this + 1) + 336)
                                                                              + 200));
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)"[MuninRoadLabeler]\n", 19);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)" State: isSceneLoaded=", 22);
  long long v4 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v4, (uint64_t)"\n", 1);
  uint64_t v5 = v21[0];
  *(_DWORD *)((char *)&v21[1] + *(void *)(v21[0] - 24)) = *(_DWORD *)((unsigned char *)&v21[1] + *(void *)(v21[0] - 24)) & 0xFFFFFEFB | 4;
  *(void *)((char *)&v21[2] + *(void *)(v5 - 24)) = 1;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)" Junctions: active=", 19);
  BOOL v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)" maxDist(Corner=", 16);
  uint64_t v7 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)" Cross=", 7);
  double v8 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)")\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)" Labels: active=", 16);
  double v9 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)"(", 1);
  double v10 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)") display=", 10);
  __n128 v11 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)" exist=", 7);
  atomic_load((unsigned int *)md::MuninRoadLabel::_totalLabels);
  float64_t v12 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)"\n", 1);
  if ((v28 & 0x10) != 0)
  {
    unint64_t v14 = v27;
    if (v27 < v24)
    {
      unint64_t v27 = v24;
      unint64_t v14 = v24;
    }
    double v15 = (const void **)&v23;
  }
  else
  {
    if ((v28 & 8) == 0)
    {
      size_t v13 = 0;
      a2[23] = 0;
      goto LABEL_16;
    }
    double v15 = (const void **)v22;
    unint64_t v14 = v22[2];
  }
  double v16 = *v15;
  size_t v13 = v14 - (void)*v15;
  if (v13 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v13 >= 0x17)
  {
    uint64_t v17 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v17 = v13 | 7;
    }
    uint64_t v18 = v17 + 1;
    double v19 = operator new(v17 + 1);
    *((void *)a2 + 1) = v13;
    *((void *)a2 + 2) = v18 | 0x8000000000000000;
    *(void *)a2 = v19;
    a2 = v19;
    goto LABEL_15;
  }
  a2[23] = v13;
  if (v13) {
LABEL_15:
  }
    memmove(a2, v16, v13);
LABEL_16:
  a2[v13] = 0;
  v21[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v21 + *(void *)(v21[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v21[1] = MEMORY[0x1E4FBA470] + 16;
  if (v26 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v29);
}

void sub_1A25AAC14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL altitude::Anchor::update(altitude::Anchor *this)
{
  uint64_t v100 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = *((unsigned __int8 *)this + 65);
  double v3 = *((double *)this + 2);
  long double v4 = tan(*((double *)this + 1) * 0.5 + 0.785398163);
  v5.n128_f64[0] = log(v4);
  BYTE1(v51) = 0;
  *(void *)((char *)&v51 + 4) = 0;
  BYTE1(v53) = 0;
  *(void *)((char *)&v53 + 4) = 0;
  char v54 = 0;
  uint64_t v55 = 0;
  char v56 = 0;
  uint64_t v57 = 0;
  char v58 = 0;
  uint64_t v59 = 0;
  char v60 = 0;
  uint64_t v61 = 0;
  char v62 = 0;
  uint64_t v63 = 0;
  char v64 = 0;
  uint64_t v65 = 0;
  char v66 = 0;
  uint64_t v67 = 0;
  char v68 = 0;
  uint64_t v69 = 0;
  char v70 = 0;
  uint64_t v71 = 0;
  char v72 = 0;
  uint64_t v73 = 0;
  char v74 = 0;
  uint64_t v75 = 0;
  char v76 = 0;
  uint64_t v77 = 0;
  char v78 = 0;
  uint64_t v79 = 0;
  char v80 = 0;
  uint64_t v81 = 0;
  char v82 = 0;
  uint64_t v83 = 0;
  char v84 = 0;
  uint64_t v85 = 0;
  char v86 = 0;
  uint64_t v87 = 0;
  char v88 = 0;
  uint64_t v89 = 0;
  char v90 = 0;
  uint64_t v91 = 0;
  char v92 = 0;
  uint64_t v93 = 0;
  char v94 = 0;
  uint64_t v95 = 0;
  char v96 = 0;
  uint64_t v97 = 0;
  char v98 = 0;
  uint64_t v99 = 0;
  uint64_t v6 = *((void *)this + 11);
  uint64_t v7 = *(void *)(v6 + 48);
  double v8 = *(void **)(v7 + 40);
  if (v8 != *(void **)(v7 + 48))
  {
    v5.n128_f64[0] = v5.n128_f64[0] * 0.159154943 + 0.5;
    do
    {
      double v9 = (_DWORD *)*v8;
      if (*v8)
      {
        unsigned int v10 = v9[98];
        if (v10 >= 0x1F) {
          char v11 = 31;
        }
        else {
          char v11 = v10;
        }
        if (*((unsigned char *)this + 65)) {
          BOOL v12 = *((unsigned __int8 *)this + 65) >= v10;
        }
        else {
          BOOL v12 = 0;
        }
        if (!v12)
        {
          int v13 = v9[99];
          int v14 = v9[100];
          if (*((unsigned __int8 *)&v51 + 24 * v10 + 1) == v10)
          {
            unsigned int v15 = *((_DWORD *)&v51 + 6 * v10 + 1);
          }
          else
          {
            double v16 = (double)(1 << v10);
            uint64_t v17 = (char *)&v51 + 24 * v10;
            *uint64_t v17 = -1;
            unsigned int v15 = (1 << v10) + ~vcvtmd_s64_f64(v5.n128_f64[0] * v16);
            v17[1] = v10;
            *((_DWORD *)v17 + 1) = v15;
            *((_DWORD *)v17 + 2) = vcvtmd_s64_f64((v3 * 0.159154943 + 0.5) * v16);
          }
          int v18 = ~(-1 << v11) - v13;
          if (v15 == v18 && *((_DWORD *)&v51 + 6 * v10 + 2) == v14)
          {
            *((unsigned char *)this + 64) = -1;
            *((unsigned char *)this + 65) = v10;
            *((_DWORD *)this + 17) = v18;
            *((_DWORD *)this + 18) = v14;
          }
        }
        uint64_t v7 = *(void *)(v6 + 48);
      }
      ++v8;
    }
    while (v8 != *(void **)(v7 + 48));
  }
  uint64_t v19 = *((unsigned __int8 *)this + 65);
  if (v19 <= v2 && !*((unsigned char *)this + 96)) {
    return 0;
  }
  *((unsigned char *)this + 96) = 1;
  if (v19 > 7)
  {
    int v26 = *((_DWORD *)this + 17);
    *(void *)&double v27 = *((unsigned int *)this + 18);
    v50[1] = 0.0;
    v50[2] = 0.0;
    *(void *)&v50[3] = v19 | ((unint64_t)(~(-1 << v19) - v26) << 32);
    v50[4] = v27;
    (*(void (**)(long long *__return_ptr, __n128))(**(void **)(v6 + 56) + 104))(&v51, v5);
    if ((void)v51)
    {
      v50[0] = 0.0;
      uint64_t v28 = *(void *)(v51 + 136);
      uint64_t v29 = *(void *)(v51 + 144);
      if (v28 >= 0x1F) {
        char v30 = 31;
      }
      else {
        char v30 = *(void *)(v51 + 136);
      }
      v47[0] = -1;
      v47[1] = v28;
      int v48 = ~(-1 << v30) - HIDWORD(v28);
      int v49 = v29;
      __n128 v31 = (std::__shared_weak_count *)*((void *)&v51 + 1);
      long long v46 = v51;
      if (*((void *)&v51 + 1))
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v51 + 1) + 8), 1uLL, memory_order_relaxed);
        long long v45 = *(_OWORD *)((char *)this + 8);
        int v32 = altitude::IntersectorHeight::sampleHeightMap((uint64_t *)&v46, (uint64_t)v47, (double *)&v45, v50);
        char v33 = v32;
        if (atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          if (!v32) {
            goto LABEL_36;
          }
LABEL_34:
          double v34 = v50[0];
          double v35 = *((double *)this + 2);
          double v36 = *((double *)this + 3) + v50[0];
          __double2 v37 = __sincos_stret(*((double *)this + 1));
          double v38 = 6378137.0 / sqrt(v37.__sinval * v37.__sinval * -0.00669437999 + 1.0);
          double v39 = (v38 + v36) * v37.__cosval;
          __double2 v40 = __sincos_stret(v35);
          int v41 = 0;
          *((double *)this + 4) = v39 * v40.__cosval;
          *((double *)this + 5) = v39 * v40.__sinval;
          *((double *)this + 6) = (v36 + v38 * 0.99330562) * v37.__sinval;
          *((double *)this + 7) = v34;
          *((unsigned char *)this + 96) = 0;
          goto LABEL_38;
        }
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
        if (v33) {
          goto LABEL_34;
        }
      }
      else
      {
        long long v45 = *(_OWORD *)((char *)this + 8);
        if (altitude::IntersectorHeight::sampleHeightMap((uint64_t *)&v46, (uint64_t)v47, (double *)&v45, v50)) {
          goto LABEL_34;
        }
      }
    }
    else if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v52))
    {
LABEL_37:
      int v41 = 1;
LABEL_38:
      double v52 = off_1EF5677B0;
      if ((void)v53) {
        atomic_fetch_add((atomic_uint *volatile)(v53 + 128), 0xFFFFFFFF);
      }
      unint64_t v42 = (std::__shared_weak_count *)*((void *)&v53 + 1);
      if (*((void *)&v53 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v53 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
        std::__shared_weak_count::__release_weak(v42);
        uint64_t v43 = (std::__shared_weak_count *)*((void *)&v51 + 1);
        if (!*((void *)&v51 + 1)) {
          return !v41;
        }
      }
      else
      {
        uint64_t v43 = (std::__shared_weak_count *)*((void *)&v51 + 1);
        if (!*((void *)&v51 + 1)) {
          return !v41;
        }
      }
      if (!atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
        return !v41;
      }
      return !v41;
    }
LABEL_36:
    *((unsigned char *)this + 96) = 0;
    goto LABEL_37;
  }
  *((unsigned char *)this + 96) = 0;
  double v20 = *((double *)this + 2);
  double v21 = *((double *)this + 3);
  __double2 v22 = __sincos_stret(*((double *)this + 1));
  double v23 = 6378137.0 / sqrt(v22.__sinval * v22.__sinval * -0.00669437999 + 1.0);
  double v24 = (v23 + v21) * v22.__cosval;
  __double2 v25 = __sincos_stret(v20);
  *((double *)this + 4) = v24 * v25.__cosval;
  *((double *)this + 5) = v24 * v25.__sinval;
  *((double *)this + 6) = (v21 + v23 * 0.99330562) * v22.__sinval;
  return 1;
}

void altitude::Anchor::destroy(altitude::Anchor *this)
{
  unsigned int v2 = (void *)*((void *)this + 11);
  uint64_t v3 = v2[5];
  long double v4 = (uint64_t *)v2[3];
  if (v4)
  {
    __n128 v5 = v2 + 3;
    uint64_t v6 = (void *)v2[3];
    do
    {
      unint64_t v7 = v6[4];
      BOOL v8 = v7 >= (unint64_t)this;
      if (v7 >= (unint64_t)this) {
        double v9 = v6;
      }
      else {
        double v9 = v6 + 1;
      }
      if (v8) {
        __n128 v5 = v6;
      }
      uint64_t v6 = (void *)*v9;
    }
    while (*v9);
    if (v5 != v2 + 3 && v5[4] <= (unint64_t)this)
    {
      unsigned int v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          char v11 = v10;
          unsigned int v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        BOOL v12 = v5;
        do
        {
          char v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          BOOL v12 = v11;
        }
        while (!v13);
      }
      if ((uint64_t *)v2[2] == v5) {
        v2[2] = v11;
      }
      --v2[4];
      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v4, v5);
      operator delete(v5);
    }
  }
  *(void *)this = *(void *)(v3 + 32);
  *(void *)(v3 + 32) = this;
}

uint64_t non-virtual thunk to'md::PolarFlyoverTileData::featureRegistryPtr(md::PolarFlyoverTileData *this)
{
  return *((void *)this + 18);
}

uint64_t md::PolarFlyoverTileData::featureRegistryPtr(md::PolarFlyoverTileData *this)
{
  return *((void *)this + 97);
}

void md::PolarFlyoverTileData::~PolarFlyoverTileData(md::PolarFlyoverTileData *this)
{
  md::PolarFlyoverTileData::~PolarFlyoverTileData(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t vars8;

  *(void *)this = &unk_1EF513410;
  *((void *)this + 79) = &unk_1EF513458;
  md::RegistryManager::removeRegistry(*((md::RegistryManager **)this + 95), this);
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 96);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *((void *)this + 92);
  if (v3)
  {
    long double v4 = *((void *)this + 93);
    __n128 v5 = (void *)*((void *)this + 92);
    if (v4 != v3)
    {
      do
      {
        uint64_t v6 = *(std::__shared_weak_count **)(v4 - 8);
        if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
        v4 -= 16;
      }
      while (v4 != v3);
      __n128 v5 = (void *)*((void *)this + 92);
    }
    *((void *)this + 93) = v3;
    operator delete(v5);
  }
  unint64_t v7 = (std::__shared_weak_count *)*((void *)this + 91);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  md::MapTileData::~MapTileData(this);
}

void sub_1A25AB4D4(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v2);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)(v1 + 736));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 720);
  md::MapTileData::~MapTileData((md::MapTileData *)v1);
  _Unwind_Resume(a1);
}

void md::ARWalkingStorefrontLabelFeature::populateStyleQueries(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  char v62 = 0;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 488))(a1)
    && (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 480))(a1, 0))
  {
    operator new();
  }
  uint64_t v6 = *(void **)a2;
  unint64_t v7 = *(void **)(a2 + 8);
  uint64_t v8 = (uint64_t)v7 - *(void *)a2;
  if ((unint64_t)v8 > 0x1F)
  {
    if (v8 != 32)
    {
      for (uint64_t i = v6 + 4; v7 != i; v7 -= 2)
      {
        int v18 = (std::__shared_weak_count *)*(v7 - 1);
        if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      *(void *)(a2 + 8) = i;
    }
  }
  else
  {
    unint64_t v9 = (unint64_t)v8 >> 4;
    unint64_t v10 = 2 - ((unint64_t)v8 >> 4);
    uint64_t v11 = *(void *)(a2 + 16);
    if (v10 <= (v11 - (uint64_t)v7) >> 4)
    {
      uint64_t v19 = &v7[2 * v10];
      uint64_t v20 = 32 - 16 * v9;
      do
      {
        if (v7)
        {
          *unint64_t v7 = 0;
          v7[1] = 0;
        }
        v7 += 2;
        v20 -= 16;
      }
      while (v20);
      *(void *)(a2 + 8) = v19;
    }
    else
    {
      uint64_t v12 = v8 >> 4;
      unint64_t v13 = (v8 >> 4) + v10;
      if (v13 >> 60) {
        abort();
      }
      uint64_t v14 = v11 - (void)v6;
      if (v14 >> 3 > v13) {
        unint64_t v13 = v14 >> 3;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0) {
        uint64_t v15 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v15 = v13;
      }
      if (v15) {
        uint64_t v16 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 24) + 16))(*(void *)(a2 + 24), 16 * v15, 8);
      }
      else {
        uint64_t v16 = 0;
      }
      double v21 = (void *)(v16 + 16 * v12);
      __double2 v22 = &v21[2 * v10];
      uint64_t v23 = 32 - 16 * v9;
      double v24 = v21;
      do
      {
        if (v24)
        {
          *double v24 = 0;
          v24[1] = 0;
        }
        v24 += 2;
        v23 -= 16;
      }
      while (v23);
      uint64_t v25 = v16 + 16 * v15;
      int v26 = *(void **)a2;
      double v27 = *(void **)(a2 + 8);
      if (v27 == *(void **)a2)
      {
        *(void *)a2 = v21;
        *(void *)(a2 + 8) = v22;
        uint64_t v30 = *(void *)(a2 + 16);
        *(void *)(a2 + 16) = v25;
      }
      else
      {
        do
        {
          long long v28 = *((_OWORD *)v27 - 1);
          v27 -= 2;
          *((_OWORD *)v21 - 1) = v28;
          v21 -= 2;
          *double v27 = 0;
          v27[1] = 0;
        }
        while (v27 != v26);
        double v27 = *(void **)a2;
        uint64_t v29 = *(void **)(a2 + 8);
        *(void *)a2 = v21;
        *(void *)(a2 + 8) = v22;
        uint64_t v30 = *(void *)(a2 + 16);
        for (*(void *)(a2 + 16) = v25; v29 != v27; v29 -= 2)
        {
          __n128 v31 = (std::__shared_weak_count *)*(v29 - 1);
          if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
            std::__shared_weak_count::__release_weak(v31);
          }
        }
      }
      if (v27) {
        (*(void (**)(void, void *, uint64_t))(**(void **)(a2 + 24) + 40))(*(void *)(a2 + 24), v27, v30 - (void)v27);
      }
    }
  }
  (*(void (**)(const FeatureStyleAttributes **__return_ptr, uint64_t, void))(*(void *)a1 + 584))(&v60, a1, 0);
  int v32 = v62;
  md::createFeatureAttributeSet((gss::Allocator *)&v63, (uint64_t *)&v60);
  md::LabelStyleCache::styleQueryForFeatureAttributes((uint64_t)&v59, a3, &v63, v32);
  if (v63)
  {
    uint64_t v64 = v63;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v66 + 40))(v66, v63, v65 - v63);
  }
  char v33 = *(void **)a2;
  long long v34 = v59;
  long long v59 = 0uLL;
  double v35 = (std::__shared_weak_count *)v33[1];
  *(_OWORD *)char v33 = v34;
  if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
  double v36 = (std::__shared_weak_count *)*((void *)&v59 + 1);
  if (*((void *)&v59 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v59 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
  }
  __double2 v37 = v60;
  double v38 = (char *)operator new(0x40uLL);
  *((void *)v38 + 1) = 0;
  *((void *)v38 + 2) = 0;
  *(void *)double v38 = &unk_1EF57F680;
  FeatureStyleAttributes::FeatureStyleAttributes((FeatureStyleAttributes *)(v38 + 24), v37);
  *(void *)&long long v59 = v38 + 24;
  *((void *)&v59 + 1) = v38;
  uint64_t v39 = v38[57];
  uint64_t v40 = *((void *)v38 + 3);
  if (v38[57])
  {
    if (v39 >= 0x20)
    {
      uint64_t v41 = 0;
      long long v45 = (int *)*((void *)v38 + 3);
      while (1)
      {
        int v46 = *v45;
        v45 += 2;
        if (v46 == 65594) {
          break;
        }
        if (v39 == ++v41) {
          goto LABEL_62;
        }
      }
    }
    else
    {
      uint64_t v41 = 0;
      unint64_t v42 = (int *)*((void *)v38 + 3);
      while (1)
      {
        int v43 = *v42;
        v42 += 2;
        if (v43 == 65594) {
          break;
        }
        if (v39 == ++v41) {
          goto LABEL_56;
        }
      }
    }
    *(_DWORD *)(v40 + 8 * v41 + 4) = 1;
  }
  else
  {
LABEL_56:
    *(void *)(v40 + 8 * v39) = 0x10001003ALL;
    unsigned __int8 v44 = v38[57] + 1;
    v38[57] = v44;
    qsort(*((void **)v38 + 3), v44, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
  }
LABEL_62:
  char v56 = v38 + 24;
  uint64_t v57 = (std::__shared_weak_count *)v38;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v38 + 1, 1uLL, memory_order_relaxed);
  double v47 = v62;
  md::createFeatureAttributeSet((gss::Allocator *)&v63, (uint64_t *)&v56);
  md::LabelStyleCache::styleQueryForFeatureAttributes((uint64_t)&v58, a3, &v63, v47);
  if (v63)
  {
    uint64_t v64 = v63;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v66 + 40))(v66, v63, v65 - v63);
  }
  int v48 = *(void **)a2;
  long long v49 = v58;
  long long v58 = 0uLL;
  __n128 v50 = (std::__shared_weak_count *)v48[3];
  *((_OWORD *)v48 + 1) = v49;
  if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
    std::__shared_weak_count::__release_weak(v50);
  }
  long long v51 = (std::__shared_weak_count *)*((void *)&v58 + 1);
  if (*((void *)&v58 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v58 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
    std::__shared_weak_count::__release_weak(v51);
  }
  double v52 = v57;
  if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
    std::__shared_weak_count::__release_weak(v52);
  }
  long long v53 = (std::__shared_weak_count *)*((void *)&v59 + 1);
  if (*((void *)&v59 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v59 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
  }
  char v54 = v61;
  if (v61 && !atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
    std::__shared_weak_count::__release_weak(v54);
  }
  uint64_t v55 = v62;
  if (v62)
  {
    if (*((char *)v62 + 23) < 0) {
      (*(void (**)(void, void, uint64_t))(*(void *)v62[3] + 40))(v62[3], *v62, v62[2] & 0x7FFFFFFFFFFFFFFFLL);
    }
    MEMORY[0x1A6239270](v55, 0x1032C402ED93987);
  }
}

void sub_1A25ABCF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::unique_ptr<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>::~unique_ptr[abi:nn180100]((uint64_t *)va2);
  _Unwind_Resume(a1);
}

uint64_t md::ARWalkingStorefrontLabelFeature::style(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 736);
  if (!v2) {
    goto LABEL_12;
  }
  uint64_t v3 = a1 + 736;
  do
  {
    unsigned int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 >= a2;
    if (v4 >= a2) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 != a1 + 736 && *(_DWORD *)(v3 + 28) <= a2) {
    uint64_t v7 = *(unsigned __int8 *)(v3 + 32);
  }
  else {
LABEL_12:
  }
    uint64_t v7 = 0;
  return *(void *)(a1 + 96) + 16 * v7;
}

void md::ARWalkingStorefrontLabelFeature::populateDebugNode(id *this, gdc::DebugTreeNode *a2, const md::LabelManager *a3)
{
  md::LabelFeature::populateDebugNode((md::LabelFeature *)this, a2, (unint64_t)a3);
  BOOL v5 = (char *)operator new(0x20uLL);
  v25.__r_.__value_.__r.__words[0] = (std::string::size_type)v5;
  *(_OWORD *)&v25.__r_.__value_.__r.__words[1] = xmmword_1A28FD670;
  strcpy(v5, "ARWalkingStorefrontLabelFeature");
  gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)&v25);
  operator delete(v5);
  uint64_t v6 = [this[88] description];
  uint64_t v19 = v6;
  if (v6)
  {
    *((unsigned char *)&v25.__r_.__value_.__s + 23) = 18;
    strcpy((char *)&v25, "VKARWalkingFeature");
    uint64_t v7 = (const std::string::value_type *)[v6 UTF8String];
    memset(&__p, 0, sizeof(__p));
    int v24 = 4;
    if (v7)
    {
      std::string::__assign_external(&__p, v7);
    }
    else
    {
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 6;
      strcpy((char *)&__p, "<null>");
    }
    gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)&v25, (uint64_t)v22);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v8 = (char *)operator new(0x20uLL);
  v25.__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
  *(_OWORD *)&v25.__r_.__value_.__r.__words[1] = xmmword_1A28FD110;
  strcpy(v8, "FallbackOcclusionStyling");
  ChildNode = gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)&v25);
  operator delete(v8);
  uint64_t v10 = (id *)this[91];
  uint64_t v11 = (id **)(this + 92);
  if (v10 != this + 92)
  {
    do
    {
      unsigned int v12 = *((_DWORD *)v10 + 7);
      if (v12)
      {
        std::to_string(&v25, v12);
      }
      else
      {
        *((unsigned char *)&v25.__r_.__value_.__s + 23) = 7;
        strcpy((char *)&v25, "UNKNOWN");
      }
      unint64_t v13 = gdc::DebugTreeNode::createChildNode((uint64_t)ChildNode, (long long *)&v25);
      if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v25.__r_.__value_.__l.__data_);
      }
      uint64_t v14 = (char *)operator new(0x20uLL);
      v25.__r_.__value_.__r.__words[0] = (std::string::size_type)v14;
      *(_OWORD *)&v25.__r_.__value_.__r.__words[1] = xmmword_1A28FD110;
      strcpy(v14, "FallbackOcclusionStyling");
      uint64_t v15 = *((unsigned __int8 *)v10 + 32);
      memset(&v20[4], 0, 24);
      int v21 = 0;
      v20[0] = v15;
      gdc::DebugTreeNode::addProperty((uint64_t)v13, (uint64_t)&v25, (uint64_t)v20);
      operator delete(v14);
      uint64_t v16 = (id *)v10[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = (id **)v16;
          uint64_t v16 = (id *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v17 = (id **)v10[2];
          BOOL v18 = *v17 == v10;
          uint64_t v10 = (id *)v17;
        }
        while (!v18);
      }
      uint64_t v10 = (id *)v17;
    }
    while (v17 != v11);
  }
}

void sub_1A25AC0FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

double md::ARWalkingStorefrontLabelFeature::elevationOffset()
{
  return 0.0;
}

uint64_t md::ARWalkingStorefrontLabelFeature::dedupingGroup@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 760);
  *a2 = *(void *)(this + 752);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

uint64_t md::ARWalkingStorefrontLabelFeature::labelFeatureType(md::ARWalkingStorefrontLabelFeature *this)
{
  return 27;
}

id md::ARWalkingStorefrontLabelFeature::arWalkingFeature(id *this)
{
  return this[88];
}

BOOL md::ARWalkingStorefrontLabelFeature::updateDynamicStyling(md::ARWalkingStorefrontLabelFeature *this, LabelManager *a2, md::Label *a3)
{
  unsigned int v4 = (uint64_t **)((char *)this + 736);
  BOOL v5 = (char *)*((void *)this + 92);
  if (v5)
  {
    unsigned int v6 = *((_DWORD *)a3 + 12);
    uint64_t v7 = (uint64_t **)((char *)this + 736);
    uint64_t v8 = (char *)*((void *)this + 92);
    do
    {
      unsigned int v9 = *((_DWORD *)v8 + 7);
      BOOL v10 = v9 >= v6;
      if (v9 >= v6) {
        uint64_t v11 = (char **)v8;
      }
      else {
        uint64_t v11 = (char **)(v8 + 8);
      }
      if (v10) {
        uint64_t v7 = (uint64_t **)v8;
      }
      uint64_t v8 = *v11;
    }
    while (*v11);
    BOOL v12 = v7 != v4 && v6 >= *((_DWORD *)v7 + 7) && *((unsigned __int8 *)v7 + 32) != *((unsigned __int8 *)this + 720);
    char v13 = *((unsigned char *)this + 720);
    do
    {
      while (1)
      {
        uint64_t v14 = v5;
        unsigned int v15 = *((_DWORD *)v5 + 7);
        if (v6 < v15) {
          break;
        }
        if (v15 >= v6) {
          goto LABEL_25;
        }
        BOOL v5 = (char *)*((void *)v14 + 1);
        if (!v5)
        {
          unsigned int v4 = (uint64_t **)(v14 + 8);
          goto LABEL_22;
        }
      }
      BOOL v5 = *(char **)v14;
    }
    while (*(void *)v14);
    unsigned int v4 = (uint64_t **)v14;
  }
  else
  {
    BOOL v12 = 0;
    char v13 = *((unsigned char *)this + 720);
    unsigned int v6 = *((_DWORD *)a3 + 12);
    uint64_t v14 = (char *)this + 736;
  }
LABEL_22:
  uint64_t v16 = v14;
  uint64_t v14 = (char *)operator new(0x28uLL);
  *((_DWORD *)v14 + 7) = v6;
  v14[32] = 0;
  *(void *)uint64_t v14 = 0;
  *((void *)v14 + 1) = 0;
  *((void *)v14 + 2) = v16;
  *unsigned int v4 = (uint64_t *)v14;
  uint64_t v17 = **((void **)this + 91);
  BOOL v18 = (uint64_t *)v14;
  if (v17)
  {
    *((void *)this + 91) = v17;
    BOOL v18 = *v4;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 92), v18);
  ++*((void *)this + 93);
LABEL_25:
  v14[32] = v13;
  return v12;
}

uint64_t md::ARWalkingStorefrontLabelFeature::newRootPart(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  uint64_t v5 = md::PointLabelFeature::newRootPart(a1, a2, a3, a4, a5);
  uint64_t v6 = v5;
  if (v5) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 64))(v5, 1, 1);
  }
  return v6;
}

void md::ARWalkingStorefrontLabelFeature::~ARWalkingStorefrontLabelFeature(md::ARWalkingStorefrontLabelFeature *this)
{
  md::ARWalkingStorefrontLabelFeature::~ARWalkingStorefrontLabelFeature(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  std::__shared_weak_count *v6;
  uint64_t vars8;

  *(void *)this = &unk_1EF54CDF8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 95);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 92));
  *((void *)this + 87) = &unk_1EF559BD8;

  *(void *)this = &unk_1EF542320;
  uint64_t v3 = *((void *)this + 84);
  if (v3)
  {
    unsigned int v4 = *((void *)this + 85);
    uint64_t v5 = (void *)*((void *)this + 84);
    if (v4 != v3)
    {
      do
      {
        uint64_t v6 = *(std::__shared_weak_count **)(v4 - 8);
        if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
        v4 -= 16;
      }
      while (v4 != v3);
      uint64_t v5 = (void *)*((void *)this + 84);
    }
    *((void *)this + 85) = v3;
    operator delete(v5);
  }
  md::PointLabelFeature::~PointLabelFeature(this);
}

void geo::_retain_ptr<VKARWalkingArrivalStoreFront * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559CB8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKARWalkingArrivalStoreFront * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559CB8;

  return a1;
}

void md::LabelExternalPointFeature::addLocation(void *a1, double *a2)
{
  uint64_t v4 = a1[24];
  if (!*(unsigned char *)(v4 + 45) || !*(unsigned char *)(v4 + 46) || *(float *)(v4 + 40) != 3.4028e38 || *(_OWORD *)(v4 + 24) != 0)
  {
    unint64_t v6 = a1[25];
    unint64_t v5 = a1[26];
    if (v6 >= v5)
    {
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - v4) >> 4) + 1;
      if (v8 > 0x555555555555555) {
        abort();
      }
      unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - v4) >> 4);
      if (2 * v9 > v8) {
        unint64_t v8 = 2 * v9;
      }
      if (v9 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v10 = 0x555555555555555;
      }
      else {
        unint64_t v10 = v8;
      }
      if (v10 > 0x555555555555555) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v11 = 48 * v10;
      BOOL v12 = (char *)operator new(48 * v10);
      char v13 = &v12[16 * ((uint64_t)(v6 - v4) >> 4)];
      uint64_t v14 = &v12[v11];
      *((_OWORD *)v13 + 1) = 0u;
      *((_OWORD *)v13 + 2) = 0u;
      *(_OWORD *)char v13 = 0u;
      *((_DWORD *)v13 + 10) = 2139095039;
      uint64_t v7 = v13 + 48;
      if (v6 == v4)
      {
        a1[24] = v13;
        a1[25] = v7;
        a1[26] = v14;
      }
      else
      {
        do
        {
          long long v15 = *(_OWORD *)(v6 - 48);
          *((void *)v13 - 4) = *(void *)(v6 - 32);
          *((_OWORD *)v13 - 3) = v15;
          *(_OWORD *)(v13 - 24) = *(_OWORD *)(v6 - 24);
          int v16 = *(_DWORD *)(v6 - 8);
          *(_DWORD *)(v13 - 5) = *(_DWORD *)(v6 - 5);
          *((_DWORD *)v13 - 2) = v16;
          v13 -= 48;
          v6 -= 48;
        }
        while (v6 != v4);
        a1[24] = v13;
        a1[25] = v7;
        a1[26] = v14;
        if (!v4) {
          goto LABEL_20;
        }
      }
      operator delete((void *)v4);
    }
    else
    {
      *(_OWORD *)(v6 + 16) = 0u;
      *(_OWORD *)(v6 + 32) = 0u;
      *(_OWORD *)unint64_t v6 = 0u;
      *(_DWORD *)(v6 + 40) = 2139095039;
      uint64_t v7 = (char *)(v6 + 48);
    }
LABEL_20:
    a1[25] = v7;
    goto LABEL_21;
  }
  uint64_t v7 = (char *)a1[25];
LABEL_21:
  double v17 = *a2;
  if (fabs(*a2) <= 85.0511169)
  {
    float64_t v32 = a2[1];
    long double v22 = tan(v17 * 0.00872664626 + 0.785398163);
    long double v23 = log(v22);
    v24.f64[0] = v32;
    v24.f64[1] = v23;
    __asm { FMOV            V1.2D, #0.5 }
    *(float64x2_t *)(v7 - 24) = vmlaq_f64(_Q1, (float64x2_t)xmmword_1A28FCBE0, v24);
    *(_WORD *)(v7 - 3) = 257;
  }
  else
  {
    double v18 = a2[1] * 0.0174532925;
    __double2 v19 = __sincos_stret(v17 * 0.0174532925);
    double v20 = 6378137.0 / sqrt(v19.__sinval * v19.__sinval * -0.00669437999 + 1.0);
    __double2 v21 = __sincos_stret(v18);
    *((double *)v7 - 6) = v20 * v19.__cosval * v21.__cosval;
    *((double *)v7 - 5) = v20 * v19.__cosval * v21.__sinval;
    *((double *)v7 - 4) = v19.__sinval * 0.99330562 * v20;
    *(v7 - 4) = 1;
  }
  double v30 = a2[2];
  if (v30 != 1.79769313e308)
  {
    float v31 = v30;
    *((float *)v7 - 2) = v31;
  }
}

void std::__shared_ptr_emplace<md::ARWalkingStorefront>::__on_zero_shared(uint64_t a1)
{
  *(void *)(a1 + 168) = &unk_1EF559CB8;
}

void std::__shared_ptr_emplace<md::ARWalkingStorefront>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580B48;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::ARWalkingStorefront>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580B48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_pointer<ARStorefrontLabelFeatureDedupingGroup *,std::shared_ptr<md::LabelDedupingGroup>::__shared_ptr_default_delete<md::LabelDedupingGroup,ARStorefrontLabelFeatureDedupingGroup>,std::allocator<ARStorefrontLabelFeatureDedupingGroup>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ARStorefrontLabelFeatureDedupingGroup *,std::shared_ptr<md::LabelDedupingGroup>::__shared_ptr_default_delete<md::LabelDedupingGroup,ARStorefrontLabelFeatureDedupingGroup>,std::allocator<ARStorefrontLabelFeatureDedupingGroup>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

BOOL ARStorefrontLabelFeatureDedupingGroup::isResolved(ARStorefrontLabelFeatureDedupingGroup *this)
{
  return *((void *)this + 5) != *((void *)this + 6);
}

double *ARStorefrontLabelFeatureDedupingGroup::prepareForCollision(int8x8_t *this, md::LabelManager *a2)
{
  this[6] = this[5];
  this[9] = 0;
  unint64_t v5 = (int8x16_t *)this[1];
  uint64_t v4 = (int8x16_t *)this[2];
  if (v5 != v4)
  {
    while (((*(uint64_t (**)(void))(*(void *)v5->i64[0] + 16))() & 1) != 0)
    {
      unint64_t v5 = (int8x16_t *)((char *)v5 + 8);
LABEL_4:
      if (v5 == v4) {
        goto LABEL_11;
      }
    }
    unint64_t v6 = (int8x16_t *)((char *)v4 - 8);
    while (v6 != v5)
    {
      uint64_t v4 = v6;
      uint64_t v7 = v6->i64[0];
      unint64_t v6 = (int8x16_t *)((char *)v6 - 8);
      if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 16))(v7))
      {
        uint64_t v8 = v5->i64[0];
        v5->i64[0] = v4->i64[0];
        unint64_t v5 = (int8x16_t *)((char *)v5 + 8);
        v4->i64[0] = v8;
        goto LABEL_4;
      }
    }
  }
  uint64_t v4 = v5;
LABEL_11:
  unint64_t v9 = (double *)this[1];
  unint64_t v10 = 126 - 2 * __clz(((char *)v4 - (char *)v9) >> 3);
  uint64_t v11 = (int8x8_t *)(*((void *)a2 + 54) + 136);
  v28[0] = this;
  v28[1] = v11;
  if (v4 == (int8x16_t *)v9) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = v10;
  }
  uint64_t result = std::__introsort<std::_ClassicAlgPolicy,ARStorefrontLabelFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**,false>(v9, v4, v28, v12, 1);
  uint64_t v14 = (int8x8_t *)this[1];
  long long v15 = (int8x8_t *)this[2];
  if (v14 != v15)
  {
    unint64_t v16 = (char *)v15 - (char *)v14 - 8;
    if (v16 > 7)
    {
      uint64_t v19 = 0;
      uint64_t v20 = (v16 >> 3) + 1;
      uint64_t v17 = v20 & 0x3FFFFFFFFFFFFFFELL;
      do
      {
        __double2 v21 = &v14[v19];
        int8x8_t v23 = *v21;
        int8x8_t v22 = v21[1];
        *(_DWORD *)(*(void *)&v23 + 32) = v19;
        *(_DWORD *)(*(void *)&v22 + 32) = v19 + 1;
        v19 += 2;
      }
      while (v17 != v19);
      if (v20 == v17) {
        goto LABEL_22;
      }
      double v18 = &v14[v20 & 0x3FFFFFFFFFFFFFFELL];
    }
    else
    {
      LODWORD(v17) = 0;
      double v18 = (int8x8_t *)this[1];
    }
    do
    {
      uint64_t v24 = (uint64_t)*v18++;
      *(_DWORD *)(v24 + 32) = v17;
      LODWORD(v17) = v17 + 1;
    }
    while (v18 != v15);
LABEL_22:
    this[9] = *v14;
  }
  if (this[13])
  {
    uint64_t result = (double *)this[12];
    if (result)
    {
      do
      {
        std::string v25 = *(double **)result;
        operator delete(result);
        uint64_t result = v25;
      }
      while (v25);
    }
    this[12] = 0;
    int8x8_t v26 = this[11];
    if (v26)
    {
      uint64_t v27 = 0;
      do
        *(void *)(*(void *)&this[10] + 8 * v27++) = 0;
      while (*(void *)&v26 != v27);
    }
    this[13] = 0;
  }
  return result;
}

double *std::__introsort<std::_ClassicAlgPolicy,ARStorefrontLabelFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**,false>(double *result, int8x16_t *a2, int8x8_t **a3, uint64_t a4, char a5)
{
  uint64_t v8 = (int8x16_t *)result;
LABEL_2:
  unint64_t v9 = a2;
  float v544 = &a2[-1].u64[1];
  unint64_t v10 = v8;
  while (1)
  {
    uint64_t v11 = v10;
    uint64_t v12 = (char *)v9 - (char *)v10;
    uint64_t v13 = ((char *)v9 - (char *)v10) >> 3;
    long double v558 = v10;
    if (v6 || !v5)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          unint64_t v251 = *v544;
          unint64_t v252 = v10->i64[0];
          unint64_t v560 = v10->i64[0];
          unint64_t v561 = v251;
          unint64_t v253 = (float *)&(*a3)[10];
          double v254 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v253, v251);
          if (v254)
          {
            double v255 = v254[3];
          }
          else
          {
            uint8x8_t v501 = a3[1];
            float64x2_t v502 = vsubq_f64(*(float64x2_t *)v501[1].i8, *(float64x2_t *)(v251 + 600));
            float64x2_t v503 = vmulq_f64(v502, v502);
            double v255 = v503.f64[0]
                 + (*(double *)v501 - *(double *)(v251 + 592)) * (*(double *)v501 - *(double *)(v251 + 592))
                 + v503.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v253, v251, &v561)+ 3) = v255;
          }
          uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v253, v252);
          if (result)
          {
            if (v255 >= result[3]) {
              return result;
            }
          }
          else
          {
            BOOL v504 = a3[1];
            float64x2_t v505 = vsubq_f64(*(float64x2_t *)v504[1].i8, *(float64x2_t *)(v252 + 600));
            float64x2_t v506 = vmulq_f64(v505, v505);
            double v507 = v506.f64[0]
                 + (*(double *)v504 - *(double *)(v252 + 592)) * (*(double *)v504 - *(double *)(v252 + 592))
                 + v506.f64[1];
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v253, v252, &v560);
            result[3] = v507;
            if (v255 >= v507) {
              return result;
            }
          }
          unint64_t v508 = v10->i64[0];
          v10->i64[0] = *v544;
          unint64_t *v544 = v508;
          return result;
        case 3:
          return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)v10, &v10->u64[1], v544, a3);
        case 4:
          unint64_t v256 = v10 + 1;
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)v10, &v10->u64[1], (unint64_t *)&v10[1], a3);
          unint64_t v257 = *v544;
          unint64_t v258 = v10[1].u64[0];
          unint64_t v560 = v258;
          unint64_t v561 = v257;
          double v259 = (float *)&(*a3)[10];
          unint64_t v260 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v259, v257);
          if (v260)
          {
            double v261 = v260[3];
          }
          else
          {
            v509 = a3[1];
            float64x2_t v510 = vsubq_f64(*(float64x2_t *)v509[1].i8, *(float64x2_t *)(v257 + 600));
            float64x2_t v511 = vmulq_f64(v510, v510);
            double v261 = v511.f64[0]
                 + (*(double *)v509 - *(double *)(v257 + 592)) * (*(double *)v509 - *(double *)(v257 + 592))
                 + v511.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v259, v257, &v561)+ 3) = v261;
          }
          uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v259, v258);
          if (result)
          {
            if (v261 >= result[3]) {
              return result;
            }
          }
          else
          {
            uint64_t v512 = a3[1];
            float64x2_t v513 = vsubq_f64(*(float64x2_t *)v512[1].i8, *(float64x2_t *)(v258 + 600));
            float64x2_t v514 = vmulq_f64(v513, v513);
            double v515 = v514.f64[0]
                 + (*(double *)v512 - *(double *)(v258 + 592)) * (*(double *)v512 - *(double *)(v258 + 592))
                 + v514.f64[1];
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v259, v258, &v560);
            result[3] = v515;
            if (v261 >= v515) {
              return result;
            }
          }
          unint64_t v516 = v256->i64[0];
          v256->i64[0] = *v544;
          unint64_t *v544 = v516;
          unint64_t v517 = v256->i64[0];
          unint64_t v518 = v10->u64[1];
          unint64_t v560 = v518;
          unint64_t v561 = v517;
          uint64_t v519 = (float *)&(*a3)[10];
          double v520 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v519, v517);
          if (v520)
          {
            double v521 = v520[3];
          }
          else
          {
            double v522 = a3[1];
            float64x2_t v523 = vsubq_f64(*(float64x2_t *)v522[1].i8, *(float64x2_t *)(v517 + 600));
            float64x2_t v524 = vmulq_f64(v523, v523);
            double v521 = v524.f64[0]
                 + (*(double *)v522 - *(double *)(v517 + 592)) * (*(double *)v522 - *(double *)(v517 + 592))
                 + v524.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v519, v517, &v561)+ 3) = v521;
          }
          uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v519, v518);
          if (result)
          {
            double v525 = result[3];
          }
          else
          {
            double v526 = a3[1];
            float64x2_t v527 = vsubq_f64(*(float64x2_t *)v526[1].i8, *(float64x2_t *)(v518 + 600));
            float64x2_t v528 = vmulq_f64(v527, v527);
            double v525 = v528.f64[0]
                 + (*(double *)v526 - *(double *)(v518 + 592)) * (*(double *)v526 - *(double *)(v518 + 592))
                 + v528.f64[1];
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v519, v518, &v560);
            result[3] = v525;
          }
          if (v521 < v525)
          {
            uint64_t v529 = v10->i64[1];
            unint64_t v530 = v10[1].u64[0];
            unint64_t v531 = v10->i64[0];
            v10->i64[1] = v530;
            v10[1].i64[0] = v529;
            unint64_t v560 = v531;
            unint64_t v561 = v530;
            float64_t v532 = (float *)&(*a3)[10];
            double v533 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v532, v530);
            if (v533)
            {
              double v534 = v533[3];
            }
            else
            {
              float v535 = a3[1];
              float64x2_t v536 = vsubq_f64(*(float64x2_t *)v535[1].i8, *(float64x2_t *)(v530 + 600));
              float64x2_t v537 = vmulq_f64(v536, v536);
              double v534 = v537.f64[0]
                   + (*(double *)v535 - *(double *)(v530 + 592)) * (*(double *)v535 - *(double *)(v530 + 592))
                   + v537.f64[1];
              *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v532, v530, &v561)+ 3) = v534;
            }
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v532, v531);
            if (result)
            {
              double v538 = result[3];
            }
            else
            {
              float v539 = a3[1];
              float64x2_t v540 = vsubq_f64(*(float64x2_t *)v539[1].i8, *(float64x2_t *)(v531 + 600));
              float64x2_t v541 = vmulq_f64(v540, v540);
              double v538 = v541.f64[0]
                   + (*(double *)v539 - *(double *)(v531 + 592)) * (*(double *)v539 - *(double *)(v531 + 592))
                   + v541.f64[1];
              uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v532, v531, &v560);
              result[3] = v538;
            }
            if (v534 < v538) {
              *unint64_t v10 = vextq_s8(*v10, *v10, 8uLL);
            }
          }
          break;
        case 5:
          return std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)v10, &v10->u64[1], (unint64_t *)&v10[1], &v10[1].u64[1], v544, a3);
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 191) {
      break;
    }
    if (!a4)
    {
      if (v10 != a2)
      {
        uint64_t v543 = (char *)v9 - (char *)v10;
        int64_t v316 = (unint64_t)(v13 - 2) >> 1;
        int64_t v555 = v316;
        uint64_t v546 = ((char *)v9 - (char *)v10) >> 3;
        do
        {
          int64_t v317 = v316;
          if (v555 >= v316)
          {
            uint64_t v318 = (2 * v316) | 1;
            BOOL v319 = (unint64_t *)v11 + v318;
            uint64_t v320 = *a3;
            if (2 * v317 + 2 < v13)
            {
              unint64_t v321 = *v319;
              uint64_t v322 = (unint64_t *)v11 + v318;
              uint64_t v323 = v319 + 1;
              unint64_t v324 = v319[1];
              unint64_t v560 = v324;
              unint64_t v561 = v321;
              double v325 = (float *)&v320[10];
              double v326 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(&v320[10], v321);
              if (v326)
              {
                double v327 = v326[3];
              }
              else
              {
                unint64_t v328 = a3[1];
                float64x2_t v329 = vsubq_f64(*(float64x2_t *)v328[1].i8, *(float64x2_t *)(v321 + 600));
                float64x2_t v330 = vmulq_f64(v329, v329);
                double v327 = v330.f64[0]
                     + (*(double *)v328 - *(double *)(v321 + 592)) * (*(double *)v328 - *(double *)(v321 + 592))
                     + v330.f64[1];
                *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v325, v321, &v561)+ 3) = v327;
              }
              double v331 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v325, v324);
              if (v331)
              {
                double v332 = v331[3];
              }
              else
              {
                unint64_t v333 = a3[1];
                float64x2_t v334 = vsubq_f64(*(float64x2_t *)v333[1].i8, *(float64x2_t *)(v324 + 600));
                float64x2_t v335 = vmulq_f64(v334, v334);
                double v332 = v335.f64[0]
                     + (*(double *)v333 - *(double *)(v324 + 592)) * (*(double *)v333 - *(double *)(v324 + 592))
                     + v335.f64[1];
                *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v325, v324, &v560)+ 3) = v332;
              }
              uint64_t v11 = v558;
              if (v327 >= v332) {
                BOOL v319 = v322;
              }
              else {
                BOOL v319 = v323;
              }
              if (v327 < v332) {
                uint64_t v318 = 2 * v317 + 2;
              }
              uint64_t v320 = *a3;
            }
            unint64_t v336 = (unint64_t *)v11 + v317;
            uint64_t v337 = v319;
            unint64_t v338 = *v319;
            unint64_t v339 = *v336;
            unint64_t v560 = *v336;
            unint64_t v561 = v338;
            double v340 = (float *)&v320[10];
            float32x2_t v341 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(&v320[10], v338);
            if (v341)
            {
              double v342 = v341[3];
              unint64_t v343 = v339;
            }
            else
            {
              float32x4_t v344 = a3[1];
              float64x2_t v345 = vsubq_f64(*(float64x2_t *)v344[1].i8, *(float64x2_t *)(v338 + 600));
              float64x2_t v346 = vmulq_f64(v345, v345);
              double v342 = v346.f64[0]
                   + (*(double *)v344 - *(double *)(v338 + 592)) * (*(double *)v344 - *(double *)(v338 + 592))
                   + v346.f64[1];
              *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v340, v338, &v561)+ 3) = v342;
              unint64_t v343 = v560;
            }
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v340, v343);
            if (result)
            {
              double v347 = result[3];
            }
            else
            {
              double v348 = a3[1];
              float64x2_t v349 = vsubq_f64(*(float64x2_t *)v348[1].i8, *(float64x2_t *)(v339 + 600));
              float64x2_t v350 = vmulq_f64(v349, v349);
              double v347 = v350.f64[0]
                   + (*(double *)v348 - *(double *)(v339 + 592)) * (*(double *)v348 - *(double *)(v339 + 592))
                   + v350.f64[1];
              uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v340, v343, &v560);
              result[3] = v347;
            }
            uint64_t v11 = v558;
            uint64_t v13 = v546;
            if (v342 >= v347)
            {
              int64_t v545 = v317;
              unint64_t v351 = *v336;
              double v548 = (float64x2_t *)(*v336 + 600);
              do
              {
                uint64_t v356 = v337;
                *unint64_t v336 = *v337;
                if (v555 < v318) {
                  break;
                }
                uint64_t v357 = (2 * v318) | 1;
                BOOL v358 = (unint64_t *)v11 + v357;
                uint64_t v318 = 2 * v318 + 2;
                uint64_t v359 = *a3;
                if (v318 >= v13)
                {
                  uint64_t v318 = v357;
                }
                else
                {
                  unint64_t v360 = *v358;
                  float32x4_t v551 = (unint64_t *)v11 + v357;
                  uint64_t v361 = v358 + 1;
                  unint64_t v362 = v358[1];
                  unint64_t v560 = v362;
                  unint64_t v561 = v360;
                  unint64_t v363 = (float *)&v359[10];
                  double v364 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(&v359[10], v360);
                  if (v364)
                  {
                    double v365 = v364[3];
                  }
                  else
                  {
                    unint64_t v366 = a3[1];
                    float64x2_t v367 = vsubq_f64(*(float64x2_t *)v366[1].i8, *(float64x2_t *)(v360 + 600));
                    float64x2_t v368 = vmulq_f64(v367, v367);
                    double v365 = v368.f64[0]
                         + (*(double *)v366 - *(double *)(v360 + 592)) * (*(double *)v366 - *(double *)(v360 + 592))
                         + v368.f64[1];
                    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v363, v360, &v561)+ 3) = v365;
                  }
                  unint64_t v369 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v363, v362);
                  if (v369)
                  {
                    double v370 = v369[3];
                  }
                  else
                  {
                    double v371 = a3[1];
                    float64x2_t v372 = vsubq_f64(*(float64x2_t *)v371[1].i8, *(float64x2_t *)(v362 + 600));
                    float64x2_t v373 = vmulq_f64(v372, v372);
                    double v370 = v373.f64[0]
                         + (*(double *)v371 - *(double *)(v362 + 592)) * (*(double *)v371 - *(double *)(v362 + 592))
                         + v373.f64[1];
                    *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v363, v362, &v560)+ 3) = v370;
                  }
                  BOOL v358 = v551;
                  if (v365 >= v370) {
                    uint64_t v318 = v357;
                  }
                  else {
                    BOOL v358 = v361;
                  }
                  uint64_t v359 = *a3;
                  uint64_t v13 = v546;
                }
                uint64_t v337 = v358;
                unint64_t v374 = *v358;
                unint64_t v560 = v351;
                unint64_t v561 = v374;
                uint64_t v375 = (float *)&v359[10];
                __int16 v376 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(&v359[10], v374);
                if (v376)
                {
                  double v377 = v376[3];
                  unint64_t v378 = v351;
                }
                else
                {
                  uint64_t v379 = a3[1];
                  float64x2_t v380 = vsubq_f64(*(float64x2_t *)v379[1].i8, *(float64x2_t *)(v374 + 600));
                  float64x2_t v381 = vmulq_f64(v380, v380);
                  double v377 = v381.f64[0]
                       + (*(double *)v379 - *(double *)(v374 + 592)) * (*(double *)v379 - *(double *)(v374 + 592))
                       + v381.f64[1];
                  *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v375, v374, &v561)+ 3) = v377;
                  unint64_t v378 = v560;
                }
                uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v375, v378);
                if (result)
                {
                  double v355 = result[3];
                }
                else
                {
                  uint64_t v352 = a3[1];
                  float64x2_t v353 = vsubq_f64(*(float64x2_t *)v352[1].i8, *v548);
                  float64x2_t v354 = vmulq_f64(v353, v353);
                  double v355 = v354.f64[0]
                       + (*(double *)v352 - *(double *)(v351 + 592)) * (*(double *)v352 - *(double *)(v351 + 592))
                       + v354.f64[1];
                  uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v375, v378, &v560);
                  result[3] = v355;
                }
                uint64_t v11 = v558;
                unint64_t v336 = v356;
              }
              while (v377 >= v355);
              *uint64_t v356 = v351;
              int64_t v317 = v545;
            }
          }
          int64_t v316 = v317 - 1;
        }
        while (v317);
        if (v543 >= 9)
        {
          uint64_t v382 = (unint64_t)v543 >> 3;
          do
          {
            uint64_t v384 = 0;
            int64_t v385 = (unint64_t)(v382 - 2) >> 1;
            unint64_t v386 = (unint64_t *)v11;
            uint64_t v556 = v382;
            unint64_t v549 = v11->i64[0];
            int64_t v552 = v385;
            do
            {
              uint64_t v391 = &v386[v384 + 1];
              uint64_t v392 = (2 * v384) | 1;
              uint64_t v393 = 2 * v384 + 2;
              if (v393 < v382)
              {
                unint64_t v394 = v386[v384 + 2];
                unint64_t v395 = *v391;
                unint64_t v560 = v394;
                unint64_t v561 = v395;
                unsigned int v396 = *a3;
                unint64_t v397 = (float *)&(*a3)[10];
                int8x8_t v398 = (*a3)[11];
                if (v398)
                {
                  unint64_t v399 = 0x9DDFEA08EB382D69 * (((8 * v395) + 8) ^ HIDWORD(v395));
                  unint64_t v400 = 0x9DDFEA08EB382D69 * (HIDWORD(v395) ^ (v399 >> 47) ^ v399);
                  unint64_t v401 = 0x9DDFEA08EB382D69 * (v400 ^ (v400 >> 47));
                  uint8x8_t v402 = (uint8x8_t)vcnt_s8(v398);
                  v402.i16[0] = vaddlv_u8(v402);
                  if (v402.u32[0] > 1uLL)
                  {
                    unint64_t v403 = v401;
                    if (v401 >= *(void *)&v398) {
                      unint64_t v403 = v401 % *(void *)&v398;
                    }
                  }
                  else
                  {
                    unint64_t v403 = v401 & (*(void *)&v398 - 1);
                  }
                  BOOL v404 = *(double ***)(*(void *)v397 + 8 * v403);
                  if (v404)
                  {
                    unint64_t v405 = *v404;
                    if (v405)
                    {
                      if (v402.u32[0] < 2uLL)
                      {
                        while (1)
                        {
                          uint64_t v407 = *((void *)v405 + 1);
                          if (v407 == v401)
                          {
                            if (*((void *)v405 + 2) == v395) {
                              goto LABEL_449;
                            }
                          }
                          else if ((v407 & (*(void *)&v398 - 1)) != v403)
                          {
                            goto LABEL_428;
                          }
                          unint64_t v405 = *(double **)v405;
                          if (!v405) {
                            goto LABEL_428;
                          }
                        }
                      }
                      do
                      {
                        unint64_t v406 = *((void *)v405 + 1);
                        if (v406 == v401)
                        {
                          if (*((void *)v405 + 2) == v395)
                          {
LABEL_449:
                            double v411 = v405[3];
                            goto LABEL_429;
                          }
                        }
                        else
                        {
                          if (v406 >= *(void *)&v398) {
                            v406 %= *(void *)&v398;
                          }
                          if (v406 != v403) {
                            break;
                          }
                        }
                        unint64_t v405 = *(double **)v405;
                      }
                      while (v405);
                    }
                  }
                }
LABEL_428:
                long long v408 = a3[1];
                float64x2_t v409 = vsubq_f64(*(float64x2_t *)v408[1].i8, *(float64x2_t *)(v395 + 600));
                float64x2_t v410 = vmulq_f64(v409, v409);
                double v411 = v410.f64[0]
                     + (*(double *)v408 - *(double *)(v395 + 592)) * (*(double *)v408 - *(double *)(v395 + 592))
                     + v410.f64[1];
                uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>((float *)&(*a3)[10], v395, &v561);
                result[3] = v411;
                int8x8_t v398 = v396[11];
                if (v398)
                {
LABEL_429:
                  unint64_t v412 = 0x9DDFEA08EB382D69 * (((8 * v394) + 8) ^ HIDWORD(v394));
                  unint64_t v413 = 0x9DDFEA08EB382D69 * (HIDWORD(v394) ^ (v412 >> 47) ^ v412);
                  unint64_t v414 = 0x9DDFEA08EB382D69 * (v413 ^ (v413 >> 47));
                  uint8x8_t v415 = (uint8x8_t)vcnt_s8(v398);
                  v415.i16[0] = vaddlv_u8(v415);
                  if (v415.u32[0] > 1uLL)
                  {
                    unint64_t v416 = v414;
                    if (v414 >= *(void *)&v398) {
                      unint64_t v416 = v414 % *(void *)&v398;
                    }
                  }
                  else
                  {
                    unint64_t v416 = v414 & (*(void *)&v398 - 1);
                  }
                  int v417 = *(double ***)(*(void *)v397 + 8 * v416);
                  if (v417)
                  {
                    uint64_t v418 = *v417;
                    if (v418)
                    {
                      if (v415.u32[0] < 2uLL)
                      {
                        uint64_t v419 = *(void *)&v398 - 1;
                        while (1)
                        {
                          uint64_t v421 = *((void *)v418 + 1);
                          if (v421 == v414)
                          {
                            if (*((void *)v418 + 2) == v394) {
                              goto LABEL_450;
                            }
                          }
                          else if ((v421 & v419) != v416)
                          {
                            goto LABEL_403;
                          }
                          uint64_t v418 = *(double **)v418;
                          if (!v418) {
                            goto LABEL_403;
                          }
                        }
                      }
                      do
                      {
                        unint64_t v420 = *((void *)v418 + 1);
                        if (v420 == v414)
                        {
                          if (*((void *)v418 + 2) == v394)
                          {
LABEL_450:
                            double v390 = v418[3];
                            goto LABEL_404;
                          }
                        }
                        else
                        {
                          if (v420 >= *(void *)&v398) {
                            v420 %= *(void *)&v398;
                          }
                          if (v420 != v416) {
                            break;
                          }
                        }
                        uint64_t v418 = *(double **)v418;
                      }
                      while (v418);
                    }
                  }
                }
LABEL_403:
                uint64_t v387 = a3[1];
                float64x2_t v388 = vsubq_f64(*(float64x2_t *)v387[1].i8, *(float64x2_t *)(v394 + 600));
                float64x2_t v389 = vmulq_f64(v388, v388);
                double v390 = v389.f64[0]
                     + (*(double *)v387 - *(double *)(v394 + 592)) * (*(double *)v387 - *(double *)(v394 + 592))
                     + v389.f64[1];
                uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v397, v394, &v560);
                result[3] = v390;
LABEL_404:
                uint64_t v11 = v558;
                int64_t v385 = v552;
                uint64_t v382 = v556;
                if (v411 < v390)
                {
                  ++v391;
                  uint64_t v392 = v393;
                }
              }
              unint64_t *v386 = *v391;
              unint64_t v386 = v391;
              uint64_t v384 = v392;
            }
            while (v392 <= v385);
            int v422 = &a2[-1].u64[1];
            BOOL v6 = v391 == &a2[-1].u64[1];
            a2 = (int8x16_t *)((char *)a2 - 8);
            if (v6)
            {
              unint64_t *v391 = v549;
            }
            else
            {
              unint64_t *v391 = *v422;
              *int v422 = v549;
              uint64_t v423 = (char *)v391 - (char *)v11 + 8;
              if (v423 >= 9)
              {
                unint64_t v424 = (((unint64_t)v423 >> 3) - 2) >> 1;
                unint64_t v425 = (unint64_t *)v11 + v424;
                unint64_t v426 = *v425;
                unint64_t v427 = *v391;
                unint64_t v560 = *v391;
                unint64_t v561 = v426;
                float v428 = (float *)&(*a3)[10];
                BOOL v429 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v428, v426);
                if (v429)
                {
                  double v430 = v429[3];
                }
                else
                {
                  unint64_t v431 = a3[1];
                  float64x2_t v432 = vsubq_f64(*(float64x2_t *)v431[1].i8, *(float64x2_t *)(v426 + 600));
                  float64x2_t v433 = vmulq_f64(v432, v432);
                  double v430 = v433.f64[0]
                       + (*(double *)v431 - *(double *)(v426 + 592)) * (*(double *)v431 - *(double *)(v426 + 592))
                       + v433.f64[1];
                  *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v428, v426, &v561)+ 3) = v430;
                }
                uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v428, v427);
                if (result)
                {
                  double v434 = result[3];
                }
                else
                {
                  uint64_t v435 = a3[1];
                  float64x2_t v436 = vsubq_f64(*(float64x2_t *)v435[1].i8, *(float64x2_t *)(v427 + 600));
                  float64x2_t v437 = vmulq_f64(v436, v436);
                  double v434 = v437.f64[0]
                       + (*(double *)v435 - *(double *)(v427 + 592)) * (*(double *)v435 - *(double *)(v427 + 592))
                       + v437.f64[1];
                  uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v428, v427, &v560);
                  result[3] = v434;
                }
                uint64_t v11 = v558;
                uint64_t v382 = v556;
                if (v430 < v434)
                {
                  unint64_t v438 = *v391;
                  size_t v439 = (float64x2_t *)(*v391 + 600);
                  do
                  {
                    unint64_t v444 = v425;
                    unint64_t *v391 = *v425;
                    if (!v424) {
                      break;
                    }
                    unint64_t v424 = (v424 - 1) >> 1;
                    unint64_t v425 = (unint64_t *)v11 + v424;
                    unint64_t v445 = *v425;
                    unint64_t v560 = v438;
                    unint64_t v561 = v445;
                    unint64_t v446 = (float *)&(*a3)[10];
                    uint64_t v447 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v446, v445);
                    if (v447)
                    {
                      double v448 = v447[3];
                    }
                    else
                    {
                      uint64_t v449 = a3[1];
                      float64x2_t v450 = vsubq_f64(*(float64x2_t *)v449[1].i8, *(float64x2_t *)(v445 + 600));
                      float64x2_t v451 = vmulq_f64(v450, v450);
                      double v448 = v451.f64[0]
                           + (*(double *)v449 - *(double *)(v445 + 592)) * (*(double *)v449 - *(double *)(v445 + 592))
                           + v451.f64[1];
                      *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v446, v445, &v561)+ 3) = v448;
                    }
                    uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v446, v438);
                    if (result)
                    {
                      double v443 = result[3];
                    }
                    else
                    {
                      uint64_t v440 = a3[1];
                      float64x2_t v441 = vsubq_f64(*(float64x2_t *)v440[1].i8, *v439);
                      float64x2_t v442 = vmulq_f64(v441, v441);
                      double v443 = v442.f64[0]
                           + (*(double *)v440 - *(double *)(v438 + 592)) * (*(double *)v440 - *(double *)(v438 + 592))
                           + v442.f64[1];
                      uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v446, v438, &v560);
                      result[3] = v443;
                    }
                    uint64_t v11 = v558;
                    uint64_t v391 = v444;
                  }
                  while (v448 < v443);
                  unint64_t *v444 = v438;
                  uint64_t v382 = v556;
                }
              }
            }
          }
          while (v382-- > 2);
        }
      }
      return result;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    long long v15 = (unint64_t *)v10 + v14;
    if ((unint64_t)v12 < 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)v10 + v14, (unint64_t *)v10, v544, a3);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)v10, (unint64_t *)v10 + v14, v544, a3);
      uint64_t v16 = v14;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>(&v10->u64[1], &v10->u64[v16 - 1], (unint64_t *)&a2[-1], a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)&v10[1], &v10->u64[v16 + 1], &a2[-2].u64[1], a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>(&v10->u64[v16 - 1], v15, &v10->u64[v16 + 1], a3);
      uint64_t v17 = v10->i64[0];
      v10->i64[0] = v10->i64[v16];
      v10->i64[v16] = v17;
      uint64_t v11 = v10;
    }
    unint64_t v18 = v11->i64[0];
    --a4;
    if (a5) {
      goto LABEL_18;
    }
    unint64_t v19 = v11[-1].u64[1];
    unint64_t v560 = v11->i64[0];
    unint64_t v561 = v19;
    uint64_t v20 = (float *)&(*a3)[10];
    __double2 v21 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v20, v19);
    if (v21)
    {
      double v22 = v21[3];
    }
    else
    {
      int8x8_t v23 = a3[1];
      float64x2_t v24 = vsubq_f64(*(float64x2_t *)v23[1].i8, *(float64x2_t *)(v19 + 600));
      float64x2_t v25 = vmulq_f64(v24, v24);
      double v22 = v25.f64[0]
          + (*(double *)v23 - *(double *)(v19 + 592)) * (*(double *)v23 - *(double *)(v19 + 592))
          + v25.f64[1];
      *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v20, v19, &v561)+ 3) = v22;
    }
    int8x8_t v26 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v20, v18);
    if (v26)
    {
      double v27 = v26[3];
    }
    else
    {
      long long v28 = a3[1];
      float64x2_t v29 = vsubq_f64(*(float64x2_t *)v28[1].i8, *(float64x2_t *)(v18 + 600));
      float64x2_t v30 = vmulq_f64(v29, v29);
      double v27 = v30.f64[0]
          + (*(double *)v28 - *(double *)(v18 + 592)) * (*(double *)v28 - *(double *)(v18 + 592))
          + v30.f64[1];
      *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v20, v18, &v560)+ 3) = v27;
    }
    unint64_t v18 = v11->i64[0];
    if (v22 < v27)
    {
LABEL_18:
      float v31 = (float64x2_t *)(v18 + 600);
      float64_t v32 = v558;
      do
      {
        while (1)
        {
          unint64_t v38 = v32->u64[1];
          float64_t v32 = (int8x16_t *)((char *)v32 + 8);
          unint64_t v37 = v38;
          unint64_t v560 = v18;
          unint64_t v561 = v38;
          uint64_t v39 = (float *)&(*a3)[10];
          uint64_t v40 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v39, v38);
          if (v40)
          {
            double v41 = v40[3];
          }
          else
          {
            unint64_t v42 = a3[1];
            float64x2_t v43 = vsubq_f64(*(float64x2_t *)v42[1].i8, *(float64x2_t *)(v37 + 600));
            float64x2_t v44 = vmulq_f64(v43, v43);
            double v41 = v44.f64[0]
                + (*(double *)v42 - *(double *)(v37 + 592)) * (*(double *)v42 - *(double *)(v37 + 592))
                + v44.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v39, v37, &v561)+ 3) = v41;
          }
          long long v45 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v39, v18);
          if (v45) {
            break;
          }
          char v33 = a3[1];
          float64x2_t v34 = vsubq_f64(*(float64x2_t *)v33[1].i8, *v31);
          float64x2_t v35 = vmulq_f64(v34, v34);
          double v36 = v35.f64[0]
              + (*(double *)v33 - *(double *)(v18 + 592)) * (*(double *)v33 - *(double *)(v18 + 592))
              + v35.f64[1];
          *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v39, v18, &v560)+ 3) = v36;
          if (v41 >= v36) {
            goto LABEL_25;
          }
        }
      }
      while (v41 < v45[3]);
LABEL_25:
      int v46 = (int8x16_t *)((char *)v32 - 8);
      double v47 = a2;
      if (&v32[-1].u64[1] == (unint64_t *)v558)
      {
        double v47 = a2;
        do
        {
          if (v32 >= v47) {
            break;
          }
          unint64_t v130 = v47[-1].u64[1];
          double v47 = (int8x16_t *)((char *)v47 - 8);
          unint64_t v129 = v130;
          unint64_t v560 = v18;
          unint64_t v561 = v130;
          uint64_t v131 = (float *)&(*a3)[10];
          uint64_t v132 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v131, v130);
          if (v132)
          {
            double v133 = v132[3];
          }
          else
          {
            unsigned int v134 = a3[1];
            float64x2_t v135 = vsubq_f64(*(float64x2_t *)v134[1].i8, *(float64x2_t *)(v129 + 600));
            float64x2_t v136 = vmulq_f64(v135, v135);
            double v133 = v136.f64[0]
                 + (*(double *)v134 - *(double *)(v129 + 592)) * (*(double *)v134 - *(double *)(v129 + 592))
                 + v136.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v131, v129, &v561)+ 3) = v133;
          }
          uint64_t v137 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v131, v18);
          if (v137)
          {
            double v128 = v137[3];
          }
          else
          {
            __n128 v125 = a3[1];
            float64x2_t v126 = vsubq_f64(*(float64x2_t *)v125[1].i8, *v31);
            float64x2_t v127 = vmulq_f64(v126, v126);
            double v128 = v127.f64[0]
                 + (*(double *)v125 - *(double *)(v18 + 592)) * (*(double *)v125 - *(double *)(v18 + 592))
                 + v127.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v131, v18, &v560)+ 3) = v128;
          }
        }
        while (v133 >= v128);
      }
      else
      {
        do
        {
          while (1)
          {
            unint64_t v49 = v47[-1].u64[1];
            double v47 = (int8x16_t *)((char *)v47 - 8);
            unint64_t v48 = v49;
            unint64_t v560 = v18;
            unint64_t v561 = v49;
            __n128 v50 = (float *)&(*a3)[10];
            long long v51 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v50, v49);
            if (v51)
            {
              double v52 = v51[3];
            }
            else
            {
              long long v53 = a3[1];
              float64x2_t v54 = vsubq_f64(*(float64x2_t *)v53[1].i8, *(float64x2_t *)(v48 + 600));
              float64x2_t v55 = vmulq_f64(v54, v54);
              double v52 = v55.f64[0]
                  + (*(double *)v53 - *(double *)(v48 + 592)) * (*(double *)v53 - *(double *)(v48 + 592))
                  + v55.f64[1];
              *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v50, v48, &v561)+ 3) = v52;
            }
            char v56 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v50, v18);
            if (!v56) {
              break;
            }
            if (v52 < v56[3]) {
              goto LABEL_33;
            }
          }
          uint64_t v57 = a3[1];
          float64x2_t v58 = vsubq_f64(*(float64x2_t *)v57[1].i8, *v31);
          float64x2_t v59 = vmulq_f64(v58, v58);
          double v60 = v59.f64[0]
              + (*(double *)v57 - *(double *)(v18 + 592)) * (*(double *)v57 - *(double *)(v18 + 592))
              + v59.f64[1];
          *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v50, v18, &v560)+ 3) = v60;
        }
        while (v52 >= v60);
      }
LABEL_33:
      uint64_t v550 = v47;
      double v553 = v32;
      if (v32 < v47)
      {
        unint64_t v61 = 0x9DDFEA08EB382D69 * (((8 * v18) + 8) ^ HIDWORD(v18));
        unint64_t v62 = 0x9DDFEA08EB382D69 * (HIDWORD(v18) ^ (v61 >> 47) ^ v61);
        unint64_t v63 = 0x9DDFEA08EB382D69 * (v62 ^ (v62 >> 47));
        uint64_t v65 = (uint64_t *)v47;
        uint64_t v64 = (uint64_t *)v32;
        do
        {
          uint64_t v66 = *v64;
          *uint64_t v64 = *v65;
          *uint64_t v65 = v66;
          do
          {
            while (1)
            {
              int v46 = (int8x16_t *)v64;
              unint64_t v68 = v64[1];
              ++v64;
              unint64_t v67 = v68;
              unint64_t v560 = v18;
              unint64_t v561 = v68;
              uint64_t v69 = *a3;
              char v70 = (float *)&(*a3)[10];
              int8x8_t v71 = (*a3)[11];
              if (!*(void *)&v71) {
                goto LABEL_57;
              }
              unint64_t v72 = 0x9DDFEA08EB382D69 * (((8 * v67) + 8) ^ HIDWORD(v67));
              unint64_t v73 = 0x9DDFEA08EB382D69 * (HIDWORD(v67) ^ (v72 >> 47) ^ v72);
              unint64_t v74 = 0x9DDFEA08EB382D69 * (v73 ^ (v73 >> 47));
              uint8x8_t v75 = (uint8x8_t)vcnt_s8(v71);
              v75.i16[0] = vaddlv_u8(v75);
              if (v75.u32[0] > 1uLL)
              {
                unint64_t v76 = v74;
                if (v74 >= *(void *)&v71) {
                  unint64_t v76 = v74 % *(void *)&v71;
                }
              }
              else
              {
                unint64_t v76 = v74 & (*(void *)&v71 - 1);
              }
              uint64_t v77 = *(double ***)(*(void *)v70 + 8 * v76);
              if (!v77 || (char v78 = *v77) == 0)
              {
LABEL_57:
                uint64_t v81 = a3[1];
                float64x2_t v82 = vsubq_f64(*(float64x2_t *)v81[1].i8, *(float64x2_t *)(v67 + 600));
                float64x2_t v83 = vmulq_f64(v82, v82);
                double v84 = v83.f64[0]
                    + (*(double *)v81 - *(double *)(v67 + 592)) * (*(double *)v81 - *(double *)(v67 + 592))
                    + v83.f64[1];
                *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>((float *)&(*a3)[10], v67, &v561)+ 3) = v84;
                int8x8_t v71 = v69[11];
                if (v71) {
                  goto LABEL_58;
                }
                goto LABEL_79;
              }
              if (v75.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v80 = *((void *)v78 + 1);
                  if (v80 == v74)
                  {
                    if (*((void *)v78 + 2) == v67) {
                      goto LABEL_78;
                    }
                  }
                  else if ((v80 & (*(void *)&v71 - 1)) != v76)
                  {
                    goto LABEL_57;
                  }
                  char v78 = *(double **)v78;
                  if (!v78) {
                    goto LABEL_57;
                  }
                }
              }
              while (1)
              {
                unint64_t v79 = *((void *)v78 + 1);
                if (v79 == v74) {
                  break;
                }
                if (v79 >= *(void *)&v71) {
                  v79 %= *(void *)&v71;
                }
                if (v79 != v76) {
                  goto LABEL_57;
                }
LABEL_47:
                char v78 = *(double **)v78;
                if (!v78) {
                  goto LABEL_57;
                }
              }
              if (*((void *)v78 + 2) != v67) {
                goto LABEL_47;
              }
LABEL_78:
              double v84 = v78[3];
LABEL_58:
              uint8x8_t v85 = (uint8x8_t)vcnt_s8(v71);
              v85.i16[0] = vaddlv_u8(v85);
              if (v85.u32[0] > 1uLL)
              {
                unint64_t v86 = v63;
                if (v63 >= *(void *)&v71) {
                  unint64_t v86 = v63 % *(void *)&v71;
                }
              }
              else
              {
                unint64_t v86 = v63 & (*(void *)&v71 - 1);
              }
              uint64_t v87 = *(double ***)(*(void *)v70 + 8 * v86);
              if (v87)
              {
                char v88 = *v87;
                if (v88) {
                  break;
                }
              }
LABEL_79:
              char v92 = a3[1];
              float64x2_t v93 = vsubq_f64(*(float64x2_t *)v92[1].i8, *v31);
              float64x2_t v94 = vmulq_f64(v93, v93);
              double v95 = v94.f64[0]
                  + (*(double *)v92 - *(double *)(v18 + 592)) * (*(double *)v92 - *(double *)(v18 + 592))
                  + v94.f64[1];
              *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v70, v18, &v560)+ 3) = v95;
              if (v84 >= v95) {
                goto LABEL_82;
              }
            }
            if (v85.u32[0] < 2uLL)
            {
              uint64_t v89 = *(void *)&v71 - 1;
              while (1)
              {
                uint64_t v91 = *((void *)v88 + 1);
                if (v91 == v63)
                {
                  if (*((void *)v88 + 2) == v18) {
                    goto LABEL_81;
                  }
                }
                else if ((v91 & v89) != v86)
                {
                  goto LABEL_79;
                }
                char v88 = *(double **)v88;
                if (!v88) {
                  goto LABEL_79;
                }
              }
            }
            while (1)
            {
              unint64_t v90 = *((void *)v88 + 1);
              if (v90 == v63) {
                break;
              }
              if (v90 >= *(void *)&v71) {
                v90 %= *(void *)&v71;
              }
              if (v90 != v86) {
                goto LABEL_79;
              }
LABEL_67:
              char v88 = *(double **)v88;
              if (!v88) {
                goto LABEL_79;
              }
            }
            if (*((void *)v88 + 2) != v18) {
              goto LABEL_67;
            }
LABEL_81:
            ;
          }
          while (v84 < v88[3]);
LABEL_82:
          while (2)
          {
            while (1)
            {
              unint64_t v97 = *--v65;
              unint64_t v96 = v97;
              unint64_t v560 = v18;
              unint64_t v561 = v97;
              char v98 = *a3;
              uint64_t v99 = (float *)&(*a3)[10];
              int8x8_t v100 = (*a3)[11];
              if (v100)
              {
                unint64_t v101 = 0x9DDFEA08EB382D69 * (((8 * v96) + 8) ^ HIDWORD(v96));
                unint64_t v102 = 0x9DDFEA08EB382D69 * (HIDWORD(v96) ^ (v101 >> 47) ^ v101);
                unint64_t v103 = 0x9DDFEA08EB382D69 * (v102 ^ (v102 >> 47));
                uint8x8_t v104 = (uint8x8_t)vcnt_s8(v100);
                v104.i16[0] = vaddlv_u8(v104);
                if (v104.u32[0] > 1uLL)
                {
                  unint64_t v105 = v103;
                  if (v103 >= *(void *)&v100) {
                    unint64_t v105 = v103 % *(void *)&v100;
                  }
                }
                else
                {
                  unint64_t v105 = v103 & (*(void *)&v100 - 1);
                }
                __n128 v106 = *(double ***)(*(void *)v99 + 8 * v105);
                if (v106)
                {
                  __n128 v107 = *v106;
                  if (v107) {
                    break;
                  }
                }
              }
LABEL_102:
              __n128 v110 = a3[1];
              float64x2_t v111 = vsubq_f64(*(float64x2_t *)v110[1].i8, *(float64x2_t *)(v96 + 600));
              float64x2_t v112 = vmulq_f64(v111, v111);
              double v113 = v112.f64[0]
                   + (*(double *)v110 - *(double *)(v96 + 592)) * (*(double *)v110 - *(double *)(v96 + 592))
                   + v112.f64[1];
              *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>((float *)&(*a3)[10], v96, &v561)+ 3) = v113;
              int8x8_t v100 = v98[11];
              if (v100) {
                goto LABEL_103;
              }
LABEL_124:
              __n128 v121 = a3[1];
              float64x2_t v122 = vsubq_f64(*(float64x2_t *)v121[1].i8, *v31);
              float64x2_t v123 = vmulq_f64(v122, v122);
              double v124 = v123.f64[0]
                   + (*(double *)v121 - *(double *)(v18 + 592)) * (*(double *)v121 - *(double *)(v18 + 592))
                   + v123.f64[1];
              *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v99, v18, &v560)+ 3) = v124;
              if (v113 < v124) {
                goto LABEL_35;
              }
            }
            if (v104.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v109 = *((void *)v107 + 1);
                if (v109 == v103)
                {
                  if (*((void *)v107 + 2) == v96) {
                    goto LABEL_123;
                  }
                }
                else if ((v109 & (*(void *)&v100 - 1)) != v105)
                {
                  goto LABEL_102;
                }
                __n128 v107 = *(double **)v107;
                if (!v107) {
                  goto LABEL_102;
                }
              }
            }
            while (2)
            {
              unint64_t v108 = *((void *)v107 + 1);
              if (v108 != v103)
              {
                if (v108 >= *(void *)&v100) {
                  v108 %= *(void *)&v100;
                }
                if (v108 != v105) {
                  goto LABEL_102;
                }
                goto LABEL_92;
              }
              if (*((void *)v107 + 2) != v96)
              {
LABEL_92:
                __n128 v107 = *(double **)v107;
                if (!v107) {
                  goto LABEL_102;
                }
                continue;
              }
              break;
            }
LABEL_123:
            double v113 = v107[3];
LABEL_103:
            uint8x8_t v114 = (uint8x8_t)vcnt_s8(v100);
            v114.i16[0] = vaddlv_u8(v114);
            if (v114.u32[0] > 1uLL)
            {
              unint64_t v115 = v63;
              if (v63 >= *(void *)&v100) {
                unint64_t v115 = v63 % *(void *)&v100;
              }
            }
            else
            {
              unint64_t v115 = v63 & (*(void *)&v100 - 1);
            }
            __n128 v116 = *(double ***)(*(void *)v99 + 8 * v115);
            if (!v116) {
              goto LABEL_124;
            }
            __n128 v117 = *v116;
            if (!v117) {
              goto LABEL_124;
            }
            if (v114.u32[0] < 2uLL)
            {
              uint64_t v118 = *(void *)&v100 - 1;
              while (1)
              {
                uint64_t v120 = *((void *)v117 + 1);
                if (v120 == v63)
                {
                  if (*((void *)v117 + 2) == v18) {
                    goto LABEL_126;
                  }
                }
                else if ((v120 & v118) != v115)
                {
                  goto LABEL_124;
                }
                __n128 v117 = *(double **)v117;
                if (!v117) {
                  goto LABEL_124;
                }
              }
            }
            while (2)
            {
              unint64_t v119 = *((void *)v117 + 1);
              if (v119 != v63)
              {
                if (v119 >= *(void *)&v100) {
                  v119 %= *(void *)&v100;
                }
                if (v119 != v115) {
                  goto LABEL_124;
                }
                goto LABEL_112;
              }
              if (*((void *)v117 + 2) != v18)
              {
LABEL_112:
                __n128 v117 = *(double **)v117;
                if (!v117) {
                  goto LABEL_124;
                }
                continue;
              }
              break;
            }
LABEL_126:
            if (v113 >= v117[3]) {
              continue;
            }
            break;
          }
LABEL_35:
          ;
        }
        while (v64 < v65);
      }
      uint64_t v8 = v558;
      if (v46 != v558) {
        v558->i64[0] = v46->i64[0];
      }
      v46->i64[0] = v18;
      unint64_t v9 = a2;
      if (v553 < v550)
      {
LABEL_141:
        uint64_t result = (double *)std::__introsort<std::_ClassicAlgPolicy,ARStorefrontLabelFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**,false>(v558, v46, a3, a4, a5 & 1);
        a5 = 0;
        unint64_t v10 = (int8x16_t *)&v46->u64[1];
      }
      else
      {
        BOOL v138 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,ARStorefrontLabelFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>(v558, v46, a3);
        unint64_t v10 = (int8x16_t *)&v46->u64[1];
        uint64_t result = (double *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,ARStorefrontLabelFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((int8x16_t *)&v46->u64[1], a2, a3);
        if (result)
        {
          a2 = v46;
          if (v138) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v138) {
          goto LABEL_141;
        }
      }
    }
    else
    {
      unint64_t v139 = *v544;
      unint64_t v560 = *v544;
      unint64_t v561 = v18;
      uint64_t v140 = (float *)&(*a3)[10];
      uint64_t v141 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v140, v18);
      if (v141)
      {
        double v142 = v141[3];
      }
      else
      {
        uint64_t v143 = a3[1];
        float64x2_t v144 = vsubq_f64(*(float64x2_t *)v143[1].i8, *(float64x2_t *)(v18 + 600));
        float64x2_t v145 = vmulq_f64(v144, v144);
        double v142 = v145.f64[0]
             + (*(double *)v143 - *(double *)(v18 + 592)) * (*(double *)v143 - *(double *)(v18 + 592))
             + v145.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v140, v18, &v561)+ 3) = v142;
      }
      uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v140, v139);
      if (result)
      {
        double v146 = result[3];
      }
      else
      {
        double v147 = a3[1];
        float64x2_t v148 = vsubq_f64(*(float64x2_t *)v147[1].i8, *(float64x2_t *)(v139 + 600));
        float64x2_t v149 = vmulq_f64(v148, v148);
        double v146 = v149.f64[0]
             + (*(double *)v147 - *(double *)(v139 + 592)) * (*(double *)v147 - *(double *)(v139 + 592))
             + v149.f64[1];
        uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v140, v139, &v560);
        result[3] = v146;
      }
      float32x2_t v150 = (float64x2_t *)(v18 + 600);
      if (v142 >= v146)
      {
        unint64_t v164 = &v11->u64[1];
        float32x4_t v151 = a2;
        do
        {
          unint64_t v10 = (int8x16_t *)v164;
          if (v164 >= (unint64_t *)a2) {
            break;
          }
          unint64_t v169 = *v164;
          unint64_t v560 = *v164;
          unint64_t v561 = v18;
          uint64_t v170 = (float *)&(*a3)[10];
          uint64_t v171 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v170, v18);
          if (v171)
          {
            double v172 = v171[3];
          }
          else
          {
            uint64_t v173 = a3[1];
            float64x2_t v174 = vsubq_f64(*(float64x2_t *)v173[1].i8, *v150);
            float64x2_t v175 = vmulq_f64(v174, v174);
            double v172 = v175.f64[0]
                 + (*(double *)v173 - *(double *)(v18 + 592)) * (*(double *)v173 - *(double *)(v18 + 592))
                 + v175.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v170, v18, &v561)+ 3) = v172;
          }
          uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v170, v169);
          if (result)
          {
            double v168 = result[3];
          }
          else
          {
            uint64_t v165 = a3[1];
            float64x2_t v166 = vsubq_f64(*(float64x2_t *)v165[1].i8, *(float64x2_t *)(v169 + 600));
            float64x2_t v167 = vmulq_f64(v166, v166);
            double v168 = v167.f64[0]
                 + (*(double *)v165 - *(double *)(v169 + 592)) * (*(double *)v165 - *(double *)(v169 + 592))
                 + v167.f64[1];
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v170, v169, &v560);
            result[3] = v168;
          }
          unint64_t v164 = &v10->u64[1];
        }
        while (v172 >= v168);
      }
      else
      {
        unint64_t v10 = v11;
        float32x4_t v151 = a2;
        do
        {
          unint64_t v157 = v10->u64[1];
          unint64_t v10 = (int8x16_t *)((char *)v10 + 8);
          unint64_t v156 = v157;
          unint64_t v560 = v157;
          unint64_t v561 = v18;
          unsigned int v158 = (float *)&(*a3)[10];
          unint64_t v159 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v158, v18);
          if (v159)
          {
            double v160 = v159[3];
          }
          else
          {
            double v161 = a3[1];
            float64x2_t v162 = vsubq_f64(*(float64x2_t *)v161[1].i8, *v150);
            float64x2_t v163 = vmulq_f64(v162, v162);
            double v160 = v163.f64[0]
                 + (*(double *)v161 - *(double *)(v18 + 592)) * (*(double *)v161 - *(double *)(v18 + 592))
                 + v163.f64[1];
            *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v158, v18, &v561)+ 3) = v160;
          }
          uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v158, v156);
          if (result)
          {
            double v155 = result[3];
          }
          else
          {
            float32x4_t v152 = a3[1];
            float64x2_t v153 = vsubq_f64(*(float64x2_t *)v152[1].i8, *(float64x2_t *)(v156 + 600));
            float64x2_t v154 = vmulq_f64(v153, v153);
            double v155 = v154.f64[0]
                 + (*(double *)v152 - *(double *)(v156 + 592)) * (*(double *)v152 - *(double *)(v156 + 592))
                 + v154.f64[1];
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v158, v156, &v560);
            result[3] = v155;
          }
        }
        while (v160 >= v155);
      }
      if (v10 < v151)
      {
        float32x4_t v151 = a2;
        do
        {
          while (1)
          {
            unint64_t v181 = v151[-1].u64[1];
            float32x4_t v151 = (int8x16_t *)((char *)v151 - 8);
            unint64_t v180 = v181;
            unint64_t v560 = v181;
            unint64_t v561 = v18;
            double v182 = (float *)&(*a3)[10];
            double v183 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v182, v18);
            if (v183)
            {
              double v184 = v183[3];
            }
            else
            {
              float32x4_t v185 = a3[1];
              float64x2_t v186 = vsubq_f64(*(float64x2_t *)v185[1].i8, *v150);
              float64x2_t v187 = vmulq_f64(v186, v186);
              double v184 = v187.f64[0]
                   + (*(double *)v185 - *(double *)(v18 + 592)) * (*(double *)v185 - *(double *)(v18 + 592))
                   + v187.f64[1];
              *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v182, v18, &v561)+ 3) = v184;
            }
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v182, v180);
            if (result) {
              break;
            }
            double v176 = a3[1];
            float64x2_t v177 = vsubq_f64(*(float64x2_t *)v176[1].i8, *(float64x2_t *)(v180 + 600));
            float64x2_t v178 = vmulq_f64(v177, v177);
            double v179 = v178.f64[0]
                 + (*(double *)v176 - *(double *)(v180 + 592)) * (*(double *)v176 - *(double *)(v180 + 592))
                 + v178.f64[1];
            uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v182, v180, &v560);
            result[3] = v179;
            if (v184 >= v179) {
              goto LABEL_174;
            }
          }
        }
        while (v184 < result[3]);
      }
LABEL_174:
      if (v10 < v151)
      {
        unint64_t v188 = 0x9DDFEA08EB382D69 * (((8 * v18) + 8) ^ HIDWORD(v18));
        unint64_t v189 = 0x9DDFEA08EB382D69 * (HIDWORD(v18) ^ (v188 >> 47) ^ v188);
        unint64_t v190 = 0x9DDFEA08EB382D69 * (v189 ^ (v189 >> 47));
        do
        {
          uint64_t v191 = v10->i64[0];
          v10->i64[0] = v151->i64[0];
          v151->i64[0] = v191;
          do
          {
            while (1)
            {
              unint64_t v193 = v10->u64[1];
              unint64_t v10 = (int8x16_t *)((char *)v10 + 8);
              unint64_t v192 = v193;
              unint64_t v560 = v193;
              unint64_t v561 = v18;
              uint64_t v194 = *a3;
              double v195 = (float *)&(*a3)[10];
              int8x8_t v196 = (*a3)[11];
              if (!*(void *)&v196) {
                goto LABEL_198;
              }
              uint8x8_t v197 = (uint8x8_t)vcnt_s8(v196);
              v197.i16[0] = vaddlv_u8(v197);
              if (v197.u32[0] > 1uLL)
              {
                unint64_t v198 = v190;
                if (v190 >= *(void *)&v196) {
                  unint64_t v198 = v190 % *(void *)&v196;
                }
              }
              else
              {
                unint64_t v198 = (*(void *)&v196 - 1) & v190;
              }
              double v199 = *(double ***)(*(void *)v195 + 8 * v198);
              if (!v199 || (double v200 = *v199) == 0)
              {
LABEL_198:
                BOOL v203 = a3[1];
                float64x2_t v204 = vsubq_f64(*(float64x2_t *)v203[1].i8, *v150);
                float64x2_t v205 = vmulq_f64(v204, v204);
                double v206 = v205.f64[0]
                     + (*(double *)v203 - *(double *)(v18 + 592)) * (*(double *)v203 - *(double *)(v18 + 592))
                     + v205.f64[1];
                uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>((float *)&(*a3)[10], v18, &v561);
                result[3] = v206;
                int8x8_t v196 = v194[11];
                if (v196) {
                  goto LABEL_199;
                }
                goto LABEL_220;
              }
              if (v197.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v202 = *((void *)v200 + 1);
                  if (v202 == v190)
                  {
                    if (*((void *)v200 + 2) == v18) {
                      goto LABEL_219;
                    }
                  }
                  else if ((v202 & (*(void *)&v196 - 1)) != v198)
                  {
                    goto LABEL_198;
                  }
                  double v200 = *(double **)v200;
                  if (!v200) {
                    goto LABEL_198;
                  }
                }
              }
              while (1)
              {
                unint64_t v201 = *((void *)v200 + 1);
                if (v201 == v190) {
                  break;
                }
                if (v201 >= *(void *)&v196) {
                  v201 %= *(void *)&v196;
                }
                if (v201 != v198) {
                  goto LABEL_198;
                }
LABEL_188:
                double v200 = *(double **)v200;
                if (!v200) {
                  goto LABEL_198;
                }
              }
              if (*((void *)v200 + 2) != v18) {
                goto LABEL_188;
              }
LABEL_219:
              double v206 = v200[3];
LABEL_199:
              unint64_t v207 = 0x9DDFEA08EB382D69 * (((8 * v192) + 8) ^ HIDWORD(v192));
              unint64_t v208 = 0x9DDFEA08EB382D69 * (HIDWORD(v192) ^ (v207 >> 47) ^ v207);
              unint64_t v209 = 0x9DDFEA08EB382D69 * (v208 ^ (v208 >> 47));
              uint8x8_t v210 = (uint8x8_t)vcnt_s8(v196);
              v210.i16[0] = vaddlv_u8(v210);
              if (v210.u32[0] > 1uLL)
              {
                unint64_t v211 = v209;
                if (v209 >= *(void *)&v196) {
                  unint64_t v211 = v209 % *(void *)&v196;
                }
              }
              else
              {
                unint64_t v211 = v209 & (*(void *)&v196 - 1);
              }
              double v212 = *(double ***)(*(void *)v195 + 8 * v211);
              if (v212)
              {
                double v213 = *v212;
                if (v213) {
                  break;
                }
              }
LABEL_220:
              double v217 = a3[1];
              float64x2_t v218 = vsubq_f64(*(float64x2_t *)v217[1].i8, *(float64x2_t *)(v192 + 600));
              float64x2_t v219 = vmulq_f64(v218, v218);
              double v220 = v219.f64[0]
                   + (*(double *)v217 - *(double *)(v192 + 592)) * (*(double *)v217 - *(double *)(v192 + 592))
                   + v219.f64[1];
              uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v195, v192, &v560);
              result[3] = v220;
              if (v206 < v220) {
                goto LABEL_223;
              }
            }
            if (v210.u32[0] < 2uLL)
            {
              uint64_t v214 = *(void *)&v196 - 1;
              while (1)
              {
                uint64_t v216 = *((void *)v213 + 1);
                if (v216 == v209)
                {
                  if (*((void *)v213 + 2) == v192) {
                    goto LABEL_222;
                  }
                }
                else if ((v216 & v214) != v211)
                {
                  goto LABEL_220;
                }
                double v213 = *(double **)v213;
                if (!v213) {
                  goto LABEL_220;
                }
              }
            }
            while (1)
            {
              unint64_t v215 = *((void *)v213 + 1);
              if (v215 == v209) {
                break;
              }
              if (v215 >= *(void *)&v196) {
                v215 %= *(void *)&v196;
              }
              if (v215 != v211) {
                goto LABEL_220;
              }
LABEL_208:
              double v213 = *(double **)v213;
              if (!v213) {
                goto LABEL_220;
              }
            }
            if (*((void *)v213 + 2) != v192) {
              goto LABEL_208;
            }
LABEL_222:
            ;
          }
          while (v206 >= v213[3]);
LABEL_223:
          while (2)
          {
            while (1)
            {
              unint64_t v222 = v151[-1].u64[1];
              float32x4_t v151 = (int8x16_t *)((char *)v151 - 8);
              unint64_t v221 = v222;
              unint64_t v560 = v222;
              unint64_t v561 = v18;
              float64x2_t v223 = *a3;
              uint64_t v224 = (float *)&(*a3)[10];
              int8x8_t v225 = (*a3)[11];
              if (v225)
              {
                uint8x8_t v226 = (uint8x8_t)vcnt_s8(v225);
                v226.i16[0] = vaddlv_u8(v226);
                if (v226.u32[0] > 1uLL)
                {
                  unint64_t v227 = v190;
                  if (v190 >= *(void *)&v225) {
                    unint64_t v227 = v190 % *(void *)&v225;
                  }
                }
                else
                {
                  unint64_t v227 = (*(void *)&v225 - 1) & v190;
                }
                float32x2_t v228 = *(double ***)(*(void *)v224 + 8 * v227);
                if (v228)
                {
                  float32x2_t v229 = *v228;
                  if (v229) {
                    break;
                  }
                }
              }
LABEL_243:
              long long v232 = a3[1];
              float64x2_t v233 = vsubq_f64(*(float64x2_t *)v232[1].i8, *v150);
              float64x2_t v234 = vmulq_f64(v233, v233);
              double v235 = v234.f64[0]
                   + (*(double *)v232 - *(double *)(v18 + 592)) * (*(double *)v232 - *(double *)(v18 + 592))
                   + v234.f64[1];
              uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>((float *)&(*a3)[10], v18, &v561);
              result[3] = v235;
              int8x8_t v225 = v223[11];
              if (v225) {
                goto LABEL_244;
              }
LABEL_265:
              uint64_t v246 = a3[1];
              float64x2_t v247 = vsubq_f64(*(float64x2_t *)v246[1].i8, *(float64x2_t *)(v221 + 600));
              float64x2_t v248 = vmulq_f64(v247, v247);
              double v249 = v248.f64[0]
                   + (*(double *)v246 - *(double *)(v221 + 592)) * (*(double *)v246 - *(double *)(v221 + 592))
                   + v248.f64[1];
              uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v224, v221, &v560);
              result[3] = v249;
              if (v235 >= v249) {
                goto LABEL_176;
              }
            }
            if (v226.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v231 = *((void *)v229 + 1);
                if (v231 == v190)
                {
                  if (*((void *)v229 + 2) == v18) {
                    goto LABEL_264;
                  }
                }
                else if ((v231 & (*(void *)&v225 - 1)) != v227)
                {
                  goto LABEL_243;
                }
                float32x2_t v229 = *(double **)v229;
                if (!v229) {
                  goto LABEL_243;
                }
              }
            }
            while (2)
            {
              unint64_t v230 = *((void *)v229 + 1);
              if (v230 != v190)
              {
                if (v230 >= *(void *)&v225) {
                  v230 %= *(void *)&v225;
                }
                if (v230 != v227) {
                  goto LABEL_243;
                }
                goto LABEL_233;
              }
              if (*((void *)v229 + 2) != v18)
              {
LABEL_233:
                float32x2_t v229 = *(double **)v229;
                if (!v229) {
                  goto LABEL_243;
                }
                continue;
              }
              break;
            }
LABEL_264:
            double v235 = v229[3];
LABEL_244:
            unint64_t v236 = 0x9DDFEA08EB382D69 * (((8 * v221) + 8) ^ HIDWORD(v221));
            unint64_t v237 = 0x9DDFEA08EB382D69 * (HIDWORD(v221) ^ (v236 >> 47) ^ v236);
            unint64_t v238 = 0x9DDFEA08EB382D69 * (v237 ^ (v237 >> 47));
            uint8x8_t v239 = (uint8x8_t)vcnt_s8(v225);
            v239.i16[0] = vaddlv_u8(v239);
            if (v239.u32[0] > 1uLL)
            {
              unint64_t v240 = v238;
              if (v238 >= *(void *)&v225) {
                unint64_t v240 = v238 % *(void *)&v225;
              }
            }
            else
            {
              unint64_t v240 = v238 & (*(void *)&v225 - 1);
            }
            uint64_t v241 = *(double ***)(*(void *)v224 + 8 * v240);
            if (!v241) {
              goto LABEL_265;
            }
            double v242 = *v241;
            if (!v242) {
              goto LABEL_265;
            }
            if (v239.u32[0] < 2uLL)
            {
              uint64_t v243 = *(void *)&v225 - 1;
              while (1)
              {
                uint64_t v245 = *((void *)v242 + 1);
                if (v245 == v238)
                {
                  if (*((void *)v242 + 2) == v221) {
                    goto LABEL_267;
                  }
                }
                else if ((v245 & v243) != v240)
                {
                  goto LABEL_265;
                }
                double v242 = *(double **)v242;
                if (!v242) {
                  goto LABEL_265;
                }
              }
            }
            while (2)
            {
              unint64_t v244 = *((void *)v242 + 1);
              if (v244 != v238)
              {
                if (v244 >= *(void *)&v225) {
                  v244 %= *(void *)&v225;
                }
                if (v244 != v240) {
                  goto LABEL_265;
                }
                goto LABEL_253;
              }
              if (*((void *)v242 + 2) != v221)
              {
LABEL_253:
                double v242 = *(double **)v242;
                if (!v242) {
                  goto LABEL_265;
                }
                continue;
              }
              break;
            }
LABEL_267:
            if (v235 < v242[3]) {
              continue;
            }
            break;
          }
LABEL_176:
          ;
        }
        while (v10 < v151);
      }
      uint64_t v250 = &v10[-1].i64[1];
      BOOL v5 = &v10[-1].u64[1] >= (unint64_t *)v558;
      BOOL v6 = &v10[-1].u64[1] == (unint64_t *)v558;
      if (&v10[-1].u64[1] != (unint64_t *)v558) {
        v558->i64[0] = *v250;
      }
      a5 = 0;
      *uint64_t v250 = v18;
      unint64_t v9 = a2;
    }
  }
  double v262 = (int8x16_t *)&v10->u64[1];
  BOOL v264 = v10 == a2 || v262 == a2;
  if ((a5 & 1) == 0)
  {
    if (v264) {
      return result;
    }
    while (1)
    {
      unint64_t v452 = (unint64_t *)v262;
      unint64_t v453 = v11->i64[0];
      unint64_t v454 = v11->u64[1];
      size_t v455 = (unint64_t *)v11;
      unint64_t v560 = v11->i64[0];
      unint64_t v561 = v454;
      int8x8_t v456 = (float *)&(*a3)[10];
      size_t v457 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v456, v454);
      if (v457)
      {
        double v458 = v457[3];
      }
      else
      {
        uint64_t v459 = a3[1];
        float64x2_t v460 = vsubq_f64(*(float64x2_t *)v459[1].i8, *(float64x2_t *)(v454 + 600));
        float64x2_t v461 = vmulq_f64(v460, v460);
        double v458 = v461.f64[0]
             + (*(double *)v459 - *(double *)(v454 + 592)) * (*(double *)v459 - *(double *)(v454 + 592))
             + v461.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v456, v454, &v561)+ 3) = v458;
      }
      uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v456, v453);
      if (!result) {
        break;
      }
      if (v458 < result[3]) {
        goto LABEL_482;
      }
LABEL_474:
      double v262 = (int8x16_t *)(v452 + 1);
      uint64_t v11 = (int8x16_t *)v452;
      if (v452 + 1 == (unint64_t *)a2) {
        return result;
      }
    }
    uint64_t v462 = a3[1];
    float64x2_t v463 = vsubq_f64(*(float64x2_t *)v462[1].i8, *(float64x2_t *)(v453 + 600));
    float64x2_t v464 = vmulq_f64(v463, v463);
    double v465 = v464.f64[0]
         + (*(double *)v462 - *(double *)(v453 + 592)) * (*(double *)v462 - *(double *)(v453 + 592))
         + v464.f64[1];
    uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v456, v453, &v560);
    result[3] = v465;
    if (v458 >= v465) {
      goto LABEL_474;
    }
LABEL_482:
    unint64_t v466 = *v452;
    unint64_t v467 = HIDWORD(*v452);
    unint64_t v468 = 0x9DDFEA08EB382D69 * ((8 * *v452 + 8) ^ v467);
    unint64_t v469 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v467 ^ (v468 >> 47) ^ v468)) ^ ((0x9DDFEA08EB382D69 * (v467 ^ (v468 >> 47) ^ v468)) >> 47));
    uint64_t v470 = (float64x2_t *)(*v452 + 600);
    double v559 = v452;
LABEL_483:
    unint64_t v471 = v452;
    unint64_t v452 = v455;
    *unint64_t v471 = *v455;
    unint64_t v473 = *--v455;
    unint64_t v472 = v473;
    unint64_t v560 = v473;
    unint64_t v561 = v466;
    unint64_t v474 = *a3;
    unint64_t v475 = (float *)&(*a3)[10];
    int8x8_t v476 = (*a3)[11];
    if (v476)
    {
      uint8x8_t v477 = (uint8x8_t)vcnt_s8(v476);
      v477.i16[0] = vaddlv_u8(v477);
      if (v477.u32[0] > 1uLL)
      {
        unint64_t v478 = v469;
        if (v469 >= *(void *)&v476) {
          unint64_t v478 = v469 % *(void *)&v476;
        }
      }
      else
      {
        unint64_t v478 = (*(void *)&v476 - 1) & v469;
      }
      unint64_t v479 = *(double ***)(*(void *)v475 + 8 * v478);
      if (v479)
      {
        unint64_t v480 = *v479;
        if (v480)
        {
          if (v477.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v482 = *((void *)v480 + 1);
              if (v482 == v469)
              {
                if (*((void *)v480 + 2) == v466) {
                  goto LABEL_524;
                }
              }
              else if ((v482 & (*(void *)&v476 - 1)) != v478)
              {
                goto LABEL_503;
              }
              unint64_t v480 = *(double **)v480;
              if (!v480) {
                goto LABEL_503;
              }
            }
          }
          do
          {
            unint64_t v481 = *((void *)v480 + 1);
            if (v481 == v469)
            {
              if (*((void *)v480 + 2) == v466)
              {
LABEL_524:
                double v486 = v480[3];
LABEL_504:
                unint64_t v487 = 0x9DDFEA08EB382D69 * (((8 * v472) + 8) ^ HIDWORD(v472));
                unint64_t v488 = 0x9DDFEA08EB382D69 * (HIDWORD(v472) ^ (v487 >> 47) ^ v487);
                unint64_t v489 = 0x9DDFEA08EB382D69 * (v488 ^ (v488 >> 47));
                uint8x8_t v490 = (uint8x8_t)vcnt_s8(v476);
                v490.i16[0] = vaddlv_u8(v490);
                if (v490.u32[0] > 1uLL)
                {
                  unint64_t v491 = v489;
                  if (v489 >= *(void *)&v476) {
                    unint64_t v491 = v489 % *(void *)&v476;
                  }
                }
                else
                {
                  unint64_t v491 = v489 & (*(void *)&v476 - 1);
                }
                long double v492 = *(double ***)(*(void *)v475 + 8 * v491);
                if (v492)
                {
                  unint64_t v493 = *v492;
                  if (v493)
                  {
                    if (v490.u32[0] < 2uLL)
                    {
                      uint64_t v494 = *(void *)&v476 - 1;
                      while (1)
                      {
                        uint64_t v496 = *((void *)v493 + 1);
                        if (v496 == v489)
                        {
                          if (*((void *)v493 + 2) == v472) {
                            goto LABEL_527;
                          }
                        }
                        else if ((v496 & v494) != v491)
                        {
                          goto LABEL_525;
                        }
                        unint64_t v493 = *(double **)v493;
                        if (!v493) {
                          goto LABEL_525;
                        }
                      }
                    }
                    do
                    {
                      unint64_t v495 = *((void *)v493 + 1);
                      if (v495 == v489)
                      {
                        if (*((void *)v493 + 2) == v472)
                        {
LABEL_527:
                          if (v486 >= v493[3])
                          {
LABEL_473:
                            unint64_t *v452 = v466;
                            unint64_t v452 = v559;
                            goto LABEL_474;
                          }
                          goto LABEL_483;
                        }
                      }
                      else
                      {
                        if (v495 >= *(void *)&v476) {
                          v495 %= *(void *)&v476;
                        }
                        if (v495 != v491) {
                          break;
                        }
                      }
                      unint64_t v493 = *(double **)v493;
                    }
                    while (v493);
                  }
                }
LABEL_525:
                double v497 = a3[1];
                float64x2_t v498 = vsubq_f64(*(float64x2_t *)v497[1].i8, *(float64x2_t *)(v472 + 600));
                float64x2_t v499 = vmulq_f64(v498, v498);
                double v500 = v499.f64[0]
                     + (*(double *)v497 - *(double *)(v472 + 592)) * (*(double *)v497 - *(double *)(v472 + 592))
                     + v499.f64[1];
                uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v475, v472, &v560);
                result[3] = v500;
                if (v486 >= v500) {
                  goto LABEL_473;
                }
                goto LABEL_483;
              }
            }
            else
            {
              if (v481 >= *(void *)&v476) {
                v481 %= *(void *)&v476;
              }
              if (v481 != v478) {
                break;
              }
            }
            unint64_t v480 = *(double **)v480;
          }
          while (v480);
        }
      }
    }
LABEL_503:
    uint64_t v483 = a3[1];
    float64x2_t v484 = vsubq_f64(*(float64x2_t *)v483[1].i8, *v470);
    float64x2_t v485 = vmulq_f64(v484, v484);
    double v486 = v485.f64[0]
         + (*(double *)v483 - *(double *)(v466 + 592)) * (*(double *)v483 - *(double *)(v466 + 592))
         + v485.f64[1];
    uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>((float *)&(*a3)[10], v466, &v561);
    result[3] = v486;
    int8x8_t v476 = v474[11];
    if (v476) {
      goto LABEL_504;
    }
    goto LABEL_525;
  }
  if (!v264)
  {
    unint64_t v265 = (unint64_t *)v10;
    while (1)
    {
      int v267 = (unint64_t *)v262;
      unint64_t v268 = *v265;
      unint64_t v269 = v265[1];
      unint64_t v560 = *v265;
      unint64_t v561 = v269;
      unint64_t v270 = (float *)&(*a3)[10];
      uint64_t v271 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v270, v269);
      if (v271)
      {
        double v272 = v271[3];
      }
      else
      {
        uint64_t v273 = a3[1];
        float64x2_t v274 = vsubq_f64(*(float64x2_t *)v273[1].i8, *(float64x2_t *)(v269 + 600));
        float64x2_t v275 = vmulq_f64(v274, v274);
        double v272 = v275.f64[0]
             + (*(double *)v273 - *(double *)(v269 + 592)) * (*(double *)v273 - *(double *)(v269 + 592))
             + v275.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v270, v269, &v561)+ 3) = v272;
      }
      uint64_t result = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v270, v268);
      if (result)
      {
        double v276 = result[3];
      }
      else
      {
        int8x16_t v277 = a3[1];
        float64x2_t v278 = vsubq_f64(*(float64x2_t *)v277[1].i8, *(float64x2_t *)(v268 + 600));
        float64x2_t v279 = vmulq_f64(v278, v278);
        double v276 = v279.f64[0]
             + (*(double *)v277 - *(double *)(v268 + 592)) * (*(double *)v277 - *(double *)(v268 + 592))
             + v279.f64[1];
        uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v270, v268, &v560);
        result[3] = v276;
      }
      uint64_t v281 = a2;
      double v280 = v558;
      if (v272 < v276) {
        break;
      }
LABEL_297:
      double v262 = (int8x16_t *)(v267 + 1);
      unint64_t v265 = v267;
      if (v267 + 1 == (unint64_t *)v281) {
        return result;
      }
    }
    unint64_t v282 = *v267;
    unint64_t v283 = HIDWORD(*v267);
    unint64_t v284 = 0x9DDFEA08EB382D69 * ((8 * *v267 + 8) ^ v283);
    unint64_t v285 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v283 ^ (v284 >> 47) ^ v284)) ^ ((0x9DDFEA08EB382D69 * (v283 ^ (v284 >> 47) ^ v284)) >> 47));
    uint64_t v286 = (float64x2_t *)(*v267 + 600);
    double v554 = v267;
    double v266 = v267;
LABEL_306:
    *double v266 = *v265;
    if (v265 == (unint64_t *)v280)
    {
      double v266 = (unint64_t *)v280;
      goto LABEL_296;
    }
    double v266 = v265;
    unint64_t v288 = *--v265;
    unint64_t v287 = v288;
    unint64_t v560 = v288;
    unint64_t v561 = v282;
    double v289 = *a3;
    unint64_t v290 = (float *)&(*a3)[10];
    int8x8_t v291 = (*a3)[11];
    if (!*(void *)&v291) {
      goto LABEL_327;
    }
    uint8x8_t v292 = (uint8x8_t)vcnt_s8(v291);
    v292.i16[0] = vaddlv_u8(v292);
    if (v292.u32[0] > 1uLL)
    {
      unint64_t v293 = v285;
      if (v285 >= *(void *)&v291) {
        unint64_t v293 = v285 % *(void *)&v291;
      }
    }
    else
    {
      unint64_t v293 = (*(void *)&v291 - 1) & v285;
    }
    float v294 = *(double ***)(*(void *)v290 + 8 * v293);
    if (!v294 || (double v295 = *v294) == 0)
    {
LABEL_327:
      unint64_t v298 = a3[1];
      float64x2_t v299 = vsubq_f64(*(float64x2_t *)v298[1].i8, *v286);
      float64x2_t v300 = vmulq_f64(v299, v299);
      double v301 = v300.f64[0]
           + (*(double *)v298 - *(double *)(v282 + 592)) * (*(double *)v298 - *(double *)(v282 + 592))
           + v300.f64[1];
      uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>((float *)&(*a3)[10], v282, &v561);
      result[3] = v301;
      int8x8_t v291 = v289[11];
      if (v291) {
        goto LABEL_328;
      }
LABEL_349:
      long long v312 = a3[1];
      float64x2_t v313 = vsubq_f64(*(float64x2_t *)v312[1].i8, *(float64x2_t *)(v287 + 600));
      float64x2_t v314 = vmulq_f64(v313, v313);
      double v315 = v314.f64[0]
           + (*(double *)v312 - *(double *)(v287 + 592)) * (*(double *)v312 - *(double *)(v287 + 592))
           + v314.f64[1];
      uint64_t result = (double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v290, v287, &v560);
      result[3] = v315;
      goto LABEL_350;
    }
    if (v292.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v297 = *((void *)v295 + 1);
        if (v297 == v285)
        {
          if (*((void *)v295 + 2) == v282) {
            goto LABEL_348;
          }
        }
        else if ((v297 & (*(void *)&v291 - 1)) != v293)
        {
          goto LABEL_327;
        }
        double v295 = *(double **)v295;
        if (!v295) {
          goto LABEL_327;
        }
      }
    }
    while (1)
    {
      unint64_t v296 = *((void *)v295 + 1);
      if (v296 == v285)
      {
        if (*((void *)v295 + 2) == v282)
        {
LABEL_348:
          double v301 = v295[3];
LABEL_328:
          unint64_t v302 = 0x9DDFEA08EB382D69 * (((8 * v287) + 8) ^ HIDWORD(v287));
          unint64_t v303 = 0x9DDFEA08EB382D69 * (HIDWORD(v287) ^ (v302 >> 47) ^ v302);
          unint64_t v304 = 0x9DDFEA08EB382D69 * (v303 ^ (v303 >> 47));
          uint8x8_t v305 = (uint8x8_t)vcnt_s8(v291);
          v305.i16[0] = vaddlv_u8(v305);
          if (v305.u32[0] > 1uLL)
          {
            unint64_t v306 = v304;
            if (v304 >= *(void *)&v291) {
              unint64_t v306 = v304 % *(void *)&v291;
            }
          }
          else
          {
            unint64_t v306 = v304 & (*(void *)&v291 - 1);
          }
          unint64_t v307 = *(double ***)(*(void *)v290 + 8 * v306);
          if (!v307) {
            goto LABEL_349;
          }
          double v308 = *v307;
          if (!v308) {
            goto LABEL_349;
          }
          if (v305.u32[0] < 2uLL)
          {
            uint64_t v309 = *(void *)&v291 - 1;
            while (1)
            {
              uint64_t v311 = *((void *)v308 + 1);
              if (v311 == v304)
              {
                if (*((void *)v308 + 2) == v287) {
                  goto LABEL_352;
                }
              }
              else if ((v311 & v309) != v306)
              {
                goto LABEL_349;
              }
              double v308 = *(double **)v308;
              if (!v308) {
                goto LABEL_349;
              }
            }
          }
          while (2)
          {
            unint64_t v310 = *((void *)v308 + 1);
            if (v310 != v304)
            {
              if (v310 >= *(void *)&v291) {
                v310 %= *(void *)&v291;
              }
              if (v310 != v306) {
                goto LABEL_349;
              }
              goto LABEL_337;
            }
            if (*((void *)v308 + 2) != v287)
            {
LABEL_337:
              double v308 = *(double **)v308;
              if (!v308) {
                goto LABEL_349;
              }
              continue;
            }
            break;
          }
LABEL_352:
          double v315 = v308[3];
LABEL_350:
          uint64_t v281 = a2;
          double v280 = v558;
          if (v301 >= v315)
          {
LABEL_296:
            *double v266 = v282;
            int v267 = v554;
            goto LABEL_297;
          }
          goto LABEL_306;
        }
      }
      else
      {
        if (v296 >= *(void *)&v291) {
          v296 %= *(void *)&v291;
        }
        if (v296 != v293) {
          goto LABEL_327;
        }
      }
      double v295 = *(double **)v295;
      if (!v295) {
        goto LABEL_327;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,ARStorefrontLabelFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>(int8x16_t *a1, int8x16_t *a2, void *a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v8 = a2[-1].u64[1];
      unint64_t v9 = a1->i64[0];
      unint64_t v99 = a1->i64[0];
      unint64_t v100 = v8;
      unint64_t v10 = (float *)(*a3 + 80);
      uint64_t v11 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v10, v8);
      if (v11)
      {
        double v12 = v11[3];
      }
      else
      {
        uint64_t v53 = a3[1];
        float64x2_t v54 = vsubq_f64(*(float64x2_t *)(v53 + 8), *(float64x2_t *)(v8 + 600));
        float64x2_t v55 = vmulq_f64(v54, v54);
        double v12 = v55.f64[0]
            + (*(double *)v53 - *(double *)(v8 + 592)) * (*(double *)v53 - *(double *)(v8 + 592))
            + v55.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v10, v8, &v100)+ 3) = v12;
      }
      char v56 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v10, v9);
      if (v56)
      {
        if (v12 >= v56[3]) {
          return 1;
        }
      }
      else
      {
        uint64_t v57 = a3[1];
        float64x2_t v58 = vsubq_f64(*(float64x2_t *)(v57 + 8), *(float64x2_t *)(v9 + 600));
        float64x2_t v59 = vmulq_f64(v58, v58);
        double v60 = v59.f64[0]
            + (*(double *)v57 - *(double *)(v9 + 592)) * (*(double *)v57 - *(double *)(v9 + 592))
            + v59.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v10, v9, &v99)+ 3) = v60;
        if (v12 >= v60) {
          return 1;
        }
      }
      uint64_t v61 = a1->i64[0];
      a1->i64[0] = v4[-1].i64[1];
      v4[-1].i64[1] = v61;
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)a1, &a1->u64[1], &a2[-1].u64[1], a3);
      return 1;
    case 4:
      int v46 = &a1->u64[1];
      double v47 = a1 + 1;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)a1, &a1->u64[1], (unint64_t *)&a1[1], a3);
      unint64_t v48 = v4[-1].u64[1];
      unint64_t v49 = a1[1].u64[0];
      unint64_t v99 = v49;
      unint64_t v100 = v48;
      __n128 v50 = (float *)(*a3 + 80);
      long long v51 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v50, v48);
      if (v51)
      {
        double v52 = v51[3];
      }
      else
      {
        uint64_t v62 = a3[1];
        float64x2_t v63 = vsubq_f64(*(float64x2_t *)(v62 + 8), *(float64x2_t *)(v48 + 600));
        float64x2_t v64 = vmulq_f64(v63, v63);
        double v52 = v64.f64[0]
            + (*(double *)v62 - *(double *)(v48 + 592)) * (*(double *)v62 - *(double *)(v48 + 592))
            + v64.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v50, v48, &v100)+ 3) = v52;
      }
      uint64_t v65 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v50, v49);
      if (v65)
      {
        if (v52 >= v65[3]) {
          return 1;
        }
      }
      else
      {
        uint64_t v66 = a3[1];
        float64x2_t v67 = vsubq_f64(*(float64x2_t *)(v66 + 8), *(float64x2_t *)(v49 + 600));
        float64x2_t v68 = vmulq_f64(v67, v67);
        double v69 = v68.f64[0]
            + (*(double *)v66 - *(double *)(v49 + 592)) * (*(double *)v66 - *(double *)(v49 + 592))
            + v68.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v50, v49, &v99)+ 3) = v69;
        if (v52 >= v69) {
          return 1;
        }
      }
      unint64_t v70 = v47->i64[0];
      v47->i64[0] = v4[-1].i64[1];
      v4[-1].i64[1] = v70;
      unint64_t v71 = v47->i64[0];
      unint64_t v72 = *v46;
      unint64_t v99 = *v46;
      unint64_t v100 = v71;
      unint64_t v73 = (float *)(*a3 + 80);
      unint64_t v74 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v73, v71);
      if (v74)
      {
        double v75 = v74[3];
      }
      else
      {
        uint64_t v76 = a3[1];
        float64x2_t v77 = vsubq_f64(*(float64x2_t *)(v76 + 8), *(float64x2_t *)(v71 + 600));
        float64x2_t v78 = vmulq_f64(v77, v77);
        double v75 = v78.f64[0]
            + (*(double *)v76 - *(double *)(v71 + 592)) * (*(double *)v76 - *(double *)(v71 + 592))
            + v78.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v73, v71, &v100)+ 3) = v75;
      }
      unint64_t v79 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v73, v72);
      if (v79)
      {
        if (v75 >= v79[3]) {
          return 1;
        }
      }
      else
      {
        uint64_t v80 = a3[1];
        float64x2_t v81 = vsubq_f64(*(float64x2_t *)(v80 + 8), *(float64x2_t *)(v72 + 600));
        float64x2_t v82 = vmulq_f64(v81, v81);
        double v83 = v82.f64[0]
            + (*(double *)v80 - *(double *)(v72 + 592)) * (*(double *)v80 - *(double *)(v72 + 592))
            + v82.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v73, v72, &v99)+ 3) = v83;
        if (v75 >= v83) {
          return 1;
        }
      }
      uint64_t v84 = a1->i64[1];
      unint64_t v85 = a1[1].u64[0];
      unint64_t v86 = a1->i64[0];
      a1->i64[1] = v85;
      a1[1].i64[0] = v84;
      unint64_t v99 = v86;
      unint64_t v100 = v85;
      uint64_t v87 = (float *)(*a3 + 80);
      char v88 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v87, v85);
      if (v88)
      {
        double v89 = v88[3];
      }
      else
      {
        uint64_t v90 = a3[1];
        float64x2_t v91 = vsubq_f64(*(float64x2_t *)(v90 + 8), *(float64x2_t *)(v85 + 600));
        float64x2_t v92 = vmulq_f64(v91, v91);
        double v89 = v92.f64[0]
            + (*(double *)v90 - *(double *)(v85 + 592)) * (*(double *)v90 - *(double *)(v85 + 592))
            + v92.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v87, v85, &v100)+ 3) = v89;
      }
      float64x2_t v93 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v87, v86);
      if (v93)
      {
        double v94 = v93[3];
      }
      else
      {
        uint64_t v95 = a3[1];
        float64x2_t v96 = vsubq_f64(*(float64x2_t *)(v95 + 8), *(float64x2_t *)(v86 + 600));
        float64x2_t v97 = vmulq_f64(v96, v96);
        double v94 = v97.f64[0]
            + (*(double *)v95 - *(double *)(v86 + 592)) * (*(double *)v95 - *(double *)(v86 + 592))
            + v97.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v87, v86, &v99)+ 3) = v94;
      }
      if (v89 < v94) {
        *a1 = vextq_s8(*a1, *a1, 8uLL);
      }
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)a1, &a1->u64[1], (unint64_t *)&a1[1], &a1[1].u64[1], &a2[-1].u64[1], a3);
      return 1;
    default:
      uint64_t v13 = (unint64_t *)&a1[1];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ARArrivalFeatureDedupingGroup::prepareForCollision(md::LabelManager *)::{lambda(md::LabelBase const*,md::LabelBase const*)#1} &,md::LabelBase**>((unint64_t *)a1, &a1->u64[1], (unint64_t *)&a1[1], a3);
      unint64_t v14 = &a1[1].u64[1];
      if (&a1[1].u64[1] == (unint64_t *)v4) {
        return 1;
      }
      uint64_t v15 = 0;
      int v16 = 0;
      char v98 = (unint64_t *)v4;
      break;
  }
  do
  {
    unint64_t v18 = *v14;
    unint64_t v19 = *v13;
    unint64_t v99 = v19;
    unint64_t v100 = v18;
    uint64_t v20 = (float *)(*a3 + 80);
    __double2 v21 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v20, v18);
    if (v21)
    {
      double v22 = v21[3];
    }
    else
    {
      uint64_t v23 = a3[1];
      float64x2_t v24 = vsubq_f64(*(float64x2_t *)(v23 + 8), *(float64x2_t *)(v18 + 600));
      float64x2_t v25 = vmulq_f64(v24, v24);
      double v22 = v25.f64[0]
          + (*(double *)v23 - *(double *)(v18 + 592)) * (*(double *)v23 - *(double *)(v18 + 592))
          + v25.f64[1];
      *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v20, v18, &v100)+ 3) = v22;
    }
    int8x8_t v26 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v20, v19);
    if (v26)
    {
      if (v22 >= v26[3]) {
        goto LABEL_8;
      }
    }
    else
    {
      uint64_t v27 = a3[1];
      float64x2_t v28 = vsubq_f64(*(float64x2_t *)(v27 + 8), *(float64x2_t *)(v19 + 600));
      float64x2_t v29 = vmulq_f64(v28, v28);
      double v30 = v29.f64[0]
          + (*(double *)v27 - *(double *)(v19 + 592)) * (*(double *)v27 - *(double *)(v19 + 592))
          + v29.f64[1];
      *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v20, v19, &v99)+ 3) = v30;
      if (v22 >= v30) {
        goto LABEL_8;
      }
    }
    unint64_t v31 = *v14;
    float64_t v32 = (float64x2_t *)(*v14 + 600);
    uint64_t v33 = v15;
    do
    {
      *(uint64_t *)((char *)&a1[1].i64[1] + v33) = *(uint64_t *)((char *)a1[1].i64 + v33);
      if (v33 == -16)
      {
        i64 = a1->i64;
        goto LABEL_7;
      }
      unint64_t v38 = *(unint64_t *)((char *)&a1->u64[1] + v33);
      unint64_t v99 = v38;
      unint64_t v100 = v31;
      uint64_t v39 = (float *)(*a3 + 80);
      uint64_t v40 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v39, v31);
      if (v40)
      {
        double v41 = v40[3];
      }
      else
      {
        uint64_t v42 = a3[1];
        float64x2_t v43 = vsubq_f64(*(float64x2_t *)(v42 + 8), *v32);
        float64x2_t v44 = vmulq_f64(v43, v43);
        double v41 = v44.f64[0]
            + (*(double *)v42 - *(double *)(v31 + 592)) * (*(double *)v42 - *(double *)(v31 + 592))
            + v44.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v39, v31, &v100)+ 3) = v41;
      }
      long long v45 = (double *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v39, v38);
      if (v45)
      {
        double v37 = v45[3];
      }
      else
      {
        uint64_t v34 = a3[1];
        float64x2_t v35 = vsubq_f64(*(float64x2_t *)(v34 + 8), *(float64x2_t *)(v38 + 600));
        float64x2_t v36 = vmulq_f64(v35, v35);
        double v37 = v36.f64[0]
            + (*(double *)v34 - *(double *)(v38 + 592)) * (*(double *)v34 - *(double *)(v38 + 592))
            + v36.f64[1];
        *((double *)std::__hash_table<std::__hash_value_type<md::LabelBase const*,double>,std::__unordered_map_hasher<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::hash<md::LabelBase const*>,std::equal_to<md::LabelBase const*>,true>,std::__unordered_map_equal<md::LabelBase const*,std::__hash_value_type<md::LabelBase const*,double>,std::equal_to<md::LabelBase const*>,std::hash<md::LabelBase const*>,true>,std::allocator<std::__hash_value_type<md::LabelBase const*,double>>>::__emplace_unique_key_args<md::LabelBase const*,std::piecewise_construct_t const&,std::tuple<md::LabelBase const* const&>,std::tuple<>>(v39, v38, &v99)+ 3) = v37;
      }
      v33 -= 8;
    }
    while (v41 < v37);
    i64 = (uint64_t *)((char *)&a1[1].i64[1] + v33);
LABEL_7:
    void *i64 = v31;
    ++v16;
    uint64_t v4 = (int8x16_t *)v98;
    if (v16 == 8) {
      return v14 + 1 == v98;
    }
LABEL_8:
    uint64_t v13 = v14;
    v15 += 8;
    ++v14;
  }
  while (v14 != (unint64_t *)v4);
  return 1;
}

void ARStorefrontLabelFeatureDedupingGroup::~ARStorefrontLabelFeatureDedupingGroup(ARStorefrontLabelFeatureDedupingGroup *this)
{
  *(void *)this = &unk_1EF5300F8;
  uint64_t v2 = (void *)*((void *)this + 12);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)*((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)this = &unk_1EF539178;
  uint64_t v5 = *((void *)this + 5);
  if (v5)
  {
    *((void *)this + 6) = v5;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v5, *((void *)this + 7) - v5);
  }
  uint64_t v6 = *((void *)this + 1);
  if (v6)
  {
    *((void *)this + 2) = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v6, *((void *)this + 3) - v6);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  *(void *)this = &unk_1EF5300F8;
  uint64_t v2 = (void *)*((void *)this + 12);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)*((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)this = &unk_1EF539178;
  uint64_t v5 = *((void *)this + 5);
  if (v5)
  {
    *((void *)this + 6) = v5;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v5, *((void *)this + 7) - v5);
  }
  uint64_t v6 = *((void *)this + 1);
  if (v6)
  {
    *((void *)this + 2) = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v6, *((void *)this + 3) - v6);
  }
}

void md::Logic<md::DebugDrawLogic,md::DebugDrawContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    double v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

BOOL gdc::ComponentStorageWrapper<std::vector<gm::LineSegment<float,3>>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<std::vector<gm::LineSegment<float,3>>>::remove(void *a1, unint64_t a2)
{
  unint64_t v21 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (*(_DWORD *)(v11 + 4) != v10 || v11 == v8) {
    return 0;
  }
  uint64_t v14 = a1[10] + 24 * v7;
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  if (v14 != v15 - 24)
  {
    std::vector<gm::LineSegment<float,3>>::__assign_with_size[abi:nn180100]<gm::LineSegment<float,3>*,gm::LineSegment<float,3>*>(v14, *(char **)(v15 - 24), *(char **)(v15 - 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v15 - 16) - *(void *)(v15 - 24)) >> 3));
    uint64_t v15 = a1[11];
  }
  uint64_t v17 = v15 - 24;
  int v16 = *(void **)(v15 - 24);
  if (v16)
  {
    *(void *)(v15 - 16) = v16;
    operator delete(v16);
  }
  a1[11] = v17;
  unint64_t v18 = (void *)a1[28];
  if (!v18) {
    return 1;
  }
  uint64_t v19 = a1[31];
  while (1)
  {
    v23[0] = &v21;
    v23[1] = 1;
    uint64_t v22 = v19;
    uint64_t v20 = v18[6];
    if (!v20) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v20 + 48))(v20, &v22, v23);
    unint64_t v18 = (void *)*v18;
    if (!v18) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<std::vector<gm::LineSegment<float,3>>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<std::vector<gm::LineSegment<float,3>>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<std::vector<gdc::Registry *>>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<std::variant<gm::Box<double,3>,gm::Sphere<double,3,std::enable_if<true,void>>,geo::OrientedBox<double,3u,double,double>>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

double gdc::ComponentStorageWrapper<std::variant<gm::Box<double,3>,gm::Sphere<double,3,std::enable_if<true,void>>,geo::OrientedBox<double,3u,double,double>>>::remove(void *a1, unint64_t a2)
{
  unint64_t v26 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return result;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return result;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return result;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (*(_DWORD *)(v11 + 4) != v10 || v11 == v8) {
    return result;
  }
  uint64_t v13 = a1[10] + 112 * v7;
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  uint64_t v16 = *(unsigned int *)(v13 + 104);
  uint64_t v17 = *(unsigned int *)(v15 - 8);
  if (v16 == -1)
  {
    if (v17 == -1) {
      goto LABEL_15;
    }
  }
  else if (v17 == -1)
  {
    ((void (*)(void *, uint64_t))off_1EF590E88[v16])(v28, v13);
    *(_DWORD *)(v13 + 104) = -1;
    goto LABEL_15;
  }
  v28[0] = v13;
  ((void (*)(void *, uint64_t, uint64_t))off_1EF590EB8[v17])(v28, v13, v15 - 112);
LABEL_15:
  uint64_t v18 = a1[11];
  uint64_t v19 = *(unsigned int *)(v18 - 8);
  if (v19 != -1) {
    ((void (*)(void *, uint64_t))off_1EF590E88[v19])(v28, v18 - 112);
  }
  *(_DWORD *)(v18 - 8) = -1;
  a1[11] = v18 - 112;
  uint64_t v20 = (void *)a1[28];
  if (v20)
  {
    uint64_t v21 = a1[31];
    while (1)
    {
      v28[0] = &v26;
      v28[1] = 1;
      uint64_t v27 = v21;
      uint64_t v22 = v20[6];
      if (!v22) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v22 + 48))(v22, &v27, v28);
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        return result;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    *(void *)&double result = _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2gm3BoxIdLi3EEENS8_6SphereIdLi3ENS_9enable_ifILb1EvEEEEN3geo11OrientedBoxIdLj3EddEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSQ_OT0_E_JRNS0_6__baseILSM_1EJSA_SE_SH_EEERKSY_EEEDcSQ_DpT0_(v23, v24, v25).n128_u64[0];
  }
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2gm3BoxIdLi3EEENS8_6SphereIdLi3ENS_9enable_ifILb1EvEEEEN3geo11OrientedBoxIdLj3EddEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSQ_OT0_E_JRNS0_6__baseILSM_1EJSA_SE_SH_EEERKSY_EEEDcSQ_DpT0_(uint64_t *a1, void *a2, void *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 104);
  if (v5 != -1)
  {
    if (v5 == 2)
    {
      a2[3] = a3[3];
      a2[4] = a3[4];
      a2[5] = a3[5];
      a2[6] = a3[6];
      *a2 = *a3;
      a2[1] = a3[1];
      a2[2] = a3[2];
      a2[7] = a3[7];
      a2[8] = a3[8];
      a2[9] = a3[9];
      a2[10] = a3[10];
      a2[11] = a3[11];
      result.n128_u64[0] = a3[12];
      a2[12] = result.n128_u64[0];
      return result;
    }
    ((void (*)(char *, uint64_t))off_1EF590E88[v5])(&v10, v4);
  }
  *(_DWORD *)(v4 + 104) = -1;
  long long v7 = *(_OWORD *)a3;
  *(void *)(v4 + 16) = a3[2];
  *(_OWORD *)uint64_t v4 = v7;
  long long v8 = *(_OWORD *)(a3 + 3);
  *(void *)(v4 + 40) = a3[5];
  *(_OWORD *)(v4 + 24) = v8;
  *(void *)(v4 + 48) = a3[6];
  __n128 result = *(__n128 *)(a3 + 7);
  long long v9 = *(_OWORD *)(a3 + 9);
  *(_OWORD *)(v4 + 88) = *(_OWORD *)(a3 + 11);
  *(_OWORD *)(v4 + 72) = v9;
  *(__n128 *)(v4 + 56) = result;
  *(_DWORD *)(v4 + 104) = 2;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2gm3BoxIdLi3EEENS8_6SphereIdLi3ENS_9enable_ifILb1EvEEEEN3geo11OrientedBoxIdLj3EddEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSQ_OT0_E_JRNS0_6__baseILSM_1EJSA_SE_SH_EEERKSY_EEEDcSQ_DpT0_(uint64_t *a1, void *a2, void *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 104);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      *a2 = *a3;
      a2[1] = a3[1];
      a2[2] = a3[2];
      result.n128_u64[0] = a3[3];
      a2[3] = result.n128_u64[0];
      return result;
    }
    ((void (*)(char *, uint64_t))off_1EF590E88[v5])(&v8, v4);
  }
  *(_DWORD *)(v4 + 104) = -1;
  __n128 result = *(__n128 *)a3;
  long long v7 = *((_OWORD *)a3 + 1);
  *(_OWORD *)uint64_t v4 = *(_OWORD *)a3;
  *(_OWORD *)(v4 + 16) = v7;
  *(_DWORD *)(v4 + 104) = 1;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2gm3BoxIdLi3EEENS8_6SphereIdLi3ENS_9enable_ifILb1EvEEEEN3geo11OrientedBoxIdLj3EddEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSQ_OT0_E_JRNS0_6__baseILSM_1EJSA_SE_SH_EEERKSY_EEEDcSQ_DpT0_(uint64_t *a1, void *a2, void *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 104);
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      a2[1] = a3[1];
      a2[2] = a3[2];
      a2[3] = a3[3];
      a2[4] = a3[4];
      result.n128_u64[0] = a3[5];
      a2[5] = result.n128_u64[0];
      return result;
    }
    ((void (*)(char *, uint64_t))off_1EF590E88[v5])(&v8, v4);
  }
  *(_DWORD *)(v4 + 104) = -1;
  __n128 result = *(__n128 *)a3;
  long long v7 = *((_OWORD *)a3 + 2);
  *(_OWORD *)(v4 + 16) = *((_OWORD *)a3 + 1);
  *(_OWORD *)(v4 + 32) = v7;
  *(__n128 *)uint64_t v4 = result;
  *(_DWORD *)(v4 + 104) = 0;
  return result;
}

void gdc::ComponentStorageWrapper<std::variant<gm::Box<double,3>,gm::Sphere<double,3,std::enable_if<true,void>>,geo::OrientedBox<double,3u,double,double>>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<std::variant<gm::Box<double,3>,gm::Sphere<double,3,std::enable_if<true,void>>,geo::OrientedBox<double,3u,double,double>>>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

void *gdc::ComponentStorageWrapper<std::variant<gm::Box<double,3>,gm::Sphere<double,3,std::enable_if<true,void>>,geo::OrientedBox<double,3u,double,double>>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((gdc::ComponentStorageSignals *)(a1 + 13));
  uint64_t v2 = a1[10];
  if (v2)
  {
    uint64_t v3 = a1[11];
    uint64_t v4 = (void *)a1[10];
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = v3 - 112;
        uint64_t v6 = *(unsigned int *)(v3 - 8);
        if (v6 != -1) {
          ((void (*)(char *, uint64_t))off_1EF590E88[v6])(&v14, v3 - 112);
        }
        *(_DWORD *)(v3 - 8) = -1;
        v3 -= 112;
      }
      while (v5 != v2);
      uint64_t v4 = (void *)a1[10];
    }
    a1[11] = v2;
    operator delete(v4);
  }
  long long v7 = (void *)a1[7];
  if (v7)
  {
    a1[8] = v7;
    operator delete(v7);
  }
  char v8 = (void *)a1[4];
  if (v8)
  {
    long long v9 = (void *)a1[5];
    char v10 = (void *)a1[4];
    if (v9 != v8)
    {
      do
      {
        uint64_t v12 = *--v9;
        uint64_t v11 = v12;
        void *v9 = 0;
        if (v12) {
          MEMORY[0x1A6239270](v11, 0x1000C40104B78CFLL);
        }
      }
      while (v9 != v8);
      char v10 = (void *)a1[4];
    }
    a1[5] = v8;
    operator delete(v10);
  }
  return a1;
}

BOOL gdc::ComponentStorageWrapper<debugComponents::DisplayOptions>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<debugComponents::DisplayOptions>::remove(void *a1, unint64_t a2)
{
  unint64_t v20 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10] + 16 * v7;
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  *(unsigned char *)uint64_t v14 = *(unsigned char *)(v15 - 16);
  *(unsigned char *)(v14 + 1) = *(unsigned char *)(v15 - 15);
  *(unsigned char *)(v14 + 2) = *(unsigned char *)(v15 - 14);
  *(unsigned char *)(v14 + 3) = *(unsigned char *)(v15 - 13);
  uint64_t v16 = *(void *)(v15 - 12);
  *(unsigned char *)(v14 + 12) = *(unsigned char *)(v15 - 4);
  *(void *)(v14 + 4) = v16;
  a1[11] -= 16;
  uint64_t v17 = (void *)a1[28];
  if (!v17) {
    return 1;
  }
  uint64_t v18 = a1[31];
  while (1)
  {
    v22[0] = &v20;
    v22[1] = 1;
    uint64_t v21 = v18;
    uint64_t v19 = v17[6];
    if (!v19) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v19 + 48))(v19, &v21, v22);
    uint64_t v17 = (void *)*v17;
    if (!v17) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<debugComponents::DisplayOptions>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<debugComponents::DisplayOptions>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<std::variant<gm::Box<float,3>,gm::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo::OrientedBox<float,2u,float,float>>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

double gdc::ComponentStorageWrapper<std::variant<gm::Box<float,3>,gm::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo::OrientedBox<float,2u,float,float>>>::remove(void *a1, unint64_t a2)
{
  unint64_t v26 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return result;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return result;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return result;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (*(_DWORD *)(v11 + 4) != v10 || v11 == v8) {
    return result;
  }
  uint64_t v13 = a1[10] + 56 * v7;
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  uint64_t v16 = *(unsigned int *)(v13 + 52);
  uint64_t v17 = *(unsigned int *)(v15 - 4);
  if (v16 == -1)
  {
    if (v17 == -1) {
      goto LABEL_15;
    }
  }
  else if (v17 == -1)
  {
    ((void (*)(void *, uint64_t))off_1EF590E28[v16])(v28, v13);
    *(_DWORD *)(v13 + 52) = -1;
    goto LABEL_15;
  }
  v28[0] = v13;
  ((void (*)(void *, uint64_t, uint64_t))off_1EF590E68[v17])(v28, v13, v15 - 56);
LABEL_15:
  uint64_t v18 = a1[11];
  uint64_t v19 = *(unsigned int *)(v18 - 4);
  if (v19 != -1) {
    ((void (*)(void *, uint64_t))off_1EF590E28[v19])(v28, v18 - 56);
  }
  *(_DWORD *)(v18 - 4) = -1;
  a1[11] = v18 - 56;
  unint64_t v20 = (void *)a1[28];
  if (v20)
  {
    uint64_t v21 = a1[31];
    while (1)
    {
      v28[0] = &v26;
      v28[1] = 1;
      uint64_t v27 = v21;
      uint64_t v22 = v20[6];
      if (!v22) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v22 + 48))(v22, &v27, v28);
      unint64_t v20 = (void *)*v20;
      if (!v20) {
        return result;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    *(void *)&double result = _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2gm3BoxIfLi3EEENS8_6SphereIfLi3ENS_9enable_ifILb1EvEEEEN3geo11OrientedBoxIfLj3EffEENSG_IfLj2EffEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSR_OT0_E_JRNS0_6__baseILSN_1EJSA_SE_SH_SI_EEERKSZ_EEEDcSR_DpT0_(v23, v24, v25).n128_u64[0];
  }
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2gm3BoxIfLi3EEENS8_6SphereIfLi3ENS_9enable_ifILb1EvEEEEN3geo11OrientedBoxIfLj3EffEENSG_IfLj2EffEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSR_OT0_E_JRNS0_6__baseILSN_1EJSA_SE_SH_SI_EEERKSZ_EEEDcSR_DpT0_(uint64_t *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 52);
  if (v5 != -1)
  {
    if (v5 == 3)
    {
      a2[3] = a3[3];
      a2[4] = a3[4];
      a2[5] = a3[5];
      a2[6] = a3[6];
      *a2 = *a3;
      a2[1] = a3[1];
      a2[2] = a3[2];
      a2[7] = a3[7];
      a2[8] = a3[8];
      a2[9] = a3[9];
      result.n128_u32[0] = a3[10];
      a2[10] = result.n128_u32[0];
      return result;
    }
    ((void (*)(char *, uint64_t))off_1EF590E28[v5])(&v9, v4);
  }
  *(_DWORD *)(v4 + 52) = -1;
  uint64_t v7 = *(void *)a3;
  *(_DWORD *)(v4 + 8) = a3[2];
  *(void *)uint64_t v4 = v7;
  uint64_t v8 = *(void *)(a3 + 3);
  *(_DWORD *)(v4 + 20) = a3[5];
  *(void *)(v4 + 12) = v8;
  *(_DWORD *)(v4 + 24) = a3[6];
  __n128 result = *(__n128 *)(a3 + 7);
  *(__n128 *)(v4 + 28) = result;
  *(_DWORD *)(v4 + 52) = 3;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2gm3BoxIfLi3EEENS8_6SphereIfLi3ENS_9enable_ifILb1EvEEEEN3geo11OrientedBoxIfLj3EffEENSG_IfLj2EffEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSR_OT0_E_JRNS0_6__baseILSN_1EJSA_SE_SH_SI_EEERKSZ_EEEDcSR_DpT0_(uint64_t *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 52);
  if (v5 != -1)
  {
    if (v5 == 2)
    {
      a2[3] = a3[3];
      a2[4] = a3[4];
      a2[5] = a3[5];
      a2[6] = a3[6];
      *a2 = *a3;
      a2[1] = a3[1];
      a2[2] = a3[2];
      a2[7] = a3[7];
      a2[8] = a3[8];
      a2[9] = a3[9];
      a2[10] = a3[10];
      a2[11] = a3[11];
      result.n128_u32[0] = a3[12];
      a2[12] = result.n128_u32[0];
      return result;
    }
    ((void (*)(char *, uint64_t))off_1EF590E28[v5])(&v9, v4);
  }
  *(_DWORD *)(v4 + 52) = -1;
  uint64_t v7 = *(void *)a3;
  *(_DWORD *)(v4 + 8) = a3[2];
  *(void *)uint64_t v4 = v7;
  uint64_t v8 = *(void *)(a3 + 3);
  *(_DWORD *)(v4 + 20) = a3[5];
  *(void *)(v4 + 12) = v8;
  *(_DWORD *)(v4 + 24) = a3[6];
  __n128 result = *(__n128 *)(a3 + 7);
  *(void *)(v4 + 44) = *(void *)(a3 + 11);
  *(__n128 *)(v4 + 28) = result;
  *(_DWORD *)(v4 + 52) = 2;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2gm3BoxIfLi3EEENS8_6SphereIfLi3ENS_9enable_ifILb1EvEEEEN3geo11OrientedBoxIfLj3EffEENSG_IfLj2EffEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSR_OT0_E_JRNS0_6__baseILSN_1EJSA_SE_SH_SI_EEERKSZ_EEEDcSR_DpT0_(uint64_t *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 52);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      *a2 = *a3;
      a2[1] = a3[1];
      a2[2] = a3[2];
      result.n128_u32[0] = a3[3];
      a2[3] = result.n128_u32[0];
      return result;
    }
    ((void (*)(char *, uint64_t))off_1EF590E28[v5])(&v7, v4);
  }
  *(_DWORD *)(v4 + 52) = -1;
  __n128 result = *(__n128 *)a3;
  *(_OWORD *)uint64_t v4 = *(_OWORD *)a3;
  *(_DWORD *)(v4 + 52) = 1;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN2gm3BoxIfLi3EEENS8_6SphereIfLi3ENS_9enable_ifILb1EvEEEEN3geo11OrientedBoxIfLj3EffEENSG_IfLj2EffEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSR_OT0_E_JRNS0_6__baseILSN_1EJSA_SE_SH_SI_EEERKSZ_EEEDcSR_DpT0_(__n128 **a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (*a1)[3].n128_u32[1];
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      a2[1] = a3[1];
      a2[2] = a3[2];
      a2[3] = a3[3];
      a2[4] = a3[4];
      result.n128_u32[0] = a3[5];
      a2[5] = result.n128_u32[0];
      return result;
    }
    ((void (*)(char *, __n128 *))off_1EF590E28[v5])(&v7, v4);
  }
  v4[3].n128_u32[1] = -1;
  __n128 result = *(__n128 *)a3;
  v4[1].n128_u64[0] = *((void *)a3 + 2);
  *uint64_t v4 = result;
  v4[3].n128_u32[1] = 0;
  return result;
}

void gdc::ComponentStorageWrapper<std::variant<gm::Box<float,3>,gm::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo::OrientedBox<float,2u,float,float>>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<std::variant<gm::Box<float,3>,gm::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo::OrientedBox<float,2u,float,float>>>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

void *gdc::ComponentStorageWrapper<std::variant<gm::Box<float,3>,gm::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo::OrientedBox<float,2u,float,float>>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((gdc::ComponentStorageSignals *)(a1 + 13));
  uint64_t v2 = a1[10];
  if (v2)
  {
    uint64_t v3 = a1[11];
    uint64_t v4 = (void *)a1[10];
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = v3 - 56;
        uint64_t v6 = *(unsigned int *)(v3 - 4);
        if (v6 != -1) {
          ((void (*)(char *, uint64_t))off_1EF590E28[v6])(&v14, v3 - 56);
        }
        *(_DWORD *)(v3 - 4) = -1;
        v3 -= 56;
      }
      while (v5 != v2);
      uint64_t v4 = (void *)a1[10];
    }
    a1[11] = v2;
    operator delete(v4);
  }
  char v7 = (void *)a1[7];
  if (v7)
  {
    a1[8] = v7;
    operator delete(v7);
  }
  uint64_t v8 = (void *)a1[4];
  if (v8)
  {
    char v9 = (void *)a1[5];
    unint64_t v10 = (void *)a1[4];
    if (v9 != v8)
    {
      do
      {
        uint64_t v12 = *--v9;
        uint64_t v11 = v12;
        void *v9 = 0;
        if (v12) {
          MEMORY[0x1A6239270](v11, 0x1000C40104B78CFLL);
        }
      }
      while (v9 != v8);
      unint64_t v10 = (void *)a1[4];
    }
    a1[5] = v8;
    operator delete(v10);
  }
  return a1;
}

BOOL gdc::ComponentStorageWrapper<gdc::Tiled>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

float gdc::ComponentStorageWrapper<gdc::Tiled>::remove(void *a1, unint64_t a2, __n128 a3)
{
  unint64_t v21 = a2;
  uint64_t v5 = a1[4];
  uint64_t v6 = a1[5];
  unint64_t v4 = a1 + 4;
  if (a2 >> 39 < (v6 - v5) >> 3)
  {
    uint64_t v7 = *(void *)(v5 + 8 * (a2 >> 39));
    if (v7)
    {
      unint64_t v8 = *(unsigned __int16 *)(v7 + 2 * (HIDWORD(a2) & 0x7F));
      uint64_t v10 = a1[7];
      uint64_t v9 = a1[8];
      if (v8 < (v9 - v10) >> 3)
      {
        unint64_t v11 = HIDWORD(a2);
        uint64_t v12 = v10 + 8 * v8;
        if (v12 != v9 && *(_DWORD *)(v12 + 4) == v11)
        {
          uint64_t v14 = a1[10] + 464 * v8;
          geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v4, (void *)v12);
          a3.n128_f32[0] = gdc::Tiled::operator=(v14, (long long *)(a1[11] - 464));
          a1[11] -= 464;
          uint64_t v15 = (void *)a1[28];
          if (v15)
          {
            uint64_t v16 = a1[31];
            while (1)
            {
              v23[0] = &v21;
              v23[1] = 1;
              uint64_t v22 = v16;
              uint64_t v17 = v15[6];
              if (!v17) {
                break;
              }
              (*(void (**)(uint64_t, uint64_t *, void *, __n128))(*(void *)v17 + 48))(v17, &v22, v23, a3);
              uint64_t v15 = (void *)*v15;
              if (!v15) {
                return a3.n128_f32[0];
              }
            }
            std::__throw_bad_function_call[abi:nn180100]();
            a3.n128_f32[0] = gdc::Tiled::operator=(v18, v19);
          }
        }
      }
    }
  }
  return a3.n128_f32[0];
}

float gdc::Tiled::operator=(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v2;
  *(void *)(a1 + 48) = *((void *)a2 + 6);
  *(void *)(a1 + 56) = *((void *)a2 + 7);
  *(void *)(a1 + 64) = *((void *)a2 + 8);
  *(void *)(a1 + 72) = *((void *)a2 + 9);
  *(void *)(a1 + 24) = *((void *)a2 + 3);
  *(void *)(a1 + 32) = *((void *)a2 + 4);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *(void *)(a1 + 80) = *((void *)a2 + 10);
  *(void *)(a1 + 88) = *((void *)a2 + 11);
  *(void *)(a1 + 96) = *((void *)a2 + 12);
  *(void *)(a1 + 104) = *((void *)a2 + 13);
  *(void *)(a1 + 112) = *((void *)a2 + 14);
  *(void *)(a1 + 120) = *((void *)a2 + 15);
  *(void *)(a1 + 128) = *((void *)a2 + 16);
  *(void *)(a1 + 136) = *((void *)a2 + 17);
  *(void *)(a1 + 144) = *((void *)a2 + 18);
  *(void *)(a1 + 152) = *((void *)a2 + 19);
  *(void *)(a1 + 160) = *((void *)a2 + 20);
  *(void *)(a1 + 168) = *((void *)a2 + 21);
  *(void *)(a1 + 176) = *((void *)a2 + 22);
  *(void *)(a1 + 184) = *((void *)a2 + 23);
  *(void *)(a1 + 192) = *((void *)a2 + 24);
  *(void *)(a1 + 200) = *((void *)a2 + 25);
  *(void *)(a1 + 208) = *((void *)a2 + 26);
  *(void *)(a1 + 216) = *((void *)a2 + 27);
  *(void *)(a1 + 224) = *((void *)a2 + 28);
  *(void *)(a1 + 232) = *((void *)a2 + 29);
  *(void *)(a1 + 240) = *((void *)a2 + 30);
  *(void *)(a1 + 248) = *((void *)a2 + 31);
  *(void *)(a1 + 256) = *((void *)a2 + 32);
  *(void *)(a1 + 264) = *((void *)a2 + 33);
  *(void *)(a1 + 272) = *((void *)a2 + 34);
  *(void *)(a1 + 280) = *((void *)a2 + 35);
  *(void *)(a1 + 288) = *((void *)a2 + 36);
  *(void *)(a1 + 296) = *((void *)a2 + 37);
  *(void *)(a1 + 304) = *((void *)a2 + 38);
  *(void *)(a1 + 312) = *((void *)a2 + 39);
  *(void *)(a1 + 320) = *((void *)a2 + 40);
  *(void *)(a1 + 328) = *((void *)a2 + 41);
  *(void *)(a1 + 336) = *((void *)a2 + 42);
  *(void *)(a1 + 344) = *((void *)a2 + 43);
  *(void *)(a1 + 352) = *((void *)a2 + 44);
  *(void *)(a1 + 360) = *((void *)a2 + 45);
  *(void *)(a1 + 368) = *((void *)a2 + 46);
  *(void *)(a1 + 376) = *((void *)a2 + 47);
  *(void *)(a1 + 384) = *((void *)a2 + 48);
  *(void *)(a1 + 392) = *((void *)a2 + 49);
  *(void *)(a1 + 400) = *((void *)a2 + 50);
  *(void *)(a1 + 408) = *((void *)a2 + 51);
  *(void *)(a1 + 416) = *((void *)a2 + 52);
  *(void *)(a1 + 424) = *((void *)a2 + 53);
  *(_OWORD *)(a1 + 432) = a2[27];
  *(_DWORD *)(a1 + 448) = *((_DWORD *)a2 + 112);
  *(_DWORD *)(a1 + 452) = *((_DWORD *)a2 + 113);
  float result = *((float *)a2 + 114);
  *(float *)(a1 + 456) = result;
  return result;
}

void gdc::ComponentStorageWrapper<gdc::Tiled>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<debugComponents::WorldDrawableContainer>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<debugComponents::WorldDrawableContainer>::remove(void *a1, unint64_t a2)
{
  unint64_t v70 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (*(_DWORD *)(v11 + 4) != v10 || v11 == v8) {
    return 0;
  }
  uint64_t v15 = (uint64_t)(a1 + 10);
  uint64_t v14 = a1[10];
  uint64_t v16 = (char **)(v14 + 48 * v7);
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v17 = a1[11];
  if (v16 == (char **)(v17 - 48)) {
    goto LABEL_67;
  }
  uint64_t v67 = v14;
  uint64_t v68 = a1[11];
  unsigned int v69 = v7;
  uint64_t v18 = *(void *)(v17 - 48);
  uint64_t v19 = *(void *)(v17 - 40);
  uint64_t v20 = v19 - v18;
  unint64_t v21 = (v19 - v18) >> 7;
  uint64_t v22 = (uint64_t)v16[2];
  uint64_t v23 = *v16;
  if (v21 > (v22 - (uint64_t)*v16) >> 7)
  {
    if (v23)
    {
      float64x2_t v24 = v16[1];
      float64x2_t v25 = *v16;
      if (v24 != v23)
      {
        do
        {
          unint64_t v26 = v24 - 128;
          uint64_t v27 = *((unsigned int *)v24 - 6);
          if (v27 != -1) {
            ((void (*)(void *, char *))off_1EF590E88[v27])(v72, v24 - 128);
          }
          *((_DWORD *)v24 - 6) = -1;
          v24 -= 128;
        }
        while (v26 != v23);
        float64x2_t v25 = *v16;
        uint64_t v20 = v19 - v18;
      }
      v16[1] = v23;
      operator delete(v25);
      uint64_t v22 = 0;
      *uint64_t v16 = 0;
      v16[1] = 0;
      v16[2] = 0;
    }
    if ((v20 & 0x8000000000000000) == 0)
    {
      uint64_t v42 = v22 >> 6;
      if (v22 >> 6 <= v21) {
        uint64_t v42 = (v19 - v18) >> 7;
      }
      BOOL v43 = (unint64_t)v22 >= 0x7FFFFFFFFFFFFF80;
      unint64_t v44 = 0x1FFFFFFFFFFFFFFLL;
      if (!v43) {
        unint64_t v44 = v42;
      }
      if (!(v44 >> 57))
      {
        unint64_t v45 = v44 << 7;
        int v46 = (char *)operator new(v44 << 7);
        *uint64_t v16 = v46;
        v16[1] = v46;
        v16[2] = &v46[v45];
        if (v18 != v19)
        {
          uint64_t v66 = v16;
          uint64_t v47 = 0;
          do
          {
            uint64_t v49 = v18 + v47;
            __n128 v50 = &v46[v47];
            *__n128 v50 = 0;
            *((_DWORD *)v50 + 26) = -1;
            uint64_t v51 = *(unsigned int *)(v18 + v47 + 104);
            if (v51 != -1)
            {
              ((void (*)(uint64_t *, char *, uint64_t))off_1EF590EA0[v51])(&v71, &v46[v47], v18 + v47);
              *((_DWORD *)v50 + 26) = v51;
            }
            *((_DWORD *)v50 + 28) = *(_DWORD *)(v49 + 112);
            uint64_t v48 = *(void *)(v49 + 116);
            v50[124] = *(unsigned char *)(v49 + 124);
            *(void *)(v50 + 116) = v48;
            v47 += 128;
          }
          while (v18 + v47 != v19);
          v46 += v47;
          uint64_t v16 = v66;
        }
        v16[1] = v46;
        uint64_t v15 = (uint64_t)(a1 + 10);
        goto LABEL_65;
      }
    }
LABEL_73:
    abort();
  }
  float64x2_t v28 = v16[1];
  unint64_t v29 = (v28 - v23) >> 7;
  if (v29 >= v21)
  {
    if (v18 == v19)
    {
LABEL_57:
      uint64_t v59 = v67;
      uint64_t v58 = v68;
      if (v28 != v23)
      {
        do
        {
          double v60 = v28 - 128;
          uint64_t v61 = *((unsigned int *)v28 - 6);
          if (v61 != -1) {
            ((void (*)(void *, char *))off_1EF590E88[v61])(v72, v28 - 128);
          }
          *((_DWORD *)v28 - 6) = -1;
          v28 -= 128;
        }
        while (v60 != v23);
      }
      v16[1] = v23;
      unsigned int v62 = v69;
      goto LABEL_66;
    }
    uint64_t v37 = 0;
    while (1)
    {
      uint64_t v40 = *(unsigned int *)&v23[v37 + 104];
      uint64_t v41 = *(unsigned int *)(v18 + v37 + 104);
      if (v40 != -1) {
        break;
      }
      if (v41 != -1) {
        goto LABEL_30;
      }
LABEL_31:
      unint64_t v38 = &v23[v37];
      v38[112] = *(unsigned char *)(v18 + v37 + 112);
      v38[113] = *(unsigned char *)(v18 + v37 + 113);
      v38[114] = *(unsigned char *)(v18 + v37 + 114);
      v38[115] = *(unsigned char *)(v18 + v37 + 115);
      uint64_t v39 = *(void *)(v18 + v37 + 116);
      v38[124] = *(unsigned char *)(v18 + v37 + 124);
      *(void *)(v38 + 116) = v39;
      v37 += 128;
      if (v18 + v37 == v19)
      {
        v23 += v37;
        float64x2_t v28 = v16[1];
        goto LABEL_57;
      }
    }
    if (v41 == -1)
    {
      ((void (*)(void *, char *))off_1EF590E88[v40])(v72, &v23[v37]);
      *(_DWORD *)&v23[v37 + 104] = -1;
      goto LABEL_31;
    }
LABEL_30:
    v72[0] = &v23[v37];
    ((void (*)(void *, char *))off_1EF590EB8[v41])(v72, &v23[v37]);
    goto LABEL_31;
  }
  uint64_t v30 = v18 + (v29 << 7);
  if (v28 == v23) {
    goto LABEL_51;
  }
  uint64_t v31 = 0;
  unint64_t v32 = v29 << 7;
  do
  {
    uint64_t v35 = *(unsigned int *)&v23[v31 + 104];
    uint64_t v36 = *(unsigned int *)(v18 + v31 + 104);
    if (v35 == -1)
    {
      if (v36 == -1) {
        goto LABEL_23;
      }
LABEL_22:
      v72[0] = &v23[v31];
      ((void (*)(void *, char *))off_1EF590EB8[v36])(v72, &v23[v31]);
      goto LABEL_23;
    }
    if (v36 != -1) {
      goto LABEL_22;
    }
    ((void (*)(void *, char *))off_1EF590E88[v35])(v72, &v23[v31]);
    *(_DWORD *)&v23[v31 + 104] = -1;
LABEL_23:
    uint64_t v33 = &v23[v31];
    v33[112] = *(unsigned char *)(v18 + v31 + 112);
    v33[113] = *(unsigned char *)(v18 + v31 + 113);
    v33[114] = *(unsigned char *)(v18 + v31 + 114);
    v33[115] = *(unsigned char *)(v18 + v31 + 115);
    uint64_t v34 = *(void *)(v18 + v31 + 116);
    v33[124] = *(unsigned char *)(v18 + v31 + 124);
    *(void *)(v33 + 116) = v34;
    v31 += 128;
  }
  while (v32 != v31);
  uint64_t v23 = v16[1];
LABEL_51:
  double v52 = v23;
  if (v30 != v19)
  {
    uint64_t v53 = 0;
    do
    {
      uint64_t v55 = v30 + v53;
      char v56 = &v23[v53];
      *char v56 = 0;
      *((_DWORD *)v56 + 26) = -1;
      uint64_t v57 = *(unsigned int *)(v30 + v53 + 104);
      if (v57 != -1)
      {
        ((void (*)(uint64_t *, char *, uint64_t))off_1EF590EA0[v57])(&v71, &v23[v53], v30 + v53);
        *((_DWORD *)v56 + 26) = v57;
      }
      *((_DWORD *)v56 + 28) = *(_DWORD *)(v55 + 112);
      uint64_t v54 = *(void *)(v55 + 116);
      v56[124] = *(unsigned char *)(v55 + 124);
      *(void *)(v56 + 116) = v54;
      v53 += 128;
    }
    while (v30 + v53 != v19);
    double v52 = &v23[v53];
    uint64_t v15 = (uint64_t)(a1 + 10);
  }
  v16[1] = v52;
LABEL_65:
  uint64_t v58 = v68;
  unsigned int v62 = v69;
  uint64_t v59 = v67;
LABEL_66:
  std::vector<std::pair<std::vector<gm::LineSegment<float,3>>,debugComponents::DisplayOptions>>::__assign_with_size[abi:nn180100]<std::pair<std::vector<gm::LineSegment<float,3>>,debugComponents::DisplayOptions>*,std::pair<std::vector<gm::LineSegment<float,3>>,debugComponents::DisplayOptions>*>((char **)(v59 + 48 * v62 + 24), *(void *)(v58 - 24), *(void *)(v58 - 16), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v58 - 16) - *(void *)(v58 - 24)) >> 3));
  uint64_t v17 = a1[11];
LABEL_67:
  std::vector<debugComponents::WorldDrawableContainer>::__base_destruct_at_end[abi:nn180100](v15, (void **)(v17 - 48));
  float64x2_t v63 = (void *)a1[28];
  if (v63)
  {
    uint64_t v64 = a1[31];
    while (1)
    {
      v72[0] = &v70;
      v72[1] = 1;
      uint64_t v71 = v64;
      uint64_t v65 = v63[6];
      if (!v65) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v65 + 48))(v65, &v71, v72);
      float64x2_t v63 = (void *)*v63;
      if (!v63) {
        return 1;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    goto LABEL_73;
  }
  return 1;
}

void sub_1A25B1750(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  uint64_t v21 = *(unsigned int *)(v17 + 104);
  if (v21 != -1) {
    ((void (*)(char *, uint64_t))off_1EF590E88[v21])(&a17, v17);
  }
  *(_DWORD *)(v17 + 104) = -1;
  *(void *)(v19 + 8) = v18;
  _Unwind_Resume(exception_object);
}

void sub_1A25B178C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  uint64_t v20 = *(unsigned int *)(v18 + 104);
  if (v20 != -1) {
    ((void (*)(char *, uint64_t))off_1EF590E88[v20])(&a17, v18);
  }
  *(_DWORD *)(v18 + 104) = -1;
  *(void *)(a10 + 8) = v17;
  _Unwind_Resume(exception_object);
}

void std::vector<std::pair<std::vector<gm::LineSegment<float,3>>,debugComponents::DisplayOptions>>::__assign_with_size[abi:nn180100]<std::pair<std::vector<gm::LineSegment<float,3>>,debugComponents::DisplayOptions>*,std::pair<std::vector<gm::LineSegment<float,3>>,debugComponents::DisplayOptions>*>(char **a1, uint64_t a2, uint64_t a3, size_t __sz)
{
  uint64_t v5 = a2;
  uint64_t v6 = a1;
  uint64_t v7 = (uint64_t)a1[2];
  uint64_t v8 = *a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((v7 - (uint64_t)*a1) >> 3) < __sz)
  {
    if (v8)
    {
      uint64_t v9 = a1[1];
      unint64_t v10 = *a1;
      if (v9 != v8)
      {
        uint64_t v11 = v6[1];
        do
        {
          uint64_t v13 = (void *)*((void *)v11 - 5);
          v11 -= 40;
          uint64_t v12 = v13;
          if (v13)
          {
            *((void *)v9 - 4) = v12;
            operator delete(v12);
          }
          uint64_t v9 = v11;
        }
        while (v11 != v8);
        unint64_t v10 = *v6;
      }
      v6[1] = v8;
      operator delete(v10);
      uint64_t v7 = 0;
      void *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
    }
    if (__sz > 0x666666666666666) {
      goto LABEL_53;
    }
    unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * (v7 >> 3);
    uint64_t v19 = 2 * v18;
    if (2 * v18 <= __sz) {
      uint64_t v19 = __sz;
    }
    unint64_t v20 = v18 >= 0x333333333333333 ? 0x666666666666666 : v19;
    if (v20 > 0x666666666666666) {
LABEL_53:
    }
      abort();
    uint64_t v21 = 40 * v20;
    uint64_t v8 = (char *)operator new(40 * v20);
    void *v6 = v8;
    v6[1] = v8;
    v6[2] = &v8[v21];
    if (v5 != a3)
    {
      BOOL v43 = v6;
      uint64_t v22 = 0;
      do
      {
        uint64_t v23 = v5 + v22;
        float64x2_t v24 = &v8[v22];
        *(void *)float64x2_t v24 = 0;
        *((void *)v24 + 1) = 0;
        *((void *)v24 + 2) = 0;
        unint64_t v26 = *(unsigned char **)(v5 + v22);
        float64x2_t v25 = *(unsigned char **)(v5 + v22 + 8);
        int64_t v27 = v25 - v26;
        if (v25 != v26)
        {
          if (0xAAAAAAAAAAAAAAABLL * (v27 >> 3) > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          float64x2_t v28 = (char *)operator new(v27);
          *(void *)float64x2_t v24 = v28;
          *((void *)v24 + 1) = v28;
          *((void *)v24 + 2) = &v28[8 * (v27 >> 3)];
          size_t v29 = 24 * ((v27 - 24) / 0x18uLL) + 24;
          memcpy(v28, v26, v29);
          *((void *)v24 + 1) = &v28[v29];
        }
        *((_DWORD *)v24 + 6) = *(_DWORD *)(v23 + 24);
        *(void *)(v24 + 28) = *(void *)(v23 + 28);
        v24[36] = *(unsigned char *)(v23 + 36);
        v22 += 40;
      }
      while (v23 + 40 != a3);
      v8 += v22;
      uint64_t v6 = v43;
    }
LABEL_48:
    v6[1] = v8;
    return;
  }
  uint64_t v14 = a1[1];
  if (0xCCCCCCCCCCCCCCCDLL * ((v14 - v8) >> 3) >= __sz)
  {
    if (a2 != a3)
    {
      do
      {
        if ((char *)v5 != v8) {
          std::vector<gm::LineSegment<float,3>>::__assign_with_size[abi:nn180100]<gm::LineSegment<float,3>*,gm::LineSegment<float,3>*>((uint64_t)v8, *(char **)v5, *(char **)(v5 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 3));
        }
        v8[24] = *(unsigned char *)(v5 + 24);
        v8[25] = *(unsigned char *)(v5 + 25);
        v8[26] = *(unsigned char *)(v5 + 26);
        v8[27] = *(unsigned char *)(v5 + 27);
        uint64_t v17 = *(void *)(v5 + 28);
        v8[36] = *(unsigned char *)(v5 + 36);
        *(void *)(v8 + 28) = v17;
        v5 += 40;
        v8 += 40;
      }
      while (v5 != a3);
      uint64_t v14 = v6[1];
    }
    if (v14 != v8)
    {
      uint64_t v40 = v14;
      do
      {
        uint64_t v42 = (void *)*((void *)v40 - 5);
        v40 -= 40;
        uint64_t v41 = v42;
        if (v42)
        {
          *((void *)v14 - 4) = v41;
          operator delete(v41);
        }
        uint64_t v14 = v40;
      }
      while (v40 != v8);
    }
    goto LABEL_48;
  }
  uint64_t v45 = a2 + 8 * ((v14 - v8) >> 3);
  if (v14 != v8)
  {
    uint64_t v15 = 8 * ((v14 - v8) >> 3);
    do
    {
      if ((char *)v5 != v8) {
        std::vector<gm::LineSegment<float,3>>::__assign_with_size[abi:nn180100]<gm::LineSegment<float,3>*,gm::LineSegment<float,3>*>((uint64_t)v8, *(char **)v5, *(char **)(v5 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 3));
      }
      v8[24] = *(unsigned char *)(v5 + 24);
      v8[25] = *(unsigned char *)(v5 + 25);
      v8[26] = *(unsigned char *)(v5 + 26);
      v8[27] = *(unsigned char *)(v5 + 27);
      uint64_t v16 = *(void *)(v5 + 28);
      v8[36] = *(unsigned char *)(v5 + 36);
      *(void *)(v8 + 28) = v16;
      v5 += 40;
      v8 += 40;
      v15 -= 40;
    }
    while (v15);
    uint64_t v8 = v6[1];
  }
  uint64_t v30 = v8;
  if (v45 != a3)
  {
    unint64_t v44 = v6;
    uint64_t v31 = 0;
    do
    {
      uint64_t v33 = v45 + v31;
      uint64_t v34 = &v8[v31];
      *(void *)uint64_t v34 = 0;
      *((void *)v34 + 1) = 0;
      *((void *)v34 + 2) = 0;
      uint64_t v36 = *(unsigned char **)(v45 + v31);
      uint64_t v35 = *(unsigned char **)(v45 + v31 + 8);
      int64_t v37 = v35 - v36;
      if (v35 != v36)
      {
        if (0xAAAAAAAAAAAAAAABLL * (v37 >> 3) > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        unint64_t v38 = (char *)operator new(v37);
        *(void *)uint64_t v34 = v38;
        *((void *)v34 + 1) = v38;
        *((void *)v34 + 2) = &v38[8 * (v37 >> 3)];
        size_t v39 = 24 * ((v37 - 24) / 0x18uLL) + 24;
        memcpy(v38, v36, v39);
        *((void *)v34 + 1) = &v38[v39];
      }
      *((_DWORD *)v34 + 6) = *(_DWORD *)(v33 + 24);
      uint64_t v32 = *(void *)(v33 + 28);
      v34[36] = *(unsigned char *)(v33 + 36);
      *(void *)(v34 + 28) = v32;
      v31 += 40;
    }
    while (v33 + 40 != a3);
    uint64_t v30 = &v8[v31];
    uint64_t v6 = v44;
  }
  v6[1] = v30;
}

void sub_1A25B1C3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  *(void *)(a10 + 8) = v10;
  _Unwind_Resume(a1);
}

void std::vector<debugComponents::WorldDrawableContainer>::__base_destruct_at_end[abi:nn180100](uint64_t a1, void **a2)
{
  uint64_t v4 = *(void ***)(a1 + 8);
  if (v4 != a2)
  {
    do
    {
      uint64_t v6 = (char *)*(v4 - 3);
      if (v6)
      {
        uint64_t v7 = (char *)*(v4 - 2);
        uint64_t v8 = *(v4 - 3);
        if (v7 != v6)
        {
          uint64_t v9 = (char *)*(v4 - 2);
          do
          {
            uint64_t v11 = (void *)*((void *)v9 - 5);
            v9 -= 40;
            uint64_t v10 = v11;
            if (v11)
            {
              *((void *)v7 - 4) = v10;
              operator delete(v10);
            }
            uint64_t v7 = v9;
          }
          while (v9 != v6);
          uint64_t v8 = *(v4 - 3);
        }
        *(v4 - 2) = v6;
        operator delete(v8);
      }
      uint64_t v12 = v4 - 6;
      uint64_t v13 = (char *)*(v4 - 6);
      if (v13)
      {
        uint64_t v14 = (char *)*(v4 - 5);
        uint64_t v5 = *(v4 - 6);
        if (v14 != v13)
        {
          do
          {
            uint64_t v15 = v14 - 128;
            uint64_t v16 = *((unsigned int *)v14 - 6);
            if (v16 != -1) {
              ((void (*)(char *, char *))off_1EF590E88[v16])(&v17, v14 - 128);
            }
            *((_DWORD *)v14 - 6) = -1;
            v14 -= 128;
          }
          while (v15 != v13);
          uint64_t v5 = *v12;
        }
        *(v4 - 5) = v13;
        operator delete(v5);
      }
      v4 -= 6;
    }
    while (v12 != a2);
  }
  *(void *)(a1 + 8) = a2;
}

void gdc::ComponentStorageWrapper<debugComponents::WorldDrawableContainer>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageWrapper<debugComponents::WorldDrawableContainer>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t gdc::ComponentStorageWrapper<debugComponents::WorldDrawableContainer>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((gdc::ComponentStorageSignals *)(a1 + 104));
  uint64_t v2 = *(void ***)(a1 + 80);
  if (v2)
  {
    std::vector<debugComponents::WorldDrawableContainer>::__base_destruct_at_end[abi:nn180100](a1 + 80, v2);
    operator delete(*(void **)(a1 + 80));
  }
  uint64_t v3 = *(void **)(a1 + 56);
  if (v3)
  {
    *(void *)(a1 + 64) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = *(void **)(a1 + 40);
    uint64_t v6 = *(void **)(a1 + 32);
    if (v5 != v4)
    {
      do
      {
        uint64_t v8 = *--v5;
        uint64_t v7 = v8;
        *uint64_t v5 = 0;
        if (v8) {
          MEMORY[0x1A6239270](v7, 0x1000C40104B78CFLL);
        }
      }
      while (v5 != v4);
      uint64_t v6 = *(void **)(a1 + 32);
    }
    *(void *)(a1 + 40) = v4;
    operator delete(v6);
  }
  return a1;
}

BOOL gdc::ComponentStorageWrapper<std::vector<debugComponents::TiledDrawableContainer>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<std::vector<debugComponents::TiledDrawableContainer>>::remove(void *a1, unint64_t a2)
{
  unint64_t v48 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (*(_DWORD *)(v11 + 4) != v10 || v11 == v8) {
    return 0;
  }
  uint64_t v14 = a1[10];
  uint64_t v15 = (uint64_t *)(v14 + 24 * v7);
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v16 = a1[11];
  if (v15 != (uint64_t *)(v16 - 24))
  {
    uint64_t v17 = *(void *)(v16 - 24);
    uint64_t v18 = *(void *)(v16 - 16);
    unint64_t v19 = (v18 - v17) >> 9;
    uint64_t v20 = v14 + 24 * v7;
    uint64_t v23 = *(void *)(v20 + 16);
    uint64_t v22 = (void *)(v20 + 16);
    uint64_t v21 = v23;
    uint64_t v24 = *v15;
    if (v19 <= (v23 - *v15) >> 9)
    {
      uint64_t v33 = v14 + 24 * v7;
      uint64_t v36 = *(void *)(v33 + 8);
      uint64_t v35 = (uint64_t *)(v33 + 8);
      uint64_t v34 = v36;
      unint64_t v37 = (v36 - v24) >> 9;
      if (v37 >= v19)
      {
        for (; v17 != v18; v24 += 512)
        {
          gdc::Tiled::operator=(v24, (long long *)v17);
          if (v17 != v24)
          {
            std::vector<std::pair<std::variant<gm::Box<float,3>,gm::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo::OrientedBox<float,2u,float,float>>,debugComponents::DisplayOptions>>::__assign_with_size[abi:nn180100]<std::pair<std::variant<gm::Box<float,3>,gm::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo::OrientedBox<float,2u,float,float>>,debugComponents::DisplayOptions>*,std::pair<std::variant<gm::Box<float,3>,gm::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo::OrientedBox<float,2u,float,float>>,debugComponents::DisplayOptions>*>((void **)(v24 + 464), *(void *)(v17 + 464), *(void *)(v17 + 472), 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(v17 + 472) - *(void *)(v17 + 464)) >> 3));
            std::vector<std::pair<std::vector<gm::LineSegment<float,3>>,debugComponents::DisplayOptions>>::__assign_with_size[abi:nn180100]<std::pair<std::vector<gm::LineSegment<float,3>>,debugComponents::DisplayOptions>*,std::pair<std::vector<gm::LineSegment<float,3>>,debugComponents::DisplayOptions>*>((char **)(v24 + 488), *(void *)(v17 + 488), *(void *)(v17 + 496), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v17 + 496) - *(void *)(v17 + 488)) >> 3));
          }
          v17 += 512;
        }
        std::vector<debugComponents::TiledDrawableContainer>::__base_destruct_at_end[abi:nn180100]((uint64_t)v15, v24);
      }
      else
      {
        uint64_t v38 = v17 + (v37 << 9);
        if (v34 != v24)
        {
          unint64_t v39 = v37 << 9;
          do
          {
            gdc::Tiled::operator=(v24, (long long *)v17);
            if (v17 != v24)
            {
              std::vector<std::pair<std::variant<gm::Box<float,3>,gm::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo::OrientedBox<float,2u,float,float>>,debugComponents::DisplayOptions>>::__assign_with_size[abi:nn180100]<std::pair<std::variant<gm::Box<float,3>,gm::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo::OrientedBox<float,2u,float,float>>,debugComponents::DisplayOptions>*,std::pair<std::variant<gm::Box<float,3>,gm::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo::OrientedBox<float,2u,float,float>>,debugComponents::DisplayOptions>*>((void **)(v24 + 464), *(void *)(v17 + 464), *(void *)(v17 + 472), 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(v17 + 472) - *(void *)(v17 + 464)) >> 3));
              std::vector<std::pair<std::vector<gm::LineSegment<float,3>>,debugComponents::DisplayOptions>>::__assign_with_size[abi:nn180100]<std::pair<std::vector<gm::LineSegment<float,3>>,debugComponents::DisplayOptions>*,std::pair<std::vector<gm::LineSegment<float,3>>,debugComponents::DisplayOptions>*>((char **)(v24 + 488), *(void *)(v17 + 488), *(void *)(v17 + 496), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v17 + 496) - *(void *)(v17 + 488)) >> 3));
            }
            v17 += 512;
            v24 += 512;
            v39 -= 512;
          }
          while (v39);
          uint64_t v24 = *v35;
        }
        uint64_t v40 = v24;
        if (v38 != v18)
        {
          uint64_t v41 = 0;
          do
          {
            std::construct_at[abi:nn180100]<debugComponents::TiledDrawableContainer,debugComponents::TiledDrawableContainer&,debugComponents::TiledDrawableContainer*>(v24 + v41, v38 + v41);
            v41 += 512;
          }
          while (v38 + v41 != v18);
          uint64_t v40 = v24 + v41;
        }
        *uint64_t v35 = v40;
      }
    }
    else
    {
      if (v24)
      {
        std::vector<debugComponents::TiledDrawableContainer>::__base_destruct_at_end[abi:nn180100](v14 + 24 * v7, *v15);
        operator delete((void *)*v15);
        uint64_t v21 = 0;
        uint64_t *v15 = 0;
        v15[1] = 0;
        v15[2] = 0;
      }
      if (v18 - v17 < 0) {
        goto LABEL_53;
      }
      uint64_t v25 = v21 >> 8;
      if (v21 >> 8 <= v19) {
        uint64_t v25 = (v18 - v17) >> 9;
      }
      BOOL v26 = (unint64_t)v21 >= 0x7FFFFFFFFFFFFE00;
      unint64_t v27 = 0x7FFFFFFFFFFFFFLL;
      if (!v26) {
        unint64_t v27 = v25;
      }
      if (v27 >> 55) {
        goto LABEL_53;
      }
      unint64_t v28 = v27 << 9;
      size_t v29 = (char *)operator new(v27 << 9);
      uint64_t *v15 = (uint64_t)v29;
      uint64_t v30 = v14 + 24 * v7;
      *(void *)(v30 + 8) = v29;
      uint64_t v31 = (void *)(v30 + 8);
      *uint64_t v22 = &v29[v28];
      if (v17 != v18)
      {
        uint64_t v32 = 0;
        do
        {
          std::construct_at[abi:nn180100]<debugComponents::TiledDrawableContainer,debugComponents::TiledDrawableContainer&,debugComponents::TiledDrawableContainer*>((uint64_t)&v29[v32], v17 + v32);
          v32 += 512;
        }
        while (v17 + v32 != v18);
        v29 += v32;
      }
      *uint64_t v31 = v29;
    }
    uint64_t v16 = a1[11];
  }
  uint64_t v44 = *(void *)(v16 - 24);
  BOOL v43 = (void **)(v16 - 24);
  uint64_t v42 = v44;
  if (v44)
  {
    std::vector<debugComponents::TiledDrawableContainer>::__base_destruct_at_end[abi:nn180100]((uint64_t)v43, v42);
    operator delete(*v43);
  }
  a1[11] = v43;
  uint64_t v45 = (void *)a1[28];
  if (v45)
  {
    uint64_t v46 = a1[31];
    while (1)
    {
      v50[0] = &v48;
      v50[1] = 1;
      uint64_t v49 = v46;
      uint64_t v47 = v45[6];
      if (!v47) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v47 + 48))(v47, &v49, v50);
      uint64_t v45 = (void *)*v45;
      if (!v45) {
        return 1;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
    abort();
  }
  return 1;
}

void sub_1A25B2248(_Unwind_Exception *a1)
{
  *uint64_t v2 = v1;
  _Unwind_Resume(a1);
}

void sub_1A25B2250(_Unwind_Exception *a1)
{
  *uint64_t v2 = v1;
  _Unwind_Resume(a1);
}

void std::vector<debugComponents::TiledDrawableContainer>::__base_destruct_at_end[abi:nn180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 512)
  {
    uint64_t v6 = *(void *)(i - 24);
    if (v6)
    {
      uint64_t v7 = *(void *)(i - 16);
      uint64_t v8 = *(void **)(i - 24);
      if (v7 != v6)
      {
        uint64_t v9 = *(void *)(i - 16);
        do
        {
          uint64_t v11 = *(void **)(v9 - 40);
          v9 -= 40;
          unint64_t v10 = v11;
          if (v11)
          {
            *(void *)(v7 - 32) = v10;
            operator delete(v10);
          }
          uint64_t v7 = v9;
        }
        while (v9 != v6);
        uint64_t v8 = *(void **)(i - 24);
      }
      *(void *)(i - 16) = v6;
      operator delete(v8);
    }
    uint64_t v12 = *(void *)(i - 48);
    if (v12)
    {
      uint64_t v13 = *(void *)(i - 40);
      uint64_t v5 = *(void **)(i - 48);
      if (v13 != v12)
      {
        do
        {
          uint64_t v14 = v13 - 72;
          uint64_t v15 = *(unsigned int *)(v13 - 20);
          if (v15 != -1) {
            ((void (*)(char *, uint64_t))off_1EF590E28[v15])(&v16, v13 - 72);
          }
          *(_DWORD *)(v13 - 20) = -1;
          v13 -= 72;
        }
        while (v14 != v12);
        uint64_t v5 = *(void **)(i - 48);
      }
      *(void *)(i - 40) = v12;
      operator delete(v5);
    }
  }
  *(void *)(a1 + 8) = a2;
}

void **std::vector<std::pair<std::variant<gm::Box<float,3>,gm::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo::OrientedBox<float,2u,float,float>>,debugComponents::DisplayOptions>>::__assign_with_size[abi:nn180100]<std::pair<std::variant<gm::Box<float,3>,gm::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo::OrientedBox<float,2u,float,float>>,debugComponents::DisplayOptions>*,std::pair<std::variant<gm::Box<float,3>,gm::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo::OrientedBox<float,2u,float,float>>,debugComponents::DisplayOptions>*>(void **result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = (uint64_t)result[2];
  uint64_t v9 = (char *)*result;
  if (0x8E38E38E38E38E39 * ((v8 - (uint64_t)*result) >> 3) < a4)
  {
    if (v9)
    {
      unint64_t v10 = (char *)result[1];
      uint64_t v11 = *result;
      if (v10 != v9)
      {
        do
        {
          uint64_t v12 = v10 - 72;
          uint64_t v13 = *((unsigned int *)v10 - 5);
          if (v13 != -1) {
            ((void (*)(char **, char *))off_1EF590E28[v13])(&v45, v10 - 72);
          }
          *((_DWORD *)v10 - 5) = -1;
          v10 -= 72;
        }
        while (v12 != v9);
        uint64_t v11 = *v7;
      }
      v7[1] = v9;
      operator delete(v11);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      _OWORD v7[2] = 0;
    }
    if (a4 > 0x38E38E38E38E38ELL) {
      goto LABEL_57;
    }
    unint64_t v28 = 0x8E38E38E38E38E39 * (v8 >> 3);
    uint64_t v29 = 2 * v28;
    if (2 * v28 <= a4) {
      uint64_t v29 = a4;
    }
    unint64_t v30 = v28 >= 0x1C71C71C71C71C7 ? 0x38E38E38E38E38ELL : v29;
    if (v30 > 0x38E38E38E38E38ELL) {
LABEL_57:
    }
      abort();
    uint64_t v31 = 9 * v30;
    float result = (void **)operator new(72 * v30);
    uint64_t v32 = result;
    *uint64_t v7 = result;
    v7[1] = result;
    _OWORD v7[2] = &result[v31];
    if (a2 != a3)
    {
      unint64_t v33 = 0;
      do
      {
        uint64_t v34 = a2 + v33;
        uint64_t v35 = &v32[v33 / 8];
        *(unsigned char *)uint64_t v35 = 0;
        *((_DWORD *)v35 + 13) = -1;
        uint64_t v36 = *(unsigned int *)(a2 + v33 + 52);
        if (v36 != -1)
        {
          float result = (void **)((uint64_t (*)(char *, void **, unint64_t))off_1EF590E48[v36])(&v46, &v32[v33 / 8], a2 + v33);
          *((_DWORD *)v35 + 13) = v36;
        }
        *((_DWORD *)v35 + 14) = *(_DWORD *)(v34 + 56);
        *(void **)((char *)v35 + 60) = *(void **)(v34 + 60);
        *((unsigned char *)v35 + 68) = *(unsigned char *)(v34 + 68);
        v33 += 72;
      }
      while (a2 + v33 != a3);
      uint64_t v32 = (void **)((char *)v32 + v33);
    }
    v7[1] = v32;
    return result;
  }
  uint64_t v14 = result[1];
  unint64_t v15 = 0x8E38E38E38E38E39 * ((v14 - v9) >> 3);
  if (v15 >= a4)
  {
    if (a2 == a3)
    {
LABEL_48:
      if (v14 != v9)
      {
        do
        {
          BOOL v43 = v14 - 72;
          uint64_t v44 = *((unsigned int *)v14 - 5);
          if (v44 != -1) {
            float result = (void **)((uint64_t (*)(char **, unsigned char *))off_1EF590E28[v44])(&v45, v14 - 72);
          }
          *((_DWORD *)v14 - 5) = -1;
          v14 -= 72;
        }
        while (v43 != v9);
      }
      v7[1] = v9;
      return result;
    }
    uint64_t v23 = 0;
    while (1)
    {
      uint64_t v26 = *(unsigned int *)&v9[v23 + 52];
      uint64_t v27 = *(unsigned int *)(a2 + v23 + 52);
      if (v26 != -1) {
        break;
      }
      if (v27 != -1) {
        goto LABEL_20;
      }
LABEL_21:
      uint64_t v24 = &v9[v23];
      v24[56] = *(unsigned char *)(a2 + v23 + 56);
      v24[57] = *(unsigned char *)(a2 + v23 + 57);
      v24[58] = *(unsigned char *)(a2 + v23 + 58);
      v24[59] = *(unsigned char *)(a2 + v23 + 59);
      uint64_t v25 = *(void *)(a2 + v23 + 60);
      v24[68] = *(unsigned char *)(a2 + v23 + 68);
      *(void *)(v24 + 60) = v25;
      v23 += 72;
      if (a2 + v23 == a3)
      {
        v9 += v23;
        uint64_t v14 = v7[1];
        goto LABEL_48;
      }
    }
    if (v27 == -1)
    {
      float result = (void **)((uint64_t (*)(char **, char *))off_1EF590E28[v26])(&v45, &v9[v23]);
      *(_DWORD *)&v9[v23 + 52] = -1;
      goto LABEL_21;
    }
LABEL_20:
    uint64_t v45 = &v9[v23];
    float result = (void **)((uint64_t (*)(char **, char *))off_1EF590E68[v27])(&v45, &v9[v23]);
    goto LABEL_21;
  }
  uint64_t v16 = a2 + 8 * ((v14 - v9) >> 3);
  if (v14 == v9) {
    goto LABEL_42;
  }
  uint64_t v17 = 0;
  uint64_t v18 = 72 * v15;
  do
  {
    uint64_t v21 = *(unsigned int *)&v9[v17 + 52];
    uint64_t v22 = *(unsigned int *)(a2 + v17 + 52);
    if (v21 == -1)
    {
      if (v22 == -1) {
        goto LABEL_13;
      }
LABEL_12:
      uint64_t v45 = &v9[v17];
      float result = (void **)((uint64_t (*)(char **, char *))off_1EF590E68[v22])(&v45, &v9[v17]);
      goto LABEL_13;
    }
    if (v22 != -1) {
      goto LABEL_12;
    }
    float result = (void **)((uint64_t (*)(char **, char *))off_1EF590E28[v21])(&v45, &v9[v17]);
    *(_DWORD *)&v9[v17 + 52] = -1;
LABEL_13:
    unint64_t v19 = &v9[v17];
    v19[56] = *(unsigned char *)(a2 + v17 + 56);
    v19[57] = *(unsigned char *)(a2 + v17 + 57);
    v19[58] = *(unsigned char *)(a2 + v17 + 58);
    v19[59] = *(unsigned char *)(a2 + v17 + 59);
    uint64_t v20 = *(void *)(a2 + v17 + 60);
    v19[68] = *(unsigned char *)(a2 + v17 + 68);
    *(void *)(v19 + 60) = v20;
    v17 += 72;
  }
  while (v18 != v17);
  uint64_t v9 = (char *)v7[1];
LABEL_42:
  unint64_t v37 = v9;
  if (v16 != a3)
  {
    uint64_t v38 = 0;
    do
    {
      uint64_t v40 = v16 + v38;
      uint64_t v41 = &v9[v38];
      *uint64_t v41 = 0;
      *((_DWORD *)v41 + 13) = -1;
      uint64_t v42 = *(unsigned int *)(v16 + v38 + 52);
      if (v42 != -1)
      {
        float result = (void **)((uint64_t (*)(char *, char *, uint64_t))off_1EF590E48[v42])(&v46, &v9[v38], v16 + v38);
        *((_DWORD *)v41 + 13) = v42;
      }
      *((_DWORD *)v41 + 14) = *(_DWORD *)(v40 + 56);
      uint64_t v39 = *(void *)(v40 + 60);
      v41[68] = *(unsigned char *)(v40 + 68);
      *(void *)(v41 + 60) = v39;
      v38 += 72;
    }
    while (v16 + v38 != a3);
    unint64_t v37 = &v9[v38];
  }
  v7[1] = v37;
  return result;
}

void sub_1A25B27F4(_Unwind_Exception *exception_object, ...)
{
  va_start(va, exception_object);
  uint64_t v5 = *(unsigned int *)(v2 + 52);
  if (v5 != -1) {
    ((void (*)(uint64_t *, uint64_t))off_1EF590E28[v5])((uint64_t *)va, v2);
  }
  *(_DWORD *)(v2 + 52) = -1;
  *(void *)(v1 + 8) = v3;
  _Unwind_Resume(exception_object);
}

void sub_1A25B2830(_Unwind_Exception *exception_object, ...)
{
  va_start(va, exception_object);
  uint64_t v5 = *(unsigned int *)(v3 + 52);
  if (v5 != -1) {
    ((void (*)(uint64_t *, uint64_t))off_1EF590E28[v5])((uint64_t *)va, v3);
  }
  *(_DWORD *)(v3 + 52) = -1;
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(exception_object);
}

uint64_t std::construct_at[abi:nn180100]<debugComponents::TiledDrawableContainer,debugComponents::TiledDrawableContainer&,debugComponents::TiledDrawableContainer*>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  *(_WORD *)a1 = *(_WORD *)a2;
  *(void *)(a1 + 4) = *(void *)(a2 + 4);
  long long v4 = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 24) = v4;
  long long v5 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v5;
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  long long v6 = *(_OWORD *)(a2 + 80);
  long long v7 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 112) = v7;
  *(_OWORD *)(a1 + 80) = v6;
  memcpy((void *)(a1 + 128), (const void *)(a2 + 128), 0x130uLL);
  *(void *)(v3 + 432) = *(void *)(a2 + 432);
  *(void *)(v3 + 440) = *(void *)(a2 + 440);
  uint64_t v8 = *(void *)(a2 + 448);
  *(_DWORD *)(v3 + 456) = *(_DWORD *)(a2 + 456);
  *(void *)(v3 + 448) = v8;
  *(void *)(v3 + 472) = 0;
  *(void *)(v3 + 480) = 0;
  *(void *)(v3 + 464) = 0;
  uint64_t v9 = *(void *)(a2 + 464);
  uint64_t v10 = *(void *)(a2 + 472);
  int64_t v11 = v10 - v9;
  uint64_t v34 = v3;
  if (v10 != v9)
  {
    unint64_t v12 = 0x8E38E38E38E38E39 * (v11 >> 3);
    if (v12 >= 0x38E38E38E38E38FLL) {
      abort();
    }
    uint64_t v13 = (char *)operator new(v11);
    uint64_t v14 = 0;
    *(void *)(v3 + 464) = v13;
    *(void *)(v3 + 472) = v13;
    *(void *)(v3 + 480) = &v13[72 * v12];
    do
    {
      uint64_t v16 = v9 + v14;
      uint64_t v17 = &v13[v14];
      *uint64_t v17 = 0;
      *((_DWORD *)v17 + 13) = -1;
      uint64_t v18 = *(unsigned int *)(v9 + v14 + 52);
      if (v18 != -1)
      {
        ((void (*)(char *, char *, uint64_t))off_1EF590E48[v18])(v35, &v13[v14], v9 + v14);
        *((_DWORD *)v17 + 13) = v18;
      }
      *((_DWORD *)v17 + 14) = *(_DWORD *)(v16 + 56);
      uint64_t v15 = *(void *)(v16 + 60);
      v17[68] = *(unsigned char *)(v16 + 68);
      *(void *)(v17 + 60) = v15;
      v14 += 72;
    }
    while (v9 + v14 != v10);
    uint64_t v3 = v34;
    *(void *)(v34 + 472) = &v13[v14];
  }
  *(void *)(v3 + 488) = 0;
  *(void *)(v3 + 496) = 0;
  *(void *)(v3 + 504) = 0;
  uint64_t v19 = *(void *)(a2 + 488);
  uint64_t v20 = *(void *)(a2 + 496);
  int64_t v21 = v20 - v19;
  if (v20 != v19)
  {
    unint64_t v22 = 0xCCCCCCCCCCCCCCCDLL * (v21 >> 3);
    if (v22 >= 0x666666666666667) {
      abort();
    }
    uint64_t v23 = (char *)operator new(v21);
    uint64_t v24 = 0;
    *(void *)(v3 + 488) = v23;
    *(void *)(v3 + 496) = v23;
    *(void *)(v3 + 504) = &v23[40 * v22];
    do
    {
      uint64_t v28 = v19 + v24;
      uint64_t v29 = &v23[v24];
      *(void *)uint64_t v29 = 0;
      *((void *)v29 + 1) = 0;
      *((void *)v29 + 2) = 0;
      uint64_t v31 = *(unsigned char **)(v19 + v24);
      unint64_t v30 = *(unsigned char **)(v19 + v24 + 8);
      int64_t v32 = v30 - v31;
      if (v30 != v31)
      {
        if (0xAAAAAAAAAAAAAAABLL * (v32 >> 3) >= 0xAAAAAAAAAAAAAABLL) {
          abort();
        }
        uint64_t v25 = (char *)operator new(v32);
        *(void *)uint64_t v29 = v25;
        *((void *)v29 + 1) = v25;
        *((void *)v29 + 2) = &v25[8 * (v32 >> 3)];
        size_t v26 = 24 * ((v32 - 24) / 0x18uLL) + 24;
        memcpy(v25, v31, v26);
        *((void *)v29 + 1) = &v25[v26];
      }
      *((_DWORD *)v29 + 6) = *(_DWORD *)(v28 + 24);
      uint64_t v27 = *(void *)(v28 + 28);
      v29[36] = *(unsigned char *)(v28 + 36);
      *(void *)(v29 + 28) = v27;
      v24 += 40;
    }
    while (v28 + 40 != v20);
    uint64_t v3 = v34;
    *(void *)(v34 + 496) = &v23[v24];
  }
  return v3;
}

void sub_1A25B2B4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13, char a14, char a15, char a16)
{
  uint64_t v17 = *(void *)(a10 + 464);
  if (v17)
  {
    uint64_t v18 = *(void *)(a10 + 472);
    uint64_t v19 = *(void **)(a10 + 464);
    if (v18 != v17)
    {
      do
      {
        uint64_t v20 = v18 - 72;
        uint64_t v21 = *(unsigned int *)(v18 - 20);
        if (v21 != -1) {
          ((void (*)(char *, uint64_t))off_1EF590E28[v21])(&a14, v18 - 72);
        }
        *(_DWORD *)(v18 - 20) = -1;
        v18 -= 72;
      }
      while (v20 != v17);
      uint64_t v19 = *(void **)(a10 + 464);
    }
    *(void *)(a10 + 472) = v17;
    operator delete(v19);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void gdc::ComponentStorageWrapper<std::vector<debugComponents::TiledDrawableContainer>>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((gdc::ComponentStorageSignals *)(a1 + 104));
  geo::sparse_map<gdc::Entity,std::vector<debugComponents::TiledDrawableContainer>>::~sparse_map((void *)(a1 + 32));
  JUMPOUT(0x1A6239270);
}

void *geo::sparse_map<gdc::Entity,std::vector<debugComponents::TiledDrawableContainer>>::~sparse_map(void *a1)
{
  uint64_t v2 = (uint64_t *)a1[6];
  if (v2)
  {
    uint64_t v3 = (uint64_t *)a1[7];
    long long v4 = (void *)a1[6];
    if (v3 != v2)
    {
      long long v5 = v3 - 3;
      do
      {
        if (*v5)
        {
          std::vector<debugComponents::TiledDrawableContainer>::__base_destruct_at_end[abi:nn180100]((uint64_t)v5, *v5);
          operator delete((void *)*v5);
        }
        BOOL v6 = v5 == v2;
        v5 -= 3;
      }
      while (!v6);
      long long v4 = (void *)a1[6];
    }
    a1[7] = v2;
    operator delete(v4);
  }
  long long v7 = (void *)a1[3];
  if (v7)
  {
    a1[4] = v7;
    operator delete(v7);
  }
  uint64_t v8 = (void *)*a1;
  if (*a1)
  {
    uint64_t v9 = (void *)a1[1];
    uint64_t v10 = (void *)*a1;
    if (v9 != v8)
    {
      do
      {
        uint64_t v12 = *--v9;
        uint64_t v11 = v12;
        void *v9 = 0;
        if (v12) {
          MEMORY[0x1A6239270](v11, 0x1000C40104B78CFLL);
        }
      }
      while (v9 != v8);
      uint64_t v10 = (void *)*a1;
    }
    a1[1] = v8;
    operator delete(v10);
  }
  return a1;
}

uint64_t gdc::ComponentStorageWrapper<std::vector<debugComponents::TiledDrawableContainer>>::~ComponentStorageWrapper(uint64_t a1)
{
  return a1;
}

uint64_t md::Logic<md::DebugDrawLogic,md::DebugDrawContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::DebugDrawLogic,md::DebugDrawContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x3619066E3FB5F2CLL && *(void *)(a3 + 32)) {
    return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)result + 160))(result, a2, v4);
  }
  a4[23] = 0;
  *a4 = 0;
  return result;
}

uint64_t gdc::ObjectHolder<md::DebugDrawContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::DebugDrawContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5555C8;
  uint64_t v1 = (md::DebugDrawContext *)a1[4];
  if (v1)
  {
    md::DebugDrawContext::~DebugDrawContext(v1);
    MEMORY[0x1A6239270]();
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::DebugDrawContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5555C8;
  uint64_t v2 = (md::DebugDrawContext *)a1[4];
  if (v2)
  {
    md::DebugDrawContext::~DebugDrawContext(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void md::DebugDrawLogic::~DebugDrawLogic(md::DebugDrawLogic *this)
{
  *(void *)this = &unk_1EF5338D8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;

  *(void *)this = &unk_1EF5338D8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void md::Logic<md::RouteLineLogic,md::RouteLineContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    long long v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      long long v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

uint64_t md::Logic<md::RouteLineLogic,md::RouteLineContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::RouteLineLogic,md::RouteLineContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x8E4587A431F9C696 && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    char v7 = *(uint64_t **)(a2 + 8);
    uint64_t v8 = *v7;
    unint64_t v9 = v7[1];
    md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>::buildRequiredTuple<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>(v15, *v7, v9);
    uint64_t v10 = md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>::buildOptionalTuple<md::PuckContext,md::RouteOverlayContext>(v8, v9);
    v12[0] = v15[0];
    v12[1] = v15[1];
    uint64_t v13 = v10;
    uint64_t v14 = v11;
    return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)v6 + 160))(v6, a2, v12, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

void md::RouteLineContext::~RouteLineContext(md::RouteLineContext *this)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 7));
  uint64_t v2 = (void *)*((void *)this + 3);
  while (v2)
  {
    uint64_t v3 = v2;
    uint64_t v2 = (void *)*v2;
    uint64_t v4 = (std::__shared_weak_count *)v3[6];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    operator delete(v3);
  }
  long long v5 = (void *)*((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v5) {
    operator delete(v5);
  }
}

uint64_t gdc::ObjectHolder<md::RouteLineContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::RouteLineContext>::~ManagedObjectHolder(void *a1)
{
  gdc::ManagedObjectHolder<md::RouteLineContext>::~ManagedObjectHolder(a1);
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::RouteLineContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555640;
  uint64_t v2 = a1[4];
  if (v2)
  {
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v2 + 56));
    uint64_t v3 = *(void **)(v2 + 24);
    while (v3)
    {
      uint64_t v4 = v3;
      uint64_t v3 = (void *)*v3;
      long long v5 = (std::__shared_weak_count *)v4[6];
      if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
      operator delete(v4);
    }
    uint64_t v6 = *(void **)(v2 + 8);
    *(void *)(v2 + 8) = 0;
    if (v6) {
      operator delete(v6);
    }
    MEMORY[0x1A6239270](v2, 0x10A0C408B8AFFAALL);
  }
  return a1;
}

void md::RouteLineLogic::~RouteLineLogic(md::RouteLineLogic *this)
{
  md::RouteLineLogic::~RouteLineLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  std::__shared_weak_count *v4;
  void *v5;

  *(void *)this = &unk_1EF5344E0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 24));
  uint64_t v2 = (void *)*((void *)this + 20);
  while (v2)
  {
    uint64_t v3 = v2;
    uint64_t v2 = (void *)*v2;
    uint64_t v4 = (std::__shared_weak_count *)v3[6];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    operator delete(v3);
  }
  long long v5 = (void *)*((void *)this + 18);
  *((void *)this + 18) = 0;
  if (v5) {
    operator delete(v5);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

float md::ARContext::planeHeight(md::ARContext *this)
{
  uint64_t v2 = +[VKDebugSettings sharedSettings];
  int v3 = [v2 arOverrideDefaults];

  if (!v3) {
    return *((float *)this + 2);
  }
  uint64_t v4 = +[VKDebugSettings sharedSettings];
  [v4 arVirtualPlaneHeight];
  float v6 = v5;

  return v6;
}

void sub_1A25B3608(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::MuninJunction::~MuninJunction(md::MuninJunction *this)
{
  *(void *)this = &unk_1EF5328C0;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;

  *(void *)this = &unk_1EF5328C0;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    operator delete(v2);
  }
}

void md::MuninJunction::addRoad(md::MuninJunction *this, const md::MuninRoadEdge *a2)
{
  float v5 = (char *)*((void *)this + 6);
  unint64_t v4 = *((void *)this + 7);
  float v6 = v5;
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v8 = (char *)*((void *)this + 5);
    uint64_t v9 = (v5 - v8) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      goto LABEL_63;
    }
    uint64_t v11 = v4 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v13 = operator new(8 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    uint64_t v15 = &v13[8 * v12];
    *uint64_t v14 = a2;
    char v7 = (char *)(v14 + 1);
    if (v5 == v8)
    {
      uint64_t v8 = v5;
    }
    else
    {
      unint64_t v16 = v5 - v8 - 8;
      if (v16 < 0x58) {
        goto LABEL_67;
      }
      if ((unint64_t)(v8 - v13) < 0x20) {
        goto LABEL_67;
      }
      uint64_t v17 = (v16 >> 3) + 1;
      float v6 = &v5[-8 * (v17 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v18 = &v13[8 * v9 - 16];
      uint64_t v19 = v5 - 16;
      uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v21 = *(_OWORD *)v19;
        *(v18 - 1) = *((_OWORD *)v19 - 1);
        *uint64_t v18 = v21;
        v18 -= 2;
        v19 -= 32;
        v20 -= 4;
      }
      while (v20);
      v14 -= v17 & 0x3FFFFFFFFFFFFFFCLL;
      if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_67:
        do
        {
          uint64_t v22 = *((void *)v6 - 1);
          v6 -= 8;
          *--uint64_t v14 = v22;
        }
        while (v6 != v8);
        uint64_t v8 = (char *)*((void *)this + 5);
      }
    }
    *((void *)this + 5) = v14;
    *((void *)this + 6) = v7;
    *((void *)this + 7) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *(void *)float v5 = a2;
    char v7 = v5 + 8;
  }
  *((void *)this + 6) = v7;
  *((unsigned char *)this + 68) += *((unsigned char *)a2 + 112);
  uint64_t v23 = (char *)*((void *)this + 5);
  int64_t v24 = v7 - v23;
  if (v7 == v23)
  {
    uint64_t v25 = 0;
    size_t v26 = 0;
    goto LABEL_34;
  }
  if (v24 < 0) {
LABEL_63:
  }
    abort();
  uint64_t v25 = (int64x2_t *)operator new(v7 - v23);
  bzero(v25, v7 - v23);
  size_t v26 = (uint64_t *)((char *)v25->i64 + v24);
  if ((unint64_t)(v24 - 8) >= 0x18)
  {
    unint64_t v29 = ((unint64_t)(v24 - 8) >> 3) + 1;
    uint64_t v27 = v29 & 0x3FFFFFFFFFFFFFFCLL;
    int64x2_t v30 = (int64x2_t)xmmword_1A28FC760;
    uint64_t v31 = v25 + 1;
    int64x2_t v32 = vdupq_n_s64(2uLL);
    int64x2_t v33 = vdupq_n_s64(4uLL);
    uint64_t v34 = v29 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v31[-1] = v30;
      *uint64_t v31 = vaddq_s64(v30, v32);
      int64x2_t v30 = vaddq_s64(v30, v33);
      v31 += 2;
      v34 -= 4;
    }
    while (v34);
    if (v29 == v27) {
      goto LABEL_34;
    }
    uint64_t v28 = &v25->i64[v29 & 0x3FFFFFFFFFFFFFFCLL];
  }
  else
  {
    uint64_t v27 = 0;
    uint64_t v28 = (uint64_t *)v25;
  }
  do
    *v28++ = v27++;
  while (v28 != v26);
LABEL_34:
  uint64_t v51 = this;
  unint64_t v35 = 126 - 2 * __clz(((char *)v26 - (char *)v25) >> 3);
  if (v7 == v23) {
    uint64_t v36 = 0;
  }
  else {
    uint64_t v36 = v35;
  }
  std::__introsort<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *,false>(v25->i64, v26, (uint64_t *)&v51, v36, 1);
  *((unsigned char *)this + 69) = 0;
  if (v26 != (uint64_t *)v25)
  {
    int v37 = 0;
    uint64_t v38 = 0;
    uint64_t v39 = *((void *)this + 5);
    uint64_t v40 = (uint64_t *)v25;
    while (1)
    {
      uint64_t v41 = *(void *)(v39 + 8 * *v40);
      if (!*(unsigned char *)(v41 + 112)) {
        goto LABEL_58;
      }
      if (!v38) {
        goto LABEL_40;
      }
      uint64_t v42 = *(unsigned __int8 *)(v41 + 39);
      if ((v42 & 0x80u) == 0) {
        uint64_t v43 = *(unsigned __int8 *)(v41 + 39);
      }
      else {
        uint64_t v43 = *(void *)(v41 + 24);
      }
      uint64_t v44 = *(unsigned __int8 *)(v38 + 39);
      int v45 = (char)v44;
      if ((v44 & 0x80u) != 0) {
        uint64_t v44 = *(void *)(v38 + 24);
      }
      if (v43 != v44) {
        goto LABEL_40;
      }
      char v46 = (const void **)(v41 + 16);
      uint64_t v49 = *(void *)(v38 + 16);
      uint64_t v47 = v38 + 16;
      uint64_t v48 = v49;
      __n128 v50 = (unsigned __int8 *)(v45 >= 0 ? v47 : v48);
      if ((v42 & 0x80) == 0) {
        break;
      }
      if (memcmp(*v46, v50, *(void *)(v41 + 24))) {
        goto LABEL_40;
      }
LABEL_41:
      ++v40;
      uint64_t v38 = v41;
      if (v40 == v26) {
        goto LABEL_58;
      }
    }
    if (!*(unsigned char *)(v41 + 39)) {
      goto LABEL_41;
    }
    while (*(unsigned __int8 *)v46 == *v50)
    {
      char v46 = (const void **)((char *)v46 + 1);
      ++v50;
      if (!--v42) {
        goto LABEL_41;
      }
    }
LABEL_40:
    *((unsigned char *)this + 69) = ++v37;
    goto LABEL_41;
  }
LABEL_58:
  if (v25)
  {
    operator delete(v25);
  }
}

uint64_t *std::__introsort<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *,false>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t v8 = (uint64_t)a3;
  unint64_t v401 = result;
LABEL_2:
  uint64_t v9 = a2;
  unint64_t k = v401;
  uint64_t v393 = a2 - 1;
  while (1)
  {
    uint64_t v11 = k;
    uint64_t v12 = (char *)v9 - (char *)k;
    uint64_t v13 = v9 - k;
    unint64_t v401 = v11;
    if (v6 || !v5)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v170 = *v393;
          uint64_t v171 = *(void *)(*(void *)v8 + 40);
          uint64_t v172 = *(void *)(v171 + 8 * *v393);
          uint64_t v173 = *v11;
          uint64_t v174 = *(void *)(v171 + 8 * *v11);
          if ((*(unsigned char *)(v172 + 112) != 0) != (*(unsigned char *)(v174 + 112) != 0))
          {
            if (!*(unsigned char *)(v172 + 112)) {
              return result;
            }
          }
          else
          {
            float32x4_t v344 = *(const void **)(v172 + 16);
            uint64_t v342 = v172 + 16;
            unint64_t v343 = v344;
            int v345 = *(char *)(v342 + 23);
            if (v345 >= 0) {
              float64x2_t v346 = (const void *)v342;
            }
            else {
              float64x2_t v346 = v343;
            }
            if (v345 >= 0) {
              size_t v347 = *(unsigned __int8 *)(v342 + 23);
            }
            else {
              size_t v347 = *(void *)(v342 + 8);
            }
            float64x2_t v350 = *(const void **)(v174 + 16);
            uint64_t v348 = v174 + 16;
            float64x2_t v349 = v350;
            int v351 = *(char *)(v348 + 23);
            if (v351 >= 0) {
              uint64_t v352 = (const void *)v348;
            }
            else {
              uint64_t v352 = v349;
            }
            if (v351 >= 0) {
              size_t v353 = *(unsigned __int8 *)(v348 + 23);
            }
            else {
              size_t v353 = *(void *)(v348 + 8);
            }
            if (v353 >= v347) {
              size_t v354 = v347;
            }
            else {
              size_t v354 = v353;
            }
            float result = (uint64_t *)memcmp(v346, v352, v354);
            if (result)
            {
              if ((result & 0x80000000) == 0) {
                return result;
              }
            }
            else if (v347 >= v353)
            {
              return result;
            }
          }
          *unint64_t v401 = v170;
          uint64_t *v393 = v173;
          break;
        case 3:
          uint64_t v175 = *(void *)(*(void *)v8 + 40);
          return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(v11, v11 + 1, v393, v175);
        case 4:
          return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(v11, v11 + 1, v11 + 2, v393, v8);
        case 5:
          return std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *,0>(v11, v11 + 1, v11 + 2, v11 + 3, v393, v8);
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 191) {
      break;
    }
    if (!a4)
    {
      if (v11 == v9) {
        return result;
      }
      int64_t v213 = (unint64_t)(v13 - 2) >> 1;
      uint64_t v388 = *(void *)v8;
      int64_t v214 = v213;
      while (1)
      {
        int64_t v216 = v214;
        if (v213 < v214) {
          goto LABEL_390;
        }
        uint64_t v217 = (2 * v214) | 1;
        unint64_t v215 = &v401[v217];
        uint64_t v218 = 2 * v214 + 2;
        uint64_t v219 = *(void *)(v388 + 40);
        uint64_t v403 = v219;
        if (v218 < v13)
        {
          uint64_t v220 = *(void *)(v219 + 8 * *v215);
          uint64_t v221 = *(void *)(v219 + 8 * v215[1]);
          if ((*(unsigned char *)(v220 + 112) != 0) != (*(unsigned char *)(v221 + 112) != 0))
          {
            if (!*(unsigned char *)(v220 + 112)) {
              goto LABEL_396;
            }
LABEL_395:
            ++v215;
            uint64_t v217 = v218;
            goto LABEL_396;
          }
          int64_t v236 = v216;
          uint8x8_t v239 = *(const void **)(v220 + 16);
          uint64_t v237 = v220 + 16;
          unint64_t v238 = v239;
          int v240 = *(char *)(v237 + 23);
          if (v240 >= 0) {
            uint64_t v241 = (const void *)v237;
          }
          else {
            uint64_t v241 = v238;
          }
          if (v240 >= 0) {
            size_t v242 = *(unsigned __int8 *)(v237 + 23);
          }
          else {
            size_t v242 = *(void *)(v237 + 8);
          }
          uint64_t v245 = *(const void **)(v221 + 16);
          uint64_t v243 = v221 + 16;
          unint64_t v244 = v245;
          int v246 = *(char *)(v243 + 23);
          if (v246 >= 0) {
            float64x2_t v247 = (const void *)v243;
          }
          else {
            float64x2_t v247 = v244;
          }
          if (v246 >= 0) {
            size_t v248 = *(unsigned __int8 *)(v243 + 23);
          }
          else {
            size_t v248 = *(void *)(v243 + 8);
          }
          if (v248 >= v242) {
            size_t v249 = v242;
          }
          else {
            size_t v249 = v248;
          }
          float result = (uint64_t *)memcmp(v241, v247, v249);
          if (result)
          {
            int64_t v216 = v236;
            uint64_t v219 = v403;
            if ((result & 0x80000000) != 0) {
              goto LABEL_395;
            }
          }
          else
          {
            int64_t v216 = v236;
            uint64_t v219 = v403;
            if (v242 < v248) {
              goto LABEL_395;
            }
          }
        }
LABEL_396:
        uint64_t v222 = *v215;
        uint64_t v223 = *(void *)(v219 + 8 * *v215);
        uint64_t v224 = *(void *)(v219 + 8 * v401[v216]);
        int v407 = *(unsigned __int8 *)(v224 + 112);
        uint64_t v390 = v401[v216];
        if ((*(unsigned char *)(v223 + 112) != 0) != (*(unsigned char *)(v224 + 112) != 0))
        {
          if (!*(unsigned char *)(v223 + 112)) {
            goto LABEL_436;
          }
        }
        else
        {
          int64_t v225 = v216;
          float32x2_t v228 = *(const void **)(v223 + 16);
          uint64_t v226 = v223 + 16;
          unint64_t v227 = v228;
          int v229 = *(char *)(v226 + 23);
          if (v229 >= 0) {
            unint64_t v230 = (const void *)v226;
          }
          else {
            unint64_t v230 = v227;
          }
          if (v229 >= 0) {
            size_t v231 = *(unsigned __int8 *)(v226 + 23);
          }
          else {
            size_t v231 = *(void *)(v226 + 8);
          }
          int v232 = *(char *)(v224 + 39);
          if (v232 >= 0) {
            float64x2_t v233 = (const void *)(v224 + 16);
          }
          else {
            float64x2_t v233 = *(const void **)(v224 + 16);
          }
          if (v232 >= 0) {
            size_t v234 = *(unsigned __int8 *)(v224 + 39);
          }
          else {
            size_t v234 = *(void *)(v224 + 24);
          }
          if (v234 >= v231) {
            size_t v235 = v231;
          }
          else {
            size_t v235 = v234;
          }
          float result = (uint64_t *)memcmp(v230, v233, v235);
          if (result)
          {
            int64_t v216 = v225;
            uint64_t v219 = v403;
            if ((result & 0x80000000) == 0) {
              goto LABEL_436;
            }
          }
          else
          {
            int64_t v216 = v225;
            uint64_t v219 = v403;
            if (v231 >= v234)
            {
LABEL_436:
              int64_t v386 = v216;
              v401[v216] = v222;
              if (v213 >= v217)
              {
                uint64_t v395 = *a3;
                while (1)
                {
                  uint64_t v250 = v215;
                  uint64_t v251 = 2 * v217;
                  uint64_t v217 = (2 * v217) | 1;
                  unint64_t v215 = &v401[v217];
                  uint64_t v252 = v251 + 2;
                  if (v251 + 2 >= v13) {
                    goto LABEL_444;
                  }
                  uint64_t v253 = *(void *)(v395 + 40);
                  uint64_t v254 = *(void *)(v253 + 8 * *v215);
                  uint64_t v255 = *(void *)(v253 + 8 * v215[1]);
                  if ((*(unsigned char *)(v254 + 112) != 0) != (*(unsigned char *)(v255 + 112) != 0)) {
                    break;
                  }
                  unint64_t v270 = *(const void **)(v254 + 16);
                  uint64_t v268 = v254 + 16;
                  unint64_t v269 = v270;
                  int v271 = *(char *)(v268 + 23);
                  if (v271 >= 0) {
                    double v272 = (const void *)v268;
                  }
                  else {
                    double v272 = v269;
                  }
                  if (v271 >= 0) {
                    size_t v273 = *(unsigned __int8 *)(v268 + 23);
                  }
                  else {
                    size_t v273 = *(void *)(v268 + 8);
                  }
                  double v276 = *(const void **)(v255 + 16);
                  uint64_t v274 = v255 + 16;
                  float64x2_t v275 = v276;
                  int v277 = *(char *)(v274 + 23);
                  if (v277 >= 0) {
                    float64x2_t v278 = (const void *)v274;
                  }
                  else {
                    float64x2_t v278 = v275;
                  }
                  if (v277 >= 0) {
                    size_t v279 = *(unsigned __int8 *)(v274 + 23);
                  }
                  else {
                    size_t v279 = *(void *)(v274 + 8);
                  }
                  if (v279 >= v273) {
                    size_t v280 = v273;
                  }
                  else {
                    size_t v280 = v279;
                  }
                  float result = (uint64_t *)memcmp(v272, v278, v280);
                  if (result)
                  {
                    int64_t v213 = (unint64_t)(v13 - 2) >> 1;
                    uint64_t v219 = v403;
                    if ((result & 0x80000000) != 0) {
                      goto LABEL_443;
                    }
                  }
                  else
                  {
                    BOOL v5 = v273 >= v279;
                    int64_t v213 = (unint64_t)(v13 - 2) >> 1;
                    uint64_t v219 = v403;
                    if (!v5) {
                      goto LABEL_443;
                    }
                  }
LABEL_444:
                  uint64_t v256 = *v215;
                  uint64_t v257 = *(void *)(v219 + 8 * *v215);
                  if ((*(unsigned char *)(v257 + 112) != 0) != (v407 != 0))
                  {
                    if (*(unsigned char *)(v257 + 112)) {
                      goto LABEL_388;
                    }
                  }
                  else
                  {
                    unint64_t v260 = *(const void **)(v257 + 16);
                    uint64_t v258 = v257 + 16;
                    double v259 = v260;
                    int v261 = *(char *)(v258 + 23);
                    if (v261 >= 0) {
                      double v262 = (const void *)v258;
                    }
                    else {
                      double v262 = v259;
                    }
                    if (v261 >= 0) {
                      size_t v263 = *(unsigned __int8 *)(v258 + 23);
                    }
                    else {
                      size_t v263 = *(void *)(v258 + 8);
                    }
                    char v264 = *(unsigned char *)(v224 + 39);
                    if (v264 >= 0) {
                      unint64_t v265 = (const void *)(v224 + 16);
                    }
                    else {
                      unint64_t v265 = *(const void **)(v224 + 16);
                    }
                    if (v264 >= 0) {
                      size_t v266 = *(unsigned __int8 *)(v224 + 39);
                    }
                    else {
                      size_t v266 = *(void *)(v224 + 24);
                    }
                    if (v266 >= v263) {
                      size_t v267 = v263;
                    }
                    else {
                      size_t v267 = v266;
                    }
                    float result = (uint64_t *)memcmp(v262, v265, v267);
                    if (result)
                    {
                      int64_t v213 = (unint64_t)(v13 - 2) >> 1;
                      uint64_t v219 = v403;
                      if ((result & 0x80000000) != 0) {
                        goto LABEL_388;
                      }
                    }
                    else
                    {
                      BOOL v5 = v263 >= v266;
                      int64_t v213 = (unint64_t)(v13 - 2) >> 1;
                      uint64_t v219 = v403;
                      if (!v5)
                      {
LABEL_388:
                        unint64_t v215 = v250;
                        goto LABEL_389;
                      }
                    }
                  }
                  *uint64_t v250 = v256;
                  if (v213 < v217) {
                    goto LABEL_389;
                  }
                }
                if (!*(unsigned char *)(v254 + 112)) {
                  goto LABEL_444;
                }
LABEL_443:
                ++v215;
                uint64_t v217 = v252;
                goto LABEL_444;
              }
LABEL_389:
              *unint64_t v215 = v390;
              int64_t v216 = v386;
            }
          }
        }
LABEL_390:
        int64_t v214 = v216 - 1;
        if (!v216)
        {
          uint64_t v281 = (unint64_t)v12 >> 3;
          unint64_t v282 = a3;
          uint64_t v396 = *a3;
          while (1)
          {
            uint64_t v285 = 0;
            uint64_t v286 = v401;
            uint64_t v408 = *v401;
            uint64_t v287 = *v282;
            do
            {
              unint64_t v288 = v286;
              v286 += v285 + 1;
              uint64_t v289 = 2 * v285;
              uint64_t v285 = (2 * v285) | 1;
              uint64_t v290 = v289 + 2;
              if (v289 + 2 < v281)
              {
                uint64_t v291 = *(void *)(v287 + 40);
                uint64_t v292 = *(void *)(v291 + 8 * *v286);
                uint64_t v293 = *(void *)(v291 + 8 * v286[1]);
                if ((*(unsigned char *)(v292 + 112) != 0) != (*(unsigned char *)(v293 + 112) != 0))
                {
                  if (!*(unsigned char *)(v292 + 112)) {
                    goto LABEL_495;
                  }
LABEL_494:
                  ++v286;
                  uint64_t v285 = v290;
                  goto LABEL_495;
                }
                unint64_t v296 = *(const void **)(v292 + 16);
                uint64_t v294 = v292 + 16;
                double v295 = v296;
                int v297 = *(char *)(v294 + 23);
                if (v297 >= 0) {
                  unint64_t v298 = (const void *)v294;
                }
                else {
                  unint64_t v298 = v295;
                }
                if (v297 >= 0) {
                  size_t v299 = *(unsigned __int8 *)(v294 + 23);
                }
                else {
                  size_t v299 = *(void *)(v294 + 8);
                }
                unint64_t v302 = *(const void **)(v293 + 16);
                uint64_t v300 = v293 + 16;
                double v301 = v302;
                int v303 = *(char *)(v300 + 23);
                if (v303 >= 0) {
                  unint64_t v304 = (const void *)v300;
                }
                else {
                  unint64_t v304 = v301;
                }
                if (v303 >= 0) {
                  size_t v305 = *(unsigned __int8 *)(v300 + 23);
                }
                else {
                  size_t v305 = *(void *)(v300 + 8);
                }
                if (v305 >= v299) {
                  size_t v306 = v299;
                }
                else {
                  size_t v306 = v305;
                }
                float result = (uint64_t *)memcmp(v298, v304, v306);
                if (result)
                {
                  if ((result & 0x80000000) != 0) {
                    goto LABEL_494;
                  }
                }
                else if (v299 < v305)
                {
                  goto LABEL_494;
                }
              }
LABEL_495:
              *unint64_t v288 = *v286;
            }
            while (v285 <= (uint64_t)((unint64_t)(v281 - 2) >> 1));
            unint64_t v307 = a2 - 1;
            BOOL v6 = v286 == --a2;
            if (v6)
            {
              uint64_t v283 = v408;
              goto LABEL_490;
            }
            *uint64_t v286 = *v307;
            *unint64_t v307 = v408;
            uint64_t v308 = (char *)v286 - (char *)v401 + 8;
            if (v308 < 9) {
              goto LABEL_491;
            }
            unint64_t v309 = ((unint64_t)v308 >> 3) - 2;
            unint64_t v310 = v309 >> 1;
            uint64_t v311 = &v401[v309 >> 1];
            uint64_t v312 = *v311;
            uint64_t v313 = *(void *)(v396 + 40);
            uint64_t v314 = *(void *)(v313 + 8 * *v311);
            uint64_t v399 = *v286;
            uint64_t v315 = *(void *)(v313 + 8 * *v286);
            uint64_t v316 = *(unsigned __int8 *)(v315 + 112);
            uint64_t v409 = v315;
            if ((*(unsigned char *)(v314 + 112) != 0) == (*(unsigned char *)(v315 + 112) != 0))
            {
              BOOL v319 = *(const void **)(v314 + 16);
              uint64_t v317 = v314 + 16;
              uint64_t v318 = v319;
              int v320 = *(char *)(v317 + 23);
              if (v320 >= 0) {
                unint64_t v321 = (const void *)v317;
              }
              else {
                unint64_t v321 = v318;
              }
              if (v320 >= 0) {
                size_t v322 = *(unsigned __int8 *)(v317 + 23);
              }
              else {
                size_t v322 = *(void *)(v317 + 8);
              }
              int v323 = *(char *)(v315 + 39);
              if (v323 >= 0) {
                unint64_t v324 = (const void *)(v315 + 16);
              }
              else {
                unint64_t v324 = *(const void **)(v315 + 16);
              }
              if (v323 >= 0) {
                size_t v325 = *(unsigned __int8 *)(v315 + 39);
              }
              else {
                size_t v325 = *(void *)(v315 + 24);
              }
              if (v325 >= v322) {
                size_t v326 = v322;
              }
              else {
                size_t v326 = v325;
              }
              float result = (uint64_t *)memcmp(v321, v324, v326);
              if (result)
              {
                uint64_t v315 = v409;
                if ((result & 0x80000000) == 0) {
                  goto LABEL_491;
                }
              }
              else
              {
                uint64_t v315 = v409;
                if (v322 >= v325) {
                  goto LABEL_491;
                }
              }
LABEL_542:
              *uint64_t v286 = v312;
              if (v309 >= 2)
              {
                BOOL v404 = (const void *)(v315 + 16);
                while (1)
                {
                  unint64_t v327 = v310 - 1;
                  unint64_t v310 = (v310 - 1) >> 1;
                  uint64_t v286 = &v401[v310];
                  uint64_t v328 = *v286;
                  uint64_t v329 = *(void *)(v313 + 8 * *v286);
                  if ((*(unsigned char *)(v329 + 112) != 0) != (v316 != 0))
                  {
                    if (!*(unsigned char *)(v329 + 112)) {
                      break;
                    }
                  }
                  else
                  {
                    uint64_t v330 = v313;
                    uint64_t v331 = v316;
                    float64x2_t v334 = *(const void **)(v329 + 16);
                    uint64_t v332 = v329 + 16;
                    unint64_t v333 = v334;
                    int v335 = *(char *)(v332 + 23);
                    if (v335 >= 0) {
                      unint64_t v336 = (const void *)v332;
                    }
                    else {
                      unint64_t v336 = v333;
                    }
                    if (v335 >= 0) {
                      size_t v337 = *(unsigned __int8 *)(v332 + 23);
                    }
                    else {
                      size_t v337 = *(void *)(v332 + 8);
                    }
                    char v338 = *(unsigned char *)(v315 + 39);
                    if (v338 >= 0) {
                      unint64_t v339 = v404;
                    }
                    else {
                      unint64_t v339 = *(const void **)(v315 + 16);
                    }
                    if (v338 >= 0) {
                      size_t v340 = *(unsigned __int8 *)(v315 + 39);
                    }
                    else {
                      size_t v340 = *(void *)(v315 + 24);
                    }
                    if (v340 >= v337) {
                      size_t v341 = v337;
                    }
                    else {
                      size_t v341 = v340;
                    }
                    float result = (uint64_t *)memcmp(v336, v339, v341);
                    if (result)
                    {
                      uint64_t v316 = v331;
                      uint64_t v313 = v330;
                      uint64_t v315 = v409;
                      if ((result & 0x80000000) == 0) {
                        break;
                      }
                    }
                    else
                    {
                      BOOL v5 = v337 >= v340;
                      uint64_t v316 = v331;
                      uint64_t v313 = v330;
                      uint64_t v315 = v409;
                      if (v5) {
                        break;
                      }
                    }
                  }
                  uint64_t *v311 = v328;
                  uint64_t v311 = &v401[v310];
                  if (v327 <= 1) {
                    goto LABEL_544;
                  }
                }
              }
              uint64_t v286 = v311;
LABEL_544:
              uint64_t v283 = v399;
LABEL_490:
              *uint64_t v286 = v283;
              goto LABEL_491;
            }
            if (*(unsigned char *)(v314 + 112)) {
              goto LABEL_542;
            }
LABEL_491:
            BOOL v284 = v281-- <= 2;
            unint64_t v282 = a3;
            if (v284) {
              return result;
            }
          }
        }
      }
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    uint64_t v15 = &v11[(unint64_t)v13 >> 1];
    uint64_t v16 = *(void *)(*(void *)v8 + 40);
    if ((unint64_t)v12 < 0x401)
    {
      float result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(v15, v11, v393, v16);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(v11, v15, v393, v16);
      uint64_t v17 = v14;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(v11 + 1, &v11[v17 - 1], a2 - 2, *(void *)(*(void *)v8 + 40));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(v11 + 2, &v11[v17 + 1], a2 - 3, *(void *)(*(void *)v8 + 40));
      float result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(&v11[v17 - 1], v15, &v11[v17 + 1], *(void *)(*(void *)v8 + 40));
      uint64_t v18 = *v11;
      uint64_t *v11 = v11[v17];
      v11[v17] = v18;
    }
    uint64_t v19 = *(void *)v8;
    uint64_t v391 = a4 - 1;
    if (a5)
    {
      uint64_t v20 = *(void *)(v19 + 40);
      uint64_t v389 = *v11;
      uint64_t v21 = *(void *)(v20 + 8 * *v11);
      int v22 = *(unsigned __int8 *)(v21 + 112);
LABEL_14:
      for (uint64_t i = v11 + 1; ; ++i)
      {
        uint64_t v25 = *i;
        uint64_t v26 = *(void *)(v20 + 8 * *i);
        if ((*(unsigned char *)(v26 + 112) != 0) != (v22 != 0))
        {
          if (!*(unsigned char *)(v26 + 112)) {
            goto LABEL_37;
          }
          continue;
        }
        uint64_t v29 = *(void *)(v26 + 16);
        uint64_t v27 = v26 + 16;
        uint64_t v28 = v29;
        int v30 = *(char *)(v27 + 23);
        uint64_t v31 = (const void *)(v30 >= 0 ? v27 : v28);
        unint64_t v32 = v30 >= 0 ? *(unsigned __int8 *)(v27 + 23) : *(void *)(v27 + 8);
        int v33 = *(char *)(v21 + 39);
        uint64_t v34 = v33 >= 0 ? (const void *)(v21 + 16) : *(const void **)(v21 + 16);
        unint64_t v35 = v33 >= 0 ? *(unsigned __int8 *)(v21 + 39) : *(void *)(v21 + 24);
        size_t v36 = v35 >= v32 ? v32 : v35;
        int v37 = memcmp(v31, v34, v36);
        if (!v37) {
          break;
        }
        if ((v37 & 0x80000000) == 0) {
          goto LABEL_37;
        }
LABEL_16:
        ;
      }
      if (v32 < v35) {
        goto LABEL_16;
      }
LABEL_37:
      unint64_t v405 = i - 1;
      if (i - 1 != v401)
      {
        for (uint64_t j = a2 - 1; ; --j)
        {
          uint64_t v39 = *(void *)(v20 + 8 * *j);
          if ((*(unsigned char *)(v39 + 112) != 0) != (v22 != 0))
          {
            if (*(unsigned char *)(v39 + 112)) {
              goto LABEL_90;
            }
          }
          else
          {
            uint64_t v42 = *(const void **)(v39 + 16);
            uint64_t v40 = v39 + 16;
            uint64_t v41 = v42;
            int v43 = *(char *)(v40 + 23);
            if (v43 >= 0) {
              uint64_t v44 = (const void *)v40;
            }
            else {
              uint64_t v44 = v41;
            }
            if (v43 >= 0) {
              size_t v45 = *(unsigned __int8 *)(v40 + 23);
            }
            else {
              size_t v45 = *(void *)(v40 + 8);
            }
            int v46 = *(char *)(v21 + 39);
            if (v46 >= 0) {
              uint64_t v47 = (const void *)(v21 + 16);
            }
            else {
              uint64_t v47 = *(const void **)(v21 + 16);
            }
            if (v46 >= 0) {
              size_t v48 = *(unsigned __int8 *)(v21 + 39);
            }
            else {
              size_t v48 = *(void *)(v21 + 24);
            }
            if (v48 >= v45) {
              size_t v49 = v45;
            }
            else {
              size_t v49 = v48;
            }
            int v50 = memcmp(v44, v47, v49);
            if (v50)
            {
              if (v50 < 0) {
                goto LABEL_90;
              }
            }
            else if (v45 < v48)
            {
              goto LABEL_90;
            }
          }
        }
      }
      uint64_t j = a2;
      if (i < a2)
      {
        for (uint64_t j = a2 - 1; ; --j)
        {
          uint64_t v51 = *(void *)(v20 + 8 * *j);
          if ((*(unsigned char *)(v51 + 112) != 0) != (v22 != 0))
          {
            if (i >= j || *(unsigned char *)(v51 + 112)) {
              break;
            }
          }
          else
          {
            uint64_t v54 = *(const void **)(v51 + 16);
            uint64_t v52 = v51 + 16;
            uint64_t v53 = v54;
            int v55 = *(char *)(v52 + 23);
            if (v55 >= 0) {
              char v56 = (const void *)v52;
            }
            else {
              char v56 = v53;
            }
            if (v55 >= 0) {
              size_t v57 = *(unsigned __int8 *)(v52 + 23);
            }
            else {
              size_t v57 = *(void *)(v52 + 8);
            }
            int v58 = *(char *)(v21 + 39);
            if (v58 >= 0) {
              uint64_t v59 = (const void *)(v21 + 16);
            }
            else {
              uint64_t v59 = *(const void **)(v21 + 16);
            }
            if (v58 >= 0) {
              size_t v60 = *(unsigned __int8 *)(v21 + 39);
            }
            else {
              size_t v60 = *(void *)(v21 + 24);
            }
            if (v60 >= v57) {
              size_t v61 = v57;
            }
            else {
              size_t v61 = v60;
            }
            int v62 = memcmp(v56, v59, v61);
            if (v62)
            {
              if (i >= j || v62 < 0) {
                break;
              }
            }
            else if (i >= j || v57 < v60)
            {
              break;
            }
          }
        }
      }
LABEL_90:
      unint64_t v397 = i;
      if (i >= j) {
        goto LABEL_140;
      }
      uint64_t v63 = *j;
      uint64_t v64 = i;
      uint64_t v65 = j;
      while (2)
      {
        *v64++ = v63;
        *uint64_t v65 = v25;
        while (2)
        {
          uint64_t v25 = *v64;
          uint64_t v66 = *(void *)(v20 + 8 * *v64);
          if ((*(unsigned char *)(v66 + 112) != 0) != (v22 != 0))
          {
            if (!*(unsigned char *)(v66 + 112)) {
              goto LABEL_115;
            }
LABEL_94:
            ++v64;
            continue;
          }
          break;
        }
        unsigned int v69 = *(const void **)(v66 + 16);
        uint64_t v67 = v66 + 16;
        uint64_t v68 = v69;
        int v70 = *(char *)(v67 + 23);
        if (v70 >= 0) {
          uint64_t v71 = (const void *)v67;
        }
        else {
          uint64_t v71 = v68;
        }
        if (v70 >= 0) {
          size_t v72 = *(unsigned __int8 *)(v67 + 23);
        }
        else {
          size_t v72 = *(void *)(v67 + 8);
        }
        int v73 = *(char *)(v21 + 39);
        if (v73 >= 0) {
          unint64_t v74 = (const void *)(v21 + 16);
        }
        else {
          unint64_t v74 = *(const void **)(v21 + 16);
        }
        if (v73 >= 0) {
          size_t v75 = *(unsigned __int8 *)(v21 + 39);
        }
        else {
          size_t v75 = *(void *)(v21 + 24);
        }
        if (v75 >= v72) {
          size_t v76 = v72;
        }
        else {
          size_t v76 = v75;
        }
        int v77 = memcmp(v71, v74, v76);
        if (v77)
        {
          if ((v77 & 0x80000000) == 0) {
            goto LABEL_115;
          }
          goto LABEL_94;
        }
        if (v72 < v75) {
          goto LABEL_94;
        }
LABEL_115:
        unint64_t v405 = v64 - 1;
        --v65;
        do
        {
          while (1)
          {
            uint64_t v63 = *v65;
            uint64_t v78 = *(void *)(v20 + 8 * *v65);
            if ((*(unsigned char *)(v78 + 112) != 0) != (v22 != 0)) {
              break;
            }
            float64x2_t v81 = *(const void **)(v78 + 16);
            uint64_t v79 = v78 + 16;
            uint64_t v80 = v81;
            int v82 = *(char *)(v79 + 23);
            if (v82 >= 0) {
              double v83 = (const void *)v79;
            }
            else {
              double v83 = v80;
            }
            if (v82 >= 0) {
              size_t v84 = *(unsigned __int8 *)(v79 + 23);
            }
            else {
              size_t v84 = *(void *)(v79 + 8);
            }
            char v85 = *(unsigned char *)(v21 + 39);
            if (v85 >= 0) {
              unint64_t v86 = (const void *)(v21 + 16);
            }
            else {
              unint64_t v86 = *(const void **)(v21 + 16);
            }
            if (v85 >= 0) {
              size_t v87 = *(unsigned __int8 *)(v21 + 39);
            }
            else {
              size_t v87 = *(void *)(v21 + 24);
            }
            if (v87 >= v84) {
              size_t v88 = v84;
            }
            else {
              size_t v88 = v87;
            }
            int v89 = memcmp(v83, v86, v88);
            if (v89)
            {
              if (v89 < 0) {
                goto LABEL_139;
              }
            }
            else if (v84 < v87)
            {
              goto LABEL_139;
            }
            --v65;
          }
          --v65;
        }
        while (!*(unsigned char *)(v78 + 112));
        ++v65;
LABEL_139:
        if (v64 < v65) {
          continue;
        }
        break;
      }
LABEL_140:
      if (v405 != v401) {
        *unint64_t v401 = *v405;
      }
      a4 = v391;
      uint64_t *v405 = v389;
      BOOL v5 = v397 >= j;
      uint64_t v9 = a2;
      uint64_t v8 = (uint64_t)a3;
      if (v5)
      {
        BOOL v90 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(v401, v405, (uint64_t)a3);
        unint64_t k = v405 + 1;
        float result = (uint64_t *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(v405 + 1, a2, (uint64_t)a3);
        if (result)
        {
          a2 = v405;
          if (v90) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v90) {
          goto LABEL_146;
        }
      }
      else
      {
LABEL_146:
        float result = (uint64_t *)std::__introsort<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *,false>(v401, v405, a3, v391, a5 & 1);
        a5 = 0;
        unint64_t k = v405 + 1;
      }
    }
    else
    {
      uint64_t v20 = *(void *)(v19 + 40);
      uint64_t v23 = *(void *)(v20 + 8 * *(v11 - 1));
      uint64_t v389 = *v11;
      uint64_t v21 = *(void *)(v20 + 8 * *v11);
      int v22 = *(unsigned __int8 *)(v21 + 112);
      if ((*(unsigned char *)(v23 + 112) != 0) != (*(unsigned char *)(v21 + 112) != 0))
      {
        if (*(unsigned char *)(v23 + 112)) {
          goto LABEL_14;
        }
      }
      else
      {
        float64x2_t v93 = *(const void **)(v23 + 16);
        uint64_t v91 = v23 + 16;
        float64x2_t v92 = v93;
        int v94 = *(char *)(v91 + 23);
        if (v94 >= 0) {
          uint64_t v95 = (const void *)v91;
        }
        else {
          uint64_t v95 = v92;
        }
        if (v94 >= 0) {
          size_t v96 = *(unsigned __int8 *)(v91 + 23);
        }
        else {
          size_t v96 = *(void *)(v91 + 8);
        }
        int v97 = *(char *)(v21 + 39);
        if (v97 >= 0) {
          char v98 = (const void *)(v21 + 16);
        }
        else {
          char v98 = *(const void **)(v21 + 16);
        }
        if (v97 >= 0) {
          size_t v99 = *(unsigned __int8 *)(v21 + 39);
        }
        else {
          size_t v99 = *(void *)(v21 + 24);
        }
        if (v99 >= v96) {
          size_t v100 = v96;
        }
        else {
          size_t v100 = v99;
        }
        float result = (uint64_t *)memcmp(v95, v98, v100);
        if (result)
        {
          if ((result & 0x80000000) != 0) {
            goto LABEL_14;
          }
        }
        else if (v96 < v99)
        {
          goto LABEL_14;
        }
      }
      uint64_t v101 = *(void *)(v20 + 8 * *v393);
      int v102 = *(unsigned __int8 *)(v101 + 112);
      if ((v22 != 0) != (*(unsigned char *)(v101 + 112) != 0))
      {
        if (v22) {
          goto LABEL_166;
        }
      }
      else
      {
        int v114 = *(char *)(v21 + 39);
        if (v114 >= 0) {
          unint64_t v115 = (const void *)(v21 + 16);
        }
        else {
          unint64_t v115 = *(const void **)(v21 + 16);
        }
        if (v114 >= 0) {
          size_t v116 = *(unsigned __int8 *)(v21 + 39);
        }
        else {
          size_t v116 = *(void *)(v21 + 24);
        }
        int v117 = *(char *)(v101 + 39);
        if (v117 >= 0) {
          uint64_t v118 = (const void *)(v101 + 16);
        }
        else {
          uint64_t v118 = *(const void **)(v101 + 16);
        }
        if (v117 >= 0) {
          size_t v119 = *(unsigned __int8 *)(v101 + 39);
        }
        else {
          size_t v119 = *(void *)(v101 + 24);
        }
        if (v119 >= v116) {
          size_t v120 = v116;
        }
        else {
          size_t v120 = v119;
        }
        float result = (uint64_t *)memcmp(v115, v118, v120);
        if (result)
        {
          if ((result & 0x80000000) != 0) {
            goto LABEL_166;
          }
        }
        else if (v116 < v119)
        {
LABEL_166:
          for (unint64_t k = v11 + 1; ; ++k)
          {
            uint64_t v103 = *(void *)(v20 + 8 * *k);
            if ((v22 != 0) != (*(unsigned char *)(v103 + 112) != 0))
            {
              if (v22) {
                goto LABEL_233;
              }
            }
            else
            {
              int v104 = *(char *)(v21 + 39);
              if (v104 >= 0) {
                unint64_t v105 = (const void *)(v21 + 16);
              }
              else {
                unint64_t v105 = *(const void **)(v21 + 16);
              }
              if (v104 >= 0) {
                size_t v106 = *(unsigned __int8 *)(v21 + 39);
              }
              else {
                size_t v106 = *(void *)(v21 + 24);
              }
              uint64_t v109 = *(const void **)(v103 + 16);
              uint64_t v107 = v103 + 16;
              unint64_t v108 = v109;
              int v110 = *(char *)(v107 + 23);
              if (v110 >= 0) {
                float64x2_t v111 = (const void *)v107;
              }
              else {
                float64x2_t v111 = v108;
              }
              if (v110 >= 0) {
                size_t v112 = *(unsigned __int8 *)(v107 + 23);
              }
              else {
                size_t v112 = *(void *)(v107 + 8);
              }
              if (v112 >= v106) {
                size_t v113 = v106;
              }
              else {
                size_t v113 = v112;
              }
              float result = (uint64_t *)memcmp(v105, v111, v113);
              if (result)
              {
                if ((result & 0x80000000) != 0) {
                  goto LABEL_233;
                }
              }
              else if (v106 < v112)
              {
                goto LABEL_233;
              }
            }
          }
        }
      }
      for (unint64_t k = v11 + 1; k < a2; ++k)
      {
        uint64_t v121 = *(void *)(v20 + 8 * *k);
        if ((v22 != 0) != (*(unsigned char *)(v121 + 112) != 0))
        {
          if (v22) {
            break;
          }
        }
        else
        {
          int v122 = *(char *)(v21 + 39);
          if (v122 >= 0) {
            float64x2_t v123 = (const void *)(v21 + 16);
          }
          else {
            float64x2_t v123 = *(const void **)(v21 + 16);
          }
          if (v122 >= 0) {
            size_t v124 = *(unsigned __int8 *)(v21 + 39);
          }
          else {
            size_t v124 = *(void *)(v21 + 24);
          }
          float64x2_t v127 = *(const void **)(v121 + 16);
          uint64_t v125 = v121 + 16;
          float64x2_t v126 = v127;
          int v128 = *(char *)(v125 + 23);
          if (v128 >= 0) {
            unint64_t v129 = (const void *)v125;
          }
          else {
            unint64_t v129 = v126;
          }
          if (v128 >= 0) {
            size_t v130 = *(unsigned __int8 *)(v125 + 23);
          }
          else {
            size_t v130 = *(void *)(v125 + 8);
          }
          if (v130 >= v124) {
            size_t v131 = v124;
          }
          else {
            size_t v131 = v130;
          }
          float result = (uint64_t *)memcmp(v123, v129, v131);
          if (result)
          {
            if ((result & 0x80000000) != 0) {
              break;
            }
          }
          else if (v124 < v130)
          {
            break;
          }
        }
      }
LABEL_233:
      uint64_t m = a2;
      if (k < a2)
      {
        for (uint64_t m = a2 - 1; ; --m)
        {
          if ((v22 != 0) != (v102 != 0))
          {
            if (!v22) {
              break;
            }
          }
          else
          {
            int v134 = *(char *)(v21 + 39);
            if (v134 >= 0) {
              float64x2_t v135 = (const void *)(v21 + 16);
            }
            else {
              float64x2_t v135 = *(const void **)(v21 + 16);
            }
            if (v134 >= 0) {
              size_t v136 = *(unsigned __int8 *)(v21 + 39);
            }
            else {
              size_t v136 = *(void *)(v21 + 24);
            }
            unint64_t v139 = *(const void **)(v101 + 16);
            uint64_t v138 = v101 + 16;
            uint64_t v137 = v139;
            int v140 = *(char *)(v138 + 23);
            if (v140 >= 0) {
              uint64_t v141 = (const void *)v138;
            }
            else {
              uint64_t v141 = v137;
            }
            if (v140 >= 0) {
              size_t v142 = *(unsigned __int8 *)(v138 + 23);
            }
            else {
              size_t v142 = *(void *)(v138 + 8);
            }
            if (v142 >= v136) {
              size_t v143 = v136;
            }
            else {
              size_t v143 = v142;
            }
            float result = (uint64_t *)memcmp(v135, v141, v143);
            if (result)
            {
              if ((result & 0x80000000) == 0) {
                break;
              }
            }
            else if (v136 >= v142)
            {
              break;
            }
          }
          uint64_t v133 = *(m - 1);
          uint64_t v101 = *(void *)(v20 + 8 * v133);
          int v102 = *(unsigned __int8 *)(v101 + 112);
        }
      }
      if (k < m)
      {
        uint64_t v144 = *k;
        uint64_t v145 = *m;
        int v406 = v22;
        do
        {
          *k++ = v145;
          uint64_t *m = v144;
          while (1)
          {
            uint64_t v144 = *k;
            uint64_t v146 = *(void *)(v20 + 8 * *k);
            if ((v22 != 0) != (*(unsigned char *)(v146 + 112) != 0))
            {
              if (v406) {
                goto LABEL_285;
              }
              goto LABEL_262;
            }
            int v147 = *(char *)(v21 + 39);
            float64x2_t v148 = v147 >= 0 ? (const void *)(v21 + 16) : *(const void **)(v21 + 16);
            unint64_t v149 = v147 >= 0 ? *(unsigned __int8 *)(v21 + 39) : *(void *)(v21 + 24);
            uint64_t v152 = *(void *)(v146 + 16);
            uint64_t v150 = v146 + 16;
            uint64_t v151 = v152;
            int v153 = *(char *)(v150 + 23);
            float64x2_t v154 = (const void *)(v153 >= 0 ? v150 : v151);
            unint64_t v155 = v153 >= 0 ? *(unsigned __int8 *)(v150 + 23) : *(void *)(v150 + 8);
            size_t v156 = v155 >= v149 ? v149 : v155;
            float result = (uint64_t *)memcmp(v148, v154, v156);
            if (!result) {
              break;
            }
            if ((result & 0x80000000) != 0) {
              goto LABEL_285;
            }
LABEL_262:
            ++k;
          }
          if (v149 >= v155) {
            goto LABEL_262;
          }
          do
          {
LABEL_285:
            while (1)
            {
              uint64_t v157 = *--m;
              uint64_t v145 = v157;
              uint64_t v158 = *(void *)(v20 + 8 * v157);
              if ((v22 != 0) != (*(unsigned char *)(v158 + 112) != 0)) {
                break;
              }
              int v159 = *(char *)(v21 + 39);
              if (v159 >= 0) {
                double v160 = (const void *)(v21 + 16);
              }
              else {
                double v160 = *(const void **)(v21 + 16);
              }
              if (v159 >= 0) {
                size_t v161 = *(unsigned __int8 *)(v21 + 39);
              }
              else {
                size_t v161 = *(void *)(v21 + 24);
              }
              unint64_t v164 = *(const void **)(v158 + 16);
              uint64_t v162 = v158 + 16;
              float64x2_t v163 = v164;
              int v165 = *(char *)(v162 + 23);
              if (v165 >= 0) {
                float64x2_t v166 = (const void *)v162;
              }
              else {
                float64x2_t v166 = v163;
              }
              if (v165 >= 0) {
                size_t v167 = *(unsigned __int8 *)(v162 + 23);
              }
              else {
                size_t v167 = *(void *)(v162 + 8);
              }
              if (v167 >= v161) {
                size_t v168 = v161;
              }
              else {
                size_t v168 = v167;
              }
              float result = (uint64_t *)memcmp(v160, v166, v168);
              if (result)
              {
                if ((result & 0x80000000) == 0) {
                  goto LABEL_259;
                }
              }
              else if (v161 >= v167)
              {
                goto LABEL_259;
              }
            }
            int v406 = v22;
          }
          while (v22);
          int v406 = 0;
LABEL_259:
          ;
        }
        while (k < m);
      }
      unint64_t v169 = k - 1;
      BOOL v5 = k - 1 >= v401;
      BOOL v6 = k - 1 == v401;
      if (k - 1 != v401) {
        *unint64_t v401 = *v169;
      }
      a5 = 0;
      a4 = v391;
      *unint64_t v169 = v389;
      uint64_t v9 = a2;
      uint64_t v8 = (uint64_t)a3;
    }
  }
  double v176 = v11 + 1;
  BOOL v178 = v11 == v9 || v176 == v9;
  if (a5)
  {
    if (v178) {
      return result;
    }
    uint64_t v179 = 0;
    uint64_t v180 = *(void *)(*(void *)v8 + 40);
    unint64_t v181 = v11;
LABEL_339:
    double v184 = v181;
    unint64_t v181 = v176;
    uint64_t v185 = *v184;
    uint64_t v183 = v184[1];
    uint64_t v186 = *(void *)(v180 + 8 * v183);
    int v187 = *(unsigned __int8 *)(v186 + 112);
    uint64_t v188 = *(void *)(v180 + 8 * *v184);
    if ((*(unsigned char *)(v186 + 112) != 0) != (*(unsigned char *)(v188 + 112) != 0))
    {
      if (!*(unsigned char *)(v186 + 112)) {
        goto LABEL_338;
      }
    }
    else
    {
      uint64_t v189 = v184[1];
      int v190 = *(char *)(v186 + 39);
      if (v190 >= 0) {
        uint64_t v191 = (const void *)(v186 + 16);
      }
      else {
        uint64_t v191 = *(const void **)(v186 + 16);
      }
      if (v190 >= 0) {
        size_t v192 = *(unsigned __int8 *)(v186 + 39);
      }
      else {
        size_t v192 = *(void *)(v186 + 24);
      }
      double v195 = *(const void **)(v188 + 16);
      uint64_t v193 = v188 + 16;
      uint64_t v194 = v195;
      int v196 = *(char *)(v193 + 23);
      if (v196 >= 0) {
        uint8x8_t v197 = (const void *)v193;
      }
      else {
        uint8x8_t v197 = v194;
      }
      if (v196 >= 0) {
        size_t v198 = *(unsigned __int8 *)(v193 + 23);
      }
      else {
        size_t v198 = *(void *)(v193 + 8);
      }
      if (v198 >= v192) {
        size_t v199 = v192;
      }
      else {
        size_t v199 = v198;
      }
      float result = (uint64_t *)memcmp(v191, v197, v199);
      if (result)
      {
        uint64_t v183 = v189;
        if ((result & 0x80000000) == 0) {
          goto LABEL_338;
        }
      }
      else
      {
        uint64_t v183 = v189;
        if (v192 >= v198) {
          goto LABEL_338;
        }
      }
    }
    v184[1] = v185;
    double v182 = v401;
    if (v184 == v401) {
      goto LABEL_337;
    }
    uint64_t v394 = v183;
    int8x8_t v398 = v181;
    int v200 = *(unsigned __int8 *)(*(void *)(v180 + 8 * v183) + 112);
    uint64_t v402 = v179;
    while (1)
    {
      uint64_t v201 = *(uint64_t *)((char *)v401 + v179 - 8);
      uint64_t v202 = *(void *)(v180 + 8 * v201);
      if ((v200 != 0) != (*(unsigned char *)(v202 + 112) != 0))
      {
        if (!v187) {
          goto LABEL_385;
        }
      }
      else
      {
        char v203 = *(unsigned char *)(v186 + 39);
        if (v203 >= 0) {
          float64x2_t v204 = (const void *)(v186 + 16);
        }
        else {
          float64x2_t v204 = *(const void **)(v186 + 16);
        }
        if (v203 >= 0) {
          size_t v205 = *(unsigned __int8 *)(v186 + 39);
        }
        else {
          size_t v205 = *(void *)(v186 + 24);
        }
        unint64_t v208 = *(const void **)(v202 + 16);
        uint64_t v206 = v202 + 16;
        unint64_t v207 = v208;
        int v209 = *(char *)(v206 + 23);
        if (v209 >= 0) {
          uint8x8_t v210 = (const void *)v206;
        }
        else {
          uint8x8_t v210 = v207;
        }
        if (v209 >= 0) {
          size_t v211 = *(unsigned __int8 *)(v206 + 23);
        }
        else {
          size_t v211 = *(void *)(v206 + 8);
        }
        if (v211 >= v205) {
          size_t v212 = v205;
        }
        else {
          size_t v212 = v211;
        }
        float result = (uint64_t *)memcmp(v204, v210, v212);
        if (result)
        {
          if ((result & 0x80000000) == 0)
          {
            double v182 = (uint64_t *)((char *)v401 + v179);
            goto LABEL_336;
          }
        }
        else if (v205 >= v211)
        {
LABEL_385:
          double v182 = v184;
LABEL_336:
          uint64_t v179 = v402;
          uint64_t v183 = v394;
          unint64_t v181 = v398;
LABEL_337:
          *double v182 = v183;
LABEL_338:
          double v176 = v181 + 1;
          v179 += 8;
          if (v181 + 1 == a2) {
            return result;
          }
          goto LABEL_339;
        }
      }
      --v184;
      *(uint64_t *)((char *)v401 + v179) = v201;
      v179 -= 8;
      if (!v179)
      {
        double v182 = v401;
        goto LABEL_336;
      }
    }
  }
  if (!v178)
  {
    uint64_t v355 = *(void *)(*(void *)v8 + 40);
    do
    {
      uint64_t v356 = v401;
      unint64_t v401 = v176;
      uint64_t v358 = *v356;
      uint64_t v357 = v356[1];
      uint64_t v359 = *(void *)(v355 + 8 * v357);
      int v360 = *(unsigned __int8 *)(v359 + 112);
      uint64_t v361 = *(void *)(v355 + 8 * *v356);
      if ((*(unsigned char *)(v359 + 112) != 0) != (*(unsigned char *)(v361 + 112) != 0))
      {
        if (*(unsigned char *)(v359 + 112)) {
          goto LABEL_614;
        }
      }
      else
      {
        int v362 = *(char *)(v359 + 39);
        if (v362 >= 0) {
          unint64_t v363 = (const void *)(v359 + 16);
        }
        else {
          unint64_t v363 = *(const void **)(v359 + 16);
        }
        if (v362 >= 0) {
          size_t v364 = *(unsigned __int8 *)(v359 + 39);
        }
        else {
          size_t v364 = *(void *)(v359 + 24);
        }
        float64x2_t v367 = *(const void **)(v361 + 16);
        uint64_t v365 = v361 + 16;
        unint64_t v366 = v367;
        int v368 = *(char *)(v365 + 23);
        if (v368 >= 0) {
          unint64_t v369 = (const void *)v365;
        }
        else {
          unint64_t v369 = v366;
        }
        if (v368 >= 0) {
          size_t v370 = *(unsigned __int8 *)(v365 + 23);
        }
        else {
          size_t v370 = *(void *)(v365 + 8);
        }
        if (v370 >= v364) {
          size_t v371 = v364;
        }
        else {
          size_t v371 = v370;
        }
        float result = (uint64_t *)memcmp(v363, v369, v371);
        if (result)
        {
          if ((result & 0x80000000) != 0) {
            goto LABEL_614;
          }
        }
        else if (v364 < v370)
        {
LABEL_614:
          uint64_t v410 = v357;
          int v372 = *(unsigned __int8 *)(*(void *)(v355 + 8 * v357) + 112);
          do
          {
            while (1)
            {
              while (1)
              {
                float64x2_t v373 = v356;
                uint64_t v374 = *--v356;
                v356[2] = v358;
                uint64_t v358 = v374;
                uint64_t v375 = *(void *)(v355 + 8 * v374);
                if ((v372 != 0) == (*(unsigned char *)(v375 + 112) != 0)) {
                  break;
                }
                if (!v360) {
                  goto LABEL_590;
                }
              }
              int v376 = *(char *)(v359 + 39);
              double v377 = v376 >= 0 ? (const void *)(v359 + 16) : *(const void **)(v359 + 16);
              unint64_t v378 = v376 >= 0 ? *(unsigned __int8 *)(v359 + 39) : *(void *)(v359 + 24);
              uint64_t v381 = *(void *)(v375 + 16);
              uint64_t v379 = v375 + 16;
              uint64_t v380 = v381;
              int v382 = *(char *)(v379 + 23);
              long long v383 = (const void *)(v382 >= 0 ? v379 : v380);
              unint64_t v384 = v382 >= 0 ? *(unsigned __int8 *)(v379 + 23) : *(void *)(v379 + 8);
              size_t v385 = v384 >= v378 ? v378 : v384;
              float result = (uint64_t *)memcmp(v377, v383, v385);
              if (!result) {
                break;
              }
              if ((result & 0x80000000) == 0) {
                goto LABEL_590;
              }
            }
          }
          while (v378 < v384);
LABEL_590:
          *float64x2_t v373 = v410;
        }
      }
      double v176 = v401 + 1;
    }
    while (v401 + 1 != a2);
  }
  return result;
}

uint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  size_t v84 = result;
  uint64_t v6 = *a2;
  uint64_t v7 = *(void *)(a4 + 8 * *a2);
  int v8 = *(unsigned __int8 *)(v7 + 112);
  uint64_t v9 = *result;
  uint64_t v10 = *(void *)(a4 + 8 * *result);
  int v11 = *(unsigned __int8 *)(v10 + 112);
  if ((*(unsigned char *)(v7 + 112) != 0) == (*(unsigned char *)(v10 + 112) != 0))
  {
    int v15 = *(char *)(v7 + 39);
    if (v15 >= 0) {
      uint64_t v16 = (const void *)(v7 + 16);
    }
    else {
      uint64_t v16 = *(const void **)(v7 + 16);
    }
    if (v15 >= 0) {
      size_t v17 = *(unsigned __int8 *)(v7 + 39);
    }
    else {
      size_t v17 = *(void *)(v7 + 24);
    }
    int v18 = *(char *)(v10 + 39);
    if (v18 >= 0) {
      uint64_t v19 = (const void *)(v10 + 16);
    }
    else {
      uint64_t v19 = *(const void **)(v10 + 16);
    }
    if (v18 >= 0) {
      size_t v20 = *(unsigned __int8 *)(v10 + 39);
    }
    else {
      size_t v20 = *(void *)(v10 + 24);
    }
    if (v20 >= v17) {
      size_t v21 = v17;
    }
    else {
      size_t v21 = v20;
    }
    float result = (uint64_t *)memcmp(v16, v19, v21);
    if (result)
    {
      if ((result & 0x80000000) == 0) {
        goto LABEL_23;
      }
    }
    else if (v17 >= v20)
    {
      goto LABEL_23;
    }
LABEL_3:
    BOOL v12 = v8 != 0;
    uint64_t v13 = *a3;
    uint64_t v14 = *(void *)(a4 + 8 * *a3);
    if (((*(unsigned char *)(v14 + 112) != 0) ^ v12))
    {
      if (*(unsigned char *)(v14 + 112))
      {
LABEL_5:
        *size_t v84 = v13;
LABEL_110:
        *a3 = v9;
        return result;
      }
    }
    else
    {
      uint64_t v27 = *(const void **)(v14 + 16);
      uint64_t v25 = v14 + 16;
      uint64_t v26 = v27;
      int v28 = *(char *)(v25 + 23);
      if (v28 >= 0) {
        uint64_t v29 = (const void *)v25;
      }
      else {
        uint64_t v29 = v26;
      }
      if (v28 >= 0) {
        size_t v30 = *(unsigned __int8 *)(v25 + 23);
      }
      else {
        size_t v30 = *(void *)(v25 + 8);
      }
      int v33 = *(const void **)(v7 + 16);
      uint64_t v32 = v7 + 16;
      uint64_t v31 = v33;
      int v34 = *(char *)(v32 + 23);
      if (v34 >= 0) {
        unint64_t v35 = (const void *)v32;
      }
      else {
        unint64_t v35 = v31;
      }
      if (v34 >= 0) {
        size_t v36 = *(unsigned __int8 *)(v32 + 23);
      }
      else {
        size_t v36 = *(void *)(v32 + 8);
      }
      if (v36 >= v30) {
        size_t v37 = v30;
      }
      else {
        size_t v37 = v36;
      }
      float result = (uint64_t *)memcmp(v29, v35, v37);
      if (result)
      {
        if ((result & 0x80000000) != 0) {
          goto LABEL_5;
        }
      }
      else if (v30 < v36)
      {
        goto LABEL_5;
      }
    }
    *size_t v84 = v6;
    *a2 = v9;
    uint64_t v38 = *a3;
    uint64_t v39 = *(void *)(a4 + 8 * *a3);
    if ((*(unsigned char *)(v39 + 112) != 0) != (v11 != 0))
    {
      if (!*(unsigned char *)(v39 + 112)) {
        return result;
      }
    }
    else
    {
      int v55 = *(const void **)(v39 + 16);
      uint64_t v53 = v39 + 16;
      uint64_t v54 = v55;
      int v56 = *(char *)(v53 + 23);
      if (v56 >= 0) {
        size_t v57 = (const void *)v53;
      }
      else {
        size_t v57 = v54;
      }
      if (v56 >= 0) {
        size_t v58 = *(unsigned __int8 *)(v53 + 23);
      }
      else {
        size_t v58 = *(void *)(v53 + 8);
      }
      size_t v61 = *(const void **)(v10 + 16);
      uint64_t v60 = v10 + 16;
      uint64_t v59 = v61;
      int v62 = *(char *)(v60 + 23);
      if (v62 >= 0) {
        uint64_t v63 = (const void *)v60;
      }
      else {
        uint64_t v63 = v59;
      }
      if (v62 >= 0) {
        size_t v64 = *(unsigned __int8 *)(v60 + 23);
      }
      else {
        size_t v64 = *(void *)(v60 + 8);
      }
      if (v64 >= v58) {
        size_t v65 = v58;
      }
      else {
        size_t v65 = v64;
      }
      float result = (uint64_t *)memcmp(v57, v63, v65);
      if (result)
      {
        if ((result & 0x80000000) == 0) {
          return result;
        }
      }
      else if (v58 >= v64)
      {
        return result;
      }
    }
    *a2 = v38;
    goto LABEL_110;
  }
  if (*(unsigned char *)(v7 + 112)) {
    goto LABEL_3;
  }
LABEL_23:
  uint64_t v22 = *a3;
  uint64_t v23 = *(void *)(a4 + 8 * *a3);
  if ((*(unsigned char *)(v23 + 112) != 0) != (v8 != 0))
  {
    int64_t v24 = a2;
    if (!*(unsigned char *)(v23 + 112)) {
      return result;
    }
  }
  else
  {
    uint64_t v42 = *(const void **)(v23 + 16);
    uint64_t v40 = v23 + 16;
    uint64_t v41 = v42;
    int v43 = *(char *)(v40 + 23);
    if (v43 >= 0) {
      uint64_t v44 = (const void *)v40;
    }
    else {
      uint64_t v44 = v41;
    }
    if (v43 >= 0) {
      size_t v45 = *(unsigned __int8 *)(v40 + 23);
    }
    else {
      size_t v45 = *(void *)(v40 + 8);
    }
    size_t v48 = *(const void **)(v7 + 16);
    uint64_t v47 = v7 + 16;
    int v46 = v48;
    int v49 = *(char *)(v47 + 23);
    if (v49 >= 0) {
      int v50 = (const void *)v47;
    }
    else {
      int v50 = v46;
    }
    if (v49 >= 0) {
      size_t v51 = *(unsigned __int8 *)(v47 + 23);
    }
    else {
      size_t v51 = *(void *)(v47 + 8);
    }
    if (v51 >= v45) {
      size_t v52 = v45;
    }
    else {
      size_t v52 = v51;
    }
    float result = (uint64_t *)memcmp(v44, v50, v52);
    if (result)
    {
      int64_t v24 = a2;
      if ((result & 0x80000000) == 0) {
        return result;
      }
    }
    else
    {
      int64_t v24 = a2;
      if (v45 >= v51) {
        return result;
      }
    }
  }
  *int64_t v24 = v22;
  *a3 = v6;
  uint64_t v66 = *v24;
  uint64_t v67 = *(void *)(a4 + 8 * *v24);
  uint64_t v68 = *v84;
  uint64_t v69 = *(void *)(a4 + 8 * *v84);
  if ((*(unsigned char *)(v67 + 112) != 0) == (*(unsigned char *)(v69 + 112) != 0))
  {
    size_t v72 = *(const void **)(v67 + 16);
    uint64_t v70 = v67 + 16;
    uint64_t v71 = v72;
    int v73 = *(char *)(v70 + 23);
    if (v73 >= 0) {
      unint64_t v74 = (const void *)v70;
    }
    else {
      unint64_t v74 = v71;
    }
    if (v73 >= 0) {
      size_t v75 = *(unsigned __int8 *)(v70 + 23);
    }
    else {
      size_t v75 = *(void *)(v70 + 8);
    }
    uint64_t v78 = *(const void **)(v69 + 16);
    uint64_t v76 = v69 + 16;
    int v77 = v78;
    int v79 = *(char *)(v76 + 23);
    if (v79 >= 0) {
      uint64_t v80 = (const void *)v76;
    }
    else {
      uint64_t v80 = v77;
    }
    if (v79 >= 0) {
      size_t v81 = *(unsigned __int8 *)(v76 + 23);
    }
    else {
      size_t v81 = *(void *)(v76 + 8);
    }
    if (v81 >= v75) {
      size_t v82 = v75;
    }
    else {
      size_t v82 = v81;
    }
    float result = (uint64_t *)memcmp(v74, v80, v82);
    if (result)
    {
      if ((result & 0x80000000) == 0) {
        return result;
      }
    }
    else if (v75 >= v81)
    {
      return result;
    }
    goto LABEL_112;
  }
  if (*(unsigned char *)(v67 + 112))
  {
LABEL_112:
    *size_t v84 = v66;
    *int64_t v24 = v68;
  }
  return result;
}

uint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  float result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(a1, a2, a3, *(void *)(*(void *)a5 + 40));
  uint64_t v11 = *a4;
  uint64_t v12 = *(void *)(*(void *)a5 + 40);
  uint64_t v13 = *(void *)(v12 + 8 * *a4);
  uint64_t v14 = *a3;
  uint64_t v15 = *(void *)(v12 + 8 * *a3);
  if ((*(unsigned char *)(v13 + 112) != 0) != (*(unsigned char *)(v15 + 112) != 0))
  {
    if (!*(unsigned char *)(v13 + 112)) {
      return result;
    }
  }
  else
  {
    int v18 = *(const void **)(v13 + 16);
    uint64_t v16 = v13 + 16;
    size_t v17 = v18;
    int v19 = *(char *)(v16 + 23);
    if (v19 >= 0) {
      size_t v20 = (const void *)v16;
    }
    else {
      size_t v20 = v17;
    }
    if (v19 >= 0) {
      size_t v21 = *(unsigned __int8 *)(v16 + 23);
    }
    else {
      size_t v21 = *(void *)(v16 + 8);
    }
    int64_t v24 = *(const void **)(v15 + 16);
    uint64_t v22 = v15 + 16;
    uint64_t v23 = v24;
    int v25 = *(char *)(v22 + 23);
    if (v25 >= 0) {
      uint64_t v26 = (const void *)v22;
    }
    else {
      uint64_t v26 = v23;
    }
    if (v25 >= 0) {
      size_t v27 = *(unsigned __int8 *)(v22 + 23);
    }
    else {
      size_t v27 = *(void *)(v22 + 8);
    }
    if (v27 >= v21) {
      size_t v28 = v21;
    }
    else {
      size_t v28 = v27;
    }
    float result = (uint64_t *)memcmp(v20, v26, v28);
    if (result)
    {
      if ((result & 0x80000000) == 0) {
        return result;
      }
    }
    else if (v21 >= v27)
    {
      return result;
    }
  }
  *a3 = v11;
  *a4 = v14;
  uint64_t v29 = *a3;
  uint64_t v30 = *(void *)(v12 + 8 * *a3);
  uint64_t v31 = *a2;
  uint64_t v32 = *(void *)(v12 + 8 * *a2);
  if ((*(unsigned char *)(v30 + 112) != 0) != (*(unsigned char *)(v32 + 112) != 0))
  {
    if (!*(unsigned char *)(v30 + 112)) {
      return result;
    }
  }
  else
  {
    unint64_t v35 = *(const void **)(v30 + 16);
    uint64_t v33 = v30 + 16;
    int v34 = v35;
    int v36 = *(char *)(v33 + 23);
    if (v36 >= 0) {
      size_t v37 = (const void *)v33;
    }
    else {
      size_t v37 = v34;
    }
    if (v36 >= 0) {
      size_t v38 = *(unsigned __int8 *)(v33 + 23);
    }
    else {
      size_t v38 = *(void *)(v33 + 8);
    }
    uint64_t v41 = *(const void **)(v32 + 16);
    uint64_t v39 = v32 + 16;
    uint64_t v40 = v41;
    int v42 = *(char *)(v39 + 23);
    if (v42 >= 0) {
      int v43 = (const void *)v39;
    }
    else {
      int v43 = v40;
    }
    if (v42 >= 0) {
      size_t v44 = *(unsigned __int8 *)(v39 + 23);
    }
    else {
      size_t v44 = *(void *)(v39 + 8);
    }
    if (v44 >= v38) {
      size_t v45 = v38;
    }
    else {
      size_t v45 = v44;
    }
    float result = (uint64_t *)memcmp(v37, v43, v45);
    if (result)
    {
      if ((result & 0x80000000) == 0) {
        return result;
      }
    }
    else if (v38 >= v44)
    {
      return result;
    }
  }
  *a2 = v29;
  *a3 = v31;
  uint64_t v46 = *a2;
  uint64_t v47 = *(void *)(v12 + 8 * *a2);
  uint64_t v48 = *a1;
  uint64_t v49 = *(void *)(v12 + 8 * *a1);
  if ((*(unsigned char *)(v47 + 112) != 0) != (*(unsigned char *)(v49 + 112) != 0))
  {
    if (!*(unsigned char *)(v47 + 112)) {
      return result;
    }
    goto LABEL_47;
  }
  size_t v52 = *(const void **)(v47 + 16);
  uint64_t v50 = v47 + 16;
  size_t v51 = v52;
  int v53 = *(char *)(v50 + 23);
  if (v53 >= 0) {
    uint64_t v54 = (const void *)v50;
  }
  else {
    uint64_t v54 = v51;
  }
  if (v53 >= 0) {
    size_t v55 = *(unsigned __int8 *)(v50 + 23);
  }
  else {
    size_t v55 = *(void *)(v50 + 8);
  }
  size_t v58 = *(const void **)(v49 + 16);
  uint64_t v56 = v49 + 16;
  size_t v57 = v58;
  int v59 = *(char *)(v56 + 23);
  if (v59 >= 0) {
    uint64_t v60 = (const void *)v56;
  }
  else {
    uint64_t v60 = v57;
  }
  if (v59 >= 0) {
    size_t v61 = *(unsigned __int8 *)(v56 + 23);
  }
  else {
    size_t v61 = *(void *)(v56 + 8);
  }
  if (v61 >= v55) {
    size_t v62 = v55;
  }
  else {
    size_t v62 = v61;
  }
  float result = (uint64_t *)memcmp(v54, v60, v62);
  if (!result)
  {
    if (v55 >= v61) {
      return result;
    }
    goto LABEL_47;
  }
  if ((result & 0x80000000) != 0)
  {
LABEL_47:
    *a1 = v46;
    *a2 = v48;
  }
  return result;
}

uint64_t *std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  float result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(a1, a2, a3, a4, a6);
  uint64_t v13 = *a5;
  uint64_t v14 = *(void *)(*(void *)a6 + 40);
  uint64_t v15 = *(void *)(v14 + 8 * *a5);
  uint64_t v16 = *a4;
  uint64_t v17 = *(void *)(v14 + 8 * *a4);
  if ((*(unsigned char *)(v15 + 112) != 0) != (*(unsigned char *)(v17 + 112) != 0))
  {
    if (!*(unsigned char *)(v15 + 112)) {
      return result;
    }
  }
  else
  {
    size_t v20 = *(const void **)(v15 + 16);
    uint64_t v18 = v15 + 16;
    int v19 = v20;
    int v21 = *(char *)(v18 + 23);
    if (v21 >= 0) {
      uint64_t v22 = (const void *)v18;
    }
    else {
      uint64_t v22 = v19;
    }
    if (v21 >= 0) {
      size_t v23 = *(unsigned __int8 *)(v18 + 23);
    }
    else {
      size_t v23 = *(void *)(v18 + 8);
    }
    uint64_t v26 = *(const void **)(v17 + 16);
    uint64_t v24 = v17 + 16;
    int v25 = v26;
    int v27 = *(char *)(v24 + 23);
    if (v27 >= 0) {
      size_t v28 = (const void *)v24;
    }
    else {
      size_t v28 = v25;
    }
    if (v27 >= 0) {
      size_t v29 = *(unsigned __int8 *)(v24 + 23);
    }
    else {
      size_t v29 = *(void *)(v24 + 8);
    }
    if (v29 >= v23) {
      size_t v30 = v23;
    }
    else {
      size_t v30 = v29;
    }
    float result = (uint64_t *)memcmp(v22, v28, v30);
    if (result)
    {
      if ((result & 0x80000000) == 0) {
        return result;
      }
    }
    else if (v23 >= v29)
    {
      return result;
    }
  }
  *a4 = v13;
  *a5 = v16;
  uint64_t v31 = *a4;
  uint64_t v32 = *(void *)(v14 + 8 * *a4);
  uint64_t v33 = *a3;
  uint64_t v34 = *(void *)(v14 + 8 * *a3);
  if ((*(unsigned char *)(v32 + 112) != 0) != (*(unsigned char *)(v34 + 112) != 0))
  {
    if (!*(unsigned char *)(v32 + 112)) {
      return result;
    }
  }
  else
  {
    size_t v37 = *(const void **)(v32 + 16);
    uint64_t v35 = v32 + 16;
    int v36 = v37;
    int v38 = *(char *)(v35 + 23);
    if (v38 >= 0) {
      uint64_t v39 = (const void *)v35;
    }
    else {
      uint64_t v39 = v36;
    }
    if (v38 >= 0) {
      size_t v40 = *(unsigned __int8 *)(v35 + 23);
    }
    else {
      size_t v40 = *(void *)(v35 + 8);
    }
    int v43 = *(const void **)(v34 + 16);
    uint64_t v41 = v34 + 16;
    int v42 = v43;
    int v44 = *(char *)(v41 + 23);
    if (v44 >= 0) {
      size_t v45 = (const void *)v41;
    }
    else {
      size_t v45 = v42;
    }
    if (v44 >= 0) {
      size_t v46 = *(unsigned __int8 *)(v41 + 23);
    }
    else {
      size_t v46 = *(void *)(v41 + 8);
    }
    if (v46 >= v40) {
      size_t v47 = v40;
    }
    else {
      size_t v47 = v46;
    }
    float result = (uint64_t *)memcmp(v39, v45, v47);
    if (result)
    {
      if ((result & 0x80000000) == 0) {
        return result;
      }
    }
    else if (v40 >= v46)
    {
      return result;
    }
  }
  *a3 = v31;
  *a4 = v33;
  uint64_t v48 = *a3;
  uint64_t v49 = *(void *)(v14 + 8 * *a3);
  uint64_t v50 = *a2;
  uint64_t v51 = *(void *)(v14 + 8 * *a2);
  if ((*(unsigned char *)(v49 + 112) != 0) != (*(unsigned char *)(v51 + 112) != 0))
  {
    if (!*(unsigned char *)(v49 + 112)) {
      return result;
    }
  }
  else
  {
    uint64_t v54 = *(const void **)(v49 + 16);
    uint64_t v52 = v49 + 16;
    int v53 = v54;
    int v55 = *(char *)(v52 + 23);
    if (v55 >= 0) {
      uint64_t v56 = (const void *)v52;
    }
    else {
      uint64_t v56 = v53;
    }
    if (v55 >= 0) {
      size_t v57 = *(unsigned __int8 *)(v52 + 23);
    }
    else {
      size_t v57 = *(void *)(v52 + 8);
    }
    uint64_t v60 = *(const void **)(v51 + 16);
    uint64_t v58 = v51 + 16;
    int v59 = v60;
    int v61 = *(char *)(v58 + 23);
    if (v61 >= 0) {
      size_t v62 = (const void *)v58;
    }
    else {
      size_t v62 = v59;
    }
    if (v61 >= 0) {
      size_t v63 = *(unsigned __int8 *)(v58 + 23);
    }
    else {
      size_t v63 = *(void *)(v58 + 8);
    }
    if (v63 >= v57) {
      size_t v64 = v57;
    }
    else {
      size_t v64 = v63;
    }
    float result = (uint64_t *)memcmp(v56, v62, v64);
    if (result)
    {
      if ((result & 0x80000000) == 0) {
        return result;
      }
    }
    else if (v57 >= v63)
    {
      return result;
    }
  }
  *a2 = v48;
  *a3 = v50;
  uint64_t v65 = *a2;
  uint64_t v66 = *(void *)(v14 + 8 * *a2);
  uint64_t v67 = *a1;
  uint64_t v68 = *(void *)(v14 + 8 * *a1);
  if ((*(unsigned char *)(v66 + 112) != 0) != (*(unsigned char *)(v68 + 112) != 0))
  {
    if (!*(unsigned char *)(v66 + 112)) {
      return result;
    }
    goto LABEL_69;
  }
  uint64_t v71 = *(const void **)(v66 + 16);
  uint64_t v69 = v66 + 16;
  uint64_t v70 = v71;
  int v72 = *(char *)(v69 + 23);
  if (v72 >= 0) {
    int v73 = (const void *)v69;
  }
  else {
    int v73 = v70;
  }
  if (v72 >= 0) {
    size_t v74 = *(unsigned __int8 *)(v69 + 23);
  }
  else {
    size_t v74 = *(void *)(v69 + 8);
  }
  int v77 = *(const void **)(v68 + 16);
  uint64_t v75 = v68 + 16;
  uint64_t v76 = v77;
  int v78 = *(char *)(v75 + 23);
  if (v78 >= 0) {
    int v79 = (const void *)v75;
  }
  else {
    int v79 = v76;
  }
  if (v78 >= 0) {
    size_t v80 = *(unsigned __int8 *)(v75 + 23);
  }
  else {
    size_t v80 = *(void *)(v75 + 8);
  }
  if (v80 >= v74) {
    size_t v81 = v74;
  }
  else {
    size_t v81 = v80;
  }
  float result = (uint64_t *)memcmp(v73, v79, v81);
  if (!result)
  {
    if (v74 >= v80) {
      return result;
    }
    goto LABEL_69;
  }
  if ((result & 0x80000000) != 0)
  {
LABEL_69:
    *a1 = v65;
    *a2 = v67;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v4 = a2;
  BOOL v5 = a1;
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *(void *)(*(void *)a3 + 40);
      uint64_t v10 = *(void *)(v9 + 8 * v8);
      uint64_t v11 = *v5;
      uint64_t v12 = *(void *)(v9 + 8 * *v5);
      if ((*(unsigned char *)(v10 + 112) != 0) == (*(unsigned char *)(v12 + 112) != 0))
      {
        uint64_t v56 = *(const void **)(v10 + 16);
        uint64_t v54 = v10 + 16;
        int v55 = v56;
        int v57 = *(char *)(v54 + 23);
        if (v57 >= 0) {
          uint64_t v58 = (const void *)v54;
        }
        else {
          uint64_t v58 = v55;
        }
        if (v57 >= 0) {
          size_t v59 = *(unsigned __int8 *)(v54 + 23);
        }
        else {
          size_t v59 = *(void *)(v54 + 8);
        }
        size_t v62 = *(const void **)(v12 + 16);
        uint64_t v60 = v12 + 16;
        int v61 = v62;
        int v63 = *(char *)(v60 + 23);
        if (v63 >= 0) {
          size_t v64 = (const void *)v60;
        }
        else {
          size_t v64 = v61;
        }
        if (v63 >= 0) {
          size_t v65 = *(unsigned __int8 *)(v60 + 23);
        }
        else {
          size_t v65 = *(void *)(v60 + 8);
        }
        if (v65 >= v59) {
          size_t v66 = v59;
        }
        else {
          size_t v66 = v65;
        }
        int v67 = memcmp(v58, v64, v66);
        if (v67)
        {
          if ((v67 & 0x80000000) == 0) {
            return 1;
          }
          goto LABEL_80;
        }
        if (v59 < v65)
        {
LABEL_80:
          *BOOL v5 = v8;
          *(v4 - 1) = v11;
        }
        return 1;
      }
      if (*(unsigned char *)(v10 + 112)) {
        goto LABEL_80;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(v5, v5 + 1, a2 - 1, *(void *)(*(void *)a3 + 40));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(v5, v5 + 1, v5 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *,0>(v5, v5 + 1, v5 + 2, v5 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v13 = v5 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninJunction::addRoad(md::MuninRoadEdge const*)::$_0 &,unsigned long *>(v5, v5 + 1, v5 + 2, *(void *)(*(void *)a3 + 40));
      uint64_t v14 = v5 + 3;
      if (v5 + 3 == v4) {
        return 1;
      }
      uint64_t v15 = 0;
      int v72 = 0;
      uint64_t v16 = *(void *)(*(void *)a3 + 40);
      uint64_t v71 = v4;
      while (2)
      {
        uint64_t v18 = *v14;
        uint64_t v19 = *(void *)(v16 + 8 * *v14);
        int v20 = *(unsigned __int8 *)(v19 + 112);
        uint64_t v21 = *v13;
        uint64_t v22 = *(void *)(v16 + 8 * *v13);
        int v73 = v20;
        if ((*(unsigned char *)(v19 + 112) != 0) != (*(unsigned char *)(v22 + 112) != 0))
        {
          if (!*(unsigned char *)(v19 + 112)) {
            goto LABEL_10;
          }
        }
        else
        {
          uint64_t v23 = v15;
          int v24 = *(char *)(v19 + 39);
          if (v24 >= 0) {
            int v25 = (const void *)(v19 + 16);
          }
          else {
            int v25 = *(const void **)(v19 + 16);
          }
          if (v24 >= 0) {
            size_t v26 = *(unsigned __int8 *)(v19 + 39);
          }
          else {
            size_t v26 = *(void *)(v19 + 24);
          }
          size_t v29 = *(const void **)(v22 + 16);
          uint64_t v27 = v22 + 16;
          size_t v28 = v29;
          int v30 = *(char *)(v27 + 23);
          if (v30 >= 0) {
            uint64_t v31 = (const void *)v27;
          }
          else {
            uint64_t v31 = v28;
          }
          if (v30 >= 0) {
            size_t v32 = *(unsigned __int8 *)(v27 + 23);
          }
          else {
            size_t v32 = *(void *)(v27 + 8);
          }
          if (v32 >= v26) {
            size_t v33 = v26;
          }
          else {
            size_t v33 = v32;
          }
          int v34 = memcmp(v25, v31, v33);
          if (v34)
          {
            uint64_t v15 = v23;
            unint64_t v4 = v71;
            int v20 = v73;
            if ((v34 & 0x80000000) == 0) {
              goto LABEL_10;
            }
          }
          else
          {
            BOOL v35 = v26 >= v32;
            uint64_t v15 = v23;
            unint64_t v4 = v71;
            int v20 = v73;
            if (v35) {
              goto LABEL_10;
            }
          }
        }
        *uint64_t v14 = v21;
        uint64_t v17 = v5;
        if (v13 == v5) {
          goto LABEL_9;
        }
        uint64_t v69 = v15;
        uint64_t v70 = v14;
        uint64_t v68 = v18;
        uint64_t v36 = *(void *)(v16 + 8 * v18);
        uint64_t v37 = v15;
        int v38 = *(unsigned __int8 *)(v36 + 112);
LABEL_37:
        uint64_t v39 = (char *)v5 + v37;
        uint64_t v40 = *(uint64_t *)((char *)v5 + v37 + 8);
        uint64_t v41 = *(void *)(v16 + 8 * v40);
        if ((v38 != 0) != (*(unsigned char *)(v41 + 112) != 0))
        {
          if (!v20)
          {
            uint64_t v17 = (uint64_t *)((char *)v5 + v37 + 16);
LABEL_8:
            uint64_t v14 = v70;
            unint64_t v4 = v71;
            uint64_t v18 = v68;
            uint64_t v15 = v69;
LABEL_9:
            *uint64_t v17 = v18;
            if (++v72 == 8) {
              return v14 + 1 == v4;
            }
LABEL_10:
            uint64_t v13 = v14;
            v15 += 8;
            if (++v14 != v4) {
              continue;
            }
            return 1;
          }
        }
        else
        {
          int v42 = v5;
          char v43 = *(unsigned char *)(v19 + 39);
          if (v43 >= 0) {
            int v44 = (const void *)(v19 + 16);
          }
          else {
            int v44 = *(const void **)(v19 + 16);
          }
          if (v43 >= 0) {
            size_t v45 = *(unsigned __int8 *)(v19 + 39);
          }
          else {
            size_t v45 = *(void *)(v19 + 24);
          }
          uint64_t v48 = *(const void **)(v41 + 16);
          uint64_t v46 = v41 + 16;
          size_t v47 = v48;
          int v49 = *(char *)(v46 + 23);
          if (v49 >= 0) {
            uint64_t v50 = (const void *)v46;
          }
          else {
            uint64_t v50 = v47;
          }
          if (v49 >= 0) {
            size_t v51 = *(unsigned __int8 *)(v46 + 23);
          }
          else {
            size_t v51 = *(void *)(v46 + 8);
          }
          if (v51 >= v45) {
            size_t v52 = v45;
          }
          else {
            size_t v52 = v51;
          }
          int v53 = memcmp(v44, v50, v52);
          if (v53)
          {
            BOOL v5 = v42;
            int v20 = v73;
            if ((v53 & 0x80000000) == 0) {
              goto LABEL_58;
            }
          }
          else
          {
            BOOL v35 = v45 >= v51;
            BOOL v5 = v42;
            int v20 = v73;
            if (v35)
            {
LABEL_58:
              uint64_t v17 = v13;
              goto LABEL_8;
            }
          }
        }
        break;
      }
      --v13;
      *((void *)v39 + 2) = v40;
      v37 -= 8;
      if (v37 == -16)
      {
        uint64_t v17 = v5;
        goto LABEL_8;
      }
      goto LABEL_37;
  }
}