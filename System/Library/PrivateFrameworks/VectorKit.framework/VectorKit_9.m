void sub_1A1B5B0B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,long long a29,long long a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,char *__p,char *a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,int a59)
{
  std::__shared_weak_count *v59;
  md::MapTileData *v60;
  void **v61;
  void **v62;
  void *v64;
  uint64_t shared_weak_owners;
  void *v66;
  void *v67;
  void *v68;
  char *v69;
  char *v70;
  char *v71;

  v64 = *v62;
  if (*v62)
  {
    shared_weak_owners = v59[32].__shared_weak_owners_;
    v66 = *v62;
    if ((void *)shared_weak_owners != v64)
    {
      do
        md::ElevatedStrokeGroup::~ElevatedStrokeGroup((md::ElevatedStrokeGroup *)(shared_weak_owners - 160));
      while ((void *)shared_weak_owners != v64);
      v66 = *v62;
    }
    v59[32].__shared_weak_owners_ = (uint64_t)v64;
    operator delete(v66);
  }
  v67 = *v61;
  if (*v61)
  {
    v59[31].__shared_weak_owners_ = (uint64_t)v67;
    operator delete(v67);
  }
  md::MapTileData::~MapTileData(v60);
  std::__shared_weak_count::~__shared_weak_count(v59);
  operator delete(v68);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a47);
  v69 = __p;
  if (__p)
  {
    v70 = a44;
    v71 = __p;
    if (a44 != __p)
    {
      do
        md::ElevatedStrokeGroup::~ElevatedStrokeGroup((md::ElevatedStrokeGroup *)(v70 - 160));
      while (v70 != v69);
      v71 = __p;
    }
    a44 = v69;
    operator delete(v71);
  }
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100]((uint64_t)&a32);
  geo::linear_map<std::bitset<2ul>,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>>,std::equal_to<std::bitset<2ul>>,std::allocator<std::pair<std::bitset<2ul>,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>>>>,std::vector<std::pair<std::bitset<2ul>,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>>>>>::~linear_map(&a37);
  if (a40) {
    operator delete(a40);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Tile::View>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t ggl::ConstantDataTyped<ggl::Tile::View>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Tile::Transform>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t ggl::ConstantDataTyped<ggl::Tile::Transform>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t md::RegistryManager::getRegistryForKey(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 312);
  if (!v2) {
    return 0;
  }
  v4 = (uint64_t *)(a1 + 312);
  unsigned int v5 = *(_DWORD *)(a2 + 96);
  if (v5 == -1)
  {
    do
    {
      v6 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v6 = (uint64_t *)(a1 + 312);
LABEL_4:
    uint64_t v7 = *((unsigned int *)v2 + 32);
    if (v7 != -1 && v7 >= v5)
    {
      if (v7 > v5)
      {
        while (1)
        {
          v6 = v2;
          uint64_t v2 = (uint64_t *)*v2;
          if (!v2) {
            break;
          }
LABEL_15:
          unsigned int v5 = *(_DWORD *)(a2 + 96);
          if (v5 != -1) {
            goto LABEL_4;
          }
        }
      }
      else
      {
        v13 = &v12;
        if (((unsigned int (*)(char **, uint64_t *, uint64_t))off_1EF58FAA8[v7])(&v13, v2 + 4, a2)) {
          ++v2;
        }
        else {
          v6 = v2;
        }
        uint64_t v2 = (uint64_t *)*v2;
        if (v2) {
          goto LABEL_15;
        }
      }
    }
    else
    {
      uint64_t v2 = (uint64_t *)v2[1];
      if (v2) {
        goto LABEL_15;
      }
    }
  }
  if (v6 == v4) {
    return 0;
  }
  unsigned int v9 = *((_DWORD *)v6 + 32);
  if (v9 != -1
    && ((uint64_t v10 = *(unsigned int *)(a2 + 96), v10 == -1)
     || v10 < v9
     || v10 <= v9
     && (v13 = &v12,
         (((uint64_t (*)(char **, uint64_t, uint64_t *))off_1EF58FAA8[v10])(&v13, a2, v6 + 4) & 1) != 0)))
  {
    return 0;
  }
  else
  {
    return v6[17];
  }
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<1ul,1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::less<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey> const>(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  return *a2 < *a3;
}

uint64_t md::SelectedDaVinciPolygonLayerDataSource::selectedPolygons@<X0>(md::SelectedDaVinciPolygonLayerDataSource *this@<X0>, uint64_t a2@<X8>)
{
  return std::unordered_set<unsigned long long>::unordered_set(a2, (uint64_t)this + 808);
}

double md::ElevatedStrokeLayerDataSource::selectedPolygons@<D0>(uint64_t a1@<X8>)
{
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  return result;
}

uint64_t geo::codec::VectorTile::polygonsCount(geo::codec::VectorTile *this)
{
  return (uint64_t)(*((void *)this + 13) - *((void *)this + 12)) >> 7;
}

void md::LabelTile::LabelTile(unsigned __int8 *a1, uint64_t a2, uint64_t a3, unsigned __int8 a4, void *a5, char a6, float **a7, void *a8)
{
  uint64_t v1611 = *MEMORY[0x1E4F143B8];
  *a1 = a4;
  *((void *)a1 + 1) = *a5;
  uint64_t v13 = a5[1];
  *((void *)a1 + 2) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 16), 1uLL, memory_order_relaxed);
  }
  v14 = operator new(0x38uLL);
  v14[1] = 0;
  v14[2] = 0;
  void *v14 = &unk_1EF57FF40;
  uint64_t v15 = *(void *)(a3 + 8);
  v14[3] = *(void *)a3;
  v14[4] = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  v14[5] = 0;
  v14[6] = 0;
  *((void *)a1 + 6) = 0;
  *((void *)a1 + 3) = v14 + 3;
  *((void *)a1 + 4) = v14;
  {
    operator new();
  }
  uint64_t v16 = mdm::Allocator::instance(void)::alloc;
  *((void *)a1 + 10) = 0;
  *((void *)a1 + 7) = v16;
  *((void *)a1 + 8) = 0;
  *((void *)a1 + 5) = a1 + 48;
  {
    operator new();
  }
  uint64_t v17 = mdm::Allocator::instance(void)::alloc;
  *((void *)a1 + 14) = 0;
  *((void *)a1 + 11) = v17;
  *((void *)a1 + 12) = 0;
  *((void *)a1 + 9) = a1 + 80;
  {
    operator new();
  }
  uint64_t v18 = mdm::Allocator::instance(void)::alloc;
  *((void *)a1 + 18) = 0;
  *((void *)a1 + 15) = v18;
  *((void *)a1 + 16) = 0;
  *((void *)a1 + 13) = a1 + 112;
  {
    operator new();
  }
  uint64_t v19 = mdm::Allocator::instance(void)::alloc;
  *((void *)a1 + 22) = 0;
  *((void *)a1 + 19) = v19;
  *((void *)a1 + 20) = 0;
  *((void *)a1 + 17) = a1 + 144;
  {
    operator new();
  }
  uint64_t v20 = mdm::Allocator::instance(void)::alloc;
  *((void *)a1 + 26) = 0;
  uint64_t v21 = (uint64_t)(a1 + 208);
  *((void *)a1 + 23) = v20;
  *((void *)a1 + 24) = 0;
  v1440 = (uint64_t *)(a1 + 176);
  *((void *)a1 + 21) = a1 + 176;
  {
    operator new();
  }
  uint64_t v22 = mdm::Allocator::instance(void)::alloc;
  *((void *)a1 + 30) = 0;
  v23 = a1 + 240;
  *((void *)a1 + 27) = v22;
  *((void *)a1 + 28) = 0;
  v1456 = (uint64_t *)(a1 + 208);
  *((void *)a1 + 25) = v21;
  {
    uint64_t v21 = (uint64_t)(a1 + 240);
    v23 = a1 + 240;
    if (v1399) {
      operator new();
    }
  }
  *((void *)a1 + 31) = mdm::Allocator::instance(void)::alloc;
  *((void *)a1 + 32) = 0;
  *((void *)a1 + 29) = v23;
  *((void *)a1 + 33) = 0;
  *((void *)a1 + 34) = 0;
  *((_DWORD *)a1 + 70) = 0;
  *((_WORD *)a1 + 144) = *(_WORD *)a2;
  *(void *)(a1 + 292) = *(void *)(a2 + 4);
  v1400 = v23;
  v1401 = a1 + 312;
  int v24 = 1 << *(unsigned char *)(a2 + 1);
  double v25 = 1.0 / (double)v24;
  double v26 = v25 * (double)*(int *)(a2 + 8);
  double v27 = v25 * (double)(v24 + ~*(_DWORD *)(a2 + 4));
  *((double *)a1 + 39) = v26;
  *((double *)a1 + 40) = v27;
  *((double *)a1 + 41) = v26 + v25;
  *((double *)a1 + 42) = v27 + v25;
  v1605[0] = &unk_1EF579410;
  v1606 = v1605;
  v1603[0] = &unk_1EF579458;
  v1604 = v1603;
  v1608 = v1607;
  v1607[0] = &unk_1EF579458;
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  v28 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v28))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v28, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsTileDecode", "", buf, 2u);
  }

  if (v1604 == v1603)
  {
    (*(void (**)(void *))(v1603[0] + 32))(v1603);
  }
  else if (v1604)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*v1604 + 40))(v1604, v29, v30);
  }
  v1404 = (void **)(a1 + 72);
  v1405 = (void **)(a1 + 40);
  v1406 = (void **)(a1 + 104);
  v1402 = (uint64_t **)(a1 + 136);
  v1416 = (void **)(a1 + 168);
  v1438 = (uint64_t **)(a1 + 200);
  if (v1606 == v1605)
  {
    (*(void (**)(void *))(v1605[0] + 32))(v1605);
  }
  else if (v1606)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*v1606 + 40))(v1606, v29, v30);
  }
  v1473 = *(std::mutex **)(*a5 + 288);
  md::LabelFeaturePool::prepareAddFeaturesForTile((uint64_t)v1473, (unint64_t **)a1 + 3);
  v1589[16] = 0;
  v31 = a1;
  *(_DWORD *)&v1589[20] = 0;
  *(_WORD *)&v1589[24] = 256;
  v1589[26] = 0;
  v1591 = 0;
  v1590 = 0;
  long long v32 = *(_OWORD *)(a1 + 328);
  long long v1588 = *(_OWORD *)(a1 + 312);
  *(_OWORD *)v1589 = v32;
  *(void *)&long long v1587 = *(void *)a3;
  *((void *)&v1587 + 1) = a1;
  uint64_t v33 = *((void *)a1 + 38);
  *(void *)buf = *a5;
  uint64_t v1586 = v33;
  long long v1585 = *((_OWORD *)a1 + 18);
  unsigned __int8 v34 = atomic_load((unsigned __int8 *)(*(void *)buf + 3392));
  v1589[24] = v34 & 1;
  v1589[26] = a6;
  int v35 = v31[289];
  v36 = +[VKPlatform sharedPlatform];
  int v37 = [v36 tileZBias];
  v1589[16] = (v35 - v37) & ~((v35 - v37) << 24 >> 31);

  v39 = *a7;
  v38 = (std::__shared_weak_count *)a7[1];
  if (v38) {
    atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v40 = v1591;
  v1590 = v39;
  v1591 = v38;
  if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
  }
  unint64_t v41 = *a1;
  BOOL v42 = v41 == 11;
  BOOL v1439 = v41 == 13;
  BOOL v1435 = v41 == 5;
  LODWORD(v1403) = v41 == 7;
  HIDWORD(v1403) = v41 == 8;
  BOOL v43 = v41 == 10;
  if (v41 == 3) {
    BOOL v43 = 1;
  }
  BOOL v1441 = v43;
  v44 = &md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::daVinciTiles;
  if (v41 != 10)
  {
    if ((v41 - 9) > 8) {
      v44 = &ggl::vSCompositingShaderVertShaderFunctionConstantMapping(void)::ref;
    }
    else {
      v44 = *(&off_1E5A8EAF0 + (char)(v41 - 9));
    }
  }
  unsigned __int8 v45 = atomic_load((unsigned __int8 *)(*a5 + 3622));
  if (v45)
  {
    unsigned int v46 = (v41 < 0x12) & (0x2164Du >> v41);
    unsigned int v47 = (v41 < 0x10) & (0xC60Bu >> v41);
  }
  else
  {
    LOBYTE(v46) = 0;
    BOOL v42 = 0;
    unsigned int v47 = 0;
    BOOL v1441 = 0;
    BOOL v1439 = 0;
    BOOL v1435 = 0;
    uint64_t v1403 = 0;
  }
  int64_t v48 = v44
      - (unsigned char *)&md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::daVinciTiles;
  if ((v46 & 1) == 0 && !v42) {
    goto LABEL_55;
  }
  unint64_t v49 = geo::codec::VectorTile::poisCount(*(geo::codec::VectorTile **)a3);
  if (v49)
  {
    char v50 = 4 * ((v41 & 0xFE) == 14);
    if (v48 != 5) {
      char v50 = 2;
    }
    if (*a1 == 11) {
      char v51 = 3;
    }
    else {
      char v51 = v50;
    }
    v52 = (uint64_t *)geo::codec::VectorTile::pois(*(geo::codec::VectorTile **)a3);
    uint64_t v1576 = *(void *)buf;
    __int16 v1577 = v1585;
    uint64_t v1578 = *(void *)((char *)&v1585 + 4);
    long long v1579 = v1587;
    long long v1580 = v1588;
    v1581[0] = *(_OWORD *)v1589;
    *(_OWORD *)((char *)v1581 + 11) = *(_OWORD *)&v1589[11];
    v1582 = v1590;
    v1583 = v1591;
    if (v1591) {
      atomic_fetch_add_explicit(&v1591->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    md::LabelFeaturePool::addPointFeatures(v1473, (unint64_t *)a3, v52, v49, &v1576, v1438, 1, v51);
    v53 = v1583;
    if (v1583 && !atomic_fetch_add(&v1583->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }
  v54 = (void *)geo::codec::VectorTile::removedFeatureIDs(*(geo::codec::VectorTile **)a3);
  if (*v54 == v54[1]) {
    goto LABEL_55;
  }
  std::mutex::lock(v1473);
  int64_t v1446 = v48;
  unsigned int v1450 = v47;
  BOOL v1429 = v42;
  v55 = *(geo::codec::VectorTile **)a3;
  v56 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v1473[7].__m_.__opaque, *(void *)a3);
  if (v56)
  {
    if (!*((unsigned char *)v56 + 436))
    {
      *((unsigned char *)v56 + 436) = 1;
      uint64_t v274 = geo::codec::VectorTile::removedFeatureIDs(v55);
      v275 = *(uint64_t **)v274;
      __srcb = *(uint64_t **)(v274 + 8);
      if (*(uint64_t **)v274 != __srcb)
      {
        v1466 = &v1473[8].__m_.__opaque[16];
        while (1)
        {
          unint64_t v276 = *v275;
          unint64_t v277 = v275[1];
          unint64_t v278 = *(void *)v1473[8].__m_.__opaque;
          if (v278)
          {
            uint8x8_t v279 = (uint8x8_t)vcnt_s8((int8x8_t)v278);
            v279.i16[0] = vaddlv_u8(v279);
            if (v279.u32[0] > 1uLL)
            {
              uint64_t v21 = *v275;
              if (v276 >= v278) {
                uint64_t v21 = v276 % v278;
              }
            }
            else
            {
              uint64_t v21 = (v278 - 1) & v276;
            }
            v280 = *(void ***)(v1473[8].__m_.__sig + 8 * v21);
            if (v280)
            {
              v281 = *v280;
              if (*v280)
              {
                if (v279.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    uint64_t v283 = v281[1];
                    if (v283 == v276)
                    {
                      if (v281[2] == v276) {
                        goto LABEL_487;
                      }
                    }
                    else if ((v283 & (v278 - 1)) != v21)
                    {
                      goto LABEL_428;
                    }
                    v281 = (void *)*v281;
                    if (!v281) {
                      goto LABEL_428;
                    }
                  }
                }
                do
                {
                  unint64_t v282 = v281[1];
                  if (v282 == v276)
                  {
                    if (v281[2] == v276) {
                      goto LABEL_487;
                    }
                  }
                  else
                  {
                    if (v282 >= v278) {
                      v282 %= v278;
                    }
                    if (v282 != v21) {
                      break;
                    }
                  }
                  v281 = (void *)*v281;
                }
                while (v281);
              }
            }
          }
LABEL_428:
          v281 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)&v1473[8].__m_.__opaque[24]
                                                                               + 16))(*(void *)&v1473[8].__m_.__opaque[24], 80, 8);
          v1592[0] = v281;
          v1592[1] = &v1473[8].__m_.__opaque[24];
          void *v281 = 0;
          v281[1] = v276;
          v281[2] = v276;
          *(_OWORD *)(v281 + 3) = 0u;
          *(_OWORD *)(v281 + 5) = 0u;
          *(_OWORD *)(v281 + 7) = 0u;
          v281[9] = 0;
          v281[4] = v281 + 8;
          v281[5] = v281 + 8;
          v281[6] = v281 + 8;
          v281[7] = 2;
          LOBYTE(v1593[0]) = 1;
          float v284 = (float)(unint64_t)(*(void *)&v1473[8].__m_.__opaque[32] + 1);
          float v285 = *(float *)&v1473[8].__m_.__opaque[40];
          if (!v278 || (float)(v285 * (float)v278) < v284) {
            break;
          }
LABEL_477:
          v308 = *(void **)(v1473[8].__m_.__sig + 8 * v21);
          if (v308)
          {
            void *v281 = *v308;
LABEL_485:
            void *v308 = v281;
            goto LABEL_486;
          }
          void *v281 = *(void *)&v1473[8].__m_.__opaque[16];
          *(void *)&v1473[8].__m_.__opaque[16] = v281;
          *(void *)(v1473[8].__m_.__sig + 8 * v21) = v1466;
          if (*v281)
          {
            unint64_t v309 = *(void *)(*v281 + 8);
            if ((v278 & (v278 - 1)) != 0)
            {
              if (v309 >= v278) {
                v309 %= v278;
              }
            }
            else
            {
              v309 &= v278 - 1;
            }
            v308 = (void *)(v1473[8].__m_.__sig + 8 * v309);
            goto LABEL_485;
          }
LABEL_486:
          ++*(void *)&v1473[8].__m_.__opaque[32];
LABEL_487:
          if (md::DebugStreamingPOIFeatureID) {
            _ZF = md::DebugStreamingPOIFeatureID == v276;
          }
          else {
            _ZF = 0;
          }
          if (_ZF)
          {
            if (GEOGetVectorKitStreamingPOILog_onceToken != -1) {
              dispatch_once(&GEOGetVectorKitStreamingPOILog_onceToken, &__block_literal_global_61);
            }
            uint64_t v21 = (uint64_t)(id)GEOGetVectorKitStreamingPOILog_log;
            if (os_log_type_enabled((os_log_t)v21, OS_LOG_TYPE_DEBUG))
            {
              md::HighlightHelper::debugTileToString((std::string *)v1592, *(void *)a3 + 4);
              v311 = v1592;
              if (SHIBYTE(v1593[0]) < 0) {
                v311 = (void **)v1592[0];
              }
              *(_DWORD *)v1609 = 136315394;
              *(void *)&v1609[4] = v311;
              *(_WORD *)&v1609[12] = 2048;
              *(void *)&v1609[14] = v277;
              _os_log_impl(&dword_1A1780000, (os_log_t)v21, OS_LOG_TYPE_DEBUG, "LabelFeaturePool::add removeFeatureID, tile=(%s), removeVersion=%llu", v1609, 0x16u);
              if (SHIBYTE(v1593[0]) < 0) {
                operator delete(v1592[0]);
              }
            }
          }
          unint64_t v8 = v281[4];
          v312 = (unint64_t *)v281[5];
          uint64_t v313 = (uint64_t)((uint64_t)v312 - v8) >> 3;
          unint64_t v314 = v281[7];
          if (v314 >= v313 + 1) {
            goto LABEL_517;
          }
          v315 = (float *)v281[6];
          unint64_t v316 = (1 << -(char)__clz(v314 + 1));
          if (v314 >= 0xFFFFFFFFFFFFFFFELL) {
            unint64_t v316 = 1;
          }
          if (v316 <= v313 + 1) {
            unint64_t v317 = v313 + 1;
          }
          else {
            unint64_t v317 = v316;
          }
          uint64_t v21 = (uint64_t)malloc_type_malloc(8 * v317, 0x100004000313F17uLL);
          v318 = (char *)v281[4];
          v319 = (char *)v281[5];
          if (v318 != v319)
          {
            unint64_t v320 = v319 - v318 - 8;
            v321 = (void *)v21;
            v322 = (char *)v281[4];
            if (v320 >= 0x18)
            {
              v321 = (void *)v21;
              v322 = (char *)v281[4];
              if ((unint64_t)(v21 - (void)v318) >= 0x20)
              {
                uint64_t v323 = (v320 >> 3) + 1;
                uint64_t v324 = 8 * (v323 & 0x3FFFFFFFFFFFFFFCLL);
                v321 = (void *)(v21 + v324);
                v325 = (long long *)(v318 + 16);
                v326 = (_OWORD *)(v21 + 16);
                uint64_t v327 = v323 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v328 = *v325;
                  *(v326 - 1) = *(v325 - 1);
                  _OWORD *v326 = v328;
                  v325 += 2;
                  v326 += 2;
                  v327 -= 4;
                }
                while (v327);
                if (v323 == (v323 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_514;
                }
                v322 = &v318[v324];
              }
            }
            do
            {
              uint64_t v329 = *(void *)v322;
              v322 += 8;
              *v321++ = v329;
            }
            while (v322 != v319);
          }
LABEL_514:
          if ((float *)v8 != v315) {
            free(v318);
          }
          v281[4] = v21;
          v312 = (unint64_t *)(v21 + 8 * v313);
          v281[7] = v317;
LABEL_517:
          unint64_t *v312 = v277;
          v281[5] = v312 + 1;
          if (v277 > v281[3])
          {
            v281[3] = v277;
            v330 = &v1473[5].__m_.__opaque[40];
            while (1)
            {
              v330 = *(char **)v330;
              if (!v330) {
                break;
              }
              uint64_t v331 = *((void *)v330 + 2);
              if (v331) {
                uint64_t v332 = v331 + 8;
              }
              else {
                uint64_t v332 = 0;
              }
              if ((*(uint64_t (**)(void))(**(void **)(v332 + 8) + 160))(*(void *)(v332 + 8)) == v276)
              {
                uint64_t v333 = *((void *)v330 + 2);
                if (v333) {
                  uint64_t v334 = v333 + 8;
                }
                else {
                  uint64_t v334 = 0;
                }
                md::PointLabelFeature::setPOIUpdateRemoveVersion(*(md::PointLabelFeature **)(v334 + 8), v277);
                break;
              }
            }
          }
          v275 += 2;
          if (v275 == __srcb) {
            goto LABEL_54;
          }
        }
        BOOL v286 = (v278 & (v278 - 1)) != 0;
        if (v278 < 3) {
          BOOL v286 = 1;
        }
        unint64_t v287 = v286 | (2 * v278);
        unint64_t v288 = vcvtps_u32_f32(v284 / v285);
        if (v287 <= v288) {
          size_t prime = v288;
        }
        else {
          size_t prime = v287;
        }
        if (prime == 1)
        {
          size_t prime = 2;
        }
        else if ((prime & (prime - 1)) != 0)
        {
          size_t prime = std::__next_prime(prime);
        }
        unint64_t v278 = *(void *)v1473[8].__m_.__opaque;
        if (prime <= v278)
        {
          if (prime >= v278) {
            goto LABEL_464;
          }
          unint64_t v301 = vcvtps_u32_f32((float)*(unint64_t *)&v1473[8].__m_.__opaque[32] / *(float *)&v1473[8].__m_.__opaque[40]);
          if (v278 < 3
            || (uint8x8_t v302 = (uint8x8_t)vcnt_s8((int8x8_t)v278), v302.i16[0] = vaddlv_u8(v302), v302.u32[0] > 1uLL))
          {
            unint64_t v301 = std::__next_prime(v301);
          }
          else
          {
            uint64_t v303 = 1 << -(char)__clz(v301 - 1);
            if (v301 >= 2) {
              unint64_t v301 = v303;
            }
          }
          if (prime <= v301) {
            size_t prime = v301;
          }
          if (prime >= v278)
          {
            unint64_t v278 = *(void *)v1473[8].__m_.__opaque;
LABEL_464:
            if ((v278 & (v278 - 1)) != 0)
            {
              if (v276 >= v278) {
                uint64_t v21 = v276 % v278;
              }
              else {
                uint64_t v21 = v276;
              }
            }
            else
            {
              uint64_t v21 = (v278 - 1) & v276;
            }
            goto LABEL_477;
          }
          if (!prime)
          {
            uint64_t sig = v1473[8].__m_.__sig;
            v1473[8].__m_.__uint64_t sig = 0;
            if (sig) {
              (*(void (**)(void, uint64_t, uint64_t))(**(void **)&v1473[8].__m_.__opaque[8] + 40))(*(void *)&v1473[8].__m_.__opaque[8], sig, 8 * *(void *)v1473[8].__m_.__opaque);
            }
            unint64_t v278 = 0;
            *(void *)v1473[8].__m_.__opaque = 0;
            goto LABEL_464;
          }
        }
        uint64_t v290 = (*(uint64_t (**)(void, size_t, uint64_t))(**(void **)&v1473[8].__m_.__opaque[8] + 16))(*(void *)&v1473[8].__m_.__opaque[8], 8 * prime, 8);
        uint64_t v291 = v1473[8].__m_.__sig;
        v1473[8].__m_.__uint64_t sig = v290;
        if (v291) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)&v1473[8].__m_.__opaque[8] + 40))(*(void *)&v1473[8].__m_.__opaque[8], v291, 8 * *(void *)v1473[8].__m_.__opaque);
        }
        uint64_t v292 = 0;
        *(void *)v1473[8].__m_.__opaque = prime;
        do
          *(void *)(v1473[8].__m_.__sig + 8 * v292++) = 0;
        while (prime != v292);
        v293 = *(void **)v1466;
        if (!*(void *)v1466)
        {
LABEL_463:
          unint64_t v278 = prime;
          goto LABEL_464;
        }
        size_t v294 = v293[1];
        size_t v295 = prime - 1;
        if ((prime & (prime - 1)) == 0)
        {
          size_t v296 = v294 & v295;
          *(void *)(v1473[8].__m_.__sig + 8 * v296) = v1466;
          for (i = (void *)*v293; *v293; i = (void *)*v293)
          {
            size_t v298 = i[1] & v295;
            if (v298 == v296)
            {
              v293 = i;
            }
            else
            {
              uint64_t v299 = v1473[8].__m_.__sig;
              if (*(void *)(v299 + 8 * v298))
              {
                void *v293 = *i;
                uint64_t v300 = 8 * v298;
                void *i = **(void **)(v1473[8].__m_.__sig + v300);
                **(void **)(v1473[8].__m_.__sig + v300) = i;
              }
              else
              {
                *(void *)(v299 + 8 * v298) = v293;
                v293 = i;
                size_t v296 = v298;
              }
            }
          }
          goto LABEL_463;
        }
        if (v294 >= prime) {
          v294 %= prime;
        }
        *(void *)(v1473[8].__m_.__sig + 8 * v294) = v1466;
        v304 = (void *)*v293;
        if (!*v293) {
          goto LABEL_463;
        }
        while (1)
        {
          size_t v306 = v304[1];
          if (v306 >= prime) {
            v306 %= prime;
          }
          if (v306 != v294)
          {
            uint64_t v307 = v1473[8].__m_.__sig;
            if (!*(void *)(v307 + 8 * v306))
            {
              *(void *)(v307 + 8 * v306) = v293;
              goto LABEL_468;
            }
            void *v293 = *v304;
            uint64_t v305 = 8 * v306;
            void *v304 = **(void **)(v1473[8].__m_.__sig + v305);
            **(void **)(v1473[8].__m_.__sig + v305) = v304;
            v304 = v293;
          }
          size_t v306 = v294;
LABEL_468:
          v293 = v304;
          v304 = (void *)*v304;
          size_t v294 = v306;
          if (!v304) {
            goto LABEL_463;
          }
        }
      }
    }
  }
LABEL_54:
  std::mutex::unlock(v1473);
  BOOL v42 = v1429;
  unsigned int v47 = v1450;
  int64_t v48 = v1446;
LABEL_55:
  if (!v47) {
    goto LABEL_541;
  }
  unint64_t v1457 = geo::codec::VectorTile::linesCount(*(geo::codec::VectorTile **)a3);
  if (!v1457) {
    goto LABEL_541;
  }
  BOOL v1430 = v42;
  int v1426 = v41 & 0xFE;
  if (v1426 == 14) {
    char v57 = 5;
  }
  else {
    char v57 = 2;
  }
  char v58 = 4 * ((v41 & 0xFE) == 14);
  if (v48 != 5) {
    char v58 = v57;
  }
  char v1451 = v58;
  uint64_t v59 = geo::codec::VectorTile::lines(*(geo::codec::VectorTile **)a3);
  uint64_t v1482 = *(void *)buf;
  uint64_t v1568 = *(void *)buf;
  __int16 v1569 = v1585;
  uint64_t v1570 = *(void *)((char *)&v1585 + 4);
  long long v1571 = v1587;
  long long v1572 = v1588;
  *(_OWORD *)v1573 = *(_OWORD *)v1589;
  *(_OWORD *)&v1573[11] = *(_OWORD *)&v1589[11];
  v60 = v1591;
  v1574 = v1590;
  v1575 = v1591;
  if (v1591) {
    atomic_fetch_add_explicit(&v1591->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  std::mutex::lock(v1473);
  v61 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v1473[7].__m_.__opaque, *(void *)a3);
  if (!v61)
  {
    std::mutex::unlock(v1473);
    BOOL v42 = v1430;
    if (v60) {
      goto LABEL_305;
    }
    goto LABEL_307;
  }
  v62 = v61;
  std::mutex::unlock(v1473);
  memset(v1609, 0, sizeof(v1609));
  {
    operator new();
  }
  uint64_t v1610 = mdm::Allocator::instance(void)::alloc;
  uint64_t v63 = *(void *)v1609;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v1609[16] - *(void *)v1609) >> 3) <= 0x1F)
  {
    uint64_t v64 = *(void *)&v1609[8];
    uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 768, 8);
    uint64_t v67 = *(void *)v1609;
    uint64_t v66 = *(void *)&v1609[8];
    uint64_t v68 = v65 + 24 * ((v64 - v63) / 24);
    if (*(void *)&v1609[8] != *(void *)v1609)
    {
      do
      {
        long long v69 = *(_OWORD *)(v66 - 24);
        *(void *)(v68 - 8) = *(void *)(v66 - 8);
        *(_OWORD *)(v68 - 24) = v69;
        v68 -= 24;
        v66 -= 24;
      }
      while (v66 != v67);
      uint64_t v66 = *(void *)v1609;
    }
    *(void *)v1609 = v68;
    *(void *)&v1609[8] = v65 + 24 * ((v64 - v63) / 24);
    uint64_t v70 = *(void *)&v1609[16];
    *(void *)&v1609[16] = v65 + 768;
    if (v66) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1610 + 40))(v1610, v66, v70 - v66);
    }
  }
  *(_OWORD *)v1593 = 0u;
  *(_OWORD *)v1592 = 0u;
  int v1594 = 1065353216;
  std::mutex::lock(v1473);
  uint64_t v71 = geo::codec::VectorTile::tileLabelLines(*(geo::codec::VectorTile **)a3);
  unsigned int v72 = 0;
  unint64_t v1447 = (unint64_t)(v62 + 3);
  while (1)
  {
    if (v72 >= geo::codec::VectorTile::tileLabelLinesCount(*(geo::codec::VectorTile **)a3))
    {
      if (*(void *)v1609 != *(void *)&v1609[8])
      {
        md::LabelFeatureStyler::styleLabelFeatures(*(unsigned int **)(v1482 + 296), (char **)v1609, 1u, 1, *(void *)(*(void *)(v1482 + 152) + 32));
        *(void *)&v1609[8] = *(void *)v1609;
        std::mutex::unlock(v1473);
        if (!v1473) {
          goto LABEL_2422;
        }
        std::mutex::lock(v1473);
      }
      std::mutex::unlock(v1473);
      std::mutex::lock(v1473);
      LODWORD(v122) = 0;
      v1598 = 0;
      __p = 0;
      v1599 = 0;
      while (1)
      {
        if (v1574 && (uint64_t v123 = *(void *)v1574) != 0)
        {
          if (*(void *)(v59 + 40) != v123)
          {
            uint64_t v124 = *(unsigned __int8 *)(v59 + 74);
            if (!*(unsigned char *)(v59 + 74)) {
              goto LABEL_252;
            }
            uint64_t v125 = *(void *)(*(void *)a3 + 3528) + 8 * *(unsigned int *)(v59 + 64);
            uint64_t v126 = 8 * v124;
            v127 = (void *)v125;
            do
            {
              if (*v127 == v123) {
                goto LABEL_173;
              }
              ++v127;
              v126 -= 8;
            }
            while (v126);
            v127 = (void *)(v125 + 8 * v124);
LABEL_173:
            if (v124 == ((uint64_t)v127 - v125) >> 3)
            {
LABEL_252:
              if (*(unsigned char *)(v1482 + 200) != 2) {
                goto LABEL_164;
              }
              char v128 = 0;
              goto LABEL_180;
            }
          }
        }
        else if ((!v59 || *(unsigned __int8 *)(v59 + 153) - 1 >= 2) {
               && !geo::codec::featureGetNativeLabelCount(v59)
        }
               && !geo::codec::featureGetNativeShieldCount(v59))
        {
          goto LABEL_252;
        }
        char v128 = 1;
LABEL_180:
        v129 = (char *)__p;
        v1598 = (std::__shared_weak_count *)__p;
        unint64_t v130 = *(unsigned int *)(v59 + 100);
        if (!v130) {
          goto LABEL_164;
        }
        char v1464 = v128;
        unint64_t v131 = 0;
        int v132 = v122 << 16;
        v133 = v1599;
        v134 = (char *)__p;
        do
        {
          if (v1592[1])
          {
            unint64_t v135 = (v132 + v131);
            uint8x8_t v136 = (uint8x8_t)vcnt_s8((int8x8_t)v1592[1]);
            v136.i16[0] = vaddlv_u8(v136);
            if (v136.u32[0] > 1uLL)
            {
              unint64_t v137 = (v132 + v131);
              if (v1592[1] <= (void *)v135) {
                unint64_t v137 = v135 % (unint64_t)v1592[1];
              }
            }
            else
            {
              unint64_t v137 = (LODWORD(v1592[1]) - 1) & v135;
            }
            v138 = (uint64_t **)*((void *)v1592[0] + v137);
            if (v138)
            {
              v139 = *v138;
              if (v139)
              {
                if (v136.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    unint64_t v141 = v139[1];
                    if (v141 == v135)
                    {
                      if (*((_DWORD *)v139 + 4) == v135) {
                        goto LABEL_222;
                      }
                    }
                    else if ((v141 & ((unint64_t)v1592[1] - 1)) != v137)
                    {
                      goto LABEL_202;
                    }
                    v139 = (uint64_t *)*v139;
                    if (!v139) {
                      goto LABEL_202;
                    }
                  }
                }
                do
                {
                  unint64_t v140 = v139[1];
                  if (v140 == v135)
                  {
                    if (*((_DWORD *)v139 + 4) == v135) {
                      goto LABEL_222;
                    }
                  }
                  else
                  {
                    if ((void *)v140 >= v1592[1]) {
                      v140 %= (unint64_t)v1592[1];
                    }
                    if (v140 != v137) {
                      break;
                    }
                  }
                  v139 = (uint64_t *)*v139;
                }
                while (v139);
              }
            }
          }
LABEL_202:
          if (v134 >= v133)
          {
            unint64_t v8 = (v134 - v129) >> 2;
            unint64_t v143 = v8 + 1;
            if ((v8 + 1) >> 62)
            {
              __p = v129;
              abort();
            }
            if ((v133 - v129) >> 1 > v143) {
              unint64_t v143 = (v133 - v129) >> 1;
            }
            if ((unint64_t)(v133 - v129) >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v144 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v144 = v143;
            }
            if (v144)
            {
              if (v144 >> 62) {
LABEL_2370:
              }
                std::__throw_bad_array_new_length[abi:nn180100]();
              v145 = operator new(4 * v144);
            }
            else
            {
              v145 = 0;
            }
            v146 = &v145[4 * v8];
            _DWORD *v146 = v131;
            v142 = (std::__shared_weak_count *)(v146 + 1);
            if (v134 != v129)
            {
              unint64_t v147 = v134 - 4 - v129;
              if (v147 < 0xBC)
              {
                v148 = v134;
                goto LABEL_217;
              }
              if (&v145[v134 - v129 - 4 - (v147 & 0xFFFFFFFFFFFFFFFCLL)] > &v145[v134 - v129 - 4])
              {
                v148 = v134;
                goto LABEL_217;
              }
              if (&v134[-(v147 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v134 - 4)
              {
                v148 = v134;
                goto LABEL_217;
              }
              if ((unint64_t)(v129 - v145) < 0x20)
              {
                v148 = v134;
                goto LABEL_217;
              }
              uint64_t v150 = (v147 >> 2) + 1;
              v148 = &v134[-4 * (v150 & 0x7FFFFFFFFFFFFFF8)];
              v151 = &v145[4 * v8 - 16];
              v152 = v134 - 16;
              uint64_t v153 = v150 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                long long v154 = *(_OWORD *)v152;
                *(v151 - 1) = *((_OWORD *)v152 - 1);
                _OWORD *v151 = v154;
                v151 -= 2;
                v152 -= 32;
                v153 -= 8;
              }
              while (v153);
              v146 -= v150 & 0x7FFFFFFFFFFFFFF8;
              if (v150 != (v150 & 0x7FFFFFFFFFFFFFF8))
              {
                do
                {
LABEL_217:
                  int v149 = *((_DWORD *)v148 - 1);
                  v148 -= 4;
                  *--v146 = v149;
                }
                while (v148 != v129);
              }
            }
            v133 = &v145[4 * v144];
            v1598 = v142;
            if (v129) {
              operator delete(v129);
            }
            v129 = (char *)v146;
            goto LABEL_221;
          }
          *(_DWORD *)v134 = v131;
          v142 = (std::__shared_weak_count *)(v134 + 4);
LABEL_221:
          v1598 = v142;
          unint64_t v130 = *(unsigned int *)(v59 + 100);
          v134 = (char *)v142;
LABEL_222:
          ++v131;
        }
        while (v131 < v130);
        v1599 = v133;
        __p = v129;
        if (v129 != v134)
        {
          if (v1464)
          {
            md::LabelFeaturePool::addLineFeature(&v1601, (uint64_t)v1473, (uint64_t *)v59, (char **)&__p, 0, (uint64_t)&v1568, v1447, v1451);
            uint64_t v155 = (uint64_t)v1601;
            v156 = v1602;
            if (v1602) {
              atomic_fetch_add_explicit(&v1602->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            }
            v157 = (uint64_t **)(a1 + 48);
LABEL_239:
            v158 = *v157;
            v159 = v157;
            if (*v157)
            {
              while (1)
              {
                v157 = (uint64_t **)v158;
                unint64_t v160 = v158[5];
                if ((unint64_t)v156 < v160) {
                  goto LABEL_239;
                }
                if (v160 >= (unint64_t)v156) {
                  break;
                }
                v158 = v157[1];
                if (!v158)
                {
                  v159 = v157 + 1;
                  goto LABEL_244;
                }
              }
              if (v156) {
                std::__shared_weak_count::__release_weak(v156);
              }
            }
            else
            {
LABEL_244:
              v161 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)a1 + 7) + 16))(*((void *)a1 + 7), 48, 8);
              v161[4] = v155;
              v161[5] = (uint64_t)v156;
              uint64_t *v161 = 0;
              v161[1] = 0;
              v161[2] = (uint64_t)v157;
              *v159 = v161;
              v162 = (void *)**v1405;
              if (v162)
              {
                *v1405 = v162;
                v161 = *v159;
              }
              std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)a1 + 6), v161);
              ++*((void *)a1 + 8);
            }
            if (v1573[25])
            {
              v163 = v1601;
              v164 = *(void **)&v1609[8];
              if (*(void *)&v1609[8] >= *(void *)&v1609[16])
              {
                unint64_t v174 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v1609[8] - *(void *)v1609) >> 3);
                unint64_t v175 = v174 + 1;
                if (v174 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  abort();
                }
                if (0x5555555555555556 * ((uint64_t)(*(void *)&v1609[16] - *(void *)v1609) >> 3) > v175) {
                  unint64_t v175 = 0x5555555555555556 * ((uint64_t)(*(void *)&v1609[16] - *(void *)v1609) >> 3);
                }
                uint64_t v176 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v1609[16] - *(void *)v1609) >> 3) >= 0x555555555555555
                     ? 0xAAAAAAAAAAAAAAALL
                     : v175;
                if (v176)
                {
                  uint64_t v177 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1610 + 16))(v1610, 24 * v176, 8);
                  v178 = (void *)(v177 + 24 * v174);
                  uint64_t v179 = v177 + 24 * v176;
                  if (v177)
                  {
                    void *v178 = v163;
                    unint64_t v180 = v177 + 24 * v174;
                    *(void *)(v180 + 8) = 0;
                    *(void *)(v180 + 16) = 0;
                  }
                }
                else
                {
                  uint64_t v179 = 0;
                  v178 = (void *)(8 * ((uint64_t)(*(void *)&v1609[8] - *(void *)v1609) >> 3));
                }
                uint64_t v182 = *(void *)v1609;
                uint64_t v181 = *(void *)&v1609[8];
                v183 = v178;
                if (*(void *)&v1609[8] != *(void *)v1609)
                {
                  do
                  {
                    long long v184 = *(_OWORD *)(v181 - 24);
                    *(v183 - 1) = *(void *)(v181 - 8);
                    *(_OWORD *)(v183 - 3) = v184;
                    v183 -= 3;
                    v181 -= 24;
                  }
                  while (v181 != v182);
                  uint64_t v181 = *(void *)v1609;
                }
                v165 = v178 + 3;
                *(void *)v1609 = v183;
                *(void *)&v1609[8] = v178 + 3;
                uint64_t v185 = *(void *)&v1609[16];
                *(void *)&v1609[16] = v179;
                if (v181) {
                  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1610 + 40))(v1610, v181, v185 - v181);
                }
              }
              else
              {
                if (*(void *)&v1609[8])
                {
                  *(void *)(*(void *)&v1609[8] + 8) = 0;
                  v164[2] = 0;
                  void *v164 = v163;
                }
                v165 = v164 + 3;
              }
              *(void *)&v1609[8] = v165;
              if (v165 != *(void **)v1609 && 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v165 - *(void *)v1609) >> 3) >= 0x20)
              {
                md::LabelFeatureStyler::styleLabelFeatures(*(unsigned int **)(v1482 + 296), (char **)v1609, 1u, 1, *(void *)(*(void *)(v1482 + 152) + 32));
                *(void *)&v1609[8] = *(void *)v1609;
                std::mutex::unlock(v1473);
                if (!v1473) {
                  goto LABEL_2422;
                }
                std::mutex::lock(v1473);
              }
            }
LABEL_288:
            v167 = v1602;
            if (v1602)
            {
LABEL_289:
              if (!atomic_fetch_add(&v167->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v167->__on_zero_shared)(v167);
                std::__shared_weak_count::__release_weak(v167);
              }
            }
          }
          else
          {
            md::LabelFeaturePool::addUnnamedLineFeature(&v1601, (uint64_t)v1473, (uint64_t *)v59, (char **)&__p, 0, (uint64_t)&v1568, v1447, v1451);
            uint64_t v166 = (uint64_t)v1601;
            v167 = v1602;
            if (v1602) {
              atomic_fetch_add_explicit(&v1602->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            }
            v168 = (uint64_t **)(a1 + 80);
LABEL_257:
            v169 = *v168;
            v170 = v168;
            if (!*v168)
            {
LABEL_262:
              v172 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)a1 + 11) + 16))(*((void *)a1 + 11), 48, 8);
              v172[4] = v166;
              v172[5] = (uint64_t)v167;
              uint64_t *v172 = 0;
              v172[1] = 0;
              v172[2] = (uint64_t)v168;
              *v170 = v172;
              v173 = (void *)**v1404;
              if (v173)
              {
                *v1404 = v173;
                v172 = *v170;
              }
              std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)a1 + 10), v172);
              ++*((void *)a1 + 12);
              goto LABEL_288;
            }
            while (1)
            {
              v168 = (uint64_t **)v169;
              unint64_t v171 = v169[5];
              if ((unint64_t)v167 < v171) {
                goto LABEL_257;
              }
              if (v171 >= (unint64_t)v167) {
                break;
              }
              v169 = v168[1];
              if (!v169)
              {
                v170 = v168 + 1;
                goto LABEL_262;
              }
            }
            if (v167)
            {
              std::__shared_weak_count::__release_weak(v167);
              goto LABEL_289;
            }
          }
        }
LABEL_164:
        unint64_t v122 = (v122 + 1);
        v59 += 168;
        if (v1457 <= v122)
        {
          BOOL v42 = v1430;
          if (*(void *)v1609 != *(void *)&v1609[8])
          {
            md::LabelFeatureStyler::styleLabelFeatures(*(unsigned int **)(v1482 + 296), (char **)v1609, 1u, 1, *(void *)(*(void *)(v1482 + 152) + 32));
            *(void *)&v1609[8] = *(void *)v1609;
            std::mutex::unlock(v1473);
            if (!v1473) {
              goto LABEL_2422;
            }
            std::mutex::lock(v1473);
          }
          if (__p) {
            operator delete(__p);
          }
          std::mutex::unlock(v1473);
          v186 = v1593[0];
          if (v1593[0])
          {
            do
            {
              v187 = (void *)*v186;
              operator delete(v186);
              v186 = v187;
            }
            while (v187);
          }
          v188 = v1592[0];
          v1592[0] = 0;
          if (v188) {
            operator delete(v188);
          }
          if (*(void *)v1609)
          {
            *(void *)&v1609[8] = *(void *)v1609;
            (*(void (**)(uint64_t, void, void))(*(void *)v1610 + 40))(v1610, *(void *)v1609, *(void *)&v1609[16] - *(void *)v1609);
          }
          v60 = v1575;
          if (!v1575) {
            goto LABEL_307;
          }
LABEL_305:
          if (!atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
            std::__shared_weak_count::__release_weak(v60);
          }
LABEL_307:
          if (v1426 == 14)
          {
            uint64_t v1458 = geo::codec::VectorTile::linesCount(*(geo::codec::VectorTile **)a3);
            BOOL v42 = v1430;
            if (v1458)
            {
              std::mutex::lock(v1473);
              v189 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v1473[7].__m_.__opaque, *(void *)a3);
              if (!v189)
              {
                v336 = v1473;
                goto LABEL_540;
              }
              v190 = v189;
              BOOL v42 = v1430;
              if (!v189[52])
              {
                v191 = (std::__shared_weak_count *)operator new(0x100uLL);
                v191->__shared_owners_ = 0;
                v191->__shared_weak_owners_ = 0;
                v191->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581590;
                uint64_t v192 = md::LabelTileCollisionInfo::LabelTileCollisionInfo((uint64_t)&v191[1], v1401);
                atomic_fetch_add_explicit(&v191->__shared_owners_, 1uLL, memory_order_relaxed);
                v193 = (std::__shared_weak_count *)v190[53];
                v190[52] = v192;
                v190[53] = v191;
                if (v193 && !atomic_fetch_add(&v193->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v193->__on_zero_shared)(v193);
                  std::__shared_weak_count::__release_weak(v193);
                }
                if (!atomic_fetch_add(&v191->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v191->__on_zero_shared)(v191);
                  std::__shared_weak_count::__release_weak(v191);
                }
              }
              uint64_t v195 = v190[52];
              uint64_t v194 = v190[53];
              if (v194) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v194 + 16), 1uLL, memory_order_relaxed);
              }
              v196 = (std::__shared_weak_count *)*((void *)a1 + 34);
              *((void *)a1 + 33) = v195;
              *((void *)a1 + 34) = v194;
              if (v196) {
                std::__shared_weak_count::__release_weak(v196);
              }
              uint64_t v197 = v190[52];
              std::mutex::unlock(v1473);
              if (v197)
              {
                std::mutex::lock((std::mutex *)v197);
                if (*(unsigned char *)(v197 + 224)) {
                  goto LABEL_539;
                }
                *(unsigned char *)(v197 + 224) = 1;
                *(unsigned char *)(v197 + 225) = *(unsigned char *)(geo::codec::VectorTile::key(*(geo::codec::VectorTile **)a3) + 1) & 0x3F;
                uint64_t v198 = geo::codec::VectorTile::lines(*(geo::codec::VectorTile **)a3);
                uint64_t v199 = 0;
                __srca = (float **)(v197 + 128);
                while (1)
                {
                  uint64_t v1465 = v199;
                  if (*(_DWORD *)(v198 + 100)) {
                    break;
                  }
LABEL_323:
                  uint64_t v199 = v1465 + 1;
                  v198 += 168;
                  if (v1465 + 1 == v1458)
                  {
                    md::LabelTileCollisionInfo::simplifyPaths((md::LabelTileCollisionInfo *)v197, 0.00100000005);
LABEL_539:
                    v336 = (std::mutex *)v197;
LABEL_540:
                    std::mutex::unlock(v336);
                    BOOL v42 = v1430;
                    goto LABEL_541;
                  }
                }
                unint64_t v200 = 0;
                while (2)
                {
                  v1592[0] = 0;
                  *(void *)v1609 = 0;
                  v201 = geo::codec::multiSectionFeaturePointsWithElevation((void *)v198, v200, v1609, v1592);
                  unsigned int v202 = v1592[0];
                  if (v1592[0] < (void *)2) {
                    goto LABEL_326;
                  }
                  unint64_t v203 = (unint64_t)v201;
                  v204 = *(char **)v1609;
                  uint64_t v205 = (*(void *)(v197 + 104) - *(void *)(v197 + 96)) >> 3;
                  v206 = *(_DWORD **)(v197 + 200);
                  unint64_t v207 = *(void *)(v197 + 208);
                  if ((unint64_t)v206 < v207)
                  {
                    if (v206)
                    {
                      _DWORD *v206 = v205;
                      v206[1] = v202;
                    }
                    v208 = v206 + 2;
                    goto LABEL_355;
                  }
                  uint64_t v209 = *(void *)(v197 + 192);
                  uint64_t v210 = ((uint64_t)v206 - v209) >> 3;
                  unint64_t v211 = v210 + 1;
                  if ((unint64_t)(v210 + 1) >> 61) {
                    goto LABEL_2386;
                  }
                  uint64_t v212 = v207 - v209;
                  if (v212 >> 2 > v211) {
                    unint64_t v211 = v212 >> 2;
                  }
                  if ((unint64_t)v212 >= 0x7FFFFFFFFFFFFFF8) {
                    uint64_t v213 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    uint64_t v213 = v211;
                  }
                  if (v213)
                  {
                    uint64_t v214 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v197 + 216) + 16))(*(void *)(v197 + 216), 8 * v213, 4);
                    v215 = (_DWORD *)(v214 + 8 * v210);
                    uint64_t v216 = v214 + 8 * v213;
                    if (v214)
                    {
                      _DWORD *v215 = v205;
                      v215[1] = v202;
                    }
                  }
                  else
                  {
                    uint64_t v216 = 0;
                    v215 = (_DWORD *)(8 * v210);
                  }
                  uint64_t v218 = *(void *)(v197 + 192);
                  uint64_t v217 = *(void *)(v197 + 200);
                  uint64_t v219 = v217 - v218;
                  if (v217 == v218)
                  {
                    v221 = v215;
                    goto LABEL_353;
                  }
                  unint64_t v220 = v219 - 8;
                  if ((unint64_t)(v219 - 8) < 0x38)
                  {
                    v221 = v215;
                  }
                  else
                  {
                    v221 = v215;
                    if ((unint64_t)(v217 - (void)v215) >= 0x20)
                    {
                      uint64_t v222 = (v220 >> 3) + 1;
                      v223 = v215 - 4;
                      v224 = (long long *)(v217 - 16);
                      uint64_t v225 = v222 & 0x3FFFFFFFFFFFFFFCLL;
                      do
                      {
                        long long v226 = *v224;
                        *(v223 - 1) = *(v224 - 1);
                        _OWORD *v223 = v226;
                        v223 -= 2;
                        v224 -= 2;
                        v225 -= 4;
                      }
                      while (v225);
                      v221 = &v215[-2 * (v222 & 0x3FFFFFFFFFFFFFFCLL)];
                      v217 -= 8 * (v222 & 0x3FFFFFFFFFFFFFFCLL);
                      if (v222 == (v222 & 0x3FFFFFFFFFFFFFFCLL))
                      {
LABEL_352:
                        uint64_t v217 = *(void *)(v197 + 192);
LABEL_353:
                        v208 = v215 + 2;
                        *(void *)(v197 + 192) = v221;
                        *(void *)(v197 + 200) = v215 + 2;
                        uint64_t v228 = *(void *)(v197 + 208);
                        *(void *)(v197 + 208) = v216;
                        if (v217) {
                          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v197 + 216) + 40))(*(void *)(v197 + 216), v217, v228 - v217);
                        }
LABEL_355:
                        *(void *)(v197 + 200) = v208;
                        uint64_t v229 = v202;
                        v230.n128_f32[0] = std::vector<gm::Matrix<float,2,1>,geo::StdAllocator<gm::Matrix<float,2,1>,mdm::Allocator>>::__insert_with_size[abi:nn180100]<gm::Matrix<float,2,1> const*,gm::Matrix<float,2,1> const*>((uint64_t *)(v197 + 96), *(void *)(v197 + 104), v203, (void *)(v203 + 8 * v202), v202);
                        unint64_t v231 = *(void *)(v197 + 136);
                        if (!v204)
                        {
                          LODWORD(__p) = 0;
                          std::vector<float,geo::StdAllocator<float,mdm::Allocator>>::insert(__srca, v231, v202, (const float *)&__p);
                          goto LABEL_326;
                        }
                        if (!v202) {
                          goto LABEL_326;
                        }
                        unint64_t v8 = (unint64_t)*__srca;
                        uint64_t v232 = v231 - (void)*__srca;
                        v233 = (float *)((char *)*__srca + (v232 & 0xFFFFFFFFFFFFFFFCLL));
                        uint64_t v234 = *(void *)(v197 + 144);
                        if (v202 <= (uint64_t)(v234 - v231) >> 2)
                        {
                          uint64_t v240 = (uint64_t)(v231 - (void)v233) >> 2;
                          uint64_t v241 = 4 * v202;
                          if (v240 >= v202)
                          {
                            v243 = &v204[4 * v202];
                            v246 = *(char **)(v197 + 136);
                          }
                          else
                          {
                            uint64_t v242 = 4 * v240;
                            v243 = &v204[v242];
                            uint64_t v244 = v241 - v242;
                            v245 = &v204[v242];
                            v246 = *(char **)(v197 + 136);
                            do
                            {
                              if (v246) {
                                *(_DWORD *)v246 = *(_DWORD *)v245;
                              }
                              v245 += 4;
                              v246 += 4;
                              v244 -= 4;
                            }
                            while (v244);
                            *(void *)(v197 + 136) = v246;
                            if ((uint64_t)(v231 - (void)v233) < 1) {
                              goto LABEL_326;
                            }
                          }
                          v247 = &v246[-v241];
                          v248 = v246;
                          while ((unint64_t)v247 < v231)
                          {
                            if (v248) {
                              *(_DWORD *)v248 = *(_DWORD *)v247;
                            }
                            v247 += 4;
                            v248 += 4;
                          }
                          v249 = (char *)&v233[(unint64_t)v241 / 4];
                          *(void *)(v197 + 136) = v248;
                          if (v246 != v249) {
                            memmove(&v246[-4 * ((v246 - v249) >> 2)], v233, v246 - v249);
                          }
                          if (v243 != v204) {
                            memmove(v233, v204, v243 - v204);
                          }
                          goto LABEL_326;
                        }
                        uint64_t v235 = v232 >> 2;
                        unint64_t v236 = (v232 >> 2) + v202;
                        if (v236 >> 62) {
LABEL_2386:
                        }
                          abort();
                        uint64_t v237 = v234 - v8;
                        if (v237 >> 1 > v236) {
                          unint64_t v236 = v237 >> 1;
                        }
                        if ((unint64_t)v237 >= 0x7FFFFFFFFFFFFFFCLL) {
                          uint64_t v238 = 0x3FFFFFFFFFFFFFFFLL;
                        }
                        else {
                          uint64_t v238 = v236;
                        }
                        if (v238) {
                          uint64_t v239 = (*(uint64_t (**)(void, uint64_t, uint64_t, __n128))(**(void **)(v197 + 152)
                        }
                                                                                             + 16))(*(void *)(v197 + 152), 4 * v238, 4, v230);
                        else {
                          uint64_t v239 = 0;
                        }
                        v250 = (_DWORD *)(v239 + 4 * v235);
                        v251 = &v250[v229];
                        uint64_t v252 = 4 * v229;
                        v253 = v250;
                        do
                        {
                          if (v253) {
                            _DWORD *v253 = *(_DWORD *)v204;
                          }
                          ++v253;
                          v204 += 4;
                          v252 -= 4;
                        }
                        while (v252);
                        v254 = *__srca;
                        if (*__srca != v233)
                        {
                          unint64_t v255 = v8 + (v232 & 0xFFFFFFFFFFFFFFFCLL) - 4 - (void)v254;
                          if (v255 < 0x3C)
                          {
                            v256 = v233;
                            goto LABEL_395;
                          }
                          v256 = v233;
                          if (v8 + (v232 & 0xFFFFFFFFFFFFFFFCLL) - (v239 + (v232 & 0xFFFFFFFFFFFFFFFCLL)) < 0x20) {
                            goto LABEL_2427;
                          }
                          uint64_t v257 = (v255 >> 2) + 1;
                          v256 = &v233[-(v257 & 0x7FFFFFFFFFFFFFF8)];
                          v258 = (float *)(v8 + 4 * v235 - 16);
                          v259 = (_OWORD *)(v239 + 4 * v235 - 16);
                          uint64_t v260 = v257 & 0x7FFFFFFFFFFFFFF8;
                          do
                          {
                            long long v261 = *(_OWORD *)v258;
                            *(v259 - 1) = *((_OWORD *)v258 - 1);
                            _OWORD *v259 = v261;
                            v258 -= 8;
                            v259 -= 2;
                            v260 -= 8;
                          }
                          while (v260);
                          v250 -= v257 & 0x7FFFFFFFFFFFFFF8;
                          if (v257 != (v257 & 0x7FFFFFFFFFFFFFF8))
                          {
LABEL_2427:
                            do
                            {
LABEL_395:
                              int v262 = *((_DWORD *)v256-- - 1);
                              *--v250 = v262;
                            }
                            while (v256 != v254);
                          }
                        }
                        v263 = *(float **)(v197 + 136);
                        if (v263 != v233)
                        {
                          v264 = (char *)((v232 & 0xFFFFFFFFFFFFFFFCLL) + v8);
                          unint64_t v265 = (char *)v263 - v264 - 4;
                          if (v265 < 0x3C) {
                            goto LABEL_2428;
                          }
                          if ((v232 & 0xFFFFFFFFFFFFFFFCLL) + v239 + 4 * v229 - (unint64_t)v264 < 0x20) {
                            goto LABEL_2428;
                          }
                          uint64_t v266 = (v265 >> 2) + 1;
                          uint64_t v267 = 4 * (v266 & 0x7FFFFFFFFFFFFFF8);
                          v233 = (float *)((char *)v233 + v267);
                          v268 = (_OWORD *)(v239 + 4 * v229 + 4 * v235 + 16);
                          v269 = (float *)(v8 + 4 * v235 + 16);
                          uint64_t v270 = v266 & 0x7FFFFFFFFFFFFFF8;
                          do
                          {
                            long long v271 = *(_OWORD *)v269;
                            *(v268 - 1) = *((_OWORD *)v269 - 1);
                            _OWORD *v268 = v271;
                            v268 += 2;
                            v269 += 8;
                            v270 -= 8;
                          }
                          while (v270);
                          v251 = (_DWORD *)((char *)v251 + v267);
                          if (v266 != (v266 & 0x7FFFFFFFFFFFFFF8))
                          {
LABEL_2428:
                            do
                            {
                              int v272 = *(_DWORD *)v233++;
                              *v251++ = v272;
                            }
                            while (v233 != v263);
                          }
                        }
                        *(void *)(v197 + 128) = v250;
                        *(void *)(v197 + 136) = v251;
                        uint64_t v273 = *(void *)(v197 + 144);
                        *(void *)(v197 + 144) = v239 + 4 * v238;
                        if (v254) {
                          (*(void (**)(void, float *, uint64_t))(**(void **)(v197 + 152) + 40))(*(void *)(v197 + 152), v254, v273 - (void)v254);
                        }
LABEL_326:
                        if (++v200 >= *(unsigned int *)(v198 + 100)) {
                          goto LABEL_323;
                        }
                        continue;
                      }
                    }
                  }
                  break;
                }
                do
                {
                  uint64_t v227 = *(void *)(v217 - 8);
                  v217 -= 8;
                  *((void *)v221 - 1) = v227;
                  v221 -= 2;
                }
                while (v217 != v218);
                goto LABEL_352;
              }
            }
          }
LABEL_541:
          if (!v42 && !v1441) {
            goto LABEL_908;
          }
          unint64_t v337 = geo::codec::VectorTile::physicalFeaturesCount(*(geo::codec::VectorTile **)a3);
          if (!v337) {
            goto LABEL_908;
          }
          if (*a1 == 11) {
            char v338 = 3;
          }
          else {
            char v338 = 0;
          }
          char v1467 = v338;
          uint64_t v339 = geo::codec::VectorTile::physicalFeatures(*(geo::codec::VectorTile **)a3);
          uint64_t v1427 = *(void *)buf;
          uint64_t v1560 = *(void *)buf;
          __int16 v1561 = v1585;
          uint64_t v1562 = *(void *)((char *)&v1585 + 4);
          long long v1563 = v1587;
          long long v1564 = v1588;
          *(_OWORD *)v1565 = *(_OWORD *)v1589;
          *(_OWORD *)&v1565[11] = *(_OWORD *)&v1589[11];
          v340 = v1591;
          v1566 = v1590;
          v1567 = v1591;
          if (v1591) {
            atomic_fetch_add_explicit(&v1591->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          std::mutex::lock(v1473);
          v341 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v1473[7].__m_.__opaque, *(void *)a3);
          if (!v341)
          {
            std::mutex::unlock(v1473);
            if (!v340) {
              goto LABEL_908;
            }
            goto LABEL_907;
          }
          v342 = v341;
          std::mutex::unlock(v1473);
          v1592[1] = 0;
          v1592[0] = 0;
          v1593[0] = 0;
          {
            operator new();
          }
          v1593[1] = (void *)mdm::Allocator::instance(void)::alloc;
          v343 = v1592[0];
          if (0xAAAAAAAAAAAAAAABLL * (((char *)v1593[0] - (char *)v1592[0]) >> 3) <= 0x1F)
          {
            v344 = v1592[1];
            uint64_t v345 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                        + 16))(mdm::Allocator::instance(void)::alloc, 768, 8);
            v346 = (char *)v1592[1];
            v347 = (char *)v1592[0];
            v348 = (char *)(v345 + 24 * ((v344 - v343) / 24));
            if (v1592[1] != v1592[0])
            {
              do
              {
                long long v349 = *(_OWORD *)(v346 - 24);
                *((void *)v348 - 1) = *((void *)v346 - 1);
                *(_OWORD *)(v348 - 24) = v349;
                v348 -= 24;
                v346 -= 24;
              }
              while (v346 != v347);
              v346 = (char *)v1592[0];
            }
            v1592[0] = v348;
            v1592[1] = (void *)(v345 + 24 * ((v344 - v343) / 24));
            v350 = v1593[0];
            v1593[0] = (void *)(v345 + 768);
            if (v346) {
              (*(void (**)(void *, char *, int64_t))(*(void *)v1593[1] + 40))(v1593[1], v346, v350 - v346);
            }
          }
          std::mutex::lock(v1473);
          __srcc = (void *)v337;
          LODWORD(v1483) = 0;
          v1598 = 0;
          __p = 0;
          opaque = v1473[3].__m_.__opaque;
          v1599 = 0;
          v1431 = v342 + 20;
          while (2)
          {
            if (!*(_DWORD *)(v339 + 100)) {
              goto LABEL_557;
            }
            int v351 = 0;
            v352 = (char *)__p;
            v353 = v1599;
            unint64_t v354 = (unint64_t)__p;
            while (2)
            {
              if (v354 < (unint64_t)v353)
              {
                *(_DWORD *)unint64_t v354 = v351;
                v354 += 4;
              }
              else
              {
                unint64_t v8 = (uint64_t)(v354 - (void)v352) >> 2;
                unint64_t v355 = v8 + 1;
                if ((v8 + 1) >> 62)
                {
                  __p = v352;
                  abort();
                }
                if ((v353 - v352) >> 1 > v355) {
                  unint64_t v355 = (v353 - v352) >> 1;
                }
                if ((unint64_t)(v353 - v352) >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v356 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v356 = v355;
                }
                if (v356)
                {
                  if (v356 >> 62) {
                    goto LABEL_2370;
                  }
                  v357 = operator new(4 * v356);
                }
                else
                {
                  v357 = 0;
                }
                v358 = &v357[4 * v8];
                _DWORD *v358 = v351;
                v359 = (std::__shared_weak_count *)(v358 + 1);
                if ((char *)v354 != v352)
                {
                  unint64_t v360 = v354 - 4 - (void)v352;
                  if (v360 < 0xBC
                    || &v357[v354 - (void)v352 - 4 - (v360 & 0xFFFFFFFFFFFFFFFCLL)] > &v357[v354 - (void)v352 - 4]
                    || v354 - 4 - (v360 & 0xFFFFFFFFFFFFFFFCLL) > v354 - 4
                    || (unint64_t)(v352 - v357) < 0x20)
                  {
                    v361 = (char *)v354;
                  }
                  else
                  {
                    uint64_t v363 = (v360 >> 2) + 1;
                    v361 = (char *)(v354 - 4 * (v363 & 0x7FFFFFFFFFFFFFF8));
                    v364 = &v357[4 * v8 - 16];
                    v365 = (long long *)(v354 - 16);
                    uint64_t v366 = v363 & 0x7FFFFFFFFFFFFFF8;
                    do
                    {
                      long long v367 = *v365;
                      *(v364 - 1) = *(v365 - 1);
                      _OWORD *v364 = v367;
                      v364 -= 2;
                      v365 -= 2;
                      v366 -= 8;
                    }
                    while (v366);
                    v358 -= v363 & 0x7FFFFFFFFFFFFFF8;
                    if (v363 == (v363 & 0x7FFFFFFFFFFFFFF8)) {
                      goto LABEL_577;
                    }
                  }
                  do
                  {
                    int v362 = *((_DWORD *)v361 - 1);
                    v361 -= 4;
                    *--v358 = v362;
                  }
                  while (v361 != v352);
                }
LABEL_577:
                v353 = &v357[4 * v356];
                v1598 = v359;
                if (v352) {
                  operator delete(v352);
                }
                v352 = (char *)v358;
                unint64_t v354 = (unint64_t)v359;
              }
              v1598 = (std::__shared_weak_count *)v354;
              if (++v351 < *(_DWORD *)(v339 + 100)) {
                continue;
              }
              break;
            }
            v1599 = v353;
            __p = v352;
            unint64_t v337 = (unint64_t)__srcc;
            if (v352 == (char *)v354) {
              goto LABEL_557;
            }
            {
              operator new();
            }
            uint64_t v368 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                        + 16))(mdm::Allocator::instance(void)::alloc, 104, 8);
            *(_OWORD *)(v368 + 16) = 0u;
            *(void *)uint64_t v368 = 1;
            *(void *)(v368 + 8) = &unk_1EF537290;
            *(_OWORD *)(v368 + 32) = 0u;
            *(void *)(v368 + 48) = 0;
            {
              operator new();
            }
            *(void *)(v368 + 56) = mdm::Allocator::instance(void)::alloc;
            v369 = *(std::__shared_weak_count **)(v339 + 8);
            if (v369 && (v369 = std::__shared_weak_count::lock(v369)) != 0) {
              uint64_t v370 = *(void *)v339;
            }
            else {
              uint64_t v370 = 0;
            }
            *(void *)(v368 + 64) = v339;
            *(void *)(v368 + 72) = v370;
            *(void *)(v368 + 80) = v369;
            *(void *)(v368 + 88) = 0;
            *(unsigned char *)(v368 + 96) = v1467;
            v371 = *(uint64_t **)(v368 + 40);
            if ((unint64_t)v371 >= *(void *)(v368 + 48))
            {
              unint64_t v354 = v368 + 64;
              uint64_t v372 = std::vector<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::StdAllocator<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::Allocator>>::__push_back_slow_path<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>> const&>((uint64_t *)(v368 + 32), v368 + 64);
            }
            else
            {
              if (v371)
              {
                uint64_t *v371 = v339;
                v371[1] = v370;
                v371[2] = (uint64_t)v369;
                if (v369) {
                  atomic_fetch_add_explicit(&v369->__shared_owners_, 1uLL, memory_order_relaxed);
                }
              }
              uint64_t v372 = (uint64_t)(v371 + 3);
            }
            *(void *)(v368 + 40) = v372;
            v1600 = (void *)v368;
            unint64_t v373 = *(unsigned __int8 *)(v368 + 96);
            uint64_t v374 = *(void *)(*(void *)(v368 + 64) + 40);
            unint64_t v375 = (v374 - 0x61C8864680B583EBLL + (v373 << 6) + (v373 >> 2)) ^ v373;
            unint64_t v376 = *(void *)&v1473[2].__m_.__opaque[48];
            if (!v376) {
              goto LABEL_638;
            }
            uint8x8_t v377 = (uint8x8_t)vcnt_s8((int8x8_t)v376);
            v377.i16[0] = vaddlv_u8(v377);
            if (v377.u32[0] > 1uLL)
            {
              unint64_t v354 = (v374 - 0x61C8864680B583EBLL + (v373 << 6) + (v373 >> 2)) ^ v373;
              if (v375 >= v376) {
                unint64_t v354 = v375 % v376;
              }
            }
            else
            {
              unint64_t v354 = v375 & (v376 - 1);
            }
            v378 = *(void **)(*(void *)&v1473[2].__m_.__opaque[40] + 8 * v354);
            if (!v378 || (v379 = (void *)*v378) == 0)
            {
LABEL_638:
              v390 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)&v1473[3].__m_.__opaque[8]
                                                                                   + 16))(*(void *)&v1473[3].__m_.__opaque[8], 24, 8);
              *(void *)v1609 = v390;
              *(void *)&v1609[8] = (char *)v1473 + 208;
              void *v390 = 0;
              v390[1] = v375;
              v390[2] = v368;
              if (v368) {
                ++*(void *)v368;
              }
              v1609[16] = 1;
              float v391 = (float)(unint64_t)(*(void *)&v1473[3].__m_.__opaque[16] + 1);
              float v392 = *(float *)&v1473[3].__m_.__opaque[24];
              if (!v376 || (float)(v392 * (float)v376) < v391)
              {
                BOOL v393 = (v376 & (v376 - 1)) != 0;
                if (v376 < 3) {
                  BOOL v393 = 1;
                }
                unint64_t v394 = v393 | (2 * v376);
                unint64_t v395 = vcvtps_u32_f32(v391 / v392);
                if (v394 <= v395) {
                  size_t v396 = v395;
                }
                else {
                  size_t v396 = v394;
                }
                if (v396 == 1)
                {
                  size_t v396 = 2;
                }
                else if ((v396 & (v396 - 1)) != 0)
                {
                  size_t v396 = std::__next_prime(v396);
                }
                unint64_t v376 = *(void *)&v1473[2].__m_.__opaque[48];
                if (v396 > v376)
                {
LABEL_652:
                  uint64_t v397 = (*(uint64_t (**)(uint64_t, size_t, uint64_t))(*(void *)v1473[3].__m_.__sig + 16))(v1473[3].__m_.__sig, 8 * v396, 8);
                  uint64_t v398 = *(void *)&v1473[2].__m_.__opaque[40];
                  *(void *)&v1473[2].__m_.__opaque[40] = v397;
                  if (v398) {
                    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1473[3].__m_.__sig + 40))(v1473[3].__m_.__sig, v398, 8 * *(void *)&v1473[2].__m_.__opaque[48]);
                  }
                  uint64_t v399 = 0;
                  *(void *)&v1473[2].__m_.__opaque[48] = v396;
                  do
                    *(void *)(*(void *)&v1473[2].__m_.__opaque[40] + 8 * v399++) = 0;
                  while (v396 != v399);
                  v400 = *(void **)opaque;
                  if (!*(void *)opaque) {
                    goto LABEL_675;
                  }
                  size_t v401 = v400[1];
                  size_t v402 = v396 - 1;
                  if ((v396 & (v396 - 1)) == 0)
                  {
                    size_t v403 = v401 & v402;
                    *(void *)(*(void *)&v1473[2].__m_.__opaque[40] + 8 * v403) = opaque;
                    for (j = (void *)*v400; *v400; j = (void *)*v400)
                    {
                      size_t v405 = j[1] & v402;
                      if (v405 == v403)
                      {
                        v400 = j;
                      }
                      else
                      {
                        uint64_t v406 = *(void *)&v1473[2].__m_.__opaque[40];
                        if (*(void *)(v406 + 8 * v405))
                        {
                          void *v400 = *j;
                          uint64_t v407 = 8 * v405;
                          void *j = **(void **)(*(void *)&v1473[2].__m_.__opaque[40] + v407);
                          **(void **)(*(void *)&v1473[2].__m_.__opaque[40] + v407) = j;
                        }
                        else
                        {
                          *(void *)(v406 + 8 * v405) = v400;
                          v400 = j;
                          size_t v403 = v405;
                        }
                      }
                    }
                    goto LABEL_675;
                  }
                  if (v401 >= v396) {
                    v401 %= v396;
                  }
                  *(void *)(*(void *)&v1473[2].__m_.__opaque[40] + 8 * v401) = opaque;
                  v411 = (void *)*v400;
                  if (!*v400)
                  {
LABEL_675:
                    unint64_t v376 = v396;
                    goto LABEL_676;
                  }
                  while (2)
                  {
                    size_t v413 = v411[1];
                    if (v413 >= v396) {
                      v413 %= v396;
                    }
                    if (v413 != v401)
                    {
                      uint64_t v414 = *(void *)&v1473[2].__m_.__opaque[40];
                      if (!*(void *)(v414 + 8 * v413))
                      {
                        *(void *)(v414 + 8 * v413) = v400;
LABEL_680:
                        v400 = v411;
                        v411 = (void *)*v411;
                        size_t v401 = v413;
                        if (!v411) {
                          goto LABEL_675;
                        }
                        continue;
                      }
                      void *v400 = *v411;
                      uint64_t v412 = 8 * v413;
                      void *v411 = **(void **)(*(void *)&v1473[2].__m_.__opaque[40] + v412);
                      **(void **)(*(void *)&v1473[2].__m_.__opaque[40] + v412) = v411;
                      v411 = v400;
                    }
                    break;
                  }
                  size_t v413 = v401;
                  goto LABEL_680;
                }
                if (v396 < v376)
                {
                  unint64_t v408 = vcvtps_u32_f32((float)*(unint64_t *)&v1473[3].__m_.__opaque[16]/ *(float *)&v1473[3].__m_.__opaque[24]);
                  if (v376 < 3
                    || (uint8x8_t v409 = (uint8x8_t)vcnt_s8((int8x8_t)v376), v409.i16[0] = vaddlv_u8(v409), v409.u32[0] > 1uLL))
                  {
                    unint64_t v408 = std::__next_prime(v408);
                  }
                  else
                  {
                    uint64_t v410 = 1 << -(char)__clz(v408 - 1);
                    if (v408 >= 2) {
                      unint64_t v408 = v410;
                    }
                  }
                  if (v396 <= v408) {
                    size_t v396 = v408;
                  }
                  if (v396 >= v376)
                  {
                    unint64_t v376 = *(void *)&v1473[2].__m_.__opaque[48];
                  }
                  else
                  {
                    if (v396) {
                      goto LABEL_652;
                    }
                    uint64_t v496 = *(void *)&v1473[2].__m_.__opaque[40];
                    *(void *)&v1473[2].__m_.__opaque[40] = 0;
                    if (v496) {
                      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1473[3].__m_.__sig + 40))(v1473[3].__m_.__sig, v496, 8 * *(void *)&v1473[2].__m_.__opaque[48]);
                    }
                    unint64_t v376 = 0;
                    *(void *)&v1473[2].__m_.__opaque[48] = 0;
                  }
                }
LABEL_676:
                if ((v376 & (v376 - 1)) != 0)
                {
                  if (v375 >= v376) {
                    unint64_t v354 = v375 % v376;
                  }
                  else {
                    unint64_t v354 = v375;
                  }
                }
                else
                {
                  unint64_t v354 = (v376 - 1) & v375;
                }
              }
              v415 = *(void **)(*(void *)&v1473[2].__m_.__opaque[40] + 8 * v354);
              if (v415)
              {
                void *v390 = *v415;
                goto LABEL_697;
              }
              void *v390 = *(void *)v1473[3].__m_.__opaque;
              *(void *)v1473[3].__m_.__opaque = v390;
              *(void *)(*(void *)&v1473[2].__m_.__opaque[40] + 8 * v354) = opaque;
              if (*v390)
              {
                unint64_t v416 = *(void *)(*v390 + 8);
                if ((v376 & (v376 - 1)) != 0)
                {
                  if (v416 >= v376) {
                    v416 %= v376;
                  }
                }
                else
                {
                  v416 &= v376 - 1;
                }
                v415 = (void *)(*(void *)&v1473[2].__m_.__opaque[40] + 8 * v416);
LABEL_697:
                void *v415 = v390;
              }
              ++*(void *)&v1473[3].__m_.__opaque[16];
              v1565[25] = 1;
              {
                operator new();
              }
              uint64_t v417 = mdm::Allocator::instance(void)::alloc;
              uint64_t v418 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                          + 16))(mdm::Allocator::instance(void)::alloc, 592, 8);
              *(void *)uint64_t v418 = &unk_1EF580FA8;
              *(void *)(v418 + 8) = 0;
              *(void *)(v418 + 16) = 0;
              *(void *)(v418 + 24) = v417;
              uint64_t v419 = v418 + 32;
              md::LineLabelFeature::LineLabelFeature(v418 + 32, 3, 1);
              *(void *)(v418 + 32) = &unk_1EF53E8C8;
              *(void *)(v418 + 472) = &unk_1EF53EB80;
              *(void *)(v418 + 480) = *(void *)(v339 + 40);
              *(_DWORD *)(v418 + 488) = *(_DWORD *)(v339 + 68);
              float v420 = *(float *)(v339 + 164);
              if (v420 == 0.0) {
                float v420 = 254.0;
              }
              *(float *)(v418 + 492) = v420;
              *(_OWORD *)(v418 + 496) = 0u;
              *(_OWORD *)(v418 + 512) = 0u;
              *(_OWORD *)(v418 + 528) = 0u;
              *(void *)(v418 + 544) = 0;
              *(_DWORD *)(v418 + 552) = 2139095039;
              *(_WORD *)(v418 + 556) = 0;
              *(unsigned char *)(v418 + 558) = 0;
              *(void *)(v418 + 560) = &unk_1EF55A018;
              *(void *)(v418 + 568) = 0;
              *(unsigned char *)(v418 + 584) = 0;
              uint64_t v422 = *(void *)(v339 + 24);
              uint64_t v421 = *(void *)(v339 + 32);
              if (v421) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v421 + 8), 1uLL, memory_order_relaxed);
              }
              unint64_t v8 = *(void *)(v418 + 456);
              *(void *)(v418 + 448) = v422;
              *(void *)(v418 + 456) = v421;
              if (v8 && !atomic_fetch_add((atomic_ullong *volatile)(v8 + 8), 0xFFFFFFFFFFFFFFFFLL))
              {
                (*(void (**)(unint64_t))(*(void *)v8 + 16))(v8);
                std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v8);
              }
              uint64_t v423 = *(void *)(v418 + 224);
              *(unsigned char *)(v423 + 122) = 3;
              *(unsigned char *)(v423 + 290) = v1561 != 255;
              md::LabelLineStore::addPhysicalFeature(v423, (uint64_t *)v339, (char **)&__p, (uint64_t)&v1560, v418 + 472);
              v424 = *(unsigned __int8 **)(v418 + 224);
              unsigned __int8 v425 = atomic_load(v424 + 80);
              if (v425) {
                md::LabelLineStore::consumeWorkUnits((md::LabelLineStore *)v424);
              }
              (*(void (**)(uint64_t, uint64_t, void))(*(void *)v419 + 32))(v419, v339, v1565[24]);
              if (v1600) {
                v426 = v1600 + 1;
              }
              else {
                v426 = 0;
              }
              v427 = (std::__shared_weak_count *)v426[2];
              v426[1] = v419;
              v426[2] = v418;
              if (v427 && !atomic_fetch_add(&v427->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v427->__on_zero_shared)(v427);
                std::__shared_weak_count::__release_weak(v427);
              }
              uint64_t v428 = *(void *)&v1473[10].__m_.__opaque[24];
              v429 = v1600;
              v430 = v1600 + 1;
              if (!v1600) {
                v430 = 0;
              }
              uint64_t v431 = v430[1];
              *(void *)(v431 + 152) = v430;
              uint64_t v432 = v428 + 1;
              *(void *)&v1473[10].__m_.__opaque[24] = v432;
              *(void *)(v431 + 72) = v432;
              *(unsigned char *)(v431 + 147) = v1467;
              goto LABEL_717;
            }
            if (v377.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v383 = v379[1];
                if (v383 == v375)
                {
                  v381 = (void *)v379[2];
                  v384 = v381 + 1;
                  if (!v381) {
                    v384 = 0;
                  }
                  if (*((unsigned __int8 *)v384 + 88) == v373 && *(void *)(v384[7] + 40) == v374) {
                    goto LABEL_626;
                  }
                }
                else if ((v383 & (v376 - 1)) != v354)
                {
                  goto LABEL_638;
                }
                v379 = (void *)*v379;
                if (!v379) {
                  goto LABEL_638;
                }
              }
            }
            while (2)
            {
              unint64_t v380 = v379[1];
              if (v380 != v375)
              {
                if (v380 >= v376) {
                  v380 %= v376;
                }
                if (v380 != v354) {
                  goto LABEL_638;
                }
LABEL_610:
                v379 = (void *)*v379;
                if (!v379) {
                  goto LABEL_638;
                }
                continue;
              }
              break;
            }
            v381 = (void *)v379[2];
            v382 = v381 + 1;
            if (!v381) {
              v382 = 0;
            }
            if (*((unsigned __int8 *)v382 + 88) != v373 || *(void *)(v382[7] + 40) != v374) {
              goto LABEL_610;
            }
LABEL_626:
            v1565[25] = 0;
            if (v381) {
              ++*v381;
            }
            _ZF = (*(void *)v368)-- == 1;
            if (_ZF)
            {
              md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk(v368 + 8);
              {
                operator new();
              }
              (*(void (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 40))(mdm::Allocator::instance(void)::alloc, v1600, 104);
              v381 = (void *)v379[2];
            }
            v1600 = v381;
            if (v381) {
              v385 = v381 + 1;
            }
            else {
              v385 = 0;
            }
            v386 = (std::mutex *)(v385[1] + 8);
            std::mutex::lock(v386);
            v387 = *(std::__shared_weak_count **)(v339 + 8);
            if (v387)
            {
              v388 = std::__shared_weak_count::lock(v387);
              if (v388)
              {
                uint64_t v389 = *(void *)v339;
                goto LABEL_873;
              }
            }
            else
            {
              v388 = 0;
            }
            uint64_t v389 = 0;
LABEL_873:
            *(void *)v1609 = v339;
            *(void *)&v1609[8] = v389;
            *(void *)&v1609[16] = v388;
            v1602 = 0;
            v1601 = 0;
            v498 = (uint64_t *)v385[4];
            if ((unint64_t)v498 >= v385[5])
            {
              uint64_t v499 = std::vector<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::StdAllocator<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::Allocator>>::__push_back_slow_path<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>>(v385 + 3, (uint64_t)v1609);
              v388 = *(std::__shared_weak_count **)&v1609[16];
            }
            else
            {
              if (v498)
              {
                uint64_t *v498 = v339;
                v498[1] = v389;
                v498[2] = (uint64_t)v388;
                *(void *)&v1609[8] = 0;
                *(void *)&v1609[16] = 0;
                v388 = 0;
              }
              uint64_t v499 = (uint64_t)(v498 + 3);
            }
            v385[4] = v499;
            if (v388 && !atomic_fetch_add(&v388->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v388->__on_zero_shared)(v388);
              std::__shared_weak_count::__release_weak(v388);
            }
            v500 = v1602;
            if (v1602 && !atomic_fetch_add(&v1602->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v500->__on_zero_shared)(v500);
              std::__shared_weak_count::__release_weak(v500);
            }
            std::mutex::unlock(v386);
            v429 = v1600;
            v501 = v1600 + 1;
            if (!v1600) {
              v501 = 0;
            }
            md::LabelLineStore::addPhysicalFeature(*(void *)(v501[1] + 192), (uint64_t *)v339, (char **)&__p, (uint64_t)&v1560, v501[1] + 440);
LABEL_717:
            if (v429) {
              v433 = v429 + 1;
            }
            else {
              v433 = 0;
            }
            v434 = (void *)v433[1];
            unint64_t v435 = v434[9];
            unint64_t v436 = v342[18];
            if (v436)
            {
              uint8x8_t v437 = (uint8x8_t)vcnt_s8((int8x8_t)v436);
              v437.i16[0] = vaddlv_u8(v437);
              if (v437.u32[0] > 1uLL)
              {
                unint64_t v8 = v434[9];
                if (v435 >= v436) {
                  unint64_t v8 = v435 % v436;
                }
              }
              else
              {
                unint64_t v8 = (v436 - 1) & v435;
              }
              v438 = *(void **)(v342[17] + 8 * v8);
              if (v438)
              {
                v439 = (void *)*v438;
                if (v439)
                {
                  if (v437.u32[0] < 2uLL)
                  {
                    while (1)
                    {
                      uint64_t v445 = v439[1];
                      if (v445 == v435)
                      {
                        uint64_t v443 = v439[2];
                        if (v443) {
                          uint64_t v444 = v443 + 8;
                        }
                        else {
                          uint64_t v444 = 0;
                        }
                        if (*(void *)(*(void *)(v444 + 8) + 72) == v435) {
                          goto LABEL_807;
                        }
                      }
                      else if ((v445 & (v436 - 1)) != v8)
                      {
                        goto LABEL_746;
                      }
                      v439 = (void *)*v439;
                      if (!v439) {
                        goto LABEL_746;
                      }
                    }
                  }
                  do
                  {
                    unint64_t v442 = v439[1];
                    if (v442 == v435)
                    {
                      uint64_t v440 = v439[2];
                      if (v440) {
                        uint64_t v441 = v440 + 8;
                      }
                      else {
                        uint64_t v441 = 0;
                      }
                      if (*(void *)(*(void *)(v441 + 8) + 72) == v435) {
                        goto LABEL_807;
                      }
                    }
                    else
                    {
                      if (v442 >= v436) {
                        v442 %= v436;
                      }
                      if (v442 != v8) {
                        break;
                      }
                    }
                    v439 = (void *)*v439;
                  }
                  while (v439);
                }
              }
            }
LABEL_746:
            v446 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v342[21] + 16))(v342[21], 24, 8);
            *(void *)v1609 = v446;
            *(void *)&v1609[8] = v342 + 21;
            void *v446 = 0;
            v446[1] = v435;
            v446[2] = v429;
            if (v429) {
              ++*v429;
            }
            v1609[16] = 1;
            float v447 = (float)(unint64_t)(v342[22] + 1);
            float v448 = *((float *)v342 + 46);
            if (!v436 || (float)(v448 * (float)v436) < v447)
            {
              BOOL v449 = (v436 & (v436 - 1)) != 0;
              if (v436 < 3) {
                BOOL v449 = 1;
              }
              unint64_t v450 = v449 | (2 * v436);
              unint64_t v451 = vcvtps_u32_f32(v447 / v448);
              if (v450 <= v451) {
                size_t v452 = v451;
              }
              else {
                size_t v452 = v450;
              }
              if (v452 == 1)
              {
                size_t v452 = 2;
              }
              else if ((v452 & (v452 - 1)) != 0)
              {
                size_t v452 = std::__next_prime(v452);
              }
              unint64_t v436 = v342[18];
              if (v452 > v436)
              {
LABEL_760:
                uint64_t v453 = (*(uint64_t (**)(void, size_t, uint64_t))(*(void *)v342[19] + 16))(v342[19], 8 * v452, 8);
                uint64_t v454 = v342[17];
                v342[17] = v453;
                if (v454) {
                  (*(void (**)(void, uint64_t, uint64_t))(*(void *)v342[19] + 40))(v342[19], v454, 8 * v342[18]);
                }
                uint64_t v455 = 0;
                v342[18] = v452;
                do
                  *(void *)(v342[17] + 8 * v455++) = 0;
                while (v452 != v455);
                v456 = (void *)*v1431;
                if (!*v1431) {
                  goto LABEL_783;
                }
                size_t v457 = v456[1];
                size_t v458 = v452 - 1;
                if ((v452 & (v452 - 1)) == 0)
                {
                  size_t v459 = v457 & v458;
                  *(void *)(v342[17] + 8 * v459) = v1431;
                  for (k = (void *)*v456; *v456; k = (void *)*v456)
                  {
                    size_t v461 = k[1] & v458;
                    if (v461 == v459)
                    {
                      v456 = k;
                    }
                    else
                    {
                      uint64_t v462 = v342[17];
                      if (*(void *)(v462 + 8 * v461))
                      {
                        void *v456 = *k;
                        uint64_t v463 = 8 * v461;
                        void *k = **(void **)(v342[17] + v463);
                        **(void **)(v342[17] + v463) = k;
                      }
                      else
                      {
                        *(void *)(v462 + 8 * v461) = v456;
                        v456 = k;
                        size_t v459 = v461;
                      }
                    }
                  }
                  goto LABEL_783;
                }
                if (v457 >= v452) {
                  v457 %= v452;
                }
                *(void *)(v342[17] + 8 * v457) = v1431;
                v467 = (void *)*v456;
                if (!*v456)
                {
LABEL_783:
                  unint64_t v436 = v452;
                  goto LABEL_784;
                }
                while (2)
                {
                  size_t v469 = v467[1];
                  if (v469 >= v452) {
                    v469 %= v452;
                  }
                  if (v469 != v457)
                  {
                    uint64_t v470 = v342[17];
                    if (!*(void *)(v470 + 8 * v469))
                    {
                      *(void *)(v470 + 8 * v469) = v456;
LABEL_788:
                      v456 = v467;
                      v467 = (void *)*v467;
                      size_t v457 = v469;
                      if (!v467) {
                        goto LABEL_783;
                      }
                      continue;
                    }
                    void *v456 = *v467;
                    uint64_t v468 = 8 * v469;
                    void *v467 = **(void **)(v342[17] + v468);
                    **(void **)(v342[17] + v468) = v467;
                    v467 = v456;
                  }
                  break;
                }
                size_t v469 = v457;
                goto LABEL_788;
              }
              if (v452 < v436)
              {
                unint64_t v464 = vcvtps_u32_f32((float)(unint64_t)v342[22] / *((float *)v342 + 46));
                if (v436 < 3
                  || (uint8x8_t v465 = (uint8x8_t)vcnt_s8((int8x8_t)v436), v465.i16[0] = vaddlv_u8(v465), v465.u32[0] > 1uLL))
                {
                  unint64_t v464 = std::__next_prime(v464);
                }
                else
                {
                  uint64_t v466 = 1 << -(char)__clz(v464 - 1);
                  if (v464 >= 2) {
                    unint64_t v464 = v466;
                  }
                }
                if (v452 <= v464) {
                  size_t v452 = v464;
                }
                if (v452 >= v436)
                {
                  unint64_t v436 = v342[18];
                }
                else
                {
                  if (v452) {
                    goto LABEL_760;
                  }
                  uint64_t v497 = v342[17];
                  v342[17] = 0;
                  if (v497) {
                    (*(void (**)(void, uint64_t, uint64_t))(*(void *)v342[19] + 40))(v342[19], v497, 8 * v342[18]);
                  }
                  unint64_t v436 = 0;
                  v342[18] = 0;
                }
              }
LABEL_784:
              if ((v436 & (v436 - 1)) != 0)
              {
                if (v435 >= v436) {
                  unint64_t v8 = v435 % v436;
                }
                else {
                  unint64_t v8 = v435;
                }
              }
              else
              {
                unint64_t v8 = (v436 - 1) & v435;
              }
            }
            v471 = *(void **)(v342[17] + 8 * v8);
            if (v471)
            {
              void *v446 = *v471;
              goto LABEL_805;
            }
            void *v446 = v342[20];
            v342[20] = v446;
            *(void *)(v342[17] + 8 * v8) = v1431;
            if (*v446)
            {
              unint64_t v472 = *(void *)(*v446 + 8);
              if ((v436 & (v436 - 1)) != 0)
              {
                if (v472 >= v436) {
                  v472 %= v436;
                }
              }
              else
              {
                v472 &= v436 - 1;
              }
              v471 = (void *)(v342[17] + 8 * v472);
LABEL_805:
              void *v471 = v446;
            }
            ++v342[22];
            v434 = (void *)v433[1];
LABEL_807:
            v473 = (std::__shared_weak_count *)v433[2];
            v1595 = v434;
            v1596 = v473;
            v474 = (uint64_t **)(a1 + 112);
            if (v473) {
              atomic_fetch_add_explicit(&v473->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v429 && (_ZF = *v429 == 1, --*v429, _ZF))
            {
              md::LabelFeatureThunk<md::PhysicalLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk((uint64_t)(v429 + 1));
              {
                operator new();
              }
              (*(void (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 40))(mdm::Allocator::instance(void)::alloc, v1600, 104);
              v434 = v1595;
              v473 = v1596;
              if (v1596) {
LABEL_812:
              }
                atomic_fetch_add_explicit(&v473->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            }
            else if (v473)
            {
              goto LABEL_812;
            }
LABEL_813:
            v475 = *v474;
            v476 = v474;
            if (!*v474) {
              goto LABEL_818;
            }
            do
            {
              v474 = (uint64_t **)v475;
              unint64_t v477 = v475[5];
              if ((unint64_t)v473 < v477) {
                goto LABEL_813;
              }
              if (v477 >= (unint64_t)v473)
              {
                if (v473) {
                  std::__shared_weak_count::__release_weak(v473);
                }
                goto LABEL_821;
              }
              v475 = v474[1];
            }
            while (v475);
            v476 = v474 + 1;
LABEL_818:
            v478 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)a1 + 15) + 16))(*((void *)a1 + 15), 48, 8);
            v478[4] = (uint64_t)v434;
            v478[5] = (uint64_t)v473;
            uint64_t *v478 = 0;
            v478[1] = 0;
            v478[2] = (uint64_t)v474;
            *v476 = v478;
            v479 = (void *)**v1406;
            if (v479)
            {
              *v1406 = v479;
              v478 = *v476;
            }
            std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)a1 + 14), v478);
            ++*((void *)a1 + 16);
LABEL_821:
            unint64_t v337 = (unint64_t)__srcc;
            if (v1565[25])
            {
              v480 = v1595;
              v481 = v1592[1];
              if (v1592[1] >= v1593[0])
              {
                unint64_t v483 = 0xAAAAAAAAAAAAAAABLL * (((char *)v1592[1] - (char *)v1592[0]) >> 3);
                unint64_t v484 = v483 + 1;
                if (v483 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  abort();
                }
                if (0x5555555555555556 * (((char *)v1593[0] - (char *)v1592[0]) >> 3) > v484) {
                  unint64_t v484 = 0x5555555555555556 * (((char *)v1593[0] - (char *)v1592[0]) >> 3);
                }
                uint64_t v485 = 0xAAAAAAAAAAAAAAABLL * (((char *)v1593[0] - (char *)v1592[0]) >> 3) >= 0x555555555555555
                     ? 0xAAAAAAAAAAAAAAALL
                     : v484;
                if (v485)
                {
                  uint64_t v486 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v1593[1] + 16))(v1593[1], 24 * v485, 8);
                  v487 = (char *)(v486 + 24 * v483);
                  v488 = (void *)(v486 + 24 * v485);
                  if (v486)
                  {
                    *(void *)v487 = v480;
                    unint64_t v489 = v486 + 24 * v483;
                    *(void *)(v489 + 8) = 0;
                    *(void *)(v489 + 16) = 0;
                  }
                }
                else
                {
                  v488 = 0;
                  v487 = (char *)(8 * (((char *)v1592[1] - (char *)v1592[0]) >> 3));
                }
                v490 = (char *)v1592[1];
                v491 = (char *)v1592[0];
                v492 = v487;
                if (v1592[1] != v1592[0])
                {
                  do
                  {
                    long long v493 = *(_OWORD *)(v490 - 24);
                    *((void *)v492 - 1) = *((void *)v490 - 1);
                    *(_OWORD *)(v492 - 24) = v493;
                    v492 -= 24;
                    v490 -= 24;
                  }
                  while (v490 != v491);
                  v490 = (char *)v1592[0];
                }
                v482 = v487 + 24;
                v1592[0] = v492;
                v1592[1] = v487 + 24;
                v494 = v1593[0];
                v1593[0] = v488;
                if (v490) {
                  (*(void (**)(void *, char *, int64_t))(*(void *)v1593[1] + 40))(v1593[1], v490, v494 - v490);
                }
              }
              else
              {
                if (v1592[1])
                {
                  *((void *)v1592[1] + 1) = 0;
                  v481[2] = 0;
                  void *v481 = v480;
                }
                v482 = v481 + 3;
              }
              v1592[1] = v482;
              if (v482 != v1592[0]
                && 0xAAAAAAAAAAAAAAABLL * ((int64_t)((uint64_t)v482 - (unint64_t)v1592[0]) >> 3) >= 0x20)
              {
                md::LabelFeatureStyler::styleLabelFeatures(*(unsigned int **)(v1427 + 296), (char **)v1592, 1u, 1, *(void *)(*(void *)(v1427 + 152) + 32));
                v1592[1] = v1592[0];
                std::mutex::unlock(v1473);
                if (v1473)
                {
                  std::mutex::lock(v1473);
                  goto LABEL_850;
                }
LABEL_2423:
                std::__throw_system_error(1, "unique_lock::lock: references null mutex");
                goto LABEL_2424;
              }
            }
LABEL_850:
            v495 = v1596;
            if (v1596 && !atomic_fetch_add(&v1596->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v495->__on_zero_shared)(v495);
              std::__shared_weak_count::__release_weak(v495);
            }
LABEL_557:
            v339 += 176;
            unint64_t v1483 = (v1483 + 1);
            if (v337 > v1483) {
              continue;
            }
            break;
          }
          if (v1592[0] != v1592[1])
          {
            md::LabelFeatureStyler::styleLabelFeatures(*(unsigned int **)(v1427 + 296), (char **)v1592, 1u, 1, *(void *)(*(void *)(v1427 + 152) + 32));
            v1592[1] = v1592[0];
            std::mutex::unlock(v1473);
            if (!v1473) {
              goto LABEL_2423;
            }
            std::mutex::lock(v1473);
          }
          if (__p) {
            operator delete(__p);
          }
          std::mutex::unlock(v1473);
          if (v1592[0])
          {
            v1592[1] = v1592[0];
            (*(void (**)(void *, void *, int64_t))(*(void *)v1593[1] + 40))(v1593[1], v1592[0], (char *)v1593[0] - (char *)v1592[0]);
          }
          v340 = v1567;
          if (!v1567)
          {
LABEL_908:
            if (v1439) {
              goto LABEL_909;
            }
            goto LABEL_934;
          }
LABEL_907:
          if (atomic_fetch_add(&v340->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_908;
          }
          ((void (*)(std::__shared_weak_count *))v340->__on_zero_shared)(v340);
          std::__shared_weak_count::__release_weak(v340);
          if (v1439)
          {
LABEL_909:
            if (*(void *)(*(void *)a3 + 3024) != *(void *)(*(void *)a3 + 3032))
            {
              v502 = (uint64_t *)(*(void *)a3 + 3024);
              uint64_t v1552 = *(void *)buf;
              __int16 v1553 = v1585;
              uint64_t v1554 = *(void *)((char *)&v1585 + 4);
              long long v1555 = v1587;
              long long v1556 = v1588;
              v1557[0] = *(_OWORD *)v1589;
              *(_OWORD *)((char *)v1557 + 11) = *(_OWORD *)&v1589[11];
              v1558 = v1590;
              v1559 = v1591;
              if (v1591) {
                atomic_fetch_add_explicit(&v1591->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              md::LabelFeaturePool::addContourLineFeatures((uint64_t)v1473, (unint64_t *)a3, v502, (uint64_t)&v1552, v1402);
              v503 = v1559;
              if (v1559 && !atomic_fetch_add(&v1559->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v503->__on_zero_shared)(v503);
                std::__shared_weak_count::__release_weak(v503);
              }
            }
            if (*(void *)(*(void *)a3 + 3136) != *(void *)(*(void *)a3 + 3144))
            {
              v504 = (uint64_t *)(*(void *)a3 + 3136);
              uint64_t v1544 = *(void *)buf;
              __int16 v1545 = v1585;
              uint64_t v1546 = *(void *)((char *)&v1585 + 4);
              long long v1547 = v1587;
              long long v1548 = v1588;
              v1549[0] = *(_OWORD *)v1589;
              *(_OWORD *)((char *)v1549 + 11) = *(_OWORD *)&v1589[11];
              v1550 = v1590;
              v1551 = v1591;
              if (v1591) {
                atomic_fetch_add_explicit(&v1591->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              md::LabelFeaturePool::addContourLineFeatures((uint64_t)v1473, (unint64_t *)a3, v504, (uint64_t)&v1544, v1402);
              v505 = v1551;
              if (v1551 && !atomic_fetch_add(&v1551->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v505->__on_zero_shared)(v505);
                std::__shared_weak_count::__release_weak(v505);
              }
            }
            if (*(void *)(*(void *)a3 + 3248) != *(void *)(*(void *)a3 + 3256))
            {
              v506 = (uint64_t *)(*(void *)a3 + 3248);
              uint64_t v1536 = *(void *)buf;
              __int16 v1537 = v1585;
              uint64_t v1538 = *(void *)((char *)&v1585 + 4);
              long long v1539 = v1587;
              long long v1540 = v1588;
              v1541[0] = *(_OWORD *)v1589;
              *(_OWORD *)((char *)v1541 + 11) = *(_OWORD *)&v1589[11];
              v1542 = v1590;
              v1543 = v1591;
              if (v1591) {
                atomic_fetch_add_explicit(&v1591->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              md::LabelFeaturePool::addContourLineFeatures((uint64_t)v1473, (unint64_t *)a3, v506, (uint64_t)&v1536, v1402);
              v507 = v1543;
              if (v1543 && !atomic_fetch_add(&v1543->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v507->__on_zero_shared)(v507);
                std::__shared_weak_count::__release_weak(v507);
              }
            }
            if (*(void *)(*(void *)a3 + 3360) != *(void *)(*(void *)a3 + 3368))
            {
              v508 = (uint64_t *)(*(void *)a3 + 3360);
              uint64_t v1528 = *(void *)buf;
              __int16 v1529 = v1585;
              uint64_t v1530 = *(void *)((char *)&v1585 + 4);
              long long v1531 = v1587;
              long long v1532 = v1588;
              v1533[0] = *(_OWORD *)v1589;
              *(_OWORD *)((char *)v1533 + 11) = *(_OWORD *)&v1589[11];
              v1534 = v1590;
              v1535 = v1591;
              if (v1591) {
                atomic_fetch_add_explicit(&v1591->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              md::LabelFeaturePool::addContourLineFeatures((uint64_t)v1473, (unint64_t *)a3, v508, (uint64_t)&v1528, v1402);
              v509 = v1535;
              if (v1535 && !atomic_fetch_add(&v1535->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v509->__on_zero_shared)(v509);
                std::__shared_weak_count::__release_weak(v509);
              }
            }
          }
LABEL_934:
          if (!v1435) {
            goto LABEL_2151;
          }
          unint64_t v510 = geo::codec::VectorTile::transitNodeCount(*(geo::codec::VectorTile **)a3);
          if (v510)
          {
            uint64_t v511 = geo::codec::VectorTile::transitNodes(*(geo::codec::VectorTile **)a3);
            uint64_t v1407 = *(void *)buf;
            uint64_t v1520 = *(void *)buf;
            __int16 v1521 = v1585;
            uint64_t v1522 = *(void *)((char *)&v1585 + 4);
            long long v1523 = v1587;
            long long v1524 = v1588;
            *(_OWORD *)v1525 = *(_OWORD *)v1589;
            *(_OWORD *)&v1525[11] = *(_OWORD *)&v1589[11];
            v1526 = v1590;
            v1527 = v1591;
            if (v1591) {
              atomic_fetch_add_explicit(&v1591->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            memset(v1609, 0, sizeof(v1609));
            {
              operator new();
            }
            uint64_t v1610 = mdm::Allocator::instance(void)::alloc;
            uint64_t v512 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                        + 16))(mdm::Allocator::instance(void)::alloc, 768, 8);
            uint64_t v513 = v512 + 768;
            uint64_t v515 = *(void *)v1609;
            uint64_t v514 = *(void *)&v1609[8];
            if (*(void *)&v1609[8] != *(void *)v1609)
            {
              do
              {
                long long v516 = *(_OWORD *)(v514 - 24);
                *(void *)(v512 - 8) = *(void *)(v514 - 8);
                *(_OWORD *)(v512 - 24) = v516;
                v512 -= 24;
                v514 -= 24;
              }
              while (v514 != v515);
              uint64_t v514 = v515;
            }
            uint64_t v517 = *(void *)&v1609[16];
            *(void *)v1609 = v512;
            *(void *)&v1609[16] = v513;
            if (v514) {
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1610 + 40))(v1610, v514, v517 - v514);
            }
            unint64_t v518 = 0;
            v519 = v1473;
            v1409 = 0;
            unint64_t v1412 = v510;
            while (1)
            {
              *(void *)&v1609[8] = *(void *)v1609;
              std::mutex::lock(v519);
              unint64_t v520 = v518;
              if (!v1409)
              {
                v521 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v1473[7].__m_.__opaque, *(void *)a3);
                if (!v521)
                {
                  std::mutex::unlock(v1473);
LABEL_1386:
                  if (*(void *)v1609)
                  {
                    *(void *)&v1609[8] = *(void *)v1609;
                    (*(void (**)(uint64_t, void, void))(*(void *)v1610 + 40))(v1610, *(void *)v1609, *(void *)&v1609[16] - *(void *)v1609);
                  }
                  v816 = v1527;
                  if (v1527 && !atomic_fetch_add(&v1527->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v816->__on_zero_shared)(v816);
                    std::__shared_weak_count::__release_weak(v816);
                  }
                  break;
                }
                v1409 = v521 + 3;
              }
              uint64_t v523 = *(void *)v1609;
              uint64_t v522 = *(void *)&v1609[8];
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v1609[8] - *(void *)v1609) >> 3) <= 0x1F
                && v518 < v510)
              {
                while (*(unsigned char *)(v511 + 321) || *(unsigned char *)(v511 + 322))
                {
LABEL_956:
                  ++v520;
                  v511 += 344;
                  if (0xAAAAAAAAAAAAAAABLL * ((v522 - v523) >> 3) > 0x1F || v520 >= v510) {
                    goto LABEL_953;
                  }
                }
                {
                  operator new();
                }
                v526 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                      + 16))(mdm::Allocator::instance(void)::alloc, 104, 8);
                unint64_t v1414 = v520;
                void *v526 = 1;
                md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::LabelFeatureThunk((uint64_t)(v526 + 1), (uint64_t *)v511, 1);
                v1595 = v526;
                v527 = std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::__emplace_unique_key_args<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator> const&>((float *)&v1473[5].__m_.__opaque[16], (uint64_t)&v1595, &v1595);
                v1525[25] = v528;
                if (!v528)
                {
                  v536 = v527;
                  v537 = (void *)v527[2];
                  if (v537) {
                    ++*v537;
                  }
                  _ZF = (*v526)-- == 1;
                  if (_ZF)
                  {
                    md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk((uint64_t)(v526 + 1));
                    {
                      operator new();
                    }
                    (*(void (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                       + 40))(mdm::Allocator::instance(void)::alloc, v1595, 104);
                    v537 = (void *)v536[2];
                  }
                  v1595 = v537;
                  if (v537) {
                    v538 = v537 + 1;
                  }
                  else {
                    v538 = 0;
                  }
                  md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::add(v538, (void *)v511);
                  v539 = v1595;
                  goto LABEL_1309;
                }
                {
                  operator new();
                }
                uint64_t v529 = mdm::Allocator::instance(void)::alloc;
                uint64_t v530 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                            + 16))(mdm::Allocator::instance(void)::alloc, 952, 8);
                *(void *)uint64_t v530 = &unk_1EF581948;
                *(void *)(v530 + 8) = 0;
                *(void *)(v530 + 16) = 0;
                *(void *)(v530 + 24) = v529;
                v1411 = md::PointLabelFeature::PointLabelFeature((md::PointLabelFeature *)(v530 + 32), (GeoCodecsPointFeature *)v511, (const md::LabelFeatureCreationParams *)&v1520);
                *(void *)(v530 + 32) = &unk_1EF544508;
                *(void *)(v530 + 704) = 0;
                *(void *)(v530 + 720) = 0;
                *(void *)(v530 + 712) = 0;
                {
                  operator new();
                }
                *(void *)(v530 + 728) = mdm::Allocator::instance(void)::alloc;
                *(void *)(v530 + 736) = 0;
                *(void *)(v530 + 752) = 0;
                *(void *)(v530 + 744) = 0;
                {
                  operator new();
                }
                *(void *)(v530 + 760) = mdm::Allocator::instance(void)::alloc;
                *(void *)(v530 + 768) = 0;
                *(void *)(v530 + 784) = 0;
                *(void *)(v530 + 776) = 0;
                {
                  operator new();
                }
                *(void *)(v530 + 792) = mdm::Allocator::instance(void)::alloc;
                *(void *)(v530 + 800) = 0;
                *(void *)(v530 + 816) = 0;
                *(void *)(v530 + 808) = 0;
                {
                  operator new();
                }
                *(void *)(v530 + 824) = mdm::Allocator::instance(void)::alloc;
                *(void *)(v530 + 832) = 0;
                *(void *)(v530 + 848) = 0;
                *(void *)(v530 + 840) = 0;
                {
                  operator new();
                }
                *(void *)(v530 + 856) = mdm::Allocator::instance(void)::alloc;
                *(void *)(v530 + 864) = 0;
                *(void *)(v530 + 880) = 0;
                *(void *)(v530 + 872) = 0;
                {
                  operator new();
                }
                v1424 = (uint64_t *)(v530 + 768);
                v1428 = (uint64_t *)(v530 + 800);
                v1443 = (uint64_t *)(v530 + 832);
                v1417 = (void *)(v530 + 864);
                v1419 = (uint64_t *)(v530 + 736);
                *(void *)(v530 + 888) = mdm::Allocator::instance(void)::alloc;
                *(void *)(v530 + 896) = *(void *)(v511 + 40);
                *(void *)(v530 + 904) = 0x8FF0000FF000000;
                *(unsigned char *)(v530 + 913) = 5;
                *(_OWORD *)(v530 + 920) = 0u;
                *(_OWORD *)(v530 + 936) = 0u;
                *(_DWORD *)(v530 + 400) = *(_DWORD *)(v511 + 300);
                uint64_t v1484 = v530;
                if (*(void *)(v511 + 312))
                {
                  geo::codec::transitNodeFeatureGetStyleAttributes((void *)v511, 0, v1592);
                  v531 = (const FeatureStyleAttributes *)v1592[0];
                  v532 = (char *)operator new(0x40uLL);
                  *((void *)v532 + 1) = 0;
                  *((void *)v532 + 2) = 0;
                  *(void *)v532 = &unk_1EF57F680;
                  FeatureStyleAttributes::FeatureStyleAttributes((FeatureStyleAttributes *)(v532 + 24), v531);
                  *(void *)(v530 + 688) = v533;
                  v534 = *(std::__shared_weak_count **)(v530 + 696);
                  *(void *)(v530 + 696) = v532;
                  if (v534 && !atomic_fetch_add(&v534->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v534->__on_zero_shared)(v534);
                    std::__shared_weak_count::__release_weak(v534);
                    v535 = (std::__shared_weak_count *)v1592[1];
                    if (v1592[1]) {
                      goto LABEL_975;
                    }
                  }
                  else
                  {
                    v535 = (std::__shared_weak_count *)v1592[1];
                    if (v1592[1])
                    {
LABEL_975:
                      if (!atomic_fetch_add(&v535->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v535->__on_zero_shared)(v535);
                        std::__shared_weak_count::__release_weak(v535);
                      }
                    }
                  }
                }
                v1592[1] = 0;
                {
                  operator new();
                }
                v1593[1] = 0;
                v1593[0] = (void *)mdm::Allocator::instance(void)::alloc;
                v1592[0] = &v1592[1];
                v540 = *(std::__shared_weak_count **)(v511 + 8);
                if (v540)
                {
                  v541 = std::__shared_weak_count::lock(v540);
                  if (v541) {
                    v542 = *(geo::codec::VectorTile **)v511;
                  }
                  else {
                    v542 = 0;
                  }
                }
                else
                {
                  v542 = 0;
                  v541 = 0;
                }
                uint64_t v543 = geo::codec::VectorTile::transitLines(v542);
                unint64_t v544 = geo::codec::VectorTile::transitLineCount(v542);
                unint64_t v545 = *(unsigned __int16 *)(v511 + 276);
                uint64_t v546 = *(void *)(v530 + 864);
                if (v545 > (*(void *)(v530 + 880) - v546) >> 3)
                {
                  uint64_t v547 = *(void *)(v530 + 872);
                  uint64_t v548 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v530 + 888) + 16))(*(void *)(v530 + 888), 8 * v545, 8);
                  uint64_t v549 = v547 - v546;
                  unint64_t v550 = v548 + ((v547 - v546) & 0xFFFFFFFFFFFFFFF8);
                  uint64_t v551 = *(void *)(v530 + 872);
                  uint64_t v552 = *(void *)(v530 + 864);
                  unint64_t v553 = v550;
                  if (v551 != v552)
                  {
                    unint64_t v554 = v551 - v552 - 8;
                    if (v554 < 0x58)
                    {
                      unint64_t v553 = v548 + ((v547 - v546) & 0xFFFFFFFFFFFFFFF8);
                      goto LABEL_1002;
                    }
                    unint64_t v553 = v548 + ((v547 - v546) & 0xFFFFFFFFFFFFFFF8);
                    if (v551 - (v549 & 0xFFFFFFFFFFFFFFF8) - v548 < 0x20) {
                      goto LABEL_2429;
                    }
                    uint64_t v555 = v549 >> 3;
                    uint64_t v556 = (v554 >> 3) + 1;
                    uint64_t v557 = v551 - 8 * (v556 & 0x3FFFFFFFFFFFFFFCLL);
                    v558 = (_OWORD *)(v548 + 8 * v555 - 16);
                    v559 = (long long *)(v551 - 16);
                    uint64_t v560 = v556 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v561 = *v559;
                      *(v558 - 1) = *(v559 - 1);
                      _OWORD *v558 = v561;
                      v558 -= 2;
                      v559 -= 2;
                      v560 -= 4;
                    }
                    while (v560);
                    unint64_t v553 = v550 - 8 * (v556 & 0x3FFFFFFFFFFFFFFCLL);
                    uint64_t v551 = v557;
                    if (v556 != (v556 & 0x3FFFFFFFFFFFFFFCLL))
                    {
LABEL_2429:
                      do
                      {
LABEL_1002:
                        uint64_t v562 = *(void *)(v551 - 8);
                        v551 -= 8;
                        *(void *)(v553 - 8) = v562;
                        v553 -= 8;
                      }
                      while (v551 != v552);
                    }
                  }
                  *(void *)(v530 + 864) = v553;
                  *(void *)(v530 + 872) = v550;
                  uint64_t v563 = *(void *)(v530 + 880);
                  *(void *)(v530 + 880) = v548 + 8 * v545;
                  if (v552) {
                    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v530 + 888) + 40))(*(void *)(v530 + 888), v552, v563 - v552);
                  }
                }
                if (*(_WORD *)(v511 + 276))
                {
                  unint64_t v564 = 0;
                  while (1)
                  {
                    unint64_t v565 = *(void *)(geo::codec::VectorTile::transitNodeLineIndices(v542)
                                     + 8 * (v564 + *(unsigned int *)(v511 + 288)));
                    if (v565 < v544) {
                      break;
                    }
LABEL_1008:
                    ++v564;
                    uint64_t v530 = v1484;
                    if (v564 >= *(unsigned __int16 *)(v511 + 276)) {
                      goto LABEL_1045;
                    }
                  }
                  v566 = (unint64_t *)(v543 + 104 * v565 + 40);
                  uint64_t v567 = v1484;
                  v568 = *(unint64_t **)(v1484 + 872);
                  unint64_t v569 = *(void *)(v1484 + 880);
                  if ((unint64_t)v568 < v569)
                  {
                    if (v568) {
                      unint64_t *v568 = *v566;
                    }
                    v570 = v568 + 1;
LABEL_1036:
                    *(void *)(v567 + 872) = v570;
                    v590 = (void **)v1592[1];
                    v591 = &v1592[1];
                    v592 = &v1592[1];
                    if (v1592[1])
                    {
                      unint64_t v593 = *v566;
                      do
                      {
                        while (1)
                        {
                          v591 = v590;
                          v594 = v590[4];
                          if (v593 >= (unint64_t)v594) {
                            break;
                          }
                          v590 = (void **)*v591;
                          v592 = v591;
                          if (!*v591) {
                            goto LABEL_1043;
                          }
                        }
                        if ((unint64_t)v594 >= v593) {
                          goto LABEL_1008;
                        }
                        v590 = (void **)v591[1];
                      }
                      while (v590);
                      v592 = v591 + 1;
                    }
LABEL_1043:
                    v595 = (uint64_t *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v1593[0] + 16))(v1593[0], 40, 8);
                    v595[4] = *v566;
                    uint64_t *v595 = 0;
                    v595[1] = 0;
                    v595[2] = (uint64_t)v591;
                    *v592 = v595;
                    if (*(void *)v1592[0])
                    {
                      v1592[0] = *(void **)v1592[0];
                      v595 = (uint64_t *)*v592;
                    }
                    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v1592[1], v595);
                    ++v1593[1];
                    goto LABEL_1008;
                  }
                  uint64_t v571 = ((uint64_t)v568 - *v1417) >> 3;
                  unint64_t v572 = v571 + 1;
                  if ((unint64_t)(v571 + 1) >> 61) {
                    abort();
                  }
                  uint64_t v573 = v569 - *v1417;
                  if (v573 >> 2 > v572) {
                    unint64_t v572 = v573 >> 2;
                  }
                  if ((unint64_t)v573 >= 0x7FFFFFFFFFFFFFF8) {
                    uint64_t v574 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    uint64_t v574 = v572;
                  }
                  if (v574)
                  {
                    uint64_t v575 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v1484 + 888) + 16))(*(void *)(v1484 + 888), 8 * v574, 8);
                    v576 = (unint64_t *)(v575 + 8 * v571);
                    uint64_t v577 = v575 + 8 * v574;
                    if (v575) {
                      unint64_t *v576 = *v566;
                    }
                    uint64_t v567 = v1484;
                  }
                  else
                  {
                    uint64_t v577 = 0;
                    v576 = (unint64_t *)(8 * v571);
                  }
                  uint64_t v578 = *(void *)(v567 + 872);
                  uint64_t v579 = *(void *)(v567 + 864);
                  v580 = v576;
                  if (v578 != v579)
                  {
                    unint64_t v581 = v578 - v579 - 8;
                    if (v581 < 0x38)
                    {
                      v580 = v576;
                    }
                    else
                    {
                      v580 = v576;
                      if ((unint64_t)(v578 - (void)v576) >= 0x20)
                      {
                        uint64_t v582 = (v581 >> 3) + 1;
                        uint64_t v583 = v578 - 8 * (v582 & 0x3FFFFFFFFFFFFFFCLL);
                        v584 = v576 - 2;
                        v585 = (long long *)(v578 - 16);
                        uint64_t v586 = v582 & 0x3FFFFFFFFFFFFFFCLL;
                        do
                        {
                          long long v587 = *v585;
                          *((_OWORD *)v584 - 1) = *(v585 - 1);
                          *(_OWORD *)v584 = v587;
                          v584 -= 4;
                          v585 -= 2;
                          v586 -= 4;
                        }
                        while (v586);
                        v580 = &v576[-(v582 & 0x3FFFFFFFFFFFFFFCLL)];
                        uint64_t v578 = v583;
                        if (v582 == (v582 & 0x3FFFFFFFFFFFFFFCLL)) {
                          goto LABEL_1034;
                        }
                      }
                    }
                    do
                    {
                      unint64_t v588 = *(void *)(v578 - 8);
                      v578 -= 8;
                      *--v580 = v588;
                    }
                    while (v578 != v579);
                  }
LABEL_1034:
                  v570 = v576 + 1;
                  *(void *)(v567 + 864) = v580;
                  *(void *)(v567 + 872) = v576 + 1;
                  uint64_t v589 = *(void *)(v567 + 880);
                  *(void *)(v567 + 880) = v577;
                  if (v579) {
                    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v567 + 888) + 40))(*(void *)(v567 + 888), v579, v589 - v579);
                  }
                  goto LABEL_1036;
                }
LABEL_1045:
                if (v541 && !atomic_fetch_add(&v541->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v541->__on_zero_shared)(v541);
                  std::__shared_weak_count::__release_weak(v541);
                }
                uint64_t v1448 = *(void *)(v511 + 232);
                if (!v1448) {
                  goto LABEL_1236;
                }
                v596 = *(std::__shared_weak_count **)(v511 + 8);
                if (v596)
                {
                  v596 = std::__shared_weak_count::lock(v596);
                  v597 = v596;
                  if (v596) {
                    v596 = *(std::__shared_weak_count **)v511;
                  }
                }
                else
                {
                  v597 = 0;
                }
                v1408 = v597;
                uint64_t v598 = geo::codec::VectorTile::transitLines((geo::codec::VectorTile *)v596);
                {
                  operator new();
                }
                uint64_t v1436 = mdm::Allocator::instance(void)::alloc;
                {
                  operator new();
                }
                unint64_t v599 = 0;
                v600 = 0;
                unint64_t v1459 = 0;
                __srcd = 0;
                unint64_t v1421 = 0;
                uint64_t v1413 = mdm::Allocator::instance(void)::alloc;
                uint64_t v1452 = v511;
                while (2)
                {
                  v1601 = 0;
                  geo::codec::transitNodeFeatureGetSystem((void *)v511, v599, &v1601);
                  v603 = v1601;
                  if (!v1601) {
                    goto LABEL_1058;
                  }
                  uint64_t v604 = v1601[3];
                  if (v604)
                  {
                    unint64_t v605 = *(unsigned __int8 *)(v604 + 33);
                    if (*(unsigned char *)(v604 + 33))
                    {
                      v606 = *(_DWORD **)v604;
                      if (*v606 == 49)
                      {
                        unint64_t v607 = 0;
LABEL_1064:
                        int v1468 = LOWORD(v606[2 * v607 + 1]);
                        if (v1601[1]) {
                          goto LABEL_1101;
                        }
LABEL_1065:
                        v608 = __srcd;
                        v602 = v600;
LABEL_1066:
                        std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>();
                        if (v600 != v602)
                        {
                          v609 = v600 + 4;
                          do
                          {
                            if (v609 == v602) {
                              goto LABEL_1080;
                            }
                            v610 = v609 - 4;
                            int v611 = *((_DWORD *)v609 - 1);
                            int v612 = *(_DWORD *)v609;
                            v609 += 4;
                          }
                          while (v611 != v612);
                          for (m = v610 + 8; m != v602; m += 4)
                          {
                            int v614 = v611;
                            int v611 = *(_DWORD *)m;
                            if (v614 != *(_DWORD *)m)
                            {
                              *((_DWORD *)v610 + 1) = v611;
                              v610 += 4;
                            }
                          }
                          v615 = v610 + 4;
                          v616 = (char *)(v602 - (v610 + 4));
                          if (v616)
                          {
                            size_t v617 = v602 - &v616[(void)v615];
                            if (v617) {
                              memmove(v615, &v616[(void)v615], v617);
                            }
                            v602 = (char *)v615 + v617;
                          }
                        }
LABEL_1080:
                        uint64_t v530 = v1484;
                        if (!v1468 && __srcd == v608 && v600 == v602)
                        {
                          uint64_t v601 = 0;
                          v602 = v600;
                        }
                        else
                        {
                          unint64_t v618 = *(void *)(v1484 + 808) - *(void *)(v1484 + 800);
                          uint64_t v619 = v608 - __srcd;
                          unint64_t v620 = *(void *)(v1484 + 776) - *(void *)(v1484 + 768);
                          unint64_t v621 = v602 - v600;
                          unint64_t v622 = *(void *)(v1484 + 744);
                          unint64_t v623 = *(void *)(v1484 + 752);
                          if (v622 >= v623)
                          {
                            unint64_t v626 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v622 - *v1419) >> 2);
                            unint64_t v627 = v626 + 1;
                            if (v626 + 1 > 0x1555555555555555) {
                              abort();
                            }
                            unint64_t v628 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v623 - *v1419) >> 2);
                            if (2 * v628 > v627) {
                              unint64_t v627 = 2 * v628;
                            }
                            if (v628 >= 0xAAAAAAAAAAAAAAALL) {
                              uint64_t v629 = 0x1555555555555555;
                            }
                            else {
                              uint64_t v629 = v627;
                            }
                            if (v629)
                            {
                              unint64_t v1432 = *(void *)(v1484 + 776) - *(void *)(v1484 + 768);
                              uint64_t v630 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v1484 + 760)
                                                                                         + 16))(*(void *)(v1484 + 760), 12 * v629, 4);
                              uint64_t v631 = v630 + 12 * v626;
                              uint64_t v632 = v630 + 12 * v629;
                              if (v630)
                              {
                                *(_DWORD *)uint64_t v631 = v1468;
                                uint64_t v624 = v602 - v600;
                                uint64_t v619 = v608 - __srcd;
                                *(_WORD *)(v631 + 4) = v618 >> 2;
                                *(_WORD *)(v631 + 6) = (unint64_t)(v608 - __srcd) >> 2;
                                *(unsigned char *)(v631 + 8) = v1432 >> 2;
                                *(unsigned char *)(v631 + 9) = v621 >> 2;
                              }
                              else
                              {
                                uint64_t v624 = v602 - v600;
                                uint64_t v619 = v608 - __srcd;
                              }
                            }
                            else
                            {
                              uint64_t v632 = 0;
                              uint64_t v631 = 12 * v626;
                              uint64_t v624 = v602 - v600;
                            }
                            uint64_t v530 = v1484;
                            uint64_t v685 = *(void *)(v1484 + 744);
                            uint64_t v686 = *(void *)(v1484 + 736);
                            uint64_t v511 = v1452;
                            uint64_t v687 = v631;
                            if (v685 != v686)
                            {
                              do
                              {
                                uint64_t v688 = *(void *)(v685 - 12);
                                v685 -= 12;
                                int v689 = *(_DWORD *)(v685 + 8);
                                *(void *)(v687 - 12) = v688;
                                v687 -= 12;
                                *(_DWORD *)(v687 + 8) = v689;
                              }
                              while (v685 != v686);
                              uint64_t v685 = *v1419;
                            }
                            uint64_t v625 = v631 + 12;
                            *(void *)(v1484 + 736) = v687;
                            *(void *)(v1484 + 744) = v631 + 12;
                            uint64_t v690 = *(void *)(v1484 + 752);
                            *(void *)(v1484 + 752) = v632;
                            if (v685)
                            {
                              uint64_t v691 = v619;
                              (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1484 + 760) + 40))(*(void *)(v1484 + 760), v685, v690 - v685);
                              uint64_t v619 = v691;
                            }
                          }
                          else
                          {
                            uint64_t v624 = v602 - v600;
                            if (v622)
                            {
                              *(_DWORD *)unint64_t v622 = v1468;
                              *(_WORD *)(v622 + 4) = v618 >> 2;
                              *(_WORD *)(v622 + 6) = (unint64_t)v619 >> 2;
                              *(unsigned char *)(v622 + 8) = v620 >> 2;
                              *(unsigned char *)(v622 + 9) = v621 >> 2;
                            }
                            uint64_t v625 = v622 + 12;
                            uint64_t v511 = v1452;
                            uint64_t v530 = v1484;
                          }
                          *(void *)(v530 + 744) = v625;
                          std::vector<unsigned int,geo::StdAllocator<unsigned int,mdm::Allocator>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned int *>,std::__wrap_iter<unsigned int *>>(v1428, *(void *)(v530 + 808), __srcd, v608, v619 >> 2);
                          uint64_t v601 = v624 >> 2;
                          std::vector<unsigned int,geo::StdAllocator<unsigned int,mdm::Allocator>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned int *>,std::__wrap_iter<unsigned int *>>(v1424, *(void *)(v530 + 776), v600, v602, v624 >> 2);
                        }
                        std::vector<unsigned int,geo::StdAllocator<unsigned int,mdm::Allocator>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned int *>,std::__wrap_iter<unsigned int *>>(v1443, *(void *)(v530 + 840), v600, v602, v601);
LABEL_1058:
                        if (++v599 != v1448) {
                          continue;
                        }
                        uint64_t v692 = *(void *)(v530 + 800);
                        uint64_t v693 = *(void *)(v530 + 808);
                        uint64_t v694 = v693 - v692;
                        unint64_t v695 = (v693 - v692) >> 2;
                        if (v695 < (*(void *)(v530 + 816) - v692) >> 2)
                        {
                          if (v693 == v692)
                          {
                            uint64_t v701 = 4 * v695;
                            uint64_t v698 = 4 * v695;
                          }
                          else
                          {
                            uint64_t v696 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v530 + 824) + 16))(*(void *)(v530 + 824), v694, 4);
                            uint64_t v692 = *(void *)(v530 + 808);
                            uint64_t v697 = *(void *)(v530 + 800);
                            uint64_t v698 = v696 + 4 * v695;
                            uint64_t v699 = v692 - v697;
                            if (v692 == v697)
                            {
                              uint64_t v701 = v696 + 4 * v695;
                            }
                            else
                            {
                              unint64_t v700 = v699 - 4;
                              if ((unint64_t)(v699 - 4) < 0x2C)
                              {
                                uint64_t v701 = v696 + 4 * v695;
                                goto LABEL_1210;
                              }
                              uint64_t v701 = v696 + 4 * v695;
                              if ((unint64_t)(v692 - v694 - v696) < 0x20) {
                                goto LABEL_2430;
                              }
                              uint64_t v702 = (v700 >> 2) + 1;
                              v703 = (_OWORD *)(v696 + 4 * v695 - 16);
                              v704 = (long long *)(v692 - 16);
                              uint64_t v705 = v702 & 0x7FFFFFFFFFFFFFF8;
                              do
                              {
                                long long v706 = *v704;
                                *(v703 - 1) = *(v704 - 1);
                                _OWORD *v703 = v706;
                                v703 -= 2;
                                v704 -= 2;
                                v705 -= 8;
                              }
                              while (v705);
                              uint64_t v701 = v698 - 4 * (v702 & 0x7FFFFFFFFFFFFFF8);
                              v692 -= 4 * (v702 & 0x7FFFFFFFFFFFFFF8);
                              if (v702 != (v702 & 0x7FFFFFFFFFFFFFF8))
                              {
LABEL_2430:
                                do
                                {
LABEL_1210:
                                  int v707 = *(_DWORD *)(v692 - 4);
                                  v692 -= 4;
                                  *(_DWORD *)(v701 - 4) = v707;
                                  v701 -= 4;
                                }
                                while (v692 != v697);
                              }
                              uint64_t v692 = v697;
                            }
                          }
                          *(void *)(v530 + 800) = v701;
                          *(void *)(v530 + 808) = v698;
                          uint64_t v708 = *(void *)(v530 + 816);
                          *(void *)(v530 + 816) = v698;
                          if (v692) {
                            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v530 + 824) + 40))(*(void *)(v530 + 824), v692, v708 - v692);
                          }
                        }
                        uint64_t v709 = *(void *)(v530 + 768);
                        uint64_t v710 = *(void *)(v530 + 776);
                        uint64_t v711 = v710 - v709;
                        unint64_t v712 = (v710 - v709) >> 2;
                        if (v712 < (*(void *)(v530 + 784) - v709) >> 2)
                        {
                          if (v710 == v709)
                          {
                            uint64_t v718 = 4 * v712;
                            uint64_t v715 = 4 * v712;
                          }
                          else
                          {
                            uint64_t v713 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v530 + 792) + 16))(*(void *)(v530 + 792), v711, 4);
                            uint64_t v709 = *(void *)(v530 + 776);
                            uint64_t v714 = *(void *)(v530 + 768);
                            uint64_t v715 = v713 + 4 * v712;
                            uint64_t v716 = v709 - v714;
                            if (v709 == v714)
                            {
                              uint64_t v718 = v713 + 4 * v712;
                            }
                            else
                            {
                              unint64_t v717 = v716 - 4;
                              if ((unint64_t)(v716 - 4) < 0x2C)
                              {
                                uint64_t v718 = v713 + 4 * v712;
                                goto LABEL_1225;
                              }
                              uint64_t v718 = v713 + 4 * v712;
                              if ((unint64_t)(v709 - v711 - v713) < 0x20) {
                                goto LABEL_2431;
                              }
                              uint64_t v719 = (v717 >> 2) + 1;
                              v720 = (_OWORD *)(v713 + 4 * v712 - 16);
                              v721 = (long long *)(v709 - 16);
                              uint64_t v722 = v719 & 0x7FFFFFFFFFFFFFF8;
                              do
                              {
                                long long v723 = *v721;
                                *(v720 - 1) = *(v721 - 1);
                                _OWORD *v720 = v723;
                                v720 -= 2;
                                v721 -= 2;
                                v722 -= 8;
                              }
                              while (v722);
                              uint64_t v718 = v715 - 4 * (v719 & 0x7FFFFFFFFFFFFFF8);
                              v709 -= 4 * (v719 & 0x7FFFFFFFFFFFFFF8);
                              if (v719 != (v719 & 0x7FFFFFFFFFFFFFF8))
                              {
LABEL_2431:
                                do
                                {
LABEL_1225:
                                  int v724 = *(_DWORD *)(v709 - 4);
                                  v709 -= 4;
                                  *(_DWORD *)(v718 - 4) = v724;
                                  v718 -= 4;
                                }
                                while (v709 != v714);
                              }
                              uint64_t v709 = v714;
                            }
                          }
                          *(void *)(v530 + 768) = v718;
                          *(void *)(v530 + 776) = v715;
                          uint64_t v725 = *(void *)(v530 + 784);
                          *(void *)(v530 + 784) = v715;
                          if (v709) {
                            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v530 + 792) + 40))(*(void *)(v530 + 792), v709, v725 - v709);
                          }
                        }
                        if (__srcd) {
                          (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v1413 + 40))(v1413, __srcd, v1421 - (void)__srcd);
                        }
                        if (v600) {
                          (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v1436 + 40))(v1436, v600, v1459 - (void)v600);
                        }
                        if (v1408 && !atomic_fetch_add(&v1408->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v1408->__on_zero_shared)(v1408);
                          std::__shared_weak_count::__release_weak(v1408);
                        }
LABEL_1236:
                        v726 = *(_DWORD **)(v530 + 832);
                        if (v726 != *(_DWORD **)(v530 + 840)) {
                          goto LABEL_1270;
                        }
                        uint64_t v727 = *(void *)(v511 + 24);
                        if (!v727) {
                          goto LABEL_1270;
                        }
                        unint64_t v728 = *(unsigned __int8 *)(v727 + 33);
                        if (!*(unsigned char *)(v727 + 33)) {
                          goto LABEL_1270;
                        }
                        v729 = *(_DWORD **)v727;
                        if (*v729 == 37)
                        {
                          unint64_t v730 = 0;
                          goto LABEL_1241;
                        }
                        unint64_t v730 = 0;
                        v734 = v729 + 2;
                        do
                        {
                          if (v728 - 1 == v730) {
                            goto LABEL_1270;
                          }
                          int v735 = *v734;
                          v734 += 2;
                          ++v730;
                        }
                        while (v735 != 37);
                        if (v730 >= v728)
                        {
LABEL_1270:
                          std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>();
                          v754 = *(char **)(v530 + 832);
                          v755 = *(char **)(v530 + 840);
                          if (v754 == v755) {
                            goto LABEL_1284;
                          }
                          v756 = v754 + 4;
                          do
                          {
                            if (v756 == v755) {
                              goto LABEL_1284;
                            }
                            v757 = v756 - 4;
                            int v758 = *((_DWORD *)v756 - 1);
                            int v759 = *(_DWORD *)v756;
                            v756 += 4;
                          }
                          while (v758 != v759);
                          for (n = v757 + 8; n != v755; n += 4)
                          {
                            int v761 = v758;
                            int v758 = *(_DWORD *)n;
                            if (v761 != *(_DWORD *)n)
                            {
                              *((_DWORD *)v757 + 1) = v758;
                              v757 += 4;
                            }
                          }
                          v764 = v757 + 4;
                          int64_t v765 = v755 - (v757 + 4);
                          if (v765)
                          {
                            int64_t v762 = v755 - &v764[v765];
                            if (v755 != &v764[v765]) {
                              memmove(v764, &v764[v765], v755 - &v764[v765]);
                            }
                            v763 = &v764[v762];
                            *(void *)(v530 + 840) = &v764[v762];
                          }
                          else
                          {
LABEL_1284:
                            v763 = *(char **)(v530 + 840);
                          }
                          v766 = *(char **)(v530 + 832);
                          v767 = (char *)(v763 - v766);
                          unint64_t v768 = (v763 - v766) >> 2;
                          if (v768 < (uint64_t)(*(void *)(v530 + 848) - (void)v766) >> 2)
                          {
                            if (v763 == v766)
                            {
                              uint64_t v774 = 4 * v768;
                              uint64_t v771 = 4 * v768;
                            }
                            else
                            {
                              uint64_t v769 = (*(uint64_t (**)(void, char *, uint64_t))(**(void **)(v530 + 856)
                                                                                        + 16))(*(void *)(v530 + 856), v767, 4);
                              v763 = *(char **)(v530 + 840);
                              v770 = *(char **)(v530 + 832);
                              uint64_t v771 = v769 + 4 * v768;
                              v772 = (char *)(v763 - v770);
                              if (v763 == v770)
                              {
                                uint64_t v774 = v769 + 4 * v768;
                              }
                              else
                              {
                                v773 = v772 - 4;
                                if ((unint64_t)(v772 - 4) < 0x2C)
                                {
                                  uint64_t v774 = v769 + 4 * v768;
                                  goto LABEL_1296;
                                }
                                uint64_t v774 = v769 + 4 * v768;
                                if ((unint64_t)(v763 - v767 - v769) < 0x20) {
                                  goto LABEL_2432;
                                }
                                uint64_t v775 = ((unint64_t)v773 >> 2) + 1;
                                v776 = (_OWORD *)(v769 + 4 * v768 - 16);
                                v777 = v763 - 16;
                                uint64_t v778 = v775 & 0x7FFFFFFFFFFFFFF8;
                                do
                                {
                                  long long v779 = *(_OWORD *)v777;
                                  *(v776 - 1) = *((_OWORD *)v777 - 1);
                                  _OWORD *v776 = v779;
                                  v776 -= 2;
                                  v777 -= 32;
                                  v778 -= 8;
                                }
                                while (v778);
                                uint64_t v774 = v771 - 4 * (v775 & 0x7FFFFFFFFFFFFFF8);
                                v763 -= 4 * (v775 & 0x7FFFFFFFFFFFFFF8);
                                if (v775 != (v775 & 0x7FFFFFFFFFFFFFF8))
                                {
LABEL_2432:
                                  do
                                  {
LABEL_1296:
                                    int v780 = *((_DWORD *)v763 - 1);
                                    v763 -= 4;
                                    *(_DWORD *)(v774 - 4) = v780;
                                    v774 -= 4;
                                  }
                                  while (v763 != v770);
                                }
                                v763 = v770;
                              }
                            }
                            *(void *)(v530 + 832) = v774;
                            *(void *)(v530 + 840) = v771;
                            uint64_t v781 = *(void *)(v530 + 848);
                            *(void *)(v530 + 848) = v771;
                            if (v763) {
                              (*(void (**)(void, char *, uint64_t))(**(void **)(v530 + 856) + 40))(*(void *)(v530 + 856), v763, v781 - (void)v763);
                            }
                          }
                          std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)v1592, (void *)v1592[1]);
                          if (v1595) {
                            v782 = v1595 + 1;
                          }
                          else {
                            v782 = 0;
                          }
                          v783 = (std::__shared_weak_count *)v782[2];
                          v782[1] = v1411;
                          v782[2] = v530;
                          if (v783 && !atomic_fetch_add(&v783->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v783->__on_zero_shared)(v783);
                            std::__shared_weak_count::__release_weak(v783);
                          }
                          uint64_t v784 = *(void *)&v1473[10].__m_.__opaque[24];
                          v539 = v1595;
                          v785 = v1595 + 1;
                          if (!v1595) {
                            v785 = 0;
                          }
                          uint64_t v786 = v785[1];
                          *(void *)(v786 + 152) = v785;
                          uint64_t v787 = v784 + 1;
                          *(void *)&v1473[10].__m_.__opaque[24] = v787;
                          *(void *)(v786 + 72) = v787;
                          *(unsigned char *)(v786 + 147) = 1;
LABEL_1309:
                          if (v539) {
                            v788 = v539 + 1;
                          }
                          else {
                            v788 = 0;
                          }
                          md::PointLabelFeature::addPointFeature((md::PointLabelFeature *)v788[1], (GeoCodecsPointFeature *)v511, (const md::LabelFeatureCreationParams *)&v1520);
                          std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeaturePoolTileInfo::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeaturePoolTileInfo::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::__emplace_unique_key_args<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator> const&>((unint64_t)(v1409 + 35), (uint64_t)v1595, &v1595);
                          v789 = v1595;
                          v790 = v1595 + 1;
                          if (v1595) {
                            v791 = v1595 + 1;
                          }
                          else {
                            v791 = 0;
                          }
                          v793 = (void *)v791[1];
                          v792 = (std::__shared_weak_count *)v791[2];
                          __p = v793;
                          v1598 = v792;
                          if (v792) {
                            atomic_fetch_add_explicit(&v792->__shared_owners_, 1uLL, memory_order_relaxed);
                          }
                          if (v789 && (_ZF = *v789 == 1, --*v789, _ZF))
                          {
                            md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk((uint64_t)v790);
                            {
                              operator new();
                            }
                            (*(void (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                               + 40))(mdm::Allocator::instance(void)::alloc, v1595, 104);
                            v793 = __p;
                            v792 = v1598;
                            if (v1598) {
LABEL_1320:
                            }
                              atomic_fetch_add_explicit(&v792->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                          }
                          else if (v792)
                          {
                            goto LABEL_1320;
                          }
                          v794 = (uint64_t **)(a1 + 208);
LABEL_1322:
                          v795 = *v794;
                          v796 = v794;
                          if (*v794)
                          {
                            while (1)
                            {
                              v794 = (uint64_t **)v795;
                              unint64_t v797 = v795[5];
                              if ((unint64_t)v792 < v797) {
                                goto LABEL_1322;
                              }
                              if (v797 >= (unint64_t)v792) {
                                break;
                              }
                              v795 = v794[1];
                              if (!v795)
                              {
                                v796 = v794 + 1;
                                goto LABEL_1327;
                              }
                            }
                            unint64_t v510 = v1412;
                            if (v792) {
                              std::__shared_weak_count::__release_weak(v792);
                            }
                          }
                          else
                          {
LABEL_1327:
                            v798 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)a1 + 27)
                                                                                                  + 16))(*((void *)a1 + 27), 48, 8);
                            v798[4] = (uint64_t)v793;
                            v798[5] = (uint64_t)v792;
                            uint64_t *v798 = 0;
                            v798[1] = 0;
                            v798[2] = (uint64_t)v794;
                            *v796 = v798;
                            v799 = (uint64_t *)**v1438;
                            if (v799)
                            {
                              *v1438 = v799;
                              v798 = *v796;
                            }
                            std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)a1 + 26), v798);
                            ++*((void *)a1 + 28);
                            unint64_t v510 = v1412;
                          }
                          if (v1525[25])
                          {
                            v800 = __p;
                            v801 = *(void **)&v1609[8];
                            if (*(void *)&v1609[8] >= *(void *)&v1609[16])
                            {
                              unint64_t v803 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v1609[8] - *(void *)v1609) >> 3);
                              unint64_t v804 = v803 + 1;
                              if (v803 + 1 > 0xAAAAAAAAAAAAAAALL) {
                                abort();
                              }
                              if (0x5555555555555556 * ((uint64_t)(*(void *)&v1609[16] - *(void *)v1609) >> 3) > v804) {
                                unint64_t v804 = 0x5555555555555556 * ((uint64_t)(*(void *)&v1609[16] - *(void *)v1609) >> 3);
                              }
                              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v1609[16] - *(void *)v1609) >> 3) >= 0x555555555555555) {
                                uint64_t v805 = 0xAAAAAAAAAAAAAAALL;
                              }
                              else {
                                uint64_t v805 = v804;
                              }
                              if (v805)
                              {
                                uint64_t v806 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1610 + 16))(v1610, 24 * v805, 8);
                                v807 = (void *)(v806 + 24 * v803);
                                uint64_t v808 = v806 + 24 * v805;
                                if (v806)
                                {
                                  void *v807 = v800;
                                  unint64_t v809 = v806 + 24 * v803;
                                  *(void *)(v809 + 8) = 0;
                                  *(void *)(v809 + 16) = 0;
                                }
                              }
                              else
                              {
                                uint64_t v808 = 0;
                                v807 = (void *)(8 * ((uint64_t)(*(void *)&v1609[8] - *(void *)v1609) >> 3));
                              }
                              uint64_t v811 = *(void *)v1609;
                              uint64_t v810 = *(void *)&v1609[8];
                              unint64_t v510 = v1412;
                              v812 = v807;
                              if (*(void *)&v1609[8] != *(void *)v1609)
                              {
                                do
                                {
                                  long long v813 = *(_OWORD *)(v810 - 24);
                                  *(v812 - 1) = *(void *)(v810 - 8);
                                  *(_OWORD *)(v812 - 3) = v813;
                                  v812 -= 3;
                                  v810 -= 24;
                                }
                                while (v810 != v811);
                                uint64_t v810 = *(void *)v1609;
                              }
                              v802 = v807 + 3;
                              *(void *)v1609 = v812;
                              *(void *)&v1609[8] = v807 + 3;
                              uint64_t v814 = *(void *)&v1609[16];
                              *(void *)&v1609[16] = v808;
                              if (v810) {
                                (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1610 + 40))(v1610, v810, v814 - v810);
                              }
                            }
                            else
                            {
                              if (*(void *)&v1609[8])
                              {
                                *(void *)(*(void *)&v1609[8] + 8) = 0;
                                v801[2] = 0;
                                void *v801 = v800;
                              }
                              v802 = v801 + 3;
                            }
                            *(void *)&v1609[8] = v802;
                          }
                          v815 = v1598;
                          if (v1598 && !atomic_fetch_add(&v1598->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v815->__on_zero_shared)(v815);
                            std::__shared_weak_count::__release_weak(v815);
                          }
                          uint64_t v523 = *(void *)v1609;
                          uint64_t v522 = *(void *)&v1609[8];
                          unint64_t v520 = v1414;
                          goto LABEL_956;
                        }
LABEL_1241:
                        int v731 = LOWORD(v729[2 * v730 + 1]);
                        unint64_t v732 = *(void *)(v530 + 848);
                        if ((unint64_t)v726 < v732)
                        {
                          if (v726) {
                            _DWORD *v726 = v731;
                          }
                          v733 = v726 + 1;
LABEL_1269:
                          *(void *)(v530 + 840) = v733;
                          goto LABEL_1270;
                        }
                        uint64_t v736 = v732 - (void)v726;
                        uint64_t v737 = v736 >> 1;
                        if ((unint64_t)(v736 >> 1) <= 1) {
                          uint64_t v737 = 1;
                        }
                        if ((unint64_t)v736 >= 0x7FFFFFFFFFFFFFFCLL) {
                          uint64_t v738 = 0x3FFFFFFFFFFFFFFFLL;
                        }
                        else {
                          uint64_t v738 = v737;
                        }
                        v739 = (_DWORD *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v530 + 856)
                                                                                             + 16))(*(void *)(v530 + 856), 4 * v738, 4);
                        if (v739) {
                          _DWORD *v739 = v731;
                        }
                        uint64_t v740 = *(void *)(v530 + 840);
                        uint64_t v741 = *(void *)(v530 + 832);
                        uint64_t v742 = v740 - v741;
                        if (v740 == v741)
                        {
                          v744 = v739;
                          goto LABEL_1267;
                        }
                        unint64_t v743 = v742 - 4;
                        if ((unint64_t)(v742 - 4) < 0x1C)
                        {
                          v744 = v739;
                        }
                        else
                        {
                          v744 = v739;
                          if ((unint64_t)(v740 - (void)v739) >= 0x20)
                          {
                            uint64_t v745 = (v743 >> 2) + 1;
                            uint64_t v746 = v740 - 4 * (v745 & 0x7FFFFFFFFFFFFFF8);
                            v747 = v739 - 4;
                            v748 = (long long *)(v740 - 16);
                            uint64_t v749 = v745 & 0x7FFFFFFFFFFFFFF8;
                            do
                            {
                              long long v750 = *v748;
                              *(v747 - 1) = *(v748 - 1);
                              _OWORD *v747 = v750;
                              v747 -= 2;
                              v748 -= 2;
                              v749 -= 8;
                            }
                            while (v749);
                            v744 = &v739[-(v745 & 0x7FFFFFFFFFFFFFF8)];
                            uint64_t v740 = v746;
                            if (v745 == (v745 & 0x7FFFFFFFFFFFFFF8))
                            {
LABEL_1267:
                              v752 = &v739[v738];
                              v733 = v739 + 1;
                              *(void *)(v530 + 832) = v744;
                              *(void *)(v530 + 840) = v739 + 1;
                              uint64_t v753 = *(void *)(v530 + 848);
                              *(void *)(v530 + 848) = v752;
                              if (v741) {
                                (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v530 + 856) + 40))(*(void *)(v530 + 856), v741, v753 - v741);
                              }
                              goto LABEL_1269;
                            }
                          }
                        }
                        do
                        {
                          int v751 = *(_DWORD *)(v740 - 4);
                          v740 -= 4;
                          *--v744 = v751;
                        }
                        while (v740 != v741);
                        goto LABEL_1267;
                      }
                      unint64_t v607 = 0;
                      v633 = v606 + 2;
                      do
                      {
                        if (v605 - 1 == v607) {
                          goto LABEL_1100;
                        }
                        int v634 = *v633;
                        v633 += 2;
                        ++v607;
                      }
                      while (v634 != 49);
                      if (v607 < v605) {
                        goto LABEL_1064;
                      }
                    }
                  }
                  break;
                }
LABEL_1100:
                int v1468 = 0;
                if (!v1601[1]) {
                  goto LABEL_1065;
                }
LABEL_1101:
                unint64_t v635 = 0;
                v602 = v600;
                v608 = __srcd;
LABEL_1104:
                v636 = v1592[1];
                if (!v1592[1]) {
                  goto LABEL_1103;
                }
                uint64_t v637 = v598 + 104 * *v603 + 104 * v635;
                unint64_t v638 = *(void *)(v637 + 40);
                while (1)
                {
                  unint64_t v639 = v636[4];
                  if (v638 >= v639)
                  {
                    if (v639 >= v638)
                    {
                      uint64_t v640 = *(void *)(v637 + 24);
                      if (!v640) {
                        goto LABEL_1103;
                      }
                      unint64_t v641 = *(unsigned __int8 *)(v640 + 33);
                      if (*(unsigned char *)(v640 + 33))
                      {
                        v642 = *(_DWORD **)v640;
                        if (*v642 == 37)
                        {
                          unint64_t v643 = 0;
                          goto LABEL_1114;
                        }
                        unint64_t v643 = 0;
                        v645 = v642 + 2;
                        do
                        {
                          if (v641 - 1 == v643) {
                            goto LABEL_1146;
                          }
                          int v646 = *v645;
                          v645 += 2;
                          ++v643;
                        }
                        while (v646 != 37);
                        if (v643 < v641)
                        {
LABEL_1114:
                          int v644 = LOWORD(v642[2 * v643 + 1]);
                          if ((unint64_t)v602 < v1459)
                          {
                            if (v602) {
                              *(_DWORD *)v602 = v644;
                            }
                            v602 += 4;
LABEL_1145:
                            uint64_t v511 = v1452;
                            goto LABEL_1146;
                          }
                          uint64_t v647 = (v602 - v600) >> 2;
                          unint64_t v648 = v647 + 1;
                          if ((unint64_t)(v647 + 1) >> 62) {
                            abort();
                          }
                          if ((uint64_t)(v1459 - (void)v600) >> 1 > v648) {
                            unint64_t v648 = (uint64_t)(v1459 - (void)v600) >> 1;
                          }
                          if (v1459 - (unint64_t)v600 >= 0x7FFFFFFFFFFFFFFCLL) {
                            uint64_t v649 = 0x3FFFFFFFFFFFFFFFLL;
                          }
                          else {
                            uint64_t v649 = v648;
                          }
                          if (v649)
                          {
                            uint64_t v650 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1436 + 16))(v1436, 4 * v649, 4);
                            v651 = (char *)(v650 + 4 * v647);
                            unint64_t v1459 = v650 + 4 * v649;
                            if (v650) {
                              *(_DWORD *)v651 = v644;
                            }
                          }
                          else
                          {
                            unint64_t v1459 = 0;
                            v651 = (char *)(4 * v647);
                          }
                          v652 = v651;
                          if (v602 != v600)
                          {
                            unint64_t v653 = v602 - v600 - 4;
                            if (v653 < 0x9C
                              || &v651[-(v653 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v651 - 4
                              || &v602[-(v653 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v602 - 4
                              || (unint64_t)(v602 - v651) < 0x20)
                            {
                              v654 = v602;
                              v652 = v651;
                            }
                            else
                            {
                              uint64_t v664 = (v653 >> 2) + 1;
                              v654 = &v602[-4 * (v664 & 0x7FFFFFFFFFFFFFF8)];
                              v665 = v651 - 16;
                              v666 = v602 - 16;
                              uint64_t v667 = v664 & 0x7FFFFFFFFFFFFFF8;
                              do
                              {
                                long long v668 = *(_OWORD *)v666;
                                *((_OWORD *)v665 - 1) = *((_OWORD *)v666 - 1);
                                *(_OWORD *)v665 = v668;
                                v665 -= 32;
                                v666 -= 32;
                                v667 -= 8;
                              }
                              while (v667);
                              v652 = &v651[-4 * (v664 & 0x7FFFFFFFFFFFFFF8)];
                              if (v664 == (v664 & 0x7FFFFFFFFFFFFFF8)) {
                                goto LABEL_1142;
                              }
                            }
                            do
                            {
                              int v655 = *((_DWORD *)v654 - 1);
                              v654 -= 4;
                              *((_DWORD *)v652 - 1) = v655;
                              v652 -= 4;
                            }
                            while (v654 != v600);
                          }
LABEL_1142:
                          v602 = v651 + 4;
                          if (v600) {
                            (*(void (**)(uint64_t, char *))(*(void *)v1436 + 40))(v1436, v600);
                          }
                          v600 = v652;
                          goto LABEL_1145;
                        }
                      }
LABEL_1146:
                      uint64_t v656 = *(void *)(v637 + 24);
                      if (v656)
                      {
                        unint64_t v657 = *(unsigned __int8 *)(v656 + 33);
                        if (*(unsigned char *)(v656 + 33))
                        {
                          v658 = *(_DWORD **)v656;
                          if (*v658 == 50)
                          {
                            unint64_t v659 = 0;
                            goto LABEL_1150;
                          }
                          unint64_t v659 = 0;
                          v662 = v658 + 2;
                          do
                          {
                            if (v657 - 1 == v659) {
                              goto LABEL_1103;
                            }
                            int v663 = *v662;
                            v662 += 2;
                            ++v659;
                          }
                          while (v663 != 50);
                          if (v659 < v657)
                          {
LABEL_1150:
                            int v660 = LOWORD(v658[2 * v659 + 1]);
                            v661 = __srcd;
                            if (__srcd != v608)
                            {
                              do
                              {
                                if (*(_DWORD *)v661 == v660) {
                                  goto LABEL_1102;
                                }
                                v661 += 4;
                              }
                              while (v661 != v608);
                              v661 = v608;
                            }
LABEL_1102:
                            if (v661 != v608) {
                              goto LABEL_1103;
                            }
                            if ((unint64_t)v608 < v1421)
                            {
                              if (v608) {
                                *(_DWORD *)v608 = v660;
                              }
                              v608 += 4;
                              goto LABEL_1103;
                            }
                            int64_t v669 = v608 - __srcd;
                            uint64_t v670 = (v608 - __srcd) >> 2;
                            unint64_t v671 = v670 + 1;
                            if ((unint64_t)(v670 + 1) >> 62) {
                              abort();
                            }
                            if ((uint64_t)(v1421 - (void)__srcd) >> 1 > v671) {
                              unint64_t v671 = (uint64_t)(v1421 - (void)__srcd) >> 1;
                            }
                            if (v1421 - (unint64_t)__srcd >= 0x7FFFFFFFFFFFFFFCLL) {
                              uint64_t v672 = 0x3FFFFFFFFFFFFFFFLL;
                            }
                            else {
                              uint64_t v672 = v671;
                            }
                            if (v672)
                            {
                              uint64_t v673 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1413 + 16))(v1413, 4 * v672, 4);
                              v674 = (char *)(v673 + 4 * v670);
                              unint64_t v1421 = v673 + 4 * v672;
                              if (v673) {
                                *(_DWORD *)v674 = v660;
                              }
                            }
                            else
                            {
                              unint64_t v1421 = 0;
                              v674 = (char *)(4 * v670);
                            }
                            v675 = v674;
                            v676 = __srcd;
                            if (__srcd != v608)
                            {
                              unint64_t v677 = v669 - 4;
                              if ((unint64_t)(v669 - 4) < 0x9C
                                || &v674[-(v677 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v674 - 4
                                || &v608[-(v677 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v608 - 4
                                || (unint64_t)(v608 - v674) < 0x20)
                              {
                                v678 = v608;
                                v675 = v674;
                                v676 = __srcd;
                              }
                              else
                              {
                                uint64_t v680 = (v677 >> 2) + 1;
                                v678 = &v608[-4 * (v680 & 0x7FFFFFFFFFFFFFF8)];
                                v681 = v674 - 16;
                                v682 = v608 - 16;
                                uint64_t v683 = v680 & 0x7FFFFFFFFFFFFFF8;
                                do
                                {
                                  long long v684 = *(_OWORD *)v682;
                                  *((_OWORD *)v681 - 1) = *((_OWORD *)v682 - 1);
                                  *(_OWORD *)v681 = v684;
                                  v681 -= 32;
                                  v682 -= 32;
                                  v683 -= 8;
                                }
                                while (v683);
                                v675 = &v674[-4 * (v680 & 0x7FFFFFFFFFFFFFF8)];
                                v676 = __srcd;
                                if (v680 == (v680 & 0x7FFFFFFFFFFFFFF8)) {
                                  goto LABEL_1181;
                                }
                              }
                              do
                              {
                                int v679 = *((_DWORD *)v678 - 1);
                                v678 -= 4;
                                *((_DWORD *)v675 - 1) = v679;
                                v675 -= 4;
                              }
                              while (v678 != v676);
                            }
LABEL_1181:
                            v608 = v674 + 4;
                            if (v676) {
                              (*(void (**)(uint64_t, char *))(*(void *)v1413 + 40))(v1413, v676);
                            }
                            __srcd = v675;
                            uint64_t v511 = v1452;
                          }
                        }
                      }
LABEL_1103:
                      ++v635;
                      v603 = v1601;
                      if (v635 >= v1601[1]) {
                        goto LABEL_1066;
                      }
                      goto LABEL_1104;
                    }
                    ++v636;
                  }
                  v636 = (void *)*v636;
                  if (!v636) {
                    goto LABEL_1103;
                  }
                }
              }
LABEL_953:
              unint64_t v518 = v520;
              md::LabelFeatureStyler::styleLabelFeatures(*(unsigned int **)(v1407 + 296), (char **)v1609, 1u, 1, *(void *)(*(void *)(v1407 + 152) + 32));
              v519 = v1473;
              std::mutex::unlock(v1473);
              if (v518 >= v510) {
                goto LABEL_1386;
              }
            }
          }
          uint64_t v1453 = *(void *)buf;
          uint64_t v1512 = *(void *)buf;
          __int16 v1513 = v1585;
          uint64_t v1514 = *(void *)((char *)&v1585 + 4);
          long long v1515 = v1587;
          long long v1516 = v1588;
          *(_OWORD *)v1517 = *(_OWORD *)v1589;
          *(_OWORD *)&v1517[11] = *(_OWORD *)&v1589[11];
          v817 = v1591;
          v1518 = v1590;
          v1519 = v1591;
          if (v1591) {
            atomic_fetch_add_explicit(&v1591->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          unint64_t v1485 = geo::codec::VectorTile::transitAccessPointCount(*(geo::codec::VectorTile **)a3);
          if (v1485)
          {
            uint64_t v818 = geo::codec::VectorTile::transitAccessPoints(*(geo::codec::VectorTile **)a3);
            v1592[1] = 0;
            v1592[0] = 0;
            v1593[0] = 0;
            {
              operator new();
            }
            v1593[1] = (void *)mdm::Allocator::instance(void)::alloc;
            v819 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                + 16))(mdm::Allocator::instance(void)::alloc, 768, 8);
            v820 = v819 + 768;
            v821 = (char *)v1592[1];
            v822 = (char *)v1592[0];
            if (v1592[1] != v1592[0])
            {
              do
              {
                long long v823 = *(_OWORD *)(v821 - 24);
                *((void *)v819 - 1) = *((void *)v821 - 1);
                *(_OWORD *)(v819 - 24) = v823;
                v819 -= 24;
                v821 -= 24;
              }
              while (v821 != v822);
              v821 = v822;
            }
            v824 = v1593[0];
            v1592[0] = v819;
            v1593[0] = v820;
            if (v821) {
              (*(void (**)(void *, char *, int64_t))(*(void *)v1593[1] + 40))(v1593[1], v821, v824 - v821);
            }
            unint64_t v825 = 0;
            v1460 = 0;
            v826 = v1473;
            while (1)
            {
              v1592[1] = v1592[0];
              std::mutex::lock(v826);
              if (!v1460)
              {
                v827 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v1473[7].__m_.__opaque, *(void *)a3);
                if (!v827)
                {
                  std::mutex::unlock(v1473);
LABEL_1559:
                  if (v1592[0])
                  {
                    v1592[1] = v1592[0];
                    (*(void (**)(void *, void *, int64_t))(*(void *)v1593[1] + 40))(v1593[1], v1592[0], (char *)v1593[0] - (char *)v1592[0]);
                  }
                  v817 = v1519;
                  break;
                }
                v1460 = v827 + 3;
              }
              if (0xAAAAAAAAAAAAAAABLL * (((char *)v1592[1] - (char *)v1592[0]) >> 3) <= 0x1F && v825 < v1485)
              {
                while (1)
                {
                  {
                    operator new();
                  }
                  v830 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                        + 16))(mdm::Allocator::instance(void)::alloc, 104, 8);
                  void *v830 = 1;
                  md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::LabelFeatureThunk((uint64_t)(v830 + 1), (uint64_t *)v818, 1);
                  __p = v830;
                  v831 = std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::__emplace_unique_key_args<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator> const&>((float *)&v1473[5].__m_.__opaque[16], (uint64_t)&__p, (void **)&__p);
                  v1517[25] = v832;
                  if (v832)
                  {
                    {
                      operator new();
                    }
                    uint64_t v833 = mdm::Allocator::instance(void)::alloc;
                    uint64_t v834 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                + 16))(mdm::Allocator::instance(void)::alloc, 752, 8);
                    *(void *)uint64_t v834 = &unk_1EF582630;
                    *(void *)(v834 + 8) = 0;
                    *(void *)(v834 + 16) = 0;
                    *(void *)(v834 + 24) = v833;
                    md::PointLabelFeature::PointLabelFeature((md::PointLabelFeature *)(v834 + 32), (GeoCodecsPointFeature *)v818, (const md::LabelFeatureCreationParams *)&v1512);
                    *(void *)(v834 + 32) = &unk_1EF54C678;
                    *(void *)(v834 + 704) = *(void *)(v818 + 224);
                    *(void *)(v834 + 720) = 0;
                    *(void *)(v834 + 728) = 0;
                    *(void *)(v834 + 712) = 0;
                    {
                      operator new();
                    }
                    char v835 = 0;
                    v836 = (void *)(v834 + 712);
                    *(void *)(v834 + 736) = mdm::Allocator::instance(void)::alloc;
                    *(unsigned char *)(v834 + 744) = 0;
                    *(_DWORD *)(v834 + 400) = *(_DWORD *)(v818 + 244);
                    if (*(unsigned __int16 *)(v818 + 240) <= 1u) {
                      unsigned __int16 v837 = 1;
                    }
                    else {
                      unsigned __int16 v837 = *(_WORD *)(v818 + 240);
                    }
                    while (2)
                    {
                      if ((v837 & 1) == 0) {
                        goto LABEL_1424;
                      }
                      v840 = *(unsigned char **)(v834 + 720);
                      unint64_t v841 = *(void *)(v834 + 728);
                      if ((unint64_t)v840 < v841)
                      {
                        if (v840) {
                          unsigned char *v840 = v835;
                        }
                        v838 = v840 + 1;
                        goto LABEL_1423;
                      }
                      v842 = &v840[-*v836];
                      unint64_t v843 = (unint64_t)(v842 + 1);
                      if ((uint64_t)(v842 + 1) < 0) {
                        abort();
                      }
                      unint64_t v844 = v841 - *v836;
                      if (2 * v844 > v843) {
                        unint64_t v843 = 2 * v844;
                      }
                      if (v844 >= 0x3FFFFFFFFFFFFFFFLL) {
                        uint64_t v845 = 0x7FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        uint64_t v845 = v843;
                      }
                      if (v845)
                      {
                        uint64_t v846 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v834 + 736) + 16))(*(void *)(v834 + 736), v845, 1);
                        v842 += v846;
                        uint64_t v847 = v846 + v845;
                        if (v846) {
                          unsigned char *v842 = v835;
                        }
                      }
                      else
                      {
                        uint64_t v847 = 0;
                      }
                      uint64_t v848 = *(void *)(v834 + 720);
                      uint64_t v849 = *(void *)(v834 + 712);
                      v850 = v842;
                      unint64_t v851 = v848 - v849;
                      if (v848 != v849)
                      {
                        if (v851 < 0x20)
                        {
                          v850 = v842;
                        }
                        else
                        {
                          v850 = v842;
                          if ((unint64_t)(v848 - (void)v842) >= 0x20)
                          {
                            uint64_t v852 = v848 - (v851 & 0xFFFFFFFFFFFFFFE0);
                            v853 = v842 - 16;
                            v854 = (long long *)(v848 - 16);
                            unint64_t v855 = v851 & 0xFFFFFFFFFFFFFFE0;
                            do
                            {
                              long long v856 = *v854;
                              *(v853 - 1) = *(v854 - 1);
                              _OWORD *v853 = v856;
                              v853 -= 2;
                              v854 -= 2;
                              v855 -= 32;
                            }
                            while (v855);
                            v850 = &v842[-(v851 & 0xFFFFFFFFFFFFFFE0)];
                            uint64_t v848 = v852;
                            if (v851 == (v851 & 0xFFFFFFFFFFFFFFE0)) {
                              goto LABEL_1448;
                            }
                          }
                        }
                        do
                        {
                          char v857 = *(unsigned char *)--v848;
                          *--v850 = v857;
                        }
                        while (v848 != v849);
                      }
LABEL_1448:
                      v838 = v842 + 1;
                      *(void *)(v834 + 712) = v850;
                      *(void *)(v834 + 720) = v838;
                      uint64_t v858 = *(void *)(v834 + 728);
                      *(void *)(v834 + 728) = v847;
                      if (v849) {
                        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v834 + 736) + 40))(*(void *)(v834 + 736), v849, v858 - v849);
                      }
LABEL_1423:
                      *(void *)(v834 + 720) = v838;
LABEL_1424:
                      ++v835;
                      unsigned int v839 = v837;
                      v837 >>= 1;
                      if (v839 <= 1)
                      {
                        if (__p) {
                          v859 = (char *)__p + 8;
                        }
                        else {
                          v859 = 0;
                        }
                        v860 = (std::__shared_weak_count *)*((void *)v859 + 2);
                        *((void *)v859 + 1) = v834 + 32;
                        *((void *)v859 + 2) = v834;
                        if (v860 && !atomic_fetch_add(&v860->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v860->__on_zero_shared)(v860);
                          std::__shared_weak_count::__release_weak(v860);
                        }
                        uint64_t v861 = *(void *)&v1473[10].__m_.__opaque[24];
                        v862 = (char *)__p;
                        v863 = (char *)__p + 8;
                        if (!__p) {
                          v863 = 0;
                        }
                        uint64_t v864 = *((void *)v863 + 1);
                        *(void *)(v864 + 152) = v863;
                        uint64_t v865 = v861 + 1;
                        *(void *)&v1473[10].__m_.__opaque[24] = v865;
                        *(void *)(v864 + 72) = v865;
                        *(unsigned char *)(v864 + 147) = 1;
                        goto LABEL_1469;
                      }
                      continue;
                    }
                  }
                  v866 = v831;
                  v867 = (void *)v831[2];
                  if (v867) {
                    ++*v867;
                  }
                  _ZF = (*v830)-- == 1;
                  if (_ZF)
                  {
                    md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk((uint64_t)(v830 + 1));
                    {
                      operator new();
                    }
                    (*(void (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                     + 40))(mdm::Allocator::instance(void)::alloc, __p, 104);
                    v867 = (void *)v866[2];
                  }
                  __p = v867;
                  v868 = v867 ? v867 + 1 : 0;
                  md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::add(v868, (void *)v818);
                  v862 = (char *)__p;
LABEL_1469:
                  if (v862) {
                    v869 = (md::PointLabelFeature **)(v862 + 8);
                  }
                  else {
                    v869 = 0;
                  }
                  md::PointLabelFeature::addPointFeature(v869[1], (GeoCodecsPointFeature *)v818, (const md::LabelFeatureCreationParams *)&v1512);
                  std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeaturePoolTileInfo::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeaturePoolTileInfo::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::__emplace_unique_key_args<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator> const&>((unint64_t)(v1460 + 35), (uint64_t)__p, (void **)&__p);
                  v870 = __p;
                  v871 = (char *)__p + 8;
                  if (__p) {
                    v872 = (char *)__p + 8;
                  }
                  else {
                    v872 = 0;
                  }
                  uint64_t v873 = *((void *)v872 + 1);
                  v874 = (std::__shared_weak_count *)*((void *)v872 + 2);
                  *(void *)v1609 = v873;
                  *(void *)&v1609[8] = v874;
                  if (v874) {
                    atomic_fetch_add_explicit(&v874->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  if (!v870) {
                    break;
                  }
                  _ZF = (*v870)-- == 1;
                  if (!_ZF) {
                    break;
                  }
                  md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk((uint64_t)v871);
                  {
                    operator new();
                  }
                  (*(void (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                   + 40))(mdm::Allocator::instance(void)::alloc, __p, 104);
                  uint64_t v873 = *(void *)v1609;
                  v874 = *(std::__shared_weak_count **)&v1609[8];
                  if (*(void *)&v1609[8]) {
                    goto LABEL_1480;
                  }
LABEL_1481:
                  v875 = (uint64_t *)(a1 + 208);
LABEL_1482:
                  v876 = (uint64_t *)*v875;
                  v877 = v875;
                  if (*v875)
                  {
                    do
                    {
                      v875 = v876;
                      unint64_t v878 = v876[5];
                      if ((unint64_t)v874 < v878) {
                        goto LABEL_1482;
                      }
                      if (v878 >= (unint64_t)v874)
                      {
                        if (v874) {
                          std::__shared_weak_count::__release_weak(v874);
                        }
                        if (!v1517[25]) {
                          goto LABEL_1545;
                        }
                        goto LABEL_1510;
                      }
                      v876 = (uint64_t *)v875[1];
                    }
                    while (v876);
                    v877 = v875 + 1;
                  }
                  uint64_t v879 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)a1 + 27) + 16))(*((void *)a1 + 27), 48, 8);
                  *(void *)(v879 + 32) = v873;
                  *(void *)(v879 + 40) = v874;
                  *(void *)uint64_t v879 = 0;
                  *(void *)(v879 + 8) = 0;
                  *(void *)(v879 + 16) = v875;
                  uint64_t *v877 = v879;
                  v880 = (uint64_t *)**v1438;
                  if (v880)
                  {
                    *v1438 = v880;
                    uint64_t v879 = *v877;
                  }
                  uint64_t v881 = *v1456;
                  _ZF = v879 == *v1456;
                  *(unsigned char *)(v879 + 24) = _ZF;
                  if (_ZF) {
                    goto LABEL_1544;
                  }
                  while (1)
                  {
                    v882 = *(uint64_t **)(v879 + 16);
                    if (*((unsigned char *)v882 + 24)) {
                      goto LABEL_1544;
                    }
                    uint64_t v883 = v882[2];
                    v884 = *(uint64_t **)v883;
                    if (*(uint64_t **)v883 == v882) {
                      break;
                    }
                    if (!v884 || (int v886 = *((unsigned __int8 *)v884 + 24), v885 = v884 + 3, v886))
                    {
                      if (*v882 == v879)
                      {
                        uint64_t v907 = *(void *)(v879 + 8);
                        uint64_t *v882 = v907;
                        if (v907)
                        {
                          *(void *)(v907 + 16) = v882;
                          uint64_t v883 = v882[2];
                        }
                        *(void *)(v879 + 16) = v883;
                        *(void *)(v882[2] + 8 * (*(void *)v882[2] != (void)v882)) = v879;
                        *(void *)(v879 + 8) = v882;
                        v882[2] = v879;
                        uint64_t v883 = *(void *)(v879 + 16);
                      }
                      else
                      {
                        uint64_t v879 = *(void *)(v879 + 16);
                      }
                      *(unsigned char *)(v879 + 24) = 1;
                      *(unsigned char *)(v883 + 24) = 0;
                      v882 = *(uint64_t **)(v883 + 8);
                      uint64_t v908 = *v882;
                      *(void *)(v883 + 8) = *v882;
                      if (v908) {
                        *(void *)(v908 + 16) = v883;
                      }
                      v882[2] = *(void *)(v883 + 16);
                      *(void *)(*(void *)(v883 + 16) + 8 * (**(void **)(v883 + 16) != v883)) = v882;
                      uint64_t *v882 = v883;
                      goto LABEL_1543;
                    }
LABEL_1492:
                    *((unsigned char *)v882 + 24) = 1;
                    uint64_t v879 = v883;
                    *(unsigned char *)(v883 + 24) = v883 == v881;
                    unsigned char *v885 = 1;
                    if (v883 == v881) {
                      goto LABEL_1544;
                    }
                  }
                  uint64_t v887 = *(void *)(v883 + 8);
                  if (v887)
                  {
                    int v888 = *(unsigned __int8 *)(v887 + 24);
                    v885 = (unsigned char *)(v887 + 24);
                    if (!v888) {
                      goto LABEL_1492;
                    }
                  }
                  if (*v882 == v879)
                  {
                    v889 = *(uint64_t ***)(v879 + 16);
                  }
                  else
                  {
                    v889 = (uint64_t **)v882[1];
                    v890 = *v889;
                    v882[1] = (uint64_t)*v889;
                    if (v890)
                    {
                      v890[2] = (uint64_t)v882;
                      uint64_t v883 = v882[2];
                    }
                    v889[2] = (uint64_t *)v883;
                    *(void *)(v882[2] + 8 * (*(void *)v882[2] != (void)v882)) = v889;
                    *v889 = v882;
                    v882[2] = (uint64_t)v889;
                    uint64_t v883 = (uint64_t)v889[2];
                    v882 = *(uint64_t **)v883;
                  }
                  *((unsigned char *)v889 + 24) = 1;
                  *(unsigned char *)(v883 + 24) = 0;
                  uint64_t v909 = v882[1];
                  *(void *)uint64_t v883 = v909;
                  if (v909) {
                    *(void *)(v909 + 16) = v883;
                  }
                  v882[2] = *(void *)(v883 + 16);
                  *(void *)(*(void *)(v883 + 16) + 8 * (**(void **)(v883 + 16) != v883)) = v882;
                  v882[1] = v883;
LABEL_1543:
                  *(void *)(v883 + 16) = v882;
LABEL_1544:
                  ++*((void *)a1 + 28);
                  if (!v1517[25])
                  {
LABEL_1545:
                    v906 = *(std::__shared_weak_count **)&v1609[8];
                    if (*(void *)&v1609[8]) {
                      goto LABEL_1546;
                    }
                    goto LABEL_1411;
                  }
LABEL_1510:
                  uint64_t v891 = *(void *)v1609;
                  v892 = v1592[1];
                  if (v1592[1] >= v1593[0])
                  {
                    unint64_t v894 = 0xAAAAAAAAAAAAAAABLL * (((char *)v1592[1] - (char *)v1592[0]) >> 3);
                    unint64_t v895 = v894 + 1;
                    if (v894 + 1 > 0xAAAAAAAAAAAAAAALL) {
                      abort();
                    }
                    if (0x5555555555555556 * (((char *)v1593[0] - (char *)v1592[0]) >> 3) > v895) {
                      unint64_t v895 = 0x5555555555555556 * (((char *)v1593[0] - (char *)v1592[0]) >> 3);
                    }
                    if (0xAAAAAAAAAAAAAAABLL * (((char *)v1593[0] - (char *)v1592[0]) >> 3) >= 0x555555555555555) {
                      uint64_t v896 = 0xAAAAAAAAAAAAAAALL;
                    }
                    else {
                      uint64_t v896 = v895;
                    }
                    if (v896)
                    {
                      uint64_t v897 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v1593[1] + 16))(v1593[1], 24 * v896, 8);
                      v898 = (char *)(v897 + 24 * v894);
                      v899 = (void *)(v897 + 24 * v896);
                      if (v897)
                      {
                        *(void *)v898 = v891;
                        unint64_t v900 = v897 + 24 * v894;
                        *(void *)(v900 + 8) = 0;
                        *(void *)(v900 + 16) = 0;
                      }
                    }
                    else
                    {
                      v899 = 0;
                      v898 = (char *)(8 * (((char *)v1592[1] - (char *)v1592[0]) >> 3));
                    }
                    v901 = (char *)v1592[1];
                    v902 = (char *)v1592[0];
                    v903 = v898;
                    if (v1592[1] != v1592[0])
                    {
                      do
                      {
                        long long v904 = *(_OWORD *)(v901 - 24);
                        *((void *)v903 - 1) = *((void *)v901 - 1);
                        *(_OWORD *)(v903 - 24) = v904;
                        v903 -= 24;
                        v901 -= 24;
                      }
                      while (v901 != v902);
                      v901 = (char *)v1592[0];
                    }
                    v893 = v898 + 24;
                    v1592[0] = v903;
                    v1592[1] = v898 + 24;
                    v905 = v1593[0];
                    v1593[0] = v899;
                    if (v901) {
                      (*(void (**)(void *, char *, int64_t))(*(void *)v1593[1] + 40))(v1593[1], v901, v905 - v901);
                    }
                  }
                  else
                  {
                    if (v1592[1])
                    {
                      *((void *)v1592[1] + 1) = 0;
                      v892[2] = 0;
                      void *v892 = v891;
                    }
                    v893 = v892 + 3;
                  }
                  v1592[1] = v893;
                  v906 = *(std::__shared_weak_count **)&v1609[8];
                  if (*(void *)&v1609[8])
                  {
LABEL_1546:
                    if (!atomic_fetch_add(&v906->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v906->__on_zero_shared)(v906);
                      std::__shared_weak_count::__release_weak(v906);
                    }
                  }
LABEL_1411:
                  ++v825;
                  v818 += 248;
                  if (0xAAAAAAAAAAAAAAABLL * (((char *)v1592[1] - (char *)v1592[0]) >> 3) > 0x1F || v825 >= v1485) {
                    goto LABEL_1409;
                  }
                }
                if (!v874) {
                  goto LABEL_1481;
                }
LABEL_1480:
                atomic_fetch_add_explicit(&v874->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                goto LABEL_1481;
              }
LABEL_1409:
              md::LabelFeatureStyler::styleLabelFeatures(*(unsigned int **)(v1453 + 296), (char **)v1592, 1u, 1, *(void *)(*(void *)(v1453 + 152) + 32));
              v826 = v1473;
              std::mutex::unlock(v1473);
              if (v825 >= v1485) {
                goto LABEL_1559;
              }
            }
          }
          if (v817 && !atomic_fetch_add(&v817->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v817->__on_zero_shared)(v817);
            std::__shared_weak_count::__release_weak(v817);
          }
          uint64_t v1418 = *(void *)buf;
          uint64_t v1504 = *(void *)buf;
          __int16 v1505 = v1585;
          uint64_t v1506 = *(void *)((char *)&v1585 + 4);
          long long v1507 = v1587;
          long long v1508 = v1588;
          *(_OWORD *)v1509 = *(_OWORD *)v1589;
          *(_OWORD *)&v1509[11] = *(_OWORD *)&v1589[11];
          v910 = v1591;
          v1510 = v1590;
          v1511 = v1591;
          if (v1591) {
            atomic_fetch_add_explicit(&v1591->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          unint64_t v911 = geo::codec::VectorTile::transitLinkCount(*(geo::codec::VectorTile **)a3);
          if (!v911) {
            goto LABEL_2096;
          }
          v1592[1] = 0;
          v1592[0] = 0;
          v1593[0] = 0;
          {
            operator new();
          }
          v1593[1] = (void *)mdm::Allocator::instance(void)::alloc;
          v912 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                              + 16))(mdm::Allocator::instance(void)::alloc, 768, 8);
          v913 = v912 + 768;
          v914 = (char *)v1592[1];
          v915 = (char *)v1592[0];
          if (v1592[1] != v1592[0])
          {
            do
            {
              long long v916 = *(_OWORD *)(v914 - 24);
              *((void *)v912 - 1) = *((void *)v914 - 1);
              *(_OWORD *)(v912 - 24) = v916;
              v912 -= 24;
              v914 -= 24;
            }
            while (v914 != v915);
            v914 = v915;
          }
          v917 = v1593[0];
          v1592[0] = v912;
          v1593[0] = v913;
          if (v914) {
            (*(void (**)(void *, char *, int64_t))(*(void *)v1593[1] + 40))(v1593[1], v914, v917 - v914);
          }
          uint64_t v1469 = geo::codec::VectorTile::transitLinks(*(geo::codec::VectorTile **)a3);
          unint64_t v918 = 0;
          v1454 = 0;
          v919 = v1473;
          v1422 = &v1473[6].__m_.__opaque[32];
          unint64_t v1433 = v911;
LABEL_1575:
          v1592[1] = v1592[0];
          std::mutex::lock(v919);
          if (!v1454)
          {
            v920 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v1473[7].__m_.__opaque, *(void *)a3);
            if (!v920)
            {
              std::mutex::unlock(v1473);
              goto LABEL_2093;
            }
            v1454 = v920 + 3;
          }
          v921 = v1592[1];
          v922 = v1592[0];
          if (0xAAAAAAAAAAAAAAABLL * (((char *)v1592[1] - (char *)v1592[0]) >> 3) > 0x1F || v918 >= v911) {
            goto LABEL_1583;
          }
          v1425 = v1454 + 45;
LABEL_1590:
          uint64_t v925 = v1469 + 184 * v918;
          uint64_t v927 = *(void *)(v925 + 32);
          v926 = (uint64_t *)(v925 + 32);
          if (!v927) {
            goto LABEL_1586;
          }
          {
            operator new();
          }
          uint64_t v928 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                      + 16))(mdm::Allocator::instance(void)::alloc, 104, 8);
          *(_OWORD *)(v928 + 16) = 0u;
          *(void *)uint64_t v928 = 1;
          *(void *)(v928 + 8) = &unk_1EF537320;
          *(_OWORD *)(v928 + 32) = 0u;
          v929 = (void *)(v928 + 32);
          *(void *)(v928 + 48) = 0;
          {
            operator new();
          }
          v930 = (uint64_t *)(v1469 + 184 * v918);
          *(void *)(v928 + 56) = mdm::Allocator::instance(void)::alloc;
          v931 = (std::__shared_weak_count *)v930[1];
          if (v931 && (v931 = std::__shared_weak_count::lock(v931)) != 0) {
            v932 = (uint64_t *)*v930;
          }
          else {
            v932 = 0;
          }
          __srce = (void *)(v928 + 64);
          v1486 = (uint64_t *)(v1469 + 184 * v918);
          *(void *)(v928 + 64) = v930;
          *(void *)(v928 + 72) = v932;
          *(void *)(v928 + 80) = v931;
          *(void *)(v928 + 88) = 0;
          *(unsigned char *)(v928 + 96) = 1;
          v933 = *(uint64_t ***)(v928 + 40);
          unint64_t v934 = *(void *)(v928 + 48);
          v1444 = v926;
          if ((unint64_t)v933 >= v934)
          {
            unint64_t v936 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v933 - *v929) >> 3);
            unint64_t v937 = v936 + 1;
            if (v936 + 1 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            if (0x5555555555555556 * ((uint64_t)(v934 - *v929) >> 3) > v937) {
              unint64_t v937 = 0x5555555555555556 * ((uint64_t)(v934 - *v929) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v934 - *v929) >> 3) >= 0x555555555555555) {
              uint64_t v938 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              uint64_t v938 = v937;
            }
            if (v938)
            {
              uint64_t v939 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v928 + 56) + 16))(*(void *)(v928 + 56), 24 * v938, 8);
              uint64_t v940 = v939 + 24 * v936;
              uint64_t v941 = v939 + 24 * v938;
              if (v939)
              {
                *(_OWORD *)uint64_t v940 = *(_OWORD *)(v928 + 64);
                uint64_t v942 = *(void *)(v928 + 80);
                *(void *)(v939 + 24 * v936 + 16) = v942;
                if (v942) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v942 + 8), 1uLL, memory_order_relaxed);
                }
              }
            }
            else
            {
              uint64_t v941 = 0;
              uint64_t v940 = 8 * (((uint64_t)v933 - *v929) >> 3);
            }
            v935 = (void *)(v940 + 24);
            uint64_t v943 = *(void *)(v928 + 32);
            uint64_t v944 = *(void *)(v928 + 40);
            if (v944 == v943)
            {
              *(void *)(v928 + 32) = v940;
              *(void *)(v928 + 40) = v935;
              uint64_t v947 = *(void *)(v928 + 48);
              *(void *)(v928 + 48) = v941;
            }
            else
            {
              do
              {
                long long v945 = *(_OWORD *)(v944 - 24);
                v944 -= 24;
                *(_OWORD *)(v940 - 24) = v945;
                v940 -= 24;
                *(void *)(v940 + 16) = *(void *)(v944 + 16);
                *(void *)(v944 + 8) = 0;
                *(void *)(v944 + 16) = 0;
              }
              while (v944 != v943);
              uint64_t v944 = *(void *)(v928 + 32);
              uint64_t v946 = *(void *)(v928 + 40);
              *(void *)(v928 + 32) = v940;
              *(void *)(v928 + 40) = v935;
              uint64_t v947 = *(void *)(v928 + 48);
              *(void *)(v928 + 48) = v941;
              while (v946 != v944)
              {
                v948 = *(std::__shared_weak_count **)(v946 - 8);
                if (v948 && !atomic_fetch_add(&v948->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v948->__on_zero_shared)(v948);
                  std::__shared_weak_count::__release_weak(v948);
                }
                v946 -= 24;
              }
            }
            if (v944) {
              (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v928 + 56) + 40))(*(void *)(v928 + 56), v944, v947 - v944);
            }
          }
          else
          {
            if (v933)
            {
              *v933 = v930;
              v933[1] = v932;
              v933[2] = (uint64_t *)v931;
              if (v931) {
                atomic_fetch_add_explicit(&v931->__shared_owners_, 1uLL, memory_order_relaxed);
              }
            }
            v935 = v933 + 3;
          }
          *(void *)(v928 + 40) = v935;
          v1595 = (void *)v928;
          unint64_t v949 = *(unsigned __int8 *)(v928 + 96);
          v950 = *(void **)(v928 + 64);
          unint64_t v951 = v950[4];
          if (v951)
          {
            uint64_t v952 = 0;
            unint64_t v953 = 0;
            do
            {
              uint64_t v954 = geo::codec::vectorTransitLineAlongLink(v950, v952);
              unint64_t v955 = ((v953 << 6) - 0x61C8864680B583EBLL + (v953 >> 2) + *(void *)(v954 + 40)) ^ v953;
              unint64_t v953 = (*(unsigned __int8 *)(v954 + 73) - 0x61C8864680B583EBLL + (v955 << 6) + (v955 >> 2)) ^ v955;
              ++v952;
            }
            while (v951 != v952);
          }
          else
          {
            unint64_t v953 = 0;
          }
          unint64_t v1461 = v918;
          unint64_t v956 = (v953 - 0x61C8864680B583EBLL + (v949 << 6) + (v949 >> 2)) ^ v949;
          unint64_t v957 = *(void *)&v1473[6].__m_.__opaque[16];
          if (v957)
          {
            uint8x8_t v958 = (uint8x8_t)vcnt_s8((int8x8_t)v957);
            v958.i16[0] = vaddlv_u8(v958);
            if (v958.u32[0] > 1uLL)
            {
              unint64_t v951 = v956;
              if (v956 >= v957) {
                unint64_t v951 = v956 % v957;
              }
            }
            else
            {
              unint64_t v951 = v956 & (v957 - 1);
            }
            v959 = *(void **)(*(void *)&v1473[6].__m_.__opaque[8] + 8 * v951);
            if (v959)
            {
              v960 = (void *)*v959;
              if (*v959)
              {
                if (v958.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    uint64_t v970 = v960[1];
                    if (v970 == v956)
                    {
                      uint64_t v971 = v960[2];
                      if (v971) {
                        uint64_t v972 = v971 + 8;
                      }
                      else {
                        uint64_t v972 = 0;
                      }
                      if (*(unsigned __int8 *)(v972 + 88) == *(unsigned __int8 *)(v928 + 96))
                      {
                        v973 = *(void **)(v972 + 56);
                        v974 = *(void **)__srce;
                        uint64_t v975 = v973[4];
                        if (v975 == *(void *)(*(void *)__srce + 32))
                        {
                          if (!v975) {
                            goto LABEL_1667;
                          }
                          uint64_t v976 = 0;
                          while (1)
                          {
                            uint64_t v977 = geo::codec::vectorTransitLineAlongLink(v973, v976);
                            uint64_t v978 = geo::codec::vectorTransitLineAlongLink(v974, v976);
                            if (*(void *)(v977 + 40) != *(void *)(v978 + 40)
                              || *(unsigned __int8 *)(v977 + 73) != *(unsigned __int8 *)(v978 + 73))
                            {
                              break;
                            }
                            if (v975 == ++v976) {
                              goto LABEL_1667;
                            }
                          }
                        }
                      }
                    }
                    else if ((v970 & (v957 - 1)) != v951)
                    {
                      goto LABEL_1679;
                    }
                    v960 = (void *)*v960;
                    if (!v960) {
                      goto LABEL_1679;
                    }
                  }
                }
                do
                {
                  unint64_t v961 = v960[1];
                  if (v961 == v956)
                  {
                    uint64_t v962 = v960[2];
                    if (v962) {
                      uint64_t v963 = v962 + 8;
                    }
                    else {
                      uint64_t v963 = 0;
                    }
                    if (*(unsigned __int8 *)(v963 + 88) == *(unsigned __int8 *)(v928 + 96))
                    {
                      v964 = *(void **)(v963 + 56);
                      v965 = *(void **)__srce;
                      uint64_t v966 = v964[4];
                      if (v966 == *(void *)(*(void *)__srce + 32))
                      {
                        if (v966)
                        {
                          uint64_t v967 = 0;
                          do
                          {
                            uint64_t v968 = geo::codec::vectorTransitLineAlongLink(v964, v967);
                            uint64_t v969 = geo::codec::vectorTransitLineAlongLink(v965, v967);
                            if (*(void *)(v968 + 40) != *(void *)(v969 + 40)
                              || *(unsigned __int8 *)(v968 + 73) != *(unsigned __int8 *)(v969 + 73))
                            {
                              goto LABEL_1639;
                            }
                          }
                          while (v966 != ++v967);
                        }
LABEL_1667:
                        v1509[25] = 0;
                        v979 = (void *)v960[2];
                        if (v979) {
                          ++*v979;
                        }
                        _ZF = (*(void *)v928)-- == 1;
                        if (_ZF)
                        {
                          md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>::~LabelFeatureThunk(v928 + 8);
                          {
                            operator new();
                          }
                          (*(void (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                             + 40))(mdm::Allocator::instance(void)::alloc, v1595, 104);
                          v979 = (void *)v960[2];
                        }
                        v1595 = v979;
                        if (v979) {
                          v980 = v979 + 1;
                        }
                        else {
                          v980 = 0;
                        }
                        v981 = (std::mutex *)(v980[1] + 8);
                        std::mutex::lock(v981);
                        v982 = (std::__shared_weak_count *)v1486[1];
                        if (v982)
                        {
                          uint64_t v983 = (uint64_t)std::__shared_weak_count::lock(v982);
                          if (v983)
                          {
                            v984 = v1486;
                            uint64_t v985 = *v1486;
                            goto LABEL_1815;
                          }
                          uint64_t v985 = 0;
                        }
                        else
                        {
                          uint64_t v983 = 0;
                          uint64_t v985 = 0;
                        }
                        v984 = v1486;
LABEL_1815:
                        *(void *)v1609 = v984;
                        *(void *)&v1609[8] = v985;
                        *(void *)&v1609[16] = v983;
                        v1598 = 0;
                        __p = 0;
                        v1069 = (uint64_t **)v980[4];
                        unint64_t v1070 = v980[5];
                        if ((unint64_t)v1069 < v1070)
                        {
                          if (v1069)
                          {
                            *v1069 = v1486;
                            v1069[1] = (uint64_t *)v985;
                            v1069[2] = (uint64_t *)v983;
                            *(void *)&v1609[8] = 0;
                            *(void *)&v1609[16] = 0;
                            uint64_t v983 = 0;
                          }
                          v980[4] = v1069 + 3;
                          if (!v983) {
                            goto LABEL_1843;
                          }
LABEL_1842:
                          if (atomic_fetch_add((atomic_ullong *volatile)(v983 + 8), 0xFFFFFFFFFFFFFFFFLL)) {
                            goto LABEL_1843;
                          }
                          (*(void (**)(uint64_t))(*(void *)v983 + 16))(v983);
                          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v983);
                          v1085 = v1598;
                          if (!v1598) {
                            goto LABEL_1847;
                          }
LABEL_1844:
                          if (!atomic_fetch_add(&v1085->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v1085->__on_zero_shared)(v1085);
                            std::__shared_weak_count::__release_weak(v1085);
                          }
                          goto LABEL_1847;
                        }
                        uint64_t v1071 = v980[3];
                        unint64_t v1072 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v1069 - v1071) >> 3);
                        unint64_t v1073 = v1072 + 1;
                        if (v1072 + 1 > 0xAAAAAAAAAAAAAAALL) {
                          abort();
                        }
                        if (0x5555555555555556 * ((uint64_t)(v1070 - v1071) >> 3) > v1073) {
                          unint64_t v1073 = 0x5555555555555556 * ((uint64_t)(v1070 - v1071) >> 3);
                        }
                        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v1070 - v1071) >> 3) >= 0x555555555555555) {
                          uint64_t v1074 = 0xAAAAAAAAAAAAAAALL;
                        }
                        else {
                          uint64_t v1074 = v1073;
                        }
                        if (v1074)
                        {
                          uint64_t v1075 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v980[6] + 16))(v980[6], 24 * v1074, 8);
                          uint64_t v1076 = v1075 + 24 * v1072;
                          uint64_t v1077 = v1075 + 24 * v1074;
                          if (v1075)
                          {
                            *(_OWORD *)uint64_t v1076 = *(_OWORD *)v1609;
                            *(void *)(v1075 + 24 * v1072 + 16) = v983;
                            *(void *)&v1609[8] = 0;
                            *(void *)&v1609[16] = 0;
                          }
                        }
                        else
                        {
                          uint64_t v1077 = 0;
                          uint64_t v1076 = 8 * (((uint64_t)v1069 - v1071) >> 3);
                        }
                        uint64_t v1078 = v1076 + 24;
                        uint64_t v1079 = v980[3];
                        uint64_t v1080 = v980[4];
                        if (v1080 == v1079)
                        {
                          v980[3] = v1076;
                          v980[4] = v1078;
                          uint64_t v1083 = v980[5];
                          v980[5] = v1077;
                        }
                        else
                        {
                          do
                          {
                            long long v1081 = *(_OWORD *)(v1080 - 24);
                            v1080 -= 24;
                            *(_OWORD *)(v1076 - 24) = v1081;
                            v1076 -= 24;
                            *(void *)(v1076 + 16) = *(void *)(v1080 + 16);
                            *(void *)(v1080 + 8) = 0;
                            *(void *)(v1080 + 16) = 0;
                          }
                          while (v1080 != v1079);
                          uint64_t v1080 = v980[3];
                          uint64_t v1082 = v980[4];
                          v980[3] = v1076;
                          v980[4] = v1078;
                          uint64_t v1083 = v980[5];
                          v980[5] = v1077;
                          while (v1082 != v1080)
                          {
                            v1084 = *(std::__shared_weak_count **)(v1082 - 8);
                            if (v1084 && !atomic_fetch_add(&v1084->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v1084->__on_zero_shared)(v1084);
                              std::__shared_weak_count::__release_weak(v1084);
                            }
                            v1082 -= 24;
                          }
                        }
                        if (v1080) {
                          (*(void (**)(void, uint64_t, uint64_t))(*(void *)v980[6] + 40))(v980[6], v1080, v1083 - v1080);
                        }
                        uint64_t v983 = *(void *)&v1609[16];
                        v980[4] = v1078;
                        if (v983) {
                          goto LABEL_1842;
                        }
LABEL_1843:
                        v1085 = v1598;
                        if (v1598) {
                          goto LABEL_1844;
                        }
LABEL_1847:
                        std::mutex::unlock(v981);
                        if (v1595) {
                          v1086 = v1595 + 1;
                        }
                        else {
                          v1086 = 0;
                        }
                        uint64_t v1087 = v1086[1];
                        md::LabelLineStore::addTransitLineSegment(*(void *)(v1087 + 192), v1486, (uint64_t)&v1504);
                        std::mutex::lock((std::mutex *)(v1087 + 608));
                        unint64_t v1088 = *(void *)(v1087 + 688);
                        unint64_t v1089 = *(void *)(v1087 + 696);
                        if (v1088 >= v1089)
                        {
                          uint64_t v1093 = *(void *)(v1087 + 680);
                          uint64_t v1094 = (uint64_t)(v1088 - v1093) >> 5;
                          if ((unint64_t)(v1094 + 1) >> 59) {
                            abort();
                          }
                          uint64_t v1095 = v1089 - v1093;
                          uint64_t v1096 = v1095 >> 4;
                          if (v1095 >> 4 <= (unint64_t)(v1094 + 1)) {
                            uint64_t v1096 = v1094 + 1;
                          }
                          if ((unint64_t)v1095 >= 0x7FFFFFFFFFFFFFE0) {
                            uint64_t v1097 = 0x7FFFFFFFFFFFFFFLL;
                          }
                          else {
                            uint64_t v1097 = v1096;
                          }
                          if (v1097)
                          {
                            uint64_t v1098 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v1087 + 704)
                                                                                        + 16))(*(void *)(v1087 + 704), 32 * v1097, 8);
                            uint64_t v1099 = v1098 + 32 * v1094;
                            uint64_t v983 = v1098 + 32 * v1097;
                            if (v1098)
                            {
                              *(unsigned char *)uint64_t v1099 = 1;
                              *(void *)(v1099 + 16) = 0;
                              *(void *)(v1099 + 8) = v1486;
                              *(void *)(v1099 + 24) = 0;
                              v1100 = (std::__shared_weak_count *)v1486[1];
                              if (v1100)
                              {
                                v1101 = std::__shared_weak_count::lock(v1100);
                                *(void *)(v1098 + 32 * v1094 + 24) = v1101;
                                if (v1101) {
                                  *(void *)(v1099 + 16) = *v1486;
                                }
                              }
                            }
                          }
                          else
                          {
                            uint64_t v983 = 0;
                            uint64_t v1099 = 32 * v1094;
                          }
                          uint64_t v1092 = v1099 + 32;
                          uint64_t v1102 = *(void *)(v1087 + 688);
                          uint64_t v1103 = *(void *)(v1087 + 680);
                          if (v1102 == v1103)
                          {
                            *(void *)(v1087 + 680) = v1099;
                            *(void *)(v1087 + 688) = v1092;
                            uint64_t v1105 = *(void *)(v1087 + 696);
                            *(void *)(v1087 + 696) = v983;
                          }
                          else
                          {
                            do
                            {
                              *(_OWORD *)(v1099 - 32) = *(_OWORD *)(v1102 - 32);
                              *(_OWORD *)(v1099 - 16) = *(_OWORD *)(v1102 - 16);
                              v1099 -= 32;
                              *(void *)(v1102 - 16) = 0;
                              *(void *)(v1102 - 8) = 0;
                              v1102 -= 32;
                            }
                            while (v1102 != v1103);
                            uint64_t v1102 = *(void *)(v1087 + 680);
                            uint64_t v1104 = *(void *)(v1087 + 688);
                            *(void *)(v1087 + 680) = v1099;
                            *(void *)(v1087 + 688) = v1092;
                            uint64_t v1105 = *(void *)(v1087 + 696);
                            *(void *)(v1087 + 696) = v983;
                            while (v1104 != v1102)
                            {
                              v1106 = *(std::__shared_weak_count **)(v1104 - 8);
                              if (v1106 && !atomic_fetch_add(&v1106->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                              {
                                ((void (*)(std::__shared_weak_count *))v1106->__on_zero_shared)(v1106);
                                std::__shared_weak_count::__release_weak(v1106);
                              }
                              v1104 -= 32;
                            }
                          }
                          if (v1102) {
                            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1087 + 704) + 40))(*(void *)(v1087 + 704), v1102, v1105 - v1102);
                          }
                        }
                        else
                        {
                          if (v1088)
                          {
                            *(unsigned char *)unint64_t v1088 = 1;
                            *(void *)(v1088 + 8) = v1486;
                            *(void *)(v1088 + 16) = 0;
                            *(void *)(v1088 + 24) = 0;
                            v1090 = (std::__shared_weak_count *)v1486[1];
                            if (v1090)
                            {
                              v1091 = std::__shared_weak_count::lock(v1090);
                              *(void *)(v1088 + 24) = v1091;
                              if (v1091) {
                                *(void *)(v1088 + 16) = *v1486;
                              }
                            }
                          }
                          uint64_t v1092 = v1088 + 32;
                        }
                        *(void *)(v1087 + 688) = v1092;
                        atomic_store(1u, (unsigned __int8 *)(v1087 + 672));
                        std::mutex::unlock((std::mutex *)(v1087 + 608));
                        v1107 = v1595;
LABEL_1917:
                        if (v1107) {
                          v1119 = v1107 + 1;
                        }
                        else {
                          v1119 = 0;
                        }
                        v1120 = (void *)v1119[1];
                        unint64_t v1121 = v1120[9];
                        unint64_t v1122 = v1454[43];
                        if (!v1122) {
                          goto LABEL_1946;
                        }
                        uint8x8_t v1123 = (uint8x8_t)vcnt_s8((int8x8_t)v1122);
                        v1123.i16[0] = vaddlv_u8(v1123);
                        if (v1123.u32[0] > 1uLL)
                        {
                          uint64_t v983 = v1120[9];
                          if (v1121 >= v1122) {
                            uint64_t v983 = v1121 % v1122;
                          }
                        }
                        else
                        {
                          uint64_t v983 = (v1122 - 1) & v1121;
                        }
                        v1124 = *(void **)(v1454[42] + 8 * v983);
                        if (!v1124 || (v1125 = (void *)*v1124) == 0)
                        {
LABEL_1946:
                          v1132 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v1454[46]
                                                                                                + 16))(v1454[46], 24, 8);
                          *(void *)v1609 = v1132;
                          *(void *)&v1609[8] = v1454 + 46;
                          void *v1132 = 0;
                          v1132[1] = v1121;
                          v1132[2] = v1107;
                          if (v1107) {
                            ++*v1107;
                          }
                          v1609[16] = 1;
                          float v1133 = (float)(unint64_t)(v1454[47] + 1);
                          float v1134 = *((float *)v1454 + 96);
                          if (!v1122 || (float)(v1134 * (float)v1122) < v1133)
                          {
                            BOOL v1135 = (v1122 & (v1122 - 1)) != 0;
                            if (v1122 < 3) {
                              BOOL v1135 = 1;
                            }
                            unint64_t v1136 = v1135 | (2 * v1122);
                            unint64_t v1137 = vcvtps_u32_f32(v1133 / v1134);
                            if (v1136 <= v1137) {
                              size_t v1138 = v1137;
                            }
                            else {
                              size_t v1138 = v1136;
                            }
                            if (v1138 == 1)
                            {
                              size_t v1138 = 2;
                            }
                            else if ((v1138 & (v1138 - 1)) != 0)
                            {
                              size_t v1138 = std::__next_prime(v1138);
                            }
                            unint64_t v1122 = v1454[43];
                            if (v1138 > v1122)
                            {
LABEL_1960:
                              uint64_t v1139 = (*(uint64_t (**)(void, size_t, uint64_t))(*(void *)v1454[44] + 16))(v1454[44], 8 * v1138, 8);
                              uint64_t v1140 = v1454[42];
                              v1454[42] = v1139;
                              if (v1140) {
                                (*(void (**)(void, uint64_t, uint64_t))(*(void *)v1454[44] + 40))(v1454[44], v1140, 8 * v1454[43]);
                              }
                              uint64_t v1141 = 0;
                              v1454[43] = v1138;
                              do
                                *(void *)(v1454[42] + 8 * v1141++) = 0;
                              while (v1138 != v1141);
                              v1142 = (void *)*v1425;
                              if (!*v1425) {
                                goto LABEL_1983;
                              }
                              size_t v1143 = v1142[1];
                              size_t v1144 = v1138 - 1;
                              if ((v1138 & (v1138 - 1)) == 0)
                              {
                                size_t v1145 = v1143 & v1144;
                                *(void *)(v1454[42] + 8 * v1145) = v1425;
                                for (ii = (void *)*v1142; *v1142; ii = (void *)*v1142)
                                {
                                  size_t v1147 = ii[1] & v1144;
                                  if (v1147 == v1145)
                                  {
                                    v1142 = ii;
                                  }
                                  else
                                  {
                                    uint64_t v1148 = v1454[42];
                                    if (*(void *)(v1148 + 8 * v1147))
                                    {
                                      void *v1142 = *ii;
                                      uint64_t v1149 = 8 * v1147;
                                      void *ii = **(void **)(v1454[42] + v1149);
                                      **(void **)(v1454[42] + v1149) = ii;
                                    }
                                    else
                                    {
                                      *(void *)(v1148 + 8 * v1147) = v1142;
                                      v1142 = ii;
                                      size_t v1145 = v1147;
                                    }
                                  }
                                }
                                goto LABEL_1983;
                              }
                              if (v1143 >= v1138) {
                                v1143 %= v1138;
                              }
                              *(void *)(v1454[42] + 8 * v1143) = v1425;
                              v1153 = (void *)*v1142;
                              if (!*v1142)
                              {
LABEL_1983:
                                unint64_t v1122 = v1138;
                                goto LABEL_1984;
                              }
                              while (2)
                              {
                                size_t v1155 = v1153[1];
                                if (v1155 >= v1138) {
                                  v1155 %= v1138;
                                }
                                if (v1155 != v1143)
                                {
                                  uint64_t v1156 = v1454[42];
                                  if (!*(void *)(v1156 + 8 * v1155))
                                  {
                                    *(void *)(v1156 + 8 * v1155) = v1142;
LABEL_1988:
                                    v1142 = v1153;
                                    v1153 = (void *)*v1153;
                                    size_t v1143 = v1155;
                                    if (!v1153) {
                                      goto LABEL_1983;
                                    }
                                    continue;
                                  }
                                  void *v1142 = *v1153;
                                  uint64_t v1154 = 8 * v1155;
                                  void *v1153 = **(void **)(v1454[42] + v1154);
                                  **(void **)(v1454[42] + v1154) = v1153;
                                  v1153 = v1142;
                                }
                                break;
                              }
                              size_t v1155 = v1143;
                              goto LABEL_1988;
                            }
                            if (v1138 < v1122)
                            {
                              unint64_t v1150 = vcvtps_u32_f32((float)(unint64_t)v1454[47] / *((float *)v1454 + 96));
                              if (v1122 < 3
                                || (uint8x8_t v1151 = (uint8x8_t)vcnt_s8((int8x8_t)v1122),
                                    v1151.i16[0] = vaddlv_u8(v1151),
                                    v1151.u32[0] > 1uLL))
                              {
                                unint64_t v1150 = std::__next_prime(v1150);
                              }
                              else
                              {
                                uint64_t v1152 = 1 << -(char)__clz(v1150 - 1);
                                if (v1150 >= 2) {
                                  unint64_t v1150 = v1152;
                                }
                              }
                              if (v1138 <= v1150) {
                                size_t v1138 = v1150;
                              }
                              if (v1138 >= v1122)
                              {
                                unint64_t v1122 = v1454[43];
                              }
                              else
                              {
                                if (v1138) {
                                  goto LABEL_1960;
                                }
                                uint64_t v1192 = v1454[42];
                                v1454[42] = 0;
                                if (v1192) {
                                  (*(void (**)(void, uint64_t, uint64_t))(*(void *)v1454[44] + 40))(v1454[44], v1192, 8 * v1454[43]);
                                }
                                unint64_t v1122 = 0;
                                v1454[43] = 0;
                              }
                            }
LABEL_1984:
                            if ((v1122 & (v1122 - 1)) != 0)
                            {
                              if (v1121 >= v1122) {
                                uint64_t v983 = v1121 % v1122;
                              }
                              else {
                                uint64_t v983 = v1121;
                              }
                            }
                            else
                            {
                              uint64_t v983 = (v1122 - 1) & v1121;
                            }
                          }
                          v1157 = *(void **)(v1454[42] + 8 * v983);
                          if (v1157)
                          {
                            void *v1132 = *v1157;
                            unint64_t v911 = v1433;
                            unint64_t v918 = v1461;
                            goto LABEL_2005;
                          }
                          void *v1132 = v1454[45];
                          v1454[45] = v1132;
                          *(void *)(v1454[42] + 8 * v983) = v1425;
                          unint64_t v911 = v1433;
                          unint64_t v918 = v1461;
                          if (*v1132)
                          {
                            unint64_t v1158 = *(void *)(*v1132 + 8);
                            if ((v1122 & (v1122 - 1)) != 0)
                            {
                              if (v1158 >= v1122) {
                                v1158 %= v1122;
                              }
                            }
                            else
                            {
                              v1158 &= v1122 - 1;
                            }
                            v1157 = (void *)(v1454[42] + 8 * v1158);
LABEL_2005:
                            void *v1157 = v1132;
                          }
                          ++v1454[47];
                          v1120 = (void *)v1119[1];
                          goto LABEL_2007;
                        }
                        if (v1123.u32[0] < 2uLL)
                        {
                          while (1)
                          {
                            uint64_t v1131 = v1125[1];
                            if (v1131 == v1121)
                            {
                              uint64_t v1129 = v1125[2];
                              if (v1129) {
                                uint64_t v1130 = v1129 + 8;
                              }
                              else {
                                uint64_t v1130 = 0;
                              }
                              if (*(void *)(*(void *)(v1130 + 8) + 72) == v1121) {
                                goto LABEL_2065;
                              }
                            }
                            else if ((v1131 & (v1122 - 1)) != v983)
                            {
                              goto LABEL_1946;
                            }
                            v1125 = (void *)*v1125;
                            if (!v1125) {
                              goto LABEL_1946;
                            }
                          }
                        }
                        while (2)
                        {
                          unint64_t v1126 = v1125[1];
                          if (v1126 != v1121)
                          {
                            if (v1126 >= v1122) {
                              v1126 %= v1122;
                            }
                            if (v1126 != v983) {
                              goto LABEL_1946;
                            }
LABEL_1930:
                            v1125 = (void *)*v1125;
                            if (!v1125) {
                              goto LABEL_1946;
                            }
                            continue;
                          }
                          break;
                        }
                        uint64_t v1127 = v1125[2];
                        if (v1127) {
                          uint64_t v1128 = v1127 + 8;
                        }
                        else {
                          uint64_t v1128 = 0;
                        }
                        if (*(void *)(*(void *)(v1128 + 8) + 72) != v1121) {
                          goto LABEL_1930;
                        }
LABEL_2065:
                        unint64_t v911 = v1433;
                        unint64_t v918 = v1461;
LABEL_2007:
                        v1159 = (std::__shared_weak_count *)v1119[2];
                        v1601 = v1120;
                        v1602 = v1159;
                        if (v1159) {
                          atomic_fetch_add_explicit(&v1159->__shared_owners_, 1uLL, memory_order_relaxed);
                        }
                        if (v1107 && (_ZF = *v1107 == 1, --*v1107, _ZF))
                        {
                          md::LabelFeatureThunk<md::TransitLineLabelFeature,GeoCodecsTransitLink,geo::codec::VectorTile>::~LabelFeatureThunk((uint64_t)(v1107 + 1));
                          {
                            operator new();
                          }
                          (*(void (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                             + 40))(mdm::Allocator::instance(void)::alloc, v1595, 104);
                          v1120 = v1601;
                          v1159 = v1602;
                          if (v1602) {
LABEL_2012:
                          }
                            atomic_fetch_add_explicit(&v1159->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                        }
                        else if (v1159)
                        {
                          goto LABEL_2012;
                        }
                        v1160 = (uint64_t *)(a1 + 176);
LABEL_2014:
                        v1161 = (uint64_t *)*v1160;
                        v1162 = v1160;
                        if (*v1160)
                        {
                          do
                          {
                            v1160 = v1161;
                            unint64_t v1163 = v1161[5];
                            if ((unint64_t)v1159 < v1163) {
                              goto LABEL_2014;
                            }
                            if (v1163 >= (unint64_t)v1159)
                            {
                              if (v1159) {
                                std::__shared_weak_count::__release_weak(v1159);
                              }
                              if (!v1509[25]) {
                                goto LABEL_2087;
                              }
                              goto LABEL_2042;
                            }
                            v1161 = (uint64_t *)v1160[1];
                          }
                          while (v1161);
                          v1162 = v1160 + 1;
                        }
                        uint64_t v1164 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)a1 + 23) + 16))(*((void *)a1 + 23), 48, 8);
                        *(void *)(v1164 + 32) = v1120;
                        *(void *)(v1164 + 40) = v1159;
                        *(void *)uint64_t v1164 = 0;
                        *(void *)(v1164 + 8) = 0;
                        *(void *)(v1164 + 16) = v1160;
                        uint64_t *v1162 = v1164;
                        v1165 = (void *)**v1416;
                        if (v1165)
                        {
                          *v1416 = v1165;
                          uint64_t v1164 = *v1162;
                        }
                        uint64_t v1166 = *v1440;
                        _ZF = v1164 == *v1440;
                        *(unsigned char *)(v1164 + 24) = _ZF;
                        if (_ZF) {
                          goto LABEL_2086;
                        }
                        while (2)
                        {
                          v1167 = *(uint64_t **)(v1164 + 16);
                          if (*((unsigned char *)v1167 + 24)) {
                            goto LABEL_2086;
                          }
                          uint64_t v1168 = v1167[2];
                          v1169 = *(uint64_t **)v1168;
                          if (*(uint64_t **)v1168 != v1167)
                          {
                            if (!v1169 || (int v1171 = *((unsigned __int8 *)v1169 + 24), v1170 = v1169 + 3, v1171))
                            {
                              if (*v1167 == v1164)
                              {
                                uint64_t v1193 = *(void *)(v1164 + 8);
                                uint64_t *v1167 = v1193;
                                if (v1193)
                                {
                                  *(void *)(v1193 + 16) = v1167;
                                  uint64_t v1168 = v1167[2];
                                }
                                *(void *)(v1164 + 16) = v1168;
                                *(void *)(v1167[2] + 8 * (*(void *)v1167[2] != (void)v1167)) = v1164;
                                *(void *)(v1164 + 8) = v1167;
                                v1167[2] = v1164;
                                uint64_t v1168 = *(void *)(v1164 + 16);
                              }
                              else
                              {
                                uint64_t v1164 = *(void *)(v1164 + 16);
                              }
                              *(unsigned char *)(v1164 + 24) = 1;
                              *(unsigned char *)(v1168 + 24) = 0;
                              v1167 = *(uint64_t **)(v1168 + 8);
                              uint64_t v1194 = *v1167;
                              *(void *)(v1168 + 8) = *v1167;
                              if (v1194) {
                                *(void *)(v1194 + 16) = v1168;
                              }
                              v1167[2] = *(void *)(v1168 + 16);
                              *(void *)(*(void *)(v1168 + 16) + 8 * (**(void **)(v1168 + 16) != v1168)) = v1167;
                              uint64_t *v1167 = v1168;
                              goto LABEL_2085;
                            }
                            goto LABEL_2024;
                          }
                          uint64_t v1172 = *(void *)(v1168 + 8);
                          if (v1172)
                          {
                            int v1173 = *(unsigned __int8 *)(v1172 + 24);
                            v1170 = (unsigned char *)(v1172 + 24);
                            if (!v1173)
                            {
LABEL_2024:
                              *((unsigned char *)v1167 + 24) = 1;
                              uint64_t v1164 = v1168;
                              *(unsigned char *)(v1168 + 24) = v1168 == v1166;
                              unsigned char *v1170 = 1;
                              if (v1168 == v1166) {
                                goto LABEL_2086;
                              }
                              continue;
                            }
                          }
                          break;
                        }
                        if (*v1167 == v1164)
                        {
                          v1174 = *(uint64_t ***)(v1164 + 16);
                        }
                        else
                        {
                          v1174 = (uint64_t **)v1167[1];
                          v1175 = *v1174;
                          v1167[1] = (uint64_t)*v1174;
                          if (v1175)
                          {
                            v1175[2] = (uint64_t)v1167;
                            uint64_t v1168 = v1167[2];
                          }
                          v1174[2] = (uint64_t *)v1168;
                          *(void *)(v1167[2] + 8 * (*(void *)v1167[2] != (void)v1167)) = v1174;
                          *v1174 = v1167;
                          v1167[2] = (uint64_t)v1174;
                          uint64_t v1168 = (uint64_t)v1174[2];
                          v1167 = *(uint64_t **)v1168;
                        }
                        *((unsigned char *)v1174 + 24) = 1;
                        *(unsigned char *)(v1168 + 24) = 0;
                        uint64_t v1195 = v1167[1];
                        *(void *)uint64_t v1168 = v1195;
                        if (v1195) {
                          *(void *)(v1195 + 16) = v1168;
                        }
                        v1167[2] = *(void *)(v1168 + 16);
                        *(void *)(*(void *)(v1168 + 16) + 8 * (**(void **)(v1168 + 16) != v1168)) = v1167;
                        v1167[1] = v1168;
LABEL_2085:
                        *(void *)(v1168 + 16) = v1167;
LABEL_2086:
                        ++*((void *)a1 + 24);
                        if (!v1509[25])
                        {
LABEL_2087:
                          v1191 = v1602;
                          if (v1602) {
                            goto LABEL_2088;
                          }
                          goto LABEL_1585;
                        }
LABEL_2042:
                        v1176 = v1601;
                        v1177 = v1592[1];
                        if (v1592[1] >= v1593[0])
                        {
                          unint64_t v1179 = 0xAAAAAAAAAAAAAAABLL * (((char *)v1592[1] - (char *)v1592[0]) >> 3);
                          unint64_t v1180 = v1179 + 1;
                          if (v1179 + 1 > 0xAAAAAAAAAAAAAAALL) {
                            abort();
                          }
                          if (0x5555555555555556 * (((char *)v1593[0] - (char *)v1592[0]) >> 3) > v1180) {
                            unint64_t v1180 = 0x5555555555555556 * (((char *)v1593[0] - (char *)v1592[0]) >> 3);
                          }
                          if (0xAAAAAAAAAAAAAAABLL * (((char *)v1593[0] - (char *)v1592[0]) >> 3) >= 0x555555555555555) {
                            uint64_t v1181 = 0xAAAAAAAAAAAAAAALL;
                          }
                          else {
                            uint64_t v1181 = v1180;
                          }
                          if (v1181)
                          {
                            uint64_t v1182 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v1593[1] + 16))(v1593[1], 24 * v1181, 8);
                            v1183 = (char *)(v1182 + 24 * v1179);
                            v1184 = (void *)(v1182 + 24 * v1181);
                            if (v1182)
                            {
                              *(void *)v1183 = v1176;
                              unint64_t v1185 = v1182 + 24 * v1179;
                              *(void *)(v1185 + 8) = 0;
                              *(void *)(v1185 + 16) = 0;
                            }
                          }
                          else
                          {
                            v1184 = 0;
                            v1183 = (char *)(8 * (((char *)v1592[1] - (char *)v1592[0]) >> 3));
                          }
                          v1186 = (char *)v1592[1];
                          v1187 = (char *)v1592[0];
                          v1188 = v1183;
                          if (v1592[1] != v1592[0])
                          {
                            do
                            {
                              long long v1189 = *(_OWORD *)(v1186 - 24);
                              *((void *)v1188 - 1) = *((void *)v1186 - 1);
                              *(_OWORD *)(v1188 - 24) = v1189;
                              v1188 -= 24;
                              v1186 -= 24;
                            }
                            while (v1186 != v1187);
                            v1186 = (char *)v1592[0];
                          }
                          v1178 = v1183 + 24;
                          v1592[0] = v1188;
                          v1592[1] = v1183 + 24;
                          v1190 = v1593[0];
                          v1593[0] = v1184;
                          if (v1186) {
                            (*(void (**)(void *, char *, int64_t))(*(void *)v1593[1] + 40))(v1593[1], v1186, v1190 - v1186);
                          }
                        }
                        else
                        {
                          if (v1592[1])
                          {
                            *((void *)v1592[1] + 1) = 0;
                            v1177[2] = 0;
                            void *v1177 = v1176;
                          }
                          v1178 = v1177 + 3;
                        }
                        v1592[1] = v1178;
                        v1191 = v1602;
                        if (v1602)
                        {
LABEL_2088:
                          if (!atomic_fetch_add(&v1191->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v1191->__on_zero_shared)(v1191);
                            std::__shared_weak_count::__release_weak(v1191);
                          }
                        }
LABEL_1585:
                        v921 = v1592[1];
                        v922 = v1592[0];
LABEL_1586:
                        ++v918;
                        if (0xAAAAAAAAAAAAAAABLL * ((v921 - v922) >> 3) <= 0x1F && v918 < v911) {
                          goto LABEL_1590;
                        }
LABEL_1583:
                        md::LabelFeatureStyler::styleLabelFeatures(*(unsigned int **)(v1418 + 296), (char **)v1592, 1u, 1, *(void *)(*(void *)(v1418 + 152) + 32));
                        v919 = v1473;
                        std::mutex::unlock(v1473);
                        if (v918 < v911) {
                          goto LABEL_1575;
                        }
LABEL_2093:
                        if (v1592[0])
                        {
                          v1592[1] = v1592[0];
                          (*(void (**)(void *, void *, int64_t))(*(void *)v1593[1] + 40))(v1593[1], v1592[0], (char *)v1593[0] - (char *)v1592[0]);
                        }
                        v910 = v1511;
LABEL_2096:
                        if (v910 && !atomic_fetch_add(&v910->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v910->__on_zero_shared)(v910);
                          std::__shared_weak_count::__release_weak(v910);
                        }
                        uint64_t v1462 = geo::codec::VectorTile::transitLinkCount(*(geo::codec::VectorTile **)a3);
                        if (v1462)
                        {
                          std::mutex::lock(v1473);
                          v1196 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v1473[7].__m_.__opaque, *(void *)a3);
                          if (!v1196)
                          {
                            v1239 = v1473;
                            goto LABEL_2150;
                          }
                          v1197 = v1196;
                          if (!v1196[52])
                          {
                            v1198 = (std::__shared_weak_count *)operator new(0x100uLL);
                            v1198->__shared_owners_ = 0;
                            v1198->__shared_weak_owners_ = 0;
                            v1198->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581590;
                            uint64_t v1199 = md::LabelTileCollisionInfo::LabelTileCollisionInfo((uint64_t)&v1198[1], v1401);
                            atomic_fetch_add_explicit(&v1198->__shared_owners_, 1uLL, memory_order_relaxed);
                            v1200 = (std::__shared_weak_count *)v1197[53];
                            v1197[52] = v1199;
                            v1197[53] = v1198;
                            if (v1200 && !atomic_fetch_add(&v1200->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v1200->__on_zero_shared)(v1200);
                              std::__shared_weak_count::__release_weak(v1200);
                            }
                            if (!atomic_fetch_add(&v1198->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v1198->__on_zero_shared)(v1198);
                              std::__shared_weak_count::__release_weak(v1198);
                            }
                          }
                          uint64_t v1202 = v1197[52];
                          uint64_t v1201 = v1197[53];
                          if (v1201) {
                            atomic_fetch_add_explicit((atomic_ullong *volatile)(v1201 + 16), 1uLL, memory_order_relaxed);
                          }
                          v1203 = (std::__shared_weak_count *)*((void *)a1 + 34);
                          *((void *)a1 + 33) = v1202;
                          *((void *)a1 + 34) = v1201;
                          if (v1203) {
                            std::__shared_weak_count::__release_weak(v1203);
                          }
                          uint64_t v1204 = v1197[52];
                          std::mutex::unlock(v1473);
                          if (v1204)
                          {
                            std::mutex::lock((std::mutex *)v1204);
                            if (*(unsigned char *)(v1204 + 224)) {
                              goto LABEL_2149;
                            }
                            *(unsigned char *)(v1204 + 224) = 1;
                            *(unsigned char *)(v1204 + 225) = *(unsigned char *)(geo::codec::VectorTile::key(*(geo::codec::VectorTile **)a3)
                                                               + 1) & 0x3F;
                            uint64_t v1205 = geo::codec::VectorTile::transitVertices(*(geo::codec::VectorTile **)a3);
                            uint64_t v1206 = geo::codec::VectorTile::transitLinks(*(geo::codec::VectorTile **)a3);
                            uint64_t v1207 = 0;
                            while (1)
                            {
                              uint64_t v1470 = v1207;
                              unint64_t v1208 = *(unsigned int *)(v1206 + 20);
                              if (v1208) {
                                break;
                              }
LABEL_2114:
                              uint64_t v1207 = v1470 + 1;
                              v1206 += 184;
                              if (v1470 + 1 == v1462)
                              {
                                md::LabelTileCollisionInfo::simplifyPaths((md::LabelTileCollisionInfo *)v1204, 0.00300000003);
LABEL_2149:
                                v1239 = (std::mutex *)v1204;
LABEL_2150:
                                std::mutex::unlock(v1239);
                                goto LABEL_2151;
                              }
                            }
                            uint64_t v1209 = 0;
                            while (2)
                            {
                              uint64_t v1210 = *(void *)(v1205 + 32) + 16 * *(unsigned int *)(v1206 + 16);
                              unint64_t v1211 = *(void *)(v1210 + 16 * v1209 + 8);
                              if (v1211 < 2) {
                                goto LABEL_2117;
                              }
                              uint64_t v1212 = *(void *)(v1205 + 8);
                              uint64_t v1213 = *(void *)(v1210 + 16 * v1209);
                              uint64_t v1214 = (*(void *)(v1204 + 104) - *(void *)(v1204 + 96)) >> 3;
                              v1215 = *(_DWORD **)(v1204 + 200);
                              unint64_t v1216 = *(void *)(v1204 + 208);
                              if ((unint64_t)v1215 < v1216)
                              {
                                if (v1215)
                                {
                                  _DWORD *v1215 = v1214;
                                  v1215[1] = v1211;
                                }
                                v1217 = v1215 + 2;
                                goto LABEL_2146;
                              }
                              uint64_t v1218 = *(void *)(v1204 + 192);
                              uint64_t v1219 = ((uint64_t)v1215 - v1218) >> 3;
                              unint64_t v1220 = v1219 + 1;
                              if ((unint64_t)(v1219 + 1) >> 61) {
                                abort();
                              }
                              uint64_t v1221 = v1216 - v1218;
                              if (v1221 >> 2 > v1220) {
                                unint64_t v1220 = v1221 >> 2;
                              }
                              if ((unint64_t)v1221 >= 0x7FFFFFFFFFFFFFF8) {
                                uint64_t v1222 = 0x1FFFFFFFFFFFFFFFLL;
                              }
                              else {
                                uint64_t v1222 = v1220;
                              }
                              if (v1222)
                              {
                                uint64_t v1223 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v1204 + 216)
                                                                                            + 16))(*(void *)(v1204 + 216), 8 * v1222, 4);
                                v1224 = (_DWORD *)(v1223 + 8 * v1219);
                                uint64_t v1225 = v1223 + 8 * v1222;
                                if (v1223)
                                {
                                  _DWORD *v1224 = v1214;
                                  v1224[1] = v1211;
                                }
                              }
                              else
                              {
                                uint64_t v1225 = 0;
                                v1224 = (_DWORD *)(8 * v1219);
                              }
                              uint64_t v1227 = *(void *)(v1204 + 192);
                              uint64_t v1226 = *(void *)(v1204 + 200);
                              uint64_t v1228 = v1226 - v1227;
                              if (v1226 == v1227)
                              {
                                v1230 = v1224;
                                goto LABEL_2144;
                              }
                              unint64_t v1229 = v1228 - 8;
                              if ((unint64_t)(v1228 - 8) < 0x38)
                              {
                                v1230 = v1224;
                              }
                              else
                              {
                                v1230 = v1224;
                                if ((unint64_t)(v1226 - (void)v1224) >= 0x20)
                                {
                                  uint64_t v1231 = (v1229 >> 3) + 1;
                                  v1232 = v1224 - 4;
                                  v1233 = (long long *)(v1226 - 16);
                                  uint64_t v1234 = v1231 & 0x3FFFFFFFFFFFFFFCLL;
                                  do
                                  {
                                    long long v1235 = *v1233;
                                    *(v1232 - 1) = *(v1233 - 1);
                                    _OWORD *v1232 = v1235;
                                    v1232 -= 2;
                                    v1233 -= 2;
                                    v1234 -= 4;
                                  }
                                  while (v1234);
                                  v1230 = &v1224[-2 * (v1231 & 0x3FFFFFFFFFFFFFFCLL)];
                                  v1226 -= 8 * (v1231 & 0x3FFFFFFFFFFFFFFCLL);
                                  if (v1231 == (v1231 & 0x3FFFFFFFFFFFFFFCLL))
                                  {
LABEL_2143:
                                    uint64_t v1226 = *(void *)(v1204 + 192);
LABEL_2144:
                                    v1217 = v1224 + 2;
                                    *(void *)(v1204 + 192) = v1230;
                                    *(void *)(v1204 + 200) = v1224 + 2;
                                    uint64_t v1237 = *(void *)(v1204 + 208);
                                    *(void *)(v1204 + 208) = v1225;
                                    if (v1226) {
                                      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1204 + 216)
                                    }
                                                                                       + 40))(*(void *)(v1204 + 216), v1226, v1237 - v1226);
LABEL_2146:
                                    *(void *)(v1204 + 200) = v1217;
                                    std::vector<gm::Matrix<float,2,1>,geo::StdAllocator<gm::Matrix<float,2,1>,mdm::Allocator>>::__insert_with_size[abi:nn180100]<gm::Matrix<float,2,1> const*,gm::Matrix<float,2,1> const*>((uint64_t *)(v1204 + 96), *(void *)(v1204 + 104), v1212 + 8 * v1213, (void *)(v1212 + 8 * v1213 + 8 * v1211), v1211);
                                    uint64_t v1238 = *(void *)(v1204 + 136);
                                    LODWORD(v1592[0]) = 0;
                                    std::vector<float,geo::StdAllocator<float,mdm::Allocator>>::insert((float **)(v1204 + 128), v1238, v1211, (const float *)v1592);
                                    unint64_t v1208 = *(unsigned int *)(v1206 + 20);
LABEL_2117:
                                    if (++v1209 >= v1208) {
                                      goto LABEL_2114;
                                    }
                                    continue;
                                  }
                                }
                              }
                              break;
                            }
                            do
                            {
                              uint64_t v1236 = *(void *)(v1226 - 8);
                              v1226 -= 8;
                              *((void *)v1230 - 1) = v1236;
                              v1230 -= 2;
                            }
                            while (v1226 != v1227);
                            goto LABEL_2143;
                          }
                        }
LABEL_2151:
                        if (!HIDWORD(v1403)) {
                          goto LABEL_2157;
                        }
                        unint64_t v1240 = geo::codec::VectorTile::poisCount(*(geo::codec::VectorTile **)a3);
                        if (!v1240) {
                          goto LABEL_2157;
                        }
                        v1241 = (uint64_t *)geo::codec::VectorTile::pois(*(geo::codec::VectorTile **)a3);
                        uint64_t v1496 = *(void *)buf;
                        __int16 v1497 = v1585;
                        uint64_t v1498 = *(void *)((char *)&v1585 + 4);
                        long long v1499 = v1587;
                        long long v1500 = v1588;
                        v1501[0] = *(_OWORD *)v1589;
                        *(_OWORD *)((char *)v1501 + 11) = *(_OWORD *)&v1589[11];
                        v1502 = v1590;
                        v1503 = v1591;
                        if (v1591) {
                          atomic_fetch_add_explicit(&v1591->__shared_owners_, 1uLL, memory_order_relaxed);
                        }
                        md::LabelFeaturePool::addPointFeatures(v1473, (unint64_t *)a3, v1241, v1240, &v1496, v1438, 17, 0);
                        v1242 = v1503;
                        if (!v1503 || atomic_fetch_add(&v1503->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
LABEL_2157:
                          if (v1403) {
                            goto LABEL_2158;
                          }
LABEL_2359:
                          v1398 = v1591;
                          if (v1591 && !atomic_fetch_add(&v1591->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v1398->__on_zero_shared)(v1398);
                            std::__shared_weak_count::__release_weak(v1398);
                          }
                          if (!v1608)
                          {
                            std::__throw_bad_function_call[abi:nn180100]();
                            goto LABEL_2424;
                          }
                          (*(void (**)(void *))(*v1608 + 48))(v1608);
                          if (v1608 == v1607)
                          {
                            (*(void (**)(void *))(v1607[0] + 32))(v1607);
                          }
                          else if (v1608)
                          {
                            (*(void (**)(void))(*v1608 + 40))();
                          }
                          return;
                        }
                        ((void (*)(std::__shared_weak_count *))v1242->__on_zero_shared)(v1242);
                        std::__shared_weak_count::__release_weak(v1242);
                        if (!v1403) {
                          goto LABEL_2359;
                        }
LABEL_2158:
                        unint64_t v1243 = geo::codec::VectorTile::poisCount(*(geo::codec::VectorTile **)a3);
                        if (!v1243) {
                          goto LABEL_2359;
                        }
                        uint64_t v1244 = geo::codec::VectorTile::pois(*(geo::codec::VectorTile **)a3);
                        uint64_t v1245 = *(void *)buf;
                        uint64_t v1488 = *(void *)buf;
                        __int16 v1489 = v1585;
                        uint64_t v1490 = *(void *)((char *)&v1585 + 4);
                        long long v1491 = v1587;
                        long long v1492 = v1588;
                        *(_OWORD *)v1493 = *(_OWORD *)v1589;
                        *(_OWORD *)&v1493[11] = *(_OWORD *)&v1589[11];
                        v1494 = v1590;
                        v1495 = v1591;
                        if (v1591) {
                          atomic_fetch_add_explicit(&v1591->__shared_owners_, 1uLL, memory_order_relaxed);
                        }
                        uint64_t v1246 = geo::codec::VectorTile::poiStorefrontBundleIDs(*(geo::codec::VectorTile **)a3);
                        v1592[1] = 0;
                        v1592[0] = 0;
                        v1593[0] = 0;
                        {
                          operator new();
                        }
                        v1593[1] = (void *)mdm::Allocator::instance(void)::alloc;
                        v1247 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                             + 16))(mdm::Allocator::instance(void)::alloc, 768, 8);
                        v1248 = v1247 + 768;
                        v1249 = (char *)v1592[1];
                        v1250 = (char *)v1592[0];
                        if (v1592[1] != v1592[0])
                        {
                          do
                          {
                            long long v1251 = *(_OWORD *)(v1249 - 24);
                            *((void *)v1247 - 1) = *((void *)v1249 - 1);
                            *(_OWORD *)(v1247 - 24) = v1251;
                            v1247 -= 24;
                            v1249 -= 24;
                          }
                          while (v1249 != v1250);
                          v1249 = v1250;
                        }
                        v1252 = v1593[0];
                        v1592[0] = v1247;
                        v1593[0] = v1248;
                        if (v1249) {
                          (*(void (**)(void *, char *, int64_t))(*(void *)v1593[1] + 40))(v1593[1], v1249, v1252 - v1249);
                        }
                        unint64_t v1253 = 0;
                        *(void *)v1445 = 0;
                        v1254 = v1473;
                        __asm { FMOV            V0.2D, #0.5 }
                        float64x2_t v1463 = _Q0;
                        unint64_t v1423 = v1243;
                        uint64_t v1420 = v1245;
                        uint64_t v1437 = v1246;
                        while (1)
                        {
                          v1592[1] = v1592[0];
                          std::mutex::lock(v1254);
                          v1258 = a8;
                          if (!*(void *)v1445)
                          {
                            v1259 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v1473[7].__m_.__opaque, *(void *)a3);
                            if (!v1259)
                            {
                              std::mutex::unlock(v1473);
LABEL_2353:
                              if (v1592[0])
                              {
                                v1592[1] = v1592[0];
                                (*(void (**)(void *, void *, int64_t))(*(void *)v1593[1] + 40))(v1593[1], v1592[0], (char *)v1593[0] - (char *)v1592[0]);
                              }
                              v1397 = v1495;
                              if (v1495 && !atomic_fetch_add(&v1495->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                              {
                                ((void (*)(std::__shared_weak_count *))v1397->__on_zero_shared)(v1397);
                                std::__shared_weak_count::__release_weak(v1397);
                              }
                              goto LABEL_2359;
                            }
                            *(void *)v1445 = v1259 + 3;
                            v1258 = a8;
                          }
                          v1260 = v1592[1];
                          v1261 = v1592[0];
                          if (0xAAAAAAAAAAAAAAABLL * (((char *)v1592[1] - (char *)v1592[0]) >> 3) <= 0x1F
                            && v1253 < v1243)
                          {
                            break;
                          }
LABEL_2176:
                          md::LabelFeatureStyler::styleLabelFeatures(*(unsigned int **)(v1245 + 296), (char **)v1592, 1u, 1, *(void *)(*(void *)(v1245 + 152) + 32));
                          v1254 = v1473;
                          std::mutex::unlock(v1473);
                          if (v1253 >= v1243) {
                            goto LABEL_2353;
                          }
                        }
                        while (2)
                        {
                          if (*(unsigned char *)(v1244 + 206))
                          {
                            uint64_t v1264 = 0;
                            int8x8_t v1266 = (int8x8_t)v1258[33];
                            uint8x8_t v1267 = (uint8x8_t)vcnt_s8(v1266);
                            v1267.i16[0] = vaddlv_u8(v1267);
                            uint64_t v1268 = *(void *)&v1266 - 1;
                            while (1)
                            {
                              if (v1266)
                              {
                                uint64_t v1265 = v1246 + 8 * *(unsigned int *)(v1244 + 188);
                                unint64_t v1270 = *(void *)(v1265 + 8 * v1264);
                                if (v1267.u32[0] > 1uLL)
                                {
                                  unint64_t v1271 = *(void *)(v1265 + 8 * v1264);
                                  if (*(void *)&v1266 <= v1270) {
                                    unint64_t v1271 = v1270 % *(void *)&v1266;
                                  }
                                }
                                else
                                {
                                  unint64_t v1271 = v1268 & v1270;
                                }
                                v1272 = *(uint64_t ****)(v1258[32] + 8 * v1271);
                                if (v1272)
                                {
                                  v1273 = *v1272;
                                  if (v1273) {
                                    break;
                                  }
                                }
                              }
LABEL_2186:
                              if (++v1264 == *(unsigned __int8 *)(v1244 + 206)) {
                                goto LABEL_2179;
                              }
                            }
                            if (v1267.u32[0] < 2uLL)
                            {
                              while (1)
                              {
                                v1274 = v1273[1];
                                if (v1274 == (uint64_t *)v1270)
                                {
                                  if (v1273[2] == (uint64_t *)v1270) {
                                    goto LABEL_2185;
                                  }
                                }
                                else if (((unint64_t)v1274 & v1268) != v1271)
                                {
                                  goto LABEL_2186;
                                }
                                v1273 = (uint64_t **)*v1273;
                                if (!v1273) {
                                  goto LABEL_2186;
                                }
                              }
                            }
                            while (2)
                            {
                              unint64_t v1275 = (unint64_t)v1273[1];
                              if (v1275 != v1270)
                              {
                                if (v1275 >= *(void *)&v1266) {
                                  v1275 %= *(void *)&v1266;
                                }
                                if (v1275 != v1271) {
                                  goto LABEL_2186;
                                }
                                goto LABEL_2202;
                              }
                              if (v1273[2] != (uint64_t *)v1270)
                              {
LABEL_2202:
                                v1273 = (uint64_t **)*v1273;
                                if (!v1273) {
                                  goto LABEL_2186;
                                }
                                continue;
                              }
                              break;
                            }
LABEL_2185:
                            uint64_t v1269 = v1258[29];
                            if (!v1269) {
                              goto LABEL_2186;
                            }
                            unsigned int v1276 = *((unsigned __int16 *)v1273 + 12);
                            uint64_t v1277 = v1269 + 168 * *((unsigned __int16 *)v1273 + 12);
                            v1279 = *(void **)(v1277 + 88);
                            v1278 = (void **)(v1277 + 88);
                            if (v1278[1] != v1279)
                            {
                              {
                                operator new();
                              }
                              v1280 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 104, 8);
                              void *v1280 = 1;
                              md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::LabelFeatureThunk((uint64_t)(v1280 + 1), (uint64_t *)v1244, 0);
                              __p = v1280;
                              v1281 = std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::__emplace_unique_key_args<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator> const&>((float *)&v1473[5].__m_.__opaque[16], (uint64_t)&__p, (void **)&__p);
                              v1493[25] = v1282;
                              if (v1282)
                              {
                                v1283 = (char *)operator new(0x328uLL);
                                *((void *)v1283 + 1) = 0;
                                *((void *)v1283 + 2) = 0;
                                *(void *)v1283 = &unk_1EF582198;
                                v1284 = md::PointLabelFeature::PointLabelFeature((md::PointLabelFeature *)(v1283 + 24), (GeoCodecsPointFeature *)v1244, (const md::LabelFeatureCreationParams *)&v1488);
                                *((void *)v1283 + 3) = &unk_1EF548670;
                                *((void *)v1283 + 89) = 0;
                                *(_OWORD *)(v1283 + 696) = 0u;
                                v1283[720] = 0;
                                v1283[760] = 0;
                                *((_DWORD *)v1283 + 200) = 0;
                                int v1285 = *(unsigned __int8 *)(v1269 + 168 * v1276 + 8);
                                if (*(unsigned char *)(v1269 + 168 * v1276 + 8))
                                {
                                  uint64_t v1286 = v1269 + 168 * v1276;
                                  long long v1287 = *(_OWORD *)(v1286 + 32);
                                  *(_OWORD *)(v1283 + 728) = *(_OWORD *)(v1286 + 16);
                                  *(_OWORD *)(v1283 + 744) = v1287;
                                  v1283[720] = 1;
                                }
                                if (*(unsigned char *)(v1269 + 168 * v1276 + 48))
                                {
                                  uint64_t v1288 = v1269 + 168 * v1276;
                                  long long v1289 = *(_OWORD *)(v1288 + 72);
                                  *((_OWORD *)v1283 + 48) = *(_OWORD *)(v1288 + 56);
                                  *((_OWORD *)v1283 + 49) = v1289;
                                  v1283[760] = 1;
                                }
                                if (!v1285) {
                                  goto LABEL_2246;
                                }
                                int8x8_t v1290 = (int8x8_t)a8[25];
                                if (!*(void *)&v1290) {
                                  goto LABEL_2246;
                                }
                                unint64_t v1291 = *((void *)v1283 + 91);
                                uint8x8_t v1292 = (uint8x8_t)vcnt_s8(v1290);
                                v1292.i16[0] = vaddlv_u8(v1292);
                                if (v1292.u32[0] > 1uLL)
                                {
                                  unint64_t v1293 = *((void *)v1283 + 91);
                                  if (*(void *)&v1290 <= v1291) {
                                    unint64_t v1293 = v1291 % *(void *)&v1290;
                                  }
                                }
                                else
                                {
                                  unint64_t v1293 = (*(void *)&v1290 - 1) & v1291;
                                }
                                v1298 = *(uint64_t ****)(a8[24] + 8 * v1293);
                                if (!v1298 || (v1299 = *v1298) == 0)
                                {
LABEL_2246:
                                  v1303 = 0;
                                  goto LABEL_2247;
                                }
                                if (v1292.u32[0] < 2uLL)
                                {
                                  uint64_t v1300 = *(void *)&v1290 - 1;
                                  while (1)
                                  {
                                    v1302 = v1299[1];
                                    if (v1302 == (uint64_t *)v1291)
                                    {
                                      if (v1299[2] == (uint64_t *)v1291) {
                                        goto LABEL_2345;
                                      }
                                    }
                                    else if (((unint64_t)v1302 & v1300) != v1293)
                                    {
                                      goto LABEL_2246;
                                    }
                                    v1299 = (uint64_t **)*v1299;
                                    if (!v1299) {
                                      goto LABEL_2246;
                                    }
                                  }
                                }
                                while (2)
                                {
                                  unint64_t v1301 = (unint64_t)v1299[1];
                                  if (v1301 != v1291)
                                  {
                                    if (v1301 >= *(void *)&v1290) {
                                      v1301 %= *(void *)&v1290;
                                    }
                                    if (v1301 != v1293) {
                                      goto LABEL_2246;
                                    }
                                    goto LABEL_2236;
                                  }
                                  if (v1299[2] != (uint64_t *)v1291)
                                  {
LABEL_2236:
                                    v1299 = (uint64_t **)*v1299;
                                    if (!v1299) {
                                      goto LABEL_2246;
                                    }
                                    continue;
                                  }
                                  break;
                                }
LABEL_2345:
                                v1303 = (float64x2_t *)(a8[21] + 1864 * *((unsigned __int16 *)v1299 + 12));
LABEL_2247:
                                v1449 = v1283 + 696;
                                v1455 = v1283;
                                v1304 = (char *)v1278[1];
                                v1305 = (char *)*v1278;
                                v1434 = v1284;
                                if (v1304 != *v1278)
                                {
                                  uint64_t v1306 = v1304 - (unsigned char *)*v1278;
                                  unint64_t v1307 = 0xAAAAAAAAAAAAAAABLL * (v1306 >> 4);
                                  if (v1307 >> 60) {
                                    abort();
                                  }
                                  v1308 = (char *)operator new(0xAAAAAAAAAAAAAAB0 * (v1306 >> 4));
                                  *((void *)v1283 + 87) = v1308;
                                  *((void *)v1283 + 88) = v1308;
                                  *((void *)v1283 + 89) = &v1308[16 * v1307];
                                  v1305 = (char *)*v1278;
                                  v1304 = (char *)v1278[1];
                                }
                                if (v1305 != v1304)
                                {
                                  float v1309 = 3.4028e38;
                                  v1471 = v1303;
                                  __srcg = v1304;
                                  while (1)
                                  {
                                    float v1487 = v1309;
                                    float v1310 = *((float *)v1305 + 6);
                                    float v1311 = *((float *)v1305 + 7);
                                    float v1313 = *((float *)v1305 + 8);
                                    float v1312 = *((float *)v1305 + 9);
                                    double v1314 = *(double *)v1305;
                                    double v1315 = *((double *)v1305 + 1);
                                    double v1316 = *((double *)v1305 + 2);
                                    float32x2_t v1317 = *(float32x2_t *)(v1305 + 40);
                                    v1318 = (char *)operator new(0xB0uLL);
                                    v1319 = (float *)v1318;
                                    v1320.f32[0] = (float)((float)(v1310 * -0.5) + (float)(v1312 * 0.5))
                                                 + (float)((float)(v1311 * 0.5) + (float)(v1313 * 0.5));
                                    v1320.f32[1] = (float)((float)(v1312 * 0.5) + (float)(v1311 * 0.5))
                                                 - (float)((float)(v1310 * -0.5) + (float)(v1313 * 0.5));
                                    v1321.f32[0] = (float)((float)((float)(v1310 * 0.5) + (float)(v1312 * -0.5))
                                                         + (float)(v1311 * 0.5))
                                                 - (float)(v1313 * -0.5);
                                    v1321.f32[1] = (float)((float)(v1312 * -0.5) - (float)(v1310 * 0.5))
                                                 + (float)((float)(v1311 * 0.5) + (float)(v1313 * -0.5));
                                    float64x2_t v1322 = vcvtq_f64_f32(v1320);
                                    float64x2_t v1323 = vmulq_f64(vcvtq_f64_f32(v1317), v1463);
                                    _Q2 = vcvtq_f64_f32(v1321);
                                    *((void *)v1318 + 1) = 0;
                                    v1325 = (atomic_ullong *)(v1318 + 8);
                                    *((void *)v1318 + 2) = 0;
                                    *((double *)v1318 + 3) = v1314;
                                    v1326 = v1318 + 24;
                                    *(void *)v1318 = &unk_1EF57FF78;
                                    *((double *)v1318 + 4) = v1315;
                                    *((double *)v1318 + 5) = v1316;
                                    double v1327 = vmuld_lane_f64(_Q2.f64[1] + _Q2.f64[1], _Q2, 1);
                                    float64_t v1328 = (v1322.f64[0] + v1322.f64[0]) * v1322.f64[0];
                                    double v1329 = 1.0 - (v1327 + v1328);
                                    _D16 = _Q2.f64[0] + _Q2.f64[0];
                                    double v1331 = vmuld_lane_f64(_Q2.f64[0] + _Q2.f64[0], _Q2, 1);
                                    double v1332 = vmuld_lane_f64(v1322.f64[0] + v1322.f64[0], v1322, 1);
                                    double v1333 = v1331 - v1332;
                                    float64_t v1334 = (_Q2.f64[0] + _Q2.f64[0]) * v1322.f64[0];
                                    double v1335 = vmuld_lane_f64(_Q2.f64[1] + _Q2.f64[1], v1322, 1);
                                    double v1336 = v1332 + v1331;
                                    __asm { FMLS            D17, D16, V2.D[0] }
                                    _Q2.f64[0] = _D17 - v1328;
                                    float64_t v1338 = (_Q2.f64[1] + _Q2.f64[1]) * v1322.f64[0];
                                    v1322.f64[0] = vmuld_lane_f64(_D16, v1322, 1);
                                    float64_t v1339 = v1338 - v1322.f64[0];
                                    v1322.f64[0] = v1322.f64[0] + v1338;
                                    double v1340 = _D17 - v1327;
                                    *(float *)&double v1327 = v1329;
                                    *(float *)&double v1336 = v1336;
                                    *(float *)&double v1329 = v1334 - v1335;
                                    *(float *)&_D16 = v1333;
                                    *(float *)_Q2.f64 = _Q2.f64[0];
                                    *(float *)v1322.f64 = v1322.f64[0];
                                    *(float *)&_D17 = v1335 + v1334;
                                    *(float *)&float64_t v1339 = v1339;
                                    *(float *)&double v1340 = v1340;
                                    *((_DWORD *)v1318 + 18) = LODWORD(v1327);
                                    *((_DWORD *)v1318 + 19) = LODWORD(v1336);
                                    *((_DWORD *)v1318 + 20) = LODWORD(v1329);
                                    *((_DWORD *)v1318 + 21) = LODWORD(_D16);
                                    *((_DWORD *)v1318 + 22) = LODWORD(_Q2.f64[0]);
                                    *((_DWORD *)v1318 + 23) = LODWORD(v1322.f64[0]);
                                    *((_DWORD *)v1318 + 24) = LODWORD(_D17);
                                    *((_DWORD *)v1318 + 25) = LODWORD(v1339);
                                    *((_DWORD *)v1318 + 26) = LODWORD(v1340);
                                    v1322.f64[0] = 1.0 / sqrt(v1314 * v1314 + v1315 * v1315 + v1316 * v1316);
                                    float64x2_t v1341 = vaddq_f64(v1323, v1323);
                                    double v1342 = vmuld_lane_f64(-0.5, v1341, 1);
                                    double v1343 = v1314 + v1342 * (v1322.f64[0] * v1314);
                                    _Q2.f64[0] = v1315 + v1342 * (v1322.f64[0] * v1315);
                                    *((double *)v1318 + 6) = v1343;
                                    *((void *)v1318 + 7) = *(void *)&_Q2.f64[0];
                                    v1322.f64[0] = v1316 + v1342 * (v1322.f64[0] * v1316);
                                    *((void *)v1318 + 8) = *(void *)&v1322.f64[0];
                                    *((double *)v1318 + 15) = v1343;
                                    *((void *)v1318 + 16) = *(void *)&_Q2.f64[0];
                                    *((void *)v1318 + 17) = *(void *)&v1322.f64[0];
                                    *((void *)v1318 + 18) = 0;
                                    *((void *)v1318 + 19) = 0;
                                    *((_DWORD *)v1318 + 40) = 1065353216;
                                    *((_WORD *)v1318 + 82) = 1;
                                    v1318[166] = 1;
                                    *(float32x2_t *)(v1318 + 108) = vcvt_f32_f64(v1341);
                                    *((_DWORD *)v1318 + 42) = 0;
                                    if (v1303)
                                    {
                                      float64x2_t v1344 = vsubq_f64(v1303[1], *(float64x2_t *)(v1318 + 56));
                                      float64x2_t v1345 = vmulq_f64(v1344, v1344);
                                      float v1346 = sqrt(v1345.f64[0]+ (v1303->f64[1] - v1343) * (v1303->f64[1] - v1343)+ v1345.f64[1]);
                                      *((float *)v1318 + 42) = v1346;
                                    }
                                    v1347 = (void *)*((void *)v1283 + 88);
                                    unint64_t v1348 = *((void *)v1283 + 89);
                                    float v1309 = v1487;
                                    if ((unint64_t)v1347 < v1348)
                                    {
                                      void *v1347 = v1326;
                                      v1347[1] = v1318;
                                      atomic_fetch_add_explicit((atomic_ullong *volatile)v1318 + 1, 1uLL, memory_order_relaxed);
                                      v1349 = v1347 + 2;
                                      goto LABEL_2274;
                                    }
                                    v1350 = (void *)*v1449;
                                    uint64_t v1351 = ((uint64_t)v1347 - *v1449) >> 4;
                                    unint64_t v1352 = v1351 + 1;
                                    if ((unint64_t)(v1351 + 1) >> 60) {
                                      abort();
                                    }
                                    uint64_t v1353 = v1348 - (void)v1350;
                                    if (v1353 >> 3 > v1352) {
                                      unint64_t v1352 = v1353 >> 3;
                                    }
                                    if ((unint64_t)v1353 >= 0x7FFFFFFFFFFFFFF0) {
                                      unint64_t v1354 = 0xFFFFFFFFFFFFFFFLL;
                                    }
                                    else {
                                      unint64_t v1354 = v1352;
                                    }
                                    if (v1354 >> 60) {
                                      goto LABEL_2370;
                                    }
                                    v1355 = (char *)operator new(16 * v1354);
                                    *(void *)&long long v1356 = v1326;
                                    *((void *)&v1356 + 1) = v1319;
                                    v1357 = &v1355[16 * v1351];
                                    v1358 = &v1355[16 * v1354];
                                    *(_OWORD *)v1357 = v1356;
                                    v1349 = v1357 + 16;
                                    atomic_fetch_add_explicit(v1325, 1uLL, memory_order_relaxed);
                                    if (v1347 != v1350) {
                                      break;
                                    }
                                    v1283 = v1455;
                                    *((void *)v1455 + 87) = v1357;
                                    *((void *)v1455 + 88) = v1349;
                                    *((void *)v1455 + 89) = v1358;
                                    if (v1347) {
                                      goto LABEL_2273;
                                    }
LABEL_2274:
                                    *((void *)v1283 + 88) = v1349;
                                    v1303 = v1471;
                                    if (v1471 && v1319[42] < v1487) {
                                      float v1309 = v1319[42];
                                    }
                                    if (!atomic_fetch_add(v1325, 0xFFFFFFFFFFFFFFFFLL))
                                    {
                                      (*(void (**)(float *))(*(void *)v1319 + 16))(v1319);
                                      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v1319);
                                    }
                                    v1305 += 48;
                                    if (v1305 == __srcg)
                                    {
                                      if (v1309 != 3.4028e38) {
                                        *((float *)v1283 + 200) = v1309;
                                      }
                                      goto LABEL_2283;
                                    }
                                  }
                                  do
                                  {
                                    long long v1359 = *((_OWORD *)v1347 - 1);
                                    v1347 -= 2;
                                    *((_OWORD *)v1357 - 1) = v1359;
                                    v1357 -= 16;
                                    void *v1347 = 0;
                                    v1347[1] = 0;
                                  }
                                  while (v1347 != v1350);
                                  v1347 = (void *)*((void *)v1455 + 87);
                                  v1360 = (void *)*((void *)v1455 + 88);
                                  *((void *)v1455 + 87) = v1357;
                                  *((void *)v1455 + 88) = v1349;
                                  *((void *)v1455 + 89) = v1358;
                                  while (v1360 != v1347)
                                  {
                                    v1361 = (std::__shared_weak_count *)*(v1360 - 1);
                                    if (v1361 && !atomic_fetch_add(&v1361->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                    {
                                      ((void (*)(std::__shared_weak_count *))v1361->__on_zero_shared)(v1361);
                                      std::__shared_weak_count::__release_weak(v1361);
                                    }
                                    v1360 -= 2;
                                  }
                                  v1283 = v1455;
                                  if (!v1347) {
                                    goto LABEL_2274;
                                  }
LABEL_2273:
                                  operator delete(v1347);
                                  goto LABEL_2274;
                                }
LABEL_2283:
                                if (__p) {
                                  v1362 = (char *)__p + 8;
                                }
                                else {
                                  v1362 = 0;
                                }
                                v1363 = (std::__shared_weak_count *)*((void *)v1362 + 2);
                                *((void *)v1362 + 1) = v1434;
                                *((void *)v1362 + 2) = v1283;
                                if (v1363 && !atomic_fetch_add(&v1363->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                {
                                  ((void (*)(std::__shared_weak_count *))v1363->__on_zero_shared)(v1363);
                                  std::__shared_weak_count::__release_weak(v1363);
                                }
                                uint64_t v1364 = *(void *)&v1473[10].__m_.__opaque[24];
                                v1297 = (char *)__p;
                                v1365 = (char *)__p + 8;
                                if (!__p) {
                                  v1365 = 0;
                                }
                                uint64_t v1366 = *((void *)v1365 + 1);
                                *(void *)(v1366 + 152) = v1365;
                                *(unsigned char *)(v1366 + 147) = 0;
                                uint64_t v1367 = v1364 + 1;
                                *(void *)&v1473[10].__m_.__opaque[24] = v1367;
                                *(void *)(v1366 + 72) = v1367;
                              }
                              else
                              {
                                v1294 = v1281;
                                v1295 = (void *)v1281[2];
                                if (v1295) {
                                  ++*v1295;
                                }
                                _ZF = (*v1280)-- == 1;
                                if (_ZF)
                                {
                                  md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk((uint64_t)(v1280 + 1));
                                  {
                                    operator new();
                                  }
                                  (*(void (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                   + 40))(mdm::Allocator::instance(void)::alloc, __p, 104);
                                  v1295 = (void *)v1294[2];
                                }
                                __p = v1295;
                                if (v1295) {
                                  v1296 = v1295 + 1;
                                }
                                else {
                                  v1296 = 0;
                                }
                                md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::add(v1296, (void *)v1244);
                                v1297 = (char *)__p;
                              }
                              if (v1297) {
                                v1368 = (md::PointLabelFeature **)(v1297 + 8);
                              }
                              else {
                                v1368 = 0;
                              }
                              md::PointLabelFeature::addPointFeature(v1368[1], (GeoCodecsPointFeature *)v1244, (const md::LabelFeatureCreationParams *)&v1488);
                              std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeaturePoolTileInfo::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeaturePoolTileInfo::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::__emplace_unique_key_args<geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,geo::fast_shared_ptr<md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator> const&>(*(void *)v1445 + 280, (uint64_t)__p, (void **)&__p);
                              v1369 = __p;
                              v1370 = (char *)__p + 8;
                              if (__p) {
                                v1371 = (char *)__p + 8;
                              }
                              else {
                                v1371 = 0;
                              }
                              uint64_t v1373 = *((void *)v1371 + 1);
                              uint64_t v1372 = *((void *)v1371 + 2);
                              *(void *)v1609 = v1373;
                              *(void *)&v1609[8] = v1372;
                              if (v1372) {
                                atomic_fetch_add_explicit((atomic_ullong *volatile)(v1372 + 8), 1uLL, memory_order_relaxed);
                              }
                              v1258 = a8;
                              unint64_t v1243 = v1423;
                              uint64_t v1245 = v1420;
                              uint64_t v1246 = v1437;
                              if (v1369 && (_ZF = *v1369 == 1, --*v1369, _ZF))
                              {
                                md::LabelFeatureThunk<md::PointLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk((uint64_t)v1370);
                                {
                                  operator new();
                                }
                                (*(void (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                 + 40))(mdm::Allocator::instance(void)::alloc, __p, 104);
                                uint64_t v1373 = *(void *)v1609;
                                v1258 = a8;
                                if (*(void *)v1609) {
                                  goto LABEL_2303;
                                }
                              }
                              else if (v1373)
                              {
LABEL_2303:
                                v1374 = *(std::__shared_weak_count **)&v1609[8];
                                if (*(void *)&v1609[8]) {
                                  atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v1609[8] + 16), 1uLL, memory_order_relaxed);
                                }
                                v1375 = (uint64_t **)(a1 + 208);
LABEL_2306:
                                v1376 = *v1375;
                                v1377 = v1375;
                                if (*v1375)
                                {
                                  while (1)
                                  {
                                    v1375 = (uint64_t **)v1376;
                                    unint64_t v1378 = v1376[5];
                                    if ((unint64_t)v1374 < v1378) {
                                      goto LABEL_2306;
                                    }
                                    if (v1378 >= (unint64_t)v1374) {
                                      break;
                                    }
                                    v1376 = v1375[1];
                                    if (!v1376)
                                    {
                                      v1377 = v1375 + 1;
                                      goto LABEL_2311;
                                    }
                                  }
                                  if (v1374)
                                  {
                                    std::__shared_weak_count::__release_weak(v1374);
                                    goto LABEL_2314;
                                  }
                                }
                                else
                                {
LABEL_2311:
                                  v1379 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t, void *))(**((void **)a1 + 27) + 16))(*((void *)a1 + 27), 48, 8, v1258);
                                  v1379[4] = v1373;
                                  v1379[5] = (uint64_t)v1374;
                                  uint64_t *v1379 = 0;
                                  v1379[1] = 0;
                                  v1379[2] = (uint64_t)v1375;
                                  *v1377 = v1379;
                                  v1380 = (uint64_t *)**v1438;
                                  if (v1380)
                                  {
                                    *v1438 = v1380;
                                    v1379 = *v1377;
                                  }
                                  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)a1 + 26), v1379);
                                  ++*((void *)a1 + 28);
LABEL_2314:
                                  v1258 = a8;
                                }
                                uint64_t v1246 = v1437;
                                if (v1493[25])
                                {
                                  uint64_t v1381 = *(void *)v1609;
                                  v1382 = v1592[1];
                                  if (v1592[1] >= v1593[0])
                                  {
                                    unint64_t v1384 = 0xAAAAAAAAAAAAAAABLL * (((char *)v1592[1] - (char *)v1592[0]) >> 3);
                                    unint64_t v1385 = v1384 + 1;
                                    if (v1384 + 1 > 0xAAAAAAAAAAAAAAALL) {
                                      abort();
                                    }
                                    if (0x5555555555555556 * (((char *)v1593[0] - (char *)v1592[0]) >> 3) > v1385) {
                                      unint64_t v1385 = 0x5555555555555556 * (((char *)v1593[0] - (char *)v1592[0]) >> 3);
                                    }
                                    if (0xAAAAAAAAAAAAAAABLL * (((char *)v1593[0] - (char *)v1592[0]) >> 3) >= 0x555555555555555) {
                                      uint64_t v1386 = 0xAAAAAAAAAAAAAAALL;
                                    }
                                    else {
                                      uint64_t v1386 = v1385;
                                    }
                                    if (v1386)
                                    {
                                      uint64_t v1387 = (*(uint64_t (**)(void *, uint64_t, uint64_t, void *))(*(void *)v1593[1] + 16))(v1593[1], 24 * v1386, 8, v1258);
                                      v1388 = (char *)(v1387 + 24 * v1384);
                                      v1389 = (void *)(v1387 + 24 * v1386);
                                      if (v1387)
                                      {
                                        *(void *)v1388 = v1381;
                                        unint64_t v1390 = v1387 + 24 * v1384;
                                        *(void *)(v1390 + 8) = 0;
                                        *(void *)(v1390 + 16) = 0;
                                      }
                                      v1258 = a8;
                                    }
                                    else
                                    {
                                      v1389 = 0;
                                      v1388 = (char *)(8 * (((char *)v1592[1] - (char *)v1592[0]) >> 3));
                                    }
                                    v1391 = (char *)v1592[1];
                                    v1392 = (char *)v1592[0];
                                    v1393 = v1388;
                                    if (v1592[1] != v1592[0])
                                    {
                                      do
                                      {
                                        long long v1394 = *(_OWORD *)(v1391 - 24);
                                        *((void *)v1393 - 1) = *((void *)v1391 - 1);
                                        *(_OWORD *)(v1393 - 24) = v1394;
                                        v1393 -= 24;
                                        v1391 -= 24;
                                      }
                                      while (v1391 != v1392);
                                      v1391 = (char *)v1592[0];
                                    }
                                    v1383 = v1388 + 24;
                                    v1592[0] = v1393;
                                    v1592[1] = v1388 + 24;
                                    v1395 = v1593[0];
                                    v1593[0] = v1389;
                                    if (v1391)
                                    {
                                      (*(void (**)(void *, char *, int64_t, void *))(*(void *)v1593[1] + 40))(v1593[1], v1391, v1395 - v1391, v1258);
                                      v1258 = a8;
                                    }
                                  }
                                  else
                                  {
                                    if (v1592[1])
                                    {
                                      *((void *)v1592[1] + 1) = 0;
                                      v1382[2] = 0;
                                      void *v1382 = v1381;
                                    }
                                    v1383 = v1382 + 3;
                                  }
                                  v1592[1] = v1383;
                                }
                              }
                              v1396 = *(std::__shared_weak_count **)&v1609[8];
                              if (*(void *)&v1609[8]
                                && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v1609[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
                              {
                                ((void (*)(std::__shared_weak_count *))v1396->__on_zero_shared)(v1396);
                                std::__shared_weak_count::__release_weak(v1396);
                                v1258 = a8;
                              }
                              v1260 = v1592[1];
                              v1261 = v1592[0];
                            }
                          }
LABEL_2179:
                          ++v1253;
                          v1244 += 224;
                          if (0xAAAAAAAAAAAAAAABLL * ((v1260 - v1261) >> 3) > 0x1F || v1253 >= v1243) {
                            goto LABEL_2176;
                          }
                          continue;
                        }
                      }
                    }
                  }
                  else
                  {
                    if (v961 >= v957) {
                      v961 %= v957;
                    }
                    if (v961 != v951) {
                      break;
                    }
                  }
LABEL_1639:
                  v960 = (void *)*v960;
                }
                while (v960);
              }
            }
          }
LABEL_1679:
          v986 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)&v1473[6].__m_.__opaque[40]
                                                                               + 16))(*(void *)&v1473[6].__m_.__opaque[40], 24, 8);
          *(void *)v1609 = v986;
          *(void *)&v1609[8] = (char *)v1473 + 432;
          void *v986 = 0;
          v986[1] = v956;
          v986[2] = v928;
          if (v928) {
            ++*(void *)v928;
          }
          v1609[16] = 1;
          float v987 = (float)(unint64_t)(*(void *)&v1473[6].__m_.__opaque[48] + 1);
          float v988 = *(float *)&v1473[7].__m_.__sig;
          if (!v957 || (float)(v988 * (float)v957) < v987)
          {
            BOOL v989 = (v957 & (v957 - 1)) != 0;
            if (v957 < 3) {
              BOOL v989 = 1;
            }
            unint64_t v990 = v989 | (2 * v957);
            unint64_t v991 = vcvtps_u32_f32(v987 / v988);
            if (v990 <= v991) {
              size_t v992 = v991;
            }
            else {
              size_t v992 = v990;
            }
            if (v992 == 1)
            {
              size_t v992 = 2;
            }
            else if ((v992 & (v992 - 1)) != 0)
            {
              size_t v992 = std::__next_prime(v992);
            }
            unint64_t v957 = *(void *)&v1473[6].__m_.__opaque[16];
            if (v992 > v957)
            {
LABEL_1693:
              uint64_t v993 = (*(uint64_t (**)(void, size_t, uint64_t))(**(void **)&v1473[6].__m_.__opaque[24] + 16))(*(void *)&v1473[6].__m_.__opaque[24], 8 * v992, 8);
              uint64_t v994 = *(void *)&v1473[6].__m_.__opaque[8];
              *(void *)&v1473[6].__m_.__opaque[8] = v993;
              if (v994) {
                (*(void (**)(void, uint64_t, uint64_t))(**(void **)&v1473[6].__m_.__opaque[24] + 40))(*(void *)&v1473[6].__m_.__opaque[24], v994, 8 * *(void *)&v1473[6].__m_.__opaque[16]);
              }
              uint64_t v995 = 0;
              *(void *)&v1473[6].__m_.__opaque[16] = v992;
              do
                *(void *)(*(void *)&v1473[6].__m_.__opaque[8] + 8 * v995++) = 0;
              while (v992 != v995);
              v996 = *(void **)v1422;
              if (!*(void *)v1422) {
                goto LABEL_1716;
              }
              size_t v997 = v996[1];
              size_t v998 = v992 - 1;
              if ((v992 & (v992 - 1)) == 0)
              {
                size_t v999 = v997 & v998;
                *(void *)(*(void *)&v1473[6].__m_.__opaque[8] + 8 * v999) = v1422;
                for (jj = (void *)*v996; *v996; jj = (void *)*v996)
                {
                  size_t v1001 = jj[1] & v998;
                  if (v1001 == v999)
                  {
                    v996 = jj;
                  }
                  else
                  {
                    uint64_t v1002 = *(void *)&v1473[6].__m_.__opaque[8];
                    if (*(void *)(v1002 + 8 * v1001))
                    {
                      void *v996 = *jj;
                      uint64_t v1003 = 8 * v1001;
                      void *jj = **(void **)(*(void *)&v1473[6].__m_.__opaque[8] + v1003);
                      **(void **)(*(void *)&v1473[6].__m_.__opaque[8] + v1003) = jj;
                    }
                    else
                    {
                      *(void *)(v1002 + 8 * v1001) = v996;
                      v996 = jj;
                      size_t v999 = v1001;
                    }
                  }
                }
                goto LABEL_1716;
              }
              if (v997 >= v992) {
                v997 %= v992;
              }
              *(void *)(*(void *)&v1473[6].__m_.__opaque[8] + 8 * v997) = v1422;
              v1007 = (void *)*v996;
              if (!*v996)
              {
LABEL_1716:
                unint64_t v957 = v992;
                goto LABEL_1717;
              }
              while (2)
              {
                size_t v1009 = v1007[1];
                if (v1009 >= v992) {
                  v1009 %= v992;
                }
                if (v1009 != v997)
                {
                  uint64_t v1010 = *(void *)&v1473[6].__m_.__opaque[8];
                  if (!*(void *)(v1010 + 8 * v1009))
                  {
                    *(void *)(v1010 + 8 * v1009) = v996;
LABEL_1721:
                    v996 = v1007;
                    v1007 = (void *)*v1007;
                    size_t v997 = v1009;
                    if (!v1007) {
                      goto LABEL_1716;
                    }
                    continue;
                  }
                  void *v996 = *v1007;
                  uint64_t v1008 = 8 * v1009;
                  void *v1007 = **(void **)(*(void *)&v1473[6].__m_.__opaque[8] + v1008);
                  **(void **)(*(void *)&v1473[6].__m_.__opaque[8] + v1008) = v1007;
                  v1007 = v996;
                }
                break;
              }
              size_t v1009 = v997;
              goto LABEL_1721;
            }
            if (v992 < v957)
            {
              unint64_t v1004 = vcvtps_u32_f32((float)*(unint64_t *)&v1473[6].__m_.__opaque[48] / *(float *)&v1473[7].__m_.__sig);
              if (v957 < 3
                || (uint8x8_t v1005 = (uint8x8_t)vcnt_s8((int8x8_t)v957), v1005.i16[0] = vaddlv_u8(v1005), v1005.u32[0] > 1uLL))
              {
                unint64_t v1004 = std::__next_prime(v1004);
              }
              else
              {
                uint64_t v1006 = 1 << -(char)__clz(v1004 - 1);
                if (v1004 >= 2) {
                  unint64_t v1004 = v1006;
                }
              }
              if (v992 <= v1004) {
                size_t v992 = v1004;
              }
              if (v992 >= v957)
              {
                unint64_t v957 = *(void *)&v1473[6].__m_.__opaque[16];
              }
              else
              {
                if (v992) {
                  goto LABEL_1693;
                }
                uint64_t v1068 = *(void *)&v1473[6].__m_.__opaque[8];
                *(void *)&v1473[6].__m_.__opaque[8] = 0;
                if (v1068) {
                  (*(void (**)(void, uint64_t, uint64_t))(**(void **)&v1473[6].__m_.__opaque[24] + 40))(*(void *)&v1473[6].__m_.__opaque[24], v1068, 8 * *(void *)&v1473[6].__m_.__opaque[16]);
                }
                unint64_t v957 = 0;
                *(void *)&v1473[6].__m_.__opaque[16] = 0;
              }
            }
LABEL_1717:
            if ((v957 & (v957 - 1)) != 0)
            {
              if (v956 >= v957) {
                unint64_t v951 = v956 % v957;
              }
              else {
                unint64_t v951 = v956;
              }
            }
            else
            {
              unint64_t v951 = (v957 - 1) & v956;
            }
          }
          v1011 = *(void **)(*(void *)&v1473[6].__m_.__opaque[8] + 8 * v951);
          if (v1011)
          {
            void *v986 = *v1011;
            v1012 = v1486;
            goto LABEL_1738;
          }
          void *v986 = *(void *)&v1473[6].__m_.__opaque[32];
          *(void *)&v1473[6].__m_.__opaque[32] = v986;
          *(void *)(*(void *)&v1473[6].__m_.__opaque[8] + 8 * v951) = v1422;
          v1012 = v1486;
          if (*v986)
          {
            unint64_t v1013 = *(void *)(*v986 + 8);
            if ((v957 & (v957 - 1)) != 0)
            {
              if (v1013 >= v957) {
                v1013 %= v957;
              }
            }
            else
            {
              v1013 &= v957 - 1;
            }
            v1011 = (void *)(*(void *)&v1473[6].__m_.__opaque[8] + 8 * v1013);
LABEL_1738:
            void *v1011 = v986;
          }
          ++*(void *)&v1473[6].__m_.__opaque[48];
          v1509[25] = 1;
          {
            operator new();
          }
          uint64_t v1014 = mdm::Allocator::instance(void)::alloc;
          uint64_t v983 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                      + 16))(mdm::Allocator::instance(void)::alloc, 744, 8);
          *(void *)uint64_t v983 = &unk_1EF5818D8;
          *(void *)(v983 + 8) = 0;
          *(void *)(v983 + 16) = 0;
          *(void *)(v983 + 24) = v1014;
          v1015 = (uint64_t *)(v983 + 32);
          md::LineLabelFeature::LineLabelFeature(v983 + 32, 9, 4);
          *(void *)(v983 + 32) = &unk_1EF544230;
          *(void *)(v983 + 472) = 850045863;
          *(_OWORD *)(v983 + 480) = 0u;
          *(_OWORD *)(v983 + 496) = 0u;
          *(_OWORD *)(v983 + 512) = 0u;
          *(_OWORD *)(v983 + 528) = 0u;
          *(_OWORD *)(v983 + 544) = 0u;
          {
            operator new();
          }
          *(void *)(v983 + 560) = mdm::Allocator::instance(void)::alloc;
          *(void *)(v983 + 568) = 0;
          *(void *)(v983 + 584) = 0;
          *(void *)(v983 + 576) = 0;
          {
            operator new();
          }
          *(void *)(v983 + 592) = mdm::Allocator::instance(void)::alloc;
          *(void *)(v983 + 608) = 0;
          {
            operator new();
          }
          *(void *)(v983 + 616) = mdm::Allocator::instance(void)::alloc;
          *(void *)(v983 + 624) = 0;
          *(void *)(v983 + 600) = v983 + 608;
          *(_WORD *)(v983 + 632) = 0;
          *(void *)(v983 + 640) = 850045863;
          *(void *)(v983 + 712) = 0;
          *(void *)(v983 + 728) = 0;
          *(void *)(v983 + 720) = 0;
          *(_OWORD *)(v983 + 648) = 0u;
          *(_OWORD *)(v983 + 664) = 0u;
          *(_OWORD *)(v983 + 680) = 0u;
          *(_OWORD *)(v983 + 689) = 0u;
          {
            operator new();
          }
          __srcf = (uint64_t *)(v983 + 568);
          *(void *)(v983 + 736) = mdm::Allocator::instance(void)::alloc;
          md::LabelLineStore::addTransitLineSegment(*(void *)(v983 + 224), v1012, (uint64_t)&v1504);
          md::TransitLineLabelFeature::addTransitLink(v1015, (unint64_t)v1012);
          uint64_t v1016 = *v1444;
          if (*v1444)
          {
            uint64_t v1017 = 0;
            do
            {
              uint64_t v1019 = geo::codec::vectorTransitLineAlongLink(v1012, v1017);
              uint64_t v1020 = *(void *)(v1019 + 40);
              int v1021 = *(_DWORD *)(v1019 + 100);
              v1022 = (std::__shared_weak_count *)v1486[1];
              if (v1022)
              {
                v1022 = std::__shared_weak_count::lock(v1022);
                v1023 = v1022;
                if (v1022) {
                  v1022 = (std::__shared_weak_count *)*v1486;
                }
              }
              else
              {
                v1023 = 0;
              }
              int v1024 = *(_DWORD *)(geo::codec::VectorTile::transitSystemInfoForFeatureID((geo::codec::VectorTile *)v1022, v1020)+ 64);
              if (v1023 && !atomic_fetch_add(&v1023->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v1023->__on_zero_shared)(v1023);
                std::__shared_weak_count::__release_weak(v1023);
              }
              int v1025 = md::LineLabelFeature::styleIndexForAttributes((uint64_t)v1015, (uint64_t *)(v1019 + 24));
              int v1026 = v1025;
              unint64_t v1027 = *(void *)(v983 + 576);
              unint64_t v1028 = *(void *)(v983 + 584);
              if (v1027 >= v1028)
              {
                uint64_t v1029 = (uint64_t)(v1027 - *__srcf) >> 5;
                unint64_t v1030 = v1029 + 1;
                if ((unint64_t)(v1029 + 1) >> 59) {
                  abort();
                }
                uint64_t v1031 = v1028 - *__srcf;
                if (v1031 >> 4 > v1030) {
                  unint64_t v1030 = v1031 >> 4;
                }
                if ((unint64_t)v1031 >= 0x7FFFFFFFFFFFFFE0) {
                  uint64_t v1032 = 0x7FFFFFFFFFFFFFFLL;
                }
                else {
                  uint64_t v1032 = v1030;
                }
                if (v1032)
                {
                  uint64_t v1033 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v983 + 592) + 16))(*(void *)(v983 + 592), 32 * v1032, 8);
                  uint64_t v1034 = v1033 + 32 * v1029;
                  uint64_t v1035 = v1033 + 32 * v1032;
                  if (v1033)
                  {
                    *(void *)uint64_t v1034 = v1020;
                    *(_WORD *)(v1034 + 8) = -1;
                    *(_WORD *)(v1034 + 14) = 0;
                    *(_DWORD *)(v1034 + 10) = 0xFFFF;
                    *(_DWORD *)(v1034 + 16) = v1021;
                    *(_DWORD *)(v1034 + 20) = v1024;
                    *(_DWORD *)(v1034 + 24) = v1026;
                  }
                }
                else
                {
                  uint64_t v1035 = 0;
                  uint64_t v1034 = 32 * v1029;
                }
                v1012 = v1486;
                uint64_t v1036 = *(void *)(v983 + 576);
                uint64_t v1037 = *(void *)(v983 + 568);
                uint64_t v1038 = v1034;
                if (v1036 != v1037)
                {
                  do
                  {
                    long long v1039 = *(_OWORD *)(v1036 - 16);
                    *(_OWORD *)(v1038 - 32) = *(_OWORD *)(v1036 - 32);
                    *(_OWORD *)(v1038 - 16) = v1039;
                    v1038 -= 32;
                    v1036 -= 32;
                  }
                  while (v1036 != v1037);
                  uint64_t v1036 = *__srcf;
                }
                uint64_t v1018 = v1034 + 32;
                *(void *)(v983 + 568) = v1038;
                *(void *)(v983 + 576) = v1034 + 32;
                uint64_t v1040 = *(void *)(v983 + 584);
                *(void *)(v983 + 584) = v1035;
                if (v1036) {
                  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v983 + 592) + 40))(*(void *)(v983 + 592), v1036, v1040 - v1036);
                }
              }
              else
              {
                if (v1027)
                {
                  *(void *)unint64_t v1027 = v1020;
                  *(_WORD *)(v1027 + 8) = -1;
                  *(_WORD *)(v1027 + 14) = 0;
                  *(_DWORD *)(v1027 + 10) = 0xFFFF;
                  *(_DWORD *)(v1027 + 16) = v1021;
                  *(_DWORD *)(v1027 + 20) = v1024;
                  *(_DWORD *)(v1027 + 24) = v1025;
                }
                uint64_t v1018 = v1027 + 32;
                v1012 = v1486;
              }
              *(void *)(v983 + 576) = v1018;
              ++v1017;
            }
            while (v1017 != v1016);
          }
          else
          {
            uint64_t v1018 = *(void *)(v983 + 576);
          }
          uint64_t v1041 = v1469 + 184 * v1461;
          uint64_t v1042 = *(void *)(v1041 + 88);
          uint64_t v1043 = *(void *)(v1041 + 96);
          uint64_t v1044 = *__srcf;
          v1045 = (std::__shared_weak_count *)v1012[1];
          if (v1045)
          {
            v1046 = std::__shared_weak_count::lock(v1045);
            if (v1046) {
              uint64_t v1047 = *v1012;
            }
            else {
              uint64_t v1047 = 0;
            }
          }
          else
          {
            uint64_t v1047 = 0;
            v1046 = 0;
          }
          unint64_t v1048 = v1018 - v1044;
          unint64_t v1049 = (v1018 - v1044) >> 5;
          if (v1043)
          {
            uint64_t v1050 = *(void *)(v1047 + 1640);
            if (v1050)
            {
              unint64_t v1051 = (v1043 + v1042);
              BOOL v1052 = v1051 > v1042;
              unint64_t v1053 = v1051 - v1042;
              if (v1052)
              {
                __int16 v1054 = 0;
                v1055 = (unsigned int *)(v1050 + 8 * v1042);
                do
                {
                  unsigned int v1057 = *v1055;
                  v1055 += 2;
                  uint64_t v1056 = v1057;
                  if (v1057 < v1049) {
                    *(_WORD *)(*__srcf + 32 * v1056 + 14) = v1054;
                  }
                  ++v1054;
                  --v1053;
                }
                while (v1053);
              }
            }
          }
          {
            operator new();
          }
          uint64_t v1058 = mdm::Allocator::instance(void)::alloc;
          if (v1018 == v1044)
          {
            v1060 = 0;
            v1062 = 0;
          }
          else
          {
            if ((v1048 & 0x8000000000000000) != 0) {
              abort();
            }
            uint64_t v1059 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                  + 16))(mdm::Allocator::instance(void)::alloc, v1048 >> 2, 8);
            v1060 = (char *)v1059;
            uint64_t v1061 = 0;
            v1062 = (uint64_t *)(v1059 + 8 * v1049);
            do
            {
              if (v1059 + v1061) {
                *(void *)(v1059 + v1061) = 0;
              }
              v1061 += 8;
            }
            while (8 * v1049 != v1061);
            if (v1049 <= 1) {
              unint64_t v1063 = 1;
            }
            else {
              unint64_t v1063 = (v1018 - v1044) >> 5;
            }
            if (v1063 <= 3)
            {
              unint64_t v1064 = 0;
              goto LABEL_1899;
            }
            unint64_t v1064 = v1063 & 0xFFFFFFFFFFFFFFFCLL;
            v1065 = (int64x2_t *)(v1059 + 16);
            unint64_t v1066 = v1063 & 0xFFFFFFFFFFFFFFFCLL;
            int64x2_t v1067 = (int64x2_t)xmmword_1A28FC760;
            do
            {
              v1065[-1] = v1067;
              int64x2_t *v1065 = vaddq_s64(v1067, vdupq_n_s64(2uLL));
              int64x2_t v1067 = vaddq_s64(v1067, vdupq_n_s64(4uLL));
              v1065 += 2;
              v1066 -= 4;
            }
            while (v1066);
            while (v1063 != v1064)
            {
LABEL_1899:
              *(void *)(v1059 + 8 * v1064) = v1064;
              ++v1064;
            }
          }
          unint64_t v1108 = 126 - 2 * __clz(((char *)v1062 - v1060) >> 3);
          int64_t v1109 = (char *)v1062 - v1060;
          *(void *)v1609 = v983 + 32;
          if (v1062 == (uint64_t *)v1060) {
            uint64_t v1110 = 0;
          }
          else {
            uint64_t v1110 = v1108;
          }
          std::__introsort<std::_ClassicAlgPolicy,md::TransitLineLabelFeature::initTransitLines(GeoCodecsTransitLink *)::$_0 &,unsigned long *,false>((unint64_t)v1060, v1062, (uint64_t)v1609, v1110, 1);
          *(_WORD *)(v983 + 632) = *(void *)v1060;
          (*(void (**)(uint64_t, char *, int64_t))(*(void *)v1058 + 40))(v1058, v1060, v1109);
          if (v1046 && !atomic_fetch_add(&v1046->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v1046->__on_zero_shared)(v1046);
            std::__shared_weak_count::__release_weak(v1046);
          }
          v1111 = *(unsigned __int8 **)(v983 + 224);
          unsigned __int8 v1112 = atomic_load(v1111 + 80);
          if (v1112) {
            md::LabelLineStore::consumeWorkUnits((md::LabelLineStore *)v1111);
          }
          (*(void (**)(uint64_t *, uint64_t *, void))(*v1015 + 32))(v1015, v1012, v1509[24]);
          if (v1595) {
            v1113 = v1595 + 1;
          }
          else {
            v1113 = 0;
          }
          v1114 = (std::__shared_weak_count *)v1113[2];
          v1113[1] = v1015;
          v1113[2] = v983;
          if (v1114 && !atomic_fetch_add(&v1114->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v1114->__on_zero_shared)(v1114);
            std::__shared_weak_count::__release_weak(v1114);
          }
          uint64_t v1115 = *(void *)&v1473[10].__m_.__opaque[24];
          v1107 = v1595;
          v1116 = v1595 + 1;
          if (!v1595) {
            v1116 = 0;
          }
          uint64_t v1117 = v1116[1];
          *(void *)(v1117 + 152) = v1116;
          uint64_t v1118 = v1115 + 1;
          *(void *)&v1473[10].__m_.__opaque[24] = v1118;
          *(void *)(v1117 + 72) = v1118;
          *(unsigned char *)(v1117 + 147) = 1;
          goto LABEL_1917;
        }
      }
    }
    unsigned int __src = v72;
    uint64_t v73 = geo::codec::VectorTile::labelLineFeatureSections(*(geo::codec::VectorTile **)a3);
    if (!*(_WORD *)(v71 + 42)) {
      goto LABEL_73;
    }
    uint64_t v74 = v73;
    unsigned int v75 = 0;
    unsigned int v76 = *(_DWORD *)(v71 + 32);
    v77 = (unsigned int *)(v73 + 40 * v76);
    unint64_t v8 = (unint64_t)v1574;
    while (1)
    {
      unsigned int v78 = *v77;
      uint64_t v79 = v59 + 168 * *v77;
      if (v8 && (uint64_t v80 = *(void *)v8) != 0)
      {
        if (*(void *)(v79 + 40) == v80) {
          goto LABEL_92;
        }
        uint64_t v81 = *(unsigned __int8 *)(v79 + 74);
        if (*(unsigned char *)(v79 + 74))
        {
          uint64_t v82 = *(void *)(*(void *)a3 + 3528) + 8 * *(unsigned int *)(v79 + 64);
          uint64_t v83 = 8 * v81;
          v84 = (void *)v82;
          while (*v84 != v80)
          {
            ++v84;
            v83 -= 8;
            if (!v83)
            {
              v84 = (void *)(v82 + 8 * v81);
              break;
            }
          }
          if (v81 != ((uint64_t)v84 - v82) >> 3)
          {
LABEL_92:
            char v85 = 1;
            goto LABEL_93;
          }
        }
      }
      else if (v59 && *(unsigned __int8 *)(v59 + 168 * v78 + 153) - 1 < 2 {
             || geo::codec::featureGetNativeLabelCount(v59 + 168 * v78)
      }
             || geo::codec::featureGetNativeShieldCount(v59 + 168 * v78)
             || *(unsigned char *)(v59 + 168 * v78 + 150))
      {
        goto LABEL_92;
      }
      if (*(unsigned char *)(v1482 + 200) != 2)
      {
        unsigned int v86 = *(unsigned __int16 *)(v71 + 42);
        goto LABEL_94;
      }
      char v85 = 0;
LABEL_93:
      unsigned int v86 = *(unsigned __int16 *)(v71 + 42);
      if (!*((unsigned char *)v77 + 31)) {
        break;
      }
LABEL_94:
      ++v75;
      v77 += 10;
      if (v75 >= v86) {
        goto LABEL_73;
      }
    }
    if (*(_WORD *)(v71 + 42))
    {
      unsigned int v87 = 0;
      v88 = (unsigned char *)(v74 + 40 * v76 + 32);
      do
      {
        if (!*v88)
        {
          int v89 = *((unsigned __int16 *)v88 - 4) | (*((_DWORD *)v88 - 8) << 16);
          std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t)v1592, v89, v89);
          unsigned int v86 = *(unsigned __int16 *)(v71 + 42);
        }
        ++v87;
        v88 += 40;
      }
      while (v87 < v86);
    }
    v90 = (uint64_t *)(v59 + 168 * *v77);
    v1598 = 0;
    __p = 0;
    v1599 = 0;
    if ((v85 & 1) == 0)
    {
      md::LabelFeaturePool::addUnnamedLineFeature(&v1601, (uint64_t)v1473, v90, (char **)&__p, v71, (uint64_t)&v1568, v1447, v1451);
      uint64_t v102 = (uint64_t)v1601;
      v103 = v1602;
      if (v1602) {
        atomic_fetch_add_explicit(&v1602->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      v104 = (uint64_t **)(a1 + 80);
      while (1)
      {
        v105 = *v104;
        v106 = v104;
        if (!*v104) {
          break;
        }
        while (1)
        {
          v104 = (uint64_t **)v105;
          unint64_t v107 = v105[5];
          if ((unint64_t)v103 < v107) {
            break;
          }
          if (v107 >= (unint64_t)v103)
          {
            if (!v103) {
              goto LABEL_158;
            }
            std::__shared_weak_count::__release_weak(v103);
            goto LABEL_156;
          }
          v105 = v104[1];
          if (!v105)
          {
            v106 = v104 + 1;
            goto LABEL_129;
          }
        }
      }
LABEL_129:
      v108 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)a1 + 11) + 16))(*((void *)a1 + 11), 48, 8);
      v108[4] = v102;
      v108[5] = (uint64_t)v103;
      uint64_t *v108 = 0;
      v108[1] = 0;
      v108[2] = (uint64_t)v104;
      *v106 = v108;
      v109 = (void *)**v1404;
      if (v109)
      {
        *v1404 = v109;
        v108 = *v106;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)a1 + 10), v108);
      ++*((void *)a1 + 12);
      goto LABEL_155;
    }
    md::LabelFeaturePool::addLineFeature(&v1601, (uint64_t)v1473, v90, (char **)&__p, v71, (uint64_t)&v1568, v1447, v1451);
    uint64_t v91 = (uint64_t)v1601;
    v92 = v1602;
    if (v1602) {
      atomic_fetch_add_explicit(&v1602->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    v93 = (uint64_t **)(a1 + 48);
    while (1)
    {
      v94 = *v93;
      v95 = v93;
      if (!*v93) {
        break;
      }
      while (1)
      {
        v93 = (uint64_t **)v94;
        unint64_t v96 = v94[5];
        if ((unint64_t)v92 < v96) {
          break;
        }
        if (v96 >= (unint64_t)v92)
        {
          if (v92) {
            std::__shared_weak_count::__release_weak(v92);
          }
          goto LABEL_116;
        }
        v94 = v93[1];
        if (!v94)
        {
          v95 = v93 + 1;
          goto LABEL_113;
        }
      }
    }
LABEL_113:
    v97 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)a1 + 7) + 16))(*((void *)a1 + 7), 48, 8);
    v97[4] = v91;
    v97[5] = (uint64_t)v92;
    uint64_t *v97 = 0;
    v97[1] = 0;
    v97[2] = (uint64_t)v93;
    *v95 = v97;
    v98 = (void *)**v1405;
    if (v98)
    {
      *v1405 = v98;
      v97 = *v95;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)a1 + 6), v97);
    ++*((void *)a1 + 8);
LABEL_116:
    if (v1573[25])
    {
      v99 = v1601;
      v100 = *(void **)&v1609[8];
      if (*(void *)&v1609[8] >= *(void *)&v1609[16])
      {
        unint64_t v110 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v1609[8] - *(void *)v1609) >> 3);
        unint64_t v111 = v110 + 1;
        if (v110 + 1 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        if (0x5555555555555556 * ((uint64_t)(*(void *)&v1609[16] - *(void *)v1609) >> 3) > v111) {
          unint64_t v111 = 0x5555555555555556 * ((uint64_t)(*(void *)&v1609[16] - *(void *)v1609) >> 3);
        }
        uint64_t v112 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v1609[16] - *(void *)v1609) >> 3) >= 0x555555555555555
             ? 0xAAAAAAAAAAAAAAALL
             : v111;
        if (v112)
        {
          uint64_t v113 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1610 + 16))(v1610, 24 * v112, 8);
          v114 = (void *)(v113 + 24 * v110);
          uint64_t v115 = v113 + 24 * v112;
          if (v113)
          {
            void *v114 = v99;
            unint64_t v116 = v113 + 24 * v110;
            *(void *)(v116 + 8) = 0;
            *(void *)(v116 + 16) = 0;
          }
        }
        else
        {
          uint64_t v115 = 0;
          v114 = (void *)(8 * ((uint64_t)(*(void *)&v1609[8] - *(void *)v1609) >> 3));
        }
        uint64_t v118 = *(void *)v1609;
        uint64_t v117 = *(void *)&v1609[8];
        v119 = v114;
        if (*(void *)&v1609[8] != *(void *)v1609)
        {
          do
          {
            long long v120 = *(_OWORD *)(v117 - 24);
            *(v119 - 1) = *(void *)(v117 - 8);
            *(_OWORD *)(v119 - 3) = v120;
            v119 -= 3;
            v117 -= 24;
          }
          while (v117 != v118);
          uint64_t v117 = *(void *)v1609;
        }
        v101 = v114 + 3;
        *(void *)v1609 = v119;
        *(void *)&v1609[8] = v114 + 3;
        uint64_t v121 = *(void *)&v1609[16];
        *(void *)&v1609[16] = v115;
        if (v117) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1610 + 40))(v1610, v117, v121 - v117);
        }
      }
      else
      {
        if (*(void *)&v1609[8])
        {
          *(void *)(*(void *)&v1609[8] + 8) = 0;
          v100[2] = 0;
          void *v100 = v99;
        }
        v101 = v100 + 3;
      }
      *(void *)&v1609[8] = v101;
      if (v101 != *(void **)v1609 && 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v101 - *(void *)v1609) >> 3) >= 0x20) {
        break;
      }
    }
LABEL_155:
    v103 = v1602;
    if (v1602)
    {
LABEL_156:
      if (!atomic_fetch_add(&v103->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
        std::__shared_weak_count::__release_weak(v103);
      }
    }
LABEL_158:
    if (__p) {
      operator delete(__p);
    }
LABEL_73:
    unsigned int v72 = __src + 1;
    v71 += 48;
  }
  md::LabelFeatureStyler::styleLabelFeatures(*(unsigned int **)(v1482 + 296), (char **)v1609, 1u, 1, *(void *)(*(void *)(v1482 + 152) + 32));
  *(void *)&v1609[8] = *(void *)v1609;
  std::mutex::unlock(v1473);
  if (v1473)
  {
    std::mutex::lock(v1473);
    goto LABEL_155;
  }
LABEL_2422:
  std::__throw_system_error(1, "unique_lock::lock: references null mutex");
LABEL_2424:
  __break(1u);
}

void sub_1A1B671E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void **a19, void **a20,void **a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,md::PointLabelFeature *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,md::PointLabelFeature *a44,uint64_t a45,uint64_t a46,uint64_t a47,void **a48,uint64_t a49,uint64_t a50,uint64_t a51,void **a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57)
{
  std::mutex::unlock(v57);
  md::LabelFeatureCreationParams::~LabelFeatureCreationParams((md::LabelFeatureCreationParams *)&STACK[0x6E0]);
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)(v58 - 240));
  v60 = *(std::__shared_weak_count **)(a57 + 272);
  if (v60) {
    std::__shared_weak_count::__release_weak(v60);
  }
  std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy((uint64_t)(a9 - 1), *a9);
  std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy(a46, *a52);
  std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy(a35, *a48);
  std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy(a13, *a12);
  std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy(a17, *a21);
  std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy(a15, *a19);
  std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy(a16, *a20);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a11);
  v61 = *(std::__shared_weak_count **)(a57 + 16);
  if (!v61) {
    _Unwind_Resume(a1);
  }
  std::__shared_weak_count::__release_weak(v61);
  _Unwind_Resume(a1);
}

uint64_t geo::codec::VectorTile::tileLabelLinesCount(geo::codec::VectorTile *this)
{
  return *((unsigned int *)this + 454);
}

void md::LabelLineStore::addPhysicalFeature(uint64_t a1, uint64_t *a2, char **a3, uint64_t a4, uint64_t a5)
{
  {
    operator new();
  }
  uint64_t v10 = (md::LabelLineStore::WorkUnit *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                             + 16))(mdm::Allocator::instance(void)::alloc, 248, 8);
  v14 = (md::LabelLineStore::WorkUnit *)md::LabelLineStore::WorkUnit::WorkUnit((uint64_t)v10, 3, a2, a3, a4, a5);
  std::mutex::lock((std::mutex *)(a1 + 16));
  v11 = *(md::LabelLineStore::WorkUnit ***)(a1 + 96);
  if ((unint64_t)v11 >= *(void *)(a1 + 104))
  {
    char v12 = std::vector<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,geo::StdAllocator<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,mdm::Allocator>>::__emplace_back_slow_path<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>>(a1 + 88, (uint64_t *)&v14);
    uint64_t v10 = v14;
  }
  else
  {
    if (v11)
    {
      v14 = 0;
      *v11 = v10;
      uint64_t v10 = 0;
    }
    char v12 = v11 + 1;
  }
  *(void *)(a1 + 96) = v12;
  atomic_store(1u, (unsigned __int8 *)(a1 + 80));
  std::mutex::unlock((std::mutex *)(a1 + 16));
  v14 = 0;
  if (v10)
  {
    md::LabelLineStore::WorkUnit::~WorkUnit(v10);
    {
      operator new();
    }
    uint64_t v13 = *(void (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
    v13();
  }
}

void sub_1A1B6870C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, md::LabelLineStore::WorkUnit *a10)
{
  std::mutex::unlock(v10);
  std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>::~unique_ptr[abi:nn180100](&a10);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_1,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_1>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "LabelsTileDecode", "", v1, 2u);
  }
}

uint64_t geo::codec::VectorTile::removedFeatureIDs(geo::codec::VectorTile *this)
{
  return (uint64_t)this + 3776;
}

uint64_t geo::codec::VectorTile::tileLabelLines(geo::codec::VectorTile *this)
{
  return *((void *)this + 228);
}

uint64_t geo::codec::VectorTile::pois(geo::codec::VectorTile *this)
{
  return *((void *)this + 63);
}

uint64_t geo::codec::VectorTile::physicalFeaturesCount(geo::codec::VectorTile *this)
{
  return 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((void *)this + 20) - *((void *)this + 19)) >> 4);
}

uint64_t geo::codec::VectorTile::physicalFeatures(geo::codec::VectorTile *this)
{
  return *((void *)this + 19);
}

void md::MeshRenderableLogic::updateBatches(md::MeshRenderableLogic *this, const md::LayoutContext *a2, const md::MaterialContext *a3)
{
  uint64_t v645 = *MEMORY[0x1E4F143B8];
  *((unsigned char *)this + 417) = 0;
  if (GEOGetVectorKitPerformanceDetailsLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceDetailsLog_onceToken, &__block_literal_global_21);
  }
  v3 = (id)GEOGetVectorKitPerformanceDetailsLog_log;
  v4 = v3;
  os_signpost_id_t v5 = *((void *)a2 + 10);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    LOWORD(buf[0]) = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v5, "ProcessEnteringFeatures", "", (uint8_t *)buf, 2u);
  }

  uint64_t v6 = *((void *)this + 17);
  unint64_t v641 = (void (**)(char **))&unk_1EF574A18;
  int v644 = (void **)&v641;
  md::RegistryManager::entering(v621, v6, &v641);
  if (v644 == (void **)&v641)
  {
    v641[4]((char **)&v641);
  }
  else if (v644)
  {
    (*((void (**)(void **))*v644 + 5))(v644);
  }
  md::FilteredIterator<std::vector<gdc::Registry *>>::begin(&v616, (uint64_t)v621);
  md::FilteredIterator<std::vector<gdc::Registry *>>::end(&__p, (uint64_t *)v621);
  uint64_t v7 = (int8x8_t **)v617;
  if (v612 != (char *)v617)
  {
    do
    {
      unint64_t v8 = *v7;
      int8x8_t v9 = (*v7)[1];
      if (!*(void *)&v9) {
        goto LABEL_36;
      }
      uint8x8_t v10 = (uint8x8_t)vcnt_s8(v9);
      v10.i16[0] = vaddlv_u8(v10);
      if (v10.u32[0] > 1uLL)
      {
        unint64_t v11 = 0xCA93DB2C2ACE8387;
        if (*(void *)&v9 <= 0xCA93DB2C2ACE8387) {
          unint64_t v11 = 0xCA93DB2C2ACE8387 % *(void *)&v9;
        }
      }
      else
      {
        unint64_t v11 = (*(void *)&v9 - 1) & 0xCA93DB2C2ACE8387;
      }
      char v12 = *(void **)(*(void *)v8 + 8 * v11);
      if (!v12 || (uint64_t v13 = (void *)*v12) == 0) {
LABEL_36:
      }
        operator new();
      if (v10.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v15 = v13[1];
          if (v15 == 0xCA93DB2C2ACE8387)
          {
            if (v13[2] == 0xCA93DB2C2ACE8387) {
              goto LABEL_34;
            }
          }
          else if ((v15 & (*(void *)&v9 - 1)) != v11)
          {
            goto LABEL_36;
          }
          uint64_t v13 = (void *)*v13;
          if (!v13) {
            goto LABEL_36;
          }
        }
      }
      while (1)
      {
        unint64_t v14 = v13[1];
        if (v14 == 0xCA93DB2C2ACE8387) {
          break;
        }
        if (v14 >= *(void *)&v9) {
          v14 %= *(void *)&v9;
        }
        if (v14 != v11) {
          goto LABEL_36;
        }
LABEL_23:
        uint64_t v13 = (void *)*v13;
        if (!v13) {
          goto LABEL_36;
        }
      }
      if (v13[2] != 0xCA93DB2C2ACE8387) {
        goto LABEL_23;
      }
LABEL_34:
      uint64_t v16 = v13[5];
      if (*(void *)(v16 + 8) != 0xCA93DB2C2ACE8387 || !*(void *)(v16 + 32)) {
        goto LABEL_36;
      }
      uint8x8_t v17 = (uint8x8_t)vcnt_s8(v9);
      v17.i16[0] = vaddlv_u8(v17);
      if (v17.u32[0] > 1uLL)
      {
        unint64_t v18 = 0xCA93DB2C2ACE8387;
        if (*(void *)&v9 <= 0xCA93DB2C2ACE8387) {
          unint64_t v18 = 0xCA93DB2C2ACE8387 % *(void *)&v9;
        }
      }
      else
      {
        unint64_t v18 = (*(void *)&v9 - 1) & 0xCA93DB2C2ACE8387;
      }
      uint64_t v19 = *(void **)(*(void *)v8 + 8 * v18);
      if (!v19 || (uint64_t v20 = (void *)*v19) == 0)
      {
LABEL_59:
        int v24 = 0;
        goto LABEL_60;
      }
      if (v17.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v22 = v20[1];
          if (v22 == 0xCA93DB2C2ACE8387)
          {
            if (v20[2] == 0xCA93DB2C2ACE8387) {
              goto LABEL_57;
            }
          }
          else if ((v22 & (*(void *)&v9 - 1)) != v18)
          {
            goto LABEL_59;
          }
          uint64_t v20 = (void *)*v20;
          if (!v20) {
            goto LABEL_59;
          }
        }
      }
      while (2)
      {
        unint64_t v21 = v20[1];
        if (v21 != 0xCA93DB2C2ACE8387)
        {
          if (v21 >= *(void *)&v9) {
            v21 %= *(void *)&v9;
          }
          if (v21 != v18) {
            goto LABEL_59;
          }
          goto LABEL_46;
        }
        if (v20[2] != 0xCA93DB2C2ACE8387)
        {
LABEL_46:
          uint64_t v20 = (void *)*v20;
          if (!v20) {
            goto LABEL_59;
          }
          continue;
        }
        break;
      }
LABEL_57:
      uint64_t v23 = v20[5];
      if (*(void *)(v23 + 8) != 0xCA93DB2C2ACE8387) {
        goto LABEL_59;
      }
      int v24 = *(unsigned __int16 **)(v23 + 32);
LABEL_60:
      uint64_t v599 = *((void *)v24 + 1);
      uint64_t v605 = *((void *)v24 + 2);
      if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
        dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
      }
      double v25 = GEOGetVectorKitMeshRenderableLogicLog(void)::log;
      if (os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_DEBUG))
      {
        int v26 = *v24;
        LODWORD(buf[0]) = 67109120;
        HIDWORD(buf[0]) = v26;
        _os_log_impl(&dword_1A1780000, v25, OS_LOG_TYPE_DEBUG, "Entering BatchManager(id:%d)", (uint8_t *)buf, 8u);
      }
      double v27 = (void *)gdc::Registry::storage<md::components::MeshInstance>(v8);
      uint64_t v28 = gdc::Registry::storage<md::components::Material>(v8);
      uint64_t v29 = (void *)v28;
      uint64_t v30 = v28 + 32;
      uint64_t v31 = v27[7];
      uint64_t v32 = v27[8];
      if (*(void *)(v28 + 64) - *(void *)(v28 + 56) >= (unint64_t)(v32 - v31)) {
        uint64_t v33 = v27 + 4;
      }
      else {
        uint64_t v33 = (void *)(v28 + 32);
      }
      if (v27 + 4 == v33 && v31 != v32)
      {
        unsigned __int8 v34 = (unsigned char *)v27[10];
        do
        {
          unint64_t v35 = *(unsigned int *)(v31 + 4);
          uint64_t v36 = v29[4];
          unint64_t v37 = (v29[5] - v36) >> 3;
          if (v35 >> 7 < v37)
          {
            uint64_t v38 = *(void *)(v36 + 8 * (v35 >> 7));
            if (v38)
            {
              unint64_t v39 = *(unsigned __int16 *)(v38 + 2 * (v35 & 0x7F));
              uint64_t v41 = v29[7];
              uint64_t v40 = v29[8];
              unint64_t v42 = (v40 - v41) >> 3;
              if (v42 > v39)
              {
                uint64_t v43 = v41 + 8 * v39;
                if (v43 != v40 && *(_DWORD *)(v43 + 4) == v35)
                {
                  if ((unint64_t v45 = *(void *)v31, v46 = *(void *)v31 >> 39, v46 < v37)
                    && (uint64_t v47 = *(void *)(v36 + 8 * v46)) != 0
                    && (unint64_t v48 = *(unsigned __int16 *)(v47 + 2 * (HIDWORD(v45) & 0x7F)), v42 > v48)
                    && ((uint64_t v49 = v41 + 8 * v48, v49 != v40) ? (v50 = *(_DWORD *)(v49 + 4) == HIDWORD(v45)) : (v50 = 0), v50))
                  {
                    char v51 = (uint64_t *)(v29[10] + 24 * v48);
                  }
                  else
                  {
                    char v51 = (uint64_t *)v29[11];
                  }
                  buildMaterialKey(v8, *(void *)v31, v34, v51, (uint64_t)buf);
                  if (v629)
                  {
                    md::RenderBatchManager::process((uint64_t)v24, (size_t)buf, v45);
                    if (v629)
                    {
                      if (v628 != -1) {
                        ((void (*)(void (***)(char **), void **))*(&off_1EF58FC48 + v628))(&v637, buf);
                      }
                    }
                  }
                }
              }
            }
          }
          v34 += 112;
          v31 += 8;
        }
        while (v31 != v32);
      }
      if ((void *)v30 == v33)
      {
        uint64_t v56 = v29[7];
        uint64_t v57 = v29[8];
        if (v56 != v57)
        {
          uint64_t v58 = (uint64_t *)v29[10];
          do
          {
            unint64_t v59 = *(unsigned int *)(v56 + 4);
            uint64_t v60 = v27[4];
            unint64_t v61 = (v27[5] - v60) >> 3;
            if (v59 >> 7 < v61)
            {
              uint64_t v62 = *(void *)(v60 + 8 * (v59 >> 7));
              if (v62)
              {
                unint64_t v63 = *(unsigned __int16 *)(v62 + 2 * (v59 & 0x7F));
                uint64_t v65 = v27[7];
                uint64_t v64 = v27[8];
                unint64_t v66 = (v64 - v65) >> 3;
                if (v66 > v63)
                {
                  uint64_t v67 = v65 + 8 * v63;
                  if (v67 != v64 && *(_DWORD *)(v67 + 4) == v59)
                  {
                    if ((unint64_t v69 = *(void *)v56, v70 = *(void *)v56 >> 39, v70 < v61)
                      && (uint64_t v71 = *(void *)(v60 + 8 * v70)) != 0
                      && (unint64_t v72 = *(unsigned __int16 *)(v71 + 2 * (HIDWORD(v69) & 0x7F)), v66 > v72)
                      && ((uint64_t v73 = v65 + 8 * v72, v73 != v64) ? (v74 = *(_DWORD *)(v73 + 4) == HIDWORD(v69)) : (v74 = 0),
                          v74))
                    {
                      unsigned int v75 = (unsigned char *)(v27[10] + 112 * v72);
                    }
                    else
                    {
                      unsigned int v75 = (unsigned char *)v27[11];
                    }
                    buildMaterialKey(v8, *(void *)v56, v75, v58, (uint64_t)buf);
                    if (v629)
                    {
                      md::RenderBatchManager::process((uint64_t)v24, (size_t)buf, v69);
                      if (v629)
                      {
                        if (v628 != -1) {
                          ((void (*)(void (***)(char **), void **))*(&off_1EF58FC48 + v628))(&v637, buf);
                        }
                      }
                    }
                  }
                }
              }
            }
            v58 += 3;
            v56 += 8;
          }
          while (v56 != v57);
        }
      }
      uint64_t v52 = (v605 - v599) >> 3;
      if (v52 != (uint64_t)(*((void *)v24 + 2) - *((void *)v24 + 1)) >> 3)
      {
        if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
          dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
        }
        v53 = GEOGetVectorKitMeshRenderableLogicLog(void)::log;
        if (os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_DEBUG))
        {
          v54 = (void *)(((uint64_t)(*((void *)v24 + 2) - *((void *)v24 + 1)) >> 3) - v52);
          int v55 = *v24;
          LODWORD(buf[0]) = 134218240;
          *(void **)((char *)buf + 4) = v54;
          WORD2(buf[1]) = 1024;
          *(_DWORD *)((char *)&buf[1] + 6) = v55;
          _os_log_impl(&dword_1A1780000, v53, OS_LOG_TYPE_DEBUG, "Added %zu batches to BatchManager(id:%d)", (uint8_t *)buf, 0x12u);
        }
      }
      while (1)
      {
        uint64_t v7 = (int8x8_t **)(v617 + 1);
        size_t v617 = (os_signpost_id_t *)v7;
        if (v7 == (int8x8_t **)v616[1]) {
          break;
        }
        if (!v620)
        {
          std::__throw_bad_function_call[abi:nn180100]();
          goto LABEL_981;
        }
        if ((*(unsigned int (**)(uint64_t *))(*v620 + 48))(v620))
        {
          uint64_t v7 = (int8x8_t **)v617;
          break;
        }
      }
    }
    while (v612 != (char *)v7);
  }
  if (v615 == &v613)
  {
    v613[4]((char **)&v613);
  }
  else if (v615)
  {
    ((void (*)(void))(*v615)[5])();
  }
  if (v620 == &v618)
  {
    (*(void (**)(uint64_t *))(v618 + 32))(&v618);
  }
  else if (v620)
  {
    (*(void (**)(void))(*v620 + 40))();
  }
  if (v624 == v622)
  {
    (*((void (**)(void **))v622[0] + 4))(v622);
  }
  else if (v624)
  {
    (*((void (**)(void))*v624 + 5))();
  }
  if (GEOGetVectorKitPerformanceDetailsLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceDetailsLog_onceToken, &__block_literal_global_21);
  }
  unsigned int v76 = (id)GEOGetVectorKitPerformanceDetailsLog_log;
  v77 = v76;
  os_signpost_id_t v78 = *((void *)a2 + 10);
  if (v78 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v76))
  {
    LOWORD(buf[0]) = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v77, OS_SIGNPOST_INTERVAL_END, v78, "ProcessEnteringFeatures", "", (uint8_t *)buf, 2u);
  }

  if (GEOGetVectorKitPerformanceDetailsLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceDetailsLog_onceToken, &__block_literal_global_21);
  }
  uint64_t v79 = (id)GEOGetVectorKitPerformanceDetailsLog_log;
  uint64_t v80 = v79;
  os_signpost_id_t v81 = *((void *)a2 + 10);
  if (v81 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v79))
  {
    LOWORD(buf[0]) = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v80, OS_SIGNPOST_INTERVAL_BEGIN, v81, "ProcessUpdatedFeatures", "", (uint8_t *)buf, 2u);
  }

  *((void *)this + 15) = 0;
  *((unsigned char *)this + 128) = 0;
  uint64_t v82 = *((void *)this + 17);
  v621[0] = &unk_1EF5749D0;
  v622[1] = v621;
  md::RegistryManager::each(v82, (uint64_t)v621);
  if (v622[1] == v621)
  {
    (*((void (**)(void **))v621[0] + 4))(v621);
  }
  else if (v622[1])
  {
    (*(void (**)(void))(*(void *)v622[1] + 40))();
  }
  uint64_t v83 = *((void *)this + 17);
  v84 = *(int8x8_t ***)(v83 + 384);
  v596 = *(int8x8_t ***)(v83 + 392);
  if (v84 == v596) {
    goto LABEL_304;
  }
  do
  {
    v600 = v84;
    char v85 = *v84;
    unsigned int v86 = (void *)gdc::Registry::storage<md::components::VisibilityChanged>(*v84);
    uint64_t v87 = gdc::Registry::storage<md::components::Visibility>(v85);
    v88 = (void *)v87;
    buf[0] = &v626;
    buf[1] = &v626;
    buf[2] = &v626;
    buf[3] = (void *)4;
    uint64_t v89 = v87 + 32;
    uint64_t v90 = v86[7];
    uint64_t v91 = v86[8];
    if (*(void *)(v87 + 64) - *(void *)(v87 + 56) >= (unint64_t)(v91 - v90)) {
      v92 = v86 + 4;
    }
    else {
      v92 = (void *)(v87 + 32);
    }
    if (v86 + 4 == v92 && v90 != v91)
    {
      while (1)
      {
        unint64_t v113 = *(unsigned int *)(v90 + 4);
        uint64_t v114 = v88[4];
        if (v113 >> 7 >= (v88[5] - v114) >> 3) {
          goto LABEL_187;
        }
        uint64_t v115 = *(void *)(v114 + 8 * (v113 >> 7));
        if (!v115) {
          goto LABEL_187;
        }
        unint64_t v116 = *(unsigned __int16 *)(v115 + 2 * (v113 & 0x7F));
        uint64_t v118 = v88[7];
        uint64_t v117 = v88[8];
        if (v116 >= (v117 - v118) >> 3) {
          goto LABEL_187;
        }
        uint64_t v119 = v118 + 8 * v116;
        if (v119 == v117 || *(_DWORD *)(v119 + 4) != v113) {
          goto LABEL_187;
        }
        unint64_t v121 = *(void *)v90;
        if (!gdc::Registry::hasAny<md::components::MeshInstance,md::components::DynamicMeshInstance>(v85, *(void *)v90))goto LABEL_187; {
        md::MeshRenderableLogic::updateEntityVisibility((uint64_t)this, v121, v85);
        }
        uint64_t v112 = (unint64_t *)buf[1];
        unint64_t v122 = (void *)((((char *)buf[1] - (char *)buf[0]) >> 3) + 1);
        if (buf[3] < v122) {
          break;
        }
LABEL_186:
        *uint64_t v112 = v121;
        buf[1] = (char *)buf[1] + 8;
LABEL_187:
        v90 += 8;
        if (v90 == v91) {
          goto LABEL_163;
        }
      }
      uint64_t v589 = buf[0];
      int64_t v592 = ((char *)buf[1] - (char *)buf[0]) >> 3;
      uint64_t v586 = buf[2];
      unint64_t v123 = (1 << -(char)__clz((unint64_t)buf[3] + 1));
      if (buf[3] >= (void *)0xFFFFFFFFFFFFFFFELL) {
        unint64_t v123 = 1;
      }
      if (v123 <= (unint64_t)v122) {
        int64_t v124 = (((char *)buf[1] - (char *)buf[0]) >> 3) + 1;
      }
      else {
        int64_t v124 = v123;
      }
      uint64_t v125 = malloc_type_malloc(8 * v124, 0x100004000313F17uLL);
      uint64_t v126 = (char *)v125;
      char v128 = (uint64_t *)buf[1];
      v127 = (uint64_t *)buf[0];
      if (buf[0] != buf[1])
      {
        unint64_t v129 = (char *)buf[1] - (char *)buf[0] - 8;
        if (v129 < 0x18)
        {
          unint64_t v130 = v125;
        }
        else
        {
          unint64_t v130 = v125;
          if ((unint64_t)((char *)v125 - (char *)buf[0]) >= 0x20)
          {
            uint64_t v131 = (v129 >> 3) + 1;
            uint64_t v132 = 8 * (v131 & 0x3FFFFFFFFFFFFFFCLL);
            unint64_t v130 = (void *)((char *)v125 + v132);
            v133 = (long long *)((char *)buf[0] + 16);
            v134 = v125 + 1;
            uint64_t v135 = v131 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v136 = *v133;
              *(v134 - 1) = *(v133 - 1);
              _OWORD *v134 = v136;
              v133 += 2;
              v134 += 2;
              v135 -= 4;
            }
            while (v135);
            if (v131 == (v131 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_212;
            }
            v127 = (uint64_t *)((char *)v127 + v132);
          }
        }
        do
        {
          uint64_t v137 = *v127++;
          *v130++ = v137;
        }
        while (v127 != v128);
      }
LABEL_212:
      if (v589 != v586) {
        free(buf[0]);
      }
      uint64_t v112 = (unint64_t *)&v126[8 * v592];
      buf[0] = v126;
      buf[1] = v112;
      buf[3] = (void *)v124;
      goto LABEL_186;
    }
LABEL_163:
    if ((void *)v89 == v92)
    {
      uint64_t v97 = v88[7];
      uint64_t v98 = v88[8];
      while (1)
      {
        if (v97 == v98) {
          goto LABEL_164;
        }
        unint64_t v165 = *(unsigned int *)(v97 + 4);
        uint64_t v166 = v86[4];
        if (v165 >> 7 < (v86[5] - v166) >> 3)
        {
          uint64_t v167 = *(void *)(v166 + 8 * (v165 >> 7));
          if (v167)
          {
            unint64_t v168 = *(unsigned __int16 *)(v167 + 2 * (v165 & 0x7F));
            uint64_t v170 = v86[7];
            uint64_t v169 = v86[8];
            if (v168 < (v169 - v170) >> 3)
            {
              uint64_t v171 = v170 + 8 * v168;
              if (v171 != v169 && *(_DWORD *)(v171 + 4) == v165)
              {
                unint64_t v173 = *(void *)v97;
                if (gdc::Registry::hasAny<md::components::MeshInstance,md::components::DynamicMeshInstance>(v85, *(void *)v97))break; {
              }
                }
            }
          }
        }
LABEL_245:
        v97 += 8;
      }
      md::MeshRenderableLogic::updateEntityVisibility((uint64_t)this, v173, v85);
      v164 = (unint64_t *)buf[1];
      unint64_t v174 = buf[0];
      int64_t v175 = ((char *)buf[1] - (char *)buf[0]) >> 3;
      if (buf[3] >= (void *)(v175 + 1))
      {
LABEL_244:
        unint64_t *v164 = v173;
        buf[1] = (char *)buf[1] + 8;
        goto LABEL_245;
      }
      uint64_t v176 = buf[2];
      unint64_t v177 = (1 << -(char)__clz((unint64_t)buf[3] + 1));
      if (buf[3] >= (void *)0xFFFFFFFFFFFFFFFELL) {
        unint64_t v177 = 1;
      }
      if (v177 <= v175 + 1) {
        unint64_t v178 = v175 + 1;
      }
      else {
        unint64_t v178 = v177;
      }
      uint64_t v179 = malloc_type_malloc(8 * v178, 0x100004000313F17uLL);
      unint64_t v180 = (char *)v179;
      uint64_t v182 = (uint64_t *)buf[1];
      uint64_t v181 = (uint64_t *)buf[0];
      if (buf[0] != buf[1])
      {
        unint64_t v183 = (char *)buf[1] - (char *)buf[0] - 8;
        if (v183 < 0x18)
        {
          long long v184 = v179;
        }
        else
        {
          long long v184 = v179;
          if ((unint64_t)((char *)v179 - (char *)buf[0]) >= 0x20)
          {
            uint64_t v185 = (v183 >> 3) + 1;
            uint64_t v186 = 8 * (v185 & 0x3FFFFFFFFFFFFFFCLL);
            long long v184 = (void *)((char *)v179 + v186);
            v187 = (long long *)((char *)buf[0] + 16);
            v188 = v179 + 1;
            uint64_t v189 = v185 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v190 = *v187;
              *(v188 - 1) = *(v187 - 1);
              _OWORD *v188 = v190;
              v187 += 2;
              v188 += 2;
              v189 -= 4;
            }
            while (v189);
            if (v185 == (v185 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_271;
            }
            uint64_t v181 = (uint64_t *)((char *)v181 + v186);
          }
        }
        do
        {
          uint64_t v191 = *v181++;
          *v184++ = v191;
        }
        while (v181 != v182);
      }
LABEL_271:
      if (v174 != v176) {
        free(buf[0]);
      }
      v164 = (unint64_t *)&v180[8 * v175];
      buf[0] = v180;
      buf[1] = v164;
      buf[3] = (void *)v178;
      goto LABEL_244;
    }
LABEL_164:
    v94 = (unint64_t *)buf[1];
    v95 = (unint64_t *)buf[0];
    if (buf[0] != buf[1])
    {
      do
      {
        unint64_t v96 = (void *)gdc::Registry::storage<md::components::VisibilityChanged>(v85);
        gdc::ComponentStorageWrapper<md::components::VisibilityChanged>::remove(v96, *v95++);
      }
      while (v95 != v94);
      v95 = (unint64_t *)buf[0];
    }
    if (v95 != buf[2]) {
      free(v95);
    }
    v99 = (void *)gdc::Registry::storage<md::components::CustomRenderStateChanged>(v85);
    uint64_t v100 = gdc::Registry::storage<md::components::CustomRenderState>(v85);
    v101 = (void *)v100;
    buf[0] = &v626;
    buf[1] = &v626;
    buf[2] = &v626;
    buf[3] = (void *)4;
    uint64_t v102 = v100 + 32;
    uint64_t v103 = v99[7];
    uint64_t v104 = v99[8];
    if (*(void *)(v100 + 64) - *(void *)(v100 + 56) >= (unint64_t)(v104 - v103)) {
      v105 = v99 + 4;
    }
    else {
      v105 = (void *)(v100 + 32);
    }
    if (v99 + 4 == v105 && v103 != v104)
    {
      while (1)
      {
        unint64_t v139 = *(unsigned int *)(v103 + 4);
        uint64_t v140 = v101[4];
        if (v139 >> 7 >= (v101[5] - v140) >> 3) {
          goto LABEL_216;
        }
        uint64_t v141 = *(void *)(v140 + 8 * (v139 >> 7));
        if (!v141) {
          goto LABEL_216;
        }
        unint64_t v142 = *(unsigned __int16 *)(v141 + 2 * (v139 & 0x7F));
        uint64_t v144 = v101[7];
        uint64_t v143 = v101[8];
        if (v142 >= (v143 - v144) >> 3) {
          goto LABEL_216;
        }
        uint64_t v145 = v144 + 8 * v142;
        if (v145 == v143 || *(_DWORD *)(v145 + 4) != v139) {
          goto LABEL_216;
        }
        unint64_t v147 = *(void *)v103;
        if (!gdc::Registry::hasAny<md::components::MeshInstance,md::components::DynamicMeshInstance>(v85, *(void *)v103))goto LABEL_216; {
        md::MeshRenderableLogic::updateEntityCustomRenderState((uint64_t)this, v147, v85);
        }
        v138 = (unint64_t *)buf[1];
        v148 = (void *)((((char *)buf[1] - (char *)buf[0]) >> 3) + 1);
        if (buf[3] < v148) {
          break;
        }
LABEL_215:
        unint64_t *v138 = v147;
        buf[1] = (char *)buf[1] + 8;
LABEL_216:
        v103 += 8;
        if (v103 == v104) {
          goto LABEL_178;
        }
      }
      v590 = buf[0];
      int64_t v593 = ((char *)buf[1] - (char *)buf[0]) >> 3;
      long long v587 = buf[2];
      unint64_t v149 = (1 << -(char)__clz((unint64_t)buf[3] + 1));
      if (buf[3] >= (void *)0xFFFFFFFFFFFFFFFELL) {
        unint64_t v149 = 1;
      }
      if (v149 <= (unint64_t)v148) {
        int64_t v150 = (((char *)buf[1] - (char *)buf[0]) >> 3) + 1;
      }
      else {
        int64_t v150 = v149;
      }
      v151 = malloc_type_malloc(8 * v150, 0x100004000313F17uLL);
      v152 = (char *)v151;
      long long v154 = (uint64_t *)buf[1];
      uint64_t v153 = (uint64_t *)buf[0];
      if (buf[0] != buf[1])
      {
        unint64_t v155 = (char *)buf[1] - (char *)buf[0] - 8;
        if (v155 < 0x18)
        {
          v156 = v151;
          goto LABEL_240;
        }
        v156 = v151;
        if ((unint64_t)((char *)v151 - (char *)buf[0]) < 0x20)
        {
          do
          {
LABEL_240:
            uint64_t v163 = *v153++;
            *v156++ = v163;
          }
          while (v153 != v154);
        }
        else
        {
          uint64_t v157 = (v155 >> 3) + 1;
          uint64_t v158 = 8 * (v157 & 0x3FFFFFFFFFFFFFFCLL);
          v156 = (void *)((char *)v151 + v158);
          v159 = (long long *)((char *)buf[0] + 16);
          unint64_t v160 = v151 + 1;
          uint64_t v161 = v157 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v162 = *v159;
            *(v160 - 1) = *(v159 - 1);
            *unint64_t v160 = v162;
            v159 += 2;
            v160 += 2;
            v161 -= 4;
          }
          while (v161);
          if (v157 != (v157 & 0x3FFFFFFFFFFFFFFCLL))
          {
            uint64_t v153 = (uint64_t *)((char *)v153 + v158);
            goto LABEL_240;
          }
        }
      }
      if (v590 != v587) {
        free(buf[0]);
      }
      v138 = (unint64_t *)&v152[8 * v593];
      buf[0] = v152;
      buf[1] = v138;
      buf[3] = (void *)v150;
      goto LABEL_215;
    }
LABEL_178:
    if ((void *)v102 == v105)
    {
      uint64_t v110 = v101[7];
      uint64_t v111 = v101[8];
      while (1)
      {
        if (v110 == v111) {
          goto LABEL_179;
        }
        unint64_t v193 = *(unsigned int *)(v110 + 4);
        uint64_t v194 = v99[4];
        if (v193 >> 7 < (v99[5] - v194) >> 3)
        {
          uint64_t v195 = *(void *)(v194 + 8 * (v193 >> 7));
          if (v195)
          {
            unint64_t v196 = *(unsigned __int16 *)(v195 + 2 * (v193 & 0x7F));
            uint64_t v198 = v99[7];
            uint64_t v197 = v99[8];
            if (v196 < (v197 - v198) >> 3)
            {
              uint64_t v199 = v198 + 8 * v196;
              if (v199 != v197 && *(_DWORD *)(v199 + 4) == v193)
              {
                unint64_t v201 = *(void *)v110;
                if (gdc::Registry::hasAny<md::components::MeshInstance,md::components::DynamicMeshInstance>(v85, *(void *)v110))break; {
              }
                }
            }
          }
        }
LABEL_275:
        v110 += 8;
      }
      md::MeshRenderableLogic::updateEntityCustomRenderState((uint64_t)this, v201, v85);
      uint64_t v192 = (unint64_t *)buf[1];
      unsigned int v202 = buf[0];
      int64_t v203 = ((char *)buf[1] - (char *)buf[0]) >> 3;
      if (buf[3] < (void *)(v203 + 1))
      {
        v204 = buf[2];
        unint64_t v205 = (1 << -(char)__clz((unint64_t)buf[3] + 1));
        if (buf[3] >= (void *)0xFFFFFFFFFFFFFFFELL) {
          unint64_t v205 = 1;
        }
        if (v205 <= v203 + 1) {
          unint64_t v206 = v203 + 1;
        }
        else {
          unint64_t v206 = v205;
        }
        unint64_t v207 = malloc_type_malloc(8 * v206, 0x100004000313F17uLL);
        v208 = (char *)v207;
        uint64_t v210 = (uint64_t *)buf[1];
        uint64_t v209 = (uint64_t *)buf[0];
        if (buf[0] != buf[1])
        {
          unint64_t v211 = (char *)buf[1] - (char *)buf[0] - 8;
          if (v211 < 0x18)
          {
            uint64_t v212 = v207;
            goto LABEL_300;
          }
          uint64_t v212 = v207;
          if ((unint64_t)((char *)v207 - (char *)buf[0]) < 0x20)
          {
            do
            {
LABEL_300:
              uint64_t v219 = *v209++;
              *v212++ = v219;
            }
            while (v209 != v210);
          }
          else
          {
            uint64_t v213 = (v211 >> 3) + 1;
            uint64_t v214 = 8 * (v213 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v212 = (void *)((char *)v207 + v214);
            v215 = (long long *)((char *)buf[0] + 16);
            uint64_t v216 = v207 + 1;
            uint64_t v217 = v213 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v218 = *v215;
              *(v216 - 1) = *(v215 - 1);
              *uint64_t v216 = v218;
              v215 += 2;
              v216 += 2;
              v217 -= 4;
            }
            while (v217);
            if (v213 != (v213 & 0x3FFFFFFFFFFFFFFCLL))
            {
              uint64_t v209 = (uint64_t *)((char *)v209 + v214);
              goto LABEL_300;
            }
          }
        }
        if (v202 != v204) {
          free(buf[0]);
        }
        uint64_t v192 = (unint64_t *)&v208[8 * v203];
        buf[0] = v208;
        buf[1] = v192;
        buf[3] = (void *)v206;
      }
      *uint64_t v192 = v201;
      buf[1] = (char *)buf[1] + 8;
      goto LABEL_275;
    }
LABEL_179:
    unint64_t v107 = (unint64_t *)buf[1];
    v108 = (unint64_t *)buf[0];
    if (buf[0] != buf[1])
    {
      do
      {
        v109 = (void *)gdc::Registry::storage<md::components::CustomRenderStateChanged>(v85);
        gdc::ComponentStorageWrapper<md::components::CustomRenderStateChanged>::remove(v109, *v108++);
      }
      while (v108 != v107);
      v108 = (unint64_t *)buf[0];
    }
    if (v108 != buf[2]) {
      free(v108);
    }
    v84 = v600 + 1;
  }
  while (v600 + 1 != v596);
  uint64_t v83 = *((void *)this + 17);
LABEL_304:
  BOOL v220 = (*((unsigned __int8 *)a3 + 73) | *((unsigned __int8 *)a3 + 72)) != 0;
  v221 = (void **)operator new(0x20uLL);
  _DWORD *v221 = &unk_1EF56B770;
  v221[1] = md::MeshRenderableLogic::processVisibilityUpdateCollector;
  v221[2] = 0;
  v221[3] = this;
  uint64_t v619 = v221;
  if (*((unsigned char *)this + 152)) {
    char v222 = v220;
  }
  else {
    char v222 = 1;
  }
  if (v222) {
    int v223 = 0x7FFFFFFF;
  }
  else {
    int v223 = *((_DWORD *)this + 110);
  }
  buf[3] = 0;
  v224 = operator new(0x20uLL);
  *(void *)v224 = &unk_1EF574AF0;
  v224[2] = v223;
  *((void *)v224 + 2) = this;
  *((void *)v224 + 3) = &v616;
  buf[3] = v224;
  md::RegistryManager::visitActiveCollectors<md::MeshRenderableLogic,CollectorKey>(v83, (uint64_t)this, 2, buf);
  if (buf[3] == buf)
  {
    (*((void (**)(void **))buf[0] + 4))(buf);
  }
  else if (buf[3])
  {
    (*(void (**)(void))(*(void *)buf[3] + 40))();
  }
  if (v619 == (void **)&v616)
  {
    ((void (*)(void **))v616[4])(&v616);
  }
  else if (v619)
  {
    (*((void (**)(void))*v619 + 5))();
  }
  uint64_t v225 = *((void *)this + 17);
  long long v226 = (void **)operator new(0x20uLL);
  *long long v226 = &unk_1EF56B770;
  v226[1] = md::MeshRenderableLogic::processMaterialUpdateCollector;
  v226[2] = 0;
  v226[3] = this;
  int v644 = v226;
  if (*((unsigned char *)this + 152)) {
    char v227 = v220;
  }
  else {
    char v227 = 1;
  }
  if (v227) {
    int v228 = 0x7FFFFFFF;
  }
  else {
    int v228 = *((_DWORD *)this + 110);
  }
  p_p = 0;
  uint64_t v229 = operator new(0x20uLL);
  *(void *)uint64_t v229 = &unk_1EF574AF0;
  v229[2] = v228;
  *((void *)v229 + 2) = this;
  *((void *)v229 + 3) = &v641;
  p_p = (void **)v229;
  md::RegistryManager::visitActiveCollectors<md::MeshRenderableLogic,CollectorKey>(v225, (uint64_t)this, 0, &__p);
  if (p_p == &__p)
  {
    (*((void (**)(void **))__p + 4))(&__p);
  }
  else if (p_p)
  {
    (*((void (**)(void))*p_p + 5))();
  }
  if (v644 == (void **)&v641)
  {
    v641[4]((char **)&v641);
  }
  else if (v644)
  {
    (*((void (**)(void))*v644 + 5))();
  }
  uint64_t v230 = *((void *)this + 17);
  unint64_t v231 = (uint64_t *)operator new(0x20uLL);
  *unint64_t v231 = (uint64_t)&unk_1EF56B770;
  v231[1] = (uint64_t)md::MeshRenderableLogic::processMaterialEnteringCollector;
  v231[2] = 0;
  v231[3] = (uint64_t)this;
  v636 = v231;
  if (*((unsigned char *)this + 152)) {
    char v232 = v220;
  }
  else {
    char v232 = 1;
  }
  if (v232) {
    int v233 = 0x7FFFFFFF;
  }
  else {
    int v233 = *((_DWORD *)this + 110);
  }
  uint64_t v640 = 0;
  uint64_t v234 = operator new(0x20uLL);
  *(void *)uint64_t v234 = &unk_1EF574AF0;
  v234[2] = v233;
  *((void *)v234 + 2) = this;
  *((void *)v234 + 3) = &v634;
  uint64_t v640 = (void **)v234;
  md::RegistryManager::visitActiveCollectors<md::MeshRenderableLogic,CollectorKey>(v230, (uint64_t)this, 3, &v637);
  if (v640 == (void **)&v637)
  {
    v637[4]((char **)&v637);
  }
  else if (v640)
  {
    (*((void (**)(void))*v640 + 5))();
  }
  if (v636 == &v634)
  {
    (*(void (**)(uint64_t *))(v634 + 32))(&v634);
  }
  else if (v636)
  {
    (*(void (**)(void))(*v636 + 40))();
  }
  uint64_t v235 = *((void *)this + 17);
  unint64_t v236 = operator new(0x20uLL);
  *unint64_t v236 = &unk_1EF56B770;
  v236[1] = md::MeshRenderableLogic::processMaterialEnteringCollector;
  v236[2] = 0;
  v236[3] = this;
  uint64_t v631 = v236;
  if (*((unsigned char *)this + 152)) {
    char v237 = v220;
  }
  else {
    char v237 = 1;
  }
  if (v237) {
    int v238 = 0x7FFFFFFF;
  }
  else {
    int v238 = *((_DWORD *)this + 110);
  }
  v633 = 0;
  uint64_t v239 = operator new(0x20uLL);
  *(void *)uint64_t v239 = &unk_1EF574AF0;
  v239[2] = v238;
  *((void *)v239 + 2) = this;
  *((void *)v239 + 3) = v630;
  v633 = v239;
  md::RegistryManager::visitActiveCollectors<md::MeshRenderableLogic,CollectorKey>(v235, (uint64_t)this, 4, v632);
  if (v633 == v632)
  {
    (*(void (**)(void *))(v632[0] + 32))(v632);
  }
  else if (v633)
  {
    (*(void (**)(void))(*v633 + 40))();
  }
  if (v631 == v630)
  {
    (*(void (**)(void *))(v630[0] + 32))(v630);
  }
  else if (v631)
  {
    (*(void (**)(void))(*v631 + 40))();
  }
  if (*((unsigned char *)this + 128))
  {
    uint64_t v240 = **((void **)this + 35);
    if (v240)
    {
      char v610 = 8;
      md::MapEngine::setNeedsTick(v240, &v610);
    }
  }
  if (GEOGetVectorKitPerformanceDetailsLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceDetailsLog_onceToken, &__block_literal_global_21);
  }
  uint64_t v241 = (id)GEOGetVectorKitPerformanceDetailsLog_log;
  uint64_t v242 = v241;
  os_signpost_id_t v243 = *((void *)a2 + 10);
  if (v243 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v241))
  {
    LOWORD(buf[0]) = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v242, OS_SIGNPOST_INTERVAL_END, v243, "ProcessUpdatedFeatures", "", (uint8_t *)buf, 2u);
  }

  if (GEOGetVectorKitPerformanceDetailsLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceDetailsLog_onceToken, &__block_literal_global_21);
  }
  uint64_t v244 = (id)GEOGetVectorKitPerformanceDetailsLog_log;
  v245 = v244;
  os_signpost_id_t v246 = *((void *)a2 + 10);
  if (v246 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v244))
  {
    LOWORD(buf[0]) = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v245, OS_SIGNPOST_INTERVAL_BEGIN, v246, "ProcessChangedBatches", "", (uint8_t *)buf, 2u);
  }

  memset(buf, 0, sizeof(buf));
  int v626 = 1065353216;
  *(_OWORD *)unint64_t v621 = 0u;
  *(_OWORD *)unint64_t v622 = 0u;
  float v623 = 1.0;
  __p = 0;
  int v612 = 0;
  v613 = 0;
  unint64_t v641 = 0;
  v642 = 0;
  unint64_t v643 = 0;
  uint64_t v637 = 0;
  unint64_t v638 = 0;
  unint64_t v639 = 0;
  uint64_t v247 = *((void *)this + 17);
  v249 = *(int8x8_t ***)(v247 + 384);
  v248 = *(int8x8_t ***)(v247 + 392);
  if (v249 != v248)
  {
    char v250 = 0;
    unint64_t v251 = 0;
    while (1)
    {
      v438 = *v249;
      int8x8_t v439 = (*v249)[1];
      if (v439)
      {
        uint8x8_t v440 = (uint8x8_t)vcnt_s8(v439);
        v440.i16[0] = vaddlv_u8(v440);
        if (v440.u32[0] > 1uLL)
        {
          unint64_t v441 = 0xCA93DB2C2ACE8387;
          if (*(void *)&v439 <= 0xCA93DB2C2ACE8387) {
            unint64_t v441 = 0xCA93DB2C2ACE8387 % *(void *)&v439;
          }
        }
        else
        {
          unint64_t v441 = (*(void *)&v439 - 1) & 0xCA93DB2C2ACE8387;
        }
        unint64_t v442 = *(void **)(*(void *)v438 + 8 * v441);
        if (v442)
        {
          uint64_t v443 = (void *)*v442;
          if (v443)
          {
            if (v440.u32[0] < 2uLL)
            {
              uint64_t v444 = *(void *)&v439 - 1;
              while (1)
              {
                uint64_t v446 = v443[1];
                if (v446 == 0xCA93DB2C2ACE8387)
                {
                  if (v443[2] == 0xCA93DB2C2ACE8387) {
                    goto LABEL_759;
                  }
                }
                else if ((v446 & v444) != v441)
                {
                  goto LABEL_737;
                }
                uint64_t v443 = (void *)*v443;
                if (!v443) {
                  goto LABEL_737;
                }
              }
            }
            while (1)
            {
              unint64_t v445 = v443[1];
              if (v445 == 0xCA93DB2C2ACE8387) {
                break;
              }
              if (v445 >= *(void *)&v439) {
                v445 %= *(void *)&v439;
              }
              if (v445 != v441) {
                goto LABEL_737;
              }
LABEL_748:
              uint64_t v443 = (void *)*v443;
              if (!v443) {
                goto LABEL_737;
              }
            }
            if (v443[2] != 0xCA93DB2C2ACE8387) {
              goto LABEL_748;
            }
LABEL_759:
            uint64_t v447 = v443[5];
            if (*(void *)(v447 + 8) == 0xCA93DB2C2ACE8387)
            {
              uint64_t v448 = *(void *)(v447 + 32);
              if (v448)
              {
                uint64_t v608 = *(void *)(v447 + 32);
                if (buf[3])
                {
                  BOOL v449 = buf[2];
                  if (buf[2])
                  {
                    do
                    {
                      unint64_t v450 = (void *)*v449;
                      operator delete(v449);
                      BOOL v449 = v450;
                    }
                    while (v450);
                  }
                  buf[2] = 0;
                  unint64_t v451 = (char *)buf[1];
                  if (buf[1])
                  {
                    size_t v452 = 0;
                    do
                      *((void *)buf[0] + (void)v452++) = 0;
                    while (v451 != v452);
                  }
                  buf[3] = 0;
                  uint64_t v448 = v608;
                }
                if (*(unsigned char *)(v448 + 80)) {
                  break;
                }
              }
            }
          }
        }
      }
LABEL_737:
      if (++v249 == v248) {
        goto LABEL_376;
      }
    }
    v595 = v248;
    uint64_t v454 = *(unint64_t **)(v448 + 8);
    uint64_t v453 = *(unint64_t **)(v448 + 16);
    if (v454 != v453)
    {
      v602 = (float *)(v448 + 88);
      uint64_t v455 = (void *)(v448 + 128);
      uint64_t v598 = (uint64_t **)(v448 + 144);
      while (1)
      {
        while (1)
        {
          unint64_t v456 = *v454;
          if (!*(void *)(*v454 + 264)) {
            break;
          }
          if (*(unsigned char *)(v456 + 352))
          {
            std::__hash_table<md::RenderBatch *,std::hash<md::RenderBatch *>,std::equal_to<md::RenderBatch *>,std::allocator<md::RenderBatch *>>::__emplace_unique_key_args<md::RenderBatch *,md::RenderBatch *&>((float *)buf, *v454, *v454);
            std::__hash_table<md::RenderBatch *,std::hash<md::RenderBatch *>,std::equal_to<md::RenderBatch *>,std::allocator<md::RenderBatch *>>::__emplace_unique_key_args<md::RenderBatch *,md::RenderBatch *&>(v602, v456, v456);
            uint64_t v453 = *(unint64_t **)(v448 + 16);
          }
          if (++v454 == v453) {
            goto LABEL_821;
          }
        }
        size_t v457 = std::__hash_table<std::__hash_value_type<std::variant<md::MaterialRenderBatchKey,md::DynamicTypedRenderBatchKey,md::MaterialDecalRenderBatchKey>,md::RenderBatch *>,std::__unordered_map_hasher<std::variant<md::MaterialRenderBatchKey,md::DynamicTypedRenderBatchKey,md::MaterialDecalRenderBatchKey>,std::__hash_value_type<std::variant<md::MaterialRenderBatchKey,md::DynamicTypedRenderBatchKey,md::MaterialDecalRenderBatchKey>,md::RenderBatch *>,std::hash<std::variant<md::MaterialRenderBatchKey,md::DynamicTypedRenderBatchKey,md::MaterialDecalRenderBatchKey>>,std::equal_to<std::variant<md::MaterialRenderBatchKey,md::DynamicTypedRenderBatchKey,md::MaterialDecalRenderBatchKey>>,true>,std::__unordered_map_equal<std::variant<md::MaterialRenderBatchKey,md::DynamicTypedRenderBatchKey,md::MaterialDecalRenderBatchKey>,std::__hash_value_type<std::variant<md::MaterialRenderBatchKey,md::DynamicTypedRenderBatchKey,md::MaterialDecalRenderBatchKey>,md::RenderBatch *>,std::equal_to<std::variant<md::MaterialRenderBatchKey,md::DynamicTypedRenderBatchKey,md::MaterialDecalRenderBatchKey>>,std::hash<std::variant<md::MaterialRenderBatchKey,md::DynamicTypedRenderBatchKey,md::MaterialDecalRenderBatchKey>>,true>,std::allocator<std::__hash_value_type<std::variant<md::MaterialRenderBatchKey,md::DynamicTypedRenderBatchKey,md::MaterialDecalRenderBatchKey>,md::RenderBatch *>>>::find<std::variant<md::MaterialRenderBatchKey,md::DynamicTypedRenderBatchKey,md::MaterialDecalRenderBatchKey>>(v455, *v454);
        size_t v458 = v457;
        if (v457)
        {
          int8x8_t v459 = *(int8x8_t *)(v448 + 136);
          v460 = v457[1];
          uint8x8_t v461 = (uint8x8_t)vcnt_s8(v459);
          v461.i16[0] = vaddlv_u8(v461);
          if (v461.u32[0] > 1uLL)
          {
            if ((unint64_t)v460 >= *(void *)&v459) {
              v460 = (uint64_t *)((unint64_t)v460 % *(void *)&v459);
            }
          }
          else
          {
            v460 = (uint64_t *)((*(void *)&v459 - 1) & (unint64_t)v460);
          }
          uint64_t v462 = *(uint64_t ***)(*v455 + 8 * (void)v460);
          do
          {
            uint64_t v463 = v462;
            uint64_t v462 = (uint64_t **)*v462;
          }
          while (v462 != v457);
          if (v463 == v598) {
            goto LABEL_793;
          }
          unint64_t v464 = v463[1];
          if (v461.u32[0] > 1uLL)
          {
            if ((unint64_t)v464 >= *(void *)&v459) {
              unint64_t v464 = (uint64_t *)((unint64_t)v464 % *(void *)&v459);
            }
          }
          else
          {
            unint64_t v464 = (uint64_t *)((unint64_t)v464 & (*(void *)&v459 - 1));
          }
          if (v464 != v460)
          {
LABEL_793:
            if (!*v457) {
              goto LABEL_794;
            }
            unint64_t v465 = (*v457)[1];
            if (v461.u32[0] > 1uLL)
            {
              if (v465 >= *(void *)&v459) {
                v465 %= *(void *)&v459;
              }
            }
            else
            {
              v465 &= *(void *)&v459 - 1;
            }
            if ((uint64_t *)v465 != v460) {
LABEL_794:
            }
              *(void *)(*v455 + 8 * (void)v460) = 0;
          }
          uint64_t v466 = *v457;
          if (*v457)
          {
            v467 = (uint64_t *)v466[1];
            if (v461.u32[0] > 1uLL)
            {
              if ((unint64_t)v467 >= *(void *)&v459) {
                v467 = (uint64_t *)((unint64_t)v467 % *(void *)&v459);
              }
            }
            else
            {
              v467 = (uint64_t *)((unint64_t)v467 & (*(void *)&v459 - 1));
            }
            if (v467 != v460)
            {
              *(void *)(*v455 + 8 * (void)v467) = v463;
              uint64_t v466 = *v457;
            }
          }
          *uint64_t v463 = v466;
          *size_t v457 = 0;
          --*(void *)(v448 + 152);
          uint64_t v468 = *((unsigned int *)v457 + 60);
          if (v468 != -1) {
            ((void (*)(uint64_t *, uint64_t **))*(&off_1EF58FCD0 + v468))(&v634, v457 + 2);
          }
          operator delete(v458);
        }
        size_t v469 = (void **)operator new(0x20uLL);
        *size_t v469 = &unk_1EF56B728;
        v469[1] = md::RenderBatchManager::destroyRenderable;
        v469[2] = 0;
        v469[3] = (void *)v448;
        uint64_t v619 = v469;
        uint64_t v470 = *(uint64_t **)(v456 + 320);
        v471 = *(uint64_t **)(v456 + 328);
        if (v470 == v471) {
          break;
        }
        do
        {
          uint64_t v634 = *v470;
          if (!v619) {
            goto LABEL_976;
          }
          (*((void (**)(void **, uint64_t *))*v619 + 6))(v619, &v634);
          ++v470;
        }
        while (v470 != v471);
        size_t v469 = v619;
        *(void *)(v456 + 328) = *(void *)(v456 + 320);
        if (v469 == (void **)&v616)
        {
          ((void (*)(void **))v616[4])(&v616);
          uint64_t v448 = v608;
          if (!*(void *)(v608 + 48)) {
            goto LABEL_815;
          }
LABEL_814:
          md::RenderBatch::~RenderBatch((md::RenderBatch *)v456);
          *(void *)unint64_t v456 = *(void *)(v448 + 72);
          *(void *)(v448 + 72) = v456;
          goto LABEL_815;
        }
        uint64_t v448 = v608;
        if (v469) {
          goto LABEL_812;
        }
LABEL_813:
        if (*(void *)(v448 + 48)) {
          goto LABEL_814;
        }
LABEL_815:
        unint64_t v472 = *(unint64_t **)(v448 + 16);
        int64_t v473 = (char *)v472 - (char *)(v454 + 1);
        if (v472 != v454 + 1) {
          memmove(v454, v454 + 1, (char *)v472 - (char *)(v454 + 1));
        }
        uint64_t v453 = (unint64_t *)((char *)v454 + v473);
        *(void *)(v448 + 16) = (char *)v454 + v473;
        if (v454 == (unint64_t *)((char *)v454 + v473))
        {
LABEL_821:
          *(unsigned char *)(v448 + 80) = 0;
          v474 = (char *)buf[3];
          goto LABEL_823;
        }
      }
      *(void *)(v456 + 328) = v470;
      uint64_t v448 = v608;
LABEL_812:
      (*((void (**)(void **))*v469 + 5))(v469);
      goto LABEL_813;
    }
    v474 = 0;
    *(unsigned char *)(v448 + 80) = 0;
LABEL_823:
    v475 = __p;
    v476 = v612;
    int64_t v477 = v612 - (unsigned char *)__p;
    uint64_t v603 = (v612 - (unsigned char *)__p) >> 3;
    unint64_t v478 = (unint64_t)&v474[v603];
    if ((unint64_t)&v474[v603] <= ((char *)v613 - (unsigned char *)__p) >> 3)
    {
      v480 = (unint64_t *)v612;
      goto LABEL_836;
    }
    if (v478 >> 61) {
LABEL_975:
    }
      abort();
    v479 = (char *)operator new(8 * v478);
    v480 = (unint64_t *)&v479[8 * v603];
    v481 = (char *)v480;
    if (v476 != (void *)v475)
    {
      unint64_t v482 = (char *)(v476 - 1) - v475;
      if (v482 < 0x58)
      {
        v481 = &v479[8 * v603];
        do
        {
LABEL_833:
          uint64_t v488 = *--v476;
          *((void *)v481 - 1) = v488;
          v481 -= 8;
        }
        while (v476 != (void *)v475);
        goto LABEL_834;
      }
      v481 = &v479[8 * v603];
      if ((unint64_t)((char *)v476 - v477 - v479) < 0x20) {
        goto LABEL_833;
      }
      uint64_t v483 = (v482 >> 3) + 1;
      unint64_t v484 = &v479[8 * v603 - 16];
      uint64_t v485 = (long long *)(v476 - 2);
      uint64_t v486 = v483 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v487 = *v485;
        *((_OWORD *)v484 - 1) = *(v485 - 1);
        *(_OWORD *)unint64_t v484 = v487;
        v484 -= 32;
        v485 -= 2;
        v486 -= 4;
      }
      while (v486);
      v481 = (char *)&v480[-(v483 & 0x3FFFFFFFFFFFFFFCLL)];
      v476 -= v483 & 0x3FFFFFFFFFFFFFFCLL;
      if (v483 != (v483 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_833;
      }
    }
LABEL_834:
    __p = v481;
    int v612 = &v479[8 * v603];
    v613 = (void (**)(char **))&v479[8 * v478];
    if (v475)
    {
      operator delete(v475);
      v480 = (unint64_t *)v612;
    }
LABEL_836:
    unint64_t v489 = buf[2];
    if (!buf[2])
    {
      v490 = v480;
LABEL_838:
      v491 = (char *)__p;
      unint64_t prime = vcvtps_u32_f32((float)((unint64_t)buf[3] + (unint64_t)v622[1]) / v623);
      if (prime == 1)
      {
        unint64_t prime = 2;
      }
      else if ((prime & (prime - 1)) != 0)
      {
        unint64_t prime = std::__next_prime(prime);
      }
      v509 = v621[1];
      if ((void *)prime > v621[1]) {
        goto LABEL_874;
      }
      if ((void *)prime < v621[1])
      {
        unint64_t v510 = vcvtps_u32_f32((float)(unint64_t)v622[1] / v623);
        if (v621[1] < (void *)3
          || (uint8x8_t v511 = (uint8x8_t)vcnt_s8((int8x8_t)v621[1]), v511.i16[0] = vaddlv_u8(v511), v511.u32[0] > 1uLL))
        {
          unint64_t v510 = std::__next_prime(v510);
        }
        else
        {
          uint64_t v512 = 1 << -(char)__clz(v510 - 1);
          if (v510 >= 2) {
            unint64_t v510 = v512;
          }
        }
        if (prime <= v510) {
          unint64_t prime = v510;
        }
        if (prime < (unint64_t)v509) {
LABEL_874:
        }
          std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)v621, prime);
      }
      for (i = (unint64_t *)&v491[8 * v603]; i != v490; ++i)
      {
        unint64_t v514 = *i;
        v616 = (void *)v514;
        uint64_t v515 = std::__hash_table<std::__hash_value_type<md::RenderBatch *,gm::Range<unsigned long>>,std::__unordered_map_hasher<md::RenderBatch *,std::__hash_value_type<md::RenderBatch *,gm::Range<unsigned long>>,std::hash<md::RenderBatch *>,std::equal_to<md::RenderBatch *>,true>,std::__unordered_map_equal<md::RenderBatch *,std::__hash_value_type<md::RenderBatch *,gm::Range<unsigned long>>,std::equal_to<md::RenderBatch *>,std::hash<md::RenderBatch *>,true>,std::allocator<std::__hash_value_type<md::RenderBatch *,gm::Range<unsigned long>>>>::__emplace_unique_key_args<md::RenderBatch *,std::piecewise_construct_t const&,std::tuple<md::RenderBatch * const&>,std::tuple<>>((uint64_t)v621, v514, &v616);
        v515[3] = v251;
        v515[4] = v251;
        v251 += *(void *)(v514 + 264);
      }
      uint64_t v517 = v641;
      long long v516 = (void (**)(char **))v642;
      int64_t v518 = v642 - (char *)v641;
      unint64_t v519 = (v642 - (char *)v641) >> 3;
      unint64_t v520 = v251 - v519;
      if (v251 <= v519)
      {
        if (v251 >= v519) {
          goto LABEL_911;
        }
        v531 = (char *)&v641[v251];
      }
      else
      {
        if (v520 > (v643 - v642) >> 3)
        {
          if (v251 >> 61) {
            goto LABEL_978;
          }
          unint64_t v521 = (v643 - (char *)v641) >> 2;
          if (v521 <= v251) {
            unint64_t v521 = v251;
          }
          if ((unint64_t)(v643 - (char *)v641) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v521 = 0x1FFFFFFFFFFFFFFFLL;
          }
          if (v521 >> 61) {
            goto LABEL_974;
          }
          unint64_t v522 = v521;
          uint64_t v523 = (char *)operator new(8 * v521);
          size_t v524 = 8 * v520;
          v525 = v523;
          v526 = &v523[8 * v519];
          size_t v604 = v524;
          bzero(v526, v524);
          uint64_t v527 = (char *)v516 - (char *)v517;
          if (v516 == v517)
          {
            uint64_t v517 = v516;
            uint64_t v529 = v526;
            size_t v530 = v604;
            goto LABEL_909;
          }
          unint64_t v528 = v527 - 8;
          if ((unint64_t)(v527 - 8) >= 0x58)
          {
            uint64_t v529 = v526;
            size_t v530 = v604;
            if ((unint64_t)((char *)v516 - v518 - v525) >= 0x20)
            {
              uint64_t v533 = (v528 >> 3) + 1;
              v534 = &v525[8 * v519 - 16];
              v535 = (long long *)(v516 - 2);
              uint64_t v536 = v533 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v537 = *v535;
                *((_OWORD *)v534 - 1) = *(v535 - 1);
                *(_OWORD *)v534 = v537;
                v534 -= 32;
                v535 -= 2;
                v536 -= 4;
              }
              while (v536);
              uint64_t v529 = &v526[-8 * (v533 & 0x3FFFFFFFFFFFFFFCLL)];
              v516 -= v533 & 0x3FFFFFFFFFFFFFFCLL;
              if (v533 == (v533 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_909;
              }
            }
          }
          else
          {
            uint64_t v529 = v526;
            size_t v530 = v604;
          }
          do
          {
            uint64_t v538 = (uint64_t)*--v516;
            *((void *)v529 - 1) = v538;
            v529 -= 8;
          }
          while (v516 != v517);
          uint64_t v517 = v641;
LABEL_909:
          unint64_t v641 = (void (**)(char **))v529;
          v642 = &v526[v530];
          unint64_t v643 = &v525[8 * v522];
          if (v517) {
            operator delete(v517);
          }
LABEL_911:
          v540 = (char *)v637;
          v539 = v638;
          unint64_t v541 = (v638 - (char *)v637) >> 3;
          unint64_t v542 = v251 - v541;
          if (v251 <= v541)
          {
            v248 = v595;
            if (v251 >= v541) {
              goto LABEL_944;
            }
            uint64_t v560 = (char *)&v637[v251];
            goto LABEL_943;
          }
          if (v542 > (v639 - v638) >> 3)
          {
            if (!(v251 >> 61))
            {
              unint64_t v543 = (v639 - (char *)v637) >> 2;
              if (v543 <= v251) {
                unint64_t v543 = v251;
              }
              if ((unint64_t)(v639 - (char *)v637) >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v544 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v544 = v543;
              }
              if (v544 >> 61) {
                goto LABEL_974;
              }
              unint64_t v545 = operator new(8 * v544);
              uint64_t v546 = &v545[8 * v541];
              uint64_t v547 = v546;
              uint64_t v548 = (v542 - 1) & 0x1FFFFFFFFFFFFFFFLL;
              if (v548)
              {
                uint64_t v549 = (v548 + 1) & 0x3FFFFFFFFFFFFFFELL;
                unint64_t v550 = v546 + 8;
                uint64_t v551 = v549;
                do
                {
                  *(v550 - 1) = 0xFFFFFFFF00000000;
                  *unint64_t v550 = 0xFFFFFFFF00000000;
                  v550 += 2;
                  v551 -= 2;
                }
                while (v551);
                if (v548 + 1 == v549) {
                  goto LABEL_926;
                }
                uint64_t v547 = &v546[8 * v549];
              }
              do
              {
                *(void *)uint64_t v547 = 0xFFFFFFFF00000000;
                v547 += 8;
              }
              while (v547 != &v545[8 * v251]);
LABEL_926:
              if (v539 != v540)
              {
                unint64_t v552 = v539 - v540 - 8;
                if (v552 < 0x58) {
                  goto LABEL_984;
                }
                if ((unint64_t)(v540 - v545) < 0x20) {
                  goto LABEL_984;
                }
                uint64_t v553 = (v552 >> 3) + 1;
                unint64_t v554 = &v545[8 * v541 - 16];
                uint64_t v555 = v539 - 16;
                uint64_t v556 = v553 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v557 = *(_OWORD *)v555;
                  *(v554 - 1) = *((_OWORD *)v555 - 1);
                  *unint64_t v554 = v557;
                  v554 -= 2;
                  v555 -= 32;
                  v556 -= 4;
                }
                while (v556);
                v546 -= 8 * (v553 & 0x3FFFFFFFFFFFFFFCLL);
                v539 -= 8 * (v553 & 0x3FFFFFFFFFFFFFFCLL);
                if (v553 != (v553 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_984:
                  do
                  {
                    uint64_t v558 = *((void *)v539 - 1);
                    v539 -= 8;
                    *((void *)v546 - 1) = v558;
                    v546 -= 8;
                  }
                  while (v539 != v540);
                }
              }
              v559 = v637;
              uint64_t v637 = (void (**)(char **))v546;
              unint64_t v638 = &v545[8 * v251];
              unint64_t v639 = &v545[8 * v544];
              v248 = v595;
              if (v559) {
                operator delete(v559);
              }
LABEL_944:
              unint64_t v564 = (void *)gdc::Registry::storage<md::components::MeshInstance>(v438);
              unint64_t v565 = (unint64_t *)v564[7];
              v566 = (unint64_t *)v564[8];
              if (v565 == v566)
              {
                char v250 = 1;
              }
              else
              {
                uint64_t v567 = (void (*)(char **))v564[10];
                do
                {
                  unint64_t v570 = *v565;
                  uint64_t v571 = std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>::find<gdc::Entity>((void *)(v608 + 168), *v565);
                  if (v571)
                  {
                    unint64_t v572 = v571[3];
                    v616 = (void *)v572;
                    if (v572)
                    {
                      if (buf[1])
                      {
                        unint64_t v573 = 0x9DDFEA08EB382D69 * (((8 * v572) + 8) ^ HIDWORD(v572));
                        unint64_t v574 = 0x9DDFEA08EB382D69 * (HIDWORD(v572) ^ (v573 >> 47) ^ v573);
                        unint64_t v575 = 0x9DDFEA08EB382D69 * (v574 ^ (v574 >> 47));
                        uint8x8_t v576 = (uint8x8_t)vcnt_s8((int8x8_t)buf[1]);
                        v576.i16[0] = vaddlv_u8(v576);
                        if (v576.u32[0] > 1uLL)
                        {
                          unint64_t v577 = v575;
                          if ((void *)v575 >= buf[1]) {
                            unint64_t v577 = v575 % (unint64_t)buf[1];
                          }
                        }
                        else
                        {
                          unint64_t v577 = ((unint64_t)buf[1] - 1) & v575;
                        }
                        uint64_t v578 = (void *)*((void *)buf[0] + v577);
                        if (v578)
                        {
                          uint64_t v579 = (void *)*v578;
                          if (v579)
                          {
                            if (v576.u32[0] < 2uLL)
                            {
                              while (1)
                              {
                                uint64_t v581 = v579[1];
                                if (v575 == v581)
                                {
                                  if (v579[2] == v572) {
                                    goto LABEL_946;
                                  }
                                }
                                else if ((v581 & ((uint64_t)buf[1] - 1)) != v577)
                                {
                                  goto LABEL_947;
                                }
                                uint64_t v579 = (void *)*v579;
                                if (!v579) {
                                  goto LABEL_947;
                                }
                              }
                            }
                            do
                            {
                              unint64_t v580 = v579[1];
                              if (v575 == v580)
                              {
                                if (v579[2] == v572)
                                {
LABEL_946:
                                  v568 = std::__hash_table<std::__hash_value_type<md::RenderBatch *,gm::Range<unsigned long>>,std::__unordered_map_hasher<md::RenderBatch *,std::__hash_value_type<md::RenderBatch *,gm::Range<unsigned long>>,std::hash<md::RenderBatch *>,std::equal_to<md::RenderBatch *>,true>,std::__unordered_map_equal<md::RenderBatch *,std::__hash_value_type<md::RenderBatch *,gm::Range<unsigned long>>,std::equal_to<md::RenderBatch *>,std::hash<md::RenderBatch *>,true>,std::allocator<std::__hash_value_type<md::RenderBatch *,gm::Range<unsigned long>>>>::__emplace_unique_key_args<md::RenderBatch *,std::piecewise_construct_t const&,std::tuple<md::RenderBatch * const&>,std::tuple<>>((uint64_t)v621, v572, &v616);
                                  uint64_t v569 = v568[4];
                                  v568[4] = v569 + 1;
                                  v569 *= 8;
                                  *(void (**)(char **))((char *)v641 + v569) = v567;
                                  *(void (**)(char **))((char *)v637 + v569) = (void (*)(char **))v570;
                                  break;
                                }
                              }
                              else
                              {
                                if ((void *)v580 >= buf[1]) {
                                  v580 %= (unint64_t)buf[1];
                                }
                                if (v580 != v577) {
                                  break;
                                }
                              }
                              uint64_t v579 = (void *)*v579;
                            }
                            while (v579);
                          }
                        }
                      }
                    }
                  }
LABEL_947:
                  uint64_t v567 = (void (*)(char **))((char *)v567 + 112);
                  ++v565;
                  char v250 = 1;
                }
                while (v565 != v566);
              }
              goto LABEL_737;
            }
LABEL_978:
            abort();
          }
          uint64_t v560 = &v638[8 * v542];
          v248 = v595;
          if (((v542 - 1) & 0x1FFFFFFFFFFFFFFFLL) != 0)
          {
            uint64_t v561 = ((v542 - 1) & 0x1FFFFFFFFFFFFFFFLL) + 1;
            uint64_t v562 = v638 + 8;
            uint64_t v563 = v561 & 0x3FFFFFFFFFFFFFFELL;
            do
            {
              *(v562 - 1) = 0xFFFFFFFF00000000;
              *uint64_t v562 = 0xFFFFFFFF00000000;
              v562 += 2;
              v563 -= 2;
            }
            while (v563);
            if (v561 == (v561 & 0x3FFFFFFFFFFFFFFELL)) {
              goto LABEL_943;
            }
            v539 += 8 * (v561 & 0x3FFFFFFFFFFFFFFELL);
          }
          do
          {
            *(void *)v539 = 0xFFFFFFFF00000000;
            v539 += 8;
          }
          while (v539 != v560);
LABEL_943:
          unint64_t v638 = v560;
          goto LABEL_944;
        }
        size_t v532 = v520;
        bzero(v642, v532 * 8);
        v531 = (char *)&v516[v532];
      }
      v642 = v531;
      goto LABEL_911;
    }
    while (v480 < (unint64_t *)v613)
    {
      unint64_t *v480 = v489[2];
      v490 = v480 + 1;
LABEL_841:
      int v612 = (char *)v490;
      unint64_t v489 = (void *)*v489;
      v480 = v490;
      if (!v489) {
        goto LABEL_838;
      }
    }
    long long v493 = (unint64_t *)__p;
    int64_t v494 = (char *)v480 - (unsigned char *)__p;
    uint64_t v495 = ((char *)v480 - (unsigned char *)__p) >> 3;
    unint64_t v496 = v495 + 1;
    if ((unint64_t)(v495 + 1) >> 61) {
      goto LABEL_975;
    }
    uint64_t v497 = (char *)v613 - (unsigned char *)__p;
    if (((char *)v613 - (unsigned char *)__p) >> 2 > v496) {
      unint64_t v496 = v497 >> 2;
    }
    if ((unint64_t)v497 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v498 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v498 = v496;
    }
    if (v498)
    {
      if (v498 >> 61) {
        goto LABEL_974;
      }
      uint64_t v499 = operator new(8 * v498);
    }
    else
    {
      uint64_t v499 = 0;
    }
    v500 = (unint64_t *)&v499[8 * v495];
    unint64_t *v500 = v489[2];
    v490 = v500 + 1;
    if (v480 == v493)
    {
      long long v493 = v480;
      goto LABEL_859;
    }
    unint64_t v501 = (char *)(v480 - 1) - (char *)v493;
    if (v501 >= 0x168)
    {
      if (&v499[v494 - 8 - (v501 & 0xFFFFFFFFFFFFFFF8)] > &v499[v494 - 8])
      {
        v502 = v480;
      }
      else if ((unint64_t *)((char *)v480 - (v501 & 0xFFFFFFFFFFFFFFF8) - 8) > v480 - 1)
      {
        v502 = v480;
      }
      else if ((unint64_t)((char *)v480 - v499 - v494) >= 0x20)
      {
        uint64_t v504 = (v501 >> 3) + 1;
        v502 = &v480[-(v504 & 0x3FFFFFFFFFFFFFFCLL)];
        v505 = &v499[8 * v495 - 16];
        v506 = v480 - 2;
        uint64_t v507 = v504 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v508 = *(_OWORD *)v506;
          *(v505 - 1) = *((_OWORD *)v506 - 1);
          _OWORD *v505 = v508;
          v505 -= 2;
          v506 -= 4;
          v507 -= 4;
        }
        while (v507);
        v500 -= v504 & 0x3FFFFFFFFFFFFFFCLL;
        if (v504 == (v504 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_859;
        }
      }
      else
      {
        v502 = v480;
      }
    }
    else
    {
      v502 = v480;
    }
    do
    {
      unint64_t v503 = *--v502;
      *--v500 = v503;
    }
    while (v502 != v493);
    long long v493 = (unint64_t *)__p;
LABEL_859:
    __p = v500;
    int v612 = (char *)v490;
    v613 = (void (**)(char **))&v499[8 * v498];
    if (v493) {
      operator delete(v493);
    }
    goto LABEL_841;
  }
  char v250 = 0;
LABEL_376:
  uint64_t v252 = *((void *)a2 + 92);
  v253 = (void **)operator new(0x30uLL);
  _DWORD *v253 = &unk_1EF574AA8;
  v253[1] = &__p;
  v253[2] = v621;
  v253[3] = &v641;
  v253[4] = &v637;
  v253[5] = this;
  uint64_t v619 = v253;
  uint64_t v634 = 0;
  unint64_t v635 = 0;
  (*(void (**)(void, void **, uint64_t *))(**(void **)(v252 + 32) + 16))(*(void *)(v252 + 32), &v616, &v634);
  v254 = v635;
  if (v635 && !atomic_fetch_add(&v635->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v254->__on_zero_shared)(v254);
    std::__shared_weak_count::__release_weak(v254);
  }
  if (v619 == (void **)&v616)
  {
    ((void (*)(void **))v616[4])(&v616);
  }
  else if (v619)
  {
    (*((void (**)(void))*v619 + 5))();
  }
  if (v637)
  {
    unint64_t v638 = (char *)v637;
    operator delete(v637);
  }
  if (v641)
  {
    v642 = (char *)v641;
    operator delete(v641);
  }
  if (__p)
  {
    int v612 = (char *)__p;
    operator delete(__p);
  }
  unint64_t v255 = v622[0];
  if (v622[0])
  {
    do
    {
      v256 = (void *)*v255;
      operator delete(v255);
      unint64_t v255 = v256;
    }
    while (v256);
  }
  uint64_t v257 = v621[0];
  v621[0] = 0;
  if (v257) {
    operator delete(v257);
  }
  v258 = buf[2];
  if (buf[2])
  {
    do
    {
      v259 = (void *)*v258;
      operator delete(v258);
      v258 = v259;
    }
    while (v259);
  }
  uint64_t v260 = buf[0];
  buf[0] = 0;
  if (v260) {
    operator delete(v260);
  }
  if (GEOGetVectorKitPerformanceDetailsLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceDetailsLog_onceToken, &__block_literal_global_21);
  }
  long long v261 = (id)GEOGetVectorKitPerformanceDetailsLog_log;
  int v262 = v261;
  os_signpost_id_t v263 = *((void *)a2 + 10);
  if (v263 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v261))
  {
    LOWORD(buf[0]) = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v262, OS_SIGNPOST_INTERVAL_END, v263, "ProcessChangedBatches", "", (uint8_t *)buf, 2u);
  }

  if (!((*((unsigned char *)this + 416) != 0) | v250 & 1)
    && *(void *)(*((void *)this + 17) + 432) == *(void *)(*((void *)this + 17) + 440))
  {
    goto LABEL_679;
  }
  if (GEOGetVectorKitPerformanceDetailsLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceDetailsLog_onceToken, &__block_literal_global_21);
  }
  v264 = (id)GEOGetVectorKitPerformanceDetailsLog_log;
  unint64_t v265 = v264;
  os_signpost_id_t v266 = *((void *)a2 + 10);
  if (v266 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v264))
  {
    LOWORD(buf[0]) = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v265, OS_SIGNPOST_INTERVAL_BEGIN, v266, "GatherRenderables", "", (uint8_t *)buf, 2u);
  }

  *((unsigned char *)this + 417) = 1;
  if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
    dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
  }
  uint64_t v267 = GEOGetVectorKitMeshRenderableLogicLog(void)::log;
  if (os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf[0]) = 0;
    _os_log_impl(&dword_1A1780000, v267, OS_LOG_TYPE_DEBUG, "Gathered renderables for active registries", (uint8_t *)buf, 2u);
  }
  md::MeshRenderableBuilder::MeshRenderableBuilder(buf, *(void *)a3, *((void *)a3 + 1), (void *)a3 + 2);
  uint64_t v268 = *((void *)this + 17);
  v269 = *(int8x8_t ***)(v268 + 384);
  uint64_t v270 = *(int8x8_t ***)(v268 + 392);
  if (v269 == v270) {
    goto LABEL_664;
  }
  long long v271 = (uint64_t *)((char *)this + 296);
  while (2)
  {
    unint64_t v276 = *v269;
    int8x8_t v277 = (*v269)[1];
    if (!*(void *)&v277) {
      goto LABEL_419;
    }
    uint8x8_t v278 = (uint8x8_t)vcnt_s8(v277);
    v278.i16[0] = vaddlv_u8(v278);
    if (v278.u32[0] > 1uLL)
    {
      unint64_t v279 = 0xCA93DB2C2ACE8387;
      if (*(void *)&v277 <= 0xCA93DB2C2ACE8387) {
        unint64_t v279 = 0xCA93DB2C2ACE8387 % *(void *)&v277;
      }
    }
    else
    {
      unint64_t v279 = (*(void *)&v277 - 1) & 0xCA93DB2C2ACE8387;
    }
    v280 = *(void **)(*(void *)v276 + 8 * v279);
    if (!v280) {
      goto LABEL_419;
    }
    v281 = (void *)*v280;
    if (!v281) {
      goto LABEL_419;
    }
    if (v278.u32[0] < 2uLL)
    {
      uint64_t v282 = *(void *)&v277 - 1;
      while (1)
      {
        uint64_t v284 = v281[1];
        if (v284 == 0xCA93DB2C2ACE8387)
        {
          if (v281[2] == 0xCA93DB2C2ACE8387) {
            goto LABEL_441;
          }
        }
        else if ((v284 & v282) != v279)
        {
          goto LABEL_419;
        }
        v281 = (void *)*v281;
        if (!v281) {
          goto LABEL_419;
        }
      }
    }
    while (1)
    {
      unint64_t v283 = v281[1];
      if (v283 == 0xCA93DB2C2ACE8387) {
        break;
      }
      if (v283 >= *(void *)&v277) {
        v283 %= *(void *)&v277;
      }
      if (v283 != v279) {
        goto LABEL_419;
      }
LABEL_430:
      v281 = (void *)*v281;
      if (!v281) {
        goto LABEL_419;
      }
    }
    if (v281[2] != 0xCA93DB2C2ACE8387) {
      goto LABEL_430;
    }
LABEL_441:
    uint64_t v285 = v281[5];
    if (*(void *)(v285 + 8) != 0xCA93DB2C2ACE8387) {
      goto LABEL_419;
    }
    BOOL v286 = *(int8x8_t **)(v285 + 32);
    if (!v286) {
      goto LABEL_419;
    }
    v594 = v270;
    v597 = v269;
    unint64_t v588 = *v269;
    LOWORD(v621[0]) = v276[5].i16[0];
    v591 = v271;
    unint64_t v287 = std::__hash_table<std::__hash_value_type<unsigned short,std::vector<md::MeshRenderable *>>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,std::vector<md::MeshRenderable *>>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,std::vector<md::MeshRenderable *>>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,std::vector<md::MeshRenderable *>>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short &&>,std::tuple<>>(v271, (unsigned __int16)v621[0], v621);
    v287[4] = v287[3];
    uint64_t v288 = *((void *)a2 + 10);
    uint64_t v637 = (void (**)(char **))&unk_1EF574A60;
    uint64_t v640 = (void **)&v637;
    v632[0] = v288;
    if (v286[10].i8[0]) {
      goto LABEL_444;
    }
    int8x8_t v293 = v286[1];
    if (*(void *)&v286[2] == *(void *)&v293) {
      goto LABEL_444;
    }
    uint64_t v294 = 0;
    uint64_t v583 = v286 + 13;
    uint64_t v601 = v286;
    while (2)
    {
      unint64_t v295 = *(void *)(*(void *)&v293 + 8 * v294);
      int8x8_t v296 = v286[12];
      uint64_t v606 = v294;
      if (!*(void *)&v296) {
        goto LABEL_534;
      }
      unint64_t v297 = 0x9DDFEA08EB382D69 * (((8 * v295) + 8) ^ HIDWORD(v295));
      unint64_t v298 = 0x9DDFEA08EB382D69 * (HIDWORD(v295) ^ (v297 >> 47) ^ v297);
      unint64_t v299 = 0x9DDFEA08EB382D69 * (v298 ^ (v298 >> 47));
      uint8x8_t v300 = (uint8x8_t)vcnt_s8(v296);
      v300.i16[0] = vaddlv_u8(v300);
      if (v300.u32[0] > 1uLL)
      {
        unint64_t v301 = v299;
        if (v299 >= *(void *)&v296) {
          unint64_t v301 = v299 % *(void *)&v296;
        }
      }
      else
      {
        unint64_t v301 = v299 & (*(void *)&v296 - 1);
      }
      uint8x8_t v302 = *(int8x8_t ***)(*(void *)&v286[11] + 8 * v301);
      if (!v302) {
        goto LABEL_534;
      }
      uint64_t v303 = *v302;
      if (!*v302) {
        goto LABEL_534;
      }
      if (v300.u32[0] < 2uLL)
      {
        uint64_t v304 = *(void *)&v296 - 1;
        while (1)
        {
          int8x8_t v306 = v303[1];
          if (*(void *)&v306 == v299)
          {
            if (*(void *)&v303[2] == v295) {
              goto LABEL_472;
            }
          }
          else if ((*(void *)&v306 & v304) != v301)
          {
            goto LABEL_534;
          }
          uint64_t v303 = (int8x8_t *)*v303;
          if (!v303) {
            goto LABEL_534;
          }
        }
      }
      while (2)
      {
        unint64_t v305 = (unint64_t)v303[1];
        if (v305 != v299)
        {
          if (v305 >= *(void *)&v296) {
            v305 %= *(void *)&v296;
          }
          if (v305 != v301) {
            goto LABEL_534;
          }
          goto LABEL_461;
        }
        if (*(void *)&v303[2] != v295)
        {
LABEL_461:
          uint64_t v303 = (int8x8_t *)*v303;
          if (!v303) {
            goto LABEL_534;
          }
          continue;
        }
        break;
      }
LABEL_472:
      if (*(void *)(v295 + 320) == *(void *)(v295 + 328)) {
        goto LABEL_500;
      }
      v616 = &unk_1EF573E90;
      size_t v617 = v632;
      uint64_t v619 = (void **)&v616;
      __p = &unk_1EF573ED8;
      int v612 = (char *)v632;
      p_p = &__p;
      v622[1] = v621;
      v621[0] = &unk_1EF573ED8;
      v621[1] = v632;
      if (GEOGetVectorKitPerformanceDetailsLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitPerformanceDetailsLog_onceToken, &__block_literal_global_21);
      }
      uint64_t v307 = (id)GEOGetVectorKitPerformanceDetailsLog_log;
      v308 = v307;
      os_signpost_id_t v309 = *v617;
      if (*v617 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v307))
      {
        LOWORD(v634) = 0;
        _os_signpost_emit_with_name_impl(&dword_1A1780000, v308, OS_SIGNPOST_INTERVAL_BEGIN, v309, "DestroyRenderables", "", (uint8_t *)&v634, 2u);
      }

      if (p_p == &__p)
      {
        (*((void (**)(void **))__p + 4))(&__p);
      }
      else if (p_p)
      {
        (*((void (**)(void))*p_p + 5))();
      }
      if (v619 == (void **)&v616)
      {
        ((void (*)(void **))v616[4])(&v616);
      }
      else if (v619)
      {
        (*((void (**)(void))*v619 + 5))();
      }
      int v644 = 0;
      v310 = (void **)operator new(0x20uLL);
      *v310 = &unk_1EF56B728;
      v310[1] = md::RenderBatchManager::destroyRenderable;
      v310[2] = 0;
      v310[3] = v286;
      int v644 = v310;
      uint64_t v311 = *(void *)(v295 + 320);
      uint64_t v312 = *(void *)(v295 + 328);
      if (v311 == v312)
      {
        *(void *)(v295 + 328) = v311;
        goto LABEL_495;
      }
      for (uint64_t j = v311 + 8; ; j += 8)
      {
        uint64_t v634 = *(void *)(j - 8);
        if (!v310) {
          goto LABEL_976;
        }
        (*((void (**)(void **, uint64_t *))*v310 + 6))(v310, &v634);
        if (j == v312) {
          break;
        }
        v310 = v644;
      }
      v310 = v644;
      *(void *)(v295 + 328) = *(void *)(v295 + 320);
      if (v310 != (void **)&v641)
      {
        if (!v310)
        {
LABEL_496:
          unint64_t v314 = v622[1];
          if (v622[1]) {
            goto LABEL_497;
          }
LABEL_976:
          std::__throw_bad_function_call[abi:nn180100]();
LABEL_981:
          __break(1u);
          return;
        }
LABEL_495:
        (*((void (**)(void **))*v310 + 5))(v310);
        goto LABEL_496;
      }
      v641[4]((char **)&v641);
      unint64_t v314 = v622[1];
      if (!v622[1]) {
        goto LABEL_976;
      }
LABEL_497:
      (*(void (**)(void *))(*(void *)v314 + 48))(v314);
      if (v622[1] == v621)
      {
        (*((void (**)(void **))v621[0] + 4))(v621);
        if (*(unsigned char *)(v295 + 312)) {
          goto LABEL_501;
        }
      }
      else
      {
        if (v622[1]) {
          (*(void (**)(void))(*(void *)v622[1] + 40))();
        }
LABEL_500:
        if (*(unsigned char *)(v295 + 312))
        {
LABEL_501:
          v315 = (void *)v632[0];
          unint64_t v316 = (void **)operator new(0x28uLL);
          unint64_t v317 = (void (**)(void))&unk_1EF573F20;
          *unint64_t v316 = &unk_1EF573F20;
          v316[1] = v286;
          v316[2] = buf;
          v316[3] = v315;
          v316[4] = (void *)v295;
          v622[1] = v316;
          if (!*(unsigned char *)(v295 + 312)) {
            goto LABEL_504;
          }
          if (*(void *)(v295 + 320) == *(void *)(v295 + 328)
            && (uint64_t v348 = *(void *)(v295 + 288), v585 = *(void *)(v295 + 296), v348 != v585))
          {
            do
            {
              if (!v622[1]) {
                goto LABEL_976;
              }
              uint64_t v350 = (*(uint64_t (**)(void *, uint64_t))(*(void *)v622[1] + 48))(v622[1], v348);
              uint64_t v351 = v350;
              v353 = *(uint64_t **)(v295 + 328);
              unint64_t v352 = *(void *)(v295 + 336);
              if ((unint64_t)v353 < v352)
              {
                uint64_t *v353 = v350;
                long long v349 = v353 + 1;
                BOOL v286 = v601;
              }
              else
              {
                unint64_t v354 = *(char **)(v295 + 320);
                uint64_t v355 = ((char *)v353 - v354) >> 3;
                unint64_t v356 = v355 + 1;
                if ((unint64_t)(v355 + 1) >> 61) {
                  abort();
                }
                uint64_t v357 = v352 - (void)v354;
                if (v357 >> 2 > v356) {
                  unint64_t v356 = v357 >> 2;
                }
                if ((unint64_t)v357 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v358 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v358 = v356;
                }
                if (v358)
                {
                  if (v358 >> 61) {
                    goto LABEL_974;
                  }
                  unint64_t v359 = v358;
                  unint64_t v360 = (char *)operator new(8 * v358);
                  unint64_t v358 = v359;
                }
                else
                {
                  unint64_t v360 = 0;
                }
                v361 = (uint64_t *)&v360[8 * v355];
                uint64_t *v361 = v351;
                long long v349 = v361 + 1;
                if (v353 != (uint64_t *)v354)
                {
                  unint64_t v362 = (char *)(v353 - 1) - v354;
                  if (v362 < 0x58) {
                    goto LABEL_985;
                  }
                  if ((unint64_t)(v354 - v360) < 0x20) {
                    goto LABEL_985;
                  }
                  uint64_t v363 = (v362 >> 3) + 1;
                  v364 = &v360[8 * v355 - 16];
                  v365 = v353 - 2;
                  uint64_t v366 = v363 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    long long v367 = *(_OWORD *)v365;
                    *((_OWORD *)v364 - 1) = *((_OWORD *)v365 - 1);
                    *(_OWORD *)v364 = v367;
                    v364 -= 32;
                    v365 -= 4;
                    v366 -= 4;
                  }
                  while (v366);
                  v361 -= v363 & 0x3FFFFFFFFFFFFFFCLL;
                  v353 -= v363 & 0x3FFFFFFFFFFFFFFCLL;
                  if (v363 != (v363 & 0x3FFFFFFFFFFFFFFCLL))
                  {
LABEL_985:
                    do
                    {
                      uint64_t v368 = *--v353;
                      *--v361 = v368;
                    }
                    while (v353 != (uint64_t *)v354);
                  }
                  v353 = *(uint64_t **)(v295 + 320);
                }
                *(void *)(v295 + 320) = v361;
                *(void *)(v295 + 328) = v349;
                *(void *)(v295 + 336) = &v360[8 * v358];
                BOOL v286 = v601;
                if (v353) {
                  operator delete(v353);
                }
              }
              *(void *)(v295 + 328) = v349;
              v348 += 224;
            }
            while (v348 != v585);
            unint64_t v316 = (void **)v622[1];
            if (v622[1] == v621)
            {
              (*((void (**)(void **))v621[0] + 4))(v621);
            }
            else if (v622[1])
            {
              goto LABEL_503;
            }
          }
          else
          {
LABEL_503:
            unint64_t v317 = (void (**)(void))*v316;
LABEL_504:
            v317[5]();
          }
        }
      }
      int8x8_t v318 = v286[12];
      unint64_t v319 = (unint64_t)v303[1];
      uint8x8_t v320 = (uint8x8_t)vcnt_s8(v318);
      v320.i16[0] = vaddlv_u8(v320);
      if (v320.u32[0] > 1uLL)
      {
        if (v319 >= *(void *)&v318) {
          v319 %= *(void *)&v318;
        }
      }
      else
      {
        v319 &= *(void *)&v318 - 1;
      }
      int8x8_t v321 = v286[11];
      v322 = *(int8x8_t **)(*(void *)&v321 + 8 * v319);
      do
      {
        uint64_t v323 = v322;
        v322 = (int8x8_t *)*v322;
      }
      while (v322 != v303);
      if (v323 == v583) {
        goto LABEL_524;
      }
      unint64_t v324 = (unint64_t)v323[1];
      if (v320.u32[0] > 1uLL)
      {
        if (v324 >= *(void *)&v318) {
          v324 %= *(void *)&v318;
        }
      }
      else
      {
        v324 &= *(void *)&v318 - 1;
      }
      if (v324 != v319)
      {
LABEL_524:
        if (!*(void *)v303) {
          goto LABEL_525;
        }
        unint64_t v325 = *(void *)(*(void *)v303 + 8);
        if (v320.u32[0] > 1uLL)
        {
          if (v325 >= *(void *)&v318) {
            v325 %= *(void *)&v318;
          }
        }
        else
        {
          v325 &= *(void *)&v318 - 1;
        }
        if (v325 != v319) {
LABEL_525:
        }
          *(void *)(*(void *)&v321 + 8 * v319) = 0;
      }
      int8x8_t v326 = *v303;
      if (*v303)
      {
        unint64_t v327 = *(void *)(*(void *)&v326 + 8);
        if (v320.u32[0] > 1uLL)
        {
          if (v327 >= *(void *)&v318) {
            v327 %= *(void *)&v318;
          }
        }
        else
        {
          v327 &= *(void *)&v318 - 1;
        }
        if (v327 != v319)
        {
          *(void *)(*(void *)&v286[11] + 8 * v327) = v323;
          int8x8_t v326 = *v303;
        }
      }
      *uint64_t v323 = v326;
      --*(void *)&v286[14];
      operator delete(v303);
LABEL_534:
      long long v328 = *(void ***)(v295 + 320);
      uint64_t v329 = *(void ***)(v295 + 328);
      while (v328 != v329)
      {
        uint64_t v331 = *v328;
        if (!v640 || (v621[0] = *v328, (*((unsigned int (**)(void **, void **))*v640 + 6))(v640, v621)))
        {
          uint64_t v333 = (char *)v287[4];
          unint64_t v332 = v287[5];
          if ((unint64_t)v333 < v332)
          {
            *(void *)uint64_t v333 = v331;
            v330 = v333 + 8;
          }
          else
          {
            uint64_t v334 = (char *)v287[3];
            uint64_t v335 = (v333 - v334) >> 3;
            unint64_t v336 = v335 + 1;
            if ((unint64_t)(v335 + 1) >> 61) {
              abort();
            }
            uint64_t v337 = v332 - (void)v334;
            if (v337 >> 2 > v336) {
              unint64_t v336 = v337 >> 2;
            }
            if ((unint64_t)v337 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v338 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v338 = v336;
            }
            if (v338)
            {
              if (v338 >> 61) {
                goto LABEL_974;
              }
              uint64_t v339 = (char *)operator new(8 * v338);
            }
            else
            {
              uint64_t v339 = 0;
            }
            v340 = &v339[8 * v335];
            *(void *)v340 = v331;
            v330 = v340 + 8;
            if (v333 != v334)
            {
              unint64_t v341 = v333 - 8 - v334;
              if (v341 < 0x58) {
                goto LABEL_986;
              }
              if ((unint64_t)(v334 - v339) < 0x20) {
                goto LABEL_986;
              }
              uint64_t v342 = (v341 >> 3) + 1;
              v343 = &v339[8 * v335 - 16];
              v344 = (long long *)(v333 - 16);
              uint64_t v345 = v342 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v346 = *v344;
                *((_OWORD *)v343 - 1) = *(v344 - 1);
                *(_OWORD *)v343 = v346;
                v343 -= 32;
                v344 -= 2;
                v345 -= 4;
              }
              while (v345);
              v340 -= 8 * (v342 & 0x3FFFFFFFFFFFFFFCLL);
              v333 -= 8 * (v342 & 0x3FFFFFFFFFFFFFFCLL);
              if (v342 != (v342 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_986:
                do
                {
                  uint64_t v347 = *((void *)v333 - 1);
                  v333 -= 8;
                  *((void *)v340 - 1) = v347;
                  v340 -= 8;
                }
                while (v333 != v334);
              }
              uint64_t v333 = (char *)v287[3];
            }
            v287[3] = v340;
            v287[4] = v330;
            v287[5] = &v339[8 * v338];
            if (v333) {
              operator delete(v333);
            }
          }
          v287[4] = v330;
        }
        ++v328;
      }
      BOOL v286 = v601;
      uint64_t v294 = v606 + 1;
      int8x8_t v293 = v601[1];
      if (v606 + 1 < (unint64_t)((uint64_t)(*(void *)&v601[2] - *(void *)&v293) >> 3)) {
        continue;
      }
      break;
    }
    if (v640 == (void **)&v637)
    {
LABEL_444:
      v637[4]((char **)&v637);
      goto LABEL_445;
    }
    if (v640) {
      (*((void (**)(void))*v640 + 5))();
    }
LABEL_445:
    int8x8_t v289 = *(int8x8_t *)((char *)this + 384);
    if (!*(void *)&v289) {
      goto LABEL_415;
    }
    unint64_t v290 = v588[5].u16[0];
    uint8x8_t v291 = (uint8x8_t)vcnt_s8(v289);
    v291.i16[0] = vaddlv_u8(v291);
    if (v291.u32[0] > 1uLL)
    {
      unint64_t v292 = v588[5].u16[0];
      if (*(void *)&v289 <= v290) {
        unint64_t v292 = v290 % *(void *)&v289;
      }
    }
    else
    {
      unint64_t v292 = (v289.i32[0] - 1) & v290;
    }
    v369 = *(uint64_t ****)(*((void *)this + 47) + 8 * v292);
    if (!v369) {
      goto LABEL_415;
    }
    uint64_t v370 = *v369;
    if (!v370) {
      goto LABEL_415;
    }
    if (v291.u32[0] < 2uLL)
    {
      uint64_t v371 = *(void *)&v289 - 1;
      while (1)
      {
        unint64_t v373 = v370[1];
        if (v373 == (uint64_t *)v290)
        {
          if (*((unsigned __int16 *)v370 + 8) == v290) {
            goto LABEL_615;
          }
        }
        else if (((unint64_t)v373 & v371) != v292)
        {
          goto LABEL_415;
        }
        uint64_t v370 = (uint64_t **)*v370;
        if (!v370) {
          goto LABEL_415;
        }
      }
    }
    while (2)
    {
      unint64_t v372 = (unint64_t)v370[1];
      if (v372 != v290)
      {
        if (v372 >= *(void *)&v289) {
          v372 %= *(void *)&v289;
        }
        if (v372 != v292) {
          goto LABEL_415;
        }
        goto LABEL_601;
      }
      if (*((unsigned __int16 *)v370 + 8) != v290)
      {
LABEL_601:
        uint64_t v370 = (uint64_t **)*v370;
        if (!v370) {
          goto LABEL_415;
        }
        continue;
      }
      break;
    }
LABEL_615:
    uint64_t v374 = (unint64_t *)v370[3];
    unint64_t v375 = (unint64_t *)v370[4];
    if (v374 != v375)
    {
      int8x8_t v376 = *(int8x8_t *)((char *)this + 344);
      if (v376)
      {
LABEL_617:
        unint64_t v377 = *v374;
        uint8x8_t v378 = (uint8x8_t)vcnt_s8(v376);
        v378.i16[0] = vaddlv_u8(v378);
        if (v378.u32[0] > 1uLL)
        {
          unint64_t v379 = *v374;
          if (v377 >= *(void *)&v376) {
            unint64_t v379 = v377 % *(void *)&v376;
          }
        }
        else
        {
          unint64_t v379 = (*(void *)&v376 - 1) & v377;
        }
        unint64_t v380 = *(uint64_t ***)(*((void *)this + 42) + 8 * v379);
        if (v380)
        {
          v381 = *v380;
          if (v381)
          {
            unsigned int v382 = (unsigned __int16)*v374;
            if (v378.u32[0] < 2uLL)
            {
              uint64_t v383 = *(void *)&v376 - 1;
              while (1)
              {
                uint64_t v385 = v381[1];
                if (v385 == v377)
                {
                  if (__PAIR64__(*((unsigned __int16 *)v381 + 9), *((unsigned __int16 *)v381 + 8)) == __PAIR64__(WORD1(v377), v382)
                    && *((_DWORD *)v381 + 5) == HIDWORD(v377))
                  {
                    goto LABEL_638;
                  }
                }
                else if ((v385 & v383) != v379)
                {
                  goto LABEL_661;
                }
                v381 = (uint64_t *)*v381;
                if (!v381) {
                  goto LABEL_661;
                }
              }
            }
            do
            {
              unint64_t v384 = v381[1];
              if (v384 == v377)
              {
                if (__PAIR64__(*((unsigned __int16 *)v381 + 9), *((unsigned __int16 *)v381 + 8)) == __PAIR64__(WORD1(v377), v382)
                  && *((_DWORD *)v381 + 5) == HIDWORD(v377))
                {
LABEL_638:
                  uint64_t v386 = v381[3];
                  v388 = (char *)v287[4];
                  unint64_t v387 = v287[5];
                  if ((unint64_t)v388 < v387)
                  {
                    *(void *)v388 = v386;
                    uint64_t v389 = v388 + 8;
LABEL_660:
                    v287[4] = v389;
                    break;
                  }
                  v390 = (char *)v287[3];
                  uint64_t v391 = (v388 - v390) >> 3;
                  unint64_t v392 = v391 + 1;
                  if ((unint64_t)(v391 + 1) >> 61) {
                    abort();
                  }
                  uint64_t v393 = v387 - (void)v390;
                  if (v393 >> 2 > v392) {
                    unint64_t v392 = v393 >> 2;
                  }
                  if ((unint64_t)v393 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v394 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v394 = v392;
                  }
                  if (!v394)
                  {
                    unint64_t v395 = 0;
                    goto LABEL_650;
                  }
                  if (!(v394 >> 61))
                  {
                    unint64_t v395 = (char *)operator new(8 * v394);
LABEL_650:
                    size_t v396 = &v395[8 * v391];
                    *(void *)size_t v396 = v386;
                    uint64_t v389 = v396 + 8;
                    if (v388 != v390)
                    {
                      unint64_t v397 = v388 - 8 - v390;
                      if (v397 < 0x58) {
                        goto LABEL_987;
                      }
                      if ((unint64_t)(v390 - v395) < 0x20) {
                        goto LABEL_987;
                      }
                      uint64_t v398 = (v397 >> 3) + 1;
                      uint64_t v399 = &v395[8 * v391 - 16];
                      v400 = (long long *)(v388 - 16);
                      uint64_t v401 = v398 & 0x3FFFFFFFFFFFFFFCLL;
                      do
                      {
                        long long v402 = *v400;
                        *((_OWORD *)v399 - 1) = *(v400 - 1);
                        *(_OWORD *)uint64_t v399 = v402;
                        v399 -= 32;
                        v400 -= 2;
                        v401 -= 4;
                      }
                      while (v401);
                      v396 -= 8 * (v398 & 0x3FFFFFFFFFFFFFFCLL);
                      v388 -= 8 * (v398 & 0x3FFFFFFFFFFFFFFCLL);
                      if (v398 != (v398 & 0x3FFFFFFFFFFFFFFCLL))
                      {
LABEL_987:
                        do
                        {
                          uint64_t v403 = *((void *)v388 - 1);
                          v388 -= 8;
                          *((void *)v396 - 1) = v403;
                          v396 -= 8;
                        }
                        while (v388 != v390);
                      }
                      v388 = (char *)v287[3];
                    }
                    v287[3] = v396;
                    v287[4] = v389;
                    v287[5] = &v395[8 * v394];
                    if (v388) {
                      operator delete(v388);
                    }
                    goto LABEL_660;
                  }
LABEL_974:
                  std::__throw_bad_array_new_length[abi:nn180100]();
                }
              }
              else
              {
                if (v384 >= *(void *)&v376) {
                  v384 %= *(void *)&v376;
                }
                if (v384 != v379) {
                  break;
                }
              }
              v381 = (uint64_t *)*v381;
            }
            while (v381);
          }
        }
LABEL_661:
        while (++v374 != v375)
        {
          int8x8_t v376 = *(int8x8_t *)((char *)this + 344);
          if (v376) {
            goto LABEL_617;
          }
        }
      }
    }
LABEL_415:
    uint64_t v272 = v287[3];
    uint64_t v273 = (uint64_t *)v287[4];
    unint64_t v274 = 126 - 2 * __clz(((uint64_t)v273 - v272) >> 3);
    if (v273 == (uint64_t *)v272) {
      uint64_t v275 = 0;
    }
    else {
      uint64_t v275 = v274;
    }
    std::__introsort<std::_ClassicAlgPolicy,md::MeshRenderableLogic::gatherRenderables(md::LayoutContext const&,md::MaterialContext const&)::$_0 &,md::MeshRenderable **,false>(v272, v273, v275, 1);
    v269 = v597;
    uint64_t v270 = v594;
    long long v271 = v591;
LABEL_419:
    if (++v269 != v270) {
      continue;
    }
    break;
  }
LABEL_664:
  v404 = v627;
  if (v627 && !atomic_fetch_add(&v627->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v404->__on_zero_shared)(v404);
    std::__shared_weak_count::__release_weak(v404);
  }
  size_t v405 = (std::__shared_weak_count *)buf[3];
  if (buf[3] && !atomic_fetch_add((atomic_ullong *volatile)buf[3] + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v405->__on_zero_shared)(v405);
    std::__shared_weak_count::__release_weak(v405);
  }
  uint64_t v406 = (std::__shared_weak_count *)buf[1];
  if (buf[1] && !atomic_fetch_add((atomic_ullong *volatile)buf[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v406->__on_zero_shared)(v406);
    std::__shared_weak_count::__release_weak(v406);
  }
  if (GEOGetVectorKitPerformanceDetailsLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceDetailsLog_onceToken, &__block_literal_global_21);
  }
  uint64_t v407 = (id)GEOGetVectorKitPerformanceDetailsLog_log;
  unint64_t v408 = v407;
  os_signpost_id_t v409 = *((void *)a2 + 10);
  if (v409 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v407))
  {
    LOWORD(buf[0]) = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v408, OS_SIGNPOST_INTERVAL_END, v409, "GatherRenderables", "", (uint8_t *)buf, 2u);
  }

LABEL_679:
  if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
    dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
  }
  BOOL v410 = os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_DEBUG);
  uint64_t v412 = this;
  if (v410)
  {
    uint64_t v413 = *((void *)this + 17);
    uint64_t v414 = *(int8x8_t ***)(v413 + 384);
    v415 = *(int8x8_t ***)(v413 + 392);
    if (v414 != v415)
    {
      *(void *)&long long v411 = 67109120;
      do
      {
        int8x8_t v416 = (*v414)[1];
        if (v416)
        {
          uint8x8_t v417 = (uint8x8_t)vcnt_s8(v416);
          v417.i16[0] = vaddlv_u8(v417);
          if (v417.u32[0] > 1uLL)
          {
            unint64_t v418 = 0xCA93DB2C2ACE8387;
            if (*(void *)&v416 <= 0xCA93DB2C2ACE8387) {
              unint64_t v418 = 0xCA93DB2C2ACE8387 % *(void *)&v416;
            }
          }
          else
          {
            unint64_t v418 = (*(void *)&v416 - 1) & 0xCA93DB2C2ACE8387;
          }
          uint64_t v419 = *(void **)(*(void *)*v414 + 8 * v418);
          if (v419)
          {
            float v420 = (void *)*v419;
            if (v420)
            {
              if (v417.u32[0] < 2uLL)
              {
                uint64_t v421 = *(void *)&v416 - 1;
                while (1)
                {
                  uint64_t v423 = v420[1];
                  if (v423 == 0xCA93DB2C2ACE8387)
                  {
                    if (v420[2] == 0xCA93DB2C2ACE8387) {
                      goto LABEL_706;
                    }
                  }
                  else if ((v423 & v421) != v418)
                  {
                    goto LABEL_684;
                  }
                  float v420 = (void *)*v420;
                  if (!v420) {
                    goto LABEL_684;
                  }
                }
              }
              do
              {
                unint64_t v422 = v420[1];
                if (v422 == 0xCA93DB2C2ACE8387)
                {
                  if (v420[2] == 0xCA93DB2C2ACE8387)
                  {
LABEL_706:
                    uint64_t v424 = v420[5];
                    if (*(void *)(v424 + 8) == 0xCA93DB2C2ACE8387)
                    {
                      unsigned __int8 v425 = *(unsigned __int16 **)(v424 + 32);
                      if (v425)
                      {
                        if (*((unsigned char *)v425 + 80))
                        {
                          long long v607 = v411;
                          if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
                            dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
                          }
                          v426 = GEOGetVectorKitMeshRenderableLogicLog(void)::log;
                          BOOL v427 = os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_ERROR);
                          long long v411 = v607;
                          if (v427)
                          {
                            buf[0] = (void *)__PAIR64__(*v425, v607);
                            _os_log_impl(&dword_1A1780000, v426, OS_LOG_TYPE_ERROR, "BatchManager(id:%d) is not finalized", (uint8_t *)buf, 8u);
                            long long v411 = v607;
                          }
                        }
                      }
                    }
                    break;
                  }
                }
                else
                {
                  if (v422 >= *(void *)&v416) {
                    v422 %= *(void *)&v416;
                  }
                  if (v422 != v418) {
                    break;
                  }
                }
                float v420 = (void *)*v420;
              }
              while (v420);
            }
          }
        }
LABEL_684:
        ++v414;
      }
      while (v414 != v415);
    }
    uint64_t v412 = this;
    for (k = (uint64_t **)*((void *)this + 39); k; uint64_t v412 = this)
    {
      uint64_t v429 = *((void *)v412 + 17);
      uint64_t v430 = *(void *)(v429 + 384);
      uint64_t v431 = *(void *)(v429 + 392);
      if (v430 == v431)
      {
LABEL_719:
        if (k[3] != k[4])
        {
          if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
            dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
          }
          uint64_t v432 = GEOGetVectorKitMeshRenderableLogicLog(void)::log;
          if (os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf[0]) = 0;
            _os_log_impl(&dword_1A1780000, v432, OS_LOG_TYPE_ERROR, "Tracking renderables for inactive registry", (uint8_t *)buf, 2u);
          }
        }
      }
      else
      {
        while (*(unsigned __int16 *)(*(void *)v430 + 40) != *((unsigned __int16 *)k + 8))
        {
          v430 += 8;
          if (v430 == v431) {
            goto LABEL_719;
          }
        }
      }
      k = (uint64_t **)*k;
    }
    for (m = (uint64_t **)*((void *)v412 + 49); m; uint64_t v412 = this)
    {
      uint64_t v434 = *((void *)v412 + 17);
      uint64_t v435 = *(void *)(v434 + 384);
      uint64_t v436 = *(void *)(v434 + 392);
      if (v435 == v436)
      {
LABEL_730:
        if (m[3] != m[4])
        {
          if (GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken != -1) {
            dispatch_once(&GEOGetVectorKitMeshRenderableLogicLog(void)::onceToken, &__block_literal_global_13147);
          }
          uint8x8_t v437 = GEOGetVectorKitMeshRenderableLogicLog(void)::log;
          if (os_log_type_enabled((os_log_t)GEOGetVectorKitMeshRenderableLogicLog(void)::log, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf[0]) = 0;
            _os_log_impl(&dword_1A1780000, v437, OS_LOG_TYPE_ERROR, "Tracking renderable injections for inactive registry", (uint8_t *)buf, 2u);
          }
        }
      }
      else
      {
        while (*(unsigned __int16 *)(*(void *)v435 + 40) != *((unsigned __int16 *)m + 8))
        {
          v435 += 8;
          if (v435 == v436) {
            goto LABEL_730;
          }
        }
      }
      m = (uint64_t **)*m;
    }
  }
  *((unsigned char *)v412 + 416) = 0;
}

void sub_1A1B6CF40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,void *__p,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,std::__shared_weak_count *a46,uint64_t a47,std::__shared_weak_count *a48,uint64_t a49,std::__shared_weak_count *a50)
{
  if (a50 && !atomic_fetch_add(&a50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a50->__on_zero_shared)(a50);
    std::__shared_weak_count::__release_weak(a50);
  }
  if (a48 && !atomic_fetch_add(&a48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a48->__on_zero_shared)(a48);
    std::__shared_weak_count::__release_weak(a48);
  }
  if (a46)
  {
    if (!atomic_fetch_add(&a46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a46->__on_zero_shared)(a46);
      std::__shared_weak_count::__release_weak(a46);
      _Unwind_Resume(a1);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::components::CustomRenderStateChanged>(int8x8_t *a1)
{
  unint64_t v10 = 0xB8E8DF22A2AE77B4;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xB8E8DF22A2AE77B4;
    if (*(void *)&v1 <= 0xB8E8DF22A2AE77B4) {
      unint64_t v3 = 0xB8E8DF22A2AE77B4 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xB8E8DF22A2AE77B4;
  }
  v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (os_signpost_id_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xB8E8DF22A2AE77B4)
      {
        if (v5[2] == 0xB8E8DF22A2AE77B4) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      os_signpost_id_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xB8E8DF22A2AE77B4) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    os_signpost_id_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xB8E8DF22A2AE77B4) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1B6DB80(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::components::VisibilityChanged>(int8x8_t *a1)
{
  unint64_t v10 = 0xA58E035ED185DBF8;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xA58E035ED185DBF8;
    if (*(void *)&v1 <= 0xA58E035ED185DBF8) {
      unint64_t v3 = 0xA58E035ED185DBF8 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xA58E035ED185DBF8;
  }
  v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (os_signpost_id_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xA58E035ED185DBF8)
      {
        if (v5[2] == 0xA58E035ED185DBF8) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      os_signpost_id_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xA58E035ED185DBF8) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    os_signpost_id_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xA58E035ED185DBF8) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1B6DDF0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,md::MeshRenderableLogic::gatherRenderables(md::LayoutContext const&,md::MaterialContext const&)::$_0 &,md::MeshRenderable **,false>(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  int8x8_t v9 = (uint64_t *)result;
LABEL_2:
  unint64_t v10 = a2 - 1;
  unint64_t v11 = v9;
  while (1)
  {
    int8x8_t v9 = v11;
    uint64_t v12 = (char *)a2 - (char *)v11;
    uint64_t v13 = a2 - v11;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v81 = *v11;
          if (*(unsigned __int8 *)(*v10 + 8) < *(unsigned __int8 *)(*v11 + 8))
          {
            *unint64_t v11 = *v10;
            *unint64_t v10 = v81;
          }
          return result;
        case 3:
          uint64_t v82 = *v11;
          uint64_t v83 = v11[1];
          unsigned int v84 = *(unsigned __int8 *)(v83 + 8);
          unsigned int v85 = *(unsigned __int8 *)(*v11 + 8);
          uint64_t v86 = *v10;
          unsigned int v87 = *(unsigned __int8 *)(*v10 + 8);
          if (v84 >= v85)
          {
            if (v87 < v84)
            {
              v11[1] = v86;
              *unint64_t v10 = v83;
              uint64_t v138 = *v11;
              uint64_t v137 = v11[1];
              if (*(unsigned __int8 *)(v137 + 8) < *(unsigned __int8 *)(*v11 + 8))
              {
                *unint64_t v11 = v137;
                v11[1] = v138;
              }
            }
          }
          else
          {
            if (v87 >= v84)
            {
              *unint64_t v11 = v83;
              v11[1] = v82;
              if (*(unsigned __int8 *)(*v10 + 8) >= v85) {
                return result;
              }
              v11[1] = *v10;
            }
            else
            {
              *unint64_t v11 = v86;
            }
            *unint64_t v10 = v82;
          }
          return result;
        case 4:
          v88 = v11 + 1;
          uint64_t v89 = v11[1];
          uint64_t v90 = v11 + 2;
          uint64_t v91 = v11[2];
          uint64_t v92 = *v11;
          unsigned int v93 = *(unsigned __int8 *)(v89 + 8);
          unsigned int v94 = *(unsigned __int8 *)(*v11 + 8);
          unsigned int v95 = *(unsigned __int8 *)(v91 + 8);
          if (v93 >= v94)
          {
            if (v95 >= v93) {
              goto LABEL_169;
            }
            uint64_t *v88 = v91;
            uint64_t *v90 = v89;
            unint64_t v96 = v11;
            uint64_t v97 = v11 + 1;
            double result = v89;
            if (v95 >= v94) {
              goto LABEL_170;
            }
          }
          else
          {
            unint64_t v96 = v11;
            uint64_t v97 = v11 + 2;
            double result = *v11;
            if (v95 >= v93)
            {
              *unint64_t v11 = v89;
              v11[1] = v92;
              unint64_t v96 = v11 + 1;
              uint64_t v97 = v11 + 2;
              double result = v92;
              if (v95 >= v94)
              {
LABEL_169:
                uint64_t v89 = v91;
LABEL_170:
                if (*(unsigned __int8 *)(*v10 + 8) < *(unsigned __int8 *)(v89 + 8))
                {
                  uint64_t *v90 = *v10;
                  *unint64_t v10 = v89;
                  uint64_t v142 = *v90;
                  uint64_t v143 = *v88;
                  unsigned int v144 = *(unsigned __int8 *)(v142 + 8);
                  if (v144 < *(unsigned __int8 *)(v143 + 8))
                  {
                    v11[1] = v142;
                    v11[2] = v143;
                    uint64_t v145 = *v11;
                    if (v144 < *(unsigned __int8 *)(*v11 + 8))
                    {
                      *unint64_t v11 = v142;
                      v11[1] = v145;
                    }
                  }
                }
                return result;
              }
            }
          }
          *unint64_t v96 = v91;
          uint64_t *v97 = v92;
          uint64_t v89 = result;
          goto LABEL_170;
        case 5:
          return (uint64_t)std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::MeshRenderableLogic::injectDynamicRenderable(gdc::Entity,gdc::Registry *)::$_0 &,md::MeshRenderable **,0>(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
        default:
          JUMPOUT(0);
      }
    }
    if (v12 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v11 != a2)
      {
        int64_t v109 = (unint64_t)(v13 - 2) >> 1;
        int64_t v110 = v109;
        do
        {
          if (v109 >= v110)
          {
            uint64_t v112 = (2 * v110) | 1;
            unint64_t v113 = &v11[v112];
            uint64_t v114 = *v113;
            if (2 * v110 + 2 < v13)
            {
              double result = *(unsigned __int8 *)(v114 + 8);
              if (result < *(unsigned __int8 *)(v113[1] + 8))
              {
                uint64_t v114 = v113[1];
                ++v113;
                uint64_t v112 = 2 * v110 + 2;
              }
            }
            uint64_t v115 = &v11[v110];
            uint64_t v116 = *v115;
            unsigned int v117 = *(unsigned __int8 *)(*v115 + 8);
            if (*(unsigned __int8 *)(v114 + 8) >= v117)
            {
              do
              {
                uint64_t v118 = v113;
                *uint64_t v115 = v114;
                if (v109 < v112) {
                  break;
                }
                double result = (2 * v112) | 1;
                unint64_t v113 = &v11[result];
                uint64_t v119 = 2 * v112 + 2;
                uint64_t v114 = *v113;
                if (v119 < v13 && *(unsigned __int8 *)(v114 + 8) < *(unsigned __int8 *)(v113[1] + 8))
                {
                  uint64_t v114 = v113[1];
                  ++v113;
                  double result = v119;
                }
                uint64_t v115 = v118;
                uint64_t v112 = result;
              }
              while (*(unsigned __int8 *)(v114 + 8) >= v117);
              *uint64_t v118 = v116;
            }
          }
          BOOL v111 = v110-- <= 0;
        }
        while (!v111);
        uint64_t v120 = (unint64_t)v12 >> 3;
        do
        {
          uint64_t v121 = 0;
          uint64_t v122 = *v11;
          unint64_t v123 = v11;
          do
          {
            int64_t v124 = &v123[v121];
            uint64_t v127 = v124[1];
            uint64_t v125 = v124 + 1;
            uint64_t v126 = v127;
            uint64_t v128 = (2 * v121) | 1;
            uint64_t v129 = 2 * v121 + 2;
            if (v129 < v120)
            {
              double result = *(unsigned __int8 *)(v126 + 8);
              if (result < *(unsigned __int8 *)(v125[1] + 8))
              {
                uint64_t v126 = v125[1];
                ++v125;
                uint64_t v128 = v129;
              }
            }
            *unint64_t v123 = v126;
            unint64_t v123 = v125;
            uint64_t v121 = v128;
          }
          while (v128 <= (uint64_t)((unint64_t)(v120 - 2) >> 1));
          if (v125 == --a2)
          {
            *uint64_t v125 = v122;
          }
          else
          {
            *uint64_t v125 = *a2;
            *a2 = v122;
            uint64_t v130 = (char *)v125 - (char *)v11 + 8;
            if (v130 >= 9)
            {
              unint64_t v131 = (((unint64_t)v130 >> 3) - 2) >> 1;
              uint64_t v132 = &v11[v131];
              uint64_t v133 = *v132;
              uint64_t v134 = *v125;
              unsigned int v135 = *(unsigned __int8 *)(*v125 + 8);
              if (*(unsigned __int8 *)(*v132 + 8) < v135)
              {
                do
                {
                  long long v136 = v132;
                  *uint64_t v125 = v133;
                  if (!v131) {
                    break;
                  }
                  unint64_t v131 = (v131 - 1) >> 1;
                  uint64_t v132 = &v11[v131];
                  uint64_t v133 = *v132;
                  uint64_t v125 = v136;
                }
                while (*(unsigned __int8 *)(*v132 + 8) < v135);
                *long long v136 = v134;
              }
            }
          }
          BOOL v111 = v120-- <= 2;
        }
        while (!v111);
      }
      return result;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    uint64_t v15 = &v11[(unint64_t)v13 >> 1];
    uint64_t v16 = *v10;
    unsigned int v17 = *(unsigned __int8 *)(*v10 + 8);
    if ((unint64_t)v12 >= 0x401)
    {
      uint64_t v18 = *v15;
      uint64_t v19 = *v11;
      unsigned int v20 = *(unsigned __int8 *)(*v15 + 8);
      unsigned int v21 = *(unsigned __int8 *)(*v11 + 8);
      if (v20 >= v21)
      {
        if (v17 < v20)
        {
          *uint64_t v15 = v16;
          *unint64_t v10 = v18;
          uint64_t v26 = *v11;
          if (*(unsigned __int8 *)(*v15 + 8) < *(unsigned __int8 *)(*v11 + 8))
          {
            *unint64_t v11 = *v15;
            *uint64_t v15 = v26;
          }
        }
      }
      else
      {
        if (v17 < v20)
        {
          *unint64_t v11 = v16;
          goto LABEL_22;
        }
        *unint64_t v11 = v18;
        *uint64_t v15 = v19;
        if (*(unsigned __int8 *)(*v10 + 8) < v21)
        {
          *uint64_t v15 = *v10;
LABEL_22:
          *unint64_t v10 = v19;
        }
      }
      uint64_t v28 = &v11[v14];
      uint64_t v31 = *(v28 - 1);
      uint64_t v29 = v28 - 1;
      uint64_t v30 = v31;
      uint64_t v32 = v11[1];
      unsigned int v33 = *(unsigned __int8 *)(v31 + 8);
      unsigned int v34 = *(unsigned __int8 *)(v32 + 8);
      uint64_t v35 = *(a2 - 2);
      unsigned int v36 = *(unsigned __int8 *)(v35 + 8);
      if (v33 >= v34)
      {
        if (v36 < v33)
        {
          *uint64_t v29 = v35;
          *(a2 - 2) = v30;
          uint64_t v37 = v11[1];
          if (*(unsigned __int8 *)(*v29 + 8) < *(unsigned __int8 *)(v37 + 8))
          {
            v11[1] = *v29;
            *uint64_t v29 = v37;
          }
        }
      }
      else
      {
        if (v36 < v33)
        {
          v11[1] = v35;
          goto LABEL_34;
        }
        v11[1] = v30;
        *uint64_t v29 = v32;
        uint64_t v38 = *(a2 - 2);
        if (*(unsigned __int8 *)(v38 + 8) < v34)
        {
          *uint64_t v29 = v38;
LABEL_34:
          *(a2 - 2) = v32;
        }
      }
      unint64_t v39 = &v11[v14];
      uint64_t v42 = v39[1];
      uint64_t v40 = v39 + 1;
      uint64_t v41 = v42;
      uint64_t v43 = v11[2];
      unsigned int v44 = *(unsigned __int8 *)(v42 + 8);
      unsigned int v45 = *(unsigned __int8 *)(v43 + 8);
      uint64_t v46 = *(a2 - 3);
      unsigned int v47 = *(unsigned __int8 *)(v46 + 8);
      if (v44 >= v45)
      {
        if (v47 < v44)
        {
          uint64_t *v40 = v46;
          *(a2 - 3) = v41;
          uint64_t v48 = v11[2];
          if (*(unsigned __int8 *)(*v40 + 8) < *(unsigned __int8 *)(v48 + 8))
          {
            v11[2] = *v40;
            uint64_t *v40 = v48;
          }
        }
      }
      else
      {
        if (v47 < v44)
        {
          v11[2] = v46;
          goto LABEL_43;
        }
        v11[2] = v41;
        uint64_t *v40 = v43;
        uint64_t v49 = *(a2 - 3);
        if (*(unsigned __int8 *)(v49 + 8) < v45)
        {
          uint64_t *v40 = v49;
LABEL_43:
          *(a2 - 3) = v43;
        }
      }
      uint64_t v50 = *v15;
      uint64_t v51 = *v29;
      unsigned int v52 = *(unsigned __int8 *)(*v15 + 8);
      unsigned int v53 = *(unsigned __int8 *)(*v29 + 8);
      uint64_t v54 = *v40;
      unsigned int v55 = *(unsigned __int8 *)(*v40 + 8);
      if (v52 >= v53)
      {
        if (v55 >= v52) {
          goto LABEL_51;
        }
        *uint64_t v15 = v54;
        uint64_t *v40 = v50;
        uint64_t v40 = v15;
        uint64_t v50 = v51;
        if (v55 >= v53)
        {
          uint64_t v50 = v54;
          goto LABEL_51;
        }
      }
      else if (v55 >= v52)
      {
        *uint64_t v29 = v50;
        *uint64_t v15 = v51;
        uint64_t v29 = v15;
        uint64_t v50 = v54;
        if (v55 >= v53)
        {
          uint64_t v50 = v51;
LABEL_51:
          uint64_t v56 = *v11;
          *unint64_t v11 = v50;
          *uint64_t v15 = v56;
          goto LABEL_52;
        }
      }
      *uint64_t v29 = v54;
      uint64_t *v40 = v51;
      goto LABEL_51;
    }
    uint64_t v22 = *v11;
    uint64_t v23 = *v15;
    unsigned int v24 = *(unsigned __int8 *)(*v11 + 8);
    unsigned int v25 = *(unsigned __int8 *)(*v15 + 8);
    if (v24 >= v25)
    {
      if (v17 < v24)
      {
        *unint64_t v11 = v16;
        *unint64_t v10 = v22;
        uint64_t v27 = *v15;
        if (*(unsigned __int8 *)(*v11 + 8) < *(unsigned __int8 *)(*v15 + 8))
        {
          *uint64_t v15 = *v11;
          *unint64_t v11 = v27;
        }
      }
      goto LABEL_52;
    }
    if (v17 < v24)
    {
      *uint64_t v15 = v16;
LABEL_31:
      *unint64_t v10 = v23;
      goto LABEL_52;
    }
    *uint64_t v15 = v22;
    *unint64_t v11 = v23;
    if (*(unsigned __int8 *)(*v10 + 8) < v25)
    {
      *unint64_t v11 = *v10;
      goto LABEL_31;
    }
LABEL_52:
    --a3;
    uint64_t v57 = *v11;
    if (a4)
    {
      unsigned int v58 = *(unsigned __int8 *)(v57 + 8);
LABEL_55:
      unint64_t v59 = v11;
      do
      {
        uint64_t v60 = v59;
        uint64_t v62 = v59[1];
        ++v59;
        uint64_t v61 = v62;
      }
      while (*(unsigned __int8 *)(v62 + 8) < v58);
      unint64_t v63 = a2;
      if (v60 == v11)
      {
        unint64_t v63 = a2;
        do
        {
          if (v59 >= v63) {
            break;
          }
          uint64_t v65 = *--v63;
        }
        while (*(unsigned __int8 *)(v65 + 8) >= v58);
      }
      else
      {
        do
          uint64_t v64 = *--v63;
        while (*(unsigned __int8 *)(v64 + 8) >= v58);
      }
      if (v59 < v63)
      {
        uint64_t v66 = *v63;
        uint64_t v67 = v59;
        uint64_t v68 = v63;
        do
        {
          *uint64_t v67 = v66;
          *uint64_t v68 = v61;
          do
          {
            uint64_t v60 = v67;
            uint64_t v69 = v67[1];
            ++v67;
            uint64_t v61 = v69;
          }
          while (*(unsigned __int8 *)(v69 + 8) < v58);
          do
          {
            uint64_t v70 = *--v68;
            uint64_t v66 = v70;
          }
          while (*(unsigned __int8 *)(v70 + 8) >= v58);
        }
        while (v67 < v68);
      }
      if (v60 != v11) {
        *unint64_t v11 = *v60;
      }
      uint64_t *v60 = v57;
      if (v59 < v63) {
        goto LABEL_74;
      }
      BOOL v71 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MeshRenderableLogic::gatherRenderables(md::LayoutContext const&,md::MaterialContext const&)::$_0 &,md::MeshRenderable **>(v11, v60);
      unint64_t v11 = v60 + 1;
      double result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MeshRenderableLogic::gatherRenderables(md::LayoutContext const&,md::MaterialContext const&)::$_0 &,md::MeshRenderable **>(v60 + 1, a2);
      if (result)
      {
        a2 = v60;
        if (v71) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v71)
      {
LABEL_74:
        double result = std::__introsort<std::_ClassicAlgPolicy,md::MeshRenderableLogic::gatherRenderables(md::LayoutContext const&,md::MaterialContext const&)::$_0 &,md::MeshRenderable **,false>(v9, v60, a3, a4 & 1);
        a4 = 0;
        unint64_t v11 = v60 + 1;
      }
    }
    else
    {
      unsigned int v58 = *(unsigned __int8 *)(v57 + 8);
      if (*(unsigned __int8 *)(*(v11 - 1) + 8) < v58) {
        goto LABEL_55;
      }
      if (v58 < *(unsigned __int8 *)(*v10 + 8))
      {
        do
        {
          uint64_t v72 = v11[1];
          ++v11;
        }
        while (v58 >= *(unsigned __int8 *)(v72 + 8));
      }
      else
      {
        uint64_t v73 = v11 + 1;
        do
        {
          unint64_t v11 = v73;
          if (v73 >= a2) {
            break;
          }
          ++v73;
        }
        while (v58 >= *(unsigned __int8 *)(*v11 + 8));
      }
      BOOL v74 = a2;
      if (v11 < a2)
      {
        BOOL v74 = a2;
        do
          uint64_t v75 = *--v74;
        while (v58 < *(unsigned __int8 *)(v75 + 8));
      }
      if (v11 < v74)
      {
        uint64_t v76 = *v11;
        uint64_t v77 = *v74;
        do
        {
          *unint64_t v11 = v77;
          *BOOL v74 = v76;
          do
          {
            uint64_t v78 = v11[1];
            ++v11;
            uint64_t v76 = v78;
          }
          while (v58 >= *(unsigned __int8 *)(v78 + 8));
          do
          {
            uint64_t v79 = *--v74;
            uint64_t v77 = v79;
          }
          while (v58 < *(unsigned __int8 *)(v79 + 8));
        }
        while (v11 < v74);
      }
      uint64_t v80 = v11 - 1;
      BOOL v4 = v11 - 1 >= v9;
      BOOL v5 = v11 - 1 == v9;
      if (v11 - 1 != v9) {
        *int8x8_t v9 = *v80;
      }
      a4 = 0;
      *uint64_t v80 = v57;
    }
  }
  uint64_t v98 = v11 + 1;
  BOOL v100 = v11 == a2 || v98 == a2;
  if (a4)
  {
    if (!v100)
    {
      uint64_t v101 = 8;
      uint64_t v102 = v11;
      do
      {
        uint64_t v105 = *v102;
        uint64_t v104 = v102[1];
        uint64_t v102 = v98;
        unsigned int v106 = *(unsigned __int8 *)(v104 + 8);
        if (v106 < *(unsigned __int8 *)(v105 + 8))
        {
          uint64_t v107 = v101;
          do
          {
            *(uint64_t *)((char *)v11 + v107) = v105;
            uint64_t v108 = v107 - 8;
            if (v107 == 8)
            {
              uint64_t v103 = v11;
              goto LABEL_118;
            }
            uint64_t v105 = *(uint64_t *)((char *)v11 + v107 - 16);
            v107 -= 8;
          }
          while (v106 < *(unsigned __int8 *)(v105 + 8));
          uint64_t v103 = (uint64_t *)((char *)v11 + v108);
LABEL_118:
          uint64_t *v103 = v104;
        }
        uint64_t v98 = v102 + 1;
        v101 += 8;
      }
      while (v102 + 1 != a2);
    }
  }
  else if (!v100)
  {
    do
    {
      uint64_t v140 = *v9;
      uint64_t v139 = v9[1];
      int8x8_t v9 = v98;
      unsigned int v141 = *(unsigned __int8 *)(v139 + 8);
      if (v141 < *(unsigned __int8 *)(v140 + 8))
      {
        do
        {
          uint64_t *v98 = v140;
          uint64_t v140 = *(v98 - 2);
          --v98;
        }
        while (v141 < *(unsigned __int8 *)(v140 + 8));
        uint64_t *v98 = v139;
      }
      uint64_t v98 = v9 + 1;
    }
    while (v9 + 1 != a2);
  }
  return result;
}

void std::__hash_table<md::RenderBatch *,std::hash<md::RenderBatch *>,std::equal_to<md::RenderBatch *>,std::allocator<md::RenderBatch *>>::__emplace_unique_key_args<md::RenderBatch *,md::RenderBatch *&>(float *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = v7 ^ (v7 >> 47);
  unint64_t v9 = 0x9DDFEA08EB382D69 * v8;
  unint64_t v10 = *((void *)a1 + 1);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * v8;
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
    }
    else
    {
      unint64_t v3 = v9 & (v10 - 1);
    }
    uint64_t v12 = *(void **)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      uint64_t v13 = (void *)*v12;
      if (v13)
      {
        if (v11.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v15 = v13[1];
            if (v15 == v9)
            {
              if (v13[2] == a2) {
                return;
              }
            }
            else if ((v15 & (v10 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v13 = (void *)*v13;
            if (!v13) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v9)
          {
            if (v13[2] == a2) {
              return;
            }
          }
          else
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
            if (v14 != v3) {
              break;
            }
          }
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_22:
  uint64_t v16 = operator new(0x18uLL);
  *uint64_t v16 = 0;
  v16[1] = v9;
  v16[2] = a3;
  float v17 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v18 = a1[8];
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t prime = v21;
    }
    else {
      size_t prime = v20;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v10 = *((void *)a1 + 1);
    }
    if (prime <= v10)
    {
      if (prime >= v10) {
        goto LABEL_59;
      }
      unint64_t v34 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v10 < 3 || (uint8x8_t v35 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v35.i16[0] = vaddlv_u8(v35), v35.u32[0] > 1uLL))
      {
        unint64_t v34 = std::__next_prime(v34);
      }
      else
      {
        uint64_t v36 = 1 << -(char)__clz(v34 - 1);
        if (v34 >= 2) {
          unint64_t v34 = v36;
        }
      }
      if (prime <= v34) {
        size_t prime = v34;
      }
      if (prime >= v10)
      {
        unint64_t v10 = *((void *)a1 + 1);
LABEL_59:
        if ((v10 & (v10 - 1)) != 0)
        {
          if (v9 >= v10) {
            unint64_t v3 = v9 % v10;
          }
          else {
            unint64_t v3 = v9;
          }
        }
        else
        {
          unint64_t v3 = (v10 - 1) & v9;
        }
        goto LABEL_72;
      }
      if (!prime)
      {
        uint64_t v43 = *(void **)a1;
        *(void *)a1 = 0;
        if (v43) {
          operator delete(v43);
        }
        unint64_t v10 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_59;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v23 = operator new(8 * prime);
    unsigned int v24 = *(void **)a1;
    *(void *)a1 = v23;
    if (v24) {
      operator delete(v24);
    }
    uint64_t v25 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v25++) = 0;
    while (prime != v25);
    uint64_t v27 = (uint64_t *)(a1 + 4);
    uint64_t v26 = (void *)*((void *)a1 + 2);
    if (!v26)
    {
LABEL_58:
      unint64_t v10 = prime;
      goto LABEL_59;
    }
    size_t v28 = v26[1];
    size_t v29 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v30 = v28 & v29;
      *(void *)(*(void *)a1 + 8 * v30) = v27;
      for (i = (void *)*v26; *v26; i = (void *)*v26)
      {
        size_t v32 = i[1] & v29;
        if (v32 == v30)
        {
          uint64_t v26 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v32))
        {
          *uint64_t v26 = *i;
          uint64_t v33 = 8 * v32;
          void *i = **(void **)(*(void *)a1 + v33);
          **(void **)(*(void *)a1 + v33) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v32) = v26;
          uint64_t v26 = i;
          size_t v30 = v32;
        }
      }
      goto LABEL_58;
    }
    if (v28 >= prime) {
      v28 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v28) = v27;
    uint64_t v37 = (void *)*v26;
    if (!*v26) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v39 = v37[1];
      if (v39 >= prime) {
        v39 %= prime;
      }
      if (v39 != v28)
      {
        if (!*(void *)(*(void *)a1 + 8 * v39))
        {
          *(void *)(*(void *)a1 + 8 * v39) = v26;
          goto LABEL_63;
        }
        *uint64_t v26 = *v37;
        uint64_t v38 = 8 * v39;
        *uint64_t v37 = **(void **)(*(void *)a1 + v38);
        **(void **)(*(void *)a1 + v38) = v37;
        uint64_t v37 = v26;
      }
      size_t v39 = v28;
LABEL_63:
      uint64_t v26 = v37;
      uint64_t v37 = (void *)*v37;
      size_t v28 = v39;
      if (!v37) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  uint64_t v40 = *(void **)a1;
  uint64_t v41 = *(void **)(*(void *)a1 + 8 * v3);
  if (v41)
  {
    *uint64_t v16 = *v41;
LABEL_80:
    *uint64_t v41 = v16;
    goto LABEL_81;
  }
  *uint64_t v16 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v16;
  v40[v3] = a1 + 4;
  if (*v16)
  {
    unint64_t v42 = *(void *)(*v16 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v42 >= v10) {
        v42 %= v10;
      }
    }
    else
    {
      v42 &= v10 - 1;
    }
    uint64_t v41 = (void *)(*(void *)a1 + 8 * v42);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
}

void sub_1A1B6EC74(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>::find<gdc::Entity>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  BOOL v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  double result = *v5;
  if (*v5)
  {
    if (v3.u32[0] < 2uLL)
    {
      uint64_t v7 = *(void *)&v2 - 1;
      while (1)
      {
        uint64_t v9 = result[1];
        if (v9 == a2)
        {
          if (__PAIR64__(*((unsigned __int16 *)result + 9), *((unsigned __int16 *)result + 8)) == __PAIR64__(WORD1(a2), (unsigned __int16)a2)&& *((_DWORD *)result + 5) == HIDWORD(a2))
          {
            return result;
          }
        }
        else if ((v9 & v7) != v4)
        {
          return 0;
        }
        double result = (uint64_t *)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v8 = result[1];
      if (v8 == a2)
      {
        if (__PAIR64__(*((unsigned __int16 *)result + 9), *((unsigned __int16 *)result + 8)) == __PAIR64__(WORD1(a2), (unsigned __int16)a2)&& *((_DWORD *)result + 5) == HIDWORD(a2))
        {
          return result;
        }
      }
      else
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
        if (v8 != v4) {
          return 0;
        }
      }
      double result = (uint64_t *)*result;
    }
    while (result);
  }
  return result;
}

BOOL std::__function::__func<md::MeshRenderableLogic::gatherRenderables(md::LayoutContext const&,md::MaterialContext const&)::$_1,std::allocator<md::MeshRenderableLogic::gatherRenderables(md::LayoutContext const&,md::MaterialContext const&)::$_1>,BOOL ()(md::MeshRenderable *)>::operator()(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(*(void *)a2 + 8) <= 3u) {
    return *(unsigned char *)(*(void *)a2 + 144) != 0;
  }
  return v2;
}

void md::RasterRenderLayer::RasterRenderLayer(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  v27[4] = *(void **)MEMORY[0x1E4F143B8];
  if (a3 == 2) {
    char v8 = 9;
  }
  else {
    char v8 = 11;
  }
  if (a3 == 1) {
    char v8 = 8;
  }
  if (a3) {
    char v9 = v8;
  }
  else {
    char v9 = 7;
  }
  if (a3 == 1) {
    __int16 v10 = 8;
  }
  else {
    __int16 v10 = 10;
  }
  if (a3) {
    __int16 v11 = v10;
  }
  else {
    __int16 v11 = 7;
  }
  uint64_t v12 = operator new(2uLL);
  *uint64_t v12 = v11;
  v27[1] = v12 + 1;
  v27[2] = v12 + 1;
  v27[0] = v12;
  uint64_t v13 = +[VKSharedResourcesManager sharedResources];
  unint64_t v14 = v13;
  if (v13)
  {
    [v13 standardCommandBufferSelector];
    uint64_t v15 = v22;
    if (a3 <= 2)
    {
LABEL_17:
      uint64_t v16 = (a3 + 6);
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v23 = 0;
    if (a3 <= 2) {
      goto LABEL_17;
    }
  }
  uint64_t v16 = 99;
  if (!*(unsigned char *)(v15 + 56)) {
    uint64_t v16 = 10;
  }
LABEL_21:
  __int16 v17 = *(_WORD *)(*(void *)(v15 + 8) + 2 * v16);
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  unsigned int v24 = 0;
  float v18 = operator new(2uLL);
  uint64_t v25 = v18 + 1;
  uint64_t v26 = v18 + 1;
  *float v18 = v17;
  unsigned int v24 = v18;
  md::CartographicTiledRenderLayer<md::MapTileDataRenderable<md::RasterTileData>>::CartographicTiledRenderLayer(a1, v9, (uint64_t)v27, a2, (uint64_t)&v24, 1);
  uint64_t v25 = v18;
  operator delete(v18);
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }

  if (v27[0]) {
    operator delete(v27[0]);
  }
  *(void *)a1 = &unk_1EF537768;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(void *)(a1 + 384) = a3;
  *(void *)(a1 + 392) = 0;
  *(unsigned char *)(a1 + 400) = 0;
  uint64_t v19 = *a4;
  uint64_t v20 = a4[1];
  if (v20)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
    unint64_t v21 = *(std::__shared_weak_count **)(a1 + 360);
    *(void *)(a1 + 352) = v19;
    *(void *)(a1 + 360) = v20;
    if (v21)
    {
      if (!atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
  }
  else
  {
    *(void *)(a1 + 352) = v19;
    *(void *)(a1 + 360) = 0;
  }
  *(void *)(a1 + 368) = *(void *)(a1 + 352);
  operator new();
}

void sub_1A1B70490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t *a16)
{
  uint64_t v22 = v18[11];
  if (v22 == v19)
  {
    (*(void (**)(uint64_t))(*(void *)v19 + 32))(v19);
    uint64_t v23 = *v20;
    if (*v20)
    {
LABEL_17:
      v18[5] = v23;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18[7] + 40))(v18[7], v23, v18[6] - v23);
      uint64_t v24 = *v18;
      if (!*v18)
      {
LABEL_8:
        if (a12 == &a9)
        {
          (*(void (**)(uint64_t *))(a9 + 32))(&a9);
        }
        else if (a12)
        {
          (*(void (**)(void))(*a12 + 40))();
        }
        if (a16 == &a13)
        {
          (*(void (**)(uint64_t *))(a13 + 32))(&a13);
        }
        else if (a16)
        {
          (*(void (**)(void))(*a16 + 40))();
        }
        MEMORY[0x1A6239270](v18, 0x10A0C40D234DDC7);
        uint64_t v25 = v17[3];
        v17[3] = 0;
        if (v25)
        {
          uint64_t v26 = ggl::FragmentedPool<ggl::RenderItem>::~FragmentedPool(v25);
          MEMORY[0x1A6239270](v26, 0x10A0C40D234DDC7);
        }
        uint64_t v27 = v17[2];
        v17[2] = 0;
        if (v27)
        {
          uint64_t v28 = ggl::FragmentedPool<ggl::TextureWithReverseAlpha::Pos2DUVPipelineSetup>::~FragmentedPool(v27);
          MEMORY[0x1A6239270](v28, 0x10A0C40D234DDC7);
        }
        uint64_t v29 = v17[1];
        v17[1] = 0;
        if (v29)
        {
          uint64_t v30 = ggl::FragmentedPool<ggl::Clut::Pos2DUVPipelineSetup>::~FragmentedPool(v29);
          MEMORY[0x1A6239270](v30, 0x10A0C40D234DDC7);
        }
        uint64_t v31 = *v17;
        *__int16 v17 = 0;
        if (v31)
        {
          uint64_t v32 = ggl::FragmentedPool<ggl::Textured::Pos2DUVPipelineSetup>::~FragmentedPool(v31);
          MEMORY[0x1A6239270](v32, 0x10A0C40D234DDC7);
        }
        MEMORY[0x1A6239270](v17, 0x20C40DC1BFBCFLL);
        uint64_t v33 = *(md::RasterRenderResources **)(v16 + 376);
        *(void *)(v16 + 376) = 0;
        if (v33)
        {
          md::RasterRenderResources::~RasterRenderResources(v33);
          MEMORY[0x1A6239270]();
        }
        unint64_t v34 = *(std::__shared_weak_count **)(v16 + 360);
        if (v34)
        {
          if (!atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
            std::__shared_weak_count::__release_weak(v34);
          }
        }
        md::CartographicTiledRenderLayer<md::MapTileDataRenderable<md::RasterTileData>>::~CartographicTiledRenderLayer(v16);
        _Unwind_Resume(a1);
      }
LABEL_7:
      v18[1] = v24;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18[3] + 40))(v18[3], v24, v18[2] - v24);
      goto LABEL_8;
    }
  }
  else if (v22)
  {
    (*(void (**)(uint64_t))(*(void *)v22 + 40))(v22);
    uint64_t v23 = *v20;
    if (*v20) {
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v23 = *v20;
    if (*v20) {
      goto LABEL_17;
    }
  }
  uint64_t v24 = *v18;
  if (!*v18) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

unint64_t *ggl::FragmentedPool<ggl::RenderItem>::FragmentedPool(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  {
    operator new();
  }
  uint64_t v6 = ggl::Allocator::instance(void)::alloc;
  a1[4] = 0;
  a1[3] = v6;
  a1[5] = 0;
  a1[6] = 0;
  {
    operator new();
  }
  a1[7] = ggl::Allocator::instance(void)::alloc;
  uint64_t v7 = *(void *)(a2 + 24);
  if (!v7) {
    goto LABEL_6;
  }
  if (v7 != a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
LABEL_6:
    a1[11] = v7;
    goto LABEL_8;
  }
  a1[11] = (unint64_t)(a1 + 8);
  (*(void (**)(void, unint64_t *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1 + 8);
LABEL_8:
  uint64_t v8 = *(void *)(a3 + 24);
  if (!v8)
  {
LABEL_11:
    a1[15] = v8;
    goto LABEL_13;
  }
  if (v8 != a3)
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
    goto LABEL_11;
  }
  a1[15] = (unint64_t)(a1 + 12);
  (*(void (**)(void, unint64_t *))(**(void **)(a3 + 24) + 24))(*(void *)(a3 + 24), a1 + 12);
LABEL_13:
  a1[16] = 2000;
  unint64_t v9 = *a1;
  if (a1[2] - *a1 > 0x31F) {
    goto LABEL_26;
  }
  unint64_t v10 = a1[1];
  uint64_t v11 = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 800, 8);
  uint64_t v12 = v10 - v9;
  unint64_t v13 = v11 + ((v10 - v9) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v15 = *a1;
  unint64_t v14 = a1[1];
  unint64_t v16 = v14 - *a1;
  if (v14 == *a1)
  {
    unint64_t v18 = v11 + ((v10 - v9) & 0xFFFFFFFFFFFFFFF8);
    goto LABEL_24;
  }
  unint64_t v17 = v16 - 8;
  if (v16 - 8 >= 0x58)
  {
    unint64_t v18 = v11 + ((v10 - v9) & 0xFFFFFFFFFFFFFFF8);
    if (v14 - (v12 & 0xFFFFFFFFFFFFFFF8) - v11 >= 0x20)
    {
      uint64_t v19 = v12 >> 3;
      uint64_t v20 = (v17 >> 3) + 1;
      unint64_t v21 = (_OWORD *)(v11 + 8 * v19 - 16);
      uint64_t v22 = (long long *)(v14 - 16);
      uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v24 = *v22;
        *(v21 - 1) = *(v22 - 1);
        *unint64_t v21 = v24;
        v21 -= 2;
        v22 -= 2;
        v23 -= 4;
      }
      while (v23);
      unint64_t v18 = v13 - 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
      v14 -= 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
      if (v20 == (v20 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    unint64_t v18 = v11 + ((v10 - v9) & 0xFFFFFFFFFFFFFFF8);
  }
  do
  {
    uint64_t v25 = *(void *)(v14 - 8);
    v14 -= 8;
    *(void *)(v18 - 8) = v25;
    v18 -= 8;
  }
  while (v14 != v15);
LABEL_23:
  unint64_t v14 = *a1;
LABEL_24:
  *a1 = v18;
  a1[1] = v13;
  unint64_t v26 = a1[2];
  a1[2] = v11 + 800;
  if (v14) {
    (*(void (**)(unint64_t, unint64_t, unint64_t))(*(void *)a1[3] + 40))(a1[3], v14, v26 - v14);
  }
LABEL_26:
  unint64_t v27 = a1[4];
  if (a1[6] - v27 > 0x31F) {
    return a1;
  }
  unint64_t v28 = a1[5];
  uint64_t v29 = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)a1[7] + 16))(a1[7], 800, 8);
  uint64_t v30 = v28 - v27;
  unint64_t v31 = v29 + ((v28 - v27) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v33 = a1[4];
  unint64_t v32 = a1[5];
  unint64_t v34 = v32 - v33;
  if (v32 == v33)
  {
    unint64_t v36 = v29 + ((v28 - v27) & 0xFFFFFFFFFFFFFFF8);
    goto LABEL_37;
  }
  unint64_t v35 = v34 - 8;
  if (v34 - 8 >= 0x58)
  {
    unint64_t v36 = v29 + ((v28 - v27) & 0xFFFFFFFFFFFFFFF8);
    if (v32 - (v30 & 0xFFFFFFFFFFFFFFF8) - v29 >= 0x20)
    {
      uint64_t v37 = v30 >> 3;
      uint64_t v38 = (v35 >> 3) + 1;
      size_t v39 = (_OWORD *)(v29 + 8 * v37 - 16);
      uint64_t v40 = (long long *)(v32 - 16);
      uint64_t v41 = v38 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v42 = *v40;
        *(v39 - 1) = *(v40 - 1);
        _OWORD *v39 = v42;
        v39 -= 2;
        v40 -= 2;
        v41 -= 4;
      }
      while (v41);
      unint64_t v36 = v31 - 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
      v32 -= 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
      if (v38 == (v38 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_36;
      }
    }
  }
  else
  {
    unint64_t v36 = v29 + ((v28 - v27) & 0xFFFFFFFFFFFFFFF8);
  }
  do
  {
    uint64_t v43 = *(void *)(v32 - 8);
    v32 -= 8;
    *(void *)(v36 - 8) = v43;
    v36 -= 8;
  }
  while (v32 != v33);
LABEL_36:
  unint64_t v32 = a1[4];
LABEL_37:
  a1[4] = v36;
  a1[5] = v31;
  unint64_t v44 = a1[6];
  a1[6] = v29 + 800;
  if (v32) {
    (*(void (**)(unint64_t, unint64_t, unint64_t))(*(void *)a1[7] + 40))(a1[7], v32, v44 - v32);
  }
  return a1;
}

void sub_1A1B71274(_Unwind_Exception *a1)
{
  std::function<ggl::RenderItem * ()(void)>::~function(v3);
  gss::FeatureAttributeSet::~FeatureAttributeSet(v2);
  gss::FeatureAttributeSet::~FeatureAttributeSet(v1);
  _Unwind_Resume(a1);
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_10RenderItemEEC1ENS_8functionIFPS4_vEEENS6_IFvS7_EEEmmEd1_UlS7_E_NS_9allocatorISC_EESA_E7__cloneEPNS0_6__baseISA_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57AC08;
}

uint64_t md::CartographicTiledRenderLayer<md::MapTileDataRenderable<md::RasterTileData>>::CartographicTiledRenderLayer(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  *(void *)a1 = &unk_1EF530C60;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  uint64_t v12 = *(const void **)a5;
  uint64_t v11 = *(void *)(a5 + 8);
  int64_t v13 = v11 - *(void *)a5;
  if (v11 != *(void *)a5)
  {
    if (v13 < 0) {
      abort();
    }
    unint64_t v14 = (char *)operator new(v11 - *(void *)a5);
    *(void *)(a1 + 8) = v14;
    *(void *)(a1 + 16) = v14;
    unint64_t v15 = &v14[2 * (v13 >> 1)];
    *(void *)(a1 + 24) = v15;
    memcpy(v14, v12, v13);
    *(void *)(a1 + 16) = v15;
  }
  *(_WORD *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 34) = a2;
  *(void *)(a1 + 40) = a4;
  *(void *)a1 = &unk_1EF5496E0;
  *(_WORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 120) = 1065353216;
  *(void *)(a1 + 128) = a1 + 136;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = a1 + 160;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = a1 + 184;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = a1 + 208;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 224) = a1 + 232;
  *(void *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 248) = xmmword_1A28FE5D0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 320) = *(_OWORD *)a3;
  *(void *)(a1 + 336) = *(void *)(a3 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(_DWORD *)(a1 + 344) = a6;
  return a1;
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured20Pos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57C6C0;
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_4Clut20Pos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57BEE0;
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_23TextureWithReverseAlpha20Pos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57BBC8;
}

void std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_3,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_3>,ggl::TextureWithReverseAlpha::Pos2DUVPipelineSetup * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5757E0;
}

void std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_2,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_2>,ggl::Clut::Pos2DUVPipelineSetup * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF575798;
}

void std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_1,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_1>,ggl::Textured::Pos2DUVPipelineSetup * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF575750;
}

void std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_0,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_0>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF575708;
}

void std::__function::__func<md::RasterRenderLayer::RasterRenderLayer(md::CartographicRenderer &,md::RasterRenderLayerType,std::shared_ptr<md::RasterSharedRenderResources> const&)::$_0,std::allocator<md::RasterRenderLayer::RasterRenderLayer(md::CartographicRenderer &,md::RasterRenderLayerType,std::shared_ptr<md::RasterSharedRenderResources> const&)::$_0>,BOOL ()(md::MapTileDataRenderable<md::RasterTileData> *,md::MapTileDataRenderable<md::RasterTileData> *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF573350;
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_5,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_5>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF51EAD0;
}

void std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_0,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_0>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF576440;
}

void std::__function::__func<md::LabelRenderer::LabelRenderer(md::LabelWorldTraits const&,ggl::StandardLibrary const&,ggl::RenderTargetFormat const&,gdc::ServiceLocator &)::$_0,std::allocator<md::LabelRenderer::LabelRenderer(md::LabelWorldTraits const&,ggl::StandardLibrary const&,ggl::RenderTargetFormat const&,gdc::ServiceLocator &)::$_0>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56F7F8;
}

void std::__function::__func<md::GlobeRasterRenderResources::GlobeRasterRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::GlobeRasterRenderResources::GlobeRasterRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5779A0;
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_8,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_8>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF577688;
}

void std::__function::__func<md::HillshadeRenderResources::HillshadeRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::HillshadeRenderResources::HillshadeRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF576C20;
}

void std::__function::__func<md::CoastLineRenderResources::CoastLineRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_5,std::allocator<md::CoastLineRenderResources::CoastLineRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_5>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF576B00;
}

void std::__function::__func<md::CoastLineRenderResources::CoastLineRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_4,std::allocator<md::CoastLineRenderResources::CoastLineRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_4>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF576AB8;
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_6,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_6>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF576830;
}

void std::__function::__func<md::BuildingRenderResources::BuildingRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_16,std::allocator<md::BuildingRenderResources::BuildingRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_16>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5763B0;
}

void std::__function::__func<md::BuildingRenderResources::BuildingRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_14,std::allocator<md::BuildingRenderResources::BuildingRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_14>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF576320;
}

void std::__function::__func<md::BuildingRenderResources::BuildingRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_12,std::allocator<md::BuildingRenderResources::BuildingRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_12>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF576290;
}

void sub_1A1B71F28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, char a10)
{
  _Unwind_Resume(a1);
}

void sub_1A1B72100(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::AnimationManager::runAnimation(md::AnimationManager *this, VKAnimation *a2)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = a2;
  BOOL v5 = v4;
  if (*((unsigned char *)this + 233))
  {
    uint64_t v6 = v4;
    [(VKAnimation *)v6 startWithRunner:*((void *)this + 2)];
    double Current = CFAbsoluteTimeGetCurrent();
    -[VKAnimation onTimerFired:](v6, "onTimerFired:");
    if ([(VKAnimation *)v6 timed])
    {
      [(VKAnimation *)v6 duration];
      [(VKAnimation *)v6 onTimerFired:v8 + Current];
    }
    [(VKAnimation *)v6 stop];

    goto LABEL_120;
  }
  std::mutex::lock((std::mutex *)((char *)this + 40));
  uint64_t v9 = [(VKAnimation *)v5 priority];
  unint64_t v10 = v5;
  uint64_t v61 = &unk_1EF5593D8;
  uint64_t v62 = v10;
  unint64_t v11 = [(VKAnimation *)v10 hash];
  uint64_t v12 = (char *)this + 40 * v9;
  int64_t v13 = v12 + 104;
  int8x8_t v14 = *(int8x8_t *)(v12 + 112);
  if (v14)
  {
    unint64_t v15 = v11;
    uint8x8_t v16 = (uint8x8_t)vcnt_s8(v14);
    v16.i16[0] = vaddlv_u8(v16);
    if (v16.u32[0] > 1uLL)
    {
      unint64_t v17 = v11;
      if (v11 >= *(void *)&v14) {
        unint64_t v17 = v11 % *(void *)&v14;
      }
    }
    else
    {
      unint64_t v17 = (*(void *)&v14 - 1) & v11;
    }
    unint64_t v18 = *(unint64_t **)(*(void *)v13 + 8 * v17);
    if (v18)
    {
      unint64_t v2 = *v18;
      if (*v18)
      {
        if (v16.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v20 = *(void *)(v2 + 8);
            if (v15 == v20)
            {
              if (geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(*(void **)(v2 + 24), (uint64_t)&v61))goto LABEL_119; {
            }
              }
            else if ((v20 & (*(void *)&v14 - 1)) != v17)
            {
              goto LABEL_26;
            }
            unint64_t v2 = *(void *)v2;
            if (!v2) {
              goto LABEL_26;
            }
          }
        }
        do
        {
          unint64_t v19 = *(void *)(v2 + 8);
          if (v15 == v19)
          {
            if (geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(*(void **)(v2 + 24), (uint64_t)&v61))goto LABEL_119; {
          }
            }
          else
          {
            if (v19 >= *(void *)&v14) {
              v19 %= *(void *)&v14;
            }
            if (v19 != v17) {
              break;
            }
          }
          unint64_t v2 = *(void *)v2;
        }
        while (v2);
      }
    }
  }
LABEL_26:
  unint64_t v21 = [(VKAnimation *)v62 hash];
  unint64_t v22 = v21;
  unint64_t v23 = *((void *)v13 + 1);
  if (v23)
  {
    uint8x8_t v24 = (uint8x8_t)vcnt_s8((int8x8_t)v23);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      unint64_t v2 = v21;
      if (v21 >= v23) {
        unint64_t v2 = v21 % v23;
      }
    }
    else
    {
      unint64_t v2 = (v23 - 1) & v21;
    }
    uint64_t v25 = *(uint64_t ****)(*(void *)v13 + 8 * v2);
    if (v25)
    {
      unint64_t v26 = *v25;
      if (*v25)
      {
        if (v24.u32[0] < 2uLL)
        {
          while (1)
          {
            unint64_t v28 = v26[1];
            if (v28 == (uint64_t *)v22)
            {
              if (geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(v26[3], (uint64_t)&v61))goto LABEL_107; {
            }
              }
            else if (((unint64_t)v28 & (v23 - 1)) != v2)
            {
              goto LABEL_48;
            }
            unint64_t v26 = (uint64_t **)*v26;
            if (!v26) {
              goto LABEL_48;
            }
          }
        }
        do
        {
          unint64_t v27 = (unint64_t)v26[1];
          if (v27 == v22)
          {
            if (geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(v26[3], (uint64_t)&v61))goto LABEL_107; {
          }
            }
          else
          {
            if (v27 >= v23) {
              v27 %= v23;
            }
            if (v27 != v2) {
              break;
            }
          }
          unint64_t v26 = (uint64_t **)*v26;
        }
        while (v26);
      }
    }
  }
LABEL_48:
  uint64_t v29 = operator new(0x28uLL);
  uint64_t v30 = v13 + 16;
  unint64_t v63 = v29;
  uint64_t v64 = v13 + 16;
  *uint64_t v29 = 0;
  v29[1] = v22;
  v29[2] = &unk_1EF5593D8;
  v29[3] = 0;
  unint64_t v31 = v62;
  unint64_t v32 = (void *)v29[3];
  v29[3] = v31;

  float v33 = (float)(unint64_t)(*((void *)v13 + 3) + 1);
  char v65 = 1;
  float v34 = *((float *)v13 + 8);
  if ((((float)(v34 * (float)v23) >= v33) & ~(v23 == 0)) == 0)
  {
    BOOL v35 = 1;
    if (v23 >= 3) {
      BOOL v35 = (v23 & (v23 - 1)) != 0;
    }
    unint64_t v36 = v35 | (2 * v23);
    unint64_t v37 = vcvtps_u32_f32(v33 / v34);
    if (v36 <= v37) {
      size_t prime = v37;
    }
    else {
      size_t prime = v36;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v23 = *((void *)v13 + 1);
    if (prime <= v23)
    {
      if (prime >= v23) {
        goto LABEL_84;
      }
      unint64_t v49 = vcvtps_u32_f32((float)*((unint64_t *)v13 + 3) / *((float *)v13 + 8));
      if (v23 < 3 || (uint8x8_t v50 = (uint8x8_t)vcnt_s8((int8x8_t)v23), v50.i16[0] = vaddlv_u8(v50), v50.u32[0] > 1uLL))
      {
        unint64_t v49 = std::__next_prime(v49);
      }
      else
      {
        uint64_t v51 = 1 << -(char)__clz(v49 - 1);
        if (v49 >= 2) {
          unint64_t v49 = v51;
        }
      }
      if (prime <= v49) {
        size_t prime = v49;
      }
      if (prime >= v23)
      {
        unint64_t v23 = *((void *)v13 + 1);
LABEL_84:
        if ((v23 & (v23 - 1)) != 0)
        {
          if (v22 >= v23) {
            unint64_t v2 = v22 % v23;
          }
          else {
            unint64_t v2 = v22;
          }
        }
        else
        {
          unint64_t v2 = (v23 - 1) & v22;
        }
        goto LABEL_97;
      }
      if (!prime)
      {
        uint64_t v60 = *(void **)v13;
        *(void *)int64_t v13 = 0;
        if (v60) {
          operator delete(v60);
        }
        unint64_t v23 = 0;
        *((void *)v13 + 1) = 0;
        goto LABEL_84;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    size_t v39 = operator new(8 * prime);
    uint64_t v40 = *(void **)v13;
    *(void *)int64_t v13 = v39;
    if (v40) {
      operator delete(v40);
    }
    uint64_t v41 = 0;
    *((void *)v13 + 1) = prime;
    do
      *(void *)(*(void *)v13 + 8 * v41++) = 0;
    while (prime != v41);
    long long v42 = (void *)*v30;
    if (!*v30)
    {
LABEL_83:
      unint64_t v23 = prime;
      goto LABEL_84;
    }
    size_t v43 = v42[1];
    size_t v44 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v45 = v43 & v44;
      *(void *)(*(void *)v13 + 8 * v45) = v30;
      for (i = (void *)*v42; *v42; i = (void *)*v42)
      {
        size_t v47 = i[1] & v44;
        if (v47 == v45)
        {
          long long v42 = i;
        }
        else if (*(void *)(*(void *)v13 + 8 * v47))
        {
          *long long v42 = *i;
          uint64_t v48 = 8 * v47;
          void *i = **(void **)(*(void *)v13 + v48);
          **(void **)(*(void *)v13 + v48) = i;
        }
        else
        {
          *(void *)(*(void *)v13 + 8 * v47) = v42;
          long long v42 = i;
          size_t v45 = v47;
        }
      }
      goto LABEL_83;
    }
    if (v43 >= prime) {
      v43 %= prime;
    }
    *(void *)(*(void *)v13 + 8 * v43) = v30;
    unsigned int v52 = (void *)*v42;
    if (!*v42) {
      goto LABEL_83;
    }
    while (1)
    {
      size_t v54 = v52[1];
      if (v54 >= prime) {
        v54 %= prime;
      }
      if (v54 != v43)
      {
        if (!*(void *)(*(void *)v13 + 8 * v54))
        {
          *(void *)(*(void *)v13 + 8 * v54) = v42;
          goto LABEL_88;
        }
        *long long v42 = *v52;
        uint64_t v53 = 8 * v54;
        void *v52 = **(void **)(*(void *)v13 + v53);
        **(void **)(*(void *)v13 + v53) = v52;
        unsigned int v52 = v42;
      }
      size_t v54 = v43;
LABEL_88:
      long long v42 = v52;
      unsigned int v52 = (void *)*v52;
      size_t v43 = v54;
      if (!v52) {
        goto LABEL_83;
      }
    }
  }
LABEL_97:
  unsigned int v55 = *(void **)v13;
  uint64_t v56 = *(void **)(*(void *)v13 + 8 * v2);
  if (v56)
  {
    *uint64_t v29 = *v56;
LABEL_105:
    void *v56 = v29;
    goto LABEL_106;
  }
  *uint64_t v29 = *v30;
  *uint64_t v30 = v29;
  v55[v2] = v30;
  if (*v29)
  {
    unint64_t v57 = *(void *)(*v29 + 8);
    if ((v23 & (v23 - 1)) != 0)
    {
      if (v57 >= v23) {
        v57 %= v23;
      }
    }
    else
    {
      v57 &= v23 - 1;
    }
    uint64_t v56 = (void *)(*(void *)v13 + 8 * v57);
    goto LABEL_105;
  }
LABEL_106:
  ++*((void *)v13 + 3);
LABEL_107:
  uint64_t v58 = *((void *)this + 2);
  unint64_t v59 = v62;
  [(VKAnimation *)v59 startWithRunner:v58];

  if ([(VKAnimation *)v10 hasFrequency]) {
    operator new();
  }
  atomic_store(1u, (unsigned __int8 *)this + 184);
LABEL_119:
  uint64_t v61 = &unk_1EF5593D8;

  std::mutex::unlock((std::mutex *)((char *)this + 40));
LABEL_120:
}

void sub_1A1B72E30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::mutex *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::unique_ptr<gdc::Timer>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::unique_ptr<gdc::Timer>>,void *>>>>::~unique_ptr[abi:nn180100](&a18);

  std::mutex::unlock(a9);
  _Unwind_Resume(a1);
}

void sub_1A1B73590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,id location)
{
  _Unwind_Resume(a1);
}

void sub_1A1B7377C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN2md10StyleLogic18initiateTransitionEf_block_invoke(uint64_t a1, float a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 208);
  float v4 = COERCE_FLOAT(atomic_load((unsigned int *)(v3 + 256)));
  if (v4 == a2) {
    goto LABEL_15;
  }
  *(float *)(v3 + 256) = a2;
  float v5 = COERCE_FLOAT(atomic_load((unsigned int *)(v3 + 256)));
  if (v5 <= 0.0)
  {
    unint64_t v6 = *(unsigned __int16 *)(v3 + 242);
    if (v6 == *(unsigned __int16 *)(v3 + 226))
    {
      if (!*(_WORD *)(v3 + 242)) {
        goto LABEL_13;
      }
      uint64_t v7 = *(_DWORD **)(v3 + 232);
      double v8 = *(_DWORD **)(v3 + 216);
      if (*v7 == *v8)
      {
        uint64_t v9 = (unsigned __int16 *)((char *)v8 + *(unsigned __int16 *)(v3 + 224));
        unint64_t v10 = (unsigned __int16 *)((char *)v7 + *(unsigned __int16 *)(v3 + 240));
        if (*v10 == *v9)
        {
          unint64_t v11 = 0;
          uint64_t v12 = 1;
          while (1)
          {
            if (v6 == v12)
            {
              unint64_t v13 = *(unsigned __int16 *)(v3 + 242);
              goto LABEL_41;
            }
            unint64_t v13 = v12;
            ++v11;
            if (v7[v12] != v8[v12]) {
              break;
            }
            ++v12;
            if (v10[v13] != v9[v13]) {
              goto LABEL_41;
            }
          }
          unint64_t v13 = v11;
LABEL_41:
          LOBYTE(v6) = v13 < v6;
          goto LABEL_13;
        }
      }
    }
  }
  LOBYTE(v6) = 1;
LABEL_13:
  atomic_store(v6, (unsigned __int8 *)(v3 + 254));
  int v14 = *(unsigned __int8 *)(v3 + 253);
  unsigned __int8 v15 = atomic_load((unsigned __int8 *)(v3 + 254));
  if (v14 != (v15 & 1))
  {
    unsigned __int8 v16 = atomic_load((unsigned __int8 *)(v3 + 254));
    *(unsigned char *)(v3 + 253) = v16 & 1;
    atomic_fetch_add((atomic_uint *volatile)(v3 + 248), 1u);
  }
LABEL_15:
  uint64_t v17 = *(void *)(v2 + 224);
  float v18 = COERCE_FLOAT(atomic_load((unsigned int *)(v17 + 256)));
  if (v18 == a2) {
    goto LABEL_29;
  }
  *(float *)(v17 + 256) = a2;
  float v19 = COERCE_FLOAT(atomic_load((unsigned int *)(v17 + 256)));
  if (v19 <= 0.0)
  {
    unint64_t v20 = *(unsigned __int16 *)(v17 + 242);
    if (v20 == *(unsigned __int16 *)(v17 + 226))
    {
      if (!*(_WORD *)(v17 + 242)) {
        goto LABEL_27;
      }
      unint64_t v21 = *(_DWORD **)(v17 + 232);
      unint64_t v22 = *(_DWORD **)(v17 + 216);
      if (*v21 == *v22)
      {
        unint64_t v23 = (unsigned __int16 *)((char *)v22 + *(unsigned __int16 *)(v17 + 224));
        uint8x8_t v24 = (unsigned __int16 *)((char *)v21 + *(unsigned __int16 *)(v17 + 240));
        if (*v24 == *v23)
        {
          unint64_t v25 = 0;
          uint64_t v26 = 1;
          while (1)
          {
            if (v20 == v26)
            {
              unint64_t v27 = *(unsigned __int16 *)(v17 + 242);
              goto LABEL_44;
            }
            unint64_t v27 = v26;
            ++v25;
            if (v21[v26] != v22[v26]) {
              break;
            }
            ++v26;
            if (v24[v27] != v23[v27]) {
              goto LABEL_44;
            }
          }
          unint64_t v27 = v25;
LABEL_44:
          LOBYTE(v20) = v27 < v20;
          goto LABEL_27;
        }
      }
    }
  }
  LOBYTE(v20) = 1;
LABEL_27:
  atomic_store(v20, (unsigned __int8 *)(v17 + 254));
  int v28 = *(unsigned __int8 *)(v17 + 253);
  unsigned __int8 v29 = atomic_load((unsigned __int8 *)(v17 + 254));
  if (v28 != (v29 & 1))
  {
    unsigned __int8 v30 = atomic_load((unsigned __int8 *)(v17 + 254));
    *(unsigned char *)(v17 + 253) = v30 & 1;
    atomic_fetch_add((atomic_uint *volatile)(v17 + 248), 1u);
  }
LABEL_29:
  char v34 = 2;
  unint64_t v31 = *(char **)(v2 + 1128);
  unint64_t v32 = *(char **)(v2 + 1136);
  if (v31 != v32)
  {
    while (*v31 <= 1u)
    {
      if (++v31 == v32) {
        goto LABEL_35;
      }
    }
  }
  if (v31 == v32 || (unint64_t v32 = v31, *v31 != 2)) {
LABEL_35:
  }
    std::vector<md::StyleManagerEvent>::insert(v2 + 1128, v32, &v34);
  uint64_t v33 = **(void **)(v2 + 1240);
  if (v33)
  {
    char v35 = 12;
    md::MapEngine::setNeedsTick(v33, &v35);
  }
}

uint64_t VKAnimationCurveEaseOut_block_invoke_5(double a1)
{
  int v1 = LODWORD(a1);
  if (_ZZUb3_E9onceToken != -1) {
    dispatch_once(&_ZZUb3_E9onceToken, &__block_literal_global_18);
  }
  uint64_t v2 = (void *)_ZZUb3_E14timingFunction;
  LODWORD(a1) = v1;
  return [v2 _solveForInput:a1];
}

void md::AnimationManager::animationDidStop(md::AnimationManager *this, VKAnimation *a2)
{
  uint64_t v3 = a2;
  std::mutex::lock((std::mutex *)((char *)this + 40));
  uint64_t v4 = [(VKAnimation *)v3 priority];
  float v5 = v3;
  uint64_t v40 = &unk_1EF5593D8;
  uint64_t v41 = v5;
  unint64_t v6 = [(VKAnimation *)v5 hash];
  uint64_t v7 = (char *)this + 40 * v4;
  double v8 = v7 + 104;
  int8x8_t v9 = *(int8x8_t *)(v7 + 112);
  if (v9)
  {
    unint64_t v10 = v6;
    uint8x8_t v11 = (uint8x8_t)vcnt_s8(v9);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v12 = v6;
      if (v6 >= *(void *)&v9) {
        unint64_t v12 = v6 % *(void *)&v9;
      }
    }
    else
    {
      unint64_t v12 = (*(void *)&v9 - 1) & v6;
    }
    unint64_t v13 = *(void ****)(*v8 + 8 * v12);
    if (v13)
    {
      int v14 = *v13;
      if (*v13)
      {
        if (v11.u32[0] < 2uLL)
        {
          uint64_t v15 = *(void *)&v9 - 1;
          while (1)
          {
            unint64_t v17 = (unint64_t)v14[1];
            if (v17 == v10)
            {
              if (geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(v14[3], (uint64_t)&v40))goto LABEL_21; {
            }
              }
            else if ((v17 & v15) != v12)
            {
              goto LABEL_48;
            }
            int v14 = (void **)*v14;
            if (!v14) {
              goto LABEL_48;
            }
          }
        }
        do
        {
          unint64_t v16 = (unint64_t)v14[1];
          if (v16 == v10)
          {
            if (geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(v14[3], (uint64_t)&v40))
            {
LABEL_21:
              int8x8_t v18 = (int8x8_t)v8[1];
              unint64_t v19 = (unint64_t)v14[1];
              uint8x8_t v20 = (uint8x8_t)vcnt_s8(v18);
              v20.i16[0] = vaddlv_u8(v20);
              if (v20.u32[0] > 1uLL)
              {
                if (v19 >= *(void *)&v18) {
                  v19 %= *(void *)&v18;
                }
              }
              else
              {
                v19 &= *(void *)&v18 - 1;
              }
              unint64_t v21 = *(void ***)(*v8 + 8 * v19);
              do
              {
                unint64_t v22 = v21;
                unint64_t v21 = (void **)*v21;
              }
              while (v21 != v14);
              if (v22 == v8 + 2) {
                goto LABEL_38;
              }
              unint64_t v23 = (unint64_t)v22[1];
              if (v20.u32[0] > 1uLL)
              {
                if (v23 >= *(void *)&v18) {
                  v23 %= *(void *)&v18;
                }
              }
              else
              {
                v23 &= *(void *)&v18 - 1;
              }
              if (v23 != v19)
              {
LABEL_38:
                if (!*v14) {
                  goto LABEL_39;
                }
                unint64_t v24 = *((void *)*v14 + 1);
                if (v20.u32[0] > 1uLL)
                {
                  if (v24 >= *(void *)&v18) {
                    v24 %= *(void *)&v18;
                  }
                }
                else
                {
                  v24 &= *(void *)&v18 - 1;
                }
                if (v24 != v19) {
LABEL_39:
                }
                  *(void *)(*v8 + 8 * v19) = 0;
              }
              unint64_t v25 = *v14;
              if (*v14)
              {
                unint64_t v26 = v25[1];
                if (v20.u32[0] > 1uLL)
                {
                  if (v26 >= *(void *)&v18) {
                    v26 %= *(void *)&v18;
                  }
                }
                else
                {
                  v26 &= *(void *)&v18 - 1;
                }
                if (v26 != v19)
                {
                  *(void *)(*v8 + 8 * v26) = v22;
                  unint64_t v25 = *v14;
                }
              }
              *unint64_t v22 = v25;
              char *v14 = 0;
              --v8[3];
              (*(void (**)(void))v14[2])();
              operator delete(v14);
              break;
            }
          }
          else
          {
            if (v16 >= *(void *)&v9) {
              v16 %= *(void *)&v9;
            }
            if (v16 != v12) {
              break;
            }
          }
          int v14 = (void **)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_48:
  unint64_t v27 = (void *)((char *)this + 192);
  int v28 = std::__hash_table<std::__hash_value_type<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::unique_ptr<gdc::Timer>>,std::__unordered_map_hasher<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::__hash_value_type<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::unique_ptr<gdc::Timer>>,std::hash<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::equal_to<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,true>,std::__unordered_map_equal<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::__hash_value_type<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::unique_ptr<gdc::Timer>>,std::equal_to<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::hash<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,true>,std::allocator<std::__hash_value_type<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::unique_ptr<gdc::Timer>>>>::find<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>((void *)this + 24, (uint64_t)&v40);
  unsigned __int8 v29 = v28;
  if (v28)
  {
    (*(void (**)(uint64_t *))(*v28[5] + 40))(v28[5]);
    int8x8_t v30 = *(int8x8_t *)((char *)this + 200);
    unint64_t v31 = v29[1];
    uint8x8_t v32 = (uint8x8_t)vcnt_s8(v30);
    v32.i16[0] = vaddlv_u8(v32);
    if (v32.u32[0] > 1uLL)
    {
      if ((unint64_t)v31 >= *(void *)&v30) {
        unint64_t v31 = (uint64_t *)((unint64_t)v31 % *(void *)&v30);
      }
    }
    else
    {
      unint64_t v31 = (uint64_t *)((*(void *)&v30 - 1) & (unint64_t)v31);
    }
    uint64_t v33 = *(uint64_t ***)(*v27 + 8 * (void)v31);
    do
    {
      char v34 = v33;
      uint64_t v33 = (uint64_t **)*v33;
    }
    while (v33 != v29);
    if (v34 == (uint64_t **)((char *)this + 208)) {
      goto LABEL_66;
    }
    unint64_t v35 = (unint64_t)v34[1];
    if (v32.u32[0] > 1uLL)
    {
      if (v35 >= *(void *)&v30) {
        v35 %= *(void *)&v30;
      }
    }
    else
    {
      v35 &= *(void *)&v30 - 1;
    }
    if ((uint64_t *)v35 != v31)
    {
LABEL_66:
      if (!*v29) {
        goto LABEL_67;
      }
      unint64_t v36 = (*v29)[1];
      if (v32.u32[0] > 1uLL)
      {
        if (v36 >= *(void *)&v30) {
          v36 %= *(void *)&v30;
        }
      }
      else
      {
        v36 &= *(void *)&v30 - 1;
      }
      if ((uint64_t *)v36 != v31) {
LABEL_67:
      }
        *(void *)(*v27 + 8 * (void)v31) = 0;
    }
    unint64_t v37 = *v29;
    if (*v29)
    {
      unint64_t v38 = v37[1];
      if (v32.u32[0] > 1uLL)
      {
        if (v38 >= *(void *)&v30) {
          v38 %= *(void *)&v30;
        }
      }
      else
      {
        v38 &= *(void *)&v30 - 1;
      }
      if ((uint64_t *)v38 != v31)
      {
        *(void *)(*v27 + 8 * v38) = v34;
        unint64_t v37 = *v29;
      }
    }
    *char v34 = v37;
    *unsigned __int8 v29 = 0;
    --*((void *)this + 27);
    size_t v39 = v29[5];
    v29[5] = 0;
    if (v39) {
      (*(void (**)(uint64_t *))(*v39 + 8))(v39);
    }
    v29[2] = (uint64_t *)&unk_1EF5593D8;

    operator delete(v29);
  }
  uint64_t v40 = &unk_1EF5593D8;

  std::mutex::unlock((std::mutex *)((char *)this + 40));
  atomic_store(1u, (unsigned __int8 *)this + 184);
}

void sub_1A1B73F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  std::mutex::unlock(v11);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::unique_ptr<gdc::Timer>>,std::__unordered_map_hasher<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::__hash_value_type<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::unique_ptr<gdc::Timer>>,std::hash<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::equal_to<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,true>,std::__unordered_map_equal<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::__hash_value_type<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::unique_ptr<gdc::Timer>>,std::equal_to<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::hash<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,true>,std::allocator<std::__hash_value_type<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::unique_ptr<gdc::Timer>>>>::find<geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(void *a1, uint64_t a2)
{
  unint64_t v4 = [*(id *)(a2 + 8) hash];
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v8 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v8 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v8 = (*(void *)&v5 - 1) & v4;
  }
  int8x8_t v9 = *(uint64_t ****)(*a1 + 8 * v8);
  if (!v9) {
    return 0;
  }
  unint64_t v10 = *v9;
  if (*v9)
  {
    if (v7.u32[0] < 2uLL)
    {
      uint64_t v11 = *(void *)&v5 - 1;
      while (1)
      {
        unint64_t v13 = v10[1];
        if (v13 == (uint64_t *)v6)
        {
          if (geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(v10[3], a2))return v10; {
        }
          }
        else if (((unint64_t)v13 & v11) != v8)
        {
          return 0;
        }
        unint64_t v10 = (uint64_t **)*v10;
        if (!v10) {
          return v10;
        }
      }
    }
    do
    {
      unint64_t v12 = (unint64_t)v10[1];
      if (v12 == v6)
      {
        if (geo::_retain_ptr<VKAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(v10[3], a2))return v10; {
      }
        }
      else
      {
        if (v12 >= *(void *)&v5) {
          v12 %= *(void *)&v5;
        }
        if (v12 != v8) {
          return 0;
        }
      }
      unint64_t v10 = (uint64_t **)*v10;
    }
    while (v10);
  }
  return v10;
}

uint64_t VKAnimationCurveEaseInOut_block_invoke_7(double a1)
{
  int v1 = LODWORD(a1);
  if (_ZZUb5_E9onceToken != -1) {
    dispatch_once(&_ZZUb5_E9onceToken, &__block_literal_global_22);
  }
  uint64_t v2 = (void *)_ZZUb5_E14timingFunction;
  LODWORD(a1) = v1;
  return [v2 _solveForInput:a1];
}

void sub_1A1B744A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN2md10StyleLogic18initiateTransitionEf_block_invoke_2(uint64_t a1, char a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = **(void **)(v4 + 1240);
  if (v5)
  {
    v13[0] = 12;
    md::MapEngine::setNeedsTick(v5, v13);
  }
  if ((a2 & 1) == 0 && *(unsigned char *)(a1 + 40)) {
    goto LABEL_21;
  }
  unint64_t v6 = (void (**)(void))&unk_1EF56D4D0;
  *(void *)unint64_t v13 = &unk_1EF56D4D0;
  int v14 = (void (***)(void))v13;
  if (!*(void *)(v4 + 256))
  {
    md::StyleLogic::updateConfiguration((md::StyleLogic *)v4, *(_DWORD *)(v4 + 1096));
    if (!v14)
    {
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_33:
      __break(1u);
      return;
    }
    unint64_t v6 = *v14;
  }
  v6[6]();
  if (v14 == (void (***)(void))v13)
  {
    (*(void (**)(char *))(*(void *)v13 + 32))(v13);
  }
  else if (v14)
  {
    (*v14)[5]();
  }
  uint8x8_t v7 = (void (**)(void))&unk_1EF56D518;
  v11[0] = &unk_1EF56D518;
  unint64_t v12 = (void (***)(void))v11;
  if (*(void *)(v4 + 272)) {
    goto LABEL_16;
  }
  md::StyleLogic::updateConfiguration((md::StyleLogic *)v4, *(_DWORD *)(v4 + 1096));
  if (!*(void *)(v4 + 272)) {
    goto LABEL_17;
  }
  if (!v12)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    goto LABEL_33;
  }
  uint8x8_t v7 = *v12;
LABEL_16:
  v7[6]();
LABEL_17:
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*v12)[5]();
  }
LABEL_21:
  v13[0] = 3;
  unint64_t v8 = *(char **)(v4 + 1128);
  int8x8_t v9 = *(char **)(v4 + 1136);
  if (v8 != v9)
  {
    while (*v8 <= 2u)
    {
      if (++v8 == v9) {
        goto LABEL_27;
      }
    }
  }
  if (v8 == v9 || (int8x8_t v9 = v8, *v8 != 3)) {
LABEL_27:
  }
    std::vector<md::StyleManagerEvent>::insert(v4 + 1128, v9, v13);
  unint64_t v10 = *(void **)(v4 + 1184);
  if (v10)
  {
    *(void *)(v4 + 1184) = 0;
  }
  *(unsigned char *)(v4 + 337) = 0;
}

void sub_1A1B74A58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a13 == &a10)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
    _Unwind_Resume(exception_object);
  }
  if (a13)
  {
    (*(void (**)(void))(*a13 + 40))();
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<md::StyleManagerEvent>::insert(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  unint64_t v6 = *(char **)(a1 + 8);
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 < v7)
  {
    if (__src == v6)
    {
      *unsigned int __src = *a3;
      *(void *)(a1 + 8) = __src + 1;
    }
    else
    {
      unint64_t v8 = __src + 1;
      if (v6)
      {
        char *v6 = *(v6 - 1);
        int8x8_t v9 = v6 + 1;
      }
      else
      {
        int8x8_t v9 = 0;
      }
      *(void *)(a1 + 8) = v9;
      if (v6 != v8) {
        memmove(__src + 1, __src, v6 - v8);
      }
      if (__src <= v3 && *(void *)(a1 + 8) > (unint64_t)v3) {
        ++v3;
      }
      *unsigned int __src = *v3;
    }
    return;
  }
  unint64_t v10 = *(char **)a1;
  uint64_t v11 = (uint64_t)&v6[-*(void *)a1 + 1];
  if (v11 < 0) {
    abort();
  }
  uint64_t v12 = __src - v10;
  unint64_t v13 = v7 - (void)v10;
  if (2 * v13 > v11) {
    uint64_t v11 = 2 * v13;
  }
  if (v13 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v14 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v14 = v11;
  }
  if (v14) {
    uint64_t v15 = (char *)operator new(v14);
  }
  else {
    uint64_t v15 = 0;
  }
  unint64_t v16 = &v15[v12];
  unint64_t v17 = &v15[v14];
  if (v12 == v14)
  {
    if (v12 < 1)
    {
      if ((unint64_t)(2 * v12) <= 1) {
        size_t v19 = 1;
      }
      else {
        size_t v19 = 2 * v12;
      }
      uint8x8_t v20 = (char *)operator new(v19);
      unint64_t v16 = &v20[v19 >> 2];
      unint64_t v17 = &v20[v19];
      if (v15)
      {
        operator delete(v15);
        unint64_t v10 = *(char **)a1;
      }
    }
    else
    {
      if (v12 + 1 >= 0) {
        uint64_t v18 = v12 + 1;
      }
      else {
        uint64_t v18 = v12 + 2;
      }
      v16 -= v18 >> 1;
    }
  }
  *unint64_t v16 = *v3;
  unint64_t v21 = v16 + 1;
  if (v10 != __src)
  {
    unint64_t v22 = __src - v10;
    if ((unint64_t)(__src - v10) < 0x20)
    {
      unint64_t v23 = __src;
    }
    else if ((unint64_t)(__src - v16) < 0x20)
    {
      unint64_t v23 = __src;
    }
    else
    {
      unint64_t v23 = &__src[-(v22 & 0xFFFFFFFFFFFFFFE0)];
      unint64_t v24 = __src - 16;
      unint64_t v25 = v16 - 16;
      unint64_t v26 = v22 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v27 = *(_OWORD *)v24;
        *((_OWORD *)v25 - 1) = *((_OWORD *)v24 - 1);
        *(_OWORD *)unint64_t v25 = v27;
        v24 -= 32;
        v25 -= 32;
        v26 -= 32;
      }
      while (v26);
      v16 -= v22 & 0xFFFFFFFFFFFFFFE0;
      if (v22 == (v22 & 0xFFFFFFFFFFFFFFE0)) {
        goto LABEL_43;
      }
    }
    do
    {
      char v28 = *--v23;
      *--unint64_t v16 = v28;
    }
    while (v23 != v10);
  }
LABEL_43:
  unsigned __int8 v29 = *(unsigned char **)(a1 + 8);
  uint64_t v30 = v29 - __src;
  if (v29 != __src)
  {
    memmove(v21, __src, v29 - __src);
    unint64_t v10 = *(char **)a1;
  }
  *(void *)a1 = v16;
  *(void *)(a1 + 8) = &v21[v30];
  *(void *)(a1 + 16) = v17;
  if (v10)
  {
    operator delete(v10);
  }
}

void sub_1A1B74DAC(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<md::StyleLogic::_finishStyleBlend(void)::$_1,std::allocator<md::StyleLogic::_finishStyleBlend(void)::$_1>,void ()(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(*a2 + 520);
  if (!v3) {
    goto LABEL_20;
  }
  uint64_t v4 = (geo::read_write_lock *)pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 16));
  if (v4) {
    geo::read_write_lock::logFailure(v4, (uint64_t)"write lock", v5);
  }
  geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator=((void *)(v3 + 216), v3 + 232);
  unsigned int v6 = atomic_load((unsigned int *)(v3 + 256));
  if ((v6 & 0x7FFFFFFF) != 0)
  {
    *(_DWORD *)(v3 + 256) = 0;
    float v7 = COERCE_FLOAT(atomic_load((unsigned int *)(v3 + 256)));
    if (v7 <= 0.0)
    {
      unint64_t v8 = *(unsigned __int16 *)(v3 + 242);
      if (v8 == *(unsigned __int16 *)(v3 + 226))
      {
        if (!*(_WORD *)(v3 + 242)) {
          goto LABEL_16;
        }
        int8x8_t v9 = *(_DWORD **)(v3 + 232);
        unint64_t v10 = *(_DWORD **)(v3 + 216);
        if (*v9 == *v10)
        {
          uint64_t v11 = (unsigned __int16 *)((char *)v10 + *(unsigned __int16 *)(v3 + 224));
          uint64_t v12 = (unsigned __int16 *)((char *)v9 + *(unsigned __int16 *)(v3 + 240));
          if (*v12 == *v11)
          {
            unint64_t v13 = 0;
            uint64_t v14 = 1;
            while (1)
            {
              if (v8 == v14)
              {
                unint64_t v15 = *(unsigned __int16 *)(v3 + 242);
                goto LABEL_46;
              }
              unint64_t v15 = v14;
              ++v13;
              if (v9[v14] != v10[v14]) {
                break;
              }
              ++v14;
              if (v12[v15] != v11[v15]) {
                goto LABEL_46;
              }
            }
            unint64_t v15 = v13;
LABEL_46:
            LOBYTE(v8) = v15 < v8;
            goto LABEL_16;
          }
        }
      }
    }
    LOBYTE(v8) = 1;
LABEL_16:
    atomic_store(v8, (unsigned __int8 *)(v3 + 254));
    int v16 = *(unsigned __int8 *)(v3 + 253);
    unsigned __int8 v17 = atomic_load((unsigned __int8 *)(v3 + 254));
    if (v16 != (v17 & 1))
    {
      unsigned __int8 v18 = atomic_load((unsigned __int8 *)(v3 + 254));
      *(unsigned char *)(v3 + 253) = v18 & 1;
      atomic_fetch_add((atomic_uint *volatile)(v3 + 248), 1u);
    }
  }
  size_t v19 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(v3 + 16));
  if (v19) {
    geo::read_write_lock::logFailure(v19, (uint64_t)"unlock", v20);
  }
LABEL_20:
  unint64_t v21 = (geo::read_write_lock *)pthread_rwlock_rdlock((pthread_rwlock_t *)(v2 + 320));
  if (v21) {
    geo::read_write_lock::logFailure(v21, (uint64_t)"read lock", v22);
  }
  for (i = *(void **)(v2 + 88); i != *(void **)(v2 + 96); i += 2)
  {
    unint64_t v24 = (std::__shared_weak_count *)i[1];
    if (v24)
    {
      unint64_t v25 = std::__shared_weak_count::lock(v24);
      if (v25)
      {
        unint64_t v26 = v25;
        long long v27 = (void *)*i;
        if (*i)
        {
          uint64_t v28 = v27[32];
          if (v28)
          {
            uint64_t v29 = v27[33];
            if (v29) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v29 + 8), 1uLL, memory_order_relaxed);
            }
            uint64_t v30 = (std::__shared_weak_count *)v27[31];
            v27[30] = v28;
            v27[31] = v29;
            if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
              std::__shared_weak_count::__release_weak(v30);
            }
            unint64_t v31 = (std::__shared_weak_count *)v27[33];
            v27[32] = 0;
            v27[33] = 0;
            if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
              std::__shared_weak_count::__release_weak(v31);
            }
          }
        }
        if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
    }
  }
  uint8x8_t v32 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(v2 + 320));
  if (v32)
  {
    geo::read_write_lock::logFailure(v32, (uint64_t)"unlock", v33);
  }
}

void sub_1A1B7514C(_Unwind_Exception *a1)
{
  uint64_t v3 = (geo::read_write_lock *)pthread_rwlock_unlock(v1);
  if (v3) {
    geo::read_write_lock::logFailure(v3, (uint64_t)"unlock", v4);
  }
  _Unwind_Resume(a1);
}

void std::__function::__func<md::StyleLogic::_finishStyleBlend(void)::$_0,std::allocator<md::StyleLogic::_finishStyleBlend(void)::$_0>,void ()(std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&)>::operator()(uint64_t a1, uint64_t *a2)
{
}

void gss::StylesheetManager<gss::PropertyID>::finishBlend(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 520);
  if (!v2) {
    goto LABEL_20;
  }
  uint64_t v3 = (geo::read_write_lock *)pthread_rwlock_wrlock((pthread_rwlock_t *)(v2 + 16));
  if (v3) {
    geo::read_write_lock::logFailure(v3, (uint64_t)"write lock", v4);
  }
  geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator=((void *)(v2 + 216), v2 + 232);
  unsigned int v5 = atomic_load((unsigned int *)(v2 + 256));
  if ((v5 & 0x7FFFFFFF) != 0)
  {
    *(_DWORD *)(v2 + 256) = 0;
    float v6 = COERCE_FLOAT(atomic_load((unsigned int *)(v2 + 256)));
    if (v6 <= 0.0)
    {
      unint64_t v7 = *(unsigned __int16 *)(v2 + 242);
      if (v7 == *(unsigned __int16 *)(v2 + 226))
      {
        if (!*(_WORD *)(v2 + 242)) {
          goto LABEL_16;
        }
        unint64_t v8 = *(_DWORD **)(v2 + 232);
        int8x8_t v9 = *(_DWORD **)(v2 + 216);
        if (*v8 == *v9)
        {
          unint64_t v10 = (unsigned __int16 *)((char *)v9 + *(unsigned __int16 *)(v2 + 224));
          uint64_t v11 = (unsigned __int16 *)((char *)v8 + *(unsigned __int16 *)(v2 + 240));
          if (*v11 == *v10)
          {
            unint64_t v12 = 0;
            uint64_t v13 = 1;
            while (1)
            {
              if (v7 == v13)
              {
                unint64_t v14 = *(unsigned __int16 *)(v2 + 242);
                goto LABEL_46;
              }
              unint64_t v14 = v13;
              ++v12;
              if (v8[v13] != v9[v13]) {
                break;
              }
              ++v13;
              if (v11[v14] != v10[v14]) {
                goto LABEL_46;
              }
            }
            unint64_t v14 = v12;
LABEL_46:
            LOBYTE(v7) = v14 < v7;
            goto LABEL_16;
          }
        }
      }
    }
    LOBYTE(v7) = 1;
LABEL_16:
    atomic_store(v7, (unsigned __int8 *)(v2 + 254));
    int v15 = *(unsigned __int8 *)(v2 + 253);
    unsigned __int8 v16 = atomic_load((unsigned __int8 *)(v2 + 254));
    if (v15 != (v16 & 1))
    {
      unsigned __int8 v17 = atomic_load((unsigned __int8 *)(v2 + 254));
      *(unsigned char *)(v2 + 253) = v17 & 1;
      atomic_fetch_add((atomic_uint *volatile)(v2 + 248), 1u);
    }
  }
  unsigned __int8 v18 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(v2 + 16));
  if (v18) {
    geo::read_write_lock::logFailure(v18, (uint64_t)"unlock", v19);
  }
LABEL_20:
  uint8x8_t v20 = (geo::read_write_lock *)pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 320));
  if (v20) {
    geo::read_write_lock::logFailure(v20, (uint64_t)"read lock", v21);
  }
  for (i = *(void **)(a1 + 88); i != *(void **)(a1 + 96); i += 2)
  {
    unint64_t v23 = (std::__shared_weak_count *)i[1];
    if (v23)
    {
      unint64_t v24 = std::__shared_weak_count::lock(v23);
      if (v24)
      {
        unint64_t v25 = v24;
        unint64_t v26 = (void *)*i;
        if (*i)
        {
          uint64_t v27 = v26[32];
          if (v27)
          {
            uint64_t v28 = v26[33];
            if (v28) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
            }
            uint64_t v29 = (std::__shared_weak_count *)v26[31];
            v26[30] = v27;
            v26[31] = v28;
            if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
              std::__shared_weak_count::__release_weak(v29);
            }
            uint64_t v30 = (std::__shared_weak_count *)v26[33];
            v26[32] = 0;
            v26[33] = 0;
            if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
              std::__shared_weak_count::__release_weak(v30);
            }
          }
        }
        if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
    }
  }
  unint64_t v31 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 320));
  if (v31)
  {
    geo::read_write_lock::logFailure(v31, (uint64_t)"unlock", v32);
  }
}

void sub_1A1B75490(_Unwind_Exception *a1)
{
  uint64_t v3 = (geo::read_write_lock *)pthread_rwlock_unlock(v1);
  if (v3) {
    geo::read_write_lock::logFailure(v3, (uint64_t)"unlock", v4);
  }
  _Unwind_Resume(a1);
}

void md::layoutElevatedPolygonMeshes<md::DaVinciGroundRenderable>(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, unsigned int *a8)
{
  uint64_t v493 = *MEMORY[0x1E4F143B8];
  int v12 = *((_DWORD *)a3 + 4);
  if (a3[3])
  {
    uint64_t v13 = *(std::__shared_weak_count **)(a2 + 256);
    uint64_t v475 = *(void *)(a2 + 248);
    v476 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v475 = 0;
    v476 = 0;
  }
  unint64_t v14 = *(void **)(a1 + 8);
  unint64_t v15 = v14[1];
  if ((v15 & (v15 - 1)) != 0)
  {
    unint64_t v17 = 0x1AF456233693CD46;
    if (v15 <= 0x1AF456233693CD46) {
      unint64_t v17 = 0x1AF456233693CD46 % v15;
    }
    unsigned __int8 v16 = *(void **)(*v14 + 8 * v17);
    do
    {
      do
        unsigned __int8 v16 = (void *)*v16;
      while (v16[1] != 0x1AF456233693CD46);
    }
    while (v16[2] != 0x1AF456233693CD46);
  }
  else
  {
    unsigned __int8 v16 = *(void **)(*v14 + 8 * ((v15 - 1) & 0x1AF456233693CD46));
    do
    {
      do
        unsigned __int8 v16 = (void *)*v16;
      while (v16[1] != 0x1AF456233693CD46);
    }
    while (v16[2] != 0x1AF456233693CD46);
  }
  float v18 = fmaxf(*(float *)(*(void *)(v16[5] + 32) + 3080) + *(float *)(*(void *)(v16[5] + 32) + 3076), 1.0);
  uint64_t v19 = *a7;
  uint8x8_t v20 = (std::__shared_weak_count *)a7[1];
  float32x4_t v492 = 0uLL;
  if (v19)
  {
    v479 = (void (**)(ggl::RenderItem *__hidden))v19;
    *(void *)&long long v480 = v20;
    if (v20) {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v484, v19, (uint64_t)v20);
    if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
      if (BYTE8(v485)) {
        goto LABEL_21;
      }
    }
    else if (BYTE8(v485))
    {
LABEL_21:
      uint64_t v21 = *(void *)(*(void *)v484 + 24);
      if ((int)v18 >= 0x17) {
        unsigned int v22 = 23;
      }
      else {
        unsigned int v22 = (int)v18;
      }
      unint64_t v23 = *(float **)v21;
      if (*(void *)v21
        && (float v24 = *v23, LODWORD(v23) = *v23 == 1.0, *(unsigned char *)(v21 + 10))
        && (v24 != 0.0 ? (_ZF = v24 == 1.0) : (_ZF = 1), !_ZF)
        || (v26 = *(unsigned __int8 *)(v21 + v23 + 11), float v24 = 0.0, v26 == 2))
      {
        LOBYTE(v479) = 1;
        LOBYTE(v477) = 1;
        char v27 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v21, 0x5Bu, v22, 0, &v479);
        char v28 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v21, 0x5Bu, v22, 1, &v477);
        if (v24 < 1.0) {
          char v28 = v27;
        }
        if (v28)
        {
LABEL_35:
          uint64_t v29 = *(void *)(*(void *)v484 + 24);
          uint64_t v30 = *(float **)v29;
          if (*(void *)v29
            && (float v31 = *v30, LODWORD(v30) = *v30 == 1.0, *(unsigned char *)(v29 + 10))
            && (v31 != 0.0 ? (BOOL v32 = v31 == 1.0) : (BOOL v32 = 1), !v32)
            || (unsigned int v33 = *(unsigned __int8 *)(v29 + v30 + 11), v31 = 0.0, v33 == 2))
          {
            LOBYTE(v479) = 1;
            LOBYTE(v477) = 1;
            int v34 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v29, 0x68u, v22, 0, &v479);
            int v35 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v29, 0x68u, v22, 1u, &v477);
            if (v31 < 1.0) {
              int v35 = v34;
            }
          }
          else
          {
            int v35 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x68u, v22, v33, 0);
          }
          int v465 = v35;
          unint64_t v40 = *(void *)(*(void *)v484 + 24);
          uint64_t v41 = *(float **)v40;
          if (*(void *)v40
            && (float v42 = *v41, LODWORD(v41) = *v41 == 1.0, *(unsigned char *)(v40 + 10))
            && (v42 != 0.0 ? (BOOL v43 = v42 == 1.0) : (BOOL v43 = 1), !v43)
            || (v44 = *(unsigned __int8 *)(v40 + v41 + 11), float v42 = 0.0, v44 == 2))
          {
            LOBYTE(v479) = 1;
            LOBYTE(v477) = 1;
            unint64_t v45 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v40, 0x6Bu, 0, &v479);
            unint64_t v46 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v40, 0x6Bu, 1u, &v477);
            if (v42 >= 1.0) {
              size_t v47 = (unsigned char *)v46;
            }
            else {
              size_t v47 = (unsigned char *)v45;
            }
            if (*v47) {
              goto LABEL_65;
            }
          }
          else if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(*(void *)(*(void *)v484 + 24), 0x6Bu, v44, 0))
          {
LABEL_65:
            gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v479, *(void *)(*(void *)v484 + 24), 0x5Du, 2u, fminf(fmaxf(v18, 0.0), 23.0));
LABEL_68:
            float32x4_t v492 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)v479)), (float32x4_t)vdupq_n_s32(0x37800080u));
            unint64_t v48 = *(void *)(*(void *)v484 + 24);
            float v49 = fminf(fmaxf(v18, 0.0), 23.0);
            uint8x8_t v50 = *(float **)v48;
            if (*(void *)v48
              && (float v51 = *v50, LODWORD(v50) = *v50 == 1.0, *(unsigned char *)(v48 + 10))
              && v51 != 0.0
              && v51 != 1.0
              || (v52 = *(unsigned __int8 *)(v48 + v50 + 11), float v51 = 0.0, v52 == 2))
            {
              LOBYTE(v479) = 1;
              LOBYTE(v477) = 1;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v48, 0x61u, 0, (BOOL *)&v479, v49);
              float v54 = v53;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v48, 0x61u, 1u, (BOOL *)&v477, v49);
              float v37 = v54 + (float)((float)(v55 - v54) * v51);
            }
            else
            {
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)v484 + 24), 0x61u, v52, 0, v49);
              float v37 = v56;
            }
            uint64_t v57 = *(void *)(*(void *)v484 + 24);
            uint64_t v58 = *(float **)v57;
            if (*(void *)v57
              && (float v59 = *v58, LODWORD(v58) = *v58 == 1.0, *(unsigned char *)(v57 + 10))
              && v59 != 0.0
              && v59 != 1.0
              || (v60 = *(unsigned __int8 *)(v57 + v58 + 11), float v59 = 0.0, v60 == 2))
            {
              LOBYTE(v479) = 1;
              LOBYTE(v477) = 1;
              int v61 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v57, 0x13Fu, v22, 0, &v479);
              int v62 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v57, 0x13Fu, v22, 1u, &v477);
              if (v59 >= 1.0) {
                LOBYTE(v38) = v62;
              }
              else {
                LOBYTE(v38) = v61;
              }
            }
            else
            {
              int v38 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x13Fu, v22, v60, 0);
            }
            uint64_t v63 = *(void *)(*(void *)v484 + 24);
            uint64_t v64 = *(float **)v63;
            if (*(void *)v63
              && (float v65 = *v64, LODWORD(v64) = *v64 == 1.0, *(unsigned char *)(v63 + 10))
              && v65 != 0.0
              && v65 != 1.0
              || (v66 = *(unsigned __int8 *)(v63 + v64 + 11), float v65 = 0.0, v66 == 2))
            {
              LOBYTE(v479) = 1;
              LOBYTE(v477) = 1;
              int v67 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v63, 0x8Au, v22, 0, &v479);
              int v68 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v63, 0x8Au, v22, 1u, &v477);
              if (v65 < 1.0) {
                LOBYTE(v68) = v67;
              }
            }
            else
            {
              int v68 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x8Au, v22, v66, 0);
            }
            int v36 = v68 - 1 < 2;
LABEL_94:
            gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v484);
            if (a3[1]) {
              goto LABEL_95;
            }
            goto LABEL_47;
          }
          gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v479, *(void *)(*(void *)v484 + 24), 0x5Du, v22, 2u, 0);
          goto LABEL_68;
        }
      }
      else if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(*(void *)v484 + 24), 0x5Bu, v22, v26, 0))
      {
        goto LABEL_35;
      }
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v484);
      goto LABEL_233;
    }
    int v36 = 0;
    int v465 = 0;
    float v37 = 0.0;
    LOBYTE(v38) = 2;
    goto LABEL_94;
  }
  int v36 = 0;
  int v465 = 0;
  float v37 = 0.0;
  LOBYTE(v38) = 2;
  if (a3[1])
  {
LABEL_95:
    float32x4_t v492 = (float32x4_t)xmmword_1A28FC6C0;
    float v39 = 1.0;
    goto LABEL_96;
  }
LABEL_47:
  float v39 = v492.f32[3];
LABEL_96:
  if (v39 < 0.0039062 || v37 < 0.1) {
    goto LABEL_233;
  }
  float v69 = *(float *)(a2 + 368) * v37;
  v479 = &off_1EF55A458;
  *((void *)&v480 + 1) = "draped stroke";
  long long v481 = 0uLL;
  *((void *)&v482 + 1) = 0;
  LODWORD(v482) = 0;
  *(_DWORD *)uint64_t v483 = 1065353216;
  memset(&v483[8], 0, 32);
  *(int64x2_t *)&v483[40] = vdupq_n_s64(1uLL);
  *(void *)&v483[56] = 0;
  int v70 = *(_DWORD *)(a6 + 88);
  if (!v70)
  {
    float v452 = v69;
    uint64_t v449 = *(void *)(a6 + 8);
    char v447 = *(unsigned char *)(a6 + 24);
    v491[0] = *(void *)(a6 + 25);
    *(void *)((char *)v491 + 7) = *(void *)(a6 + 32);
    uint64_t v81 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup>::pop(a5[1]);
    uint64_t v82 = *(void *)(*((void *)v81 + 8) + 48);
    memset(v484, 0, sizeof(v484));
    uint64_t v83 = *(void *)(v82 + 8);
    *(void *)&long long v84 = 0;
    *((void *)&v84 + 1) = v82;
    uint64_t v85 = *(void *)(v82 + 72);
    *(_OWORD *)unint64_t v484 = v84;
    *(void *)&long long v485 = v83;
    *(void *)&long long v486 = v85;
    WORD4(v485) = 1;
    *(void *)uint64_t v85 = v492.i64[0];
    *(_DWORD *)(v85 + 8) = v492.i32[2];
    *(float *)(v85 + 12) = v39;
    *(_DWORD *)(v85 + 32) = *a8;
    *(_DWORD *)(v85 + 36) = a8[1];
    *(_DWORD *)(v85 + 40) = a8[2];
    *(_DWORD *)(v85 + 44) = a8[3];
    if (v38 == 2)
    {
      float v87 = 0.5;
      float v86 = 0.5;
    }
    else if (v38 == 1)
    {
      float v86 = 1.0;
      float v87 = 0.0;
    }
    else
    {
      float v86 = 0.0;
      float v87 = 1.0;
    }
    float v88 = -(float)(v452 * v87);
    float v89 = v86 * v452;
    if (a3[1])
    {
      float v89 = 1.0;
      float v88 = -1.0;
    }
    *(float *)(v85 + 16) = v88;
    *(float *)(v85 + 20) = v89;
    md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineState,std::shared_ptr<ggl::ElevatedStrokeColorWithDistanceShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v477, (uint64_t)(a5 + 19), v475 != 0, a3[2]);
    ggl::Flyover::FlyoverPipelineSetup::setState(v81, (uint64_t)v477, v478);
    uint64_t v90 = v478;
    if (v478 && !atomic_fetch_add(&v478->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
      std::__shared_weak_count::__release_weak(v90);
    }
    uint64_t v91 = (void *)*((void *)v81 + 8);
    v91[1] = 0;
    uint64_t v92 = *(void *)(a2 + 216);
    *uint64_t v91 = v92;
    unsigned int v93 = (void *)*((void *)v81 + 20);
    uint64_t v94 = *(void *)(a2 + 224);
    if (v94) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v94 + 8), 1uLL, memory_order_relaxed);
    }
    unsigned int v95 = (std::__shared_weak_count *)v93[1];
    *unsigned int v93 = v92;
    v93[1] = v94;
    if (v95 && !atomic_fetch_add(&v95->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
      std::__shared_weak_count::__release_weak(v95);
    }
    uint64_t v96 = *((void *)v81 + 8);
    *(void *)(v96 + 24) = 0;
    uint64_t v97 = *(void *)(a2 + 232);
    *(void *)(v96 + 16) = v97;
    uint64_t v98 = *((void *)v81 + 20);
    uint64_t v99 = *(void *)(a2 + 240);
    if (v99) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v99 + 8), 1uLL, memory_order_relaxed);
    }
    BOOL v100 = *(std::__shared_weak_count **)(v98 + 24);
    *(void *)(v98 + 16) = v97;
    *(void *)(v98 + 24) = v99;
    if (v100 && !atomic_fetch_add(&v100->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
      std::__shared_weak_count::__release_weak(v100);
    }
    uint64_t v101 = a5;
    uint64_t v102 = *((void *)v81 + 8);
    *(void *)(v102 + 32) = v475;
    *(void *)(v102 + 40) = 0;
    uint64_t v103 = *((void *)v81 + 20);
    if (v476) {
      atomic_fetch_add_explicit(&v476->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v104 = *(std::__shared_weak_count **)(v103 + 40);
    *(void *)(v103 + 32) = v475;
    *(void *)(v103 + 40) = v476;
    if (v104 && !atomic_fetch_add(&v104->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
      std::__shared_weak_count::__release_weak(v104);
    }
    *((void *)&v481 + 1) = v81;
    if ((void)v486)
    {
      unint64_t v106 = *(void *)&v484[16];
      unint64_t v105 = v485;
      if ((void)v485 != *(void *)&v484[16])
      {
        uint64_t v107 = *(void **)&v484[8];
        int v108 = BYTE8(v485);
        int v109 = BYTE9(v485);
        if (*(void *)v484 && *(unsigned char *)(*(void *)&v484[8] + 17) != 2) {
          (*(void (**)(void))(**(void **)v484 + 64))();
        }
        if (v108 && !v109)
        {
          unint64_t v111 = v107[7];
          unint64_t v110 = v107[8];
          if (v110 == v111) {
            unint64_t v111 = v107[10] - v107[9];
          }
          if (v106 < v111) {
            unint64_t v111 = v106;
          }
          if (v110 <= v105) {
            unint64_t v110 = v105;
          }
          if (v110 == v111) {
            unint64_t v110 = v111 + v107[10] - v107[9];
          }
          v107[7] = v111;
          v107[8] = v110;
        }
      }
    }
    char v112 = 0;
    float v113 = v492.f32[3];
LABEL_184:
    a5 = v101;
    if (v113 >= 1.0)
    {
      uint64_t v144 = md::DaVinciRenderStateCache::renderState((unsigned __int8 **)v101 + 94, 3, 0, (a3[1] | a3[2]) == 0, 0, 1, a3[1], 3);
    }
    else
    {
      uint64_t v141 = v101[99];
      if (!v141) {
        goto LABEL_199;
      }
      uint64_t v142 = v101 + 99;
      do
      {
        while (*(float *)(v141 + 28) < v492.f32[0]
             && *(float *)(v141 + 32) < v492.f32[1]
             && *(float *)(v141 + 36) < v492.f32[2]
             && *(float *)(v141 + 40) < v113)
        {
          uint64_t v141 = *(void *)(v141 + 8);
          if (!v141) {
            goto LABEL_194;
          }
        }
        uint64_t v142 = (uint64_t *)v141;
        uint64_t v141 = *(void *)v141;
      }
      while (v141);
LABEL_194:
      if (v142 != v101 + 99
        && (v492.f32[0] >= *((float *)v142 + 7)
         || v492.f32[1] >= *((float *)v142 + 8)
         || v492.f32[2] >= *((float *)v142 + 9)
         || v113 >= *((float *)v142 + 10)))
      {
        int v143 = *((unsigned __int8 *)v142 + 44);
      }
      else
      {
LABEL_199:
        std::__tree<std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>,std::__map_value_compare<geo::Color<float,4,(geo::ColorSpace)0>,std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>,std::less<geo::Color<float,4,(geo::ColorSpace)0>>,true>,std::allocator<std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>>>::__emplace_unique_key_args<geo::Color<float,4,(geo::ColorSpace)0>,geo::Color<float,4,(geo::ColorSpace)0> const&,unsigned char &>(v101 + 98, v492.f32, &v492, *((unsigned char *)v101 + 808));
        int v143 = *((unsigned __int8 *)v101 + 808);
        *((unsigned char *)v101 + 808) = (v143 + 1) % *((unsigned __int8 *)v101 + 809);
      }
      LODWORD(v482) = a3[4] + v143;
      uint64_t v144 = (uint64_t)(v101 + 64);
    }
    *(void *)&long long v481 = v144;
    *((void *)&v482 + 1) = (v465 << 10) | 1u;
    uint64_t v145 = *(void *)(a4 + 8);
    if (v145)
    {
      uint64_t v146 = a4 + 8;
      do
      {
        int v147 = *(_DWORD *)(v145 + 28);
        BOOL v148 = v147 < v36;
        if (v147 >= v36) {
          unint64_t v149 = (uint64_t *)v145;
        }
        else {
          unint64_t v149 = (uint64_t *)(v145 + 8);
        }
        if (!v148) {
          uint64_t v146 = v145;
        }
        uint64_t v145 = *v149;
      }
      while (*v149);
      if (v146 != a4 + 8 && v36 >= *(_DWORD *)(v146 + 28))
      {
        int64_t v150 = *(void **)(*((void *)a3 + 1) + 8);
        uint64_t v151 = v150[3];
        uint64_t v152 = v150[4];
        uint64_t v153 = v152 - v151;
        if (v152 == v151) {
          goto LABEL_220;
        }
        uint64_t v154 = 0;
        unint64_t v155 = v153 >> 3;
        while (1)
        {
          v156 = *(unsigned __int8 **)(v151 + 8 * v154);
          if (*v156 == *(unsigned __int8 *)(v146 + 32))
          {
            unint64_t v157 = *((void *)v156 + 1);
            uint64_t v158 = v150[15];
            if (v157 < (v150[16] - v158) >> 3) {
              break;
            }
          }
          if (++v154 >= v155) {
            goto LABEL_220;
          }
        }
        uint64_t v159 = *(void *)(v158 + 8 * v157);
        if (!v159) {
LABEL_220:
        }
          uint64_t v160 = 0;
        else {
          uint64_t v160 = *(void *)(*(void *)(v159 + 24) + 8 * *(unsigned __int8 *)(v146 + 33));
        }
        if (v112)
        {
          *(_OWORD *)&v484[8] = v480;
          long long v485 = v481;
          long long v486 = v482;
          long long v490 = *(_OWORD *)&v483[48];
          long long v489 = *(_OWORD *)&v483[32];
          long long v488 = *(_OWORD *)&v483[16];
          *(void *)unint64_t v484 = &off_1EF55A458;
          long long v487 = *(_OWORD *)v483;
          uint64_t v161 = (void *)v101[92];
          uint64_t v162 = v161[1];
          if (v162 == v101[93])
          {
            uint64_t v161 = (void *)*v161;
            if (!v161)
            {
              uint64_t v161 = malloc_type_malloc(120 * v162 + 16, 0xB644C221uLL);
              void *v161 = 0;
              v161[1] = 0;
              *(void *)v101[92] = v161;
            }
            v101[92] = (uint64_t)v161;
            uint64_t v162 = v161[1];
          }
          uint64_t v163 = &v161[15 * v162];
          uint64_t v164 = (uint64_t)(v163 + 2);
          v161[1] = v162 + 1;
          v163[2] = &off_1EF55A458;
          long long v165 = v489;
          long long v166 = v490;
          long long v167 = v488;
          *(_OWORD *)(v163 + 9) = v487;
          long long v168 = *(_OWORD *)&v484[8];
          long long v169 = v485;
          *(_OWORD *)(v163 + 7) = v486;
          *(_OWORD *)(v163 + 5) = v169;
          *(_OWORD *)(v163 + 3) = v168;
          *(_OWORD *)(v163 + 15) = v166;
          *(_OWORD *)(v163 + 13) = v165;
          *(_OWORD *)(v163 + 11) = v167;
          v163[10] = v449;
        }
        else
        {
          *(_OWORD *)&v484[8] = v480;
          long long v485 = v481;
          long long v486 = v482;
          long long v490 = *(_OWORD *)&v483[48];
          long long v489 = *(_OWORD *)&v483[32];
          long long v488 = *(_OWORD *)&v483[16];
          *(void *)unint64_t v484 = &off_1EF55A458;
          long long v487 = *(_OWORD *)v483;
          uint64_t v170 = (void *)v101[92];
          uint64_t v171 = v170[1];
          if (v171 == v101[93])
          {
            uint64_t v170 = (void *)*v170;
            if (!v170)
            {
              uint64_t v170 = malloc_type_malloc(120 * v171 + 16, 0xB644C221uLL);
              *uint64_t v170 = 0;
              v170[1] = 0;
              *(void *)v101[92] = v170;
            }
            v101[92] = (uint64_t)v170;
            uint64_t v171 = v170[1];
          }
          v172 = &v170[15 * v171];
          uint64_t v164 = (uint64_t)(v172 + 2);
          v170[1] = v171 + 1;
          v172[2] = &off_1EF55A458;
          long long v174 = v489;
          long long v173 = v490;
          long long v175 = v488;
          *(_OWORD *)(v172 + 9) = v487;
          *(_OWORD *)(v172 + 11) = v175;
          *(_OWORD *)(v172 + 13) = v174;
          long long v176 = *(_OWORD *)&v484[8];
          long long v177 = v485;
          *(_OWORD *)(v172 + 7) = v486;
          *(_OWORD *)(v172 + 5) = v177;
          *(_OWORD *)(v172 + 3) = v176;
          *(_OWORD *)(v172 + 15) = v173;
          v172[10] = v449;
          *((unsigned char *)v172 + 88) = v447;
          uint64_t v178 = *(void *)((char *)v491 + 7);
          *(void *)((char *)v172 + 89) = v491[0];
          v172[12] = v178;
          v172[13] = 0;
          v172[14] = 1;
        }
        ggl::CommandBuffer::pushRenderItem(v160, v164);
      }
    }
    goto LABEL_233;
  }
  if (v70 != 1) {
    goto LABEL_596;
  }
  if (*(unsigned char *)(a6 + 32))
  {
    float v451 = v69;
    uint64_t v449 = *(void *)(a6 + 8);
    BOOL v71 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::ElevatedStrokeColorPipelineSetup>::pop(*a5);
    md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedStrokeColorPipelineState,std::shared_ptr<ggl::ElevatedStrokeColorShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants((std::__shared_weak_count **)v484, (uint64_t)(a5 + 4), v475 != 0);
    ggl::Flyover::FlyoverPipelineSetup::setState(v71, *(uint64_t *)v484, *(std::__shared_weak_count **)&v484[8]);
    uint64_t v72 = *(std::__shared_weak_count **)&v484[8];
    if (*(void *)&v484[8]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v484[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
      std::__shared_weak_count::__release_weak(v72);
    }
    uint64_t v73 = (void *)*((void *)v71 + 8);
    uint64_t v74 = v73[6];
    memset(v484, 0, sizeof(v484));
    uint64_t v75 = *(void *)(v74 + 8);
    *(void *)&long long v76 = 0;
    *((void *)&v76 + 1) = v74;
    uint64_t v77 = *(void *)(v74 + 72);
    *(_OWORD *)unint64_t v484 = v76;
    *(void *)&long long v485 = v75;
    *(void *)&long long v486 = v77;
    WORD4(v485) = 1;
    float32_t v78 = v492.f32[3];
    *(float32x4_t *)uint64_t v77 = v492;
    *(_DWORD *)(v77 + 48) = v12;
    float32x2_t v79 = (float32x2_t)*a8;
    *(_DWORD *)(v77 + 32) = v79.i32[0];
    *(_DWORD *)(v77 + 36) = a8[1];
    *(_DWORD *)(v77 + 40) = a8[2];
    *(_DWORD *)(v77 + 44) = a8[3];
    if (!*(unsigned char *)(a6 + 32)) {
      goto LABEL_597;
    }
    v79.i32[0] = *(_DWORD *)(a6 + 24);
    if (v38 == 2)
    {
      float32x2_t v80 = (float32x2_t)0x3F0000003F000000;
    }
    else if (v38 == 1)
    {
      float32x2_t v80 = (float32x2_t)1065353216;
    }
    else
    {
      float32x2_t v80 = (float32x2_t)0x3F80000000000000;
    }
    float32x2_t v114 = vmul_n_f32(v80, v451);
    v115.i32[0] = vsub_f32(v79, v114).u32[0];
    v115.i32[1] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&v79, 0), v114).i32[1];
    v79.f32[0] = *(float *)(a6 + 28) + v79.f32[0];
    float32x2_t v116 = vmaxnm_f32(vdiv_f32(v115, (float32x2_t)vdup_lane_s32((int32x2_t)v79, 0)), 0);
    __asm
    {
      FMOV            V1.2S, #1.0
      FMOV            V4.2S, #-1.0
    }
    *(int8x8_t *)(v77 + 16) = vbsl_s8((int8x8_t)vcgt_f32(v116, _D1), (int8x8_t)_D1, (int8x8_t)vmla_f32(_D4, (float32x2_t)0x4000000040000000, v116));
    v73[1] = 0;
    uint64_t v122 = *(void *)(a2 + 216);
    *uint64_t v73 = v122;
    unint64_t v123 = (void *)*((void *)v71 + 20);
    uint64_t v124 = *(void *)(a2 + 224);
    if (v124) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v124 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v125 = (std::__shared_weak_count *)v123[1];
    *unint64_t v123 = v122;
    v123[1] = v124;
    if (v125 && !atomic_fetch_add(&v125->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      float v457 = v78;
      ((void (*)(std::__shared_weak_count *))v125->__on_zero_shared)(v125);
      std::__shared_weak_count::__release_weak(v125);
      float32_t v78 = v457;
    }
    uint64_t v126 = *((void *)v71 + 8);
    *(void *)(v126 + 24) = 0;
    uint64_t v127 = *(void *)(a2 + 232);
    *(void *)(v126 + 16) = v127;
    uint64_t v128 = *((void *)v71 + 20);
    uint64_t v129 = *(void *)(a2 + 240);
    if (v129) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v129 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v130 = *(std::__shared_weak_count **)(v128 + 24);
    *(void *)(v128 + 16) = v127;
    *(void *)(v128 + 24) = v129;
    if (v130 && !atomic_fetch_add(&v130->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      float v458 = v78;
      ((void (*)(std::__shared_weak_count *))v130->__on_zero_shared)(v130);
      std::__shared_weak_count::__release_weak(v130);
      float32_t v78 = v458;
    }
    uint64_t v101 = a5;
    uint64_t v131 = *((void *)v71 + 8);
    *(void *)(v131 + 32) = v475;
    *(void *)(v131 + 40) = 0;
    uint64_t v132 = *((void *)v71 + 20);
    if (v476) {
      atomic_fetch_add_explicit(&v476->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v133 = *(std::__shared_weak_count **)(v132 + 40);
    *(void *)(v132 + 32) = v475;
    *(void *)(v132 + 40) = v476;
    if (v133 && !atomic_fetch_add(&v133->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      float v459 = v78;
      ((void (*)(std::__shared_weak_count *))v133->__on_zero_shared)(v133);
      std::__shared_weak_count::__release_weak(v133);
      float32_t v78 = v459;
    }
    *((void *)&v481 + 1) = v71;
    if ((void)v486)
    {
      unint64_t v135 = *(void *)&v484[16];
      unint64_t v134 = v485;
      if ((void)v485 != *(void *)&v484[16])
      {
        long long v136 = *(void **)&v484[8];
        int v137 = BYTE8(v485);
        int v138 = BYTE9(v485);
        if (*(void *)v484 && *(unsigned char *)(*(void *)&v484[8] + 17) != 2)
        {
          float v460 = v78;
          (*(void (**)(void))(**(void **)v484 + 64))();
          float32_t v78 = v460;
        }
        if (v137 && !v138)
        {
          unint64_t v140 = v136[7];
          unint64_t v139 = v136[8];
          if (v139 == v140) {
            unint64_t v140 = v136[10] - v136[9];
          }
          if (v135 < v140) {
            unint64_t v140 = v135;
          }
          if (v139 <= v134) {
            unint64_t v139 = v134;
          }
          if (v139 == v140) {
            unint64_t v139 = v140 + v136[10] - v136[9];
          }
          v136[7] = v140;
          v136[8] = v139;
        }
      }
    }
    char v447 = 0;
    float v113 = v78;
    char v112 = 1;
    goto LABEL_184;
  }
LABEL_233:
  uint64_t v179 = *a7;
  unint64_t v180 = (std::__shared_weak_count *)a7[1];
  float32x4_t v492 = 0uLL;
  if (v179)
  {
    v479 = (void (**)(ggl::RenderItem *__hidden))v179;
    *(void *)&long long v480 = v180;
    if (v180) {
      atomic_fetch_add_explicit(&v180->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v484, v179, (uint64_t)v180);
    if (v180 && !atomic_fetch_add(&v180->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v180->__on_zero_shared)(v180);
      std::__shared_weak_count::__release_weak(v180);
      if (BYTE8(v485)) {
        goto LABEL_239;
      }
    }
    else if (BYTE8(v485))
    {
LABEL_239:
      uint64_t v181 = *(void *)(*(void *)v484 + 24);
      if ((int)v18 >= 0x17) {
        unsigned int v182 = 23;
      }
      else {
        unsigned int v182 = (int)v18;
      }
      unint64_t v183 = *(float **)v181;
      if (*(void *)v181
        && (float v184 = *v183, LODWORD(v183) = *v183 == 1.0, *(unsigned char *)(v181 + 10))
        && (v184 != 0.0 ? (BOOL v185 = v184 == 1.0) : (BOOL v185 = 1), !v185)
        || (v186 = *(unsigned __int8 *)(v181 + v183 + 11), float v184 = 0.0, v186 == 2))
      {
        LOBYTE(v479) = 1;
        LOBYTE(v477) = 1;
        char v187 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v181, 0x5Bu, v182, 0, &v479);
        char v188 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v181, 0x5Bu, v182, 1, &v477);
        if (v184 < 1.0) {
          char v188 = v187;
        }
        if (v188)
        {
LABEL_253:
          uint64_t v189 = *(void *)(*(void *)v484 + 24);
          long long v190 = *(float **)v189;
          if (*(void *)v189
            && (float v191 = *v190, LODWORD(v190) = *v190 == 1.0, *(unsigned char *)(v189 + 10))
            && (v191 != 0.0 ? (BOOL v192 = v191 == 1.0) : (BOOL v192 = 1), !v192)
            || (v193 = *(unsigned __int8 *)(v189 + v190 + 11), float v191 = 0.0, v193 == 2))
          {
            LOBYTE(v479) = 1;
            LOBYTE(v477) = 1;
            int v194 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v189, 0x68u, v182, 0, &v479);
            int v195 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v189, 0x68u, v182, 1u, &v477);
            if (v191 < 1.0) {
              int v195 = v194;
            }
          }
          else
          {
            int v195 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x68u, v182, v193, 0);
          }
          int v466 = v195;
          unint64_t v200 = *(void *)(*(void *)v484 + 24);
          unint64_t v201 = *(float **)v200;
          if (*(void *)v200
            && (float v202 = *v201, LODWORD(v201) = *v201 == 1.0, *(unsigned char *)(v200 + 10))
            && (v202 != 0.0 ? (BOOL v203 = v202 == 1.0) : (BOOL v203 = 1), !v203)
            || (v204 = *(unsigned __int8 *)(v200 + v201 + 11), float v202 = 0.0, v204 == 2))
          {
            LOBYTE(v479) = 1;
            LOBYTE(v477) = 1;
            unint64_t v205 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v200, 0x197u, 0, &v479);
            unint64_t v206 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v200, 0x197u, 1u, &v477);
            if (v202 >= 1.0) {
              unint64_t v207 = (unsigned char *)v206;
            }
            else {
              unint64_t v207 = (unsigned char *)v205;
            }
            if (*v207) {
              goto LABEL_283;
            }
          }
          else if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(*(void *)(*(void *)v484 + 24), 0x197u, v204, 0))
          {
LABEL_283:
            gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v479, *(void *)(*(void *)v484 + 24), 0x193u, 2u, fminf(fmaxf(v18, 0.0), 23.0));
LABEL_286:
            float32x4_t v492 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)v479)), (float32x4_t)vdupq_n_s32(0x37800080u));
            unint64_t v208 = *(void *)(*(void *)v484 + 24);
            float v209 = fminf(fmaxf(v18, 0.0), 23.0);
            uint64_t v210 = *(float **)v208;
            if (*(void *)v208
              && (float v211 = *v210, LODWORD(v210) = *v210 == 1.0, *(unsigned char *)(v208 + 10))
              && v211 != 0.0
              && v211 != 1.0
              || (v212 = *(unsigned __int8 *)(v208 + v210 + 11), float v211 = 0.0, v212 == 2))
            {
              LOBYTE(v479) = 1;
              LOBYTE(v477) = 1;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v208, 0x194u, 0, (BOOL *)&v479, v209);
              float v214 = v213;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v208, 0x194u, 1u, (BOOL *)&v477, v209);
              float v197 = v214 + (float)((float)(v215 - v214) * v211);
            }
            else
            {
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)v484 + 24), 0x194u, v212, 0, v209);
              float v197 = v216;
            }
            uint64_t v217 = *(void *)(*(void *)v484 + 24);
            long long v218 = *(float **)v217;
            if (*(void *)v217
              && (float v219 = *v218, LODWORD(v218) = *v218 == 1.0, *(unsigned char *)(v217 + 10))
              && v219 != 0.0
              && v219 != 1.0
              || (v220 = *(unsigned __int8 *)(v217 + v218 + 11), float v219 = 0.0, v220 == 2))
            {
              LOBYTE(v479) = 1;
              LOBYTE(v477) = 1;
              int v221 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v217, 0x198u, v182, 0, &v479);
              int v222 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v217, 0x198u, v182, 1u, &v477);
              if (v219 >= 1.0) {
                LOBYTE(v198) = v222;
              }
              else {
                LOBYTE(v198) = v221;
              }
            }
            else
            {
              int v198 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x198u, v182, v220, 0);
            }
            uint64_t v223 = *(void *)(*(void *)v484 + 24);
            v224 = *(float **)v223;
            if (*(void *)v223
              && (float v225 = *v224, LODWORD(v224) = *v224 == 1.0, *(unsigned char *)(v223 + 10))
              && v225 != 0.0
              && v225 != 1.0
              || (v226 = *(unsigned __int8 *)(v223 + v224 + 11), float v225 = 0.0, v226 == 2))
            {
              LOBYTE(v479) = 1;
              LOBYTE(v477) = 1;
              int v227 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v223, 0x8Au, v182, 0, &v479);
              int v228 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v223, 0x8Au, v182, 1u, &v477);
              if (v225 < 1.0) {
                LOBYTE(v228) = v227;
              }
            }
            else
            {
              int v228 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x8Au, v182, v226, 0);
            }
            int v196 = v228 - 1 < 2;
LABEL_312:
            gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v484);
            if (a3[1]) {
              goto LABEL_313;
            }
            goto LABEL_265;
          }
          gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v479, *(void *)(*(void *)v484 + 24), 0x193u, v182, 2u, 0);
          goto LABEL_286;
        }
      }
      else if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(*(void *)v484 + 24), 0x5Bu, v182, v186, 0))
      {
        goto LABEL_253;
      }
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v484);
      goto LABEL_453;
    }
    int v196 = 0;
    int v466 = 0;
    float v197 = 0.0;
    LOBYTE(v198) = 2;
    goto LABEL_312;
  }
  int v196 = 0;
  int v466 = 0;
  float v197 = 0.0;
  LOBYTE(v198) = 2;
  if (a3[1])
  {
LABEL_313:
    float32x4_t v492 = (float32x4_t)xmmword_1A28FC6C0;
    float v199 = 1.0;
    goto LABEL_314;
  }
LABEL_265:
  float v199 = v492.f32[3];
LABEL_314:
  if (v199 < 0.0039062 || v197 < 0.1) {
    goto LABEL_453;
  }
  float v229 = *(float *)(a2 + 368) * v197;
  v479 = &off_1EF55A458;
  *((void *)&v480 + 1) = "draped stroke";
  long long v481 = 0uLL;
  *((void *)&v482 + 1) = 0;
  LODWORD(v482) = 0;
  *(_DWORD *)uint64_t v483 = 1065353216;
  memset(&v483[8], 0, 32);
  *(int64x2_t *)&v483[40] = vdupq_n_s64(1uLL);
  *(void *)&v483[56] = 0;
  int v230 = *(_DWORD *)(a6 + 88);
  if (!v230)
  {
    float v454 = v229;
    uint64_t v450 = *(void *)(a6 + 8);
    char v448 = *(unsigned char *)(a6 + 24);
    v491[0] = *(void *)(a6 + 25);
    *(void *)((char *)v491 + 7) = *(void *)(a6 + 32);
    uint64_t v241 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup>::pop(a5[1]);
    uint64_t v242 = *(void *)(*((void *)v241 + 8) + 48);
    memset(v484, 0, sizeof(v484));
    uint64_t v243 = *(void *)(v242 + 8);
    *(void *)&long long v244 = 0;
    *((void *)&v244 + 1) = v242;
    uint64_t v245 = *(void *)(v242 + 72);
    *(_OWORD *)unint64_t v484 = v244;
    *(void *)&long long v485 = v243;
    *(void *)&long long v486 = v245;
    WORD4(v485) = 1;
    *(void *)uint64_t v245 = v492.i64[0];
    *(_DWORD *)(v245 + 8) = v492.i32[2];
    *(float *)(v245 + 12) = v199;
    *(_DWORD *)(v245 + 32) = *a8;
    *(_DWORD *)(v245 + 36) = a8[1];
    *(_DWORD *)(v245 + 40) = a8[2];
    *(_DWORD *)(v245 + 44) = a8[3];
    if (v198 == 2)
    {
      float v248 = 0.5;
      float v247 = 0.5;
      float v246 = v454;
    }
    else
    {
      float v246 = v454;
      if (v198 == 1)
      {
        float v247 = 1.0;
        float v248 = 0.0;
      }
      else
      {
        float v247 = 0.0;
        float v248 = 1.0;
      }
    }
    float v249 = -(float)(v246 * v248);
    float v250 = v247 * v246;
    if (a3[1])
    {
      float v250 = 1.0;
      float v249 = -1.0;
    }
    *(float *)(v245 + 16) = v249;
    *(float *)(v245 + 20) = v250;
    md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineState,std::shared_ptr<ggl::ElevatedStrokeColorWithDistanceShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v477, (uint64_t)(a5 + 19), v475 != 0, a3[2]);
    ggl::Flyover::FlyoverPipelineSetup::setState(v241, (uint64_t)v477, v478);
    unint64_t v251 = v478;
    if (v478 && !atomic_fetch_add(&v478->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v251->__on_zero_shared)(v251);
      std::__shared_weak_count::__release_weak(v251);
    }
    uint64_t v252 = (void *)*((void *)v241 + 8);
    v252[1] = 0;
    uint64_t v253 = *(void *)(a2 + 216);
    *uint64_t v252 = v253;
    v254 = (void *)*((void *)v241 + 20);
    uint64_t v255 = *(void *)(a2 + 224);
    if (v255) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v255 + 8), 1uLL, memory_order_relaxed);
    }
    v256 = (std::__shared_weak_count *)v254[1];
    void *v254 = v253;
    v254[1] = v255;
    if (v256 && !atomic_fetch_add(&v256->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v256->__on_zero_shared)(v256);
      std::__shared_weak_count::__release_weak(v256);
    }
    uint64_t v257 = *((void *)v241 + 8);
    *(void *)(v257 + 24) = 0;
    uint64_t v258 = *(void *)(a2 + 232);
    *(void *)(v257 + 16) = v258;
    uint64_t v259 = *((void *)v241 + 20);
    uint64_t v260 = *(void *)(a2 + 240);
    if (v260) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v260 + 8), 1uLL, memory_order_relaxed);
    }
    long long v261 = *(std::__shared_weak_count **)(v259 + 24);
    *(void *)(v259 + 16) = v258;
    *(void *)(v259 + 24) = v260;
    if (v261 && !atomic_fetch_add(&v261->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v261->__on_zero_shared)(v261);
      std::__shared_weak_count::__release_weak(v261);
    }
    uint64_t v262 = *((void *)v241 + 8);
    *(void *)(v262 + 32) = v475;
    *(void *)(v262 + 40) = 0;
    uint64_t v263 = *((void *)v241 + 20);
    if (v476) {
      atomic_fetch_add_explicit(&v476->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v264 = a5;
    unint64_t v265 = *(std::__shared_weak_count **)(v263 + 40);
    *(void *)(v263 + 32) = v475;
    *(void *)(v263 + 40) = v476;
    if (v265 && !atomic_fetch_add(&v265->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v265->__on_zero_shared)(v265);
      std::__shared_weak_count::__release_weak(v265);
    }
    *((void *)&v481 + 1) = v241;
    if ((void)v486)
    {
      unint64_t v267 = *(void *)&v484[16];
      unint64_t v266 = v485;
      if ((void)v485 != *(void *)&v484[16])
      {
        uint64_t v268 = *(void **)&v484[8];
        int v269 = BYTE8(v485);
        int v270 = BYTE9(v485);
        if (*(void *)v484 && *(unsigned char *)(*(void *)&v484[8] + 17) != 2) {
          (*(void (**)(void))(**(void **)v484 + 64))();
        }
        if (v269 && !v270)
        {
          unint64_t v272 = v268[7];
          unint64_t v271 = v268[8];
          if (v271 == v272) {
            unint64_t v272 = v268[10] - v268[9];
          }
          if (v267 < v272) {
            unint64_t v272 = v267;
          }
          if (v271 <= v266) {
            unint64_t v271 = v266;
          }
          if (v271 == v272) {
            unint64_t v271 = v272 + v268[10] - v268[9];
          }
          v268[7] = v272;
          v268[8] = v271;
        }
      }
    }
    char v273 = 0;
    float v274 = v492.f32[3];
    goto LABEL_402;
  }
  if (v230 != 1)
  {
LABEL_596:
    std::__throw_bad_variant_access[abi:nn180100]();
LABEL_598:
    __break(1u);
    return;
  }
  if (!*(unsigned char *)(a6 + 64)) {
    goto LABEL_453;
  }
  float v453 = v229;
  uint64_t v450 = *(void *)(a6 + 40);
  unint64_t v231 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::ElevatedStrokeColorPipelineSetup>::pop(*a5);
  md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedStrokeColorPipelineState,std::shared_ptr<ggl::ElevatedStrokeColorShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants((std::__shared_weak_count **)v484, (uint64_t)(a5 + 4), v475 != 0);
  ggl::Flyover::FlyoverPipelineSetup::setState(v231, *(uint64_t *)v484, *(std::__shared_weak_count **)&v484[8]);
  char v232 = *(std::__shared_weak_count **)&v484[8];
  if (*(void *)&v484[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v484[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v232->__on_zero_shared)(v232);
    std::__shared_weak_count::__release_weak(v232);
  }
  int v233 = (void *)*((void *)v231 + 8);
  uint64_t v234 = v233[6];
  memset(v484, 0, sizeof(v484));
  uint64_t v235 = *(void *)(v234 + 8);
  *(void *)&long long v236 = 0;
  *((void *)&v236 + 1) = v234;
  uint64_t v237 = *(void *)(v234 + 72);
  *(_OWORD *)unint64_t v484 = v236;
  *(void *)&long long v485 = v235;
  *(void *)&long long v486 = v237;
  WORD4(v485) = 1;
  float32_t v238 = v492.f32[3];
  *(float32x4_t *)uint64_t v237 = v492;
  *(_DWORD *)(v237 + 48) = v12;
  float32x2_t v239 = (float32x2_t)*a8;
  *(_DWORD *)(v237 + 32) = v239.i32[0];
  *(_DWORD *)(v237 + 36) = a8[1];
  *(_DWORD *)(v237 + 40) = a8[2];
  *(_DWORD *)(v237 + 44) = a8[3];
  if (!*(unsigned char *)(a6 + 64))
  {
LABEL_597:
    std::__throw_bad_optional_access[abi:nn180100]();
    goto LABEL_598;
  }
  v239.i32[0] = *(_DWORD *)(a6 + 56);
  if (v198 == 2)
  {
    float32x2_t v240 = (float32x2_t)0x3F0000003F000000;
  }
  else if (v198 == 1)
  {
    float32x2_t v240 = (float32x2_t)1065353216;
  }
  else
  {
    float32x2_t v240 = (float32x2_t)0x3F80000000000000;
  }
  float32x2_t v275 = vmul_n_f32(v240, v453);
  v276.i32[0] = vsub_f32(v239, v275).u32[0];
  v276.i32[1] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&v239, 0), v275).i32[1];
  v239.f32[0] = *(float *)(a6 + 60) + v239.f32[0];
  float32x2_t v277 = vmaxnm_f32(vdiv_f32(v276, (float32x2_t)vdup_lane_s32((int32x2_t)v239, 0)), 0);
  __asm
  {
    FMOV            V1.2S, #1.0
    FMOV            V4.2S, #-1.0
  }
  *(int8x8_t *)(v237 + 16) = vbsl_s8((int8x8_t)vcgt_f32(v277, _D1), (int8x8_t)_D1, (int8x8_t)vmla_f32(_D4, (float32x2_t)0x4000000040000000, v277));
  v233[1] = 0;
  uint64_t v280 = *(void *)(a2 + 216);
  void *v233 = v280;
  v281 = (void *)*((void *)v231 + 20);
  uint64_t v282 = *(void *)(a2 + 224);
  if (v282) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v282 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v283 = (std::__shared_weak_count *)v281[1];
  void *v281 = v280;
  v281[1] = v282;
  if (v283 && !atomic_fetch_add(&v283->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    float v461 = v238;
    ((void (*)(std::__shared_weak_count *))v283->__on_zero_shared)(v283);
    std::__shared_weak_count::__release_weak(v283);
    float32_t v238 = v461;
  }
  uint64_t v284 = *((void *)v231 + 8);
  *(void *)(v284 + 24) = 0;
  uint64_t v285 = *(void *)(a2 + 232);
  *(void *)(v284 + 16) = v285;
  uint64_t v286 = *((void *)v231 + 20);
  uint64_t v287 = *(void *)(a2 + 240);
  if (v287) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v287 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v288 = *(std::__shared_weak_count **)(v286 + 24);
  *(void *)(v286 + 16) = v285;
  *(void *)(v286 + 24) = v287;
  if (v288 && !atomic_fetch_add(&v288->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    float v462 = v238;
    ((void (*)(std::__shared_weak_count *))v288->__on_zero_shared)(v288);
    std::__shared_weak_count::__release_weak(v288);
    float32_t v238 = v462;
  }
  uint64_t v289 = *((void *)v231 + 8);
  *(void *)(v289 + 32) = v475;
  *(void *)(v289 + 40) = 0;
  uint64_t v290 = *((void *)v231 + 20);
  if (v476) {
    atomic_fetch_add_explicit(&v476->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v264 = a5;
  uint8x8_t v291 = *(std::__shared_weak_count **)(v290 + 40);
  *(void *)(v290 + 32) = v475;
  *(void *)(v290 + 40) = v476;
  if (v291 && !atomic_fetch_add(&v291->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    float v463 = v238;
    ((void (*)(std::__shared_weak_count *))v291->__on_zero_shared)(v291);
    std::__shared_weak_count::__release_weak(v291);
    float32_t v238 = v463;
  }
  *((void *)&v481 + 1) = v231;
  if ((void)v486)
  {
    unint64_t v293 = *(void *)&v484[16];
    unint64_t v292 = v485;
    if ((void)v485 != *(void *)&v484[16])
    {
      uint64_t v294 = *(void **)&v484[8];
      int v295 = BYTE8(v485);
      int v296 = BYTE9(v485);
      if (*(void *)v484 && *(unsigned char *)(*(void *)&v484[8] + 17) != 2)
      {
        float v464 = v238;
        (*(void (**)(void))(**(void **)v484 + 64))();
        float32_t v238 = v464;
      }
      if (v295 && !v296)
      {
        unint64_t v298 = v294[7];
        unint64_t v297 = v294[8];
        if (v297 == v298) {
          unint64_t v298 = v294[10] - v294[9];
        }
        if (v293 < v298) {
          unint64_t v298 = v293;
        }
        if (v297 <= v292) {
          unint64_t v297 = v292;
        }
        if (v297 == v298) {
          unint64_t v297 = v298 + v294[10] - v294[9];
        }
        v294[7] = v298;
        v294[8] = v297;
      }
    }
  }
  char v448 = 0;
  float v274 = v238;
  char v273 = 1;
LABEL_402:
  a5 = v264;
  if (v274 >= 1.0)
  {
    uint64_t v302 = md::DaVinciRenderStateCache::renderState((unsigned __int8 **)v264 + 94, 3, 0, (a3[1] | a3[2]) == 0, 0, 1, a3[1], 3);
  }
  else
  {
    uint64_t v299 = v264[99];
    if (!v299) {
      goto LABEL_417;
    }
    uint8x8_t v300 = v264 + 99;
    do
    {
      while (*(float *)(v299 + 28) < v492.f32[0]
           && *(float *)(v299 + 32) < v492.f32[1]
           && *(float *)(v299 + 36) < v492.f32[2]
           && *(float *)(v299 + 40) < v274)
      {
        uint64_t v299 = *(void *)(v299 + 8);
        if (!v299) {
          goto LABEL_412;
        }
      }
      uint8x8_t v300 = (uint64_t *)v299;
      uint64_t v299 = *(void *)v299;
    }
    while (v299);
LABEL_412:
    if (v300 != v264 + 99
      && (v492.f32[0] >= *((float *)v300 + 7)
       || v492.f32[1] >= *((float *)v300 + 8)
       || v492.f32[2] >= *((float *)v300 + 9)
       || v274 >= *((float *)v300 + 10)))
    {
      int v301 = *((unsigned __int8 *)v300 + 44);
    }
    else
    {
LABEL_417:
      std::__tree<std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>,std::__map_value_compare<geo::Color<float,4,(geo::ColorSpace)0>,std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>,std::less<geo::Color<float,4,(geo::ColorSpace)0>>,true>,std::allocator<std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>>>::__emplace_unique_key_args<geo::Color<float,4,(geo::ColorSpace)0>,geo::Color<float,4,(geo::ColorSpace)0> const&,unsigned char &>(v264 + 98, v492.f32, &v492, *((unsigned char *)v264 + 808));
      int v301 = *((unsigned __int8 *)v264 + 808);
      *((unsigned char *)v264 + 808) = (v301 + 1) % *((unsigned __int8 *)v264 + 809);
    }
    LODWORD(v482) = a3[4] + v301;
    uint64_t v302 = (uint64_t)(v264 + 64);
  }
  *(void *)&long long v481 = v302;
  *((void *)&v482 + 1) = (v466 << 10) | 3u;
  uint64_t v303 = *(void *)(a4 + 8);
  if (v303)
  {
    uint64_t v304 = a4 + 8;
    do
    {
      int v305 = *(_DWORD *)(v303 + 28);
      BOOL v306 = v305 < v196;
      if (v305 >= v196) {
        uint64_t v307 = (uint64_t *)v303;
      }
      else {
        uint64_t v307 = (uint64_t *)(v303 + 8);
      }
      if (!v306) {
        uint64_t v304 = v303;
      }
      uint64_t v303 = *v307;
    }
    while (*v307);
    if (v304 != a4 + 8 && v196 >= *(_DWORD *)(v304 + 28))
    {
      v308 = *(void **)(*((void *)a3 + 1) + 8);
      uint64_t v309 = v308[3];
      uint64_t v310 = v308[4];
      uint64_t v311 = v310 - v309;
      if (v310 == v309) {
        goto LABEL_438;
      }
      uint64_t v312 = 0;
      unint64_t v313 = v311 >> 3;
      while (1)
      {
        unint64_t v314 = *(unsigned __int8 **)(v309 + 8 * v312);
        if (*v314 == *(unsigned __int8 *)(v304 + 32))
        {
          unint64_t v315 = *((void *)v314 + 1);
          uint64_t v316 = v308[15];
          if (v315 < (v308[16] - v316) >> 3) {
            break;
          }
        }
        if (++v312 >= v313) {
          goto LABEL_438;
        }
      }
      uint64_t v317 = *(void *)(v316 + 8 * v315);
      if (!v317) {
LABEL_438:
      }
        uint64_t v318 = 0;
      else {
        uint64_t v318 = *(void *)(*(void *)(v317 + 24) + 8 * *(unsigned __int8 *)(v304 + 33));
      }
      if (v273)
      {
        *(_OWORD *)&v484[8] = v480;
        long long v485 = v481;
        long long v486 = v482;
        long long v490 = *(_OWORD *)&v483[48];
        long long v489 = *(_OWORD *)&v483[32];
        long long v488 = *(_OWORD *)&v483[16];
        *(void *)unint64_t v484 = &off_1EF55A458;
        long long v487 = *(_OWORD *)v483;
        unint64_t v319 = (void *)v264[92];
        uint64_t v320 = v319[1];
        if (v320 == v264[93])
        {
          unint64_t v319 = (void *)*v319;
          uint64_t v321 = v450;
          if (!v319)
          {
            unint64_t v319 = malloc_type_malloc(120 * v320 + 16, 0xB644C221uLL);
            void *v319 = 0;
            v319[1] = 0;
            *(void *)v264[92] = v319;
          }
          v264[92] = (uint64_t)v319;
          uint64_t v320 = v319[1];
        }
        else
        {
          uint64_t v321 = v450;
        }
        unint64_t v325 = &v319[15 * v320];
        uint64_t v326 = (uint64_t)(v325 + 2);
        v319[1] = v320 + 1;
        v325[2] = &off_1EF55A458;
        long long v327 = v489;
        long long v328 = v490;
        long long v329 = v488;
        *(_OWORD *)(v325 + 9) = v487;
        long long v330 = *(_OWORD *)&v484[8];
        long long v331 = v485;
        *(_OWORD *)(v325 + 7) = v486;
        *(_OWORD *)(v325 + 5) = v331;
        *(_OWORD *)(v325 + 3) = v330;
        *(_OWORD *)(v325 + 15) = v328;
        *(_OWORD *)(v325 + 13) = v327;
        *(_OWORD *)(v325 + 11) = v329;
        v325[10] = v321;
      }
      else
      {
        *(_OWORD *)&v484[8] = v480;
        long long v485 = v481;
        long long v486 = v482;
        long long v490 = *(_OWORD *)&v483[48];
        long long v489 = *(_OWORD *)&v483[32];
        long long v488 = *(_OWORD *)&v483[16];
        *(void *)unint64_t v484 = &off_1EF55A458;
        long long v487 = *(_OWORD *)v483;
        v322 = (void *)v264[92];
        uint64_t v323 = v322[1];
        if (v323 == v264[93])
        {
          v322 = (void *)*v322;
          uint64_t v324 = v450;
          if (!v322)
          {
            v322 = malloc_type_malloc(120 * v323 + 16, 0xB644C221uLL);
            void *v322 = 0;
            v322[1] = 0;
            *(void *)v264[92] = v322;
          }
          v264[92] = (uint64_t)v322;
          uint64_t v323 = v322[1];
        }
        else
        {
          uint64_t v324 = v450;
        }
        unint64_t v332 = &v322[15 * v323];
        uint64_t v326 = (uint64_t)(v332 + 2);
        v322[1] = v323 + 1;
        v332[2] = &off_1EF55A458;
        long long v334 = v489;
        long long v333 = v490;
        long long v335 = v488;
        *(_OWORD *)(v332 + 9) = v487;
        *(_OWORD *)(v332 + 11) = v335;
        *(_OWORD *)(v332 + 13) = v334;
        long long v336 = *(_OWORD *)&v484[8];
        long long v337 = v485;
        *(_OWORD *)(v332 + 7) = v486;
        *(_OWORD *)(v332 + 5) = v337;
        *(_OWORD *)(v332 + 3) = v336;
        *(_OWORD *)(v332 + 15) = v333;
        v332[10] = v324;
        *((unsigned char *)v332 + 88) = v448;
        uint64_t v338 = *(void *)((char *)v491 + 7);
        *(void *)((char *)v332 + 89) = v491[0];
        v332[12] = v338;
        v332[13] = 0;
        v332[14] = 1;
      }
      ggl::CommandBuffer::pushRenderItem(v318, v326);
    }
  }
LABEL_453:
  uint64_t v339 = *a7;
  if (!*a7)
  {
    if (!*a3) {
      goto LABEL_592;
    }
    int v354 = 0;
    int v356 = 0;
    goto LABEL_516;
  }
  v340 = (std::__shared_weak_count *)a7[1];
  v479 = (void (**)(ggl::RenderItem *__hidden))v339;
  *(void *)&long long v480 = v340;
  if (v340) {
    atomic_fetch_add_explicit(&v340->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v484, v339, (uint64_t)v340);
  if (v340 && !atomic_fetch_add(&v340->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v340->__on_zero_shared)(v340);
    std::__shared_weak_count::__release_weak(v340);
    if (BYTE8(v485)) {
      goto LABEL_459;
    }
LABEL_486:
    int v356 = 0;
    int v354 = 0;
    int8x16_t v467 = 0u;
    goto LABEL_515;
  }
  if (!BYTE8(v485)) {
    goto LABEL_486;
  }
LABEL_459:
  uint64_t v341 = *(void *)(*(void *)v484 + 24);
  if ((int)v18 >= 0x17) {
    unsigned int v342 = 23;
  }
  else {
    unsigned int v342 = (int)v18;
  }
  v343 = *(float **)v341;
  if (!*(void *)v341
    || (float v344 = *v343, LODWORD(v343) = *v343 == 1.0, !*(unsigned char *)(v341 + 10))
    || (v344 != 0.0 ? (BOOL v345 = v344 == 1.0) : (BOOL v345 = 1), v345))
  {
    int v346 = *(unsigned __int8 *)(v341 + v343 + 11);
    float v344 = 0.0;
    if (v346 != 2)
    {
      if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(*(void *)v484 + 24), 0x5Bu, v342, v346, 0))goto LABEL_473; {
LABEL_488:
      }
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v484);
      goto LABEL_592;
    }
  }
  LOBYTE(v479) = 1;
  v492.i8[0] = 1;
  char v347 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v341, 0x5Bu, v342, 0, &v479);
  char v348 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v341, 0x5Bu, v342, 1, &v492);
  if (v344 < 1.0) {
    char v348 = v347;
  }
  if (!v348) {
    goto LABEL_488;
  }
LABEL_473:
  uint64_t v349 = *(void *)(*(void *)v484 + 24);
  uint64_t v350 = *(float **)v349;
  if (*(void *)v349
    && (float v351 = *v350, LODWORD(v350) = *v350 == 1.0, *(unsigned char *)(v349 + 10))
    && (v351 != 0.0 ? (BOOL v352 = v351 == 1.0) : (BOOL v352 = 1), !v352)
    || (v353 = *(unsigned __int8 *)(v349 + v350 + 11), float v351 = 0.0, v353 == 2))
  {
    LOBYTE(v479) = 1;
    v492.i8[0] = 1;
    int v354 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v349, 0x68u, v342, 0, &v479);
    int v355 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v349, 0x68u, v342, 1u, &v492);
    if (v351 >= 1.0) {
      int v354 = v355;
    }
  }
  else
  {
    int v354 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x68u, v342, v353, 0);
  }
  unint64_t v357 = *(void *)(*(void *)v484 + 24);
  unint64_t v358 = *(float **)v357;
  if (*(void *)v357
    && (float v359 = *v358, LODWORD(v358) = *v358 == 1.0, *(unsigned char *)(v357 + 10))
    && (v359 != 0.0 ? (BOOL v360 = v359 == 1.0) : (BOOL v360 = 1), !v360)
    || (v361 = *(unsigned __int8 *)(v357 + v358 + 11), float v359 = 0.0, v361 == 2))
  {
    LOBYTE(v479) = 1;
    v492.i8[0] = 1;
    unint64_t v362 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v357, 0x6Cu, 0, &v479);
    unint64_t v363 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v357, 0x6Cu, 1u, &v492);
    if (v359 >= 1.0) {
      v364 = (unsigned char *)v363;
    }
    else {
      v364 = (unsigned char *)v362;
    }
    if (*v364) {
      goto LABEL_502;
    }
LABEL_504:
    gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v479, *(void *)(*(void *)v484 + 24), 0x5Cu, v342, 2u, 0);
    goto LABEL_505;
  }
  if (!*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(*(void *)(*(void *)v484 + 24), 0x6Cu, v361, 0))goto LABEL_504; {
LABEL_502:
  }
  gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v479, *(void *)(*(void *)v484 + 24), 0x5Cu, 2u, fminf(fmaxf(v18, 0.0), 23.0));
LABEL_505:
  v365 = v479;
  uint64_t v366 = *(void *)(*(void *)v484 + 24);
  long long v367 = *(float **)v366;
  if (*(void *)v366
    && (float v368 = *v367, LODWORD(v367) = *v367 == 1.0, *(unsigned char *)(v366 + 10))
    && v368 != 0.0
    && v368 != 1.0
    || (v369 = *(unsigned __int8 *)(v366 + v367 + 11), float v368 = 0.0, v369 == 2))
  {
    LOBYTE(v479) = 1;
    v492.i8[0] = 1;
    int v370 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v366, 0x8Au, v342, 0, &v479);
    int v371 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v366, 0x8Au, v342, 1u, &v492);
    if (v368 < 1.0) {
      LOBYTE(v371) = v370;
    }
  }
  else
  {
    int v371 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x8Au, v342, v369, 0);
  }
  int8x16_t v467 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)v365)), (float32x4_t)vdupq_n_s32(0x37800080u));
  int v356 = v371 - 1 < 2;
LABEL_515:
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v484);
  if (*a3)
  {
LABEL_516:
    uint64_t v372 = 0x3F80000000000000;
    unint64_t v373 = 0x3F80000000000000;
    goto LABEL_517;
  }
  uint64_t v372 = v467.i64[0];
  if (*(float *)&v467.i32[3] < 0.0039062) {
    goto LABEL_592;
  }
  unint64_t v373 = vextq_s8(v467, v467, 8uLL).u64[0];
LABEL_517:
  v479 = &off_1EF55A458;
  *((void *)&v480 + 1) = "draped fill";
  long long v481 = 0uLL;
  *((void *)&v482 + 1) = 0;
  LODWORD(v482) = 0;
  *(_DWORD *)uint64_t v483 = 1065353216;
  memset(&v483[8], 0, 32);
  *(int64x2_t *)&v483[40] = vdupq_n_s64(1uLL);
  *(void *)&v483[56] = 0;
  int v374 = *(_DWORD *)(a6 + 88);
  if (v374)
  {
    if (v374 == 1)
    {
      uint64_t v375 = *(void *)(a6 + 72);
      if (v375)
      {
        unint64_t v455 = v373;
        uint64_t v468 = v372;
        int8x8_t v376 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::ElevatedFillColorPipelineSetup>::pop(a5[2]);
        md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedFillColorPipelineState,std::shared_ptr<ggl::ElevatedFillNoWidthClipColorShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants((std::__shared_weak_count **)v484, (uint64_t)(a5 + 34), v475 != 0);
        unint64_t v377 = a5;
        ggl::Flyover::FlyoverPipelineSetup::setState(v376, *(uint64_t *)v484, *(std::__shared_weak_count **)&v484[8]);
        uint8x8_t v378 = *(std::__shared_weak_count **)&v484[8];
        if (*(void *)&v484[8]
          && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v484[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v378->__on_zero_shared)(v378);
          std::__shared_weak_count::__release_weak(v378);
        }
        unint64_t v379 = (void *)*((void *)v376 + 8);
        unint64_t v380 = (void *)v379[4];
        unint64_t v381 = v380[1];
        uint64_t v382 = v380[9];
        *(void *)uint64_t v382 = v468;
        *(void *)(v382 + 8) = v455;
        *(_DWORD *)(v382 + 32) = v12;
        *(_DWORD *)(v382 + 16) = *a8;
        *(_DWORD *)(v382 + 20) = a8[1];
        *(_DWORD *)(v382 + 24) = a8[2];
        *(_DWORD *)(v382 + 28) = a8[3];
        v379[1] = 0;
        uint64_t v383 = *(void *)(a2 + 216);
        void *v379 = v383;
        unint64_t v384 = (void *)*((void *)v376 + 20);
        uint64_t v385 = *(void *)(a2 + 224);
        if (v385) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v385 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v386 = (std::__shared_weak_count *)v384[1];
        void *v384 = v383;
        v384[1] = v385;
        if (v386 && !atomic_fetch_add(&v386->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v386->__on_zero_shared)(v386);
          std::__shared_weak_count::__release_weak(v386);
        }
        uint64_t v387 = *((void *)v376 + 8);
        *(void *)(v387 + 24) = 0;
        uint64_t v388 = *(void *)(a2 + 232);
        *(void *)(v387 + 16) = v388;
        uint64_t v389 = *((void *)v376 + 20);
        uint64_t v390 = *(void *)(a2 + 240);
        if (v390) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v390 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v391 = *(std::__shared_weak_count **)(v389 + 24);
        *(void *)(v389 + 16) = v388;
        *(void *)(v389 + 24) = v390;
        if (v391 && !atomic_fetch_add(&v391->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v391->__on_zero_shared)(v391);
          std::__shared_weak_count::__release_weak(v391);
        }
        uint64_t v392 = *((void *)v376 + 8);
        *(void *)(v392 + 48) = v475;
        *(void *)(v392 + 56) = 0;
        uint64_t v393 = *((void *)v376 + 20);
        if (v476) {
          atomic_fetch_add_explicit(&v476->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        unint64_t v394 = *(std::__shared_weak_count **)(v393 + 56);
        *(void *)(v393 + 48) = v475;
        *(void *)(v393 + 56) = v476;
        if (v394)
        {
          char v474 = 0;
          char v395 = 1;
          if (atomic_fetch_add(&v394->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_560;
          }
          goto LABEL_556;
        }
        char v474 = 0;
        char v395 = 1;
        goto LABEL_560;
      }
      goto LABEL_592;
    }
    goto LABEL_596;
  }
  if (*(unsigned char *)(a6 + 40))
  {
    unint64_t v456 = v373;
    uint64_t v469 = v372;
    uint64_t v375 = *(void *)(a6 + 8);
    char v396 = *(unsigned char *)(a6 + 24);
    v492.i64[0] = *(void *)(a6 + 25);
    *(uint64_t *)((char *)v492.i64 + 7) = *(void *)(a6 + 32);
    int8x8_t v376 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::ElevatedFillColorWithDistancePipelineSetup>::pop(a5[3]);
    char v474 = v396;
    md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedFillColorWithDistancePipelineState,std::shared_ptr<ggl::ElevatedFillColorShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants((std::__shared_weak_count **)v484, (uint64_t)(a5 + 49), v475 != 0);
    unint64_t v377 = a5;
    ggl::Flyover::FlyoverPipelineSetup::setState(v376, *(uint64_t *)v484, *(std::__shared_weak_count **)&v484[8]);
    unint64_t v397 = *(std::__shared_weak_count **)&v484[8];
    if (*(void *)&v484[8]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v484[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v397->__on_zero_shared)(v397);
      std::__shared_weak_count::__release_weak(v397);
    }
    uint64_t v398 = (void *)*((void *)v376 + 8);
    unint64_t v380 = (void *)v398[4];
    unint64_t v381 = v380[1];
    uint64_t v399 = v380[9];
    *(void *)&long long v400 = v469;
    *((void *)&v400 + 1) = v456;
    *(_OWORD *)uint64_t v399 = v400;
    *(_DWORD *)(v399 + 16) = *a8;
    *(_DWORD *)(v399 + 20) = a8[1];
    *(_DWORD *)(v399 + 24) = a8[2];
    *(_DWORD *)(v399 + 28) = a8[3];
    v398[1] = 0;
    uint64_t v401 = *(void *)(a2 + 216);
    *uint64_t v398 = v401;
    long long v402 = (void *)*((void *)v376 + 20);
    uint64_t v403 = *(void *)(a2 + 224);
    if (v403) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v403 + 8), 1uLL, memory_order_relaxed);
    }
    v404 = (std::__shared_weak_count *)v402[1];
    *long long v402 = v401;
    v402[1] = v403;
    if (v404 && !atomic_fetch_add(&v404->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v404->__on_zero_shared)(v404);
      std::__shared_weak_count::__release_weak(v404);
    }
    uint64_t v405 = *((void *)v376 + 8);
    *(void *)(v405 + 24) = 0;
    uint64_t v406 = *(void *)(a2 + 232);
    *(void *)(v405 + 16) = v406;
    uint64_t v407 = *((void *)v376 + 20);
    uint64_t v408 = *(void *)(a2 + 240);
    if (v408) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v408 + 8), 1uLL, memory_order_relaxed);
    }
    os_signpost_id_t v409 = *(std::__shared_weak_count **)(v407 + 24);
    *(void *)(v407 + 16) = v406;
    *(void *)(v407 + 24) = v408;
    if (v409 && !atomic_fetch_add(&v409->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v409->__on_zero_shared)(v409);
      std::__shared_weak_count::__release_weak(v409);
    }
    uint64_t v410 = *((void *)v376 + 8);
    *(void *)(v410 + 48) = v475;
    *(void *)(v410 + 56) = 0;
    uint64_t v411 = *((void *)v376 + 20);
    if (v476) {
      atomic_fetch_add_explicit(&v476->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v394 = *(std::__shared_weak_count **)(v411 + 56);
    *(void *)(v411 + 48) = v475;
    *(void *)(v411 + 56) = v476;
    char v395 = 0;
    if (v394 && !atomic_fetch_add(&v394->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
LABEL_556:
      ((void (*)(std::__shared_weak_count *))v394->__on_zero_shared)(v394);
      std::__shared_weak_count::__release_weak(v394);
    }
LABEL_560:
    *((void *)&v481 + 1) = v376;
    unint64_t v412 = v380[8];
    if (v412 <= v381) {
      unint64_t v412 = v381;
    }
    v380[7] = 0;
    v380[8] = v412;
    *(void *)&long long v481 = md::DaVinciRenderStateCache::renderState((unsigned __int8 **)v377 + 94, 3, 0, *a3 == 0, 0, 1, *a3, 3);
    *((void *)&v482 + 1) = (v354 << 10);
    uint64_t v413 = *(void *)(a4 + 8);
    uint64_t v472 = a4 + 8;
    if (v413)
    {
      uint64_t v414 = v472;
      do
      {
        int v415 = *(_DWORD *)(v413 + 28);
        BOOL v416 = v415 < v356;
        if (v415 >= v356) {
          uint8x8_t v417 = (uint64_t *)v413;
        }
        else {
          uint8x8_t v417 = (uint64_t *)(v413 + 8);
        }
        if (!v416) {
          uint64_t v414 = v413;
        }
        uint64_t v413 = *v417;
      }
      while (*v417);
      if (v414 != v472 && v356 >= *(_DWORD *)(v414 + 28))
      {
        unint64_t v418 = *(void **)(*((void *)a3 + 1) + 8);
        uint64_t v419 = v418[3];
        uint64_t v420 = v418[4];
        uint64_t v421 = v420 - v419;
        if (v420 == v419) {
          goto LABEL_579;
        }
        uint64_t v422 = 0;
        unint64_t v423 = v421 >> 3;
        while (1)
        {
          uint64_t v424 = *(unsigned __int8 **)(v419 + 8 * v422);
          if (*v424 == *(unsigned __int8 *)(v414 + 32))
          {
            unint64_t v425 = *((void *)v424 + 1);
            uint64_t v426 = v418[15];
            if (v425 < (v418[16] - v426) >> 3) {
              break;
            }
          }
          if (++v422 >= v423) {
            goto LABEL_579;
          }
        }
        uint64_t v427 = *(void *)(v426 + 8 * v425);
        if (!v427) {
LABEL_579:
        }
          uint64_t v428 = 0;
        else {
          uint64_t v428 = *(void *)(*(void *)(v427 + 24) + 8 * *(unsigned __int8 *)(v414 + 33));
        }
        if (v395)
        {
          *(_OWORD *)&v484[8] = v480;
          long long v485 = v481;
          long long v486 = v482;
          long long v490 = *(_OWORD *)&v483[48];
          long long v489 = *(_OWORD *)&v483[32];
          long long v488 = *(_OWORD *)&v483[16];
          *(void *)unint64_t v484 = &off_1EF55A458;
          long long v487 = *(_OWORD *)v483;
          uint64_t v429 = (void *)v377[92];
          uint64_t v430 = v429[1];
          if (v430 == v377[93])
          {
            uint64_t v429 = (void *)*v429;
            if (!v429)
            {
              uint64_t v429 = malloc_type_malloc(120 * v430 + 16, 0xB644C221uLL);
              void *v429 = 0;
              v429[1] = 0;
              *(void *)v377[92] = v429;
            }
            v377[92] = (uint64_t)v429;
            uint64_t v430 = v429[1];
          }
          uint64_t v431 = &v429[15 * v430];
          uint64_t v432 = (uint64_t)(v431 + 2);
          v429[1] = v430 + 1;
          v431[2] = &off_1EF55A458;
          long long v433 = v489;
          long long v434 = v490;
          long long v435 = v488;
          *(_OWORD *)(v431 + 9) = v487;
          long long v436 = *(_OWORD *)&v484[8];
          long long v437 = v485;
          *(_OWORD *)(v431 + 7) = v486;
          *(_OWORD *)(v431 + 5) = v437;
          *(_OWORD *)(v431 + 3) = v436;
          *(_OWORD *)(v431 + 15) = v434;
          *(_OWORD *)(v431 + 13) = v433;
          *(_OWORD *)(v431 + 11) = v435;
          v431[10] = v375;
        }
        else
        {
          *(_OWORD *)&v484[8] = v480;
          long long v485 = v481;
          long long v486 = v482;
          long long v490 = *(_OWORD *)&v483[48];
          long long v489 = *(_OWORD *)&v483[32];
          long long v488 = *(_OWORD *)&v483[16];
          *(void *)unint64_t v484 = &off_1EF55A458;
          long long v487 = *(_OWORD *)v483;
          v438 = (void *)v377[92];
          uint64_t v439 = v438[1];
          if (v439 == v377[93])
          {
            v438 = (void *)*v438;
            if (!v438)
            {
              v438 = malloc_type_malloc(120 * v439 + 16, 0xB644C221uLL);
              void *v438 = 0;
              v438[1] = 0;
              *(void *)v377[92] = v438;
            }
            v377[92] = (uint64_t)v438;
            uint64_t v439 = v438[1];
          }
          uint8x8_t v440 = &v438[15 * v439];
          uint64_t v432 = (uint64_t)(v440 + 2);
          v438[1] = v439 + 1;
          v440[2] = &off_1EF55A458;
          long long v442 = v489;
          long long v441 = v490;
          long long v443 = v488;
          *(_OWORD *)(v440 + 9) = v487;
          *(_OWORD *)(v440 + 11) = v443;
          *(_OWORD *)(v440 + 13) = v442;
          long long v444 = *(_OWORD *)&v484[8];
          long long v445 = v485;
          *(_OWORD *)(v440 + 7) = v486;
          *(_OWORD *)(v440 + 5) = v445;
          *(_OWORD *)(v440 + 3) = v444;
          *(_OWORD *)(v440 + 15) = v441;
          v440[10] = v375;
          *((unsigned char *)v440 + 88) = v474;
          uint64_t v446 = *(uint64_t *)((char *)v492.i64 + 7);
          *(void *)((char *)v440 + 89) = v492.i64[0];
          v440[12] = v446;
          v440[13] = 0;
          v440[14] = 1;
        }
        ggl::CommandBuffer::pushRenderItem(v428, v432);
      }
    }
  }
LABEL_592:
  if (v476)
  {
    if (!atomic_fetch_add(&v476->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v476->__on_zero_shared)(v476);
      std::__shared_weak_count::__release_weak(v476);
    }
  }
}

void sub_1A1B7863C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t md::DaVinciRenderStateCache::renderState(unsigned __int8 **a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9 = a7;
  if (a4) {
    unsigned int v12 = 2;
  }
  else {
    unsigned int v12 = 0;
  }
  if (a5) {
    int v13 = 4;
  }
  else {
    int v13 = 0;
  }
  if (a6) {
    int v14 = 8;
  }
  else {
    int v14 = 0;
  }
  if (a7) {
    int v15 = 16;
  }
  else {
    int v15 = 0;
  }
  int v16 = v14 | v15 | a3 | v12 | v13;
  float v18 = *a1;
  unint64_t v17 = a1[1];
  if (*a1 != v17)
  {
    while (*v18 != a2 || (v18[2] & 0x1F) != v16 || v18[1] != a8)
    {
      v18 += 16;
      if (v18 == v17) {
        goto LABEL_20;
      }
    }
  }
  if (v18 == v17)
  {
LABEL_20:
    int v19 = (v12 >> 1) ^ 1 | (a8 << 8) | ((a3 ^ 1) << 16);
    if (a6) {
      uint64_t v20 = 0x80000202020100;
    }
    else {
      uint64_t v20 = 1;
    }
    {
      operator new();
    }
    uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 216, 8);
    unsigned int v22 = (void (***)(void))v21;
    *(void *)(v21 + 16) = 0;
    *(void *)(v21 + 24) = 0;
    *(_DWORD *)(v21 + 32) = 0;
    *(_DWORD *)(v21 + 36) = v19;
    *(void *)uint64_t v21 = &unk_1EF55A890;
    *(void *)(v21 + 8) = 0;
    *(_DWORD *)(v21 + 40) = v13 << 28;
    *(_DWORD *)(v21 + 44) = v13 << 28;
    *(void *)(v21 + 48) = v20;
    *(void *)(v21 + 67) = 0;
    *(void *)(v21 + 59) = 0;
    *(unsigned char *)(v21 + 75) = 0;
    *(void *)(v21 + 132) = 0;
    *(void *)(v21 + 124) = 0;
    *(_WORD *)(v21 + 188) = 257;
    *(unsigned char *)(v21 + 208) = 0;
    *(void *)(v21 + 192) = 0;
    *(void *)(v21 + 200) = 0;
    *(unsigned char *)(v21 + 58) = a2;
    *(unsigned char *)(v21 + 56) = 1;
    if (a2 == 3) {
      char v23 = v9;
    }
    else {
      char v23 = 0;
    }
    *(unsigned char *)(v21 + 57) = v23;
    unint64_t v25 = *a1;
    float v24 = a1[1];
    float v18 = *a1;
    if (*a1 != v24)
    {
      while (*v18 != a2 || (v18[2] & 0x1F) != v16 || v18[1] != a8)
      {
        v18 += 16;
        if (v18 == v24) {
          goto LABEL_36;
        }
      }
    }
    if (v18 != v24)
    {
      if (!v21) {
        return *((void *)v18 + 1);
      }
      goto LABEL_63;
    }
LABEL_36:
    int v26 = a1[2];
    if (v24 >= v26)
    {
      uint64_t v28 = (v24 - v25) >> 4;
      unint64_t v29 = v28 + 1;
      if ((unint64_t)(v28 + 1) >> 60) {
        abort();
      }
      uint64_t v30 = v26 - v25;
      if (v30 >> 3 > v29) {
        unint64_t v29 = v30 >> 3;
      }
      if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v29 = 0xFFFFFFFFFFFFFFFLL;
      }
      if (v29)
      {
        uint64_t v31 = 16 * v29;
        uint64_t v32 = (*(uint64_t (**)(unsigned __int8 *, unint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 16 * v29, 8);
        uint64_t v33 = v32 + 16 * v28;
        unint64_t v29 = v32 + v31;
        if (v32)
        {
          *(unsigned char *)uint64_t v33 = a2;
          *(unsigned char *)(v33 + 1) = a8;
          *(unsigned char *)(v33 + 2) = v16;
          *(void *)(v33 + 8) = v22;
          unsigned int v22 = 0;
        }
      }
      else
      {
        uint64_t v33 = 16 * v28;
      }
      uint64_t v27 = v33 + 16;
      int v34 = *a1;
      int v35 = a1[1];
      if (v35 == *a1)
      {
        *a1 = (unsigned __int8 *)v33;
        a1[1] = (unsigned __int8 *)v27;
        unint64_t v40 = a1[2];
        a1[2] = (unsigned __int8 *)v29;
      }
      else
      {
        do
        {
          __int16 v36 = *((_WORD *)v35 - 8);
          v35 -= 16;
          unsigned __int8 v37 = v35[2];
          *(_WORD *)(v33 - 16) = v36;
          v33 -= 16;
          *(unsigned char *)(v33 + 2) = v37;
          uint64_t v38 = *((void *)v35 + 1);
          *((void *)v35 + 1) = 0;
          *(void *)(v33 + 8) = v38;
        }
        while (v35 != v34);
        int v35 = *a1;
        float v39 = a1[1];
        *a1 = (unsigned __int8 *)v33;
        a1[1] = (unsigned __int8 *)v27;
        unint64_t v40 = a1[2];
        for (a1[2] = (unsigned __int8 *)v29; v39 != v35; v39 -= 16)
        {
          uint64_t v41 = (void (***)(void))*((void *)v39 - 1);
          *((void *)v39 - 1) = 0;
          if (v41)
          {
            (**v41)(v41);
            {
              operator new();
            }
            (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                    + 40))(mdm::Allocator::instance(void)::alloc, v41, 216);
          }
        }
      }
      if (v35) {
        (*(void (**)(unsigned __int8 *, unsigned __int8 *, int64_t))(*(void *)a1[3] + 40))(a1[3], v35, v40 - v35);
      }
    }
    else
    {
      if (v24)
      {
        *float v24 = a2;
        v24[1] = a8;
        v24[2] = v16;
        *((void *)v24 + 1) = v21;
        unsigned int v22 = 0;
      }
      uint64_t v27 = (uint64_t)(v24 + 16);
    }
    a1[1] = (unsigned __int8 *)v27;
    float v18 = (unsigned __int8 *)(v27 - 16);
    if (v22)
    {
LABEL_63:
      (**v22)(v22);
      {
        operator new();
      }
      (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                              + 40))(mdm::Allocator::instance(void)::alloc, v22, 216);
    }
  }
  return *((void *)v18 + 1);
}

unint64_t gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(unint64_t result, unsigned int a2, unsigned int a3, unsigned char *a4)
{
  uint64_t v4 = *(void *)(result + 16 * a3 + 16);
  if (!v4)
  {
    if (a4) {
      *a4 = 0;
    }
    return (unint64_t)gss::defaultValueForKey<gss::PropertyID,BOOL>(a2);
  }
  unsigned int v5 = (char *)(result + 16 * a3);
  uint64_t v6 = *((unsigned __int16 *)v5 + 28);
  if (!*((_WORD *)v5 + 28))
  {
LABEL_31:
    float v24 = *(unsigned __int16 ****)(v4 + 72);
    if (v24)
    {
      uint64_t v11 = *v24;
      uint64_t v25 = *((unsigned __int16 *)v11 + 5);
      if (!*((_WORD *)v11 + 5))
      {
        LOWORD(v33) = 0;
        goto LABEL_66;
      }
      uint64_t v26 = (uint64_t)*v11;
      if (!*((unsigned char *)v11 + 15))
      {
        uint64_t v34 = 2 * v25;
        int v35 = *v11;
        while (*v35 != a2)
        {
          ++v35;
          v34 -= 2;
          if (!v34)
          {
            int v35 = (unsigned __int16 *)(v26 + 2 * v25);
            break;
          }
        }
        unint64_t v33 = ((unint64_t)v35 - v26) >> 1;
LABEL_66:
        if (v25 != (unsigned __int16)v33)
        {
          uint64_t v42 = *((unsigned __int16 *)v11 + 13);
          if (!*((_WORD *)v11 + 13)) {
            return (unint64_t)&gss::PropertySetValueHelper<gss::PropertyID,BOOL>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
          }
          uint64_t v30 = v11[2];
          if (*((unsigned char *)v11 + 31))
          {
            if (v42 >= 0x1E)
            {
              float v54 = v11[2];
              unint64_t v55 = *((unsigned __int16 *)v11 + 13);
              do
              {
                unint64_t v56 = v55 >> 1;
                uint64_t v57 = &v54[v55 >> 1];
                unsigned int v59 = *v57;
                uint64_t v58 = v57 + 1;
                v55 += ~(v55 >> 1);
                if (v59 < a2) {
                  float v54 = v58;
                }
                else {
                  unint64_t v55 = v56;
                }
              }
              while (v55);
              if (v54 == &v30[v42] || *v54 != a2) {
                return (unint64_t)&gss::PropertySetValueHelper<gss::PropertyID,BOOL>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
              }
              unint64_t v31 = (unint64_t)((char *)v54 - (char *)v30) >> 1;
            }
            else
            {
              unint64_t v31 = 0;
              double result = (unint64_t)&gss::PropertySetValueHelper<gss::PropertyID,BOOL>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
              while (1)
              {
                unsigned int v43 = v30[v31];
                if (v43 >= a2) {
                  break;
                }
                if (v42 == ++v31) {
                  return result;
                }
              }
              if (v43 != a2) {
                LOWORD(v31) = *((_WORD *)v11 + 13);
              }
            }
          }
          else
          {
            uint64_t v46 = 2 * v42;
            size_t v47 = v11[2];
            while (*v47 != a2)
            {
              ++v47;
              v46 -= 2;
              if (!v46)
              {
                size_t v47 = &v30[v42];
                break;
              }
            }
            unint64_t v31 = (unint64_t)((char *)v47 - (char *)v30) >> 1;
          }
          if (v42 == (unsigned __int16)v31) {
            return (unint64_t)&gss::PropertySetValueHelper<gss::PropertyID,BOOL>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
          }
          if (v42 <= (unsigned __int16)v31) {
            return result;
          }
          return (unint64_t)v30 + *((unsigned __int16 *)v11 + 12) + (unsigned __int16)v31;
        }
        goto LABEL_67;
      }
      if (v25 < 0x1E)
      {
        uint64_t v27 = 0;
        while (1)
        {
          unsigned int v28 = *(unsigned __int16 *)(v26 + 2 * v27);
          if (v28 >= a2) {
            break;
          }
          if (v25 == ++v27) {
            goto LABEL_67;
          }
        }
        if (v28 == a2) {
          LOWORD(v33) = v27;
        }
        else {
          LOWORD(v33) = *((_WORD *)v11 + 5);
        }
        goto LABEL_66;
      }
      __int16 v36 = *v11;
      unint64_t v37 = *((unsigned __int16 *)v11 + 5);
      do
      {
        unint64_t v38 = v37 >> 1;
        float v39 = &v36[v37 >> 1];
        unsigned int v41 = *v39;
        unint64_t v40 = v39 + 1;
        v37 += ~(v37 >> 1);
        if (v41 < a2) {
          __int16 v36 = v40;
        }
        else {
          unint64_t v37 = v38;
        }
      }
      while (v37);
      if (v36 != (unsigned __int16 *)(v26 + 2 * v25) && *v36 == a2)
      {
        unint64_t v33 = ((unint64_t)v36 - v26) >> 1;
        goto LABEL_66;
      }
    }
LABEL_67:
    if (a4) {
      *a4 = 0;
    }
    return (unint64_t)gss::defaultValueForKey<gss::PropertyID,BOOL>(a2);
  }
  uint64_t v7 = *((void *)v5 + 6);
  uint64_t v8 = v7 + 8 * v6;
  while (1)
  {
    unint64_t v10 = *(unsigned __int16 ****)(*(void *)v7 + 72);
    if (v10)
    {
      uint64_t v11 = *v10;
      uint64_t v12 = *((unsigned __int16 *)v11 + 5);
      if (*((_WORD *)v11 + 5))
      {
        uint64_t v13 = (uint64_t)*v11;
        if (*((unsigned char *)v11 + 15))
        {
          if (v12 >= 0x1E)
          {
            float v18 = *v11;
            unint64_t v19 = *((unsigned __int16 *)v11 + 5);
            do
            {
              unint64_t v20 = v19 >> 1;
              uint64_t v21 = &v18[v19 >> 1];
              unsigned int v23 = *v21;
              unsigned int v22 = v21 + 1;
              double result = v23;
              v19 += ~(v19 >> 1);
              if (v23 < a2) {
                float v18 = v22;
              }
              else {
                unint64_t v19 = v20;
              }
            }
            while (v19);
            if (v18 == (unsigned __int16 *)(v13 + 2 * v12) || *v18 != a2) {
              goto LABEL_6;
            }
            unint64_t v9 = ((unint64_t)v18 - v13) >> 1;
          }
          else
          {
            uint64_t v14 = 0;
            while (1)
            {
              unsigned int v15 = *(unsigned __int16 *)(v13 + 2 * v14);
              if (v15 >= a2) {
                break;
              }
              if (v12 == ++v14) {
                goto LABEL_6;
              }
            }
            LOWORD(v9) = v15 == a2 ? v14 : *((_WORD *)v11 + 5);
          }
        }
        else
        {
          uint64_t v16 = 2 * v12;
          unint64_t v17 = *v11;
          while (*v17 != a2)
          {
            ++v17;
            v16 -= 2;
            if (!v16)
            {
              unint64_t v17 = (unsigned __int16 *)(v13 + 2 * v12);
              break;
            }
          }
          unint64_t v9 = ((unint64_t)v17 - v13) >> 1;
        }
      }
      else
      {
        LOWORD(v9) = 0;
      }
      if (v12 != (unsigned __int16)v9) {
        break;
      }
    }
LABEL_6:
    v7 += 8;
    if (v7 == v8) {
      goto LABEL_31;
    }
  }
  uint64_t v29 = *((unsigned __int16 *)v11 + 13);
  if (!*((_WORD *)v11 + 13)) {
    return (unint64_t)&gss::PropertySetValueHelper<gss::PropertyID,BOOL>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
  }
  uint64_t v30 = v11[2];
  if (!*((unsigned char *)v11 + 31))
  {
    uint64_t v44 = 2 * v29;
    unint64_t v45 = v11[2];
    while (*v45 != a2)
    {
      ++v45;
      v44 -= 2;
      if (!v44)
      {
        unint64_t v45 = &v30[v29];
        break;
      }
    }
    unint64_t v31 = (unint64_t)((char *)v45 - (char *)v30) >> 1;
LABEL_105:
    if (v29 <= (unsigned __int16)v31) {
      return (unint64_t)&gss::PropertySetValueHelper<gss::PropertyID,BOOL>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
    }
    return (unint64_t)v30 + *((unsigned __int16 *)v11 + 12) + (unsigned __int16)v31;
  }
  if (v29 < 0x1E)
  {
    unint64_t v31 = 0;
    double result = (unint64_t)&gss::PropertySetValueHelper<gss::PropertyID,BOOL>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
    while (1)
    {
      unsigned int v32 = v30[v31];
      if (v32 >= a2) {
        break;
      }
      if (v29 == ++v31) {
        return result;
      }
    }
    if (v32 != a2) {
      LOWORD(v31) = *((_WORD *)v11 + 13);
    }
    goto LABEL_105;
  }
  unint64_t v48 = v11[2];
  unint64_t v49 = *((unsigned __int16 *)v11 + 13);
  do
  {
    unint64_t v50 = v49 >> 1;
    float v51 = &v48[v49 >> 1];
    unsigned int v53 = *v51;
    unsigned int v52 = v51 + 1;
    v49 += ~(v49 >> 1);
    if (v53 < a2) {
      unint64_t v48 = v52;
    }
    else {
      unint64_t v49 = v50;
    }
  }
  while (v49);
  if (v48 != &v30[v29] && *v48 == a2)
  {
    unint64_t v31 = (unint64_t)((char *)v48 - (char *)v30) >> 1;
    goto LABEL_105;
  }
  return (unint64_t)&gss::PropertySetValueHelper<gss::PropertyID,BOOL>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *uint64_t v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      unsigned int v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        int v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *uint64_t v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      unsigned int v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  unsigned int v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineState,std::shared_ptr<ggl::ElevatedStrokeColorWithDistanceShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(std::__shared_weak_count **a1, uint64_t a2, __int8 a3, char a4)
{
  v8.i64[0] = 65792;
  v8.i32[2] = 65792;
  v8.i16[6] = 0;
  v8.i8[14] = 0;
  v8.i8[15] = a3;
  unint64_t v9 = 0;
  BYTE4(v9) = a4;
  int8x16_t v10 = vceqzq_s8(v8);
  int16x8_t v11 = vmovl_high_s8(v10);
  int32x4_t v12 = vmovl_s16(*(int16x4_t *)v11.i8);
  v13.i64[0] = v12.u32[0];
  v13.i64[1] = v12.u32[1];
  int8x16_t v14 = v13;
  int16x8_t v15 = vmovl_s8(*(int8x8_t *)v10.i8);
  int32x4_t v16 = vmovl_s16(*(int16x4_t *)v15.i8);
  v13.i64[0] = v16.u32[0];
  v13.i64[1] = v16.u32[1];
  int8x16_t v17 = v13;
  int32x4_t v18 = vmovl_high_s16(v11);
  v13.i64[0] = v18.u32[0];
  v13.i64[1] = v18.u32[1];
  int8x16_t v19 = v13;
  int32x4_t v20 = vmovl_high_s16(v15);
  v13.i64[0] = v20.u32[0];
  v13.i64[1] = v20.u32[1];
  int8x16_t v21 = v13;
  v13.i64[0] = v12.u32[2];
  v13.i64[1] = v12.u32[3];
  int8x16_t v22 = v13;
  v13.i64[0] = v16.u32[2];
  v13.i64[1] = v16.u32[3];
  int8x16_t v23 = v13;
  v13.i64[0] = v18.u32[2];
  v13.i64[1] = v18.u32[3];
  int8x16_t v24 = v13;
  v13.i64[0] = v20.u32[2];
  v13.i64[1] = v20.u32[3];
  int8x16_t v25 = vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v13);
  int8x16_t v26 = vbicq_s8((int8x16_t)xmmword_1A28FCA20, v22);
  int8x16_t v27 = vceqzq_s8((int8x16_t)v9);
  int16x8_t v28 = vmovl_high_s8(v27);
  int32x4_t v29 = vmovl_s16(*(int16x4_t *)v28.i8);
  v13.i64[0] = v29.i32[0];
  v13.i64[1] = v29.i32[1];
  int8x16_t v30 = v13;
  int16x8_t v31 = vmovl_s8(*(int8x8_t *)v27.i8);
  int32x4_t v32 = vmovl_s16(*(int16x4_t *)v31.i8);
  v13.i64[0] = v32.i32[0];
  v13.i64[1] = v32.i32[1];
  int8x16_t v33 = v13;
  int32x4_t v34 = vmovl_high_s16(v28);
  v13.i64[0] = v34.i32[0];
  v13.i64[1] = v34.i32[1];
  int8x16_t v35 = v13;
  int32x4_t v36 = vmovl_high_s16(v31);
  v13.i64[0] = v36.i32[0];
  v13.i64[1] = v36.i32[1];
  int8x16_t v37 = v13;
  v13.i64[0] = v29.i32[2];
  v13.i64[1] = v29.i32[3];
  int8x16_t v38 = v13;
  v13.i64[0] = v32.i32[2];
  v13.i64[1] = v32.i32[3];
  int8x16_t v39 = v13;
  v13.i64[0] = v34.i32[2];
  v13.i64[1] = v34.i32[3];
  int8x16_t v40 = v13;
  v13.i64[0] = v36.i32[2];
  v13.i64[1] = v36.i32[3];
  unint64_t v41 = vaddvq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA80, v33), vbicq_s8((int8x16_t)xmmword_1A28FCA50, v17)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA70, v30), vbicq_s8((int8x16_t)xmmword_1A28FCA60, v14))), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAA0, v37), vbicq_s8((int8x16_t)xmmword_1A28FCA30, v21)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA90, v35), vbicq_s8((int8x16_t)xmmword_1A28FCA40, v19)))), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAC0, v39),
                                      vbicq_s8((int8x16_t)xmmword_1A28FCA10, v23)),
                                    vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAB0, v38), v26)),
                                  vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAE0, v13), v25), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAD0, v40), vbicq_s8((int8x16_t)xmmword_1A28FCA00, v24))))));
  unint64_t v42 = v41;
  uint64_t v44 = (uint64_t **)(a2 + 104);
  uint64_t v43 = *(void **)(a2 + 104);
  if (!v43) {
    goto LABEL_12;
  }
  unint64_t v45 = (uint64_t **)(a2 + 104);
  do
  {
    unint64_t v46 = v43[4];
    BOOL v47 = v46 >= v41;
    if (v46 >= v41) {
      unint64_t v48 = v43;
    }
    else {
      unint64_t v48 = v43 + 1;
    }
    if (v47) {
      unint64_t v45 = (uint64_t **)v43;
    }
    uint64_t v43 = (void *)*v48;
  }
  while (*v48);
  if (v45 != v44 && v41 >= (unint64_t)v45[4])
  {
    *a1 = (std::__shared_weak_count *)v45[5];
    uint64_t v132 = v45[6];
    a1[1] = (std::__shared_weak_count *)v132;
    if (v132) {
      atomic_fetch_add_explicit(v132 + 1, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_12:
    unint64_t v49 = (std::__shared_weak_count *)operator new(0x198uLL);
    v49->__shared_owners_ = 0;
    v49->__shared_weak_owners_ = 0;
    v49->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589898;
    unint64_t v50 = v49 + 1;
    long long v133 = *(_OWORD *)(a2 + 16);
    long long v134 = *(_OWORD *)(a2 + 32);
    {
      {
        {
          {
            ggl::MeshTyped<ggl::DaVinci::DistanceCompressedVbo>::attributesReflection(void)::r = (uint64_t)&ggl::DaVinci::distanceCompressedVboReflection;
          }
          ggl::MeshTyped<ggl::DaVinci::DistanceCompressedVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::DaVinci::DistanceCompressedVbo>::attributesReflection(void)::r;
          unk_1E957F298 = 1;
        }
        ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::DaVinci::DistanceCompressedVbo>::typedReflection(void)::r;
        *(void *)algn_1E957F0F8 = &ggl::DaVinci::pipelineDataElevatedStrokeColorWithDistancePipelineDeviceStructs(void)::ref;
        qword_1E957F100 = 0;
        {
          ggl::DaVinci::pipelineDataElevatedStrokeColorWithDistancePipelineConstantStructs(void)::ref = (uint64_t)ggl::Tile::View::reflection(void)::reflection;
          unk_1E957F150 = ggl::Tile::Transform::reflection(void)::reflection;
          qword_1E957F158 = (uint64_t)ggl::Tile::Clipping::reflection(void)::reflection;
          unk_1E957F160 = ggl::DaVinci::ClippedStroke::reflection(void)::reflection;
          qword_1E957F168 = (uint64_t)ggl::PolylineOverlayRibbon::Style::reflection(void)::reflection;
        }
        qword_1E957F108 = (uint64_t)&ggl::DaVinci::pipelineDataElevatedStrokeColorWithDistancePipelineConstantStructs(void)::ref;
        unk_1E957F110 = xmmword_1A28FC940;
      }
      ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineState::typedReflection(void)::ref = (uint64_t)&ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup::typedReflection(void)::ref;
      {
        ggl::ElevatedStrokeColorWithDistanceShader::typedReflection(void)::ref = (uint64_t)"ElevatedStrokeColorWithDistanceShader";
        {
          qword_1EB31D660 = (uint64_t)"ElevatedStrokeColorWithDistanceShader";
          unk_1EB31D668 = ggl::elevatedStrokeColorWithDistanceShaderVertShaderFunctionAttributes(void)::ref;
          qword_1EB31D670 = 1;
          unk_1EB31D678 = &ggl::elevatedStrokeColorWithDistanceShaderVertShaderFunctionConstantMapping(void)::ref;
          qword_1EB31D680 = 4;
          unk_1EB31D688 = &ggl::elevatedStrokeColorWithDistanceShaderVertShaderFunctionBufferMapping(void)::ref;
          qword_1EB31D690 = 0;
          unk_1EB31D698 = &ggl::elevatedStrokeColorWithDistanceShaderVertShaderFunctionTextureMapping(void)::ref;
          ggl::elevatedStrokeColorWithDistanceShaderVertexFunctionDescriptor(void)::ref = 1731713468;
          qword_1EB31D6A0 = 0;
          unk_1EB31D6A8 = &ggl::elevatedStrokeColorWithDistanceShaderVertShaderFunctionSamplerMapping(void)::ref;
          qword_1EB31D6B8 = 0;
          unk_1EB31D6C0 = 0;
          qword_1EB31D6B0 = 0;
        }
        qword_1EB31C4E0 = (uint64_t)&ggl::elevatedStrokeColorWithDistanceShaderVertexFunctionDescriptor(void)::ref;
        dword_1EB31C4E8 = 1731713468;
        {
          ggl::elevatedStrokeColorWithDistanceShaderFragmentFunctionDescriptor(void)::ref = 0x1F73A1BC0;
          qword_1EB31D898 = (uint64_t)"ElevatedStrokeColorWithDistanceShader";
          unk_1EB31D8A0 = 0;
          qword_1EB31D8A8 = 0;
          unk_1EB31D8B0 = &ggl::elevatedStrokeColorWithDistanceShaderFragShaderFunctionConstantMapping(void)::ref;
          qword_1EB31D8B8 = 3;
          unk_1EB31D8C0 = &ggl::elevatedStrokeColorWithDistanceShaderFragShaderFunctionBufferMapping(void)::ref;
          qword_1EB31D8C8 = 0;
          unk_1EB31D8D0 = &ggl::elevatedStrokeColorWithDistanceShaderFragShaderFunctionTextureMapping(void)::ref;
          qword_1EB31D8D8 = 1;
          unk_1EB31D8E0 = &ggl::elevatedStrokeColorWithDistanceShaderFragShaderFunctionSamplerMapping(void)::ref;
          qword_1EB31D8F0 = 0;
          unk_1EB31D8F8 = 0;
          qword_1EB31D8E8 = 1;
        }
        qword_1EB31C4F0 = (uint64_t)&ggl::elevatedStrokeColorWithDistanceShaderFragmentFunctionDescriptor(void)::ref;
        dword_1EB31C4F8 = -147186752;
        qword_1EB31C500 = (uint64_t)ggl::elevatedStrokeColorWithDistanceShaderShaderConstants(void)::ref;
        unk_1EB31C508 = 5;
        qword_1EB31C510 = (uint64_t)ggl::elevatedStrokeColorWithDistanceShaderShaderTextures(void)::ref;
        unk_1EB31C518 = 1;
        qword_1EB31C520 = (uint64_t)&ggl::elevatedStrokeColorWithDistanceShaderShaderSamplers(void)::ref;
        unk_1EB31C528 = 1;
      }
      qword_1E957F500 = (uint64_t)&ggl::ElevatedStrokeColorWithDistanceShader::typedReflection(void)::ref;
      {
        ggl::DaVinci::pipelineStateElevatedStrokeColorWithDistancePipelineAttributeStructBinding(void)::attr = 0;
        unk_1E9589DC0 = 0;
        qword_1E9589DC8 = (uint64_t)"";
        dword_1E9589DD0 = 0;
        qword_1E9589DD8 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorWithDistancePipelineAttributeBinding_0(void)::attr;
        unk_1E9589DE0 = 3;
      }
      qword_1E957F508 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorWithDistancePipelineAttributeStructBinding(void)::attr;
      unk_1E957F510 = 1;
      qword_1E957F518 = 0;
      unk_1E957F520 = 1;
      qword_1E957F528 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorWithDistancePipelineDeviceStructBinding(void)::ref;
      unk_1E957F530 = 0;
      {
        ggl::DaVinci::pipelineStateElevatedStrokeColorWithDistancePipelineConstantStructBinding(void)::ref = 0;
        unk_1E9589CD0 = 0;
        qword_1E9589CD8 = (uint64_t)"view";
        dword_1E9589CE0 = 3;
        qword_1E9589CE8 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorWithDistancePipelineConstantViewBinding(void)::reflection;
        *(_OWORD *)algn_1E9589CF0 = xmmword_1A28FCEB0;
        qword_1E9589D00 = 1;
        unk_1E9589D08 = "transform";
        dword_1E9589D10 = 3;
        qword_1E9589D18 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorWithDistancePipelineConstantTransformBinding(void)::reflection;
        unk_1E9589D20 = xmmword_1A28FCF70;
        qword_1E9589D30 = 2;
        unk_1E9589D38 = "tileClipping";
        dword_1E9589D40 = 3;
        qword_1E9589D48 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorWithDistancePipelineConstantTileClippingBinding(void)::reflection;
        *(_OWORD *)algn_1E9589D50 = xmmword_1A28FC910;
        qword_1E9589D60 = 3;
        unk_1E9589D68 = "clippedStroke";
        dword_1E9589D70 = 3;
        qword_1E9589D78 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorWithDistancePipelineConstantClippedStrokeBinding(void)::reflection;
        unk_1E9589D80 = vdupq_n_s64(4uLL);
        qword_1E9589D90 = 4;
        unk_1E9589D98 = "style";
        dword_1E9589DA0 = 3;
        qword_1E9589DA8 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorWithDistancePipelineConstantStyleBinding(void)::reflection;
        unk_1E9589DB0 = 8;
      }
      qword_1E957F538 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorWithDistancePipelineConstantStructBinding(void)::ref;
      unk_1E957F540 = 5;
    }
    float v51 = *(std::__shared_weak_count_vtbl **)a2;
    unsigned int v52 = *(std::__shared_weak_count **)(a2 + 8);
    if (v52) {
      atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(_OWORD *)unint64_t v135 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)&v135[12] = *(_OWORD *)(a2 + 60);
    long long v53 = *(_OWORD *)(a2 + 76);
    char v54 = *(unsigned char *)(a2 + 92);
    v49[1].__shared_weak_owners_ = 0;
    v49[2].__vftable = 0;
    LODWORD(v49[2].__shared_owners_) = 0;
    v49[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55B208;
    v49[1].__shared_owners_ = 0;
    v49[2].__shared_weak_owners_ = (uint64_t)&ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineState::typedReflection(void)::ref;
    v49[3].__vftable = v51;
    v49[3].__shared_owners_ = (uint64_t)v52;
    if (v52) {
      atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    LOBYTE(v49[5].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v49[5].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v49[6].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v49[7].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v49[6].__shared_weak_owners_ + 4) = 0;
    LOBYTE(v49[7].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v49[7].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v49[8].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v49[9].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v49[8].__shared_weak_owners_ + 4) = 0;
    LOBYTE(v49[9].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v49[9].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v49[10].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v49[11].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v49[10].__shared_weak_owners_ + 4) = 0;
    *(_OWORD *)&v49[11].__shared_weak_owners_ = v133;
    *(_OWORD *)&v49[12].__shared_owners_ = v134;
    LOBYTE(v49[13].__vftable) = 0;
    v49[16].__vftable = 0;
    *(_OWORD *)&v49[14].__shared_weak_owners_ = 0u;
    *(_OWORD *)&v49[15].__shared_owners_ = 0u;
    *(_OWORD *)&v49[13].__shared_owners_ = 0u;
    v49[14].std::__shared_count = 0u;
    v49[16].__shared_owners_ = 0x100000001;
    LOBYTE(v49[16].__shared_weak_owners_) = 0;
    *(std::__shared_count *)((char *)&v49[4].std::__shared_count + 4) = *(std::__shared_count *)&v135[12];
    *(_OWORD *)&v49[3].__shared_weak_owners_ = *(_OWORD *)v135;
    *(_OWORD *)((char *)&v49[4].__shared_weak_owners_ + 4) = v53;
    BYTE4(v49[5].__shared_owners_) = v54;
    if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
    *(std::__shared_weak_count_vtbl **)((char *)&v49[14].__vftable + 1) = 0;
    BYTE1(v49[14].__shared_owners_) = 0;
    *(uint64_t *)((char *)&v49[13].__shared_weak_owners_ + 1) = 0;
    WORD1(v49[14].__shared_owners_) = 257;
    HIDWORD(v49[14].__shared_owners_) = 0;
    v49[14].__shared_weak_owners_ = 16842752;
    int8x16_t v55 = *(int8x16_t *)&v49[14].__shared_owners_;
    int8x16_t v56 = vceqzq_s8(*(int8x16_t *)&v49[13].__shared_weak_owners_);
    int16x8_t v57 = vmovl_high_s8(v56);
    int32x4_t v58 = vmovl_s16(*(int16x4_t *)v57.i8);
    v59.i64[0] = v58.u32[0];
    v59.i64[1] = v58.u32[1];
    int8x16_t v60 = v59;
    int16x8_t v61 = vmovl_s8(*(int8x8_t *)v56.i8);
    int32x4_t v62 = vmovl_s16(*(int16x4_t *)v61.i8);
    v59.i64[0] = v62.u32[0];
    v59.i64[1] = v62.u32[1];
    int8x16_t v63 = v59;
    int32x4_t v64 = vmovl_high_s16(v57);
    v59.i64[0] = v64.u32[0];
    v59.i64[1] = v64.u32[1];
    int8x16_t v65 = v59;
    int32x4_t v66 = vmovl_high_s16(v61);
    v59.i64[0] = v66.u32[0];
    v59.i64[1] = v66.u32[1];
    int8x16_t v67 = v59;
    v59.i64[0] = v58.u32[2];
    v59.i64[1] = v58.u32[3];
    int8x16_t v68 = v59;
    v59.i64[0] = v62.u32[2];
    v59.i64[1] = v62.u32[3];
    int8x16_t v69 = v59;
    v59.i64[0] = v64.u32[2];
    v59.i64[1] = v64.u32[3];
    int8x16_t v70 = v59;
    v59.i64[0] = v66.u32[2];
    v59.i64[1] = v66.u32[3];
    int8x16_t v71 = vbicq_s8((int8x16_t)xmmword_1A28FC980, v59);
    v49[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF561468;
    LOBYTE(v49[15].__vftable) = a3;
    *(_WORD *)((char *)&v49[15].__vftable + 1) = 0;
    BYTE3(v49[15].__vftable) = 0;
    BYTE4(v49[15].__vftable) = a4;
    int8x16_t v72 = vbicq_s8((int8x16_t)xmmword_1A28FC990, v70);
    int8x16_t v73 = vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v69);
    *(_WORD *)((char *)&v49[15].__vftable + 5) = 0;
    int8x16_t v74 = vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v65);
    HIBYTE(v49[15].__vftable) = 0;
    int8x16_t v75 = vceqzq_s8(v55);
    int16x8_t v76 = vmovl_high_s8(v75);
    int32x4_t v77 = vmovl_s16(*(int16x4_t *)v76.i8);
    v59.i64[0] = v77.u32[0];
    v59.i64[1] = v77.u32[1];
    int8x16_t v78 = v59;
    int16x8_t v79 = vmovl_s8(*(int8x8_t *)v75.i8);
    int32x4_t v80 = vmovl_s16(*(int16x4_t *)v79.i8);
    v59.i64[0] = v80.u32[0];
    v59.i64[1] = v80.u32[1];
    int8x16_t v81 = v59;
    int32x4_t v82 = vmovl_high_s16(v76);
    v59.i64[0] = v82.u32[0];
    v59.i64[1] = v82.u32[1];
    int8x16_t v83 = v59;
    int32x4_t v84 = vmovl_high_s16(v79);
    v59.i64[0] = v84.u32[0];
    v59.i64[1] = v84.u32[1];
    int8x16_t v85 = v59;
    v59.i64[0] = v77.u32[2];
    v59.i64[1] = v77.u32[3];
    int8x16_t v86 = v59;
    v59.i64[0] = v80.u32[2];
    v59.i64[1] = v80.u32[3];
    int8x16_t v87 = v59;
    v59.i64[0] = v82.u32[2];
    v59.i64[1] = v82.u32[3];
    int8x16_t v88 = v59;
    v59.i64[0] = v84.u32[2];
    v59.i64[1] = v84.u32[3];
    int8x16_t v89 = vbicq_s8((int8x16_t)xmmword_1A28FCA00, v88);
    int8x16_t v90 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA60, v78), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v60));
    int8x16_t v91 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v81), vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v63));
    int8x16_t v92 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA40, v83), v74);
    int8x16_t v93 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v85), vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v67));
    int8x16_t v94 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA20, v86), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v68));
    int8x16_t v95 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v87), v73);
    int8x16_t v96 = vorrq_s8(v89, v72);
    int8x16_t v97 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v59), v71);
    int8x16_t v98 = vceqzq_s8((int8x16_t)v49[15].std::__shared_count);
    int16x8_t v99 = vmovl_s8(*(int8x8_t *)v98.i8);
    int32x4_t v100 = vmovl_high_s16(v99);
    v59.i64[0] = v100.i32[2];
    v59.i64[1] = v100.i32[3];
    int8x16_t v101 = v59;
    int16x8_t v102 = vmovl_high_s8(v98);
    int32x4_t v103 = vmovl_high_s16(v102);
    v59.i64[0] = v103.i32[2];
    v59.i64[1] = v103.i32[3];
    int8x16_t v104 = v59;
    int32x4_t v105 = vmovl_s16(*(int16x4_t *)v99.i8);
    v59.i64[0] = v105.i32[2];
    v59.i64[1] = v105.i32[3];
    int8x16_t v106 = v59;
    int32x4_t v107 = vmovl_s16(*(int16x4_t *)v102.i8);
    v59.i64[0] = v107.i32[2];
    v59.i64[1] = v107.i32[3];
    int8x16_t v108 = v59;
    v59.i64[0] = v100.i32[0];
    v59.i64[1] = v100.i32[1];
    int8x16_t v109 = v59;
    v59.i64[0] = v103.i32[0];
    v59.i64[1] = v103.i32[1];
    int8x16_t v110 = v59;
    v59.i64[0] = v105.i32[0];
    v59.i64[1] = v105.i32[1];
    int8x16_t v111 = v59;
    v59.i64[0] = v107.i32[0];
    v59.i64[1] = v107.i32[1];
    int8x16_t v112 = vbicq_s8((int8x16_t)xmmword_1A28FCA70, v59);
    int8x16_t v113 = vceqzq_s8(*(int8x16_t *)&v49[15].__shared_weak_owners_);
    int16x8_t v114 = vmovl_high_s8(v113);
    int32x4_t v115 = vmovl_s16(*(int16x4_t *)v114.i8);
    v59.i64[0] = v115.i32[0];
    v59.i64[1] = v115.i32[1];
    int8x16_t v116 = v59;
    int16x8_t v117 = vmovl_s8(*(int8x8_t *)v113.i8);
    int32x4_t v118 = vmovl_s16(*(int16x4_t *)v117.i8);
    v59.i64[0] = v118.i32[0];
    v59.i64[1] = v118.i32[1];
    int8x16_t v119 = v59;
    int32x4_t v120 = vmovl_high_s16(v114);
    v59.i64[0] = v120.i32[0];
    v59.i64[1] = v120.i32[1];
    int8x16_t v121 = v59;
    int32x4_t v122 = vmovl_high_s16(v117);
    v59.i64[0] = v122.i32[0];
    v59.i64[1] = v122.i32[1];
    int8x16_t v123 = v59;
    v59.i64[0] = v115.i32[2];
    v59.i64[1] = v115.i32[3];
    int8x16_t v124 = v59;
    v59.i64[0] = v118.i32[2];
    v59.i64[1] = v118.i32[3];
    int8x16_t v125 = v59;
    v59.i64[0] = v120.i32[2];
    v59.i64[1] = v120.i32[3];
    int8x16_t v126 = v59;
    v59.i64[0] = v122.i32[2];
    v59.i64[1] = v122.i32[3];
    v49[13].__shared_owners_ = vaddvq_s64(vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB50, v119), vbicq_s8((int8x16_t)xmmword_1A28FCA80, v111)), v91), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB60, v116), v112), v90)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB30, v123), vbicq_s8((int8x16_t)xmmword_1A28FCAA0, v109)), v93), vorrq_s8(vorrq_s8(
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCB40, v121),
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCA90, v110)),
                                                    v92))),
                                   (int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB10, v125), vbicq_s8((int8x16_t)xmmword_1A28FCAC0, v106)), v95), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB20, v124), vbicq_s8((int8x16_t)xmmword_1A28FCAB0, v108)), v94)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAF0, v59), vbicq_s8((int8x16_t)xmmword_1A28FCAE0, v101)), v97), vorrq_s8(vorrq_s8(
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCB00, v126),
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCAD0, v104)),
                                                    v96)))));
    LOBYTE(v49[13].__vftable) = 1;
    *a1 = v50;
    a1[1] = v49;
    atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v127 = *v44;
    uint64_t v128 = v44;
    if (*v44)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v128 = (uint64_t **)v127;
          unint64_t v129 = v127[4];
          if (v42 >= v129) {
            break;
          }
          uint64_t v127 = *v128;
          uint64_t v44 = v128;
          if (!*v128) {
            goto LABEL_27;
          }
        }
        if (v129 >= v42) {
          break;
        }
        uint64_t v127 = v128[1];
        if (!v127)
        {
          uint64_t v44 = v128 + 1;
          goto LABEL_27;
        }
      }
      if (!atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
      }
    }
    else
    {
LABEL_27:
      uint64_t v130 = (uint64_t *)operator new(0x38uLL);
      v130[4] = v42;
      v130[5] = (uint64_t)v50;
      v130[6] = (uint64_t)v49;
      *uint64_t v130 = 0;
      v130[1] = 0;
      v130[2] = (uint64_t)v128;
      unsigned char *v44 = v130;
      uint64_t v131 = **(void **)(a2 + 96);
      if (v131)
      {
        *(void *)(a2 + 96) = v131;
        uint64_t v130 = *v44;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a2 + 104), v130);
      ++*(void *)(a2 + 112);
    }
  }
}

void sub_1A1B7A0CC(_Unwind_Exception *a1)
{
  md::components::Material::~Material((md::components::Material *)(v2 - 176));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>,std::__map_value_compare<geo::Color<float,4,(geo::ColorSpace)0>,std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>,std::less<geo::Color<float,4,(geo::ColorSpace)0>>,true>,std::allocator<std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>>>::__emplace_unique_key_args<geo::Color<float,4,(geo::ColorSpace)0>,geo::Color<float,4,(geo::ColorSpace)0> const&,unsigned char &>(uint64_t *result, float *a2, _OWORD *a3, char a4)
{
  uint64_t v6 = result;
  int8x16_t v8 = (uint64_t **)(result + 1);
  uint64_t v7 = result[1];
  if (v7)
  {
    float v9 = *a2;
    float v10 = a2[1];
    float v11 = a2[2];
    float v12 = a2[3];
    while (1)
    {
      while (1)
      {
        int8x16_t v13 = (uint64_t **)v7;
        float v14 = *(float *)(v7 + 28);
        if (v9 >= v14 || v10 >= *(float *)(v7 + 32) || v11 >= *(float *)(v7 + 36) || v12 >= *(float *)(v7 + 40)) {
          break;
        }
        uint64_t v7 = *(void *)v7;
        int8x16_t v8 = v13;
        if (!*v13) {
          goto LABEL_16;
        }
      }
      if (v14 >= v9 || *(float *)(v7 + 32) >= v10 || *(float *)(v7 + 36) >= v11 || *(float *)(v7 + 40) >= v12) {
        break;
      }
      uint64_t v7 = *(void *)(v7 + 8);
      if (!v7)
      {
        int8x16_t v8 = v13 + 1;
        goto LABEL_16;
      }
    }
  }
  else
  {
    int8x16_t v13 = (uint64_t **)(result + 1);
LABEL_16:
    int16x8_t v15 = (char *)operator new(0x30uLL);
    *(_OWORD *)(v15 + 28) = *a3;
    v15[44] = a4;
    *(void *)int16x8_t v15 = 0;
    *((void *)v15 + 1) = 0;
    *((void *)v15 + 2) = v13;
    *int8x16_t v8 = (uint64_t *)v15;
    uint64_t v16 = *(void *)*v6;
    if (v16)
    {
      uint64_t *v6 = v16;
      int8x16_t v17 = *v8;
    }
    else
    {
      int8x16_t v17 = (uint64_t *)v15;
    }
    double result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v6[1], v17);
    ++v6[2];
  }
  return result;
}

void md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedFillColorWithDistancePipelineState,std::shared_ptr<ggl::ElevatedFillColorShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(std::__shared_weak_count **a1, uint64_t a2, __int8 a3)
{
  v6.i64[0] = 65792;
  v6.i32[2] = 65792;
  v6.i16[6] = 0;
  v6.i8[14] = 0;
  v6.i8[15] = a3;
  int8x16_t v7 = vceqzq_s8(v6);
  int16x8_t v8 = vmovl_s8(*(int8x8_t *)v7.i8);
  int32x4_t v9 = vmovl_high_s16(v8);
  v10.i64[0] = v9.u32[2];
  v10.i64[1] = v9.u32[3];
  int8x16_t v11 = v10;
  int16x8_t v12 = vmovl_high_s8(v7);
  int32x4_t v13 = vmovl_high_s16(v12);
  v10.i64[0] = v13.u32[2];
  v10.i64[1] = v13.u32[3];
  int8x16_t v14 = v10;
  int32x4_t v15 = vmovl_s16(*(int16x4_t *)v8.i8);
  v10.i64[0] = v15.u32[2];
  v10.i64[1] = v15.u32[3];
  int8x16_t v16 = v10;
  int32x4_t v17 = vmovl_s16(*(int16x4_t *)v12.i8);
  v10.i64[0] = v17.u32[2];
  v10.i64[1] = v17.u32[3];
  int8x16_t v18 = v10;
  v10.i64[0] = v9.u32[0];
  v10.i64[1] = v9.u32[1];
  int8x16_t v19 = v10;
  v10.i64[0] = v13.u32[0];
  v10.i64[1] = v13.u32[1];
  int8x16_t v20 = v10;
  v10.i64[0] = v15.u32[0];
  v10.i64[1] = v15.u32[1];
  int8x16_t v21 = v10;
  v10.i64[0] = v17.u32[0];
  v10.i64[1] = v17.u32[1];
  unint64_t v22 = vaddvq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v21), vbicq_s8((int8x16_t)xmmword_1A28FCA60, v10)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v19), vbicq_s8((int8x16_t)xmmword_1A28FCA40, v20))), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v16), vbicq_s8((int8x16_t)xmmword_1A28FCA20, v18)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v11), vbicq_s8((int8x16_t)xmmword_1A28FCA00, v14)))));
  unint64_t v23 = v22;
  int8x16_t v25 = (uint64_t **)(a2 + 104);
  int8x16_t v24 = *(void **)(a2 + 104);
  if (!v24) {
    goto LABEL_12;
  }
  int8x16_t v26 = (uint64_t **)(a2 + 104);
  do
  {
    unint64_t v27 = v24[4];
    BOOL v28 = v27 >= v22;
    if (v27 >= v22) {
      int32x4_t v29 = v24;
    }
    else {
      int32x4_t v29 = v24 + 1;
    }
    if (v28) {
      int8x16_t v26 = (uint64_t **)v24;
    }
    int8x16_t v24 = (void *)*v29;
  }
  while (*v29);
  if (v26 != v25 && v22 >= (unint64_t)v26[4])
  {
    *a1 = (std::__shared_weak_count *)v26[5];
    int8x16_t v113 = v26[6];
    a1[1] = (std::__shared_weak_count *)v113;
    if (v113) {
      atomic_fetch_add_explicit(v113 + 1, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_12:
    int8x16_t v30 = (std::__shared_weak_count *)operator new(0x198uLL);
    v30->__shared_owners_ = 0;
    v30->__shared_weak_owners_ = 0;
    v30->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589860;
    int16x8_t v31 = v30 + 1;
    long long v115 = *(_OWORD *)(a2 + 16);
    long long v116 = *(_OWORD *)(a2 + 32);
    {
      if (v114)
      {
        {
          if (v114)
          {
            {
              {
                ggl::MeshTyped<ggl::DaVinci::DistanceCompressedVbo>::attributesReflection(void)::r = (uint64_t)&ggl::DaVinci::distanceCompressedVboReflection;
              }
              ggl::MeshTyped<ggl::DaVinci::DistanceCompressedVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::DaVinci::DistanceCompressedVbo>::attributesReflection(void)::r;
              unk_1E957F298 = 1;
            }
            ggl::DaVinci::ElevatedFillColorWithDistancePipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::DaVinci::DistanceCompressedVbo>::typedReflection(void)::r;
            unk_1E957F0C0 = &ggl::DaVinci::pipelineDataElevatedFillColorWithDistancePipelineDeviceStructs(void)::ref;
            qword_1E957F0C8 = 0;
            {
              ggl::DaVinci::pipelineDataElevatedFillColorWithDistancePipelineConstantStructs(void)::ref = (uint64_t)ggl::Tile::View::reflection(void)::reflection;
              unk_1E957F130 = ggl::Tile::Transform::reflection(void)::reflection;
              qword_1E957F138 = (uint64_t)ggl::DaVinci::ElevatedFillStyle::reflection(void)::reflection;
              unk_1E957F140 = ggl::Tile::Clipping::reflection(void)::reflection;
            }
            qword_1E957F0D0 = (uint64_t)&ggl::DaVinci::pipelineDataElevatedFillColorWithDistancePipelineConstantStructs(void)::ref;
            unk_1E957F0D8 = xmmword_1A28FCFA0;
          }
        }
        ggl::DaVinci::ElevatedFillColorWithDistancePipelineState::typedReflection(void)::ref = (uint64_t)&ggl::DaVinci::ElevatedFillColorWithDistancePipelineSetup::typedReflection(void)::ref;
        ggl::ElevatedFillColorShader::typedReflection(v114);
        qword_1E9588B78 = (uint64_t)&ggl::ElevatedFillColorShader::typedReflection(void)::ref;
        {
          ggl::DaVinci::pipelineStateElevatedFillColorWithDistancePipelineAttributeStructBinding(void)::attr = 0;
          unk_1E9589CA0 = 0;
          qword_1E9589CA8 = (uint64_t)"";
          dword_1E9589CB0 = 0;
          qword_1E9589CB8 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorWithDistancePipelineAttributeBinding_0(void)::attr;
          unk_1E9589CC0 = 3;
        }
        qword_1E9588B80 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorWithDistancePipelineAttributeStructBinding(void)::attr;
        *(void *)algn_1E9588B88 = 1;
        qword_1E9588B90 = 0;
        unk_1E9588B98 = 0;
        qword_1E9588BA0 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorWithDistancePipelineDeviceStructBinding(void)::ref;
        unk_1E9588BA8 = 0;
        {
          ggl::DaVinci::pipelineStateElevatedFillColorWithDistancePipelineConstantStructBinding(void)::ref = 0;
          unk_1E9589BE0 = 0;
          qword_1E9589BE8 = (uint64_t)"view";
          dword_1E9589BF0 = 3;
          qword_1E9589BF8 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorWithDistancePipelineConstantViewBinding(void)::reflection;
          unk_1E9589C00 = xmmword_1A28FCEB0;
          qword_1E9589C10 = 1;
          unk_1E9589C18 = "transform";
          dword_1E9589C20 = 3;
          qword_1E9589C28 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorWithDistancePipelineConstantTransformBinding(void)::reflection;
          *(_OWORD *)algn_1E9589C30 = xmmword_1A28FCF70;
          qword_1E9589C40 = 2;
          unk_1E9589C48 = "style";
          dword_1E9589C50 = 3;
          qword_1E9589C58 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorWithDistancePipelineConstantStyleBinding(void)::reflection;
          unk_1E9589C60 = vdupq_n_s64(3uLL);
          qword_1E9589C70 = 3;
          unk_1E9589C78 = "tileClipping";
          dword_1E9589C80 = 3;
          qword_1E9589C88 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorWithDistancePipelineConstantTileClippingBinding(void)::reflection;
          unk_1E9589C90 = 2;
        }
        qword_1E9588BB0 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorWithDistancePipelineConstantStructBinding(void)::ref;
        unk_1E9588BB8 = 4;
      }
    }
    int32x4_t v32 = *(std::__shared_weak_count_vtbl **)a2;
    int8x16_t v33 = *(std::__shared_weak_count **)(a2 + 8);
    if (v33) {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(_OWORD *)int16x8_t v117 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)&v117[12] = *(_OWORD *)(a2 + 60);
    long long v34 = *(_OWORD *)(a2 + 76);
    char v35 = *(unsigned char *)(a2 + 92);
    v30[1].__shared_weak_owners_ = 0;
    v30[2].__vftable = 0;
    LODWORD(v30[2].__shared_owners_) = 0;
    v30[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55B208;
    v30[1].__shared_owners_ = 0;
    v30[2].__shared_weak_owners_ = (uint64_t)&ggl::DaVinci::ElevatedFillColorWithDistancePipelineState::typedReflection(void)::ref;
    v30[3].__vftable = v32;
    v30[3].__shared_owners_ = (uint64_t)v33;
    if (v33) {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    LOBYTE(v30[5].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v30[5].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v30[6].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v30[7].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v30[6].__shared_weak_owners_ + 4) = 0;
    LOBYTE(v30[7].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v30[7].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v30[8].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v30[9].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v30[8].__shared_weak_owners_ + 4) = 0;
    LOBYTE(v30[9].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v30[9].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v30[10].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v30[11].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v30[10].__shared_weak_owners_ + 4) = 0;
    *(_OWORD *)&v30[11].__shared_weak_owners_ = v115;
    *(_OWORD *)&v30[12].__shared_owners_ = v116;
    LOBYTE(v30[13].__vftable) = 0;
    v30[16].__vftable = 0;
    *(_OWORD *)&v30[14].__shared_weak_owners_ = 0u;
    *(_OWORD *)&v30[15].__shared_owners_ = 0u;
    *(_OWORD *)&v30[13].__shared_owners_ = 0u;
    v30[14].std::__shared_count = 0u;
    v30[16].__shared_owners_ = 0x100000001;
    LOBYTE(v30[16].__shared_weak_owners_) = 0;
    *(std::__shared_count *)((char *)&v30[4].std::__shared_count + 4) = *(std::__shared_count *)&v117[12];
    *(_OWORD *)&v30[3].__shared_weak_owners_ = *(_OWORD *)v117;
    *(_OWORD *)((char *)&v30[4].__shared_weak_owners_ + 4) = v34;
    BYTE4(v30[5].__shared_owners_) = v35;
    if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
    *(std::__shared_weak_count_vtbl **)((char *)&v30[14].__vftable + 1) = 0;
    BYTE1(v30[14].__shared_owners_) = 0;
    *(uint64_t *)((char *)&v30[13].__shared_weak_owners_ + 1) = 0;
    WORD1(v30[14].__shared_owners_) = 257;
    HIDWORD(v30[14].__shared_owners_) = 0;
    v30[14].__shared_weak_owners_ = 16842752;
    int8x16_t v36 = *(int8x16_t *)&v30[14].__shared_owners_;
    int8x16_t v37 = vceqzq_s8(*(int8x16_t *)&v30[13].__shared_weak_owners_);
    int16x8_t v38 = vmovl_high_s8(v37);
    int32x4_t v39 = vmovl_s16(*(int16x4_t *)v38.i8);
    v40.i64[0] = v39.u32[0];
    v40.i64[1] = v39.u32[1];
    int8x16_t v41 = v40;
    int16x8_t v42 = vmovl_s8(*(int8x8_t *)v37.i8);
    int32x4_t v43 = vmovl_s16(*(int16x4_t *)v42.i8);
    v40.i64[0] = v43.u32[0];
    v40.i64[1] = v43.u32[1];
    int8x16_t v44 = v40;
    int32x4_t v45 = vmovl_high_s16(v38);
    v40.i64[0] = v45.u32[0];
    v40.i64[1] = v45.u32[1];
    int8x16_t v46 = v40;
    int32x4_t v47 = vmovl_high_s16(v42);
    v40.i64[0] = v47.u32[0];
    v40.i64[1] = v47.u32[1];
    int8x16_t v48 = v40;
    v40.i64[0] = v39.u32[2];
    v40.i64[1] = v39.u32[3];
    int8x16_t v49 = v40;
    v40.i64[0] = v43.u32[2];
    v40.i64[1] = v43.u32[3];
    int8x16_t v50 = v40;
    v40.i64[0] = v45.u32[2];
    v40.i64[1] = v45.u32[3];
    int8x16_t v51 = v40;
    v40.i64[0] = v47.u32[2];
    v40.i64[1] = v47.u32[3];
    int8x16_t v52 = vbicq_s8((int8x16_t)xmmword_1A28FC980, v40);
    v30[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF561418;
    LOBYTE(v30[15].__vftable) = a3;
    int8x16_t v53 = vbicq_s8((int8x16_t)xmmword_1A28FC990, v51);
    int8x16_t v54 = vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v50);
    HIDWORD(v30[15].__vftable) = 0;
    int8x16_t v55 = vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v46);
    *(_DWORD *)((char *)&v30[15].__vftable + 1) = 0;
    int8x16_t v56 = vceqzq_s8(v36);
    int16x8_t v57 = vmovl_high_s8(v56);
    int32x4_t v58 = vmovl_s16(*(int16x4_t *)v57.i8);
    v40.i64[0] = v58.u32[0];
    v40.i64[1] = v58.u32[1];
    int8x16_t v59 = v40;
    int16x8_t v60 = vmovl_s8(*(int8x8_t *)v56.i8);
    int32x4_t v61 = vmovl_s16(*(int16x4_t *)v60.i8);
    v40.i64[0] = v61.u32[0];
    v40.i64[1] = v61.u32[1];
    int8x16_t v62 = v40;
    int32x4_t v63 = vmovl_high_s16(v57);
    v40.i64[0] = v63.u32[0];
    v40.i64[1] = v63.u32[1];
    int8x16_t v64 = v40;
    int32x4_t v65 = vmovl_high_s16(v60);
    v40.i64[0] = v65.u32[0];
    v40.i64[1] = v65.u32[1];
    int8x16_t v66 = v40;
    v40.i64[0] = v58.u32[2];
    v40.i64[1] = v58.u32[3];
    int8x16_t v67 = v40;
    v40.i64[0] = v61.u32[2];
    v40.i64[1] = v61.u32[3];
    int8x16_t v68 = v40;
    v40.i64[0] = v63.u32[2];
    v40.i64[1] = v63.u32[3];
    int8x16_t v69 = v40;
    v40.i64[0] = v65.u32[2];
    v40.i64[1] = v65.u32[3];
    int8x16_t v70 = vbicq_s8((int8x16_t)xmmword_1A28FCA00, v69);
    int8x16_t v71 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA60, v59), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v41));
    int8x16_t v72 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v62), vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v44));
    int8x16_t v73 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA40, v64), v55);
    int8x16_t v74 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v66), vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v48));
    int8x16_t v75 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA20, v67), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v49));
    int8x16_t v76 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v68), v54);
    int8x16_t v77 = vorrq_s8(v70, v53);
    int8x16_t v78 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v40), v52);
    int8x16_t v79 = vceqzq_s8((int8x16_t)v30[15].std::__shared_count);
    int16x8_t v80 = vmovl_s8(*(int8x8_t *)v79.i8);
    int32x4_t v81 = vmovl_high_s16(v80);
    v40.i64[0] = v81.i32[2];
    v40.i64[1] = v81.i32[3];
    int8x16_t v82 = v40;
    int16x8_t v83 = vmovl_high_s8(v79);
    int32x4_t v84 = vmovl_high_s16(v83);
    v40.i64[0] = v84.i32[2];
    v40.i64[1] = v84.i32[3];
    int8x16_t v85 = v40;
    int32x4_t v86 = vmovl_s16(*(int16x4_t *)v80.i8);
    v40.i64[0] = v86.i32[2];
    v40.i64[1] = v86.i32[3];
    int8x16_t v87 = v40;
    int32x4_t v88 = vmovl_s16(*(int16x4_t *)v83.i8);
    v40.i64[0] = v88.i32[2];
    v40.i64[1] = v88.i32[3];
    int8x16_t v89 = v40;
    v40.i64[0] = v81.i32[0];
    v40.i64[1] = v81.i32[1];
    int8x16_t v90 = v40;
    v40.i64[0] = v84.i32[0];
    v40.i64[1] = v84.i32[1];
    int8x16_t v91 = v40;
    v40.i64[0] = v86.i32[0];
    v40.i64[1] = v86.i32[1];
    int8x16_t v92 = v40;
    v40.i64[0] = v88.i32[0];
    v40.i64[1] = v88.i32[1];
    int8x16_t v93 = vbicq_s8((int8x16_t)xmmword_1A28FCA70, v40);
    int8x16_t v94 = vceqzq_s8(*(int8x16_t *)&v30[15].__shared_weak_owners_);
    int16x8_t v95 = vmovl_high_s8(v94);
    int32x4_t v96 = vmovl_s16(*(int16x4_t *)v95.i8);
    v40.i64[0] = v96.i32[0];
    v40.i64[1] = v96.i32[1];
    int8x16_t v97 = v40;
    int16x8_t v98 = vmovl_s8(*(int8x8_t *)v94.i8);
    int32x4_t v99 = vmovl_s16(*(int16x4_t *)v98.i8);
    v40.i64[0] = v99.i32[0];
    v40.i64[1] = v99.i32[1];
    int8x16_t v100 = v40;
    int32x4_t v101 = vmovl_high_s16(v95);
    v40.i64[0] = v101.i32[0];
    v40.i64[1] = v101.i32[1];
    int8x16_t v102 = v40;
    int32x4_t v103 = vmovl_high_s16(v98);
    v40.i64[0] = v103.i32[0];
    v40.i64[1] = v103.i32[1];
    int8x16_t v104 = v40;
    v40.i64[0] = v96.i32[2];
    v40.i64[1] = v96.i32[3];
    int8x16_t v105 = v40;
    v40.i64[0] = v99.i32[2];
    v40.i64[1] = v99.i32[3];
    int8x16_t v106 = v40;
    v40.i64[0] = v101.i32[2];
    v40.i64[1] = v101.i32[3];
    int8x16_t v107 = v40;
    v40.i64[0] = v103.i32[2];
    v40.i64[1] = v103.i32[3];
    v30[13].__shared_owners_ = vaddvq_s64(vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB50, v100), vbicq_s8((int8x16_t)xmmword_1A28FCA80, v92)), v72), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB60, v97), v93), v71)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB30, v104), vbicq_s8((int8x16_t)xmmword_1A28FCAA0, v90)), v74), vorrq_s8(vorrq_s8(
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCB40, v102),
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCA90, v91)),
                                                    v73))),
                                   (int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB10, v106), vbicq_s8((int8x16_t)xmmword_1A28FCAC0, v87)), v76), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB20, v105), vbicq_s8((int8x16_t)xmmword_1A28FCAB0, v89)), v75)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAF0, v40), vbicq_s8((int8x16_t)xmmword_1A28FCAE0, v82)), v78), vorrq_s8(vorrq_s8(
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCB00, v107),
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCAD0, v85)),
                                                    v77)))));
    LOBYTE(v30[13].__vftable) = 1;
    *a1 = v31;
    a1[1] = v30;
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
    int8x16_t v108 = *v25;
    int8x16_t v109 = v25;
    if (*v25)
    {
      while (1)
      {
        while (1)
        {
          int8x16_t v109 = (uint64_t **)v108;
          unint64_t v110 = v108[4];
          if (v23 >= v110) {
            break;
          }
          int8x16_t v108 = *v109;
          int8x16_t v25 = v109;
          if (!*v109) {
            goto LABEL_27;
          }
        }
        if (v110 >= v23) {
          break;
        }
        int8x16_t v108 = v109[1];
        if (!v108)
        {
          int8x16_t v25 = v109 + 1;
          goto LABEL_27;
        }
      }
      if (!atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    else
    {
LABEL_27:
      int8x16_t v111 = (uint64_t *)operator new(0x38uLL);
      v111[4] = v23;
      v111[5] = (uint64_t)v31;
      v111[6] = (uint64_t)v30;
      *int8x16_t v111 = 0;
      v111[1] = 0;
      v111[2] = (uint64_t)v109;
      *int8x16_t v25 = v111;
      uint64_t v112 = **(void **)(a2 + 96);
      if (v112)
      {
        *(void *)(a2 + 96) = v112;
        int8x16_t v111 = *v25;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a2 + 104), v111);
      ++*(void *)(a2 + 112);
    }
  }
}

void sub_1A1B7AC74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  md::components::Material::~Material((md::components::Material *)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v17);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::ElevatedPolygonRenderResources::ElevatedPolygonRenderResources(ggl::StandardLibrary const&,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::ElevatedPolygonRenderResources::ElevatedPolygonRenderResources(ggl::StandardLibrary const&,ggl::RenderTargetFormat const&)::$_1>,ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup * ()(void)>::operator()()
{
}

void sub_1A1B7B12C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::CartographicTiledRenderLayer<md::MapTileDataRenderable<md::TrafficTileData>>::clearScene(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 52) == 1)
  {
    long long v10 = *(_OWORD *)(a1 + 272);
    (*(void (**)(uint64_t, long long *))(*(void *)a1 + 120))(a1, &v10);
  }
  if (*(void *)(a1 + 112))
  {
    uint64_t v2 = *(unsigned char **)(a1 + 104);
    if (v2)
    {
      do
      {
        if (v2[112]) {
          v2[112] = 0;
        }
        int16x8_t v8 = *(unsigned char **)v2;
        int32x4_t v9 = (void *)*((void *)v2 + 4);
        if (v9 != *((void **)v2 + 6)) {
          free(v9);
        }
        operator delete(v2);
        uint64_t v2 = v8;
      }
      while (v8);
    }
    *(void *)(a1 + 104) = 0;
    uint64_t v3 = *(void *)(a1 + 96);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*(void *)(a1 + 88) + 8 * i) = 0;
    }
    *(void *)(a1 + 112) = 0;
  }
  *(void *)(a1 + 280) = *(void *)(a1 + 272);
  geo::Pool<md::MapTileDataRenderable<md::TrafficTileData>>::disposeElements(a1 + 224);
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 136));
  *(void *)(a1 + 128) = a1 + 136;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 136) = 0;
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 160));
  *(void *)(a1 + 152) = a1 + 160;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 160) = 0;
  unint64_t v5 = (void *)(a1 + 184);
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 184));
  int8x16_t v7 = *(void **)(a1 + 208);
  int8x16_t v6 = (void *)(a1 + 208);
  *(v6 - 4) = v5;
  *unint64_t v5 = 0;
  *(v6 - 2) = 0;
  std::__tree<gdc::LayerDataWithWorld>::destroy(v7);
  *(v6 - 1) = v6;
  void *v6 = 0;
  v6[1] = 0;
}

void geo::Pool<md::MapTileDataRenderable<md::TrafficTileData>>::disposeElements(uint64_t a1)
{
  int32x4_t v29 = 0;
  uint64_t v30 = 0;
  BOOL v28 = &v29;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = &v29;
      unint64_t v5 = &v29;
      if (v29)
      {
        int8x16_t v6 = v29;
        while (1)
        {
          while (1)
          {
            unint64_t v5 = (uint64_t **)v6;
            unint64_t v7 = v6[4];
            if ((unint64_t)v2 >= v7) {
              break;
            }
            int8x16_t v6 = *v5;
            uint64_t v4 = v5;
            if (!*v5) {
              goto LABEL_12;
            }
          }
          if (v7 >= (unint64_t)v2) {
            break;
          }
          int8x16_t v6 = v5[1];
          if (!v6)
          {
            uint64_t v4 = v5 + 1;
            goto LABEL_12;
          }
        }
      }
      else
      {
LABEL_12:
        int16x8_t v8 = (uint64_t *)operator new(0x28uLL);
        v8[4] = (uint64_t)v2;
        *int16x8_t v8 = 0;
        v8[1] = 0;
        v8[2] = (uint64_t)v5;
        uint64_t *v4 = v8;
        if (*v28)
        {
          BOOL v28 = (uint64_t **)*v28;
          int16x8_t v8 = *v4;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v29, v8);
        uint64_t v3 = ++v30;
        uint64_t v2 = *(void **)(a1 + 40);
      }
      uint64_t v2 = (void *)*v2;
      *(void *)(a1 + 40) = v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  unint64_t v9 = *(void *)(a1 + 24);
  long long v10 = *(void **)a1;
  int8x16_t v11 = (void *)(a1 + 8);
  BOOL v12 = v3 == *(void *)(a1 + 16) * v9 || v10 == v11;
  if (v12 || v9 == 0)
  {
    if (v10 == v11) {
      goto LABEL_47;
    }
    goto LABEL_49;
  }
  uint64_t v14 = 1;
  do
  {
    if (v14)
    {
      unint64_t v15 = 0;
      uint64_t v16 = v10[4];
      do
      {
        uint64_t v17 = (void (***)(void))(v16 + 400 * v15);
        int8x16_t v18 = v29;
        if (!v29) {
          goto LABEL_28;
        }
        int8x16_t v19 = &v29;
        do
        {
          int8x16_t v20 = v18;
          int8x16_t v21 = v19;
          unint64_t v22 = v18[4];
          unint64_t v23 = (uint64_t **)(v18 + 1);
          if (v22 >= (unint64_t)v17)
          {
            unint64_t v23 = (uint64_t **)v20;
            int8x16_t v19 = (uint64_t **)v20;
          }
          int8x16_t v18 = *v23;
        }
        while (v18);
        if (v19 == &v29) {
          goto LABEL_28;
        }
        if (v22 < (unint64_t)v17) {
          int8x16_t v20 = (uint64_t *)v21;
        }
        if ((unint64_t)v17 < v20[4])
        {
LABEL_28:
          (**v17)(v17);
          unint64_t v9 = *(void *)(a1 + 24);
        }
        ++v15;
        uint64_t v14 = v9;
      }
      while (v15 < v9);
    }
    int8x16_t v24 = (void *)v10[1];
    if (v24)
    {
      do
      {
        int8x16_t v25 = v24;
        int8x16_t v24 = (void *)*v24;
      }
      while (v24);
    }
    else
    {
      do
      {
        int8x16_t v25 = (void *)v10[2];
        BOOL v12 = *v25 == (void)v10;
        long long v10 = v25;
      }
      while (!v12);
    }
    long long v10 = v25;
  }
  while (v25 != v11);
  long long v10 = *(void **)a1;
  if (*(void **)a1 != v11)
  {
    do
    {
LABEL_49:
      free((void *)v10[4]);
      int8x16_t v26 = (void *)v10[1];
      if (v26)
      {
        do
        {
          unint64_t v27 = v26;
          int8x16_t v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          unint64_t v27 = (void *)v10[2];
          BOOL v12 = *v27 == (void)v10;
          long long v10 = v27;
        }
        while (!v12);
      }
      long long v10 = v27;
    }
    while (v27 != v11);
  }
LABEL_47:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v11;
  *(void *)(a1 + 40) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v29);
}

void sub_1A1B7B594(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v1);
  _Unwind_Resume(a1);
}

void md::CartographicTiledRenderLayer<md::FlyoverRenderable>::clearScene(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 52) == 1)
  {
    long long v10 = *(_OWORD *)(a1 + 272);
    (*(void (**)(uint64_t, long long *))(*(void *)a1 + 120))(a1, &v10);
  }
  if (*(void *)(a1 + 112))
  {
    uint64_t v2 = *(unsigned char **)(a1 + 104);
    if (v2)
    {
      do
      {
        if (v2[112]) {
          v2[112] = 0;
        }
        int16x8_t v8 = *(unsigned char **)v2;
        unint64_t v9 = (void *)*((void *)v2 + 4);
        if (v9 != *((void **)v2 + 6)) {
          free(v9);
        }
        operator delete(v2);
        uint64_t v2 = v8;
      }
      while (v8);
    }
    *(void *)(a1 + 104) = 0;
    uint64_t v3 = *(void *)(a1 + 96);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*(void *)(a1 + 88) + 8 * i) = 0;
    }
    *(void *)(a1 + 112) = 0;
  }
  *(void *)(a1 + 280) = *(void *)(a1 + 272);
  geo::Pool<md::FlyoverRenderable>::disposeElements(a1 + 224);
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 136));
  *(void *)(a1 + 128) = a1 + 136;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 136) = 0;
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 160));
  *(void *)(a1 + 152) = a1 + 160;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 160) = 0;
  unint64_t v5 = (void *)(a1 + 184);
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 184));
  unint64_t v7 = *(void **)(a1 + 208);
  int8x16_t v6 = (void *)(a1 + 208);
  *(v6 - 4) = v5;
  *unint64_t v5 = 0;
  *(v6 - 2) = 0;
  std::__tree<gdc::LayerDataWithWorld>::destroy(v7);
  *(v6 - 1) = v6;
  void *v6 = 0;
  v6[1] = 0;
}

void geo::Pool<md::FlyoverRenderable>::disposeElements(uint64_t a1)
{
  int32x4_t v29 = 0;
  uint64_t v30 = 0;
  BOOL v28 = &v29;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = &v29;
      unint64_t v5 = &v29;
      if (v29)
      {
        int8x16_t v6 = v29;
        while (1)
        {
          while (1)
          {
            unint64_t v5 = (uint64_t **)v6;
            unint64_t v7 = v6[4];
            if ((unint64_t)v2 >= v7) {
              break;
            }
            int8x16_t v6 = *v5;
            uint64_t v4 = v5;
            if (!*v5) {
              goto LABEL_12;
            }
          }
          if (v7 >= (unint64_t)v2) {
            break;
          }
          int8x16_t v6 = v5[1];
          if (!v6)
          {
            uint64_t v4 = v5 + 1;
            goto LABEL_12;
          }
        }
      }
      else
      {
LABEL_12:
        int16x8_t v8 = (uint64_t *)operator new(0x28uLL);
        v8[4] = (uint64_t)v2;
        *int16x8_t v8 = 0;
        v8[1] = 0;
        v8[2] = (uint64_t)v5;
        uint64_t *v4 = v8;
        if (*v28)
        {
          BOOL v28 = (uint64_t **)*v28;
          int16x8_t v8 = *v4;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v29, v8);
        uint64_t v3 = ++v30;
        uint64_t v2 = *(void **)(a1 + 40);
      }
      uint64_t v2 = (void *)*v2;
      *(void *)(a1 + 40) = v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  unint64_t v9 = *(void *)(a1 + 24);
  long long v10 = *(void **)a1;
  int8x16_t v11 = (void *)(a1 + 8);
  BOOL v12 = v3 == *(void *)(a1 + 16) * v9 || v10 == v11;
  if (v12 || v9 == 0)
  {
    if (v10 == v11) {
      goto LABEL_47;
    }
    goto LABEL_49;
  }
  uint64_t v14 = 1;
  do
  {
    if (v14)
    {
      unint64_t v15 = 0;
      uint64_t v16 = v10[4];
      do
      {
        uint64_t v17 = (void (***)(void))(v16 + 400 * v15);
        int8x16_t v18 = v29;
        if (!v29) {
          goto LABEL_28;
        }
        int8x16_t v19 = &v29;
        do
        {
          int8x16_t v20 = v18;
          int8x16_t v21 = v19;
          unint64_t v22 = v18[4];
          unint64_t v23 = (uint64_t **)(v18 + 1);
          if (v22 >= (unint64_t)v17)
          {
            unint64_t v23 = (uint64_t **)v20;
            int8x16_t v19 = (uint64_t **)v20;
          }
          int8x16_t v18 = *v23;
        }
        while (v18);
        if (v19 == &v29) {
          goto LABEL_28;
        }
        if (v22 < (unint64_t)v17) {
          int8x16_t v20 = (uint64_t *)v21;
        }
        if ((unint64_t)v17 < v20[4])
        {
LABEL_28:
          (**v17)(v17);
          unint64_t v9 = *(void *)(a1 + 24);
        }
        ++v15;
        uint64_t v14 = v9;
      }
      while (v15 < v9);
    }
    int8x16_t v24 = (void *)v10[1];
    if (v24)
    {
      do
      {
        int8x16_t v25 = v24;
        int8x16_t v24 = (void *)*v24;
      }
      while (v24);
    }
    else
    {
      do
      {
        int8x16_t v25 = (void *)v10[2];
        BOOL v12 = *v25 == (void)v10;
        long long v10 = v25;
      }
      while (!v12);
    }
    long long v10 = v25;
  }
  while (v25 != v11);
  long long v10 = *(void **)a1;
  if (*(void **)a1 != v11)
  {
    do
    {
LABEL_49:
      free((void *)v10[4]);
      int8x16_t v26 = (void *)v10[1];
      if (v26)
      {
        do
        {
          unint64_t v27 = v26;
          int8x16_t v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          unint64_t v27 = (void *)v10[2];
          BOOL v12 = *v27 == (void)v10;
          long long v10 = v27;
        }
        while (!v12);
      }
      long long v10 = v27;
    }
    while (v27 != v11);
  }
LABEL_47:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v11;
  *(void *)(a1 + 40) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v29);
}

void sub_1A1B7B970(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v1);
  _Unwind_Resume(a1);
}

uint64_t md::Logic<md::PuckLogic,md::PuckContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext,md::NavigationContext,md::StyleLogicContext,md::SharedResourcesContext,md::RegistryContext,md::IdentifiedResourceContext,md::SceneContext,md::NonTiledAssetContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x9AEE7E062376E454)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext,md::NavigationContext,md::StyleLogicContext,md::SharedResourcesContext,md::RegistryContext,md::IdentifiedResourceContext,md::SceneContext,md::NonTiledAssetContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::ElevationContext,md::NavigationContext,md::StyleLogicContext,md::SharedResourcesContext,md::RegistryContext,md::IdentifiedResourceContext,md::SceneContext,md::NonTiledAssetContext>(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 144))(v5, a2, v6, v3);
    }
  }
  return result;
}

void md::PuckLogic::runBeforeLayout(uint64_t a1, uint64_t a2, void *a3, unsigned __int8 *i)
{
  uint64_t v775 = *MEMORY[0x1E4F143B8];
  v764[0] = &unk_1EF579EC0;
  v764[1] = a2;
  int64_t v765 = v764;
  v762[0] = &unk_1EF579F08;
  v762[1] = a2;
  v763 = v762;
  v767 = v766;
  v766[0] = &unk_1EF579F08;
  v766[1] = a2;
  _ZNSt3__110__function6__funcIZN2md9PuckLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17NavigationContextENS2_17StyleLogicContextENS2_22SharedResourcesContextENS2_15RegistryContextENS2_25IdentifiedResourceContextENS2_12SceneContextENS2_20NonTiledAssetContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_11PuckContextEE3__0NS_9allocatorISR_EEFvvEEclEv((uint64_t)v764);
  if (v763 == v762)
  {
    (*(void (**)(void *))(v762[0] + 32))(v762);
  }
  else if (v763)
  {
    (*(void (**)(void))(*v763 + 40))();
  }
  if (v765 == v764)
  {
    (*(void (**)(void *))(v764[0] + 32))(v764);
  }
  else if (v765)
  {
    (*(void (**)(void))(*v765 + 40))();
  }
  unint64_t v7 = (float *)a3[1];
  uint64_t v712 = *a3;
  uint64_t v8 = a3[2];
  uint64_t v722 = (uint64_t *)a3[3];
  unint64_t v700 = (id *)a3[4];
  unint64_t v9 = (uint64_t *)a3[7];
  uint64_t v686 = (int8x8_t *)a3[6];
  long long v10 = (void *)a3[8];
  id v11 = *(id *)(v8 + 48);
  uint64_t v12 = [v11 puck];

  if (!*(void *)(a1 + 440))
  {
    double v13 = *(double *)(v8 + 160);
    long long v14 = *(_OWORD *)(v8 + 144);
    double v15 = *(double *)(a1 + 456);
    double v16 = *(double *)(a1 + 464);
    double v17 = *(double *)(a1 + 472);
    double v18 = vabdd_f64(v15, *(double *)&v14);
    long long v729 = v14;
    BOOL v19 = v18 <= fabs(*(double *)&v14 + v15) * 2.22044605e-14 || v18 <= 2.22507386e-308;
    if (!v19
      || ((double v20 = vabdd_f64(v16, *((double *)&v14 + 1)), v20 > fabs(*((double *)&v729 + 1) + v16) * 2.22044605e-14)
        ? (BOOL v21 = v20 <= 2.22507386e-308)
        : (BOOL v21 = 1),
          !v21
       || ((double v22 = vabdd_f64(v17, v13), v22 > fabs(v13 + v17) * 2.22044605e-14)
         ? (BOOL v23 = v22 <= 2.22507386e-308)
         : (BOOL v23 = 1),
           !v23)))
    {
      [0 stop];
      int8x16_t v24 = *(void **)(a1 + 440);
      *(void *)(a1 + 440) = 0;

      int8x16_t v25 = [[VKTimedAnimation alloc] initWithDuration:1.5];
      int8x16_t v26 = *(void **)(a1 + 440);
      *(void *)(a1 + 440) = v25;

      [*(id *)(a1 + 440) setTimingFunction:VKAnimationCurveEaseInOut];
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&buf[16] = ___ZN2md9PuckLogic13animatePuckUpERKN3geo9Mercator3IdEE_block_invoke;
      *(void *)&long long v769 = &__block_descriptor_88_e8_v12__0f8l;
      *((void *)&v769 + 1) = a1;
      *(double *)&long long v770 = v15;
      *((double *)&v770 + 1) = v16;
      *(double *)uint64_t v771 = v17;
      *(_OWORD *)&v771[1] = v729;
      double v772 = v13;
      [*(id *)(a1 + 440) setStepHandler:buf];
      *(void *)uint64_t v749 = MEMORY[0x1E4F143A8];
      *(void *)&v749[8] = 3221225472;
      *(void *)&v749[16] = ___ZN2md9PuckLogic13animatePuckUpERKN3geo9Mercator3IdEE_block_invoke_2;
      *(void *)&long long v750 = &__block_descriptor_40_e8_v12__0B8l;
      *((void *)&v750 + 1) = a1;
      [*(id *)(a1 + 440) setCompletionHandler:v749];
      md::AnimationRunner::runAnimation(*(md::MapEngine ***)(a1 + 448), *(VKAnimation **)(a1 + 440));
    }
  }
  int v27 = *(unsigned __int8 *)v7;
  void *i = v27;
  double v28 = *(double *)(a1 + 456);
  double v697 = *(double *)(a1 + 472);
  double v698 = *(double *)(a1 + 464);
  uint64_t v715 = v8;
  double v29 = *(double *)(v8 + 64);
  double v695 = cos(v29 + v29);
  double v694 = cos(v29 * 4.0);
  double v693 = cos(v29 * 6.0);
  double v30 = v29 * 0.5;
  long double v31 = tan(v29 * 0.5 + 0.78103484);
  double v692 = log(v31);
  long double v32 = tan(v29 * 0.5 + 0.789761487);
  double v691 = log(v32);
  __asm { FMOV            V1.2D, #0.5 }
  unsigned int v696 = *(unsigned __int8 *)(v712 + 3776) - 4;
  float64x2_t v730 = _Q1;
  if (v696 >= 0xFFFFFFFD)
  {
    long double v39 = *(double *)(v712 + 496);
    long double v40 = *(double *)(v712 + 504);
    long double v41 = *(double *)(v712 + 512);
    double v42 = sqrt(v39 * v39 + v40 * v40);
    double v43 = atan2(v41, v42 * 0.996647189);
    long double v725 = atan2(v40, v39);
    __double2 v44 = __sincos_stret(v43);
    double v45 = atan2(v41 + v44.__sinval * v44.__sinval * 42841.3115 * v44.__sinval, v42 + v44.__cosval * v44.__cosval * -42697.6727 * v44.__cosval);
    __double2 v46 = __sincos_stret(v45);
    long double v47 = tan(v45 * 0.5 + 0.785398163);
    long double v48 = log(v47);
    v49.f64[0] = v725;
    v49.f64[1] = v48;
    float64x2_t v37 = vmlaq_f64(v730, (float64x2_t)vdupq_n_s64(0x3FC45F306DC9C883uLL), v49);
    double v38 = (v42 / v46.__cosval + -6378137.0 / sqrt(v46.__sinval * v46.__sinval * -0.00669437999 + 1.0))
        * 0.0000000249532021;
  }
  else
  {
    float64x2_t v37 = *(float64x2_t *)(v712 + 496);
    double v38 = *(double *)(v712 + 512);
  }
  float64x2_t v726 = v37;
  *(float64x2_t *)v760 = v37;
  *(double *)&v760[16] = v38;
  long long v711 = *(_OWORD *)(v8 + 72);
  long double v50 = tan(v30 + 0.785398163);
  long double v51 = log(v50);
  _V6.D[1] = *((void *)&v711 + 1);
  *(void *)&v53.f64[0] = v711;
  v53.f64[1] = v51;
  *(float64x2_t *)int v761 = vmlaq_f64(v730, (float64x2_t)vdupq_n_s64(0x3FC45F306DC9C883uLL), v53);
  double v710 = *(double *)&v761[8];
  long long v731 = *(_OWORD *)v761;
  double v699 = v28;
  if (v27)
  {
    _D3 = (float)(v7[4] * v7[5]);
    __asm { FMLA            D2, D3, V6.D[1] }
    double v690 = (*((double *)&v711 + 1) + *(float *)(v8 + 88)) * 0.0000000249532021;
    double v56 = _D2 * 0.0000000249532021;
  }
  else
  {
    double v56 = 0.0;
    double v690 = 0.0;
  }
  double v703 = v56;
  *(double *)&v761[16] = v56;
  long double v57 = exp(v726.f64[1] * 6.28318531 + -3.14159265);
  double v58 = atan(v57) * 2.0 + -1.57079633;
  long double v59 = fmod(v726.f64[0] * 6.28318531, 6.28318531);
  double v727 = fmod(v59 + 6.28318531, 6.28318531) + -3.14159265;
  __double2 v60 = __sincos_stret(v58);
  double v61 = 6378137.0 / sqrt(1.0 - v60.__sinval * v60.__sinval * 0.00669437999);
  double v62 = v38 * 40075017.0;
  double v63 = (v61 + v62) * v60.__cosval;
  __double2 v64 = __sincos_stret(v727);
  double v708 = v63 * v64.__cosval;
  double v709 = v63 * v64.__sinval;
  double v707 = (v62 + v61 * 0.99330562) * v60.__sinval;
  long double v65 = exp(v710 * 6.28318531 + -3.14159265);
  double v66 = atan(v65) * 2.0 + -1.57079633;
  long double v67 = fmod(*(double *)&v731 * 6.28318531, 6.28318531);
  double v68 = fmod(v67 + 6.28318531, 6.28318531) + -3.14159265;
  __double2 v69 = __sincos_stret(v66);
  double v70 = 6378137.0 / sqrt(1.0 - v69.__sinval * v69.__sinval * 0.00669437999);
  double v71 = (v70 + v703 * 40075017.0) * v69.__cosval;
  __double2 v72 = __sincos_stret(v68);
  *(double *)int v759 = v71 * v72.__cosval;
  *(double *)&v759[8] = v71 * v72.__sinval;
  *(double *)&v759[16] = (v703 * 40075017.0 + v70 * 0.99330562) * v69.__sinval;
  double v73 = ((v708 - v71 * v72.__cosval) * (v71 * v72.__cosval)
       + (v709 - v71 * v72.__sinval) * (v71 * v72.__sinval)
       + (v707 - *(double *)&v759[16]) * *(double *)&v759[16])
      / sqrt(((v708 - v71 * v72.__cosval) * (v708 - v71 * v72.__cosval)+ (v709 - v71 * v72.__sinval) * (v709 - v71 * v72.__sinval)+ (v707 - *(double *)&v759[16]) * (v707 - *(double *)&v759[16]))* (*(double *)v759 * *(double *)v759+ *(double *)&v759[8] * *(double *)&v759[8]+ *(double *)&v759[16] * *(double *)&v759[16]))+ 0.08;
  *(unsigned char *)(a1 + 388) = v73 >= 0.0;
  if (v12) {
    int v75 = v73 >= 0.0 && *(unsigned char *)(v12 + 48) != 0;
  }
  else {
    int v75 = 0;
  }
  i[208] = v75;
  if (*(unsigned __int8 *)(a1 + 486) != v75)
  {
    if (GEOGetVectorKitPuckLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitPuckLogicLog(void)::onceToken, &__block_literal_global_5070);
    }
    int8x16_t v76 = (id)GEOGetVectorKitPuckLogicLog(void)::log;
    if (os_log_type_enabled(v76, OS_LOG_TYPE_INFO))
    {
      int v77 = *(unsigned __int8 *)(a1 + 486);
      int v78 = i[208];
      int v79 = *(unsigned __int8 *)(v12 + 48);
      *(_DWORD *)buf = 67110144;
      *(_DWORD *)&buf[4] = v77;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v78;
      *(_WORD *)&buf[14] = 2048;
      *(void *)&buf[16] = v12;
      LOWORD(v769) = 1024;
      *(_DWORD *)((char *)&v769 + 2) = v79;
      WORD3(v769) = 1024;
      DWORD2(v769) = v73 >= 0.0;
      _os_log_impl(&dword_1A1780000, v76, OS_LOG_TYPE_INFO, "State _puckFallbackState.shouldRenderPuck changed from %d to %d; puck: %p, enabled: %d, normalFacingCamera: %d",
        buf,
        0x24u);
    }

    int v75 = i[208];
    *(unsigned char *)(a1 + 486) = v75;
  }
  if (!v75)
  {
    md::PuckLogic::update3DPuckVisibility((md::PuckLogic *)a1, 0);
    goto LABEL_467;
  }
  buf[23] = 4;
  strcpy(buf, "puck");
  int16x8_t v80 = std::__hash_table<std::__hash_value_type<std::string,unsigned long long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long long>>>::find<std::string>(v10, (uint64_t)buf);
  if (v80)
  {
    *(void *)(a1 + 488) = v80[5];
    *(unsigned char *)(a1 + 496) = 1;
  }
  buf[23] = 11;
  strcpy(buf, "regularPuck");
  int32x4_t v81 = std::__hash_table<std::__hash_value_type<std::string,unsigned long long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long long>>>::find<std::string>(v10 + 5, (uint64_t)buf);
  if (v81)
  {
    *(void *)(a1 + 504) = v81[5];
    *(unsigned char *)(a1 + 512) = 1;
  }
  buf[23] = 12;
  strcpy(buf, "occludedPuck");
  int8x16_t v82 = std::__hash_table<std::__hash_value_type<std::string,unsigned long long>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,unsigned long long>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,unsigned long long>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,unsigned long long>>>::find<std::string>(v10 + 5, (uint64_t)buf);
  if (v82)
  {
    *(void *)(a1 + 520) = v82[5];
    *(unsigned char *)(a1 + 528) = 1;
  }
  int v83 = *(unsigned char *)(a1 + 496) && *(unsigned char *)(a1 + 512) && *(unsigned char *)(a1 + 528) != 0;
  md::updateAndLogChange<BOOL>((unsigned char *)(a1 + 487), v83, (uint64_t)"_puckFallbackState.nonTiledIDsFound");
  if (*(unsigned char *)(a1 + 536) && !*(unsigned char *)(a1 + 328) && *(unsigned char *)(a1 + 487)) {
    md::RegistryManager::vendRegistry((md::RegistryManager *)v745);
  }
  if (!*(void *)(a1 + 288))
  {
    uint64_t v84 = *(void *)(a1 + 272);
    buf[0] = 0;
    LODWORD(v773[1]) = 1;
    *(void *)(a1 + 288) = md::RegistryManager::getRegistryForKey(v84, (uint64_t)buf);
    if (LODWORD(v773[1]) != -1) {
      ((void (*)(unsigned char *, unsigned char *))off_1EF58F7B8[LODWORD(v773[1])])(v749, buf);
    }
  }
  v757[0] = &unk_1EF579F50;
  v757[1] = a1;
  int v758 = v757;
  int8x16_t v85 = (unsigned char *)v722[6];
  int32x4_t v86 = (unsigned char *)v722[7];
  if (v85 == v86) {
    goto LABEL_71;
  }
  do
  {
    buf[0] = *v85;
    if (!v758)
    {
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_585:
      __break(1u);
      return;
    }
    (*(void (**)(void *, unsigned char *))(*v758 + 48))(v758, buf);
    ++v85;
  }
  while (v85 != v86);
  if (v758 == v757)
  {
LABEL_71:
    (*(void (**)(void *))(v757[0] + 32))(v757);
    if (*(unsigned char *)(a1 + 496)) {
      goto LABEL_68;
    }
    goto LABEL_72;
  }
  if (v758) {
    (*(void (**)(void))(*v758 + 40))();
  }
  if (!*(unsigned char *)(a1 + 496))
  {
LABEL_72:
    BOOL v91 = 0;
    goto LABEL_95;
  }
LABEL_68:
  int8x8_t v87 = v686[6];
  if (v87)
  {
    unint64_t v88 = *(void *)(a1 + 488);
    uint8x8_t v89 = (uint8x8_t)vcnt_s8(v87);
    v89.i16[0] = vaddlv_u8(v89);
    if (v89.u32[0] > 1uLL)
    {
      unint64_t v90 = *(void *)(a1 + 488);
      if (v88 >= *(void *)&v87) {
        unint64_t v90 = v88 % *(void *)&v87;
      }
    }
    else
    {
      unint64_t v90 = (*(void *)&v87 - 1) & v88;
    }
    int8x16_t v92 = *(void **)(*(void *)&v686[5] + 8 * v90);
    if (v92)
    {
      int8x16_t v92 = (void *)*v92;
      if (v92)
      {
        if (v89.u32[0] < 2uLL)
        {
          uint64_t v93 = *(void *)&v87 - 1;
          while (1)
          {
            uint64_t v95 = v92[1];
            if (v88 == v95)
            {
              if (v92[2] == v88) {
                goto LABEL_94;
              }
            }
            else if ((v95 & v93) != v90)
            {
              goto LABEL_93;
            }
            int8x16_t v92 = (void *)*v92;
            if (!v92) {
              goto LABEL_94;
            }
          }
        }
        do
        {
          unint64_t v94 = v92[1];
          if (v88 == v94)
          {
            if (v92[2] == v88) {
              break;
            }
          }
          else
          {
            if (v94 >= *(void *)&v87) {
              v94 %= *(void *)&v87;
            }
            if (v94 != v90) {
              goto LABEL_93;
            }
          }
          int8x16_t v92 = (void *)*v92;
        }
        while (v92);
      }
    }
  }
  else
  {
LABEL_93:
    int8x16_t v92 = 0;
  }
LABEL_94:
  BOOL v91 = v92 != 0;
LABEL_95:
  uint64_t v96 = *v9;
  {
    qword_1EB3176C0 = 0;
    qword_1EB3176B8 = 0;
    md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet = (uint64_t)&qword_1EB3176B8;
    __cxa_atexit((void (*)(void *))std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100], &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet, &dword_1A1780000);
  }
  int8x16_t v97 = *(_WORD **)(v96 + 48);
  int16x8_t v98 = *(_WORD **)(v96 + 56);
  int32x4_t v99 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
  if (v97 == v98)
  {
    uint64_t v101 = v715;
  }
  else
  {
    int8x16_t v100 = *(_WORD **)(v96 + 48);
    uint64_t v101 = v715;
    while (*v100 != 62)
    {
      v100 += 16;
      if (v100 == v98) {
        goto LABEL_108;
      }
    }
    if (v100 == v98)
    {
      int32x4_t v99 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
    }
    else
    {
      while (*v97 != 62)
      {
        v97 += 16;
        if (v97 == v98)
        {
          int8x16_t v97 = v98;
          break;
        }
      }
      int32x4_t v99 = (uint64_t *)(v97 + 4);
    }
  }
LABEL_108:
  uint64_t v102 = v99[2];
  int32x4_t v103 = *(int8x8_t **)(a1 + 288);
  unint64_t v728 = i;
  if (v103)
  {
    uint64_t v676 = v99[2];
    BOOL v687 = v91;
    int8x16_t v104 = (void *)gdc::Registry::storage<md::components::DynamicMeshInstance>(v103);
    int8x16_t v105 = (void *)gdc::Registry::storage<md::components::Material>(v103);
    uint64_t v106 = gdc::Registry::storage<md::components::Asset>(v103);
    int8x16_t v107 = (void *)v106;
    uint64_t v108 = v106 + 32;
    unint64_t v110 = (unint64_t *)v104[7];
    int8x16_t v109 = (uint64_t *)v104[8];
    if (v105[8] - v105[7] >= (unint64_t)((char *)v109 - (char *)v110)) {
      int8x16_t v111 = v104 + 4;
    }
    else {
      int8x16_t v111 = v105 + 4;
    }
    if (*(void *)(v106 + 64) - *(void *)(v106 + 56) >= v111[4] - v111[3]) {
      uint64_t v112 = v111;
    }
    else {
      uint64_t v112 = (void *)(v106 + 32);
    }
    if (v109 != (uint64_t *)v110 && v104 + 4 == v112)
    {
      int v114 = 0;
      uint64_t v115 = 1;
      do
      {
        unint64_t v364 = *((unsigned int *)v110 + 1);
        unint64_t v365 = v364 >> 7;
        uint64_t v366 = v105[4];
        unint64_t v367 = (v105[5] - v366) >> 3;
        if (v364 >> 7 < v367)
        {
          uint64_t v368 = *(void *)(v366 + 8 * v365);
          if (v368)
          {
            unint64_t v369 = *(unsigned __int16 *)(v368 + 2 * (v364 & 0x7F));
            uint64_t v371 = v105[7];
            uint64_t v370 = v105[8];
            unint64_t v372 = (v370 - v371) >> 3;
            if (v372 > v369)
            {
              uint64_t v373 = v371 + 8 * v369;
              if (v373 != v370 && *(_DWORD *)(v373 + 4) == v364)
              {
                uint64_t v375 = v107[4];
                if (v365 < (v107[5] - v375) >> 3)
                {
                  uint64_t v376 = *(void *)(v375 + 8 * v365);
                  if (v376)
                  {
                    unint64_t v377 = *(unsigned __int16 *)(v376 + 2 * (v364 & 0x7F));
                    uint64_t v379 = v107[7];
                    uint64_t v378 = v107[8];
                    if (v377 < (v378 - v379) >> 3)
                    {
                      uint64_t v380 = v379 + 8 * v377;
                      if (v380 != v378 && *(_DWORD *)(v380 + 4) == v364)
                      {
                        unint64_t v382 = *v110 >> 39;
                        if (v382 < v367
                          && (uint64_t v383 = *(void *)(v366 + 8 * v382)) != 0
                          && (unint64_t v384 = *(unsigned __int16 *)(v383 + 2 * (HIDWORD(*v110) & 0x7F)), v372 > v384)
                          && ((uint64_t v385 = v371 + 8 * v384, v385 != v370)
                            ? (BOOL v386 = *(_DWORD *)(v385 + 4) == HIDWORD(*v110))
                            : (BOOL v386 = 0),
                              v386))
                        {
                          uint64_t v387 = v105[10] + 24 * v384;
                        }
                        else
                        {
                          uint64_t v387 = v105[11];
                        }
                        unint64_t v664 = HIDWORD(*v110);
                        unint64_t v665 = *v110;
                        uint64_t v666 = v108;
                        unsigned int v668 = v115;
                        uint64_t v388 = *(std::__shared_weak_count **)(v387 + 16);
                        if (v388) {
                          atomic_fetch_add_explicit(&v388->__shared_owners_, 1uLL, memory_order_relaxed);
                        }
                        uint64_t v673 = v388;
                        uint64_t v389 = (void *)gdc::Registry::storage<md::components::RenderableInjected>(*(int8x8_t **)(a1 + 288));
                        uint64_t v390 = v389[4];
                        uint64_t v115 = v668;
                        uint64_t v108 = v666;
                        if (v382 >= (v389[5] - v390) >> 3
                          || (uint64_t v391 = *(void *)(v390 + 8 * v382)) == 0
                          || (unint64_t v392 = *(unsigned __int16 *)(v391 + 2 * (HIDWORD(v665) & 0x7F)),
                              uint64_t v394 = v389[7],
                              uint64_t v393 = v389[8],
                              v392 >= (v393 - v394) >> 3)
                          || ((uint64_t v395 = v394 + 8 * v392, v395 != v393)
                            ? (BOOL v396 = *(_DWORD *)(v395 + 4) == v664)
                            : (BOOL v396 = 0),
                              !v396 || (uint64_t v397 = v389[10]) == 0 || v397 + v392 == v389[11]))
                        {
                          uint64_t v115 = 0;
                        }
                        if (v673)
                        {
                          uint64_t v101 = v715;
                          if (!atomic_fetch_add(&v673->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            unsigned int v669 = v115;
                            ((void (*)(std::__shared_weak_count *))v673->__on_zero_shared)(v673);
                            std::__shared_weak_count::__release_weak(v673);
                            uint64_t v108 = v666;
                            uint64_t v115 = v669;
                          }
                          int v114 = 1;
                        }
                        else
                        {
                          int v114 = 1;
                          uint64_t v101 = v715;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        ++v110;
      }
      while (v110 != (unint64_t *)v109);
    }
    else
    {
      int v114 = 0;
      uint64_t v115 = 1;
    }
    if (v105 + 4 == v112)
    {
      float v197 = (unint64_t *)v105[7];
      int v198 = (uint64_t *)v105[8];
      if (v197 != (unint64_t *)v198)
      {
        float v199 = (std::__shared_weak_count **)(v105[10] + 16);
        do
        {
          unint64_t v599 = *((unsigned int *)v197 + 1);
          unint64_t v600 = v599 >> 7;
          uint64_t v601 = v104[4];
          if (v599 >> 7 < (v104[5] - v601) >> 3)
          {
            uint64_t v602 = *(void *)(v601 + 8 * v600);
            if (v602)
            {
              unint64_t v603 = *(unsigned __int16 *)(v602 + 2 * (v599 & 0x7F));
              uint64_t v605 = v104[7];
              uint64_t v604 = v104[8];
              if (v603 < (v604 - v605) >> 3)
              {
                uint64_t v606 = v605 + 8 * v603;
                if (v606 != v604 && *(_DWORD *)(v606 + 4) == v599)
                {
                  uint64_t v608 = v107[4];
                  if (v600 < (v107[5] - v608) >> 3)
                  {
                    uint64_t v609 = *(void *)(v608 + 8 * v600);
                    if (v609)
                    {
                      unint64_t v610 = *(unsigned __int16 *)(v609 + 2 * (v599 & 0x7F));
                      uint64_t v612 = v107[7];
                      uint64_t v611 = v107[8];
                      if (v610 < (v611 - v612) >> 3)
                      {
                        uint64_t v613 = v612 + 8 * v610;
                        if (v613 != v611 && *(_DWORD *)(v613 + 4) == v599)
                        {
                          uint64_t v667 = v108;
                          unsigned int v670 = v115;
                          unint64_t v615 = *v197;
                          v616 = *v199;
                          if (*v199) {
                            atomic_fetch_add_explicit(&v616->__shared_owners_, 1uLL, memory_order_relaxed);
                          }
                          v674 = v616;
                          size_t v617 = (void *)gdc::Registry::storage<md::components::RenderableInjected>(*(int8x8_t **)(a1 + 288));
                          uint64_t v618 = v617[4];
                          uint64_t v115 = v670;
                          uint64_t v108 = v667;
                          if (v615 >> 39 >= (v617[5] - v618) >> 3
                            || (uint64_t v619 = *(void *)(v618 + 8 * (v615 >> 39))) == 0
                            || (unint64_t v620 = *(unsigned __int16 *)(v619 + 2 * (HIDWORD(v615) & 0x7F)),
                                uint64_t v622 = v617[7],
                                uint64_t v621 = v617[8],
                                v620 >= (v621 - v622) >> 3)
                            || ((uint64_t v623 = v622 + 8 * v620, v623 != v621)
                              ? (BOOL v624 = *(_DWORD *)(v623 + 4) == HIDWORD(v615))
                              : (BOOL v624 = 0),
                                !v624 || (uint64_t v625 = v617[10]) == 0 || v625 + v620 == v617[11]))
                          {
                            uint64_t v115 = 0;
                          }
                          if (v674)
                          {
                            uint64_t v101 = v715;
                            if (!atomic_fetch_add(&v674->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              unsigned int v671 = v115;
                              ((void (*)(std::__shared_weak_count *))v674->__on_zero_shared)(v674);
                              std::__shared_weak_count::__release_weak(v674);
                              uint64_t v108 = v667;
                              uint64_t v115 = v671;
                            }
                            int v114 = 1;
                          }
                          else
                          {
                            int v114 = 1;
                            uint64_t v101 = v715;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          ++v197;
          v199 += 3;
        }
        while (v197 != (unint64_t *)v198);
      }
    }
    if ((void *)v108 == v112)
    {
      unint64_t v200 = (unint64_t *)v107[7];
      unint64_t v201 = (uint64_t *)v107[8];
      for (uint64_t i = v728; v200 != (unint64_t *)v201; ++v200)
      {
        unint64_t v626 = *((unsigned int *)v200 + 1);
        unint64_t v627 = v626 >> 7;
        uint64_t v628 = v104[4];
        if (v626 >> 7 < (v104[5] - v628) >> 3)
        {
          uint64_t v629 = *(void *)(v628 + 8 * v627);
          if (v629)
          {
            unint64_t v630 = *(unsigned __int16 *)(v629 + 2 * (v626 & 0x7F));
            uint64_t v632 = v104[7];
            uint64_t v631 = v104[8];
            if (v630 < (v631 - v632) >> 3)
            {
              uint64_t v633 = v632 + 8 * v630;
              if (v633 != v631 && *(_DWORD *)(v633 + 4) == v626)
              {
                uint64_t v635 = v105[4];
                unint64_t v636 = (v105[5] - v635) >> 3;
                if (v627 < v636)
                {
                  uint64_t v637 = *(void *)(v635 + 8 * v627);
                  if (v637)
                  {
                    unint64_t v638 = *(unsigned __int16 *)(v637 + 2 * (v626 & 0x7F));
                    uint64_t v640 = v105[7];
                    uint64_t v639 = v105[8];
                    unint64_t v641 = (v639 - v640) >> 3;
                    if (v641 > v638)
                    {
                      uint64_t v642 = v640 + 8 * v638;
                      if (v642 != v639 && *(_DWORD *)(v642 + 4) == v626)
                      {
                        unint64_t v644 = *v200;
                        unint64_t v645 = HIDWORD(*v200);
                        unint64_t v646 = *v200 >> 39;
                        if (v646 < v636
                          && (uint64_t v647 = *(void *)(v635 + 8 * v646)) != 0
                          && (unint64_t v648 = *(unsigned __int16 *)(v647 + 2 * (HIDWORD(v644) & 0x7F)), v641 > v648)
                          && ((uint64_t v649 = v640 + 8 * v648, v649 != v639)
                            ? (BOOL v650 = *(_DWORD *)(v649 + 4) == v645)
                            : (BOOL v650 = 0),
                              v650))
                        {
                          uint64_t v651 = v105[10] + 24 * v648;
                        }
                        else
                        {
                          uint64_t v651 = v105[11];
                        }
                        uint64_t v652 = v115;
                        unint64_t v653 = *(std::__shared_weak_count **)(v651 + 16);
                        if (v653) {
                          atomic_fetch_add_explicit(&v653->__shared_owners_, 1uLL, memory_order_relaxed);
                        }
                        v675 = v653;
                        v654 = (void *)gdc::Registry::storage<md::components::RenderableInjected>(*(int8x8_t **)(a1 + 288));
                        uint64_t v655 = v654[4];
                        if (v646 >= (v654[5] - v655) >> 3) {
                          goto LABEL_572;
                        }
                        uint64_t v656 = *(void *)(v655 + 8 * v646);
                        if (!v656) {
                          goto LABEL_572;
                        }
                        unint64_t v657 = *(unsigned __int16 *)(v656 + 2 * (HIDWORD(v644) & 0x7F));
                        uint64_t v659 = v654[7];
                        uint64_t v658 = v654[8];
                        if (v657 >= (v658 - v659) >> 3) {
                          goto LABEL_572;
                        }
                        uint64_t v660 = v659 + 8 * v657;
                        BOOL v661 = v660 != v658 && *(_DWORD *)(v660 + 4) == v645;
                        if (!v661 || (v663 = v654[10]) == 0 || (uint64_t v115 = v652, v663 + v657 == v654[11])) {
LABEL_572:
                        }
                          uint64_t v115 = 0;
                        if (v675)
                        {
                          uint64_t i = v728;
                          uint64_t v101 = v715;
                          if (!atomic_fetch_add(&v675->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            uint64_t v662 = v115;
                            ((void (*)(std::__shared_weak_count *))v675->__on_zero_shared)(v675);
                            std::__shared_weak_count::__release_weak(v675);
                            uint64_t v115 = v662;
                          }
                          int v114 = 1;
                        }
                        else
                        {
                          int v114 = 1;
                          uint64_t i = v728;
                          uint64_t v101 = v715;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      uint64_t i = v728;
    }
    if (v115) {
      BOOL v116 = v114 == 0;
    }
    else {
      BOOL v116 = 1;
    }
    int v117 = !v116;
    BOOL v91 = v687;
    uint64_t v102 = v676;
  }
  else
  {
    int v114 = 0;
    int v117 = 0;
  }
  md::updateAndLogChange<BOOL>((unsigned char *)(a1 + 481), v114 != 0, (uint64_t)"_puckFallbackState.puckEntitiesExist");
  md::updateAndLogChange<BOOL>((unsigned char *)(a1 + 482), v117, (uint64_t)"_puckFallbackState.puckEntitiesInjected");
  md::updateAndLogChange<BOOL>((unsigned char *)(a1 + 484), v91, (uint64_t)"_puckFallbackState.puckAssetAvailable");
  md::updateAndLogChange<BOOL>((unsigned char *)(a1 + 485), v102 != 0, (uint64_t)"_puckFallbackState.injectablesInView");
  md::updateAndLogChange<BOOL>((unsigned char *)(a1 + 483), *(unsigned __int8 *)(v712 + 3776) - 1 < 3, (uint64_t)"_puckFallbackState.cameraTypeGlobe");
  int v119 = 0;
  if ((v91 & v117) == 1 && v102)
  {
    int32x4_t v120 = +[VKDebugSettings sharedSettings];
    int v119 = [v120 enable3DPuck];
  }
  int8x16_t v121 = (_OWORD *)(a1 + 296);
  i[209] = v119;
  if (*(unsigned __int8 *)(a1 + 480) != v119)
  {
    if (GEOGetVectorKitPuckLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitPuckLogicLog(void)::onceToken, &__block_literal_global_5070);
    }
    int32x4_t v122 = GEOGetVectorKitPuckLogicLog(void)::log;
    BOOL v118 = os_log_type_enabled((os_log_t)GEOGetVectorKitPuckLogicLog(void)::log, OS_LOG_TYPE_INFO);
    if (v118)
    {
      int v123 = *(unsigned __int8 *)(a1 + 480);
      *(_DWORD *)buf = 136315650;
      *(void *)&buf[4] = "_puckRenderMode";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v123;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v119;
      _os_log_impl(&dword_1A1780000, v122, OS_LOG_TYPE_INFO, "State %s changed from %d to %d", buf, 0x18u);
    }
    *(unsigned char *)(a1 + 480) = v119;
  }
  if (!*(void *)v121)
  {
    uint64_t v124 = gss::Allocator::instance((gss::Allocator *)v118);
    *(void *)&long long v750 = v124;
    int8x16_t v125 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v124 + 16))(v124, 16, 4);
    int8x16_t v126 = v125;
    *(void *)uint64_t v749 = v125;
    *(void *)&v749[16] = v125 + 2;
    if (v125) {
      *int8x16_t v125 = 0xE00000005;
    }
    v125[1] = 65594;
    *(void *)&v749[8] = v125 + 2;
    gss::FeatureAttributeSet::FeatureAttributeSet((gss::FeatureAttributeSet *)buf, (uint64_t)v749);
    (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v124 + 40))(v124, v126, 16);
    uint64_t v127 = *v722;
    *(void *)&v749[7] = 0;
    *(void *)uint64_t v749 = 0;
    v749[15] = 1;
    gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)v745, v127, (gss::FeatureAttributeSet *)buf, (gss::QueryOverrides *)v749);
    long long v128 = *(_OWORD *)v745;
    unint64_t v129 = *(std::__shared_weak_count **)(a1 + 304);
    *(void *)&v745[8] = 0;
    *(void *)uint64_t v745 = 0;
    *int8x16_t v121 = v128;
    if (v129 && !atomic_fetch_add(&v129->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v129->__on_zero_shared)(v129);
      std::__shared_weak_count::__release_weak(v129);
    }
    uint64_t v130 = *(std::__shared_weak_count **)&v745[8];
    if (*(void *)&v745[8]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v745[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v130->__on_zero_shared)(v130);
      std::__shared_weak_count::__release_weak(v130);
    }
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      (*(void (**)(void, void, void))(*(void *)v769 + 40))(v769, *(void *)buf, *(void *)&buf[16] - *(void *)buf);
    }
  }
  uint64_t v131 = (_OWORD *)(a1 + 120);
  md::LayoutContext::zoomAtCentrePoint(*(int8x8_t **)(a2 + 8));
  long long v133 = (gss::Allocator *)md::PuckStyleInfo::update(a1 + 120, v101, v700, v722, (uint64_t *)(a1 + 296), v132);
  if (!*(unsigned char *)(a1 + 193))
  {
    if (!*(void *)(a1 + 312))
    {
      uint64_t v134 = gss::Allocator::instance(v133);
      *(void *)&long long v750 = v134;
      unint64_t v135 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v134 + 16))(v134, 16, 4);
      long long v136 = v135;
      *(void *)uint64_t v749 = v135;
      *(void *)&v749[16] = v135 + 2;
      if (v135) {
        *unint64_t v135 = 0xE00000005;
      }
      v135[1] = 0x10001003ALL;
      *(void *)&v749[8] = v135 + 2;
      gss::FeatureAttributeSet::FeatureAttributeSet((gss::FeatureAttributeSet *)buf, (uint64_t)v749);
      (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v134 + 40))(v134, v136, 16);
      uint64_t v137 = *v722;
      *(void *)&v749[7] = 0;
      *(void *)uint64_t v749 = 0;
      v749[15] = 1;
      gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)v745, v137, (gss::FeatureAttributeSet *)buf, (gss::QueryOverrides *)v749);
      long long v138 = *(_OWORD *)v745;
      unint64_t v139 = *(std::__shared_weak_count **)(a1 + 320);
      *(void *)&v745[8] = 0;
      *(void *)uint64_t v745 = 0;
      *(_OWORD *)(a1 + 312) = v138;
      if (v139 && !atomic_fetch_add(&v139->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v139->__on_zero_shared)(v139);
        std::__shared_weak_count::__release_weak(v139);
      }
      unint64_t v140 = *(std::__shared_weak_count **)&v745[8];
      if (*(void *)&v745[8]
        && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v745[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v140->__on_zero_shared)(v140);
        std::__shared_weak_count::__release_weak(v140);
      }
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        (*(void (**)(void, void, void))(*(void *)v769 + 40))(v769, *(void *)buf, *(void *)&buf[16] - *(void *)buf);
      }
    }
    md::LayoutContext::zoomAtCentrePoint(*(int8x8_t **)(a2 + 8));
    md::PuckStyleInfo::update(a1 + 196, v101, v700, v722, (uint64_t *)(a1 + 312), v141);
  }
  uint64_t v142 = v728 + 264;
  *(_OWORD *)(v728 + 56) = *v131;
  *((_DWORD *)v728 + 18) = *(_DWORD *)(a1 + 136);
  *((_DWORD *)v728 + 19) = *(_DWORD *)(a1 + 140);
  *((_DWORD *)v728 + 20) = *(_DWORD *)(a1 + 144);
  *((_DWORD *)v728 + 21) = *(_DWORD *)(a1 + 148);
  *((_DWORD *)v728 + 22) = *(_DWORD *)(a1 + 152);
  *((_DWORD *)v728 + 23) = *(_DWORD *)(a1 + 156);
  *((_DWORD *)v728 + 24) = *(_DWORD *)(a1 + 160);
  *((_DWORD *)v728 + 25) = *(_DWORD *)(a1 + 164);
  *((_DWORD *)v728 + 26) = *(_DWORD *)(a1 + 168);
  *((_DWORD *)v728 + 27) = *(_DWORD *)(a1 + 172);
  *((_DWORD *)v728 + 28) = *(_DWORD *)(a1 + 176);
  *((_DWORD *)v728 + 29) = *(_DWORD *)(a1 + 180);
  uint64_t v143 = *(void *)(a1 + 184);
  *((_WORD *)v728 + 64) = *(_WORD *)(a1 + 192);
  *((void *)v728 + 15) = v143;
  *(_OWORD *)(v728 + 132) = *(_OWORD *)(a1 + 196);
  *((_DWORD *)v728 + 37) = *(_DWORD *)(a1 + 212);
  *((_DWORD *)v728 + 38) = *(_DWORD *)(a1 + 216);
  *((_DWORD *)v728 + 39) = *(_DWORD *)(a1 + 220);
  *((_DWORD *)v728 + 40) = *(_DWORD *)(a1 + 224);
  *((_DWORD *)v728 + 41) = *(_DWORD *)(a1 + 228);
  *((_DWORD *)v728 + 42) = *(_DWORD *)(a1 + 232);
  *((_DWORD *)v728 + 43) = *(_DWORD *)(a1 + 236);
  *((_DWORD *)v728 + 44) = *(_DWORD *)(a1 + 240);
  *((_DWORD *)v728 + 45) = *(_DWORD *)(a1 + 244);
  *((_DWORD *)v728 + 46) = *(_DWORD *)(a1 + 248);
  *((_DWORD *)v728 + 47) = *(_DWORD *)(a1 + 252);
  *((_DWORD *)v728 + 48) = *(_DWORD *)(a1 + 256);
  uint64_t v144 = *(void *)(a1 + 260);
  *((_WORD *)v728 + 102) = *(_WORD *)(a1 + 268);
  *(void *)(v728 + 196) = v144;
  uint64_t v145 = "se_cfENS_8_hash_cfENS_9_equal_cfEEE";
  if (!v728[209])
  {
    uint64_t v146 = *a3;
    uint64_t v147 = a3[2];
    float v148 = *(float *)(a3[1] + 16) * *(float *)(a3[1] + 20);
    double v149 = *(double *)(v147 + 72);
    double v150 = *(double *)(v147 + 80);
    long double v151 = tan(*(double *)(v147 + 64) * 0.5 + 0.785398163);
    double v152 = log(v151);
    double v153 = v149 * 0.159154943 + 0.5;
    double v154 = v152 * 0.159154943 + 0.5;
    int v155 = *v728;
    if (*(unsigned __int8 *)(v146 + 3776) - 1 >= 3)
    {
      double v202 = 0.0;
      if (v155 == 1) {
        double v202 = ((float)(*(float *)(v147 + 88) + 0.1) + v150 * v148) * 0.0000000249532021;
      }
      double v704 = 0.0;
      double v705 = v202;
      double v713 = v154;
      double v717 = v149 * 0.159154943 + 0.5;
      *(double *)(a1 + 336) = v153;
      *(double *)(a1 + 344) = v154;
      double v701 = 1.0;
      double v684 = 0.0;
      double v688 = 0.0;
      double v682 = 1.0;
      *(double *)(a1 + 352) = v202;
      double v196 = 0.0;
    }
    else
    {
      double v716 = v152;
      double v156 = 0.0;
      if (v155 == 1) {
        double v156 = (float)(*(float *)(v147 + 88) + 0.1) + v150 * v148;
      }
      *(double *)(a1 + 336) = v153;
      *(double *)(a1 + 344) = v154;
      *(double *)(a1 + 352) = v156;
      long double v157 = v153 * 6.28318531;
      long double v158 = exp(v154 * 6.28318531 + -3.14159265);
      double v159 = atan(v158) * 2.0 + -1.57079633;
      long double v160 = fmod(v157, 6.28318531);
      double v161 = fmod(v160 + 6.28318531, 6.28318531) + -3.14159265;
      __double2 v162 = __sincos_stret(v159);
      double v163 = 6378137.0 / sqrt(1.0 - v162.__sinval * v162.__sinval * 0.00669437999);
      double v164 = (v163 + v156) * v162.__cosval;
      __double2 v165 = __sincos_stret(v161);
      double v166 = v164 * v165.__cosval;
      double v167 = v164 * v165.__sinval;
      double v168 = (v163 * 0.99330562 + v156) * v162.__sinval;
      double v169 = (v163 + v156 + 1.0) * v162.__cosval;
      double v170 = -(v166 - v169 * v165.__cosval);
      double v171 = -(v167 - v169 * v165.__sinval);
      double v172 = -(v168 - (v163 * 0.99330562 + v156 + 1.0) * v162.__sinval);
      double v173 = 1.0 / sqrt(v170 * v170 + v171 * v171 + v172 * v172);
      double v174 = v173 * v170;
      double v175 = v173 * v171;
      double v176 = v173 * v172;
      long double v177 = exp(v716 + 0.000628318515);
      long double v178 = atan(v177);
      __double2 v179 = __sincos_stret(v178 * 2.0 + -1.57079633);
      double v180 = 6378137.0 / sqrt(1.0 - v179.__sinval * v179.__sinval * 0.00669437999);
      double v181 = (v180 + v156) * v179.__cosval;
      double v713 = v167;
      double v717 = v166;
      double v182 = -(v166 - v181 * v165.__cosval);
      double v183 = -(v167 - v181 * v165.__sinval);
      double v705 = v168;
      double v184 = -(v168 - (v156 + v180 * 0.99330562) * v179.__sinval);
      double v185 = 1.0 / sqrt(v182 * v182 + v183 * v183 + v184 * v184);
      double v186 = v185 * v182;
      double v187 = v185 * v183;
      double v188 = v185 * v184;
      double v189 = -(v188 * v175 - v187 * v176);
      double v190 = -(v186 * v176 - v188 * v174);
      double v191 = -(v187 * v174 - v186 * v175);
      double v192 = 1.0 / sqrt(v189 * v189 + v190 * v190 + v191 * v191);
      double v193 = v192 * v189;
      double v194 = v192 * v190;
      double v195 = v192 * v191;
      double v701 = v176;
      double v704 = v174;
      double v682 = -(v195 * v174 - v193 * v176);
      double v684 = -(v194 * v176 - v195 * v175);
      double v688 = v175;
      double v196 = -(v193 * v175 - v194 * v174);
    }
    double v680 = v196;
    double v204 = *(double *)(v146 + 496);
    double v203 = *(double *)(v146 + 504);
    double v205 = *(double *)(v146 + 512);
    double v206 = *(double *)(v146 + 3760);
    [*(id *)a2 size];
    double v208 = v207;
    float v209 = *(float *)v131;
    double v210 = *(double *)(v146 + 3112);
    double v211 = *(double *)(v146 + 3120);
    double v677 = *(double *)(v146 + 3128);
    uint64_t v212 = [*(id *)(v147 + 48) puck];
    double v213 = (v717 - v204) * (v717 - v204) + (v713 - v203) * (v713 - v203) + (v705 - v205) * (v705 - v205);
    float v214 = (v206 + v206) / v208;
    double v215 = v214;
    double v216 = v209;
    float v217 = *(double *)(v212 + 32);
    if (*(unsigned char *)(v212 + 49))
    {
      BOOL v218 = 0;
      double v220 = v701;
      double v219 = v704;
      double v221 = v688;
    }
    else
    {
      double v220 = v701;
      double v219 = v704;
      double v221 = v688;
      double v222 = v210 * v704 + v211 * v688 + v677 * v701;
      *(double *)&uint64_t v672 = v215;
      double v223 = v216;
      double v224 = v211 - v222 * v688;
      double v225 = v210 - v222 * v704;
      double v226 = 1.0 / sqrt(v225 * v225 + v224 * v224 + (v677 - v222 * v701) * (v677 - v222 * v701));
      double v227 = atan2(v226 * v225, v226 * v224);
      long double v228 = v217 + 3.14159265 - v227;
      double v229 = v227;
      long double v230 = fmod(v228, 6.28318531);
      float v231 = fmod(v230 + 6.28318531, 6.28318531) + -3.14159265;
      float v232 = 0.7854;
      if (!*(unsigned char *)(v212 + 50)) {
        float v232 = -0.7854;
      }
      if (v231 < 4.71238898 && v231 > 1.57079633) {
        float v232 = -v232;
      }
      float v234 = v232 + v231;
      double v216 = v223;
      double v215 = *(double *)&v672;
      BOOL v218 = v234 <= 3.14159265 && v234 >= 0.0;
      float v217 = v229;
    }
    double v235 = v215 * v216;
    *(unsigned char *)(v212 + 50) = v218;
    double v678 = sqrt(v213);
    __double2 v236 = __sincos_stret(v217 * -0.5 + 1.57079633);
    double v237 = v236.__sinval * v219;
    double v238 = v236.__sinval * v221;
    double v239 = v236.__sinval * v220;
    double v240 = -(v239 * v682 - v238 * v680) - (v239 * v682 - v238 * v680);
    double v241 = -(v237 * v680 - v239 * v684) - (v237 * v680 - v239 * v684);
    double v242 = -(v238 * v684 - v237 * v682) - (v238 * v684 - v237 * v682);
    double v243 = v684 + v240 * v236.__cosval + v242 * (v236.__sinval * v221) - v241 * (v236.__sinval * v220);
    double v244 = v682 + v240 * (v236.__sinval * v220) + v241 * v236.__cosval - v242 * (v236.__sinval * v219);
    double v245 = v680 + v241 * (v236.__sinval * v219) + v242 * v236.__cosval - v240 * (v236.__sinval * v221);
    double v246 = -(v245 * v221 - v244 * v220);
    double v247 = -(v243 * v220 - v245 * v219);
    double v248 = -(v244 * v219 - v243 * v221);
    double v249 = 1.0 / sqrt(v246 * v246 + v247 * v247 + v248 * v248);
    double v250 = v249 * v246;
    double v251 = v249 * v247;
    double v252 = v249 * v248;
    double v253 = -(v251 * v220 - v252 * v221);
    double v254 = -(v252 * v219 - v250 * v220);
    double v255 = -(v250 * v221 - v251 * v219);
    double v256 = 1.0 / sqrt(v253 * v253 + v254 * v254 + v255 * v255);
    double v257 = v256 * v253;
    double v258 = v256 * v254;
    double v259 = v256 * v255;
    double v260 = v258 + v250 + v220;
    double v261 = v219;
    double v262 = v220;
    if (v260 <= 0.0)
    {
      if (v250 <= v258 || v250 <= v220)
      {
        double v269 = sqrt(v220 + 1.0 - (v258 + v250));
        double v270 = 1.0 / (v269 + v269);
        double v271 = (v252 + v219) * v270;
        double v272 = v259 + v221;
        double v273 = v272 * v270;
        double v274 = v269 * 0.5;
        double v275 = (v251 - v257) * v270;
        double v276 = sqrt(1.0 - (v220 + v250) + v258);
        double v277 = v257 + v251;
        double v278 = 1.0 / (v276 + v276);
        double v279 = v277 * v278;
        double v280 = v276 * 0.5;
        double v281 = v272 * v278;
        double v282 = (v219 - v252) * v278;
        if (v258 > v220) {
          double v264 = v279;
        }
        else {
          double v264 = v271;
        }
        if (v258 > v220) {
          double v265 = v280;
        }
        else {
          double v265 = v273;
        }
        if (v258 > v220) {
          double v266 = v281;
        }
        else {
          double v266 = v274;
        }
        if (v258 > v220) {
          double v267 = v282;
        }
        else {
          double v267 = v275;
        }
      }
      else
      {
        double v283 = sqrt(v250 + 1.0 - (v220 + v258));
        double v264 = v283 * 0.5;
        double v284 = v257 + v251;
        double v285 = 1.0 / (v283 + v283);
        double v265 = v284 * v285;
        double v266 = (v252 + v261) * v285;
        double v267 = (v259 - v221) * v285;
      }
    }
    else
    {
      double v263 = 0.5 / sqrt(v260 + 1.0);
      double v264 = v263 * (v259 - v221);
      double v265 = v263 * (v261 - v252);
      double v266 = v263 * (v251 - v257);
      double v267 = 0.25 / v263;
    }
    double v286 = v678 * v235;
    if (*v728 || *(unsigned __int8 *)(v146 + 3776) - 1 < 3)
    {
      double v287 = v713;
      double v288 = v717;
      double v289 = v705;
    }
    else
    {
      double v328 = v717 - *(double *)(v146 + 496);
      double v329 = v713 - *(double *)(v146 + 504);
      double v330 = v705 - *(double *)(v146 + 512);
      double v331 = v328 * v261 + v329 * v221 + v330 * v262;
      double v332 = v261;
      double v333 = v262;
      double v679 = v328 - v331 * v261;
      double v681 = v329 - v331 * v221;
      double v334 = v330 - v331 * v262;
      *(float *)&double v328 = *(double *)(v146 + 40) * -10.0 + 7.5;
      double v685 = v286;
      float v683 = 0.5 / (float)(expf(*(float *)&v328) + 1.0);
      double v335 = v221;
      double v689 = v221;
      double v702 = v333;
      double v336 = -(v334 * v221 - v681 * v333);
      double v337 = -(v679 * v333 - v334 * v332);
      double v338 = -(v681 * v332 - v679 * v335);
      __double2 v339 = __sincos_stret(v683 * 0.5);
      double v340 = v339.__sinval / sqrt(v336 * v336 + v337 * v337 + v338 * v338);
      double v341 = v340 * v336;
      double v342 = v340 * v337;
      double v343 = v340 * v338;
      float v344 = sinf(v683);
      double v286 = v685;
      double v345 = v685 * (0.5 * v344);
      double v346 = v339.__cosval * v265 + v342 * v267 + v343 * v264;
      double v347 = v339.__cosval * v266 + v341 * v265 + v343 * v267 - v342 * v264;
      double v287 = v713 + v345 * v689;
      double v288 = v717 + v345 * v332;
      double v348 = v342 * v265 + v343 * v266 + v341 * v264;
      double v264 = v339.__cosval * v264 + v341 * v267 + v342 * v266 - v343 * v265;
      double v289 = v705 + v345 * v702;
      double v265 = v346 - v341 * v266;
      double v267 = -(v348 - v339.__cosval * v267);
      double v266 = v347;
    }
    double v290 = (v265 + v265) * v265;
    double v291 = (v266 + v266) * v266;
    double v292 = (v264 + v264) * v265;
    double v293 = (v266 + v266) * v267;
    double v294 = v292 - v293;
    *(double *)buf = 1.0 - (v290 + v291);
    *(double *)&uint8_t buf[8] = v293 + v292;
    double v295 = 1.0 - (v264 + v264) * v264;
    *((double *)&v769 + 1) = v294;
    *(double *)&long long v770 = v295 - v291;
    double v296 = v266 * (v264 + v264);
    double v297 = v267 * (v265 + v265);
    double v298 = (v265 + v265) * v266;
    double v299 = v267 * (v264 + v264);
    *(double *)&v771[1] = v297 + v296;
    *(double *)&v771[2] = v298 - v299;
    *(double *)&buf[16] = v296 - v297;
    *((double *)&v770 + 1) = v299 + v298;
    double v772 = v295 - v290;
    *(void *)&long long v769 = 0;
    v771[0] = 0;
    memset(v773, 0, sizeof(v773));
    uint64_t v774 = 0x3FF0000000000000;
    double v300 = *((float *)v728 + 15);
    long long v751 = 0u;
    uint64_t v753 = 0;
    *(_OWORD *)&v749[8] = 0u;
    long long v750 = 0u;
    long long v752 = 0u;
    *(void *)uint64_t v749 = 0x3FF0000000000000;
    *(void *)&long long v751 = 0x3FF0000000000000;
    *(void *)&long long v755 = 0;
    double v754 = 1.0;
    *((void *)&v755 + 1) = 0xBFE0000000000000;
    *(double *)v756 = v300;
    *(_OWORD *)&v756[8] = xmmword_1A28FCCC0;
    double v301 = v286 * *(float *)(v212 + 40);
    memset(&v745[40], 0, 40);
    memset(&v745[8], 0, 32);
    *((void *)&v748 + 1) = 0x3FF0000000000000;
    *(double *)uint64_t v745 = v301;
    *(double *)&v745[40] = v301;
    long long v746 = *(unint64_t *)&v301;
    *(double *)&long long v747 = v288;
    *((double *)&v747 + 1) = v287;
    *(double *)&long long v748 = v289;
    long long v738 = 0u;
    uint64_t v740 = 0;
    long long v743 = 0u;
    long long v742 = 0u;
    long long v739 = 0u;
    long long v737 = 0u;
    long long v736 = 0u;
    unint64_t v735 = 0x3FF0000000000000;
    *(void *)&long long v738 = 0x3FF0000000000000;
    uint64_t v741 = 0x3FF0000000000000;
    uint64_t v744 = 0x3FF0000000000000;
    if (v218) {
      unint64_t v735 = 0xBFF0000000000000;
    }
    gm::operator*<double,4,4,4>(v732, (double *)v745, (double *)buf);
    gm::operator*<double,4,4,4>(v733, v732, (double *)&v735);
    gm::operator*<double,4,4,4>((double *)v734, v733, (double *)v749);
    long long v302 = v734[1];
    *(_OWORD *)(v728 + 216) = v734[0];
    *(_OWORD *)(v728 + 232) = v302;
    long long v303 = v734[3];
    *(_OWORD *)(v728 + 248) = v734[2];
    long long v304 = v734[4];
    long long v305 = v734[5];
    _OWORD *v142 = v303;
    *(_OWORD *)(v728 + 280) = v304;
    long long v306 = v734[6];
    long long v307 = v734[7];
    *(_OWORD *)(v728 + 296) = v305;
    *(_OWORD *)(v728 + 312) = v306;
    *(_OWORD *)(v728 + 328) = v307;
  }
  uint64_t v308 = *a3;
  uint64_t v309 = a3[2];
  double v310 = *(double *)(*a3 + 3760);
  [*(id *)a2 size];
  double v312 = v311;
  float v313 = *(float *)(a1 + 120);
  float v314 = *(float *)(a1 + 188);
  id v315 = *(id *)(v309 + 48);
  double v316 = *(double *)([v315 puck] + 32);

  BOOL v318 = v728[209] == 1 && v728[208] != 0;
  md::PuckLogic::update3DPuckVisibility((md::PuckLogic *)a1, v318);
  LOBYTE(v734[0]) = v318;
  if (!*(void *)(a1 + 288)) {
    goto LABEL_435;
  }
  *(void *)&v749[8] = 0;
  *(void *)uint64_t v749 = 0;
  v749[16] = 1;
  *(void *)&v745[8] = 0;
  *(void *)uint64_t v745 = 0;
  v745[16] = 1;
  int v319 = *(unsigned __int8 *)(a1 + 192);
  if (v319 == 2)
  {
    v749[16] = 0;
    if (*(unsigned char *)(a1 + 193))
    {
      if (*(unsigned char *)(a1 + 193) != 1) {
        goto LABEL_250;
      }
      uint64_t v326 = *(void *)(a1 + 392);
      uint64_t v327 = *(void *)(a1 + 400);
      if (v327) {
        goto LABEL_237;
      }
    }
    else
    {
      uint64_t v326 = *(void *)(a1 + 408);
      uint64_t v327 = *(void *)(a1 + 416);
      if (v327)
      {
LABEL_237:
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v327 + 8), 1uLL, memory_order_relaxed);
        unint64_t v325 = *(std::__shared_weak_count **)&v745[8];
        *(void *)uint64_t v745 = v326;
        *(void *)&v745[8] = v327;
        if (v325) {
          goto LABEL_244;
        }
        goto LABEL_250;
      }
    }
    *(void *)uint64_t v745 = v326;
    *(void *)&v745[8] = 0;
    goto LABEL_250;
  }
  if (v319 == 1)
  {
    v749[16] = 1;
    v745[16] = 0;
    if (*(unsigned char *)(a1 + 193))
    {
      if (*(unsigned char *)(a1 + 193) != 1) {
        goto LABEL_250;
      }
      uint64_t v323 = *(void *)(a1 + 392);
      uint64_t v324 = *(void *)(a1 + 400);
      if (v324) {
        goto LABEL_232;
      }
    }
    else
    {
      uint64_t v323 = *(void *)(a1 + 408);
      uint64_t v324 = *(void *)(a1 + 416);
      if (v324)
      {
LABEL_232:
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v324 + 8), 1uLL, memory_order_relaxed);
        unint64_t v325 = *(std::__shared_weak_count **)&v749[8];
        *(void *)uint64_t v749 = v323;
        *(void *)&v749[8] = v324;
        if (v325) {
          goto LABEL_244;
        }
        goto LABEL_250;
      }
    }
    *(void *)uint64_t v749 = v323;
    *(void *)&v749[8] = 0;
    goto LABEL_250;
  }
  if (!*(unsigned char *)(a1 + 192))
  {
    v749[16] = 1;
    uint64_t v320 = *(void *)(a1 + 408);
    uint64_t v321 = *(void *)(a1 + 416);
    if (v321)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v321 + 8), 1uLL, memory_order_relaxed);
      v322 = *(std::__shared_weak_count **)&v749[8];
      *(void *)uint64_t v749 = v320;
      *(void *)&v749[8] = v321;
      if (v322 && !atomic_fetch_add(&v322->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v322->__on_zero_shared)(v322);
        std::__shared_weak_count::__release_weak(v322);
      }
    }
    else
    {
      *(void *)uint64_t v749 = *(void *)(a1 + 408);
      *(void *)&v749[8] = 0;
    }
    uint64_t v350 = *(void *)(a1 + 424);
    uint64_t v349 = *(void *)(a1 + 432);
    if (v349) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v349 + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v325 = *(std::__shared_weak_count **)&v745[8];
    *(void *)uint64_t v745 = v350;
    *(void *)&v745[8] = v349;
    if (v325)
    {
LABEL_244:
      if (!atomic_fetch_add(&v325->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v325->__on_zero_shared)(v325);
        std::__shared_weak_count::__release_weak(v325);
      }
    }
  }
LABEL_250:
  uint64_t v714 = v308;
  BOOL v351 = v749[16] != 0;
  if (!LOBYTE(v734[0])) {
    BOOL v351 = 0;
  }
  v749[16] = v351;
  if (LOBYTE(v734[0])) {
    BOOL v352 = v745[16] != 0;
  }
  else {
    BOOL v352 = 0;
  }
  v745[16] = v352;
  unint64_t v735 = (unint64_t)v734;
  *(void *)&long long v736 = a1;
  unsigned int v353 = *(int8x8_t **)(a1 + 288);
  int v354 = (void *)gdc::Registry::storage<md::components::OcclusionType>(v353);
  int v355 = (void *)gdc::Registry::storage<md::components::CustomRenderState>(v353);
  uint64_t v356 = gdc::Registry::storage<md::components::Visibility>(v353);
  unint64_t v357 = (void *)v356;
  uint64_t v358 = v356 + 32;
  uint64_t v360 = v354[7];
  uint64_t v359 = v354[8];
  if (v355[8] - v355[7] >= (unint64_t)(v359 - v360)) {
    unsigned int v361 = v354 + 4;
  }
  else {
    unsigned int v361 = v355 + 4;
  }
  if (*(void *)(v356 + 64) - *(void *)(v356 + 56) >= v361[4] - v361[3]) {
    unint64_t v362 = v361;
  }
  else {
    unint64_t v362 = (void *)(v356 + 32);
  }
  if (v354 + 4 == v362)
  {
    *(void *)buf = &v735;
    *(void *)&uint8_t buf[8] = v749;
    *(void *)&buf[16] = v745;
    if (v360 != v359)
    {
      unint64_t v363 = (char *)v354[10];
      while (2)
      {
        unint64_t v399 = *(unsigned int *)(v360 + 4);
        unint64_t v400 = v399 >> 7;
        uint64_t v401 = v355[4];
        unint64_t v402 = (v355[5] - v401) >> 3;
        if (v399 >> 7 >= v402) {
          goto LABEL_310;
        }
        uint64_t v403 = *(void *)(v401 + 8 * v400);
        if (!v403) {
          goto LABEL_310;
        }
        unint64_t v404 = *(unsigned __int16 *)(v403 + 2 * (v399 & 0x7F));
        uint64_t v406 = v355[7];
        uint64_t v405 = v355[8];
        unint64_t v407 = (v405 - v406) >> 3;
        if (v407 <= v404) {
          goto LABEL_310;
        }
        uint64_t v408 = v406 + 8 * v404;
        if (v408 == v405 || *(_DWORD *)(v408 + 4) != v399) {
          goto LABEL_310;
        }
        uint64_t v410 = v357[4];
        unint64_t v411 = (v357[5] - v410) >> 3;
        if (v400 >= v411) {
          goto LABEL_310;
        }
        uint64_t v412 = *(void *)(v410 + 8 * v400);
        if (!v412) {
          goto LABEL_310;
        }
        unint64_t v413 = *(unsigned __int16 *)(v412 + 2 * (v399 & 0x7F));
        uint64_t v415 = v357[7];
        uint64_t v414 = v357[8];
        unint64_t v416 = (v414 - v415) >> 3;
        if (v416 <= v413) {
          goto LABEL_310;
        }
        uint64_t v417 = v415 + 8 * v413;
        if (v417 == v414 || *(_DWORD *)(v417 + 4) != v399) {
          goto LABEL_310;
        }
        uint64_t v706 = v358;
        unint64_t v419 = *(void *)v360;
        uint64_t v420 = HIDWORD(*(void *)v360);
        unint64_t v421 = *(void *)v360 >> 39;
        if (v421 >= v402
          || (uint64_t v422 = *(void *)(v401 + 8 * v421)) == 0
          || (unint64_t v423 = *(unsigned __int16 *)(v422 + 2 * (HIDWORD(v419) & 0x7F)), v407 <= v423)
          || ((v424 = v406 + 8 * v423, v424 != v405) ? (BOOL v425 = *(_DWORD *)(v424 + 4) == v420) : (BOOL v425 = 0), !v425))
        {
          uint64_t v426 = (void *)v355[11];
          if (v421 < v411) {
            goto LABEL_335;
          }
          goto LABEL_308;
        }
        uint64_t v426 = (void *)(v355[10] + 24 * v423);
        if (v421 >= v411) {
          goto LABEL_308;
        }
LABEL_335:
        uint64_t v427 = *(void *)(v410 + 8 * v421);
        if (v427
          && (unint64_t v428 = *(unsigned __int16 *)(v427 + 2 * (HIDWORD(v419) & 0x7F)), v416 > v428)
          && ((uint64_t v429 = v415 + 8 * v428, v429 != v414) ? (v430 = *(_DWORD *)(v429 + 4) == v420) : (v430 = 0), v430))
        {
          uint64_t v398 = (unsigned char *)(v357[10] + v428);
        }
        else
        {
LABEL_308:
          uint64_t v398 = (unsigned char *)v357[11];
        }
        md::PuckLogic::update3DPuckRenderStates(md::PuckStyleInfo const&,md::PuckStyleInfo const&,BOOL)::$_1::operator()((uint64_t *)buf, v419, *v363, v426, v398);
        uint64_t v358 = v706;
LABEL_310:
        ++v363;
        v360 += 8;
        if (v360 == v359) {
          break;
        }
        continue;
      }
    }
    uint64_t v142 = v728 + 264;
  }
  uint64_t v145 = "N3geo11_retain_ptrIP9CGContextNS_10_retain_cfIS2_EENS_11_release_cfENS_8_hash_cfENS_9_equal_cfEEE" + 62;
  if (v355 + 4 == v362)
  {
    *(void *)buf = &v735;
    *(void *)&uint8_t buf[8] = v749;
    *(void *)&buf[16] = v745;
    uint64_t v432 = v355[7];
    uint64_t v433 = v355[8];
    if (v432 == v433)
    {
LABEL_389:
      uint64_t v145 = "se_cfENS_8_hash_cfENS_9_equal_cfEEE";
      if ((void *)v358 == v362) {
        goto LABEL_390;
      }
LABEL_348:
      uint64_t v431 = *(std::__shared_weak_count **)&v745[8];
      if (*(void *)&v745[8]) {
        goto LABEL_430;
      }
      goto LABEL_432;
    }
    long long v434 = (void *)v355[10];
    while (1)
    {
      unint64_t v437 = *(unsigned int *)(v432 + 4);
      unint64_t v438 = v437 >> 7;
      uint64_t v439 = v354[4];
      unint64_t v440 = (v354[5] - v439) >> 3;
      if (v437 >> 7 >= v440) {
        goto LABEL_354;
      }
      uint64_t v441 = *(void *)(v439 + 8 * v438);
      if (!v441) {
        goto LABEL_354;
      }
      unint64_t v442 = *(unsigned __int16 *)(v441 + 2 * (v437 & 0x7F));
      uint64_t v444 = v354[7];
      uint64_t v443 = v354[8];
      unint64_t v445 = (v443 - v444) >> 3;
      if (v445 <= v442) {
        goto LABEL_354;
      }
      uint64_t v446 = v444 + 8 * v442;
      if (v446 == v443 || *(_DWORD *)(v446 + 4) != v437) {
        goto LABEL_354;
      }
      uint64_t v448 = v357[4];
      unint64_t v449 = (v357[5] - v448) >> 3;
      if (v438 >= v449) {
        goto LABEL_354;
      }
      uint64_t v450 = *(void *)(v448 + 8 * v438);
      if (!v450) {
        goto LABEL_354;
      }
      unint64_t v451 = *(unsigned __int16 *)(v450 + 2 * (v437 & 0x7F));
      uint64_t v453 = v357[7];
      uint64_t v452 = v357[8];
      unint64_t v454 = (v452 - v453) >> 3;
      if (v454 <= v451) {
        goto LABEL_354;
      }
      uint64_t v455 = v453 + 8 * v451;
      if (v455 == v452 || *(_DWORD *)(v455 + 4) != v437) {
        goto LABEL_354;
      }
      unint64_t v457 = *(void *)v432;
      uint64_t v458 = HIDWORD(*(void *)v432);
      unint64_t v459 = *(void *)v432 >> 39;
      if (v459 < v440
        && (uint64_t v460 = *(void *)(v439 + 8 * v459)) != 0
        && (unint64_t v461 = *(unsigned __int16 *)(v460 + 2 * (HIDWORD(v457) & 0x7F)), v445 > v461)
        && ((uint64_t v462 = v444 + 8 * v461, v462 != v443) ? (v463 = *(_DWORD *)(v462 + 4) == v458) : (v463 = 0), v463))
      {
        float v464 = (char *)(v354[10] + v461);
        if (v459 >= v449) {
          goto LABEL_352;
        }
      }
      else
      {
        float v464 = (char *)v354[11];
        if (v459 >= v449) {
          goto LABEL_352;
        }
      }
      uint64_t v465 = *(void *)(v448 + 8 * v459);
      if (v465)
      {
        unint64_t v466 = *(unsigned __int16 *)(v465 + 2 * (HIDWORD(v457) & 0x7F));
        if (v454 > v466)
        {
          uint64_t v467 = v453 + 8 * v466;
          if (v467 != v452 && *(_DWORD *)(v467 + 4) == v458)
          {
            uint64_t v435 = v358;
            long long v436 = (unsigned char *)(v357[10] + v466);
            goto LABEL_353;
          }
        }
      }
LABEL_352:
      uint64_t v435 = v358;
      long long v436 = (unsigned char *)v357[11];
LABEL_353:
      md::PuckLogic::update3DPuckRenderStates(md::PuckStyleInfo const&,md::PuckStyleInfo const&,BOOL)::$_1::operator()((uint64_t *)buf, v457, *v464, v434, v436);
      uint64_t v358 = v435;
LABEL_354:
      v434 += 3;
      v432 += 8;
      if (v432 == v433) {
        goto LABEL_389;
      }
    }
  }
  if ((void *)v358 != v362) {
    goto LABEL_348;
  }
LABEL_390:
  *(void *)buf = &v735;
  *(void *)&uint8_t buf[8] = v749;
  *(void *)&buf[16] = v745;
  uint64_t v469 = v357[7];
  uint64_t v470 = v357[8];
  if (v469 != v470)
  {
    v471 = (unsigned char *)v357[10];
    while (2)
    {
      unint64_t v473 = *(unsigned int *)(v469 + 4);
      unint64_t v474 = v473 >> 7;
      uint64_t v475 = v354[4];
      unint64_t v476 = (v354[5] - v475) >> 3;
      if (v473 >> 7 >= v476) {
        goto LABEL_394;
      }
      uint64_t v477 = *(void *)(v475 + 8 * v474);
      if (!v477) {
        goto LABEL_394;
      }
      unint64_t v478 = *(unsigned __int16 *)(v477 + 2 * (v473 & 0x7F));
      uint64_t v480 = v354[7];
      uint64_t v479 = v354[8];
      unint64_t v481 = (v479 - v480) >> 3;
      if (v481 <= v478) {
        goto LABEL_394;
      }
      uint64_t v482 = v480 + 8 * v478;
      if (v482 == v479 || *(_DWORD *)(v482 + 4) != v473) {
        goto LABEL_394;
      }
      uint64_t v484 = v355[4];
      unint64_t v485 = (v355[5] - v484) >> 3;
      if (v474 >= v485) {
        goto LABEL_394;
      }
      uint64_t v486 = *(void *)(v484 + 8 * v474);
      if (!v486) {
        goto LABEL_394;
      }
      unint64_t v487 = *(unsigned __int16 *)(v486 + 2 * (v473 & 0x7F));
      uint64_t v489 = v355[7];
      uint64_t v488 = v355[8];
      unint64_t v490 = (v488 - v489) >> 3;
      if (v490 <= v487) {
        goto LABEL_394;
      }
      uint64_t v491 = v489 + 8 * v487;
      if (v491 == v488 || *(_DWORD *)(v491 + 4) != v473) {
        goto LABEL_394;
      }
      unint64_t v493 = *(void *)v469;
      uint64_t v494 = HIDWORD(*(void *)v469);
      unint64_t v495 = *(void *)v469 >> 39;
      if (v495 >= v476
        || (uint64_t v496 = *(void *)(v475 + 8 * v495)) == 0
        || (unint64_t v497 = *(unsigned __int16 *)(v496 + 2 * (HIDWORD(v493) & 0x7F)), v481 <= v497)
        || ((v498 = v480 + 8 * v497, v498 != v479) ? (BOOL v499 = *(_DWORD *)(v498 + 4) == v494) : (BOOL v499 = 0), !v499))
      {
        v500 = (char *)v354[11];
        if (v495 < v485) {
          goto LABEL_419;
        }
        goto LABEL_392;
      }
      v500 = (char *)(v354[10] + v497);
      if (v495 >= v485) {
        goto LABEL_392;
      }
LABEL_419:
      uint64_t v501 = *(void *)(v484 + 8 * v495);
      if (v501
        && (unint64_t v502 = *(unsigned __int16 *)(v501 + 2 * (HIDWORD(v493) & 0x7F)), v490 > v502)
        && ((uint64_t v503 = v489 + 8 * v502, v503 != v488) ? (v504 = *(_DWORD *)(v503 + 4) == v494) : (v504 = 0), v504))
      {
        uint64_t v472 = (void *)(v355[10] + 24 * v502);
      }
      else
      {
LABEL_392:
        uint64_t v472 = (void *)v355[11];
      }
      md::PuckLogic::update3DPuckRenderStates(md::PuckStyleInfo const&,md::PuckStyleInfo const&,BOOL)::$_1::operator()((uint64_t *)buf, v493, *v500, v472, v471);
LABEL_394:
      ++v471;
      v469 += 8;
      if (v469 == v470) {
        break;
      }
      continue;
    }
  }
  uint64_t v431 = *(std::__shared_weak_count **)&v745[8];
  if (*(void *)&v745[8])
  {
LABEL_430:
    if (!atomic_fetch_add(&v431->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v431->__on_zero_shared)(v431);
      std::__shared_weak_count::__release_weak(v431);
    }
  }
LABEL_432:
  v505 = *(std::__shared_weak_count **)&v749[8];
  uint64_t v308 = v714;
  if (*(void *)&v749[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v749[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v505->__on_zero_shared)(v505);
    std::__shared_weak_count::__release_weak(v505);
  }
LABEL_435:
  double v718 = v310;
  double v720 = v312;
  double v723 = fabs((v691 - v692) * 0.159154943);
  if (*(unsigned __int8 *)(v308 + 3776) - 4 >= 0xFFFFFFFD)
  {
    v511.f64[0] = v709;
    v511.f64[1] = v707;
    float64x2_t v512 = vsubq_f64(v511, *(float64x2_t *)&v759[8]);
    float64x2_t v513 = vmulq_f64(v512, v512);
    double v510 = sqrt(v513.f64[0] + (v708 - *(double *)v759) * (v708 - *(double *)v759) + v513.f64[1]) * 0.0000000249532021;
    double v506 = *(double *)v760;
    long long v507 = *(_OWORD *)&v760[8];
  }
  else
  {
    double v506 = *(double *)v760;
    long long v507 = *(_OWORD *)&v760[8];
    float64x2_t v508 = vsubq_f64(*(float64x2_t *)&v760[8], *(float64x2_t *)&v761[8]);
    float64x2_t v509 = vmulq_f64(v508, v508);
    double v510 = sqrt(v509.f64[0] + (*(double *)v760 - *(double *)v761) * (*(double *)v760 - *(double *)v761) + v509.f64[1]);
  }
  double v514 = v506 - *(double *)&v731;
  double v515 = 1.0
       / sqrt(v514 * v514+ (*(double *)&v507 - v710) * (*(double *)&v507 - v710)+ (*((double *)&v507 + 1) - v690) * (*((double *)&v507 + 1) - v690));
  double v516 = v699 + -(v699 - v515 * v514) * v314;
  double v517 = v698 + -(v698 - v515 * (*(double *)&v507 - v710)) * v314;
  double v518 = v697 + -(v697 - v515 * (*((double *)&v507 + 1) - v690)) * v314;
  double v519 = 1.0 / sqrt(v516 * v516 + v517 * v517 + v518 * v518);
  double v520 = v519 * v516;
  double v521 = v519 * v517;
  double v522 = v519 * v518;
  __double2 v523 = __sincos_stret(*((double *)v145 + 140) + v316 * -0.5);
  double v524 = v521 * v521 + v520 * v520;
  double v525 = sqrt(v524 + v522 * v522) + v522;
  double v526 = 1.0 / sqrt(v524 + v525 * v525);
  double v527 = -(v521 * v526);
  double v528 = v526 * v520;
  double v529 = v526 * v525;
  double v530 = v527 * v523.__cosval + v529 * (v520 * v523.__sinval) - v528 * (v522 * v523.__sinval);
  double v531 = v528 * v523.__cosval + v529 * (v521 * v523.__sinval) + v527 * (v522 * v523.__sinval);
  double v532 = v529 * (v522 * v523.__sinval) + v528 * (v520 * v523.__sinval) - v527 * (v521 * v523.__sinval);
  double v533 = -(v527 * (v520 * v523.__sinval) + v528 * (v521 * v523.__sinval) - v529 * v523.__cosval);
  double v534 = v723 * 40075017.0 / (v695 * -559.82 + 111132.92 + v694 * 1.175 + v693 * -0.0023);
  if (v696 < 0xFFFFFFFD) {
    double v534 = 1.0;
  }
  double v535 = v531 + v531;
  double v536 = (v531 + v531) * v531;
  double v537 = (v532 + v532) * v532;
  double v538 = v530 + v530;
  double v539 = (v530 + v530) * v531;
  double v540 = (v532 + v532) * v533;
  double v541 = v532 * (v530 + v530);
  double v542 = v533 * v535;
  double v543 = v533 * v535 + v541;
  double v544 = 1.0 - (v530 + v530) * v530;
  double v545 = v535 * v532;
  double v546 = v533 * v538;
  *(double *)buf = 1.0 - (v536 + v537);
  *(double *)&uint8_t buf[8] = v540 + v539;
  *((double *)&v769 + 1) = v539 - v540;
  *(double *)&long long v770 = v544 - v537;
  *(double *)&v771[1] = v543;
  *(double *)&v771[2] = v545 - v546;
  *(double *)&buf[16] = v541 - v542;
  *((double *)&v770 + 1) = v546 + v545;
  double v772 = v544 - v536;
  *(void *)&long long v769 = 0;
  v771[0] = 0;
  v773[0] = 0;
  *(_OWORD *)(a1 + 336) = v731;
  *(double *)(a1 + 352) = v690;
  *(_OWORD *)&v773[1] = v731;
  *(double *)&v773[3] = v690;
  uint64_t v774 = 0x3FF0000000000000;
  long long v751 = 0u;
  uint64_t v753 = 0;
  *(_OWORD *)v756 = 0u;
  long long v755 = 0u;
  long long v752 = 0u;
  long long v750 = 0u;
  *(_OWORD *)&v749[8] = 0u;
  *(void *)&v756[16] = 0x3FF0000000000000;
  *(double *)uint64_t v749 = v718 * v313 * v534 * (1.6 * v510) / v720;
  *(double *)&long long v751 = *(double *)v749;
  double v754 = *(double *)v749;
  gm::operator*<double,4,4,4>((double *)v745, (double *)buf, (double *)v749);
  long long v547 = *(_OWORD *)&v745[16];
  v142[5] = *(_OWORD *)v745;
  v142[6] = v547;
  uint64_t v548 = (double *)(v142 + 5);
  long long v549 = *(_OWORD *)&v745[48];
  *((_OWORD *)v548 + 2) = *(_OWORD *)&v745[32];
  *((_OWORD *)v548 + 3) = v549;
  long long v550 = v746;
  *((_OWORD *)v548 + 4) = *(_OWORD *)&v745[64];
  *((_OWORD *)v548 + 5) = v550;
  long long v551 = v748;
  *((_OWORD *)v548 + 6) = v747;
  *((_OWORD *)v548 + 7) = v551;
  unint64_t v552 = *(int8x8_t **)(a1 + 288);
  if (v552)
  {
    uint64_t v553 = (void *)gdc::Registry::storage<md::components::DynamicMeshInstance>(*(int8x8_t **)(a1 + 288));
    uint64_t v554 = gdc::Registry::storage<md::components::Material>(v552);
    uint64_t v555 = (void *)v554;
    uint64_t v557 = v553[7];
    uint64_t v556 = v553[8];
    if (*(void *)(v554 + 64) - *(void *)(v554 + 56) >= (unint64_t)(v556 - v557)) {
      uint64_t v558 = v553 + 4;
    }
    else {
      uint64_t v558 = (void *)(v554 + 32);
    }
    v721 = v558;
    uint64_t v724 = v554 + 32;
    if (v553 + 4 == v558 && v557 != v556)
    {
      v559 = (float *)(v553[10] + 288);
      while (2)
      {
        unint64_t v561 = *(unsigned int *)(v557 + 4);
        uint64_t v562 = v555[4];
        if (v561 >> 7 >= (v555[5] - v562) >> 3) {
          goto LABEL_449;
        }
        uint64_t v563 = *(void *)(v562 + 8 * (v561 >> 7));
        if (!v563) {
          goto LABEL_449;
        }
        unint64_t v564 = *(unsigned __int16 *)(v563 + 2 * (v561 & 0x7F));
        uint64_t v566 = v555[7];
        uint64_t v565 = v555[8];
        if (v564 >= (v565 - v566) >> 3) {
          goto LABEL_449;
        }
        uint64_t v567 = v566 + 8 * v564;
        if (v567 == v565 || *(_DWORD *)(v567 + 4) != v561) {
          goto LABEL_449;
        }
        if (!*(unsigned char *)(a1 + 384))
        {
          long long v569 = *(_OWORD *)(v559 - 63);
          *(void *)(a1 + 376) = *(void *)(v559 - 59);
          *(_OWORD *)(a1 + 360) = v569;
          *(unsigned char *)(a1 + 384) = 1;
        }
        float v570 = *(v559 - 61);
        float32x2_t v560 = vmaxnm_f32(vsub_f32(*(float32x2_t *)(v559 - 60), *(float32x2_t *)(v559 - 63)), 0);
        float v571 = fmaxf(*(v559 - 58) - v570, 0.0);
        if (v560.f32[0] <= v560.f32[1])
        {
          v560.i32[0] = v560.i32[1];
          if (v560.f32[1] > v571) {
            goto LABEL_448;
          }
        }
        else if (v560.f32[0] > v571)
        {
LABEL_448:
          memset(v773, 0, sizeof(v773));
          memset(v771, 0, sizeof(v771));
          long long v769 = 0u;
          long long v770 = 0u;
          *(_OWORD *)&uint8_t buf[8] = 0u;
          uint64_t v774 = 0x3FF0000000000000;
          *(double *)buf = 1.0 / v560.f32[0];
          *(double *)&long long v770 = *(double *)buf;
          double v772 = *(double *)buf;
          long long v755 = 0uLL;
          long long v752 = 0u;
          uint64_t v753 = 0;
          long long v750 = 0u;
          long long v751 = 0u;
          *(_OWORD *)&v749[8] = 0u;
          *(void *)uint64_t v749 = 0x3FF0000000000000;
          *(void *)&long long v751 = 0x3FF0000000000000;
          double v754 = 1.0;
          *(void *)&v756[16] = 0x3FF0000000000000;
          *(void *)v756 = 0;
          *(double *)&v756[8] = (float)-v570;
          gm::operator*<double,3,4,4>((double *)v734, (double *)v559 - 22, v548);
          gm::operator*<double,3,4,4>((double *)&v735, (double *)v734, (double *)buf);
          gm::operator*<double,3,4,4>((double *)v745, (double *)&v735, (double *)v749);
          *((_OWORD *)v559 - 5) = *(_OWORD *)v745;
          *((_OWORD *)v559 - 4) = *(_OWORD *)&v745[16];
          *((_OWORD *)v559 - 3) = *(_OWORD *)&v745[32];
          *((_OWORD *)v559 - 2) = *(_OWORD *)&v745[48];
          *((_OWORD *)v559 - 1) = *(_OWORD *)&v745[64];
          *(_OWORD *)v559 = v746;
LABEL_449:
          v557 += 8;
          v559 += 76;
          if (v557 == v556) {
            goto LABEL_465;
          }
          continue;
        }
        break;
      }
      v560.f32[0] = v571;
      goto LABEL_448;
    }
LABEL_465:
    if ((void *)v724 == v721)
    {
      unint64_t v573 = (unint64_t *)v555[7];
      unint64_t v572 = (uint64_t *)v555[8];
      if (v573 != (unint64_t *)v572)
      {
        while (2)
        {
          unint64_t v578 = *((unsigned int *)v573 + 1);
          uint64_t v579 = v553[4];
          unint64_t v580 = (v553[5] - v579) >> 3;
          if (v578 >> 7 >= v580
            || (uint64_t v581 = *(void *)(v579 + 8 * (v578 >> 7))) == 0
            || (unint64_t v582 = *(unsigned __int16 *)(v581 + 2 * (v578 & 0x7F)),
                uint64_t v584 = v553[7],
                uint64_t v583 = v553[8],
                unint64_t v585 = (v583 - v584) >> 3,
                v585 <= v582)
            || ((uint64_t v586 = v584 + 8 * v582, v586 != v583) ? (v587 = *(_DWORD *)(v586 + 4) == v578) : (v587 = 0),
                !v587))
          {
LABEL_477:
            if (++v573 == (unint64_t *)v572) {
              goto LABEL_466;
            }
            continue;
          }
          break;
        }
        unint64_t v588 = *v573;
        unint64_t v589 = *v573 >> 39;
        if (v589 < v580
          && (uint64_t v590 = *(void *)(v579 + 8 * v589)) != 0
          && (unint64_t v591 = *(unsigned __int16 *)(v590 + 2 * (HIDWORD(v588) & 0x7F)), v585 > v591)
          && ((v592 = HIDWORD(v588), uint64_t v593 = v584 + 8 * v591, v593 != v583)
            ? (BOOL v594 = *(_DWORD *)(v593 + 4) == v592)
            : (BOOL v594 = 0),
              v594))
        {
          uint64_t v595 = v553[10] + 304 * v591;
          if (!*(unsigned char *)(a1 + 384))
          {
LABEL_494:
            long long v596 = *(_OWORD *)(v595 + 36);
            *(void *)(a1 + 376) = *(void *)(v595 + 52);
            *(_OWORD *)(a1 + 360) = v596;
            *(unsigned char *)(a1 + 384) = 1;
          }
        }
        else
        {
          uint64_t v595 = v553[11];
          if (!*(unsigned char *)(a1 + 384)) {
            goto LABEL_494;
          }
        }
        float v597 = *(float *)(v595 + 44);
        float32x2_t v574 = vmaxnm_f32(vsub_f32(*(float32x2_t *)(v595 + 48), *(float32x2_t *)(v595 + 36)), 0);
        float v598 = fmaxf(*(float *)(v595 + 56) - v597, 0.0);
        if (v574.f32[0] <= v574.f32[1])
        {
          v574.i32[0] = v574.i32[1];
          if (v574.f32[1] <= v598) {
            goto LABEL_475;
          }
        }
        else
        {
          if (v574.f32[0] > v598) {
            goto LABEL_476;
          }
LABEL_475:
          v574.f32[0] = v598;
        }
LABEL_476:
        memset(v773, 0, sizeof(v773));
        memset(v771, 0, sizeof(v771));
        long long v769 = 0u;
        long long v770 = 0u;
        *(_OWORD *)&uint8_t buf[8] = 0u;
        uint64_t v774 = 0x3FF0000000000000;
        *(double *)buf = 1.0 / v574.f32[0];
        *(double *)&long long v770 = *(double *)buf;
        double v772 = *(double *)buf;
        long long v755 = 0uLL;
        long long v752 = 0u;
        uint64_t v753 = 0;
        long long v750 = 0u;
        long long v751 = 0u;
        *(_OWORD *)&v749[8] = 0u;
        *(void *)uint64_t v749 = 0x3FF0000000000000;
        *(void *)&long long v751 = 0x3FF0000000000000;
        double v754 = 1.0;
        *(void *)&v756[16] = 0x3FF0000000000000;
        *(void *)v756 = 0;
        *(double *)&v756[8] = (float)-v597;
        gm::operator*<double,3,4,4>((double *)v734, (double *)(v595 + 112), v548);
        gm::operator*<double,3,4,4>((double *)&v735, (double *)v734, (double *)buf);
        gm::operator*<double,3,4,4>((double *)v745, (double *)&v735, (double *)v749);
        long long v575 = *(_OWORD *)&v745[16];
        *(_OWORD *)(v595 + 208) = *(_OWORD *)v745;
        *(_OWORD *)(v595 + 224) = v575;
        long long v576 = *(_OWORD *)&v745[48];
        *(_OWORD *)(v595 + 240) = *(_OWORD *)&v745[32];
        *(_OWORD *)(v595 + 256) = v576;
        long long v577 = v746;
        *(_OWORD *)(v595 + 272) = *(_OWORD *)&v745[64];
        *(_OWORD *)(v595 + 288) = v577;
        goto LABEL_477;
      }
    }
  }
LABEL_466:
  *(_OWORD *)(v728 + 8) = *(_OWORD *)v761;
  *((void *)v728 + 3) = *(void *)&v761[16];
  *((_OWORD *)v728 + 2) = *(_OWORD *)v759;
  *((void *)v728 + 6) = *(void *)&v759[16];
LABEL_467:
  if (!v767)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    goto LABEL_585;
  }
  (*(void (**)(void *))(*v767 + 48))(v767);
  if (v767 == v766)
  {
    (*(void (**)(void *))(v766[0] + 32))(v766);
  }
  else if (v767)
  {
    (*(void (**)(void))(*v767 + 40))();
  }
}

void sub_1A1B7F0B4(_Unwind_Exception *a1)
{
}

void _ZNSt3__110__function6__funcIZN2md9PuckLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17NavigationContextENS2_17StyleLogicContextENS2_22SharedResourcesContextENS2_15RegistryContextENS2_25IdentifiedResourceContextENS2_12SceneContextENS2_20NonTiledAssetContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_11PuckContextEE3__1NS_9allocatorISR_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "PuckLogic", "", v5, 2u);
  }
}

void _ZNSt3__110__function6__funcIZN2md9PuckLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17NavigationContextENS2_17StyleLogicContextENS2_22SharedResourcesContextENS2_15RegistryContextENS2_25IdentifiedResourceContextENS2_12SceneContextENS2_20NonTiledAssetContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_11PuckContextEE3__0NS_9allocatorISR_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "PuckLogic", "", v5, 2u);
  }
}

void md::PuckLogic::update3DPuckVisibility(md::PuckLogic *this, int a2)
{
  uint64_t v2 = (int8x8_t *)*((void *)this + 36);
  if (v2)
  {
    uint64_t v5 = (void *)gdc::Registry::storage<md::components::DynamicMeshInstance>(*((int8x8_t **)this + 36));
    int8x16_t v6 = (void *)gdc::Registry::storage<md::components::Material>(v2);
    uint64_t v7 = gdc::Registry::storage<md::components::Visibility>(v2);
    uint64_t v8 = (void *)v7;
    uint64_t v9 = v7 + 32;
    uint64_t v10 = v5[7];
    uint64_t v11 = v5[8];
    if (v6[8] - v6[7] >= (unint64_t)(v11 - v10)) {
      uint64_t v12 = v5 + 4;
    }
    else {
      uint64_t v12 = v6 + 4;
    }
    if (*(void *)(v7 + 64) - *(void *)(v7 + 56) >= v12[4] - v12[3]) {
      double v13 = v12;
    }
    else {
      double v13 = (void *)(v7 + 32);
    }
    if (v5 + 4 == v13 && v10 != v11)
    {
      do
      {
        unint64_t v15 = *(unsigned int *)(v10 + 4);
        unint64_t v16 = v15 >> 7;
        uint64_t v17 = v6[4];
        if (v15 >> 7 < (v6[5] - v17) >> 3)
        {
          uint64_t v18 = *(void *)(v17 + 8 * v16);
          if (v18)
          {
            unint64_t v19 = *(unsigned __int16 *)(v18 + 2 * (v15 & 0x7F));
            uint64_t v21 = v6[7];
            uint64_t v20 = v6[8];
            if (v19 < (v20 - v21) >> 3)
            {
              uint64_t v22 = v21 + 8 * v19;
              if (v22 != v20 && *(_DWORD *)(v22 + 4) == v15)
              {
                uint64_t v24 = v8[4];
                unint64_t v25 = (v8[5] - v24) >> 3;
                if (v16 < v25)
                {
                  uint64_t v26 = *(void *)(v24 + 8 * v16);
                  if (v26)
                  {
                    unint64_t v27 = *(unsigned __int16 *)(v26 + 2 * (v15 & 0x7F));
                    uint64_t v29 = v8[7];
                    uint64_t v28 = v8[8];
                    unint64_t v30 = (v28 - v29) >> 3;
                    if (v30 > v27)
                    {
                      uint64_t v31 = v29 + 8 * v27;
                      if (v31 != v28 && *(_DWORD *)(v31 + 4) == v15)
                      {
                        if ((unint64_t v33 = *(void *)v10, v34 = *(void *)v10 >> 39, v34 < v25)
                          && (uint64_t v35 = *(void *)(v24 + 8 * v34)) != 0
                          && (unint64_t v36 = *(unsigned __int16 *)(v35 + 2 * (HIDWORD(v33) & 0x7F)), v30 > v36)
                          && ((uint64_t v37 = v29 + 8 * v36, v37 != v28)
                            ? (BOOL v38 = *(_DWORD *)(v37 + 4) == HIDWORD(v33))
                            : (BOOL v38 = 0),
                              v38))
                        {
                          long double v39 = (unsigned char *)(v8[10] + v36);
                        }
                        else
                        {
                          long double v39 = (unsigned char *)v8[11];
                        }
                        if (*v39 != a2)
                        {
                          unsigned char *v39 = a2;
                          uint64_t v90 = v33;
                          long double v40 = (void *)gdc::Registry::storage<md::components::VisibilityChanged>(*((int8x8_t **)this + 36));
                          gdc::ComponentStorageWrapper<md::components::Collapsible>::emplace(v40, v90);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        v10 += 8;
      }
      while (v10 != v11);
    }
    if (v6 + 4 == v13)
    {
      uint64_t v41 = v6[7];
      uint64_t v42 = v6[8];
      while (v41 != v42)
      {
        unint64_t v43 = *(unsigned int *)(v41 + 4);
        unint64_t v44 = v43 >> 7;
        uint64_t v45 = v5[4];
        if (v43 >> 7 < (v5[5] - v45) >> 3)
        {
          uint64_t v46 = *(void *)(v45 + 8 * v44);
          if (v46)
          {
            unint64_t v47 = *(unsigned __int16 *)(v46 + 2 * (v43 & 0x7F));
            uint64_t v49 = v5[7];
            uint64_t v48 = v5[8];
            if (v47 < (v48 - v49) >> 3)
            {
              uint64_t v50 = v49 + 8 * v47;
              if (v50 != v48 && *(_DWORD *)(v50 + 4) == v43)
              {
                uint64_t v52 = v8[4];
                unint64_t v53 = (v8[5] - v52) >> 3;
                if (v44 < v53)
                {
                  uint64_t v54 = *(void *)(v52 + 8 * v44);
                  if (v54)
                  {
                    unint64_t v55 = *(unsigned __int16 *)(v54 + 2 * (v43 & 0x7F));
                    uint64_t v57 = v8[7];
                    uint64_t v56 = v8[8];
                    unint64_t v58 = (v56 - v57) >> 3;
                    if (v58 > v55)
                    {
                      uint64_t v59 = v57 + 8 * v55;
                      if (v59 != v56 && *(_DWORD *)(v59 + 4) == v43)
                      {
                        if ((unint64_t v61 = *(void *)v41, v62 = *(void *)v41 >> 39, v62 < v53)
                          && (uint64_t v63 = *(void *)(v52 + 8 * v62)) != 0
                          && (unint64_t v64 = *(unsigned __int16 *)(v63 + 2 * (HIDWORD(v61) & 0x7F)), v58 > v64)
                          && ((uint64_t v65 = v57 + 8 * v64, v65 != v56)
                            ? (BOOL v66 = *(_DWORD *)(v65 + 4) == HIDWORD(v61))
                            : (BOOL v66 = 0),
                              v66))
                        {
                          long double v67 = (unsigned char *)(v8[10] + v64);
                        }
                        else
                        {
                          long double v67 = (unsigned char *)v8[11];
                        }
                        if (*v67 != a2)
                        {
                          *long double v67 = a2;
                          double v68 = (void *)gdc::Registry::storage<md::components::VisibilityChanged>(*((int8x8_t **)this + 36));
                          gdc::ComponentStorageWrapper<md::components::Collapsible>::emplace(v68, v61);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        v41 += 8;
      }
    }
    if ((void *)v9 == v13)
    {
      uint64_t v69 = v8[7];
      uint64_t v70 = v8[8];
      if (v69 != v70)
      {
        double v71 = (unsigned char *)v8[10];
        do
        {
          unint64_t v72 = *(unsigned int *)(v69 + 4);
          unint64_t v73 = v72 >> 7;
          uint64_t v74 = v5[4];
          if (v72 >> 7 < (v5[5] - v74) >> 3)
          {
            uint64_t v75 = *(void *)(v74 + 8 * v73);
            if (v75)
            {
              unint64_t v76 = *(unsigned __int16 *)(v75 + 2 * (v72 & 0x7F));
              uint64_t v78 = v5[7];
              uint64_t v77 = v5[8];
              if (v76 < (v77 - v78) >> 3)
              {
                uint64_t v79 = v78 + 8 * v76;
                if (v79 != v77 && *(_DWORD *)(v79 + 4) == v72)
                {
                  uint64_t v81 = v6[4];
                  if (v73 < (v6[5] - v81) >> 3)
                  {
                    uint64_t v82 = *(void *)(v81 + 8 * v73);
                    if (v82)
                    {
                      unint64_t v83 = *(unsigned __int16 *)(v82 + 2 * (v72 & 0x7F));
                      uint64_t v85 = v6[7];
                      uint64_t v84 = v6[8];
                      if (v83 < (v84 - v85) >> 3)
                      {
                        uint64_t v86 = v85 + 8 * v83;
                        if (v86 != v84 && *(_DWORD *)(v86 + 4) == v72 && *v71 != a2)
                        {
                          uint64_t v88 = *(void *)v69;
                          *double v71 = a2;
                          uint8x8_t v89 = (void *)gdc::Registry::storage<md::components::VisibilityChanged>(*((int8x8_t **)this + 36));
                          gdc::ComponentStorageWrapper<md::components::Collapsible>::emplace(v89, v88);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          ++v71;
          v69 += 8;
        }
        while (v69 != v70);
      }
    }
  }
}

#error "1A1B7F928: too big function (funcsize=0)"

void sub_1A1BA7784(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,md::LayoutContext **a23,md::LayoutContext **a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t *a30,uint64_t *a31,uint64_t a32,uint64_t a33,void *a34,uint64_t *a35,uint64_t *a36,uint64_t a37,uint64_t a38,uint64_t *a39,uint64_t *a40,void *a41,uint64_t a42,id *a43,ecs2::Flow *a44)
{
  STACK[0x290] = a1;
  unint64_t v47 = (void **)*v44;
  if (*v44)
  {
    do
    {
      long double v51 = (void **)*v47;
      uint64_t v52 = *((unsigned int *)v47 + 8);
      if (v52 != -1) {
        ((void (*)(unint64_t *, void **))off_1EF58FBE8[v52])(&STACK[0x9F0], v47 + 3);
      }
      operator delete(v47);
      unint64_t v47 = v51;
    }
    while (v51);
  }
  uint64_t v48 = *v45;
  *uint64_t v45 = 0;
  if (v48) {
    operator delete(v48);
  }
  uint64_t v49 = (void *)STACK[0x3A0];

  MEMORY[0x1A6239270](v45, 0x10A0C408EF24B1CLL);
  unint64_t v50 = STACK[0x390];
  *(void *)unint64_t v50 = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v50 + 104));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v50 + 80));

  MEMORY[0x1A6239270](v50, 0x10F1C4090BBBB8ELL);
  unint64_t v53 = (void *)STACK[0x4E0];
  if (STACK[0x4E0])
  {
    STACK[0x4E8] = (unint64_t)v53;
    operator delete(v53);
  }

  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)&STACK[0x9D0]);
  md::Monitorable<md::ConfigValue<GEOConfigKeyInteger,int>>::~Monitorable(a25);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(a26);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(a27);
  std::unique_ptr<md::HomeQueueScheduler>::~unique_ptr[abi:nn180100](a40);
  uint64_t v54 = *(void *)(STACK[0x3C0] + 4528);
  *(void *)(STACK[0x3C0] + 4528) = 0;
  if (v54) {
    (*(void (**)(uint64_t))(*(void *)v54 + 8))(v54);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](STACK[0x370]);
  uint64_t v55 = *(void *)(STACK[0x3C0] + 4504);
  *(void *)(STACK[0x3C0] + 4504) = 0;
  if (v55) {
    (*(void (**)(uint64_t))(*(void *)v55 + 8))(v55);
  }
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(a28);
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(a29);
  uint64_t v56 = STACK[0x3C0] + 1360;
  uint64_t v57 = *(void *)(STACK[0x3C0] + 4336);
  *(void *)(STACK[0x3C0] + 4336) = 0;
  if (v57) {
    (*(void (**)(uint64_t))(*(void *)v57 + 8))(v57);
  }
  unint64_t v58 = *(std::__shared_weak_count **)(STACK[0x3C0] + 1384);
  if (v58) {
    std::__shared_weak_count::__release_weak(v58);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v56);

  unint64_t v59 = STACK[0x3C0];
  uint64_t v60 = STACK[0x3C0] + 1144;
  unint64_t v61 = (uint64_t *)(STACK[0x3C0] + 1184);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a12);
  std::unique_ptr<md::DaVinciTransitionManager>::~unique_ptr[abi:nn180100](a39);
  uint64_t v62 = *(void *)(v59 + 1192);
  *(void *)(v59 + 1192) = 0;
  if (v62) {
    (*(void (**)(uint64_t))(*(void *)v62 + 8))(v62);
  }
  uint64_t v63 = *v61;
  uint64_t *v61 = 0;
  if (v63) {
    (*(void (**)(uint64_t))(*(void *)v63 + 8))(v63);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v60);
  uint64_t v64 = *(void *)(STACK[0x3C0] + 1136);
  *(void *)(STACK[0x3C0] + 1136) = 0;
  if (v64) {
    (*(void (**)(uint64_t))(*(void *)v64 + 8))(v64);
  }
  uint64_t v65 = *(void *)(STACK[0x3C0] + 1128);
  *(void *)(STACK[0x3C0] + 1128) = 0;
  if (v65) {
    std::default_delete<md::MapEngineSettings>::operator()[abi:nn180100](v65);
  }
  uint64_t v66 = *(void *)STACK[0x3B8];
  *(void *)STACK[0x3B8] = 0;
  if (v66) {
    (*(void (**)(uint64_t))(*(void *)v66 + 8))(v66);
  }
  unint64_t v67 = STACK[0x3C0];
  *(void *)(v67 + 1096) = a13;

  unint64_t v68 = STACK[0x3C0];
  uint64_t v69 = (id *)(STACK[0x3C0] + 848);
  std::unique_ptr<md::LayoutContext>::~unique_ptr[abi:nn180100](a23);
  std::unique_ptr<md::LayoutContext>::~unique_ptr[abi:nn180100](a24);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a32);
  std::unique_ptr<md::ARContext>::~unique_ptr[abi:nn180100](a30);
  ggl::Loader::~Loader((ggl::Loader *)(v68 + 1048));
  std::unique_ptr<gdc::Context>::~unique_ptr[abi:nn180100](a31);
  std::unique_ptr<md::MapDataAccess>::~unique_ptr[abi:nn180100](a35);
  std::unique_ptr<md::World>::~unique_ptr[abi:nn180100]((md::World **)STACK[0x368]);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a33);
  uint64_t v70 = *(void *)(v68 + 864);
  *(void *)(v68 + 864) = 0;
  if (v70) {
    (*(void (**)(uint64_t))(*(void *)v70 + 8))(v70);
  }
  uint64_t v71 = *a36;
  *a36 = 0;
  if (v71) {
    (*(void (**)(uint64_t))(*(void *)v71 + 8))(v71);
  }
  objc_destroyWeak(v69);

  ecs2::Flow::~Flow(a44);
  gdc::Registry::~Registry((gdc::Registry *)STACK[0x280]);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a42);
  uint64_t v72 = *(void *)STACK[0x258];
  *(void *)STACK[0x258] = 0;
  if (v72) {
    MEMORY[0x1A6239270](v72, 0x20C4093837F09);
  }
  uint64_t v73 = *(void *)(STACK[0x3C0] + 104);
  *(void *)(STACK[0x3C0] + 104) = 0;
  if (v73) {
    (*(void (**)(uint64_t))(*(void *)v73 + 8))(v73);
  }
  uint64_t v74 = *a17;
  *a17 = 0;
  if (v74) {
    (*(void (**)(uint64_t))(*(void *)v74 + 8))(v74);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a16);
  *a14 = a15;

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](STACK[0x288]);
  _Unwind_Resume((_Unwind_Exception *)STACK[0x290]);
}

char *std::__hash_table<std::__hash_value_type<gdc::TypeInfo,std::unordered_set<gdc::tf::Task>>,std::__unordered_map_hasher<gdc::TypeInfo,std::__hash_value_type<gdc::TypeInfo,std::unordered_set<gdc::tf::Task>>,std::hash<gdc::TypeInfo>,std::equal_to<gdc::TypeInfo>,true>,std::__unordered_map_equal<gdc::TypeInfo,std::__hash_value_type<gdc::TypeInfo,std::unordered_set<gdc::tf::Task>>,std::equal_to<gdc::TypeInfo>,std::hash<gdc::TypeInfo>,true>,std::allocator<std::__hash_value_type<gdc::TypeInfo,std::unordered_set<gdc::tf::Task>>>>::__emplace_unique_key_args<gdc::TypeInfo,std::piecewise_construct_t const&,std::tuple<gdc::TypeInfo const&>,std::tuple<>>(float *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = (char *)*v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = *((void *)v10 + 1);
            if (v12 == a2)
            {
              if (*((void *)v10 + 2) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = *(char **)v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = *((void *)v10 + 1);
          if (v11 == a2)
          {
            if (*((void *)v10 + 2) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = *(char **)v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v10 = (char *)operator new(0x50uLL);
  *(void *)uint64_t v10 = 0;
  *((void *)v10 + 1) = a2;
  *((_OWORD *)v10 + 1) = *(_OWORD *)a3;
  *((void *)v10 + 4) = *(void *)(a3 + 16);
  *(_OWORD *)(v10 + 40) = 0u;
  *(_OWORD *)(v10 + 56) = 0u;
  *((_DWORD *)v10 + 18) = 1065353216;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (prime <= v7)
    {
      if (prime >= v7) {
        goto LABEL_59;
      }
      unint64_t v30 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
      {
        unint64_t v30 = std::__next_prime(v30);
      }
      else
      {
        uint64_t v32 = 1 << -(char)__clz(v30 - 1);
        if (v30 >= 2) {
          unint64_t v30 = v32;
        }
      }
      if (prime <= v30) {
        size_t prime = v30;
      }
      if (prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
LABEL_59:
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= a2) {
            unint64_t v3 = a2 % v7;
          }
          else {
            unint64_t v3 = a2;
          }
        }
        else
        {
          unint64_t v3 = (v7 - 1) & a2;
        }
        goto LABEL_72;
      }
      if (!prime)
      {
        long double v40 = *(void **)a1;
        *(void *)a1 = 0;
        if (v40) {
          operator delete(v40);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_59;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v19 = operator new(8 * prime);
    uint64_t v20 = *(void **)a1;
    *(void *)a1 = v19;
    if (v20) {
      operator delete(v20);
    }
    uint64_t v21 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v21++) = 0;
    while (prime != v21);
    BOOL v23 = (uint64_t *)(a1 + 4);
    uint64_t v22 = (void *)*((void *)a1 + 2);
    if (!v22)
    {
LABEL_58:
      unint64_t v7 = prime;
      goto LABEL_59;
    }
    size_t v24 = v22[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*(void *)a1 + 8 * v26) = v23;
      for (uint64_t i = (void *)*v22; *v22; uint64_t i = (void *)*v22)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          uint64_t v22 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v28))
        {
          *uint64_t v22 = *i;
          uint64_t v29 = 8 * v28;
          void *i = **(void **)(*(void *)a1 + v29);
          **(void **)(*(void *)a1 + v29) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v28) = v22;
          uint64_t v22 = i;
          size_t v26 = v28;
        }
      }
      goto LABEL_58;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v24) = v23;
    unint64_t v33 = (void *)*v22;
    if (!*v22) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*(void *)a1 + 8 * v35))
        {
          *(void *)(*(void *)a1 + 8 * v35) = v22;
          goto LABEL_63;
        }
        *uint64_t v22 = *v33;
        uint64_t v34 = 8 * v35;
        *unint64_t v33 = **(void **)(*(void *)a1 + v34);
        **(void **)(*(void *)a1 + v34) = v33;
        unint64_t v33 = v22;
      }
      size_t v35 = v24;
LABEL_63:
      uint64_t v22 = v33;
      unint64_t v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  unint64_t v36 = *(void **)a1;
  uint64_t v37 = *(void **)(*(void *)a1 + 8 * v3);
  if (v37)
  {
    *(void *)uint64_t v10 = *v37;
LABEL_80:
    *uint64_t v37 = v10;
    goto LABEL_81;
  }
  *(void *)uint64_t v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v36[v3] = a1 + 4;
  if (*(void *)v10)
  {
    unint64_t v38 = *(void *)(*(void *)v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    uint64_t v37 = (void *)(*(void *)a1 + 8 * v38);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
  return v10;
}

void std::__hash_table<altitude::Tile *,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,std::allocator<altitude::Tile *>>::__emplace_unique_key_args<altitude::Tile *,altitude::Tile * const&>(float *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = v7 ^ (v7 >> 47);
  unint64_t v9 = 0x9DDFEA08EB382D69 * v8;
  unint64_t v10 = *((void *)a1 + 1);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * v8;
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
    }
    else
    {
      unint64_t v3 = v9 & (v10 - 1);
    }
    uint64_t v12 = *(void **)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      float v13 = (void *)*v12;
      if (v13)
      {
        if (v11.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v15 = v13[1];
            if (v15 == v9)
            {
              if (v13[2] == a2) {
                return;
              }
            }
            else if ((v15 & (v10 - 1)) != v3)
            {
              goto LABEL_22;
            }
            float v13 = (void *)*v13;
            if (!v13) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v9)
          {
            if (v13[2] == a2) {
              return;
            }
          }
          else
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
            if (v14 != v3) {
              break;
            }
          }
          float v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_22:
  unint64_t v16 = operator new(0x18uLL);
  *unint64_t v16 = 0;
  v16[1] = v9;
  v16[2] = a3;
  float v17 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v18 = a1[8];
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t prime = v21;
    }
    else {
      size_t prime = v20;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v10 = *((void *)a1 + 1);
    }
    if (prime <= v10)
    {
      if (prime >= v10) {
        goto LABEL_59;
      }
      unint64_t v34 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v10 < 3 || (uint8x8_t v35 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v35.i16[0] = vaddlv_u8(v35), v35.u32[0] > 1uLL))
      {
        unint64_t v34 = std::__next_prime(v34);
      }
      else
      {
        uint64_t v36 = 1 << -(char)__clz(v34 - 1);
        if (v34 >= 2) {
          unint64_t v34 = v36;
        }
      }
      if (prime <= v34) {
        size_t prime = v34;
      }
      if (prime >= v10)
      {
        unint64_t v10 = *((void *)a1 + 1);
LABEL_59:
        if ((v10 & (v10 - 1)) != 0)
        {
          if (v9 >= v10) {
            unint64_t v3 = v9 % v10;
          }
          else {
            unint64_t v3 = v9;
          }
        }
        else
        {
          unint64_t v3 = (v10 - 1) & v9;
        }
        goto LABEL_72;
      }
      if (!prime)
      {
        unint64_t v44 = *(void **)a1;
        *(void *)a1 = 0;
        if (v44) {
          operator delete(v44);
        }
        unint64_t v10 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_59;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    BOOL v23 = operator new(8 * prime);
    size_t v24 = *(void **)a1;
    *(void *)a1 = v23;
    if (v24) {
      operator delete(v24);
    }
    uint64_t v25 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v25++) = 0;
    while (prime != v25);
    unint64_t v27 = (uint64_t *)(a1 + 4);
    size_t v26 = (void *)*((void *)a1 + 2);
    if (!v26)
    {
LABEL_58:
      unint64_t v10 = prime;
      goto LABEL_59;
    }
    size_t v28 = v26[1];
    size_t v29 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v30 = v28 & v29;
      *(void *)(*(void *)a1 + 8 * v30) = v27;
      for (uint64_t i = (void *)*v26; *v26; uint64_t i = (void *)*v26)
      {
        size_t v32 = i[1] & v29;
        if (v32 == v30)
        {
          size_t v26 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v32))
        {
          *size_t v26 = *i;
          uint64_t v33 = 8 * v32;
          void *i = **(void **)(*(void *)a1 + v33);
          **(void **)(*(void *)a1 + v33) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v32) = v26;
          size_t v26 = i;
          size_t v30 = v32;
        }
      }
      goto LABEL_58;
    }
    if (v28 >= prime) {
      v28 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v28) = v27;
    uint64_t v37 = (void *)*v26;
    if (!*v26) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v39 = v37[1];
      if (v39 >= prime) {
        v39 %= prime;
      }
      if (v39 != v28)
      {
        if (!*(void *)(*(void *)a1 + 8 * v39))
        {
          *(void *)(*(void *)a1 + 8 * v39) = v26;
          goto LABEL_63;
        }
        *size_t v26 = *v37;
        uint64_t v38 = 8 * v39;
        *uint64_t v37 = **(void **)(*(void *)a1 + v38);
        **(void **)(*(void *)a1 + v38) = v37;
        uint64_t v37 = v26;
      }
      size_t v39 = v28;
LABEL_63:
      size_t v26 = v37;
      uint64_t v37 = (void *)*v37;
      size_t v28 = v39;
      if (!v37) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  long double v40 = *(void **)a1;
  uint64_t v41 = *(void **)(*(void *)a1 + 8 * v3);
  if (v41)
  {
    *unint64_t v16 = *v41;
LABEL_80:
    *uint64_t v41 = v16;
    goto LABEL_81;
  }
  uint64_t v42 = *((void *)a1 + 2);
  *unint64_t v16 = v42;
  *((void *)a1 + 2) = v16;
  v40[v3] = a1 + 4;
  if (v42)
  {
    unint64_t v43 = *(void *)(v42 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v43 >= v10) {
        v43 %= v10;
      }
    }
    else
    {
      v43 &= v10 - 1;
    }
    uint64_t v41 = (void *)(*(void *)a1 + 8 * v43);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
}

void ecs2::DebugTasks::~DebugTasks(ecs2::DebugTasks *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    unint64_t v3 = (void *)*((void *)this + 4);
    os_signpost_id_t v4 = (void *)*((void *)this + 3);
    if (v3 != v2)
    {
      uint64_t v5 = v3 - 4;
      unint64_t v6 = v3 - 4;
      do
      {
        unint64_t v8 = (void *)v6[3];
        if (v6 == v8)
        {
          (*(void (**)(void *))(*v6 + 32))(v6);
        }
        else if (v8)
        {
          (*(void (**)(void *))(*v8 + 40))(v8);
        }
        v5 -= 4;
        BOOL v7 = v6 == v2;
        v6 -= 4;
      }
      while (!v7);
      os_signpost_id_t v4 = (void *)*((void *)this + 3);
    }
    *((void *)this + 4) = v2;
    operator delete(v4);
  }
  unint64_t v9 = *(void **)this;
  if (*(void *)this)
  {
    unint64_t v10 = (void *)*((void *)this + 1);
    uint8x8_t v11 = *(void **)this;
    if (v10 != v9)
    {
      uint64_t v12 = v10 - 4;
      float v13 = v10 - 4;
      do
      {
        unint64_t v14 = (void *)v13[3];
        if (v13 == v14)
        {
          (*(void (**)(void *))(*v13 + 32))(v13);
        }
        else if (v14)
        {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        v12 -= 4;
        BOOL v7 = v13 == v9;
        v13 -= 4;
      }
      while (!v7);
      uint8x8_t v11 = *(void **)this;
    }
    *((void *)this + 1) = v9;
    operator delete(v11);
  }
}

ecs2::DebugTasks *ecs2::DebugTasks::DebugTasks(ecs2::DebugTasks *this, const ecs2::DebugTasks *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  os_signpost_id_t v4 = *(void **)a2;
  uint64_t v5 = (void *)*((void *)a2 + 1);
  int64_t v6 = (int64_t)v5 - *(void *)a2;
  if (v5 != *(void **)a2)
  {
    if (v6 < 0) {
      goto LABEL_22;
    }
    uint64_t v7 = v6 >> 5;
    unint64_t v8 = operator new(v6);
    *(void *)this = v8;
    *((void *)this + 1) = v8;
    *((void *)this + 2) = &v8[4 * v7];
    unint64_t v9 = v4;
    do
    {
      unint64_t v10 = (void *)v9[3];
      if (v10)
      {
        if (v9 == v10)
        {
          v8[3] = v8;
          (*(void (**)(void *, void *))(*v9 + 24))(v9, v8);
        }
        else
        {
          v8[3] = (*(uint64_t (**)(void *))(*v10 + 16))(v10);
        }
      }
      else
      {
        v8[3] = 0;
      }
      v9 += 4;
      v8 += 4;
      v4 += 4;
    }
    while (v9 != v5);
    *((void *)this + 1) = v8;
  }
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  uint8x8_t v11 = (char *)*((void *)a2 + 3);
  uint64_t v12 = (char *)*((void *)a2 + 4);
  int64_t v13 = v12 - v11;
  if (v12 == v11) {
    return this;
  }
  if (v13 < 0) {
LABEL_22:
  }
    abort();
  uint64_t v14 = v13 >> 5;
  uint64_t v15 = operator new(v13);
  *((void *)this + 3) = v15;
  *((void *)this + 4) = v15;
  *((void *)this + 5) = &v15[4 * v14];
  unint64_t v16 = v11;
  do
  {
    float v17 = (char *)*((void *)v16 + 3);
    if (v17)
    {
      if (v16 == v17)
      {
        v15[3] = v15;
        (*(void (**)(char *, void *))(*(void *)v16 + 24))(v16, v15);
      }
      else
      {
        v15[3] = (*(uint64_t (**)(char *))(*(void *)v17 + 16))(v17);
      }
    }
    else
    {
      v15[3] = 0;
    }
    v16 += 32;
    v15 += 4;
    v11 += 32;
  }
  while (v16 != v12);
  *((void *)this + 4) = v15;
  return this;
}

uint64_t gdc::Registry::storage<ecs2::GraphHandle>(int8x8_t *a1)
{
  uint64_t v10 = 0x15E974F8019C956ALL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x15E974F8019C956ALL;
    if (*(void *)&v1 <= 0x15E974F8019C956AuLL) {
      uint64_t v3 = 0x15E974F8019C956AuLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x15E974F8019C956ALL;
  }
  os_signpost_id_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x15E974F8019C956ALL)
      {
        if (v5[2] == 0x15E974F8019C956ALL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x15E974F8019C956ALL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x15E974F8019C956ALL) {
    goto LABEL_11;
  }
  return v5[3];
}

uint64_t gdc::Registry::storage<ecs2::ExecutionMetadata>(int8x8_t *a1)
{
  uint64_t v10 = 0x6106C25540188653;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x6106C25540188653;
    if (*(void *)&v1 <= 0x6106C25540188653uLL) {
      uint64_t v3 = 0x6106C25540188653uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x6106C25540188653;
  }
  os_signpost_id_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x6106C25540188653)
      {
        if (v5[2] == 0x6106C25540188653) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x6106C25540188653) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x6106C25540188653) {
    goto LABEL_11;
  }
  return v5[3];
}

uint64_t geo::IntrusiveNodeGraph<gdc::tf::TaskData>::emplace<std::in_place_type_t<gdc::tf::TaskData::StaticModule>,gdc::tf::Taskflow &>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  uint64_t v6 = *(void *)(v4 + 40);
  if (!v6)
  {
    geo::Pool<geo::IntrusiveNode<gdc::tf::TaskData>>::allocateSlab(*(uint64_t ***)(a1 + 24));
    uint64_t v6 = *(void *)(v4 + 40);
  }
  *(void *)(v4 + 40) = *(void *)v6;
  *(void *)uint64_t v6 = a2 + 56;
  *(_DWORD *)(v6 + 64) = 3;
  *(unsigned char *)(v6 + 95) = 0;
  *(unsigned char *)(v6 + 72) = 0;
  *(void *)(v6 + 96) = v5;
  *(_OWORD *)(v6 + 104) = 0u;
  *(_OWORD *)(v6 + 120) = 0u;
  *(_OWORD *)(v6 + 136) = 0u;
  uint64_t v8 = *(void **)(a1 + 8);
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v8 >= v7)
  {
    uint64_t v10 = *(unsigned char **)a1;
    uint64_t v11 = (uint64_t)v8 - *(void *)a1;
    uint64_t v12 = v11 >> 3;
    unint64_t v13 = (v11 >> 3) + 1;
    if (v13 >> 61) {
      abort();
    }
    uint64_t v14 = v7 - (void)v10;
    if (v14 >> 2 > v13) {
      unint64_t v13 = v14 >> 2;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15)
    {
      if (v15 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v16 = operator new(8 * v15);
    }
    else
    {
      unint64_t v16 = 0;
    }
    float v17 = &v16[8 * v12];
    float v18 = &v16[8 * v15];
    *float v17 = v6;
    unint64_t v9 = v17 + 1;
    if (v8 == (void *)v10)
    {
      uint64_t v10 = v8;
    }
    else
    {
      unint64_t v19 = (char *)v8 - v10 - 8;
      if (v19 < 0x58) {
        goto LABEL_31;
      }
      if ((unint64_t)((char *)v8 - v16 - v11) < 0x20) {
        goto LABEL_31;
      }
      uint64_t v20 = (v19 >> 3) + 1;
      unint64_t v21 = &v16[8 * v12 - 16];
      uint64_t v22 = (long long *)(v8 - 2);
      uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v24 = *v22;
        *(v21 - 1) = *(v22 - 1);
        *unint64_t v21 = v24;
        v21 -= 2;
        v22 -= 2;
        v23 -= 4;
      }
      while (v23);
      v17 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
      v8 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
      if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_31:
        do
        {
          uint64_t v25 = *--v8;
          *--float v17 = v25;
        }
        while (v8 != (void *)v10);
        uint64_t v10 = *(unsigned char **)a1;
      }
    }
    *(void *)a1 = v17;
    *(void *)(a1 + 8) = v9;
    *(void *)(a1 + 16) = v18;
    if (v10) {
      operator delete(v10);
    }
  }
  else
  {
    *uint64_t v8 = v6;
    unint64_t v9 = v8 + 1;
  }
  *(void *)(a1 + 8) = v9;
  return *(v9 - 1);
}

void geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>>::emplace<md::MapEngineSetting&,int>(unsigned __int8 **a1, unsigned __int8 a2, int a3)
{
  uint64_t v5 = *a1;
  uint64_t v6 = a1[1];
  unint64_t v7 = *a1;
  if (*a1 != v6)
  {
    unint64_t v7 = *a1;
    while (*v7 != a2)
    {
      v7 += 16;
      if (v7 == v6) {
        goto LABEL_7;
      }
    }
  }
  if (v7 == v6)
  {
LABEL_7:
    uint64_t v8 = a3;
    unint64_t v9 = a1[2];
    if (v6 >= v9)
    {
      uint64_t v11 = (v6 - v5) >> 4;
      unint64_t v12 = v11 + 1;
      if ((unint64_t)(v11 + 1) >> 60) {
        abort();
      }
      uint64_t v13 = v9 - v5;
      if (v13 >> 3 > v12) {
        unint64_t v12 = v13 >> 3;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        if (v14 >> 60) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v15 = (char *)operator new(16 * v14);
      }
      else
      {
        unint64_t v15 = 0;
      }
      unint64_t v16 = &v15[16 * v11];
      *unint64_t v16 = a2;
      *((void *)v16 + 1) = v8;
      uint64_t v10 = (unsigned __int8 *)(v16 + 16);
      if (v5 != v6)
      {
        do
        {
          *((_OWORD *)v16 - 1) = *((_OWORD *)v6 - 1);
          v16 -= 16;
          v6 -= 16;
        }
        while (v6 != v5);
        uint64_t v5 = *a1;
      }
      *a1 = (unsigned __int8 *)v16;
      a1[1] = v10;
      a1[2] = (unsigned __int8 *)&v15[16 * v14];
      if (v5) {
        operator delete(v5);
      }
    }
    else
    {
      unsigned __int8 *v6 = a2;
      *((void *)v6 + 1) = a3;
      uint64_t v10 = v6 + 16;
    }
    a1[1] = v10;
  }
}

void std::__format::__output_buffer<char>::__output_buffer[abi:nn180100]<std::__format::__format_buffer<std::back_insert_iterator<std::string>,char>>(char *,unsigned long,std::__format::__format_buffer<std::back_insert_iterator<std::string>,char> *)::{lambda(char *,unsigned long,void *)#1}::__invoke(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = (char *)a1;
  unint64_t v5 = *(void *)(a3 + 296);
  LODWORD(v6) = *(char *)(v5 + 23);
  if ((v6 & 0x80000000) != 0)
  {
    if (!a2) {
      return;
    }
    uint64_t v8 = (char *)(a1 + a2);
    size_t v9 = *(void *)(v5 + 8);
    if (*(void *)v5 > a1 || *(void *)v5 + *(void *)(v5 + 8) + 1 <= a1)
    {
      size_t v7 = *(void *)(v5 + 8);
      unint64_t v14 = *(void *)(v5 + 16);
      uint64_t v15 = v14 & 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v12 = (v14 & 0x7FFFFFFFFFFFFFFFLL) - 1;
      if (v12 - v7 < a2)
      {
        unint64_t v11 = v7 + a2;
        if (0x7FFFFFFFFFFFFFF8 - v15 < v7 + a2 - v12) {
          goto LABEL_133;
        }
        unsigned int __src = *(char **)v5;
        if (v12 >= 0x3FFFFFFFFFFFFFF3)
        {
          size_t v17 = 0x7FFFFFFFFFFFFFF7;
LABEL_25:
          float v18 = (char *)operator new(v17);
          unint64_t v19 = v18;
          if (v9) {
            memmove(v18, __src, v9);
          }
          if (v7 != v9) {
            memmove(&v19[v9 + a2], &__src[v9], v7 - v9);
          }
          if (v12 != 22) {
            operator delete(__src);
          }
          *(void *)unint64_t v5 = v19;
          *(void *)(v5 + 16) = v17 | 0x8000000000000000;
          size_t v20 = v7 + a2;
          goto LABEL_89;
        }
LABEL_18:
        if (v11 <= 2 * v12) {
          unint64_t v11 = 2 * v12;
        }
        uint64_t v16 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v11 | 7) != 0x17) {
          uint64_t v16 = v11 | 7;
        }
        if (v11 >= 0x17) {
          size_t v17 = v16 + 1;
        }
        else {
          size_t v17 = 23;
        }
        goto LABEL_25;
      }
      unint64_t v6 = HIBYTE(v14);
      unint64_t v19 = *(char **)v5;
LABEL_85:
      size_t v46 = v9;
      if (v7 != v9)
      {
        memmove(&v19[v9 + a2], &v19[v9], v7 - v9);
        LOBYTE(v6) = *(unsigned char *)(v5 + 23);
        size_t v46 = v7;
      }
      size_t v20 = v46 + a2;
      if ((v6 & 0x80) == 0)
      {
        *(unsigned char *)(v5 + 23) = v20 & 0x7F;
        goto LABEL_90;
      }
LABEL_89:
      *(void *)(v5 + 8) = v20;
LABEL_90:
      v19[v20] = 0;
      unint64_t v47 = &v19[v9];
      if (a2 < 8)
      {
        uint64_t v48 = v4;
        goto LABEL_126;
      }
      if ((unint64_t)(&v19[v9] - v4) < 0x20)
      {
        uint64_t v48 = v4;
        goto LABEL_126;
      }
      if (a2 >= 0x20)
      {
        unint64_t v49 = a2 & 0xFFFFFFFFFFFFFFE0;
        uint64_t v54 = &v19[v9 + 16];
        uint64_t v55 = (long long *)(v4 + 16);
        unint64_t v56 = a2 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v57 = *v55;
          *((_OWORD *)v54 - 1) = *(v55 - 1);
          *(_OWORD *)uint64_t v54 = v57;
          v54 += 32;
          v55 += 2;
          v56 -= 32;
        }
        while (v56);
        if (v49 == a2) {
          return;
        }
        if ((a2 & 0x18) == 0)
        {
          v47 += v49;
          uint64_t v48 = &v4[v49];
          goto LABEL_126;
        }
      }
      else
      {
        unint64_t v49 = 0;
      }
      unint64_t v58 = a2 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v48 = &v4[a2 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v59 = v49 - (a2 & 0xFFFFFFFFFFFFFFF8);
      uint64_t v60 = &v19[v9 + v49];
      unint64_t v61 = (uint64_t *)&v4[v49];
      do
      {
        uint64_t v62 = *v61++;
        *(void *)uint64_t v60 = v62;
        v60 += 8;
        v59 += 8;
      }
      while (v59);
      if (v58 == a2) {
        return;
      }
      v47 += v58;
      do
      {
LABEL_126:
        char v72 = *v48++;
        *v47++ = v72;
      }
      while (v48 != v8);
      return;
    }
  }
  else
  {
    if (!a2) {
      return;
    }
    size_t v7 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = (char *)(a1 + a2);
    size_t v9 = v7;
    if (v5 > a1 || v5 + *(unsigned __int8 *)(v5 + 23) + 1 <= a1)
    {
      if (22 - v7 < a2)
      {
        unint64_t v11 = v7 + a2;
        if (v7 + a2 - 0x7FFFFFFFFFFFFFF8 < 0x800000000000001ELL) {
          goto LABEL_133;
        }
        unint64_t v12 = 22;
        unsigned int __src = *(char **)(a3 + 296);
        goto LABEL_18;
      }
      unint64_t v19 = *(char **)(a3 + 296);
      goto LABEL_85;
    }
  }
  __srca = (char *)v9;
  __p = 0;
  size_t v77 = 0;
  int64_t v78 = 0;
  do
  {
    char v24 = *v4;
    if ((SHIBYTE(v78) & 0x80000000) == 0)
    {
      if (HIBYTE(v78) != 22)
      {
        size_t v21 = HIBYTE(v78);
        HIBYTE(v78) = (HIBYTE(v78) + 1) & 0x7F;
        p_p = (char *)&__p;
        goto LABEL_34;
      }
      uint64_t v25 = &__p;
      size_t v21 = 22;
LABEL_41:
      if (v21 + 1 > 2 * v21) {
        unint64_t v27 = v21 + 1;
      }
      else {
        unint64_t v27 = 2 * v21;
      }
      uint64_t v28 = (v27 & 0x7FFFFFFFFFFFFFF8) + 8;
      if ((v27 | 7) != 0x17) {
        uint64_t v28 = v27 | 7;
      }
      if (v27 >= 0x17) {
        size_t v26 = v28 + 1;
      }
      else {
        size_t v26 = 23;
      }
LABEL_49:
      size_t v29 = (char *)operator new(v26);
      p_p = v29;
      if (!v21 || (memmove(v29, v25, v21), v21 != 22)) {
        operator delete(v25);
      }
      __p = p_p;
      int64_t v78 = v26 | 0x8000000000000000;
      goto LABEL_54;
    }
    size_t v21 = (v78 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v77 == v21)
    {
      if ((v78 & 0x7FFFFFFFFFFFFFFFLL) == 0x7FFFFFFFFFFFFFF8) {
        goto LABEL_133;
      }
      uint64_t v25 = __p;
      size_t v26 = 0x7FFFFFFFFFFFFFF7;
      if (v21 >= 0x3FFFFFFFFFFFFFF3) {
        goto LABEL_49;
      }
      goto LABEL_41;
    }
    p_p = (char *)__p;
    size_t v21 = v77;
LABEL_54:
    size_t v77 = v21 + 1;
LABEL_34:
    uint64_t v23 = &p_p[v21];
    char *v23 = v24;
    v23[1] = 0;
    ++v4;
  }
  while (v4 != v8);
  if (v78 >= 0) {
    size_t v30 = (char *)&__p;
  }
  else {
    size_t v30 = (char *)__p;
  }
  if (v78 >= 0) {
    unint64_t v31 = HIBYTE(v78);
  }
  else {
    unint64_t v31 = v77;
  }
  LODWORD(v32) = *(char *)(v5 + 23);
  if ((v32 & 0x80000000) != 0)
  {
    uint64_t v33 = *(char **)(v5 + 8);
    unint64_t v37 = *(void *)(v5 + 16);
    uint64_t v38 = v37 & 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v35 = (v37 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v35 - (unint64_t)v33 >= a2)
    {
      unint64_t v32 = HIBYTE(v37);
      unint64_t v40 = *(void *)v5;
      goto LABEL_97;
    }
    unint64_t v34 = (unint64_t)&v33[a2];
    size_t v39 = 0x7FFFFFFFFFFFFFF7;
    if (0x7FFFFFFFFFFFFFF8 - v38 < (unint64_t)&v33[a2 - v35]) {
      goto LABEL_133;
    }
    unint64_t v36 = *(void *)v5;
    if (v35 < 0x3FFFFFFFFFFFFFF3)
    {
LABEL_68:
      if (v34 <= 2 * v35) {
        unint64_t v34 = 2 * v35;
      }
      if (v34 >= 0x17)
      {
        unint64_t v41 = (v34 & 0xFFFFFFFFFFFFFFF8) + 8;
        uint64_t v42 = v34 | 7;
        if (v42 == 23) {
          uint64_t v42 = v41;
        }
        size_t v39 = v42 + 1;
      }
      else
      {
        size_t v39 = 23;
      }
    }
    unint64_t v43 = (char *)operator new(v39);
    unint64_t v40 = (unint64_t)v43;
    if (__srca) {
      memmove(v43, (const void *)v36, (size_t)__srca);
    }
    if (v33 != __srca) {
      memmove(&__srca[v40 + a2], &__srca[v36], v33 - __srca);
    }
    if (v35 != 22) {
      operator delete((void *)v36);
    }
    *(void *)unint64_t v5 = v40;
    *(void *)(v5 + 16) = v39 | 0x8000000000000000;
    unint64_t v44 = &v33[a2];
    uint64_t v45 = __srca;
  }
  else
  {
    uint64_t v33 = (char *)*(unsigned __int8 *)(v5 + 23);
    if (22 - (uint64_t)v33 < a2)
    {
      unint64_t v34 = (unint64_t)&v33[a2];
      if ((unint64_t)&v33[a2 - 0x7FFFFFFFFFFFFFF8] >= 0x800000000000001ELL)
      {
        unint64_t v35 = 22;
        unint64_t v36 = v5;
        goto LABEL_68;
      }
LABEL_133:
      abort();
    }
    unint64_t v40 = v5;
LABEL_97:
    uint64_t v45 = __srca;
    unint64_t v50 = __srca;
    if (v33 != __srca)
    {
      memmove(&__srca[v40 + a2], &__srca[v40], v33 - __srca);
      LOBYTE(v32) = *(unsigned char *)(v5 + 23);
      unint64_t v50 = v33;
    }
    unint64_t v44 = &v50[a2];
    if ((v32 & 0x80) == 0)
    {
      *(unsigned char *)(v5 + 23) = v44 & 0x7F;
      v44[v40] = 0;
      if (!v31) {
        goto LABEL_130;
      }
LABEL_103:
      long double v51 = &v45[v40];
      if (v31 < 8)
      {
        uint64_t v52 = v30;
        goto LABEL_129;
      }
      uint64_t v52 = v30;
      if ((unint64_t)(&v45[v40] - v30) >= 0x20)
      {
        if (v31 < 0x20)
        {
          uint64_t v53 = 0;
LABEL_121:
          unint64_t v67 = v31 & 0xFFFFFFFFFFFFFFF8;
          v51 += v31 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v68 = v53 - (v31 & 0xFFFFFFFFFFFFFFF8);
          uint64_t v69 = &v30[v53];
          uint64_t v70 = &v45[v53 + v40];
          do
          {
            uint64_t v71 = *(void *)v69;
            v69 += 8;
            *(void *)uint64_t v70 = v71;
            v70 += 8;
            v68 += 8;
          }
          while (v68);
          if (v31 == v67) {
            goto LABEL_130;
          }
          uint64_t v52 = &v30[v67];
          goto LABEL_129;
        }
        uint64_t v53 = v31 & 0xFFFFFFFFFFFFFFE0;
        uint64_t v63 = (long long *)(v30 + 16);
        uint64_t v64 = &v45[v40 + 16];
        unint64_t v65 = v31 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v66 = *v63;
          *((_OWORD *)v64 - 1) = *(v63 - 1);
          *(_OWORD *)uint64_t v64 = v66;
          v63 += 2;
          v64 += 32;
          v65 -= 32;
        }
        while (v65);
        if (v31 == v53) {
          goto LABEL_130;
        }
        if ((v31 & 0x18) != 0) {
          goto LABEL_121;
        }
        uint64_t v52 = &v30[v53];
        v51 += v53;
      }
      do
      {
LABEL_129:
        char v73 = *v52++;
        *v51++ = v73;
      }
      while (v52 != &v30[v31]);
      goto LABEL_130;
    }
  }
  *(void *)(v5 + 8) = v44;
  v44[v40] = 0;
  if (v31) {
    goto LABEL_103;
  }
LABEL_130:
  if (SHIBYTE(v78) < 0) {
    operator delete(__p);
  }
}

void geo::linear_map<unsigned short,std::list<std::unique_ptr<gdc::SelectionContext>>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::list<std::unique_ptr<gdc::SelectionContext>>>>,std::vector<std::pair<unsigned short,std::list<std::unique_ptr<gdc::SelectionContext>>>>>::emplace<unsigned short,std::list<std::unique_ptr<gdc::SelectionContext>>>(unsigned __int16 **a1, unsigned __int16 a2, void *a3)
{
  uint64_t v54 = &v54;
  uint64_t v55 = &v54;
  uint64_t v56 = 0;
  uint64_t v4 = a3[2];
  if (v4)
  {
    unint64_t v6 = (void *)*a3;
    unint64_t v5 = (uint64_t *)a3[1];
    uint64_t v7 = *v5;
    *(void *)(v7 + 8) = *(void *)(*a3 + 8);
    *(void *)v6[1] = v7;
    uint64_t v8 = v54;
    v54[1] = v5;
    *unint64_t v5 = (uint64_t)v8;
    uint64_t v54 = v6;
    v6[1] = &v54;
    uint64_t v56 = v4;
    a3[2] = 0;
    uint64_t v9 = v4;
  }
  else
  {
    uint64_t v9 = 0;
    unint64_t v6 = &v54;
  }
  unint64_t v12 = *a1;
  unint64_t v11 = a1[1];
  uint64_t v13 = *a1;
  if (*a1 != v11)
  {
    while (*v13 != a2)
    {
      v13 += 16;
      if (v13 == v11) {
        goto LABEL_9;
      }
    }
  }
  if (v13 != v11)
  {
LABEL_13:
    if (!v4) {
      return;
    }
    goto LABEL_45;
  }
LABEL_9:
  unint64_t v14 = a1[2];
  if (v11 < v14)
  {
    *unint64_t v11 = a2;
    *((void *)v11 + 1) = v11 + 4;
    *((void *)v11 + 2) = v11 + 4;
    *((void *)v11 + 3) = 0;
    uint64_t v15 = v56;
    if (v56)
    {
      size_t v17 = v54;
      uint64_t v16 = v55;
      uint64_t v18 = *v55;
      *(void *)(v18 + 8) = v54[1];
      *(void *)v17[1] = v18;
      uint64_t v19 = *((void *)v11 + 1);
      *(void *)(v19 + 8) = v16;
      *uint64_t v16 = v19;
      *((void *)v11 + 1) = v17;
      v17[1] = v11 + 4;
      *((void *)v11 + 3) = v15;
    }
    uint64_t v4 = 0;
    a1[1] = v11 + 16;
    goto LABEL_13;
  }
  uint64_t v20 = ((char *)v11 - (char *)v12) >> 5;
  unint64_t v21 = v20 + 1;
  if ((unint64_t)(v20 + 1) >> 59) {
    abort();
  }
  uint64_t v22 = (char *)v14 - (char *)v12;
  if (v22 >> 4 > v21) {
    unint64_t v21 = v22 >> 4;
  }
  if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v23 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v23 = v21;
  }
  if (v23)
  {
    if (v23 >> 59) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    char v24 = (char *)operator new(32 * v23);
  }
  else
  {
    char v24 = 0;
  }
  uint64_t v25 = &v24[32 * v20];
  *(_WORD *)uint64_t v25 = a2;
  size_t v26 = (uint64_t *)(v25 + 8);
  *(int64x2_t *)(v25 + 8) = vdupq_n_s64((unint64_t)(v25 + 8));
  *((void *)v25 + 3) = 0;
  if (v9)
  {
    unint64_t v27 = v55;
    uint64_t v28 = *v55;
    *(void *)(v28 + 8) = v6[1];
    *(void *)v6[1] = v28;
    uint64_t v29 = *v26;
    *(void *)(v29 + 8) = v27;
    *unint64_t v27 = v29;
    *size_t v26 = (uint64_t)v6;
    v6[1] = v26;
    *((void *)v25 + 3) = v9;
    uint64_t v56 = 0;
  }
  size_t v30 = &v24[32 * v23];
  unint64_t v31 = v25 + 32;
  if (v12 != v11)
  {
    uint64_t v32 = 0;
    do
    {
      uint64_t v33 = &v25[v32 * 2];
      unint64_t v34 = &v11[v32];
      *((_WORD *)v33 - 16) = v11[v32 - 16];
      unint64_t v35 = &v25[v32 * 2 - 24];
      *((void *)v33 - 3) = v35;
      *((void *)v33 - 2) = v35;
      *((void *)v33 - 1) = 0;
      uint64_t v36 = *(void *)&v11[v32 - 4];
      if (v36)
      {
        uint64_t v38 = *((void *)v34 - 3);
        unint64_t v37 = (uint64_t *)*((void *)v34 - 2);
        uint64_t v39 = *v37;
        *(void *)(v39 + 8) = *(void *)(v38 + 8);
        **(void **)(v38 + 8) = v39;
        uint64_t v40 = *(void *)v35;
        *(void *)(v40 + 8) = v37;
        *unint64_t v37 = v40;
        *(void *)unint64_t v35 = v38;
        *(void *)(v38 + 8) = v35;
        *((void *)v33 - 1) = v36;
        *((void *)v34 - 1) = 0;
      }
      v32 -= 16;
    }
    while (&v11[v32] != v12);
    v25 += v32 * 2;
  }
  unint64_t v41 = *a1;
  uint64_t v42 = a1[1];
  *a1 = (unsigned __int16 *)v25;
  a1[1] = (unsigned __int16 *)v31;
  a1[2] = (unsigned __int16 *)v30;
  while (v42 != v41)
  {
    if (*((void *)v42 - 1))
    {
      uint64_t v43 = *((void *)v42 - 3);
      unint64_t v44 = (unsigned __int16 *)*((void *)v42 - 2);
      uint64_t v45 = *(void *)v44;
      *(void *)(v45 + 8) = *(void *)(v43 + 8);
      **(void **)(v43 + 8) = v45;
      *((void *)v42 - 1) = 0;
      if (v44 != v42 - 12)
      {
        do
        {
          unint64_t v47 = (unsigned __int16 *)*((void *)v44 + 1);
          uint64_t v46 = *((void *)v44 + 2);
          *((void *)v44 + 2) = 0;
          if (v46) {
            (*(void (**)(uint64_t))(*(void *)v46 + 8))(v46);
          }
          operator delete(v44);
          unint64_t v44 = v47;
        }
        while (v47 != v42 - 12);
      }
    }
    v42 -= 16;
  }
  if (v41) {
    operator delete(v41);
  }
  uint64_t v48 = v56;
  a1[1] = (unsigned __int16 *)v31;
  if (v48)
  {
LABEL_45:
    unint64_t v49 = v54;
    unint64_t v50 = v55;
    uint64_t v51 = *v55;
    *(void *)(v51 + 8) = v54[1];
    *(void *)v49[1] = v51;
    uint64_t v56 = 0;
    if (v50 != &v54)
    {
      do
      {
        uint64_t v53 = (void *)v50[1];
        uint64_t v52 = v50[2];
        v50[2] = 0;
        if (v52) {
          (*(void (**)(uint64_t))(*(void *)v52 + 8))(v52);
        }
        operator delete(v50);
        unint64_t v50 = v53;
      }
      while (v53 != &v54);
    }
  }
}

void sub_1A1BB0C74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *std::__hash_table<std::__hash_value_type<md::TileSelectionTileSetType,long long>,std::__unordered_map_hasher<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,long long>,std::hash<md::TileSelectionTileSetType>,std::equal_to<md::TileSelectionTileSetType>,true>,std::__unordered_map_equal<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,long long>,std::equal_to<md::TileSelectionTileSetType>,std::hash<md::TileSelectionTileSetType>,true>,std::allocator<std::__hash_value_type<md::TileSelectionTileSetType,long long>>>::__emplace_unique_key_args<md::TileSelectionTileSetType,std::piecewise_construct_t const&,std::tuple<md::TileSelectionTileSetType const&>,std::tuple<>>(float *a1, unsigned __int16 a2, _WORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((unsigned __int16 *)v10 + 8) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((unsigned __int16 *)v10 + 8) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v10 = operator new(0x20uLL);
  *uint64_t v10 = 0;
  v10[1] = v6;
  *((_WORD *)v10 + 8) = *a3;
  v10[3] = 0;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (prime <= v7)
    {
      if (prime >= v7) {
        goto LABEL_59;
      }
      unint64_t v30 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
      {
        unint64_t v30 = std::__next_prime(v30);
      }
      else
      {
        uint64_t v32 = 1 << -(char)__clz(v30 - 1);
        if (v30 >= 2) {
          unint64_t v30 = v32;
        }
      }
      if (prime <= v30) {
        size_t prime = v30;
      }
      if (prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
LABEL_59:
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v6) {
            unint64_t v3 = v6 % v7;
          }
          else {
            unint64_t v3 = v6;
          }
        }
        else
        {
          unint64_t v3 = (v7 - 1) & v6;
        }
        goto LABEL_72;
      }
      if (!prime)
      {
        uint64_t v40 = *(void **)a1;
        *(void *)a1 = 0;
        if (v40) {
          operator delete(v40);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_59;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v19 = operator new(8 * prime);
    uint64_t v20 = *(void **)a1;
    *(void *)a1 = v19;
    if (v20) {
      operator delete(v20);
    }
    uint64_t v21 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v21++) = 0;
    while (prime != v21);
    unint64_t v23 = (uint64_t *)(a1 + 4);
    uint64_t v22 = (void *)*((void *)a1 + 2);
    if (!v22)
    {
LABEL_58:
      unint64_t v7 = prime;
      goto LABEL_59;
    }
    size_t v24 = v22[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*(void *)a1 + 8 * v26) = v23;
      for (uint64_t i = (void *)*v22; *v22; uint64_t i = (void *)*v22)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          uint64_t v22 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v28))
        {
          *uint64_t v22 = *i;
          uint64_t v29 = 8 * v28;
          void *i = **(void **)(*(void *)a1 + v29);
          **(void **)(*(void *)a1 + v29) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v28) = v22;
          uint64_t v22 = i;
          size_t v26 = v28;
        }
      }
      goto LABEL_58;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v24) = v23;
    uint64_t v33 = (void *)*v22;
    if (!*v22) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*(void *)a1 + 8 * v35))
        {
          *(void *)(*(void *)a1 + 8 * v35) = v22;
          goto LABEL_63;
        }
        *uint64_t v22 = *v33;
        uint64_t v34 = 8 * v35;
        *uint64_t v33 = **(void **)(*(void *)a1 + v34);
        **(void **)(*(void *)a1 + v34) = v33;
        uint64_t v33 = v22;
      }
      size_t v35 = v24;
LABEL_63:
      uint64_t v22 = v33;
      uint64_t v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  uint64_t v36 = *(void **)a1;
  unint64_t v37 = *(void **)(*(void *)a1 + 8 * v3);
  if (v37)
  {
    *uint64_t v10 = *v37;
LABEL_80:
    *unint64_t v37 = v10;
    goto LABEL_81;
  }
  *uint64_t v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v36[v3] = a1 + 4;
  if (*v10)
  {
    unint64_t v38 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    unint64_t v37 = (void *)(*(void *)a1 + 8 * v38);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A1BB10DC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::vector<objc_object * {__strong}>::__emplace_back_slow_path<objc_object * {__strong}>(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1] - *a1;
  uint64_t v3 = v2 >> 3;
  unint64_t v4 = (v2 >> 3) + 1;
  if (v4 >> 61) {
    abort();
  }
  uint64_t v7 = a1[2] - *a1;
  if (v7 >> 2 > v4) {
    unint64_t v4 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v4;
  }
  if (v8)
  {
    if (v8 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v9 = (char *)operator new(8 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v10 = &v9[8 * v3];
  unint64_t v11 = &v9[8 * v8];
  uint64_t v12 = *a2;
  *a2 = 0;
  *(void *)uint64_t v10 = v12;
  float v13 = v10 + 8;
  float v14 = (char *)*a1;
  BOOL v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
    if (!v15) {
      return v13;
    }
    goto LABEL_22;
  }
  unint64_t v16 = (unint64_t)&v15[-*a1 - 8];
  if (v16 <= 0x77 || &v15[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v10 && &v9[v2 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v15) {
    goto LABEL_30;
  }
  uint64_t v17 = (v16 >> 3) + 1;
  uint64_t v18 = &v9[8 * v3 - 16];
  uint64_t v19 = v15 - 32;
  uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v22 = *(_OWORD *)v19;
    long long v21 = *((_OWORD *)v19 + 1);
    *(_OWORD *)uint64_t v19 = 0uLL;
    *((_OWORD *)v19 + 1) = 0uLL;
    v19 -= 32;
    *((_OWORD *)v18 - 1) = v22;
    *(_OWORD *)uint64_t v18 = v21;
    v18 -= 32;
    v20 -= 4;
  }
  while (v20);
  v10 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
  v15 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
  if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_30:
    do
    {
      uint64_t v23 = *((void *)v15 - 1);
      v15 -= 8;
      *(void *)BOOL v15 = 0;
      *((void *)v10 - 1) = v23;
      v10 -= 8;
    }
    while (v15 != v14);
  }
  BOOL v15 = (char *)*a1;
  size_t v24 = (char *)a1[1];
  *a1 = v10;
  a1[1] = v13;
  a1[2] = v11;
  while (v24 != v15)
  {
    size_t v25 = (void *)*((void *)v24 - 1);
    v24 -= 8;
  }
  if (v15) {
LABEL_22:
  }
    operator delete(v15);
  return v13;
}

void *std::__hash_table<std::__hash_value_type<md::FeatureFlag,BOOL>,std::__unordered_map_hasher<md::FeatureFlag,std::__hash_value_type<md::FeatureFlag,BOOL>,std::hash<md::FeatureFlag>,std::equal_to<md::FeatureFlag>,true>,std::__unordered_map_equal<md::FeatureFlag,std::__hash_value_type<md::FeatureFlag,BOOL>,std::equal_to<md::FeatureFlag>,std::hash<md::FeatureFlag>,true>,std::allocator<std::__hash_value_type<md::FeatureFlag,BOOL>>>::__emplace_unique_key_args<md::FeatureFlag,std::piecewise_construct_t const&,std::tuple<md::FeatureFlag&&>,std::tuple<>>(float *a1, unsigned __int8 a2, unsigned char *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((unsigned __int8 *)v10 + 16) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((unsigned __int8 *)v10 + 16) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v10 = operator new(0x18uLL);
  *uint64_t v10 = 0;
  v10[1] = v6;
  *((unsigned char *)v10 + 16) = *a3;
  *((unsigned char *)v10 + 17) = 0;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (prime <= v7)
    {
      if (prime >= v7) {
        goto LABEL_59;
      }
      unint64_t v30 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
      {
        unint64_t v30 = std::__next_prime(v30);
      }
      else
      {
        uint64_t v32 = 1 << -(char)__clz(v30 - 1);
        if (v30 >= 2) {
          unint64_t v30 = v32;
        }
      }
      if (prime <= v30) {
        size_t prime = v30;
      }
      if (prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
LABEL_59:
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v6) {
            unint64_t v3 = v6 % v7;
          }
          else {
            unint64_t v3 = v6;
          }
        }
        else
        {
          unint64_t v3 = (v7 - 1) & v6;
        }
        goto LABEL_72;
      }
      if (!prime)
      {
        uint64_t v40 = *(void **)a1;
        *(void *)a1 = 0;
        if (v40) {
          operator delete(v40);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_59;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v19 = operator new(8 * prime);
    uint64_t v20 = *(void **)a1;
    *(void *)a1 = v19;
    if (v20) {
      operator delete(v20);
    }
    uint64_t v21 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v21++) = 0;
    while (prime != v21);
    uint64_t v23 = (uint64_t *)(a1 + 4);
    long long v22 = (void *)*((void *)a1 + 2);
    if (!v22)
    {
LABEL_58:
      unint64_t v7 = prime;
      goto LABEL_59;
    }
    size_t v24 = v22[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*(void *)a1 + 8 * v26) = v23;
      for (uint64_t i = (void *)*v22; *v22; uint64_t i = (void *)*v22)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          long long v22 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v28))
        {
          *long long v22 = *i;
          uint64_t v29 = 8 * v28;
          void *i = **(void **)(*(void *)a1 + v29);
          **(void **)(*(void *)a1 + v29) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v28) = v22;
          long long v22 = i;
          size_t v26 = v28;
        }
      }
      goto LABEL_58;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v24) = v23;
    uint64_t v33 = (void *)*v22;
    if (!*v22) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*(void *)a1 + 8 * v35))
        {
          *(void *)(*(void *)a1 + 8 * v35) = v22;
          goto LABEL_63;
        }
        *long long v22 = *v33;
        uint64_t v34 = 8 * v35;
        *uint64_t v33 = **(void **)(*(void *)a1 + v34);
        **(void **)(*(void *)a1 + v34) = v33;
        uint64_t v33 = v22;
      }
      size_t v35 = v24;
LABEL_63:
      long long v22 = v33;
      uint64_t v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  uint64_t v36 = *(void **)a1;
  unint64_t v37 = *(void **)(*(void *)a1 + 8 * v3);
  if (v37)
  {
    *uint64_t v10 = *v37;
LABEL_80:
    *unint64_t v37 = v10;
    goto LABEL_81;
  }
  *uint64_t v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v36[v3] = a1 + 4;
  if (*v10)
  {
    unint64_t v38 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    unint64_t v37 = (void *)(*(void *)a1 + 8 * v38);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A1BB16DC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *geo::Pool<ecs2::Graph>::allocateSlab(uint64_t **a1)
{
  double result = (char *)malloc_type_malloc((size_t)a1[4], 0x160B39uLL);
  unint64_t v3 = result;
  unint64_t v5 = a1 + 1;
  unint64_t v4 = a1[1];
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v6 = (uint64_t **)v4;
        unint64_t v7 = v4[4];
        if ((unint64_t)result >= v7) {
          break;
        }
        unint64_t v4 = *v6;
        unint64_t v5 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      if (v7 >= (unint64_t)result) {
        break;
      }
      unint64_t v4 = v6[1];
      if (!v4)
      {
        unint64_t v5 = v6 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    unint64_t v6 = a1 + 1;
LABEL_8:
    uint8x8_t v8 = (uint64_t *)operator new(0x28uLL);
    v8[4] = (uint64_t)v3;
    *uint8x8_t v8 = 0;
    v8[1] = 0;
    v8[2] = (uint64_t)v6;
    *unint64_t v5 = v8;
    uint64_t v9 = (uint64_t *)**a1;
    if (v9)
    {
      *a1 = v9;
      uint64_t v10 = *v5;
    }
    else
    {
      uint64_t v10 = v8;
    }
    double result = (char *)std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  unint64_t v11 = a1[5];
  uint64_t v12 = 248 * (void)a1[3] - 248;
  if ((v12 & 0x8000000000000000) == 0)
  {
    float v13 = &v3[v12];
    float v14 = &v3[v12];
    do
    {
      *(void *)float v14 = v11;
      v14 -= 248;
      unint64_t v11 = (uint64_t *)v13;
      float v13 = v14;
    }
    while (v14 >= v3);
    unint64_t v11 = (uint64_t *)(v14 + 248);
  }
  a1[5] = v11;
  return result;
}

void md::DaVinciGroundLayerDataSource::setRegistryManager(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = (const void *)(a1 + 792);
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  sp_mut = std::__get_sp_mut(v6);
  std::__sp_mut::lock(sp_mut);
  *(void *)(a1 + 792) = a2;
  uint8x8_t v8 = *(std::__shared_weak_count **)(a1 + 800);
  *(void *)(a1 + 800) = a3;
  std::__sp_mut::unlock(sp_mut);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
}

void sub_1A1BB18D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void md::Monitorable<md::ConfigValue<GEOConfigKeyUInteger,unsigned int>>::setCallbackQueue(void *a1, void *a2, void *a3)
{
  v19[3] = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  if (a1[3])
  {
    GEOConfigRemoveBlockListener();
    unint64_t v6 = (void *)a1[3];
    a1[3] = 0;
  }
  uint64_t v7 = a3[3];
  if (!v7) {
    goto LABEL_6;
  }
  if ((void *)v7 != a3)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
LABEL_6:
    uint64_t v18 = (uint64_t *)v7;
    goto LABEL_8;
  }
  uint64_t v18 = &v16;
  (*(void (**)(void *, uint64_t *))(*a3 + 24))(a3, &v16);
LABEL_8:
  uint8x8_t v8 = a1 + 6;
  if (a1 + 6 != &v16)
  {
    uint64_t v9 = v18;
    uint64_t v10 = (void *)a1[9];
    if (v18 == &v16)
    {
      if (v10 == v8)
      {
        (*(void (**)(uint64_t *, void *))(v16 + 24))(&v16, v19);
        (*(void (**)(uint64_t *))(*v18 + 32))(v18);
        uint64_t v18 = 0;
        (*(void (**)(void, uint64_t *))(*(void *)a1[9] + 24))(a1[9], &v16);
        (*(void (**)(void))(*(void *)a1[9] + 32))(a1[9]);
        a1[9] = 0;
        uint64_t v18 = &v16;
        (*(void (**)(void *, void *))(v19[0] + 24))(v19, a1 + 6);
        (*(void (**)(void *))(v19[0] + 32))(v19);
      }
      else
      {
        (*(void (**)(uint64_t *, void *))(v16 + 24))(&v16, a1 + 6);
        (*(void (**)(uint64_t *))(*v18 + 32))(v18);
        uint64_t v18 = (uint64_t *)a1[9];
      }
      a1[9] = v8;
    }
    else if (v10 == v8)
    {
      (*(void (**)(void *, uint64_t *))(a1[6] + 24))(a1 + 6, &v16);
      (*(void (**)(void))(*(void *)a1[9] + 32))(a1[9]);
      a1[9] = v18;
      uint64_t v18 = &v16;
    }
    else
    {
      uint64_t v18 = (uint64_t *)a1[9];
      a1[9] = v9;
    }
  }
  if (v18 == &v16)
  {
    (*(void (**)(uint64_t *))(v16 + 32))(&v16);
  }
  else if (v18)
  {
    (*(void (**)(void))(*v18 + 40))();
  }
  unint64_t v11 = (std::__shared_weak_count *)a1[5];
  uint64_t v16 = a1[4];
  unint64_t v17 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v15 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = _GEOConfigAddBlockListenerForKey();
  float v13 = (void *)a1[3];
  a1[3] = v12;

  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  float v14 = v17;
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
}

void sub_1A1BB1D88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v10);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:nn180100]<ecs2::LayoutNode,ecs2::LayoutNode const&,ecs2::LayoutNode*>(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
  uint64_t v4 = a1 + 16;
  uint64_t v5 = *(void *)(a2 + 40);
  if (v5)
  {
    if (v5 == a2 + 16)
    {
      *(void *)(a1 + 40) = v4;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 40) + 24))(*(void *)(a2 + 40), v4);
    }
    else
    {
      *(void *)(a1 + 40) = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
    }
  }
  else
  {
    *(void *)(a1 + 40) = 0;
  }
  unint64_t v6 = (std::string *)(a1 + 48);
  if (*(char *)(a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 48);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  return a1;
}

void sub_1A1BB1EA0(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *(void *)(v1 + 40);
  if (v4 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
    _Unwind_Resume(exception_object);
  }
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::unique_ptr<md::MaterialResourceStore>::reset[abi:nn180100](uint64_t *result)
{
  uint64_t v1 = *result;
  *double result = 0;
  if (v1)
  {
    md::data_array_cache<md::ls::ColorData,geo::handle<md::ls::ColorData>,md::MaterialKey,md::ls::ColorData,md::MaterialKeyHasher>::~data_array_cache(v1 + 904);
    md::data_array_cache<md::ls::ZIndex,geo::handle<md::ls::ZIndex>,md::MaterialKey,md::ls::ZIndex,md::MaterialKeyHasher>::~data_array_cache(v1 + 608);
    md::data_array_cache<md::ls::MaterialVisibilityOptions,geo::handle<md::ls::MaterialVisibilityOptions>,md::MaterialKey,md::ls::MaterialVisibilityOptions,md::MaterialKeyHasher>::~data_array_cache(v1 + 312);
    md::data_array_cache<md::MaterialIDStorage,geo::handle<md::MaterialIDStorage>,md::MaterialKey,std::shared_ptr<gms::Material<ggl::Texture2D>>,md::MaterialKeyHasher>::~data_array_cache(v1 + 16);
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    JUMPOUT(0x1A6239270);
  }
  return result;
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_30,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_30>,void ()(gdc::SceneStatus)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF521110;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_28,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_28>,void ()(NSError *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF521080;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_24,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_24>,void ()(VKMuninAvailability)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579DE8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_23,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_23>,void ()(geo::Unit<geo::DegreeUnitDescription,double>)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579DA0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_12,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_12>,void ()(VKARWalkingElevationRequestFailureInfo *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579AD0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_11,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_11>,void ()(VKARWalkingFeatureSet *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579A88;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_10,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_10>,void ()(VKARWalkingFeatureDidUpdateInfo *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579A40;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_9,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_9>,void ()(md::MuninJunction const*,md::MuninRoadEdge const*,BOOL)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5799F8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_2,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_2>,geo::optional<gm::Range<double>> ()(geo::QuadTile const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5741A8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<md::LightingLogic::LightingLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::LightingLogic::LightingLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,BOOL ()(BOOL const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56FC30;
}

uint64_t std::__function::__func<md::MapEngine::MapEngineDisplayLinkCaller,std::allocator<md::MapEngine::MapEngineDisplayLinkCaller>,void ()(double)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF519EE0;
  a2[1] = v2;
  return result;
}

uint64_t *md::LogicBase::addDependencies<md::ARLogicContext,md::NavigationContext>(uint64_t *result)
{
  uint64_t v1 = result;
  unint64_t v3 = (uint64_t **)(result + 10);
  uint64_t v2 = (uint64_t *)result[10];
  uint64_t v4 = (uint64_t **)(result + 10);
  uint64_t v5 = (uint64_t **)(result + 10);
  if (v2)
  {
    unint64_t v6 = (uint64_t *)result[10];
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (uint64_t **)v6;
        unint64_t v7 = v6[4];
        if (v7 <= 0x37F8C546A65FE3EELL) {
          break;
        }
        unint64_t v6 = *v5;
        uint64_t v4 = v5;
        if (!*v5) {
          goto LABEL_8;
        }
      }
      if (v7 == 0x37F8C546A65FE3EELL) {
        break;
      }
      unint64_t v6 = v5[1];
      if (!v6)
      {
        uint64_t v4 = v5 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    uint8x8_t v8 = (uint64_t *)operator new(0x38uLL);
    v8[4] = 0x37F8C546A65FE3EELL;
    v8[5] = (uint64_t)"md::ARLogicContext]";
    v8[6] = 18;
    *uint8x8_t v8 = 0;
    v8[1] = 0;
    v8[2] = (uint64_t)v5;
    uint64_t *v4 = v8;
    uint64_t v9 = *(void *)v1[9];
    if (v9)
    {
      v1[9] = v9;
      uint64_t v10 = *v4;
    }
    else
    {
      uint64_t v10 = v8;
    }
    double result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v1[10], v10);
    uint64_t v2 = (uint64_t *)v1[10];
    ++v1[11];
  }
  unint64_t v11 = v3;
  if (v2)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v11 = (uint64_t **)v2;
        unint64_t v12 = v2[4];
        if (v12 <= 0x1B8B241A8D896A1DLL) {
          break;
        }
        uint64_t v2 = *v11;
        unint64_t v3 = v11;
        if (!*v11) {
          goto LABEL_19;
        }
      }
      if (v12 == 0x1B8B241A8D896A1DLL) {
        break;
      }
      uint64_t v2 = v11[1];
      if (!v2)
      {
        unint64_t v3 = v11 + 1;
        goto LABEL_19;
      }
    }
  }
  else
  {
LABEL_19:
    float v13 = (uint64_t *)operator new(0x38uLL);
    v13[4] = 0x1B8B241A8D896A1DLL;
    v13[5] = (uint64_t)"md::NavigationContext]";
    v13[6] = 21;
    uint64_t *v13 = 0;
    v13[1] = 0;
    v13[2] = (uint64_t)v11;
    char *v3 = v13;
    uint64_t v14 = *(void *)v1[9];
    if (v14)
    {
      v1[9] = v14;
      BOOL v15 = *v3;
    }
    else
    {
      BOOL v15 = v13;
    }
    double result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v1[10], v15);
    ++v1[11];
  }
  return result;
}

uint64_t *md::LogicBase::addDependencies<md::CameraContext,md::StyleLogicContext>(uint64_t *result)
{
  uint64_t v1 = result;
  unint64_t v3 = (uint64_t **)(result + 10);
  uint64_t v2 = (uint64_t *)result[10];
  uint64_t v4 = (uint64_t **)(result + 10);
  uint64_t v5 = (uint64_t **)(result + 10);
  if (v2)
  {
    unint64_t v6 = (uint64_t *)result[10];
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (uint64_t **)v6;
        unint64_t v7 = v6[4];
        if (v7 <= 0x1AF456233693CD46) {
          break;
        }
        unint64_t v6 = *v5;
        uint64_t v4 = v5;
        if (!*v5) {
          goto LABEL_8;
        }
      }
      if (v7 == 0x1AF456233693CD46) {
        break;
      }
      unint64_t v6 = v5[1];
      if (!v6)
      {
        uint64_t v4 = v5 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    uint8x8_t v8 = (uint64_t *)operator new(0x38uLL);
    v8[4] = 0x1AF456233693CD46;
    v8[5] = (uint64_t)"md::CameraContext]";
    v8[6] = 17;
    *uint8x8_t v8 = 0;
    v8[1] = 0;
    v8[2] = (uint64_t)v5;
    uint64_t *v4 = v8;
    uint64_t v9 = *(void *)v1[9];
    if (v9)
    {
      v1[9] = v9;
      uint64_t v10 = *v4;
    }
    else
    {
      uint64_t v10 = v8;
    }
    double result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v1[10], v10);
    uint64_t v2 = (uint64_t *)v1[10];
    ++v1[11];
  }
  unint64_t v11 = v3;
  if (v2)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v11 = (uint64_t **)v2;
        unint64_t v12 = v2[4];
        if (v12 <= 0xE42D19AFCA302E68) {
          break;
        }
        uint64_t v2 = *v11;
        unint64_t v3 = v11;
        if (!*v11) {
          goto LABEL_19;
        }
      }
      if (v12 == 0xE42D19AFCA302E68) {
        break;
      }
      uint64_t v2 = v11[1];
      if (!v2)
      {
        unint64_t v3 = v11 + 1;
        goto LABEL_19;
      }
    }
  }
  else
  {
LABEL_19:
    float v13 = (uint64_t *)operator new(0x38uLL);
    v13[4] = 0xE42D19AFCA302E68;
    v13[5] = (uint64_t)"md::StyleLogicContext]";
    v13[6] = 21;
    uint64_t *v13 = 0;
    v13[1] = 0;
    v13[2] = (uint64_t)v11;
    char *v3 = v13;
    uint64_t v14 = *(void *)v1[9];
    if (v14)
    {
      v1[9] = v14;
      BOOL v15 = *v3;
    }
    else
    {
      BOOL v15 = v13;
    }
    double result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v1[10], v15);
    ++v1[11];
  }
  return result;
}

uint64_t *md::LogicBase::addDependencies<md::CameraContext,md::SceneContext>(uint64_t *result)
{
  uint64_t v1 = result;
  unint64_t v3 = (uint64_t **)(result + 10);
  uint64_t v2 = (uint64_t *)result[10];
  uint64_t v4 = (uint64_t **)(result + 10);
  uint64_t v5 = (uint64_t **)(result + 10);
  if (v2)
  {
    unint64_t v6 = (uint64_t *)result[10];
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (uint64_t **)v6;
        unint64_t v7 = v6[4];
        if (v7 <= 0x1AF456233693CD46) {
          break;
        }
        unint64_t v6 = *v5;
        uint64_t v4 = v5;
        if (!*v5) {
          goto LABEL_8;
        }
      }
      if (v7 == 0x1AF456233693CD46) {
        break;
      }
      unint64_t v6 = v5[1];
      if (!v6)
      {
        uint64_t v4 = v5 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    uint8x8_t v8 = (uint64_t *)operator new(0x38uLL);
    v8[4] = 0x1AF456233693CD46;
    v8[5] = (uint64_t)"md::CameraContext]";
    v8[6] = 17;
    *uint8x8_t v8 = 0;
    v8[1] = 0;
    v8[2] = (uint64_t)v5;
    uint64_t *v4 = v8;
    uint64_t v9 = *(void *)v1[9];
    if (v9)
    {
      v1[9] = v9;
      uint64_t v10 = *v4;
    }
    else
    {
      uint64_t v10 = v8;
    }
    double result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v1[10], v10);
    uint64_t v2 = (uint64_t *)v1[10];
    ++v1[11];
  }
  unint64_t v11 = v3;
  if (v2)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v11 = (uint64_t **)v2;
        unint64_t v12 = v2[4];
        if (v12 <= 0x99BED48DEFBBD82BLL) {
          break;
        }
        uint64_t v2 = *v11;
        unint64_t v3 = v11;
        if (!*v11) {
          goto LABEL_19;
        }
      }
      if (v12 == 0x99BED48DEFBBD82BLL) {
        break;
      }
      uint64_t v2 = v11[1];
      if (!v2)
      {
        unint64_t v3 = v11 + 1;
        goto LABEL_19;
      }
    }
  }
  else
  {
LABEL_19:
    float v13 = (uint64_t *)operator new(0x38uLL);
    v13[4] = 0x99BED48DEFBBD82BLL;
    v13[5] = (uint64_t)"md::SceneContext]";
    v13[6] = 16;
    uint64_t *v13 = 0;
    v13[1] = 0;
    v13[2] = (uint64_t)v11;
    char *v3 = v13;
    uint64_t v14 = *(void *)v1[9];
    if (v14)
    {
      v1[9] = v14;
      BOOL v15 = *v3;
    }
    else
    {
      BOOL v15 = v13;
    }
    double result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v1[10], v15);
    ++v1[11];
  }
  return result;
}

void md::IdentifiedResourceLogic::IdentifiedResourceLogic(std::shared_ptr<md::RegistryManager> const&,NSObject  {objcproto17OS_dispatch_queue}*)::$_0::operator()(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1 + 19;
  if (a1[22])
  {
    unint64_t v3 = (void *)a1[21];
    if (v3)
    {
      do
      {
        uint64_t v4 = (void *)*v3;
        operator delete(v3);
        unint64_t v3 = v4;
      }
      while (v4);
    }
    a1[21] = 0;
    uint64_t v5 = a1[20];
    if (v5)
    {
      for (uint64_t i = 0; i != v5; ++i)
        *(void *)(*v1 + 8 * i) = 0;
    }
    a1[22] = 0;
  }
  unint64_t v7 = GEOConfigGetArray();
  uint8x8_t v8 = v7;
  if (v7)
  {
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    id v9 = v7;
    uint64_t v10 = [v9 countByEnumeratingWithState:&v15 objects:v19 count:16];
    if (v10)
    {
      uint64_t v11 = *(void *)v16;
      do
      {
        uint64_t v12 = 0;
        do
        {
          if (*(void *)v16 != v11) {
            objc_enumerationMutation(v9);
          }
          float v13 = *(void **)(*((void *)&v15 + 1) + 8 * v12);
          if (v13)
          {
            uint64_t v14 = objc_msgSend(v13, "unsignedLongLongValue", (void)v15);
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>((uint64_t)v1, v14, v14);
          }
          ++v12;
        }
        while (v10 != v12);
        uint64_t v10 = [v9 countByEnumeratingWithState:&v15 objects:v19 count:16];
      }
      while (v10);
    }
  }
}

void sub_1A1BB2790(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::unordered_map<md::DaVinciGroundSettings::Property,md::DaVinciGroundSettings::PropertyType>::unordered_map(int *a1, uint64_t a2)
{
  *(_OWORD *)&qword_1E957F568 = 0u;
  dword_1E957F578 = 1065353216;
  if (!a2) {
    return;
  }
  unint64_t v3 = a1;
  unint64_t v4 = 0;
  uint64_t v5 = 0;
  unint64_t v6 = &a1[2 * a2];
  do
  {
    unint64_t v7 = *v3;
    if (v4)
    {
      uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v4);
      v8.i16[0] = vaddlv_u8(v8);
      if (v8.u32[0] > 1uLL)
      {
        unint64_t v2 = *v3;
        if (v4 <= v7) {
          unint64_t v2 = v7 % v4;
        }
      }
      else
      {
        unint64_t v2 = (v4 - 1) & v7;
      }
      if (v9)
      {
        uint64_t v10 = *v9;
        if (v10)
        {
          if (v8.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v12 = v10[1];
              if (v12 == v7)
              {
                if (*((_DWORD *)v10 + 4) == v7) {
                  goto LABEL_83;
                }
              }
              else if ((v12 & (v4 - 1)) != v2)
              {
                goto LABEL_23;
              }
              uint64_t v10 = (uint64_t *)*v10;
              if (!v10) {
                goto LABEL_23;
              }
            }
          }
          do
          {
            unint64_t v11 = v10[1];
            if (v11 == v7)
            {
              if (*((_DWORD *)v10 + 4) == v7) {
                goto LABEL_83;
              }
            }
            else
            {
              if (v11 >= v4) {
                v11 %= v4;
              }
              if (v11 != v2) {
                break;
              }
            }
            uint64_t v10 = (uint64_t *)*v10;
          }
          while (v10);
        }
      }
    }
LABEL_23:
    float v13 = operator new(0x18uLL);
    void *v13 = 0;
    v13[1] = v7;
    v13[2] = *(void *)v3;
    float v14 = (float)(unint64_t)(v5 + 1);
    if (!v4 || (float)(*(float *)&dword_1E957F578 * (float)v4) < v14)
    {
      BOOL v15 = (v4 & (v4 - 1)) != 0;
      if (v4 < 3) {
        BOOL v15 = 1;
      }
      unint64_t v16 = v15 | (2 * v4);
      unint64_t v17 = vcvtps_u32_f32(v14 / *(float *)&dword_1E957F578);
      if (v16 <= v17) {
        size_t prime = v17;
      }
      else {
        size_t prime = v16;
      }
      if (prime == 1)
      {
        size_t prime = 2;
      }
      else if ((prime & (prime - 1)) != 0)
      {
        size_t prime = std::__next_prime(prime);
      }
      if (prime <= v4)
      {
        if (prime >= v4) {
          goto LABEL_60;
        }
        unint64_t v29 = vcvtps_u32_f32((float)(unint64_t)qword_1E957F570 / *(float *)&dword_1E957F578);
        if (v4 < 3 || (uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v4), v30.i16[0] = vaddlv_u8(v30), v30.u32[0] > 1uLL))
        {
          unint64_t v29 = std::__next_prime(v29);
        }
        else
        {
          uint64_t v31 = 1 << -(char)__clz(v29 - 1);
          if (v29 >= 2) {
            unint64_t v29 = v31;
          }
        }
        if (prime <= v29) {
          size_t prime = v29;
        }
        if (prime >= v4)
        {
LABEL_60:
          if ((v4 & (v4 - 1)) != 0)
          {
            if (v4 <= v7) {
              unint64_t v2 = v7 % v4;
            }
            else {
              unint64_t v2 = v7;
            }
          }
          else
          {
            unint64_t v2 = (v4 - 1) & v7;
          }
          goto LABEL_73;
        }
        if (!prime)
        {
          if (v38) {
            operator delete(v38);
          }
          unint64_t v4 = 0;
          goto LABEL_60;
        }
      }
      if (prime >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v19 = operator new(8 * prime);
      if (v20) {
        operator delete(v20);
      }
      uint64_t v21 = 0;
      do
      while (prime != v21);
      long long v22 = (void **)qword_1E957F568;
      if (!qword_1E957F568)
      {
LABEL_59:
        unint64_t v4 = prime;
        goto LABEL_60;
      }
      size_t v23 = *(void *)(qword_1E957F568 + 8);
      size_t v24 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        size_t v25 = v23 & v24;
        for (uint64_t i = *v22; *v22; uint64_t i = *v22)
        {
          size_t v27 = i[1] & v24;
          if (v27 == v25)
          {
            long long v22 = (void **)i;
          }
          {
            *long long v22 = (void *)*i;
            uint64_t v28 = 8 * v27;
          }
          else
          {
            long long v22 = (void **)i;
            size_t v25 = v27;
          }
        }
        goto LABEL_59;
      }
      if (v23 >= prime) {
        v23 %= prime;
      }
      uint64_t v32 = *v22;
      if (!*v22) {
        goto LABEL_59;
      }
      while (1)
      {
        size_t v34 = v32[1];
        if (v34 >= prime) {
          v34 %= prime;
        }
        if (v34 != v23)
        {
          {
            goto LABEL_64;
          }
          *long long v22 = (void *)*v32;
          uint64_t v33 = 8 * v34;
          uint64_t v32 = v22;
        }
        size_t v34 = v23;
LABEL_64:
        long long v22 = (void **)v32;
        uint64_t v32 = (void *)*v32;
        size_t v23 = v34;
        if (!v32) {
          goto LABEL_59;
        }
      }
    }
LABEL_73:
    if (v36)
    {
      void *v13 = *v36;
LABEL_81:
      void *v36 = v13;
      goto LABEL_82;
    }
    void *v13 = qword_1E957F568;
    qword_1E957F568 = (uint64_t)v13;
    *(void *)(v35 + 8 * v2) = &qword_1E957F568;
    if (*v13)
    {
      unint64_t v37 = *(void *)(*v13 + 8);
      if ((v4 & (v4 - 1)) != 0)
      {
        if (v37 >= v4) {
          v37 %= v4;
        }
      }
      else
      {
        v37 &= v4 - 1;
      }
      goto LABEL_81;
    }
LABEL_82:
    uint64_t v5 = ++qword_1E957F570;
LABEL_83:
    v3 += 2;
  }
  while (v3 != v6);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xCE03281732FA0019;
  result[1] = "md::ls::TextureHandleForType<DaVinci::EmissiveTexture>]";
  result[2] = 54;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB2D5C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSpecularContribution>(md::ita::PrepareFunctionConstantDescriptorSpecularContribution &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorSpecularContribution &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSpecularContribution>(md::ita::PrepareFunctionConstantDescriptorSpecularContribution &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x1631ACE79ACA9DD7;
  result[1] = "md::ls::MaterialSpecularity]";
  result[2] = 27;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSpecularContribution>(md::ita::PrepareFunctionConstantDescriptorSpecularContribution &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorSpecularContribution &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSpecularContribution>(md::ita::PrepareFunctionConstantDescriptorSpecularContribution &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB2E1C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth>(md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth>(md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xE7D1C5E790E8E07;
  result[1] = "md::ls::IntendedStandardPassSceneDepth]";
  result[2] = 38;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth>(md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth>(md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB2EDC(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled>(md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled>(md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xA50DD2A5BD75DBD6;
  result[1] = "md::ls::StyleEmissiveDataKeyHandle]";
  result[2] = 34;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled>(md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled>(md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB2F9C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorColorCorrection>(md::ita::PrepareFunctionConstantDescriptorColorCorrection &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorColorCorrection &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorColorCorrection>(md::ita::PrepareFunctionConstantDescriptorColorCorrection &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x65937AC5D2157F71;
  result[1] = "md::ls::ColorCorrectionFactorConstantHandle]";
  result[2] = 43;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorColorCorrection>(md::ita::PrepareFunctionConstantDescriptorColorCorrection &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorColorCorrection &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorColorCorrection>(md::ita::PrepareFunctionConstantDescriptorColorCorrection &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB305C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorUseCameraZBias>(md::ita::PrepareFunctionConstantDescriptorUseCameraZBias &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorUseCameraZBias &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorUseCameraZBias>(md::ita::PrepareFunctionConstantDescriptorUseCameraZBias &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x499CE17DBD9A1615;
  result[1] = "md::ls::NeedsZBias]";
  result[2] = 18;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorUseCameraZBias>(md::ita::PrepareFunctionConstantDescriptorUseCameraZBias &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorUseCameraZBias &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorUseCameraZBias>(md::ita::PrepareFunctionConstantDescriptorUseCameraZBias &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB311C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorTextureEnabled &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorTextureEnabled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorTextureEnabled &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x1D932F2BF291491;
  result[1] = "md::ls::TextureHandleForType<DaVinci::TexTexture>]";
  result[2] = 49;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorTextureEnabled &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorTextureEnabled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorTextureEnabled &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB31DC(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPreserveHeight>(md::ita::PrepareFunctionConstantDescriptorPreserveHeight &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorPreserveHeight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPreserveHeight>(md::ita::PrepareFunctionConstantDescriptorPreserveHeight &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x98A9F01DBB8BCCCELL;
  result[1] = "md::ls::PreserveHeight]";
  result[2] = 22;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPreserveHeight>(md::ita::PrepareFunctionConstantDescriptorPreserveHeight &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorPreserveHeight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPreserveHeight>(md::ita::PrepareFunctionConstantDescriptorPreserveHeight &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB329C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorIdentityMatrix>(md::ita::PrepareFunctionConstantDescriptorIdentityMatrix &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorIdentityMatrix &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorIdentityMatrix>(md::ita::PrepareFunctionConstantDescriptorIdentityMatrix &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x944162BB9DE8E7EBLL;
  result[1] = "md::ls::UseIdentityMatrix]";
  result[2] = 25;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorIdentityMatrix>(md::ita::PrepareFunctionConstantDescriptorIdentityMatrix &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorIdentityMatrix &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorIdentityMatrix>(md::ita::PrepareFunctionConstantDescriptorIdentityMatrix &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB335C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorRoutelineMask>(md::ita::PrepareFunctionConstantDescriptorRoutelineMask &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorRoutelineMask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorRoutelineMask>(md::ita::PrepareFunctionConstantDescriptorRoutelineMask &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls31StyleRouteLineMaskDataKeyHandleEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB33BC(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorRoutelineMask>(md::ita::PrepareFunctionConstantDescriptorRoutelineMask &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorRoutelineMask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorRoutelineMask>(md::ita::PrepareFunctionConstantDescriptorRoutelineMask &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB341C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPositionScale>(md::ita::PrepareFunctionConstantDescriptorPositionScale &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorPositionScale &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPositionScale>(md::ita::PrepareFunctionConstantDescriptorPositionScale &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x6C7EE74910D42096;
  v2[1] = "md::ls::PositionScaleInfoConstantDataHandle]";
  *(void *)&double result = 43;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDBE0;
  v2[4] = "md::ls::IsMercator]";
  v2[5] = 18;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPositionScale>(md::ita::PrepareFunctionConstantDescriptorPositionScale &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorPositionScale &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPositionScale>(md::ita::PrepareFunctionConstantDescriptorPositionScale &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB34F0(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorDualElevation>(md::ita::PrepareFunctionConstantDescriptorDualElevation &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorDualElevation &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorDualElevation>(md::ita::PrepareFunctionConstantDescriptorDualElevation &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x8261D2F258A435BBLL;
  result[1] = "md::ls::IsElevated]";
  result[2] = 18;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorDualElevation>(md::ita::PrepareFunctionConstantDescriptorDualElevation &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorDualElevation &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorDualElevation>(md::ita::PrepareFunctionConstantDescriptorDualElevation &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB35B0(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTileClipping>(md::ita::PrepareFunctionConstantDescriptorTileClipping &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorTileClipping &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTileClipping>(md::ita::PrepareFunctionConstantDescriptorTileClipping &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x4F0CC5B74BC3AC16;
  v2[1] = "md::ls::UniqueRenderArrayID]";
  *(void *)&double result = 27;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDBD0;
  v2[4] = "md::ls::ClippingConstantDataHandle]";
  v2[5] = 34;
  v2[6] = 0x7931433C9A6EB2C6;
  v2[7] = "md::ls::SharedUniqueID]";
  v2[8] = 22;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTileClipping>(md::ita::PrepareFunctionConstantDescriptorTileClipping &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorTileClipping &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTileClipping>(md::ita::PrepareFunctionConstantDescriptorTileClipping &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB36A8(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorBlendedWater>(md::ita::PrepareFunctionConstantDescriptorBlendedWater &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorBlendedWater &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorBlendedWater>(md::ita::PrepareFunctionConstantDescriptorBlendedWater &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB3708(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorClimateTint>(md::ita::PrepareFunctionConstantDescriptorClimateTint &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorClimateTint &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorClimateTint>(md::ita::PrepareFunctionConstantDescriptorClimateTint &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x11BB47B172EB0B40;
  result[1] = "md::ls::NeedsClimateTint]";
  result[2] = 24;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorClimateTint>(md::ita::PrepareFunctionConstantDescriptorClimateTint &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorClimateTint &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorClimateTint>(md::ita::PrepareFunctionConstantDescriptorClimateTint &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB37C8(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareGradientParametersConstantDataHandle>(md::ita::PrepareGradientParametersConstantDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareGradientParametersConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareGradientParametersConstantDataHandle>(md::ita::PrepareGradientParametersConstantDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *(void *)&double result = 24;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD00;
  v2[4] = "md::ls::InView]";
  v2[5] = 14;
  v2[6] = 0x741786E98487217CLL;
  v2[7] = "md::ls::RampMaterialData]";
  v2[8] = 24;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareGradientParametersConstantDataHandle>(md::ita::PrepareGradientParametersConstantDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareGradientParametersConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareGradientParametersConstantDataHandle>(md::ita::PrepareGradientParametersConstantDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls19ColorRampDataHandleEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB38C0(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLightDebug>(md::ita::PrepareFunctionConstantDescriptorLightDebug &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorLightDebug &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLightDebug>(md::ita::PrepareFunctionConstantDescriptorLightDebug &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x888DE670CA75E2DCLL;
  result[1] = "md::ls::UsesDebugLight]";
  result[2] = 22;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLightDebug>(md::ita::PrepareFunctionConstantDescriptorLightDebug &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorLightDebug &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLightDebug>(md::ita::PrepareFunctionConstantDescriptorLightDebug &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB3980(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorGlobeLight>(md::ita::PrepareFunctionConstantDescriptorGlobeLight &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorGlobeLight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorGlobeLight>(md::ita::PrepareFunctionConstantDescriptorGlobeLight &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x97E77A2C4FA4C0B5;
  result[1] = "md::ls::UseGlobeLighting]";
  result[2] = 24;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorGlobeLight>(md::ita::PrepareFunctionConstantDescriptorGlobeLight &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorGlobeLight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorGlobeLight>(md::ita::PrepareFunctionConstantDescriptorGlobeLight &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB3A40(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverS2TransformConstantDataHandle>(md::ita::PrepareFlyoverS2TransformConstantDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFlyoverS2TransformConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverS2TransformConstantDataHandle>(md::ita::PrepareFlyoverS2TransformConstantDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x695C99F828CA9E84;
  result[1] = "md::ls::BaseMapTileHandle]";
  result[2] = 25;
  *a1 = result;
  return result;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverS2TransformConstantDataHandle>(md::ita::PrepareFlyoverS2TransformConstantDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFlyoverS2TransformConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverS2TransformConstantDataHandle>(md::ita::PrepareFlyoverS2TransformConstantDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x81BF69EEE736436;
  result[1] = "md::ls::FlyoverCommonS2TransformHandle]";
  result[2] = 38;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareColorCorrectionFactorsConstantHandle>(md::ita::PrepareColorCorrectionFactorsConstantHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareColorCorrectionFactorsConstantHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareColorCorrectionFactorsConstantHandle>(md::ita::PrepareColorCorrectionFactorsConstantHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD00;
  v2[4] = "md::ls::InView]";
  v2[5] = 14;
  v2[6] = 0xB6C12FBB402E8E70;
  v2[7] = "md::ls::RenderableMaterialData]";
  v2[8] = 30;
  unint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)unint64_t v3 = 0x3B99BF65D7C678C8;
    v2[10] = "md::ls::MaterialBrightnessAndSaturation]";
    v2[11] = 39;
    unint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x3B99BF65D7C678C8;
  *((void *)v10 + 1) = "md::ls::MaterialBrightnessAndSaturation]";
  *((void *)v10 + 2) = 39;
  unint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  unint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BB3D04(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareColorCorrectionFactorsConstantHandle>(md::ita::PrepareColorCorrectionFactorsConstantHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareColorCorrectionFactorsConstantHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareColorCorrectionFactorsConstantHandle>(md::ita::PrepareColorCorrectionFactorsConstantHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLandCover>(md::ita::PrepareFunctionConstantDescriptorLandCover &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorLandCover &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLandCover>(md::ita::PrepareFunctionConstantDescriptorLandCover &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xD5B48B62BD07EF80;
  result[1] = "md::ls::HasMaterialRasterRenderItem]";
  result[2] = 35;
  *a1 = result;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverTransformConstantDataHandle>(md::ita::PrepareFlyoverTransformConstantDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFlyoverTransformConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverTransformConstantDataHandle>(md::ita::PrepareFlyoverTransformConstantDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xBED6A4C8B7C54422;
  v2[1] = "md::ls::ModelTransformData]";
  *(void *)&double result = 26;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDE20;
  v2[4] = "md::ls::GlobeMatrix]";
  v2[5] = 19;
  *a1 = v2;
  return result;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverTransformConstantDataHandle>(md::ita::PrepareFlyoverTransformConstantDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFlyoverTransformConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverTransformConstantDataHandle>(md::ita::PrepareFlyoverTransformConstantDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x7D9191A7B57B7B35;
  result[1] = "md::ls::FlyoverCommonTransformConstantDataHandle]";
  result[2] = 48;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForDepthPrePass>(md::ita::CreateTileClearRenderItemsForDepthPrePass &&)::{lambda(void)#1},std::allocator<md::ita::CreateTileClearRenderItemsForDepthPrePass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForDepthPrePass>(md::ita::CreateTileClearRenderItemsForDepthPrePass &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0xF0uLL);
  a1[2] = (char *)(v2 + 30);
  *unint64_t v2 = 0xE0AB1B46607846E6;
  v2[1] = "md::ls::EnteringView]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDCA0;
  v2[4] = "md::ls::SupportsDepthPrePass]";
  v2[5] = 28;
  v2[6] = 0x684A78DCF1B284C1;
  v2[7] = "md::ls::RenderablesCount]";
  v2[8] = 24;
  unint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 30)
  {
    *(void *)unint64_t v3 = 0x24B7D588576BB14ELL;
    v2[10] = "md::ls::AssociationTileHandle]";
    v2[11] = 29;
    unint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_128;
  }
  if (0x5555555555555556 * (((char *)(v2 + 30) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 30) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 30) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_129;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x24B7D588576BB14ELL;
  *((void *)v10 + 1) = "md::ls::AssociationTileHandle]";
  *((void *)v10 + 2) = 29;
  unint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  unint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)unint64_t v4 = 0x695C99F828CA9E84;
    *((void *)v4 + 1) = "md::ls::BaseMapTileHandle]";
    *((void *)v4 + 2) = 25;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_128;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_129;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x695C99F828CA9E84;
  *((void *)v21 + 1) = "md::ls::BaseMapTileHandle]";
  *((void *)v21 + 2) = 25;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  unint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0x414BF8D9069621AELL;
    *((void *)v14 + 1) = "md::ls::TileViewConstantDataHandle]";
    *((void *)v14 + 2) = 34;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_128;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_129;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0x414BF8D9069621AELL;
  *((void *)v32 + 1) = "md::ls::TileViewConstantDataHandle]";
  *((void *)v32 + 2) = 34;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0xD270E8E58701C515;
    *((void *)v25 + 1) = "md::ls::TileTransformConstantDataHandle]";
    *((void *)v25 + 2) = 39;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_128;
  }
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_129;
    }
    uint64_t v42 = (char *)operator new(24 * v41);
  }
  else
  {
    uint64_t v42 = 0;
  }
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0xD270E8E58701C515;
  *((void *)v43 + 1) = "md::ls::TileTransformConstantDataHandle]";
  *((void *)v43 + 2) = 39;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
  unint64_t v46 = (unint64_t)a1[2];
  if ((unint64_t)v36 < v46)
  {
    *(void *)uint64_t v36 = 0xBCC33905201D8160;
    *((void *)v36 + 1) = "md::ls::TileMatrix]";
    *((void *)v36 + 2) = 18;
    unint64_t v47 = v36 + 24;
    goto LABEL_91;
  }
  uint64_t v48 = *a1;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v36 - *a1) >> 3);
  unint64_t v50 = v49 + 1;
  if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_128;
  }
  unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v48) >> 3);
  if (2 * v51 > v50) {
    unint64_t v50 = 2 * v51;
  }
  if (v51 >= 0x555555555555555) {
    unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v52 = v50;
  }
  if (v52)
  {
    if (v52 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_129;
    }
    uint64_t v53 = (char *)operator new(24 * v52);
  }
  else
  {
    uint64_t v53 = 0;
  }
  uint64_t v54 = &v53[24 * v49];
  uint64_t v55 = &v53[24 * v52];
  *(void *)uint64_t v54 = 0xBCC33905201D8160;
  *((void *)v54 + 1) = "md::ls::TileMatrix]";
  *((void *)v54 + 2) = 18;
  unint64_t v47 = v54 + 24;
  if (v36 == v48)
  {
    *a1 = v54;
    a1[1] = v47;
    a1[2] = v55;
LABEL_90:
    operator delete(v36);
    goto LABEL_91;
  }
  do
  {
    long long v56 = *(_OWORD *)(v36 - 24);
    *((void *)v54 - 1) = *((void *)v36 - 1);
    *(_OWORD *)(v54 - 24) = v56;
    v54 -= 24;
    v36 -= 24;
  }
  while (v36 != v48);
  uint64_t v36 = *a1;
  *a1 = v54;
  a1[1] = v47;
  a1[2] = v55;
  if (v36) {
    goto LABEL_90;
  }
LABEL_91:
  a1[1] = v47;
  unint64_t v57 = (unint64_t)a1[2];
  if ((unint64_t)v47 < v57)
  {
    *(void *)unint64_t v47 = 0xB4E92DEB291A7B99;
    *((void *)v47 + 1) = "md::ls::TilePrepassShadowConstantDataHandle]";
    *((void *)v47 + 2) = 43;
    unint64_t v58 = v47 + 24;
    goto LABEL_109;
  }
  unint64_t v59 = *a1;
  unint64_t v60 = 0xAAAAAAAAAAAAAAABLL * ((v47 - *a1) >> 3);
  unint64_t v61 = v60 + 1;
  if (v60 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_128;
  }
  unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v57 - (void)v59) >> 3);
  if (2 * v62 > v61) {
    unint64_t v61 = 2 * v62;
  }
  if (v62 >= 0x555555555555555) {
    unint64_t v63 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v63 = v61;
  }
  if (v63)
  {
    if (v63 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_129;
    }
    uint64_t v64 = (char *)operator new(24 * v63);
  }
  else
  {
    uint64_t v64 = 0;
  }
  unint64_t v65 = &v64[24 * v60];
  long long v66 = &v64[24 * v63];
  *(void *)unint64_t v65 = 0xB4E92DEB291A7B99;
  *((void *)v65 + 1) = "md::ls::TilePrepassShadowConstantDataHandle]";
  *((void *)v65 + 2) = 43;
  unint64_t v58 = v65 + 24;
  if (v47 == v59)
  {
    *a1 = v65;
    a1[1] = v58;
    a1[2] = v66;
LABEL_108:
    operator delete(v47);
    goto LABEL_109;
  }
  do
  {
    long long v67 = *(_OWORD *)(v47 - 24);
    *((void *)v65 - 1) = *((void *)v47 - 1);
    *(_OWORD *)(v65 - 24) = v67;
    v65 -= 24;
    v47 -= 24;
  }
  while (v47 != v59);
  unint64_t v47 = *a1;
  *a1 = v65;
  a1[1] = v58;
  a1[2] = v66;
  if (v47) {
    goto LABEL_108;
  }
LABEL_109:
  a1[1] = v58;
  unint64_t v68 = (unint64_t)a1[2];
  if ((unint64_t)v58 < v68)
  {
    *(void *)unint64_t v58 = 0x33C39664142A0949;
    *((void *)v58 + 1) = "md::ls::TilePrepassConstantDataHandle]";
    *((void *)v58 + 2) = 37;
    uint64_t v69 = v58 + 24;
    goto LABEL_127;
  }
  uint64_t v70 = *a1;
  unint64_t v71 = 0xAAAAAAAAAAAAAAABLL * ((v58 - *a1) >> 3);
  unint64_t v72 = v71 + 1;
  if (v71 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_128:
  }
    abort();
  unint64_t v73 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v68 - (void)v70) >> 3);
  if (2 * v73 > v72) {
    unint64_t v72 = 2 * v73;
  }
  if (v73 >= 0x555555555555555) {
    unint64_t v74 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v74 = v72;
  }
  if (v74)
  {
    if (v74 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v75 = (char *)operator new(24 * v74);
      goto LABEL_121;
    }
LABEL_129:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v75 = 0;
LABEL_121:
  unint64_t v76 = &v75[24 * v71];
  size_t v77 = &v75[24 * v74];
  *(void *)unint64_t v76 = 0x33C39664142A0949;
  *((void *)v76 + 1) = "md::ls::TilePrepassConstantDataHandle]";
  *((void *)v76 + 2) = 37;
  uint64_t v69 = v76 + 24;
  if (v58 == v70)
  {
    *a1 = v76;
    a1[1] = v69;
    a1[2] = v77;
LABEL_126:
    operator delete(v58);
    goto LABEL_127;
  }
  do
  {
    long long v78 = *(_OWORD *)(v58 - 24);
    *((void *)v76 - 1) = *((void *)v58 - 1);
    *(_OWORD *)(v76 - 24) = v78;
    v76 -= 24;
    v58 -= 24;
  }
  while (v58 != v70);
  unint64_t v58 = *a1;
  *a1 = v76;
  a1[1] = v69;
  a1[2] = v77;
  if (v58) {
    goto LABEL_126;
  }
LABEL_127:
  a1[1] = v69;
}

void sub_1A1BB4728(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForDepthPrePass>(md::ita::CreateTileClearRenderItemsForDepthPrePass &&)::{lambda(void)#2},std::allocator<md::ita::CreateTileClearRenderItemsForDepthPrePass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForDepthPrePass>(md::ita::CreateTileClearRenderItemsForDepthPrePass &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForStyleGroundOcclusion>(md::ita::ProcessRenderableForStyleGroundOcclusion &&)::{lambda(void)#1},std::allocator<md::ita::ProcessRenderableForStyleGroundOcclusion &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForStyleGroundOcclusion>(md::ita::ProcessRenderableForStyleGroundOcclusion &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *(void *)&double result = 24;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDE10;
  v2[4] = "md::ls::UnitsPerMeter]";
  v2[5] = 21;
  v2[6] = 0xA219A074B7259E0FLL;
  v2[7] = "md::ls::InView]";
  v2[8] = 14;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForStyleGroundOcclusion>(md::ita::ProcessRenderableForStyleGroundOcclusion &&)::{lambda(void)#2},std::allocator<md::ita::ProcessRenderableForStyleGroundOcclusion &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForStyleGroundOcclusion>(md::ita::ProcessRenderableForStyleGroundOcclusion &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSplined>(md::ita::PrepareFunctionConstantDescriptorSplined &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorSplined &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSplined>(md::ita::PrepareFunctionConstantDescriptorSplined &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x237F9D3BCC905318;
  v2[1] = "md::ls::IsMercator]";
  *(void *)&double result = 18;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDC30;
  v2[4] = "md::ls::IsOpaque]";
  v2[5] = 16;
  v2[6] = 0x73F0259EC1934FB1;
  v2[7] = "md::ls::IsTransparent]";
  v2[8] = 21;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSplined>(md::ita::PrepareFunctionConstantDescriptorSplined &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorSplined &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSplined>(md::ita::PrepareFunctionConstantDescriptorSplined &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 48;
  unint64_t v3 = (char **)a1;
  _ZZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsES5_EEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_ENKUlTpTnmNS1_16integer_sequenceImJXspT_EEEEE_clIJLm0ELm1EEEEDaSH_(&v3);
}

void sub_1A1BB48DC(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorShadows>(md::ita::PrepareFunctionConstantDescriptorShadows &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorShadows &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorShadows>(md::ita::PrepareFunctionConstantDescriptorShadows &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x4C30532B0D2F6731;
  v2[1] = "md::ls::UsesShadow]";
  *(void *)&double result = 18;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDC10;
  v2[4] = "md::ls::IntendedStandardPassSceneDepth]";
  v2[5] = 38;
  v2[6] = 0x3EB2A2A09E298E0ELL;
  v2[7] = "md::ls::IntendedStandardPassShadow]";
  v2[8] = 34;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorShadows>(md::ita::PrepareFunctionConstantDescriptorShadows &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorShadows &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorShadows>(md::ita::PrepareFunctionConstantDescriptorShadows &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 48;
  unint64_t v3 = (char **)a1;
  _ZZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsES5_EEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_ENKUlTpTnmNS1_16integer_sequenceImJXspT_EEEEE_clIJLm0ELm1EEEEDaSH_(&v3);
}

void sub_1A1BB49E0(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOverlay>(md::ita::PrepareFunctionConstantDescriptorOverlay &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorOverlay &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOverlay>(md::ita::PrepareFunctionConstantDescriptorOverlay &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xE40027D1222182B5;
  result[1] = "md::ls::HasOverlayPatch]";
  result[2] = 23;
  *a1 = result;
  return result;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPlanar>(md::ita::PrepareFunctionConstantDescriptorPlanar &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorPlanar &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPlanar>(md::ita::PrepareFunctionConstantDescriptorPlanar &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x32FFF5E924C6D657;
  result[1] = "md::ls::PlanarConstantDataHandle]";
  result[2] = 32;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForShadowPass>(md::ita::CreateTileClearRenderItemsForShadowPass &&)::{lambda(void)#1},std::allocator<md::ita::CreateTileClearRenderItemsForShadowPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForShadowPass>(md::ita::CreateTileClearRenderItemsForShadowPass &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0xC0uLL);
  a1[2] = (char *)(v2 + 24);
  *unint64_t v2 = 0xE0AB1B46607846E6;
  v2[1] = "md::ls::EnteringView]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDC90;
  v2[4] = "md::ls::SupportsShadows]";
  v2[5] = 23;
  v2[6] = 0x24B7D588576BB14ELL;
  v2[7] = "md::ls::AssociationTileHandle]";
  v2[8] = 29;
  unint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 24)
  {
    *(void *)unint64_t v3 = 0x695C99F828CA9E84;
    v2[10] = "md::ls::BaseMapTileHandle]";
    v2[11] = 25;
    unint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  if (0x5555555555555556 * (((char *)(v2 + 24) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 24) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 24) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x695C99F828CA9E84;
  *((void *)v10 + 1) = "md::ls::BaseMapTileHandle]";
  *((void *)v10 + 2) = 25;
  unint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  unint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)unint64_t v4 = 0x414BF8D9069621AELL;
    *((void *)v4 + 1) = "md::ls::TileViewConstantDataHandle]";
    *((void *)v4 + 2) = 34;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x414BF8D9069621AELL;
  *((void *)v21 + 1) = "md::ls::TileViewConstantDataHandle]";
  *((void *)v21 + 2) = 34;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  unint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0xD270E8E58701C515;
    *((void *)v14 + 1) = "md::ls::TileTransformConstantDataHandle]";
    *((void *)v14 + 2) = 39;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0xD270E8E58701C515;
  *((void *)v32 + 1) = "md::ls::TileTransformConstantDataHandle]";
  *((void *)v32 + 2) = 39;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0xBCC33905201D8160;
    *((void *)v25 + 1) = "md::ls::TileMatrix]";
    *((void *)v25 + 2) = 18;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    uint64_t v42 = (char *)operator new(24 * v41);
  }
  else
  {
    uint64_t v42 = 0;
  }
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0xBCC33905201D8160;
  *((void *)v43 + 1) = "md::ls::TileMatrix]";
  *((void *)v43 + 2) = 18;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
  unint64_t v46 = (unint64_t)a1[2];
  if ((unint64_t)v36 < v46)
  {
    *(void *)uint64_t v36 = 0xF2296D6406C155CBLL;
    *((void *)v36 + 1) = "md::ls::TileShadowConstantDataHandle]";
    *((void *)v36 + 2) = 36;
    unint64_t v47 = v36 + 24;
    goto LABEL_91;
  }
  uint64_t v48 = *a1;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v36 - *a1) >> 3);
  unint64_t v50 = v49 + 1;
  if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_92:
  }
    abort();
  unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v48) >> 3);
  if (2 * v51 > v50) {
    unint64_t v50 = 2 * v51;
  }
  if (v51 >= 0x555555555555555) {
    unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v52 = v50;
  }
  if (v52)
  {
    if (v52 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v53 = (char *)operator new(24 * v52);
      goto LABEL_85;
    }
LABEL_93:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v53 = 0;
LABEL_85:
  uint64_t v54 = &v53[24 * v49];
  uint64_t v55 = &v53[24 * v52];
  *(void *)uint64_t v54 = 0xF2296D6406C155CBLL;
  *((void *)v54 + 1) = "md::ls::TileShadowConstantDataHandle]";
  *((void *)v54 + 2) = 36;
  unint64_t v47 = v54 + 24;
  if (v36 == v48)
  {
    *a1 = v54;
    a1[1] = v47;
    a1[2] = v55;
LABEL_90:
    operator delete(v36);
    goto LABEL_91;
  }
  do
  {
    long long v56 = *(_OWORD *)(v36 - 24);
    *((void *)v54 - 1) = *((void *)v36 - 1);
    *(_OWORD *)(v54 - 24) = v56;
    v54 -= 24;
    v36 -= 24;
  }
  while (v36 != v48);
  uint64_t v36 = *a1;
  *a1 = v54;
  a1[1] = v47;
  a1[2] = v55;
  if (v36) {
    goto LABEL_90;
  }
LABEL_91:
  a1[1] = v47;
}

void sub_1A1BB513C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForShadowPass>(md::ita::CreateTileClearRenderItemsForShadowPass &&)::{lambda(void)#2},std::allocator<md::ita::CreateTileClearRenderItemsForShadowPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForShadowPass>(md::ita::CreateTileClearRenderItemsForShadowPass &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForStyleRouteLineMask>(md::ita::ProcessRenderableForStyleRouteLineMask &&)::{lambda(void)#1},std::allocator<md::ita::ProcessRenderableForStyleRouteLineMask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForStyleRouteLineMask>(md::ita::ProcessRenderableForStyleRouteLineMask &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0xA219A074B7259E0FLL;
  v2[1] = "md::ls::InView]";
  *(void *)&double result = 14;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD10;
  v2[4] = "md::ls::MeshRenderableID]";
  v2[5] = 24;
  v2[6] = 0x52AE3240ED071F6CLL;
  v2[7] = "md::ls::GradientMaskColorFactors]";
  v2[8] = 32;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMaterialStyleConstantDataHandle>(md::ita::PrepareMaterialStyleConstantDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareMaterialStyleConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMaterialStyleConstantDataHandle>(md::ita::PrepareMaterialStyleConstantDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xA219A074B7259E0FLL;
  v2[1] = "md::ls::InView]";
  *(void *)&double result = 14;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD30;
  v2[4] = "md::ls::RenderableMaterialData]";
  v2[5] = 30;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMaterialStyleConstantDataHandle>(md::ita::PrepareMaterialStyleConstantDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareMaterialStyleConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMaterialStyleConstantDataHandle>(md::ita::PrepareMaterialStyleConstantDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorWater>(md::ita::PrepareFunctionConstantDescriptorWater &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorWater &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorWater>(md::ita::PrepareFunctionConstantDescriptorWater &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB52C0(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleGroundOcclusionConstantData>(md::ita::AssignStyleGroundOcclusionConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleGroundOcclusionConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleGroundOcclusionConstantData>(md::ita::AssignStyleGroundOcclusionConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xD5AD9B8C3FE62EE8;
  v2[1] = "md::ls::StyleGroundOcclusionConstantDataHandle]";
  *(void *)&double result = 46;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD9B0;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>]";
  v2[5] = 96;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleGroundOcclusionConstantData>(md::ita::AssignStyleGroundOcclusionConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleGroundOcclusionConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleGroundOcclusionConstantData>(md::ita::AssignStyleGroundOcclusionConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB5394(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderStateStencilRefValue>(md::ita::SetupCustomRenderStateStencilRefValue &&)::{lambda(void)#1},std::allocator<md::ita::SetupCustomRenderStateStencilRefValue &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderStateStencilRefValue>(md::ita::SetupCustomRenderStateStencilRefValue &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xA0C97F52893883B7;
  v2[1] = "md::ls::CustomRenderState]";
  *(void *)&double result = 25;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDBA0;
  v2[4] = "md::ls::RenderItemID]";
  v2[5] = 20;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderStateStencilRefValue>(md::ita::SetupCustomRenderStateStencilRefValue &&)::{lambda(void)#2},std::allocator<md::ita::SetupCustomRenderStateStencilRefValue &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderStateStencilRefValue>(md::ita::SetupCustomRenderStateStencilRefValue &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSSAO>(md::ita::PrepareFunctionConstantDescriptorSSAO &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorSSAO &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSSAO>(md::ita::PrepareFunctionConstantDescriptorSSAO &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x237F9D3BCC905318;
  v2[1] = "md::ls::IsMercator]";
  *(void *)&double result = 18;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDC20;
  v2[4] = "md::ls::IsMaterial]";
  v2[5] = 18;
  *a1 = v2;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorECEF>(md::ita::PrepareFunctionConstantDescriptorECEF &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorECEF &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorECEF>(md::ita::PrepareFunctionConstantDescriptorECEF &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x237F9D3BCC905318;
  v2[1] = "md::ls::IsMercator]";
  *(void *)&double result = 18;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDBF0;
  v2[4] = "md::ls::IsNotMercator]";
  v2[5] = 21;
  *a1 = v2;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleCameraLightingConstantData>(md::ita::AssignStyleCameraLightingConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleCameraLightingConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleCameraLightingConstantData>(md::ita::AssignStyleCameraLightingConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x96F87A2692FE4013;
  v2[1] = "md::ls::StyleCameraConstantDataHandle]";
  *(void *)&double result = 37;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDA50;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>]";
  v2[5] = 95;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleCameraLightingConstantData>(md::ita::AssignStyleCameraLightingConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleCameraLightingConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleCameraLightingConstantData>(md::ita::AssignStyleCameraLightingConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB55D0(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightingConfigurationVertexData>(md::ita::AssignLightingConfigurationVertexData &&)::{lambda(void)#1},std::allocator<md::ita::AssignLightingConfigurationVertexData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightingConfigurationVertexData>(md::ita::AssignLightingConfigurationVertexData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x4A991B37E344929BLL;
  result[1] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>>]";
  result[2] = 101;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightingConfigurationVertexData>(md::ita::AssignLightingConfigurationVertexData &&)::{lambda(void)#2},std::allocator<md::ita::AssignLightingConfigurationVertexData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightingConfigurationVertexData>(md::ita::AssignLightingConfigurationVertexData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB5690(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForPlanarParameters>(md::ita::ProcessRenderableForPlanarParameters &&)::{lambda(void)#1},std::allocator<md::ita::ProcessRenderableForPlanarParameters &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForPlanarParameters>(md::ita::ProcessRenderableForPlanarParameters &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0x3209EBE3B62CF3D3;
  v2[1] = "md::ls::UniqueMaterialData]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDE00;
  v2[4] = "md::ls::UniqueMaterialAlbedoTexture]";
  v2[5] = 35;
  v2[6] = 0xBEF372B431A710A8;
  v2[7] = "md::ls::UnitsPerMeter]";
  v2[8] = 21;
  unint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)unint64_t v3 = 0xD6C8660F950CD951;
    v2[10] = "md::ls::CanUpdateWithStyleZChange]";
    v2[11] = 33;
    unint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xD6C8660F950CD951;
  *((void *)v10 + 1) = "md::ls::CanUpdateWithStyleZChange]";
  *((void *)v10 + 2) = 33;
  unint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  unint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BB5894(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForPlanarParameters>(md::ita::ProcessRenderableForPlanarParameters &&)::{lambda(void)#2},std::allocator<md::ita::ProcessRenderableForPlanarParameters &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForPlanarParameters>(md::ita::ProcessRenderableForPlanarParameters &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorFog>(md::ita::PrepareFunctionConstantDescriptorFog &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorFog &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorFog>(md::ita::PrepareFunctionConstantDescriptorFog &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x3E8485C60908F920;
  v2[1] = "md::ls::IsMaterial]";
  *(void *)&double result = 18;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDC00;
  v2[4] = "md::ls::MainPassItem]";
  v2[5] = 20;
  *a1 = v2;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfMaterialRequiresEmissiveColor>(md::ita::CheckIfMaterialRequiresEmissiveColor &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfMaterialRequiresEmissiveColor &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfMaterialRequiresEmissiveColor>(md::ita::CheckIfMaterialRequiresEmissiveColor &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xCE1B2B8E676E76D8;
  v2[1] = "md::ls::MaterialPendingProcessing]";
  *(void *)&double result = 33;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDF40;
  v2[4] = "md::ls::UniqueMaterialData]";
  v2[5] = 26;
  *a1 = v2;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleRouteLineMaskConstantData>(md::ita::AssignStyleRouteLineMaskConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleRouteLineMaskConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleRouteLineMaskConstantData>(md::ita::AssignStyleRouteLineMaskConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x8E45E81B6E5A8E0ELL;
  v2[1] = "md::ls::StyleRouteLineMaskDataKeyHandle]";
  *(void *)&double result = 39;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD9C0;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>]";
  v2[5] = 94;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleRouteLineMaskConstantData>(md::ita::AssignStyleRouteLineMaskConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleRouteLineMaskConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleRouteLineMaskConstantData>(md::ita::AssignStyleRouteLineMaskConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB5A5C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleEmissiveColorConstantData>(md::ita::AssignStyleEmissiveColorConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleEmissiveColorConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleEmissiveColorConstantData>(md::ita::AssignStyleEmissiveColorConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xA50DD2A5BD75DBD6;
  v2[1] = "md::ls::StyleEmissiveDataKeyHandle]";
  *(void *)&double result = 34;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD9D0;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>]";
  v2[5] = 94;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleEmissiveColorConstantData>(md::ita::AssignStyleEmissiveColorConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleEmissiveColorConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleEmissiveColorConstantData>(md::ita::AssignStyleEmissiveColorConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB5B30(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradientParametersConstantData>(md::ita::AssignGradientParametersConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignGradientParametersConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradientParametersConstantData>(md::ita::AssignGradientParametersConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x8963537098E96576;
  v2[1] = "md::ls::GradientConstantDataHandle1]";
  *(void *)&double result = 35;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD990;
  v2[4] = "md::ls::GradientConstantDataHandle2]";
  v2[5] = 35;
  v2[6] = 0x7B8C320EC5754EB9;
  v2[7] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>]";
  v2[8] = 94;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradientParametersConstantData>(md::ita::AssignGradientParametersConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignGradientParametersConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradientParametersConstantData>(md::ita::AssignGradientParametersConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB5C28(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverS2TransformConstantData>(md::ita::AssignFlyoverS2TransformConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverS2TransformConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverS2TransformConstantData>(md::ita::AssignFlyoverS2TransformConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x81BF69EEE736436;
  v2[1] = "md::ls::FlyoverCommonS2TransformHandle]";
  *(void *)&double result = 38;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD870;
  v2[4] = "md::ls::FlyoverInstance]";
  v2[5] = 23;
  v2[6] = 0x68B9076D41547F1ALL;
  v2[7] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>]";
  v2[8] = 93;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverS2TransformConstantData>(md::ita::AssignFlyoverS2TransformConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverS2TransformConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverS2TransformConstantData>(md::ita::AssignFlyoverS2TransformConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB5D20(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareTileElevatedStrokeDataHandle>(md::ita::PrepareTileElevatedStrokeDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareTileElevatedStrokeDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareTileElevatedStrokeDataHandle>(md::ita::PrepareTileElevatedStrokeDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0xA219A074B7259E0FLL;
  v2[1] = "md::ls::InView]";
  *(void *)&double result = 14;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD40;
  v2[4] = "md::ls::MercatorBounds]";
  v2[5] = 22;
  v2[6] = 0xB6C12FBB402E8E70;
  v2[7] = "md::ls::RenderableMaterialData]";
  v2[8] = 30;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareTileElevatedStrokeDataHandle>(md::ita::PrepareTileElevatedStrokeDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareTileElevatedStrokeDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareTileElevatedStrokeDataHandle>(md::ita::PrepareTileElevatedStrokeDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorAO>(md::ita::PrepareFunctionConstantDescriptorAO &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorAO &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorAO>(md::ita::PrepareFunctionConstantDescriptorAO &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xD5AD9B8C3FE62EE8;
  result[1] = "md::ls::StyleGroundOcclusionConstantDataHandle]";
  result[2] = 46;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorAO>(md::ita::PrepareFunctionConstantDescriptorAO &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorAO &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorAO>(md::ita::PrepareFunctionConstantDescriptorAO &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB5E84(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLandCoverSettingsConstantData>(md::ita::AssignLandCoverSettingsConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignLandCoverSettingsConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLandCoverSettingsConstantData>(md::ita::AssignLandCoverSettingsConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xDC98991DB7473274;
  v2[1] = "md::ls::LandCoverSettingsConstantDataHandle]";
  *(void *)&double result = 43;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD9E0;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>]";
  v2[5] = 93;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLandCoverSettingsConstantData>(md::ita::AssignLandCoverSettingsConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignLandCoverSettingsConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLandCoverSettingsConstantData>(md::ita::AssignLandCoverSettingsConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB5F58(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverAtmosphereTextureIndex>(md::ita::AssignFlyoverAtmosphereTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverAtmosphereTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverAtmosphereTextureIndex>(md::ita::AssignFlyoverAtmosphereTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xD2597E061104B596;
  result[1] = "md::ls::RequiresShaderTextureID<Flyover::AtmosphereTexture>]";
  result[2] = 59;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverAtmosphereTextureIndex>(md::ita::AssignFlyoverAtmosphereTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverAtmosphereTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverAtmosphereTextureIndex>(md::ita::AssignFlyoverAtmosphereTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB6018(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleColorConstantDataHandle>(md::ita::UpdateStyleColorConstantDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::UpdateStyleColorConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleColorConstantDataHandle>(md::ita::UpdateStyleColorConstantDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xD68EA0DE832DEC03;
  v2[1] = "md::ls::RenderItemID]";
  *(void *)&double result = 20;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDB20;
  v2[4] = "md::ls::ColorDataHandle]";
  v2[5] = 23;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleColorConstantDataHandle>(md::ita::UpdateStyleColorConstantDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::UpdateStyleColorConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleColorConstantDataHandle>(md::ita::UpdateStyleColorConstantDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderTargetSizeConstantData>(md::ita::AssignRenderTargetSizeConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignRenderTargetSizeConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderTargetSizeConstantData>(md::ita::AssignRenderTargetSizeConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xA20E903AC8423AE1;
  result[1] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>]";
  result[2] = 92;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderTargetSizeConstantData>(md::ita::AssignRenderTargetSizeConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignRenderTargetSizeConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderTargetSizeConstantData>(md::ita::AssignRenderTargetSizeConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB6158(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignPlanarParametersConstantData>(md::ita::AssignPlanarParametersConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignPlanarParametersConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignPlanarParametersConstantData>(md::ita::AssignPlanarParametersConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x32FFF5E924C6D657;
  v2[1] = "md::ls::PlanarConstantDataHandle]";
  *(void *)&double result = 32;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDA30;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>]";
  v2[5] = 92;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignPlanarParametersConstantData>(md::ita::AssignPlanarParametersConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignPlanarParametersConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignPlanarParametersConstantData>(md::ita::AssignPlanarParametersConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB622C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGroundAtmosphereConstantData>(md::ita::AssignGroundAtmosphereConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignGroundAtmosphereConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGroundAtmosphereConstantData>(md::ita::AssignGroundAtmosphereConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x2E4DB0E7E1795086;
  result[1] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>>]";
  result[2] = 92;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGroundAtmosphereConstantData>(md::ita::AssignGroundAtmosphereConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignGroundAtmosphereConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGroundAtmosphereConstantData>(md::ita::AssignGroundAtmosphereConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB62EC(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTransformConstantData>(md::ita::AssignFlyoverTransformConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverTransformConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTransformConstantData>(md::ita::AssignFlyoverTransformConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x7D9191A7B57B7B35;
  v2[1] = "md::ls::FlyoverCommonTransformConstantDataHandle]";
  *(void *)&double result = 48;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD8A0;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>]";
  v2[5] = 91;
  v2[6] = 0x69465F3BE0BF85FBLL;
  v2[7] = "md::ls::FlyoverInstance]";
  v2[8] = 23;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTransformConstantData>(md::ita::AssignFlyoverTransformConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverTransformConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTransformConstantData>(md::ita::AssignFlyoverTransformConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB63E4(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTexcoordsConstantData>(md::ita::AssignFlyoverTexcoordsConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverTexcoordsConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTexcoordsConstantData>(md::ita::AssignFlyoverTexcoordsConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x5B12559DCF20DC9ALL;
  v2[1] = "md::ls::FlyoverCommonTexcoordsHandle]";
  *(void *)&double result = 36;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD860;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>]";
  v2[5] = 91;
  v2[6] = 0x69465F3BE0BF85FBLL;
  v2[7] = "md::ls::FlyoverInstance]";
  v2[8] = 23;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTexcoordsConstantData>(md::ita::AssignFlyoverTexcoordsConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverTexcoordsConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTexcoordsConstantData>(md::ita::AssignFlyoverTexcoordsConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB64DC(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PerformVisibilityTestOnRenderItem>(md::ita::PerformVisibilityTestOnRenderItem &&)::{lambda(void)#1},std::allocator<md::ita::PerformVisibilityTestOnRenderItem &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PerformVisibilityTestOnRenderItem>(md::ita::PerformVisibilityTestOnRenderItem &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xFA77EBF8E4CA45B8;
  v2[1] = "md::ls::VisibilityGroupTest]";
  *(void *)&double result = 27;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDC40;
  v2[4] = "md::ls::AssociationHandle]";
  v2[5] = 25;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PerformVisibilityTestOnRenderItem>(md::ita::PerformVisibilityTestOnRenderItem &&)::{lambda(void)#2},std::allocator<md::ita::PerformVisibilityTestOnRenderItem &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PerformVisibilityTestOnRenderItem>(md::ita::PerformVisibilityTestOnRenderItem &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfShouldDeleteUniqueMaterial &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xDACEFB85CDF2B135;
  v2[1] = "md::ls::RequestReset]";
  *(void *)&double result = 20;
  *((_OWORD *)v2 + 1) = xmmword_1A28FE000;
  v2[4] = "md::ls::UniqueMaterialData]";
  v2[5] = 26;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfShouldDeleteUniqueMaterial &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignInstanceTransformDeviceData>(md::ita::AssignInstanceTransformDeviceData &&)::{lambda(void)#1},std::allocator<md::ita::AssignInstanceTransformDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignInstanceTransformDeviceData>(md::ita::AssignInstanceTransformDeviceData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xAF179EFD8A4C83D4;
  v2[1] = "md::ls::InstanceTransformHandle]";
  *(void *)&double result = 31;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD8E0;
  v2[4] = "md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>>]";
  v2[5] = 89;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignInstanceTransformDeviceData>(md::ita::AssignInstanceTransformDeviceData &&)::{lambda(void)#2},std::allocator<md::ita::AssignInstanceTransformDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignInstanceTransformDeviceData>(md::ita::AssignInstanceTransformDeviceData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB66B0(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverMaterialConstantData>(md::ita::AssignFlyoverMaterialConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverMaterialConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverMaterialConstantData>(md::ita::AssignFlyoverMaterialConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0xB70B6DE024A5B9DALL;
  v2[1] = "md::ls::FlyoverCommonMaterialHandle]";
  *(void *)&double result = 35;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD850;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>]";
  v2[5] = 90;
  v2[6] = 0x69465F3BE0BF85FBLL;
  v2[7] = "md::ls::FlyoverInstance]";
  v2[8] = 23;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverMaterialConstantData>(md::ita::AssignFlyoverMaterialConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverMaterialConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverMaterialConstantData>(md::ita::AssignFlyoverMaterialConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB67A8(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignCommandBuffersToRenderItems>(md::ita::AssignCommandBuffersToRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::AssignCommandBuffersToRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignCommandBuffersToRenderItems>(md::ita::AssignCommandBuffersToRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x171C8753A53C145FLL;
  v2[1] = "md::ls::DataForCommandBuffer]";
  *(void *)&double result = 28;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDB10;
  v2[4] = "md::ls::VisibilityTestResult]";
  v2[5] = 28;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignCommandBuffersToRenderItems>(md::ita::AssignCommandBuffersToRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::AssignCommandBuffersToRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignCommandBuffersToRenderItems>(md::ita::AssignCommandBuffersToRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatusRenderables>(md::ita::UpdateProcessedStatusRenderables &&)::{lambda(void)#1},std::allocator<md::ita::UpdateProcessedStatusRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatusRenderables>(md::ita::UpdateProcessedStatusRenderables &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x90uLL);
  a1[2] = (char *)(v2 + 18);
  *unint64_t v2 = 0xCAB567F400206020;
  v2[1] = "md::ls::FinishedProcessing]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FD800;
  v2[4] = "md::ls::PendingProcessing]";
  v2[5] = 25;
  v2[6] = 0x343B7A672BA2F664;
  v2[7] = "md::ls::FinishedProcessingShadow]";
  v2[8] = 32;
  unint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 18)
  {
    *(void *)unint64_t v3 = 0xEC85A518158AB507;
    v2[10] = "md::ls::PendingProcessingShadow]";
    v2[11] = 31;
    unint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_56;
  }
  if (0x5555555555555556 * (((char *)(v2 + 18) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 18) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 18) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_57;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xEC85A518158AB507;
  *((void *)v10 + 1) = "md::ls::PendingProcessingShadow]";
  *((void *)v10 + 2) = 31;
  unint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  unint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)unint64_t v4 = 0x2B00F9EAE99A5837;
    *((void *)v4 + 1) = "md::ls::FinishedProcessingDepthPrePass]";
    *((void *)v4 + 2) = 38;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_56;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_57;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x2B00F9EAE99A5837;
  *((void *)v21 + 1) = "md::ls::FinishedProcessingDepthPrePass]";
  *((void *)v21 + 2) = 38;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  unint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0xB7D4B4C2109DE954;
    *((void *)v14 + 1) = "md::ls::PendingProcessingDepthPrePass]";
    *((void *)v14 + 2) = 37;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_56:
  }
    abort();
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v31 = (char *)operator new(24 * v30);
      goto LABEL_49;
    }
LABEL_57:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v31 = 0;
LABEL_49:
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0xB7D4B4C2109DE954;
  *((void *)v32 + 1) = "md::ls::PendingProcessingDepthPrePass]";
  *((void *)v32 + 2) = 37;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
}

void sub_1A1BB6C7C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatusRenderables>(md::ita::UpdateProcessedStatusRenderables &&)::{lambda(void)#2},std::allocator<md::ita::UpdateProcessedStatusRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatusRenderables>(md::ita::UpdateProcessedStatusRenderables &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateColorRampGradientResources>(md::ita::UpdateColorRampGradientResources &&)::{lambda(void)#1},std::allocator<md::ita::UpdateColorRampGradientResources &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateColorRampGradientResources>(md::ita::UpdateColorRampGradientResources &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xD68EA0DE832DEC03;
  v2[1] = "md::ls::RenderItemID]";
  *(void *)&double result = 20;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDB30;
  v2[4] = "md::ls::ColorRampDataHandle]";
  v2[5] = 27;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateColorRampGradientResources>(md::ita::UpdateColorRampGradientResources &&)::{lambda(void)#2},std::allocator<md::ita::UpdateColorRampGradientResources &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateColorRampGradientResources>(md::ita::UpdateColorRampGradientResources &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightSpecularConfiguration>(md::ita::AssignLightSpecularConfiguration &&)::{lambda(void)#1},std::allocator<md::ita::AssignLightSpecularConfiguration &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightSpecularConfiguration>(md::ita::AssignLightSpecularConfiguration &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  uint64_t v3 = 0;
  *a1 = result;
  a1[1] = result;
  a1[2] = result + 3;
  uint64_t v4 = 0xCBF29CE484222325;
  do
    uint64_t v4 = 0x100000001B3 * (v4 ^ aStdStringViewG_672[v3++ + 38]);
  while (v3 != 103);
  *double result = v4;
  result[1] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>>]";
  result[2] = 103;
  a1[1] = result + 3;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightSpecularConfiguration>(md::ita::AssignLightSpecularConfiguration &&)::{lambda(void)#2},std::allocator<md::ita::AssignLightSpecularConfiguration &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightSpecularConfiguration>(md::ita::AssignLightSpecularConfiguration &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB6DFC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverDiffuseTextureIndex>(md::ita::AssignFlyoverDiffuseTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverDiffuseTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverDiffuseTextureIndex>(md::ita::AssignFlyoverDiffuseTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0xEC8E73EF48115BAELL;
  v2[1] = "md::ls::RequiresShaderTextureID<Flyover::DiffuseTexture>]";
  *(void *)&double result = 56;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD840;
  v2[4] = "md::ls::TextureHandleForType<Flyover::DiffuseTexture>]";
  v2[5] = 53;
  v2[6] = 0x69465F3BE0BF85FBLL;
  v2[7] = "md::ls::FlyoverInstance]";
  v2[8] = 23;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverDiffuseTextureIndex>(md::ita::AssignFlyoverDiffuseTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverDiffuseTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverDiffuseTextureIndex>(md::ita::AssignFlyoverDiffuseTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB6EF4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverSharedConstantData>(md::ita::UpdateFlyoverSharedConstantData &&)::{lambda(void)#1},std::allocator<md::ita::UpdateFlyoverSharedConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverSharedConstantData>(md::ita::UpdateFlyoverSharedConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverSharedConstantData>(md::ita::UpdateFlyoverSharedConstantData &&)::{lambda(void)#2},std::allocator<md::ita::UpdateFlyoverSharedConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverSharedConstantData>(md::ita::UpdateFlyoverSharedConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForFlyoverClip>(md::ita::ProcessRenderableForFlyoverClip &&)::{lambda(void)#1},std::allocator<md::ita::ProcessRenderableForFlyoverClip &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForFlyoverClip>(md::ita::ProcessRenderableForFlyoverClip &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0x2523AFF0E364AA00;
  v2[1] = "md::BoundData]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDE30;
  v2[4] = "md::ls::TileType]";
  v2[5] = 16;
  v2[6] = 0x78FA727E419141C0;
  v2[7] = "md::ls::FlyoverClipPlaneData]";
  v2[8] = 28;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)uint64_t v3 = 0xBED6A4C8B7C54422;
    v2[10] = "md::ls::ModelTransformData]";
    v2[11] = 26;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xBED6A4C8B7C54422;
  *((void *)v10 + 1) = "md::ls::ModelTransformData]";
  *((void *)v10 + 2) = 26;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BB7110(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForFlyoverClip>(md::ita::ProcessRenderableForFlyoverClip &&)::{lambda(void)#2},std::allocator<md::ita::ProcessRenderableForFlyoverClip &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForFlyoverClip>(md::ita::ProcessRenderableForFlyoverClip &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x5E4DB6CB13CB5848;
  result[1] = "md::ls::FlyoverClipConstantDataHandle]";
  result[2] = 37;
  *a1 = result;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessMaterialsForUpdatedStyle>(md::ita::ProcessMaterialsForUpdatedStyle &&)::{lambda(void)#2},std::allocator<md::ita::ProcessMaterialsForUpdatedStyle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessMaterialsForUpdatedStyle>(md::ita::ProcessMaterialsForUpdatedStyle &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x849CB194B84BB63DLL;
  v2[1] = "md::ls::UniqueMaterialVisibilityOptionsHandle]";
  *(void *)&double result = 45;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDF20;
  v2[4] = "md::ls::UniqueMaterialZIndexHandle]";
  v2[5] = 34;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPassCommandBuffers>(md::ita::PrepareShadowPassCommandBuffers &&)::{lambda(void)#1},std::allocator<md::ita::PrepareShadowPassCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPassCommandBuffers>(md::ita::PrepareShadowPassCommandBuffers &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPassCommandBuffers>(md::ita::PrepareShadowPassCommandBuffers &&)::{lambda(void)#2},std::allocator<md::ita::PrepareShadowPassCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPassCommandBuffers>(md::ita::PrepareShadowPassCommandBuffers &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls20PassToCommandBuffersEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB7250(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileTransformConstantData>(md::ita::AssignTileTransformConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignTileTransformConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileTransformConstantData>(md::ita::AssignTileTransformConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x74DC502726E97929;
  v2[1] = "md::ls::TransformConstantDataHandle]";
  *(void *)&double result = 35;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDA40;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Transform>>]";
  v2[5] = 82;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileTransformConstantData>(md::ita::AssignTileTransformConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignTileTransformConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileTransformConstantData>(md::ita::AssignTileTransformConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB7324(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTransitionToFlatData>(md::ita::AssignStyleTransitionToFlatData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleTransitionToFlatData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTransitionToFlatData>(md::ita::AssignStyleTransitionToFlatData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x4ED66455113F81E3;
  result[1] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>>]";
  result[2] = 97;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTransitionToFlatData>(md::ita::AssignStyleTransitionToFlatData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleTransitionToFlatData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTransitionToFlatData>(md::ita::AssignStyleTransitionToFlatData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB73E4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignMaterialStyleConstantData>(md::ita::AssignMaterialStyleConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignMaterialStyleConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignMaterialStyleConstantData>(md::ita::AssignMaterialStyleConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x8DB28088BB3C2FE3;
  v2[1] = "md::ls::MaterialStyleConstantDataHandle]";
  *(void *)&double result = 39;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD9A0;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>]";
  v2[5] = 89;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignMaterialStyleConstantData>(md::ita::AssignMaterialStyleConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignMaterialStyleConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignMaterialStyleConstantData>(md::ita::AssignMaterialStyleConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB74B8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverSharedConstantData>(md::ita::AssignFlyoverSharedConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverSharedConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverSharedConstantData>(md::ita::AssignFlyoverSharedConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0xE57F1B6EAAE9263ALL;
  v2[1] = "md::ls::FlyoverSharedConstants]";
  *(void *)&double result = 30;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD880;
  v2[4] = "md::ls::FlyoverInstance]";
  v2[5] = 23;
  v2[6] = 0x5E5AF20C38ADA136;
  v2[7] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Shared>>]";
  v2[8] = 88;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverSharedConstantData>(md::ita::AssignFlyoverSharedConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverSharedConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverSharedConstantData>(md::ita::AssignFlyoverSharedConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB75B0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForSeeThrough>(md::ita::SetupRenderStatesForSeeThrough &&)::{lambda(void)#1},std::allocator<md::ita::SetupRenderStatesForSeeThrough &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForSeeThrough>(md::ita::SetupRenderStatesForSeeThrough &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0x40FCAF57579CC039;
  v2[1] = "md::ls::IntendedSceneLayerType<md::SceneLayer::SeeThrough>]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDB90;
  v2[4] = "md::ls::MainPassItem]";
  v2[5] = 20;
  v2[6] = 0x73F0259EC1934FB1;
  v2[7] = "md::ls::IsTransparent]";
  v2[8] = 21;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)uint64_t v3 = 0x1E85A99FD528C623;
    v2[10] = "md::ls::NeedsRenderState]";
    v2[11] = 24;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x1E85A99FD528C623;
  *((void *)v10 + 1) = "md::ls::NeedsRenderState]";
  *((void *)v10 + 2) = 24;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BB77B0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForSeeThrough>(md::ita::SetupRenderStatesForSeeThrough &&)::{lambda(void)#2},std::allocator<md::ita::SetupRenderStatesForSeeThrough &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForSeeThrough>(md::ita::SetupRenderStatesForSeeThrough &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialEmissiveTexture>(md::ita::ResolveMaterialEmissiveTexture &&)::{lambda(void)#1},std::allocator<md::ita::ResolveMaterialEmissiveTexture &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialEmissiveTexture>(md::ita::ResolveMaterialEmissiveTexture &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls18UniqueMaterialDataEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB781C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialEmissiveTexture>(md::ita::ResolveMaterialEmissiveTexture &&)::{lambda(void)#2},std::allocator<md::ita::ResolveMaterialEmissiveTexture &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialEmissiveTexture>(md::ita::ResolveMaterialEmissiveTexture &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x1202E9D2D9704CABLL;
  v2[1] = "md::ls::UniqueMaterialEmissiveTexture]";
  *(void *)&double result = 37;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD90;
  v2[4] = "md::ls::SharedMaterialEmissiveTexture]";
  v2[5] = 37;
  v2[6] = 0xCE03281732FA0019;
  v2[7] = "md::ls::TextureHandleForType<DaVinci::EmissiveTexture>]";
  v2[8] = 54;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareStyleConstantDataHandle>(md::ita::PrepareStyleConstantDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareStyleConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareStyleConstantDataHandle>(md::ita::PrepareStyleConstantDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *(void *)&double result = 24;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD60;
  v2[4] = "md::ls::OrientedBox]";
  v2[5] = 19;
  *a1 = v2;
  return result;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareStyleConstantDataHandle>(md::ita::PrepareStyleConstantDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareStyleConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareStyleConstantDataHandle>(md::ita::PrepareStyleConstantDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x1BB343378E1EE5BLL;
  result[1] = "md::ls::StyleDataKeyHandle]";
  result[2] = 26;
  *a1 = result;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRasterOverlayDataHandle>(md::ita::PrepareRasterOverlayDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareRasterOverlayDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRasterOverlayDataHandle>(md::ita::PrepareRasterOverlayDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x8D1BF84D316565E9;
  v2[1] = "md::ls::MercatorBounds]";
  *(void *)&double result = 22;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD50;
  v2[4] = "md::ls::InView]";
  v2[5] = 14;
  v2[6] = 0xB6C12FBB402E8E70;
  v2[7] = "md::ls::RenderableMaterialData]";
  v2[8] = 30;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRasterOverlayDataHandle>(md::ita::PrepareRasterOverlayDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareRasterOverlayDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRasterOverlayDataHandle>(md::ita::PrepareRasterOverlayDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xDC66BF6D06F6D0BALL;
  result[1] = "md::ls::RasterOverlayConstantDataHandle]";
  result[2] = 39;
  *a1 = result;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledDepthPrePassSlice>(md::ita::PrepareCulledDepthPrePassSlice &&)::{lambda(void)#1},std::allocator<md::ita::PrepareCulledDepthPrePassSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledDepthPrePassSlice>(md::ita::PrepareCulledDepthPrePassSlice &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x45B31C2960E9BCB1;
  v2[1] = "md::ls::VisibilityGroupID]";
  *(void *)&double result = 25;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDE60;
  v2[4] = "md::ls::SliceAssignmentT<md::SliceType::CulledMain>]";
  v2[5] = 51;
  v2[6] = 0xFB8BCB8E983A05B1;
  v2[7] = "md::ls::SliceAssignmentT<md::SliceType::CulledMainNotFiltered>]";
  v2[8] = 62;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledDepthPrePassSlice>(md::ita::PrepareCulledDepthPrePassSlice &&)::{lambda(void)#2},std::allocator<md::ita::PrepareCulledDepthPrePassSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledDepthPrePassSlice>(md::ita::PrepareCulledDepthPrePassSlice &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverNightTextureIndex>(md::ita::AssignFlyoverNightTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverNightTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverNightTextureIndex>(md::ita::AssignFlyoverNightTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0xF9931FC5DA4F362;
  v2[1] = "md::ls::RequiresShaderTextureID<Flyover::NightTexture>]";
  *(void *)&double result = 54;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD830;
  v2[4] = "md::ls::TextureHandleForType<Flyover::NightTexture>]";
  v2[5] = 51;
  v2[6] = 0x69465F3BE0BF85FBLL;
  v2[7] = "md::ls::FlyoverInstance]";
  v2[8] = 23;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverNightTextureIndex>(md::ita::AssignFlyoverNightTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverNightTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverNightTextureIndex>(md::ita::AssignFlyoverNightTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB7C1C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDepthPrePassConstantData>(md::ita::AssignDepthPrePassConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignDepthPrePassConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDepthPrePassConstantData>(md::ita::AssignDepthPrePassConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x70E01531993BB945;
  v2[1] = "md::ls::PrepassShadowConstantDataHandle]";
  *(void *)&double result = 39;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDA00;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>]";
  v2[5] = 82;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDepthPrePassConstantData>(md::ita::AssignDepthPrePassConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignDepthPrePassConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDepthPrePassConstantData>(md::ita::AssignDepthPrePassConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB7CF0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleTextureIfNecessary>(md::ita::UpdateStyleTextureIfNecessary &&)::{lambda(void)#1},std::allocator<md::ita::UpdateStyleTextureIfNecessary &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleTextureIfNecessary>(md::ita::UpdateStyleTextureIfNecessary &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x78uLL);
  a1[2] = (char *)(v2 + 15);
  *unint64_t v2 = 0xA219A074B7259E0FLL;
  v2[1] = "md::ls::InView]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD10;
  v2[4] = "md::ls::MeshRenderableID]";
  v2[5] = 24;
  v2[6] = 0xB6C12FBB402E8E70;
  v2[7] = "md::ls::RenderableMaterialData]";
  v2[8] = 30;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 15)
  {
    *(void *)uint64_t v3 = 0x9D7520A01DC69D83;
    v2[10] = "md::ls::HasMaterialRaster]";
    v2[11] = 25;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_38;
  }
  if (0x5555555555555556 * (((char *)(v2 + 15) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 15) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 15) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_39;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x9D7520A01DC69D83;
  *((void *)v10 + 1) = "md::ls::HasMaterialRaster]";
  *((void *)v10 + 2) = 25;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x7A5110AF346E0C7FLL;
    *((void *)v4 + 1) = "md::ls::MaterialRasterMaxIndex]";
    *((void *)v4 + 2) = 30;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_38:
  }
    abort();
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v20 = (char *)operator new(24 * v19);
      goto LABEL_31;
    }
LABEL_39:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v20 = 0;
LABEL_31:
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x7A5110AF346E0C7FLL;
  *((void *)v21 + 1) = "md::ls::MaterialRasterMaxIndex]";
  *((void *)v21 + 2) = 30;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
}

void sub_1A1BB8028(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialDiffuseTexture>(md::ita::ResolveMaterialDiffuseTexture &&)::{lambda(void)#1},std::allocator<md::ita::ResolveMaterialDiffuseTexture &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialDiffuseTexture>(md::ita::ResolveMaterialDiffuseTexture &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls18UniqueMaterialDataEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BB8088(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialDiffuseTexture>(md::ita::ResolveMaterialDiffuseTexture &&)::{lambda(void)#2},std::allocator<md::ita::ResolveMaterialDiffuseTexture &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialDiffuseTexture>(md::ita::ResolveMaterialDiffuseTexture &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0xCF2EB3C843EAD89ALL;
  v2[1] = "md::ls::UniqueMaterialDiffuseTexture]";
  *(void *)&double result = 36;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDDA0;
  v2[4] = "md::ls::SharedMaterialDiffuseTexture]";
  v2[5] = 36;
  v2[6] = 0xDD9825BCFA7911B2;
  v2[7] = "md::ls::TextureHandleForType<DaVinci::DiffuseTexture>]";
  v2[8] = 53;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForLandCover>(md::ita::ProcessRenderableForLandCover &&)::{lambda(void)#1},std::allocator<md::ita::ProcessRenderableForLandCover &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForLandCover>(md::ita::ProcessRenderableForLandCover &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *(void *)&double result = 24;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDDD0;
  v2[4] = "md::ls::RenderablePendingProcessing]";
  v2[5] = 35;
  v2[6] = 0x7A5110AF346E0C7FLL;
  v2[7] = "md::ls::MaterialRasterMaxIndex]";
  v2[8] = 30;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForLandCover>(md::ita::ProcessRenderableForLandCover &&)::{lambda(void)#2},std::allocator<md::ita::ProcessRenderableForLandCover &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForLandCover>(md::ita::ProcessRenderableForLandCover &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareUnflattenedCulledSlice>(md::ita::PrepareUnflattenedCulledSlice &&)::{lambda(void)#1},std::allocator<md::ita::PrepareUnflattenedCulledSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareUnflattenedCulledSlice>(md::ita::PrepareUnflattenedCulledSlice &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x90uLL);
  a1[2] = (char *)(v2 + 18);
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDE90;
  v2[4] = "md::ls::IntendedSceneLayer]";
  v2[5] = 26;
  v2[6] = 0x45B31C2960E9BCB1;
  v2[7] = "md::ls::VisibilityGroupID]";
  v2[8] = 25;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 18)
  {
    *(void *)uint64_t v3 = 0x768C72EB9B71F7ADLL;
    v2[10] = "md::ls::RenderableVisibilityOptions]";
    v2[11] = 35;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_56;
  }
  if (0x5555555555555556 * (((char *)(v2 + 18) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 18) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 18) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_57;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x768C72EB9B71F7ADLL;
  *((void *)v10 + 1) = "md::ls::RenderableVisibilityOptions]";
  *((void *)v10 + 2) = 35;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0xECC498AF223943D5;
    *((void *)v4 + 1) = "md::ls::MeshLayerTypeV]";
    *((void *)v4 + 2) = 22;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_56;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_57;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0xECC498AF223943D5;
  *((void *)v21 + 1) = "md::ls::MeshLayerTypeV]";
  *((void *)v21 + 2) = 22;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0xFB8BCB8E983A05B1;
    *((void *)v14 + 1) = "md::ls::SliceAssignmentT<md::SliceType::CulledMainNotFiltered>]";
    *((void *)v14 + 2) = 62;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_56:
  }
    abort();
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v31 = (char *)operator new(24 * v30);
      goto LABEL_49;
    }
LABEL_57:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v31 = 0;
LABEL_49:
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0xFB8BCB8E983A05B1;
  *((void *)v32 + 1) = "md::ls::SliceAssignmentT<md::SliceType::CulledMainNotFiltered>]";
  *((void *)v32 + 2) = 62;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
}

void sub_1A1BB8618(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareUnflattenedCulledSlice>(md::ita::PrepareUnflattenedCulledSlice &&)::{lambda(void)#2},std::allocator<md::ita::PrepareUnflattenedCulledSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareUnflattenedCulledSlice>(md::ita::PrepareUnflattenedCulledSlice &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPassCommandBuffers>(md::ita::PrepareMainPassCommandBuffers &&)::{lambda(void)#1},std::allocator<md::ita::PrepareMainPassCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPassCommandBuffers>(md::ita::PrepareMainPassCommandBuffers &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPrePassRenderItems>(md::ita::CreateDepthPrePassRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::CreateDepthPrePassRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPrePassRenderItems>(md::ita::CreateDepthPrePassRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0x2DFCB5932E0A2DE3;
  v2[1] = "md::ls::SliceAssignmentT<md::SliceType::CulledDepthPrePass>]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDCD0;
  v2[4] = "md::ls::RenderableMeshVertexFormat]";
  v2[5] = 34;
  v2[6] = 0x751B872B282C3971;
  v2[7] = "md::ls::TileType]";
  v2[8] = 16;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)uint64_t v3 = 0xB7D4B4C2109DE954;
    v2[10] = "md::ls::PendingProcessingDepthPrePass]";
    v2[11] = 37;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xB7D4B4C2109DE954;
  *((void *)v10 + 1) = "md::ls::PendingProcessingDepthPrePass]";
  *((void *)v10 + 2) = 37;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BB8834(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPrePassRenderItems>(md::ita::CreateDepthPrePassRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::CreateDepthPrePassRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPrePassRenderItems>(md::ita::CreateDepthPrePassRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x198uLL);
  a1[2] = (char *)(v2 + 51);
  *unint64_t v2 = 0x523816724122CCE2;
  v2[1] = "md::ls::AssociationHandle]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDCB0;
  v2[4] = "md::ls::HasMeshHandle]";
  v2[5] = 21;
  v2[6] = 0x6C7EE74910D42096;
  v2[7] = "md::ls::PositionScaleInfoConstantDataHandle]";
  v2[8] = 43;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 51)
  {
    *(void *)uint64_t v3 = 0xCFE242268B958ADALL;
    v2[10] = "md::ls::ViewConstantDataHandle]";
    v2[11] = 30;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_254;
  }
  if (0x5555555555555556 * (((char *)(v2 + 51) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 51) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 51) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_255;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xCFE242268B958ADALL;
  *((void *)v10 + 1) = "md::ls::ViewConstantDataHandle]";
  *((void *)v10 + 2) = 30;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x74DC502726E97929;
    *((void *)v4 + 1) = "md::ls::TransformConstantDataHandle]";
    *((void *)v4 + 2) = 35;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_254;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_255;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x74DC502726E97929;
  *((void *)v21 + 1) = "md::ls::TransformConstantDataHandle]";
  *((void *)v21 + 2) = 35;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0x71CBA64B1A9CA230;
    *((void *)v14 + 1) = "md::ls::IndexRange]";
    *((void *)v14 + 2) = 18;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_254;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_255;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0x71CBA64B1A9CA230;
  *((void *)v32 + 1) = "md::ls::IndexRange]";
  *((void *)v32 + 2) = 18;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0x3218EFD67197A145;
    *((void *)v25 + 1) = "md::ls::NormalsHandle]";
    *((void *)v25 + 2) = 21;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_254;
  }
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_255;
    }
    uint64_t v42 = (char *)operator new(24 * v41);
  }
  else
  {
    uint64_t v42 = 0;
  }
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0x3218EFD67197A145;
  *((void *)v43 + 1) = "md::ls::NormalsHandle]";
  *((void *)v43 + 2) = 21;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
  unint64_t v46 = (unint64_t)a1[2];
  if ((unint64_t)v36 < v46)
  {
    *(void *)uint64_t v36 = 0xAF179EFD8A4C83D4;
    *((void *)v36 + 1) = "md::ls::InstanceTransformHandle]";
    *((void *)v36 + 2) = 31;
    unint64_t v47 = v36 + 24;
    goto LABEL_91;
  }
  uint64_t v48 = *a1;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v36 - *a1) >> 3);
  unint64_t v50 = v49 + 1;
  if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_254;
  }
  unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v48) >> 3);
  if (2 * v51 > v50) {
    unint64_t v50 = 2 * v51;
  }
  if (v51 >= 0x555555555555555) {
    unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v52 = v50;
  }
  if (v52)
  {
    if (v52 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_255;
    }
    uint64_t v53 = (char *)operator new(24 * v52);
  }
  else
  {
    uint64_t v53 = 0;
  }
  uint64_t v54 = &v53[24 * v49];
  uint64_t v55 = &v53[24 * v52];
  *(void *)uint64_t v54 = 0xAF179EFD8A4C83D4;
  *((void *)v54 + 1) = "md::ls::InstanceTransformHandle]";
  *((void *)v54 + 2) = 31;
  unint64_t v47 = v54 + 24;
  if (v36 == v48)
  {
    *a1 = v54;
    a1[1] = v47;
    a1[2] = v55;
LABEL_90:
    operator delete(v36);
    goto LABEL_91;
  }
  do
  {
    long long v56 = *(_OWORD *)(v36 - 24);
    *((void *)v54 - 1) = *((void *)v36 - 1);
    *(_OWORD *)(v54 - 24) = v56;
    v54 -= 24;
    v36 -= 24;
  }
  while (v36 != v48);
  uint64_t v36 = *a1;
  *a1 = v54;
  a1[1] = v47;
  a1[2] = v55;
  if (v36) {
    goto LABEL_90;
  }
LABEL_91:
  a1[1] = v47;
  unint64_t v57 = (unint64_t)a1[2];
  if ((unint64_t)v47 < v57)
  {
    *(void *)unint64_t v47 = 0xCBB77B1CBD05D7C5;
    *((void *)v47 + 1) = "md::ls::UVsHandle]";
    *((void *)v47 + 2) = 17;
    unint64_t v58 = v47 + 24;
    goto LABEL_109;
  }
  unint64_t v59 = *a1;
  unint64_t v60 = 0xAAAAAAAAAAAAAAABLL * ((v47 - *a1) >> 3);
  unint64_t v61 = v60 + 1;
  if (v60 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_254;
  }
  unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v57 - (void)v59) >> 3);
  if (2 * v62 > v61) {
    unint64_t v61 = 2 * v62;
  }
  if (v62 >= 0x555555555555555) {
    unint64_t v63 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v63 = v61;
  }
  if (v63)
  {
    if (v63 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_255;
    }
    uint64_t v64 = (char *)operator new(24 * v63);
  }
  else
  {
    uint64_t v64 = 0;
  }
  unint64_t v65 = &v64[24 * v60];
  long long v66 = &v64[24 * v63];
  *(void *)unint64_t v65 = 0xCBB77B1CBD05D7C5;
  *((void *)v65 + 1) = "md::ls::UVsHandle]";
  *((void *)v65 + 2) = 17;
  unint64_t v58 = v65 + 24;
  if (v47 == v59)
  {
    *a1 = v65;
    a1[1] = v58;
    a1[2] = v66;
LABEL_108:
    operator delete(v47);
    goto LABEL_109;
  }
  do
  {
    long long v67 = *(_OWORD *)(v47 - 24);
    *((void *)v65 - 1) = *((void *)v47 - 1);
    *(_OWORD *)(v65 - 24) = v67;
    v65 -= 24;
    v47 -= 24;
  }
  while (v47 != v59);
  unint64_t v47 = *a1;
  *a1 = v65;
  a1[1] = v58;
  a1[2] = v66;
  if (v47) {
    goto LABEL_108;
  }
LABEL_109:
  a1[1] = v58;
  unint64_t v68 = (unint64_t)a1[2];
  if ((unint64_t)v58 < v68)
  {
    *(void *)unint64_t v58 = 0x499CE17DBD9A1615;
    *((void *)v58 + 1) = "md::ls::NeedsZBias]";
    *((void *)v58 + 2) = 18;
    uint64_t v69 = v58 + 24;
    goto LABEL_127;
  }
  uint64_t v70 = *a1;
  unint64_t v71 = 0xAAAAAAAAAAAAAAABLL * ((v58 - *a1) >> 3);
  unint64_t v72 = v71 + 1;
  if (v71 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_254;
  }
  unint64_t v73 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v68 - (void)v70) >> 3);
  if (2 * v73 > v72) {
    unint64_t v72 = 2 * v73;
  }
  if (v73 >= 0x555555555555555) {
    unint64_t v74 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v74 = v72;
  }
  if (v74)
  {
    if (v74 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_255;
    }
    uint64_t v75 = (char *)operator new(24 * v74);
  }
  else
  {
    uint64_t v75 = 0;
  }
  unint64_t v76 = &v75[24 * v71];
  size_t v77 = &v75[24 * v74];
  *(void *)unint64_t v76 = 0x499CE17DBD9A1615;
  *((void *)v76 + 1) = "md::ls::NeedsZBias]";
  *((void *)v76 + 2) = 18;
  uint64_t v69 = v76 + 24;
  if (v58 == v70)
  {
    *a1 = v76;
    a1[1] = v69;
    a1[2] = v77;
LABEL_126:
    operator delete(v58);
    goto LABEL_127;
  }
  do
  {
    long long v78 = *(_OWORD *)(v58 - 24);
    *((void *)v76 - 1) = *((void *)v58 - 1);
    *(_OWORD *)(v76 - 24) = v78;
    v76 -= 24;
    v58 -= 24;
  }
  while (v58 != v70);
  unint64_t v58 = *a1;
  *a1 = v76;
  a1[1] = v69;
  a1[2] = v77;
  if (v58) {
    goto LABEL_126;
  }
LABEL_127:
  a1[1] = v69;
  unint64_t v79 = (unint64_t)a1[2];
  if ((unint64_t)v69 < v79)
  {
    *(void *)uint64_t v69 = 0xD443D3DCBB78491ALL;
    *((void *)v69 + 1) = "md::ls::ElevationHandle]";
    *((void *)v69 + 2) = 23;
    int16x8_t v80 = v69 + 24;
    goto LABEL_145;
  }
  uint64_t v81 = *a1;
  unint64_t v82 = 0xAAAAAAAAAAAAAAABLL * ((v69 - *a1) >> 3);
  unint64_t v83 = v82 + 1;
  if (v82 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_254;
  }
  unint64_t v84 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v79 - (void)v81) >> 3);
  if (2 * v84 > v83) {
    unint64_t v83 = 2 * v84;
  }
  if (v84 >= 0x555555555555555) {
    unint64_t v85 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v85 = v83;
  }
  if (v85)
  {
    if (v85 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_255;
    }
    uint64_t v86 = (char *)operator new(24 * v85);
  }
  else
  {
    uint64_t v86 = 0;
  }
  int8x8_t v87 = &v86[24 * v82];
  uint64_t v88 = &v86[24 * v85];
  *(void *)int8x8_t v87 = 0xD443D3DCBB78491ALL;
  *((void *)v87 + 1) = "md::ls::ElevationHandle]";
  *((void *)v87 + 2) = 23;
  int16x8_t v80 = v87 + 24;
  if (v69 == v81)
  {
    *a1 = v87;
    a1[1] = v80;
    a1[2] = v88;
LABEL_144:
    operator delete(v69);
    goto LABEL_145;
  }
  do
  {
    long long v89 = *(_OWORD *)(v69 - 24);
    *((void *)v87 - 1) = *((void *)v69 - 1);
    *(_OWORD *)(v87 - 24) = v89;
    v87 -= 24;
    v69 -= 24;
  }
  while (v69 != v81);
  uint64_t v69 = *a1;
  *a1 = v87;
  a1[1] = v80;
  a1[2] = v88;
  if (v69) {
    goto LABEL_144;
  }
LABEL_145:
  a1[1] = v80;
  unint64_t v90 = (unint64_t)a1[2];
  if ((unint64_t)v80 < v90)
  {
    *(void *)int16x8_t v80 = 0x70E01531993BB945;
    *((void *)v80 + 1) = "md::ls::PrepassShadowConstantDataHandle]";
    *((void *)v80 + 2) = 39;
    BOOL v91 = v80 + 24;
    goto LABEL_163;
  }
  int8x16_t v92 = *a1;
  unint64_t v93 = 0xAAAAAAAAAAAAAAABLL * ((v80 - *a1) >> 3);
  unint64_t v94 = v93 + 1;
  if (v93 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_254;
  }
  unint64_t v95 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v90 - (void)v92) >> 3);
  if (2 * v95 > v94) {
    unint64_t v94 = 2 * v95;
  }
  if (v95 >= 0x555555555555555) {
    unint64_t v96 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v96 = v94;
  }
  if (v96)
  {
    if (v96 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_255;
    }
    int8x16_t v97 = (char *)operator new(24 * v96);
  }
  else
  {
    int8x16_t v97 = 0;
  }
  int16x8_t v98 = &v97[24 * v93];
  int32x4_t v99 = &v97[24 * v96];
  *(void *)int16x8_t v98 = 0x70E01531993BB945;
  *((void *)v98 + 1) = "md::ls::PrepassShadowConstantDataHandle]";
  *((void *)v98 + 2) = 39;
  BOOL v91 = v98 + 24;
  if (v80 == v92)
  {
    *a1 = v98;
    a1[1] = v91;
    a1[2] = v99;
LABEL_162:
    operator delete(v80);
    goto LABEL_163;
  }
  do
  {
    long long v100 = *(_OWORD *)(v80 - 24);
    *((void *)v98 - 1) = *((void *)v80 - 1);
    *(_OWORD *)(v98 - 24) = v100;
    v98 -= 24;
    v80 -= 24;
  }
  while (v80 != v92);
  int16x8_t v80 = *a1;
  *a1 = v98;
  a1[1] = v91;
  a1[2] = v99;
  if (v80) {
    goto LABEL_162;
  }
LABEL_163:
  a1[1] = v91;
  unint64_t v101 = (unint64_t)a1[2];
  if ((unint64_t)v91 < v101)
  {
    *(void *)BOOL v91 = 0x1EBB3E0519E8FF9DLL;
    *((void *)v91 + 1) = "md::ls::PrepassConstantDataHandle]";
    *((void *)v91 + 2) = 33;
    uint64_t v102 = v91 + 24;
    goto LABEL_181;
  }
  int32x4_t v103 = *a1;
  unint64_t v104 = 0xAAAAAAAAAAAAAAABLL * ((v91 - *a1) >> 3);
  unint64_t v105 = v104 + 1;
  if (v104 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_254;
  }
  unint64_t v106 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v101 - (void)v103) >> 3);
  if (2 * v106 > v105) {
    unint64_t v105 = 2 * v106;
  }
  if (v106 >= 0x555555555555555) {
    unint64_t v107 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v107 = v105;
  }
  if (v107)
  {
    if (v107 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_255;
    }
    uint64_t v108 = (char *)operator new(24 * v107);
  }
  else
  {
    uint64_t v108 = 0;
  }
  int8x16_t v109 = &v108[24 * v104];
  unint64_t v110 = &v108[24 * v107];
  *(void *)int8x16_t v109 = 0x1EBB3E0519E8FF9DLL;
  *((void *)v109 + 1) = "md::ls::PrepassConstantDataHandle]";
  *((void *)v109 + 2) = 33;
  uint64_t v102 = v109 + 24;
  if (v91 == v103)
  {
    *a1 = v109;
    a1[1] = v102;
    a1[2] = v110;
LABEL_180:
    operator delete(v91);
    goto LABEL_181;
  }
  do
  {
    long long v111 = *(_OWORD *)(v91 - 24);
    *((void *)v109 - 1) = *((void *)v91 - 1);
    *(_OWORD *)(v109 - 24) = v111;
    v109 -= 24;
    v91 -= 24;
  }
  while (v91 != v103);
  BOOL v91 = *a1;
  *a1 = v109;
  a1[1] = v102;
  a1[2] = v110;
  if (v91) {
    goto LABEL_180;
  }
LABEL_181:
  a1[1] = v102;
  unint64_t v112 = (unint64_t)a1[2];
  if ((unint64_t)v102 < v112)
  {
    *(void *)uint64_t v102 = 0x98A9F01DBB8BCCCELL;
    *((void *)v102 + 1) = "md::ls::PreserveHeight]";
    *((void *)v102 + 2) = 22;
    int8x16_t v113 = v102 + 24;
    goto LABEL_199;
  }
  int v114 = *a1;
  unint64_t v115 = 0xAAAAAAAAAAAAAAABLL * ((v102 - *a1) >> 3);
  unint64_t v116 = v115 + 1;
  if (v115 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_254;
  }
  unint64_t v117 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v112 - (void)v114) >> 3);
  if (2 * v117 > v116) {
    unint64_t v116 = 2 * v117;
  }
  if (v117 >= 0x555555555555555) {
    unint64_t v118 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v118 = v116;
  }
  if (v118)
  {
    if (v118 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_255;
    }
    int v119 = (char *)operator new(24 * v118);
  }
  else
  {
    int v119 = 0;
  }
  int32x4_t v120 = &v119[24 * v115];
  int8x16_t v121 = &v119[24 * v118];
  *(void *)int32x4_t v120 = 0x98A9F01DBB8BCCCELL;
  *((void *)v120 + 1) = "md::ls::PreserveHeight]";
  *((void *)v120 + 2) = 22;
  int8x16_t v113 = v120 + 24;
  if (v102 == v114)
  {
    *a1 = v120;
    a1[1] = v113;
    a1[2] = v121;
LABEL_198:
    operator delete(v102);
    goto LABEL_199;
  }
  do
  {
    long long v122 = *(_OWORD *)(v102 - 24);
    *((void *)v120 - 1) = *((void *)v102 - 1);
    *(_OWORD *)(v120 - 24) = v122;
    v120 -= 24;
    v102 -= 24;
  }
  while (v102 != v114);
  uint64_t v102 = *a1;
  *a1 = v120;
  a1[1] = v113;
  a1[2] = v121;
  if (v102) {
    goto LABEL_198;
  }
LABEL_199:
  a1[1] = v113;
  unint64_t v123 = (unint64_t)a1[2];
  if ((unint64_t)v113 < v123)
  {
    *(void *)int8x16_t v113 = 0x9292F9031FE6DB5;
    *((void *)v113 + 1) = "md::ls::ClippingConstantDataHandle]";
    *((void *)v113 + 2) = 34;
    uint64_t v124 = v113 + 24;
    goto LABEL_217;
  }
  int8x16_t v125 = *a1;
  unint64_t v126 = 0xAAAAAAAAAAAAAAABLL * ((v113 - *a1) >> 3);
  unint64_t v127 = v126 + 1;
  if (v126 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_254;
  }
  unint64_t v128 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v123 - (void)v125) >> 3);
  if (2 * v128 > v127) {
    unint64_t v127 = 2 * v128;
  }
  if (v128 >= 0x555555555555555) {
    unint64_t v129 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v129 = v127;
  }
  if (v129)
  {
    if (v129 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_255;
    }
    uint64_t v130 = (char *)operator new(24 * v129);
  }
  else
  {
    uint64_t v130 = 0;
  }
  uint64_t v131 = &v130[24 * v126];
  float v132 = &v130[24 * v129];
  *(void *)uint64_t v131 = 0x9292F9031FE6DB5;
  *((void *)v131 + 1) = "md::ls::ClippingConstantDataHandle]";
  *((void *)v131 + 2) = 34;
  uint64_t v124 = v131 + 24;
  if (v113 == v125)
  {
    *a1 = v131;
    a1[1] = v124;
    a1[2] = v132;
LABEL_216:
    operator delete(v113);
    goto LABEL_217;
  }
  do
  {
    long long v133 = *(_OWORD *)(v113 - 24);
    *((void *)v131 - 1) = *((void *)v113 - 1);
    *(_OWORD *)(v131 - 24) = v133;
    v131 -= 24;
    v113 -= 24;
  }
  while (v113 != v125);
  int8x16_t v113 = *a1;
  *a1 = v131;
  a1[1] = v124;
  a1[2] = v132;
  if (v113) {
    goto LABEL_216;
  }
LABEL_217:
  a1[1] = v124;
  unint64_t v134 = (unint64_t)a1[2];
  if ((unint64_t)v124 < v134)
  {
    *(void *)uint64_t v124 = 0x237F9D3BCC905318;
    *((void *)v124 + 1) = "md::ls::IsMercator]";
    *((void *)v124 + 2) = 18;
    unint64_t v135 = v124 + 24;
    goto LABEL_235;
  }
  long long v136 = *a1;
  unint64_t v137 = 0xAAAAAAAAAAAAAAABLL * ((v124 - *a1) >> 3);
  unint64_t v138 = v137 + 1;
  if (v137 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_254;
  }
  unint64_t v139 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v134 - (void)v136) >> 3);
  if (2 * v139 > v138) {
    unint64_t v138 = 2 * v139;
  }
  if (v139 >= 0x555555555555555) {
    unint64_t v140 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v140 = v138;
  }
  if (v140)
  {
    if (v140 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_255;
    }
    float v141 = (char *)operator new(24 * v140);
  }
  else
  {
    float v141 = 0;
  }
  uint64_t v142 = &v141[24 * v137];
  uint64_t v143 = &v141[24 * v140];
  *(void *)uint64_t v142 = 0x237F9D3BCC905318;
  *((void *)v142 + 1) = "md::ls::IsMercator]";
  *((void *)v142 + 2) = 18;
  unint64_t v135 = v142 + 24;
  if (v124 == v136)
  {
    *a1 = v142;
    a1[1] = v135;
    a1[2] = v143;
LABEL_234:
    operator delete(v124);
    goto LABEL_235;
  }
  do
  {
    long long v144 = *(_OWORD *)(v124 - 24);
    *((void *)v142 - 1) = *((void *)v124 - 1);
    *(_OWORD *)(v142 - 24) = v144;
    v142 -= 24;
    v124 -= 24;
  }
  while (v124 != v136);
  uint64_t v124 = *a1;
  *a1 = v142;
  a1[1] = v135;
  a1[2] = v143;
  if (v124) {
    goto LABEL_234;
  }
LABEL_235:
  a1[1] = v135;
  unint64_t v145 = (unint64_t)a1[2];
  if ((unint64_t)v135 < v145)
  {
    *(void *)unint64_t v135 = 0xE53EF176130D7769;
    *((void *)v135 + 1) = "md::ls::InstanceCount]";
    *((void *)v135 + 2) = 21;
    uint64_t v146 = v135 + 24;
    goto LABEL_253;
  }
  uint64_t v147 = *a1;
  unint64_t v148 = 0xAAAAAAAAAAAAAAABLL * ((v135 - *a1) >> 3);
  unint64_t v149 = v148 + 1;
  if (v148 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_254:
  }
    abort();
  unint64_t v150 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v145 - (void)v147) >> 3);
  if (2 * v150 > v149) {
    unint64_t v149 = 2 * v150;
  }
  if (v150 >= 0x555555555555555) {
    unint64_t v151 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v151 = v149;
  }
  if (v151)
  {
    if (v151 <= 0xAAAAAAAAAAAAAAALL)
    {
      double v152 = (char *)operator new(24 * v151);
      goto LABEL_247;
    }
LABEL_255:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  double v152 = 0;
LABEL_247:
  double v153 = &v152[24 * v148];
  double v154 = &v152[24 * v151];
  *(void *)double v153 = 0xE53EF176130D7769;
  *((void *)v153 + 1) = "md::ls::InstanceCount]";
  *((void *)v153 + 2) = 21;
  uint64_t v146 = v153 + 24;
  if (v135 == v147)
  {
    *a1 = v153;
    a1[1] = v146;
    a1[2] = v154;
LABEL_252:
    operator delete(v135);
    goto LABEL_253;
  }
  do
  {
    long long v155 = *(_OWORD *)(v135 - 24);
    *((void *)v153 - 1) = *((void *)v135 - 1);
    *(_OWORD *)(v153 - 24) = v155;
    v153 -= 24;
    v135 -= 24;
  }
  while (v135 != v147);
  unint64_t v135 = *a1;
  *a1 = v153;
  a1[1] = v146;
  a1[2] = v154;
  if (v135) {
    goto LABEL_252;
  }
LABEL_253:
  a1[1] = v146;
}

void sub_1A1BB9914(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectFlyoverMeshRenderables>(md::ita::CollectFlyoverMeshRenderables &&)::{lambda(void)#1},std::allocator<md::ita::CollectFlyoverMeshRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectFlyoverMeshRenderables>(md::ita::CollectFlyoverMeshRenderables &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x108uLL);
  a1[2] = (char *)(v2 + 33);
  *unint64_t v2 = 0x41650A8095FBA956;
  v2[1] = "md::ls::RegisterHandle]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDF50;
  v2[4] = "md::ls::EnteringView]";
  v2[5] = 20;
  v2[6] = 0x695C99F828CA9E84;
  v2[7] = "md::ls::BaseMapTileHandle]";
  v2[8] = 25;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 33)
  {
    *(void *)uint64_t v3 = 0xFC370D9176A00DEBLL;
    v2[10] = "md::ls::TileRenderableTypeT<md::FlyoverRenderable>]";
    v2[11] = 50;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_146;
  }
  if (0x5555555555555556 * (((char *)(v2 + 33) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 33) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 33) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_147;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xFC370D9176A00DEBLL;
  *((void *)v10 + 1) = "md::ls::TileRenderableTypeT<md::FlyoverRenderable>]";
  *((void *)v10 + 2) = 50;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x52DA3EA752368C9DLL;
    *((void *)v4 + 1) = "md::ls::MapDataTypeV]";
    *((void *)v4 + 2) = 20;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_146;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_147;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x52DA3EA752368C9DLL;
  *((void *)v21 + 1) = "md::ls::MapDataTypeV]";
  *((void *)v21 + 2) = 20;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0x24B7D588576BB14ELL;
    *((void *)v14 + 1) = "md::ls::AssociationTileHandle]";
    *((void *)v14 + 2) = 29;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_146;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_147;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0x24B7D588576BB14ELL;
  *((void *)v32 + 1) = "md::ls::AssociationTileHandle]";
  *((void *)v32 + 2) = 29;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0x93E8A4F5122D6D07;
    *((void *)v25 + 1) = "md::ls::GlobeMatrixData]";
    *((void *)v25 + 2) = 23;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_146;
  }
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_147;
    }
    uint64_t v42 = (char *)operator new(24 * v41);
  }
  else
  {
    uint64_t v42 = 0;
  }
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0x93E8A4F5122D6D07;
  *((void *)v43 + 1) = "md::ls::GlobeMatrixData]";
  *((void *)v43 + 2) = 23;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
  unint64_t v46 = (unint64_t)a1[2];
  if ((unint64_t)v36 < v46)
  {
    *(void *)uint64_t v36 = 0xBCC33905201D8160;
    *((void *)v36 + 1) = "md::ls::TileMatrix]";
    *((void *)v36 + 2) = 18;
    unint64_t v47 = v36 + 24;
    goto LABEL_91;
  }
  uint64_t v48 = *a1;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v36 - *a1) >> 3);
  unint64_t v50 = v49 + 1;
  if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_146;
  }
  unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v48) >> 3);
  if (2 * v51 > v50) {
    unint64_t v50 = 2 * v51;
  }
  if (v51 >= 0x555555555555555) {
    unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v52 = v50;
  }
  if (v52)
  {
    if (v52 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_147;
    }
    uint64_t v53 = (char *)operator new(24 * v52);
  }
  else
  {
    uint64_t v53 = 0;
  }
  uint64_t v54 = &v53[24 * v49];
  uint64_t v55 = &v53[24 * v52];
  *(void *)uint64_t v54 = 0xBCC33905201D8160;
  *((void *)v54 + 1) = "md::ls::TileMatrix]";
  *((void *)v54 + 2) = 18;
  unint64_t v47 = v54 + 24;
  if (v36 == v48)
  {
    *a1 = v54;
    a1[1] = v47;
    a1[2] = v55;
LABEL_90:
    operator delete(v36);
    goto LABEL_91;
  }
  do
  {
    long long v56 = *(_OWORD *)(v36 - 24);
    *((void *)v54 - 1) = *((void *)v36 - 1);
    *(_OWORD *)(v54 - 24) = v56;
    v54 -= 24;
    v36 -= 24;
  }
  while (v36 != v48);
  uint64_t v36 = *a1;
  *a1 = v54;
  a1[1] = v47;
  a1[2] = v55;
  if (v36) {
    goto LABEL_90;
  }
LABEL_91:
  a1[1] = v47;
  unint64_t v57 = (unint64_t)a1[2];
  if ((unint64_t)v47 < v57)
  {
    *(void *)unint64_t v47 = 0xD270E8E58701C515;
    *((void *)v47 + 1) = "md::ls::TileTransformConstantDataHandle]";
    *((void *)v47 + 2) = 39;
    unint64_t v58 = v47 + 24;
    goto LABEL_109;
  }
  unint64_t v59 = *a1;
  unint64_t v60 = 0xAAAAAAAAAAAAAAABLL * ((v47 - *a1) >> 3);
  unint64_t v61 = v60 + 1;
  if (v60 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_146;
  }
  unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v57 - (void)v59) >> 3);
  if (2 * v62 > v61) {
    unint64_t v61 = 2 * v62;
  }
  if (v62 >= 0x555555555555555) {
    unint64_t v63 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v63 = v61;
  }
  if (v63)
  {
    if (v63 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_147;
    }
    uint64_t v64 = (char *)operator new(24 * v63);
  }
  else
  {
    uint64_t v64 = 0;
  }
  unint64_t v65 = &v64[24 * v60];
  long long v66 = &v64[24 * v63];
  *(void *)unint64_t v65 = 0xD270E8E58701C515;
  *((void *)v65 + 1) = "md::ls::TileTransformConstantDataHandle]";
  *((void *)v65 + 2) = 39;
  unint64_t v58 = v65 + 24;
  if (v47 == v59)
  {
    *a1 = v65;
    a1[1] = v58;
    a1[2] = v66;
LABEL_108:
    operator delete(v47);
    goto LABEL_109;
  }
  do
  {
    long long v67 = *(_OWORD *)(v47 - 24);
    *((void *)v65 - 1) = *((void *)v47 - 1);
    *(_OWORD *)(v65 - 24) = v67;
    v65 -= 24;
    v47 -= 24;
  }
  while (v47 != v59);
  unint64_t v47 = *a1;
  *a1 = v65;
  a1[1] = v58;
  a1[2] = v66;
  if (v47) {
    goto LABEL_108;
  }
LABEL_109:
  a1[1] = v58;
  unint64_t v68 = (unint64_t)a1[2];
  if ((unint64_t)v58 < v68)
  {
    *(void *)unint64_t v58 = 0x414BF8D9069621AELL;
    *((void *)v58 + 1) = "md::ls::TileViewConstantDataHandle]";
    *((void *)v58 + 2) = 34;
    uint64_t v69 = v58 + 24;
    goto LABEL_127;
  }
  uint64_t v70 = *a1;
  unint64_t v71 = 0xAAAAAAAAAAAAAAABLL * ((v58 - *a1) >> 3);
  unint64_t v72 = v71 + 1;
  if (v71 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_146;
  }
  unint64_t v73 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v68 - (void)v70) >> 3);
  if (2 * v73 > v72) {
    unint64_t v72 = 2 * v73;
  }
  if (v73 >= 0x555555555555555) {
    unint64_t v74 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v74 = v72;
  }
  if (v74)
  {
    if (v74 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_147;
    }
    uint64_t v75 = (char *)operator new(24 * v74);
  }
  else
  {
    uint64_t v75 = 0;
  }
  unint64_t v76 = &v75[24 * v71];
  size_t v77 = &v75[24 * v74];
  *(void *)unint64_t v76 = 0x414BF8D9069621AELL;
  *((void *)v76 + 1) = "md::ls::TileViewConstantDataHandle]";
  *((void *)v76 + 2) = 34;
  uint64_t v69 = v76 + 24;
  if (v58 == v70)
  {
    *a1 = v76;
    a1[1] = v69;
    a1[2] = v77;
LABEL_126:
    operator delete(v58);
    goto LABEL_127;
  }
  do
  {
    long long v78 = *(_OWORD *)(v58 - 24);
    *((void *)v76 - 1) = *((void *)v58 - 1);
    *(_OWORD *)(v76 - 24) = v78;
    v76 -= 24;
    v58 -= 24;
  }
  while (v58 != v70);
  unint64_t v58 = *a1;
  *a1 = v76;
  a1[1] = v69;
  a1[2] = v77;
  if (v58) {
    goto LABEL_126;
  }
LABEL_127:
  a1[1] = v69;
  unint64_t v79 = (unint64_t)a1[2];
  if ((unint64_t)v69 < v79)
  {
    *(void *)uint64_t v69 = 0x53EA4A91D91C8985;
    *((void *)v69 + 1) = "md::ls::FlyoverOctileKey]";
    *((void *)v69 + 2) = 24;
    int16x8_t v80 = v69 + 24;
    goto LABEL_145;
  }
  uint64_t v81 = *a1;
  unint64_t v82 = 0xAAAAAAAAAAAAAAABLL * ((v69 - *a1) >> 3);
  unint64_t v83 = v82 + 1;
  if (v82 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_146:
  }
    abort();
  unint64_t v84 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v79 - (void)v81) >> 3);
  if (2 * v84 > v83) {
    unint64_t v83 = 2 * v84;
  }
  if (v84 >= 0x555555555555555) {
    unint64_t v85 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v85 = v83;
  }
  if (v85)
  {
    if (v85 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v86 = (char *)operator new(24 * v85);
      goto LABEL_139;
    }
LABEL_147:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v86 = 0;
LABEL_139:
  int8x8_t v87 = &v86[24 * v82];
  uint64_t v88 = &v86[24 * v85];
  *(void *)int8x8_t v87 = 0x53EA4A91D91C8985;
  *((void *)v87 + 1) = "md::ls::FlyoverOctileKey]";
  *((void *)v87 + 2) = 24;
  int16x8_t v80 = v87 + 24;
  if (v69 == v81)
  {
    *a1 = v87;
    a1[1] = v80;
    a1[2] = v88;
LABEL_144:
    operator delete(v69);
    goto LABEL_145;
  }
  do
  {
    long long v89 = *(_OWORD *)(v69 - 24);
    *((void *)v87 - 1) = *((void *)v69 - 1);
    *(_OWORD *)(v87 - 24) = v89;
    v87 -= 24;
    v69 -= 24;
  }
  while (v69 != v81);
  uint64_t v69 = *a1;
  *a1 = v87;
  a1[1] = v80;
  a1[2] = v88;
  if (v69) {
    goto LABEL_144;
  }
LABEL_145:
  a1[1] = v80;
}

void sub_1A1BBA318(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectFlyoverMeshRenderables>(md::ita::CollectFlyoverMeshRenderables &&)::{lambda(void)#2},std::allocator<md::ita::CollectFlyoverMeshRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectFlyoverMeshRenderables>(md::ita::CollectFlyoverMeshRenderables &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectDaVinciMeshRenderables>(md::ita::CollectDaVinciMeshRenderables &&)::{lambda(void)#1},std::allocator<md::ita::CollectDaVinciMeshRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectDaVinciMeshRenderables>(md::ita::CollectDaVinciMeshRenderables &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x1B0uLL);
  a1[2] = (char *)(v2 + 54);
  *unint64_t v2 = 0x41650A8095FBA956;
  v2[1] = "md::ls::RegisterHandle]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDF50;
  v2[4] = "md::ls::EnteringView]";
  v2[5] = 20;
  v2[6] = 0x695C99F828CA9E84;
  v2[7] = "md::ls::BaseMapTileHandle]";
  v2[8] = 25;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 54)
  {
    *(void *)uint64_t v3 = 0x24B7D588576BB14ELL;
    v2[10] = "md::ls::AssociationTileHandle]";
    v2[11] = 29;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_272;
  }
  if (0x5555555555555556 * (((char *)(v2 + 54) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 54) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 54) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_273;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x24B7D588576BB14ELL;
  *((void *)v10 + 1) = "md::ls::AssociationTileHandle]";
  *((void *)v10 + 2) = 29;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0xC0EF30C6D6B08313;
    *((void *)v4 + 1) = "md::ls::TileRenderableTypeT<md::DaVinciGroundRenderable>]";
    *((void *)v4 + 2) = 56;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_272;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_273;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0xC0EF30C6D6B08313;
  *((void *)v21 + 1) = "md::ls::TileRenderableTypeT<md::DaVinciGroundRenderable>]";
  *((void *)v21 + 2) = 56;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0x6CC93B0E0603EFDCLL;
    *((void *)v14 + 1) = "md::ls::TransferStyleAttributeRasterSet]";
    *((void *)v14 + 2) = 39;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_272;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_273;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0x6CC93B0E0603EFDCLL;
  *((void *)v32 + 1) = "md::ls::TransferStyleAttributeRasterSet]";
  *((void *)v32 + 2) = 39;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0xE2FCA37BA4379744;
    *((void *)v25 + 1) = "md::ls::TileUnitsPerMeter]";
    *((void *)v25 + 2) = 25;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_272;
  }
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_273;
    }
    uint64_t v42 = (char *)operator new(24 * v41);
  }
  else
  {
    uint64_t v42 = 0;
  }
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0xE2FCA37BA4379744;
  *((void *)v43 + 1) = "md::ls::TileUnitsPerMeter]";
  *((void *)v43 + 2) = 25;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
  unint64_t v46 = (unint64_t)a1[2];
  if ((unint64_t)v36 < v46)
  {
    *(void *)uint64_t v36 = 0x52DA3EA752368C9DLL;
    *((void *)v36 + 1) = "md::ls::MapDataTypeV]";
    *((void *)v36 + 2) = 20;
    unint64_t v47 = v36 + 24;
    goto LABEL_91;
  }
  uint64_t v48 = *a1;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v36 - *a1) >> 3);
  unint64_t v50 = v49 + 1;
  if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_272;
  }
  unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v48) >> 3);
  if (2 * v51 > v50) {
    unint64_t v50 = 2 * v51;
  }
  if (v51 >= 0x555555555555555) {
    unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v52 = v50;
  }
  if (v52)
  {
    if (v52 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_273;
    }
    uint64_t v53 = (char *)operator new(24 * v52);
  }
  else
  {
    uint64_t v53 = 0;
  }
  uint64_t v54 = &v53[24 * v49];
  uint64_t v55 = &v53[24 * v52];
  *(void *)uint64_t v54 = 0x52DA3EA752368C9DLL;
  *((void *)v54 + 1) = "md::ls::MapDataTypeV]";
  *((void *)v54 + 2) = 20;
  unint64_t v47 = v54 + 24;
  if (v36 == v48)
  {
    *a1 = v54;
    a1[1] = v47;
    a1[2] = v55;
LABEL_90:
    operator delete(v36);
    goto LABEL_91;
  }
  do
  {
    long long v56 = *(_OWORD *)(v36 - 24);
    *((void *)v54 - 1) = *((void *)v36 - 1);
    *(_OWORD *)(v54 - 24) = v56;
    v54 -= 24;
    v36 -= 24;
  }
  while (v36 != v48);
  uint64_t v36 = *a1;
  *a1 = v54;
  a1[1] = v47;
  a1[2] = v55;
  if (v36) {
    goto LABEL_90;
  }
LABEL_91:
  a1[1] = v47;
  unint64_t v57 = (unint64_t)a1[2];
  if ((unint64_t)v47 < v57)
  {
    *(void *)unint64_t v47 = 0xCAC3230B44CECEB9;
    *((void *)v47 + 1) = "md::ls::TileClippingConstantDataHandle]";
    *((void *)v47 + 2) = 38;
    unint64_t v58 = v47 + 24;
    goto LABEL_109;
  }
  unint64_t v59 = *a1;
  unint64_t v60 = 0xAAAAAAAAAAAAAAABLL * ((v47 - *a1) >> 3);
  unint64_t v61 = v60 + 1;
  if (v60 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_272;
  }
  unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v57 - (void)v59) >> 3);
  if (2 * v62 > v61) {
    unint64_t v61 = 2 * v62;
  }
  if (v62 >= 0x555555555555555) {
    unint64_t v63 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v63 = v61;
  }
  if (v63)
  {
    if (v63 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_273;
    }
    uint64_t v64 = (char *)operator new(24 * v63);
  }
  else
  {
    uint64_t v64 = 0;
  }
  unint64_t v65 = &v64[24 * v60];
  long long v66 = &v64[24 * v63];
  *(void *)unint64_t v65 = 0xCAC3230B44CECEB9;
  *((void *)v65 + 1) = "md::ls::TileClippingConstantDataHandle]";
  *((void *)v65 + 2) = 38;
  unint64_t v58 = v65 + 24;
  if (v47 == v59)
  {
    *a1 = v65;
    a1[1] = v58;
    a1[2] = v66;
LABEL_108:
    operator delete(v47);
    goto LABEL_109;
  }
  do
  {
    long long v67 = *(_OWORD *)(v47 - 24);
    *((void *)v65 - 1) = *((void *)v47 - 1);
    *(_OWORD *)(v65 - 24) = v67;
    v65 -= 24;
    v47 -= 24;
  }
  while (v47 != v59);
  unint64_t v47 = *a1;
  *a1 = v65;
  a1[1] = v58;
  a1[2] = v66;
  if (v47) {
    goto LABEL_108;
  }
LABEL_109:
  a1[1] = v58;
  unint64_t v68 = (unint64_t)a1[2];
  if ((unint64_t)v58 < v68)
  {
    *(void *)unint64_t v58 = 0x414BF8D9069621AELL;
    *((void *)v58 + 1) = "md::ls::TileViewConstantDataHandle]";
    *((void *)v58 + 2) = 34;
    uint64_t v69 = v58 + 24;
    goto LABEL_127;
  }
  uint64_t v70 = *a1;
  unint64_t v71 = 0xAAAAAAAAAAAAAAABLL * ((v58 - *a1) >> 3);
  unint64_t v72 = v71 + 1;
  if (v71 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_272;
  }
  unint64_t v73 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v68 - (void)v70) >> 3);
  if (2 * v73 > v72) {
    unint64_t v72 = 2 * v73;
  }
  if (v73 >= 0x555555555555555) {
    unint64_t v74 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v74 = v72;
  }
  if (v74)
  {
    if (v74 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_273;
    }
    uint64_t v75 = (char *)operator new(24 * v74);
  }
  else
  {
    uint64_t v75 = 0;
  }
  unint64_t v76 = &v75[24 * v71];
  size_t v77 = &v75[24 * v74];
  *(void *)unint64_t v76 = 0x414BF8D9069621AELL;
  *((void *)v76 + 1) = "md::ls::TileViewConstantDataHandle]";
  *((void *)v76 + 2) = 34;
  uint64_t v69 = v76 + 24;
  if (v58 == v70)
  {
    *a1 = v76;
    a1[1] = v69;
    a1[2] = v77;
LABEL_126:
    operator delete(v58);
    goto LABEL_127;
  }
  do
  {
    long long v78 = *(_OWORD *)(v58 - 24);
    *((void *)v76 - 1) = *((void *)v58 - 1);
    *(_OWORD *)(v76 - 24) = v78;
    v76 -= 24;
    v58 -= 24;
  }
  while (v58 != v70);
  unint64_t v58 = *a1;
  *a1 = v76;
  a1[1] = v69;
  a1[2] = v77;
  if (v58) {
    goto LABEL_126;
  }
LABEL_127:
  a1[1] = v69;
  unint64_t v79 = (unint64_t)a1[2];
  if ((unint64_t)v69 < v79)
  {
    *(void *)uint64_t v69 = 0xBCC33905201D8160;
    *((void *)v69 + 1) = "md::ls::TileMatrix]";
    *((void *)v69 + 2) = 18;
    int16x8_t v80 = v69 + 24;
    goto LABEL_145;
  }
  uint64_t v81 = *a1;
  unint64_t v82 = 0xAAAAAAAAAAAAAAABLL * ((v69 - *a1) >> 3);
  unint64_t v83 = v82 + 1;
  if (v82 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_272;
  }
  unint64_t v84 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v79 - (void)v81) >> 3);
  if (2 * v84 > v83) {
    unint64_t v83 = 2 * v84;
  }
  if (v84 >= 0x555555555555555) {
    unint64_t v85 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v85 = v83;
  }
  if (v85)
  {
    if (v85 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_273;
    }
    uint64_t v86 = (char *)operator new(24 * v85);
  }
  else
  {
    uint64_t v86 = 0;
  }
  int8x8_t v87 = &v86[24 * v82];
  uint64_t v88 = &v86[24 * v85];
  *(void *)int8x8_t v87 = 0xBCC33905201D8160;
  *((void *)v87 + 1) = "md::ls::TileMatrix]";
  *((void *)v87 + 2) = 18;
  int16x8_t v80 = v87 + 24;
  if (v69 == v81)
  {
    *a1 = v87;
    a1[1] = v80;
    a1[2] = v88;
LABEL_144:
    operator delete(v69);
    goto LABEL_145;
  }
  do
  {
    long long v89 = *(_OWORD *)(v69 - 24);
    *((void *)v87 - 1) = *((void *)v69 - 1);
    *(_OWORD *)(v87 - 24) = v89;
    v87 -= 24;
    v69 -= 24;
  }
  while (v69 != v81);
  uint64_t v69 = *a1;
  *a1 = v87;
  a1[1] = v80;
  a1[2] = v88;
  if (v69) {
    goto LABEL_144;
  }
LABEL_145:
  a1[1] = v80;
  unint64_t v90 = (unint64_t)a1[2];
  if ((unint64_t)v80 < v90)
  {
    *(void *)int16x8_t v80 = 0xCF1A54FDD9A1F93FLL;
    *((void *)v80 + 1) = "md::ls::TileRenderableDataHandle]";
    *((void *)v80 + 2) = 32;
    BOOL v91 = v80 + 24;
    goto LABEL_163;
  }
  int8x16_t v92 = *a1;
  unint64_t v93 = 0xAAAAAAAAAAAAAAABLL * ((v80 - *a1) >> 3);
  unint64_t v94 = v93 + 1;
  if (v93 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_272;
  }
  unint64_t v95 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v90 - (void)v92) >> 3);
  if (2 * v95 > v94) {
    unint64_t v94 = 2 * v95;
  }
  if (v95 >= 0x555555555555555) {
    unint64_t v96 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v96 = v94;
  }
  if (v96)
  {
    if (v96 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_273;
    }
    int8x16_t v97 = (char *)operator new(24 * v96);
  }
  else
  {
    int8x16_t v97 = 0;
  }
  int16x8_t v98 = &v97[24 * v93];
  int32x4_t v99 = &v97[24 * v96];
  *(void *)int16x8_t v98 = 0xCF1A54FDD9A1F93FLL;
  *((void *)v98 + 1) = "md::ls::TileRenderableDataHandle]";
  *((void *)v98 + 2) = 32;
  BOOL v91 = v98 + 24;
  if (v80 == v92)
  {
    *a1 = v98;
    a1[1] = v91;
    a1[2] = v99;
LABEL_162:
    operator delete(v80);
    goto LABEL_163;
  }
  do
  {
    long long v100 = *(_OWORD *)(v80 - 24);
    *((void *)v98 - 1) = *((void *)v80 - 1);
    *(_OWORD *)(v98 - 24) = v100;
    v98 -= 24;
    v80 -= 24;
  }
  while (v80 != v92);
  int16x8_t v80 = *a1;
  *a1 = v98;
  a1[1] = v91;
  a1[2] = v99;
  if (v80) {
    goto LABEL_162;
  }
LABEL_163:
  a1[1] = v91;
  unint64_t v101 = (unint64_t)a1[2];
  if ((unint64_t)v91 < v101)
  {
    *(void *)BOOL v91 = 0x684A78DCF1B284C1;
    *((void *)v91 + 1) = "md::ls::RenderablesCount]";
    *((void *)v91 + 2) = 24;
    uint64_t v102 = v91 + 24;
    goto LABEL_181;
  }
  int32x4_t v103 = *a1;
  unint64_t v104 = 0xAAAAAAAAAAAAAAABLL * ((v91 - *a1) >> 3);
  unint64_t v105 = v104 + 1;
  if (v104 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_272;
  }
  unint64_t v106 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v101 - (void)v103) >> 3);
  if (2 * v106 > v105) {
    unint64_t v105 = 2 * v106;
  }
  if (v106 >= 0x555555555555555) {
    unint64_t v107 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v107 = v105;
  }
  if (v107)
  {
    if (v107 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_273;
    }
    uint64_t v108 = (char *)operator new(24 * v107);
  }
  else
  {
    uint64_t v108 = 0;
  }
  int8x16_t v109 = &v108[24 * v104];
  unint64_t v110 = &v108[24 * v107];
  *(void *)int8x16_t v109 = 0x684A78DCF1B284C1;
  *((void *)v109 + 1) = "md::ls::RenderablesCount]";
  *((void *)v109 + 2) = 24;
  uint64_t v102 = v109 + 24;
  if (v91 == v103)
  {
    *a1 = v109;
    a1[1] = v102;
    a1[2] = v110;
LABEL_180:
    operator delete(v91);
    goto LABEL_181;
  }
  do
  {
    long long v111 = *(_OWORD *)(v91 - 24);
    *((void *)v109 - 1) = *((void *)v91 - 1);
    *(_OWORD *)(v109 - 24) = v111;
    v109 -= 24;
    v91 -= 24;
  }
  while (v91 != v103);
  BOOL v91 = *a1;
  *a1 = v109;
  a1[1] = v102;
  a1[2] = v110;
  if (v91) {
    goto LABEL_180;
  }
LABEL_181:
  a1[1] = v102;
  unint64_t v112 = (unint64_t)a1[2];
  if ((unint64_t)v102 < v112)
  {
    *(void *)uint64_t v102 = 0xD270E8E58701C515;
    *((void *)v102 + 1) = "md::ls::TileTransformConstantDataHandle]";
    *((void *)v102 + 2) = 39;
    int8x16_t v113 = v102 + 24;
    goto LABEL_199;
  }
  int v114 = *a1;
  unint64_t v115 = 0xAAAAAAAAAAAAAAABLL * ((v102 - *a1) >> 3);
  unint64_t v116 = v115 + 1;
  if (v115 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_272;
  }
  unint64_t v117 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v112 - (void)v114) >> 3);
  if (2 * v117 > v116) {
    unint64_t v116 = 2 * v117;
  }
  if (v117 >= 0x555555555555555) {
    unint64_t v118 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v118 = v116;
  }
  if (v118)
  {
    if (v118 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_273;
    }
    int v119 = (char *)operator new(24 * v118);
  }
  else
  {
    int v119 = 0;
  }
  int32x4_t v120 = &v119[24 * v115];
  int8x16_t v121 = &v119[24 * v118];
  *(void *)int32x4_t v120 = 0xD270E8E58701C515;
  *((void *)v120 + 1) = "md::ls::TileTransformConstantDataHandle]";
  *((void *)v120 + 2) = 39;
  int8x16_t v113 = v120 + 24;
  if (v102 == v114)
  {
    *a1 = v120;
    a1[1] = v113;
    a1[2] = v121;
LABEL_198:
    operator delete(v102);
    goto LABEL_199;
  }
  do
  {
    long long v122 = *(_OWORD *)(v102 - 24);
    *((void *)v120 - 1) = *((void *)v102 - 1);
    *(_OWORD *)(v120 - 24) = v122;
    v120 -= 24;
    v102 -= 24;
  }
  while (v102 != v114);
  uint64_t v102 = *a1;
  *a1 = v120;
  a1[1] = v113;
  a1[2] = v121;
  if (v102) {
    goto LABEL_198;
  }
LABEL_199:
  a1[1] = v113;
  unint64_t v123 = (unint64_t)a1[2];
  if ((unint64_t)v113 < v123)
  {
    *(void *)int8x16_t v113 = 0xF2296D6406C155CBLL;
    *((void *)v113 + 1) = "md::ls::TileShadowConstantDataHandle]";
    *((void *)v113 + 2) = 36;
    uint64_t v124 = v113 + 24;
    goto LABEL_217;
  }
  int8x16_t v125 = *a1;
  unint64_t v126 = 0xAAAAAAAAAAAAAAABLL * ((v113 - *a1) >> 3);
  unint64_t v127 = v126 + 1;
  if (v126 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_272;
  }
  unint64_t v128 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v123 - (void)v125) >> 3);
  if (2 * v128 > v127) {
    unint64_t v127 = 2 * v128;
  }
  if (v128 >= 0x555555555555555) {
    unint64_t v129 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v129 = v127;
  }
  if (v129)
  {
    if (v129 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_273;
    }
    uint64_t v130 = (char *)operator new(24 * v129);
  }
  else
  {
    uint64_t v130 = 0;
  }
  uint64_t v131 = &v130[24 * v126];
  float v132 = &v130[24 * v129];
  *(void *)uint64_t v131 = 0xF2296D6406C155CBLL;
  *((void *)v131 + 1) = "md::ls::TileShadowConstantDataHandle]";
  *((void *)v131 + 2) = 36;
  uint64_t v124 = v131 + 24;
  if (v113 == v125)
  {
    *a1 = v131;
    a1[1] = v124;
    a1[2] = v132;
LABEL_216:
    operator delete(v113);
    goto LABEL_217;
  }
  do
  {
    long long v133 = *(_OWORD *)(v113 - 24);
    *((void *)v131 - 1) = *((void *)v113 - 1);
    *(_OWORD *)(v131 - 24) = v133;
    v131 -= 24;
    v113 -= 24;
  }
  while (v113 != v125);
  int8x16_t v113 = *a1;
  *a1 = v131;
  a1[1] = v124;
  a1[2] = v132;
  if (v113) {
    goto LABEL_216;
  }
LABEL_217:
  a1[1] = v124;
  unint64_t v134 = (unint64_t)a1[2];
  if ((unint64_t)v124 < v134)
  {
    *(void *)uint64_t v124 = 0xB4E92DEB291A7B99;
    *((void *)v124 + 1) = "md::ls::TilePrepassShadowConstantDataHandle]";
    *((void *)v124 + 2) = 43;
    unint64_t v135 = v124 + 24;
    goto LABEL_235;
  }
  long long v136 = *a1;
  unint64_t v137 = 0xAAAAAAAAAAAAAAABLL * ((v124 - *a1) >> 3);
  unint64_t v138 = v137 + 1;
  if (v137 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_272;
  }
  unint64_t v139 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v134 - (void)v136) >> 3);
  if (2 * v139 > v138) {
    unint64_t v138 = 2 * v139;
  }
  if (v139 >= 0x555555555555555) {
    unint64_t v140 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v140 = v138;
  }
  if (v140)
  {
    if (v140 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_273;
    }
    float v141 = (char *)operator new(24 * v140);
  }
  else
  {
    float v141 = 0;
  }
  uint64_t v142 = &v141[24 * v137];
  uint64_t v143 = &v141[24 * v140];
  *(void *)uint64_t v142 = 0xB4E92DEB291A7B99;
  *((void *)v142 + 1) = "md::ls::TilePrepassShadowConstantDataHandle]";
  *((void *)v142 + 2) = 43;
  unint64_t v135 = v142 + 24;
  if (v124 == v136)
  {
    *a1 = v142;
    a1[1] = v135;
    a1[2] = v143;
LABEL_234:
    operator delete(v124);
    goto LABEL_235;
  }
  do
  {
    long long v144 = *(_OWORD *)(v124 - 24);
    *((void *)v142 - 1) = *((void *)v124 - 1);
    *(_OWORD *)(v142 - 24) = v144;
    v142 -= 24;
    v124 -= 24;
  }
  while (v124 != v136);
  uint64_t v124 = *a1;
  *a1 = v142;
  a1[1] = v135;
  a1[2] = v143;
  if (v124) {
    goto LABEL_234;
  }
LABEL_235:
  a1[1] = v135;
  unint64_t v145 = (unint64_t)a1[2];
  if ((unint64_t)v135 < v145)
  {
    *(void *)unint64_t v135 = 0x33C39664142A0949;
    *((void *)v135 + 1) = "md::ls::TilePrepassConstantDataHandle]";
    *((void *)v135 + 2) = 37;
    uint64_t v146 = v135 + 24;
    goto LABEL_253;
  }
  uint64_t v147 = *a1;
  unint64_t v148 = 0xAAAAAAAAAAAAAAABLL * ((v135 - *a1) >> 3);
  unint64_t v149 = v148 + 1;
  if (v148 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_272;
  }
  unint64_t v150 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v145 - (void)v147) >> 3);
  if (2 * v150 > v149) {
    unint64_t v149 = 2 * v150;
  }
  if (v150 >= 0x555555555555555) {
    unint64_t v151 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v151 = v149;
  }
  if (v151)
  {
    if (v151 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_273;
    }
    double v152 = (char *)operator new(24 * v151);
  }
  else
  {
    double v152 = 0;
  }
  double v153 = &v152[24 * v148];
  double v154 = &v152[24 * v151];
  *(void *)double v153 = 0x33C39664142A0949;
  *((void *)v153 + 1) = "md::ls::TilePrepassConstantDataHandle]";
  *((void *)v153 + 2) = 37;
  uint64_t v146 = v153 + 24;
  if (v135 == v147)
  {
    *a1 = v153;
    a1[1] = v146;
    a1[2] = v154;
LABEL_252:
    operator delete(v135);
    goto LABEL_253;
  }
  do
  {
    long long v155 = *(_OWORD *)(v135 - 24);
    *((void *)v153 - 1) = *((void *)v135 - 1);
    *(_OWORD *)(v153 - 24) = v155;
    v153 -= 24;
    v135 -= 24;
  }
  while (v135 != v147);
  unint64_t v135 = *a1;
  *a1 = v153;
  a1[1] = v146;
  a1[2] = v154;
  if (v135) {
    goto LABEL_252;
  }
LABEL_253:
  a1[1] = v146;
  unint64_t v156 = (unint64_t)a1[2];
  if ((unint64_t)v146 < v156)
  {
    *(void *)uint64_t v146 = 0x80A8239313E99C5FLL;
    *((void *)v146 + 1) = "md::ls::TileStyleCameraConstantDataHandle]";
    *((void *)v146 + 2) = 41;
    long double v157 = v146 + 24;
    goto LABEL_271;
  }
  long double v158 = *a1;
  unint64_t v159 = 0xAAAAAAAAAAAAAAABLL * ((v146 - *a1) >> 3);
  unint64_t v160 = v159 + 1;
  if (v159 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_272:
  }
    abort();
  unint64_t v161 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v156 - (void)v158) >> 3);
  if (2 * v161 > v160) {
    unint64_t v160 = 2 * v161;
  }
  if (v161 >= 0x555555555555555) {
    unint64_t v162 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v162 = v160;
  }
  if (v162)
  {
    if (v162 <= 0xAAAAAAAAAAAAAAALL)
    {
      double v163 = (char *)operator new(24 * v162);
      goto LABEL_265;
    }
LABEL_273:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  double v163 = 0;
LABEL_265:
  double v164 = &v163[24 * v159];
  __double2 v165 = &v163[24 * v162];
  *(void *)double v164 = 0x80A8239313E99C5FLL;
  *((void *)v164 + 1) = "md::ls::TileStyleCameraConstantDataHandle]";
  *((void *)v164 + 2) = 41;
  long double v157 = v164 + 24;
  if (v146 == v158)
  {
    *a1 = v164;
    a1[1] = v157;
    a1[2] = v165;
LABEL_270:
    operator delete(v146);
    goto LABEL_271;
  }
  do
  {
    long long v166 = *(_OWORD *)(v146 - 24);
    *((void *)v164 - 1) = *((void *)v146 - 1);
    *(_OWORD *)(v164 - 24) = v166;
    v164 -= 24;
    v146 -= 24;
  }
  while (v146 != v158);
  uint64_t v146 = *a1;
  *a1 = v164;
  a1[1] = v157;
  a1[2] = v165;
  if (v146) {
    goto LABEL_270;
  }
LABEL_271:
  a1[1] = v157;
}

void sub_1A1BBB524(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectDaVinciMeshRenderables>(md::ita::CollectDaVinciMeshRenderables &&)::{lambda(void)#2},std::allocator<md::ita::CollectDaVinciMeshRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectDaVinciMeshRenderables>(md::ita::CollectDaVinciMeshRenderables &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfShouldDeleteRenderable &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *(void *)&double result = 24;
  *((_OWORD *)v2 + 1) = xmmword_1A28FE010;
  v2[4] = "md::ls::AssociationHandle]";
  v2[5] = 25;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfShouldDeleteRenderable &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTemperatureTextureIndex>(md::ita::AssignTemperatureTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignTemperatureTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTemperatureTextureIndex>(md::ita::AssignTemperatureTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x985FB09D9DF9959FLL;
  v2[1] = "md::ls::HasStyleAttributeRasterSet]";
  *(void *)&double result = 34;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD920;
  v2[4] = "md::ls::RequiresShaderTextureID<DaVinci::TemperatureTexture>]";
  v2[5] = 60;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTemperatureTextureIndex>(md::ita::AssignTemperatureTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignTemperatureTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTemperatureTextureIndex>(md::ita::AssignTemperatureTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BBB684(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleShadowConstantData>(md::ita::AssignStyleShadowConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleShadowConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleShadowConstantData>(md::ita::AssignStyleShadowConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x5E7EAD35976A86ALL;
  result[1] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>>]";
  result[2] = 87;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleShadowConstantData>(md::ita::AssignStyleShadowConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleShadowConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleShadowConstantData>(md::ita::AssignStyleShadowConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BBB744(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLinearDepthConstantData>(md::ita::AssignLinearDepthConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignLinearDepthConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLinearDepthConstantData>(md::ita::AssignLinearDepthConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x1EBB3E0519E8FF9DLL;
  v2[1] = "md::ls::PrepassConstantDataHandle]";
  *(void *)&double result = 33;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD9F0;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>]";
  v2[5] = 84;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLinearDepthConstantData>(md::ita::AssignLinearDepthConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignLinearDepthConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLinearDepthConstantData>(md::ita::AssignLinearDepthConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BBB818(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverClipConstantData>(md::ita::AssignFlyoverClipConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverClipConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverClipConstantData>(md::ita::AssignFlyoverClipConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x5E4DB6CB13CB5848;
  v2[1] = "md::ls::FlyoverClipConstantDataHandle]";
  *(void *)&double result = 37;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD890;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>]";
  v2[5] = 86;
  v2[6] = 0x69465F3BE0BF85FBLL;
  v2[7] = "md::ls::FlyoverInstance]";
  v2[8] = 23;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverClipConstantData>(md::ita::AssignFlyoverClipConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverClipConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverClipConstantData>(md::ita::AssignFlyoverClipConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BBB910(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyWantsDynamicShadowBounds>(md::ita::ApplyWantsDynamicShadowBounds &&)::{lambda(void)#1},std::allocator<md::ita::ApplyWantsDynamicShadowBounds &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyWantsDynamicShadowBounds>(md::ita::ApplyWantsDynamicShadowBounds &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *(void *)&double result = 24;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDDF0;
  v2[4] = "md::ls::MeshLayerTypeV]";
  v2[5] = 22;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyWantsDynamicShadowBounds>(md::ita::ApplyWantsDynamicShadowBounds &&)::{lambda(void)#2},std::allocator<md::ita::ApplyWantsDynamicShadowBounds &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyWantsDynamicShadowBounds>(md::ita::ApplyWantsDynamicShadowBounds &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialAlbedoTexture>(md::ita::ResolveMaterialAlbedoTexture &&)::{lambda(void)#1},std::allocator<md::ita::ResolveMaterialAlbedoTexture &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialAlbedoTexture>(md::ita::ResolveMaterialAlbedoTexture &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x3209EBE3B62CF3D3;
  v2[1] = "md::ls::UniqueMaterialData]";
  *(void *)&double result = 26;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDDC0;
  v2[4] = "md::ls::MeshRenderableID]";
  v2[5] = 24;
  v2[6] = 0x28D6AB85FDB5A2BLL;
  v2[7] = "md::ls::RenderableAlbedoTexture]";
  v2[8] = 31;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialAlbedoTexture>(md::ita::ResolveMaterialAlbedoTexture &&)::{lambda(void)#2},std::allocator<md::ita::ResolveMaterialAlbedoTexture &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialAlbedoTexture>(md::ita::ResolveMaterialAlbedoTexture &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x5FF8F613B2E16249;
  v2[1] = "md::ls::UniqueMaterialAlbedoTexture]";
  *(void *)&double result = 35;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDDB0;
  v2[4] = "md::ls::SharedMaterialAlbedoTexture]";
  v2[5] = 35;
  v2[6] = 0x1D932F2BF291491;
  v2[7] = "md::ls::TextureHandleForType<DaVinci::TexTexture>]";
  v2[8] = 49;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::MarkPipelineDataRequirements>(md::ita::MarkPipelineDataRequirements &&)::{lambda(void)#1},std::allocator<md::ita::MarkPipelineDataRequirements &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::MarkPipelineDataRequirements>(md::ita::MarkPipelineDataRequirements &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0xD68EA0DE832DEC03;
  v2[1] = "md::ls::RenderItemID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDAF0;
  v2[4] = "md::ls::RenderItemUpdate]";
  v2[5] = 24;
  v2[6] = 0xB3837544666C5A60;
  v2[7] = "md::ls::DataIDSetToUse]";
  v2[8] = 22;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)uint64_t v3 = 0xE54E641F7C1F9B89;
    v2[10] = "md::ls::RequiredPipelinePoolID]";
    v2[11] = 30;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xE54E641F7C1F9B89;
  *((void *)v10 + 1) = "md::ls::RequiredPipelinePoolID]";
  *((void *)v10 + 2) = 30;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BBBCC4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::MarkPipelineDataRequirements>(md::ita::MarkPipelineDataRequirements &&)::{lambda(void)#2},std::allocator<md::ita::MarkPipelineDataRequirements &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::MarkPipelineDataRequirements>(md::ita::MarkPipelineDataRequirements &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BBBD24(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateUnflattenedRenderItems>(md::ita::CreateUnflattenedRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::CreateUnflattenedRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateUnflattenedRenderItems>(md::ita::CreateUnflattenedRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0xA8uLL);
  a1[2] = (char *)(v2 + 21);
  *unint64_t v2 = 0xF5773E2F171FA967;
  v2[1] = "md::ls::SliceAssignmentT<md::SliceType::CulledUnflattenedMain>]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDCC0;
  v2[4] = "md::ls::RenderableMeshVertexFormat]";
  v2[5] = 34;
  v2[6] = 0x751B872B282C3971;
  v2[7] = "md::ls::TileType]";
  v2[8] = 16;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 21)
  {
    *(void *)uint64_t v3 = 0xEC2A00DC914732D7;
    v2[10] = "md::ls::IntendedSceneLayer]";
    v2[11] = 26;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_74;
  }
  if (0x5555555555555556 * (((char *)(v2 + 21) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 21) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 21) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_75;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xEC2A00DC914732D7;
  *((void *)v10 + 1) = "md::ls::IntendedSceneLayer]";
  *((void *)v10 + 2) = 26;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0xECC498AF223943D5;
    *((void *)v4 + 1) = "md::ls::MeshLayerTypeV]";
    *((void *)v4 + 2) = 22;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_74;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_75;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0xECC498AF223943D5;
  *((void *)v21 + 1) = "md::ls::MeshLayerTypeV]";
  *((void *)v21 + 2) = 22;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0x75DBD6381F1903FFLL;
    *((void *)v14 + 1) = "md::ls::PendingProcessing]";
    *((void *)v14 + 2) = 25;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_74;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_75;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0x75DBD6381F1903FFLL;
  *((void *)v32 + 1) = "md::ls::PendingProcessing]";
  *((void *)v32 + 2) = 25;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0x9D7520A01DC69D83;
    *((void *)v25 + 1) = "md::ls::HasMaterialRaster]";
    *((void *)v25 + 2) = 25;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_74:
  }
    abort();
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v42 = (char *)operator new(24 * v41);
      goto LABEL_67;
    }
LABEL_75:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v42 = 0;
LABEL_67:
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0x9D7520A01DC69D83;
  *((void *)v43 + 1) = "md::ls::HasMaterialRaster]";
  *((void *)v43 + 2) = 25;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
}

void sub_1A1BBC29C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateUnflattenedRenderItems>(md::ita::CreateUnflattenedRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::CreateUnflattenedRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateUnflattenedRenderItems>(md::ita::CreateUnflattenedRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x408uLL);
  a1[2] = (char *)(v2 + 129);
  *unint64_t v2 = 0x523816724122CCE2;
  v2[1] = "md::ls::AssociationHandle]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDCB0;
  v2[4] = "md::ls::HasMeshHandle]";
  v2[5] = 21;
  v2[6] = 0x6C7EE74910D42096;
  v2[7] = "md::ls::PositionScaleInfoConstantDataHandle]";
  v2[8] = 43;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 129)
  {
    *(void *)uint64_t v3 = 0xCFE242268B958ADALL;
    v2[10] = "md::ls::ViewConstantDataHandle]";
    v2[11] = 30;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  if (0x5555555555555556 * (((char *)(v2 + 129) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 129) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 129) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xCFE242268B958ADALL;
  *((void *)v10 + 1) = "md::ls::ViewConstantDataHandle]";
  *((void *)v10 + 2) = 30;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x74DC502726E97929;
    *((void *)v4 + 1) = "md::ls::TransformConstantDataHandle]";
    *((void *)v4 + 2) = 35;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x74DC502726E97929;
  *((void *)v21 + 1) = "md::ls::TransformConstantDataHandle]";
  *((void *)v21 + 2) = 35;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0x1BB343378E1EE5BLL;
    *((void *)v14 + 1) = "md::ls::StyleDataKeyHandle]";
    *((void *)v14 + 2) = 26;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0x1BB343378E1EE5BLL;
  *((void *)v32 + 1) = "md::ls::StyleDataKeyHandle]";
  *((void *)v32 + 2) = 26;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0xA50DD2A5BD75DBD6;
    *((void *)v25 + 1) = "md::ls::StyleEmissiveDataKeyHandle]";
    *((void *)v25 + 2) = 34;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v42 = (char *)operator new(24 * v41);
  }
  else
  {
    uint64_t v42 = 0;
  }
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0xA50DD2A5BD75DBD6;
  *((void *)v43 + 1) = "md::ls::StyleEmissiveDataKeyHandle]";
  *((void *)v43 + 2) = 34;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
  unint64_t v46 = (unint64_t)a1[2];
  if ((unint64_t)v36 < v46)
  {
    *(void *)uint64_t v36 = 0x96F87A2692FE4013;
    *((void *)v36 + 1) = "md::ls::StyleCameraConstantDataHandle]";
    *((void *)v36 + 2) = 37;
    unint64_t v47 = v36 + 24;
    goto LABEL_91;
  }
  uint64_t v48 = *a1;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v36 - *a1) >> 3);
  unint64_t v50 = v49 + 1;
  if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v48) >> 3);
  if (2 * v51 > v50) {
    unint64_t v50 = 2 * v51;
  }
  if (v51 >= 0x555555555555555) {
    unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v52 = v50;
  }
  if (v52)
  {
    if (v52 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v53 = (char *)operator new(24 * v52);
  }
  else
  {
    uint64_t v53 = 0;
  }
  uint64_t v54 = &v53[24 * v49];
  uint64_t v55 = &v53[24 * v52];
  *(void *)uint64_t v54 = 0x96F87A2692FE4013;
  *((void *)v54 + 1) = "md::ls::StyleCameraConstantDataHandle]";
  *((void *)v54 + 2) = 37;
  unint64_t v47 = v54 + 24;
  if (v36 == v48)
  {
    *a1 = v54;
    a1[1] = v47;
    a1[2] = v55;
LABEL_90:
    operator delete(v36);
    goto LABEL_91;
  }
  do
  {
    long long v56 = *(_OWORD *)(v36 - 24);
    *((void *)v54 - 1) = *((void *)v36 - 1);
    *(_OWORD *)(v54 - 24) = v56;
    v54 -= 24;
    v36 -= 24;
  }
  while (v36 != v48);
  uint64_t v36 = *a1;
  *a1 = v54;
  a1[1] = v47;
  a1[2] = v55;
  if (v36) {
    goto LABEL_90;
  }
LABEL_91:
  a1[1] = v47;
  unint64_t v57 = (unint64_t)a1[2];
  if ((unint64_t)v47 < v57)
  {
    *(void *)unint64_t v47 = 0xA3F884E4E2541296;
    *((void *)v47 + 1) = "md::ls::ColorDataHandle]";
    *((void *)v47 + 2) = 23;
    unint64_t v58 = v47 + 24;
    goto LABEL_109;
  }
  unint64_t v59 = *a1;
  unint64_t v60 = 0xAAAAAAAAAAAAAAABLL * ((v47 - *a1) >> 3);
  unint64_t v61 = v60 + 1;
  if (v60 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v57 - (void)v59) >> 3);
  if (2 * v62 > v61) {
    unint64_t v61 = 2 * v62;
  }
  if (v62 >= 0x555555555555555) {
    unint64_t v63 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v63 = v61;
  }
  if (v63)
  {
    if (v63 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v64 = (char *)operator new(24 * v63);
  }
  else
  {
    uint64_t v64 = 0;
  }
  unint64_t v65 = &v64[24 * v60];
  long long v66 = &v64[24 * v63];
  *(void *)unint64_t v65 = 0xA3F884E4E2541296;
  *((void *)v65 + 1) = "md::ls::ColorDataHandle]";
  *((void *)v65 + 2) = 23;
  unint64_t v58 = v65 + 24;
  if (v47 == v59)
  {
    *a1 = v65;
    a1[1] = v58;
    a1[2] = v66;
LABEL_108:
    operator delete(v47);
    goto LABEL_109;
  }
  do
  {
    long long v67 = *(_OWORD *)(v47 - 24);
    *((void *)v65 - 1) = *((void *)v47 - 1);
    *(_OWORD *)(v65 - 24) = v67;
    v65 -= 24;
    v47 -= 24;
  }
  while (v47 != v59);
  unint64_t v47 = *a1;
  *a1 = v65;
  a1[1] = v58;
  a1[2] = v66;
  if (v47) {
    goto LABEL_108;
  }
LABEL_109:
  a1[1] = v58;
  unint64_t v68 = (unint64_t)a1[2];
  if ((unint64_t)v58 < v68)
  {
    *(void *)unint64_t v58 = 0x71CBA64B1A9CA230;
    *((void *)v58 + 1) = "md::ls::IndexRange]";
    *((void *)v58 + 2) = 18;
    uint64_t v69 = v58 + 24;
    goto LABEL_127;
  }
  uint64_t v70 = *a1;
  unint64_t v71 = 0xAAAAAAAAAAAAAAABLL * ((v58 - *a1) >> 3);
  unint64_t v72 = v71 + 1;
  if (v71 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v73 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v68 - (void)v70) >> 3);
  if (2 * v73 > v72) {
    unint64_t v72 = 2 * v73;
  }
  if (v73 >= 0x555555555555555) {
    unint64_t v74 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v74 = v72;
  }
  if (v74)
  {
    if (v74 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v75 = (char *)operator new(24 * v74);
  }
  else
  {
    uint64_t v75 = 0;
  }
  unint64_t v76 = &v75[24 * v71];
  size_t v77 = &v75[24 * v74];
  *(void *)unint64_t v76 = 0x71CBA64B1A9CA230;
  *((void *)v76 + 1) = "md::ls::IndexRange]";
  *((void *)v76 + 2) = 18;
  uint64_t v69 = v76 + 24;
  if (v58 == v70)
  {
    *a1 = v76;
    a1[1] = v69;
    a1[2] = v77;
LABEL_126:
    operator delete(v58);
    goto LABEL_127;
  }
  do
  {
    long long v78 = *(_OWORD *)(v58 - 24);
    *((void *)v76 - 1) = *((void *)v58 - 1);
    *(_OWORD *)(v76 - 24) = v78;
    v76 -= 24;
    v58 -= 24;
  }
  while (v58 != v70);
  unint64_t v58 = *a1;
  *a1 = v76;
  a1[1] = v69;
  a1[2] = v77;
  if (v58) {
    goto LABEL_126;
  }
LABEL_127:
  a1[1] = v69;
  unint64_t v79 = (unint64_t)a1[2];
  if ((unint64_t)v69 < v79)
  {
    *(void *)uint64_t v69 = 0xD5AD9B8C3FE62EE8;
    *((void *)v69 + 1) = "md::ls::StyleGroundOcclusionConstantDataHandle]";
    *((void *)v69 + 2) = 46;
    int16x8_t v80 = v69 + 24;
    goto LABEL_145;
  }
  uint64_t v81 = *a1;
  unint64_t v82 = 0xAAAAAAAAAAAAAAABLL * ((v69 - *a1) >> 3);
  unint64_t v83 = v82 + 1;
  if (v82 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v84 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v79 - (void)v81) >> 3);
  if (2 * v84 > v83) {
    unint64_t v83 = 2 * v84;
  }
  if (v84 >= 0x555555555555555) {
    unint64_t v85 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v85 = v83;
  }
  if (v85)
  {
    if (v85 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v86 = (char *)operator new(24 * v85);
  }
  else
  {
    uint64_t v86 = 0;
  }
  int8x8_t v87 = &v86[24 * v82];
  uint64_t v88 = &v86[24 * v85];
  *(void *)int8x8_t v87 = 0xD5AD9B8C3FE62EE8;
  *((void *)v87 + 1) = "md::ls::StyleGroundOcclusionConstantDataHandle]";
  *((void *)v87 + 2) = 46;
  int16x8_t v80 = v87 + 24;
  if (v69 == v81)
  {
    *a1 = v87;
    a1[1] = v80;
    a1[2] = v88;
LABEL_144:
    operator delete(v69);
    goto LABEL_145;
  }
  do
  {
    long long v89 = *(_OWORD *)(v69 - 24);
    *((void *)v87 - 1) = *((void *)v69 - 1);
    *(_OWORD *)(v87 - 24) = v89;
    v87 -= 24;
    v69 -= 24;
  }
  while (v69 != v81);
  uint64_t v69 = *a1;
  *a1 = v87;
  a1[1] = v80;
  a1[2] = v88;
  if (v69) {
    goto LABEL_144;
  }
LABEL_145:
  a1[1] = v80;
  unint64_t v90 = (unint64_t)a1[2];
  if ((unint64_t)v80 < v90)
  {
    *(void *)int16x8_t v80 = 0x3218EFD67197A145;
    *((void *)v80 + 1) = "md::ls::NormalsHandle]";
    *((void *)v80 + 2) = 21;
    BOOL v91 = v80 + 24;
    goto LABEL_163;
  }
  int8x16_t v92 = *a1;
  unint64_t v93 = 0xAAAAAAAAAAAAAAABLL * ((v80 - *a1) >> 3);
  unint64_t v94 = v93 + 1;
  if (v93 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v95 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v90 - (void)v92) >> 3);
  if (2 * v95 > v94) {
    unint64_t v94 = 2 * v95;
  }
  if (v95 >= 0x555555555555555) {
    unint64_t v96 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v96 = v94;
  }
  if (v96)
  {
    if (v96 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    int8x16_t v97 = (char *)operator new(24 * v96);
  }
  else
  {
    int8x16_t v97 = 0;
  }
  int16x8_t v98 = &v97[24 * v93];
  int32x4_t v99 = &v97[24 * v96];
  *(void *)int16x8_t v98 = 0x3218EFD67197A145;
  *((void *)v98 + 1) = "md::ls::NormalsHandle]";
  *((void *)v98 + 2) = 21;
  BOOL v91 = v98 + 24;
  if (v80 == v92)
  {
    *a1 = v98;
    a1[1] = v91;
    a1[2] = v99;
LABEL_162:
    operator delete(v80);
    goto LABEL_163;
  }
  do
  {
    long long v100 = *(_OWORD *)(v80 - 24);
    *((void *)v98 - 1) = *((void *)v80 - 1);
    *(_OWORD *)(v98 - 24) = v100;
    v98 -= 24;
    v80 -= 24;
  }
  while (v80 != v92);
  int16x8_t v80 = *a1;
  *a1 = v98;
  a1[1] = v91;
  a1[2] = v99;
  if (v80) {
    goto LABEL_162;
  }
LABEL_163:
  a1[1] = v91;
  unint64_t v101 = (unint64_t)a1[2];
  if ((unint64_t)v91 < v101)
  {
    *(void *)BOOL v91 = 0xAF179EFD8A4C83D4;
    *((void *)v91 + 1) = "md::ls::InstanceTransformHandle]";
    *((void *)v91 + 2) = 31;
    uint64_t v102 = v91 + 24;
    goto LABEL_181;
  }
  int32x4_t v103 = *a1;
  unint64_t v104 = 0xAAAAAAAAAAAAAAABLL * ((v91 - *a1) >> 3);
  unint64_t v105 = v104 + 1;
  if (v104 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v106 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v101 - (void)v103) >> 3);
  if (2 * v106 > v105) {
    unint64_t v105 = 2 * v106;
  }
  if (v106 >= 0x555555555555555) {
    unint64_t v107 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v107 = v105;
  }
  if (v107)
  {
    if (v107 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v108 = (char *)operator new(24 * v107);
  }
  else
  {
    uint64_t v108 = 0;
  }
  int8x16_t v109 = &v108[24 * v104];
  unint64_t v110 = &v108[24 * v107];
  *(void *)int8x16_t v109 = 0xAF179EFD8A4C83D4;
  *((void *)v109 + 1) = "md::ls::InstanceTransformHandle]";
  *((void *)v109 + 2) = 31;
  uint64_t v102 = v109 + 24;
  if (v91 == v103)
  {
    *a1 = v109;
    a1[1] = v102;
    a1[2] = v110;
LABEL_180:
    operator delete(v91);
    goto LABEL_181;
  }
  do
  {
    long long v111 = *(_OWORD *)(v91 - 24);
    *((void *)v109 - 1) = *((void *)v91 - 1);
    *(_OWORD *)(v109 - 24) = v111;
    v109 -= 24;
    v91 -= 24;
  }
  while (v91 != v103);
  BOOL v91 = *a1;
  *a1 = v109;
  a1[1] = v102;
  a1[2] = v110;
  if (v91) {
    goto LABEL_180;
  }
LABEL_181:
  a1[1] = v102;
  unint64_t v112 = (unint64_t)a1[2];
  if ((unint64_t)v102 < v112)
  {
    *(void *)uint64_t v102 = 0xCBB77B1CBD05D7C5;
    *((void *)v102 + 1) = "md::ls::UVsHandle]";
    *((void *)v102 + 2) = 17;
    int8x16_t v113 = v102 + 24;
    goto LABEL_199;
  }
  int v114 = *a1;
  unint64_t v115 = 0xAAAAAAAAAAAAAAABLL * ((v102 - *a1) >> 3);
  unint64_t v116 = v115 + 1;
  if (v115 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v117 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v112 - (void)v114) >> 3);
  if (2 * v117 > v116) {
    unint64_t v116 = 2 * v117;
  }
  if (v117 >= 0x555555555555555) {
    unint64_t v118 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v118 = v116;
  }
  if (v118)
  {
    if (v118 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    int v119 = (char *)operator new(24 * v118);
  }
  else
  {
    int v119 = 0;
  }
  int32x4_t v120 = &v119[24 * v115];
  int8x16_t v121 = &v119[24 * v118];
  *(void *)int32x4_t v120 = 0xCBB77B1CBD05D7C5;
  *((void *)v120 + 1) = "md::ls::UVsHandle]";
  *((void *)v120 + 2) = 17;
  int8x16_t v113 = v120 + 24;
  if (v102 == v114)
  {
    *a1 = v120;
    a1[1] = v113;
    a1[2] = v121;
LABEL_198:
    operator delete(v102);
    goto LABEL_199;
  }
  do
  {
    long long v122 = *(_OWORD *)(v102 - 24);
    *((void *)v120 - 1) = *((void *)v102 - 1);
    *(_OWORD *)(v120 - 24) = v122;
    v120 -= 24;
    v102 -= 24;
  }
  while (v102 != v114);
  uint64_t v102 = *a1;
  *a1 = v120;
  a1[1] = v113;
  a1[2] = v121;
  if (v102) {
    goto LABEL_198;
  }
LABEL_199:
  a1[1] = v113;
  unint64_t v123 = (unint64_t)a1[2];
  if ((unint64_t)v113 < v123)
  {
    *(void *)int8x16_t v113 = 0xD443D3DCBB78491ALL;
    *((void *)v113 + 1) = "md::ls::ElevationHandle]";
    *((void *)v113 + 2) = 23;
    uint64_t v124 = v113 + 24;
    goto LABEL_217;
  }
  int8x16_t v125 = *a1;
  unint64_t v126 = 0xAAAAAAAAAAAAAAABLL * ((v113 - *a1) >> 3);
  unint64_t v127 = v126 + 1;
  if (v126 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v128 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v123 - (void)v125) >> 3);
  if (2 * v128 > v127) {
    unint64_t v127 = 2 * v128;
  }
  if (v128 >= 0x555555555555555) {
    unint64_t v129 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v129 = v127;
  }
  if (v129)
  {
    if (v129 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v130 = (char *)operator new(24 * v129);
  }
  else
  {
    uint64_t v130 = 0;
  }
  uint64_t v131 = &v130[24 * v126];
  float v132 = &v130[24 * v129];
  *(void *)uint64_t v131 = 0xD443D3DCBB78491ALL;
  *((void *)v131 + 1) = "md::ls::ElevationHandle]";
  *((void *)v131 + 2) = 23;
  uint64_t v124 = v131 + 24;
  if (v113 == v125)
  {
    *a1 = v131;
    a1[1] = v124;
    a1[2] = v132;
LABEL_216:
    operator delete(v113);
    goto LABEL_217;
  }
  do
  {
    long long v133 = *(_OWORD *)(v113 - 24);
    *((void *)v131 - 1) = *((void *)v113 - 1);
    *(_OWORD *)(v131 - 24) = v133;
    v131 -= 24;
    v113 -= 24;
  }
  while (v113 != v125);
  int8x16_t v113 = *a1;
  *a1 = v131;
  a1[1] = v124;
  a1[2] = v132;
  if (v113) {
    goto LABEL_216;
  }
LABEL_217:
  a1[1] = v124;
  unint64_t v134 = (unint64_t)a1[2];
  if ((unint64_t)v124 < v134)
  {
    *(void *)uint64_t v124 = 0xDD9825BCFA7911B2;
    *((void *)v124 + 1) = "md::ls::TextureHandleForType<DaVinci::DiffuseTexture>]";
    *((void *)v124 + 2) = 53;
    unint64_t v135 = v124 + 24;
    goto LABEL_235;
  }
  long long v136 = *a1;
  unint64_t v137 = 0xAAAAAAAAAAAAAAABLL * ((v124 - *a1) >> 3);
  unint64_t v138 = v137 + 1;
  if (v137 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v139 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v134 - (void)v136) >> 3);
  if (2 * v139 > v138) {
    unint64_t v138 = 2 * v139;
  }
  if (v139 >= 0x555555555555555) {
    unint64_t v140 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v140 = v138;
  }
  if (v140)
  {
    if (v140 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    float v141 = (char *)operator new(24 * v140);
  }
  else
  {
    float v141 = 0;
  }
  uint64_t v142 = &v141[24 * v137];
  uint64_t v143 = &v141[24 * v140];
  *(void *)uint64_t v142 = 0xDD9825BCFA7911B2;
  *((void *)v142 + 1) = "md::ls::TextureHandleForType<DaVinci::DiffuseTexture>]";
  *((void *)v142 + 2) = 53;
  unint64_t v135 = v142 + 24;
  if (v124 == v136)
  {
    *a1 = v142;
    a1[1] = v135;
    a1[2] = v143;
LABEL_234:
    operator delete(v124);
    goto LABEL_235;
  }
  do
  {
    long long v144 = *(_OWORD *)(v124 - 24);
    *((void *)v142 - 1) = *((void *)v124 - 1);
    *(_OWORD *)(v142 - 24) = v144;
    v142 -= 24;
    v124 -= 24;
  }
  while (v124 != v136);
  uint64_t v124 = *a1;
  *a1 = v142;
  a1[1] = v135;
  a1[2] = v143;
  if (v124) {
    goto LABEL_234;
  }
LABEL_235:
  a1[1] = v135;
  unint64_t v145 = (unint64_t)a1[2];
  if ((unint64_t)v135 < v145)
  {
    *(void *)unint64_t v135 = 0xDC98991DB7473274;
    *((void *)v135 + 1) = "md::ls::LandCoverSettingsConstantDataHandle]";
    *((void *)v135 + 2) = 43;
    uint64_t v146 = v135 + 24;
    goto LABEL_253;
  }
  uint64_t v147 = *a1;
  unint64_t v148 = 0xAAAAAAAAAAAAAAABLL * ((v135 - *a1) >> 3);
  unint64_t v149 = v148 + 1;
  if (v148 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v150 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v145 - (void)v147) >> 3);
  if (2 * v150 > v149) {
    unint64_t v149 = 2 * v150;
  }
  if (v150 >= 0x555555555555555) {
    unint64_t v151 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v151 = v149;
  }
  if (v151)
  {
    if (v151 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    double v152 = (char *)operator new(24 * v151);
  }
  else
  {
    double v152 = 0;
  }
  double v153 = &v152[24 * v148];
  double v154 = &v152[24 * v151];
  *(void *)double v153 = 0xDC98991DB7473274;
  *((void *)v153 + 1) = "md::ls::LandCoverSettingsConstantDataHandle]";
  *((void *)v153 + 2) = 43;
  uint64_t v146 = v153 + 24;
  if (v135 == v147)
  {
    *a1 = v153;
    a1[1] = v146;
    a1[2] = v154;
LABEL_252:
    operator delete(v135);
    goto LABEL_253;
  }
  do
  {
    long long v155 = *(_OWORD *)(v135 - 24);
    *((void *)v153 - 1) = *((void *)v135 - 1);
    *(_OWORD *)(v153 - 24) = v155;
    v153 -= 24;
    v135 -= 24;
  }
  while (v135 != v147);
  unint64_t v135 = *a1;
  *a1 = v153;
  a1[1] = v146;
  a1[2] = v154;
  if (v135) {
    goto LABEL_252;
  }
LABEL_253:
  a1[1] = v146;
  unint64_t v156 = (unint64_t)a1[2];
  if ((unint64_t)v146 < v156)
  {
    *(void *)uint64_t v146 = 0xEAA0B82FC49F7277;
    *((void *)v146 + 1) = "md::ls::ShadowConstantDataHandle]";
    *((void *)v146 + 2) = 32;
    long double v157 = v146 + 24;
    goto LABEL_271;
  }
  long double v158 = *a1;
  unint64_t v159 = 0xAAAAAAAAAAAAAAABLL * ((v146 - *a1) >> 3);
  unint64_t v160 = v159 + 1;
  if (v159 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v161 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v156 - (void)v158) >> 3);
  if (2 * v161 > v160) {
    unint64_t v160 = 2 * v161;
  }
  if (v161 >= 0x555555555555555) {
    unint64_t v162 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v162 = v160;
  }
  if (v162)
  {
    if (v162 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    double v163 = (char *)operator new(24 * v162);
  }
  else
  {
    double v163 = 0;
  }
  double v164 = &v163[24 * v159];
  __double2 v165 = &v163[24 * v162];
  *(void *)double v164 = 0xEAA0B82FC49F7277;
  *((void *)v164 + 1) = "md::ls::ShadowConstantDataHandle]";
  *((void *)v164 + 2) = 32;
  long double v157 = v164 + 24;
  if (v146 == v158)
  {
    *a1 = v164;
    a1[1] = v157;
    a1[2] = v165;
LABEL_270:
    operator delete(v146);
    goto LABEL_271;
  }
  do
  {
    long long v166 = *(_OWORD *)(v146 - 24);
    *((void *)v164 - 1) = *((void *)v146 - 1);
    *(_OWORD *)(v164 - 24) = v166;
    v164 -= 24;
    v146 -= 24;
  }
  while (v146 != v158);
  uint64_t v146 = *a1;
  *a1 = v164;
  a1[1] = v157;
  a1[2] = v165;
  if (v146) {
    goto LABEL_270;
  }
LABEL_271:
  a1[1] = v157;
  unint64_t v167 = (unint64_t)a1[2];
  if ((unint64_t)v157 < v167)
  {
    *(void *)long double v157 = 0x1EBB3E0519E8FF9DLL;
    *((void *)v157 + 1) = "md::ls::PrepassConstantDataHandle]";
    *((void *)v157 + 2) = 33;
    double v168 = v157 + 24;
    goto LABEL_289;
  }
  double v169 = *a1;
  unint64_t v170 = 0xAAAAAAAAAAAAAAABLL * ((v157 - *a1) >> 3);
  unint64_t v171 = v170 + 1;
  if (v170 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v172 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v167 - (void)v169) >> 3);
  if (2 * v172 > v171) {
    unint64_t v171 = 2 * v172;
  }
  if (v172 >= 0x555555555555555) {
    unint64_t v173 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v173 = v171;
  }
  if (v173)
  {
    if (v173 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    double v174 = (char *)operator new(24 * v173);
  }
  else
  {
    double v174 = 0;
  }
  double v175 = &v174[24 * v170];
  double v176 = &v174[24 * v173];
  *(void *)double v175 = 0x1EBB3E0519E8FF9DLL;
  *((void *)v175 + 1) = "md::ls::PrepassConstantDataHandle]";
  *((void *)v175 + 2) = 33;
  double v168 = v175 + 24;
  if (v157 == v169)
  {
    *a1 = v175;
    a1[1] = v168;
    a1[2] = v176;
LABEL_288:
    operator delete(v157);
    goto LABEL_289;
  }
  do
  {
    long long v177 = *(_OWORD *)(v157 - 24);
    *((void *)v175 - 1) = *((void *)v157 - 1);
    *(_OWORD *)(v175 - 24) = v177;
    v175 -= 24;
    v157 -= 24;
  }
  while (v157 != v169);
  long double v157 = *a1;
  *a1 = v175;
  a1[1] = v168;
  a1[2] = v176;
  if (v157) {
    goto LABEL_288;
  }
LABEL_289:
  a1[1] = v168;
  unint64_t v178 = (unint64_t)a1[2];
  if ((unint64_t)v168 < v178)
  {
    *(void *)double v168 = 0x65937AC5D2157F71;
    *((void *)v168 + 1) = "md::ls::ColorCorrectionFactorConstantHandle]";
    *((void *)v168 + 2) = 43;
    __double2 v179 = v168 + 24;
    goto LABEL_307;
  }
  double v180 = *a1;
  unint64_t v181 = 0xAAAAAAAAAAAAAAABLL * ((v168 - *a1) >> 3);
  unint64_t v182 = v181 + 1;
  if (v181 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v183 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v178 - (void)v180) >> 3);
  if (2 * v183 > v182) {
    unint64_t v182 = 2 * v183;
  }
  if (v183 >= 0x555555555555555) {
    unint64_t v184 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v184 = v182;
  }
  if (v184)
  {
    if (v184 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    double v185 = (char *)operator new(24 * v184);
  }
  else
  {
    double v185 = 0;
  }
  double v186 = &v185[24 * v181];
  double v187 = &v185[24 * v184];
  *(void *)double v186 = 0x65937AC5D2157F71;
  *((void *)v186 + 1) = "md::ls::ColorCorrectionFactorConstantHandle]";
  *((void *)v186 + 2) = 43;
  __double2 v179 = v186 + 24;
  if (v168 == v180)
  {
    *a1 = v186;
    a1[1] = v179;
    a1[2] = v187;
LABEL_306:
    operator delete(v168);
    goto LABEL_307;
  }
  do
  {
    long long v188 = *(_OWORD *)(v168 - 24);
    *((void *)v186 - 1) = *((void *)v168 - 1);
    *(_OWORD *)(v186 - 24) = v188;
    v186 -= 24;
    v168 -= 24;
  }
  while (v168 != v180);
  double v168 = *a1;
  *a1 = v186;
  a1[1] = v179;
  a1[2] = v187;
  if (v168) {
    goto LABEL_306;
  }
LABEL_307:
  a1[1] = v179;
  unint64_t v189 = (unint64_t)a1[2];
  if ((unint64_t)v179 < v189)
  {
    *(void *)__double2 v179 = 0x9292F9031FE6DB5;
    *((void *)v179 + 1) = "md::ls::ClippingConstantDataHandle]";
    *((void *)v179 + 2) = 34;
    double v190 = v179 + 24;
    goto LABEL_325;
  }
  double v191 = *a1;
  unint64_t v192 = 0xAAAAAAAAAAAAAAABLL * ((v179 - *a1) >> 3);
  unint64_t v193 = v192 + 1;
  if (v192 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v194 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v189 - (void)v191) >> 3);
  if (2 * v194 > v193) {
    unint64_t v193 = 2 * v194;
  }
  if (v194 >= 0x555555555555555) {
    unint64_t v195 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v195 = v193;
  }
  if (v195)
  {
    if (v195 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    double v196 = (char *)operator new(24 * v195);
  }
  else
  {
    double v196 = 0;
  }
  float v197 = &v196[24 * v192];
  int v198 = &v196[24 * v195];
  *(void *)float v197 = 0x9292F9031FE6DB5;
  *((void *)v197 + 1) = "md::ls::ClippingConstantDataHandle]";
  *((void *)v197 + 2) = 34;
  double v190 = v197 + 24;
  if (v179 == v191)
  {
    *a1 = v197;
    a1[1] = v190;
    a1[2] = v198;
LABEL_324:
    operator delete(v179);
    goto LABEL_325;
  }
  do
  {
    long long v199 = *(_OWORD *)(v179 - 24);
    *((void *)v197 - 1) = *((void *)v179 - 1);
    *(_OWORD *)(v197 - 24) = v199;
    v197 -= 24;
    v179 -= 24;
  }
  while (v179 != v191);
  __double2 v179 = *a1;
  *a1 = v197;
  a1[1] = v190;
  a1[2] = v198;
  if (v179) {
    goto LABEL_324;
  }
LABEL_325:
  a1[1] = v190;
  unint64_t v200 = (unint64_t)a1[2];
  if ((unint64_t)v190 < v200)
  {
    *(void *)double v190 = 0x32FFF5E924C6D657;
    *((void *)v190 + 1) = "md::ls::PlanarConstantDataHandle]";
    *((void *)v190 + 2) = 32;
    unint64_t v201 = v190 + 24;
    goto LABEL_343;
  }
  double v202 = *a1;
  unint64_t v203 = 0xAAAAAAAAAAAAAAABLL * ((v190 - *a1) >> 3);
  unint64_t v204 = v203 + 1;
  if (v203 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v205 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v200 - (void)v202) >> 3);
  if (2 * v205 > v204) {
    unint64_t v204 = 2 * v205;
  }
  if (v205 >= 0x555555555555555) {
    unint64_t v206 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v206 = v204;
  }
  if (v206)
  {
    if (v206 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    double v207 = (char *)operator new(24 * v206);
  }
  else
  {
    double v207 = 0;
  }
  double v208 = &v207[24 * v203];
  float v209 = &v207[24 * v206];
  *(void *)double v208 = 0x32FFF5E924C6D657;
  *((void *)v208 + 1) = "md::ls::PlanarConstantDataHandle]";
  *((void *)v208 + 2) = 32;
  unint64_t v201 = v208 + 24;
  if (v190 == v202)
  {
    *a1 = v208;
    a1[1] = v201;
    a1[2] = v209;
LABEL_342:
    operator delete(v190);
    goto LABEL_343;
  }
  do
  {
    long long v210 = *(_OWORD *)(v190 - 24);
    *((void *)v208 - 1) = *((void *)v190 - 1);
    *(_OWORD *)(v208 - 24) = v210;
    v208 -= 24;
    v190 -= 24;
  }
  while (v190 != v202);
  double v190 = *a1;
  *a1 = v208;
  a1[1] = v201;
  a1[2] = v209;
  if (v190) {
    goto LABEL_342;
  }
LABEL_343:
  a1[1] = v201;
  unint64_t v211 = (unint64_t)a1[2];
  if ((unint64_t)v201 < v211)
  {
    *(void *)unint64_t v201 = 0x1D932F2BF291491;
    *((void *)v201 + 1) = "md::ls::TextureHandleForType<DaVinci::TexTexture>]";
    *((void *)v201 + 2) = 49;
    uint64_t v212 = v201 + 24;
    goto LABEL_361;
  }
  double v213 = *a1;
  unint64_t v214 = 0xAAAAAAAAAAAAAAABLL * ((v201 - *a1) >> 3);
  unint64_t v215 = v214 + 1;
  if (v214 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v216 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v211 - (void)v213) >> 3);
  if (2 * v216 > v215) {
    unint64_t v215 = 2 * v216;
  }
  if (v216 >= 0x555555555555555) {
    unint64_t v217 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v217 = v215;
  }
  if (v217)
  {
    if (v217 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    BOOL v218 = (char *)operator new(24 * v217);
  }
  else
  {
    BOOL v218 = 0;
  }
  double v219 = &v218[24 * v214];
  double v220 = &v218[24 * v217];
  *(void *)double v219 = 0x1D932F2BF291491;
  *((void *)v219 + 1) = "md::ls::TextureHandleForType<DaVinci::TexTexture>]";
  *((void *)v219 + 2) = 49;
  uint64_t v212 = v219 + 24;
  if (v201 == v213)
  {
    *a1 = v219;
    a1[1] = v212;
    a1[2] = v220;
LABEL_360:
    operator delete(v201);
    goto LABEL_361;
  }
  do
  {
    long long v221 = *(_OWORD *)(v201 - 24);
    *((void *)v219 - 1) = *((void *)v201 - 1);
    *(_OWORD *)(v219 - 24) = v221;
    v219 -= 24;
    v201 -= 24;
  }
  while (v201 != v213);
  unint64_t v201 = *a1;
  *a1 = v219;
  a1[1] = v212;
  a1[2] = v220;
  if (v201) {
    goto LABEL_360;
  }
LABEL_361:
  a1[1] = v212;
  unint64_t v222 = (unint64_t)a1[2];
  if ((unint64_t)v212 < v222)
  {
    *(void *)uint64_t v212 = 0xCE03281732FA0019;
    *((void *)v212 + 1) = "md::ls::TextureHandleForType<DaVinci::EmissiveTexture>]";
    *((void *)v212 + 2) = 54;
    double v223 = v212 + 24;
    goto LABEL_379;
  }
  double v224 = *a1;
  unint64_t v225 = 0xAAAAAAAAAAAAAAABLL * ((v212 - *a1) >> 3);
  unint64_t v226 = v225 + 1;
  if (v225 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v227 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v222 - (void)v224) >> 3);
  if (2 * v227 > v226) {
    unint64_t v226 = 2 * v227;
  }
  if (v227 >= 0x555555555555555) {
    unint64_t v228 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v228 = v226;
  }
  if (v228)
  {
    if (v228 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    double v229 = (char *)operator new(24 * v228);
  }
  else
  {
    double v229 = 0;
  }
  long double v230 = &v229[24 * v225];
  float v231 = &v229[24 * v228];
  *(void *)long double v230 = 0xCE03281732FA0019;
  *((void *)v230 + 1) = "md::ls::TextureHandleForType<DaVinci::EmissiveTexture>]";
  *((void *)v230 + 2) = 54;
  double v223 = v230 + 24;
  if (v212 == v224)
  {
    *a1 = v230;
    a1[1] = v223;
    a1[2] = v231;
LABEL_378:
    operator delete(v212);
    goto LABEL_379;
  }
  do
  {
    long long v232 = *(_OWORD *)(v212 - 24);
    *((void *)v230 - 1) = *((void *)v212 - 1);
    *(_OWORD *)(v230 - 24) = v232;
    v230 -= 24;
    v212 -= 24;
  }
  while (v212 != v224);
  uint64_t v212 = *a1;
  *a1 = v230;
  a1[1] = v223;
  a1[2] = v231;
  if (v212) {
    goto LABEL_378;
  }
LABEL_379:
  a1[1] = v223;
  unint64_t v233 = (unint64_t)a1[2];
  if ((unint64_t)v223 < v233)
  {
    *(void *)double v223 = 0xD2D99CA7D5B116C8;
    *((void *)v223 + 1) = "md::ls::TextureHandleForType<DaVinci::OverlayTexture>]";
    *((void *)v223 + 2) = 53;
    float v234 = v223 + 24;
    goto LABEL_397;
  }
  double v235 = *a1;
  unint64_t v236 = 0xAAAAAAAAAAAAAAABLL * ((v223 - *a1) >> 3);
  unint64_t v237 = v236 + 1;
  if (v236 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v238 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v233 - (void)v235) >> 3);
  if (2 * v238 > v237) {
    unint64_t v237 = 2 * v238;
  }
  if (v238 >= 0x555555555555555) {
    unint64_t v239 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v239 = v237;
  }
  if (v239)
  {
    if (v239 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    double v240 = (char *)operator new(24 * v239);
  }
  else
  {
    double v240 = 0;
  }
  double v241 = &v240[24 * v236];
  double v242 = &v240[24 * v239];
  *(void *)double v241 = 0xD2D99CA7D5B116C8;
  *((void *)v241 + 1) = "md::ls::TextureHandleForType<DaVinci::OverlayTexture>]";
  *((void *)v241 + 2) = 53;
  float v234 = v241 + 24;
  if (v223 == v235)
  {
    *a1 = v241;
    a1[1] = v234;
    a1[2] = v242;
LABEL_396:
    operator delete(v223);
    goto LABEL_397;
  }
  do
  {
    long long v243 = *(_OWORD *)(v223 - 24);
    *((void *)v241 - 1) = *((void *)v223 - 1);
    *(_OWORD *)(v241 - 24) = v243;
    v241 -= 24;
    v223 -= 24;
  }
  while (v223 != v235);
  double v223 = *a1;
  *a1 = v241;
  a1[1] = v234;
  a1[2] = v242;
  if (v223) {
    goto LABEL_396;
  }
LABEL_397:
  a1[1] = v234;
  unint64_t v244 = (unint64_t)a1[2];
  if ((unint64_t)v234 < v244)
  {
    *(void *)float v234 = 0xDF0018B9242ADFDBLL;
    *((void *)v234 + 1) = "md::ls::BlendRasterConstantDataHandle]";
    *((void *)v234 + 2) = 37;
    double v245 = v234 + 24;
    goto LABEL_415;
  }
  double v246 = *a1;
  unint64_t v247 = 0xAAAAAAAAAAAAAAABLL * ((v234 - *a1) >> 3);
  unint64_t v248 = v247 + 1;
  if (v247 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v249 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v244 - (void)v246) >> 3);
  if (2 * v249 > v248) {
    unint64_t v248 = 2 * v249;
  }
  if (v249 >= 0x555555555555555) {
    unint64_t v250 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v250 = v248;
  }
  if (v250)
  {
    if (v250 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    double v251 = (char *)operator new(24 * v250);
  }
  else
  {
    double v251 = 0;
  }
  double v252 = &v251[24 * v247];
  double v253 = &v251[24 * v250];
  *(void *)double v252 = 0xDF0018B9242ADFDBLL;
  *((void *)v252 + 1) = "md::ls::BlendRasterConstantDataHandle]";
  *((void *)v252 + 2) = 37;
  double v245 = v252 + 24;
  if (v234 == v246)
  {
    *a1 = v252;
    a1[1] = v245;
    a1[2] = v253;
LABEL_414:
    operator delete(v234);
    goto LABEL_415;
  }
  do
  {
    long long v254 = *(_OWORD *)(v234 - 24);
    *((void *)v252 - 1) = *((void *)v234 - 1);
    *(_OWORD *)(v252 - 24) = v254;
    v252 -= 24;
    v234 -= 24;
  }
  while (v234 != v246);
  float v234 = *a1;
  *a1 = v252;
  a1[1] = v245;
  a1[2] = v253;
  if (v234) {
    goto LABEL_414;
  }
LABEL_415:
  a1[1] = v245;
  unint64_t v255 = (unint64_t)a1[2];
  if ((unint64_t)v245 < v255)
  {
    *(void *)double v245 = 0xDC66BF6D06F6D0BALL;
    *((void *)v245 + 1) = "md::ls::RasterOverlayConstantDataHandle]";
    *((void *)v245 + 2) = 39;
    double v256 = v245 + 24;
    goto LABEL_433;
  }
  double v257 = *a1;
  unint64_t v258 = 0xAAAAAAAAAAAAAAABLL * ((v245 - *a1) >> 3);
  unint64_t v259 = v258 + 1;
  if (v258 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v260 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v255 - (void)v257) >> 3);
  if (2 * v260 > v259) {
    unint64_t v259 = 2 * v260;
  }
  if (v260 >= 0x555555555555555) {
    unint64_t v261 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v261 = v259;
  }
  if (v261)
  {
    if (v261 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    double v262 = (char *)operator new(24 * v261);
  }
  else
  {
    double v262 = 0;
  }
  double v263 = &v262[24 * v258];
  double v264 = &v262[24 * v261];
  *(void *)double v263 = 0xDC66BF6D06F6D0BALL;
  *((void *)v263 + 1) = "md::ls::RasterOverlayConstantDataHandle]";
  *((void *)v263 + 2) = 39;
  double v256 = v263 + 24;
  if (v245 == v257)
  {
    *a1 = v263;
    a1[1] = v256;
    a1[2] = v264;
LABEL_432:
    operator delete(v245);
    goto LABEL_433;
  }
  do
  {
    long long v265 = *(_OWORD *)(v245 - 24);
    *((void *)v263 - 1) = *((void *)v245 - 1);
    *(_OWORD *)(v263 - 24) = v265;
    v263 -= 24;
    v245 -= 24;
  }
  while (v245 != v257);
  double v245 = *a1;
  *a1 = v263;
  a1[1] = v256;
  a1[2] = v264;
  if (v245) {
    goto LABEL_432;
  }
LABEL_433:
  a1[1] = v256;
  unint64_t v266 = (unint64_t)a1[2];
  if ((unint64_t)v256 < v266)
  {
    *(void *)double v256 = 0x985FB09D9DF9959FLL;
    *((void *)v256 + 1) = "md::ls::HasStyleAttributeRasterSet]";
    *((void *)v256 + 2) = 34;
    double v267 = v256 + 24;
    goto LABEL_451;
  }
  uint64_t v268 = *a1;
  unint64_t v269 = 0xAAAAAAAAAAAAAAABLL * ((v256 - *a1) >> 3);
  unint64_t v270 = v269 + 1;
  if (v269 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v271 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v266 - (void)v268) >> 3);
  if (2 * v271 > v270) {
    unint64_t v270 = 2 * v271;
  }
  if (v271 >= 0x555555555555555) {
    unint64_t v272 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v272 = v270;
  }
  if (v272)
  {
    if (v272 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    double v273 = (char *)operator new(24 * v272);
  }
  else
  {
    double v273 = 0;
  }
  double v274 = &v273[24 * v269];
  double v275 = &v273[24 * v272];
  *(void *)double v274 = 0x985FB09D9DF9959FLL;
  *((void *)v274 + 1) = "md::ls::HasStyleAttributeRasterSet]";
  *((void *)v274 + 2) = 34;
  double v267 = v274 + 24;
  if (v256 == v268)
  {
    *a1 = v274;
    a1[1] = v267;
    a1[2] = v275;
LABEL_450:
    operator delete(v256);
    goto LABEL_451;
  }
  do
  {
    long long v276 = *(_OWORD *)(v256 - 24);
    *((void *)v274 - 1) = *((void *)v256 - 1);
    *(_OWORD *)(v274 - 24) = v276;
    v274 -= 24;
    v256 -= 24;
  }
  while (v256 != v268);
  double v256 = *a1;
  *a1 = v274;
  a1[1] = v267;
  a1[2] = v275;
  if (v256) {
    goto LABEL_450;
  }
LABEL_451:
  a1[1] = v267;
  unint64_t v277 = (unint64_t)a1[2];
  if ((unint64_t)v267 < v277)
  {
    *(void *)double v267 = 0x11BB47B172EB0B40;
    *((void *)v267 + 1) = "md::ls::NeedsClimateTint]";
    *((void *)v267 + 2) = 24;
    double v278 = v267 + 24;
    goto LABEL_469;
  }
  double v279 = *a1;
  unint64_t v280 = 0xAAAAAAAAAAAAAAABLL * ((v267 - *a1) >> 3);
  unint64_t v281 = v280 + 1;
  if (v280 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v282 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v277 - (void)v279) >> 3);
  if (2 * v282 > v281) {
    unint64_t v281 = 2 * v282;
  }
  if (v282 >= 0x555555555555555) {
    unint64_t v283 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v283 = v281;
  }
  if (v283)
  {
    if (v283 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    double v284 = (char *)operator new(24 * v283);
  }
  else
  {
    double v284 = 0;
  }
  double v285 = &v284[24 * v280];
  double v286 = &v284[24 * v283];
  *(void *)double v285 = 0x11BB47B172EB0B40;
  *((void *)v285 + 1) = "md::ls::NeedsClimateTint]";
  *((void *)v285 + 2) = 24;
  double v278 = v285 + 24;
  if (v267 == v279)
  {
    *a1 = v285;
    a1[1] = v278;
    a1[2] = v286;
LABEL_468:
    operator delete(v267);
    goto LABEL_469;
  }
  do
  {
    long long v287 = *(_OWORD *)(v267 - 24);
    *((void *)v285 - 1) = *((void *)v267 - 1);
    *(_OWORD *)(v285 - 24) = v287;
    v285 -= 24;
    v267 -= 24;
  }
  while (v267 != v279);
  double v267 = *a1;
  *a1 = v285;
  a1[1] = v278;
  a1[2] = v286;
  if (v267) {
    goto LABEL_468;
  }
LABEL_469:
  a1[1] = v278;
  unint64_t v288 = (unint64_t)a1[2];
  if ((unint64_t)v278 < v288)
  {
    *(void *)double v278 = 0xA0C97F52893883B7;
    *((void *)v278 + 1) = "md::ls::CustomRenderState]";
    *((void *)v278 + 2) = 25;
    double v289 = v278 + 24;
    goto LABEL_487;
  }
  double v290 = *a1;
  unint64_t v291 = 0xAAAAAAAAAAAAAAABLL * ((v278 - *a1) >> 3);
  unint64_t v292 = v291 + 1;
  if (v291 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v293 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v288 - (void)v290) >> 3);
  if (2 * v293 > v292) {
    unint64_t v292 = 2 * v293;
  }
  if (v293 >= 0x555555555555555) {
    unint64_t v294 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v294 = v292;
  }
  if (v294)
  {
    if (v294 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    double v295 = (char *)operator new(24 * v294);
  }
  else
  {
    double v295 = 0;
  }
  double v296 = &v295[24 * v291];
  double v297 = &v295[24 * v294];
  *(void *)double v296 = 0xA0C97F52893883B7;
  *((void *)v296 + 1) = "md::ls::CustomRenderState]";
  *((void *)v296 + 2) = 25;
  double v289 = v296 + 24;
  if (v278 == v290)
  {
    *a1 = v296;
    a1[1] = v289;
    a1[2] = v297;
LABEL_486:
    operator delete(v278);
    goto LABEL_487;
  }
  do
  {
    long long v298 = *(_OWORD *)(v278 - 24);
    *((void *)v296 - 1) = *((void *)v278 - 1);
    *(_OWORD *)(v296 - 24) = v298;
    v296 -= 24;
    v278 -= 24;
  }
  while (v278 != v290);
  double v278 = *a1;
  *a1 = v296;
  a1[1] = v289;
  a1[2] = v297;
  if (v278) {
    goto LABEL_486;
  }
LABEL_487:
  a1[1] = v289;
  unint64_t v299 = (unint64_t)a1[2];
  if ((unint64_t)v289 < v299)
  {
    *(void *)double v289 = 0xE103B5C60804137ELL;
    *((void *)v289 + 1) = "md::ls::ColorRampDataHandle]";
    *((void *)v289 + 2) = 27;
    double v300 = v289 + 24;
    goto LABEL_505;
  }
  double v301 = *a1;
  unint64_t v302 = 0xAAAAAAAAAAAAAAABLL * ((v289 - *a1) >> 3);
  unint64_t v303 = v302 + 1;
  if (v302 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v304 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v299 - (void)v301) >> 3);
  if (2 * v304 > v303) {
    unint64_t v303 = 2 * v304;
  }
  if (v304 >= 0x555555555555555) {
    unint64_t v305 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v305 = v303;
  }
  if (v305)
  {
    if (v305 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    long long v306 = (char *)operator new(24 * v305);
  }
  else
  {
    long long v306 = 0;
  }
  long long v307 = &v306[24 * v302];
  uint64_t v308 = &v306[24 * v305];
  *(void *)long long v307 = 0xE103B5C60804137ELL;
  *((void *)v307 + 1) = "md::ls::ColorRampDataHandle]";
  *((void *)v307 + 2) = 27;
  double v300 = v307 + 24;
  if (v289 == v301)
  {
    *a1 = v307;
    a1[1] = v300;
    a1[2] = v308;
LABEL_504:
    operator delete(v289);
    goto LABEL_505;
  }
  do
  {
    long long v309 = *(_OWORD *)(v289 - 24);
    *((void *)v307 - 1) = *((void *)v289 - 1);
    *(_OWORD *)(v307 - 24) = v309;
    v307 -= 24;
    v289 -= 24;
  }
  while (v289 != v301);
  double v289 = *a1;
  *a1 = v307;
  a1[1] = v300;
  a1[2] = v308;
  if (v289) {
    goto LABEL_504;
  }
LABEL_505:
  a1[1] = v300;
  unint64_t v310 = (unint64_t)a1[2];
  if ((unint64_t)v300 < v310)
  {
    *(void *)double v300 = 0x7931433C9A6EB2C6;
    *((void *)v300 + 1) = "md::ls::SharedUniqueID]";
    *((void *)v300 + 2) = 22;
    double v311 = v300 + 24;
    goto LABEL_523;
  }
  double v312 = *a1;
  unint64_t v313 = 0xAAAAAAAAAAAAAAABLL * ((v300 - *a1) >> 3);
  unint64_t v314 = v313 + 1;
  if (v313 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v315 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v310 - (void)v312) >> 3);
  if (2 * v315 > v314) {
    unint64_t v314 = 2 * v315;
  }
  if (v315 >= 0x555555555555555) {
    unint64_t v316 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v316 = v314;
  }
  if (v316)
  {
    if (v316 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v317 = (char *)operator new(24 * v316);
  }
  else
  {
    uint64_t v317 = 0;
  }
  BOOL v318 = &v317[24 * v313];
  int v319 = &v317[24 * v316];
  *(void *)BOOL v318 = 0x7931433C9A6EB2C6;
  *((void *)v318 + 1) = "md::ls::SharedUniqueID]";
  *((void *)v318 + 2) = 22;
  double v311 = v318 + 24;
  if (v300 == v312)
  {
    *a1 = v318;
    a1[1] = v311;
    a1[2] = v319;
LABEL_522:
    operator delete(v300);
    goto LABEL_523;
  }
  do
  {
    long long v320 = *(_OWORD *)(v300 - 24);
    *((void *)v318 - 1) = *((void *)v300 - 1);
    *(_OWORD *)(v318 - 24) = v320;
    v318 -= 24;
    v300 -= 24;
  }
  while (v300 != v312);
  double v300 = *a1;
  *a1 = v318;
  a1[1] = v311;
  a1[2] = v319;
  if (v300) {
    goto LABEL_522;
  }
LABEL_523:
  a1[1] = v311;
  unint64_t v321 = (unint64_t)a1[2];
  if ((unint64_t)v311 < v321)
  {
    *(void *)double v311 = 0x7087983DEF28DBFELL;
    *((void *)v311 + 1) = "md::ls::IsOpaque]";
    *((void *)v311 + 2) = 16;
    v322 = v311 + 24;
    goto LABEL_541;
  }
  uint64_t v323 = *a1;
  unint64_t v324 = 0xAAAAAAAAAAAAAAABLL * ((v311 - *a1) >> 3);
  unint64_t v325 = v324 + 1;
  if (v324 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v326 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v321 - (void)v323) >> 3);
  if (2 * v326 > v325) {
    unint64_t v325 = 2 * v326;
  }
  if (v326 >= 0x555555555555555) {
    unint64_t v327 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v327 = v325;
  }
  if (v327)
  {
    if (v327 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    double v328 = (char *)operator new(24 * v327);
  }
  else
  {
    double v328 = 0;
  }
  double v329 = &v328[24 * v324];
  double v330 = &v328[24 * v327];
  *(void *)double v329 = 0x7087983DEF28DBFELL;
  *((void *)v329 + 1) = "md::ls::IsOpaque]";
  *((void *)v329 + 2) = 16;
  v322 = v329 + 24;
  if (v311 == v323)
  {
    *a1 = v329;
    a1[1] = v322;
    a1[2] = v330;
LABEL_540:
    operator delete(v311);
    goto LABEL_541;
  }
  do
  {
    long long v331 = *(_OWORD *)(v311 - 24);
    *((void *)v329 - 1) = *((void *)v311 - 1);
    *(_OWORD *)(v329 - 24) = v331;
    v329 -= 24;
    v311 -= 24;
  }
  while (v311 != v323);
  double v311 = *a1;
  *a1 = v329;
  a1[1] = v322;
  a1[2] = v330;
  if (v311) {
    goto LABEL_540;
  }
LABEL_541:
  a1[1] = v322;
  unint64_t v332 = (unint64_t)a1[2];
  if ((unint64_t)v322 < v332)
  {
    *(void *)v322 = 0x73F0259EC1934FB1;
    *((void *)v322 + 1) = "md::ls::IsTransparent]";
    *((void *)v322 + 2) = 21;
    double v333 = v322 + 24;
    goto LABEL_559;
  }
  double v334 = *a1;
  unint64_t v335 = 0xAAAAAAAAAAAAAAABLL * ((v322 - *a1) >> 3);
  unint64_t v336 = v335 + 1;
  if (v335 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v337 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v332 - (void)v334) >> 3);
  if (2 * v337 > v336) {
    unint64_t v336 = 2 * v337;
  }
  if (v337 >= 0x555555555555555) {
    unint64_t v338 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v338 = v336;
  }
  if (v338)
  {
    if (v338 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    __double2 v339 = (char *)operator new(24 * v338);
  }
  else
  {
    __double2 v339 = 0;
  }
  double v340 = &v339[24 * v335];
  double v341 = &v339[24 * v338];
  *(void *)double v340 = 0x73F0259EC1934FB1;
  *((void *)v340 + 1) = "md::ls::IsTransparent]";
  *((void *)v340 + 2) = 21;
  double v333 = v340 + 24;
  if (v322 == v334)
  {
    *a1 = v340;
    a1[1] = v333;
    a1[2] = v341;
LABEL_558:
    operator delete(v322);
    goto LABEL_559;
  }
  do
  {
    long long v342 = *(_OWORD *)(v322 - 24);
    *((void *)v340 - 1) = *((void *)v322 - 1);
    *(_OWORD *)(v340 - 24) = v342;
    v340 -= 24;
    v322 -= 24;
  }
  while (v322 != v334);
  v322 = *a1;
  *a1 = v340;
  a1[1] = v333;
  a1[2] = v341;
  if (v322) {
    goto LABEL_558;
  }
LABEL_559:
  a1[1] = v333;
  unint64_t v343 = (unint64_t)a1[2];
  if ((unint64_t)v333 < v343)
  {
    *(void *)double v333 = 0x499CE17DBD9A1615;
    *((void *)v333 + 1) = "md::ls::NeedsZBias]";
    *((void *)v333 + 2) = 18;
    float v344 = v333 + 24;
    goto LABEL_577;
  }
  double v345 = *a1;
  unint64_t v346 = 0xAAAAAAAAAAAAAAABLL * ((v333 - *a1) >> 3);
  unint64_t v347 = v346 + 1;
  if (v346 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v348 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v343 - (void)v345) >> 3);
  if (2 * v348 > v347) {
    unint64_t v347 = 2 * v348;
  }
  if (v348 >= 0x555555555555555) {
    unint64_t v349 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v349 = v347;
  }
  if (v349)
  {
    if (v349 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v350 = (char *)operator new(24 * v349);
  }
  else
  {
    uint64_t v350 = 0;
  }
  BOOL v351 = &v350[24 * v346];
  BOOL v352 = &v350[24 * v349];
  *(void *)BOOL v351 = 0x499CE17DBD9A1615;
  *((void *)v351 + 1) = "md::ls::NeedsZBias]";
  *((void *)v351 + 2) = 18;
  float v344 = v351 + 24;
  if (v333 == v345)
  {
    *a1 = v351;
    a1[1] = v344;
    a1[2] = v352;
LABEL_576:
    operator delete(v333);
    goto LABEL_577;
  }
  do
  {
    long long v353 = *(_OWORD *)(v333 - 24);
    *((void *)v351 - 1) = *((void *)v333 - 1);
    *(_OWORD *)(v351 - 24) = v353;
    v351 -= 24;
    v333 -= 24;
  }
  while (v333 != v345);
  double v333 = *a1;
  *a1 = v351;
  a1[1] = v344;
  a1[2] = v352;
  if (v333) {
    goto LABEL_576;
  }
LABEL_577:
  a1[1] = v344;
  unint64_t v354 = (unint64_t)a1[2];
  if ((unint64_t)v344 < v354)
  {
    *(void *)float v344 = 0x98A9F01DBB8BCCCELL;
    *((void *)v344 + 1) = "md::ls::PreserveHeight]";
    *((void *)v344 + 2) = 22;
    int v355 = v344 + 24;
    goto LABEL_595;
  }
  uint64_t v356 = *a1;
  unint64_t v357 = 0xAAAAAAAAAAAAAAABLL * ((v344 - *a1) >> 3);
  unint64_t v358 = v357 + 1;
  if (v357 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v359 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v354 - (void)v356) >> 3);
  if (2 * v359 > v358) {
    unint64_t v358 = 2 * v359;
  }
  if (v359 >= 0x555555555555555) {
    unint64_t v360 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v360 = v358;
  }
  if (v360)
  {
    if (v360 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    unsigned int v361 = (char *)operator new(24 * v360);
  }
  else
  {
    unsigned int v361 = 0;
  }
  unint64_t v362 = &v361[24 * v357];
  unint64_t v363 = &v361[24 * v360];
  *(void *)unint64_t v362 = 0x98A9F01DBB8BCCCELL;
  *((void *)v362 + 1) = "md::ls::PreserveHeight]";
  *((void *)v362 + 2) = 22;
  int v355 = v362 + 24;
  if (v344 == v356)
  {
    *a1 = v362;
    a1[1] = v355;
    a1[2] = v363;
LABEL_594:
    operator delete(v344);
    goto LABEL_595;
  }
  do
  {
    long long v364 = *(_OWORD *)(v344 - 24);
    *((void *)v362 - 1) = *((void *)v344 - 1);
    *(_OWORD *)(v362 - 24) = v364;
    v362 -= 24;
    v344 -= 24;
  }
  while (v344 != v356);
  float v344 = *a1;
  *a1 = v362;
  a1[1] = v355;
  a1[2] = v363;
  if (v344) {
    goto LABEL_594;
  }
LABEL_595:
  a1[1] = v355;
  unint64_t v365 = (unint64_t)a1[2];
  if ((unint64_t)v355 < v365)
  {
    *(void *)int v355 = 0xE53EF176130D7769;
    *((void *)v355 + 1) = "md::ls::InstanceCount]";
    *((void *)v355 + 2) = 21;
    uint64_t v366 = v355 + 24;
    goto LABEL_613;
  }
  unint64_t v367 = *a1;
  unint64_t v368 = 0xAAAAAAAAAAAAAAABLL * ((v355 - *a1) >> 3);
  unint64_t v369 = v368 + 1;
  if (v368 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v370 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v365 - (void)v367) >> 3);
  if (2 * v370 > v369) {
    unint64_t v369 = 2 * v370;
  }
  if (v370 >= 0x555555555555555) {
    unint64_t v371 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v371 = v369;
  }
  if (v371)
  {
    if (v371 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    unint64_t v372 = (char *)operator new(24 * v371);
  }
  else
  {
    unint64_t v372 = 0;
  }
  uint64_t v373 = &v372[24 * v368];
  int v374 = &v372[24 * v371];
  *(void *)uint64_t v373 = 0xE53EF176130D7769;
  *((void *)v373 + 1) = "md::ls::InstanceCount]";
  *((void *)v373 + 2) = 21;
  uint64_t v366 = v373 + 24;
  if (v355 == v367)
  {
    *a1 = v373;
    a1[1] = v366;
    a1[2] = v374;
LABEL_612:
    operator delete(v355);
    goto LABEL_613;
  }
  do
  {
    long long v375 = *(_OWORD *)(v355 - 24);
    *((void *)v373 - 1) = *((void *)v355 - 1);
    *(_OWORD *)(v373 - 24) = v375;
    v373 -= 24;
    v355 -= 24;
  }
  while (v355 != v367);
  int v355 = *a1;
  *a1 = v373;
  a1[1] = v366;
  a1[2] = v374;
  if (v355) {
    goto LABEL_612;
  }
LABEL_613:
  a1[1] = v366;
  unint64_t v376 = (unint64_t)a1[2];
  if ((unint64_t)v366 < v376)
  {
    *(void *)uint64_t v366 = 0x76B9BA390004E44ELL;
    *((void *)v366 + 1) = "md::ls::IsDecal]";
    *((void *)v366 + 2) = 15;
    unint64_t v377 = v366 + 24;
    goto LABEL_631;
  }
  uint64_t v378 = *a1;
  unint64_t v379 = 0xAAAAAAAAAAAAAAABLL * ((v366 - *a1) >> 3);
  unint64_t v380 = v379 + 1;
  if (v379 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v381 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v376 - (void)v378) >> 3);
  if (2 * v381 > v380) {
    unint64_t v380 = 2 * v381;
  }
  if (v381 >= 0x555555555555555) {
    unint64_t v382 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v382 = v380;
  }
  if (v382)
  {
    if (v382 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v383 = (char *)operator new(24 * v382);
  }
  else
  {
    uint64_t v383 = 0;
  }
  unint64_t v384 = &v383[24 * v379];
  uint64_t v385 = &v383[24 * v382];
  *(void *)unint64_t v384 = 0x76B9BA390004E44ELL;
  *((void *)v384 + 1) = "md::ls::IsDecal]";
  *((void *)v384 + 2) = 15;
  unint64_t v377 = v384 + 24;
  if (v366 == v378)
  {
    *a1 = v384;
    a1[1] = v377;
    a1[2] = v385;
LABEL_630:
    operator delete(v366);
    goto LABEL_631;
  }
  do
  {
    long long v386 = *(_OWORD *)(v366 - 24);
    *((void *)v384 - 1) = *((void *)v366 - 1);
    *(_OWORD *)(v384 - 24) = v386;
    v384 -= 24;
    v366 -= 24;
  }
  while (v366 != v378);
  uint64_t v366 = *a1;
  *a1 = v384;
  a1[1] = v377;
  a1[2] = v385;
  if (v366) {
    goto LABEL_630;
  }
LABEL_631:
  a1[1] = v377;
  unint64_t v387 = (unint64_t)a1[2];
  if ((unint64_t)v377 < v387)
  {
    *(void *)unint64_t v377 = 0x3E8485C60908F920;
    *((void *)v377 + 1) = "md::ls::IsMaterial]";
    *((void *)v377 + 2) = 18;
    uint64_t v388 = v377 + 24;
    goto LABEL_649;
  }
  uint64_t v389 = *a1;
  unint64_t v390 = 0xAAAAAAAAAAAAAAABLL * ((v377 - *a1) >> 3);
  unint64_t v391 = v390 + 1;
  if (v390 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v392 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v387 - (void)v389) >> 3);
  if (2 * v392 > v391) {
    unint64_t v391 = 2 * v392;
  }
  if (v392 >= 0x555555555555555) {
    unint64_t v393 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v393 = v391;
  }
  if (v393)
  {
    if (v393 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v394 = (char *)operator new(24 * v393);
  }
  else
  {
    uint64_t v394 = 0;
  }
  uint64_t v395 = &v394[24 * v390];
  BOOL v396 = &v394[24 * v393];
  *(void *)uint64_t v395 = 0x3E8485C60908F920;
  *((void *)v395 + 1) = "md::ls::IsMaterial]";
  *((void *)v395 + 2) = 18;
  uint64_t v388 = v395 + 24;
  if (v377 == v389)
  {
    *a1 = v395;
    a1[1] = v388;
    a1[2] = v396;
LABEL_648:
    operator delete(v377);
    goto LABEL_649;
  }
  do
  {
    long long v397 = *(_OWORD *)(v377 - 24);
    *((void *)v395 - 1) = *((void *)v377 - 1);
    *(_OWORD *)(v395 - 24) = v397;
    v395 -= 24;
    v377 -= 24;
  }
  while (v377 != v389);
  unint64_t v377 = *a1;
  *a1 = v395;
  a1[1] = v388;
  a1[2] = v396;
  if (v377) {
    goto LABEL_648;
  }
LABEL_649:
  a1[1] = v388;
  unint64_t v398 = (unint64_t)a1[2];
  if ((unint64_t)v388 < v398)
  {
    *(void *)uint64_t v388 = 0x237F9D3BCC905318;
    *((void *)v388 + 1) = "md::ls::IsMercator]";
    *((void *)v388 + 2) = 18;
    unint64_t v399 = v388 + 24;
    goto LABEL_667;
  }
  unint64_t v400 = *a1;
  unint64_t v401 = 0xAAAAAAAAAAAAAAABLL * ((v388 - *a1) >> 3);
  unint64_t v402 = v401 + 1;
  if (v401 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v403 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v398 - (void)v400) >> 3);
  if (2 * v403 > v402) {
    unint64_t v402 = 2 * v403;
  }
  if (v403 >= 0x555555555555555) {
    unint64_t v404 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v404 = v402;
  }
  if (v404)
  {
    if (v404 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v405 = (char *)operator new(24 * v404);
  }
  else
  {
    uint64_t v405 = 0;
  }
  uint64_t v406 = &v405[24 * v401];
  unint64_t v407 = &v405[24 * v404];
  *(void *)uint64_t v406 = 0x237F9D3BCC905318;
  *((void *)v406 + 1) = "md::ls::IsMercator]";
  *((void *)v406 + 2) = 18;
  unint64_t v399 = v406 + 24;
  if (v388 == v400)
  {
    *a1 = v406;
    a1[1] = v399;
    a1[2] = v407;
LABEL_666:
    operator delete(v388);
    goto LABEL_667;
  }
  do
  {
    long long v408 = *(_OWORD *)(v388 - 24);
    *((void *)v406 - 1) = *((void *)v388 - 1);
    *(_OWORD *)(v406 - 24) = v408;
    v406 -= 24;
    v388 -= 24;
  }
  while (v388 != v400);
  uint64_t v388 = *a1;
  *a1 = v406;
  a1[1] = v399;
  a1[2] = v407;
  if (v388) {
    goto LABEL_666;
  }
LABEL_667:
  a1[1] = v399;
  unint64_t v409 = (unint64_t)a1[2];
  if ((unint64_t)v399 < v409)
  {
    *(void *)unint64_t v399 = 0xE115FCB3272B65A3;
    *((void *)v399 + 1) = "md::ls::ZIndex]";
    *((void *)v399 + 2) = 14;
    uint64_t v410 = v399 + 24;
    goto LABEL_685;
  }
  unint64_t v411 = *a1;
  unint64_t v412 = 0xAAAAAAAAAAAAAAABLL * ((v399 - *a1) >> 3);
  unint64_t v413 = v412 + 1;
  if (v412 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v414 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v409 - (void)v411) >> 3);
  if (2 * v414 > v413) {
    unint64_t v413 = 2 * v414;
  }
  if (v414 >= 0x555555555555555) {
    unint64_t v415 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v415 = v413;
  }
  if (v415)
  {
    if (v415 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    unint64_t v416 = (char *)operator new(24 * v415);
  }
  else
  {
    unint64_t v416 = 0;
  }
  uint64_t v417 = &v416[24 * v412];
  unint64_t v418 = &v416[24 * v415];
  *(void *)uint64_t v417 = 0xE115FCB3272B65A3;
  *((void *)v417 + 1) = "md::ls::ZIndex]";
  *((void *)v417 + 2) = 14;
  uint64_t v410 = v417 + 24;
  if (v399 == v411)
  {
    *a1 = v417;
    a1[1] = v410;
    a1[2] = v418;
LABEL_684:
    operator delete(v399);
    goto LABEL_685;
  }
  do
  {
    long long v419 = *(_OWORD *)(v399 - 24);
    *((void *)v417 - 1) = *((void *)v399 - 1);
    *(_OWORD *)(v417 - 24) = v419;
    v417 -= 24;
    v399 -= 24;
  }
  while (v399 != v411);
  unint64_t v399 = *a1;
  *a1 = v417;
  a1[1] = v410;
  a1[2] = v418;
  if (v399) {
    goto LABEL_684;
  }
LABEL_685:
  a1[1] = v410;
  unint64_t v420 = (unint64_t)a1[2];
  if ((unint64_t)v410 < v420)
  {
    *(void *)uint64_t v410 = 0x58D7FF1BC7A42F8;
    *((void *)v410 + 1) = "md::ls::DefaultZIndex]";
    *((void *)v410 + 2) = 21;
    unint64_t v421 = v410 + 24;
    goto LABEL_703;
  }
  uint64_t v422 = *a1;
  unint64_t v423 = 0xAAAAAAAAAAAAAAABLL * ((v410 - *a1) >> 3);
  unint64_t v424 = v423 + 1;
  if (v423 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_722;
  }
  unint64_t v425 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v420 - (void)v422) >> 3);
  if (2 * v425 > v424) {
    unint64_t v424 = 2 * v425;
  }
  if (v425 >= 0x555555555555555) {
    unint64_t v426 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v426 = v424;
  }
  if (v426)
  {
    if (v426 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_723;
    }
    uint64_t v427 = (char *)operator new(24 * v426);
  }
  else
  {
    uint64_t v427 = 0;
  }
  unint64_t v428 = &v427[24 * v423];
  uint64_t v429 = &v427[24 * v426];
  *(void *)unint64_t v428 = 0x58D7FF1BC7A42F8;
  *((void *)v428 + 1) = "md::ls::DefaultZIndex]";
  *((void *)v428 + 2) = 21;
  unint64_t v421 = v428 + 24;
  if (v410 == v422)
  {
    *a1 = v428;
    a1[1] = v421;
    a1[2] = v429;
LABEL_702:
    operator delete(v410);
    goto LABEL_703;
  }
  do
  {
    long long v430 = *(_OWORD *)(v410 - 24);
    *((void *)v428 - 1) = *((void *)v410 - 1);
    *(_OWORD *)(v428 - 24) = v430;
    v428 -= 24;
    v410 -= 24;
  }
  while (v410 != v422);
  uint64_t v410 = *a1;
  *a1 = v428;
  a1[1] = v421;
  a1[2] = v429;
  if (v410) {
    goto LABEL_702;
  }
LABEL_703:
  a1[1] = v421;
  unint64_t v431 = (unint64_t)a1[2];
  if ((unint64_t)v421 < v431)
  {
    *(void *)unint64_t v421 = 0x763953A644184BA9;
    *((void *)v421 + 1) = "md::ls::RenderableHash]";
    *((void *)v421 + 2) = 22;
    uint64_t v432 = v421 + 24;
    goto LABEL_721;
  }
  uint64_t v433 = *a1;
  unint64_t v434 = 0xAAAAAAAAAAAAAAABLL * ((v421 - *a1) >> 3);
  unint64_t v435 = v434 + 1;
  if (v434 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_722:
  }
    abort();
  unint64_t v436 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v431 - (void)v433) >> 3);
  if (2 * v436 > v435) {
    unint64_t v435 = 2 * v436;
  }
  if (v436 >= 0x555555555555555) {
    unint64_t v437 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v437 = v435;
  }
  if (v437)
  {
    if (v437 <= 0xAAAAAAAAAAAAAAALL)
    {
      unint64_t v438 = (char *)operator new(24 * v437);
      goto LABEL_715;
    }
LABEL_723:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  unint64_t v438 = 0;
LABEL_715:
  uint64_t v439 = &v438[24 * v434];
  unint64_t v440 = &v438[24 * v437];
  *(void *)uint64_t v439 = 0x763953A644184BA9;
  *((void *)v439 + 1) = "md::ls::RenderableHash]";
  *((void *)v439 + 2) = 22;
  uint64_t v432 = v439 + 24;
  if (v421 == v433)
  {
    *a1 = v439;
    a1[1] = v432;
    a1[2] = v440;
LABEL_720:
    operator delete(v421);
    goto LABEL_721;
  }
  do
  {
    long long v441 = *(_OWORD *)(v421 - 24);
    *((void *)v439 - 1) = *((void *)v421 - 1);
    *(_OWORD *)(v439 - 24) = v441;
    v439 -= 24;
    v421 -= 24;
  }
  while (v421 != v433);
  unint64_t v421 = *a1;
  *a1 = v439;
  a1[1] = v432;
  a1[2] = v440;
  if (v421) {
    goto LABEL_720;
  }
LABEL_721:
  a1[1] = v432;
}

void sub_1A1BBF120(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPeeledRenderItems>(md::ita::CreateDepthPeeledRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::CreateDepthPeeledRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPeeledRenderItems>(md::ita::CreateDepthPeeledRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0xA8uLL);
  a1[2] = (char *)(v2 + 21);
  *unint64_t v2 = 0xAC1208F38C3ADC06;
  v2[1] = "md::ls::SliceAssignmentT<md::SliceType::Main>]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDC80;
  v2[4] = "md::ls::RenderableMeshVertexFormat]";
  v2[5] = 34;
  v2[6] = 0x751B872B282C3971;
  v2[7] = "md::ls::TileType]";
  v2[8] = 16;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 21)
  {
    *(void *)uint64_t v3 = 0xCB7F6519084BB4D0;
    v2[10] = "md::ls::RequiresDepthPeel]";
    v2[11] = 25;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_74;
  }
  if (0x5555555555555556 * (((char *)(v2 + 21) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 21) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 21) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_75;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xCB7F6519084BB4D0;
  *((void *)v10 + 1) = "md::ls::RequiresDepthPeel]";
  *((void *)v10 + 2) = 25;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0xECC498AF223943D5;
    *((void *)v4 + 1) = "md::ls::MeshLayerTypeV]";
    *((void *)v4 + 2) = 22;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_74;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_75;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0xECC498AF223943D5;
  *((void *)v21 + 1) = "md::ls::MeshLayerTypeV]";
  *((void *)v21 + 2) = 22;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0xEC2A00DC914732D7;
    *((void *)v14 + 1) = "md::ls::IntendedSceneLayer]";
    *((void *)v14 + 2) = 26;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_74;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_75;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0xEC2A00DC914732D7;
  *((void *)v32 + 1) = "md::ls::IntendedSceneLayer]";
  *((void *)v32 + 2) = 26;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0x75DBD6381F1903FFLL;
    *((void *)v25 + 1) = "md::ls::PendingProcessing]";
    *((void *)v25 + 2) = 25;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_74:
  }
    abort();
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v42 = (char *)operator new(24 * v41);
      goto LABEL_67;
    }
LABEL_75:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v42 = 0;
LABEL_67:
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0x75DBD6381F1903FFLL;
  *((void *)v43 + 1) = "md::ls::PendingProcessing]";
  *((void *)v43 + 2) = 25;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
}

void sub_1A1BBF698(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPeeledRenderItems>(md::ita::CreateDepthPeeledRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::CreateDepthPeeledRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPeeledRenderItems>(md::ita::CreateDepthPeeledRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x180uLL);
  a1[2] = (char *)(v2 + 48);
  *unint64_t v2 = 0x523816724122CCE2;
  v2[1] = "md::ls::AssociationHandle]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDC70;
  v2[4] = "md::ls::PrepassConstantDataHandle]";
  v2[5] = 33;
  v2[6] = 0xEAA0B82FC49F7277;
  v2[7] = "md::ls::ShadowConstantDataHandle]";
  v2[8] = 32;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 48)
  {
    *(void *)uint64_t v3 = 0x98A9F01DBB8BCCCELL;
    v2[10] = "md::ls::PreserveHeight]";
    v2[11] = 22;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  if (0x5555555555555556 * (((char *)(v2 + 48) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 48) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 48) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x98A9F01DBB8BCCCELL;
  *((void *)v10 + 1) = "md::ls::PreserveHeight]";
  *((void *)v10 + 2) = 22;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0xCD844FF303308290;
    *((void *)v4 + 1) = "md::ls::HasMeshHandle]";
    *((void *)v4 + 2) = 21;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0xCD844FF303308290;
  *((void *)v21 + 1) = "md::ls::HasMeshHandle]";
  *((void *)v21 + 2) = 21;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0x6C7EE74910D42096;
    *((void *)v14 + 1) = "md::ls::PositionScaleInfoConstantDataHandle]";
    *((void *)v14 + 2) = 43;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0x6C7EE74910D42096;
  *((void *)v32 + 1) = "md::ls::PositionScaleInfoConstantDataHandle]";
  *((void *)v32 + 2) = 43;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0xCFE242268B958ADALL;
    *((void *)v25 + 1) = "md::ls::ViewConstantDataHandle]";
    *((void *)v25 + 2) = 30;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v42 = (char *)operator new(24 * v41);
  }
  else
  {
    uint64_t v42 = 0;
  }
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0xCFE242268B958ADALL;
  *((void *)v43 + 1) = "md::ls::ViewConstantDataHandle]";
  *((void *)v43 + 2) = 30;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
  unint64_t v46 = (unint64_t)a1[2];
  if ((unint64_t)v36 < v46)
  {
    *(void *)uint64_t v36 = 0x74DC502726E97929;
    *((void *)v36 + 1) = "md::ls::TransformConstantDataHandle]";
    *((void *)v36 + 2) = 35;
    unint64_t v47 = v36 + 24;
    goto LABEL_91;
  }
  uint64_t v48 = *a1;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v36 - *a1) >> 3);
  unint64_t v50 = v49 + 1;
  if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v48) >> 3);
  if (2 * v51 > v50) {
    unint64_t v50 = 2 * v51;
  }
  if (v51 >= 0x555555555555555) {
    unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v52 = v50;
  }
  if (v52)
  {
    if (v52 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v53 = (char *)operator new(24 * v52);
  }
  else
  {
    uint64_t v53 = 0;
  }
  uint64_t v54 = &v53[24 * v49];
  uint64_t v55 = &v53[24 * v52];
  *(void *)uint64_t v54 = 0x74DC502726E97929;
  *((void *)v54 + 1) = "md::ls::TransformConstantDataHandle]";
  *((void *)v54 + 2) = 35;
  unint64_t v47 = v54 + 24;
  if (v36 == v48)
  {
    *a1 = v54;
    a1[1] = v47;
    a1[2] = v55;
LABEL_90:
    operator delete(v36);
    goto LABEL_91;
  }
  do
  {
    long long v56 = *(_OWORD *)(v36 - 24);
    *((void *)v54 - 1) = *((void *)v36 - 1);
    *(_OWORD *)(v54 - 24) = v56;
    v54 -= 24;
    v36 -= 24;
  }
  while (v36 != v48);
  uint64_t v36 = *a1;
  *a1 = v54;
  a1[1] = v47;
  a1[2] = v55;
  if (v36) {
    goto LABEL_90;
  }
LABEL_91:
  a1[1] = v47;
  unint64_t v57 = (unint64_t)a1[2];
  if ((unint64_t)v47 < v57)
  {
    *(void *)unint64_t v47 = 0x71CBA64B1A9CA230;
    *((void *)v47 + 1) = "md::ls::IndexRange]";
    *((void *)v47 + 2) = 18;
    unint64_t v58 = v47 + 24;
    goto LABEL_109;
  }
  unint64_t v59 = *a1;
  unint64_t v60 = 0xAAAAAAAAAAAAAAABLL * ((v47 - *a1) >> 3);
  unint64_t v61 = v60 + 1;
  if (v60 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v57 - (void)v59) >> 3);
  if (2 * v62 > v61) {
    unint64_t v61 = 2 * v62;
  }
  if (v62 >= 0x555555555555555) {
    unint64_t v63 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v63 = v61;
  }
  if (v63)
  {
    if (v63 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v64 = (char *)operator new(24 * v63);
  }
  else
  {
    uint64_t v64 = 0;
  }
  unint64_t v65 = &v64[24 * v60];
  long long v66 = &v64[24 * v63];
  *(void *)unint64_t v65 = 0x71CBA64B1A9CA230;
  *((void *)v65 + 1) = "md::ls::IndexRange]";
  *((void *)v65 + 2) = 18;
  unint64_t v58 = v65 + 24;
  if (v47 == v59)
  {
    *a1 = v65;
    a1[1] = v58;
    a1[2] = v66;
LABEL_108:
    operator delete(v47);
    goto LABEL_109;
  }
  do
  {
    long long v67 = *(_OWORD *)(v47 - 24);
    *((void *)v65 - 1) = *((void *)v47 - 1);
    *(_OWORD *)(v65 - 24) = v67;
    v65 -= 24;
    v47 -= 24;
  }
  while (v47 != v59);
  unint64_t v47 = *a1;
  *a1 = v65;
  a1[1] = v58;
  a1[2] = v66;
  if (v47) {
    goto LABEL_108;
  }
LABEL_109:
  a1[1] = v58;
  unint64_t v68 = (unint64_t)a1[2];
  if ((unint64_t)v58 < v68)
  {
    *(void *)unint64_t v58 = 0x3218EFD67197A145;
    *((void *)v58 + 1) = "md::ls::NormalsHandle]";
    *((void *)v58 + 2) = 21;
    uint64_t v69 = v58 + 24;
    goto LABEL_127;
  }
  uint64_t v70 = *a1;
  unint64_t v71 = 0xAAAAAAAAAAAAAAABLL * ((v58 - *a1) >> 3);
  unint64_t v72 = v71 + 1;
  if (v71 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v73 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v68 - (void)v70) >> 3);
  if (2 * v73 > v72) {
    unint64_t v72 = 2 * v73;
  }
  if (v73 >= 0x555555555555555) {
    unint64_t v74 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v74 = v72;
  }
  if (v74)
  {
    if (v74 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v75 = (char *)operator new(24 * v74);
  }
  else
  {
    uint64_t v75 = 0;
  }
  unint64_t v76 = &v75[24 * v71];
  size_t v77 = &v75[24 * v74];
  *(void *)unint64_t v76 = 0x3218EFD67197A145;
  *((void *)v76 + 1) = "md::ls::NormalsHandle]";
  *((void *)v76 + 2) = 21;
  uint64_t v69 = v76 + 24;
  if (v58 == v70)
  {
    *a1 = v76;
    a1[1] = v69;
    a1[2] = v77;
LABEL_126:
    operator delete(v58);
    goto LABEL_127;
  }
  do
  {
    long long v78 = *(_OWORD *)(v58 - 24);
    *((void *)v76 - 1) = *((void *)v58 - 1);
    *(_OWORD *)(v76 - 24) = v78;
    v76 -= 24;
    v58 -= 24;
  }
  while (v58 != v70);
  unint64_t v58 = *a1;
  *a1 = v76;
  a1[1] = v69;
  a1[2] = v77;
  if (v58) {
    goto LABEL_126;
  }
LABEL_127:
  a1[1] = v69;
  unint64_t v79 = (unint64_t)a1[2];
  if ((unint64_t)v69 < v79)
  {
    *(void *)uint64_t v69 = 0xAF179EFD8A4C83D4;
    *((void *)v69 + 1) = "md::ls::InstanceTransformHandle]";
    *((void *)v69 + 2) = 31;
    int16x8_t v80 = v69 + 24;
    goto LABEL_145;
  }
  uint64_t v81 = *a1;
  unint64_t v82 = 0xAAAAAAAAAAAAAAABLL * ((v69 - *a1) >> 3);
  unint64_t v83 = v82 + 1;
  if (v82 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v84 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v79 - (void)v81) >> 3);
  if (2 * v84 > v83) {
    unint64_t v83 = 2 * v84;
  }
  if (v84 >= 0x555555555555555) {
    unint64_t v85 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v85 = v83;
  }
  if (v85)
  {
    if (v85 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v86 = (char *)operator new(24 * v85);
  }
  else
  {
    uint64_t v86 = 0;
  }
  int8x8_t v87 = &v86[24 * v82];
  uint64_t v88 = &v86[24 * v85];
  *(void *)int8x8_t v87 = 0xAF179EFD8A4C83D4;
  *((void *)v87 + 1) = "md::ls::InstanceTransformHandle]";
  *((void *)v87 + 2) = 31;
  int16x8_t v80 = v87 + 24;
  if (v69 == v81)
  {
    *a1 = v87;
    a1[1] = v80;
    a1[2] = v88;
LABEL_144:
    operator delete(v69);
    goto LABEL_145;
  }
  do
  {
    long long v89 = *(_OWORD *)(v69 - 24);
    *((void *)v87 - 1) = *((void *)v69 - 1);
    *(_OWORD *)(v87 - 24) = v89;
    v87 -= 24;
    v69 -= 24;
  }
  while (v69 != v81);
  uint64_t v69 = *a1;
  *a1 = v87;
  a1[1] = v80;
  a1[2] = v88;
  if (v69) {
    goto LABEL_144;
  }
LABEL_145:
  a1[1] = v80;
  unint64_t v90 = (unint64_t)a1[2];
  if ((unint64_t)v80 < v90)
  {
    *(void *)int16x8_t v80 = 0xCBB77B1CBD05D7C5;
    *((void *)v80 + 1) = "md::ls::UVsHandle]";
    *((void *)v80 + 2) = 17;
    BOOL v91 = v80 + 24;
    goto LABEL_163;
  }
  int8x16_t v92 = *a1;
  unint64_t v93 = 0xAAAAAAAAAAAAAAABLL * ((v80 - *a1) >> 3);
  unint64_t v94 = v93 + 1;
  if (v93 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v95 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v90 - (void)v92) >> 3);
  if (2 * v95 > v94) {
    unint64_t v94 = 2 * v95;
  }
  if (v95 >= 0x555555555555555) {
    unint64_t v96 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v96 = v94;
  }
  if (v96)
  {
    if (v96 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    int8x16_t v97 = (char *)operator new(24 * v96);
  }
  else
  {
    int8x16_t v97 = 0;
  }
  int16x8_t v98 = &v97[24 * v93];
  int32x4_t v99 = &v97[24 * v96];
  *(void *)int16x8_t v98 = 0xCBB77B1CBD05D7C5;
  *((void *)v98 + 1) = "md::ls::UVsHandle]";
  *((void *)v98 + 2) = 17;
  BOOL v91 = v98 + 24;
  if (v80 == v92)
  {
    *a1 = v98;
    a1[1] = v91;
    a1[2] = v99;
LABEL_162:
    operator delete(v80);
    goto LABEL_163;
  }
  do
  {
    long long v100 = *(_OWORD *)(v80 - 24);
    *((void *)v98 - 1) = *((void *)v80 - 1);
    *(_OWORD *)(v98 - 24) = v100;
    v98 -= 24;
    v80 -= 24;
  }
  while (v80 != v92);
  int16x8_t v80 = *a1;
  *a1 = v98;
  a1[1] = v91;
  a1[2] = v99;
  if (v80) {
    goto LABEL_162;
  }
LABEL_163:
  a1[1] = v91;
  unint64_t v101 = (unint64_t)a1[2];
  if ((unint64_t)v91 < v101)
  {
    *(void *)BOOL v91 = 0x499CE17DBD9A1615;
    *((void *)v91 + 1) = "md::ls::NeedsZBias]";
    *((void *)v91 + 2) = 18;
    uint64_t v102 = v91 + 24;
    goto LABEL_181;
  }
  int32x4_t v103 = *a1;
  unint64_t v104 = 0xAAAAAAAAAAAAAAABLL * ((v91 - *a1) >> 3);
  unint64_t v105 = v104 + 1;
  if (v104 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v106 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v101 - (void)v103) >> 3);
  if (2 * v106 > v105) {
    unint64_t v105 = 2 * v106;
  }
  if (v106 >= 0x555555555555555) {
    unint64_t v107 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v107 = v105;
  }
  if (v107)
  {
    if (v107 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v108 = (char *)operator new(24 * v107);
  }
  else
  {
    uint64_t v108 = 0;
  }
  int8x16_t v109 = &v108[24 * v104];
  unint64_t v110 = &v108[24 * v107];
  *(void *)int8x16_t v109 = 0x499CE17DBD9A1615;
  *((void *)v109 + 1) = "md::ls::NeedsZBias]";
  *((void *)v109 + 2) = 18;
  uint64_t v102 = v109 + 24;
  if (v91 == v103)
  {
    *a1 = v109;
    a1[1] = v102;
    a1[2] = v110;
LABEL_180:
    operator delete(v91);
    goto LABEL_181;
  }
  do
  {
    long long v111 = *(_OWORD *)(v91 - 24);
    *((void *)v109 - 1) = *((void *)v91 - 1);
    *(_OWORD *)(v109 - 24) = v111;
    v109 -= 24;
    v91 -= 24;
  }
  while (v91 != v103);
  BOOL v91 = *a1;
  *a1 = v109;
  a1[1] = v102;
  a1[2] = v110;
  if (v91) {
    goto LABEL_180;
  }
LABEL_181:
  a1[1] = v102;
  unint64_t v112 = (unint64_t)a1[2];
  if ((unint64_t)v102 < v112)
  {
    *(void *)uint64_t v102 = 0x9292F9031FE6DB5;
    *((void *)v102 + 1) = "md::ls::ClippingConstantDataHandle]";
    *((void *)v102 + 2) = 34;
    int8x16_t v113 = v102 + 24;
    goto LABEL_199;
  }
  int v114 = *a1;
  unint64_t v115 = 0xAAAAAAAAAAAAAAABLL * ((v102 - *a1) >> 3);
  unint64_t v116 = v115 + 1;
  if (v115 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v117 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v112 - (void)v114) >> 3);
  if (2 * v117 > v116) {
    unint64_t v116 = 2 * v117;
  }
  if (v117 >= 0x555555555555555) {
    unint64_t v118 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v118 = v116;
  }
  if (v118)
  {
    if (v118 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    int v119 = (char *)operator new(24 * v118);
  }
  else
  {
    int v119 = 0;
  }
  int32x4_t v120 = &v119[24 * v115];
  int8x16_t v121 = &v119[24 * v118];
  *(void *)int32x4_t v120 = 0x9292F9031FE6DB5;
  *((void *)v120 + 1) = "md::ls::ClippingConstantDataHandle]";
  *((void *)v120 + 2) = 34;
  int8x16_t v113 = v120 + 24;
  if (v102 == v114)
  {
    *a1 = v120;
    a1[1] = v113;
    a1[2] = v121;
LABEL_198:
    operator delete(v102);
    goto LABEL_199;
  }
  do
  {
    long long v122 = *(_OWORD *)(v102 - 24);
    *((void *)v120 - 1) = *((void *)v102 - 1);
    *(_OWORD *)(v120 - 24) = v122;
    v120 -= 24;
    v102 -= 24;
  }
  while (v102 != v114);
  uint64_t v102 = *a1;
  *a1 = v120;
  a1[1] = v113;
  a1[2] = v121;
  if (v102) {
    goto LABEL_198;
  }
LABEL_199:
  a1[1] = v113;
  unint64_t v123 = (unint64_t)a1[2];
  if ((unint64_t)v113 < v123)
  {
    *(void *)int8x16_t v113 = 0x237F9D3BCC905318;
    *((void *)v113 + 1) = "md::ls::IsMercator]";
    *((void *)v113 + 2) = 18;
    uint64_t v124 = v113 + 24;
    goto LABEL_217;
  }
  int8x16_t v125 = *a1;
  unint64_t v126 = 0xAAAAAAAAAAAAAAABLL * ((v113 - *a1) >> 3);
  unint64_t v127 = v126 + 1;
  if (v126 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v128 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v123 - (void)v125) >> 3);
  if (2 * v128 > v127) {
    unint64_t v127 = 2 * v128;
  }
  if (v128 >= 0x555555555555555) {
    unint64_t v129 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v129 = v127;
  }
  if (v129)
  {
    if (v129 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v130 = (char *)operator new(24 * v129);
  }
  else
  {
    uint64_t v130 = 0;
  }
  uint64_t v131 = &v130[24 * v126];
  float v132 = &v130[24 * v129];
  *(void *)uint64_t v131 = 0x237F9D3BCC905318;
  *((void *)v131 + 1) = "md::ls::IsMercator]";
  *((void *)v131 + 2) = 18;
  uint64_t v124 = v131 + 24;
  if (v113 == v125)
  {
    *a1 = v131;
    a1[1] = v124;
    a1[2] = v132;
LABEL_216:
    operator delete(v113);
    goto LABEL_217;
  }
  do
  {
    long long v133 = *(_OWORD *)(v113 - 24);
    *((void *)v131 - 1) = *((void *)v113 - 1);
    *(_OWORD *)(v131 - 24) = v133;
    v131 -= 24;
    v113 -= 24;
  }
  while (v113 != v125);
  int8x16_t v113 = *a1;
  *a1 = v131;
  a1[1] = v124;
  a1[2] = v132;
  if (v113) {
    goto LABEL_216;
  }
LABEL_217:
  a1[1] = v124;
  unint64_t v134 = (unint64_t)a1[2];
  if ((unint64_t)v124 < v134)
  {
    *(void *)uint64_t v124 = 0xD443D3DCBB78491ALL;
    *((void *)v124 + 1) = "md::ls::ElevationHandle]";
    *((void *)v124 + 2) = 23;
    unint64_t v135 = v124 + 24;
    goto LABEL_235;
  }
  long long v136 = *a1;
  unint64_t v137 = 0xAAAAAAAAAAAAAAABLL * ((v124 - *a1) >> 3);
  unint64_t v138 = v137 + 1;
  if (v137 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_236:
  }
    abort();
  unint64_t v139 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v134 - (void)v136) >> 3);
  if (2 * v139 > v138) {
    unint64_t v138 = 2 * v139;
  }
  if (v139 >= 0x555555555555555) {
    unint64_t v140 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v140 = v138;
  }
  if (v140)
  {
    if (v140 <= 0xAAAAAAAAAAAAAAALL)
    {
      float v141 = (char *)operator new(24 * v140);
      goto LABEL_229;
    }
LABEL_237:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  float v141 = 0;
LABEL_229:
  uint64_t v142 = &v141[24 * v137];
  uint64_t v143 = &v141[24 * v140];
  *(void *)uint64_t v142 = 0xD443D3DCBB78491ALL;
  *((void *)v142 + 1) = "md::ls::ElevationHandle]";
  *((void *)v142 + 2) = 23;
  unint64_t v135 = v142 + 24;
  if (v124 == v136)
  {
    *a1 = v142;
    a1[1] = v135;
    a1[2] = v143;
LABEL_234:
    operator delete(v124);
    goto LABEL_235;
  }
  do
  {
    long long v144 = *(_OWORD *)(v124 - 24);
    *((void *)v142 - 1) = *((void *)v124 - 1);
    *(_OWORD *)(v142 - 24) = v144;
    v142 -= 24;
    v124 -= 24;
  }
  while (v124 != v136);
  uint64_t v124 = *a1;
  *a1 = v142;
  a1[1] = v135;
  a1[2] = v143;
  if (v124) {
    goto LABEL_234;
  }
LABEL_235:
  a1[1] = v135;
}

void sub_1A1BC0654(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildSSAODOFCommonFrameGraph>(md::ita::BuildSSAODOFCommonFrameGraph &&)::{lambda(void)#1},std::allocator<md::ita::BuildSSAODOFCommonFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildSSAODOFCommonFrameGraph>(md::ita::BuildSSAODOFCommonFrameGraph &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x73C8822C1D168C4;
  v2[1] = "md::ls::PassSSAOConfiguration]";
  *(void *)&double result = 29;
  *((_OWORD *)v2 + 1) = xmmword_1A28FF8F0;
  v2[4] = "md::ls::PassMapEngineCapabilities]";
  v2[5] = 33;
  *a1 = v2;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileElevatedStrokeData>(md::ita::AssignTileElevatedStrokeData &&)::{lambda(void)#1},std::allocator<md::ita::AssignTileElevatedStrokeData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileElevatedStrokeData>(md::ita::AssignTileElevatedStrokeData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xB3E1F50BFD41E071;
  v2[1] = "md::ls::ElevatedStrokeConstantDataHandle]";
  *(void *)&double result = 40;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDA70;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>]";
  v2[5] = 90;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileElevatedStrokeData>(md::ita::AssignTileElevatedStrokeData &&)::{lambda(void)#2},std::allocator<md::ita::AssignTileElevatedStrokeData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileElevatedStrokeData>(md::ita::AssignTileElevatedStrokeData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC079C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleIndexTextureIndex>(md::ita::AssignStyleIndexTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleIndexTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleIndexTextureIndex>(md::ita::AssignStyleIndexTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xD5B48B62BD07EF80;
  v2[1] = "md::ls::HasMaterialRasterRenderItem]";
  *(void *)&double result = 35;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD950;
  v2[4] = "md::ls::RequiresShaderTextureID<DaVinci::StyleIndexTexture>]";
  v2[5] = 59;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleIndexTextureIndex>(md::ita::AssignStyleIndexTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleIndexTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleIndexTextureIndex>(md::ita::AssignStyleIndexTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC0870(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleBlendConstantData>(md::ita::AssignStyleBlendConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleBlendConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleBlendConstantData>(md::ita::AssignStyleBlendConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x24EEF26FD15B5B85;
  result[1] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>>]";
  result[2] = 86;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleBlendConstantData>(md::ita::AssignStyleBlendConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleBlendConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleBlendConstantData>(md::ita::AssignStyleBlendConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC0930(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#1},std::allocator<md::ita::UpdateResourcesAfterRebuild &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0xD853A1C6BA9D5FEDLL;
  v2[1] = "md::ls::SupportsRebuildingRenderables]";
  *(void *)&double result = 37;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDFE0;
  v2[4] = "md::ls::EnteringView]";
  v2[5] = 20;
  v2[6] = 0x24B7D588576BB14ELL;
  v2[7] = "md::ls::AssociationTileHandle]";
  v2[8] = 29;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#2},std::allocator<md::ita::UpdateResourcesAfterRebuild &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls18UniqueMaterialDataEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC0A28(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverTileViewMatrix>(md::ita::UpdateFlyoverTileViewMatrix &&)::{lambda(void)#1},std::allocator<md::ita::UpdateFlyoverTileViewMatrix &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverTileViewMatrix>(md::ita::UpdateFlyoverTileViewMatrix &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *(void *)&double result = 24;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDE50;
  v2[4] = "md::ls::GlobeMatrix]";
  v2[5] = 19;
  *a1 = v2;
  return result;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverTileViewMatrix>(md::ita::UpdateFlyoverTileViewMatrix &&)::{lambda(void)#2},std::allocator<md::ita::UpdateFlyoverTileViewMatrix &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverTileViewMatrix>(md::ita::UpdateFlyoverTileViewMatrix &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x8CADE1E37F052ADDLL;
  result[1] = "md::ls::TileViewMatrix]";
  result[2] = 22;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateDepthPrePassConstants>(md::ita::UpdateDepthPrePassConstants &&)::{lambda(void)#1},std::allocator<md::ita::UpdateDepthPrePassConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateDepthPrePassConstants>(md::ita::UpdateDepthPrePassConstants &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD80;
  v2[4] = "md::ls::SharedRenderableDataHandle]";
  v2[5] = 34;
  v2[6] = 0xA219A074B7259E0FLL;
  v2[7] = "md::ls::InView]";
  v2[8] = 14;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)uint64_t v3 = 0x412941A9C4AFE129;
    v2[10] = "md::ls::SharedTileMatrix]";
    v2[11] = 24;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x412941A9C4AFE129;
  *((void *)v10 + 1) = "md::ls::SharedTileMatrix]";
  *((void *)v10 + 2) = 24;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BC0CFC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateDepthPrePassConstants>(md::ita::UpdateDepthPrePassConstants &&)::{lambda(void)#2},std::allocator<md::ita::UpdateDepthPrePassConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateDepthPrePassConstants>(md::ita::UpdateDepthPrePassConstants &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x70E01531993BB945;
  v2[1] = "md::ls::PrepassShadowConstantDataHandle]";
  *(void *)&double result = 39;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD70;
  v2[4] = "md::ls::PrepassConstantDataHandle]";
  v2[5] = 33;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMeshRenderableBounds>(md::ita::PrepareMeshRenderableBounds &&)::{lambda(void)#1},std::allocator<md::ita::PrepareMeshRenderableBounds &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMeshRenderableBounds>(md::ita::PrepareMeshRenderableBounds &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0xA8uLL);
  a1[2] = (char *)(v2 + 21);
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDED0;
  v2[4] = "md::ls::GeocentricBounds]";
  v2[5] = 24;
  v2[6] = 0xD15AF44EFDE875A7;
  v2[7] = "md::ls::SliceAssignmentT<md::SliceType::AllByPrimitiveAndVisibility>]";
  v2[8] = 68;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 21)
  {
    *(void *)uint64_t v3 = 0x1DBDEAE2D8DF6302;
    v2[10] = "md::ls::MeshRenderableTransformConstantDataHandle]";
    v2[11] = 49;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_74;
  }
  if (0x5555555555555556 * (((char *)(v2 + 21) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 21) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 21) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_75;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x1DBDEAE2D8DF6302;
  *((void *)v10 + 1) = "md::ls::MeshRenderableTransformConstantDataHandle]";
  *((void *)v10 + 2) = 49;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x6B3ACE485940A135;
    *((void *)v4 + 1) = "md::ls::MeshRenderableBounds]";
    *((void *)v4 + 2) = 28;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_74;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_75;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x6B3ACE485940A135;
  *((void *)v21 + 1) = "md::ls::MeshRenderableBounds]";
  *((void *)v21 + 2) = 28;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0x2DE7529E814754ABLL;
    *((void *)v14 + 1) = "md::ls::BoundZScale]";
    *((void *)v14 + 2) = 19;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_74;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_75;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0x2DE7529E814754ABLL;
  *((void *)v32 + 1) = "md::ls::BoundZScale]";
  *((void *)v32 + 2) = 19;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0xA2CB76FD7F023F9CLL;
    *((void *)v25 + 1) = "md::ls::BoundZAdjust]";
    *((void *)v25 + 2) = 20;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_74:
  }
    abort();
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v42 = (char *)operator new(24 * v41);
      goto LABEL_67;
    }
LABEL_75:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v42 = 0;
LABEL_67:
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0xA2CB76FD7F023F9CLL;
  *((void *)v43 + 1) = "md::ls::BoundZAdjust]";
  *((void *)v43 + 2) = 20;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
}

void sub_1A1BC12E8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMeshRenderableBounds>(md::ita::PrepareMeshRenderableBounds &&)::{lambda(void)#2},std::allocator<md::ita::PrepareMeshRenderableBounds &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMeshRenderableBounds>(md::ita::PrepareMeshRenderableBounds &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x2523AFF0E364AA00;
  v2[1] = "md::BoundData]";
  *(void *)&double result = 13;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDEC0;
  v2[4] = "md::BoundData]";
  v2[5] = 13;
  *a1 = v2;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBoundsScaleAndAdjust>(md::ita::PrepareBoundsScaleAndAdjust &&)::{lambda(void)#1},std::allocator<md::ita::PrepareBoundsScaleAndAdjust &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBoundsScaleAndAdjust>(md::ita::PrepareBoundsScaleAndAdjust &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *(void *)&double result = 24;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDEF0;
  v2[4] = "md::ls::MeshRenderableTransformConstantDataHandle]";
  v2[5] = 49;
  *a1 = v2;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBoundsScaleAndAdjust>(md::ita::PrepareBoundsScaleAndAdjust &&)::{lambda(void)#2},std::allocator<md::ita::PrepareBoundsScaleAndAdjust &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBoundsScaleAndAdjust>(md::ita::PrepareBoundsScaleAndAdjust &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x2DE7529E814754ABLL;
  v2[1] = "md::ls::BoundZScale]";
  *(void *)&double result = 19;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDEE0;
  v2[4] = "md::ls::BoundZAdjust]";
  v2[5] = 20;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateShadowPassRenderItems>(md::ita::CreateShadowPassRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::CreateShadowPassRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateShadowPassRenderItems>(md::ita::CreateShadowPassRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x90uLL);
  a1[2] = (char *)(v2 + 18);
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDCE0;
  v2[4] = "md::ls::SliceAssignmentT<md::SliceType::CulledShadow>]";
  v2[5] = 53;
  v2[6] = 0xE8C803AC798645E1;
  v2[7] = "md::ls::RenderableMeshVertexFormat]";
  v2[8] = 34;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 18)
  {
    *(void *)uint64_t v3 = 0x751B872B282C3971;
    v2[10] = "md::ls::TileType]";
    v2[11] = 16;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_56;
  }
  if (0x5555555555555556 * (((char *)(v2 + 18) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 18) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 18) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_57;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x751B872B282C3971;
  *((void *)v10 + 1) = "md::ls::TileType]";
  *((void *)v10 + 2) = 16;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0xECC498AF223943D5;
    *((void *)v4 + 1) = "md::ls::MeshLayerTypeV]";
    *((void *)v4 + 2) = 22;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_56;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_57;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0xECC498AF223943D5;
  *((void *)v21 + 1) = "md::ls::MeshLayerTypeV]";
  *((void *)v21 + 2) = 22;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0xEC85A518158AB507;
    *((void *)v14 + 1) = "md::ls::PendingProcessingShadow]";
    *((void *)v14 + 2) = 31;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_56:
  }
    abort();
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v31 = (char *)operator new(24 * v30);
      goto LABEL_49;
    }
LABEL_57:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v31 = 0;
LABEL_49:
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0xEC85A518158AB507;
  *((void *)v32 + 1) = "md::ls::PendingProcessingShadow]";
  *((void *)v32 + 2) = 31;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
}

void sub_1A1BC1890(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateShadowPassRenderItems>(md::ita::CreateShadowPassRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::CreateShadowPassRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateShadowPassRenderItems>(md::ita::CreateShadowPassRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x180uLL);
  a1[2] = (char *)(v2 + 48);
  *unint64_t v2 = 0x523816724122CCE2;
  v2[1] = "md::ls::AssociationHandle]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDCB0;
  v2[4] = "md::ls::HasMeshHandle]";
  v2[5] = 21;
  v2[6] = 0x6C7EE74910D42096;
  v2[7] = "md::ls::PositionScaleInfoConstantDataHandle]";
  v2[8] = 43;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 48)
  {
    *(void *)uint64_t v3 = 0xCFE242268B958ADALL;
    v2[10] = "md::ls::ViewConstantDataHandle]";
    v2[11] = 30;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  if (0x5555555555555556 * (((char *)(v2 + 48) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 48) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 48) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xCFE242268B958ADALL;
  *((void *)v10 + 1) = "md::ls::ViewConstantDataHandle]";
  *((void *)v10 + 2) = 30;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x74DC502726E97929;
    *((void *)v4 + 1) = "md::ls::TransformConstantDataHandle]";
    *((void *)v4 + 2) = 35;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x74DC502726E97929;
  *((void *)v21 + 1) = "md::ls::TransformConstantDataHandle]";
  *((void *)v21 + 2) = 35;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0x71CBA64B1A9CA230;
    *((void *)v14 + 1) = "md::ls::IndexRange]";
    *((void *)v14 + 2) = 18;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0x71CBA64B1A9CA230;
  *((void *)v32 + 1) = "md::ls::IndexRange]";
  *((void *)v32 + 2) = 18;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0x3218EFD67197A145;
    *((void *)v25 + 1) = "md::ls::NormalsHandle]";
    *((void *)v25 + 2) = 21;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v42 = (char *)operator new(24 * v41);
  }
  else
  {
    uint64_t v42 = 0;
  }
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0x3218EFD67197A145;
  *((void *)v43 + 1) = "md::ls::NormalsHandle]";
  *((void *)v43 + 2) = 21;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
  unint64_t v46 = (unint64_t)a1[2];
  if ((unint64_t)v36 < v46)
  {
    *(void *)uint64_t v36 = 0xAF179EFD8A4C83D4;
    *((void *)v36 + 1) = "md::ls::InstanceTransformHandle]";
    *((void *)v36 + 2) = 31;
    unint64_t v47 = v36 + 24;
    goto LABEL_91;
  }
  uint64_t v48 = *a1;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v36 - *a1) >> 3);
  unint64_t v50 = v49 + 1;
  if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v48) >> 3);
  if (2 * v51 > v50) {
    unint64_t v50 = 2 * v51;
  }
  if (v51 >= 0x555555555555555) {
    unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v52 = v50;
  }
  if (v52)
  {
    if (v52 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v53 = (char *)operator new(24 * v52);
  }
  else
  {
    uint64_t v53 = 0;
  }
  uint64_t v54 = &v53[24 * v49];
  uint64_t v55 = &v53[24 * v52];
  *(void *)uint64_t v54 = 0xAF179EFD8A4C83D4;
  *((void *)v54 + 1) = "md::ls::InstanceTransformHandle]";
  *((void *)v54 + 2) = 31;
  unint64_t v47 = v54 + 24;
  if (v36 == v48)
  {
    *a1 = v54;
    a1[1] = v47;
    a1[2] = v55;
LABEL_90:
    operator delete(v36);
    goto LABEL_91;
  }
  do
  {
    long long v56 = *(_OWORD *)(v36 - 24);
    *((void *)v54 - 1) = *((void *)v36 - 1);
    *(_OWORD *)(v54 - 24) = v56;
    v54 -= 24;
    v36 -= 24;
  }
  while (v36 != v48);
  uint64_t v36 = *a1;
  *a1 = v54;
  a1[1] = v47;
  a1[2] = v55;
  if (v36) {
    goto LABEL_90;
  }
LABEL_91:
  a1[1] = v47;
  unint64_t v57 = (unint64_t)a1[2];
  if ((unint64_t)v47 < v57)
  {
    *(void *)unint64_t v47 = 0xCBB77B1CBD05D7C5;
    *((void *)v47 + 1) = "md::ls::UVsHandle]";
    *((void *)v47 + 2) = 17;
    unint64_t v58 = v47 + 24;
    goto LABEL_109;
  }
  unint64_t v59 = *a1;
  unint64_t v60 = 0xAAAAAAAAAAAAAAABLL * ((v47 - *a1) >> 3);
  unint64_t v61 = v60 + 1;
  if (v60 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v57 - (void)v59) >> 3);
  if (2 * v62 > v61) {
    unint64_t v61 = 2 * v62;
  }
  if (v62 >= 0x555555555555555) {
    unint64_t v63 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v63 = v61;
  }
  if (v63)
  {
    if (v63 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v64 = (char *)operator new(24 * v63);
  }
  else
  {
    uint64_t v64 = 0;
  }
  unint64_t v65 = &v64[24 * v60];
  long long v66 = &v64[24 * v63];
  *(void *)unint64_t v65 = 0xCBB77B1CBD05D7C5;
  *((void *)v65 + 1) = "md::ls::UVsHandle]";
  *((void *)v65 + 2) = 17;
  unint64_t v58 = v65 + 24;
  if (v47 == v59)
  {
    *a1 = v65;
    a1[1] = v58;
    a1[2] = v66;
LABEL_108:
    operator delete(v47);
    goto LABEL_109;
  }
  do
  {
    long long v67 = *(_OWORD *)(v47 - 24);
    *((void *)v65 - 1) = *((void *)v47 - 1);
    *(_OWORD *)(v65 - 24) = v67;
    v65 -= 24;
    v47 -= 24;
  }
  while (v47 != v59);
  unint64_t v47 = *a1;
  *a1 = v65;
  a1[1] = v58;
  a1[2] = v66;
  if (v47) {
    goto LABEL_108;
  }
LABEL_109:
  a1[1] = v58;
  unint64_t v68 = (unint64_t)a1[2];
  if ((unint64_t)v58 < v68)
  {
    *(void *)unint64_t v58 = 0x499CE17DBD9A1615;
    *((void *)v58 + 1) = "md::ls::NeedsZBias]";
    *((void *)v58 + 2) = 18;
    uint64_t v69 = v58 + 24;
    goto LABEL_127;
  }
  uint64_t v70 = *a1;
  unint64_t v71 = 0xAAAAAAAAAAAAAAABLL * ((v58 - *a1) >> 3);
  unint64_t v72 = v71 + 1;
  if (v71 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v73 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v68 - (void)v70) >> 3);
  if (2 * v73 > v72) {
    unint64_t v72 = 2 * v73;
  }
  if (v73 >= 0x555555555555555) {
    unint64_t v74 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v74 = v72;
  }
  if (v74)
  {
    if (v74 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v75 = (char *)operator new(24 * v74);
  }
  else
  {
    uint64_t v75 = 0;
  }
  unint64_t v76 = &v75[24 * v71];
  size_t v77 = &v75[24 * v74];
  *(void *)unint64_t v76 = 0x499CE17DBD9A1615;
  *((void *)v76 + 1) = "md::ls::NeedsZBias]";
  *((void *)v76 + 2) = 18;
  uint64_t v69 = v76 + 24;
  if (v58 == v70)
  {
    *a1 = v76;
    a1[1] = v69;
    a1[2] = v77;
LABEL_126:
    operator delete(v58);
    goto LABEL_127;
  }
  do
  {
    long long v78 = *(_OWORD *)(v58 - 24);
    *((void *)v76 - 1) = *((void *)v58 - 1);
    *(_OWORD *)(v76 - 24) = v78;
    v76 -= 24;
    v58 -= 24;
  }
  while (v58 != v70);
  unint64_t v58 = *a1;
  *a1 = v76;
  a1[1] = v69;
  a1[2] = v77;
  if (v58) {
    goto LABEL_126;
  }
LABEL_127:
  a1[1] = v69;
  unint64_t v79 = (unint64_t)a1[2];
  if ((unint64_t)v69 < v79)
  {
    *(void *)uint64_t v69 = 0xE53EF176130D7769;
    *((void *)v69 + 1) = "md::ls::InstanceCount]";
    *((void *)v69 + 2) = 21;
    int16x8_t v80 = v69 + 24;
    goto LABEL_145;
  }
  uint64_t v81 = *a1;
  unint64_t v82 = 0xAAAAAAAAAAAAAAABLL * ((v69 - *a1) >> 3);
  unint64_t v83 = v82 + 1;
  if (v82 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v84 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v79 - (void)v81) >> 3);
  if (2 * v84 > v83) {
    unint64_t v83 = 2 * v84;
  }
  if (v84 >= 0x555555555555555) {
    unint64_t v85 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v85 = v83;
  }
  if (v85)
  {
    if (v85 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v86 = (char *)operator new(24 * v85);
  }
  else
  {
    uint64_t v86 = 0;
  }
  int8x8_t v87 = &v86[24 * v82];
  uint64_t v88 = &v86[24 * v85];
  *(void *)int8x8_t v87 = 0xE53EF176130D7769;
  *((void *)v87 + 1) = "md::ls::InstanceCount]";
  *((void *)v87 + 2) = 21;
  int16x8_t v80 = v87 + 24;
  if (v69 == v81)
  {
    *a1 = v87;
    a1[1] = v80;
    a1[2] = v88;
LABEL_144:
    operator delete(v69);
    goto LABEL_145;
  }
  do
  {
    long long v89 = *(_OWORD *)(v69 - 24);
    *((void *)v87 - 1) = *((void *)v69 - 1);
    *(_OWORD *)(v87 - 24) = v89;
    v87 -= 24;
    v69 -= 24;
  }
  while (v69 != v81);
  uint64_t v69 = *a1;
  *a1 = v87;
  a1[1] = v80;
  a1[2] = v88;
  if (v69) {
    goto LABEL_144;
  }
LABEL_145:
  a1[1] = v80;
  unint64_t v90 = (unint64_t)a1[2];
  if ((unint64_t)v80 < v90)
  {
    *(void *)int16x8_t v80 = 0xD443D3DCBB78491ALL;
    *((void *)v80 + 1) = "md::ls::ElevationHandle]";
    *((void *)v80 + 2) = 23;
    BOOL v91 = v80 + 24;
    goto LABEL_163;
  }
  int8x16_t v92 = *a1;
  unint64_t v93 = 0xAAAAAAAAAAAAAAABLL * ((v80 - *a1) >> 3);
  unint64_t v94 = v93 + 1;
  if (v93 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v95 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v90 - (void)v92) >> 3);
  if (2 * v95 > v94) {
    unint64_t v94 = 2 * v95;
  }
  if (v95 >= 0x555555555555555) {
    unint64_t v96 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v96 = v94;
  }
  if (v96)
  {
    if (v96 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    int8x16_t v97 = (char *)operator new(24 * v96);
  }
  else
  {
    int8x16_t v97 = 0;
  }
  int16x8_t v98 = &v97[24 * v93];
  int32x4_t v99 = &v97[24 * v96];
  *(void *)int16x8_t v98 = 0xD443D3DCBB78491ALL;
  *((void *)v98 + 1) = "md::ls::ElevationHandle]";
  *((void *)v98 + 2) = 23;
  BOOL v91 = v98 + 24;
  if (v80 == v92)
  {
    *a1 = v98;
    a1[1] = v91;
    a1[2] = v99;
LABEL_162:
    operator delete(v80);
    goto LABEL_163;
  }
  do
  {
    long long v100 = *(_OWORD *)(v80 - 24);
    *((void *)v98 - 1) = *((void *)v80 - 1);
    *(_OWORD *)(v98 - 24) = v100;
    v98 -= 24;
    v80 -= 24;
  }
  while (v80 != v92);
  int16x8_t v80 = *a1;
  *a1 = v98;
  a1[1] = v91;
  a1[2] = v99;
  if (v80) {
    goto LABEL_162;
  }
LABEL_163:
  a1[1] = v91;
  unint64_t v101 = (unint64_t)a1[2];
  if ((unint64_t)v91 < v101)
  {
    *(void *)BOOL v91 = 0xEAA0B82FC49F7277;
    *((void *)v91 + 1) = "md::ls::ShadowConstantDataHandle]";
    *((void *)v91 + 2) = 32;
    uint64_t v102 = v91 + 24;
    goto LABEL_181;
  }
  int32x4_t v103 = *a1;
  unint64_t v104 = 0xAAAAAAAAAAAAAAABLL * ((v91 - *a1) >> 3);
  unint64_t v105 = v104 + 1;
  if (v104 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v106 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v101 - (void)v103) >> 3);
  if (2 * v106 > v105) {
    unint64_t v105 = 2 * v106;
  }
  if (v106 >= 0x555555555555555) {
    unint64_t v107 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v107 = v105;
  }
  if (v107)
  {
    if (v107 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v108 = (char *)operator new(24 * v107);
  }
  else
  {
    uint64_t v108 = 0;
  }
  int8x16_t v109 = &v108[24 * v104];
  unint64_t v110 = &v108[24 * v107];
  *(void *)int8x16_t v109 = 0xEAA0B82FC49F7277;
  *((void *)v109 + 1) = "md::ls::ShadowConstantDataHandle]";
  *((void *)v109 + 2) = 32;
  uint64_t v102 = v109 + 24;
  if (v91 == v103)
  {
    *a1 = v109;
    a1[1] = v102;
    a1[2] = v110;
LABEL_180:
    operator delete(v91);
    goto LABEL_181;
  }
  do
  {
    long long v111 = *(_OWORD *)(v91 - 24);
    *((void *)v109 - 1) = *((void *)v91 - 1);
    *(_OWORD *)(v109 - 24) = v111;
    v109 -= 24;
    v91 -= 24;
  }
  while (v91 != v103);
  BOOL v91 = *a1;
  *a1 = v109;
  a1[1] = v102;
  a1[2] = v110;
  if (v91) {
    goto LABEL_180;
  }
LABEL_181:
  a1[1] = v102;
  unint64_t v112 = (unint64_t)a1[2];
  if ((unint64_t)v102 < v112)
  {
    *(void *)uint64_t v102 = 0x237F9D3BCC905318;
    *((void *)v102 + 1) = "md::ls::IsMercator]";
    *((void *)v102 + 2) = 18;
    int8x16_t v113 = v102 + 24;
    goto LABEL_199;
  }
  int v114 = *a1;
  unint64_t v115 = 0xAAAAAAAAAAAAAAABLL * ((v102 - *a1) >> 3);
  unint64_t v116 = v115 + 1;
  if (v115 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v117 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v112 - (void)v114) >> 3);
  if (2 * v117 > v116) {
    unint64_t v116 = 2 * v117;
  }
  if (v117 >= 0x555555555555555) {
    unint64_t v118 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v118 = v116;
  }
  if (v118)
  {
    if (v118 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    int v119 = (char *)operator new(24 * v118);
  }
  else
  {
    int v119 = 0;
  }
  int32x4_t v120 = &v119[24 * v115];
  int8x16_t v121 = &v119[24 * v118];
  *(void *)int32x4_t v120 = 0x237F9D3BCC905318;
  *((void *)v120 + 1) = "md::ls::IsMercator]";
  *((void *)v120 + 2) = 18;
  int8x16_t v113 = v120 + 24;
  if (v102 == v114)
  {
    *a1 = v120;
    a1[1] = v113;
    a1[2] = v121;
LABEL_198:
    operator delete(v102);
    goto LABEL_199;
  }
  do
  {
    long long v122 = *(_OWORD *)(v102 - 24);
    *((void *)v120 - 1) = *((void *)v102 - 1);
    *(_OWORD *)(v120 - 24) = v122;
    v120 -= 24;
    v102 -= 24;
  }
  while (v102 != v114);
  uint64_t v102 = *a1;
  *a1 = v120;
  a1[1] = v113;
  a1[2] = v121;
  if (v102) {
    goto LABEL_198;
  }
LABEL_199:
  a1[1] = v113;
  unint64_t v123 = (unint64_t)a1[2];
  if ((unint64_t)v113 < v123)
  {
    *(void *)int8x16_t v113 = 0x98A9F01DBB8BCCCELL;
    *((void *)v113 + 1) = "md::ls::PreserveHeight]";
    *((void *)v113 + 2) = 22;
    uint64_t v124 = v113 + 24;
    goto LABEL_217;
  }
  int8x16_t v125 = *a1;
  unint64_t v126 = 0xAAAAAAAAAAAAAAABLL * ((v113 - *a1) >> 3);
  unint64_t v127 = v126 + 1;
  if (v126 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_236;
  }
  unint64_t v128 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v123 - (void)v125) >> 3);
  if (2 * v128 > v127) {
    unint64_t v127 = 2 * v128;
  }
  if (v128 >= 0x555555555555555) {
    unint64_t v129 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v129 = v127;
  }
  if (v129)
  {
    if (v129 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_237;
    }
    uint64_t v130 = (char *)operator new(24 * v129);
  }
  else
  {
    uint64_t v130 = 0;
  }
  uint64_t v131 = &v130[24 * v126];
  float v132 = &v130[24 * v129];
  *(void *)uint64_t v131 = 0x98A9F01DBB8BCCCELL;
  *((void *)v131 + 1) = "md::ls::PreserveHeight]";
  *((void *)v131 + 2) = 22;
  uint64_t v124 = v131 + 24;
  if (v113 == v125)
  {
    *a1 = v131;
    a1[1] = v124;
    a1[2] = v132;
LABEL_216:
    operator delete(v113);
    goto LABEL_217;
  }
  do
  {
    long long v133 = *(_OWORD *)(v113 - 24);
    *((void *)v131 - 1) = *((void *)v113 - 1);
    *(_OWORD *)(v131 - 24) = v133;
    v131 -= 24;
    v113 -= 24;
  }
  while (v113 != v125);
  int8x16_t v113 = *a1;
  *a1 = v131;
  a1[1] = v124;
  a1[2] = v132;
  if (v113) {
    goto LABEL_216;
  }
LABEL_217:
  a1[1] = v124;
  unint64_t v134 = (unint64_t)a1[2];
  if ((unint64_t)v124 < v134)
  {
    *(void *)uint64_t v124 = 0x7931433C9A6EB2C6;
    *((void *)v124 + 1) = "md::ls::SharedUniqueID]";
    *((void *)v124 + 2) = 22;
    unint64_t v135 = v124 + 24;
    goto LABEL_235;
  }
  long long v136 = *a1;
  unint64_t v137 = 0xAAAAAAAAAAAAAAABLL * ((v124 - *a1) >> 3);
  unint64_t v138 = v137 + 1;
  if (v137 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_236:
  }
    abort();
  unint64_t v139 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v134 - (void)v136) >> 3);
  if (2 * v139 > v138) {
    unint64_t v138 = 2 * v139;
  }
  if (v139 >= 0x555555555555555) {
    unint64_t v140 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v140 = v138;
  }
  if (v140)
  {
    if (v140 <= 0xAAAAAAAAAAAAAAALL)
    {
      float v141 = (char *)operator new(24 * v140);
      goto LABEL_229;
    }
LABEL_237:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  float v141 = 0;
LABEL_229:
  uint64_t v142 = &v141[24 * v137];
  uint64_t v143 = &v141[24 * v140];
  *(void *)uint64_t v142 = 0x7931433C9A6EB2C6;
  *((void *)v142 + 1) = "md::ls::SharedUniqueID]";
  *((void *)v142 + 2) = 22;
  unint64_t v135 = v142 + 24;
  if (v124 == v136)
  {
    *a1 = v142;
    a1[1] = v135;
    a1[2] = v143;
LABEL_234:
    operator delete(v124);
    goto LABEL_235;
  }
  do
  {
    long long v144 = *(_OWORD *)(v124 - 24);
    *((void *)v142 - 1) = *((void *)v124 - 1);
    *(_OWORD *)(v142 - 24) = v144;
    v142 -= 24;
    v124 -= 24;
  }
  while (v124 != v136);
  uint64_t v124 = *a1;
  *a1 = v142;
  a1[1] = v135;
  a1[2] = v143;
  if (v124) {
    goto LABEL_234;
  }
LABEL_235:
  a1[1] = v135;
}

void sub_1A1BC284C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSSAOConstantData>(md::ita::AssignStyleSSAOConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleSSAOConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSSAOConstantData>(md::ita::AssignStyleSSAOConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x3E8485C60908F920;
  v2[1] = "md::ls::IsMaterial]";
  *(void *)&double result = 18;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDA20;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>]";
  v2[5] = 85;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSSAOConstantData>(md::ita::AssignStyleSSAOConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleSSAOConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSSAOConstantData>(md::ita::AssignStyleSSAOConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC2920(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRouteMaskTextureIndex>(md::ita::AssignRouteMaskTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignRouteMaskTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRouteMaskTextureIndex>(md::ita::AssignRouteMaskTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x3B44468EF6722590;
  result[1] = "md::ls::RequiresShaderTextureID<DaVinci::RouteMaskTexture>]";
  result[2] = 58;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRouteMaskTextureIndex>(md::ita::AssignRouteMaskTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignRouteMaskTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRouteMaskTextureIndex>(md::ita::AssignRouteMaskTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC29E0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOcclusionTextureIndex>(md::ita::AssignOcclusionTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignOcclusionTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOcclusionTextureIndex>(md::ita::AssignOcclusionTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x561A1640388A2320;
  result[1] = "md::ls::RequiresShaderTextureID<DaVinci::OcclusionTexture>]";
  result[2] = 58;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOcclusionTextureIndex>(md::ita::AssignOcclusionTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignOcclusionTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOcclusionTextureIndex>(md::ita::AssignOcclusionTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC2AA0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient2TextureIndex>(md::ita::AssignGradient2TextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignGradient2TextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient2TextureIndex>(md::ita::AssignGradient2TextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xC55E4C6C5DFCA74ALL;
  v2[1] = "md::ls::TextureHandleForType<DaVinci::Gradient2Texture>]";
  *(void *)&double result = 55;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD900;
  v2[4] = "md::ls::RequiresShaderTextureID<DaVinci::Gradient2Texture>]";
  v2[5] = 58;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient2TextureIndex>(md::ita::AssignGradient2TextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignGradient2TextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient2TextureIndex>(md::ita::AssignGradient2TextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC2B74(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient1TextureIndex>(md::ita::AssignGradient1TextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignGradient1TextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient1TextureIndex>(md::ita::AssignGradient1TextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xCAA3A5E853432887;
  v2[1] = "md::ls::TextureHandleForType<DaVinci::Gradient1Texture>]";
  *(void *)&double result = 55;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD910;
  v2[4] = "md::ls::RequiresShaderTextureID<DaVinci::Gradient1Texture>]";
  v2[5] = 58;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient1TextureIndex>(md::ita::AssignGradient1TextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignGradient1TextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient1TextureIndex>(md::ita::AssignGradient1TextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC2C48(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignColorCorrectionFactor>(md::ita::AssignColorCorrectionFactor &&)::{lambda(void)#1},std::allocator<md::ita::AssignColorCorrectionFactor &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignColorCorrectionFactor>(md::ita::AssignColorCorrectionFactor &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x65937AC5D2157F71;
  v2[1] = "md::ls::ColorCorrectionFactorConstantHandle]";
  *(void *)&double result = 43;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDAD0;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>>]";
  v2[5] = 97;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignColorCorrectionFactor>(md::ita::AssignColorCorrectionFactor &&)::{lambda(void)#2},std::allocator<md::ita::AssignColorCorrectionFactor &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignColorCorrectionFactor>(md::ita::AssignColorCorrectionFactor &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC2D1C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForDecals>(md::ita::SetupRenderStatesForDecals &&)::{lambda(void)#1},std::allocator<md::ita::SetupRenderStatesForDecals &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForDecals>(md::ita::SetupRenderStatesForDecals &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x76B9BA390004E44ELL;
  v2[1] = "md::ls::IsDecal]";
  *(void *)&double result = 15;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDB70;
  v2[4] = "md::ls::RenderItemID]";
  v2[5] = 20;
  v2[6] = 0x1E85A99FD528C623;
  v2[7] = "md::ls::NeedsRenderState]";
  v2[8] = 24;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForDecals>(md::ita::SetupRenderStatesForDecals &&)::{lambda(void)#2},std::allocator<md::ita::SetupRenderStatesForDecals &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForDecals>(md::ita::SetupRenderStatesForDecals &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupPredefinedRenderState>(md::ita::SetupPredefinedRenderState &&)::{lambda(void)#1},std::allocator<md::ita::SetupPredefinedRenderState &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupPredefinedRenderState>(md::ita::SetupPredefinedRenderState &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0xCB8AA7FBA6BCD25CLL;
  v2[1] = "md::ls::PredefinedRenderState]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDB80;
  v2[4] = "md::ls::RenderItemID]";
  v2[5] = 20;
  v2[6] = 0x1E85A99FD528C623;
  v2[7] = "md::ls::NeedsRenderState]";
  v2[8] = 24;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)uint64_t v3 = 0x69465F3BE0BF85FBLL;
    v2[10] = "md::ls::FlyoverInstance]";
    v2[11] = 23;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x69465F3BE0BF85FBLL;
  *((void *)v10 + 1) = "md::ls::FlyoverInstance]";
  *((void *)v10 + 2) = 23;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BC2FC4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupPredefinedRenderState>(md::ita::SetupPredefinedRenderState &&)::{lambda(void)#2},std::allocator<md::ita::SetupPredefinedRenderState &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupPredefinedRenderState>(md::ita::SetupPredefinedRenderState &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSliceWithCulled>(md::ita::PrepareMainSliceWithCulled &&)::{lambda(void)#1},std::allocator<md::ita::PrepareMainSliceWithCulled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSliceWithCulled>(md::ita::PrepareMainSliceWithCulled &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDE80;
  v2[4] = "md::ls::VisibilityGroupID]";
  v2[5] = 25;
  v2[6] = 0x6CA90C12C415463ALL;
  v2[7] = "md::ls::WantsCulledSlices]";
  v2[8] = 25;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)uint64_t v3 = 0x731F9AB6193E8641;
    v2[10] = "md::ls::SliceAssignmentT<md::SliceType::CulledMain>]";
    v2[11] = 51;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x731F9AB6193E8641;
  *((void *)v10 + 1) = "md::ls::SliceAssignmentT<md::SliceType::CulledMain>]";
  *((void *)v10 + 2) = 51;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BC31D0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSliceWithCulled>(md::ita::PrepareMainSliceWithCulled &&)::{lambda(void)#2},std::allocator<md::ita::PrepareMainSliceWithCulled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSliceWithCulled>(md::ita::PrepareMainSliceWithCulled &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanUpFrameGraphResources>(md::ita::CleanUpFrameGraphResources &&)::{lambda(void)#1},std::allocator<md::ita::CleanUpFrameGraphResources &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanUpFrameGraphResources>(md::ita::CleanUpFrameGraphResources &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanUpFrameGraphResources>(md::ita::CleanUpFrameGraphResources &&)::{lambda(void)#2},std::allocator<md::ita::CleanUpFrameGraphResources &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanUpFrameGraphResources>(md::ita::CleanUpFrameGraphResources &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x9792F5BB2E6066F1;
  v2[1] = "md::ls::FrameGraphBuilder]";
  *(void *)&double result = 25;
  *((_OWORD *)v2 + 1) = xmmword_1A28FF8A0;
  v2[4] = "md::ls::FrameGraphRenderTarget]";
  v2[5] = 30;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfMaterialNeedsUpdate>(md::ita::CheckIfMaterialNeedsUpdate &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfMaterialNeedsUpdate &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfMaterialNeedsUpdate>(md::ita::CheckIfMaterialNeedsUpdate &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls18UniqueMaterialDataEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC32BC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfMaterialNeedsUpdate>(md::ita::CheckIfMaterialNeedsUpdate &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfMaterialNeedsUpdate &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfMaterialNeedsUpdate>(md::ita::CheckIfMaterialNeedsUpdate &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignEmissiveTextureIndex>(md::ita::AssignEmissiveTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignEmissiveTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignEmissiveTextureIndex>(md::ita::AssignEmissiveTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xCE03281732FA0019;
  v2[1] = "md::ls::TextureHandleForType<DaVinci::EmissiveTexture>]";
  *(void *)&double result = 54;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD970;
  v2[4] = "md::ls::RequiresShaderTextureID<DaVinci::EmissiveTexture>]";
  v2[5] = 57;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignEmissiveTextureIndex>(md::ita::AssignEmissiveTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignEmissiveTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignEmissiveTextureIndex>(md::ita::AssignEmissiveTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC339C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignElevationsDeviceData>(md::ita::AssignElevationsDeviceData &&)::{lambda(void)#1},std::allocator<md::ita::AssignElevationsDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignElevationsDeviceData>(md::ita::AssignElevationsDeviceData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xD443D3DCBB78491ALL;
  v2[1] = "md::ls::ElevationHandle]";
  *(void *)&double result = 23;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD8D0;
  v2[4] = "md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>>]";
  v2[5] = 82;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignElevationsDeviceData>(md::ita::AssignElevationsDeviceData &&)::{lambda(void)#2},std::allocator<md::ita::AssignElevationsDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignElevationsDeviceData>(md::ita::AssignElevationsDeviceData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC3470(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignClippingConstantData>(md::ita::AssignClippingConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignClippingConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignClippingConstantData>(md::ita::AssignClippingConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x9292F9031FE6DB5;
  v2[1] = "md::ls::ClippingConstantDataHandle]";
  *(void *)&double result = 34;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDA60;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::Clipping>>]";
  v2[5] = 81;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignClippingConstantData>(md::ita::AssignClippingConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignClippingConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignClippingConstantData>(md::ita::AssignClippingConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC3544(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessMaterialsForZIndex>(md::ita::ProcessMaterialsForZIndex &&)::{lambda(void)#1},std::allocator<md::ita::ProcessMaterialsForZIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessMaterialsForZIndex>(md::ita::ProcessMaterialsForZIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x3209EBE3B62CF3D3;
  v2[1] = "md::ls::UniqueMaterialData]";
  *(void *)&double result = 26;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDF30;
  v2[4] = "md::ls::DefaultZIndex]";
  v2[5] = 21;
  v2[6] = 0xE115FCB3272B65A3;
  v2[7] = "md::ls::ZIndex]";
  v2[8] = 14;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessMaterialsForZIndex>(md::ita::ProcessMaterialsForZIndex &&)::{lambda(void)#2},std::allocator<md::ita::ProcessMaterialsForZIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessMaterialsForZIndex>(md::ita::ProcessMaterialsForZIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DecidePipelineForMainPass>(md::ita::DecidePipelineForMainPass &&)::{lambda(void)#1},std::allocator<md::ita::DecidePipelineForMainPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DecidePipelineForMainPass>(md::ita::DecidePipelineForMainPass &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x90uLL);
  a1[2] = (char *)(v2 + 18);
  *unint64_t v2 = 0xDB4F0ABC43345F6ALL;
  v2[1] = "md::ls::MainPassItem]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDB40;
  v2[4] = "md::ls::IsDecal]";
  v2[5] = 15;
  v2[6] = 0xE1A4D8CDA8432F0;
  v2[7] = "md::ls::IsS2]";
  v2[8] = 12;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 18)
  {
    *(void *)uint64_t v3 = 0x237F9D3BCC905318;
    v2[10] = "md::ls::IsMercator]";
    v2[11] = 18;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_56;
  }
  if (0x5555555555555556 * (((char *)(v2 + 18) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 18) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 18) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_57;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x237F9D3BCC905318;
  *((void *)v10 + 1) = "md::ls::IsMercator]";
  *((void *)v10 + 2) = 18;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x69465F3BE0BF85FBLL;
    *((void *)v4 + 1) = "md::ls::FlyoverInstance]";
    *((void *)v4 + 2) = 23;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_56;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_57;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x69465F3BE0BF85FBLL;
  *((void *)v21 + 1) = "md::ls::FlyoverInstance]";
  *((void *)v21 + 2) = 23;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0xD49B968135FE1A73;
    *((void *)v14 + 1) = "md::ls::TextureHandleForType<Flyover::NightTexture>]";
    *((void *)v14 + 2) = 51;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_56:
  }
    abort();
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v31 = (char *)operator new(24 * v30);
      goto LABEL_49;
    }
LABEL_57:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v31 = 0;
LABEL_49:
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0xD49B968135FE1A73;
  *((void *)v32 + 1) = "md::ls::TextureHandleForType<Flyover::NightTexture>]";
  *((void *)v32 + 2) = 51;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
}

void sub_1A1BC3A3C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DecidePipelineForMainPass>(md::ita::DecidePipelineForMainPass &&)::{lambda(void)#2},std::allocator<md::ita::DecidePipelineForMainPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DecidePipelineForMainPass>(md::ita::DecidePipelineForMainPass &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls22RequiredPipelinePoolIDEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC3A9C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfRenderableIsUnique>(md::ita::CheckIfRenderableIsUnique &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfRenderableIsUnique &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfRenderableIsUnique>(md::ita::CheckIfRenderableIsUnique &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x4F0CC5B74BC3AC16;
  v2[1] = "md::ls::UniqueRenderArrayID]";
  *(void *)&double result = 27;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDC60;
  v2[4] = "md::ls::SharedUniqueID]";
  v2[5] = 22;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfRenderableIsUnique>(md::ita::CheckIfRenderableIsUnique &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfRenderableIsUnique &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfRenderableIsUnique>(md::ita::CheckIfRenderableIsUnique &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOverlayTextureIndex>(md::ita::AssignOverlayTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignOverlayTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOverlayTextureIndex>(md::ita::AssignOverlayTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xD2D99CA7D5B116C8;
  v2[1] = "md::ls::TextureHandleForType<DaVinci::OverlayTexture>]";
  *(void *)&double result = 53;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD960;
  v2[4] = "md::ls::RequiresShaderTextureID<DaVinci::OverlayTexture>]";
  v2[5] = 56;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOverlayTextureIndex>(md::ita::AssignOverlayTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignOverlayTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOverlayTextureIndex>(md::ita::AssignOverlayTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC3BF0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDiffuseTextureIndex>(md::ita::AssignDiffuseTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignDiffuseTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDiffuseTextureIndex>(md::ita::AssignDiffuseTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x3BD94B5787965DA7;
  v2[1] = "md::ls::RequiresShaderTextureID<DaVinci::DiffuseTexture>]";
  *(void *)&double result = 56;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD8F0;
  v2[4] = "md::ls::TextureHandleForType<DaVinci::DiffuseTexture>]";
  v2[5] = 53;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDiffuseTextureIndex>(md::ita::AssignDiffuseTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignDiffuseTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDiffuseTextureIndex>(md::ita::AssignDiffuseTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC3CC4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAridityTextureIndex>(md::ita::AssignAridityTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignAridityTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAridityTextureIndex>(md::ita::AssignAridityTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x985FB09D9DF9959FLL;
  v2[1] = "md::ls::HasStyleAttributeRasterSet]";
  *(void *)&double result = 34;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD930;
  v2[4] = "md::ls::RequiresShaderTextureID<DaVinci::AridityTexture>]";
  v2[5] = 56;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAridityTextureIndex>(md::ita::AssignAridityTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignAridityTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAridityTextureIndex>(md::ita::AssignAridityTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC3D98(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAmbientTextureIndex>(md::ita::AssignAmbientTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignAmbientTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAmbientTextureIndex>(md::ita::AssignAmbientTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xAEACE637C9751345;
  result[1] = "md::ls::RequiresShaderTextureID<DaVinci::AmbientTexture>]";
  result[2] = 56;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAmbientTextureIndex>(md::ita::AssignAmbientTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignAmbientTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAmbientTextureIndex>(md::ita::AssignAmbientTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC3E58(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleEmmisiveColor>(md::ita::UpdateStyleEmmisiveColor &&)::{lambda(void)#1},std::allocator<md::ita::UpdateStyleEmmisiveColor &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleEmmisiveColor>(md::ita::UpdateStyleEmmisiveColor &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x3209EBE3B62CF3D3;
  v2[1] = "md::ls::UniqueMaterialData]";
  *(void *)&double result = 26;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDF10;
  v2[4] = "md::ls::CanUpdateWithStyleZChange]";
  v2[5] = 33;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareRouteLineMaskPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareRouteLineMaskPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledShadowSlice>(md::ita::PrepareCulledShadowSlice &&)::{lambda(void)#1},std::allocator<md::ita::PrepareCulledShadowSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledShadowSlice>(md::ita::PrepareCulledShadowSlice &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0xC0uLL);
  a1[2] = (char *)(v2 + 24);
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDE70;
  v2[4] = "md::ls::SliceAssignmentT<md::SliceType::AllShadow>]";
  v2[5] = 50;
  v2[6] = 0x45B31C2960E9BCB1;
  v2[7] = "md::ls::VisibilityGroupID]";
  v2[8] = 25;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 24)
  {
    *(void *)uint64_t v3 = 0x5EBA003AC7A96B8ALL;
    v2[10] = "md::ls::SharedRenderableDataHandle]";
    v2[11] = 34;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  if (0x5555555555555556 * (((char *)(v2 + 24) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 24) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 24) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x5EBA003AC7A96B8ALL;
  *((void *)v10 + 1) = "md::ls::SharedRenderableDataHandle]";
  *((void *)v10 + 2) = 34;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0xA054AACDFDD6A6BLL;
    *((void *)v4 + 1) = "md::ls::AppliedWantsDynamicShadowBounds]";
    *((void *)v4 + 2) = 39;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0xA054AACDFDD6A6BLL;
  *((void *)v21 + 1) = "md::ls::AppliedWantsDynamicShadowBounds]";
  *((void *)v21 + 2) = 39;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0x2523AFF0E364AA00;
    *((void *)v14 + 1) = "md::BoundData]";
    *((void *)v14 + 2) = 13;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0x2523AFF0E364AA00;
  *((void *)v32 + 1) = "md::BoundData]";
  *((void *)v32 + 2) = 13;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0x2DE7529E814754ABLL;
    *((void *)v25 + 1) = "md::ls::BoundZScale]";
    *((void *)v25 + 2) = 19;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    uint64_t v42 = (char *)operator new(24 * v41);
  }
  else
  {
    uint64_t v42 = 0;
  }
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0x2DE7529E814754ABLL;
  *((void *)v43 + 1) = "md::ls::BoundZScale]";
  *((void *)v43 + 2) = 19;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
  unint64_t v46 = (unint64_t)a1[2];
  if ((unint64_t)v36 < v46)
  {
    *(void *)uint64_t v36 = 0xA2CB76FD7F023F9CLL;
    *((void *)v36 + 1) = "md::ls::BoundZAdjust]";
    *((void *)v36 + 2) = 20;
    unint64_t v47 = v36 + 24;
    goto LABEL_91;
  }
  uint64_t v48 = *a1;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v36 - *a1) >> 3);
  unint64_t v50 = v49 + 1;
  if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_92:
  }
    abort();
  unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v48) >> 3);
  if (2 * v51 > v50) {
    unint64_t v50 = 2 * v51;
  }
  if (v51 >= 0x555555555555555) {
    unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v52 = v50;
  }
  if (v52)
  {
    if (v52 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v53 = (char *)operator new(24 * v52);
      goto LABEL_85;
    }
LABEL_93:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v53 = 0;
LABEL_85:
  uint64_t v54 = &v53[24 * v49];
  uint64_t v55 = &v53[24 * v52];
  *(void *)uint64_t v54 = 0xA2CB76FD7F023F9CLL;
  *((void *)v54 + 1) = "md::ls::BoundZAdjust]";
  *((void *)v54 + 2) = 20;
  unint64_t v47 = v54 + 24;
  if (v36 == v48)
  {
    *a1 = v54;
    a1[1] = v47;
    a1[2] = v55;
LABEL_90:
    operator delete(v36);
    goto LABEL_91;
  }
  do
  {
    long long v56 = *(_OWORD *)(v36 - 24);
    *((void *)v54 - 1) = *((void *)v36 - 1);
    *(_OWORD *)(v54 - 24) = v56;
    v54 -= 24;
    v36 -= 24;
  }
  while (v36 != v48);
  uint64_t v36 = *a1;
  *a1 = v54;
  a1[1] = v47;
  a1[2] = v55;
  if (v36) {
    goto LABEL_90;
  }
LABEL_91:
  a1[1] = v47;
}

void sub_1A1BC4580(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledShadowSlice>(md::ita::PrepareCulledShadowSlice &&)::{lambda(void)#2},std::allocator<md::ita::PrepareCulledShadowSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledShadowSlice>(md::ita::PrepareCulledShadowSlice &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::EndFrameGraphPreparation>(md::ita::EndFrameGraphPreparation &&)::{lambda(void)#1},std::allocator<md::ita::EndFrameGraphPreparation &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::EndFrameGraphPreparation>(md::ita::EndFrameGraphPreparation &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xE0E0BD7780EC271BLL;
  v2[1] = "md::ls::PreviousResourceStamp]";
  *(void *)&double result = 29;
  *((_OWORD *)v2 + 1) = xmmword_1A28FF8B0;
  v2[4] = "md::ls::PassCount]";
  v2[5] = 17;
  *a1 = v2;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildRouteLineFrameGraph>(md::ita::BuildRouteLineFrameGraph &&)::{lambda(void)#1},std::allocator<md::ita::BuildRouteLineFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildRouteLineFrameGraph>(md::ita::BuildRouteLineFrameGraph &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0xD7B05696AE714D71;
  v2[1] = "md::ls::FrameBufferDesc]";
  *(void *)&double result = 23;
  *((_OWORD *)v2 + 1) = xmmword_1A28FF8C0;
  v2[4] = "md::ls::PassRoutelineMaskConfiguration]";
  v2[5] = 38;
  v2[6] = 0x6738F9098C50E08CLL;
  v2[7] = "md::ls::PassDeviceCapabilities]";
  v2[8] = 30;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildRouteLineFrameGraph>(md::ita::BuildRouteLineFrameGraph &&)::{lambda(void)#2},std::allocator<md::ita::BuildRouteLineFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildRouteLineFrameGraph>(md::ita::BuildRouteLineFrameGraph &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 48;
  uint64_t v3 = (char **)a1;
  _ZZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FrameGraphBuilderENS4_9PassCountEEEEZNS_18typelist_as_vectorIS7_EENS1_6vectorINS_8TypeInfoENS1_9allocatorISA_EEEEvEUlTyvE_EEvOT0_ENKUlTpTnmNS1_16integer_sequenceImJXspT_EEEEE_clIJLm0ELm1EEEEDaSI_(&v3);
}

void sub_1A1BC4704(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSunMatrixData>(md::ita::AssignStyleSunMatrixData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleSunMatrixData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSunMatrixData>(md::ita::AssignStyleSunMatrixData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x7EE4E2CB5D22239;
  result[1] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>>]";
  result[2] = 90;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSunMatrixData>(md::ita::AssignStyleSunMatrixData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleSunMatrixData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSunMatrixData>(md::ita::AssignStyleSunMatrixData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC47C4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignShadowTextureIndex>(md::ita::AssignShadowTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignShadowTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignShadowTextureIndex>(md::ita::AssignShadowTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x4B2419C7BBAFEE01;
  result[1] = "md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture>]";
  result[2] = 55;
  *a1 = result;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignShadowConstantData>(md::ita::AssignShadowConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignShadowConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignShadowConstantData>(md::ita::AssignShadowConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xEAA0B82FC49F7277;
  v2[1] = "md::ls::ShadowConstantDataHandle]";
  *(void *)&double result = 32;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDA10;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>]";
  v2[5] = 82;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignShadowConstantData>(md::ita::AssignShadowConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignShadowConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignShadowConstantData>(md::ita::AssignShadowConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC48F8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignSRGBBlendStyleData>(md::ita::AssignSRGBBlendStyleData &&)::{lambda(void)#1},std::allocator<md::ita::AssignSRGBBlendStyleData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignSRGBBlendStyleData>(md::ita::AssignSRGBBlendStyleData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xDF0018B9242ADFDBLL;
  v2[1] = "md::ls::BlendRasterConstantDataHandle]";
  *(void *)&double result = 37;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDA80;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>>]";
  v2[5] = 91;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignSRGBBlendStyleData>(md::ita::AssignSRGBBlendStyleData &&)::{lambda(void)#2},std::allocator<md::ita::AssignSRGBBlendStyleData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignSRGBBlendStyleData>(md::ita::AssignSRGBBlendStyleData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC49CC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#1},std::allocator<md::ita::UpdateClippingConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0xBCC33905201D8160;
  v2[1] = "md::ls::TileMatrix]";
  *(void *)&double result = 18;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDF70;
  v2[4] = "md::ls::LayerDataReference]";
  v2[5] = 26;
  v2[6] = 0x14C796C7576DD197;
  v2[7] = "md::ls::SupportsFragmentClip]";
  v2[8] = 28;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#2},std::allocator<md::ita::UpdateClippingConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xE57C2F66048E40BDLL;
  v2[1] = "md::ls::RequireTypedRenderableForLegacyReasons<md::DaVinciGroundRenderable>]";
  *(void *)&double result = 75;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDF60;
  v2[4] = "md::ls::TileClippingConstantDataHandle]";
  v2[5] = 38;
  *a1 = v2;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupDefaultRenderState>(md::ita::SetupDefaultRenderState &&)::{lambda(void)#1},std::allocator<md::ita::SetupDefaultRenderState &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupDefaultRenderState>(md::ita::SetupDefaultRenderState &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x1E85A99FD528C623;
  v2[1] = "md::ls::NeedsRenderState]";
  *(void *)&double result = 24;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDBC0;
  v2[4] = "md::ls::IsTransparent]";
  v2[5] = 21;
  v2[6] = 0xD68EA0DE832DEC03;
  v2[7] = "md::ls::RenderItemID]";
  v2[8] = 20;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupDefaultRenderState>(md::ita::SetupDefaultRenderState &&)::{lambda(void)#2},std::allocator<md::ita::SetupDefaultRenderState &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupDefaultRenderState>(md::ita::SetupDefaultRenderState &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ReserveStencilRangeTask>(md::ita::ReserveStencilRangeTask &&)::{lambda(void)#1},std::allocator<md::ita::ReserveStencilRangeTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ReserveStencilRangeTask>(md::ita::ReserveStencilRangeTask &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ReserveStencilRangeTask>(md::ita::ReserveStencilRangeTask &&)::{lambda(void)#2},std::allocator<md::ita::ReserveStencilRangeTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ReserveStencilRangeTask>(md::ita::ReserveStencilRangeTask &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanupRampMaterialData>(md::ita::CleanupRampMaterialData &&)::{lambda(void)#1},std::allocator<md::ita::CleanupRampMaterialData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanupRampMaterialData>(md::ita::CleanupRampMaterialData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanupRampMaterialData>(md::ita::CleanupRampMaterialData &&)::{lambda(void)#2},std::allocator<md::ita::CleanupRampMaterialData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanupRampMaterialData>(md::ita::CleanupRampMaterialData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTextureIndex>(md::ita::AssignStyleTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTextureIndex>(md::ita::AssignStyleTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xD5B48B62BD07EF80;
  v2[1] = "md::ls::HasMaterialRasterRenderItem]";
  *(void *)&double result = 35;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD940;
  v2[4] = "md::ls::RequiresShaderTextureID<DaVinci::StyleTexture>]";
  v2[5] = 54;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTextureIndex>(md::ita::AssignStyleTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTextureIndex>(md::ita::AssignStyleTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC4C80(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleConstantData>(md::ita::AssignStyleConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleConstantData>(md::ita::AssignStyleConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x9C1597C84433D2CALL;
  v2[1] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::Style>>]";
  *(void *)&double result = 81;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDAE0;
  v2[4] = "md::ls::StyleDataKeyHandle]";
  v2[5] = 26;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleConstantData>(md::ita::AssignStyleConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleConstantData>(md::ita::AssignStyleConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC4D54(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRasterOverlayData>(md::ita::AssignRasterOverlayData &&)::{lambda(void)#1},std::allocator<md::ita::AssignRasterOverlayData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRasterOverlayData>(md::ita::AssignRasterOverlayData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xDC66BF6D06F6D0BALL;
  v2[1] = "md::ls::RasterOverlayConstantDataHandle]";
  *(void *)&double result = 39;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDA90;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>]";
  v2[5] = 89;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRasterOverlayData>(md::ita::AssignRasterOverlayData &&)::{lambda(void)#2},std::allocator<md::ita::AssignRasterOverlayData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRasterOverlayData>(md::ita::AssignRasterOverlayData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC4E28(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignPositionScaleInfo>(md::ita::AssignPositionScaleInfo &&)::{lambda(void)#1},std::allocator<md::ita::AssignPositionScaleInfo &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignPositionScaleInfo>(md::ita::AssignPositionScaleInfo &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x6C7EE74910D42096;
  v2[1] = "md::ls::PositionScaleInfoConstantDataHandle]";
  *(void *)&double result = 43;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDAC0;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>]";
  v2[5] = 90;
  *a1 = v2;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignNormalsDeviceData>(md::ita::AssignNormalsDeviceData &&)::{lambda(void)#1},std::allocator<md::ita::AssignNormalsDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignNormalsDeviceData>(md::ita::AssignNormalsDeviceData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x3218EFD67197A145;
  v2[1] = "md::ls::NormalsHandle]";
  *(void *)&double result = 21;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD8C0;
  v2[4] = "md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>]";
  v2[5] = 79;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignNormalsDeviceData>(md::ita::AssignNormalsDeviceData &&)::{lambda(void)#2},std::allocator<md::ita::AssignNormalsDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignNormalsDeviceData>(md::ita::AssignNormalsDeviceData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC4F70(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyUsesIdentityMatrix>(md::ita::ApplyUsesIdentityMatrix &&)::{lambda(void)#1},std::allocator<md::ita::ApplyUsesIdentityMatrix &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyUsesIdentityMatrix>(md::ita::ApplyUsesIdentityMatrix &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDDF0;
  v2[4] = "md::ls::MeshLayerTypeV]";
  v2[5] = 22;
  v2[6] = 0xCC16A20B07DB93CCLL;
  v2[7] = "md::ls::InstanceDataV]";
  v2[8] = 21;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)uint64_t v3 = 0xA219A074B7259E0FLL;
    v2[10] = "md::ls::InView]";
    v2[11] = 14;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xA219A074B7259E0FLL;
  *((void *)v10 + 1) = "md::ls::InView]";
  *((void *)v10 + 2) = 14;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BC5174(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyUsesIdentityMatrix>(md::ita::ApplyUsesIdentityMatrix &&)::{lambda(void)#2},std::allocator<md::ita::ApplyUsesIdentityMatrix &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyUsesIdentityMatrix>(md::ita::ApplyUsesIdentityMatrix &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#1},std::allocator<md::ita::UpdateCameraStyleLight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls10TileMatrixEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC51E0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#2},std::allocator<md::ita::UpdateCameraStyleLight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x80A8239313E99C5FLL;
  result[1] = "md::ls::TileStyleCameraConstantDataHandle]";
  result[2] = 41;
  *a1 = result;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderState>(md::ita::SetupCustomRenderState &&)::{lambda(void)#1},std::allocator<md::ita::SetupCustomRenderState &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderState>(md::ita::SetupCustomRenderState &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0xA0C97F52893883B7;
  v2[1] = "md::ls::CustomRenderState]";
  *(void *)&double result = 25;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDBB0;
  v2[4] = "md::ls::IntendedSceneLayerType<md::SceneLayer::AboveRoute>]";
  v2[5] = 58;
  v2[6] = 0x1E85A99FD528C623;
  v2[7] = "md::ls::NeedsRenderState]";
  v2[8] = 24;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderState>(md::ita::SetupCustomRenderState &&)::{lambda(void)#2},std::allocator<md::ita::SetupCustomRenderState &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderState>(md::ita::SetupCustomRenderState &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResetFunctionConstants>(md::ita::ResetFunctionConstants &&)::{lambda(void)#1},std::allocator<md::ita::ResetFunctionConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResetFunctionConstants>(md::ita::ResetFunctionConstants &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBuildFrameGraph>(md::ita::PrepareBuildFrameGraph &&)::{lambda(void)#1},std::allocator<md::ita::PrepareBuildFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBuildFrameGraph>(md::ita::PrepareBuildFrameGraph &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md3ita11FrameHandleEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC5350(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBuildFrameGraph>(md::ita::PrepareBuildFrameGraph &&)::{lambda(void)#2},std::allocator<md::ita::PrepareBuildFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBuildFrameGraph>(md::ita::PrepareBuildFrameGraph &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DetermineDataIDsNeeded>(md::ita::DetermineDataIDsNeeded &&)::{lambda(void)#2},std::allocator<md::ita::DetermineDataIDsNeeded &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DetermineDataIDsNeeded>(md::ita::DetermineDataIDsNeeded &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildPrimaryFrameGraph>(md::ita::BuildPrimaryFrameGraph &&)::{lambda(void)#1},std::allocator<md::ita::BuildPrimaryFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildPrimaryFrameGraph>(md::ita::BuildPrimaryFrameGraph &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x78uLL);
  a1[2] = (char *)(v2 + 15);
  *unint64_t v2 = 0x2CF7C0CBD63AB273;
  v2[1] = "md::ls::FrameGraphRenderTarget]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FF8D0;
  v2[4] = "md::ls::PassDeviceCapabilities]";
  v2[5] = 30;
  v2[6] = 0x937D85B25618F8B3;
  v2[7] = "md::ls::PassSSAODescriptor]";
  v2[8] = 26;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 15)
  {
    *(void *)uint64_t v3 = 0x73F7A94D4E0637DDLL;
    v2[10] = "md::ls::PassShadowDescriptor]";
    v2[11] = 28;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_38;
  }
  if (0x5555555555555556 * (((char *)(v2 + 15) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 15) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 15) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_39;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x73F7A94D4E0637DDLL;
  *((void *)v10 + 1) = "md::ls::PassShadowDescriptor]";
  *((void *)v10 + 2) = 28;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x6D136A48B3800686;
    *((void *)v4 + 1) = "md::ls::PassRouteLineDescriptor]";
    *((void *)v4 + 2) = 31;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_38:
  }
    abort();
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v20 = (char *)operator new(24 * v19);
      goto LABEL_31;
    }
LABEL_39:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v20 = 0;
LABEL_31:
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x6D136A48B3800686;
  *((void *)v21 + 1) = "md::ls::PassRouteLineDescriptor]";
  *((void *)v21 + 2) = 31;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
}

void sub_1A1BC56A0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildPrimaryFrameGraph>(md::ita::BuildPrimaryFrameGraph &&)::{lambda(void)#2},std::allocator<md::ita::BuildPrimaryFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildPrimaryFrameGraph>(md::ita::BuildPrimaryFrameGraph &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 48;
  uint64_t v3 = (char **)a1;
  _ZZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FrameGraphBuilderENS4_9PassCountEEEEZNS_18typelist_as_vectorIS7_EENS1_6vectorINS_8TypeInfoENS1_9allocatorISA_EEEEvEUlTyvE_EEvOT0_ENKUlTpTnmNS1_16integer_sequenceImJXspT_EEEEE_clIJLm0ELm1EEEEDaSI_(&v3);
}

void sub_1A1BC570C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyPositionScaleInfo>(md::ita::ApplyPositionScaleInfo &&)::{lambda(void)#1},std::allocator<md::ita::ApplyPositionScaleInfo &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyPositionScaleInfo>(md::ita::ApplyPositionScaleInfo &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *(void *)&double result = 24;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDDD0;
  v2[4] = "md::ls::RenderablePendingProcessing]";
  v2[5] = 35;
  v2[6] = 0xEE00EAF3B9AFA033;
  v2[7] = "md::ls::MeshRenderablePositionScaleInfo]";
  v2[8] = 39;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyPositionScaleInfo>(md::ita::ApplyPositionScaleInfo &&)::{lambda(void)#2},std::allocator<md::ita::ApplyPositionScaleInfo &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyPositionScaleInfo>(md::ita::ApplyPositionScaleInfo &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#1},std::allocator<md::ita::UpdateTileRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xCF1A54FDD9A1F93FLL;
  v2[1] = "md::ls::TileRenderableDataHandle]";
  *(void *)&double result = 32;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDFA0;
  v2[4] = "md::ls::BoundsWidth]";
  v2[5] = 19;
  *a1 = v2;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#2},std::allocator<md::ita::UpdateTileRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xBBBF2D3465784E7ELL;
  v2[1] = "md::ls::NeedsUpdate<ggl::Tile::View>]";
  *(void *)&double result = 36;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDF90;
  v2[4] = "md::ls::TileViewConstantDataHandle]";
  v2[5] = 34;
  *a1 = v2;
  return result;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateShadowConstants>(md::ita::UpdateShadowConstants &&)::{lambda(void)#2},std::allocator<md::ita::UpdateShadowConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateShadowConstants>(md::ita::UpdateShadowConstants &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xF2296D6406C155CBLL;
  result[1] = "md::ls::TileShadowConstantDataHandle]";
  result[2] = 36;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatus>(md::ita::UpdateProcessedStatus &&)::{lambda(void)#1},std::allocator<md::ita::UpdateProcessedStatus &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatus>(md::ita::UpdateProcessedStatus &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatus>(md::ita::UpdateProcessedStatus &&)::{lambda(void)#2},std::allocator<md::ita::UpdateProcessedStatus &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatus>(md::ita::UpdateProcessedStatus &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRenderableData>(md::ita::PrepareRenderableData &&)::{lambda(void)#2},std::allocator<md::ita::PrepareRenderableData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRenderableData>(md::ita::PrepareRenderableData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xF37331D7CF44CB11;
  v2[1] = "md::ls::NeedsTileRenderableDataHandleUpdate]";
  *(void *)&double result = 43;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDFB0;
  v2[4] = "md::ls::TileRenderableDataHandle]";
  v2[5] = 32;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#1},std::allocator<md::ita::PrepareCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls32CommandBufferDescriptionCreationEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC59E4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#2},std::allocator<md::ita::PrepareCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutStartTask>(md::ita::LegacyLayoutStartTask &&)::{lambda(void)#1},std::allocator<md::ita::LegacyLayoutStartTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutStartTask>(md::ita::LegacyLayoutStartTask &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutStartTask>(md::ita::LegacyLayoutStartTask &&)::{lambda(void)#2},std::allocator<md::ita::LegacyLayoutStartTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutStartTask>(md::ita::LegacyLayoutStartTask &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#1},std::allocator<md::ita::DeletePendingDeletion &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x34ACED59D994E35ELL;
  result[1] = "md::ls::PendingDeletion]";
  result[2] = 23;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#2},std::allocator<md::ita::DeletePendingDeletion &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateMainRenderItems>(md::ita::CreateMainRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::CreateMainRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateMainRenderItems>(md::ita::CreateMainRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0xC0uLL);
  a1[2] = (char *)(v2 + 24);
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDCF0;
  v2[4] = "md::ls::SliceAssignmentT<md::SliceType::Main>]";
  v2[5] = 45;
  v2[6] = 0xE8C803AC798645E1;
  v2[7] = "md::ls::RenderableMeshVertexFormat]";
  v2[8] = 34;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 24)
  {
    *(void *)uint64_t v3 = 0x751B872B282C3971;
    v2[10] = "md::ls::TileType]";
    v2[11] = 16;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  if (0x5555555555555556 * (((char *)(v2 + 24) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 24) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 24) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x751B872B282C3971;
  *((void *)v10 + 1) = "md::ls::TileType]";
  *((void *)v10 + 2) = 16;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x75DBD6381F1903FFLL;
    *((void *)v4 + 1) = "md::ls::PendingProcessing]";
    *((void *)v4 + 2) = 25;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x75DBD6381F1903FFLL;
  *((void *)v21 + 1) = "md::ls::PendingProcessing]";
  *((void *)v21 + 2) = 25;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0xECC498AF223943D5;
    *((void *)v14 + 1) = "md::ls::MeshLayerTypeV]";
    *((void *)v14 + 2) = 22;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0xECC498AF223943D5;
  *((void *)v32 + 1) = "md::ls::MeshLayerTypeV]";
  *((void *)v32 + 2) = 22;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0xEC2A00DC914732D7;
    *((void *)v25 + 1) = "md::ls::IntendedSceneLayer]";
    *((void *)v25 + 2) = 26;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    uint64_t v42 = (char *)operator new(24 * v41);
  }
  else
  {
    uint64_t v42 = 0;
  }
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0xEC2A00DC914732D7;
  *((void *)v43 + 1) = "md::ls::IntendedSceneLayer]";
  *((void *)v43 + 2) = 26;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
  unint64_t v46 = (unint64_t)a1[2];
  if ((unint64_t)v36 < v46)
  {
    *(void *)uint64_t v36 = 0x9D7520A01DC69D83;
    *((void *)v36 + 1) = "md::ls::HasMaterialRaster]";
    *((void *)v36 + 2) = 25;
    unint64_t v47 = v36 + 24;
    goto LABEL_91;
  }
  uint64_t v48 = *a1;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v36 - *a1) >> 3);
  unint64_t v50 = v49 + 1;
  if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_92:
  }
    abort();
  unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v48) >> 3);
  if (2 * v51 > v50) {
    unint64_t v50 = 2 * v51;
  }
  if (v51 >= 0x555555555555555) {
    unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v52 = v50;
  }
  if (v52)
  {
    if (v52 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v53 = (char *)operator new(24 * v52);
      goto LABEL_85;
    }
LABEL_93:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v53 = 0;
LABEL_85:
  uint64_t v54 = &v53[24 * v49];
  uint64_t v55 = &v53[24 * v52];
  *(void *)uint64_t v54 = 0x9D7520A01DC69D83;
  *((void *)v54 + 1) = "md::ls::HasMaterialRaster]";
  *((void *)v54 + 2) = 25;
  unint64_t v47 = v54 + 24;
  if (v36 == v48)
  {
    *a1 = v54;
    a1[1] = v47;
    a1[2] = v55;
LABEL_90:
    operator delete(v36);
    goto LABEL_91;
  }
  do
  {
    long long v56 = *(_OWORD *)(v36 - 24);
    *((void *)v54 - 1) = *((void *)v36 - 1);
    *(_OWORD *)(v54 - 24) = v56;
    v54 -= 24;
    v36 -= 24;
  }
  while (v36 != v48);
  uint64_t v36 = *a1;
  *a1 = v54;
  a1[1] = v47;
  a1[2] = v55;
  if (v36) {
    goto LABEL_90;
  }
LABEL_91:
  a1[1] = v47;
}

void sub_1A1BC6110(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfReadyToProcess &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x90uLL);
  a1[2] = (char *)(v2 + 18);
  *unint64_t v2 = 0x41650A8095FBA956;
  v2[1] = "md::ls::RegisterHandle]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDFF0;
  v2[4] = "md::ls::MapDataTypeV]";
  v2[5] = 20;
  v2[6] = 0xD14836FBCB6E3943;
  v2[7] = "md::ls::CheckIfReadyToProcess]";
  v2[8] = 29;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 18)
  {
    *(void *)uint64_t v3 = 0x53EA4A91D91C8985;
    v2[10] = "md::ls::FlyoverOctileKey]";
    v2[11] = 24;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_56;
  }
  if (0x5555555555555556 * (((char *)(v2 + 18) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 18) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 18) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_57;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x53EA4A91D91C8985;
  *((void *)v10 + 1) = "md::ls::FlyoverOctileKey]";
  *((void *)v10 + 2) = 24;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x695C99F828CA9E84;
    *((void *)v4 + 1) = "md::ls::BaseMapTileHandle]";
    *((void *)v4 + 2) = 25;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_56;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_57;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x695C99F828CA9E84;
  *((void *)v21 + 1) = "md::ls::BaseMapTileHandle]";
  *((void *)v21 + 2) = 25;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0xF3801DCCD1DDBED8;
    *((void *)v14 + 1) = "md::ls::WillEnterView]";
    *((void *)v14 + 2) = 21;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_56:
  }
    abort();
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v31 = (char *)operator new(24 * v30);
      goto LABEL_49;
    }
LABEL_57:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v31 = 0;
LABEL_49:
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0xF3801DCCD1DDBED8;
  *((void *)v32 + 1) = "md::ls::WillEnterView]";
  *((void *)v32 + 2) = 21;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
}

void sub_1A1BC6560(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfReadyToProcess &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x684A78DCF1B284C1;
  result[1] = "md::ls::RenderablesCount]";
  result[2] = 24;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfNeedsDepthPeel>(md::ita::CheckIfNeedsDepthPeel &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfNeedsDepthPeel &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfNeedsDepthPeel>(md::ita::CheckIfNeedsDepthPeel &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD00;
  v2[4] = "md::ls::InView]";
  v2[5] = 14;
  v2[6] = 0xEC2A00DC914732D7;
  v2[7] = "md::ls::IntendedSceneLayer]";
  v2[8] = 26;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)uint64_t v3 = 0x910D7E292AD5622FLL;
    v2[10] = "md::ls::CheckIfRequiresDepthPeel]";
    v2[11] = 32;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x910D7E292AD5622FLL;
  *((void *)v10 + 1) = "md::ls::CheckIfRequiresDepthPeel]";
  *((void *)v10 + 2) = 32;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BC67C4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfNeedsDepthPeel>(md::ita::CheckIfNeedsDepthPeel &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfNeedsDepthPeel &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfNeedsDepthPeel>(md::ita::CheckIfNeedsDepthPeel &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildShadowFrameGraph>(md::ita::BuildShadowFrameGraph &&)::{lambda(void)#1},std::allocator<md::ita::BuildShadowFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildShadowFrameGraph>(md::ita::BuildShadowFrameGraph &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x7216A09FEC0661A6;
  result[1] = "md::ls::PassShadowConfiguration]";
  result[2] = 31;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildShadowFrameGraph>(md::ita::BuildShadowFrameGraph &&)::{lambda(void)#2},std::allocator<md::ita::BuildShadowFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildShadowFrameGraph>(md::ita::BuildShadowFrameGraph &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 48;
  uint64_t v3 = (char **)a1;
  _ZZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FrameGraphBuilderENS4_9PassCountEEEEZNS_18typelist_as_vectorIS7_EENS1_6vectorINS_8TypeInfoENS1_9allocatorISA_EEEEvEUlTyvE_EEvOT0_ENKUlTpTnmNS1_16integer_sequenceImJXspT_EEEEE_clIJLm0ELm1EEEEDaSI_(&v3);
}

void sub_1A1BC689C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTexTextureIndex>(md::ita::AssignTexTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignTexTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTexTextureIndex>(md::ita::AssignTexTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x1D932F2BF291491;
  v2[1] = "md::ls::TextureHandleForType<DaVinci::TexTexture>]";
  *(void *)&double result = 49;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD980;
  v2[4] = "md::ls::RequiresShaderTextureID<DaVinci::TexTexture>]";
  v2[5] = 52;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTexTextureIndex>(md::ita::AssignTexTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignTexTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTexTextureIndex>(md::ita::AssignTexTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC6970(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#1},std::allocator<md::ita::UpdateTileTransforms &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x34AE67B339EEC99CLL;
  v2[1] = "md::ls::TileBounds]";
  *(void *)&double result = 18;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDF80;
  v2[4] = "md::ls::TileMatrix]";
  v2[5] = 18;
  *a1 = v2;
  return result;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#2},std::allocator<md::ita::UpdateTileTransforms &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xD270E8E58701C515;
  result[1] = "md::ls::TileTransformConstantDataHandle]";
  result[2] = 39;
  *a1 = result;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#1},std::allocator<md::ita::DisconnectComponents &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xDACEFB85CDF2B135;
  v2[1] = "md::ls::RequestReset]";
  *(void *)&double result = 20;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDFD0;
  v2[4] = "md::ls::PendingDeletion]";
  v2[5] = 23;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#2},std::allocator<md::ita::DisconnectComponents &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x270uLL);
  a1[2] = (char *)(v2 + 78);
  *unint64_t v2 = 0xB6C12FBB402E8E70;
  v2[1] = "md::ls::RenderableMaterialData]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDFC0;
  v2[4] = "md::ls::RampMaterialData]";
  v2[5] = 24;
  v2[6] = 0xA3F884E4E2541296;
  v2[7] = "md::ls::ColorDataHandle]";
  v2[8] = 23;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 78)
  {
    *(void *)uint64_t v3 = 0x849CB194B84BB63DLL;
    v2[10] = "md::ls::UniqueMaterialVisibilityOptionsHandle]";
    v2[11] = 45;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  if (0x5555555555555556 * (((char *)(v2 + 78) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 78) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 78) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x849CB194B84BB63DLL;
  *((void *)v10 + 1) = "md::ls::UniqueMaterialVisibilityOptionsHandle]";
  *((void *)v10 + 2) = 45;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0xE515B39146CD9FB7;
    *((void *)v4 + 1) = "md::ls::UniqueMaterialZIndexHandle]";
    *((void *)v4 + 2) = 34;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0xE515B39146CD9FB7;
  *((void *)v21 + 1) = "md::ls::UniqueMaterialZIndexHandle]";
  *((void *)v21 + 2) = 34;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0x60915CB292001F47;
    *((void *)v14 + 1) = "md::ls::UniqueColorDataHandle]";
    *((void *)v14 + 2) = 29;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0x60915CB292001F47;
  *((void *)v32 + 1) = "md::ls::UniqueColorDataHandle]";
  *((void *)v32 + 2) = 29;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0x6C7EE74910D42096;
    *((void *)v25 + 1) = "md::ls::PositionScaleInfoConstantDataHandle]";
    *((void *)v25 + 2) = 43;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    uint64_t v42 = (char *)operator new(24 * v41);
  }
  else
  {
    uint64_t v42 = 0;
  }
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0x6C7EE74910D42096;
  *((void *)v43 + 1) = "md::ls::PositionScaleInfoConstantDataHandle]";
  *((void *)v43 + 2) = 43;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
  unint64_t v46 = (unint64_t)a1[2];
  if ((unint64_t)v36 < v46)
  {
    *(void *)uint64_t v36 = 0x6E0342375BBCD967;
    *((void *)v36 + 1) = "md::ls::StyleRouteLineMaskConstantDataHandle]";
    *((void *)v36 + 2) = 44;
    unint64_t v47 = v36 + 24;
    goto LABEL_91;
  }
  uint64_t v48 = *a1;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v36 - *a1) >> 3);
  unint64_t v50 = v49 + 1;
  if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v48) >> 3);
  if (2 * v51 > v50) {
    unint64_t v50 = 2 * v51;
  }
  if (v51 >= 0x555555555555555) {
    unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v52 = v50;
  }
  if (v52)
  {
    if (v52 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    uint64_t v53 = (char *)operator new(24 * v52);
  }
  else
  {
    uint64_t v53 = 0;
  }
  uint64_t v54 = &v53[24 * v49];
  uint64_t v55 = &v53[24 * v52];
  *(void *)uint64_t v54 = 0x6E0342375BBCD967;
  *((void *)v54 + 1) = "md::ls::StyleRouteLineMaskConstantDataHandle]";
  *((void *)v54 + 2) = 44;
  unint64_t v47 = v54 + 24;
  if (v36 == v48)
  {
    *a1 = v54;
    a1[1] = v47;
    a1[2] = v55;
LABEL_90:
    operator delete(v36);
    goto LABEL_91;
  }
  do
  {
    long long v56 = *(_OWORD *)(v36 - 24);
    *((void *)v54 - 1) = *((void *)v36 - 1);
    *(_OWORD *)(v54 - 24) = v56;
    v54 -= 24;
    v36 -= 24;
  }
  while (v36 != v48);
  uint64_t v36 = *a1;
  *a1 = v54;
  a1[1] = v47;
  a1[2] = v55;
  if (v36) {
    goto LABEL_90;
  }
LABEL_91:
  a1[1] = v47;
  unint64_t v57 = (unint64_t)a1[2];
  if ((unint64_t)v47 < v57)
  {
    *(void *)unint64_t v47 = 0x7DD7F5B95CA3FF88;
    *((void *)v47 + 1) = "md::ls::StyleConstantHandle]";
    *((void *)v47 + 2) = 27;
    unint64_t v58 = v47 + 24;
    goto LABEL_109;
  }
  unint64_t v59 = *a1;
  unint64_t v60 = 0xAAAAAAAAAAAAAAABLL * ((v47 - *a1) >> 3);
  unint64_t v61 = v60 + 1;
  if (v60 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v57 - (void)v59) >> 3);
  if (2 * v62 > v61) {
    unint64_t v61 = 2 * v62;
  }
  if (v62 >= 0x555555555555555) {
    unint64_t v63 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v63 = v61;
  }
  if (v63)
  {
    if (v63 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    uint64_t v64 = (char *)operator new(24 * v63);
  }
  else
  {
    uint64_t v64 = 0;
  }
  unint64_t v65 = &v64[24 * v60];
  long long v66 = &v64[24 * v63];
  *(void *)unint64_t v65 = 0x7DD7F5B95CA3FF88;
  *((void *)v65 + 1) = "md::ls::StyleConstantHandle]";
  *((void *)v65 + 2) = 27;
  unint64_t v58 = v65 + 24;
  if (v47 == v59)
  {
    *a1 = v65;
    a1[1] = v58;
    a1[2] = v66;
LABEL_108:
    operator delete(v47);
    goto LABEL_109;
  }
  do
  {
    long long v67 = *(_OWORD *)(v47 - 24);
    *((void *)v65 - 1) = *((void *)v47 - 1);
    *(_OWORD *)(v65 - 24) = v67;
    v65 -= 24;
    v47 -= 24;
  }
  while (v47 != v59);
  unint64_t v47 = *a1;
  *a1 = v65;
  a1[1] = v58;
  a1[2] = v66;
  if (v47) {
    goto LABEL_108;
  }
LABEL_109:
  a1[1] = v58;
  unint64_t v68 = (unint64_t)a1[2];
  if ((unint64_t)v58 < v68)
  {
    *(void *)unint64_t v58 = 0xDC98991DB7473274;
    *((void *)v58 + 1) = "md::ls::LandCoverSettingsConstantDataHandle]";
    *((void *)v58 + 2) = 43;
    uint64_t v69 = v58 + 24;
    goto LABEL_127;
  }
  uint64_t v70 = *a1;
  unint64_t v71 = 0xAAAAAAAAAAAAAAABLL * ((v58 - *a1) >> 3);
  unint64_t v72 = v71 + 1;
  if (v71 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v73 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v68 - (void)v70) >> 3);
  if (2 * v73 > v72) {
    unint64_t v72 = 2 * v73;
  }
  if (v73 >= 0x555555555555555) {
    unint64_t v74 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v74 = v72;
  }
  if (v74)
  {
    if (v74 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    uint64_t v75 = (char *)operator new(24 * v74);
  }
  else
  {
    uint64_t v75 = 0;
  }
  unint64_t v76 = &v75[24 * v71];
  size_t v77 = &v75[24 * v74];
  *(void *)unint64_t v76 = 0xDC98991DB7473274;
  *((void *)v76 + 1) = "md::ls::LandCoverSettingsConstantDataHandle]";
  *((void *)v76 + 2) = 43;
  uint64_t v69 = v76 + 24;
  if (v58 == v70)
  {
    *a1 = v76;
    a1[1] = v69;
    a1[2] = v77;
LABEL_126:
    operator delete(v58);
    goto LABEL_127;
  }
  do
  {
    long long v78 = *(_OWORD *)(v58 - 24);
    *((void *)v76 - 1) = *((void *)v58 - 1);
    *(_OWORD *)(v76 - 24) = v78;
    v76 -= 24;
    v58 -= 24;
  }
  while (v58 != v70);
  unint64_t v58 = *a1;
  *a1 = v76;
  a1[1] = v69;
  a1[2] = v77;
  if (v58) {
    goto LABEL_126;
  }
LABEL_127:
  a1[1] = v69;
  unint64_t v79 = (unint64_t)a1[2];
  if ((unint64_t)v69 < v79)
  {
    *(void *)uint64_t v69 = 0xD5AD9B8C3FE62EE8;
    *((void *)v69 + 1) = "md::ls::StyleGroundOcclusionConstantDataHandle]";
    *((void *)v69 + 2) = 46;
    int16x8_t v80 = v69 + 24;
    goto LABEL_145;
  }
  uint64_t v81 = *a1;
  unint64_t v82 = 0xAAAAAAAAAAAAAAABLL * ((v69 - *a1) >> 3);
  unint64_t v83 = v82 + 1;
  if (v82 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v84 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v79 - (void)v81) >> 3);
  if (2 * v84 > v83) {
    unint64_t v83 = 2 * v84;
  }
  if (v84 >= 0x555555555555555) {
    unint64_t v85 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v85 = v83;
  }
  if (v85)
  {
    if (v85 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    uint64_t v86 = (char *)operator new(24 * v85);
  }
  else
  {
    uint64_t v86 = 0;
  }
  int8x8_t v87 = &v86[24 * v82];
  uint64_t v88 = &v86[24 * v85];
  *(void *)int8x8_t v87 = 0xD5AD9B8C3FE62EE8;
  *((void *)v87 + 1) = "md::ls::StyleGroundOcclusionConstantDataHandle]";
  *((void *)v87 + 2) = 46;
  int16x8_t v80 = v87 + 24;
  if (v69 == v81)
  {
    *a1 = v87;
    a1[1] = v80;
    a1[2] = v88;
LABEL_144:
    operator delete(v69);
    goto LABEL_145;
  }
  do
  {
    long long v89 = *(_OWORD *)(v69 - 24);
    *((void *)v87 - 1) = *((void *)v69 - 1);
    *(_OWORD *)(v87 - 24) = v89;
    v87 -= 24;
    v69 -= 24;
  }
  while (v69 != v81);
  uint64_t v69 = *a1;
  *a1 = v87;
  a1[1] = v80;
  a1[2] = v88;
  if (v69) {
    goto LABEL_144;
  }
LABEL_145:
  a1[1] = v80;
  unint64_t v90 = (unint64_t)a1[2];
  if ((unint64_t)v80 < v90)
  {
    *(void *)int16x8_t v80 = 0xE103B5C60804137ELL;
    *((void *)v80 + 1) = "md::ls::ColorRampDataHandle]";
    *((void *)v80 + 2) = 27;
    BOOL v91 = v80 + 24;
    goto LABEL_163;
  }
  int8x16_t v92 = *a1;
  unint64_t v93 = 0xAAAAAAAAAAAAAAABLL * ((v80 - *a1) >> 3);
  unint64_t v94 = v93 + 1;
  if (v93 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v95 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v90 - (void)v92) >> 3);
  if (2 * v95 > v94) {
    unint64_t v94 = 2 * v95;
  }
  if (v95 >= 0x555555555555555) {
    unint64_t v96 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v96 = v94;
  }
  if (v96)
  {
    if (v96 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    int8x16_t v97 = (char *)operator new(24 * v96);
  }
  else
  {
    int8x16_t v97 = 0;
  }
  int16x8_t v98 = &v97[24 * v93];
  int32x4_t v99 = &v97[24 * v96];
  *(void *)int16x8_t v98 = 0xE103B5C60804137ELL;
  *((void *)v98 + 1) = "md::ls::ColorRampDataHandle]";
  *((void *)v98 + 2) = 27;
  BOOL v91 = v98 + 24;
  if (v80 == v92)
  {
    *a1 = v98;
    a1[1] = v91;
    a1[2] = v99;
LABEL_162:
    operator delete(v80);
    goto LABEL_163;
  }
  do
  {
    long long v100 = *(_OWORD *)(v80 - 24);
    *((void *)v98 - 1) = *((void *)v80 - 1);
    *(_OWORD *)(v98 - 24) = v100;
    v98 -= 24;
    v80 -= 24;
  }
  while (v80 != v92);
  int16x8_t v80 = *a1;
  *a1 = v98;
  a1[1] = v91;
  a1[2] = v99;
  if (v80) {
    goto LABEL_162;
  }
LABEL_163:
  a1[1] = v91;
  unint64_t v101 = (unint64_t)a1[2];
  if ((unint64_t)v91 < v101)
  {
    *(void *)BOOL v91 = 0x3218EFD67197A145;
    *((void *)v91 + 1) = "md::ls::NormalsHandle]";
    *((void *)v91 + 2) = 21;
    uint64_t v102 = v91 + 24;
    goto LABEL_181;
  }
  int32x4_t v103 = *a1;
  unint64_t v104 = 0xAAAAAAAAAAAAAAABLL * ((v91 - *a1) >> 3);
  unint64_t v105 = v104 + 1;
  if (v104 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v106 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v101 - (void)v103) >> 3);
  if (2 * v106 > v105) {
    unint64_t v105 = 2 * v106;
  }
  if (v106 >= 0x555555555555555) {
    unint64_t v107 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v107 = v105;
  }
  if (v107)
  {
    if (v107 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    uint64_t v108 = (char *)operator new(24 * v107);
  }
  else
  {
    uint64_t v108 = 0;
  }
  int8x16_t v109 = &v108[24 * v104];
  unint64_t v110 = &v108[24 * v107];
  *(void *)int8x16_t v109 = 0x3218EFD67197A145;
  *((void *)v109 + 1) = "md::ls::NormalsHandle]";
  *((void *)v109 + 2) = 21;
  uint64_t v102 = v109 + 24;
  if (v91 == v103)
  {
    *a1 = v109;
    a1[1] = v102;
    a1[2] = v110;
LABEL_180:
    operator delete(v91);
    goto LABEL_181;
  }
  do
  {
    long long v111 = *(_OWORD *)(v91 - 24);
    *((void *)v109 - 1) = *((void *)v91 - 1);
    *(_OWORD *)(v109 - 24) = v111;
    v109 -= 24;
    v91 -= 24;
  }
  while (v91 != v103);
  BOOL v91 = *a1;
  *a1 = v109;
  a1[1] = v102;
  a1[2] = v110;
  if (v91) {
    goto LABEL_180;
  }
LABEL_181:
  a1[1] = v102;
  unint64_t v112 = (unint64_t)a1[2];
  if ((unint64_t)v102 < v112)
  {
    *(void *)uint64_t v102 = 0xCBB77B1CBD05D7C5;
    *((void *)v102 + 1) = "md::ls::UVsHandle]";
    *((void *)v102 + 2) = 17;
    int8x16_t v113 = v102 + 24;
    goto LABEL_199;
  }
  int v114 = *a1;
  unint64_t v115 = 0xAAAAAAAAAAAAAAABLL * ((v102 - *a1) >> 3);
  unint64_t v116 = v115 + 1;
  if (v115 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v117 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v112 - (void)v114) >> 3);
  if (2 * v117 > v116) {
    unint64_t v116 = 2 * v117;
  }
  if (v117 >= 0x555555555555555) {
    unint64_t v118 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v118 = v116;
  }
  if (v118)
  {
    if (v118 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    int v119 = (char *)operator new(24 * v118);
  }
  else
  {
    int v119 = 0;
  }
  int32x4_t v120 = &v119[24 * v115];
  int8x16_t v121 = &v119[24 * v118];
  *(void *)int32x4_t v120 = 0xCBB77B1CBD05D7C5;
  *((void *)v120 + 1) = "md::ls::UVsHandle]";
  *((void *)v120 + 2) = 17;
  int8x16_t v113 = v120 + 24;
  if (v102 == v114)
  {
    *a1 = v120;
    a1[1] = v113;
    a1[2] = v121;
LABEL_198:
    operator delete(v102);
    goto LABEL_199;
  }
  do
  {
    long long v122 = *(_OWORD *)(v102 - 24);
    *((void *)v120 - 1) = *((void *)v102 - 1);
    *(_OWORD *)(v120 - 24) = v122;
    v120 -= 24;
    v102 -= 24;
  }
  while (v102 != v114);
  uint64_t v102 = *a1;
  *a1 = v120;
  a1[1] = v113;
  a1[2] = v121;
  if (v102) {
    goto LABEL_198;
  }
LABEL_199:
  a1[1] = v113;
  unint64_t v123 = (unint64_t)a1[2];
  if ((unint64_t)v113 < v123)
  {
    *(void *)int8x16_t v113 = 0xD443D3DCBB78491ALL;
    *((void *)v113 + 1) = "md::ls::ElevationHandle]";
    *((void *)v113 + 2) = 23;
    uint64_t v124 = v113 + 24;
    goto LABEL_217;
  }
  int8x16_t v125 = *a1;
  unint64_t v126 = 0xAAAAAAAAAAAAAAABLL * ((v113 - *a1) >> 3);
  unint64_t v127 = v126 + 1;
  if (v126 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v128 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v123 - (void)v125) >> 3);
  if (2 * v128 > v127) {
    unint64_t v127 = 2 * v128;
  }
  if (v128 >= 0x555555555555555) {
    unint64_t v129 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v129 = v127;
  }
  if (v129)
  {
    if (v129 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    uint64_t v130 = (char *)operator new(24 * v129);
  }
  else
  {
    uint64_t v130 = 0;
  }
  uint64_t v131 = &v130[24 * v126];
  float v132 = &v130[24 * v129];
  *(void *)uint64_t v131 = 0xD443D3DCBB78491ALL;
  *((void *)v131 + 1) = "md::ls::ElevationHandle]";
  *((void *)v131 + 2) = 23;
  uint64_t v124 = v131 + 24;
  if (v113 == v125)
  {
    *a1 = v131;
    a1[1] = v124;
    a1[2] = v132;
LABEL_216:
    operator delete(v113);
    goto LABEL_217;
  }
  do
  {
    long long v133 = *(_OWORD *)(v113 - 24);
    *((void *)v131 - 1) = *((void *)v113 - 1);
    *(_OWORD *)(v131 - 24) = v133;
    v131 -= 24;
    v113 -= 24;
  }
  while (v113 != v125);
  int8x16_t v113 = *a1;
  *a1 = v131;
  a1[1] = v124;
  a1[2] = v132;
  if (v113) {
    goto LABEL_216;
  }
LABEL_217:
  a1[1] = v124;
  unint64_t v134 = (unint64_t)a1[2];
  if ((unint64_t)v124 < v134)
  {
    *(void *)uint64_t v124 = 0xAF179EFD8A4C83D4;
    *((void *)v124 + 1) = "md::ls::InstanceTransformHandle]";
    *((void *)v124 + 2) = 31;
    unint64_t v135 = v124 + 24;
    goto LABEL_235;
  }
  long long v136 = *a1;
  unint64_t v137 = 0xAAAAAAAAAAAAAAABLL * ((v124 - *a1) >> 3);
  unint64_t v138 = v137 + 1;
  if (v137 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v139 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v134 - (void)v136) >> 3);
  if (2 * v139 > v138) {
    unint64_t v138 = 2 * v139;
  }
  if (v139 >= 0x555555555555555) {
    unint64_t v140 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v140 = v138;
  }
  if (v140)
  {
    if (v140 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    float v141 = (char *)operator new(24 * v140);
  }
  else
  {
    float v141 = 0;
  }
  uint64_t v142 = &v141[24 * v137];
  uint64_t v143 = &v141[24 * v140];
  *(void *)uint64_t v142 = 0xAF179EFD8A4C83D4;
  *((void *)v142 + 1) = "md::ls::InstanceTransformHandle]";
  *((void *)v142 + 2) = 31;
  unint64_t v135 = v142 + 24;
  if (v124 == v136)
  {
    *a1 = v142;
    a1[1] = v135;
    a1[2] = v143;
LABEL_234:
    operator delete(v124);
    goto LABEL_235;
  }
  do
  {
    long long v144 = *(_OWORD *)(v124 - 24);
    *((void *)v142 - 1) = *((void *)v124 - 1);
    *(_OWORD *)(v142 - 24) = v144;
    v142 -= 24;
    v124 -= 24;
  }
  while (v124 != v136);
  uint64_t v124 = *a1;
  *a1 = v142;
  a1[1] = v135;
  a1[2] = v143;
  if (v124) {
    goto LABEL_234;
  }
LABEL_235:
  a1[1] = v135;
  unint64_t v145 = (unint64_t)a1[2];
  if ((unint64_t)v135 < v145)
  {
    *(void *)unint64_t v135 = 0xEBDB618C34E97A19;
    *((void *)v135 + 1) = "md::ls::UniqueStyleEmissiveDataKeyHandle]";
    *((void *)v135 + 2) = 40;
    uint64_t v146 = v135 + 24;
    goto LABEL_253;
  }
  uint64_t v147 = *a1;
  unint64_t v148 = 0xAAAAAAAAAAAAAAABLL * ((v135 - *a1) >> 3);
  unint64_t v149 = v148 + 1;
  if (v148 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v150 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v145 - (void)v147) >> 3);
  if (2 * v150 > v149) {
    unint64_t v149 = 2 * v150;
  }
  if (v150 >= 0x555555555555555) {
    unint64_t v151 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v151 = v149;
  }
  if (v151)
  {
    if (v151 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    double v152 = (char *)operator new(24 * v151);
  }
  else
  {
    double v152 = 0;
  }
  double v153 = &v152[24 * v148];
  double v154 = &v152[24 * v151];
  *(void *)double v153 = 0xEBDB618C34E97A19;
  *((void *)v153 + 1) = "md::ls::UniqueStyleEmissiveDataKeyHandle]";
  *((void *)v153 + 2) = 40;
  uint64_t v146 = v153 + 24;
  if (v135 == v147)
  {
    *a1 = v153;
    a1[1] = v146;
    a1[2] = v154;
LABEL_252:
    operator delete(v135);
    goto LABEL_253;
  }
  do
  {
    long long v155 = *(_OWORD *)(v135 - 24);
    *((void *)v153 - 1) = *((void *)v135 - 1);
    *(_OWORD *)(v153 - 24) = v155;
    v153 -= 24;
    v135 -= 24;
  }
  while (v135 != v147);
  unint64_t v135 = *a1;
  *a1 = v153;
  a1[1] = v146;
  a1[2] = v154;
  if (v135) {
    goto LABEL_252;
  }
LABEL_253:
  a1[1] = v146;
  unint64_t v156 = (unint64_t)a1[2];
  if ((unint64_t)v146 < v156)
  {
    *(void *)uint64_t v146 = 0x11BB47B172EB0B40;
    *((void *)v146 + 1) = "md::ls::NeedsClimateTint]";
    *((void *)v146 + 2) = 24;
    long double v157 = v146 + 24;
    goto LABEL_271;
  }
  long double v158 = *a1;
  unint64_t v159 = 0xAAAAAAAAAAAAAAABLL * ((v146 - *a1) >> 3);
  unint64_t v160 = v159 + 1;
  if (v159 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v161 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v156 - (void)v158) >> 3);
  if (2 * v161 > v160) {
    unint64_t v160 = 2 * v161;
  }
  if (v161 >= 0x555555555555555) {
    unint64_t v162 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v162 = v160;
  }
  if (v162)
  {
    if (v162 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    double v163 = (char *)operator new(24 * v162);
  }
  else
  {
    double v163 = 0;
  }
  double v164 = &v163[24 * v159];
  __double2 v165 = &v163[24 * v162];
  *(void *)double v164 = 0x11BB47B172EB0B40;
  *((void *)v164 + 1) = "md::ls::NeedsClimateTint]";
  *((void *)v164 + 2) = 24;
  long double v157 = v164 + 24;
  if (v146 == v158)
  {
    *a1 = v164;
    a1[1] = v157;
    a1[2] = v165;
LABEL_270:
    operator delete(v146);
    goto LABEL_271;
  }
  do
  {
    long long v166 = *(_OWORD *)(v146 - 24);
    *((void *)v164 - 1) = *((void *)v146 - 1);
    *(_OWORD *)(v164 - 24) = v166;
    v164 -= 24;
    v146 -= 24;
  }
  while (v146 != v158);
  uint64_t v146 = *a1;
  *a1 = v164;
  a1[1] = v157;
  a1[2] = v165;
  if (v146) {
    goto LABEL_270;
  }
LABEL_271:
  a1[1] = v157;
  unint64_t v167 = (unint64_t)a1[2];
  if ((unint64_t)v157 < v167)
  {
    *(void *)long double v157 = 0x28D6AB85FDB5A2BLL;
    *((void *)v157 + 1) = "md::ls::RenderableAlbedoTexture]";
    *((void *)v157 + 2) = 31;
    double v168 = v157 + 24;
    goto LABEL_289;
  }
  double v169 = *a1;
  unint64_t v170 = 0xAAAAAAAAAAAAAAABLL * ((v157 - *a1) >> 3);
  unint64_t v171 = v170 + 1;
  if (v170 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v172 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v167 - (void)v169) >> 3);
  if (2 * v172 > v171) {
    unint64_t v171 = 2 * v172;
  }
  if (v172 >= 0x555555555555555) {
    unint64_t v173 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v173 = v171;
  }
  if (v173)
  {
    if (v173 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    double v174 = (char *)operator new(24 * v173);
  }
  else
  {
    double v174 = 0;
  }
  double v175 = &v174[24 * v170];
  double v176 = &v174[24 * v173];
  *(void *)double v175 = 0x28D6AB85FDB5A2BLL;
  *((void *)v175 + 1) = "md::ls::RenderableAlbedoTexture]";
  *((void *)v175 + 2) = 31;
  double v168 = v175 + 24;
  if (v157 == v169)
  {
    *a1 = v175;
    a1[1] = v168;
    a1[2] = v176;
LABEL_288:
    operator delete(v157);
    goto LABEL_289;
  }
  do
  {
    long long v177 = *(_OWORD *)(v157 - 24);
    *((void *)v175 - 1) = *((void *)v157 - 1);
    *(_OWORD *)(v175 - 24) = v177;
    v175 -= 24;
    v157 -= 24;
  }
  while (v157 != v169);
  long double v157 = *a1;
  *a1 = v175;
  a1[1] = v168;
  a1[2] = v176;
  if (v157) {
    goto LABEL_288;
  }
LABEL_289:
  a1[1] = v168;
  unint64_t v178 = (unint64_t)a1[2];
  if ((unint64_t)v168 < v178)
  {
    *(void *)double v168 = 0xD49B968135FE1A73;
    *((void *)v168 + 1) = "md::ls::TextureHandleForType<Flyover::NightTexture>]";
    *((void *)v168 + 2) = 51;
    __double2 v179 = v168 + 24;
    goto LABEL_307;
  }
  double v180 = *a1;
  unint64_t v181 = 0xAAAAAAAAAAAAAAABLL * ((v168 - *a1) >> 3);
  unint64_t v182 = v181 + 1;
  if (v181 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v183 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v178 - (void)v180) >> 3);
  if (2 * v183 > v182) {
    unint64_t v182 = 2 * v183;
  }
  if (v183 >= 0x555555555555555) {
    unint64_t v184 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v184 = v182;
  }
  if (v184)
  {
    if (v184 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    double v185 = (char *)operator new(24 * v184);
  }
  else
  {
    double v185 = 0;
  }
  double v186 = &v185[24 * v181];
  double v187 = &v185[24 * v184];
  *(void *)double v186 = 0xD49B968135FE1A73;
  *((void *)v186 + 1) = "md::ls::TextureHandleForType<Flyover::NightTexture>]";
  *((void *)v186 + 2) = 51;
  __double2 v179 = v186 + 24;
  if (v168 == v180)
  {
    *a1 = v186;
    a1[1] = v179;
    a1[2] = v187;
LABEL_306:
    operator delete(v168);
    goto LABEL_307;
  }
  do
  {
    long long v188 = *(_OWORD *)(v168 - 24);
    *((void *)v186 - 1) = *((void *)v168 - 1);
    *(_OWORD *)(v186 - 24) = v188;
    v186 -= 24;
    v168 -= 24;
  }
  while (v168 != v180);
  double v168 = *a1;
  *a1 = v186;
  a1[1] = v179;
  a1[2] = v187;
  if (v168) {
    goto LABEL_306;
  }
LABEL_307:
  a1[1] = v179;
  unint64_t v189 = (unint64_t)a1[2];
  if ((unint64_t)v179 < v189)
  {
    *(void *)__double2 v179 = 0xBAA35DF429A7267FLL;
    *((void *)v179 + 1) = "md::ls::TextureHandleForType<Flyover::DiffuseTexture>]";
    *((void *)v179 + 2) = 53;
    double v190 = v179 + 24;
    goto LABEL_325;
  }
  double v191 = *a1;
  unint64_t v192 = 0xAAAAAAAAAAAAAAABLL * ((v179 - *a1) >> 3);
  unint64_t v193 = v192 + 1;
  if (v192 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v194 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v189 - (void)v191) >> 3);
  if (2 * v194 > v193) {
    unint64_t v193 = 2 * v194;
  }
  if (v194 >= 0x555555555555555) {
    unint64_t v195 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v195 = v193;
  }
  if (v195)
  {
    if (v195 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    double v196 = (char *)operator new(24 * v195);
  }
  else
  {
    double v196 = 0;
  }
  float v197 = &v196[24 * v192];
  int v198 = &v196[24 * v195];
  *(void *)float v197 = 0xBAA35DF429A7267FLL;
  *((void *)v197 + 1) = "md::ls::TextureHandleForType<Flyover::DiffuseTexture>]";
  *((void *)v197 + 2) = 53;
  double v190 = v197 + 24;
  if (v179 == v191)
  {
    *a1 = v197;
    a1[1] = v190;
    a1[2] = v198;
LABEL_324:
    operator delete(v179);
    goto LABEL_325;
  }
  do
  {
    long long v199 = *(_OWORD *)(v179 - 24);
    *((void *)v197 - 1) = *((void *)v179 - 1);
    *(_OWORD *)(v197 - 24) = v199;
    v197 -= 24;
    v179 -= 24;
  }
  while (v179 != v191);
  __double2 v179 = *a1;
  *a1 = v197;
  a1[1] = v190;
  a1[2] = v198;
  if (v179) {
    goto LABEL_324;
  }
LABEL_325:
  a1[1] = v190;
  unint64_t v200 = (unint64_t)a1[2];
  if ((unint64_t)v190 < v200)
  {
    *(void *)double v190 = 0x5FF8F613B2E16249;
    *((void *)v190 + 1) = "md::ls::UniqueMaterialAlbedoTexture]";
    *((void *)v190 + 2) = 35;
    unint64_t v201 = v190 + 24;
    goto LABEL_343;
  }
  double v202 = *a1;
  unint64_t v203 = 0xAAAAAAAAAAAAAAABLL * ((v190 - *a1) >> 3);
  unint64_t v204 = v203 + 1;
  if (v203 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v205 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v200 - (void)v202) >> 3);
  if (2 * v205 > v204) {
    unint64_t v204 = 2 * v205;
  }
  if (v205 >= 0x555555555555555) {
    unint64_t v206 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v206 = v204;
  }
  if (v206)
  {
    if (v206 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    double v207 = (char *)operator new(24 * v206);
  }
  else
  {
    double v207 = 0;
  }
  double v208 = &v207[24 * v203];
  float v209 = &v207[24 * v206];
  *(void *)double v208 = 0x5FF8F613B2E16249;
  *((void *)v208 + 1) = "md::ls::UniqueMaterialAlbedoTexture]";
  *((void *)v208 + 2) = 35;
  unint64_t v201 = v208 + 24;
  if (v190 == v202)
  {
    *a1 = v208;
    a1[1] = v201;
    a1[2] = v209;
LABEL_342:
    operator delete(v190);
    goto LABEL_343;
  }
  do
  {
    long long v210 = *(_OWORD *)(v190 - 24);
    *((void *)v208 - 1) = *((void *)v190 - 1);
    *(_OWORD *)(v208 - 24) = v210;
    v208 -= 24;
    v190 -= 24;
  }
  while (v190 != v202);
  double v190 = *a1;
  *a1 = v208;
  a1[1] = v201;
  a1[2] = v209;
  if (v190) {
    goto LABEL_342;
  }
LABEL_343:
  a1[1] = v201;
  unint64_t v211 = (unint64_t)a1[2];
  if ((unint64_t)v201 < v211)
  {
    *(void *)unint64_t v201 = 0x1202E9D2D9704CABLL;
    *((void *)v201 + 1) = "md::ls::UniqueMaterialEmissiveTexture]";
    *((void *)v201 + 2) = 37;
    uint64_t v212 = v201 + 24;
    goto LABEL_361;
  }
  double v213 = *a1;
  unint64_t v214 = 0xAAAAAAAAAAAAAAABLL * ((v201 - *a1) >> 3);
  unint64_t v215 = v214 + 1;
  if (v214 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v216 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v211 - (void)v213) >> 3);
  if (2 * v216 > v215) {
    unint64_t v215 = 2 * v216;
  }
  if (v216 >= 0x555555555555555) {
    unint64_t v217 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v217 = v215;
  }
  if (v217)
  {
    if (v217 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    BOOL v218 = (char *)operator new(24 * v217);
  }
  else
  {
    BOOL v218 = 0;
  }
  double v219 = &v218[24 * v214];
  double v220 = &v218[24 * v217];
  *(void *)double v219 = 0x1202E9D2D9704CABLL;
  *((void *)v219 + 1) = "md::ls::UniqueMaterialEmissiveTexture]";
  *((void *)v219 + 2) = 37;
  uint64_t v212 = v219 + 24;
  if (v201 == v213)
  {
    *a1 = v219;
    a1[1] = v212;
    a1[2] = v220;
LABEL_360:
    operator delete(v201);
    goto LABEL_361;
  }
  do
  {
    long long v221 = *(_OWORD *)(v201 - 24);
    *((void *)v219 - 1) = *((void *)v201 - 1);
    *(_OWORD *)(v219 - 24) = v221;
    v219 -= 24;
    v201 -= 24;
  }
  while (v201 != v213);
  unint64_t v201 = *a1;
  *a1 = v219;
  a1[1] = v212;
  a1[2] = v220;
  if (v201) {
    goto LABEL_360;
  }
LABEL_361:
  a1[1] = v212;
  unint64_t v222 = (unint64_t)a1[2];
  if ((unint64_t)v212 < v222)
  {
    *(void *)uint64_t v212 = 0xCF2EB3C843EAD89ALL;
    *((void *)v212 + 1) = "md::ls::UniqueMaterialDiffuseTexture]";
    *((void *)v212 + 2) = 36;
    double v223 = v212 + 24;
    goto LABEL_379;
  }
  double v224 = *a1;
  unint64_t v225 = 0xAAAAAAAAAAAAAAABLL * ((v212 - *a1) >> 3);
  unint64_t v226 = v225 + 1;
  if (v225 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v227 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v222 - (void)v224) >> 3);
  if (2 * v227 > v226) {
    unint64_t v226 = 2 * v227;
  }
  if (v227 >= 0x555555555555555) {
    unint64_t v228 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v228 = v226;
  }
  if (v228)
  {
    if (v228 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    double v229 = (char *)operator new(24 * v228);
  }
  else
  {
    double v229 = 0;
  }
  long double v230 = &v229[24 * v225];
  float v231 = &v229[24 * v228];
  *(void *)long double v230 = 0xCF2EB3C843EAD89ALL;
  *((void *)v230 + 1) = "md::ls::UniqueMaterialDiffuseTexture]";
  *((void *)v230 + 2) = 36;
  double v223 = v230 + 24;
  if (v212 == v224)
  {
    *a1 = v230;
    a1[1] = v223;
    a1[2] = v231;
LABEL_378:
    operator delete(v212);
    goto LABEL_379;
  }
  do
  {
    long long v232 = *(_OWORD *)(v212 - 24);
    *((void *)v230 - 1) = *((void *)v212 - 1);
    *(_OWORD *)(v230 - 24) = v232;
    v230 -= 24;
    v212 -= 24;
  }
  while (v212 != v224);
  uint64_t v212 = *a1;
  *a1 = v230;
  a1[1] = v223;
  a1[2] = v231;
  if (v212) {
    goto LABEL_378;
  }
LABEL_379:
  a1[1] = v223;
  unint64_t v233 = (unint64_t)a1[2];
  if ((unint64_t)v223 < v233)
  {
    *(void *)double v223 = 0x9A2CF0F3E5B1FB4ELL;
    *((void *)v223 + 1) = "md::ls::TexturesToDisconnect]";
    *((void *)v223 + 2) = 28;
    float v234 = v223 + 24;
    goto LABEL_397;
  }
  double v235 = *a1;
  unint64_t v236 = 0xAAAAAAAAAAAAAAABLL * ((v223 - *a1) >> 3);
  unint64_t v237 = v236 + 1;
  if (v236 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_416;
  }
  unint64_t v238 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v233 - (void)v235) >> 3);
  if (2 * v238 > v237) {
    unint64_t v237 = 2 * v238;
  }
  if (v238 >= 0x555555555555555) {
    unint64_t v239 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v239 = v237;
  }
  if (v239)
  {
    if (v239 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_417;
    }
    double v240 = (char *)operator new(24 * v239);
  }
  else
  {
    double v240 = 0;
  }
  double v241 = &v240[24 * v236];
  double v242 = &v240[24 * v239];
  *(void *)double v241 = 0x9A2CF0F3E5B1FB4ELL;
  *((void *)v241 + 1) = "md::ls::TexturesToDisconnect]";
  *((void *)v241 + 2) = 28;
  float v234 = v241 + 24;
  if (v223 == v235)
  {
    *a1 = v241;
    a1[1] = v234;
    a1[2] = v242;
LABEL_396:
    operator delete(v223);
    goto LABEL_397;
  }
  do
  {
    long long v243 = *(_OWORD *)(v223 - 24);
    *((void *)v241 - 1) = *((void *)v223 - 1);
    *(_OWORD *)(v241 - 24) = v243;
    v241 -= 24;
    v223 -= 24;
  }
  while (v223 != v235);
  double v223 = *a1;
  *a1 = v241;
  a1[1] = v234;
  a1[2] = v242;
  if (v223) {
    goto LABEL_396;
  }
LABEL_397:
  a1[1] = v234;
  unint64_t v244 = (unint64_t)a1[2];
  if ((unint64_t)v234 < v244)
  {
    *(void *)float v234 = 0xE103B5C60804137ELL;
    *((void *)v234 + 1) = "md::ls::ColorRampDataHandle]";
    *((void *)v234 + 2) = 27;
    double v245 = v234 + 24;
    goto LABEL_415;
  }
  double v246 = *a1;
  unint64_t v247 = 0xAAAAAAAAAAAAAAABLL * ((v234 - *a1) >> 3);
  unint64_t v248 = v247 + 1;
  if (v247 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_416:
  }
    abort();
  unint64_t v249 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v244 - (void)v246) >> 3);
  if (2 * v249 > v248) {
    unint64_t v248 = 2 * v249;
  }
  if (v249 >= 0x555555555555555) {
    unint64_t v250 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v250 = v248;
  }
  if (v250)
  {
    if (v250 <= 0xAAAAAAAAAAAAAAALL)
    {
      double v251 = (char *)operator new(24 * v250);
      goto LABEL_409;
    }
LABEL_417:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  double v251 = 0;
LABEL_409:
  double v252 = &v251[24 * v247];
  double v253 = &v251[24 * v250];
  *(void *)double v252 = 0xE103B5C60804137ELL;
  *((void *)v252 + 1) = "md::ls::ColorRampDataHandle]";
  *((void *)v252 + 2) = 27;
  double v245 = v252 + 24;
  if (v234 == v246)
  {
    *a1 = v252;
    a1[1] = v245;
    a1[2] = v253;
LABEL_414:
    operator delete(v234);
    goto LABEL_415;
  }
  do
  {
    long long v254 = *(_OWORD *)(v234 - 24);
    *((void *)v252 - 1) = *((void *)v234 - 1);
    *(_OWORD *)(v252 - 24) = v254;
    v252 -= 24;
    v234 -= 24;
  }
  while (v234 != v246);
  float v234 = *a1;
  *a1 = v252;
  a1[1] = v245;
  a1[2] = v253;
  if (v234) {
    goto LABEL_414;
  }
LABEL_415:
  a1[1] = v245;
}

void sub_1A1BC85A8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelineStates>(md::ita::CreatePipelineStates &&)::{lambda(void)#1},std::allocator<md::ita::CreatePipelineStates &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelineStates>(md::ita::CreatePipelineStates &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0xC62D89929260CB56;
  v2[1] = "md::ls::FunctionConstants]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDB50;
  v2[4] = "md::ls::RequiredPipelinePoolID]";
  v2[5] = 30;
  v2[6] = 0x7087983DEF28DBFELL;
  v2[7] = "md::ls::IsOpaque]";
  v2[8] = 16;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)uint64_t v3 = 0x73F0259EC1934FB1;
    v2[10] = "md::ls::IsTransparent]";
    v2[11] = 21;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x73F0259EC1934FB1;
  *((void *)v10 + 1) = "md::ls::IsTransparent]";
  *((void *)v10 + 2) = 21;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BC87AC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelineStates>(md::ita::CreatePipelineStates &&)::{lambda(void)#2},std::allocator<md::ita::CreatePipelineStates &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelineStates>(md::ita::CreatePipelineStates &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfStyleZChanged>(md::ita::CheckIfStyleZChanged &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfStyleZChanged &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfStyleZChanged>(md::ita::CheckIfStyleZChanged &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfStyleZChanged>(md::ita::CheckIfStyleZChanged &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfStyleZChanged &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfStyleZChanged>(md::ita::CheckIfStyleZChanged &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x79DDAE60A4170168;
  result[1] = "md::ls::UpdatesWithStyleZChange]";
  result[2] = 31;
  *a1 = result;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleColorData>(md::ita::AssignStyleColorData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleColorData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleColorData>(md::ita::AssignStyleColorData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x7E6F38B7040F8E0FLL;
  v2[1] = "md::ls::StyleColorConstantDataHandle]";
  *(void *)&double result = 36;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDAA0;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>]";
  v2[5] = 86;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyColorCorrection>(md::ita::ApplyColorCorrection &&)::{lambda(void)#1},std::allocator<md::ita::ApplyColorCorrection &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyColorCorrection>(md::ita::ApplyColorCorrection &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0xA219A074B7259E0FLL;
  v2[1] = "md::ls::InView]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD10;
  v2[4] = "md::ls::MeshRenderableID]";
  v2[5] = 24;
  v2[6] = 0x20D1AB8FE4B8A761;
  v2[7] = "md::ls::CanEnableTexture]";
  v2[8] = 24;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)uint64_t v3 = 0xB6C12FBB402E8E70;
    v2[10] = "md::ls::RenderableMaterialData]";
    v2[11] = 30;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xB6C12FBB402E8E70;
  *((void *)v10 + 1) = "md::ls::RenderableMaterialData]";
  *((void *)v10 + 2) = 30;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BC8A98(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyColorCorrection>(md::ita::ApplyColorCorrection &&)::{lambda(void)#2},std::allocator<md::ita::ApplyColorCorrection &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyColorCorrection>(md::ita::ApplyColorCorrection &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCommonDataTask>(md::ita::SetupCommonDataTask &&)::{lambda(void)#1},std::allocator<md::ita::SetupCommonDataTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCommonDataTask>(md::ita::SetupCommonDataTask &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCommonDataTask>(md::ita::SetupCommonDataTask &&)::{lambda(void)#2},std::allocator<md::ita::SetupCommonDataTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCommonDataTask>(md::ita::SetupCommonDataTask &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x41650A8095FBA956;
  result[1] = "md::ls::RegisterHandle]";
  result[2] = 22;
  *a1 = result;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowBounds>(md::ita::PrepareShadowBounds &&)::{lambda(void)#1},std::allocator<md::ita::PrepareShadowBounds &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowBounds>(md::ita::PrepareShadowBounds &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xA054AACDFDD6A6BLL;
  v2[1] = "md::ls::AppliedWantsDynamicShadowBounds]";
  *(void *)&double result = 39;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDEB0;
  v2[4] = "md::BoundData]";
  v2[5] = 13;
  *a1 = v2;
  return result;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowBounds>(md::ita::PrepareShadowBounds &&)::{lambda(void)#2},std::allocator<md::ita::PrepareShadowBounds &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowBounds>(md::ita::PrepareShadowBounds &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x5EBA003AC7A96B8ALL;
  result[1] = "md::ls::SharedRenderableDataHandle]";
  result[2] = 34;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareDepthPrePass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareDepthPrePass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildSSAOFrameGraph>(md::ita::BuildSSAOFrameGraph &&)::{lambda(void)#1},std::allocator<md::ita::BuildSSAOFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildSSAOFrameGraph>(md::ita::BuildSSAOFrameGraph &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0xD7B05696AE714D71;
  v2[1] = "md::ls::FrameBufferDesc]";
  *(void *)&double result = 23;
  *((_OWORD *)v2 + 1) = xmmword_1A28FF8E0;
  v2[4] = "md::ls::PassSSAOConfiguration]";
  v2[5] = 29;
  v2[6] = 0xC5E1935BF25B6EDALL;
  v2[7] = "md::ls::PassMapEngineCapabilities]";
  v2[8] = 33;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignUVsDeviceData>(md::ita::AssignUVsDeviceData &&)::{lambda(void)#1},std::allocator<md::ita::AssignUVsDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignUVsDeviceData>(md::ita::AssignUVsDeviceData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xCBB77B1CBD05D7C5;
  v2[1] = "md::ls::UVsHandle]";
  *(void *)&double result = 17;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD8B0;
  v2[4] = "md::ls::RequiresShaderDeviceDataID<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>]";
  v2[5] = 75;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignUVsDeviceData>(md::ita::AssignUVsDeviceData &&)::{lambda(void)#2},std::allocator<md::ita::AssignUVsDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignUVsDeviceData>(md::ita::AssignUVsDeviceData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls13PipelineSetupEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BC8D68(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssembleRenderItems>(md::ita::AssembleRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::AssembleRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssembleRenderItems>(md::ita::AssembleRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0xF0uLL);
  a1[2] = (char *)(v2 + 30);
  *unint64_t v2 = 0x52AC71251090DBDELL;
  v2[1] = "md::ls::RenderState]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FD820;
  v2[4] = "md::ls::PipelineSetup]";
  v2[5] = 21;
  v2[6] = 0x9158B59D97A4E38DLL;
  v2[7] = "md::ls::RenderOrderToUse]";
  v2[8] = 24;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 30)
  {
    *(void *)uint64_t v3 = 0xE53EF176130D7769;
    v2[10] = "md::ls::InstanceCount]";
    v2[11] = 21;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_128;
  }
  if (0x5555555555555556 * (((char *)(v2 + 30) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 30) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 30) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_129;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xE53EF176130D7769;
  *((void *)v10 + 1) = "md::ls::InstanceCount]";
  *((void *)v10 + 2) = 21;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x9EC66CE0B60A2DFFLL;
    *((void *)v4 + 1) = "md::ls::StencilRefValueToUse]";
    *((void *)v4 + 2) = 28;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_128;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_129;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x9EC66CE0B60A2DFFLL;
  *((void *)v21 + 1) = "md::ls::StencilRefValueToUse]";
  *((void *)v21 + 2) = 28;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0x71CBA64B1A9CA230;
    *((void *)v14 + 1) = "md::ls::IndexRange]";
    *((void *)v14 + 2) = 18;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_128;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_129;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0x71CBA64B1A9CA230;
  *((void *)v32 + 1) = "md::ls::IndexRange]";
  *((void *)v32 + 2) = 18;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0xCD844FF303308290;
    *((void *)v25 + 1) = "md::ls::HasMeshHandle]";
    *((void *)v25 + 2) = 21;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_128;
  }
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_129;
    }
    uint64_t v42 = (char *)operator new(24 * v41);
  }
  else
  {
    uint64_t v42 = 0;
  }
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0xCD844FF303308290;
  *((void *)v43 + 1) = "md::ls::HasMeshHandle]";
  *((void *)v43 + 2) = 21;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
  unint64_t v46 = (unint64_t)a1[2];
  if ((unint64_t)v36 < v46)
  {
    *(void *)uint64_t v36 = 0xC62D89929260CB56;
    *((void *)v36 + 1) = "md::ls::FunctionConstants]";
    *((void *)v36 + 2) = 25;
    unint64_t v47 = v36 + 24;
    goto LABEL_91;
  }
  uint64_t v48 = *a1;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v36 - *a1) >> 3);
  unint64_t v50 = v49 + 1;
  if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_128;
  }
  unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v48) >> 3);
  if (2 * v51 > v50) {
    unint64_t v50 = 2 * v51;
  }
  if (v51 >= 0x555555555555555) {
    unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v52 = v50;
  }
  if (v52)
  {
    if (v52 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_129;
    }
    uint64_t v53 = (char *)operator new(24 * v52);
  }
  else
  {
    uint64_t v53 = 0;
  }
  uint64_t v54 = &v53[24 * v49];
  uint64_t v55 = &v53[24 * v52];
  *(void *)uint64_t v54 = 0xC62D89929260CB56;
  *((void *)v54 + 1) = "md::ls::FunctionConstants]";
  *((void *)v54 + 2) = 25;
  unint64_t v47 = v54 + 24;
  if (v36 == v48)
  {
    *a1 = v54;
    a1[1] = v47;
    a1[2] = v55;
LABEL_90:
    operator delete(v36);
    goto LABEL_91;
  }
  do
  {
    long long v56 = *(_OWORD *)(v36 - 24);
    *((void *)v54 - 1) = *((void *)v36 - 1);
    *(_OWORD *)(v54 - 24) = v56;
    v54 -= 24;
    v36 -= 24;
  }
  while (v36 != v48);
  uint64_t v36 = *a1;
  *a1 = v54;
  a1[1] = v47;
  a1[2] = v55;
  if (v36) {
    goto LABEL_90;
  }
LABEL_91:
  a1[1] = v47;
  unint64_t v57 = (unint64_t)a1[2];
  if ((unint64_t)v47 < v57)
  {
    *(void *)unint64_t v47 = 0x8D5EEF513BFB7EF4;
    *((void *)v47 + 1) = "md::ls::VisibilityTestResult]";
    *((void *)v47 + 2) = 28;
    unint64_t v58 = v47 + 24;
    goto LABEL_109;
  }
  unint64_t v59 = *a1;
  unint64_t v60 = 0xAAAAAAAAAAAAAAABLL * ((v47 - *a1) >> 3);
  unint64_t v61 = v60 + 1;
  if (v60 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_128;
  }
  unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v57 - (void)v59) >> 3);
  if (2 * v62 > v61) {
    unint64_t v61 = 2 * v62;
  }
  if (v62 >= 0x555555555555555) {
    unint64_t v63 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v63 = v61;
  }
  if (v63)
  {
    if (v63 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_129;
    }
    uint64_t v64 = (char *)operator new(24 * v63);
  }
  else
  {
    uint64_t v64 = 0;
  }
  unint64_t v65 = &v64[24 * v60];
  long long v66 = &v64[24 * v63];
  *(void *)unint64_t v65 = 0x8D5EEF513BFB7EF4;
  *((void *)v65 + 1) = "md::ls::VisibilityTestResult]";
  *((void *)v65 + 2) = 28;
  unint64_t v58 = v65 + 24;
  if (v47 == v59)
  {
    *a1 = v65;
    a1[1] = v58;
    a1[2] = v66;
LABEL_108:
    operator delete(v47);
    goto LABEL_109;
  }
  do
  {
    long long v67 = *(_OWORD *)(v47 - 24);
    *((void *)v65 - 1) = *((void *)v47 - 1);
    *(_OWORD *)(v65 - 24) = v67;
    v65 -= 24;
    v47 -= 24;
  }
  while (v47 != v59);
  unint64_t v47 = *a1;
  *a1 = v65;
  a1[1] = v58;
  a1[2] = v66;
  if (v47) {
    goto LABEL_108;
  }
LABEL_109:
  a1[1] = v58;
  unint64_t v68 = (unint64_t)a1[2];
  if ((unint64_t)v58 < v68)
  {
    *(void *)unint64_t v58 = 0x22E5462B4C348FD9;
    *((void *)v58 + 1) = "md::ls::ShouldSkipRender]";
    *((void *)v58 + 2) = 24;
    uint64_t v69 = v58 + 24;
    goto LABEL_127;
  }
  uint64_t v70 = *a1;
  unint64_t v71 = 0xAAAAAAAAAAAAAAABLL * ((v58 - *a1) >> 3);
  unint64_t v72 = v71 + 1;
  if (v71 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_128:
  }
    abort();
  unint64_t v73 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v68 - (void)v70) >> 3);
  if (2 * v73 > v72) {
    unint64_t v72 = 2 * v73;
  }
  if (v73 >= 0x555555555555555) {
    unint64_t v74 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v74 = v72;
  }
  if (v74)
  {
    if (v74 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v75 = (char *)operator new(24 * v74);
      goto LABEL_121;
    }
LABEL_129:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v75 = 0;
LABEL_121:
  unint64_t v76 = &v75[24 * v71];
  size_t v77 = &v75[24 * v74];
  *(void *)unint64_t v76 = 0x22E5462B4C348FD9;
  *((void *)v76 + 1) = "md::ls::ShouldSkipRender]";
  *((void *)v76 + 2) = 24;
  uint64_t v69 = v76 + 24;
  if (v58 == v70)
  {
    *a1 = v76;
    a1[1] = v69;
    a1[2] = v77;
LABEL_126:
    operator delete(v58);
    goto LABEL_127;
  }
  do
  {
    long long v78 = *(_OWORD *)(v58 - 24);
    *((void *)v76 - 1) = *((void *)v58 - 1);
    *(_OWORD *)(v76 - 24) = v78;
    v76 -= 24;
    v58 -= 24;
  }
  while (v58 != v70);
  unint64_t v58 = *a1;
  *a1 = v76;
  a1[1] = v69;
  a1[2] = v77;
  if (v58) {
    goto LABEL_126;
  }
LABEL_127:
  a1[1] = v69;
}

void sub_1A1BC9648(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssembleRenderItems>(md::ita::AssembleRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::AssembleRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssembleRenderItems>(md::ita::AssembleRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xD68EA0DE832DEC03;
  result[1] = "md::ls::RenderItemID]";
  result[2] = 20;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SortCommandBuffers>(md::ita::SortCommandBuffers &&)::{lambda(void)#1},std::allocator<md::ita::SortCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SortCommandBuffers>(md::ita::SortCommandBuffers &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SortCommandBuffers>(md::ita::SortCommandBuffers &&)::{lambda(void)#2},std::allocator<md::ita::SortCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SortCommandBuffers>(md::ita::SortCommandBuffers &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowSlice>(md::ita::PrepareShadowSlice &&)::{lambda(void)#1},std::allocator<md::ita::PrepareShadowSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowSlice>(md::ita::PrepareShadowSlice &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x78uLL);
  a1[2] = (char *)(v2 + 15);
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDE80;
  v2[4] = "md::ls::VisibilityGroupID]";
  v2[5] = 25;
  v2[6] = 0x8D203CEEEBEC82DELL;
  v2[7] = "md::ls::CanCastShadow]";
  v2[8] = 21;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 15)
  {
    *(void *)uint64_t v3 = 0x731F9AB6193E8641;
    v2[10] = "md::ls::SliceAssignmentT<md::SliceType::CulledMain>]";
    v2[11] = 51;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_38;
  }
  if (0x5555555555555556 * (((char *)(v2 + 15) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 15) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 15) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_39;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x731F9AB6193E8641;
  *((void *)v10 + 1) = "md::ls::SliceAssignmentT<md::SliceType::CulledMain>]";
  *((void *)v10 + 2) = 51;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0xFB8BCB8E983A05B1;
    *((void *)v4 + 1) = "md::ls::SliceAssignmentT<md::SliceType::CulledMainNotFiltered>]";
    *((void *)v4 + 2) = 62;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_38:
  }
    abort();
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v20 = (char *)operator new(24 * v19);
      goto LABEL_31;
    }
LABEL_39:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v20 = 0;
LABEL_31:
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0xFB8BCB8E983A05B1;
  *((void *)v21 + 1) = "md::ls::SliceAssignmentT<md::SliceType::CulledMainNotFiltered>]";
  *((void *)v21 + 2) = 62;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
}

void sub_1A1BC99F8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowSlice>(md::ita::PrepareShadowSlice &&)::{lambda(void)#2},std::allocator<md::ita::PrepareShadowSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowSlice>(md::ita::PrepareShadowSlice &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledSlice>(md::ita::PrepareCulledSlice &&)::{lambda(void)#1},std::allocator<md::ita::PrepareCulledSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledSlice>(md::ita::PrepareCulledSlice &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0xC0uLL);
  a1[2] = (char *)(v2 + 24);
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDEA0;
  v2[4] = "md::BoundData]";
  v2[5] = 13;
  v2[6] = 0x45B31C2960E9BCB1;
  v2[7] = "md::ls::VisibilityGroupID]";
  v2[8] = 25;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 24)
  {
    *(void *)uint64_t v3 = 0x5EBA003AC7A96B8ALL;
    v2[10] = "md::ls::SharedRenderableDataHandle]";
    v2[11] = 34;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  if (0x5555555555555556 * (((char *)(v2 + 24) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 24) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 24) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x5EBA003AC7A96B8ALL;
  *((void *)v10 + 1) = "md::ls::SharedRenderableDataHandle]";
  *((void *)v10 + 2) = 34;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x6CA90C12C415463ALL;
    *((void *)v4 + 1) = "md::ls::WantsCulledSlices]";
    *((void *)v4 + 2) = 25;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x6CA90C12C415463ALL;
  *((void *)v21 + 1) = "md::ls::WantsCulledSlices]";
  *((void *)v21 + 2) = 25;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0xEC2A00DC914732D7;
    *((void *)v14 + 1) = "md::ls::IntendedSceneLayer]";
    *((void *)v14 + 2) = 26;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0xEC2A00DC914732D7;
  *((void *)v32 + 1) = "md::ls::IntendedSceneLayer]";
  *((void *)v32 + 2) = 26;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0xD15AF44EFDE875A7;
    *((void *)v25 + 1) = "md::ls::SliceAssignmentT<md::SliceType::AllByPrimitiveAndVisibility>]";
    *((void *)v25 + 2) = 68;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_92;
  }
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    uint64_t v42 = (char *)operator new(24 * v41);
  }
  else
  {
    uint64_t v42 = 0;
  }
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0xD15AF44EFDE875A7;
  *((void *)v43 + 1) = "md::ls::SliceAssignmentT<md::SliceType::AllByPrimitiveAndVisibility>]";
  *((void *)v43 + 2) = 68;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
  unint64_t v46 = (unint64_t)a1[2];
  if ((unint64_t)v36 < v46)
  {
    *(void *)uint64_t v36 = 0x768C72EB9B71F7ADLL;
    *((void *)v36 + 1) = "md::ls::RenderableVisibilityOptions]";
    *((void *)v36 + 2) = 35;
    unint64_t v47 = v36 + 24;
    goto LABEL_91;
  }
  uint64_t v48 = *a1;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v36 - *a1) >> 3);
  unint64_t v50 = v49 + 1;
  if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_92:
  }
    abort();
  unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v48) >> 3);
  if (2 * v51 > v50) {
    unint64_t v50 = 2 * v51;
  }
  if (v51 >= 0x555555555555555) {
    unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v52 = v50;
  }
  if (v52)
  {
    if (v52 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v53 = (char *)operator new(24 * v52);
      goto LABEL_85;
    }
LABEL_93:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v53 = 0;
LABEL_85:
  uint64_t v54 = &v53[24 * v49];
  uint64_t v55 = &v53[24 * v52];
  *(void *)uint64_t v54 = 0x768C72EB9B71F7ADLL;
  *((void *)v54 + 1) = "md::ls::RenderableVisibilityOptions]";
  *((void *)v54 + 2) = 35;
  unint64_t v47 = v54 + 24;
  if (v36 == v48)
  {
    *a1 = v54;
    a1[1] = v47;
    a1[2] = v55;
LABEL_90:
    operator delete(v36);
    goto LABEL_91;
  }
  do
  {
    long long v56 = *(_OWORD *)(v36 - 24);
    *((void *)v54 - 1) = *((void *)v36 - 1);
    *(_OWORD *)(v54 - 24) = v56;
    v54 -= 24;
    v36 -= 24;
  }
  while (v36 != v48);
  uint64_t v36 = *a1;
  *a1 = v54;
  a1[1] = v47;
  a1[2] = v55;
  if (v36) {
    goto LABEL_90;
  }
LABEL_91:
  a1[1] = v47;
}

void sub_1A1BCA0A0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledSlice>(md::ita::PrepareCulledSlice &&)::{lambda(void)#2},std::allocator<md::ita::PrepareCulledSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledSlice>(md::ita::PrepareCulledSlice &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileViewData>(md::ita::AssignTileViewData &&)::{lambda(void)#1},std::allocator<md::ita::AssignTileViewData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileViewData>(md::ita::AssignTileViewData &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xCFE242268B958ADALL;
  v2[1] = "md::ls::ViewConstantDataHandle]";
  *(void *)&double result = 30;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDAB0;
  v2[4] = "md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::Tile::View>>]";
  v2[5] = 77;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::TransferPipelines>(md::ita::TransferPipelines &&)::{lambda(void)#1},std::allocator<md::ita::TransferPipelines &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::TransferPipelines>(md::ita::TransferPipelines &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x78uLL);
  a1[2] = (char *)(v2 + 15);
  *unint64_t v2 = 0xBBB17A4464CB2E03;
  v2[1] = "md::ls::PipelineSetupToApply]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDB00;
  v2[4] = "md::ls::DataIDSetToUse]";
  v2[5] = 22;
  v2[6] = 0xB160D04D0F4A35A4;
  v2[7] = "md::ls::PipelineState]";
  v2[8] = 21;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 15)
  {
    *(void *)uint64_t v3 = 0x52AC71251090DBDELL;
    v2[10] = "md::ls::RenderState]";
    v2[11] = 19;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_38;
  }
  if (0x5555555555555556 * (((char *)(v2 + 15) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 15) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 15) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_39;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x52AC71251090DBDELL;
  *((void *)v10 + 1) = "md::ls::RenderState]";
  *((void *)v10 + 2) = 19;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0xD68EA0DE832DEC03;
    *((void *)v4 + 1) = "md::ls::RenderItemID]";
    *((void *)v4 + 2) = 20;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_38:
  }
    abort();
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v20 = (char *)operator new(24 * v19);
      goto LABEL_31;
    }
LABEL_39:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v20 = 0;
LABEL_31:
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0xD68EA0DE832DEC03;
  *((void *)v21 + 1) = "md::ls::RenderItemID]";
  *((void *)v21 + 2) = 20;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
}

void sub_1A1BCA458(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::TransferPipelines>(md::ita::TransferPipelines &&)::{lambda(void)#2},std::allocator<md::ita::TransferPipelines &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::TransferPipelines>(md::ita::TransferPipelines &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStates>(md::ita::SetupRenderStates &&)::{lambda(void)#1},std::allocator<md::ita::SetupRenderStates &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStates>(md::ita::SetupRenderStates &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0x56D66E00519BD989;
  result[1] = "md::ls::NeedsNewRenderState]";
  result[2] = 27;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStates>(md::ita::SetupRenderStates &&)::{lambda(void)#2},std::allocator<md::ita::SetupRenderStates &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStates>(md::ita::SetupRenderStates &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#1},std::allocator<md::ita::PushLegacyRibbons &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xE57C2F66048E40BDLL;
  result[1] = "md::ls::RequireTypedRenderableForLegacyReasons<md::DaVinciGroundRenderable>]";
  result[2] = 75;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#2},std::allocator<md::ita::PushLegacyRibbons &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareShadowPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareShadowPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#1},std::allocator<md::ita::PrepareSSAOPasses &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#2},std::allocator<md::ita::PrepareSSAOPasses &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectParameters>(md::ita::CollectParameters &&)::{lambda(void)#1},std::allocator<md::ita::CollectParameters &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectParameters>(md::ita::CollectParameters &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0xA219A074B7259E0FLL;
  v2[1] = "md::ls::InView]";
  *(void *)&double result = 14;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD10;
  v2[4] = "md::ls::MeshRenderableID]";
  v2[5] = 24;
  v2[6] = 0xB6C12FBB402E8E70;
  v2[7] = "md::ls::RenderableMaterialData]";
  v2[8] = 30;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectParameters>(md::ita::CollectParameters &&)::{lambda(void)#2},std::allocator<md::ita::CollectParameters &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectParameters>(md::ita::CollectParameters &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderOrder>(md::ita::AssignRenderOrder &&)::{lambda(void)#1},std::allocator<md::ita::AssignRenderOrder &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderOrder>(md::ita::AssignRenderOrder &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0xD8uLL);
  a1[2] = (char *)(v2 + 27);
  *unint64_t v2 = 0x76B9BA390004E44ELL;
  v2[1] = "md::ls::IsDecal]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDB70;
  v2[4] = "md::ls::RenderItemID]";
  v2[5] = 20;
  v2[6] = 0x3E8485C60908F920;
  v2[7] = "md::ls::IsMaterial]";
  v2[8] = 18;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 27)
  {
    *(void *)uint64_t v3 = 0x3EAAB620EAA88EC8;
    v2[10] = "md::ls::CustomZIndex]";
    v2[11] = 20;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_110;
  }
  if (0x5555555555555556 * (((char *)(v2 + 27) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 27) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 27) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_111;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x3EAAB620EAA88EC8;
  *((void *)v10 + 1) = "md::ls::CustomZIndex]";
  *((void *)v10 + 2) = 20;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x7087983DEF28DBFELL;
    *((void *)v4 + 1) = "md::ls::IsOpaque]";
    *((void *)v4 + 2) = 16;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_110;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_111;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x7087983DEF28DBFELL;
  *((void *)v21 + 1) = "md::ls::IsOpaque]";
  *((void *)v21 + 2) = 16;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0x763953A644184BA9;
    *((void *)v14 + 1) = "md::ls::RenderableHash]";
    *((void *)v14 + 2) = 22;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_110;
  }
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_111;
    }
    uint64_t v31 = (char *)operator new(24 * v30);
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0x763953A644184BA9;
  *((void *)v32 + 1) = "md::ls::RenderableHash]";
  *((void *)v32 + 2) = 22;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
  unint64_t v35 = (unint64_t)a1[2];
  if ((unint64_t)v25 < v35)
  {
    *(void *)size_t v25 = 0x9705908F280836EDLL;
    *((void *)v25 + 1) = "md::ls::SharedMaterialZIndexHandle]";
    *((void *)v25 + 2) = 34;
    uint64_t v36 = v25 + 24;
    goto LABEL_73;
  }
  unint64_t v37 = *a1;
  unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *a1) >> 3);
  unint64_t v39 = v38 + 1;
  if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_110;
  }
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - (void)v37) >> 3);
  if (2 * v40 > v39) {
    unint64_t v39 = 2 * v40;
  }
  if (v40 >= 0x555555555555555) {
    unint64_t v41 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    if (v41 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_111;
    }
    uint64_t v42 = (char *)operator new(24 * v41);
  }
  else
  {
    uint64_t v42 = 0;
  }
  uint64_t v43 = &v42[24 * v38];
  unint64_t v44 = &v42[24 * v41];
  *(void *)uint64_t v43 = 0x9705908F280836EDLL;
  *((void *)v43 + 1) = "md::ls::SharedMaterialZIndexHandle]";
  *((void *)v43 + 2) = 34;
  uint64_t v36 = v43 + 24;
  if (v25 == v37)
  {
    *a1 = v43;
    a1[1] = v36;
    a1[2] = v44;
LABEL_72:
    operator delete(v25);
    goto LABEL_73;
  }
  do
  {
    long long v45 = *(_OWORD *)(v25 - 24);
    *((void *)v43 - 1) = *((void *)v25 - 1);
    *(_OWORD *)(v43 - 24) = v45;
    v43 -= 24;
    v25 -= 24;
  }
  while (v25 != v37);
  size_t v25 = *a1;
  *a1 = v43;
  a1[1] = v36;
  a1[2] = v44;
  if (v25) {
    goto LABEL_72;
  }
LABEL_73:
  a1[1] = v36;
  unint64_t v46 = (unint64_t)a1[2];
  if ((unint64_t)v36 < v46)
  {
    *(void *)uint64_t v36 = 0x3EB2A2A09E298E0ELL;
    *((void *)v36 + 1) = "md::ls::IntendedStandardPassShadow]";
    *((void *)v36 + 2) = 34;
    unint64_t v47 = v36 + 24;
    goto LABEL_91;
  }
  uint64_t v48 = *a1;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v36 - *a1) >> 3);
  unint64_t v50 = v49 + 1;
  if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_110;
  }
  unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v48) >> 3);
  if (2 * v51 > v50) {
    unint64_t v50 = 2 * v51;
  }
  if (v51 >= 0x555555555555555) {
    unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v52 = v50;
  }
  if (v52)
  {
    if (v52 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_111;
    }
    uint64_t v53 = (char *)operator new(24 * v52);
  }
  else
  {
    uint64_t v53 = 0;
  }
  uint64_t v54 = &v53[24 * v49];
  uint64_t v55 = &v53[24 * v52];
  *(void *)uint64_t v54 = 0x3EB2A2A09E298E0ELL;
  *((void *)v54 + 1) = "md::ls::IntendedStandardPassShadow]";
  *((void *)v54 + 2) = 34;
  unint64_t v47 = v54 + 24;
  if (v36 == v48)
  {
    *a1 = v54;
    a1[1] = v47;
    a1[2] = v55;
LABEL_90:
    operator delete(v36);
    goto LABEL_91;
  }
  do
  {
    long long v56 = *(_OWORD *)(v36 - 24);
    *((void *)v54 - 1) = *((void *)v36 - 1);
    *(_OWORD *)(v54 - 24) = v56;
    v54 -= 24;
    v36 -= 24;
  }
  while (v36 != v48);
  uint64_t v36 = *a1;
  *a1 = v54;
  a1[1] = v47;
  a1[2] = v55;
  if (v36) {
    goto LABEL_90;
  }
LABEL_91:
  a1[1] = v47;
  unint64_t v57 = (unint64_t)a1[2];
  if ((unint64_t)v47 < v57)
  {
    *(void *)unint64_t v47 = 0xE7D1C5E790E8E07;
    *((void *)v47 + 1) = "md::ls::IntendedStandardPassSceneDepth]";
    *((void *)v47 + 2) = 38;
    unint64_t v58 = v47 + 24;
    goto LABEL_109;
  }
  unint64_t v59 = *a1;
  unint64_t v60 = 0xAAAAAAAAAAAAAAABLL * ((v47 - *a1) >> 3);
  unint64_t v61 = v60 + 1;
  if (v60 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_110:
  }
    abort();
  unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v57 - (void)v59) >> 3);
  if (2 * v62 > v61) {
    unint64_t v61 = 2 * v62;
  }
  if (v62 >= 0x555555555555555) {
    unint64_t v63 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v63 = v61;
  }
  if (v63)
  {
    if (v63 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v64 = (char *)operator new(24 * v63);
      goto LABEL_103;
    }
LABEL_111:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v64 = 0;
LABEL_103:
  unint64_t v65 = &v64[24 * v60];
  long long v66 = &v64[24 * v63];
  *(void *)unint64_t v65 = 0xE7D1C5E790E8E07;
  *((void *)v65 + 1) = "md::ls::IntendedStandardPassSceneDepth]";
  *((void *)v65 + 2) = 38;
  unint64_t v58 = v65 + 24;
  if (v47 == v59)
  {
    *a1 = v65;
    a1[1] = v58;
    a1[2] = v66;
LABEL_108:
    operator delete(v47);
    goto LABEL_109;
  }
  do
  {
    long long v67 = *(_OWORD *)(v47 - 24);
    *((void *)v65 - 1) = *((void *)v47 - 1);
    *(_OWORD *)(v65 - 24) = v67;
    v65 -= 24;
    v47 -= 24;
  }
  while (v47 != v59);
  unint64_t v47 = *a1;
  *a1 = v65;
  a1[1] = v58;
  a1[2] = v66;
  if (v47) {
    goto LABEL_108;
  }
LABEL_109:
  a1[1] = v58;
}

void sub_1A1BCADD0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderOrder>(md::ita::AssignRenderOrder &&)::{lambda(void)#2},std::allocator<md::ita::AssignRenderOrder &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderOrder>(md::ita::AssignRenderOrder &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x78uLL);
  *unint64_t v2 = 0x9158B59D97A4E38DLL;
  v2[1] = "md::ls::RenderOrderToUse]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDC50;
  v2[4] = "md::ls::RenderOrderToUse]";
  v2[5] = 24;
  v2[6] = 0x9158B59D97A4E38DLL;
  v2[7] = "md::ls::RenderOrderToUse]";
  v2[8] = 24;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  a1[2] = (char *)(v2 + 15);
  if (v2 + 9 < v2 + 15)
  {
    *(void *)uint64_t v3 = 0x9158B59D97A4E38DLL;
    v2[10] = "md::ls::RenderOrderToUse]";
    v2[11] = 24;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_38;
  }
  if (0x5555555555555556 * (((char *)(v2 + 15) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 15) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 15) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_39;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x9158B59D97A4E38DLL;
  *((void *)v10 + 1) = "md::ls::RenderOrderToUse]";
  *((void *)v10 + 2) = 24;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x9158B59D97A4E38DLL;
    *((void *)v4 + 1) = "md::ls::RenderOrderToUse]";
    *((void *)v4 + 2) = 24;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_38:
  }
    abort();
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v20 = (char *)operator new(24 * v19);
      goto LABEL_31;
    }
LABEL_39:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v20 = 0;
LABEL_31:
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x9158B59D97A4E38DLL;
  *((void *)v21 + 1) = "md::ls::RenderOrderToUse]";
  *((void *)v21 + 2) = 24;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
}

void sub_1A1BCB084(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSlice>(md::ita::PrepareMainSlice &&)::{lambda(void)#1},std::allocator<md::ita::PrepareMainSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSlice>(md::ita::PrepareMainSlice &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDE80;
  v2[4] = "md::ls::VisibilityGroupID]";
  v2[5] = 25;
  v2[6] = 0x50A14E0778169E99;
  v2[7] = "md::ls::IgnoreCulling]";
  v2[8] = 21;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)uint64_t v3 = 0xD15AF44EFDE875A7;
    v2[10] = "md::ls::SliceAssignmentT<md::SliceType::AllByPrimitiveAndVisibility>]";
    v2[11] = 68;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xD15AF44EFDE875A7;
  *((void *)v10 + 1) = "md::ls::SliceAssignmentT<md::SliceType::AllByPrimitiveAndVisibility>]";
  *((void *)v10 + 2) = 68;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BCB288(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSlice>(md::ita::PrepareMainSlice &&)::{lambda(void)#2},std::allocator<md::ita::PrepareMainSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSlice>(md::ita::PrepareMainSlice &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutTask>(md::ita::LegacyLayoutTask &&)::{lambda(void)#1},std::allocator<md::ita::LegacyLayoutTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutTask>(md::ita::LegacyLayoutTask &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutTask>(md::ita::LegacyLayoutTask &&)::{lambda(void)#2},std::allocator<md::ita::LegacyLayoutTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutTask>(md::ita::LegacyLayoutTask &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectColorData>(md::ita::CollectColorData &&)::{lambda(void)#2},std::allocator<md::ita::CollectColorData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectColorData>(md::ita::CollectColorData &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x60915CB292001F47;
  v2[1] = "md::ls::UniqueColorDataHandle]";
  *(void *)&double result = 29;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDDE0;
  v2[4] = "md::ls::SharedColorDataHandle]";
  v2[5] = 29;
  v2[6] = 0xA3F884E4E2541296;
  v2[7] = "md::ls::ColorDataHandle]";
  v2[8] = 23;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushRenderItems>(md::ita::PushRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::PushRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushRenderItems>(md::ita::PushRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xD68EA0DE832DEC03;
  v2[1] = "md::ls::RenderItemID]";
  *(void *)&double result = 20;
  *((_OWORD *)v2 + 1) = xmmword_1A28FD810;
  v2[4] = "md::ls::ItemsPrepared]";
  v2[5] = 21;
  *a1 = v2;
  return result;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushRenderItems>(md::ita::PushRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::PushRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushRenderItems>(md::ita::PushRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xE74BE2A9DD9BA5F1;
  result[1] = "md::ls::CommandBufferRef]";
  result[2] = 24;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareMainPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareMainPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::OnLayoutEndTask>(md::ita::OnLayoutEndTask &&)::{lambda(void)#1},std::allocator<md::ita::OnLayoutEndTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::OnLayoutEndTask>(md::ita::OnLayoutEndTask &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::OnLayoutEndTask>(md::ita::OnLayoutEndTask &&)::{lambda(void)#2},std::allocator<md::ita::OnLayoutEndTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::OnLayoutEndTask>(md::ita::OnLayoutEndTask &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelines>(md::ita::CreatePipelines &&)::{lambda(void)#1},std::allocator<md::ita::CreatePipelines &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelines>(md::ita::CreatePipelines &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0xD68EA0DE832DEC03;
  v2[1] = "md::ls::RenderItemID]";
  *(void *)&double result = 20;
  *((_OWORD *)v2 + 1) = xmmword_1A28FDB60;
  v2[4] = "md::ls::RequiredPipelinePoolID]";
  v2[5] = 30;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelines>(md::ita::CreatePipelines &&)::{lambda(void)#2},std::allocator<md::ita::CreatePipelines &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelines>(md::ita::CreatePipelines &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyAlbedoTint>(md::ita::ApplyAlbedoTint &&)::{lambda(void)#1},std::allocator<md::ita::ApplyAlbedoTint &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyAlbedoTint>(md::ita::ApplyAlbedoTint &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x60uLL);
  a1[2] = (char *)(v2 + 12);
  *unint64_t v2 = 0xA219A074B7259E0FLL;
  v2[1] = "md::ls::InView]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD20;
  v2[4] = "md::ls::SharedColorDataHandle]";
  v2[5] = 29;
  v2[6] = 0x60915CB292001F47;
  v2[7] = "md::ls::UniqueColorDataHandle]";
  v2[8] = 29;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 12)
  {
    *(void *)uint64_t v3 = 0x2906BE24995F2F60;
    v2[10] = "md::ls::AlbedoTintColor]";
    v2[11] = 23;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 12) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 12) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x2906BE24995F2F60;
  *((void *)v10 + 1) = "md::ls::AlbedoTintColor]";
  *((void *)v10 + 2) = 23;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
}

void sub_1A1BCB6C8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyAlbedoTint>(md::ita::ApplyAlbedoTint &&)::{lambda(void)#2},std::allocator<md::ita::ApplyAlbedoTint &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyAlbedoTint>(md::ita::ApplyAlbedoTint &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xA3F884E4E2541296;
  result[1] = "md::ls::ColorDataHandle]";
  result[2] = 23;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSlices>(md::ita::PrepareSlices &&)::{lambda(void)#1},std::allocator<md::ita::PrepareSlices &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSlices>(md::ita::PrepareSlices &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x90uLL);
  a1[2] = (char *)(v2 + 18);
  *unint64_t v2 = 0x8DCCA4FD35258189;
  v2[1] = "md::ls::MeshRenderableID]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDF00;
  v2[4] = "md::ls::PrimitiveType]";
  v2[5] = 21;
  v2[6] = 0xA83B1A8F06D3B3DBLL;
  v2[7] = "md::ls::SharedMaterialVisibilityOptionsHandle]";
  v2[8] = 45;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 18)
  {
    *(void *)uint64_t v3 = 0x768C72EB9B71F7ADLL;
    v2[10] = "md::ls::RenderableVisibilityOptions]";
    v2[11] = 35;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_56;
  }
  if (0x5555555555555556 * (((char *)(v2 + 18) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 18) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 18) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_57;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0x768C72EB9B71F7ADLL;
  *((void *)v10 + 1) = "md::ls::RenderableVisibilityOptions]";
  *((void *)v10 + 2) = 35;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0x66C5B6134E34F45DLL;
    *((void *)v4 + 1) = "md::ls::MarketMask]";
    *((void *)v4 + 2) = 18;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_56;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_57;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0x66C5B6134E34F45DLL;
  *((void *)v21 + 1) = "md::ls::MarketMask]";
  *((void *)v21 + 2) = 18;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0x849CB194B84BB63DLL;
    *((void *)v14 + 1) = "md::ls::UniqueMaterialVisibilityOptionsHandle]";
    *((void *)v14 + 2) = 45;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_56:
  }
    abort();
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v31 = (char *)operator new(24 * v30);
      goto LABEL_49;
    }
LABEL_57:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v31 = 0;
LABEL_49:
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0x849CB194B84BB63DLL;
  *((void *)v32 + 1) = "md::ls::UniqueMaterialVisibilityOptionsHandle]";
  *((void *)v32 + 2) = 45;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
}

void sub_1A1BCBB7C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSlices>(md::ita::PrepareSlices &&)::{lambda(void)#2},std::allocator<md::ita::PrepareSlices &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSlices>(md::ita::PrepareSlices &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfOpaque>(md::ita::CheckIfOpaque &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfOpaque &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfOpaque>(md::ita::CheckIfOpaque &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(char **a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x90uLL);
  a1[2] = (char *)(v2 + 18);
  *unint64_t v2 = 0xA219A074B7259E0FLL;
  v2[1] = "md::ls::InView]";
  *((_OWORD *)v2 + 1) = xmmword_1A28FDD10;
  v2[4] = "md::ls::MeshRenderableID]";
  v2[5] = 24;
  v2[6] = 0x20D1AB8FE4B8A761;
  v2[7] = "md::ls::CanEnableTexture]";
  v2[8] = 24;
  uint64_t v3 = (char *)(v2 + 9);
  *a1 = (char *)v2;
  a1[1] = (char *)(v2 + 9);
  if (v2 + 9 < v2 + 18)
  {
    *(void *)uint64_t v3 = 0xA3F884E4E2541296;
    v2[10] = "md::ls::ColorDataHandle]";
    v2[11] = 23;
    uint64_t v4 = (char *)(v2 + 12);
    goto LABEL_19;
  }
  uint64_t v5 = *a1;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_56;
  }
  if (0x5555555555555556 * (((char *)(v2 + 18) - v5) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * (((char *)(v2 + 18) - v5) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)(v2 + 18) - v5) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_57;
    }
    id v9 = (char *)operator new(24 * v8);
  }
  else
  {
    id v9 = 0;
  }
  uint64_t v10 = &v9[24 * v6];
  unint64_t v11 = &v9[24 * v8];
  *(void *)uint64_t v10 = 0xA3F884E4E2541296;
  *((void *)v10 + 1) = "md::ls::ColorDataHandle]";
  *((void *)v10 + 2) = 23;
  uint64_t v4 = v10 + 24;
  if (v3 == v5)
  {
    *a1 = v10;
    a1[1] = v4;
    a1[2] = v11;
LABEL_18:
    operator delete(v3);
    goto LABEL_19;
  }
  do
  {
    uint64_t v12 = *((void *)v3 - 1);
    *(_OWORD *)(v10 - 24) = *(_OWORD *)(v3 - 24);
    *((void *)v10 - 1) = v12;
    v10 -= 24;
    v3 -= 24;
  }
  while (v3 != v5);
  uint64_t v3 = *a1;
  *a1 = v10;
  a1[1] = v4;
  a1[2] = v11;
  if (v3) {
    goto LABEL_18;
  }
LABEL_19:
  a1[1] = v4;
  unint64_t v13 = (unint64_t)a1[2];
  if ((unint64_t)v4 < v13)
  {
    *(void *)uint64_t v4 = 0xB6C12FBB402E8E70;
    *((void *)v4 + 1) = "md::ls::RenderableMaterialData]";
    *((void *)v4 + 2) = 30;
    float v14 = v4 + 24;
    goto LABEL_37;
  }
  BOOL v15 = *a1;
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v17 = v16 + 1;
  if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_56;
  }
  unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v15) >> 3);
  if (2 * v18 > v17) {
    unint64_t v17 = 2 * v18;
  }
  if (v18 >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v17;
  }
  if (v19)
  {
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_57;
    }
    uint64_t v20 = (char *)operator new(24 * v19);
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = &v20[24 * v16];
  long long v22 = &v20[24 * v19];
  *(void *)uint64_t v21 = 0xB6C12FBB402E8E70;
  *((void *)v21 + 1) = "md::ls::RenderableMaterialData]";
  *((void *)v21 + 2) = 30;
  float v14 = v21 + 24;
  if (v4 == v15)
  {
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v22;
LABEL_36:
    operator delete(v4);
    goto LABEL_37;
  }
  do
  {
    uint64_t v23 = *((void *)v4 - 1);
    *(_OWORD *)(v21 - 24) = *(_OWORD *)(v4 - 24);
    *((void *)v21 - 1) = v23;
    v21 -= 24;
    v4 -= 24;
  }
  while (v4 != v15);
  uint64_t v4 = *a1;
  *a1 = v21;
  a1[1] = v14;
  a1[2] = v22;
  if (v4) {
    goto LABEL_36;
  }
LABEL_37:
  a1[1] = v14;
  unint64_t v24 = (unint64_t)a1[2];
  if ((unint64_t)v14 < v24)
  {
    *(void *)float v14 = 0xE40027D1222182B5;
    *((void *)v14 + 1) = "md::ls::HasOverlayPatch]";
    *((void *)v14 + 2) = 23;
    size_t v25 = v14 + 24;
    goto LABEL_55;
  }
  size_t v26 = *a1;
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v14 - *a1) >> 3);
  unint64_t v28 = v27 + 1;
  if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_56:
  }
    abort();
  unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (void)v26) >> 3);
  if (2 * v29 > v28) {
    unint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x555555555555555) {
    unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v30 = v28;
  }
  if (v30)
  {
    if (v30 <= 0xAAAAAAAAAAAAAAALL)
    {
      uint64_t v31 = (char *)operator new(24 * v30);
      goto LABEL_49;
    }
LABEL_57:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v31 = 0;
LABEL_49:
  uint64_t v32 = &v31[24 * v27];
  uint64_t v33 = &v31[24 * v30];
  *(void *)uint64_t v32 = 0xE40027D1222182B5;
  *((void *)v32 + 1) = "md::ls::HasOverlayPatch]";
  *((void *)v32 + 2) = 23;
  size_t v25 = v32 + 24;
  if (v14 == v26)
  {
    *a1 = v32;
    a1[1] = v25;
    a1[2] = v33;
LABEL_54:
    operator delete(v14);
    goto LABEL_55;
  }
  do
  {
    long long v34 = *(_OWORD *)(v14 - 24);
    *((void *)v32 - 1) = *((void *)v14 - 1);
    *(_OWORD *)(v32 - 24) = v34;
    v32 -= 24;
    v14 -= 24;
  }
  while (v14 != v26);
  float v14 = *a1;
  *a1 = v32;
  a1[1] = v25;
  a1[2] = v33;
  if (v14) {
    goto LABEL_54;
  }
LABEL_55:
  a1[1] = v25;
}

void sub_1A1BCBFD8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfOpaque>(md::ita::CheckIfOpaque &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfOpaque &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfOpaque>(md::ita::CheckIfOpaque &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::erq::EncodeRenderQueue>(md::erq::EncodeRenderQueue &&)::{lambda(void)#1},std::allocator<md::erq::EncodeRenderQueue &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::erq::EncodeRenderQueue>(md::erq::EncodeRenderQueue &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  unint64_t v2 = operator new(0x48uLL);
  a1[2] = v2 + 9;
  *unint64_t v2 = 0x17922920A08D336CLL;
  v2[1] = "md::erq::RenderQueueToSubmit]";
  *(void *)&double result = 28;
  *((_OWORD *)v2 + 1) = xmmword_1A28FE880;
  v2[4] = "md::erq::RenderTargetToSubmit]";
  v2[5] = 29;
  v2[6] = 0x3D9415B0404B6523;
  v2[7] = "md::erq::GPUWorkCallbacks]";
  v2[8] = 25;
  *a1 = v2;
  a1[1] = v2 + 9;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::erq::EncodeRenderQueue>(md::erq::EncodeRenderQueue &&)::{lambda(void)#2},std::allocator<md::erq::EncodeRenderQueue &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::erq::EncodeRenderQueue>(md::erq::EncodeRenderQueue &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupMeshRendererLayout>(CleanupMeshRendererLayout &&)::{lambda(void)#2},std::allocator<CleanupMeshRendererLayout &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupMeshRendererLayout>(CleanupMeshRendererLayout &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForRender>(PrepareFrameForRender &&)::{lambda(void)#1},std::allocator<PrepareFrameForRender &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForRender>(PrepareFrameForRender &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

double std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#1},std::allocator<PrepareFrameForEncode &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<D0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v2 = operator new(0x30uLL);
  a1[1] = v2 + 6;
  a1[2] = v2 + 6;
  *unint64_t v2 = 0x8004EB719AAADA5BLL;
  v2[1] = "md::ita::FrameHandle]";
  *(void *)&double result = 20;
  *((_OWORD *)v2 + 1) = xmmword_1A28FE990;
  v2[4] = "md::ls::RenderTargetToPrepare]";
  v2[5] = 29;
  *a1 = v2;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#2},std::allocator<PrepareFrameForEncode &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#1},std::allocator<CleanupEntities &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#1}<gdc>> ()(void)>::operator()@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double result = operator new(0x18uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *double result = 0xC3545FB0365E4B12;
  result[1] = "md::ls::MarkForEntityDeletion]";
  result[2] = 29;
  *a1 = result;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#2},std::allocator<CleanupEntities &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_1,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  unint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(v1 + 1216);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "InitMapEngine", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::LightingLogic::LightingLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::LightingLogic::LightingLogic(NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,BOOL ()(BOOL const&)>::operator()(uint64_t a1, unsigned char *a2)
{
  if (*a2) {
    return MEMORY[0x1F411C478]();
  }
  else {
    return 0;
  }
}

uint64_t std::__function::__func<md::MeshRendererModule,std::allocator<md::MeshRendererModule>,ecs2::ModuleDescriptor ()(void)>::operator()@<X0>(uint64_t a1@<X8>)
{
  return md::MeshRendererModule::operator()(a1);
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_26,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_26>,void ()(long long)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF520FF0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_20,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_20>,void ()(VKNavigationPuckLocationTracingEvent *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579D10;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::GlobeGridBoundsProvider::boundsQuery(void)::{lambda(geo::QuadTile const&)#1},std::allocator<md::GlobeGridBoundsProvider::boundsQuery(void)::{lambda(geo::QuadTile const&)#1}>,geo::optional<gm::Range<double>> ()(geo::QuadTile const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51EBF0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_4,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_4>,geo::optional<gm::Range<double>> ()(geo::QuadTile const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5741F0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_0,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_0>,geo::optional<gm::Range<double>> ()(geo::QuadTile const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF574160;
  a2[1] = v2;
  return result;
}

void ecs2::FlowDescriptor::~FlowDescriptor(ecs2::FlowDescriptor *this)
{
  uint64_t v2 = *((void *)this + 9);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 10);
    os_signpost_id_t v4 = (void *)*((void *)this + 9);
    if (v3 != v2)
    {
      uint64_t v5 = v3 - 56;
      do
      {
        if (*(char *)(v3 - 1) < 0) {
          operator delete(*(void **)(v3 - 24));
        }
        uint64_t v6 = *(void *)(v3 - 32);
        if (v3 - 56 == v6)
        {
          (*(void (**)(uint64_t))(*(void *)(v3 - 56) + 32))(v3 - 56);
        }
        else if (v6)
        {
          (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
        }
        v3 -= 72;
        v5 -= 72;
      }
      while (v3 != v2);
      os_signpost_id_t v4 = (void *)*((void *)this + 9);
    }
    *((void *)this + 10) = v2;
    operator delete(v4);
  }
  uint64_t v7 = *((void *)this + 6);
  if (v7)
  {
    uint64_t v8 = *((void *)this + 7);
    id v9 = (void *)*((void *)this + 6);
    if (v8 != v7)
    {
      uint64_t v10 = *((void *)this + 7);
      do
      {
        uint64_t v12 = *(void **)(v10 - 24);
        v10 -= 24;
        unint64_t v11 = v12;
        if (v12)
        {
          *(void *)(v8 - 16) = v11;
          operator delete(v11);
        }
        uint64_t v8 = v10;
      }
      while (v10 != v7);
      id v9 = (void *)*((void *)this + 6);
    }
    *((void *)this + 7) = v7;
    operator delete(v9);
  }
  uint64_t v13 = *((void *)this + 3);
  if (v13)
  {
    uint64_t v14 = *((void *)this + 4);
    BOOL v15 = (void *)*((void *)this + 3);
    if (v14 != v13)
    {
      do
      {
        v14 -= 64;
        std::__destroy_at[abi:nn180100]<ecs2::BucketDescriptor,0>(v14);
      }
      while (v14 != v13);
      BOOL v15 = (void *)*((void *)this + 3);
    }
    *((void *)this + 4) = v13;
    operator delete(v15);
  }
  if (*((char *)this + 23) < 0) {
    operator delete(*(void **)this);
  }
}

void geo::concurrent_queue_base<std::function<void ()(void)>,geo::BasicStoragePolicy<std::function<void ()(void)>>>::close(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  *(unsigned char *)a1 = 1;
  if (*(void *)(a1 + 160))
  {
    unint64_t v3 = *(void *)(a1 + 152);
    do
    {
      os_signpost_id_t v4 = (void *)(*(void *)(*(void *)(a1 + 128) + ((v3 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v3 & 0x7F));
      uint64_t v5 = (void *)v4[3];
      if (v5 == v4)
      {
        (*(void (**)(void *))(*v4 + 32))(v4);
      }
      else if (v5)
      {
        (*(void (**)(void *))(*v5 + 40))(v5);
      }
      uint64_t v6 = *(void *)(a1 + 160) - 1;
      unint64_t v3 = *(void *)(a1 + 152) + 1;
      *(void *)(a1 + 152) = v3;
      *(void *)(a1 + 160) = v6;
      if (v3 >= 0x100)
      {
        operator delete(**(void ***)(a1 + 128));
        *(void *)(a1 + 128) += 8;
        uint64_t v6 = *(void *)(a1 + 160);
        unint64_t v3 = *(void *)(a1 + 152) - 128;
        *(void *)(a1 + 152) = v3;
      }
    }
    while (v6);
  }
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 72));
  std::mutex::unlock(v2);
}

void geo::small_vector_base<unsigned short>::insert(char **a1, char *a2, _WORD *a3)
{
  uint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  uint64_t v7 = (a2 - *a1) >> 1;
  if (v5 == a2)
  {
    unint64_t v27 = (unint64_t)a1[3];
    if (v27 >= v7 + 1)
    {
LABEL_41:
      *(_WORD *)a2 = *a3;
      a1[1] = a2 + 2;
      return;
    }
    unint64_t v28 = a1[2];
    unint64_t v29 = (1 << -(char)__clz(v27 + 1));
    if (v27 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v30 = 1;
    }
    else {
      unint64_t v30 = v29;
    }
    if (v30 <= v7 + 1) {
      unint64_t v31 = v7 + 1;
    }
    else {
      unint64_t v31 = v30;
    }
    uint64_t v32 = (char *)malloc_type_malloc(2 * v31, 0x1000040BDFB0063uLL);
    uint64_t v33 = *a1;
    long long v34 = a1[1];
    if (*a1 != v34)
    {
      unint64_t v35 = v34 - v33 - 2;
      uint64_t v36 = v32;
      unint64_t v37 = *a1;
      if (v35 >= 0x1E)
      {
        uint64_t v36 = v32;
        unint64_t v37 = *a1;
        if ((unint64_t)(v32 - v33) >= 0x20)
        {
          uint64_t v38 = (v35 >> 1) + 1;
          unint64_t v39 = 2 * (v38 & 0xFFFFFFFFFFFFFFF0);
          uint64_t v36 = &v32[v39];
          unint64_t v40 = (long long *)(v33 + 16);
          unint64_t v41 = v32 + 16;
          unint64_t v42 = v38 & 0xFFFFFFFFFFFFFFF0;
          do
          {
            long long v43 = *v40;
            *(v41 - 1) = *(v40 - 1);
            *unint64_t v41 = v43;
            v40 += 2;
            v41 += 2;
            v42 -= 16;
          }
          while (v42);
          if (v38 == (v38 & 0xFFFFFFFFFFFFFFF0)) {
            goto LABEL_38;
          }
          unint64_t v37 = &v33[v39];
        }
      }
      do
      {
        __int16 v44 = *(_WORD *)v37;
        v37 += 2;
        *(_WORD *)uint64_t v36 = v44;
        v36 += 2;
      }
      while (v37 != v34);
    }
LABEL_38:
    if (v6 != v28) {
      free(v33);
    }
    *a1 = v32;
    a2 = &v32[2 * v7];
    a1[3] = (char *)v31;
    goto LABEL_41;
  }
  uint64_t v8 = &v6[2 * v7];
  uint64_t v9 = (v5 - v6) >> 1;
  if ((char *)v9 == a1[3])
  {
    uint64_t v10 = a1[2];
    unint64_t v11 = (1 << -(char)__clz(v9 + 1));
    if ((unint64_t)(v5 - v6) >= 0xFFFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 1;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12 <= v9 + 1) {
      unint64_t v13 = v9 + 1;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v14 = (char *)malloc_type_malloc(2 * v13, 0x1000040BDFB0063uLL);
    BOOL v15 = *a1;
    unint64_t v16 = a1[1];
    if (*a1 == v16) {
      goto LABEL_17;
    }
    unint64_t v17 = v16 - v15 - 2;
    unint64_t v18 = v14;
    unint64_t v19 = *a1;
    if (v17 >= 0x1E)
    {
      unint64_t v18 = v14;
      unint64_t v19 = *a1;
      if ((unint64_t)(v14 - v15) >= 0x20)
      {
        uint64_t v20 = (v17 >> 1) + 1;
        unint64_t v21 = 2 * (v20 & 0xFFFFFFFFFFFFFFF0);
        unint64_t v18 = &v14[v21];
        long long v22 = (long long *)(v15 + 16);
        uint64_t v23 = v14 + 16;
        unint64_t v24 = v20 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          long long v25 = *v22;
          *(v23 - 1) = *(v22 - 1);
          _OWORD *v23 = v25;
          v22 += 2;
          v23 += 2;
          v24 -= 16;
        }
        while (v24);
        if (v20 == (v20 & 0xFFFFFFFFFFFFFFF0)) {
          goto LABEL_17;
        }
        unint64_t v19 = &v15[v21];
      }
    }
    do
    {
      __int16 v26 = *(_WORD *)v19;
      v19 += 2;
      *(_WORD *)unint64_t v18 = v26;
      v18 += 2;
    }
    while (v19 != v16);
LABEL_17:
    if (v6 != v10) {
      free(v15);
    }
    *a1 = v14;
    uint64_t v5 = &v14[2 * v9];
    a1[3] = (char *)v13;
  }
  a1[1] = v5 + 2;
  if (v5 != v8) {
    memmove(v8 + 2, v8, v5 - v8);
  }
  *(_WORD *)uint64_t v8 = *a3;
}

void md::Renderer::Renderer(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5)
{
  id v9 = a3;
  *(void *)a1 = &unk_1EF553E08;
  uint64_t v10 = a4[1];
  *(void *)(a1 + 8) = *a4;
  *(void *)(a1 + 16) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = a2;
  *(void *)(a1 + 96) = a5;
  *(void *)(a1 + 104) = v9;
  operator new();
}

void sub_1A1BCCAC0(_Unwind_Exception *a1)
{
  uint64_t v8 = *(void **)(v1 + 64);
  if (v8)
  {
    *(void *)(v1 + 72) = v8;
    operator delete(v8);
  }
  std::vector<std::unique_ptr<md::RenderLayer>>::~vector[abi:nn180100](v5);
  std::unique_ptr<md::FrameGraphResourceRegistry>::~unique_ptr[abi:nn180100](v3);
  uint64_t v9 = *v6;
  uint64_t *v6 = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v4);

  _Unwind_Resume(a1);
}

void md::World::setPreferredUnits(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 24) + 56);
  *(unsigned char *)(a1 + 392) = a2;
  uint64_t v4 = *(void *)(v3 + 32);
  uint64_t v5 = *(void *)(v3 + 40);
  if (v4 != v5)
  {
    while (*(_WORD *)v4 != 44)
    {
      v4 += 16;
      if (v4 == v5) {
        return;
      }
    }
  }
  if (v4 != v5)
  {
    uint64_t v6 = *(void *)(v4 + 8);
    if (v6)
    {
      if (*(unsigned __int8 *)(v6 + 618) != a2)
      {
        *(unsigned char *)(v6 + 618) = a2;
        uint64_t v7 = *(void *)(a1 + 80);
        uint64_t v8 = *(void *)(a1 + 88);
        if (v7 != v8)
        {
          while (*(_WORD *)v7 != 65)
          {
            v7 += 16;
            if (v7 == v8) {
              goto LABEL_21;
            }
          }
        }
        if (v7 != v8)
        {
          uint64_t v9 = *(void **)(v7 + 8);
          if (v9)
          {
            std::__list_imp<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry,std::allocator<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry>>::clear(*(void **)(v7 + 8));
            if (v9[6])
            {
              uint64_t v10 = (unsigned char *)v9[5];
              if (v10)
              {
                do
                {
                  if (v10[112]) {
                    v10[112] = 0;
                  }
                  BOOL v15 = *(unsigned char **)v10;
                  unint64_t v16 = (void *)*((void *)v10 + 4);
                  if (v16 != *((void **)v10 + 6)) {
                    free(v16);
                  }
                  operator delete(v10);
                  uint64_t v10 = v15;
                }
                while (v15);
              }
              v9[5] = 0;
              uint64_t v11 = v9[4];
              if (v11)
              {
                for (uint64_t i = 0; i != v11; ++i)
                  *(void *)(v9[3] + 8 * i) = 0;
              }
              v9[6] = 0;
            }
            v9[8] = v9;
            v9[9] = 0;
          }
        }
LABEL_21:
        uint64_t v13 = *(void *)(a1 + 32);
        uint64_t v14 = *(void *)(a1 + 40);
        if (v13 != v14)
        {
          while (*(_WORD *)v13 != 65)
          {
            v13 += 16;
            if (v13 == v14) {
              goto LABEL_33;
            }
          }
        }
        if (v13 != v14)
        {
          unint64_t v17 = *(gdc::LayerDataSource **)(v13 + 8);
          if (v17) {
            gdc::LayerDataSource::cancelAllLayerDataRequests(v17);
          }
        }
LABEL_33:
        uint64_t v18 = *(void *)(a1 + 80);
        uint64_t v19 = *(void *)(a1 + 88);
        if (v18 != v19)
        {
          while (*(_WORD *)v18 != 66)
          {
            v18 += 16;
            if (v18 == v19) {
              goto LABEL_46;
            }
          }
        }
        if (v18 != v19)
        {
          uint64_t v20 = *(void **)(v18 + 8);
          if (v20)
          {
            std::__list_imp<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry,std::allocator<geo::MarkedLRUCache<gdc::LayerDataRequestKey,std::shared_ptr<gdc::LayerData>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>>::CacheEntry>>::clear(*(void **)(v18 + 8));
            if (v20[6])
            {
              unint64_t v21 = (unsigned char *)v20[5];
              if (v21)
              {
                do
                {
                  if (v21[112]) {
                    v21[112] = 0;
                  }
                  __int16 v26 = *(unsigned char **)v21;
                  unint64_t v27 = (void *)*((void *)v21 + 4);
                  if (v27 != *((void **)v21 + 6)) {
                    free(v27);
                  }
                  operator delete(v21);
                  unint64_t v21 = v26;
                }
                while (v26);
              }
              v20[5] = 0;
              uint64_t v22 = v20[4];
              if (v22)
              {
                for (uint64_t j = 0; j != v22; ++j)
                  *(void *)(v20[3] + 8 * j) = 0;
              }
              v20[6] = 0;
            }
            v20[8] = v20;
            v20[9] = 0;
          }
        }
LABEL_46:
        uint64_t v24 = *(void *)(a1 + 32);
        uint64_t v25 = *(void *)(a1 + 40);
        if (v24 != v25)
        {
          while (*(_WORD *)v24 != 66)
          {
            v24 += 16;
            if (v24 == v25) {
              return;
            }
          }
        }
        if (v24 != v25)
        {
          unint64_t v28 = *(gdc::LayerDataSource **)(v24 + 8);
          if (v28)
          {
            gdc::LayerDataSource::cancelAllLayerDataRequests(v28);
          }
        }
      }
    }
  }
}

#error "1A1BCCDA8: too big function (funcsize=0)"

void sub_1A1BE0BB4(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, void **a10, void **a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void **a37,void **a38,void **a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void **a46,void **a47,void **a48,void **a49,void **a50,void **a51,void **a52,void **a53,void **a54,void **a55,void **a56,void **a57,void **a58,void **a59,void **a60,void **a61,void **a62,void **a63)
{
  STACK[0x910] = a1;
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x8A0]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x8B0]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x900]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x990]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x3D8]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x9A0]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x4A0]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x600]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x650]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x678]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x680]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x738]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x760]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x778]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x790]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x7B0]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x7C0]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x7D0]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x800]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x460]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x810]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x838]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x848]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x858]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x860]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)STACK[0x868]);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor(v74);
  ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor((void **)&STACK[0x6840]);
  LODWORD(STACK[0x890]) = 0;
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x9D0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x9C0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(v75);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0xA00]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0xC00]);
  STACK[0x8B0] = STACK[0x8A0];
  STACK[0x900] = STACK[0x8B0];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0xC80]);
  STACK[0x990] = STACK[0x900];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0xD00]);
  STACK[0x3D8] = STACK[0x990];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a9);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a37);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x8F0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x920]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x960]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x9B0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x9F0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a38);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a39);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a46);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x970]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a47);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x940]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x9E0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a49);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a50);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a51);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a52);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x950]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a53);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a54);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a55);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a56);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a57);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a58);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x980]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a59);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a60);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a61);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x8C0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a63);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a64);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a65);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a66);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a67);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a68);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a69);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a70);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a71);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a72);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x230]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x238]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x270]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x8E0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x290]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x298]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x2D0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x2D8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x2E0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x2E8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x930]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a62);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x2F0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a48);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x328]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(v73);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0xD80]);
  unint64_t v76 = STACK[0x640];
  unint64_t v77 = STACK[0x688];
  long long v78 = (void **)STACK[0x830];
  unint64_t v79 = (void **)STACK[0x818];
  int16x8_t v80 = (void **)STACK[0x7F0];
  uint64_t v81 = (void **)STACK[0x7E0];
  unint64_t v82 = (void **)STACK[0x6C8];
  STACK[0x9A0] = STACK[0x3D8];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x2A00]);
  STACK[0x4A0] = STACK[0x9A0];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x498]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x2A80]);
  STACK[0x600] = STACK[0x4A0];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x4A8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x4B0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x4B8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x4C0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x4C8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x4D0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x4D8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x4E0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x4E8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x4F0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x4F8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x500]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x508]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x510]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x520]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x880]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x528]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x530]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x538]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x540]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x558]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x560]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x568]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x570]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x580]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x588]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x590]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x598]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x5A0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x5A8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x5B0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x5B8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x5C0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x8D0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x5C8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x5D0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x5D8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x5E0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x5E8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x5F0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x5F8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(v72);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x2B80]);
  STACK[0x650] = STACK[0x600];
  int v83 = STACK[0x890];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x608]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x610]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x618]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x620]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x628]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x630]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x638]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x4100]);
  STACK[0x678] = STACK[0x650];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x648]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x4500]);
  STACK[0x680] = STACK[0x678];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x658]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x670]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x668]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x660]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x4600]);
  STACK[0x738] = STACK[0x680];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x690]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x698]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x6A0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x6A8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x6B0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x6B8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x6C0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x6D0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x6D8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x6E0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x6E8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x6F0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x6F8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x700]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x708]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x710]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(v82);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x718]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x720]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x728]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x730]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x4880]);
  STACK[0x760] = STACK[0x738];
  unint64_t v84 = (void *)v76;
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x740]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x5380]);
  unint64_t v85 = (_Unwind_Exception *)STACK[0x910];
  STACK[0x778] = STACK[0x760];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x748]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x5480]);
  STACK[0x790] = STACK[0x778];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x750]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x758]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x5580]);
  STACK[0x7B0] = STACK[0x790];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x768]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x770]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x780]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x788]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x5700]);
  STACK[0x7C0] = STACK[0x7B0];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x798]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x5980]);
  STACK[0x7D0] = STACK[0x7C0];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x7A0]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x7A8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x5A80]);
  STACK[0x800] = STACK[0x7D0];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x7B8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x5C00]);
  STACK[0x810] = STACK[0x800];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x7C8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x5D00]);
  STACK[0x838] = STACK[0x810];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x7D8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(v81);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x7E8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(v80);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x7F8]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x808]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x5E00]);
  STACK[0x848] = STACK[0x838];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a10);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x820]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(v79);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x828]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(v78);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x6180]);
  STACK[0x858] = STACK[0x848];
  uint64_t v86 = (void **)STACK[0x840];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x6480]);
  operator delete(v84);
  STACK[0x860] = STACK[0x858];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(a11);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x6500]);
  STACK[0x868] = STACK[0x860];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x6600]);
  int8x8_t v87 = (void **)STACK[0x868];
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor(v86);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)STACK[0x850]);
  ecs2::ExecutionTaskDescriptor::~ExecutionTaskDescriptor((void **)&STACK[0x6680]);
  ecs2::UtlityTaskDescriptor::~UtlityTaskDescriptor((void **)&STACK[0x6800]);
  if (v83 && &STACK[0x6840] != (unint64_t *)v87)
  {
    do
    {
      v87 -= 16;
      ecs2::ModuleBucketDescriptor::~ModuleBucketDescriptor(v87);
    }
    while (v87 != (void **)&STACK[0x6840]);
  }
  if (*(char *)(v77 + 31) < 0) {
    operator delete(*(void **)(v77 + 8));
  }
  _Unwind_Resume(v85);
}

uint64_t md::LabelsLogic::setSelectedLabelMarkerWillDisappearCallback(uint64_t a1, void *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)(a1 + 128);
  uint64_t v3 = (void *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      uint64_t v6 = v5;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v5);
    }
    else
    {
      uint64_t v6 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  std::__function::__value_func<void ()(md::LabelManager *,std::shared_ptr<md::LabelMarker> const&)>::swap[abi:nn180100](v5, v2);
  uint64_t result = (uint64_t)v6;
  if (v6 == v5) {
    return (*(uint64_t (**)(void *))(v5[0] + 32))(v5);
  }
  if (v6) {
    return (*(uint64_t (**)(void))(*v6 + 40))();
  }
  return result;
}

void sub_1A1BE2CEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1BE2DBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1BE2EB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::CartographicTiledRenderLayer<HillshadeRenderable>::clearScene(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 52) == 1)
  {
    long long v10 = *(_OWORD *)(a1 + 272);
    (*(void (**)(uint64_t, long long *))(*(void *)a1 + 120))(a1, &v10);
  }
  if (*(void *)(a1 + 112))
  {
    uint64_t v2 = *(unsigned char **)(a1 + 104);
    if (v2)
    {
      do
      {
        if (v2[112]) {
          v2[112] = 0;
        }
        uint64_t v8 = *(unsigned char **)v2;
        uint64_t v9 = (void *)*((void *)v2 + 4);
        if (v9 != *((void **)v2 + 6)) {
          free(v9);
        }
        operator delete(v2);
        uint64_t v2 = v8;
      }
      while (v8);
    }
    *(void *)(a1 + 104) = 0;
    uint64_t v3 = *(void *)(a1 + 96);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*(void *)(a1 + 88) + 8 * i) = 0;
    }
    *(void *)(a1 + 112) = 0;
  }
  *(void *)(a1 + 280) = *(void *)(a1 + 272);
  geo::Pool<HillshadeRenderable>::disposeElements(a1 + 224);
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 136));
  *(void *)(a1 + 128) = a1 + 136;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 136) = 0;
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 160));
  *(void *)(a1 + 152) = a1 + 160;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 160) = 0;
  uint64_t v5 = (void *)(a1 + 184);
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 184));
  uint64_t v7 = *(void **)(a1 + 208);
  uint64_t v6 = (void *)(a1 + 208);
  *(v6 - 4) = v5;
  *uint64_t v5 = 0;
  *(v6 - 2) = 0;
  std::__tree<gdc::LayerDataWithWorld>::destroy(v7);
  *(v6 - 1) = v6;
  void *v6 = 0;
  v6[1] = 0;
}

void geo::Pool<HillshadeRenderable>::disposeElements(uint64_t a1)
{
  unint64_t v29 = 0;
  uint64_t v30 = 0;
  unint64_t v28 = &v29;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = &v29;
      uint64_t v5 = &v29;
      if (v29)
      {
        uint64_t v6 = v29;
        while (1)
        {
          while (1)
          {
            uint64_t v5 = (uint64_t **)v6;
            unint64_t v7 = v6[4];
            if ((unint64_t)v2 >= v7) {
              break;
            }
            uint64_t v6 = *v5;
            uint64_t v4 = v5;
            if (!*v5) {
              goto LABEL_12;
            }
          }
          if (v7 >= (unint64_t)v2) {
            break;
          }
          uint64_t v6 = v5[1];
          if (!v6)
          {
            uint64_t v4 = v5 + 1;
            goto LABEL_12;
          }
        }
      }
      else
      {
LABEL_12:
        uint64_t v8 = (uint64_t *)operator new(0x28uLL);
        v8[4] = (uint64_t)v2;
        *uint64_t v8 = 0;
        v8[1] = 0;
        v8[2] = (uint64_t)v5;
        void *v4 = v8;
        if (*v28)
        {
          unint64_t v28 = (uint64_t **)*v28;
          uint64_t v8 = *v4;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v29, v8);
        uint64_t v3 = ++v30;
        uint64_t v2 = *(void **)(a1 + 40);
      }
      uint64_t v2 = (void *)*v2;
      *(void *)(a1 + 40) = v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  unint64_t v9 = *(void *)(a1 + 24);
  long long v10 = *(void **)a1;
  uint64_t v11 = (void *)(a1 + 8);
  BOOL v12 = v3 == *(void *)(a1 + 16) * v9 || v10 == v11;
  if (v12 || v9 == 0)
  {
    if (v10 == v11) {
      goto LABEL_47;
    }
    goto LABEL_49;
  }
  uint64_t v14 = 1;
  do
  {
    if (v14)
    {
      unint64_t v15 = 0;
      uint64_t v16 = v10[4];
      do
      {
        unint64_t v17 = (void (***)(void))(v16 + 400 * v15);
        uint64_t v18 = v29;
        if (!v29) {
          goto LABEL_28;
        }
        uint64_t v19 = &v29;
        do
        {
          uint64_t v20 = v18;
          unint64_t v21 = v19;
          unint64_t v22 = v18[4];
          uint64_t v23 = (uint64_t **)(v18 + 1);
          if (v22 >= (unint64_t)v17)
          {
            uint64_t v23 = (uint64_t **)v20;
            uint64_t v19 = (uint64_t **)v20;
          }
          uint64_t v18 = *v23;
        }
        while (v18);
        if (v19 == &v29) {
          goto LABEL_28;
        }
        if (v22 < (unint64_t)v17) {
          uint64_t v20 = (uint64_t *)v21;
        }
        if ((unint64_t)v17 < v20[4])
        {
LABEL_28:
          (**v17)(v17);
          unint64_t v9 = *(void *)(a1 + 24);
        }
        ++v15;
        uint64_t v14 = v9;
      }
      while (v15 < v9);
    }
    uint64_t v24 = (void *)v10[1];
    if (v24)
    {
      do
      {
        uint64_t v25 = v24;
        uint64_t v24 = (void *)*v24;
      }
      while (v24);
    }
    else
    {
      do
      {
        uint64_t v25 = (void *)v10[2];
        BOOL v12 = *v25 == (void)v10;
        long long v10 = v25;
      }
      while (!v12);
    }
    long long v10 = v25;
  }
  while (v25 != v11);
  long long v10 = *(void **)a1;
  if (*(void **)a1 != v11)
  {
    do
    {
LABEL_49:
      free((void *)v10[4]);
      __int16 v26 = (void *)v10[1];
      if (v26)
      {
        do
        {
          unint64_t v27 = v26;
          __int16 v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          unint64_t v27 = (void *)v10[2];
          BOOL v12 = *v27 == (void)v10;
          long long v10 = v27;
        }
        while (!v12);
      }
      long long v10 = v27;
    }
    while (v27 != v11);
  }
LABEL_47:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v11;
  *(void *)(a1 + 40) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v29);
}

void sub_1A1BE3A28(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v1);
  _Unwind_Resume(a1);
}

uint64_t md::CompositeLabeler::customDebugDraw(uint64_t this, const md::LayoutContext *a2)
{
  uint64_t v2 = *(uint64_t **)(this + 8);
  for (uint64_t i = *(uint64_t **)(this + 16);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, const md::LayoutContext *))(*(void *)v5 + 312))(v5, a2))
  {
    uint64_t v5 = *v2++;
  }
  return this;
}

void md::MapNavLabeler::customDebugDraw(md::MapNavLabeler *this, id *a2)
{
  uint64_t v4 = *((void *)this + 86);
  uint64_t v5 = +[VKDebugSettings sharedSettings];
  if ([v5 enableEtaLabelDebugging]) {
    goto LABEL_6;
  }
  uint64_t v6 = +[VKDebugSettings sharedSettings];
  if ([v6 enableRouteShareSectionDebugging])
  {
LABEL_5:

LABEL_6:
LABEL_7:
    uint64_t v8 = *((void *)this + 86);
    BOOL v12 = +[VKDebugSettings sharedSettings];
    if (([v12 enableEtaLabelDebugging] & 1) != 0
      || ([v12 enableEtaLabelRectDebugging] & 1) != 0
      || ([v12 enableRouteShareSectionDebugging] & 1) != 0)
    {
      if (!*a2) {
        goto LABEL_23;
      }
    }
    else if (!*(unsigned char *)(v8 + 448) || !*a2)
    {
      goto LABEL_23;
    }
    if (objc_opt_respondsToSelector())
    {
      unint64_t v9 = (ggl::DebugConsole *)[*a2 debugConsoleForId:9];
      if (!*a2) {
        goto LABEL_23;
      }
LABEL_15:
      if (objc_opt_respondsToSelector())
      {
        uint64_t v10 = [*a2 debugConsoleForId:10];
        if (v9)
        {
          if (v10) {
            ggl::DebugConsole::begin(v9);
          }
        }
      }
      goto LABEL_23;
    }
    unint64_t v9 = 0;
    if (*a2) {
      goto LABEL_15;
    }
LABEL_23:

    return;
  }
  unint64_t v7 = +[VKDebugSettings sharedSettings];
  if ([v7 enableEtaLabelRectDebugging])
  {

    goto LABEL_5;
  }
  int v11 = *(unsigned __int8 *)(v4 + 448);

  if (v11) {
    goto LABEL_7;
  }
}

void sub_1A1BE5BB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34)
{
  STACK[0x2A0] = (unint64_t)off_1EF57F4A0;
  STACK[0x328] = (unint64_t)off_1EF57F4F0;
  STACK[0x2B0] = (unint64_t)off_1EF57F4C8;
  STACK[0x2B8] = (unint64_t)&unk_1EF57F2D0;
  if (SLOBYTE(STACK[0x30F]) < 0) {
    (*(void (**)(unint64_t, unint64_t, unint64_t))(*(void *)STACK[0x310] + 40))(STACK[0x310], STACK[0x2F8], STACK[0x308] & 0x7FFFFFFFFFFFFFFFLL);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1A62391A0](&STACK[0x328]);

  _Unwind_Resume(a1);
}

__CFString *___ZN2md18NonTiledAssetLogic15loadNonTiledIDsEP17VKResourceManager_block_invoke(uint64_t a1)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  return @"NonTiledAssets.json";
}

void gdc::ResourceManager::addResourceFetcher<md::S2TileFetcher,void,GEOApplicationAuditToken * {__strong},GEOTileSetStyle,unsigned short,float,std::shared_ptr<md::TaskContext>>(uint64_t a1, uint64_t a2, void *a3)
{
  id v3 = a3;
  operator new();
}

void sub_1A1BE620C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14) {
    (*(void (**)(void))(*(void *)a14 + 8))();
  }

  _Unwind_Resume(a1);
}

void gdc::ResourceManager::addResourceFetcher<md::S2RasterTileResourceFetcher,void,GEOApplicationAuditToken * {__strong},GEOTileSetStyle,unsigned short,float,std::shared_ptr<md::TaskContext>>(uint64_t a1, uint64_t a2, void *a3)
{
}

void sub_1A1BE6574(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, char a11, uint64_t a12, uint64_t a13)
{
  if (a13) {
    (*(void (**)(void))(*(void *)a13 + 8))();
  }

  _Unwind_Resume(a1);
}

void gdc::ResourceManager::addResourceFetcher<md::GEOFlyoverTileResourceFetcher,void,GEOApplicationAuditToken * {__strong},GEOTileSetStyle,unsigned short,float,std::shared_ptr<md::TaskContext>,VKSharedResources * {__strong}>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  id v8 = a3;
  id v9 = a7;
  operator new();
}

void sub_1A1BE6B44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (!atomic_fetch_add(v19, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  md::TiledGEOResourceFetcher::~TiledGEOResourceFetcher(v17);

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  MEMORY[0x1A6239270](v17, 0x10A1C404F795E9FLL);

  _Unwind_Resume(a1);
}

void gdc::ResourceManager::addResourceFetcher<md::DaVinciGroundTileResourceFetcher,void,GEOApplicationAuditToken * {__strong},GEOTileSetStyle,unsigned short,float,std::shared_ptr<md::TaskContext>>(uint64_t a1, uint64_t a2, void *a3)
{
}

void sub_1A1BE6F00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, char a11, uint64_t a12, uint64_t a13)
{
  if (a13) {
    (*(void (**)(void))(*(void *)a13 + 8))();
  }

  _Unwind_Resume(a1);
}

void gdc::ResourceManager::addResourceFetcher<md::RasterTileResourceFetcher,void,GEOApplicationAuditToken * {__strong},GEOTileSetStyle,unsigned short,float,std::shared_ptr<md::TaskContext>>(uint64_t a1, uint64_t a2, void *a3)
{
}

void sub_1A1BE7154(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, uint64_t a10, char a11)
{
  if (a10) {
    (*(void (**)(void))(*(void *)a10 + 8))();
  }

  _Unwind_Resume(a1);
}

void *md::RasterTileResourceFetcher::RasterTileResourceFetcher(void *a1, void *a2, int a3, int a4, uint64_t *a5, uint64_t a6, float a7)
{
  id v13 = a2;
  LOWORD(v18[0]) = a4;
  uint64_t v14 = *a5;
  unint64_t v15 = (std::__shared_weak_count *)a5[1];
  v21[0] = v14;
  v21[1] = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v19 = &unk_1EF559518;
  id v20 = 0;
  md::TiledGEOResourceFetcher::TiledGEOResourceFetcher((uint64_t)a1, v13, a3, (unsigned __int16 *)v18, 1, v21, (uint64_t)&v19, a7);
  uint64_t v19 = &unk_1EF559518;

  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  *a1 = &unk_1EF5468C0;
  *(void *)((char *)a1 + 620) = a6;
  uint64_t v16 = (std::__shared_weak_count *)operator new(0x20uLL);
  v16->__shared_owners_ = 0;
  v16->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581D70;
  v16->__shared_weak_owners_ = 0;
  v16[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF546898;
  v18[0] = (uint64_t)&v16[1];
  v18[1] = (uint64_t)v16;
  gdc::ResourceFetcher::setDecoder(a1, a4, v18);
  if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }

  return a1;
}

void sub_1A1BE7418(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  md::TiledGEOResourceFetcher::~TiledGEOResourceFetcher(v3);

  _Unwind_Resume(a1);
}

void *md::GEOVectorTileResourceFetcher::GEOVectorTileResourceFetcher(void *a1, void *a2, int a3, int a4, uint64_t *a5, float a6)
{
  id v11 = a2;
  LOWORD(v17[0]) = a4;
  uint64_t v12 = *a5;
  id v13 = (std::__shared_weak_count *)a5[1];
  v20[0] = v12;
  v20[1] = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = &unk_1EF559518;
  id v19 = 0;
  md::TiledGEOResourceFetcher::TiledGEOResourceFetcher((uint64_t)a1, v11, a3, (unsigned __int16 *)v17, 1, v20, (uint64_t)&v18, a6);
  uint64_t v18 = &unk_1EF559518;

  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  *a1 = &unk_1EF54A268;
  uint64_t v14 = (std::__shared_weak_count *)operator new(0x38uLL);
  v14->__shared_owners_ = 0;
  v14->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582320;
  v14->__shared_weak_owners_ = 0;
  v14[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF54A240;
  id v15 = objc_alloc_init(MEMORY[0x1E4F64BA8]);
  v14[1].__shared_owners_ = (uint64_t)&unk_1EF5598F8;
  v14[1].__shared_weak_owners_ = (uint64_t)v15;
  v17[0] = (uint64_t)&v14[1];
  v17[1] = (uint64_t)v14;
  gdc::ResourceFetcher::setDecoder(a1, a4, v17);
  if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }

  return a1;
}

void sub_1A1BE76AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  md::TiledGEOResourceFetcher::~TiledGEOResourceFetcher(v3);

  _Unwind_Resume(a1);
}

void gdc::ResourceFetcher::setDecoder(void *a1, int a2, uint64_t *a3)
{
  unsigned __int16 v3 = a2;
  uint64_t v5 = *a3;
  uint64_t v6 = (unsigned __int16 *)a1[5];
  uint64_t v7 = (unsigned __int16 *)a1[6];
  if (*a3)
  {
    id v9 = (unsigned __int16 *)a1[5];
    if (v6 != v7)
    {
      id v9 = (unsigned __int16 *)a1[5];
      while (*v9 != a2)
      {
        v9 += 12;
        if (v9 == v7) {
          goto LABEL_8;
        }
      }
    }
    if (v9 == v7)
    {
LABEL_8:
      id v9 = (unsigned __int16 *)a1[5];
      if (v6 != v7)
      {
        id v9 = (unsigned __int16 *)a1[5];
        while (*v9 != a2)
        {
          v9 += 12;
          if (v9 == v7) {
            goto LABEL_25;
          }
        }
      }
      if (v9 == v7)
      {
LABEL_25:
        unint64_t v13 = a1[7];
        if ((unint64_t)v7 >= v13)
        {
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * (((char *)v7 - (char *)v6) >> 3) + 1;
          if (v15 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v6) >> 3);
          if (2 * v16 > v15) {
            unint64_t v15 = 2 * v16;
          }
          if (v16 >= 0x555555555555555) {
            unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v17 = v15;
          }
          if (v17 > 0xAAAAAAAAAAAAAAALL) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = (char *)operator new(24 * v17);
          id v9 = (unsigned __int16 *)&v18[8 * (((char *)v7 - (char *)v6) >> 3)];
          *id v9 = v3;
          id v19 = &v18[24 * v17];
          *((void *)v9 + 1) = 0;
          *((void *)v9 + 2) = 0;
          id v20 = v9 + 12;
          if (v6 == v7)
          {
            a1[5] = v9;
            a1[6] = v20;
            a1[7] = v19;
          }
          else
          {
            unint64_t v21 = &v18[8 * (((char *)v7 - (char *)v6) >> 3)];
            do
            {
              __int16 v22 = *(v7 - 12);
              v7 -= 12;
              *((_WORD *)v21 - 12) = v22;
              v21 -= 24;
              *(_OWORD *)(v21 + 8) = *(_OWORD *)(v7 + 4);
              *((void *)v7 + 1) = 0;
              *((void *)v7 + 2) = 0;
            }
            while (v7 != v6);
            uint64_t v6 = (unsigned __int16 *)a1[5];
            uint64_t v23 = (unsigned __int16 *)a1[6];
            a1[5] = v21;
            a1[6] = v20;
            for (a1[7] = v19; v23 != v6; v23 -= 12)
            {
              uint64_t v24 = (std::__shared_weak_count *)*((void *)v23 - 1);
              if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
                std::__shared_weak_count::__release_weak(v24);
              }
            }
          }
          if (v6) {
            operator delete(v6);
          }
          a1[6] = v20;
        }
        else
        {
          *uint64_t v7 = a2;
          *((void *)v7 + 1) = 0;
          *((void *)v7 + 2) = 0;
          a1[6] = v7 + 12;
          id v9 = v7;
        }
      }
      uint64_t v5 = *a3;
    }
    uint64_t v25 = a3[1];
    if (v25) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
    }
    __int16 v26 = (std::__shared_weak_count *)*((void *)v9 + 2);
    *((void *)v9 + 1) = v5;
    *((void *)v9 + 2) = v25;
    if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  else
  {
    if (v6 != v7)
    {
      while (*v6 != a2)
      {
        v6 += 12;
        if (v6 == v7) {
          return;
        }
      }
    }
    if (v6 != v7)
    {
      if (v6 + 12 != v7)
      {
        do
        {
          uint64_t v10 = v6;
          unsigned __int16 *v6 = v6[12];
          long long v11 = *((_OWORD *)v6 + 2);
          *((void *)v6 + 4) = 0;
          *((void *)v6 + 5) = 0;
          uint64_t v12 = (std::__shared_weak_count *)*((void *)v6 + 2);
          *(_OWORD *)(v10 + 4) = v11;
          if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
            std::__shared_weak_count::__release_weak(v12);
          }
          uint64_t v6 = v10 + 12;
        }
        while (v10 + 24 != v7);
        uint64_t v7 = (unsigned __int16 *)a1[6];
      }
      for (; v7 != v6; v7 -= 12)
      {
        uint64_t v14 = (std::__shared_weak_count *)*((void *)v7 - 1);
        if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
      a1[6] = v6;
    }
  }
}

void sub_1A1BE7B6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  md::components::Material::~Material((md::components::Material *)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZZZN2md10StyleLogic22setupDecodingCallbacksERKNSt3__110shared_ptrIN3gss17StylesheetManagerINS3_10PropertyIDEEEEEENK3__1clES7_bENKUlPS0_E_clESB__block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(os_unfair_lock_s **)(a1 + 32);
      if (v5)
      {
        v9[0] = &unk_1EF57F138;
        uint64_t v10 = v9;
        os_unfair_lock_lock(v5 + 2);
        if (*(void *)&v5->_os_unfair_lock_opaque)
        {
          uint64_t v8 = *(void *)&v5->_os_unfair_lock_opaque;
          if (!v10)
          {
            std::__throw_bad_function_call[abi:nn180100]();
            __break(1u);
            return;
          }
          (*(void (**)(void *, uint64_t *))(*v10 + 48))(v10, &v8);
        }
        os_unfair_lock_unlock(v5 + 2);
        if (v10 == v9)
        {
          (*(void (**)(void *))(v9[0] + 32))(v9);
        }
        else if (v10)
        {
          (*(void (**)(void *, uint64_t, uint64_t))(*v10 + 40))(v10, v6, v7);
        }
      }
      if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1A1BE7D2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  os_unfair_lock_unlock(v12);
  std::function<void ()(md::StyleLogic *)>::~function(&a12);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZZZN2md10StyleLogic22setupDecodingCallbacksERKNS_10shared_ptrIN3gss17StylesheetManagerINS5_10PropertyIDEEEEEENK3__1clES9_bENKUlPS3_E_clESD_EUb_EUlSD_E_NS_9allocatorISF_EEFvSD_EEclEOSD_(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  char v6 = 5;
  uint64_t v3 = *(char **)(v2 + 1128);
  uint64_t v4 = *(char **)(v2 + 1136);
  if (v3 != v4)
  {
    while (*v3 <= 4u)
    {
      if (++v3 == v4) {
        goto LABEL_7;
      }
    }
  }
  if (v3 == v4 || (uint64_t v4 = v3, *v3 != 5)) {
LABEL_7:
  }
    std::vector<md::StyleManagerEvent>::insert(v2 + 1128, v4, &v6);
  uint64_t v5 = **(void **)(v2 + 1240);
  if (v5)
  {
    char v7 = 8;
    md::MapEngine::setNeedsTick(v5, &v7);
  }
}

void ___ZZZN2md10StyleLogic22setupDecodingCallbacksERKNSt3__110shared_ptrIN3gss17StylesheetManagerINS3_10PropertyIDEEEEEENK3__0clES7_bENKUlPS0_E_clESB__block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(os_unfair_lock_s **)(a1 + 32);
      if (v5)
      {
        v9[0] = &unk_1EF57F0F0;
        uint64_t v10 = v9;
        os_unfair_lock_lock(v5 + 2);
        if (*(void *)&v5->_os_unfair_lock_opaque)
        {
          uint64_t v8 = *(void *)&v5->_os_unfair_lock_opaque;
          if (!v10)
          {
            std::__throw_bad_function_call[abi:nn180100]();
            __break(1u);
            return;
          }
          (*(void (**)(void *, uint64_t *))(*v10 + 48))(v10, &v8);
        }
        os_unfair_lock_unlock(v5 + 2);
        if (v10 == v9)
        {
          (*(void (**)(void *))(v9[0] + 32))(v9);
        }
        else if (v10)
        {
          (*(void (**)(void *, uint64_t, uint64_t))(*v10 + 40))(v10, v6, v7);
        }
      }
      if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1A1BE7F94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  os_unfair_lock_unlock(v12);
  std::function<void ()(md::StyleLogic *)>::~function(&a12);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZZZN2md10StyleLogic22setupDecodingCallbacksERKNS_10shared_ptrIN3gss17StylesheetManagerINS5_10PropertyIDEEEEEENK3__0clES9_bENKUlPS3_E_clESD_EUb_EUlSD_E_NS_9allocatorISF_EEFvSD_EEclEOSD_(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  char v6 = 4;
  uint64_t v3 = *(char **)(v2 + 1128);
  uint64_t v4 = *(char **)(v2 + 1136);
  if (v3 != v4)
  {
    while (*v3 <= 3u)
    {
      if (++v3 == v4) {
        goto LABEL_7;
      }
    }
  }
  if (v3 == v4 || (uint64_t v4 = v3, *v3 != 4)) {
LABEL_7:
  }
    std::vector<md::StyleManagerEvent>::insert(v2 + 1128, v4, &v6);
  uint64_t v5 = **(void **)(v2 + 1240);
  if (v5)
  {
    char v7 = 12;
    md::MapEngine::setNeedsTick(v5, &v7);
  }
}

uint64_t ggl::TextureCube::vendImplicitLoadItems(uint64_t result, uint64_t *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = 0;
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = result + 96;
  unint64_t v6 = a2[1];
  uint64_t v34 = result + 96;
  do
  {
    uint64_t v7 = *(void *)(v5 + 16 * v4);
    unint64_t v8 = *(unsigned int *)(v3 + 196) | ((unint64_t)*(unsigned int *)(v3 + 196) << 32);
    unint64_t v9 = a2[2];
    if (v6 < v9)
    {
      if (v6)
      {
        uint64_t v10 = operator new(0x20uLL);
        *uint64_t v10 = &unk_1EF56B890;
        v10[1] = ggl::TextureCube::onImplicitLoadComplete;
        v10[2] = 0;
        v10[3] = v3;
        uint64_t v36 = v10;
        *(void *)unint64_t v6 = v7;
        *(void *)(v6 + 8) = v3;
        *(unsigned char *)(v6 + 16) = 1;
        *(unsigned char *)(v6 + 17) = v4;
        *(unsigned char *)(v6 + 20) = 0;
        *(void *)(v6 + 28) = 0;
        *(void *)(v6 + 36) = v8;
        uint64_t result = (uint64_t)v36;
        if (v36)
        {
          if (v36 == v35)
          {
            *(void *)(v6 + 72) = v6 + 48;
            loc_1A1A727C4(v35);
          }
          else
          {
            *(void *)(v6 + 72) = (*(uint64_t (**)(void))(*v36 + 16))();
          }
          uint64_t result = (uint64_t)v36;
          if (v36 == v35)
          {
            uint64_t result = (*(uint64_t (**)(void *))(v35[0] + 32))(v35);
          }
          else if (v36)
          {
            uint64_t result = (*(uint64_t (**)(void))(*v36 + 40))();
          }
        }
        else
        {
          *(void *)(v6 + 72) = 0;
        }
      }
      v6 += 80;
      goto LABEL_4;
    }
    unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v6 - *a2) >> 4);
    unint64_t v12 = v11 + 1;
    if (v11 + 1 > 0x333333333333333) {
      abort();
    }
    unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v9 - *a2) >> 4);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x199999999999999) {
      uint64_t v14 = 0x333333333333333;
    }
    else {
      uint64_t v14 = v12;
    }
    if (v14)
    {
      uint64_t v15 = 80 * v14;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2[3] + 16))(a2[3], 80 * v14, 8);
      uint64_t v16 = result + 80 * v11;
      uint64_t v17 = result + v15;
      if (result)
      {
        uint64_t v18 = result;
        id v19 = operator new(0x20uLL);
        *id v19 = &unk_1EF56B890;
        v19[1] = ggl::TextureCube::onImplicitLoadComplete;
        v19[2] = 0;
        v19[3] = v3;
        uint64_t v36 = v19;
        *(void *)uint64_t v16 = v7;
        unint64_t v20 = v18 + 80 * v11;
        *(void *)(v20 + 8) = v3;
        *(unsigned char *)(v20 + 16) = 1;
        *(unsigned char *)(v20 + 17) = v4;
        *(unsigned char *)(v20 + 20) = 0;
        *(void *)(v20 + 28) = 0;
        *(void *)(v20 + 36) = v8;
        if (v36)
        {
          if (v36 == v35)
          {
            *(void *)(v18 + 80 * v11 + 72) = v20 + 48;
            (*(void (**)(void *))(*v36 + 24))(v36);
          }
          else
          {
            *(void *)(v18 + 80 * v11 + 72) = (*(uint64_t (**)(void))(*v36 + 16))();
          }
        }
        else
        {
          *(void *)(v18 + 80 * v11 + 72) = 0;
        }
        uint64_t result = (uint64_t)v36;
        if (v36 == v35)
        {
          uint64_t result = (*(uint64_t (**)(void *))(v35[0] + 32))(v35);
        }
        else if (v36)
        {
          uint64_t result = (*(uint64_t (**)(void))(*v36 + 40))();
        }
      }
    }
    else
    {
      uint64_t v17 = 0;
      uint64_t v16 = 80 * v11;
    }
    unint64_t v6 = v16 + 80;
    __int16 v22 = (char *)*a2;
    unint64_t v21 = (char *)a2[1];
    if (v21 == (char *)*a2)
    {
      *a2 = v16;
      a2[1] = v6;
      uint64_t v30 = (char *)a2[2];
      a2[2] = v17;
    }
    else
    {
      uint64_t v23 = 0;
      do
      {
        uint64_t v24 = v16 + v23;
        uint64_t v25 = &v21[v23];
        *(_OWORD *)(v24 - 80) = *(_OWORD *)&v21[v23 - 80];
        *(unsigned char *)(v24 - 64) = 0;
        if (v21[v23 - 64])
        {
          *(unsigned char *)(v24 - 63) = *(v25 - 63);
          *(unsigned char *)(v24 - 64) = 1;
        }
        *(unsigned char *)(v24 - 60) = 0;
        if (*(v25 - 60))
        {
          *(_DWORD *)(v16 + v23 - 56) = *(_DWORD *)&v21[v23 - 56];
          *(unsigned char *)(v24 - 60) = 1;
        }
        uint64_t v26 = v16 + v23;
        unint64_t v27 = &v21[v23];
        *(_OWORD *)(v16 + v23 - 52) = *(_OWORD *)&v21[v23 - 52];
        unint64_t v28 = *(char **)&v21[v23 - 8];
        if (v28)
        {
          if (v27 - 32 == v28)
          {
            *(void *)(v26 - 8) = v26 - 32;
            uint64_t result = (*(uint64_t (**)(void))(**((void **)v27 - 1) + 24))(*((void *)v27 - 1));
          }
          else
          {
            *(void *)(v26 - 8) = v28;
            *((void *)v27 - 1) = 0;
          }
        }
        else
        {
          *(void *)(v26 - 8) = 0;
        }
        v23 -= 80;
      }
      while (&v21[v23] != v22);
      unint64_t v21 = (char *)*a2;
      unint64_t v29 = (char *)a2[1];
      *a2 = v16 + v23;
      a2[1] = v6;
      uint64_t v30 = (char *)a2[2];
      a2[2] = v17;
      if (v29 != v21)
      {
        unint64_t v31 = v29 - 32;
        uint64_t v32 = v29 - 32;
        do
        {
          uint64_t result = *((void *)v32 + 3);
          if (v32 == (char *)result)
          {
            uint64_t result = (*(uint64_t (**)(char *))(*(void *)v32 + 32))(v32);
            if (!*(v32 - 28)) {
              goto LABEL_53;
            }
          }
          else
          {
            if (result) {
              uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
            }
            if (!*(v32 - 28)) {
              goto LABEL_53;
            }
          }
          *(v32 - 28) = 0;
LABEL_53:
          if (*(v32 - 32)) {
            *(v32 - 32) = 0;
          }
          uint64_t v33 = v32 - 48;
          v32 -= 80;
          v31 -= 80;
        }
        while (v33 != v21);
      }
    }
    uint64_t v5 = v34;
    if (v21) {
      uint64_t result = (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)a2[3] + 40))(a2[3], v21, v30 - v21);
    }
LABEL_4:
    a2[1] = v6;
    ++v4;
  }
  while (v4 != 6);
  return result;
}

__n128 std::__function::__func<std::__bind<void (ggl::TextureCube::*)(ggl::Texture2DLoadItem const&),ggl::TextureCube*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (ggl::TextureCube::*)(ggl::Texture2DLoadItem const&),ggl::TextureCube*,std::placeholders::__ph<1> const&>>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF56B890;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResetFunctionConstants>(md::ita::ResetFunctionConstants &&)::{lambda(void)#2},std::allocator<md::ita::ResetFunctionConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResetFunctionConstants>(md::ita::ResetFunctionConstants &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BE8704(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorFog>(md::ita::PrepareFunctionConstantDescriptorFog &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorFog &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorFog>(md::ita::PrepareFunctionConstantDescriptorFog &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BE8764(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSSAO>(md::ita::PrepareFunctionConstantDescriptorSSAO &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorSSAO &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSSAO>(md::ita::PrepareFunctionConstantDescriptorSSAO &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BE87C4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPlanar>(md::ita::PrepareFunctionConstantDescriptorPlanar &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorPlanar &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPlanar>(md::ita::PrepareFunctionConstantDescriptorPlanar &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BE8824(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOverlay>(md::ita::PrepareFunctionConstantDescriptorOverlay &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorOverlay &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOverlay>(md::ita::PrepareFunctionConstantDescriptorOverlay &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BE8884(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLandCover>(md::ita::PrepareFunctionConstantDescriptorLandCover &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorLandCover &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLandCover>(md::ita::PrepareFunctionConstantDescriptorLandCover &&)::{lambda(void)#2}<gdc>> ()(void)>::operator()(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 24;
  _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_((char **)a1);
}

void sub_1A1BE88E4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void _ZN3gdc16forEachInnerTypeINSt3__15tupleIJN2md2ls17FunctionConstantsEEEEZNS_18typelist_as_vectorIS6_EENS1_6vectorINS_8TypeInfoENS1_9allocatorIS9_EEEEvEUlTyvE_EEvOT0_(char **a1)
{
  uint64_t v3 = a1[1];
  unint64_t v2 = (unint64_t)a1[2];
  if ((unint64_t)v3 >= v2)
  {
    uint64_t v5 = *a1;
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
    unint64_t v7 = v6 + 1;
    if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v2 - (void)v5) >> 3);
    if (2 * v8 > v7) {
      unint64_t v7 = 2 * v8;
    }
    if (v8 >= 0x555555555555555) {
      unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v9 = v7;
    }
    if (v9)
    {
      if (v9 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v10 = (char *)operator new(24 * v9);
    }
    else
    {
      uint64_t v10 = 0;
    }
    unint64_t v11 = &v10[24 * v6];
    *(void *)unint64_t v11 = 0xC62D89929260CB56;
    *((void *)v11 + 1) = "md::ls::FunctionConstants]";
    *((void *)v11 + 2) = 25;
    uint64_t v4 = v11 + 24;
    if (v3 != v5)
    {
      do
      {
        long long v12 = *(_OWORD *)(v3 - 24);
        *((void *)v11 - 1) = *((void *)v3 - 1);
        *(_OWORD *)(v11 - 24) = v12;
        v11 -= 24;
        v3 -= 24;
      }
      while (v3 != v5);
      uint64_t v3 = *a1;
    }
    *a1 = v11;
    a1[1] = v4;
    a1[2] = &v10[24 * v9];
    if (v3) {
      operator delete(v3);
    }
  }
  else
  {
    *(void *)uint64_t v3 = 0xC62D89929260CB56;
    *((void *)v3 + 1) = "md::ls::FunctionConstants]";
    *((void *)v3 + 2) = 25;
    uint64_t v4 = v3 + 24;
  }
  a1[1] = v4;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,md::RoadPosition **,false>(uint64_t result, unint64_t *a2, uint64_t a3, char a4)
{
  unint64_t v9 = (unint64_t *)result;
LABEL_2:
  uint64_t v10 = a2 - 1;
  unint64_t v11 = v9;
  while (1)
  {
    unint64_t v9 = v11;
    uint64_t v12 = (char *)a2 - (char *)v11;
    unint64_t v13 = a2 - v11;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unint64_t v66 = *v11;
          if (*v10 < *v11)
          {
            *unint64_t v11 = *v10;
            *uint64_t v10 = v66;
          }
          return result;
        case 3uLL:
          unint64_t v67 = *v11;
          unint64_t v68 = v11[1];
          unint64_t v69 = *v10;
          if (v68 >= *v11)
          {
            if (v69 < v68)
            {
              v11[1] = v69;
              *uint64_t v10 = v68;
              unint64_t v98 = *v11;
              unint64_t v97 = v11[1];
              if (v97 < *v11)
              {
                *unint64_t v11 = v97;
                v11[1] = v98;
              }
            }
          }
          else
          {
            if (v69 >= v68)
            {
              *unint64_t v11 = v68;
              v11[1] = v67;
              if (*v10 >= v67) {
                return result;
              }
              v11[1] = *v10;
            }
            else
            {
              *unint64_t v11 = v69;
            }
            *uint64_t v10 = v67;
          }
          return result;
        case 4uLL:
          uint64_t v70 = v11 + 1;
          unint64_t v71 = (unint64_t *)v11[1];
          unint64_t v72 = v11 + 2;
          unint64_t v73 = v11[2];
          unint64_t v74 = (unint64_t *)*v11;
          if ((unint64_t)v71 >= *v11)
          {
            if (v73 >= (unint64_t)v71) {
              goto LABEL_174;
            }
            *uint64_t v70 = v73;
            *unint64_t v72 = (unint64_t)v71;
            uint64_t v75 = v11;
            unint64_t v76 = (unint64_t **)(v11 + 1);
            __n128 result = (uint64_t)v71;
            if (v73 >= (unint64_t)v74) {
              goto LABEL_175;
            }
          }
          else
          {
            uint64_t v75 = v11;
            unint64_t v76 = (unint64_t **)(v11 + 2);
            __n128 result = *v11;
            if (v73 >= (unint64_t)v71)
            {
              *unint64_t v11 = (unint64_t)v71;
              v11[1] = (unint64_t)v74;
              uint64_t v75 = v11 + 1;
              unint64_t v76 = (unint64_t **)(v11 + 2);
              __n128 result = (uint64_t)v74;
              if (v73 >= (unint64_t)v74)
              {
LABEL_174:
                unint64_t v71 = (unint64_t *)v73;
LABEL_175:
                if (*v10 < (unint64_t)v71)
                {
                  *unint64_t v72 = *v10;
                  *uint64_t v10 = (unint64_t)v71;
                  unint64_t v113 = *v72;
                  unint64_t v114 = *v70;
                  if (v113 < v114)
                  {
                    v11[1] = v113;
                    v11[2] = v114;
                    unint64_t v115 = *v11;
                    if (v113 < *v11)
                    {
                      *unint64_t v11 = v113;
                      v11[1] = v115;
                    }
                  }
                }
                return result;
              }
            }
          }
          *uint64_t v75 = v73;
          *unint64_t v76 = v74;
          unint64_t v71 = (unint64_t *)result;
          goto LABEL_175;
        case 5uLL:
          return (uint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,md::RoadPosition **>(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
        default:
          JUMPOUT(0);
      }
    }
    if (v12 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v11 != a2)
      {
        int64_t v87 = (v13 - 2) >> 1;
        int64_t v88 = v87;
        do
        {
          if (v87 >= v88)
          {
            uint64_t v90 = (2 * v88) | 1;
            BOOL v91 = &v11[v90];
            if (2 * v88 + 2 < (uint64_t)v13)
            {
              unint64_t v93 = v91[1];
              BOOL v92 = *v91 >= v93;
              if (*v91 < v93) {
                ++v91;
              }
              else {
                unint64_t v93 = *v91;
              }
              if (!v92) {
                uint64_t v90 = 2 * v88 + 2;
              }
            }
            else
            {
              unint64_t v93 = *v91;
            }
            unint64_t v94 = &v11[v88];
            unint64_t v95 = *v94;
            if (v93 >= *v94)
            {
              while (1)
              {
                unint64_t *v94 = v93;
                unint64_t v94 = v91;
                if (v87 < v90) {
                  break;
                }
                uint64_t v96 = (2 * v90) | 1;
                BOOL v91 = &v11[v96];
                uint64_t v90 = 2 * v90 + 2;
                if (v90 < (uint64_t)v13)
                {
                  unint64_t v93 = *v91;
                  __n128 result = (uint64_t)(v91 + 1);
                  if (*v91 >= v91[1])
                  {
                    uint64_t v90 = v96;
                  }
                  else
                  {
                    unint64_t v93 = v91[1];
                    ++v91;
                  }
                  if (v93 < v95) {
                    break;
                  }
                }
                else
                {
                  unint64_t v93 = *v91;
                  uint64_t v90 = v96;
                  if (*v91 < v95) {
                    break;
                  }
                }
              }
              unint64_t *v94 = v95;
            }
          }
          BOOL v89 = v88-- <= 0;
        }
        while (!v89);
        uint64_t v101 = (unint64_t)v12 >> 3;
        do
        {
          uint64_t v102 = 0;
          unint64_t v103 = *v11;
          unint64_t v104 = v11;
          do
          {
            unint64_t v106 = &v104[v102 + 1];
            uint64_t v107 = (2 * v102) | 1;
            uint64_t v102 = 2 * v102 + 2;
            if (v102 < v101)
            {
              unint64_t v105 = *v106;
              if (*v106 >= v106[1])
              {
                uint64_t v102 = v107;
              }
              else
              {
                unint64_t v105 = v106[1];
                ++v106;
              }
            }
            else
            {
              unint64_t v105 = *v106;
              uint64_t v102 = v107;
            }
            *unint64_t v104 = v105;
            unint64_t v104 = v106;
          }
          while (v102 <= (uint64_t)((unint64_t)(v101 - 2) >> 1));
          if (v106 == --a2)
          {
            *unint64_t v106 = v103;
          }
          else
          {
            *unint64_t v106 = *a2;
            *a2 = v103;
            uint64_t v108 = (char *)v106 - (char *)v11 + 8;
            if (v108 >= 9)
            {
              unint64_t v109 = (((unint64_t)v108 >> 3) - 2) >> 1;
              unint64_t v110 = &v11[v109];
              unint64_t v111 = *v110;
              unint64_t v112 = *v106;
              if (*v110 < *v106)
              {
                do
                {
                  *unint64_t v106 = v111;
                  unint64_t v106 = v110;
                  if (!v109) {
                    break;
                  }
                  unint64_t v109 = (v109 - 1) >> 1;
                  unint64_t v110 = &v11[v109];
                  unint64_t v111 = *v110;
                }
                while (*v110 < v112);
                *unint64_t v106 = v112;
              }
            }
          }
          BOOL v89 = v101-- <= 2;
        }
        while (!v89);
      }
      return result;
    }
    unint64_t v14 = v13 >> 1;
    uint64_t v15 = &v11[v13 >> 1];
    unint64_t v16 = *v10;
    if ((unint64_t)v12 >= 0x401)
    {
      unint64_t v17 = *v15;
      unint64_t v18 = *v11;
      if (*v15 >= *v11)
      {
        if (v16 < v17)
        {
          *uint64_t v15 = v16;
          *uint64_t v10 = v17;
          unint64_t v21 = *v11;
          if (*v15 < *v11)
          {
            *unint64_t v11 = *v15;
            *uint64_t v15 = v21;
          }
        }
      }
      else
      {
        if (v16 < v17)
        {
          *unint64_t v11 = v16;
          goto LABEL_22;
        }
        *unint64_t v11 = v17;
        *uint64_t v15 = v18;
        if (*v10 < v18)
        {
          *uint64_t v15 = *v10;
LABEL_22:
          *uint64_t v10 = v18;
        }
      }
      uint64_t v23 = &v11[v14];
      unint64_t v26 = *(v23 - 1);
      uint64_t v24 = v23 - 1;
      unint64_t v25 = v26;
      unint64_t v27 = v11[1];
      unint64_t v28 = *(a2 - 2);
      if (v26 >= v27)
      {
        if (v28 < v25)
        {
          *uint64_t v24 = v28;
          *(a2 - 2) = v25;
          unint64_t v29 = v11[1];
          if (*v24 < v29)
          {
            v11[1] = *v24;
            *uint64_t v24 = v29;
          }
        }
      }
      else
      {
        if (v28 < v25)
        {
          v11[1] = v28;
          goto LABEL_34;
        }
        v11[1] = v25;
        *uint64_t v24 = v27;
        unint64_t v30 = *(a2 - 2);
        if (v30 < v27)
        {
          *uint64_t v24 = v30;
LABEL_34:
          *(a2 - 2) = v27;
        }
      }
      unint64_t v31 = &v11[v14];
      unint64_t v34 = v31[1];
      uint64_t v32 = v31 + 1;
      unint64_t v33 = v34;
      unint64_t v35 = v11[2];
      unint64_t v36 = *(a2 - 3);
      if (v34 >= v35)
      {
        if (v36 < v33)
        {
          *uint64_t v32 = v36;
          *(a2 - 3) = v33;
          unint64_t v37 = v11[2];
          if (*v32 < v37)
          {
            v11[2] = *v32;
            *uint64_t v32 = v37;
          }
        }
      }
      else
      {
        if (v36 < v33)
        {
          v11[2] = v36;
          goto LABEL_43;
        }
        v11[2] = v33;
        *uint64_t v32 = v35;
        unint64_t v38 = *(a2 - 3);
        if (v38 < v35)
        {
          *uint64_t v32 = v38;
LABEL_43:
          *(a2 - 3) = v35;
        }
      }
      unint64_t v39 = *v15;
      unint64_t v40 = *v24;
      unint64_t v41 = *v32;
      if (*v15 >= *v24)
      {
        if (v41 >= v39) {
          goto LABEL_52;
        }
        *uint64_t v15 = v41;
        *uint64_t v32 = v39;
        uint64_t v32 = &v11[v13 >> 1];
        unint64_t v39 = v40;
        if (v41 >= v40)
        {
          unint64_t v39 = v41;
          goto LABEL_52;
        }
      }
      else if (v41 >= v39)
      {
        *uint64_t v24 = v39;
        *uint64_t v15 = v40;
        uint64_t v24 = &v11[v13 >> 1];
        unint64_t v39 = v41;
        if (v41 >= v40)
        {
          unint64_t v39 = v40;
LABEL_52:
          unint64_t v42 = *v11;
          *unint64_t v11 = v39;
          *uint64_t v15 = v42;
          goto LABEL_53;
        }
      }
      *uint64_t v24 = v41;
      *uint64_t v32 = v40;
      goto LABEL_52;
    }
    unint64_t v19 = *v11;
    unint64_t v20 = *v15;
    if (*v11 >= *v15)
    {
      if (v16 < v19)
      {
        *unint64_t v11 = v16;
        *uint64_t v10 = v19;
        unint64_t v22 = *v15;
        if (*v11 < *v15)
        {
          *uint64_t v15 = *v11;
          *unint64_t v11 = v22;
        }
      }
      goto LABEL_53;
    }
    if (v16 >= v19)
    {
      *uint64_t v15 = v19;
      *unint64_t v11 = v20;
      if (*v10 >= v20) {
        goto LABEL_53;
      }
      *unint64_t v11 = *v10;
    }
    else
    {
      *uint64_t v15 = v16;
    }
    *uint64_t v10 = v20;
LABEL_53:
    --a3;
    unint64_t v43 = *v11;
    __int16 v44 = v11;
    if ((a4 & 1) != 0 || (__int16 v44 = v11, *(v11 - 1) < v43))
    {
      do
      {
        long long v45 = v44;
        unint64_t v47 = v44[1];
        ++v44;
        unint64_t v46 = v47;
      }
      while (v47 < v43);
      uint64_t v48 = a2;
      if (v45 == v11)
      {
        uint64_t v48 = a2;
        do
        {
          if (v44 >= v48) {
            break;
          }
          unint64_t v50 = *--v48;
        }
        while (v50 >= v43);
      }
      else
      {
        do
          unint64_t v49 = *--v48;
        while (v49 >= v43);
      }
      if (v44 < v48)
      {
        unint64_t v51 = *v48;
        unint64_t v52 = v44;
        uint64_t v53 = v48;
        do
        {
          unint64_t *v52 = v51;
          unint64_t *v53 = v46;
          do
          {
            long long v45 = v52;
            unint64_t v54 = v52[1];
            ++v52;
            unint64_t v46 = v54;
          }
          while (v54 < v43);
          do
          {
            unint64_t v55 = *--v53;
            unint64_t v51 = v55;
          }
          while (v55 >= v43);
        }
        while (v52 < v53);
      }
      if (v45 != v11) {
        *unint64_t v11 = *v45;
      }
      *long long v45 = v43;
      if (v44 < v48) {
        goto LABEL_73;
      }
      BOOL v56 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,md::RoadPosition **>(v11, v45);
      unint64_t v11 = v45 + 1;
      __n128 result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,md::RoadPosition **>(v45 + 1, a2);
      if (result)
      {
        a2 = v45;
        if (v56) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v56)
      {
LABEL_73:
        __n128 result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,md::RoadPosition **,false>(v9, v45, a3, a4 & 1);
        a4 = 0;
        unint64_t v11 = v45 + 1;
      }
    }
    else
    {
      if (v43 < *v10)
      {
        do
        {
          unint64_t v57 = v11[1];
          ++v11;
        }
        while (v43 >= v57);
      }
      else
      {
        unint64_t v58 = v11 + 1;
        do
        {
          unint64_t v11 = v58;
          if (v58 >= a2) {
            break;
          }
          ++v58;
        }
        while (v43 >= *v11);
      }
      unint64_t v59 = a2;
      if (v11 < a2)
      {
        unint64_t v59 = a2;
        do
          unint64_t v60 = *--v59;
        while (v43 < v60);
      }
      if (v11 < v59)
      {
        unint64_t v61 = *v11;
        unint64_t v62 = *v59;
        do
        {
          *unint64_t v11 = v62;
          *unint64_t v59 = v61;
          do
          {
            unint64_t v63 = v11[1];
            ++v11;
            unint64_t v61 = v63;
          }
          while (v43 >= v63);
          do
          {
            unint64_t v64 = *--v59;
            unint64_t v62 = v64;
          }
          while (v43 < v64);
        }
        while (v11 < v59);
      }
      unint64_t v65 = v11 - 1;
      BOOL v4 = v11 - 1 >= v9;
      BOOL v5 = v11 - 1 == v9;
      if (v11 - 1 != v9) {
        *unint64_t v9 = *v65;
      }
      a4 = 0;
      *unint64_t v65 = v43;
    }
  }
  unint64_t v77 = v11 + 1;
  BOOL v79 = v11 == a2 || v77 == a2;
  if (a4)
  {
    if (!v79)
    {
      uint64_t v80 = 8;
      uint64_t v81 = v11;
      do
      {
        unint64_t v84 = *v81;
        unint64_t v83 = v81[1];
        uint64_t v81 = v77;
        if (v83 < v84)
        {
          uint64_t v85 = v80;
          do
          {
            *(unint64_t *)((char *)v11 + v85) = v84;
            uint64_t v86 = v85 - 8;
            if (v85 == 8)
            {
              unint64_t v82 = v11;
              goto LABEL_116;
            }
            unint64_t v84 = *(unint64_t *)((char *)v11 + v85 - 16);
            v85 -= 8;
          }
          while (v83 < v84);
          unint64_t v82 = (unint64_t *)((char *)v11 + v86);
LABEL_116:
          *unint64_t v82 = v83;
        }
        unint64_t v77 = v81 + 1;
        v80 += 8;
      }
      while (v81 + 1 != a2);
    }
  }
  else if (!v79)
  {
    do
    {
      unint64_t v100 = *v9;
      unint64_t v99 = v9[1];
      unint64_t v9 = v77;
      if (v99 < v100)
      {
        do
        {
          unint64_t *v77 = v100;
          unint64_t v100 = *(v77 - 2);
          --v77;
        }
        while (v99 < v100);
        unint64_t *v77 = v99;
      }
      unint64_t v77 = v9 + 1;
    }
    while (v9 + 1 != a2);
  }
  return result;
}

uint64_t md::MapNavLabeler::stylesheetAnimationDidFinish(md::MapNavLabeler *this)
{
  unint64_t v2 = (uint64_t **)*((void *)this + 9);
  md::LabelFeatureStyler::restyleFeatures((*v2)[37], v2 + 18);
  uint64_t v3 = *v2;
  *((unsigned char *)v3 + 3041) = 1;
  unsigned __int8 v4 = atomic_load((unsigned __int8 *)v3 + 3058);
  if (v4)
  {
    uint64_t v5 = v3[17];
    if (v5)
    {
      uint64_t v6 = *(void *)(v5 + 56);
      if (v6)
      {
        uint64_t v10 = v3;
        char v9 = 9;
        (*(void (**)(uint64_t, uint64_t **, char *))(*(void *)v6 + 48))(v6, &v10, &v9);
      }
    }
  }
  unint64_t v7 = (void *)*((void *)this + 7);
  return [v7 styleManagerDidFinishAnimating];
}

void *md::LabelManager::startStylesheetLabelAnimations(md::LabelManager *this)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  v15[0] = &unk_1EF56F0F0;
  unint64_t v16 = v15;
  v13[0] = &unk_1EF56F138;
  unint64_t v14 = v13;
  unint64_t v18 = v17;
  v17[0] = &unk_1EF56F138;
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  unint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v12 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsStylesheetLabelAnimations", "", v12, 2u);
  }

  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
  }
  else if (v14)
  {
    (*(void (**)(void))(*v14 + 40))();
  }
  if (v16 == v15)
  {
    (*(void (**)(void *))(v15[0] + 32))(v15);
  }
  else if (v16)
  {
    (*(void (**)(void))(*v16 + 40))();
  }
  *((unsigned char *)this + 3376) = 0;
  uint64_t v3 = *((void *)this + 34);
  uint64_t v4 = *(void *)(v3 + 24);
  for (uint64_t i = *(void *)(v3 + 32); i != v4; i -= 16)
  {
    uint64_t v6 = *(std::__shared_weak_count **)(i - 8);
    if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  *(void *)(v3 + 32) = v4;
  *(unsigned char *)(v3 + 60) = 1;
  uint64_t v7 = *((void *)this + 37);
  int v8 = *(_DWORD *)(v7 + 12);
  BOOL v9 = __CFADD__(v8, 1);
  unsigned int v10 = v8 + 1;
  *(_DWORD *)(v7 + 12) = v10;
  if (v9)
  {
    *(void *)(v7 + 12) = 0x100000002;
    unsigned int v10 = 2;
  }
  atomic_store(v10, (unsigned int *)(v7 + 8));
  (*(void (**)(void))(**((void **)this + 30) + 144))(*((void *)this + 30));
  md::LabelTextDataLoader::finishBatch(*((md::LabelTextDataLoader **)this + 34));
  (*(void (**)(void))(**(void **)(*((void *)this + 21) + 72) + 8))(*(void *)(*((void *)this + 21)
                                                                                                  + 72));
  if (!v18)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
  (*(void (**)(void *))(*v18 + 48))(v18);
  __n128 result = v18;
  if (v18 == v17) {
    return (void *)(*(uint64_t (**)(void *))(v17[0] + 32))(v17);
  }
  if (v18) {
    return (void *)(*(uint64_t (**)(void))(*v18 + 40))();
  }
  return result;
}

void sub_1A1BE977C(_Unwind_Exception *exception_object)
{
}

void sub_1A1BE9788(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t *a21)
{
  if (a21 == &a18)
  {
    (*(void (**)(uint64_t *))(a18 + 32))(&a18);
    _Unwind_Resume(exception_object);
  }
  if (!a21) {
    _Unwind_Resume(exception_object);
  }
  (*(void (**)(void))(*a21 + 40))();
  _Unwind_Resume(exception_object);
}

void sub_1A1BE9804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0,std::allocator<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  v13[0] = &unk_1EF57E3B8;
  unint64_t v14 = v13;
  v11[0] = &unk_1EF57E370;
  uint64_t v12 = v11;
  unint64_t v16 = v15;
  v15[0] = &unk_1EF57E370;
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  unint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsBgkdLayout", "", buf, 2u);
  }

  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
  }
  else if (v14)
  {
    (*(void (**)(void))(*v14 + 40))();
  }
  md::LabelManager::layoutForStaging(*(void *)(a1 + 8), a1 + 24);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(a1 + 8) + 216));
  uint64_t v3 = (std::recursive_mutex *)(*(void *)(a1 + 8) + 24);
  std::recursive_mutex::lock(v3);
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(unsigned __int8 *)(v4 + 3305) == *(unsigned __int8 *)(a1 + 36))
  {
    *(_WORD *)(v4 + 3384) = 1;
    unsigned __int8 v5 = atomic_load((unsigned __int8 *)(v4 + 3058));
    if (v5)
    {
      uint64_t v6 = *(void *)(v4 + 136);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 + 56);
        if (v7)
        {
          *(void *)buf = v4;
          char v9 = 9;
          (*(void (**)(uint64_t, uint8_t *, char *))(*(void *)v7 + 48))(v7, buf, &v9);
        }
      }
    }
  }
  std::recursive_mutex::unlock(v3);
  if (!v16)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
    JUMPOUT(0x1A1BE9B80);
  }
  (*(void (**)(void *))(*v16 + 48))(v16);
  uint64_t result = (uint64_t)v16;
  if (v16 == v15) {
    return (*(uint64_t (**)(void *))(v15[0] + 32))(v15);
  }
  if (v16) {
    return (*(uint64_t (**)(void *))(*v16 + 40))(v16);
  }
  return result;
}

void sub_1A1BE9BA8(_Unwind_Exception *exception_object)
{
}

void sub_1A1BE9BB4()
{
}

uint64_t md::LabelManager::layoutForStaging(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 320);
  *(void *)(v4 + 136) = 0;
  *(_DWORD *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 88) = 0;
  unsigned __int8 v5 = *(char **)(v4 + 56);
  uint64_t v6 = *(char **)(v4 + 64);
  if (v5 != v6)
  {
    unint64_t v7 = v6 - v5 - 24;
    if (v7 < 0x18) {
      goto LABEL_7;
    }
    unint64_t v8 = v7 / 0x18 + 1;
    char v9 = v5;
    uint64_t v10 = v8 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(void *)char v9 = 0;
      *((void *)v9 + 3) = 0;
      v9 += 48;
      v10 -= 2;
    }
    while (v10);
    if (v8 != (v8 & 0x1FFFFFFFFFFFFFFELL))
    {
      v5 += 24 * (v8 & 0x1FFFFFFFFFFFFFFELL);
      do
      {
LABEL_7:
        *(void *)unsigned __int8 v5 = 0;
        v5 += 24;
      }
      while (v5 != v6);
    }
  }
  if (*(unsigned char *)(*(void *)(a1 + 432) + 21) || *(unsigned char *)(a1 + 3052))
  {
    if (*(unsigned char *)(a1 + 3051)) {
      (*(void (**)(void))(**(void **)(a1 + 240) + 120))(*(void *)(a1 + 240));
    }
    *(unsigned char *)(a1 + 3052) = 0;
  }
  uint64_t v11 = *(void *)(*(void *)(a1 + 336) + 200);
  if (*(unsigned char *)(v11 + 88))
  {
    *(_WORD *)(v11 + 88) = 256;
    operator new();
  }
  *(_DWORD *)(*(void *)(a1 + 3144) + 160) = *(_DWORD *)(a2 + 8);
  uint64_t v12 = *(void *)(a1 + 272);
  uint64_t v13 = *(void *)(v12 + 24);
  for (uint64_t i = *(void *)(v12 + 32); i != v13; i -= 16)
  {
    uint64_t v15 = *(std::__shared_weak_count **)(i - 8);
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  *(void *)(v12 + 32) = v13;
  *(unsigned char *)(v12 + 60) = 1;
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 240) + 40))(*(void *)(a1 + 240), a2);
  md::LabelTextDataLoader::finishBatch(*(md::LabelTextDataLoader **)(a1 + 272));
  uint64_t result = md::FontGlyphCache::finishFrame(*(void *)(a1 + 3144));
  if (!*(void *)(a1 + 184) && *(unsigned char *)(a1 + 3051))
  {
    uint64_t v17 = *(uint64_t (**)(void))(**(void **)(a1 + 240) + 128);
    return v17();
  }
  return result;
}

void sub_1A1BEA6B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,std::__shared_weak_count *a35)
{
  std::__tree<std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>>>::destroy(a20);
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&a29);
  unint64_t v36 = a35;
  if (a35)
  {
    if (!atomic_fetch_add(&a35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t md::FontGlyphCache::finishFrame(uint64_t this)
{
  uint64_t v1 = (_DWORD *)this;
  unsigned int v2 = *(_DWORD *)(this + 152);
  if (*(unsigned char *)(this + 164))
  {
    if (v2)
    {
      do
      {
        uint64_t v3 = *(void *)(*(void *)v1 + 32);
        if (*(void *)(v3 + 96)) {
          break;
        }
        unsigned int v4 = atomic_load((unsigned int *)(v3 + 52));
        int v5 = v4 - v1[40];
        if (v5 < 0) {
          int v5 = -v5;
        }
        if (*(unsigned char *)(v3 + 108))
        {
          unsigned __int8 v6 = atomic_load((unsigned __int8 *)(v3 + 109));
          if ((v6 & 1) == 0) {
            break;
          }
        }
        if (v5 < 0x1F5) {
          break;
        }
        this = md::FontGlyphCache::eraseGlyph((uint64_t)v1, *(float **)v1);
      }
      while (v1[38]);
    }
  }
  else if (v2 >= 0x101)
  {
    do
    {
      unint64_t v7 = *(float **)v1;
      if (v2 <= 0x3FF)
      {
        unsigned int v8 = atomic_load((unsigned int *)(*((void *)v7 + 4) + 52));
        int v9 = v8 - v1[40];
        if (v9 < 0) {
          int v9 = -v9;
        }
        if (v9 < 0xC9) {
          break;
        }
      }
      this = md::FontGlyphCache::eraseGlyph((uint64_t)v1, v7);
      unsigned int v2 = v1[38];
    }
    while (v2 > 0x100);
  }
  return this;
}

void md::LabelTextDataLoader::finishBatch(md::LabelTextDataLoader *this)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  *((unsigned char *)this + 60) = 0;
  if (*((void *)this + 3) != *((void *)this + 4))
  {
    unsigned __int8 v2 = atomic_load((unsigned __int8 *)(*((void *)this + 2) + 3393));
    if (v2)
    {
      uint64_t v16 = *((void *)this + 3);
      for (uint64_t i = *((void *)this + 4); i != v16; i -= 16)
      {
        unint64_t v18 = *(std::__shared_weak_count **)(i - 8);
        if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      *((void *)this + 4) = v16;
    }
    else
    {
      uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 1);
      uint64_t v46 = *(void *)this;
      unint64_t v47 = v3;
      if (v3) {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v4 = *((void *)this + 2);
      int v5 = *(std::__shared_weak_count **)(v4 + 16);
      uint64_t v44 = *(void *)(v4 + 8);
      if (v5 && (long long v45 = std::__shared_weak_count::lock(v5)) != 0)
      {
        {
          operator new();
        }
        uint64_t v6 = mdm::Allocator::instance(void)::alloc;
        long long v41 = *(_OWORD *)((char *)this + 24);
        *(_OWORD *)((char *)this + 24) = 0u;
        uint64_t v42 = *((void *)this + 5);
        uint64_t v43 = v6;
        *((void *)this + 5) = 0;
        atomic_fetch_add((atomic_uint *volatile)this + 14, 1u);
        uint64_t v7 = *(void *)(*(void *)(*((void *)this + 2) + 152) + 104);
        uint64_t v32 = 0;
        long long v33 = 0u;
        uint64_t v8 = v43;
        uint64_t v34 = v43;
        long long v9 = v41;
        uint64_t v10 = *((void *)&v41 + 1) - v41;
        if (*((void *)&v41 + 1) == (void)v41)
        {
          uint64_t v19 = 0;
          uint64_t v12 = 0;
        }
        else
        {
          if (v10 < 0) {
            abort();
          }
          uint64_t v11 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v43 + 16))(v43, *((void *)&v41 + 1) - v41, 8);
          uint64_t v12 = v11;
          uint64_t v13 = 0;
          uint64_t v10 = v11 + 16 * (v10 >> 4);
          uint64_t v32 = v11;
          *((void *)&v33 + 1) = v10;
          do
          {
            if (v11 + v13)
            {
              unint64_t v14 = (void *)(v11 + v13);
              void *v14 = *(void *)(v9 + v13);
              uint64_t v15 = *(void *)(v9 + v13 + 8);
              v14[1] = v15;
              if (v15) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
              }
            }
            v13 += 16;
          }
          while ((void)v9 + v13 != *((void *)&v9 + 1));
          uint64_t v19 = v11 + v13;
          *(void *)&long long v33 = v11 + v13;
        }
        uint64_t v21 = v44;
        unint64_t v20 = v45;
        uint64_t v35 = v44;
        unint64_t v36 = v45;
        if (v45) {
          atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v22 = v46;
        uint64_t v23 = v47;
        uint64_t v37 = v46;
        unint64_t v38 = v47;
        if (v47) {
          atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v24 = operator new(0x48uLL);
        *uint64_t v24 = &unk_1EF5748B0;
        v24[1] = v12;
        v24[2] = v19;
        v24[3] = v10;
        long long v33 = 0uLL;
        uint64_t v32 = 0;
        v24[4] = v8;
        v24[5] = v21;
        uint64_t v35 = 0;
        unint64_t v36 = 0;
        v24[6] = v20;
        v24[7] = v22;
        v24[8] = v23;
        uint64_t v37 = 0;
        unint64_t v38 = 0;
        unint64_t v49 = v24;
        geo::TaskQueue::async(&v39, v7, v48);
        unint64_t v25 = v40;
        if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
        if (v49 == v48)
        {
          (*(void (**)(void *))(v48[0] + 32))(v48);
        }
        else if (v49)
        {
          (*(void (**)(void *))(*v49 + 40))(v49);
        }
        md::LabelTextDataLoader::finishBatch(void)::$_0::~$_0(&v32);
        uint64_t v26 = v41;
        if ((void)v41)
        {
          uint64_t v27 = *((void *)&v41 + 1);
          uint64_t v28 = v41;
          if (*((void *)&v41 + 1) != (void)v41)
          {
            do
            {
              unint64_t v29 = *(std::__shared_weak_count **)(v27 - 8);
              if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *, uint64_t))v29->__on_zero_shared)(v29, v28);
                std::__shared_weak_count::__release_weak(v29);
              }
              v27 -= 16;
            }
            while (v27 != v26);
            uint64_t v28 = v41;
          }
          *((void *)&v41 + 1) = v26;
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v43 + 40))(v43, v28, v42 - v28);
        }
        unint64_t v30 = v45;
        if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
        }
        unint64_t v31 = v47;
        if (v47)
        {
          if (!atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
            std::__shared_weak_count::__release_weak(v31);
          }
        }
      }
      else
      {
        std::__throw_bad_weak_ptr[abi:nn180100]();
        __break(1u);
      }
    }
  }
}

void sub_1A1BEADA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,char a26)
{
  std::function<void ()(void)>::~function((void *)(v26 - 120));
  md::LabelTextDataLoader::finishBatch(void)::$_0::~$_0(&a9);
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100](&a19);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a24);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a26);
  _Unwind_Resume(a1);
}

uint64_t md::CompositeLabeler::layoutForStaging(uint64_t result, uint64_t a2)
{
  unsigned __int8 v2 = *(uint64_t **)(result + 8);
  for (uint64_t i = *(uint64_t **)(result + 16);
        v2 != i;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 40))(v5, a2))
  {
    uint64_t v5 = *v2++;
  }
  return result;
}

void std::__function::__func<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#2},std::allocator<md::LabelManager::evaluateUpdateOperation(BOOL &,BOOL &)::$_0::operator() const(void)::{lambda(void)#2}>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "LabelsBgkdLayout", "", v1, 2u);
  }
}

uint64_t md::CompositeLabeler::restyleActiveLabels(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 8);
  for (uint64_t i = *(uint64_t **)(this + 16); v1 != i; this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 144))(v3))
    uint64_t v3 = *v1++;
  return this;
}

void md::RouteLineSupport::restyleFeatures(md::RouteLineSupport *this)
{
  uint64_t v2 = *((void *)this + 11);
  uint64_t v3 = *((void *)this + 12);
  unint64_t v63 = 0;
  uint64_t i = 0;
  unint64_t v62 = 0;
  {
    operator new();
  }
  uint64_t v4 = mdm::Allocator::instance(void)::alloc;
  uint64_t v65 = mdm::Allocator::instance(void)::alloc;
  uint64_t v5 = v3 - v2;
  if (v3 == v2)
  {
    uint64_t v12 = 0;
    uint64_t v8 = v62;
  }
  else
  {
    if (v5 < 0) {
      abort();
    }
    uint64_t v6 = v5 >> 4;
    uint64_t v7 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc);
    uint64_t v8 = v7;
    uint64_t v9 = 0;
    unint64_t v62 = v7;
    uint64_t i = &v7[2 * v6];
    do
    {
      if (&v7[v9])
      {
        uint64_t v10 = &v7[v9];
        *uint64_t v10 = *(void *)(v2 + v9 * 8);
        uint64_t v11 = *(void *)(v2 + v9 * 8 + 8);
        v10[1] = v11;
        if (v11) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
        }
      }
      v9 += 2;
    }
    while (v2 + v9 * 8 != v3);
    uint64_t v12 = &v7[v9];
    unint64_t v63 = v12;
  }
  unint64_t v14 = (char *)*((void *)this + 36);
  uint64_t v13 = (char *)*((void *)this + 37);
  if (v13 - v14 >= 1)
  {
    uint64_t v15 = (v13 - v14) >> 4;
    unint64_t v16 = (char *)v12 - (char *)v8;
    uint64_t v17 = ((char *)v12 - (char *)v8) >> 4;
    unint64_t v18 = (uint64_t *)((char *)v8 + (((char *)v12 - (char *)v8) & 0xFFFFFFFFFFFFFFF0));
    uint64_t v19 = v63;
    if (v15 > ((char *)i - (char *)v63) >> 4)
    {
      unint64_t v20 = v15 + (((char *)v63 - (char *)v8) >> 4);
      if (v20 >> 60) {
        abort();
      }
      uint64_t v21 = (char *)i - (char *)v8;
      if (i - v8 > v20) {
        unint64_t v20 = v21 >> 3;
      }
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
        uint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v22 = v20;
      }
      if (v22) {
        uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 16))(v4, 16 * v22, 8);
      }
      else {
        uint64_t v23 = 0;
      }
      unint64_t v30 = (uint64_t *)(v23 + 16 * v17);
      uint64_t v31 = 16 * v15;
      uint64_t v32 = &v30[2 * v15];
      long long v33 = (uint64_t *)(v14 + 8);
      uint64_t v34 = v30;
      do
      {
        if (v34)
        {
          *uint64_t v34 = *(v33 - 1);
          uint64_t v35 = *v33;
          v34[1] = *v33;
          if (v35) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v35 + 8), 1uLL, memory_order_relaxed);
          }
        }
        v34 += 2;
        v33 += 2;
        v31 -= 16;
      }
      while (v31);
      if (v16 >= 0x10)
      {
        uint64_t v36 = 2 * v17;
        uint64_t v37 = v8 - 2;
        do
        {
          unint64_t v38 = &v37[v36];
          *(_OWORD *)(v23 + v36 * 8 - 16) = *(_OWORD *)&v37[v36];
          uint64_t *v38 = 0;
          v38[1] = 0;
          v36 -= 2;
        }
        while (v36 * 8);
        unint64_t v30 = (uint64_t *)v23;
      }
      unint64_t v39 = v63;
      if (v63 != v18)
      {
        do
        {
          *(_OWORD *)uint64_t v32 = *(_OWORD *)v18;
          v32 += 2;
          *unint64_t v18 = 0;
          v18[1] = 0;
          v18 += 2;
        }
        while (v18 != v39);
        unint64_t v18 = v39;
      }
      unint64_t v40 = v62;
      long long v41 = i;
      unint64_t v62 = v30;
      unint64_t v63 = v32;
      for (uint64_t i = (uint64_t *)(v23 + 16 * v22); v18 != v40; v18 -= 2)
      {
        uint64_t v42 = (std::__shared_weak_count *)*(v18 - 1);
        if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
          std::__shared_weak_count::__release_weak(v42);
        }
      }
      if (v40) {
        (*(void (**)(uint64_t, uint64_t *, int64_t))(*(void *)v65 + 40))(v65, v40, (char *)v41 - (char *)v40);
      }
      goto LABEL_71;
    }
    uint64_t v24 = (char *)v63 - (char *)v18;
    uint64_t v25 = ((char *)v63 - (char *)v18) >> 4;
    if (v25 >= v15)
    {
      uint64_t v26 = &v14[16 * v15];
      uint64_t v28 = v63;
LABEL_52:
      uint64_t v43 = (char *)&v18[2 * v15];
      uint64_t v44 = &v28[-2 * v15];
      long long v45 = v28;
      if (v44 < v19)
      {
        long long v45 = v28;
        do
        {
          if (v45)
          {
            *(_OWORD *)long long v45 = *(_OWORD *)v44;
            uint64_t *v44 = 0;
            v44[1] = 0;
          }
          v44 += 2;
          v45 += 2;
        }
        while (v44 < v19);
      }
      unint64_t v63 = v45;
      if (v28 != (uint64_t *)v43)
      {
        uint64_t v46 = (std::__shared_weak_count **)(v28 - 1);
        uint64_t v47 = 16 * (((char *)v28 - v43) >> 4);
        uint64_t v48 = (uint64_t)&v8[2 * v17 - 2];
        do
        {
          unint64_t v49 = (void *)(v48 + v47);
          long long v50 = *(_OWORD *)(v48 + v47);
          *unint64_t v49 = 0;
          v49[1] = 0;
          unint64_t v51 = *v46;
          *(_OWORD *)(v46 - 1) = v50;
          if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
            std::__shared_weak_count::__release_weak(v51);
          }
          v46 -= 2;
          v47 -= 16;
        }
        while (v47);
      }
      for (; v14 != v26; v18 += 2)
      {
        uint64_t v53 = *(void *)v14;
        uint64_t v52 = *((void *)v14 + 1);
        if (v52) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v52 + 8), 1uLL, memory_order_relaxed);
        }
        unint64_t v54 = (std::__shared_weak_count *)v18[1];
        *unint64_t v18 = v53;
        v18[1] = v52;
        if (v54 && !atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
          std::__shared_weak_count::__release_weak(v54);
        }
        v14 += 16;
      }
      goto LABEL_71;
    }
    uint64_t v26 = &v14[16 * v25];
    if (v26 == v13)
    {
      uint64_t v28 = v63;
    }
    else
    {
      uint64_t v27 = (uint64_t *)&v14[16 * v25];
      uint64_t v28 = v63;
      do
      {
        if (v28)
        {
          uint64_t *v28 = *v27;
          uint64_t v29 = v27[1];
          v28[1] = v29;
          if (v29) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v29 + 8), 1uLL, memory_order_relaxed);
          }
        }
        v27 += 2;
        v28 += 2;
      }
      while (v27 != (uint64_t *)v13);
    }
    unint64_t v63 = v28;
    if (v24 >= 1) {
      goto LABEL_52;
    }
  }
LABEL_71:
  md::LabelFeatureStyler::styleExternalFeatures(*(unsigned int **)(*((void *)this + 1) + 296), &v62);
  uint64_t v55 = *((void *)this + 1);
  *(unsigned char *)(v55 + 3041) = 1;
  unsigned __int8 v56 = atomic_load((unsigned __int8 *)(v55 + 3058));
  if (v56)
  {
    uint64_t v57 = *(void *)(v55 + 136);
    if (v57)
    {
      uint64_t v58 = *(void *)(v57 + 56);
      if (v58)
      {
        uint64_t v67 = v55;
        char v66 = 9;
        (*(void (**)(uint64_t, uint64_t *, char *))(*(void *)v58 + 48))(v58, &v67, &v66);
      }
    }
  }
  unint64_t v59 = v62;
  if (v62)
  {
    unint64_t v60 = v63;
    if (v63 != v62)
    {
      do
      {
        unint64_t v61 = (std::__shared_weak_count *)*(v60 - 1);
        if (v61)
        {
          if (!atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
            std::__shared_weak_count::__release_weak(v61);
          }
        }
        v60 -= 2;
      }
      while (v60 != v59);
      unint64_t v59 = v62;
    }
    (*(void (**)(uint64_t, uint64_t *, int64_t))(*(void *)v65 + 40))(v65, v59, (char *)i - (char *)v59);
  }
}

void sub_1A1BEB5B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void md::LabelFeatureStyler::styleExternalFeatures(unsigned int *a1, uint64_t **a2)
{
  if (*a2 != a2[1])
  {
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    {
      operator new();
    }
    uint64_t v4 = mdm::Allocator::instance(void)::alloc;
    uint64_t v27 = mdm::Allocator::instance(void)::alloc;
    uint64_t v5 = (char *)a2[1] - (char *)*a2;
    if (!v5)
    {
      uint64_t v11 = 0;
      goto LABEL_33;
    }
    if (v5 < 0) {
      abort();
    }
    uint64_t v6 = v5 >> 4;
    uint64_t v7 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                      + 16))(mdm::Allocator::instance(void)::alloc, 24 * (v5 >> 4), 8);
    uint64_t v8 = v7;
    uint64_t v24 = v7;
    uint64_t v25 = v7;
    uint64_t v26 = &v7[24 * v6];
    uint64_t v9 = *a2;
    uint64_t v10 = a2[1];
    if (*a2 != v10)
    {
      uint64_t v11 = v7;
      do
      {
        uint64_t v12 = *v9;
        if (*(_DWORD *)(*v9 + 128) != a1[3])
        {
          uint64_t v13 = v26;
          if (v11 >= v26)
          {
            unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v11 - v8) >> 3);
            unint64_t v15 = v14 + 1;
            if (v14 + 1 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            if (0x5555555555555556 * ((v26 - v8) >> 3) > v15) {
              unint64_t v15 = 0x5555555555555556 * ((v26 - v8) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((v26 - v8) >> 3) >= 0x555555555555555) {
              uint64_t v16 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              uint64_t v16 = v15;
            }
            if (v16)
            {
              uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 16))(v4, 24 * v16, 8);
              uint64_t v18 = v17 + 24 * v14;
              uint64_t v19 = v17 + 24 * v16;
              if (v17)
              {
                *(void *)uint64_t v18 = v12;
                unint64_t v20 = v17 + 24 * v14;
                *(void *)(v20 + 8) = 0;
                *(void *)(v20 + 16) = 0;
              }
            }
            else
            {
              uint64_t v19 = 0;
              uint64_t v18 = 24 * v14;
            }
            uint64_t v22 = v24;
            uint64_t v21 = v25;
            uint64_t v8 = (char *)v18;
            if (v25 != v24)
            {
              do
              {
                long long v23 = *(_OWORD *)(v21 - 24);
                *((void *)v8 - 1) = *((void *)v21 - 1);
                *(_OWORD *)(v8 - 24) = v23;
                v8 -= 24;
                v21 -= 24;
              }
              while (v21 != v22);
              uint64_t v21 = v22;
            }
            uint64_t v11 = (char *)(v18 + 24);
            uint64_t v24 = v8;
            uint64_t v26 = (char *)v19;
            if (v21) {
              (*(void (**)(uint64_t, char *, int64_t))(*(void *)v4 + 40))(v4, v21, v13 - v21);
            }
          }
          else
          {
            if (v11)
            {
              *((void *)v11 + 1) = 0;
              *((void *)v11 + 2) = 0;
              *(void *)uint64_t v11 = v12;
            }
            v11 += 24;
          }
          uint64_t v25 = v11;
        }
        v9 += 2;
      }
      while (v9 != v10);
      if (v24 != v11)
      {
        md::LabelFeatureStyler::styleLabelFeatures(a1, &v24, 1u, 0, *(void *)(*(void *)(*(void *)a1 + 152) + 64));
        uint64_t v11 = v24;
        if (!v24) {
          return;
        }
        goto LABEL_34;
      }
LABEL_33:
      if (!v11) {
        return;
      }
      goto LABEL_34;
    }
    uint64_t v11 = v7;
    if (v7)
    {
LABEL_34:
      uint64_t v25 = v11;
      (*(void (**)(uint64_t, char *, int64_t))(*(void *)v27 + 40))(v27, v11, v26 - v11);
    }
  }
}

void sub_1A1BEB90C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a9) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 - a9);
  }
  _Unwind_Resume(exception_object);
}

void md::StandardLabeler::restyleActiveLabels(md::StandardLabeler *this)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 6);
  uint64_t v3 = (void **)(v2 + 192);
  uint64_t v4 = (uint64_t *)(v2 + 200);
  std::__tree<std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,std::__map_value_compare<std::pair<unsigned long long,md::LabelIdentifier>,std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,std::less<std::pair<unsigned long long,md::LabelIdentifier>>,true>,geo::StdAllocator<std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,mdm::Allocator>>::destroy(v2 + 192, *(void **)(v2 + 200));
  *(void *)(v2 + 216) = 0;
  *(void *)(v2 + 192) = v2 + 200;
  *(void *)(v2 + 200) = 0;
  uint64_t v5 = *(void **)(v2 + 224);
  if (v5 != (void *)(v2 + 232))
  {
    do
    {
      uint64_t v6 = *v4;
      uint64_t v7 = (uint64_t *)(v2 + 200);
      uint64_t v8 = v2 + 200;
      if (*v4)
      {
        unint64_t v9 = v5[4];
        unsigned int v10 = *((_DWORD *)v5 + 10);
        while (1)
        {
          while (1)
          {
            uint64_t v8 = v6;
            unint64_t v11 = *(void *)(v6 + 32);
            unsigned int v12 = *(_DWORD *)(v8 + 40);
            BOOL v13 = v10 < v12;
            if (v9 != v11) {
              BOOL v13 = v9 < v11;
            }
            if (!v13) {
              break;
            }
            uint64_t v6 = *(void *)v8;
            uint64_t v7 = (uint64_t *)v8;
            if (!*(void *)v8) {
              goto LABEL_16;
            }
          }
          BOOL v14 = v12 < v10;
          int v15 = v9 == v11 ? v14 : v11 < v9;
          if (v15 != 1) {
            break;
          }
          uint64_t v6 = *(void *)(v8 + 8);
          if (!v6)
          {
            uint64_t v7 = (uint64_t *)(v8 + 8);
            goto LABEL_16;
          }
        }
      }
      else
      {
LABEL_16:
        uint64_t v16 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 208) + 16))(*(void *)(v2 + 208), 64, 8);
        uint64_t v17 = (uint64_t *)v16;
        *(_OWORD *)(v16 + 32) = *((_OWORD *)v5 + 2);
        *(void *)(v16 + 48) = v5[6];
        uint64_t v18 = v5[7];
        *(void *)(v16 + 56) = v18;
        if (v18) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 16), 1uLL, memory_order_relaxed);
        }
        *(void *)uint64_t v16 = 0;
        *(void *)(v16 + 8) = 0;
        *(void *)(v16 + 16) = v8;
        *uint64_t v7 = v16;
        uint64_t v19 = (void *)**v3;
        if (v19)
        {
          std::__shared_weak_count *v3 = v19;
          uint64_t v17 = (uint64_t *)*v7;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v2 + 200), v17);
        ++*(void *)(v2 + 216);
      }
      unint64_t v20 = (void *)v5[1];
      if (v20)
      {
        do
        {
          uint64_t v21 = v20;
          unint64_t v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          uint64_t v21 = (void *)v5[2];
          BOOL v22 = *v21 == (void)v5;
          uint64_t v5 = v21;
        }
        while (!v22);
      }
      uint64_t v5 = v21;
    }
    while (v21 != (void *)(v2 + 232));
  }
  (*(void (**)(md::StandardLabeler *))(*(void *)this + 432))(this);
  md::LabelCustomFeatureSupport::updateStylesForFeatures(*((md::LabelCustomFeatureSupport **)this + 4));
  uint64_t v23 = *((void *)this + 5);
  if (*(void *)(v23 + 8) != *(void *)(v23 + 16)) {
    md::LabelFeatureStyler::styleExternalFeatures(*(unsigned int **)(*(void *)v23 + 296), (uint64_t **)(v23 + 8));
  }
  uint64_t v24 = (void *)*((void *)this + 6);
  if (v24[31])
  {
    uint64_t v25 = *((void *)this + 3);
    unint64_t v72 = 0;
    unint64_t v73 = 0;
    unint64_t v74 = 0;
    {
      operator new();
    }
    uint64_t v75 = mdm::Allocator::instance(void)::alloc;
    unint64_t v26 = v24[31];
    uint64_t v71 = v25;
    if (v26)
    {
      if (v26 >> 61) {
        abort();
      }
      uint64_t v27 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                     + 16))(mdm::Allocator::instance(void)::alloc, 8 * v26, 8);
      unint64_t v72 = v27;
      unint64_t v73 = v27;
      unint64_t v74 = &v27[v26];
    }
    else
    {
      uint64_t v27 = 0;
    }
    uint64_t v28 = (void *)v24[28];
    uint64_t v70 = v24;
    uint64_t v29 = v24 + 29;
    if (v28 != v24 + 29)
    {
      while (1)
      {
        uint64_t v30 = *(void *)(v28[6] + 8);
        uint64_t v31 = v74;
        if (v27 >= v74) {
          break;
        }
        if (v27) {
          *uint64_t v27 = v30;
        }
        ++v27;
LABEL_65:
        unint64_t v73 = v27;
        long long v50 = (void *)v28[1];
        if (v50)
        {
          do
          {
            unint64_t v51 = v50;
            long long v50 = (void *)*v50;
          }
          while (v50);
        }
        else
        {
          do
          {
            unint64_t v51 = (void *)v28[2];
            BOOL v22 = *v51 == (void)v28;
            uint64_t v28 = v51;
          }
          while (!v22);
        }
        uint64_t v28 = v51;
        if (v51 == v29) {
          goto LABEL_71;
        }
      }
      uint64_t v32 = v72;
      uint64_t v33 = v27 - v72;
      unint64_t v34 = v33 + 1;
      if ((unint64_t)(v33 + 1) >> 61) {
        abort();
      }
      if (((char *)v74 - (char *)v72) >> 2 > v34) {
        unint64_t v34 = ((char *)v74 - (char *)v72) >> 2;
      }
      if ((unint64_t)((char *)v74 - (char *)v72) >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v35 = v34;
      }
      if (v35)
      {
        uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v75 + 16))(v75, 8 * v35, 8);
        uint64_t v37 = (uint64_t *)(v36 + 8 * v33);
        uint64_t v38 = v36 + 8 * v35;
        if (v36) {
          *uint64_t v37 = v30;
        }
      }
      else
      {
        uint64_t v38 = 0;
        uint64_t v37 = (uint64_t *)(8 * v33);
      }
      unint64_t v39 = v73;
      int64_t v40 = (char *)v73 - (char *)v32;
      if (v73 == v32)
      {
        uint64_t v42 = v37;
        goto LABEL_63;
      }
      unint64_t v41 = v40 - 8;
      if ((unint64_t)(v40 - 8) < 0x38)
      {
        uint64_t v42 = v37;
      }
      else
      {
        uint64_t v42 = v37;
        if ((unint64_t)((char *)v73 - (char *)v37) >= 0x20)
        {
          uint64_t v43 = (v41 >> 3) + 1;
          uint64_t v44 = &v73[-(v43 & 0x3FFFFFFFFFFFFFFCLL)];
          long long v45 = v37 - 2;
          uint64_t v46 = v73 - 2;
          uint64_t v47 = v43 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v48 = *(_OWORD *)v46;
            *((_OWORD *)v45 - 1) = *((_OWORD *)v46 - 1);
            *(_OWORD *)long long v45 = v48;
            v45 -= 4;
            v46 -= 4;
            v47 -= 4;
          }
          while (v47);
          uint64_t v42 = &v37[-(v43 & 0x3FFFFFFFFFFFFFFCLL)];
          unint64_t v39 = v44;
          if (v43 == (v43 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_63;
          }
        }
      }
      do
      {
        uint64_t v49 = *--v39;
        *--uint64_t v42 = v49;
      }
      while (v39 != v32);
      uint64_t v32 = v72;
      uint64_t v31 = v74;
LABEL_63:
      uint64_t v27 = v37 + 1;
      unint64_t v72 = v42;
      unint64_t v74 = (uint64_t *)v38;
      if (v32) {
        (*(void (**)(uint64_t, uint64_t *, int64_t))(*(void *)v75 + 40))(v75, v32, (char *)v31 - (char *)v32);
      }
      goto LABEL_65;
    }
LABEL_71:
    md::LabelFeatureStyler::restyleFeatures(*(void *)(v71 + 296), &v72);
    uint64_t v24 = v70;
    if (v72)
    {
      unint64_t v73 = v72;
      (*(void (**)(uint64_t, uint64_t *, int64_t))(*(void *)v75 + 40))(v75, v72, (char *)v74 - (char *)v72);
    }
  }
  uint64_t v52 = v24[88];
  if (v52)
  {
    uint64_t v54 = *(void *)(v52 + 8);
    uint64_t v53 = *(std::__shared_weak_count **)(v52 + 16);
    uint64_t v76 = v54;
    unint64_t v77 = v53;
    if (v53) {
      atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v73 = 0;
    {
      operator new();
    }
    uint64_t v75 = mdm::Allocator::instance(void)::alloc;
    uint64_t v55 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                          + 16))(mdm::Allocator::instance(void)::alloc, 16, 8);
    unint64_t v72 = v55;
    unint64_t v74 = v55 + 2;
    if (v55)
    {
      uint64_t *v55 = v54;
      v55[1] = (uint64_t)v53;
      if (v53)
      {
        atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
        unint64_t v73 = v55 + 2;
        goto LABEL_81;
      }
      unint64_t v73 = v55 + 2;
    }
    else
    {
      unint64_t v73 = (uint64_t *)16;
      if (v53)
      {
LABEL_81:
        if (!atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
          std::__shared_weak_count::__release_weak(v53);
        }
      }
    }
    md::LabelFeatureStyler::styleExternalFeatures(*(unsigned int **)(v24[1] + 296), &v72);
    unsigned __int8 v56 = v72;
    if (v72)
    {
      uint64_t v57 = v73;
      if (v73 != v72)
      {
        do
        {
          uint64_t v58 = (std::__shared_weak_count *)*(v57 - 1);
          if (v58 && !atomic_fetch_add(&v58->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
            std::__shared_weak_count::__release_weak(v58);
          }
          v57 -= 2;
        }
        while (v57 != v56);
        unsigned __int8 v56 = v72;
      }
      (*(void (**)(uint64_t, uint64_t *, int64_t))(*(void *)v75 + 40))(v75, v56, (char *)v74 - (char *)v56);
    }
  }
  if (!*(unsigned char *)(*((void *)this + 3) + 3375))
  {
    unint64_t v61 = (char *)*((void *)this + 9);
    unint64_t v62 = (char *)*((void *)this + 10);
    if (v61 == v62) {
      return;
    }
    unint64_t v63 = v62 - v61 - 16;
    if (v63 >= 0x10)
    {
      uint64_t v64 = (v63 >> 4) + 1;
      uint64_t v65 = (uint64_t *)(v61 + 16);
      uint64_t v66 = v64 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        uint64_t v67 = *(v65 - 2);
        uint64_t v68 = *v65;
        v65 += 4;
        *(_DWORD *)(v67 + 52) = 0;
        *(_DWORD *)(v68 + 52) = 0;
        v66 -= 2;
      }
      while (v66);
      if (v64 == (v64 & 0x1FFFFFFFFFFFFFFELL)) {
        return;
      }
      v61 += 16 * (v64 & 0x1FFFFFFFFFFFFFFELL);
    }
    do
    {
      uint64_t v69 = *(void *)v61;
      v61 += 16;
      *(_DWORD *)(v69 + 52) = 0;
    }
    while (v61 != v62);
    return;
  }
  LOWORD(v72) = 257;
  BYTE2(v72) = 1;
  unint64_t v59 = (md::Label **)*((void *)this + 9);
  unint64_t v60 = (md::Label **)*((void *)this + 10);
  while (v59 != v60)
  {
    if (*((unsigned char *)*v59 + 820) == 2) {
      md::Label::layoutForStaging(*v59, *((void *)this + 3), *((md::LabelPool **)this + 6), &v72);
    }
    v59 += 2;
  }
}

void sub_1A1BEC248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1A1BEC25C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A1BEC270(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (!a12) {
    _Unwind_Resume(exception_object);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a15 + 40))(a15, a12, a14 - a12);
  _Unwind_Resume(exception_object);
}

uint64_t std::__tree<std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,std::__map_value_compare<std::pair<unsigned long long,md::LabelIdentifier>,std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,std::less<std::pair<unsigned long long,md::LabelIdentifier>>,true>,geo::StdAllocator<std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,mdm::Allocator>>::destroy(uint64_t result, void *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,std::__map_value_compare<std::pair<unsigned long long,md::LabelIdentifier>,std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,std::less<std::pair<unsigned long long,md::LabelIdentifier>>,true>,geo::StdAllocator<std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,mdm::Allocator>>::destroy(result, *a2);
    std::__tree<std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,std::__map_value_compare<std::pair<unsigned long long,md::LabelIdentifier>,std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,std::less<std::pair<unsigned long long,md::LabelIdentifier>>,true>,geo::StdAllocator<std::__value_type<std::pair<unsigned long long,md::LabelIdentifier>,std::weak_ptr<md::Label>>,mdm::Allocator>>::destroy(v3, a2[1]);
    uint64_t v4 = (std::__shared_weak_count *)a2[7];
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
    uint64_t v5 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v5();
  }
  return result;
}

void md::LabelCustomFeatureSupport::updateStylesForFeatures(md::LabelCustomFeatureSupport *this)
{
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  uint64_t v12 = 0;
  {
    operator new();
  }
  uint64_t v13 = mdm::Allocator::instance(void)::alloc;
  uint64_t v2 = (md::LabelCustomFeatureSupport *)*((void *)this + 9);
  if (v2 != (md::LabelCustomFeatureSupport *)((char *)this + 80))
  {
    do
    {
      md::LabelCustomFeatureProvider::populateAllLabelFeatures((void *)v2 + 5, &v10);
      uint64_t v3 = (md::LabelCustomFeatureSupport *)*((void *)v2 + 1);
      if (v3)
      {
        do
        {
          uint64_t v4 = v3;
          uint64_t v3 = *(md::LabelCustomFeatureSupport **)v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          uint64_t v4 = (md::LabelCustomFeatureSupport *)*((void *)v2 + 2);
          BOOL v5 = *(void *)v4 == (void)v2;
          uint64_t v2 = v4;
        }
        while (!v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != (md::LabelCustomFeatureSupport *)((char *)this + 80));
    uint64_t v6 = v10;
    uint64_t v7 = v11;
    if (v10 == v11)
    {
      if (!v10) {
        return;
      }
    }
    else
    {
      md::LabelFeatureStyler::styleExternalFeatures(*(unsigned int **)(*((void *)this + 2) + 296), &v10);
      if (!v6) {
        return;
      }
      do
      {
        uint64_t v8 = (std::__shared_weak_count *)*(v7 - 1);
        if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
        v7 -= 2;
      }
      while (v7 != v6);
    }
    unint64_t v9 = *(void (**)(void))(*(void *)v13 + 40);
    v9();
  }
}

void sub_1A1BEC538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void md::LabelCustomFeatureProvider::populateAllLabelFeatures(void *a1, void *a2)
{
  uint64_t v2 = a1[28];
  if (v2)
  {
    std::vector<std::shared_ptr<md::LabelStyle>,geo::StdAllocator<std::shared_ptr<md::LabelStyle>,mdm::Allocator>>::reserve((uint64_t)a2, v2 + ((uint64_t)(a2[1] - *a2) >> 4));
    BOOL v5 = (void *)a1[25];
    uint64_t v6 = a1 + 26;
    if (v5 != v6)
    {
      uint64_t v7 = (void *)a2[1];
      do
      {
        if ((unint64_t)v7 >= a2[2])
        {
          uint64_t v7 = std::vector<std::shared_ptr<md::LabelMarker>,geo::StdAllocator<std::shared_ptr<md::LabelMarker>,mdm::Allocator>>::__push_back_slow_path<std::shared_ptr<md::LabelMarker> const&>((uint64_t)a2, (long long *)(v5 + 5));
        }
        else
        {
          if (v7)
          {
            uint64_t v8 = v5[6];
            *uint64_t v7 = v5[5];
            v7[1] = v8;
            if (v8) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
            }
          }
          v7 += 2;
        }
        a2[1] = v7;
        unint64_t v9 = (void *)v5[1];
        if (v9)
        {
          do
          {
            unsigned int v10 = v9;
            unint64_t v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            unsigned int v10 = (void *)v5[2];
            BOOL v11 = *v10 == (void)v5;
            BOOL v5 = v10;
          }
          while (!v11);
        }
        BOOL v5 = v10;
      }
      while (v10 != v6);
    }
  }
}

void md::MapStandardLabeler::updateStylesForFeatures(md::MapStandardLabeler *this)
{
  uint64_t v1 = *((void *)this + 49);
  if (*(void *)(v1 + 128) != *(void *)(v1 + 136)) {
    md::LabelFeatureStyler::styleExternalFeatures(*(unsigned int **)(*(void *)(v1 + 16) + 296), (uint64_t **)(v1 + 128));
  }
  if (*(void *)(v1 + 240) != *(void *)(v1 + 248))
  {
    uint64_t v2 = *(unsigned int **)(*(void *)(v1 + 16) + 296);
    md::LabelFeatureStyler::styleExternalFeatures(v2, (uint64_t **)(v1 + 240));
  }
}

void md::MapNavLabeler::restyleActiveLabels(id *this)
{
  [this[7] styleManagerDidChange:*((unsigned __int8 *)this[3] + 3375)];
  uint64_t v2 = (uint64_t **)this[9];
  md::LabelFeatureStyler::restyleFeatures((*v2)[37], v2 + 18);
  uint64_t v3 = *v2;
  *((unsigned char *)v3 + 3041) = 1;
  unsigned __int8 v4 = atomic_load((unsigned __int8 *)v3 + 3058);
  if (v4)
  {
    uint64_t v5 = v3[17];
    if (v5)
    {
      uint64_t v6 = *(void *)(v5 + 56);
      if (v6)
      {
        unint64_t v9 = v3;
        char v8 = 9;
        (*(void (**)(uint64_t, uint64_t **, char *))(*(void *)v6 + 48))(v6, &v9, &v8);
      }
    }
  }
  uint64_t v7 = (md::RouteLineSupport *)this[8];
  md::RouteLineSupport::restyleFeatures(v7);
}

uint64_t md::LabelFeatureStyler::restyleFeatures(uint64_t result, uint64_t **a2)
{
  uint64_t v2 = (_DWORD *)result;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  {
    unint64_t v20 = a2;
    a2 = v20;
    if (result) {
      operator new();
    }
  }
  uint64_t v35 = mdm::Allocator::instance(void)::alloc;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  {
    uint64_t v21 = a2;
    a2 = v21;
    if (result) {
      operator new();
    }
  }
  uint64_t v31 = mdm::Allocator::instance(void)::alloc;
  uint64_t v3 = atomic_load((unsigned __int8 *)(*(void *)v2 + 3394));
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  {
    BOOL v22 = a2;
    a2 = v22;
    if (result) {
      operator new();
    }
  }
  uint64_t v27 = mdm::Allocator::instance(void)::alloc;
  unsigned __int8 v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    do
    {
      uint64_t result = *v4;
      uint64_t v23 = result;
      if (*(_DWORD *)(result + 128) != v2[3])
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)result + 264))(result) == 7)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)v23 + 536))(v23, *(void *)v2);
        }
        else
        {
          uint64_t v6 = v32;
          for (uint64_t i = v33; i != v6; i -= 2)
          {
            char v8 = (std::__shared_weak_count *)*(i - 1);
            if (v8)
            {
              if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
                std::__shared_weak_count::__release_weak(v8);
              }
            }
          }
          uint64_t v33 = v6;
          if (!(*(uint64_t (**)(uint64_t))(*(void *)v23 + 64))(v23)) {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v23 + 528))(v23, v3);
          }
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t **, uint64_t))(*(void *)v23 + 568))(v23, &v32, *(void *)(*(void *)v2 + 336) + 184);
          if (v32 != v33)
          {
            std::vector<md::LabelFeature *,geo::StdAllocator<md::LabelFeature *,mdm::Allocator>>::assign((uint64_t)&v24, ((char *)v33 - (char *)v32) >> 4, (const double *)&v23);
            uint64_t v9 = v28;
            for (uint64_t j = v29; j != v9; j -= 16)
            {
              BOOL v11 = *(std::__shared_weak_count **)(j - 8);
              if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
                std::__shared_weak_count::__release_weak(v11);
              }
            }
            uint64_t v29 = v9;
            md::LabelStyleCache::requestStyles(*(void *)(*(void *)v2 + 336), &v32, (uint64_t)&v28, &v24);
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 576))(v23);
          }
        }
      }
      ++v4;
    }
    while (v4 != v5);
    if (v24)
    {
      uint64_t v25 = v24;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v27 + 40))(v27, v24, v26 - v24);
    }
  }
  uint64_t v12 = v28;
  if (v28)
  {
    uint64_t v13 = v29;
    uint64_t v14 = v28;
    if (v29 != v28)
    {
      do
      {
        int v15 = *(std::__shared_weak_count **)(v13 - 8);
        if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v15->__on_zero_shared)(v15, v14);
          std::__shared_weak_count::__release_weak(v15);
        }
        v13 -= 16;
      }
      while (v13 != v12);
      uint64_t v14 = v28;
    }
    uint64_t v29 = v12;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v31 + 40))(v31, v14, v30 - v14);
  }
  uint64_t v16 = v32;
  if (v32)
  {
    uint64_t v17 = v33;
    uint64_t v18 = v32;
    if (v33 != v32)
    {
      do
      {
        uint64_t v19 = (std::__shared_weak_count *)*(v17 - 1);
        if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t *))v19->__on_zero_shared)(v19, v18);
          std::__shared_weak_count::__release_weak(v19);
        }
        v17 -= 2;
      }
      while (v17 != v16);
      uint64_t v18 = v32;
    }
    uint64_t v33 = v16;
    return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v35 + 40))(v35, v18, v34 - (void)v18);
  }
  return result;
}

void sub_1A1BECD30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  if (a4) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a7 + 40))(a7, a4, a6 - a4);
  }
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100]((uint64_t *)va);
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100]((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::LabelTextDataLoader::finishBatch(void)::$_0,std::allocator<md::LabelTextDataLoader::finishBatch(void)::$_0>,void ()(void)>::destroy_deallocate(uint64_t *a1)
{
  md::LabelTextDataLoader::finishBatch(void)::$_0::~$_0(a1 + 1);
  operator delete(a1);
}

uint64_t *md::LabelTextDataLoader::finishBatch(void)::$_0::~$_0(uint64_t *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[5];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[5];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = *a1;
  if (*a1)
  {
    uint64_t v5 = a1[1];
    uint64_t v6 = *a1;
    if (v5 != v4)
    {
      do
      {
        uint64_t v7 = *(std::__shared_weak_count **)(v5 - 8);
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v7->__on_zero_shared)(v7, v6);
          std::__shared_weak_count::__release_weak(v7);
        }
        v5 -= 16;
      }
      while (v5 != v4);
      uint64_t v6 = *a1;
    }
    a1[1] = v4;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v6, a1[2] - v6);
  }
  return a1;
}

void std::__function::__func<md::LabelManager::startStylesheetLabelAnimations(void)::$_1,std::allocator<md::LabelManager::startStylesheetLabelAnimations(void)::$_1>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "LabelsStylesheetLabelAnimations", "", v1, 2u);
  }
}

void md::LabelSettingsStyleCache::styleQueryForCategory(gss::Allocator *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = gss::Allocator::instance(a1);
  v10[3] = v6;
  uint64_t v7 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 16))(v6, 8, 4);
  uint64_t v8 = v7;
  v10[0] = v7;
  v10[2] = v7 + 1;
  if (v7) {
    *uint64_t v7 = (a3 << 32) | 0x1004B;
  }
  v10[1] = v7 + 1;
  md::LabelSettingsStyleCache::styleQueryForAttributes((uint64_t **)a1, *a2, (uint64_t)v10);
  if (v8)
  {
    uint64_t v9 = *(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v6 + 40);
    v9(v6, v8, 8);
  }
}

void sub_1A1BED0F8(_Unwind_Exception *exception_object)
{
  if (v2) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1 + 40))(v1, v2, 8);
  }
  _Unwind_Resume(exception_object);
}

void md::LabelSettingsStyleCache::styleQueryForAttributes(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  gss::FeatureAttributeSet::FeatureAttributeSet((gss::FeatureAttributeSet *)v5, a3);
  memset(v7, 0, 15);
  v7[15] = 1;
  gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes(a1, a2, (gss::FeatureAttributeSet *)v5, (gss::QueryOverrides *)v7);
  if (v5[0])
  {
    v5[1] = v5[0];
    (*(void (**)(uint64_t, void, void))(*(void *)v6 + 40))(v6, v5[0], v5[2] - v5[0]);
  }
}

void sub_1A1BED1CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  gss::QueryOverrides::~QueryOverrides((gss::QueryOverrides *)va);
  if (a2) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a5 + 40))(a5, a2, a4 - a2);
  }
  _Unwind_Resume(a1);
}

void sub_1A1BED2CC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  if (*v1)
  {
    v1[1] = v3;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[3] + 40))(v1[3], v3, v1[2] - v3);
  }
  _Unwind_Resume(exception_object);
}

void md::LabelManager::layout(uint64_t a1, md::LayoutContext *a2, uint64_t a3)
{
  uint64_t v1043 = *MEMORY[0x1E4F143B8];
  v982 = (std::recursive_mutex *)(a1 + 24);
  mach_absolute_time();
  std::recursive_mutex::lock(v982);
  uint64_t v4 = (void *)*((void *)a2 + 1);
  int8x8_t v5 = (int8x8_t)v4[1];
  if (!*(void *)&v5) {
    goto LABEL_24;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = 0x99BED48DEFBBD82BLL;
    if (*(void *)&v5 <= 0x99BED48DEFBBD82BLL) {
      unint64_t v7 = 0x99BED48DEFBBD82BLL % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v5 - 1) & 0x99BED48DEFBBD82BLL;
  }
  uint64_t v8 = *(void **)(*v4 + 8 * v7);
  if (!v8) {
    goto LABEL_24;
  }
  uint64_t v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_24;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v10 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v12 = v9[1];
      if (v12 == 0x99BED48DEFBBD82BLL)
      {
        if (v9[2] == 0x99BED48DEFBBD82BLL) {
          goto LABEL_22;
        }
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_24;
      }
      uint64_t v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_24;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v9[1];
    if (v11 == 0x99BED48DEFBBD82BLL) {
      break;
    }
    if (v11 >= *(void *)&v5) {
      v11 %= *(void *)&v5;
    }
    if (v11 != v7) {
      goto LABEL_24;
    }
LABEL_11:
    uint64_t v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_24;
    }
  }
  if (v9[2] != 0x99BED48DEFBBD82BLL) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v13 = v9[5];
  if (*(void *)(v13 + 8) == 0x99BED48DEFBBD82BLL)
  {
    uint64_t v14 = *(void *)(v13 + 32);
    goto LABEL_25;
  }
LABEL_24:
  uint64_t v14 = 0;
LABEL_25:
  if (*(unsigned char *)(a1 + 3044))
  {
    uint64_t v15 = md::LayoutContext::frameState(a2);
    double v16 = *(double *)(a1 + 3288);
    double v17 = fmax(*(double *)(v15 + 88), v16);
    if (*(unsigned char *)(*(void *)(a1 + 232) + 20)) {
      double v18 = fmax(fabs((*(double *)(a1 + 3096)+ *(double *)(a1 + 3088)+ *(double *)(a1 + 3104)+ *(double *)(a1 + 3112)+ *(double *)(a1 + 3120))* 0.2)* 25.0, 1.0);
    }
    else {
      double v18 = 1.0;
    }
    float v20 = v17 - v16;
    double v19 = v18 * v20;
  }
  else
  {
    double v19 = 0.0;
  }
  uint64_t v994 = a2;
  *(void *)(a1 + 3288) = *(void *)(md::LayoutContext::frameState(a2) + 88);
  ++*(_DWORD *)(a1 + 3272);
  *(unsigned char *)(a1 + 3304) = 1;
  *(_DWORD *)(a1 + 3396) = 0;
  if (v14)
  {
    uint64_t v21 = *(void **)v14;
    BOOL v22 = *(unsigned __int16 **)(*(void *)v14 + 184);
    uint64_t v23 = *(unsigned __int16 **)(*(void *)v14 + 192);
    if (v22 != v23)
    {
      uint64_t v24 = (unsigned __int16 *)v21[15];
      do
      {
        uint64_t v25 = (unsigned __int16 *)v21[14];
        if (v25 != v24)
        {
          uint64_t v25 = (unsigned __int16 *)v21[14];
          while (*v25 != *v22)
          {
            v25 += 56;
            if (v25 == v24)
            {
              uint64_t v25 = (unsigned __int16 *)v21[15];
              break;
            }
          }
        }
        if (!*((unsigned char *)v25 + 8)) {
          goto LABEL_52;
        }
        ++v22;
      }
      while (v22 != v23);
    }
    uint64_t v26 = (unsigned __int16 *)v21[26];
    uint64_t v27 = (unsigned __int16 *)v21[27];
    if (v26 == v27)
    {
      BOOL v31 = 1;
    }
    else
    {
      uint64_t v29 = (unsigned __int16 *)v21[14];
      uint64_t v28 = (unsigned __int16 *)v21[15];
      do
      {
        uint64_t v33 = v29;
        if (v29 != v28)
        {
          uint64_t v33 = v29;
          while (*v33 != *v26)
          {
            v33 += 56;
            if (v33 == v28)
            {
              uint64_t v33 = v28;
              break;
            }
          }
        }
        int v30 = *((unsigned __int8 *)v33 + 8);
        _ZF = v30 == 0;
        BOOL v31 = v30 != 0;
        ++v26;
        _ZF = _ZF || v26 == v27;
      }
      while (!_ZF);
    }
  }
  else
  {
LABEL_52:
    BOOL v31 = 0;
  }
  *(unsigned char *)(a1 + 3386) = v31;
  if (*(unsigned char *)(a1 + 3388))
  {
    *(unsigned char *)(a1 + 3388) = 0;
    uint64_t v34 = *(void (******)(void))(a1 + 168);
    uint64_t v35 = *v34;
    uint64_t v36 = v34[1];
    if (*v34 != v36)
    {
      do
        (***v35++)();
      while (v35 != v36);
    }
  }
  uint64_t v37 = *(void *)(a1 + 3448);
  if (v37) {
    (*(void (**)(uint64_t))(*(void *)v37 + 40))(v37);
  }
  uint64_t v38 = a1;
  atomic_store(0, (unsigned __int8 *)(a1 + 3048));
  unint64_t v39 = (uint64_t *)*((void *)a2 + 1);
  int8x8_t v40 = (int8x8_t)v39[1];
  if (!*(void *)&v40)
  {
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    uint64_t v45 = 0;
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    uint64_t v1002 = (void **)(a1 + 1544);
    uint64_t v990 = a1 + 440;
    *(_OWORD *)__p = *(_OWORD *)(a1 + 1544);
LABEL_228:
    uint64_t v96 = 0;
    *(_WORD *)(v38 + 451) = 0;
    *(unsigned char *)(v38 + 453) = 0;
    goto LABEL_229;
  }
  uint8x8_t v41 = (uint8x8_t)vcnt_s8(v40);
  v41.i16[0] = vaddlv_u8(v41);
  if (v41.u32[0] > 1uLL)
  {
    uint64_t v42 = 0x1AF456233693CD46;
    if (*(void *)&v40 <= 0x1AF456233693CD46uLL) {
      uint64_t v42 = 0x1AF456233693CD46uLL % *(void *)&v40;
    }
  }
  else
  {
    uint64_t v42 = (*(void *)&v40 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v49 = *(void **)(*v39 + 8 * v42);
  if (!v49 || (long long v50 = (void *)*v49) == 0)
  {
    uint64_t v43 = 0;
    uint64_t v53 = (void **)(a1 + 1544);
    uint64_t v990 = a1 + 440;
    *(_OWORD *)__p = *(_OWORD *)(a1 + 1544);
    goto LABEL_86;
  }
  if (v41.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v52 = v50[1];
      if (v52 == 0x1AF456233693CD46)
      {
        if (v50[2] == 0x1AF456233693CD46) {
          goto LABEL_82;
        }
      }
      else if ((v52 & (*(void *)&v40 - 1)) != v42)
      {
        goto LABEL_84;
      }
      long long v50 = (void *)*v50;
      if (!v50) {
        goto LABEL_84;
      }
    }
  }
  while (2)
  {
    unint64_t v51 = v50[1];
    if (v51 != 0x1AF456233693CD46)
    {
      if (v51 >= *(void *)&v40) {
        v51 %= *(void *)&v40;
      }
      if (v51 != v42) {
        goto LABEL_84;
      }
      goto LABEL_70;
    }
    if (v50[2] != 0x1AF456233693CD46)
    {
LABEL_70:
      long long v50 = (void *)*v50;
      if (!v50) {
        goto LABEL_84;
      }
      continue;
    }
    break;
  }
LABEL_82:
  uint64_t v54 = v50[5];
  if (*(void *)(v54 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v43 = *(void *)(v54 + 32);
    goto LABEL_85;
  }
LABEL_84:
  uint64_t v43 = 0;
LABEL_85:
  uint64_t v53 = (void **)(a1 + 1544);
  uint64_t v990 = a1 + 440;
  *(_OWORD *)__p = *(_OWORD *)(a1 + 1544);
LABEL_86:
  uint8x8_t v55 = (uint8x8_t)vcnt_s8(v40);
  v55.i16[0] = vaddlv_u8(v55);
  if (v55.u32[0] > 1uLL)
  {
    unint64_t v56 = 0xE42D19AFCA302E68;
    if (*(void *)&v40 <= 0xE42D19AFCA302E68) {
      unint64_t v56 = 0xE42D19AFCA302E68 % *(void *)&v40;
    }
  }
  else
  {
    unint64_t v56 = (*(void *)&v40 - 1) & 0xE42D19AFCA302E68;
  }
  uint64_t v57 = *v39;
  uint64_t v46 = *(uint64_t **)(*v39 + 8 * v56);
  if (!v46 || (uint64_t v46 = (uint64_t *)*v46) == 0)
  {
LABEL_108:
    if (v55.u32[0] > 1uLL) {
      goto LABEL_111;
    }
    goto LABEL_109;
  }
  if (v55.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v59 = v46[1];
      if (v59 == 0xE42D19AFCA302E68)
      {
        if (v46[2] == 0xE42D19AFCA302E68) {
          goto LABEL_106;
        }
      }
      else if ((v59 & (*(void *)&v40 - 1)) != v56)
      {
        goto LABEL_110;
      }
      uint64_t v46 = (uint64_t *)*v46;
      if (!v46) {
        goto LABEL_108;
      }
    }
  }
  while (1)
  {
    unint64_t v58 = v46[1];
    if (v58 == 0xE42D19AFCA302E68) {
      break;
    }
    if (v58 >= *(void *)&v40) {
      v58 %= *(void *)&v40;
    }
    if (v58 != v56) {
      goto LABEL_110;
    }
LABEL_95:
    uint64_t v46 = (uint64_t *)*v46;
    if (!v46) {
      goto LABEL_108;
    }
  }
  if (v46[2] != 0xE42D19AFCA302E68) {
    goto LABEL_95;
  }
LABEL_106:
  uint64_t v60 = v46[5];
  if (*(void *)(v60 + 8) == 0xE42D19AFCA302E68)
  {
    uint64_t v46 = *(uint64_t **)(v60 + 32);
    goto LABEL_108;
  }
LABEL_110:
  uint64_t v46 = 0;
  if (v55.u32[0] <= 1uLL)
  {
LABEL_109:
    unint64_t v61 = (*(void *)&v40 - 1) & 0x1AF456233693CD46;
    goto LABEL_113;
  }
LABEL_111:
  unint64_t v61 = 0x1AF456233693CD46;
  if (*(void *)&v40 <= 0x1AF456233693CD46uLL) {
    unint64_t v61 = 0x1AF456233693CD46uLL % *(void *)&v40;
  }
LABEL_113:
  unint64_t v62 = *(void **)(v57 + 8 * v61);
  if (!v62) {
    goto LABEL_131;
  }
  unint64_t v63 = (void *)*v62;
  if (!v63) {
    goto LABEL_131;
  }
  if (v55.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v65 = v63[1];
      if (v65 == 0x1AF456233693CD46)
      {
        if (v63[2] == 0x1AF456233693CD46) {
          goto LABEL_129;
        }
      }
      else if ((v65 & (*(void *)&v40 - 1)) != v61)
      {
        goto LABEL_131;
      }
      unint64_t v63 = (void *)*v63;
      if (!v63) {
        goto LABEL_131;
      }
    }
  }
  while (2)
  {
    unint64_t v64 = v63[1];
    if (v64 != 0x1AF456233693CD46)
    {
      if (v64 >= *(void *)&v40) {
        v64 %= *(void *)&v40;
      }
      if (v64 != v61) {
        goto LABEL_131;
      }
      goto LABEL_118;
    }
    if (v63[2] != 0x1AF456233693CD46)
    {
LABEL_118:
      unint64_t v63 = (void *)*v63;
      if (!v63) {
        goto LABEL_131;
      }
      continue;
    }
    break;
  }
LABEL_129:
  uint64_t v66 = v63[5];
  if (*(void *)(v66 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v45 = *(void *)(v66 + 32);
    goto LABEL_132;
  }
LABEL_131:
  uint64_t v45 = 0;
LABEL_132:
  if (v55.u32[0] > 1uLL)
  {
    unint64_t v67 = 0x8BD499FBD96FBB9ELL;
    if (*(void *)&v40 <= 0x8BD499FBD96FBB9ELL) {
      unint64_t v67 = 0x8BD499FBD96FBB9ELL % *(void *)&v40;
    }
  }
  else
  {
    unint64_t v67 = (*(void *)&v40 - 1) & 0x8BD499FBD96FBB9ELL;
  }
  uint64_t v68 = *(void **)(v57 + 8 * v67);
  if (!v68) {
    goto LABEL_156;
  }
  uint64_t v69 = (void *)*v68;
  if (!v69) {
    goto LABEL_156;
  }
  if (v55.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v71 = v69[1];
      if (v71 == 0x8BD499FBD96FBB9ELL)
      {
        if (v69[2] == 0x8BD499FBD96FBB9ELL) {
          goto LABEL_152;
        }
      }
      else if ((v71 & (*(void *)&v40 - 1)) != v67)
      {
        goto LABEL_156;
      }
      uint64_t v69 = (void *)*v69;
      if (!v69) {
        goto LABEL_156;
      }
    }
  }
  while (1)
  {
    unint64_t v70 = v69[1];
    if (v70 == 0x8BD499FBD96FBB9ELL) {
      break;
    }
    if (v70 >= *(void *)&v40) {
      v70 %= *(void *)&v40;
    }
    if (v70 != v67) {
      goto LABEL_156;
    }
LABEL_141:
    uint64_t v69 = (void *)*v69;
    if (!v69) {
      goto LABEL_156;
    }
  }
  if (v69[2] != 0x8BD499FBD96FBB9ELL) {
    goto LABEL_141;
  }
LABEL_152:
  uint64_t v72 = v69[5];
  if (*(void *)(v72 + 8) != 0x8BD499FBD96FBB9ELL)
  {
LABEL_156:
    uint64_t v47 = 0;
    if (v55.u32[0] > 1uLL) {
      goto LABEL_154;
    }
    goto LABEL_157;
  }
  uint64_t v47 = *(float **)(v72 + 32);
  if (v55.u32[0] <= 1uLL)
  {
LABEL_157:
    unint64_t v73 = (*(void *)&v40 - 1) & 0x1B8B241A8D896A1DLL;
    goto LABEL_158;
  }
LABEL_154:
  unint64_t v73 = 0x1B8B241A8D896A1DLL;
  if (*(void *)&v40 <= 0x1B8B241A8D896A1DuLL) {
    unint64_t v73 = 0x1B8B241A8D896A1DuLL % *(void *)&v40;
  }
LABEL_158:
  unint64_t v74 = *(void **)(v57 + 8 * v73);
  uint64_t v1002 = v53;
  if (!v74) {
    goto LABEL_176;
  }
  uint64_t v75 = (void *)*v74;
  if (!v75) {
    goto LABEL_176;
  }
  if (v55.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v77 = v75[1];
      if (v77 == 0x1B8B241A8D896A1DLL)
      {
        if (v75[2] == 0x1B8B241A8D896A1DLL) {
          goto LABEL_174;
        }
      }
      else if ((v77 & (*(void *)&v40 - 1)) != v73)
      {
        goto LABEL_176;
      }
      uint64_t v75 = (void *)*v75;
      if (!v75) {
        goto LABEL_176;
      }
    }
  }
  while (2)
  {
    unint64_t v76 = v75[1];
    if (v76 != 0x1B8B241A8D896A1DLL)
    {
      if (v76 >= *(void *)&v40) {
        v76 %= *(void *)&v40;
      }
      if (v76 != v73) {
        goto LABEL_176;
      }
      goto LABEL_163;
    }
    if (v75[2] != 0x1B8B241A8D896A1DLL)
    {
LABEL_163:
      uint64_t v75 = (void *)*v75;
      if (!v75) {
        goto LABEL_176;
      }
      continue;
    }
    break;
  }
LABEL_174:
  uint64_t v78 = v75[5];
  if (*(void *)(v78 + 8) == 0x1B8B241A8D896A1DLL)
  {
    uint64_t v44 = *(void *)(v78 + 32);
    goto LABEL_177;
  }
LABEL_176:
  uint64_t v44 = 0;
LABEL_177:
  if (v55.u32[0] > 1uLL)
  {
    unint64_t v79 = 0x92F3DC114CADB853;
    if (*(void *)&v40 <= 0x92F3DC114CADB853) {
      unint64_t v79 = 0x92F3DC114CADB853 % *(void *)&v40;
    }
  }
  else
  {
    unint64_t v79 = (*(void *)&v40 - 1) & 0x92F3DC114CADB853;
  }
  uint64_t v80 = *(void **)(v57 + 8 * v79);
  if (!v80) {
    goto LABEL_199;
  }
  uint64_t v81 = (void *)*v80;
  if (!v81) {
    goto LABEL_199;
  }
  if (v55.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v83 = v81[1];
      if (v83 == 0x92F3DC114CADB853)
      {
        if (v81[2] == 0x92F3DC114CADB853) {
          goto LABEL_197;
        }
      }
      else if ((v83 & (*(void *)&v40 - 1)) != v79)
      {
        goto LABEL_199;
      }
      uint64_t v81 = (void *)*v81;
      if (!v81) {
        goto LABEL_199;
      }
    }
  }
  while (2)
  {
    unint64_t v82 = v81[1];
    if (v82 != 0x92F3DC114CADB853)
    {
      if (v82 >= *(void *)&v40) {
        v82 %= *(void *)&v40;
      }
      if (v82 != v79) {
        goto LABEL_199;
      }
      goto LABEL_186;
    }
    if (v81[2] != 0x92F3DC114CADB853)
    {
LABEL_186:
      uint64_t v81 = (void *)*v81;
      if (!v81) {
        goto LABEL_199;
      }
      continue;
    }
    break;
  }
LABEL_197:
  uint64_t v84 = v81[5];
  if (*(void *)(v84 + 8) == 0x92F3DC114CADB853)
  {
    uint64_t v48 = *(void *)(v84 + 32);
    goto LABEL_200;
  }
LABEL_199:
  uint64_t v48 = 0;
LABEL_200:
  if (v55.u32[0] > 1uLL)
  {
    unint64_t v85 = 0xC97B9E962ADF4AD4;
    if (*(void *)&v40 <= 0xC97B9E962ADF4AD4) {
      unint64_t v85 = 0xC97B9E962ADF4AD4 % *(void *)&v40;
    }
  }
  else
  {
    unint64_t v85 = (*(void *)&v40 - 1) & 0xC97B9E962ADF4AD4;
  }
  uint64_t v86 = *(void **)(v57 + 8 * v85);
  if (!v86) {
    goto LABEL_227;
  }
  int64_t v87 = (void *)*v86;
  if (!v87) {
    goto LABEL_227;
  }
  if (v55.u32[0] < 2uLL)
  {
    uint64_t v88 = *(void *)&v40 - 1;
    while (1)
    {
      uint64_t v90 = v87[1];
      if (v90 == 0xC97B9E962ADF4AD4)
      {
        if (v87[2] == 0xC97B9E962ADF4AD4) {
          goto LABEL_220;
        }
      }
      else if ((v90 & v88) != v85)
      {
        goto LABEL_227;
      }
      int64_t v87 = (void *)*v87;
      if (!v87) {
        goto LABEL_227;
      }
    }
  }
  while (1)
  {
    unint64_t v89 = v87[1];
    if (v89 == 0xC97B9E962ADF4AD4) {
      break;
    }
    if (v89 >= *(void *)&v40) {
      v89 %= *(void *)&v40;
    }
    if (v89 != v85) {
      goto LABEL_227;
    }
LABEL_209:
    int64_t v87 = (void *)*v87;
    if (!v87) {
      goto LABEL_227;
    }
  }
  if (v87[2] != 0xC97B9E962ADF4AD4) {
    goto LABEL_209;
  }
LABEL_220:
  uint64_t v91 = v87[5];
  if (*(void *)(v91 + 8) != 0xC97B9E962ADF4AD4 || (BOOL v92 = *(uint64_t **)(v91 + 32)) == 0)
  {
LABEL_227:
    uint64_t v38 = a1;
    goto LABEL_228;
  }
  uint64_t v93 = *v92;
  uint64_t v94 = v92[1];
  uint64_t v95 = v93;
  if (v93 != v94)
  {
    uint64_t v95 = v93;
    while (*(unsigned char *)v95 != 21)
    {
      v95 += 16;
      if (v95 == v94) {
        goto LABEL_1380;
      }
    }
  }
  if (v95 == v94)
  {
LABEL_1380:
    *(unsigned char *)(a1 + 451) = 0;
  }
  else
  {
    uint64_t v969 = *(void *)(v95 + 8);
    *(unsigned char *)(a1 + 451) = v969 != 0;
    if (v969)
    {
      BOOL v970 = 1;
LABEL_1409:
      *(unsigned char *)(a1 + 452) = v970;
      goto LABEL_1411;
    }
  }
  if (v93 == v94)
  {
    *(unsigned char *)(a1 + 452) = 0;
    uint64_t v975 = v93;
  }
  else
  {
    uint64_t v971 = v93;
    while (*(unsigned char *)v971 != 25)
    {
      v971 += 16;
      if (v971 == v94) {
        goto LABEL_1410;
      }
    }
    if (v971 != v94)
    {
      BOOL v970 = *(void *)(v971 + 8) != 0;
      goto LABEL_1409;
    }
LABEL_1410:
    *(unsigned char *)(a1 + 452) = 0;
LABEL_1411:
    uint64_t v975 = v93;
    if (v93 != v94)
    {
      uint64_t v975 = v93;
      while (*(unsigned char *)v975 != 34)
      {
        v975 += 16;
        if (v975 == v94) {
          goto LABEL_1418;
        }
      }
    }
  }
  if (v975 == v94) {
LABEL_1418:
  }
    uint64_t v976 = 0;
  else {
    uint64_t v976 = *(void *)(v975 + 8);
  }
  *(unsigned char *)(a1 + 453) = v976 != 0;
  if (v93 != v94)
  {
    while (*(unsigned char *)v93 != 33)
    {
      v93 += 16;
      if (v93 == v94) {
        goto LABEL_1425;
      }
    }
  }
  if (v93 == v94) {
LABEL_1425:
  }
    uint64_t v96 = 0;
  else {
    uint64_t v96 = *(void *)(v93 + 8);
  }
  uint64_t v38 = a1;
LABEL_229:
  *(unsigned char *)(v38 + 454) = v96 != 0;
  if (v46)
  {
    int v97 = *((_DWORD *)v46 + 22);
    unint64_t v98 = (unsigned char *)*((void *)v994 + 9);
    if (v98) {
      goto LABEL_231;
    }
  }
  else
  {
    int v97 = 0;
    unint64_t v98 = (unsigned char *)*((void *)v994 + 9);
    if (v98) {
LABEL_231:
    }
      LOBYTE(v98) = *v98 != 0;
  }
  unint64_t v99 = (float32x2_t *)a1;
  *(unsigned char *)(a1 + 455) = (_BYTE)v98;
  *(unsigned char *)(a1 + 456) = v97 == 9;
  if (v97 != 9)
  {
    *(unsigned char *)(a1 + 457) = 0;
    goto LABEL_263;
  }
  unint64_t v100 = (void *)*((void *)v994 + 1);
  int8x8_t v101 = (int8x8_t)v100[1];
  if (!*(void *)&v101) {
    goto LABEL_261;
  }
  uint8x8_t v102 = (uint8x8_t)vcnt_s8(v101);
  v102.i16[0] = vaddlv_u8(v102);
  if (v102.u32[0] > 1uLL)
  {
    uint64_t v103 = 0x37F8C546A65FE3EELL;
    if (*(void *)&v101 <= 0x37F8C546A65FE3EEuLL) {
      uint64_t v103 = 0x37F8C546A65FE3EEuLL % *(void *)&v101;
    }
  }
  else
  {
    uint64_t v103 = (*(void *)&v101 - 1) & 0x37F8C546A65FE3EELL;
  }
  unint64_t v104 = *(void **)(*v100 + 8 * v103);
  if (!v104) {
    goto LABEL_261;
  }
  unint64_t v105 = (void *)*v104;
  if (!v105) {
    goto LABEL_261;
  }
  if (v102.u32[0] < 2uLL)
  {
    uint64_t v106 = *(void *)&v101 - 1;
    while (1)
    {
      uint64_t v108 = v105[1];
      if (v108 == 0x37F8C546A65FE3EELL)
      {
        if (v105[2] == 0x37F8C546A65FE3EELL) {
          goto LABEL_257;
        }
      }
      else if ((v108 & v106) != v103)
      {
        goto LABEL_261;
      }
      unint64_t v105 = (void *)*v105;
      if (!v105) {
        goto LABEL_261;
      }
    }
  }
  while (2)
  {
    unint64_t v107 = v105[1];
    if (v107 != 0x37F8C546A65FE3EELL)
    {
      if (v107 >= *(void *)&v101) {
        v107 %= *(void *)&v101;
      }
      if (v107 != v103) {
        goto LABEL_261;
      }
      goto LABEL_246;
    }
    if (v105[2] != 0x37F8C546A65FE3EELL)
    {
LABEL_246:
      unint64_t v105 = (void *)*v105;
      if (!v105) {
        goto LABEL_261;
      }
      continue;
    }
    break;
  }
LABEL_257:
  uint64_t v109 = v105[5];
  if (*(void *)(v109 + 8) == 0x37F8C546A65FE3EELL)
  {
    uint64_t v110 = *(void *)(v109 + 32);
    if (!v110) {
      goto LABEL_262;
    }
    if (*(unsigned char *)(v110 + 64) == 2)
    {
      LOBYTE(v110) = *(unsigned char *)(v110 + 16) == 3;
      goto LABEL_262;
    }
  }
LABEL_261:
  LOBYTE(v110) = 0;
LABEL_262:
  unint64_t v99 = (float32x2_t *)a1;
  *(unsigned char *)(a1 + 457) = v110;
LABEL_263:
  v99[58].i8[2] = *((unsigned char *)v46 + 97);
  v99[108].i32[1] = *((_DWORD *)v46 + 25);
  v99[60].f32[1] = 1.0 / *((float *)v46 + 26);
  id v111 = *(id *)v994;
  [v111 sizeInPixels];
  double v113 = v112;
  double v115 = v114;

  float32_t v116 = v113;
  float32_t v117 = v115;
  v99[188].f32[0] = v116;
  v99[188].f32[1] = v117;
  id v118 = *(id *)v994;
  [v118 contentScale];
  *(float *)&double v119 = v119;
  v99[60].i32[0] = LODWORD(v119);

  float32x2_t v120 = v99[188];
  float32x2_t v121 = 0;
  v99[189] = 0;
  v99[190] = v120;
  v122.i32[0] = v99[60].i32[0];
  BOOL v123 = v120.f32[0] < 0.0;
  if (v120.f32[1] < 0.0) {
    BOOL v123 = 1;
  }
  if (v123)
  {
    v99[191] = 0;
    v99[192] = v120;
    float32x2_t v124 = v120;
  }
  else
  {
    int8x16_t v125 = (float32x2_t *)v99[55];
    float32x2_t v126 = vrnd_f32(vmul_n_f32(v125[9], *(float *)v122.i32));
    v99[191] = vneg_f32(v126);
    v99[192] = vadd_f32(v126, v120);
    float32x2_t v127 = vrnd_f32(vmul_n_f32(v125[8], *(float *)v122.i32));
    float32x2_t v121 = vneg_f32(v127);
    float32x2_t v124 = vadd_f32(v127, v120);
  }
  v99[193] = v121;
  v99[194] = v124;
  *(float *)v122.i32 = truncf(*(float *)v122.i32 * 50.0);
  if (v123) {
    *(float *)v122.i32 = 0.0;
  }
  v99[195].i32[0] = v122.i32[0];
  v99[195].i32[1] = v122.i32[0];
  v99[196] = vsub_f32(v120, (float32x2_t)vdup_lane_s32(v122, 0));
  unint64_t v128 = (float *)md::LayoutContext::frameState(v994);
  float v129 = *(float *)(a1 + 1520);
  float v130 = *(float *)(a1 + 1512);
  if (v129 >= v130)
  {
    float v136 = *(float *)(a1 + 1524);
    float v137 = *(float *)(a1 + 1516);
    unint64_t v135 = v994;
    if (v136 >= v137)
    {
      float v132 = v130 + v128[1];
      float v133 = v137 + v128[2];
      float v131 = v129 - v128[3];
      float v134 = v136 - *v128;
    }
    else
    {
      float v131 = -3.4028e38;
      float v132 = 3.4028e38;
      float v133 = 3.4028e38;
      float v134 = -3.4028e38;
    }
  }
  else
  {
    float v131 = -3.4028e38;
    float v132 = 3.4028e38;
    float v133 = 3.4028e38;
    float v134 = -3.4028e38;
    unint64_t v135 = v994;
  }
  uint64_t v138 = a1;
  *(float *)(a1 + 1576) = v132;
  *(float *)(a1 + 1580) = v133;
  *(float *)(a1 + 1584) = v131;
  *(float *)(a1 + 1588) = v134;
  if (*(unsigned char *)(*(void *)(a1 + 440) + 29))
  {
    unsigned __int8 v139 = 0;
    *(unsigned char *)(a1 + 464) = 1;
    *(_DWORD *)(a1 + 488) = 1065353216;
    goto LABEL_283;
  }
  if (v47)
  {
    int v140 = *(unsigned __int8 *)v47;
    uint64_t v138 = a1;
    *(unsigned char *)(a1 + 464) = v140;
    if (v140 || *(unsigned char *)(a1 + 456))
    {
      *(float *)(a1 + 488) = v47[5] * v47[4];
      unsigned __int8 v139 = *((unsigned char *)v47 + 2);
      goto LABEL_283;
    }
  }
  else
  {
    uint64_t v138 = a1;
    *(unsigned char *)(a1 + 464) = 0;
  }
  unsigned __int8 v139 = 0;
  *(_DWORD *)(v138 + 488) = 0;
LABEL_283:
  *(unsigned char *)(v138 + 465) = v139;
  if (v44) {
    int v141 = *(_DWORD *)(v44 + 88);
  }
  else {
    int v141 = 0;
  }
  *(_DWORD *)(a1 + 492) = v141;
  *(void *)(a1 + 752) = *(void *)(v45 + 3760);
  *(void *)(a1 + 704) = *(void *)(v45 + 5240);
  *(void *)(a1 + 712) = *(void *)(v45 + 4760);
  *(void *)(a1 + 720) = *(void *)(v45 + 4768);
  *(void *)(a1 + 736) = *(void *)(v45 + 5576);
  *(_DWORD *)(a1 + 856) = *(_DWORD *)(v45 + 4280);
  *(void *)(a1 + 920) = *(void *)(v45 + 5248);
  *(void *)(a1 + 928) = *(void *)(v45 + 5256);
  *(void *)(a1 + 936) = *(void *)(v45 + 5264);
  *(void *)(a1 + 944) = *(void *)(v45 + 5272);
  *(void *)(a1 + 952) = *(void *)(v45 + 5280);
  *(void *)(a1 + 960) = *(void *)(v45 + 5288);
  *(void *)(a1 + 968) = *(void *)(v45 + 5296);
  *(void *)(a1 + 976) = *(void *)(v45 + 5304);
  *(void *)(a1 + 984) = *(void *)(v45 + 5312);
  *(void *)(a1 + 992) = *(void *)(v45 + 5320);
  *(void *)(a1 + 1000) = *(void *)(v45 + 5328);
  *(void *)(a1 + 1008) = *(void *)(v45 + 5336);
  *(void *)(a1 + 1016) = *(void *)(v45 + 5344);
  *(void *)(a1 + 1024) = *(void *)(v45 + 5352);
  *(void *)(a1 + 1032) = *(void *)(v45 + 5360);
  *(void *)(a1 + 1040) = *(void *)(v45 + 5368);
  *(void *)(a1 + 1048) = *(void *)(v45 + 4344);
  *(void *)(a1 + 1056) = *(void *)(v45 + 4352);
  *(void *)(a1 + 1064) = *(void *)(v45 + 4360);
  *(void *)(a1 + 1072) = *(void *)(v45 + 4368);
  *(void *)(a1 + 1080) = *(void *)(v45 + 4376);
  *(void *)(a1 + 1088) = *(void *)(v45 + 4384);
  *(void *)(a1 + 1096) = *(void *)(v45 + 4392);
  *(void *)(a1 + 1104) = *(void *)(v45 + 4400);
  *(void *)(a1 + 1112) = *(void *)(v45 + 4408);
  *(void *)(a1 + 1120) = *(void *)(v45 + 4416);
  *(void *)(a1 + 1128) = *(void *)(v45 + 4424);
  *(void *)(a1 + 1136) = *(void *)(v45 + 4432);
  *(void *)(a1 + 1144) = *(void *)(v45 + 4440);
  *(void *)(a1 + 1152) = *(void *)(v45 + 4448);
  *(void *)(a1 + 1160) = *(void *)(v45 + 4456);
  *(void *)(a1 + 1168) = *(void *)(v45 + 4464);
  *(void *)(a1 + 1176) = *(void *)(v45 + 4600);
  *(void *)(a1 + 1184) = *(void *)(v45 + 4608);
  *(void *)(a1 + 1192) = *(void *)(v45 + 4616);
  *(void *)(a1 + 1200) = *(void *)(v45 + 4624);
  *(void *)(a1 + 1208) = *(void *)(v45 + 4632);
  *(void *)(a1 + 1216) = *(void *)(v45 + 4640);
  *(void *)(a1 + 1224) = *(void *)(v45 + 4648);
  *(void *)(a1 + 1232) = *(void *)(v45 + 4656);
  *(void *)(a1 + 1240) = *(void *)(v45 + 4664);
  *(void *)(a1 + 1248) = *(void *)(v45 + 4672);
  *(void *)(a1 + 1256) = *(void *)(v45 + 4680);
  *(void *)(a1 + 1264) = *(void *)(v45 + 4688);
  *(void *)(a1 + 1272) = *(void *)(v45 + 4696);
  *(void *)(a1 + 1280) = *(void *)(v45 + 4704);
  *(void *)(a1 + 1288) = *(void *)(v45 + 4712);
  *(void *)(a1 + 1296) = *(void *)(v45 + 4720);
  *(void *)(a1 + 1304) = *(void *)(v45 + 5376);
  *(void *)(a1 + 1312) = *(void *)(v45 + 5384);
  *(void *)(a1 + 1320) = *(void *)(v45 + 5392);
  *(void *)(a1 + 1328) = *(void *)(v45 + 5400);
  *(void *)(a1 + 1336) = *(void *)(v45 + 5408);
  *(void *)(a1 + 1344) = *(void *)(v45 + 5416);
  *(void *)(a1 + 1352) = *(void *)(v45 + 5424);
  *(void *)(a1 + 1360) = *(void *)(v45 + 5432);
  *(void *)(a1 + 1368) = *(void *)(v45 + 5440);
  *(void *)(a1 + 1376) = *(void *)(v45 + 5448);
  *(void *)(a1 + 1384) = *(void *)(v45 + 5456);
  *(void *)(a1 + 1392) = *(void *)(v45 + 5464);
  *(void *)(a1 + 1400) = *(void *)(v45 + 5472);
  *(void *)(a1 + 1408) = *(void *)(v45 + 5480);
  *(void *)(a1 + 1416) = *(void *)(v45 + 5488);
  *(void *)(a1 + 1424) = *(void *)(v45 + 5496);
  uint64_t v142 = *(void *)(v45 + 4288);
  uint64_t v143 = *(void *)(v45 + 4296);
  double v144 = *(double *)(v45 + 4304);
  *(void *)(a1 + 576) = v142;
  *(void *)(a1 + 584) = v143;
  *(double *)(a1 + 592) = v144;
  if (!*(unsigned char *)(a1 + 462))
  {
    *(void *)(a1 + 552) = v142;
    *(void *)(a1 + 560) = v143;
    *(double *)(a1 + 568) = v144;
  }
  double v145 = *(double *)(v45 + 5224);
  *(_OWORD *)(a1 + 600) = *(_OWORD *)(v45 + 5208);
  *(double *)(a1 + 616) = v145;
  uint64_t v146 = *(void *)(v45 + 5200);
  *(_OWORD *)(a1 + 624) = *(_OWORD *)(v45 + 5184);
  *(void *)(a1 + 640) = v146;
  uint64_t v147 = *(void *)(v45 + 5176);
  uint64_t v985 = (_OWORD *)(a1 + 584);
  *(_OWORD *)(a1 + 648) = *(_OWORD *)(v45 + 5160);
  *(void *)(a1 + 664) = v147;
  *(float *)&uint64_t v147 = *(double *)(v45 + 3840);
  *(float *)&uint64_t v147 = *(float *)&v147 + 1.57079633;
  float v148 = fmodf(*(float *)&v147 + 3.1416, 6.2832);
  *(float *)(a1 + 860) = fmodf(v148 + 6.2832, 6.2832) + -3.1416;
  *(_DWORD *)(a1 + 864) = *(_DWORD *)(v45 + 5232);
  if (*(unsigned char *)(a1 + 448))
  {
    md::LabelLayoutContext::coordinateEyePos((md::LabelLayoutContext *)&v1022, v990);
    double v149 = *(double *)&v1022;
    long double v150 = cos(*(double *)&v1022 * 0.034906585) * -559.82 + 111132.92;
    long double v151 = v150 + cos(v149 * 0.0698131701) * 1.175;
    long double v152 = v151 + cos(v149 * 0.104719755) * -0.0023;
    double v153 = v149 * 0.00872664626;
    long double v154 = tan(v149 * 0.00872664626 + 0.78103484);
    double v155 = log(v154);
    long double v156 = tan(v153 + 0.789761487);
    double v157 = fabs((log(v156) - v155) * 0.159154943) / v152;
    *(double *)(a1 + 784) = v157;
    uint64_t v158 = *(void *)(a1 + 440);
    if (*(unsigned char *)(v158 + 96))
    {
      double v159 = v157 * *(double *)(v158 + 88);
      goto LABEL_293;
    }
LABEL_295:
    uint64_t v164 = 5544;
    if (*(unsigned char *)(v45 + 3784) == 1) {
      uint64_t v164 = 5520;
    }
    uint64_t v165 = 5536;
    if (*(unsigned char *)(v45 + 3784) == 1) {
      uint64_t v165 = 5512;
    }
    uint64_t v166 = 5552;
    if (*(unsigned char *)(v45 + 3784) == 1) {
      uint64_t v166 = 5528;
    }
    uint64_t v167 = *(void *)(v45 + v166);
    uint64_t v168 = *(void *)(v45 + v164);
    *(void *)(a1 + 672) = *(void *)(v45 + v165);
    *(void *)(a1 + 680) = v168;
    *(void *)(a1 + 688) = v167;
    *(void *)(a1 + 696) = *(void *)(v45 + 5560);
    if (!*(unsigned char *)(v158 + 84)) {
      goto LABEL_302;
    }
LABEL_294:
    BOOL v160 = 0;
    float v161 = *(float *)(v158 + 80);
    uint64_t v162 = a1;
    *(float *)(a1 + 472) = v161;
    *(float *)(a1 + 476) = v161;
    int v163 = (int)v161;
  }
  else
  {
    *(void *)(a1 + 784) = 0x3FF0000000000000;
    uint64_t v158 = *(void *)(a1 + 440);
    if (!*(unsigned char *)(v158 + 96)) {
      goto LABEL_295;
    }
    double v159 = *(double *)(v158 + 88);
LABEL_293:
    *(double *)(a1 + 696) = v159;
    *(float64x2_t *)(a1 + 672) = vmlaq_n_f64(*(float64x2_t *)(a1 + 576), *(float64x2_t *)(a1 + 600), v159);
    *(double *)(a1 + 688) = v144 + v145 * v159;
    if (*(unsigned char *)(v158 + 84)) {
      goto LABEL_294;
    }
LABEL_302:
    float v169 = floor((float)(*(float *)(md::LayoutContext::frameState(v135) + 112) * 1000.0) + 0.5) * 0.001;
    *(float *)(a1 + 472) = v169;
    *(_DWORD *)(a1 + 476) = *(_DWORD *)(md::LayoutContext::frameState(v994) + 112);
    float v170 = floor((float)(*(float *)(md::LayoutContext::frameState(v994) + 112) * 1000.0) + 0.5) * 0.001;
    int v163 = (int)v170;
    if ((int)v170 >= 23) {
      LOBYTE(v163) = 23;
    }
    uint64_t v158 = *(void *)v990;
    BOOL v160 = *(unsigned char *)(*(void *)v990 + 32) != 0;
    uint64_t v162 = a1;
    unint64_t v135 = v994;
  }
  unint64_t v171 = (float32x4_t *)(v162 + 872);
  *(unsigned char *)(v162 + 468) = v163;
  *(unsigned char *)(v162 + 467) = v160;
  if (v47 && *(unsigned char *)v47)
  {
    uint64_t v172 = a1;
    *(unsigned char *)(a1 + 460) = *(float *)(a1 + 472) >= *(float *)(v158 + 36);
    *(unsigned char *)(a1 + 461) = 0;
    BOOL v173 = 1;
  }
  else
  {
    double v174 = (unsigned __int8 *)*((void *)v135 + 92);
    int v175 = *v174;
    *(unsigned char *)(a1 + 460) = v175;
    *(unsigned char *)(a1 + 461) = v174[1];
    BOOL v173 = ((v97 - 1) >= 0xA || ((0x20Fu >> (v97 - 1)) & 1) == 0) && v175 != 0;
    uint64_t v172 = a1;
  }
  *(unsigned char *)(v172 + 459) = v173;
  float v176 = *(float *)(v172 + 860);
  float v177 = 1.57079633 - v176;
  float v178 = v177 * 0.159154943;
  *(unsigned char *)(v172 + 912) = vcvts_n_s32_f32(v178 - floorf(v178), 8uLL);
  *unint64_t v171 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 624)), *(float64x2_t *)(a1 + 640));
  *(float32x2_t *)(v172 + 888) = vcvt_f32_f64(*(float64x2_t *)(v172 + 656));
  float v179 = *(double *)(v45 + 3840);
  __float2 v180 = __sincosf_stret(v179);
  *(float *)(v172 + 896) = v180.__cosval;
  *(float *)(v172 + 900) = -v180.__sinval;
  if (v173)
  {
    if (*(unsigned char *)(v172 + 463)) {
      float v181 = 30.0;
    }
    else {
      float v181 = 20.0;
    }
    BOOL v182 = *(float *)(v172 + 864) < v181;
  }
  else
  {
    BOOL v182 = 1;
  }
  *(unsigned char *)(a1 + 463) = v182;
  double v183 = *(double *)(a1 + 576);
  BOOL v184 = vabdd_f64(*(double *)(a1 + 792), v183) < 0.00000001
      && vabdd_f64(*(double *)(a1 + 800), *(double *)(a1 + 584)) < 0.00000001
      && vabdd_f64(*(double *)(a1 + 808), *(double *)(a1 + 592)) < 0.00000001;
  double v185 = *(double *)(a1 + 600);
  v980 = v171;
  if (vabdd_f64(*(double *)(a1 + 816), v185) >= 0.00000001
    || vabdd_f64(*(double *)(a1 + 824), *(double *)(a1 + 608)) >= 0.00000001
    || vabdd_f64(*(double *)(a1 + 832), *(double *)(a1 + 616)) >= 0.00000001)
  {
    int v188 = 1;
  }
  else
  {
    float v186 = *(float *)(a1 + 840);
    if ((v186 >= -3.1416 && v186 <= 3.1416 || fabsf(v186 + 3.1416) <= 0.000001 || fabsf(v186 + -3.1416) <= 0.000001)
      && (v176 >= -3.1416 && v176 <= 3.1416 || fabsf(v176 + 3.1416) <= 0.000001 || fabsf(v176 + -3.1416) <= 0.000001))
    {
      BOOL v187 = vabds_f32(v186, v176) <= 0.000001
          || fabsf((float)(-6.2832 - fminf(v186, v176)) + fmaxf(v186, v176)) <= 0.000001;
    }
    else
    {
      BOOL v187 = 0;
    }
    int v188 = !v187;
  }
  float v189 = *(float *)(a1 + 864);
  float v190 = vabds_f32(*(float *)(a1 + 844), v189);
  float v191 = *(float *)(a1 + 472);
  float v192 = vabds_f32(*(float *)(a1 + 848), v191);
  int v193 = !v184 | v188;
  if (v190 > 0.000001) {
    int v193 = 1;
  }
  if (v192 > 0.000001) {
    int v194 = 1;
  }
  else {
    int v194 = v193;
  }
  if (v194 == 1)
  {
    *(double *)(a1 + 792) = v183;
    *(_OWORD *)(a1 + 800) = *v985;
    *(double *)(a1 + 816) = v185;
    *(_OWORD *)(a1 + 824) = *(_OWORD *)(a1 + 608);
    *(float *)(a1 + 840) = v176;
    *(float *)(a1 + 844) = v189;
    *(float *)(a1 + 848) = v191;
  }
  char v195 = *(unsigned char *)(a1 + 455);
  if (v195)
  {
    float v196 = *(double *)(v45 + 3848);
    __float2 v199 = __sincosf_stret(v196);
    float cosval = v199.__cosval;
    float sinval = v199.__sinval;
    char v195 = fabsf(v199.__cosval + -1.0) > 0.000001;
  }
  else
  {
    float sinval = 0.0;
    float cosval = 1.0;
  }
  *(float *)(a1 + 904) = cosval;
  *(float *)(a1 + 908) = sinval;
  *(unsigned char *)(a1 + 458) = v195;
  if (*(unsigned char *)(a1 + 456))
  {
    int v200 = *(unsigned __int8 *)(v158 + 18);
    *(_WORD *)(a1 + 449) = 0;
    double v201 = 0.0;
    if (!v200) {
      goto LABEL_358;
    }
LABEL_357:
    *(double *)(a1 + 728) = v201;
    goto LABEL_358;
  }
  if (!*(unsigned char *)(a1 + 448) && !*(unsigned char *)(v158 + 18))
  {
    *(_WORD *)(a1 + 449) = 0;
    goto LABEL_358;
  }
  *(unsigned char *)(a1 + 449) = v189 < 1.0;
  BOOL v202 = v189 < 20.0;
  if (v191 < 15.0) {
    BOOL v202 = 1;
  }
  *(unsigned char *)(a1 + 450) = v202;
  if (*(unsigned char *)(v158 + 18))
  {
    double v201 = 0.0;
    if (v189 < 1.0)
    {
      long double v203 = asin(213678.089/ sqrt(*(double *)(a1 + 576) * *(double *)(a1 + 576)+ *(double *)(a1 + 584) * *(double *)(a1 + 584)+ *(double *)(a1 + 592) * *(double *)(a1 + 592)));
      double v201 = cos(1.22173048 - v203) * -6378137.0;
    }
    goto LABEL_357;
  }
LABEL_358:
  *(void *)(a1 + 744) = *(void *)(v45 + 2984);
  if (a1 + 1592 != v45 + 2960) {
    std::vector<gm::Matrix<double,2,1>>::__assign_with_size[abi:nn180100]<gm::Matrix<double,2,1>*,gm::Matrix<double,2,1>*>(a1 + 1592, *(void *)(v45 + 2960), *(char **)(v45 + 2968), (uint64_t)(*(void *)(v45 + 2968) - *(void *)(v45 + 2960)) >> 4);
  }
  id v204 = *(id *)v994;
  [v204 sizeInPixels];
  *(float *)&double v205 = v205;
  *(_DWORD *)(a1 + 916) = LODWORD(v205);

  double v206 = *(float *)(a1 + 916);
  double v207 = (*(double *)(a1 + 752) + *(double *)(a1 + 752)) / v206;
  *(double *)(a1 + 760) = v207;
  double v208 = -*(double *)(a1 + 616);
  long long v209 = *(_OWORD *)(a1 + 640);
  *(_OWORD *)(a1 + 1432) = *(_OWORD *)(a1 + 624);
  *(_OWORD *)(a1 + 1448) = v209;
  float64x2_t v210 = vnegq_f64(*(float64x2_t *)(a1 + 600));
  *(_OWORD *)(a1 + 1464) = *(_OWORD *)(a1 + 656);
  *(float64x2_t *)(a1 + 1480) = v210;
  *(double *)(a1 + 1496) = v208;
  double v211 = *(double *)(a1 + 696);
  if (v211 == 0.0)
  {
    *(double *)(a1 + 768) = *(double *)(a1 + 744) / v206;
    if (!v194) {
      goto LABEL_371;
    }
LABEL_362:
    ++*(_DWORD *)(a1 + 1620);
    if (*(unsigned char *)(a1 + 448)) {
      char v212 = v188;
    }
    else {
      char v212 = 1;
    }
    if ((v212 & 1) != 0 || v190 > 0.000001 || v192 > 0.000001)
    {
LABEL_376:
      int v214 = *(_DWORD *)(a1 + 1616);
      if ((v214 + 1) > 1) {
        int v215 = v214 + 1;
      }
      else {
        int v215 = 1;
      }
      *(_DWORD *)(a1 + 1616) = v215;
    }
    else if (!v184)
    {
      goto LABEL_375;
    }
  }
  else
  {
    *(double *)(a1 + 768) = v211 * v207;
    if (v194) {
      goto LABEL_362;
    }
LABEL_371:
    if (*(unsigned char *)(a1 + 448)) {
      char v213 = v184;
    }
    else {
      char v213 = 1;
    }
    if ((v213 & 1) == 0)
    {
LABEL_375:
      if (*(float *)(a1 + 864) > 0.0) {
        goto LABEL_376;
      }
    }
  }
  float v216 = 1.0;
  float v217 = 1.0;
  if (v47) {
    float v217 = v47[5];
  }
  *(float *)(a1 + 1624) = v217;
  if (v48) {
    float v216 = *(float *)(v48 + 4);
  }
  *(float *)(a1 + 504) = v216;
  *(void *)(a1 + 776) = *(void *)(md::LayoutContext::frameState(v994) + 88);
  BOOL v218 = (void *)*((void *)v994 + 1);
  int8x8_t v219 = (int8x8_t)v218[1];
  if (!*(void *)&v219) {
    goto LABEL_409;
  }
  uint8x8_t v220 = (uint8x8_t)vcnt_s8(v219);
  v220.i16[0] = vaddlv_u8(v220);
  if (v220.u32[0] > 1uLL)
  {
    uint64_t v221 = 0x4927EB92E562CC46;
    if (*(void *)&v219 <= 0x4927EB92E562CC46uLL) {
      uint64_t v221 = 0x4927EB92E562CC46uLL % *(void *)&v219;
    }
  }
  else
  {
    uint64_t v221 = (*(void *)&v219 - 1) & 0x4927EB92E562CC46;
  }
  unint64_t v222 = *(void **)(*v218 + 8 * v221);
  if (!v222) {
    goto LABEL_409;
  }
  double v223 = (void *)*v222;
  if (!v223) {
    goto LABEL_409;
  }
  if (v220.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v225 = v223[1];
      if (v225 == 0x4927EB92E562CC46)
      {
        if (v223[2] == 0x4927EB92E562CC46) {
          goto LABEL_407;
        }
      }
      else if ((v225 & (*(void *)&v219 - 1)) != v221)
      {
        goto LABEL_409;
      }
      double v223 = (void *)*v223;
      if (!v223) {
        goto LABEL_409;
      }
    }
  }
  while (2)
  {
    unint64_t v224 = v223[1];
    if (v224 != 0x4927EB92E562CC46)
    {
      if (v224 >= *(void *)&v219) {
        v224 %= *(void *)&v219;
      }
      if (v224 != v221) {
        goto LABEL_409;
      }
      goto LABEL_394;
    }
    if (v223[2] != 0x4927EB92E562CC46)
    {
LABEL_394:
      double v223 = (void *)*v223;
      if (!v223) {
        goto LABEL_409;
      }
      continue;
    }
    break;
  }
LABEL_407:
  uint64_t v226 = v223[5];
  if (*(void *)(v226 + 8) == 0x4927EB92E562CC46)
  {
    uint64_t v227 = *(void *)(v226 + 32);
    goto LABEL_410;
  }
LABEL_409:
  uint64_t v227 = 0;
LABEL_410:
  *(void *)(a1 + 1672) = v227;
  if (*(unsigned char *)(a1 + 456))
  {
    if (!*(void *)&v219) {
      goto LABEL_438;
    }
LABEL_414:
    *(int8x8_t *)&long long v228 = vcnt_s8(v219);
    LOWORD(v228) = vaddlv_u8(*(uint8x8_t *)&v228);
    if (v228 > 1uLL)
    {
      unint64_t v229 = 0xDFC317497CF9A4BFLL;
      if (*(void *)&v219 <= 0xDFC317497CF9A4BFLL) {
        unint64_t v229 = 0xDFC317497CF9A4BFLL % *(void *)&v219;
      }
    }
    else
    {
      unint64_t v229 = (*(void *)&v219 - 1) & 0xDFC317497CF9A4BFLL;
    }
    long double v230 = *(void **)(*v218 + 8 * v229);
    if (!v230) {
      goto LABEL_438;
    }
    float v231 = (void *)*v230;
    if (!v231) {
      goto LABEL_438;
    }
    if (v228 < 2uLL)
    {
      uint64_t v232 = *(void *)&v219 - 1;
      while (1)
      {
        uint64_t v234 = v231[1];
        if (v234 == 0xDFC317497CF9A4BFLL)
        {
          if (v231[2] == 0xDFC317497CF9A4BFLL) {
            goto LABEL_434;
          }
        }
        else if ((v234 & v232) != v229)
        {
          goto LABEL_438;
        }
        float v231 = (void *)*v231;
        if (!v231) {
          goto LABEL_438;
        }
      }
    }
    while (1)
    {
      unint64_t v233 = v231[1];
      if (v233 == 0xDFC317497CF9A4BFLL)
      {
        if (v231[2] == 0xDFC317497CF9A4BFLL)
        {
LABEL_434:
          uint64_t v235 = v231[5];
          if (*(void *)(v235 + 8) != 0xDFC317497CF9A4BFLL) {
            goto LABEL_438;
          }
          unint64_t v236 = *(void **)(v235 + 32);
          if (!v236) {
            goto LABEL_438;
          }
          unint64_t v239 = (void *)*v236;
          unint64_t v237 = v236 + 1;
          unint64_t v238 = v239;
          if (v239 == v237) {
            goto LABEL_438;
          }
          double v240 = 0;
          double v241 = 0;
          double v242 = 0;
          while (2)
          {
            uint64_t v260 = v43;
            char v261 = *((unsigned char *)v238 + 28);
            if (v261)
            {
              LODWORD(v228) = *((_DWORD *)v238 + 9);
              double v262 = (double)(unint64_t)v228;
              if (v241 < v242) {
                goto LABEL_464;
              }
LABEL_467:
              uint64_t v265 = (v241 - v240) >> 4;
              unint64_t v266 = v265 + 1;
              if ((unint64_t)(v265 + 1) >> 60) {
                abort();
              }
              if ((v242 - v240) >> 3 > v266) {
                unint64_t v266 = (v242 - v240) >> 3;
              }
              if ((unint64_t)(v242 - v240) >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v267 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v267 = v266;
              }
              if (v267)
              {
                if (v267 >> 60) {
                  goto LABEL_1436;
                }
                uint64_t v268 = (char *)operator new(16 * v267);
              }
              else
              {
                uint64_t v268 = 0;
              }
              unint64_t v269 = &v268[16 * v265];
              char *v269 = v261;
              *((double *)v269 + 1) = v262;
              if (v241 == v240)
              {
                unint64_t v271 = &v268[16 * v265];
                uint64_t v43 = v260;
              }
              else
              {
                unint64_t v270 = &v268[16 * v265];
                uint64_t v43 = v260;
                do
                {
                  long long v228 = *((_OWORD *)v241 - 1);
                  unint64_t v271 = v270 - 16;
                  *((_OWORD *)v270 - 1) = v228;
                  v241 -= 16;
                  v270 -= 16;
                }
                while (v241 != v240);
              }
              double v242 = &v268[16 * v267];
              double v241 = v269 + 16;
              if (v240) {
                operator delete(v240);
              }
              double v240 = v271;
              double v264 = (void *)v238[1];
              if (v264) {
                goto LABEL_485;
              }
              do
              {
LABEL_487:
                unint64_t v272 = (void *)v238[2];
                _ZF = *v272 == (void)v238;
                unint64_t v238 = v272;
              }
              while (!_ZF);
            }
            else
            {
              double v262 = 1.79769313e308;
              if (v241 >= v242) {
                goto LABEL_467;
              }
LABEL_464:
              *double v241 = v261;
              int v263 = v1022;
              *((_DWORD *)v241 + 1) = *(_DWORD *)((char *)&v1022 + 3);
              *(_DWORD *)(v241 + 1) = v263;
              *((double *)v241 + 1) = v262;
              v241 += 16;
              uint64_t v43 = v260;
              double v264 = (void *)v238[1];
              if (!v264) {
                goto LABEL_487;
              }
              do
              {
LABEL_485:
                unint64_t v272 = v264;
                double v264 = (void *)*v264;
              }
              while (v264);
            }
            unint64_t v238 = v272;
            if (v272 == v237) {
              goto LABEL_439;
            }
            continue;
          }
        }
      }
      else
      {
        if (v233 >= *(void *)&v219) {
          v233 %= *(void *)&v219;
        }
        if (v233 != v229) {
          goto LABEL_438;
        }
      }
      float v231 = (void *)*v231;
      if (!v231) {
        goto LABEL_438;
      }
    }
  }
  *(_DWORD *)(a1 + 1628) = 1114636288;
  *(unsigned char *)(a1 + 1632) = 1;
  BOOL v218 = (void *)*((void *)v994 + 1);
  int8x8_t v219 = (int8x8_t)v218[1];
  if (v219) {
    goto LABEL_414;
  }
LABEL_438:
  double v242 = 0;
  double v241 = 0;
  double v240 = 0;
LABEL_439:
  long long v243 = *(unsigned __int8 **)(a1 + 1656);
  unint64_t v244 = *(unsigned __int8 **)(a1 + 1648);
  if (v243 - v244 == v241 - v240)
  {
    if (v244 != v243)
    {
      double v245 = (double *)v240;
      double v246 = *(double **)(a1 + 1648);
      while (*(unsigned __int8 *)v246 == *(unsigned __int8 *)v245 && v246[1] == v245[1])
      {
        v246 += 2;
        v245 += 2;
        if (v246 == (double *)v243) {
          goto LABEL_448;
        }
      }
      goto LABEL_450;
    }
LABEL_448:
    *(unsigned char *)(a1 + 1636) = 0;
    if (v240) {
      operator delete(v240);
    }
  }
  else
  {
LABEL_450:
    ++*(unsigned char *)(a1 + 1637);
    *(unsigned char *)(a1 + 1636) = 1;
    if (v244)
    {
      *(void *)(a1 + 1656) = v244;
      operator delete(v244);
      *(void *)(a1 + 1648) = 0;
      *(void *)(a1 + 1656) = 0;
      *(void *)(a1 + 1664) = 0;
    }
    *(void *)(a1 + 1648) = v240;
    *(void *)(a1 + 1656) = v241;
    *(void *)(a1 + 1664) = v242;
    *(void *)(a1 + 1640) = 0;
    if ((unint64_t)(v241 - v240) >= 0x11) {
      *(double *)(a1 + 1640) = sqrt(*((double *)v241 - 3));
    }
  }
  if (*(unsigned char *)(md::LayoutContext::frameState(v994) + 84) == 2)
  {
    int v248 = *(_DWORD *)(md::LayoutContext::frameState(v994) + 80);
  }
  else
  {
    int v249 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 168) + 32) + 8))(*(void *)(*(void *)(a1 + 168) + 32));
    int v248 = 0;
    if (v249) {
      int v248 = *(_DWORD *)(a1 + 3364);
    }
  }
  *(_DWORD *)(a1 + 1680) = v248;
  *(unsigned char *)(a1 + 1712) = *(unsigned char *)(md::LayoutContext::frameState(v994) + 84);
  unint64_t v250 = (double *)md::LayoutContext::frameState(v994);
  double v251 = v250[8];
  double v252 = v250[9];
  long double v253 = tan(v250[7] * 0.5 + 0.785398163);
  double v254 = log(v253);
  double v255 = v252 * *(float *)(a1 + 488);
  double v256 = (void *)*((void *)v994 + 1);
  int8x8_t v257 = (int8x8_t)v256[1];
  if (v257)
  {
    uint8x8_t v258 = (uint8x8_t)vcnt_s8(v257);
    v258.i16[0] = vaddlv_u8(v258);
    if (v258.u32[0] > 1uLL)
    {
      uint64_t v259 = 0x1B8B241A8D896A1DLL;
      if (*(void *)&v257 <= 0x1B8B241A8D896A1DuLL) {
        uint64_t v259 = 0x1B8B241A8D896A1DuLL % *(void *)&v257;
      }
    }
    else
    {
      uint64_t v259 = (*(void *)&v257 - 1) & 0x1B8B241A8D896A1DLL;
    }
    double v273 = *(void **)(*v256 + 8 * v259);
    if (v273)
    {
      double v274 = (void *)*v273;
      if (v274)
      {
        if (v258.u32[0] < 2uLL)
        {
          uint64_t v275 = *(void *)&v257 - 1;
          while (1)
          {
            uint64_t v277 = v274[1];
            if (v277 == 0x1B8B241A8D896A1DLL)
            {
              if (v274[2] == 0x1B8B241A8D896A1DLL) {
                goto LABEL_508;
              }
            }
            else if ((v277 & v275) != v259)
            {
              goto LABEL_511;
            }
            double v274 = (void *)*v274;
            if (!v274) {
              goto LABEL_511;
            }
          }
        }
        do
        {
          unint64_t v276 = v274[1];
          if (v276 == 0x1B8B241A8D896A1DLL)
          {
            if (v274[2] == 0x1B8B241A8D896A1DLL)
            {
LABEL_508:
              uint64_t v278 = v274[5];
              if (*(void *)(v278 + 8) == 0x1B8B241A8D896A1DLL)
              {
                uint64_t v279 = *(void *)(v278 + 32);
                if (v279) {
                  double v255 = v255 + *(float *)(v279 + 88);
                }
              }
              break;
            }
          }
          else
          {
            if (v276 >= *(void *)&v257) {
              v276 %= *(void *)&v257;
            }
            if (v276 != v259) {
              break;
            }
          }
          double v274 = (void *)*v274;
        }
        while (v274);
      }
    }
  }
LABEL_511:
  double v280 = v251 * 0.159154943 + 0.5;
  double v281 = v254 * 0.159154943 + 0.5;
  int v282 = *(unsigned __int8 *)(a1 + 448);
  if (*(unsigned char *)(a1 + 448))
  {
    double v283 = *(double *)(*(void *)(a1 + 232) + 56) * v255;
  }
  else
  {
    long double v284 = v280 * 6.28318531;
    long double v285 = exp(v281 * 6.28318531 + -3.14159265);
    double v286 = atan(v285) * 2.0 + -1.57079633;
    long double v287 = fmod(v284, 6.28318531);
    double v288 = fmod(v287 + 6.28318531, 6.28318531) + -3.14159265;
    __double2 v289 = __sincos_stret(v286);
    double v290 = 6378137.0 / sqrt(v289.__sinval * v289.__sinval * -0.00669437999 + 1.0);
    double v291 = (v290 + v255) * v289.__cosval;
    __double2 v292 = __sincos_stret(v288);
    double v280 = v291 * v292.__cosval;
    double v281 = v291 * v292.__sinval;
    double v283 = (v255 + v290 * 0.99330562) * v289.__sinval;
  }
  *(double *)(a1 + 1688) = v280;
  *(double *)(a1 + 1696) = v281;
  *(double *)(a1 + 1704) = v283;
  float v293 = *(float *)(a1 + 496);
  float v294 = *(float *)(a1 + 860);
  if (vabds_f32(v293, v294) > 0.0959931128)
  {
    float v293 = round(v294 * 6.36619755) * 0.157079637;
    *(float *)(a1 + 496) = v293;
  }
  float v295 = v293 + -0.07854;
  __float2 v296 = __sincosf_stret((float)(v293 + -0.07854) - v294);
  *(float *)(a1 + 508) = -v296.__sinval;
  *(float *)(a1 + 512) = v296.__cosval;
  *(float *)(a1 + 516) = v296.__cosval;
  *(float *)(a1 + 520) = v296.__sinval;
  if (v282)
  {
    __float2 v299 = __sincosf_stret(v295);
    float v298 = v299.__cosval;
    float v297 = v299.__sinval;
    float v300 = -v299.__cosval;
    float v301 = 0.0;
    float v302 = v299.__sinval;
    float v303 = 0.0;
  }
  else
  {
    double v304 = *(double *)(a1 + 576);
    double v305 = *(double *)(a1 + 584);
    double v306 = *(double *)(a1 + 592);
    double v307 = 1.0 / sqrt(v304 * v304 + v305 * v305 + v306 * v306);
    double v308 = v307 * v304;
    double v309 = v307 * v305;
    double v310 = v307 * v306;
    double v991 = v307 * v306;
    double v311 = 1.0 / sqrt(v309 * v309 + v308 * v308);
    double v995 = v19;
    double v312 = -(v307 * v305 * v311);
    double v313 = v311 * v308;
    double v987 = v295 * 0.5;
    __double2 v314 = __sincos_stret(v987);
    double v315 = v310 * v314.__sinval;
    double v316 = v310 * v314.__sinval * -2.0 * v313;
    double v317 = (v312 + v312) * (v310 * v314.__sinval);
    double v318 = -(v312 * (v309 * v314.__sinval) - v313 * (v308 * v314.__sinval))
         - (v312 * (v309 * v314.__sinval)
          - v313 * (v308 * v314.__sinval));
    float v298 = v312 + v316 * v314.__cosval - v317 * (v310 * v314.__sinval) + v318 * (v309 * v314.__sinval);
    float v297 = v313 + v316 * v315 + v317 * v314.__cosval - v318 * (v308 * v314.__sinval);
    float v301 = v318 * v314.__cosval - (v316 * (v309 * v314.__sinval) - v317 * (v308 * v314.__sinval));
    __double2 v319 = __sincos_stret(v987 + -0.785398163);
    double v320 = v991 * v319.__sinval * -2.0 * v313;
    double v321 = (v312 + v312) * (v991 * v319.__sinval);
    double v322 = -(v312 * (v309 * v319.__sinval) - v313 * (v308 * v319.__sinval))
         - (v312 * (v309 * v319.__sinval)
          - v313 * (v308 * v319.__sinval));
    double v323 = v313 + v320 * (v991 * v319.__sinval);
    double v19 = v995;
    float v302 = v312 + v320 * v319.__cosval - v321 * (v991 * v319.__sinval) + v322 * (v309 * v319.__sinval);
    float v300 = v323 + v321 * v319.__cosval - v322 * (v308 * v319.__sinval);
    float v303 = v322 * v319.__cosval - (v320 * (v309 * v319.__sinval) - v321 * (v308 * v319.__sinval));
  }
  *(float *)(a1 + 524) = v298;
  *(float *)(a1 + 528) = v297;
  *(float *)(a1 + 532) = v301;
  *(float *)(a1 + 536) = v302;
  *(float *)(a1 + 540) = v300;
  *(float *)(a1 + 544) = v303;
  if (!*(unsigned char *)(a1 + 464))
  {
    float v328 = 0.0;
    goto LABEL_569;
  }
  unint64_t v324 = (uint64_t *)*((void *)v994 + 1);
  int8x8_t v325 = (int8x8_t)v324[1];
  if (!*(void *)&v325)
  {
    float v329 = MEMORY[0x14];
    double v330 = MEMORY[0x200];
    if (!v282) {
      goto LABEL_525;
    }
    goto LABEL_567;
  }
  uint8x8_t v326 = (uint8x8_t)vcnt_s8(v325);
  v326.i16[0] = vaddlv_u8(v326);
  if (v326.u32[0] > 1uLL)
  {
    unint64_t v327 = 0x8BD499FBD96FBB9ELL;
    if (*(void *)&v325 <= 0x8BD499FBD96FBB9ELL) {
      unint64_t v327 = 0x8BD499FBD96FBB9ELL % *(void *)&v325;
    }
  }
  else
  {
    unint64_t v327 = (*(void *)&v325 - 1) & 0x8BD499FBD96FBB9ELL;
  }
  uint64_t v337 = *v324;
  unint64_t v338 = *(void **)(v337 + 8 * v327);
  if (v338 && (__double2 v339 = (void *)*v338) != 0)
  {
    if (v326.u32[0] >= 2uLL)
    {
      while (v339[1] != 0x8BD499FBD96FBB9ELL || v339[2] != 0x8BD499FBD96FBB9ELL)
        __double2 v339 = (void *)*v339;
    }
    else
    {
      while (v339[1] != 0x8BD499FBD96FBB9ELL || v339[2] != 0x8BD499FBD96FBB9ELL)
        __double2 v339 = (void *)*v339;
    }
    uint64_t v340 = *(void *)(v339[5] + 32) + 20;
    if (v326.u32[0] > 1uLL) {
      goto LABEL_540;
    }
LABEL_543:
    unint64_t v341 = (*(void *)&v325 - 1) & 0x1AF456233693CD46;
  }
  else
  {
    uint64_t v340 = 20;
    if (v326.u32[0] <= 1uLL) {
      goto LABEL_543;
    }
LABEL_540:
    unint64_t v341 = 0x1AF456233693CD46;
    if (*(void *)&v325 <= 0x1AF456233693CD46uLL) {
      unint64_t v341 = 0x1AF456233693CD46uLL % *(void *)&v325;
    }
  }
  float v329 = *(float *)v340;
  long long v342 = *(void **)(v337 + 8 * v341);
  if (!v342) {
    goto LABEL_566;
  }
  unint64_t v343 = (void *)*v342;
  if (!v343) {
    goto LABEL_566;
  }
  if (v326.u32[0] < 2uLL)
  {
    uint64_t v344 = *(void *)&v325 - 1;
    while (1)
    {
      uint64_t v346 = v343[1];
      if (v346 == 0x1AF456233693CD46)
      {
        if (v343[2] == 0x1AF456233693CD46) {
          goto LABEL_563;
        }
      }
      else if ((v346 & v344) != v341)
      {
        goto LABEL_566;
      }
      unint64_t v343 = (void *)*v343;
      if (!v343) {
        goto LABEL_566;
      }
    }
  }
  while (1)
  {
    unint64_t v345 = v343[1];
    if (v345 == 0x1AF456233693CD46) {
      break;
    }
    if (v345 >= *(void *)&v325) {
      v345 %= *(void *)&v325;
    }
    if (v345 != v341) {
      goto LABEL_566;
    }
LABEL_549:
    unint64_t v343 = (void *)*v343;
    if (!v343) {
      goto LABEL_566;
    }
  }
  if (v343[2] != 0x1AF456233693CD46) {
    goto LABEL_549;
  }
LABEL_563:
  unint64_t v347 = (int8x8_t *)v343[5];
  if (*(void *)&v347[1] != 0x1AF456233693CD46)
  {
LABEL_566:
    int8x8_t v325 = 0;
    double v330 = MEMORY[0x200];
    if (!v282) {
      goto LABEL_525;
    }
    goto LABEL_567;
  }
  int8x8_t v325 = v347[4];
  double v330 = *(double *)(*(void *)&v325 + 512);
  if (!v282)
  {
LABEL_525:
    double v331 = sqrt(*(double *)(*(void *)&v325 + 504) * *(double *)(*(void *)&v325 + 504)+ *(double *)(*(void *)&v325 + 496) * *(double *)(*(void *)&v325 + 496));
    double v332 = atan2(v330, v331 * 0.996647189);
    __double2 v333 = __sincos_stret(v332);
    double v334 = atan2(v330 + v333.__sinval * v333.__sinval * 42841.3115 * v333.__sinval, v331 + v333.__cosval * v333.__cosval * -42697.6727 * v333.__cosval);
    __double2 v335 = __sincos_stret(v334);
    double v336 = v331 / v335.__cosval + -6378137.0 / sqrt(v335.__sinval * v335.__sinval * -0.00669437999 + 1.0);
    goto LABEL_568;
  }
LABEL_567:
  double v336 = v330 * 40075017.0;
LABEL_568:
  float v348 = v336;
  float v328 = fmaxf(v348 * 0.002, 1.0) * v329;
LABEL_569:
  *(float *)(a1 + 500) = v328;
  unint64_t v349 = +[VKDebugSettings sharedSettings];
  *(unsigned char *)(a1 + 1713) = [v349 enableDOF];

  uint64_t v350 = +[VKDebugSettings sharedSettings];
  [v350 dofStrength];
  *(_DWORD *)(a1 + 1716) = v351;

  if (*(unsigned char *)(a1 + 3656) && fmod(*(long double *)(a1 + 776), 6.0) > 3.0)
  {
    float v352 = *(float *)(a1 + 472) + 0.2;
    *(float *)(a1 + 472) = v352;
    *(unsigned char *)(a1 + 468) = (int)v352;
  }
  if (*(unsigned char *)(a1 + 1636))
  {
    *(void *)&long long v1022 = &unk_1EF56E958;
    *((void *)&v1022 + 1) = a1;
    *((void *)&v1023 + 1) = &v1022;
    md::LabelManager::queueCommand((md::LabelManager *)a1, 65, 0, &v1022);
    if (*((long long **)&v1023 + 1) == &v1022)
    {
      (*(void (**)(long long *))(v1022 + 32))(&v1022);
    }
    else if (*((void *)&v1023 + 1))
    {
      (*(void (**)(void))(**((void **)&v1023 + 1) + 40))();
    }
  }
  if (__p[0] != *v1002 || __p[1] != *(void **)(a1 + 1552)) {
    *(unsigned char *)(a1 + 3049) = 1;
  }
  *(unsigned char *)(a1 + 3028) = *(unsigned char *)(md::LayoutContext::frameState(v994) + 48);
  double v353 = *(double *)(v43 + 5560);
  if (v353 == 0.0) {
    double v353 = *(double *)(a1 + 3128);
  }
  uint64_t v354 = *(int *)(a1 + 3136);
  *(double *)(a1 + 8 * v354 + 3088) = 1.0 - *(double *)(a1 + 3128) / v353;
  *(_DWORD *)(a1 + 3136) = ((int)v354 + 1) % 5;
  *(double *)(a1 + 3128) = v353;
  int v355 = *(void **)(a1 + 360);
  uint64_t v356 = (uint64_t *)v355[12];
  size_t v998 = (uint64_t *)v355[13];
  if (v356 == v998) {
    goto LABEL_642;
  }
  int v357 = 0;
  uint64_t v358 = (uint64_t)(v355 + 16);
  uint64_t v1003 = *(void **)(a1 + 360);
  while (2)
  {
    unint64_t v359 = (uint64_t *)*v356;
    if (*(unsigned char *)(*v356 + 285))
    {
      BOOL v360 = 0;
      *((unsigned char *)v359 + 285) = 0;
      char v361 = 4;
      goto LABEL_588;
    }
    if (*((unsigned char *)v359 + 282) != 2)
    {
      BOOL v360 = 0;
      goto LABEL_625;
    }
    uint64_t v363 = *v359;
    uint64_t v362 = v359[1];
    if (*v359 == v362)
    {
LABEL_619:
      int v374 = 2;
      goto LABEL_620;
    }
    BOOL v364 = 1;
    int v992 = v357;
    uint64_t v988 = v359[1];
    while (*(unsigned char *)(v363 + 238))
    {
      if (*(unsigned char *)(v363 + 238) == 1)
      {
        uint64_t v365 = (*(void *)(v363 + 16) - *(void *)(v363 + 8)) >> 3;
        char v366 = 1;
      }
      else
      {
        char v366 = 0;
        LOBYTE(v365) = 0;
      }
LABEL_615:
      *(unsigned char *)(v363 + 244) = ((*(_DWORD *)(v363 + 16) - *(_DWORD *)(v363 + 8)) >> 3) - v365;
      *(unsigned char *)(v363 + 241) = v366 & 1;
      if (*(unsigned char *)(v363 + 242))
      {
LABEL_623:
        *((unsigned char *)v359 + 282) = 5;
        BOOL v360 = 1;
        goto LABEL_625;
      }
      if (v364)
      {
        int v373 = *(unsigned __int8 *)(v363 + 241);
        BOOL v364 = *(unsigned char *)(v363 + 241) != 0;
        v363 += 248;
        if (v363 == v362)
        {
          if (v373) {
            goto LABEL_619;
          }
LABEL_636:
          int v374 = 1;
LABEL_620:
          int v375 = *((unsigned __int8 *)v359 + 280);
          BOOL v360 = v374 != v375;
          *((unsigned char *)v359 + 281) = v375;
          *((unsigned char *)v359 + 280) = v374;
          char v361 = 3;
LABEL_588:
          *((unsigned char *)v359 + 282) = v361;
          goto LABEL_625;
        }
      }
      else
      {
        BOOL v364 = 0;
        v363 += 248;
        if (v363 == v362) {
          goto LABEL_636;
        }
      }
    }
    BOOL v996 = v364;
    unint64_t v368 = *(unsigned int **)(v363 + 8);
    unint64_t v367 = *(unsigned int **)(v363 + 16);
    if (v368 == v367)
    {
      char v369 = 0;
      char v366 = 0;
      LOBYTE(v365) = 0;
LABEL_608:
      int v372 = *(unsigned __int8 *)(v363 + 237);
      uint64_t v362 = v988;
      BOOL v364 = v996;
      if (*(unsigned char *)(v363 + 237))
      {
        if (v372 == 2)
        {
          char v366 = *(unsigned __int8 *)(v363 + 240) <= v365;
        }
        else if (v372 == 1)
        {
          char v366 = v369 ^ 1;
        }
        else
        {
          char v366 = 0;
        }
      }
      *(unsigned char *)(v363 + 243) = v365;
      int v357 = v992;
      goto LABEL_615;
    }
    LOBYTE(v365) = 0;
    char v366 = 0;
    char v369 = 0;
    while (1)
    {
      unsigned int v370 = *v368;
      md::OcclusionQueryResource::initialize(v355[28] + 24 * *v368);
      int v355 = v1003;
      if (*((unsigned char *)v368 + 4) == 1) {
        goto LABEL_598;
      }
      if (*((unsigned char *)v368 + 4)) {
        goto LABEL_605;
      }
      uint64_t v371 = *(void *)(v1003[28] + 24 * v370);
      if (*(unsigned char *)(v371 + 136) == 2)
      {
        *(unsigned char *)(v363 + 242) = 1;
        int v357 = v992;
        goto LABEL_623;
      }
      if (!*(unsigned char *)(v371 + 129)) {
        break;
      }
      if (!*(_DWORD *)(v371 + 132))
      {
LABEL_605:
        char v369 = 1;
        goto LABEL_599;
      }
LABEL_598:
      LOBYTE(v365) = v365 + 1;
      char v366 = 1;
LABEL_599:
      v368 += 2;
      if (v368 == v367) {
        goto LABEL_608;
      }
    }
    BOOL v360 = 0;
    int v357 = v992;
LABEL_625:
    unint64_t v376 = (uint64_t *)*v356;
    unsigned int v377 = *(unsigned __int8 *)(*v356 + 282);
    if (v377 >= 3)
    {
      uint64_t v378 = *v376;
      uint64_t v379 = v376[1];
      if (*v376 != v379)
      {
        do
        {
          md::OcclusionTest::checkinResources(*(md::OcclusionTest **)(v378 + 8), *(md::OcclusionContext **)(v378 + 16), v358);
          v378 += 248;
        }
        while (v378 != v379);
        uint64_t v381 = *v376;
        uint64_t v380 = v376[1];
        int v355 = v1003;
        if (*v376 != v380)
        {
          unint64_t v382 = v380 - v381 - 248;
          uint64_t v383 = *v376;
          if (v382 < 0xF8) {
            goto LABEL_1452;
          }
          unint64_t v384 = v382 / 0xF8 + 1;
          uint64_t v383 = v381 + 248 * (v384 & 0x3FFFFFFFFFFFFFELL);
          uint64_t v385 = (void *)(v381 + 264);
          uint64_t v386 = v384 & 0x3FFFFFFFFFFFFFELL;
          do
          {
            uint64_t v387 = *(v385 - 1);
            *(v385 - 31) = *(v385 - 32);
            void *v385 = v387;
            v385 += 62;
            v386 -= 2;
          }
          while (v386);
          if (v384 != (v384 & 0x3FFFFFFFFFFFFFELL))
          {
LABEL_1452:
            do
            {
              *(void *)(v383 + 16) = *(void *)(v383 + 8);
              v383 += 248;
            }
            while (v383 != v380);
          }
        }
      }
      if (v377 == 5)
      {
        *((unsigned char *)v376 + 281) = *((unsigned char *)v376 + 280);
        *((unsigned char *)v376 + 280) = 0;
      }
      *((unsigned char *)v376 + 282) = 0;
      atomic_store(1u, (unsigned __int8 *)v376 + 286);
    }
    v357 |= v360;
    v356 += 2;
    if (v356 != v998) {
      continue;
    }
    break;
  }
  uint64_t v388 = (void *)v355[12];
  uint64_t v389 = (void *)v355[13];
  if (v388 == v389)
  {
LABEL_642:
    unint64_t v390 = v994;
    goto LABEL_643;
  }
  unint64_t v390 = v994;
  while (*(unsigned char *)(*v388 + 282))
  {
    v388 += 2;
    if (v388 == v389) {
      goto LABEL_643;
    }
  }
  if (v388 != v389)
  {
    uint64_t v410 = v388 + 2;
    if (v388 + 2 != v389)
    {
      do
      {
        uint64_t v411 = *v410;
        if (*(unsigned char *)(*v410 + 282))
        {
          uint64_t v412 = v410[1];
          *uint64_t v410 = 0;
          v410[1] = 0;
          unint64_t v413 = (std::__shared_weak_count *)v388[1];
          void *v388 = v411;
          v388[1] = v412;
          if (v413 && !atomic_fetch_add(&v413->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v413->__on_zero_shared)(v413);
            std::__shared_weak_count::__release_weak(v413);
            int v355 = v1003;
          }
          v388 += 2;
        }
        v410 += 2;
      }
      while (v410 != v389);
      uint64_t v389 = (void *)v355[13];
    }
  }
  if (v388 != v389)
  {
    do
    {
      long long v419 = (std::__shared_weak_count *)*(v389 - 1);
      if (v419 && !atomic_fetch_add(&v419->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v419->__on_zero_shared)(v419);
        std::__shared_weak_count::__release_weak(v419);
        int v355 = v1003;
      }
      v389 -= 2;
    }
    while (v389 != v388);
    v355[13] = v388;
  }
LABEL_643:
  float v391 = v19;
  uint64_t v392 = a1;
  (*(void (**)(void, md::LayoutContext *, float))(**(void **)(a1 + 240) + 24))(*(void *)(a1 + 240), v390, v391);
  if (*(unsigned char *)(a1 + 3381))
  {
    *(unsigned char *)(a1 + 3381) = 0;
    md::LabelManager::tryWaitForBkgdUpdateComplete((md::LabelManager *)a1, 0x1F4u);
  }
  unint64_t v393 = (uint64_t *)(a1 + 1672);
  if (*(unsigned char *)(a1 + 3385))
  {
LABEL_876:
    uint64_t v561 = *(void *)(v392 + 304);
    unsigned int v562 = *(_DWORD *)(v392 + 3272);
    *(_DWORD *)(v561 + 112) = v562;
    *(_DWORD *)(v561 + 116) = 0;
    atomic_store(v562, (unsigned int *)(*(void *)(v561 + 104) + 76));
    *(_DWORD *)(*(void *)(v561 + 128) + 160) = v562;
    __p[0] = &unk_1EF56E7A8;
    *((void *)&v1009 + 1) = __p;
    uint64_t v1040 = (void (**)(void **))&unk_1EF56E7F0;
    uint64_t v1042 = (void **)&v1040;
    *((void *)&v1023 + 1) = &v1022;
    *(void *)&long long v1022 = &unk_1EF56E7F0;
    if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
    }
    uint64_t v563 = (id)GEOGetVectorKitPerformanceLog_log;
    if (os_signpost_enabled(v563))
    {
      LOWORD(buf) = 0;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v563, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LayoutDisplayLabels", "", (uint8_t *)&buf, 2u);
    }

    if (v1042 == (void **)&v1040)
    {
      v1040[4]((void **)&v1040);
    }
    else if (v1042)
    {
      (*((void (**)(void))*v1042 + 5))();
    }
    if (*((void ***)&v1009 + 1) == __p)
    {
      (*((void (**)(void **))__p[0] + 4))(__p);
      uint64_t v564 = *v393;
      if (*v393)
      {
LABEL_888:
        float v565 = 1.0 - *(float *)(v564 + 280);
        goto LABEL_891;
      }
    }
    else
    {
      if (*((void *)&v1009 + 1)) {
        (*(void (**)(void))(**((void **)&v1009 + 1) + 40))();
      }
      uint64_t v564 = *v393;
      if (*v393) {
        goto LABEL_888;
      }
    }
    float v565 = 1.0;
LABEL_891:
    *(float *)(a1 + 3344) = v565;
    (*(void (**)(void, md::LayoutContext *))(**(void **)(a1 + 240) + 56))(*(void *)(a1 + 240), v390);
    if (!*((void *)&v1023 + 1))
    {
      std::__throw_bad_function_call[abi:nn180100]();
      goto LABEL_1449;
    }
    (*(void (**)(void))(**((void **)&v1023 + 1) + 48))(*((void *)&v1023 + 1));
    if (*((long long **)&v1023 + 1) == &v1022)
    {
      (*(void (**)(long long *))(v1022 + 32))(&v1022);
    }
    else if (*((void *)&v1023 + 1))
    {
      (*(void (**)(void))(**((void **)&v1023 + 1) + 40))();
    }
    uint64_t v566 = *(void *)(a1 + 304);
    *(unsigned char *)(v566 + 120) = 0;
    unint64_t v567 = *(void *)(v566 + 104);
    if (*(void *)(v567 + 32) != *(void *)(v567 + 40))
    {
      v568 = *(std::__shared_weak_count **)(v567 + 16);
      buf = *(std::__shared_weak_count_vtbl **)(v567 + 8);
      uint64_t v1038 = v568;
      if (v568) {
        atomic_fetch_add_explicit(&v568->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      {
        operator new();
      }
      uint64_t v569 = mdm::Allocator::instance(void)::alloc;
      *(_OWORD *)__p = *(_OWORD *)(v567 + 32);
      *(void *)(v567 + 32) = 0;
      *(void *)(v567 + 40) = 0;
      *(void *)&long long v1009 = *(void *)(v567 + 48);
      *((void *)&v1009 + 1) = v569;
      *(void *)(v567 + 48) = 0;
      uint64_t v570 = *(void *)(v567 + 24);
      float v571 = *(std::__shared_weak_count **)(v570 + 16);
      uint64_t v1034 = *(void (***)(void **))(v570 + 8);
      if (!v571) {
        goto LABEL_1437;
      }
      uint64_t v1035 = std::__shared_weak_count::lock(v571);
      if (!v1035) {
        goto LABEL_1437;
      }
      atomic_fetch_add((atomic_uint *volatile)(v567 + 64), 1u);
      uint64_t v572 = *(void *)(*(void *)(*(void *)(v567 + 24) + 152) + 88);
      long long v1022 = v567;
      long long v1023 = 0uLL;
      unint64_t v573 = (void *)*((void *)&v1009 + 1);
      *(void *)&long long v1024 = *((void *)&v1009 + 1);
      float32x2_t v574 = (char *)__p[0];
      long long v575 = (char *)__p[1];
      int64_t v576 = (char *)__p[1] - (char *)__p[0];
      if (__p[1] == __p[0])
      {
        uint64_t v999 = 0;
        unint64_t v582 = 0;
        uint64_t v578 = 0;
      }
      else
      {
        if (v576 < 0) {
          abort();
        }
        uint64_t v577 = (*(uint64_t (**)(void, int64_t, uint64_t))(**((void **)&v1009 + 1) + 16))(*((void *)&v1009 + 1), (char *)__p[1] - (char *)__p[0], 8);
        uint64_t v578 = v577;
        uint64_t v579 = 0;
        *((void *)&v1022 + 1) = v577;
        uint64_t v999 = v577 + 16 * (v576 >> 4);
        *((void *)&v1023 + 1) = v999;
        do
        {
          if (v577 + v579)
          {
            unint64_t v580 = (void *)(v577 + v579);
            void *v580 = *(void *)&v574[v579];
            uint64_t v581 = *(void *)&v574[v579 + 8];
            v580[1] = v581;
            if (v581) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v581 + 8), 1uLL, memory_order_relaxed);
            }
          }
          v579 += 16;
        }
        while (&v574[v579] != v575);
        unint64_t v582 = (void *)(v577 + v579);
        *(void *)&long long v1023 = v577 + v579;
      }
      uint64_t v1004 = v572;
      uint64_t v583 = v1034;
      uint64_t v584 = v1035;
      *((void *)&v1024 + 1) = v1034;
      *(void *)&long long v1025 = v1035;
      if (v1035) {
        atomic_fetch_add_explicit(&v1035->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v586 = buf;
      unint64_t v585 = v1038;
      *((void *)&v1025 + 1) = buf;
      *(void *)&long long v1026 = v1038;
      if (v1038) {
        atomic_fetch_add_explicit(&v1038->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v1042 = 0;
      BOOL v587 = (void **)operator new(0x50uLL);
      *BOOL v587 = &unk_1EF575630;
      v587[1] = (void *)v567;
      v587[2] = (void *)v578;
      v587[3] = v582;
      v587[4] = (void *)v999;
      v587[5] = v573;
      long long v1023 = 0uLL;
      *((void *)&v1022 + 1) = 0;
      v587[6] = v583;
      v587[7] = v584;
      *((void *)&v1024 + 1) = 0;
      *(void *)&long long v1025 = 0;
      v587[8] = v586;
      v587[9] = v585;
      *((void *)&v1025 + 1) = 0;
      *(void *)&long long v1026 = 0;
      uint64_t v1042 = v587;
      geo::TaskQueue::async(&v1031, v1004, &v1040);
      unint64_t v588 = v1032;
      if (v1032 && !atomic_fetch_add(&v1032->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v588->__on_zero_shared)(v588);
        std::__shared_weak_count::__release_weak(v588);
      }
      if (v1042 == (void **)&v1040)
      {
        v1040[4]((void **)&v1040);
      }
      else if (v1042)
      {
        (*((void (**)(void))*v1042 + 5))();
      }
      md::LabelGlyphImageLoader::startQueuedLoads(void)::$_0::~$_0((uint64_t)&v1022);
      unint64_t v589 = v1035;
      if (v1035 && !atomic_fetch_add(&v1035->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v589->__on_zero_shared)(v589);
        std::__shared_weak_count::__release_weak(v589);
      }
      uint64_t v590 = (char *)__p[0];
      if (__p[0])
      {
        unint64_t v591 = (char *)__p[1];
        unint64_t v592 = __p[0];
        if (__p[1] != __p[0])
        {
          do
          {
            uint64_t v593 = (std::__shared_weak_count *)*((void *)v591 - 1);
            if (v593 && !atomic_fetch_add(&v593->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *, void *))v593->__on_zero_shared)(v593, v592);
              std::__shared_weak_count::__release_weak(v593);
            }
            v591 -= 16;
          }
          while (v591 != v590);
          unint64_t v592 = __p[0];
        }
        __p[1] = v590;
        (*(void (**)(void, void *, void))(**((void **)&v1009 + 1) + 40))(*((void *)&v1009 + 1), v592, v1009 - (void)v592);
      }
      BOOL v594 = v1038;
      if (v1038 && !atomic_fetch_add(&v1038->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v594->__on_zero_shared)(v594);
        std::__shared_weak_count::__release_weak(v594);
      }
    }
    md::FontGlyphCache::finishFrame(*(void *)(v566 + 128));
    int v595 = *(_DWORD *)(v566 + 96);
    if (v595 >= 257)
    {
      int v596 = *(_DWORD *)(v566 + 116);
      if (v595 > (v596 + 400))
      {
        int v597 = v596 + 300;
        if (v595 > v596 + 300)
        {
          while (1)
          {
            uint64_t v599 = *(void *)(v566 + 80);
            if (!v599 || (*(_DWORD *)(v566 + 112) - *(_DWORD *)v599) < 0x78) {
              goto LABEL_986;
            }
            if (v595)
            {
              uint64_t v600 = *(void *)(v599 + 24);
              *(void *)(v566 + 80) = v600;
              *(void *)(v599 + 24) = 0;
              if (v600) {
                *(void *)(v600 + 16) = 0;
              }
              if (v599 == *(void *)(v566 + 88)) {
                *(void *)(v566 + 88) = 0;
              }
              *(_DWORD *)(v566 + 96) = v595 - 1;
            }
            unint64_t v601 = *(void *)(v599 + 8);
            unint64_t v602 = (unint64_t)(float)(*(float *)(v601 + 48) * 0.0625);
            uint64_t v603 = *(void *)(v566 + 136);
            if (((*(void *)(v566 + 144) - v603) >> 2) - 1 < v602) {
              unint64_t v602 = ((*(void *)(v566 + 144) - v603) >> 2) - 1;
            }
            --*(_DWORD *)(v603 + 4 * v602);
            uint64_t v604 = *(void *)(v599 + 32);
            if (v604)
            {
              (*(void (**)(uint64_t))(*(void *)v604 + 16))(v604);
              uint64_t v605 = *(std::__shared_weak_count **)(v599 + 40);
              *(void *)(v599 + 32) = 0;
              *(void *)(v599 + 40) = 0;
              if (v605)
              {
                if (!atomic_fetch_add(&v605->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v605->__on_zero_shared)(v605);
                  std::__shared_weak_count::__release_weak(v605);
                }
              }
            }
            *(void *)(v599 + 8) = 0;
            *(void *)(v601 + 96) = 0;
            uint64_t v606 = *(void *)(v566 + 128);
            if (v606)
            {
              long long v607 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>((void *)(v606 + 88), v601);
              if (v607) {
                md::FontGlyphCache::eraseGlyph(v606, (float *)v607[3]);
              }
            }
            uint64_t v608 = *(void **)(v566 + 56);
            unint64_t v609 = *(void *)(v566 + 64);
            if ((unint64_t)v608 >= v609) {
              break;
            }
            if (v608) {
              void *v608 = v599;
            }
            float v598 = v608 + 1;
LABEL_942:
            *(void *)(v566 + 56) = v598;
            int v595 = *(_DWORD *)(v566 + 96);
            if (v595 <= v597) {
              goto LABEL_986;
            }
          }
          uint64_t v610 = *(void *)(v566 + 48);
          uint64_t v611 = ((uint64_t)v608 - v610) >> 3;
          unint64_t v612 = v611 + 1;
          if ((unint64_t)(v611 + 1) >> 61) {
LABEL_1440:
          }
            abort();
          uint64_t v613 = v609 - v610;
          if (v613 >> 2 > v612) {
            unint64_t v612 = v613 >> 2;
          }
          if ((unint64_t)v613 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v614 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v614 = v612;
          }
          if (v614)
          {
            uint64_t v615 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v566 + 72) + 16))(*(void *)(v566 + 72), 8 * v614, 8);
            v616 = (void *)(v615 + 8 * v611);
            uint64_t v617 = v615 + 8 * v614;
            if (v615) {
              void *v616 = v599;
            }
          }
          else
          {
            uint64_t v617 = 0;
            v616 = (void *)(8 * v611);
          }
          uint64_t v619 = *(void *)(v566 + 48);
          uint64_t v618 = *(void *)(v566 + 56);
          uint64_t v620 = v618 - v619;
          if (v618 == v619)
          {
            uint64_t v622 = v616;
            goto LABEL_984;
          }
          unint64_t v621 = v620 - 8;
          if ((unint64_t)(v620 - 8) < 0x38)
          {
            uint64_t v622 = v616;
          }
          else
          {
            uint64_t v622 = v616;
            if ((unint64_t)(v618 - (void)v616) >= 0x20)
            {
              uint64_t v623 = (v621 >> 3) + 1;
              BOOL v624 = v616 - 2;
              uint64_t v625 = (long long *)(v618 - 16);
              uint64_t v626 = v623 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v627 = *v625;
                *(v624 - 1) = *(v625 - 1);
                *BOOL v624 = v627;
                v624 -= 2;
                v625 -= 2;
                v626 -= 4;
              }
              while (v626);
              uint64_t v622 = &v616[-(v623 & 0x3FFFFFFFFFFFFFFCLL)];
              v618 -= 8 * (v623 & 0x3FFFFFFFFFFFFFFCLL);
              if (v623 == (v623 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_983;
              }
            }
          }
          do
          {
            uint64_t v628 = *(void *)(v618 - 8);
            v618 -= 8;
            *--uint64_t v622 = v628;
          }
          while (v618 != v619);
LABEL_983:
          uint64_t v618 = *(void *)(v566 + 48);
LABEL_984:
          float v598 = v616 + 1;
          *(void *)(v566 + 48) = v622;
          *(void *)(v566 + 56) = v616 + 1;
          uint64_t v629 = *(void *)(v566 + 64);
          *(void *)(v566 + 64) = v617;
          if (v618) {
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v566 + 72) + 40))(*(void *)(v566 + 72), v618, v629 - v618);
          }
          goto LABEL_942;
        }
      }
    }
LABEL_986:
    if (*(void *)(a1 + 184)) {
      goto LABEL_1347;
    }
    uint64_t v630 = *(void *)(a1 + 360);
    uint64_t v631 = *(uint64_t **)(*(void *)(*(void *)(v630 + 8) + 112) + 8);
    uint64_t v632 = **(uint64_t ***)(*(void *)(v630 + 8) + 112);
    uint64_t v989 = v630;
    if (*(unsigned char *)(a1 + 3051))
    {
      if (v632 != v631 && *v632 != 0xD369A4D92C8FFE6CLL)
      {
        uint64_t v633 = v632 + 5;
        do
        {
          uint64_t v634 = *v633;
          v633 += 5;
        }
        while (v634 != 0xD369A4D92C8FFE6CLL);
        uint64_t v632 = v633 - 5;
      }
      uint64_t v635 = (uint64_t (***)(void))v632[3];
      unint64_t v636 = (std::__shared_weak_count *)v632[4];
      if (v636)
      {
        atomic_fetch_add_explicit(&v636->__shared_owners_, 1uLL, memory_order_relaxed);
        if (!atomic_fetch_add(&v636->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v636->__on_zero_shared)(v636);
          std::__shared_weak_count::__release_weak(v636);
        }
      }
      uint64_t v637 = *(void **)((**v635)(v635) + 8);
      uint64_t v638 = v637[3];
      uint64_t v639 = v637[4];
      uint64_t v640 = v639 - v638;
      if (v639 == v638) {
        goto LABEL_1003;
      }
      uint64_t v641 = 0;
      unint64_t v642 = v640 >> 3;
      while (1)
      {
        unint64_t v643 = *(unsigned __int8 **)(v638 + 8 * v641);
        if (*v643 == *(unsigned __int8 *)(v630 + 288))
        {
          unint64_t v644 = *((void *)v643 + 1);
          uint64_t v645 = v637[15];
          if (v644 < (v637[16] - v645) >> 3) {
            break;
          }
        }
        if (++v641 >= v642) {
          goto LABEL_1003;
        }
      }
      uint64_t v646 = *(void *)(v645 + 8 * v644);
      if (!v646) {
LABEL_1003:
      }
        uint64_t v647 = 0;
      else {
        uint64_t v647 = *(void *)(*(void *)(v646 + 24) + 8 * *(unsigned __int8 *)(v630 + 289));
      }
      uint64_t v648 = *(void *)(v647 + 304);
      *(void *)(v630 + 296) = v648;
      *(void *)(v630 + 304) = *(void *)(v647 + 352);
      if (!v648 && *(void *)(v630 + 88))
      {
        long long v1030 = *(_OWORD *)(a1 + 1032);
        long long v674 = *(_OWORD *)(a1 + 1000);
        long long v1026 = *(_OWORD *)(a1 + 984);
        long long v1027 = v674;
        long long v675 = *(_OWORD *)(a1 + 936);
        long long v1022 = *(_OWORD *)(a1 + 920);
        long long v1023 = v675;
        long long v676 = *(_OWORD *)(a1 + 968);
        long long v1024 = *(_OWORD *)(a1 + 952);
        long long v1025 = v676;
        uint64_t v1028 = 0;
        uint64_t v1029 = 0;
        *(void *)&long long v1030 = 0;
        gm::operator*<double,4,4,4>((double *)__p, (double *)(a1 + 1048), (double *)&v1022);
        float v677 = *(double *)__p;
        float v678 = *(double *)&__p[1];
        float v679 = *(double *)&v1009;
        float v680 = *((double *)&v1009 + 1);
        float v681 = v1010;
        float v682 = v1011;
        float v683 = v1012;
        float v684 = v1013;
        float v685 = v1014;
        float v686 = v1015;
        float v687 = v1016;
        float v688 = v1017;
        float v689 = v1018;
        float v690 = v1019;
        float v691 = v1020;
        float v692 = v1021;
        double v693 = *(void **)(v630 + 160);
        unint64_t v694 = v693[1];
        double v695 = (float *)v693[9];
        *double v695 = v677;
        v695[1] = v678;
        v695[2] = v679;
        v695[3] = v680;
        v695[4] = v681;
        v695[5] = v682;
        v695[6] = v683;
        v695[7] = v684;
        v695[8] = v685;
        v695[9] = v686;
        v695[10] = v687;
        v695[11] = v688;
        v695[12] = v689;
        v695[13] = v690;
        v695[14] = v691;
        v695[15] = v692;
        if (v693[8] > v694) {
          unint64_t v694 = v693[8];
        }
        v693[7] = 0;
        v693[8] = v694;
        unsigned int v696 = *(void **)(v630 + 192);
        unint64_t v697 = v696[1];
        double v698 = (float *)v696[9];
        *double v698 = v677;
        v698[1] = v678;
        v698[2] = v679;
        v698[3] = v680;
        v698[4] = v681;
        v698[5] = v682;
        v698[6] = v683;
        v698[7] = v684;
        v698[8] = v685;
        v698[9] = v686;
        v698[10] = v687;
        v698[11] = v688;
        v698[12] = v689;
        v698[13] = v690;
        v698[14] = v691;
        v698[15] = v692;
        if (v696[8] > v697) {
          unint64_t v697 = v696[8];
        }
        v696[7] = 0;
        v696[8] = v697;
        if (!*(unsigned char *)(v630 + 156))
        {
          long double v699 = exp(*(double *)v985 * 6.28318531 + -3.14159265);
          long double v700 = atan(v699) * 114.591559 + -90.0;
          long double v701 = cos(v700 * 0.034906585) * -559.82 + 111132.92;
          long double v702 = v701 + cos(v700 * 0.0698131701) * 1.175;
          long double v703 = v702 + cos(v700 * 0.104719755) * -0.0023;
          long double v704 = v700 * 0.00872664626;
          long double v705 = tan(v700 * 0.00872664626 + 0.78103484);
          double v706 = log(v705);
          long double v707 = tan(v704 + 0.789761487);
          *(long double *)(v630 + 136) = fabs((log(v707) - v706) * 0.159154943) / v703;
        }
        if (*(void *)(v630 + 88))
        {
          uint64_t v984 = v630 + 128;
          unint64_t v708 = *(void *)(v630 + 80);
          do
          {
            uint64_t v709 = *(void *)(*(void *)(v630 + 56) + ((v708 >> 5) & 0x7FFFFFFFFFFFFF8));
            double v710 = (unsigned __int8 ***)(v709 + 16 * v708);
            long long v711 = *v710;
            double v713 = **v710;
            uint64_t v712 = (*v710)[1];
            if (v713 == v712) {
              goto LABEL_1211;
            }
            unint64_t v714 = v712 - v713 - 248;
            if (v714 >= 0xF8)
            {
              uint64_t v717 = 0;
              uint64_t v718 = 0;
              unint64_t v719 = v714 / 0xF8 + 1;
              double v720 = v713 + 264;
              uint64_t v721 = v719 & 0x3FFFFFFFFFFFFFELL;
              do
              {
                v717 += (uint64_t)(*(v720 - 31) - *(v720 - 32)) >> 3;
                v718 += (uint64_t)(*v720 - *(v720 - 1)) >> 3;
                v720 += 62;
                v721 -= 2;
              }
              while (v721);
              unint64_t v715 = v718 + v717;
              if (v719 == (v719 & 0x3FFFFFFFFFFFFFELL)) {
                goto LABEL_1046;
              }
              double v716 = &v713[248 * (v719 & 0x3FFFFFFFFFFFFFELL)];
            }
            else
            {
              unint64_t v715 = 0;
              double v716 = **v710;
            }
            do
            {
              v715 += (uint64_t)(*((void *)v716 + 2) - *((void *)v716 + 1)) >> 3;
              v716 += 248;
            }
            while (v716 != v712);
LABEL_1046:
            uint64_t v722 = *(void *)(v630 + 264);
            if (v715 > (v722 - *(void *)(v630 + 256)) >> 2) {
              break;
            }
            v986 = *v710;
            double v723 = **v710;
            do
            {
              uint64_t v724 = *((void *)v723 + 1);
              uint64_t v725 = *((void *)v723 + 2);
              if (v724 != v725)
              {
                do
                {
                  *(unsigned char *)(v724 + 4) = 0;
                  int v726 = *(_DWORD *)(v722 - 4);
                  v722 -= 4;
                  *(_DWORD *)uint64_t v724 = v726;
                  v724 += 8;
                }
                while (v724 != v725);
                *(void *)(v630 + 264) = v722;
              }
              v723 += 248;
            }
            while (v723 != v712);
            uint64_t v978 = v709;
            v979 = (unsigned __int8 ***)(v709 + 16 * v708);
            unint64_t v981 = v708;
            uint64_t v993 = v712;
            do
            {
              v713[238] = 0;
              uint64_t v727 = *v713;
              if ((v727 - 1) <= 4)
              {
                md::OcclusionTest::_generateTestMethods[2 * v727](v713, v986, v984, v990);
                if (!v713[238])
                {
                  long long v729 = (unsigned int *)*((void *)v713 + 1);
                  unint64_t v728 = (unsigned int *)*((void *)v713 + 2);
                  if (v729 != v728)
                  {
                    size_t v997 = (unsigned int *)*((void *)v713 + 2);
                    v1000 = v713;
                    while (*((unsigned char *)v729 + 4))
                    {
LABEL_1059:
                      v729 += 2;
                      if (v729 == v728) {
                        goto LABEL_1053;
                      }
                    }
                    unsigned int v730 = *v729;
                    md::OcclusionQueryResource::initialize(*(void *)(v630 + 224) + 24 * *v729);
                    uint64_t v1006 = (void *)(*(void *)(v630 + 224) + 24 * v730);
                    uint64_t v731 = *v1006;
                    *(unsigned char *)(v731 + 129) = 0;
                    *(_DWORD *)(v731 + 132) = 0;
                    *(unsigned char *)(v731 + 136) = 0;
                    ++*(unsigned char *)(v731 + 128);
                    unint64_t v732 = *(char **)(v647 + 280);
                    v733 = *(char **)(v647 + 272);
                    uint64_t v734 = v732 - v733;
                    if (v732 == v733) {
                      uint64_t v735 = 0;
                    }
                    else {
                      uint64_t v735 = 32 * (v732 - v733) - 1;
                    }
                    unint64_t v737 = *(void *)(v647 + 296);
                    uint64_t v736 = *(void *)(v647 + 304);
                    unint64_t v738 = v736 + v737;
                    if (v735 != v736 + v737)
                    {
                      double v713 = v1000;
                      long long v748 = v1006;
                      goto LABEL_1180;
                    }
                    if (v737 >= 0x100)
                    {
                      *(void *)(v647 + 296) = v737 - 256;
                      long long v739 = v733 + 8;
                      uint64_t v740 = *(void *)v733;
                      *(void *)(v647 + 272) = v733 + 8;
                      if (*(char **)(v647 + 288) != v732) {
                        goto LABEL_1157;
                      }
                      uint64_t v741 = *(char **)(v647 + 264);
                      if (v739 > v741)
                      {
                        uint64_t v742 = (v739 - v741) >> 3;
                        if (v742 >= -1) {
                          uint64_t v743 = v742 + 1;
                        }
                        else {
                          uint64_t v743 = v742 + 2;
                        }
                        uint64_t v744 = v743 >> 1;
                        uint64_t v745 = &v739[-8 * (v743 >> 1)];
                        int64_t v746 = v732 - v739;
                        if (v732 == v739)
                        {
                          long long v747 = v732;
                        }
                        else
                        {
                          memmove(&v739[-8 * (v743 >> 1)], v733 + 8, v732 - v739);
                          long long v747 = *(char **)(v647 + 272);
                        }
                        unint64_t v732 = &v745[v746];
                        *(void *)(v647 + 272) = &v747[-8 * v744];
                        *(void *)(v647 + 280) = &v745[v746];
                        uint64_t v630 = v989;
                        goto LABEL_1157;
                      }
                      if (v732 == v741) {
                        unint64_t v768 = 1;
                      }
                      else {
                        unint64_t v768 = (v732 - v741) >> 2;
                      }
                      if (!(v768 >> 61))
                      {
                        long long v769 = operator new(8 * v768);
                        unint64_t v770 = v768 >> 2;
                        uint64_t v771 = &v769[8 * (v768 >> 2)];
                        int64_t v772 = v732 - v739;
                        _ZF = v732 == v739;
                        unint64_t v732 = v771;
                        if (!_ZF)
                        {
                          unint64_t v732 = &v771[v772 & 0xFFFFFFFFFFFFFFF8];
                          unint64_t v773 = v772 - 8;
                          if (v773 >= 0x38)
                          {
                            uint64_t v815 = 8 * v770;
                            unint64_t v816 = &v769[8 * v770] - v739;
                            uint64_t v774 = &v769[8 * (v768 >> 2)];
                            if (v816 < 0x20) {
                              goto LABEL_1154;
                            }
                            uint64_t v817 = (v773 >> 3) + 1;
                            uint64_t v818 = 8 * (v817 & 0x3FFFFFFFFFFFFFFCLL);
                            uint64_t v774 = &v771[v818];
                            v819 = (long long *)(v733 + 24);
                            v820 = &v769[v815 + 16];
                            uint64_t v821 = v817 & 0x3FFFFFFFFFFFFFFCLL;
                            do
                            {
                              long long v822 = *v819;
                              *(v820 - 1) = *(v819 - 1);
                              _OWORD *v820 = v822;
                              v819 += 2;
                              v820 += 2;
                              v821 -= 4;
                            }
                            while (v821);
                            if (v817 != (v817 & 0x3FFFFFFFFFFFFFFCLL))
                            {
                              v739 += v818;
                              goto LABEL_1154;
                            }
                          }
                          else
                          {
                            uint64_t v774 = &v769[8 * (v768 >> 2)];
                            do
                            {
LABEL_1154:
                              uint64_t v823 = *(void *)v739;
                              v739 += 8;
                              *(void *)uint64_t v774 = v823;
                              v774 += 8;
                            }
                            while (v774 != v732);
                          }
                        }
                        *(void *)(v647 + 264) = v769;
                        *(void *)(v647 + 272) = v771;
                        *(void *)(v647 + 280) = v732;
                        *(void *)(v647 + 288) = &v769[8 * v768];
                        uint64_t v630 = v989;
                        if (v741)
                        {
                          operator delete(v741);
                          unint64_t v732 = *(char **)(v647 + 280);
                        }
LABEL_1157:
                        *(void *)unint64_t v732 = v740;
LABEL_1158:
                        *(void *)(v647 + 280) += 8;
LABEL_1179:
                        v733 = *(char **)(v647 + 272);
                        uint64_t v736 = *(void *)(v647 + 304);
                        unint64_t v738 = v736 + *(void *)(v647 + 296);
                        long long v748 = v1006;
                        uint64_t v731 = *v1006;
                        double v713 = v1000;
LABEL_1180:
                        unint64_t v851 = (void *)(*(void *)&v733[(v738 >> 5) & 0x7FFFFFFFFFFFFF8]
                                        + 16 * v738);
                        *unint64_t v851 = v731;
                        uint64_t v852 = v748[1];
                        v851[1] = v852;
                        if (v852)
                        {
                          atomic_fetch_add_explicit((atomic_ullong *volatile)(v852 + 8), 1uLL, memory_order_relaxed);
                          uint64_t v736 = *(void *)(v647 + 304);
                        }
                        *(void *)(v647 + 304) = v736 + 1;
                        unint64_t v728 = v997;
                        goto LABEL_1059;
                      }
LABEL_1436:
                      std::__throw_bad_array_new_length[abi:nn180100]();
                    }
                    uint64_t v749 = v734 >> 3;
                    long long v750 = *(char **)(v647 + 288);
                    long long v751 = *(char **)(v647 + 264);
                    if (v734 >> 3 < (unint64_t)((v750 - v751) >> 3))
                    {
                      if (v750 != v732)
                      {
                        long long v752 = operator new(0x1000uLL);
                        uint64_t v753 = *(char **)(v647 + 280);
                        if (v753 != *(char **)(v647 + 288))
                        {
LABEL_1178:
                          *(void *)uint64_t v753 = v752;
                          *(void *)(v647 + 280) += 8;
                          uint64_t v630 = v989;
                          goto LABEL_1179;
                        }
                        double v754 = *(char **)(v647 + 264);
                        long long v755 = *(char **)(v647 + 272);
                        if (v755 > v754)
                        {
                          uint64_t v756 = (v755 - v754) >> 3;
                          if (v756 >= -1) {
                            uint64_t v757 = v756 + 1;
                          }
                          else {
                            uint64_t v757 = v756 + 2;
                          }
                          uint64_t v758 = v757 >> 1;
                          int v759 = &v755[-8 * (v757 >> 1)];
                          int64_t v760 = v753 - v755;
                          if (v753 != v755)
                          {
                            memmove(&v755[-8 * (v757 >> 1)], *(const void **)(v647 + 272), v753 - v755);
                            uint64_t v753 = *(char **)(v647 + 272);
                          }
                          int v761 = &v753[-8 * v758];
                          uint64_t v753 = &v759[v760];
                          *(void *)(v647 + 272) = v761;
                          *(void *)(v647 + 280) = &v759[v760];
                          goto LABEL_1178;
                        }
                        if (v753 == v754) {
                          unint64_t v808 = 1;
                        }
                        else {
                          unint64_t v808 = (v753 - v754) >> 2;
                        }
                        if (v808 >> 61) {
                          goto LABEL_1436;
                        }
                        unint64_t v809 = operator new(8 * v808);
                        unint64_t v810 = v808 >> 2;
                        uint64_t v811 = &v809[8 * (v808 >> 2)];
                        int64_t v812 = v753 - v755;
                        _ZF = v753 == v755;
                        uint64_t v753 = v811;
                        if (!_ZF)
                        {
                          uint64_t v753 = &v811[v812 & 0xFFFFFFFFFFFFFFF8];
                          unint64_t v813 = v812 - 8;
                          if (v813 >= 0x38)
                          {
                            uint64_t v842 = 8 * v810;
                            unint64_t v843 = &v809[8 * v810] - v755;
                            uint64_t v814 = &v809[8 * (v808 >> 2)];
                            if (v843 < 0x20) {
                              goto LABEL_1175;
                            }
                            uint64_t v844 = (v813 >> 3) + 1;
                            uint64_t v845 = 8 * (v844 & 0x3FFFFFFFFFFFFFFCLL);
                            uint64_t v814 = &v811[v845];
                            uint64_t v846 = (long long *)(v755 + 16);
                            uint64_t v847 = &v809[v842 + 16];
                            uint64_t v848 = v844 & 0x3FFFFFFFFFFFFFFCLL;
                            do
                            {
                              long long v849 = *v846;
                              *(v847 - 1) = *(v846 - 1);
                              *uint64_t v847 = v849;
                              v846 += 2;
                              v847 += 2;
                              v848 -= 4;
                            }
                            while (v848);
                            if (v844 != (v844 & 0x3FFFFFFFFFFFFFFCLL))
                            {
                              v755 += v845;
                              goto LABEL_1175;
                            }
                          }
                          else
                          {
                            uint64_t v814 = &v809[8 * (v808 >> 2)];
                            do
                            {
LABEL_1175:
                              uint64_t v850 = *(void *)v755;
                              v755 += 8;
                              *(void *)uint64_t v814 = v850;
                              v814 += 8;
                            }
                            while (v814 != v753);
                          }
                        }
                        *(void *)(v647 + 264) = v809;
                        *(void *)(v647 + 272) = v811;
                        *(void *)(v647 + 280) = v753;
                        *(void *)(v647 + 288) = &v809[8 * v808];
                        if (v754)
                        {
                          operator delete(v754);
                          uint64_t v753 = *(char **)(v647 + 280);
                        }
                        goto LABEL_1178;
                      }
                      uint64_t v775 = operator new(0x1000uLL);
                      v776 = *(char **)(v647 + 272);
                      if (v776 != *(char **)(v647 + 264))
                      {
                        v777 = *(char **)(v647 + 272);
                        uint64_t v630 = v989;
                        goto LABEL_1186;
                      }
                      unint64_t v803 = *(unsigned char **)(v647 + 280);
                      unint64_t v802 = *(void *)(v647 + 288);
                      if ((unint64_t)v803 < v802)
                      {
                        uint64_t v804 = (uint64_t)(v802 - (void)v803) >> 3;
                        if (v804 >= -1) {
                          uint64_t v805 = v804 + 1;
                        }
                        else {
                          uint64_t v805 = v804 + 2;
                        }
                        uint64_t v806 = v805 >> 1;
                        v807 = &v803[8 * (v805 >> 1)];
                        v777 = &v807[-(v803 - v776)];
                        if (v803 != v776)
                        {
                          memmove(&v807[-(v803 - v776)], *(const void **)(v647 + 272), v803 - v776);
                          v776 = *(char **)(v647 + 280);
                        }
                        *(void *)(v647 + 272) = v777;
                        *(void *)(v647 + 280) = &v776[8 * v806];
                        uint64_t v630 = v989;
LABEL_1186:
                        *((void *)v777 - 1) = v775;
                        unint64_t v855 = *(char **)(v647 + 272);
                        v854 = *(char **)(v647 + 280);
                        *(void *)(v647 + 272) = v855 - 8;
                        uint64_t v856 = *((void *)v855 - 1);
                        *(void *)(v647 + 272) = v855;
                        if (v854 != *(char **)(v647 + 288))
                        {
LABEL_1187:
                          *(void *)v854 = v856;
                          goto LABEL_1158;
                        }
                        char v857 = *(char **)(v647 + 264);
                        if (v855 > v857)
                        {
                          uint64_t v858 = (v855 - v857) >> 3;
                          if (v858 >= -1) {
                            uint64_t v859 = v858 + 1;
                          }
                          else {
                            uint64_t v859 = v858 + 2;
                          }
                          uint64_t v860 = v859 >> 1;
                          uint64_t v861 = &v855[-8 * (v859 >> 1)];
                          size_t v862 = v854 - v855;
                          if (v862)
                          {
                            memmove(&v855[-8 * (v859 >> 1)], v855, v862);
                            unint64_t v855 = *(char **)(v647 + 272);
                          }
                          v863 = &v861[v862];
                          *(void *)(v647 + 272) = &v855[-8 * v860];
                          *(void *)(v647 + 280) = v863;
                          uint64_t v630 = v989;
                          *(void *)v863 = v856;
                          goto LABEL_1158;
                        }
                        if (v854 == v857) {
                          unint64_t v864 = 1;
                        }
                        else {
                          unint64_t v864 = (v854 - v857) >> 2;
                        }
                        if (v864 >> 61) {
                          goto LABEL_1436;
                        }
                        uint64_t v865 = operator new(8 * v864);
                        unint64_t v866 = v864 >> 2;
                        v867 = &v865[8 * (v864 >> 2)];
                        int64_t v868 = v854 - v855;
                        _ZF = v854 == v855;
                        v854 = v867;
                        if (!_ZF)
                        {
                          v854 = &v867[v868 & 0xFFFFFFFFFFFFFFF8];
                          unint64_t v869 = v868 - 8;
                          if (v869 >= 0x38)
                          {
                            uint64_t v871 = 8 * v866;
                            unint64_t v872 = &v865[8 * v866] - v855;
                            v870 = &v865[8 * (v864 >> 2)];
                            if (v872 < 0x20) {
                              goto LABEL_1207;
                            }
                            uint64_t v873 = (v869 >> 3) + 1;
                            uint64_t v874 = 8 * (v873 & 0x3FFFFFFFFFFFFFFCLL);
                            v870 = &v867[v874];
                            v875 = (long long *)(v855 + 16);
                            v876 = &v865[v871 + 16];
                            uint64_t v877 = v873 & 0x3FFFFFFFFFFFFFFCLL;
                            do
                            {
                              long long v878 = *v875;
                              *(v876 - 1) = *(v875 - 1);
                              _OWORD *v876 = v878;
                              v875 += 2;
                              v876 += 2;
                              v877 -= 4;
                            }
                            while (v877);
                            if (v873 != (v873 & 0x3FFFFFFFFFFFFFFCLL))
                            {
                              v855 += v874;
                              goto LABEL_1207;
                            }
                          }
                          else
                          {
                            v870 = &v865[8 * (v864 >> 2)];
                            do
                            {
LABEL_1207:
                              uint64_t v879 = *(void *)v855;
                              v855 += 8;
                              *(void *)v870 = v879;
                              v870 += 8;
                            }
                            while (v870 != v854);
                          }
                        }
                        *(void *)(v647 + 264) = v865;
                        *(void *)(v647 + 272) = v867;
                        *(void *)(v647 + 280) = v854;
                        *(void *)(v647 + 288) = &v865[8 * v864];
                        uint64_t v630 = v989;
                        if (v857)
                        {
                          operator delete(v857);
                          v854 = *(char **)(v647 + 280);
                        }
                        goto LABEL_1187;
                      }
                      uint64_t v824 = v802 - (void)v776;
                      _ZF = v824 == 0;
                      uint64_t v825 = v824 >> 2;
                      if (_ZF) {
                        unint64_t v826 = 1;
                      }
                      else {
                        unint64_t v826 = v825;
                      }
                      if (v826 >> 61) {
                        goto LABEL_1436;
                      }
                      v827 = (char *)operator new(8 * v826);
                      unint64_t v828 = (v826 + 3) >> 2;
                      v777 = &v827[8 * v828];
                      v829 = &v827[8 * v826];
                      v830 = v777;
                      uint64_t v831 = v803 - v776;
                      uint64_t v630 = v989;
                      if (v803 != v776)
                      {
                        v830 = &v777[v831 & 0xFFFFFFFFFFFFFFF8];
                        unint64_t v832 = v831 - 8;
                        uint64_t v833 = &v827[8 * v828];
                        uint64_t v834 = v776;
                        if (v832 > 0x37)
                        {
                          uint64_t v835 = 8 * v828;
                          uint64_t v833 = &v827[8 * v828];
                          uint64_t v834 = v776;
                          if ((unint64_t)(v833 - v776) >= 0x20)
                          {
                            uint64_t v836 = (v832 >> 3) + 1;
                            uint64_t v837 = 8 * (v836 & 0x3FFFFFFFFFFFFFFCLL);
                            uint64_t v833 = &v777[v837];
                            v838 = (long long *)(v776 + 16);
                            unsigned int v839 = &v827[v835 + 16];
                            uint64_t v840 = v836 & 0x3FFFFFFFFFFFFFFCLL;
                            do
                            {
                              long long v841 = *v838;
                              *((_OWORD *)v839 - 1) = *(v838 - 1);
                              *(_OWORD *)unsigned int v839 = v841;
                              v838 += 2;
                              v839 += 32;
                              v840 -= 4;
                            }
                            while (v840);
                            if (v836 == (v836 & 0x3FFFFFFFFFFFFFFCLL))
                            {
                              *(void *)(v647 + 264) = v827;
                              *(void *)(v647 + 272) = v777;
                              *(void *)(v647 + 280) = v830;
                              *(void *)(v647 + 288) = v829;
LABEL_1185:
                              operator delete(v776);
                              v777 = *(char **)(v647 + 272);
                              goto LABEL_1186;
                            }
                            uint64_t v834 = &v776[v837];
                          }
                        }
                        do
                        {
                          uint64_t v853 = *(void *)v834;
                          v834 += 8;
                          *(void *)uint64_t v833 = v853;
                          v833 += 8;
                        }
                        while (v833 != v830);
                      }
                      *(void *)(v647 + 264) = v827;
                      *(void *)(v647 + 272) = v777;
                      *(void *)(v647 + 280) = v830;
                      *(void *)(v647 + 288) = v829;
                      if (!v776) {
                        goto LABEL_1186;
                      }
                      goto LABEL_1185;
                    }
                    if (v750 == v751) {
                      unint64_t v762 = 1;
                    }
                    else {
                      unint64_t v762 = (v750 - v751) >> 2;
                    }
                    if (v762 >> 61) {
                      goto LABEL_1436;
                    }
                    v763 = (char *)operator new(8 * v762);
                    v764 = operator new(0x1000uLL);
                    int64_t v765 = &v763[8 * v749];
                    v766 = &v763[8 * v762];
                    if (v749 == v762)
                    {
                      if (v734 < 1)
                      {
                        if (v732 == v733) {
                          unint64_t v778 = 1;
                        }
                        else {
                          unint64_t v778 = v734 >> 2;
                        }
                        if (v778 >> 61) {
                          goto LABEL_1436;
                        }
                        long long v779 = v764;
                        int64_t v765 = (char *)operator new(8 * v778);
                        v766 = &v765[8 * v778];
                        operator delete(v763);
                        v733 = *(char **)(v647 + 272);
                        unint64_t v732 = *(char **)(v647 + 280);
                        v763 = v765;
                        v764 = v779;
                      }
                      else
                      {
                        unint64_t v767 = v749 + 2;
                        if (v749 >= -1) {
                          unint64_t v767 = v749 + 1;
                        }
                        v765 -= 8 * (v767 >> 1);
                      }
                    }
                    *(void *)int64_t v765 = v764;
                    int v780 = v765 + 8;
                    if (v732 == v733)
                    {
LABEL_1108:
                      uint64_t v781 = *(void **)(v647 + 264);
                      *(void *)(v647 + 264) = v763;
                      *(void *)(v647 + 272) = v765;
                      *(void *)(v647 + 280) = v780;
                      *(void *)(v647 + 288) = v766;
                      uint64_t v630 = v989;
                      if (v781) {
                        operator delete(v781);
                      }
                      goto LABEL_1179;
                    }
                    while (2)
                    {
                      if (v765 != v763)
                      {
                        v782 = v765;
                        v783 = v780;
                        goto LABEL_1111;
                      }
                      if (v780 < v766)
                      {
                        uint64_t v785 = (v766 - v780) >> 3;
                        if (v785 >= -1) {
                          unint64_t v786 = v785 + 1;
                        }
                        else {
                          unint64_t v786 = v785 + 2;
                        }
                        v783 = &v780[8 * (v786 >> 1)];
                        v782 = &v765[8 * (v786 >> 1)];
                        if (v780 == v765)
                        {
                          v763 = v780;
                        }
                        else
                        {
                          memmove(&v765[8 * (v786 >> 1)], v765, v780 - v765);
                          v763 = v765;
                        }
LABEL_1111:
                        uint64_t v784 = *((void *)v732 - 1);
                        v732 -= 8;
                        *((void *)v782 - 1) = v784;
                        int64_t v765 = v782 - 8;
                        int v780 = v783;
                        if (v732 == *(char **)(v647 + 272)) {
                          goto LABEL_1108;
                        }
                        continue;
                      }
                      break;
                    }
                    if (v766 == v765) {
                      unint64_t v787 = 1;
                    }
                    else {
                      unint64_t v787 = (v766 - v765) >> 2;
                    }
                    if (v787 >> 61) {
                      goto LABEL_1436;
                    }
                    v788 = (char *)operator new(8 * v787);
                    v763 = v788;
                    unint64_t v789 = (v787 + 3) >> 2;
                    v782 = &v788[8 * v789];
                    v783 = v782;
                    int64_t v790 = v780 - v765;
                    if (v780 != v765)
                    {
                      v783 = &v782[v790 & 0xFFFFFFFFFFFFFFF8];
                      unint64_t v791 = v790 - 8;
                      v792 = &v788[8 * v789];
                      v793 = v765;
                      if (v791 < 0x38
                        || (uint64_t v794 = 8 * v789, v792 = &v788[8 * v789], v793 = v765, (unint64_t)(v792 - v765) < 0x20))
                      {
                        do
                        {
LABEL_1130:
                          uint64_t v801 = *(void *)v793;
                          v793 += 8;
                          *(void *)v792 = v801;
                          v792 += 8;
                        }
                        while (v792 != v783);
                      }
                      else
                      {
                        uint64_t v795 = (v791 >> 3) + 1;
                        uint64_t v796 = 8 * (v795 & 0x3FFFFFFFFFFFFFFCLL);
                        v792 = &v782[v796];
                        unint64_t v797 = (long long *)(v765 + 16);
                        v798 = &v788[v794 + 16];
                        uint64_t v799 = v795 & 0x3FFFFFFFFFFFFFFCLL;
                        do
                        {
                          long long v800 = *v797;
                          *((_OWORD *)v798 - 1) = *(v797 - 1);
                          *(_OWORD *)v798 = v800;
                          v797 += 2;
                          v798 += 32;
                          v799 -= 4;
                        }
                        while (v799);
                        if (v795 != (v795 & 0x3FFFFFFFFFFFFFFCLL))
                        {
                          v793 = &v765[v796];
                          goto LABEL_1130;
                        }
                      }
                    }
                    v766 = &v788[8 * v787];
                    operator delete(v765);
                    goto LABEL_1111;
                  }
                }
              }
LABEL_1053:
              v713 += 248;
            }
            while (v713 != v993);
            double v710 = v979;
            unint64_t v708 = v981;
            long long v711 = *v979;
            uint64_t v709 = v978;
LABEL_1211:
            *((unsigned char *)v711 + 282) = 2;
            v880 = *(void **)(v630 + 104);
            unint64_t v881 = *(void *)(v630 + 112);
            if ((unint64_t)v880 < v881)
            {
              if (v880)
              {
                void *v880 = v711;
                uint64_t v882 = *(void *)(v709 + 16 * v708 + 8);
                v880[1] = v882;
                if (v882) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v882 + 8), 1uLL, memory_order_relaxed);
                }
              }
              uint64_t v883 = v880 + 2;
              goto LABEL_1238;
            }
            uint64_t v884 = *(void *)(v630 + 96);
            uint64_t v885 = ((uint64_t)v880 - v884) >> 4;
            unint64_t v886 = v885 + 1;
            if ((unint64_t)(v885 + 1) >> 60) {
              goto LABEL_1440;
            }
            uint64_t v887 = v881 - v884;
            if (v887 >> 3 > v886) {
              unint64_t v886 = v887 >> 3;
            }
            if ((unint64_t)v887 >= 0x7FFFFFFFFFFFFFF0) {
              uint64_t v888 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v888 = v886;
            }
            if (v888)
            {
              uint64_t v889 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v630 + 120) + 16))(*(void *)(v630 + 120), 16 * v888, 8);
              v890 = (_OWORD *)(v889 + 16 * v885);
              uint64_t v891 = v889 + 16 * v888;
              if (v889)
              {
                long long v892 = *(_OWORD *)v710;
                _OWORD *v890 = *(_OWORD *)v710;
                if (*((void *)&v892 + 1)) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v892 + 1) + 8), 1uLL, memory_order_relaxed);
                }
              }
            }
            else
            {
              uint64_t v891 = 0;
              v890 = (_OWORD *)(16 * v885);
            }
            uint64_t v883 = v890 + 1;
            v893 = *(void **)(v989 + 96);
            unint64_t v894 = *(void **)(v989 + 104);
            if (v894 == v893)
            {
              *(void *)(v989 + 96) = v890;
              *(void *)(v989 + 104) = v883;
              uint64_t v897 = *(void *)(v989 + 112);
              *(void *)(v989 + 112) = v891;
            }
            else
            {
              do
              {
                long long v895 = *((_OWORD *)v894 - 1);
                v894 -= 2;
                *--v890 = v895;
                *unint64_t v894 = 0;
                v894[1] = 0;
              }
              while (v894 != v893);
              unint64_t v894 = *(void **)(v989 + 96);
              uint64_t v896 = *(void **)(v989 + 104);
              *(void *)(v989 + 96) = v890;
              *(void *)(v989 + 104) = v883;
              uint64_t v897 = *(void *)(v989 + 112);
              *(void *)(v989 + 112) = v891;
              while (v896 != v894)
              {
                v898 = (std::__shared_weak_count *)*(v896 - 1);
                if (v898 && !atomic_fetch_add(&v898->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v898->__on_zero_shared)(v898);
                  std::__shared_weak_count::__release_weak(v898);
                }
                v896 -= 2;
              }
            }
            if (v894) {
              (*(void (**)(void, void *, uint64_t))(**(void **)(v989 + 120) + 40))(*(void *)(v989 + 120), v894, v897 - (void)v894);
            }
LABEL_1238:
            *(void *)(v989 + 104) = v883;
            uint64_t v630 = v989;
            v899 = *(std::__shared_weak_count **)(*(void *)(*(void *)(v989 + 56)
                                                            + ((*(void *)(v989 + 80) >> 5) & 0x7FFFFFFFFFFFFF8))
                                                + 16 * *(void *)(v989 + 80)
                                                + 8);
            if (v899 && !atomic_fetch_add(&v899->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *, unint64_t, uint64_t))v899->__on_zero_shared)(v899, v708, v709);
              std::__shared_weak_count::__release_weak(v899);
            }
            uint64_t v900 = *(void *)(v989 + 88) - 1;
            unint64_t v708 = *(void *)(v989 + 80) + 1;
            *(void *)(v989 + 80) = v708;
            *(void *)(v989 + 88) = v900;
            if (v708 >= 0x200)
            {
              operator delete(**(void ***)(v989 + 56));
              *(void *)(v989 + 56) += 8;
              uint64_t v900 = *(void *)(v989 + 88);
              unint64_t v708 = *(void *)(v989 + 80) - 256;
              *(void *)(v989 + 80) = v708;
            }
          }
          while (v900);
        }
      }
LABEL_1347:
      uint64_t v1034 = (void (**)(void **))&unk_1EF56DFC8;
      uint64_t v1036 = (void **)&v1034;
      uint64_t v1031 = (std::__shared_weak_count_vtbl *)&unk_1EF56E010;
      uint64_t v1033 = &v1031;
      p_buf = &buf;
      buf = (std::__shared_weak_count_vtbl *)&unk_1EF56E010;
      if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
      }
      uint64_t v966 = (id)GEOGetVectorKitPerformanceLog_log;
      if (os_signpost_enabled(v966))
      {
        LOWORD(v1022) = 0;
        _os_signpost_emit_with_name_impl(&dword_1A1780000, v966, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsRender", "", (uint8_t *)&v1022, 2u);
      }

      if (v1033 == &v1031)
      {
        ((void (*)(std::__shared_weak_count_vtbl **))v1031->__on_zero_shared_weak)(&v1031);
      }
      else if (v1033)
      {
        ((void (*)(void))(*v1033)[1].~__shared_weak_count)();
      }
      if (v1036 == (void **)&v1034)
      {
        v1034[4]((void **)&v1034);
      }
      else if (v1036)
      {
        (*((void (**)(void))*v1036 + 5))();
      }
      uint64_t v967 = *(void *)(a1 + 256);
      __p[0] = &unk_1EF575990;
      *((void *)&v1009 + 1) = __p;
      uint64_t v1040 = (void (**)(void **))&unk_1EF5759D8;
      uint64_t v1042 = (void **)&v1040;
      *((void *)&v1023 + 1) = &v1022;
      *(void *)&long long v1022 = &unk_1EF5759D8;
      if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
      }
      uint64_t v968 = (id)GEOGetVectorKitPerformanceLog_log;
      if (os_signpost_enabled(v968))
      {
        *(_WORD *)v1007 = 0;
        _os_signpost_emit_with_name_impl(&dword_1A1780000, v968, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsTextureAtlasUpdate", "", v1007, 2u);
      }

      if (v1042 == (void **)&v1040)
      {
        v1040[4]((void **)&v1040);
      }
      else if (v1042)
      {
        (*((void (**)(void))*v1042 + 5))();
      }
      if (*((void ***)&v1009 + 1) == __p)
      {
        (*((void (**)(void **))__p[0] + 4))(__p);
      }
      else if (*((void *)&v1009 + 1))
      {
        (*(void (**)(void))(**((void **)&v1009 + 1) + 40))();
      }
      (*(void (**)(void))(**(void **)(v967 + 8) + 16))(*(void *)(v967 + 8));
      (*(void (**)(void))(**(void **)(v967 + 16) + 16))(*(void *)(v967 + 16));
      if (*((void *)&v1023 + 1))
      {
        (*(void (**)(void))(**((void **)&v1023 + 1) + 48))(*((void *)&v1023 + 1));
        if (*((long long **)&v1023 + 1) == &v1022)
        {
          (*(void (**)(long long *))(v1022 + 32))(&v1022);
        }
        else if (*((void *)&v1023 + 1))
        {
          (*(void (**)(void))(**((void **)&v1023 + 1) + 40))();
        }
        *(unsigned char *)(*(void *)(a1 + 328) + 1848) = *(unsigned char *)(a1 + 192) == 2;
        operator new();
      }
      std::__throw_bad_function_call[abi:nn180100]();
      goto LABEL_1449;
    }
    if (v632 != v631 && *v632 != 0xD369A4D92C8FFE6CLL)
    {
      uint64_t v649 = v632 + 5;
      do
      {
        uint64_t v650 = *v649;
        v649 += 5;
      }
      while (v650 != 0xD369A4D92C8FFE6CLL);
      uint64_t v632 = v649 - 5;
    }
    uint64_t v651 = (uint64_t (***)(void))v632[3];
    uint64_t v652 = (std::__shared_weak_count *)v632[4];
    if (v652)
    {
      atomic_fetch_add_explicit(&v652->__shared_owners_, 1uLL, memory_order_relaxed);
      if (!atomic_fetch_add(&v652->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v652->__on_zero_shared)(v652);
        std::__shared_weak_count::__release_weak(v652);
      }
    }
    uint64_t v1005 = (**v651)(v651);
    unint64_t v653 = *(void ***)(v630 + 56);
    v654 = *(void ***)(v630 + 64);
    if (v654 == v653)
    {
      uint64_t v659 = (void *)(v630 + 88);
      v654 = *(void ***)(v630 + 56);
      goto LABEL_1289;
    }
    unint64_t v655 = *(void *)(v630 + 80);
    uint64_t v656 = v630;
    unint64_t v657 = &v653[v655 >> 8];
    uint64_t v658 = (char *)*v657 + 16 * v655;
    uint64_t v659 = (void *)(v656 + 88);
    uint64_t v660 = *(uint64_t *)((char *)v653 + (((*(void *)(v656 + 88) + v655) >> 5) & 0x7FFFFFFFFFFFFF8))
         + 16 * (*(unsigned char *)(v656 + 88) + v655);
    if (v658 == (char *)v660)
    {
      uint64_t v630 = v656;
      if (v654 != v653)
      {
LABEL_1244:
        unint64_t v901 = *(void *)(v630 + 80);
        uint64_t v902 = *(void *)(v630 + 88);
        v903 = &v653[v901 >> 8];
        uint64_t v904 = (uint64_t)*v903 + 16 * v901;
        uint64_t v905 = *(uint64_t *)((char *)v653 + (((v902 + v901) >> 5) & 0x7FFFFFFFFFFFFF8))
             + 16 * (v902 + v901);
        if (v904 == v905)
        {
          uint64_t v630 = v989;
        }
        else
        {
          do
          {
            v906 = *(std::__shared_weak_count **)(v904 + 8);
            if (v906 && !atomic_fetch_add(&v906->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v906->__on_zero_shared)(v906);
              std::__shared_weak_count::__release_weak(v906);
            }
            v904 += 16;
            if (v904 - (void)*v903 == 4096)
            {
              uint64_t v907 = (uint64_t)v903[1];
              ++v903;
              uint64_t v904 = v907;
            }
          }
          while (v904 != v905);
          uint64_t v630 = v989;
          unint64_t v653 = *(void ***)(v989 + 56);
          v654 = *(void ***)(v989 + 64);
        }
LABEL_1289:
        *uint64_t v659 = 0;
        unint64_t v918 = (char *)v654 - (char *)v653;
        if (v918 >= 0x11)
        {
          do
          {
            operator delete(*v653);
            uint64_t v919 = *(void *)(v630 + 64);
            unint64_t v653 = (void **)(*(void *)(v630 + 56) + 8);
            *(void *)(v630 + 56) = v653;
            unint64_t v918 = v919 - (void)v653;
          }
          while (v918 > 0x10);
        }
        if (v918 >> 3 == 1)
        {
          uint64_t v920 = 128;
        }
        else
        {
          if (v918 >> 3 != 2)
          {
LABEL_1296:
            uint64_t v921 = v630;
            v922 = *(uint64_t ***)(v630 + 96);
            v923 = *(uint64_t ***)(v630 + 104);
            if (v922 != v923)
            {
              uint64_t v924 = v921 + 128;
              do
              {
                uint64_t v925 = *v922;
                uint64_t v926 = **v922;
                uint64_t v927 = (*v922)[1];
                if (v926 != v927)
                {
                  do
                  {
                    md::OcclusionTest::checkinResources(*(md::OcclusionTest **)(v926 + 8), *(md::OcclusionContext **)(v926 + 16), v924);
                    v926 += 248;
                  }
                  while (v926 != v927);
                  uint64_t v929 = *v925;
                  uint64_t v928 = v925[1];
                  if (*v925 != v928)
                  {
                    unint64_t v930 = v928 - v929 - 248;
                    uint64_t v931 = *v925;
                    if (v930 < 0xF8) {
                      goto LABEL_1453;
                    }
                    unint64_t v932 = v930 / 0xF8 + 1;
                    uint64_t v931 = v929 + 248 * (v932 & 0x3FFFFFFFFFFFFFELL);
                    v933 = (void *)(v929 + 264);
                    uint64_t v934 = v932 & 0x3FFFFFFFFFFFFFELL;
                    do
                    {
                      uint64_t v935 = *(v933 - 1);
                      *(v933 - 31) = *(v933 - 32);
                      void *v933 = v935;
                      v933 += 62;
                      v934 -= 2;
                    }
                    while (v934);
                    if (v932 != (v932 & 0x3FFFFFFFFFFFFFELL))
                    {
LABEL_1453:
                      do
                      {
                        *(void *)(v931 + 16) = *(void *)(v931 + 8);
                        v931 += 248;
                      }
                      while (v931 != v928);
                    }
                  }
                }
                *((unsigned char *)v925 + 281) = *((unsigned char *)v925 + 280);
                *((unsigned char *)v925 + 280) = 0;
                *((unsigned char *)v925 + 282) = 0;
                atomic_store(1u, (unsigned __int8 *)v925 + 286);
                v922 += 2;
              }
              while (v922 != v923);
              unint64_t v936 = *(uint64_t ***)(v989 + 96);
              v922 = *(uint64_t ***)(v989 + 104);
              if (v922 != v936)
              {
                do
                {
                  unint64_t v937 = (std::__shared_weak_count *)*(v922 - 1);
                  if (v937 && !atomic_fetch_add(&v937->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v937->__on_zero_shared)(v937);
                    std::__shared_weak_count::__release_weak(v937);
                  }
                  v922 -= 2;
                }
                while (v922 != v936);
                v922 = v936;
              }
            }
            *(void *)(v989 + 104) = v922;
            uint64_t v938 = *(void **)(v1005 + 8);
            uint64_t v939 = v938[3];
            uint64_t v940 = v938[4];
            uint64_t v941 = v940 - v939;
            if (v940 == v939) {
              goto LABEL_1322;
            }
            uint64_t v942 = 0;
            unint64_t v943 = v941 >> 3;
            while (1)
            {
              uint64_t v944 = *(unsigned __int8 **)(v939 + 8 * v942);
              if (*v944 == *(unsigned __int8 *)(v989 + 288))
              {
                unint64_t v945 = *((void *)v944 + 1);
                uint64_t v946 = v938[15];
                if (v945 < (v938[16] - v946) >> 3) {
                  break;
                }
              }
              if (++v942 >= v943) {
                goto LABEL_1322;
              }
            }
            uint64_t v947 = *(void *)(v946 + 8 * v945);
            if (!v947) {
LABEL_1322:
            }
              v948 = 0;
            else {
              v948 = *(void **)(*(void *)(v947 + 24) + 8 * *(unsigned __int8 *)(v989 + 289));
            }
            unint64_t v949 = (void **)v948[34];
            v950 = (void **)v948[35];
            if (v950 == v949)
            {
              unint64_t v955 = v948 + 38;
              v950 = (void **)v948[34];
            }
            else
            {
              unint64_t v951 = v948[37];
              uint64_t v952 = &v949[v951 >> 8];
              unint64_t v953 = (char *)*v952;
              uint64_t v954 = (uint64_t)*v952 + 16 * v951;
              unint64_t v955 = v948 + 38;
              uint64_t v956 = *(uint64_t *)((char *)v949 + (((v948[38] + v951) >> 5) & 0x7FFFFFFFFFFFFF8))
                   + 16 * (*((unsigned char *)v948 + 304) + v951);
              if (v954 != v956)
              {
                unint64_t v957 = (char *)*v952 + 16 * v951;
                uint8x8_t v958 = &v949[v951 >> 8];
                do
                {
                  uint64_t v959 = *(void *)v957;
                  v957 += 16;
                  --*(unsigned char *)(v959 + 128);
                  if (v957 - v953 == 4096)
                  {
                    v960 = (char *)v958[1];
                    ++v958;
                    unint64_t v953 = v960;
                    unint64_t v957 = v960;
                  }
                }
                while (v957 != (char *)v956);
                if (v954 != v956)
                {
                  do
                  {
                    unint64_t v961 = *(std::__shared_weak_count **)(v954 + 8);
                    if (v961 && !atomic_fetch_add(&v961->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v961->__on_zero_shared)(v961);
                      std::__shared_weak_count::__release_weak(v961);
                    }
                    v954 += 16;
                    if (v954 - (void)*v952 == 4096)
                    {
                      uint64_t v962 = (uint64_t)v952[1];
                      ++v952;
                      uint64_t v954 = v962;
                    }
                  }
                  while (v954 != v956);
                  unint64_t v949 = (void **)v948[34];
                  v950 = (void **)v948[35];
                }
              }
            }
            *unint64_t v955 = 0;
            unint64_t v963 = (char *)v950 - (char *)v949;
            if (v963 >= 0x11)
            {
              do
              {
                operator delete(*v949);
                uint64_t v964 = v948[35];
                unint64_t v949 = (void **)(v948[34] + 8);
                v948[34] = v949;
                unint64_t v963 = v964 - (void)v949;
              }
              while (v963 > 0x10);
            }
            if (v963 >> 3 == 1)
            {
              uint64_t v965 = 128;
            }
            else
            {
              if (v963 >> 3 != 2)
              {
LABEL_1346:
                *(void *)(v989 + 296) = 0;
                *(void *)(v989 + 304) = 0;
                goto LABEL_1347;
              }
              uint64_t v965 = 256;
            }
            v948[37] = v965;
            goto LABEL_1346;
          }
          uint64_t v920 = 256;
        }
        *(void *)(v630 + 80) = v920;
        goto LABEL_1296;
      }
    }
    else
    {
      uint64_t v661 = v656 + 128;
      do
      {
        uint64_t v662 = *(uint64_t **)v658;
        uint64_t v663 = **(void **)v658;
        uint64_t v664 = *(void *)(*(void *)v658 + 8);
        if (v663 != v664)
        {
          do
          {
            md::OcclusionTest::checkinResources(*(md::OcclusionTest **)(v663 + 8), *(md::OcclusionContext **)(v663 + 16), v661);
            v663 += 248;
          }
          while (v663 != v664);
          uint64_t v666 = *v662;
          uint64_t v665 = v662[1];
          if (*v662 != v665)
          {
            unint64_t v667 = v665 - v666 - 248;
            uint64_t v668 = *v662;
            if (v667 < 0xF8) {
              goto LABEL_1454;
            }
            unint64_t v669 = v667 / 0xF8 + 1;
            uint64_t v668 = v666 + 248 * (v669 & 0x3FFFFFFFFFFFFFELL);
            unsigned int v670 = (void *)(v666 + 264);
            uint64_t v671 = v669 & 0x3FFFFFFFFFFFFFELL;
            do
            {
              uint64_t v672 = *(v670 - 1);
              *(v670 - 31) = *(v670 - 32);
              *unsigned int v670 = v672;
              v670 += 62;
              v671 -= 2;
            }
            while (v671);
            if (v669 != (v669 & 0x3FFFFFFFFFFFFFELL))
            {
LABEL_1454:
              do
              {
                *(void *)(v668 + 16) = *(void *)(v668 + 8);
                v668 += 248;
              }
              while (v668 != v665);
            }
          }
        }
        *((unsigned char *)v662 + 281) = *((unsigned char *)v662 + 280);
        *((unsigned char *)v662 + 280) = 0;
        *((unsigned char *)v662 + 282) = 0;
        atomic_store(1u, (unsigned __int8 *)v662 + 286);
        v658 += 16;
        if (v658 - (unsigned char *)*v657 == 4096)
        {
          uint64_t v673 = (char *)v657[1];
          ++v657;
          uint64_t v658 = v673;
        }
      }
      while (v658 != (char *)v660);
      uint64_t v630 = v989;
      unint64_t v653 = *(void ***)(v989 + 56);
      v654 = *(void ***)(v989 + 64);
      if (v654 != v653) {
        goto LABEL_1244;
      }
    }
    unint64_t v653 = v654;
    goto LABEL_1289;
  }
  *(unsigned char *)(a1 + 3383) = *(unsigned char *)(a1 + 3382) ^ 1;
  *(void *)(a1 + 432) = v990;
  md::LabelManager::updateDebugSettings((md::LabelManager *)a1);
  uint64_t v394 = *(void *)(*(void *)(a1 + 336) + 184);
  if (!v394) {
    goto LABEL_665;
  }
  uint64_t v395 = *(void *)(v394 + 520);
  BOOL v396 = *(std::__shared_weak_count **)(v394 + 528);
  if (v396)
  {
    atomic_fetch_add_explicit(&v396->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add(&v396->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v396->__on_zero_shared)(v396);
      std::__shared_weak_count::__release_weak(v396);
      if (v395) {
        goto LABEL_650;
      }
LABEL_722:
      operator new();
    }
  }
  if (!v395) {
    goto LABEL_722;
  }
LABEL_650:
  uint64_t v397 = *(void *)(a1 + 3488);
  if (v397)
  {
    uint64_t v398 = *(void *)(v397 + 520);
    unint64_t v399 = *(std::__shared_weak_count **)(v397 + 528);
    if (v399)
    {
      atomic_fetch_add_explicit(&v399->__shared_owners_, 1uLL, memory_order_relaxed);
      if (!atomic_fetch_add(&v399->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v399->__on_zero_shared)(v399);
        std::__shared_weak_count::__release_weak(v399);
      }
    }
    if (v398)
    {
      uint64_t v400 = *(void *)(*(void *)(a1 + 336) + 184);
      uint64_t v401 = *(void *)(v400 + 520);
      uint64_t v402 = *(void *)(v400 + 528);
      *(void *)&long long v1022 = v401;
      *((void *)&v1022 + 1) = v402;
      if (v402) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v402 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v403 = *(void *)(a1 + 3488);
      unint64_t v404 = *(void **)(v403 + 520);
      uint64_t v405 = *(std::__shared_weak_count **)(v403 + 528);
      __p[0] = v404;
      __p[1] = v405;
      if (v405) {
        atomic_fetch_add_explicit(&v405->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      gss::ClientStyleState<gss::PropertyID>::setStateWithClientStyleState(v401, (uint64_t)v404);
      if (v405 && !atomic_fetch_add(&v405->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v405->__on_zero_shared)(v405);
        std::__shared_weak_count::__release_weak(v405);
      }
      uint64_t v406 = (std::__shared_weak_count *)*((void *)&v1022 + 1);
      if (*((void *)&v1022 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v1022 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v406->__on_zero_shared)(v406);
        std::__shared_weak_count::__release_weak(v406);
      }
    }
  }
LABEL_665:
  if (*(unsigned char *)(a1 + 3384))
  {
    *(unsigned char *)(a1 + 3384) = 0;
    md::FontTrackingCache::updateForDisplay(*(md::FontTrackingCache **)(a1 + 312));
    (*(void (**)(void))(**(void **)(a1 + 240) + 48))(*(void *)(a1 + 240));
  }
  md::LabelManager::flushCommands((md::LabelManager *)a1);
  unint64_t v407 = (void *)*((void *)v390 + 1);
  unint64_t v408 = v407[1];
  if ((v408 & (v408 - 1)) != 0)
  {
    unint64_t v414 = 0xE42D19AFCA302E68;
    if (v408 <= 0xE42D19AFCA302E68) {
      unint64_t v414 = 0xE42D19AFCA302E68 % v408;
    }
    unint64_t v409 = *(void **)(*v407 + 8 * v414);
    do
    {
      do
        unint64_t v409 = (void *)*v409;
      while (v409[1] != 0xE42D19AFCA302E68);
    }
    while (v409[2] != 0xE42D19AFCA302E68);
  }
  else
  {
    unint64_t v409 = *(void **)(*v407 + 8 * ((v408 - 1) & 0xE42D19AFCA302E68));
    do
    {
      do
        unint64_t v409 = (void *)*v409;
      while (v409[1] != 0xE42D19AFCA302E68);
    }
    while (v409[2] != 0xE42D19AFCA302E68);
  }
  uint64_t v415 = *(void *)(v409[5] + 32);
  *(unsigned char *)(a1 + 3050) = *(unsigned char *)(v415 + 94) == 1;
  uint64_t v416 = *(void *)(a1 + 336);
  int v417 = *(unsigned __int8 *)(v415 + 83);
  if (*(unsigned char *)(v416 + 181)) {
    BOOL v418 = *(unsigned __int8 *)(v416 + 180) == v417;
  }
  else {
    BOOL v418 = 0;
  }
  if (!v418)
  {
    *(unsigned char *)(v416 + 181) = 1;
    *(unsigned char *)(v416 + 180) = v417;
    std::mutex::lock((std::mutex *)v416);
    *(void *)&long long v1022 = &unk_1EF570F98;
    *((void *)&v1023 + 1) = &v1022;
    md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::forEach(*(uint64_t **)(v416 + 264), (uint64_t)&v1022);
    if (*((long long **)&v1023 + 1) == &v1022)
    {
      (*(void (**)(long long *))(v1022 + 32))(&v1022);
    }
    else if (*((void *)&v1023 + 1))
    {
      (*(void (**)(void))(**((void **)&v1023 + 1) + 40))();
    }
    __p[0] = &unk_1EF570F98;
    *((void *)&v1009 + 1) = __p;
    md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::forEach(*(uint64_t **)(v416 + 376), (uint64_t)__p);
    if (*((void ***)&v1009 + 1) == __p)
    {
      (*((void (**)(void **))__p[0] + 4))(__p);
    }
    else if (*((void *)&v1009 + 1))
    {
      (*(void (**)(void))(**((void **)&v1009 + 1) + 40))();
    }
    uint64_t v420 = *(void *)(v416 + 432);
    *(unsigned char *)(v420 + 136) = -1;
    *(unsigned char *)(v420 + 125) = 0;
    unint64_t v421 = *(std::__shared_weak_count **)(v420 + 416);
    *(void *)(v420 + 408) = 0;
    *(void *)(v420 + 416) = 0;
    if (v421 && !atomic_fetch_add(&v421->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v421->__on_zero_shared)(v421);
      std::__shared_weak_count::__release_weak(v421);
    }
    uint64_t v422 = *(std::__shared_weak_count **)(v420 + 432);
    *(void *)(v420 + 424) = 0;
    *(void *)(v420 + 432) = 0;
    if (v422 && !atomic_fetch_add(&v422->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v422->__on_zero_shared)(v422);
      std::__shared_weak_count::__release_weak(v422);
    }
    std::mutex::unlock((std::mutex *)v416);
  }
  uint64_t v423 = *(void *)(v416 + 200);
  if (*(unsigned char *)(v423 + 89))
  {
    *(unsigned char *)(v423 + 89) = 0;
    uint64_t v424 = *(void *)(v423 + 56);
    *(void *)(v423 + 56) = 0;
    uint64_t v425 = *(void *)(v423 + 80);
    *(void *)(v423 + 80) = v424;
    if (v425) {
      MEMORY[0x1A6239270](v425, 0x1000C40F5825EE8);
    }
  }
  uint64_t v426 = a1;
  uint64_t v427 = a3;
  if (!*(void *)(a1 + 184))
  {
    uint64_t v428 = *(void *)(a1 + 232);
    if (*(unsigned char *)(v428 + 22))
    {
      int v429 = *(unsigned __int8 *)(a1 + 3612);
      *(unsigned char *)(a1 + 3051) = v429;
      if (v429 && !*(unsigned char *)(v428 + 21)) {
        *(unsigned char *)(a1 + 3051) = (*(uint64_t (**)(void, md::LayoutContext *, uint64_t))(**(void **)(a1 + 240)
      }
                                                                                                + 112))(*(void *)(a1 + 240), v390, a3);
    }
    else
    {
      *(unsigned char *)(a1 + 3051) = 0;
    }
    md::OcclusionManager::flushQueuedQueries(*(int64x2_t **)(a1 + 360));
    *(unsigned char *)(a1 + 3152) = *(unsigned char *)(a1 + 3571);
    int v430 = *(unsigned __int8 *)(a1 + 3572);
    uint64_t v427 = a3;
    if (*(unsigned __int8 *)(a1 + 3153) != v430)
    {
      *(unsigned char *)(a1 + 3153) = v430;
      if (v430) {
        *(unsigned char *)(a1 + 3042) = 1;
      }
    }
  }
  if (*(unsigned char *)(a1 + 3049))
  {
    unint64_t v431 = *(uint64_t **)(a1 + 168);
    uint64_t v432 = *v431;
    uint64_t v433 = v431[1];
    if (*v431 != v433)
    {
      do
      {
        (*(void (**)(void))(**(void **)v432 + 48))();
        v432 += 8;
      }
      while (v432 != v433);
    }
    uint64_t v434 = *(void *)(a1 + 320);
    float v435 = *(float *)(a1 + 176);
    {
      operator new();
    }
    uint64_t v436 = mdm::Allocator::instance(void)::alloc;
    uint64_t v438 = *(void *)(v434 + 56);
    uint64_t v437 = *(void *)(v434 + 64);
    *(void *)(v434 + 56) = 0;
    *(void *)(v434 + 64) = 0;
    uint64_t v439 = *(void *)(v434 + 72);
    *(void *)(v434 + 72) = 0;
    if (v438)
    {
      if (v437 != v438)
      {
        uint64_t v440 = v437;
        do
        {
          free(*(void **)(v437 - 8));
          *(void *)(v440 - 24) = 0;
          *(void *)(v440 - 16) = 0;
          v440 -= 24;
          *(void *)(v437 - 8) = 0;
          uint64_t v437 = v440;
        }
        while (v440 != v438);
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v436 + 40))(v436, v438, v439 - v438);
    }
    *(unsigned char *)(v434 + 92) = 0;
    *(_DWORD *)(v434 + 12) = *(_DWORD *)(a1 + 1544);
    *(_DWORD *)(v434 + 16) = *(_DWORD *)(a1 + 1548);
    *(_DWORD *)(v434 + 20) = *(_DWORD *)(a1 + 1552);
    *(_DWORD *)(v434 + 24) = *(_DWORD *)(a1 + 1556);
    *(float *)(v434 + 28) = v435 * 100.0;
    *(float *)(v434 + 32) = 0.01 / v435;
    *(_DWORD *)(v434 + 36) = *(_DWORD *)(a1 + 1544);
    *(_DWORD *)(v434 + 40) = *(_DWORD *)(a1 + 1548);
    __asm { FMOV            V2.2S, #1.0 }
    int32x2_t v445 = vcvt_s32_f32(vmla_n_f32(_D2, vsub_f32(vadd_f32(*(float32x2_t *)(a1 + 1552), (float32x2_t)vdup_n_s32(0xBDCCCCCD)), *(float32x2_t *)(a1 + 1544)), 0.01 / v435));
    *(int32x2_t *)(v434 + 44) = v445;
    unsigned int v446 = vmul_lane_s32(v445, v445, 1).u32[0];
    uint64_t v447 = v446;
    if ((int)v446 < 1)
    {
      *(_DWORD *)(v434 + 44) = 0;
      *(_DWORD *)(v434 + 48) = 0;
    }
    else
    {
      uint64_t v448 = *(void *)(v434 + 56);
      unint64_t v449 = *(void **)(v434 + 64);
      uint64_t v450 = (char *)v449 - v448;
      unint64_t v451 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v449 - v448) >> 3);
      unint64_t v452 = v446 - v451;
      if (v446 <= v451)
      {
        if (v446 < v451)
        {
          uint64_t v462 = (void *)(v448 + 24 * v446);
          if (v449 != v462)
          {
            BOOL v463 = *(void **)(v434 + 64);
            do
            {
              free((void *)*(v449 - 1));
              *(v463 - 3) = 0;
              *(v463 - 2) = 0;
              v463 -= 3;
              *(v449 - 1) = 0;
              unint64_t v449 = v463;
            }
            while (v463 != v462);
          }
          *(void *)(v434 + 64) = v462;
        }
      }
      else
      {
        uint64_t v453 = *(void *)(v434 + 72);
        if (0xAAAAAAAAAAAAAAABLL * ((v453 - (uint64_t)v449) >> 3) >= v452)
        {
          float v464 = &v449[3 * v452];
          uint64_t v465 = 24 * v446 - (void)v450;
          do
          {
            if (v449)
            {
              *unint64_t v449 = 0;
              v449[1] = 0;
              v449[2] = 0;
            }
            v449 += 3;
            v465 -= 24;
          }
          while (v465);
          *(void *)(v434 + 64) = v464;
        }
        else
        {
          unint64_t v454 = 0xAAAAAAAAAAAAAAABLL * ((v453 - v448) >> 3);
          uint64_t v455 = 2 * v454;
          if (2 * v454 <= v446) {
            uint64_t v455 = v446;
          }
          if (v454 >= 0x555555555555555) {
            uint64_t v456 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            uint64_t v456 = v455;
          }
          uint64_t v457 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v434 + 80) + 16))(*(void *)(v434 + 80), 24 * v456, 8);
          uint64_t v458 = (void *)(v457 + 24 * v451);
          uint64_t v459 = v457 + 24 * v447;
          uint64_t v460 = 24 * v447 - (void)v450;
          unint64_t v461 = v458;
          do
          {
            if (v461)
            {
              *unint64_t v461 = 0;
              v461[1] = 0;
              v461[2] = 0;
            }
            v461 += 3;
            v460 -= 24;
          }
          while (v460);
          uint64_t v466 = v457 + 24 * v456;
          uint64_t v467 = *(void *)(v434 + 56);
          uint64_t v468 = *(void *)(v434 + 64);
          if (v468 == v467)
          {
            *(void *)(v434 + 56) = v458;
            *(void *)(v434 + 64) = v459;
            uint64_t v471 = *(void *)(v434 + 72);
            *(void *)(v434 + 72) = v466;
          }
          else
          {
            do
            {
              long long v469 = *(_OWORD *)(v468 - 24);
              *(v458 - 1) = *(void *)(v468 - 8);
              *(_OWORD *)(v458 - 3) = v469;
              v458 -= 3;
              v468 -= 24;
            }
            while (v468 != v467);
            uint64_t v468 = *(void *)(v434 + 56);
            uint64_t v470 = *(void *)(v434 + 64);
            *(void *)(v434 + 56) = v458;
            *(void *)(v434 + 64) = v459;
            uint64_t v471 = *(void *)(v434 + 72);
            *(void *)(v434 + 72) = v466;
            if (v470 != v468)
            {
              uint64_t v472 = v470;
              do
              {
                free(*(void **)(v470 - 8));
                *(void *)(v472 - 24) = 0;
                *(void *)(v472 - 16) = 0;
                v472 -= 24;
                *(void *)(v470 - 8) = 0;
                uint64_t v470 = v472;
              }
              while (v472 != v468);
            }
          }
          if (v468) {
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v434 + 80) + 40))(*(void *)(v434 + 80), v468, v471 - v468);
          }
        }
      }
    }
    uint64_t v426 = a1;
    *(unsigned char *)(a1 + 3049) = 0;
    uint64_t v427 = a3;
  }
  if (*(void *)(v426 + 416) == *(void *)(v427 + 40))
  {
    unint64_t v473 = (void *)(a1 + 400);
    int8x8_t v474 = *(int8x8_t *)(v427 + 8);
    uint8x8_t v475 = (uint8x8_t)vcnt_s8(v474);
    v475.i16[0] = vaddlv_u8(v475);
    uint64_t v476 = *(void *)&v474 - 1;
LABEL_771:
    unint64_t v473 = (void *)*v473;
    if (v473)
    {
      if (v474)
      {
        unint64_t v477 = v473[2];
        unint64_t v478 = 0x9DDFEA08EB382D69 * (((8 * v477) + 8) ^ HIDWORD(v477));
        unint64_t v479 = 0x9DDFEA08EB382D69 * (HIDWORD(v477) ^ (v478 >> 47) ^ v478);
        unint64_t v480 = 0x9DDFEA08EB382D69 * (v479 ^ (v479 >> 47));
        if (v475.u32[0] > 1uLL)
        {
          unint64_t v481 = v480;
          if (v480 >= *(void *)&v474) {
            unint64_t v481 = v480 % *(void *)&v474;
          }
        }
        else
        {
          unint64_t v481 = v480 & v476;
        }
        uint64_t v482 = *(void **)(*(void *)v427 + 8 * v481);
        if (v482)
        {
          uint64_t v483 = (void *)*v482;
          if (v483)
          {
            if (v475.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v484 = v483[1];
                if (v480 == v484)
                {
                  if (v483[2] == v477) {
                    goto LABEL_771;
                  }
                }
                else if ((v484 & v476) != v481)
                {
                  goto LABEL_792;
                }
                uint64_t v483 = (void *)*v483;
                if (!v483) {
                  goto LABEL_792;
                }
              }
            }
            while (1)
            {
              unint64_t v485 = v483[1];
              if (v480 == v485)
              {
                if (v483[2] == v477) {
                  goto LABEL_771;
                }
              }
              else
              {
                if (v485 >= *(void *)&v474) {
                  v485 %= *(void *)&v474;
                }
                if (v485 != v481) {
                  goto LABEL_792;
                }
              }
              uint64_t v483 = (void *)*v483;
              if (!v483) {
                goto LABEL_792;
              }
            }
          }
        }
      }
      goto LABEL_792;
    }
    uint64_t v486 = 0;
  }
  else
  {
LABEL_792:
    if (a1 + 376 == v427)
    {
      uint64_t v486 = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 424) = *(_DWORD *)(v427 + 48);
      std::__hash_table<std::shared_ptr<md::LabelMapTile>,std::hash<std::shared_ptr<md::LabelMapTile>>,std::equal_to<std::shared_ptr<md::LabelMapTile>>,geo::StdAllocator<std::shared_ptr<md::LabelMapTile>,mdm::Allocator>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::shared_ptr<md::LabelMapTile>,void *> *>>((void *)(a1 + 376), *(void **)(v427 + 24));
      uint64_t v486 = 1;
      uint64_t v427 = a3;
    }
  }
  uint64_t v487 = a1;
  (*(void (**)(void, md::LayoutContext *, uint64_t, uint64_t))(**(void **)(a1 + 240) + 32))(*(void *)(a1 + 240), v390, v427, v486);
  if (*(unsigned char *)(a1 + 3376))
  {
    md::LabelManager::startStylesheetLabelAnimations((md::LabelManager *)a1);
    goto LABEL_797;
  }
  if (*(unsigned char *)(a1 + 3373) && !*(unsigned char *)(a1 + 3375))
  {
    *(unsigned char *)(a1 + 3373) = 0;
    if (*(unsigned char *)(a1 + 3374))
    {
      *(unsigned char *)(a1 + 3374) = 0;
      md::LabelStyleCache::stylesheetDidChange(*(std::mutex **)(a1 + 336));
    }
    uint64_t v908 = *(void *)(a1 + 272);
    uint64_t v909 = *(void *)(v908 + 24);
    for (uint64_t i = *(void *)(v908 + 32); i != v909; i -= 16)
    {
      unint64_t v911 = *(std::__shared_weak_count **)(i - 8);
      if (v911 && !atomic_fetch_add(&v911->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v911->__on_zero_shared)(v911);
        std::__shared_weak_count::__release_weak(v911);
      }
    }
    *(void *)(v908 + 32) = v909;
    *(unsigned char *)(v908 + 60) = 1;
    uint64_t v912 = *(void *)(a1 + 296);
    int v913 = *(_DWORD *)(v912 + 12);
    _CF = __CFADD__(v913, 1);
    unsigned int v914 = v913 + 1;
    *(_DWORD *)(v912 + 12) = v914;
    if (_CF)
    {
      *(void *)(v912 + 12) = 0x100000002;
      unsigned int v914 = 2;
    }
    atomic_store(v914, (unsigned int *)(v912 + 8));
    (*(void (**)(void))(**(void **)(a1 + 240) + 144))(*(void *)(a1 + 240));
    md::LabelTextDataLoader::finishBatch(*(md::LabelTextDataLoader **)(a1 + 272));
    (*(void (**)(void))(**(void **)(*(void *)(a1 + 168) + 72) + 8))(*(void *)(*(void *)(a1 + 168) + 72));
    if (*(void *)(a1 + 184)) {
      int v488 = 0;
    }
    else {
LABEL_797:
    }
      int v488 = 1;
    uint64_t v487 = a1;
    *(_WORD *)(a1 + 3046) = 257;
    if (*(unsigned char *)(a1 + 3646)) {
      goto LABEL_806;
    }
LABEL_803:
    if (*(unsigned char *)(v487 + 3380) || *(unsigned char *)(v487 + 3054) || *(void *)(v487 + 184)) {
      goto LABEL_806;
    }
    int v489 = (*(uint64_t (**)(void))(**(void **)(v487 + 240) + 80))(*(void *)(v487 + 240));
  }
  else
  {
    int v488 = 0;
    if (!*(unsigned char *)(a1 + 3646)) {
      goto LABEL_803;
    }
LABEL_806:
    int v489 = 1;
  }
  *(unsigned char *)(a1 + 3057) = *(unsigned char *)(a1 + 3380);
  *(unsigned char *)(a1 + 3380) = 0;
  LODWORD(v1034) = 65793;
  WORD2(v1034) = 0;
  LODWORD(v1035) = *(_DWORD *)(a1 + 3272);
  uint64_t v490 = mach_absolute_time();
  if (*(unsigned char *)(a1 + 3042)) {
    int v491 = 1;
  }
  else {
    int v491 = (*(uint64_t (**)(void))(**(void **)(a1 + 240) + 88))(*(void *)(a1 + 240));
  }
  int v492 = *(unsigned __int8 *)(a1 + 3043);
  *(_WORD *)(a1 + 3042) = 0;
  if (*(unsigned char *)(a1 + 3041))
  {
    BOOL v493 = 1;
  }
  else if (*(unsigned char *)(a1 + 3608))
  {
    BOOL v493 = *(unsigned char *)(a1 + 3609) != 0;
  }
  else
  {
    BOOL v493 = 0;
  }
  *(unsigned char *)(a1 + 3041) = 0;
  BYTE4(v1034) = v493;
  if (*(void *)(a1 + 184))
  {
    LODWORD(v1034) = 65537;
    uint64_t v392 = a1;
    goto LABEL_817;
  }
  LOBYTE(v1034) = v493;
  if (!v488)
  {
    BYTE1(v1034) = (*(uint64_t (**)(void))(**(void **)(a1 + 240) + 96))(*(void *)(a1 + 240)) ^ 1;
    char v546 = *(unsigned char *)(a1 + 3379) | atomic_exchange((atomic_uchar *volatile)(a1 + 3378), 0) & 1;
    *(unsigned char *)(a1 + 3379) = v546;
    if (v489)
    {
      if ((v491 & 1) == 0 && !*(unsigned char *)(a1 + 3611))
      {
        uint64_t v547 = *(void *)(a1 + 3440);
        if (v547)
        {
          if (v546 || *(unsigned char *)(a1 + 3045) || (int v548 = *(unsigned __int8 *)(a1 + 3046), *(unsigned char *)(a1 + 3046)))
          {
            if (BYTE1(v1034))
            {
              int v548 = *(unsigned __int8 *)(a1 + 3046);
              if (*(unsigned char *)(a1 + 3046))
              {
                int v549 = 0;
                BYTE1(v1034) = 0;
                int v548 = 1;
              }
              else
              {
                int v549 = 1;
              }
              char v977 = 0;
            }
            else
            {
              int v549 = 0;
              char v977 = 0;
              int v548 = 1;
            }
          }
          else
          {
            int v549 = BYTE1(v1034);
            char v977 = 1;
          }
          *(unsigned char *)(a1 + 3045) |= (v1034 | v549) != 0;
          int v540 = v548 != 0;
          if (v977)
          {
LABEL_1431:
            if (!(*(unsigned int (**)(uint64_t))(*(void *)v547 + 56))(v547))
            {
              *(void *)(a1 + 3296) = v490;
              (*(void (**)(void, void, double))(**(void **)(a1 + 3440) + 24))(*(void *)(a1 + 3440), 0, 0.1);
              int v540 = 0;
              goto LABEL_1396;
            }
            if (v490 - *(void *)(a1 + 3296) < MaxCollisionIntervalInMachTime)
            {
LABEL_1433:
              int v540 = 0;
              goto LABEL_1396;
            }
            goto LABEL_1393;
          }
LABEL_1286:
          if (!v540) {
            goto LABEL_1396;
          }
        }
      }
    }
    else
    {
      BOOL v916 = *(_DWORD *)(a1 + 3280) != *(_DWORD *)(a1 + 1620) || *(_DWORD *)(a1 + 3276) != *(_DWORD *)(a1 + 3272) - 1;
      if ((_BYTE)v1034) {
        char v917 = 1;
      }
      else {
        char v917 = v491;
      }
      if ((v917 & 1) == 0 && !BYTE1(v1034))
      {
        uint64_t v547 = *(void *)(a1 + 3440);
        if (v547)
        {
          if (!v546 && !*(unsigned char *)(a1 + 3045))
          {
            int v540 = *(unsigned char *)(a1 + 3046) != 0;
            if (*(unsigned char *)(a1 + 3046)) {
              BOOL v916 = 0;
            }
            if (v916) {
              goto LABEL_1431;
            }
            goto LABEL_1286;
          }
        }
        else if (!*(unsigned char *)(a1 + 3045) && !*(unsigned char *)(a1 + 3046) && !v916)
        {
          goto LABEL_1433;
        }
      }
    }
LABEL_1393:
    uint64_t v973 = *(void *)(a1 + 3440);
    if (v973) {
      (*(void (**)(uint64_t))(*(void *)v973 + 40))(v973);
    }
    *(_WORD *)(a1 + 3045) = 0;
    *(unsigned char *)(a1 + 3379) = 0;
    int v540 = 1;
LABEL_1396:
    BYTE2(v1034) = v540;
    if (v492)
    {
      int v492 = 1;
      uint64_t v974 = a1;
    }
    else
    {
      uint64_t v974 = a1;
      int v492 = *(unsigned char *)(a1 + 3047) != 0;
    }
    BYTE3(v1034) = v492;
    *(unsigned char *)(v974 + 3047) = 0;
    int v539 = BYTE1(v1034);
    if (!(_BYTE)v1034) {
      goto LABEL_1400;
    }
LABEL_1404:
    uint64_t v392 = a1;
    if (!v540) {
      goto LABEL_818;
    }
LABEL_817:
    *(_DWORD *)(v392 + 3276) = *(_DWORD *)(v392 + 3272);
    *(_DWORD *)(v392 + 3280) = *(_DWORD *)(v392 + 1620);
    goto LABEL_818;
  }
  int v539 = 0;
  BYTE1(v1034) = 0;
  int v540 = v493 | v491;
  BYTE2(v1034) = v493 | v491;
  BYTE3(v1034) = v492;
  if (v493) {
    goto LABEL_1404;
  }
LABEL_1400:
  if (v539) {
    goto LABEL_1404;
  }
  uint64_t v392 = a1;
  if (v540) {
    goto LABEL_817;
  }
  if (!v492) {
    goto LABEL_876;
  }
LABEL_818:
  *(_DWORD *)(*(void *)(v392 + 3144) + 160) = *(_DWORD *)(v392 + 3272);
  if (v489)
  {
    md::LabelManager::layoutForStaging(v392, (uint64_t)&v1034);
    md::FontTrackingCache::updateForDisplay(*(md::FontTrackingCache **)(v392 + 312));
    (*(void (**)(void))(**(void **)(v392 + 240) + 48))(*(void *)(v392 + 240));
    md::OcclusionManager::flushQueuedQueries(*(int64x2_t **)(v392 + 360));
    goto LABEL_876;
  }
  unint64_t v495 = *(void (***)(void **))(v392 + 8);
  uint64_t v494 = *(std::__shared_weak_count **)(v392 + 16);
  uint64_t v1040 = v495;
  if (v494)
  {
    uint64_t v496 = std::__shared_weak_count::lock(v494);
    uint64_t v1041 = v496;
    if (v496)
    {
      unint64_t v497 = (atomic_ullong *)v496;
      *(unsigned char *)(a1 + 3385) = 1;
      BYTE5(v1034) = 1;
      *(_OWORD *)(a1 + 1728) = *(_OWORD *)v990;
      long long v498 = *(_OWORD *)(v990 + 16);
      long long v499 = *(_OWORD *)(v990 + 32);
      long long v500 = *(_OWORD *)(v990 + 48);
      *(_DWORD *)(a1 + 1792) = *(_DWORD *)(v990 + 64);
      *(_OWORD *)(a1 + 1776) = v500;
      *(_OWORD *)(a1 + 1760) = v499;
      *(_OWORD *)(a1 + 1744) = v498;
      long long v501 = *(_OWORD *)(a1 + 524);
      *(_OWORD *)(a1 + 1796) = *(_OWORD *)(a1 + 508);
      *(_OWORD *)(a1 + 1812) = v501;
      *(void *)(a1 + 1828) = *(void *)(a1 + 540);
      *(_OWORD *)(a1 + 1840) = *(_OWORD *)(a1 + 552);
      *(_OWORD *)(a1 + 1856) = *(_OWORD *)(a1 + 568);
      long long v502 = *(_OWORD *)(a1 + 600);
      *(_OWORD *)(a1 + 1872) = *v985;
      *(_OWORD *)(a1 + 1888) = v502;
      *(_OWORD *)(a1 + 1904) = *(_OWORD *)(a1 + 616);
      *(_OWORD *)(a1 + 1920) = *(_OWORD *)(a1 + 632);
      *(_OWORD *)(a1 + 1936) = *(_OWORD *)(a1 + 648);
      *(_OWORD *)(a1 + 1952) = *(_OWORD *)(a1 + 664);
      *(_OWORD *)(a1 + 1968) = *(_OWORD *)(a1 + 680);
      long long v503 = *(_OWORD *)(a1 + 696);
      *(_OWORD *)(a1 + 2000) = *(_OWORD *)(a1 + 712);
      *(_OWORD *)(a1 + 1984) = v503;
      long long v504 = *(_OWORD *)(a1 + 728);
      long long v505 = *(_OWORD *)(a1 + 744);
      long long v506 = *(_OWORD *)(a1 + 760);
      *(_OWORD *)(a1 + 2064) = *(_OWORD *)(a1 + 776);
      *(_OWORD *)(a1 + 2048) = v506;
      *(_OWORD *)(a1 + 2032) = v505;
      *(_OWORD *)(a1 + 2016) = v504;
      long long v507 = *(_OWORD *)(a1 + 808);
      *(_OWORD *)(a1 + 2080) = *(_OWORD *)(a1 + 792);
      *(_OWORD *)(a1 + 2096) = v507;
      *(_OWORD *)(a1 + 2112) = *(_OWORD *)(a1 + 824);
      uint64_t v508 = *(void *)(a1 + 840);
      *(_DWORD *)(a1 + 2136) = *(_DWORD *)(a1 + 848);
      *(void *)(a1 + 2128) = v508;
      *(_OWORD *)(a1 + 2144) = *(_OWORD *)(a1 + 856);
      *(float32x4_t *)(a1 + 2160) = *v980;
      *(_OWORD *)(a1 + 2176) = *(_OWORD *)(a1 + 888);
      *(void *)(a1 + 2192) = *(void *)(a1 + 904);
      *(void *)(a1 + 2200) = *(void *)(a1 + 912);
      long long v509 = *(_OWORD *)(a1 + 936);
      *(_OWORD *)(a1 + 2208) = *(_OWORD *)(a1 + 920);
      *(_OWORD *)(a1 + 2224) = v509;
      long long v510 = *(_OWORD *)(a1 + 968);
      *(_OWORD *)(a1 + 2240) = *(_OWORD *)(a1 + 952);
      *(_OWORD *)(a1 + 2256) = v510;
      long long v511 = *(_OWORD *)(a1 + 1000);
      *(_OWORD *)(a1 + 2272) = *(_OWORD *)(a1 + 984);
      *(_OWORD *)(a1 + 2288) = v511;
      long long v512 = *(_OWORD *)(a1 + 1032);
      *(_OWORD *)(a1 + 2304) = *(_OWORD *)(a1 + 1016);
      *(_OWORD *)(a1 + 2320) = v512;
      long long v513 = *(_OWORD *)(a1 + 1064);
      *(_OWORD *)(a1 + 2336) = *(_OWORD *)(a1 + 1048);
      *(_OWORD *)(a1 + 2352) = v513;
      long long v514 = *(_OWORD *)(a1 + 1096);
      *(_OWORD *)(a1 + 2368) = *(_OWORD *)(a1 + 1080);
      *(_OWORD *)(a1 + 2384) = v514;
      long long v515 = *(_OWORD *)(a1 + 1128);
      *(_OWORD *)(a1 + 2400) = *(_OWORD *)(a1 + 1112);
      *(_OWORD *)(a1 + 2416) = v515;
      long long v516 = *(_OWORD *)(a1 + 1160);
      *(_OWORD *)(a1 + 2432) = *(_OWORD *)(a1 + 1144);
      *(_OWORD *)(a1 + 2448) = v516;
      long long v517 = *(_OWORD *)(a1 + 1192);
      *(_OWORD *)(a1 + 2464) = *(_OWORD *)(a1 + 1176);
      *(_OWORD *)(a1 + 2480) = v517;
      long long v518 = *(_OWORD *)(a1 + 1224);
      *(_OWORD *)(a1 + 2496) = *(_OWORD *)(a1 + 1208);
      *(_OWORD *)(a1 + 2512) = v518;
      long long v519 = *(_OWORD *)(a1 + 1256);
      *(_OWORD *)(a1 + 2528) = *(_OWORD *)(a1 + 1240);
      *(_OWORD *)(a1 + 2544) = v519;
      long long v520 = *(_OWORD *)(a1 + 1288);
      *(_OWORD *)(a1 + 2560) = *(_OWORD *)(a1 + 1272);
      *(_OWORD *)(a1 + 2576) = v520;
      long long v521 = *(_OWORD *)(a1 + 1320);
      *(_OWORD *)(a1 + 2592) = *(_OWORD *)(a1 + 1304);
      *(_OWORD *)(a1 + 2608) = v521;
      long long v522 = *(_OWORD *)(a1 + 1352);
      *(_OWORD *)(a1 + 2624) = *(_OWORD *)(a1 + 1336);
      *(_OWORD *)(a1 + 2640) = v522;
      long long v523 = *(_OWORD *)(a1 + 1384);
      *(_OWORD *)(a1 + 2656) = *(_OWORD *)(a1 + 1368);
      *(_OWORD *)(a1 + 2672) = v523;
      long long v524 = *(_OWORD *)(a1 + 1416);
      *(_OWORD *)(a1 + 2688) = *(_OWORD *)(a1 + 1400);
      *(_OWORD *)(a1 + 2704) = v524;
      long long v525 = *(_OWORD *)(a1 + 1448);
      *(_OWORD *)(a1 + 2720) = *(_OWORD *)(a1 + 1432);
      *(_OWORD *)(a1 + 2736) = v525;
      long long v526 = *(_OWORD *)(a1 + 1480);
      *(_OWORD *)(a1 + 2752) = *(_OWORD *)(a1 + 1464);
      *(_OWORD *)(a1 + 2768) = v526;
      *(void *)(a1 + 2784) = *(void *)(a1 + 1496);
      *(_OWORD *)(a1 + 2792) = *(_OWORD *)(a1 + 1504);
      *(_OWORD *)(a1 + 2808) = *(_OWORD *)(a1 + 1520);
      *(_OWORD *)(a1 + 2824) = *(_OWORD *)(a1 + 1536);
      *(_OWORD *)(a1 + 2840) = *(_OWORD *)(a1 + 1552);
      *(_OWORD *)(a1 + 2856) = *(_OWORD *)(a1 + 1568);
      unint64_t v527 = *(void *)(a1 + 1592);
      double v528 = *(char **)(a1 + 1600);
      *(void *)(a1 + 2872) = *(void *)(a1 + 1584);
      std::vector<gm::Matrix<double,2,1>>::__assign_with_size[abi:nn180100]<gm::Matrix<double,2,1>*,gm::Matrix<double,2,1>*>(a1 + 2880, v527, v528, (uint64_t)&v528[-v527] >> 4);
      long long v529 = *(_OWORD *)(a1 + 1632);
      *(_OWORD *)(a1 + 2904) = *(_OWORD *)(a1 + 1616);
      *(_OWORD *)(a1 + 2920) = v529;
      double v530 = *(char **)(a1 + 1648);
      double v531 = *(unsigned char **)(a1 + 1656);
      size_t v532 = v531 - v530;
      unint64_t v533 = (v531 - v530) >> 4;
      uint64_t v534 = *(void *)(a1 + 2952);
      double v535 = *(char **)(a1 + 2936);
      if (v533 > (v534 - (uint64_t)v535) >> 4)
      {
        if (v535)
        {
          *(void *)(a1 + 2944) = v535;
          operator delete(v535);
          uint64_t v534 = 0;
          *(void *)(a1 + 2936) = 0;
          *(void *)(a1 + 2944) = 0;
          *(void *)(a1 + 2952) = 0;
        }
        if ((v532 & 0x8000000000000000) != 0) {
          goto LABEL_1448;
        }
        uint64_t v536 = v534 >> 3;
        if (v534 >> 3 <= v533) {
          uint64_t v536 = (v531 - v530) >> 4;
        }
        unint64_t v537 = (unint64_t)v534 >= 0x7FFFFFFFFFFFFFF0 ? 0xFFFFFFFFFFFFFFFLL : v536;
        if (v537 >> 60) {
LABEL_1448:
        }
          abort();
        double v538 = (char *)operator new(16 * v537);
        double v535 = v538;
        *(void *)(a1 + 2936) = v538;
        *(void *)(a1 + 2944) = v538;
        *(void *)(a1 + 2952) = &v538[16 * v537];
        if (v531 != v530) {
          memcpy(v538, v530, v531 - v530);
        }
        goto LABEL_855;
      }
      double v541 = *(unsigned char **)(a1 + 2944);
      unint64_t v542 = (v541 - v535) >> 4;
      if (v542 >= v533)
      {
        if (v531 == v530) {
          goto LABEL_855;
        }
        double v544 = *(void **)(a1 + 2936);
        double v545 = *(char **)(a1 + 1648);
        goto LABEL_854;
      }
      double v543 = &v530[16 * v542];
      if (v541 != v535)
      {
        memmove(*(void **)(a1 + 2936), *(const void **)(a1 + 1648), v541 - v535);
        double v535 = *(char **)(a1 + 2944);
      }
      size_t v532 = v531 - v543;
      if (v531 != v543)
      {
        double v544 = v535;
        double v545 = v543;
LABEL_854:
        memmove(v544, v545, v532);
      }
LABEL_855:
      long long v550 = &v535[v532];
      uint64_t v551 = a1;
      *(void *)(a1 + 2944) = v550;
      uint64_t v552 = *v393;
      *(void *)(a1 + 2960) = *v393;
      *(_DWORD *)(a1 + 2968) = *(_DWORD *)(a1 + 1680);
      *(_OWORD *)(a1 + 2976) = *(_OWORD *)(a1 + 1688);
      *(void *)(a1 + 2992) = *(void *)(a1 + 1704);
      *(void *)(a1 + 3000) = *(void *)(a1 + 1712);
      *(_DWORD *)(a1 + 3008) = *(_DWORD *)(a1 + 1720);
      uint64_t v553 = *(md::VenueLogicContext **)(a1 + 3016);
      if (v552)
      {
        if (!v553) {
          operator new();
        }
        uint64_t v551 = a1;
        md::VenueLogicContext::operator=((uint64_t)v553, *(void *)(a1 + 2960));
        *(void *)(a1 + 2960) = *(void *)(a1 + 3016);
      }
      else
      {
        *(void *)(a1 + 3016) = 0;
        if (v553)
        {
          md::VenueLogicContext::~VenueLogicContext(v553);
          MEMORY[0x1A6239270]();
        }
      }
      *(void *)(v551 + 432) = v551 + 1728;
      dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v551 + 216), 0xFFFFFFFFFFFFFFFFLL);
      char v554 = *(unsigned char *)(v551 + 3305) + 1;
      *(unsigned char *)(v551 + 3305) = v554;
      uint64_t v555 = *(void *)(*(void *)(v551 + 152) + 80);
      __p[0] = v495;
      __p[1] = v497;
      atomic_fetch_add_explicit(v497 + 1, 1uLL, memory_order_relaxed);
      *(void *)&long long v1009 = v1034;
      DWORD2(v1009) = v1035;
      BYTE12(v1009) = v554;
      *((void *)&v1023 + 1) = 0;
      uint64_t v556 = operator new(0x28uLL);
      *uint64_t v556 = &unk_1EF56EBE0;
      v556[1] = v495;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v557 = v1009;
      v556[2] = v497;
      v556[3] = v557;
      *(void *)((char *)v556 + 29) = *(void *)((char *)&v1009 + 5);
      *((void *)&v1023 + 1) = v556;
      geo::TaskQueue::async(&buf, v555, &v1022);
      uint64_t v558 = v1038;
      unint64_t v390 = v994;
      if (v1038 && !atomic_fetch_add(&v1038->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v558->__on_zero_shared)(v558);
        std::__shared_weak_count::__release_weak(v558);
      }
      if (*((long long **)&v1023 + 1) == &v1022)
      {
        (*(void (**)(long long *))(v1022 + 32))(&v1022);
        v559 = (std::__shared_weak_count *)__p[1];
        if (!__p[1]) {
          goto LABEL_872;
        }
      }
      else
      {
        if (*((void *)&v1023 + 1)) {
          (*(void (**)(void))(**((void **)&v1023 + 1) + 40))();
        }
        v559 = (std::__shared_weak_count *)__p[1];
        if (!__p[1])
        {
LABEL_872:
          float32x2_t v560 = v1041;
          if (v1041 && !atomic_fetch_add(&v1041->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v560->__on_zero_shared)(v560);
            std::__shared_weak_count::__release_weak(v560);
          }
          uint64_t v392 = a1;
          goto LABEL_876;
        }
      }
      if (!atomic_fetch_add(&v559->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v559->__on_zero_shared)(v559);
        std::__shared_weak_count::__release_weak(v559);
      }
      goto LABEL_872;
    }
  }
LABEL_1437:
  std::__throw_bad_weak_ptr[abi:nn180100]();
LABEL_1449:
  __break(1u);
}

void sub_1A1BF59BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::recursive_mutex *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0) {
    operator delete(__p);
  }

  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)(v35 - 240));
  std::recursive_mutex::unlock(a14);
  uint64_t v37 = mach_absolute_time();
  if (ggl::Performance::Counters::instance(void)::onceToken[0] != -1) {
    dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_53878);
  }
  atomic_fetch_add((atomic_ullong *volatile)(*(void *)(ggl::Performance::Counters::instance(void)::counters + 32) + 96), v37 - a15);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::LabelTextureAtlasStore::startFrame(void)::$_1,std::allocator<md::LabelTextureAtlasStore::startFrame(void)::$_1>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "LabelsTextureAtlasUpdate", "", v1, 2u);
  }
}

void std::__function::__func<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_1,std::allocator<md::LabelManager::renderLabels(md::LayoutContext const&,BOOL &,BOOL &)::$_1>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "LabelsRender", "", v1, 2u);
  }
}

uint64_t md::CompositeLabeler::startFrameLayout(uint64_t this, const md::LayoutContext *a2, float a3)
{
  uint64_t v3 = *(uint64_t **)(this + 8);
  for (uint64_t i = *(uint64_t **)(this + 16);
        v3 != i;
        this = (*(uint64_t (**)(uint64_t, const md::LayoutContext *, float))(*(void *)v7 + 24))(v7, a2, a3))
  {
    uint64_t v7 = *v3++;
  }
  return this;
}

uint64_t md::CompositeLabeler::endFrameLayout(uint64_t this, BOOL *a2, BOOL *a3)
{
  uint64_t v3 = *(uint64_t **)(this + 8);
  for (uint64_t i = *(uint64_t **)(this + 16);
        v3 != i;
        this = (*(uint64_t (**)(uint64_t, BOOL *, BOOL *))(*(void *)v7 + 72))(v7, a2, a3))
  {
    uint64_t v7 = *v3++;
  }
  return this;
}

void md::StandardLabeler::endFrameLayout(md::StandardLabeler *this, BOOL *a2, BOOL *a3)
{
  if (*((void *)this + 30)) {
    md::StandardLabeler::monitorSelectedLabelState(this, 0);
  }
  *a2 |= *((unsigned char *)this + 370);
  *a3 |= *((unsigned char *)this + 371);
}

uint64_t md::MapNavLabeler::startFrameLayout(uint64_t this, const md::LayoutContext *a2, float a3)
{
  *(float *)(this + 684) = a3;
  *(_WORD *)(this + 824) = 0;
  return this;
}

uint64_t md::MapNavLabeler::endFrameLayout(uint64_t this, BOOL *a2, BOOL *a3)
{
  *a2 |= *(unsigned char *)(this + 824);
  *a3 |= *(unsigned char *)(this + 825);
  return this;
}

void std::__function::__func<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_1,std::allocator<md::LabelManager::layoutDisplayLabels(md::LayoutContext const&)::$_1>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "LayoutDisplayLabels", "", v1, 2u);
  }
}

void md::OcclusionManager::flushQueuedQueries(int64x2_t *this)
{
  unint64_t v2 = this[5].u64[0];
  uint64_t v3 = this[5].i64[1];
  unint64_t v4 = v2 + v3;
  unint64_t v5 = (v2 + v3) >> 8;
  uint8x8_t v6 = (char *)this[3].i64[1];
  uint64_t v7 = (char *)this[4].i64[0];
  uint64_t v8 = &v6[8 * v5];
  int64_t v9 = v7 - v6;
  if (v7 == v6)
  {
    uint64_t v10 = (char *)this[1].i64[0];
    unint64_t v384 = this + 1;
    unint64_t v11 = (char *)this[1].i64[1];
    uint64_t v385 = &this[1].i64[1];
    unint64_t v12 = (v11 - v10) >> 4;
    unint64_t v13 = v2 >> 8;
  }
  else
  {
    uint64_t v10 = (char *)this[1].i64[0];
    unint64_t v384 = this + 1;
    unint64_t v11 = (char *)this[1].i64[1];
    uint64_t v385 = &this[1].i64[1];
    unint64_t v12 = (v11 - v10) >> 4;
    unint64_t v13 = v2 >> 8;
    uint64_t v14 = &v6[8 * (v2 >> 8)];
    if (*(void *)v8 + 16 * v4 != *(void *)v14 + 16 * v2)
    {
      unint64_t v15 = ((16 * v4) >> 4) + 32 * (v8 - v14) - ((16 * v2) >> 4);
      goto LABEL_6;
    }
  }
  unint64_t v15 = 0;
LABEL_6:
  double v16 = (void **)&this[3];
  uint64_t v397 = v11;
  if (v15 >= v3 - v15)
  {
    uint64_t v29 = 32 * v9 - 1;
    uint64_t v30 = v7 - v6;
    if (v7 == v6) {
      uint64_t v29 = 0;
    }
    unint64_t v31 = v29 - v4;
    BOOL v32 = v12 >= v31;
    unint64_t v33 = v12 - v31;
    if (v33 == 0 || !v32)
    {
LABEL_384:
      double v290 = (uint64_t *)&v6[8 * v5];
      if (v7 == v6) {
        uint64_t v291 = 0;
      }
      else {
        uint64_t v291 = *v290 + 16 * v4;
      }
      unint64_t v316 = v3 - v15;
      if (v3 - v15 >= v12)
      {
        double v320 = (void *)v291;
        __double2 v319 = &v6[8 * v5];
        if (!v12) {
          goto LABEL_517;
        }
      }
      else
      {
        if (v316 >= v12 >> 1) {
          double v317 = &v11[16 * (v3 - v15 - v12)];
        }
        else {
          double v317 = &v10[16 * v316];
        }
        if (v317 == v11)
        {
          double v320 = (void *)v291;
          __double2 v319 = &v6[8 * v5];
        }
        else
        {
          double v318 = v317;
          __double2 v319 = &v6[8 * v5];
          double v320 = (void *)v291;
          do
          {
            *double v320 = *(void *)v318;
            uint64_t v321 = *((void *)v318 + 1);
            v320[1] = v321;
            if (v321) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v321 + 8), 1uLL, memory_order_relaxed);
            }
            v320 += 2;
            if ((void *)((char *)v320 - *(void *)v319) == (void *)4096)
            {
              double v322 = (void *)*((void *)v319 + 1);
              v319 += 8;
              double v320 = v322;
            }
            ++this[5].i64[1];
            v318 += 16;
          }
          while (v318 != v11);
          unint64_t v11 = v317;
        }
        unint64_t v12 = v316;
        if (!v316) {
          goto LABEL_517;
        }
      }
      uint64_t v323 = ((v291 - *v290) >> 4) - v12;
      if (v323 < 1)
      {
        unint64_t v326 = 255 - v323;
        unint64_t v324 = (char *)&v290[-(v326 >> 8)];
        uint64_t v325 = *(void *)v324 + 16 * ~(_BYTE)v326;
        if (v325 == v291) {
          goto LABEL_436;
        }
      }
      else
      {
        unint64_t v324 = (char *)&v290[(unint64_t)v323 >> 8];
        uint64_t v325 = *(void *)v324 + 16 * v323;
        if (v325 == v291) {
          goto LABEL_436;
        }
      }
      unint64_t v327 = v324;
      uint64_t v328 = v325;
      do
      {
        *(_OWORD *)double v320 = *(_OWORD *)v328;
        v320 += 2;
        *(void *)uint64_t v328 = 0;
        *(void *)(v328 + 8) = 0;
        if ((void *)((char *)v320 - *(void *)v319) == (void *)4096)
        {
          float v329 = (void *)*((void *)v319 + 1);
          v319 += 8;
          double v320 = v329;
        }
        v328 += 16;
        if (v328 - *(void *)v327 == 4096)
        {
          uint64_t v330 = *((void *)v327 + 1);
          v327 += 8;
          uint64_t v328 = v330;
        }
        ++this[5].i64[1];
      }
      while (v328 != v291);
LABEL_436:
      if (v12 < v316)
      {
        uint64_t v331 = *v290;
        uint64_t v332 = ((v291 - *v290) >> 4) - v316;
        if (v332 < 1)
        {
          unint64_t v335 = 255 - v332;
          __double2 v333 = (char *)&v290[-(v335 >> 8)];
          uint64_t v334 = *(void *)v333 + 16 * ~(_BYTE)v335;
        }
        else
        {
          __double2 v333 = (char *)&v290[(unint64_t)v332 >> 8];
          uint64_t v334 = *(void *)v333 + 16 * v332;
        }
        uint64_t v398 = v11;
        if (v333 != v324)
        {
          uint64_t v336 = *(void *)v324;
          uint64_t v392 = v334;
          BOOL v396 = v333;
          if (*(void *)v324 == v325)
          {
            unint64_t v11 = v398;
          }
          else
          {
            __pg = v324;
            while (1)
            {
              if ((v325 - v336) >> 4 >= (v291 - v331) >> 4) {
                uint64_t v337 = (v291 - v331) >> 4;
              }
              else {
                uint64_t v337 = (v325 - v336) >> 4;
              }
              if (v337)
              {
                uint64_t v338 = -16 * v337;
                uint64_t v339 = v325 - 16;
                do
                {
                  long long v340 = *(_OWORD *)v339;
                  *(void *)uint64_t v339 = 0;
                  *(void *)(v339 + 8) = 0;
                  unint64_t v341 = *(std::__shared_weak_count **)(v291 - 8);
                  *(_OWORD *)(v291 - 16) = v340;
                  v291 -= 16;
                  if (v341 && !atomic_fetch_add(&v341->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v341->__on_zero_shared)(v341);
                    std::__shared_weak_count::__release_weak(v341);
                  }
                  v339 -= 16;
                  v338 += 16;
                }
                while (v338);
              }
              v325 -= 16 * v337;
              if (v325 == v336) {
                break;
              }
              uint64_t v342 = *--v290;
              uint64_t v331 = v342;
              uint64_t v291 = v342 + 4096;
            }
            uint64_t v331 = *v290;
            uint64_t v334 = v392;
            if (*v290 + 4096 == v291)
            {
              uint64_t v343 = v290[1];
              ++v290;
              uint64_t v331 = v343;
              uint64_t v291 = v343;
            }
            __double2 v333 = v396;
            unint64_t v11 = v398;
            unint64_t v324 = __pg;
          }
          uint64_t v350 = v324 - 8;
          if (v324 - 8 != v333)
          {
            do
            {
              __ph = v350;
              uint64_t v351 = *(void *)v350;
              uint64_t v352 = *(void *)v350 + 4096;
              while (1)
              {
                if ((v352 - v351) >> 4 >= (v291 - v331) >> 4) {
                  uint64_t v353 = (v291 - v331) >> 4;
                }
                else {
                  uint64_t v353 = (v352 - v351) >> 4;
                }
                if (v353)
                {
                  uint64_t v354 = -16 * v353;
                  uint64_t v355 = v352 - 16;
                  do
                  {
                    long long v356 = *(_OWORD *)v355;
                    *(void *)uint64_t v355 = 0;
                    *(void *)(v355 + 8) = 0;
                    int v357 = *(std::__shared_weak_count **)(v291 - 8);
                    *(_OWORD *)(v291 - 16) = v356;
                    v291 -= 16;
                    if (v357 && !atomic_fetch_add(&v357->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v357->__on_zero_shared)(v357);
                      std::__shared_weak_count::__release_weak(v357);
                    }
                    v355 -= 16;
                    v354 += 16;
                  }
                  while (v354);
                }
                v352 -= 16 * v353;
                if (v352 == v351) {
                  break;
                }
                uint64_t v358 = *--v290;
                uint64_t v331 = v358;
                uint64_t v291 = v358 + 4096;
              }
              uint64_t v331 = *v290;
              uint64_t v334 = v392;
              if (*v290 + 4096 == v291)
              {
                uint64_t v359 = v290[1];
                ++v290;
                uint64_t v331 = v359;
                uint64_t v291 = v359;
              }
              __double2 v333 = v396;
              unint64_t v11 = v398;
              uint64_t v350 = __ph - 8;
            }
            while (__ph - 8 != v396);
          }
          uint64_t v360 = *(void *)v333 + 4096;
          if (v360 == v334) {
            goto LABEL_502;
          }
          uint64_t v361 = *v290;
          while (1)
          {
            uint64_t v362 = (v291 - v361) >> 4;
            if ((v360 - v334) >> 4 >= v362) {
              uint64_t v363 = v362;
            }
            else {
              uint64_t v363 = (v360 - v334) >> 4;
            }
            if (v363)
            {
              uint64_t v364 = -16 * v363;
              uint64_t v365 = v360 - 16;
              do
              {
                long long v366 = *(_OWORD *)v365;
                *(void *)uint64_t v365 = 0;
                *(void *)(v365 + 8) = 0;
                unint64_t v367 = *(std::__shared_weak_count **)(v291 - 8);
                *(_OWORD *)(v291 - 16) = v366;
                v291 -= 16;
                if (v367 && !atomic_fetch_add(&v367->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v367->__on_zero_shared)(v367);
                  std::__shared_weak_count::__release_weak(v367);
                }
                v365 -= 16;
                v364 += 16;
              }
              while (v364);
            }
            v360 -= 16 * v363;
            unint64_t v11 = v398;
            if (v360 == v334) {
              break;
            }
            uint64_t v368 = *--v290;
            uint64_t v361 = v368;
            uint64_t v291 = v368 + 4096;
          }
          goto LABEL_500;
        }
        if (v334 != v325)
        {
          while (1)
          {
            if ((v325 - v334) >> 4 >= (v291 - v331) >> 4) {
              uint64_t v344 = (v291 - v331) >> 4;
            }
            else {
              uint64_t v344 = (v325 - v334) >> 4;
            }
            if (v344)
            {
              uint64_t v345 = -16 * v344;
              uint64_t v346 = v325 - 16;
              do
              {
                long long v347 = *(_OWORD *)v346;
                *(void *)uint64_t v346 = 0;
                *(void *)(v346 + 8) = 0;
                float v348 = *(std::__shared_weak_count **)(v291 - 8);
                *(_OWORD *)(v291 - 16) = v347;
                v291 -= 16;
                if (v348 && !atomic_fetch_add(&v348->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v348->__on_zero_shared)(v348);
                  std::__shared_weak_count::__release_weak(v348);
                }
                v346 -= 16;
                v345 += 16;
              }
              while (v345);
            }
            v325 -= 16 * v344;
            unint64_t v11 = v398;
            if (v325 == v334) {
              break;
            }
            uint64_t v349 = *--v290;
            uint64_t v331 = v349;
            uint64_t v291 = v349 + 4096;
          }
LABEL_500:
          if (*v290 + 4096 == v291)
          {
            uint64_t v369 = v290[1];
            ++v290;
            uint64_t v291 = v369;
          }
        }
      }
LABEL_502:
      if (v11 != v10)
      {
        uint64_t v370 = *v290;
        while (1)
        {
          uint64_t v371 = (v291 - v370) >> 4;
          int v372 = v11;
          if ((v11 - v10) >> 4 >= v371) {
            uint64_t v373 = v371;
          }
          else {
            uint64_t v373 = (v11 - v10) >> 4;
          }
          if (v373)
          {
            int v374 = (std::__shared_weak_count **)(v11 - 8);
            uint64_t v375 = -16 * v373;
            unint64_t v376 = (std::__shared_weak_count **)(v291 - 8);
            do
            {
              uint64_t v378 = *(v374 - 1);
              unsigned int v377 = *v374;
              if (*v374) {
                atomic_fetch_add_explicit(&v377->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              uint64_t v379 = *v376;
              *(v376 - 1) = v378;
              *unint64_t v376 = v377;
              if (v379 && !atomic_fetch_add(&v379->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v379->__on_zero_shared)(v379);
                std::__shared_weak_count::__release_weak(v379);
              }
              v374 -= 2;
              v376 -= 2;
              v375 += 16;
            }
            while (v375);
          }
          unint64_t v11 = &v372[-16 * v373];
          if (v11 == v10) {
            break;
          }
          uint64_t v380 = *--v290;
          uint64_t v370 = v380;
          uint64_t v291 = v380 + 4096;
        }
      }
      goto LABEL_517;
    }
    if (v7 == v6) {
      unint64_t v34 = v33 + 1;
    }
    else {
      unint64_t v34 = v33;
    }
    if ((_BYTE)v34) {
      unint64_t v35 = (v34 >> 8) + 1;
    }
    else {
      unint64_t v35 = v34 >> 8;
    }
    if (v35 >= v13) {
      unint64_t v36 = v13;
    }
    else {
      unint64_t v36 = v35;
    }
    unint64_t v390 = v12;
    unint64_t v393 = v15;
    if (v35 > v13)
    {
      unint64_t v37 = v35 - v36;
      uint64_t v38 = this[4].i64[1] - this[3].i64[0];
      uint64_t v39 = v30 >> 3;
      if (v35 - v36 > (v38 >> 3) - (v30 >> 3))
      {
        unint64_t v40 = v38 >> 2;
        if (v40 <= v37 + v39) {
          unint64_t v41 = v37 + v39;
        }
        else {
          unint64_t v41 = v40;
        }
        if (v41)
        {
          if (v41 >> 61) {
            goto LABEL_524;
          }
          uint64_t v42 = (char *)operator new(8 * v41);
        }
        else
        {
          uint64_t v42 = 0;
        }
        unint64_t v387 = v36 << 8;
        double v145 = &v42[8 * (v39 - v36)];
        __pc = v42;
        uint64_t v146 = &v42[8 * v41];
        uint64_t v7 = v145;
        while (1)
        {
          uint64_t v147 = v146;
          float v148 = operator new(0x1000uLL);
          if (v7 == v146)
          {
            if (v145 <= __pc)
            {
              if (v146 == __pc) {
                unint64_t v154 = 1;
              }
              else {
                unint64_t v154 = (v146 - __pc) >> 2;
              }
              if (v154 >> 61) {
                goto LABEL_524;
              }
              double v155 = (char *)operator new(8 * v154);
              long double v156 = v155;
              unint64_t v157 = v154 >> 2;
              uint64_t v158 = &v155[8 * (v154 >> 2)];
              uint64_t v7 = v158;
              int64_t v159 = v147 - v145;
              if (v147 != v145)
              {
                uint64_t v7 = &v158[v159 & 0xFFFFFFFFFFFFFFF8];
                unint64_t v160 = v159 - 8;
                if (v160 >= 0x38)
                {
                  uint64_t v162 = 8 * v157;
                  if ((unint64_t)(&v155[8 * v157] - v145) < 0x20)
                  {
                    float v161 = &v155[8 * (v154 >> 2)];
                    goto LABEL_199;
                  }
                  uint64_t v163 = (v160 >> 3) + 1;
                  uint64_t v164 = 8 * (v163 & 0x3FFFFFFFFFFFFFFCLL);
                  float v161 = &v158[v164];
                  uint64_t v165 = (long long *)(v145 + 16);
                  uint64_t v166 = &v155[v162 + 16];
                  uint64_t v167 = v163 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    long long v168 = *v165;
                    *((_OWORD *)v166 - 1) = *(v165 - 1);
                    *(_OWORD *)uint64_t v166 = v168;
                    v165 += 2;
                    v166 += 32;
                    v167 -= 4;
                  }
                  while (v167);
                  if (v163 != (v163 & 0x3FFFFFFFFFFFFFFCLL))
                  {
                    v145 += v164;
                    goto LABEL_199;
                  }
                }
                else
                {
                  float v161 = &v155[8 * (v154 >> 2)];
                  do
                  {
LABEL_199:
                    uint64_t v169 = *(void *)v145;
                    v145 += 8;
                    *(void *)float v161 = v169;
                    v161 += 8;
                  }
                  while (v161 != v7);
                }
              }
              uint64_t v146 = &v155[8 * v154];
              double v145 = v158;
              if (__pc) {
                operator delete(__pc);
              }
              __pc = v156;
              goto LABEL_178;
            }
            uint64_t v149 = (v145 - __pc) >> 3;
            if (v149 >= -1) {
              uint64_t v150 = v149 + 1;
            }
            else {
              uint64_t v150 = v149 + 2;
            }
            uint64_t v151 = v150 >> 1;
            long double v152 = &v145[-8 * (v150 >> 1)];
            double v153 = v147;
            if (v147 != v145)
            {
              memmove(v152, v145, v147 - v145);
              double v153 = v145;
            }
            uint64_t v7 = &v152[v147 - v145];
            double v145 = &v153[-8 * v151];
            uint64_t v146 = v147;
          }
LABEL_178:
          *(void *)uint64_t v7 = v148;
          v7 += 8;
          if (!--v37)
          {
            float v170 = (void *)this[3].i64[1];
            if (!v36)
            {
              unint64_t v171 = v145;
LABEL_205:
              uint64_t v172 = (void *)this[4].i64[0];
              if (v172 != v170)
              {
                BOOL v173 = __pc;
                while (1)
                {
                  if (v171 == v173)
                  {
                    if (v7 < v146)
                    {
                      uint64_t v196 = (v146 - v7) >> 3;
                      if (v196 >= -1) {
                        uint64_t v197 = v196 + 1;
                      }
                      else {
                        uint64_t v197 = v196 + 2;
                      }
                      uint64_t v198 = v197 >> 1;
                      unint64_t v171 = &v173[8 * (v197 >> 1)];
                      __float2 v199 = v173;
                      if (v7 != v173)
                      {
                        memmove(v171, v173, v7 - v173);
                        __float2 v199 = v7;
                      }
                      uint64_t v7 = &v199[8 * v198];
                      goto LABEL_235;
                    }
                    __pd = v173;
                    if (v146 == v173) {
                      unint64_t v200 = 1;
                    }
                    else {
                      unint64_t v200 = (v146 - v173) >> 2;
                    }
                    if (v200 >> 61) {
                      goto LABEL_524;
                    }
                    BOOL v173 = (char *)operator new(8 * v200);
                    unint64_t v201 = (v200 + 3) >> 2;
                    unint64_t v171 = &v173[8 * v201];
                    uint64_t v146 = &v173[8 * v200];
                    BOOL v202 = __pd;
                    int64_t v203 = v7 - __pd;
                    BOOL v58 = v7 == __pd;
                    uint64_t v7 = v171;
                    if (!v58)
                    {
                      uint64_t v7 = &v171[v203 & 0xFFFFFFFFFFFFFFF8];
                      unint64_t v204 = v203 - 8;
                      double v205 = &v173[8 * v201];
                      double v206 = __pd;
                      if (v204 >= 0x38)
                      {
                        uint64_t v207 = 8 * v201;
                        double v205 = &v173[8 * v201];
                        double v206 = __pd;
                        if ((unint64_t)(v205 - __pd) >= 0x20)
                        {
                          uint64_t v208 = (v204 >> 3) + 1;
                          uint64_t v209 = 8 * (v208 & 0x3FFFFFFFFFFFFFFCLL);
                          double v205 = &v171[v209];
                          float64x2_t v210 = (long long *)(__pd + 16);
                          double v211 = &v173[v207 + 16];
                          uint64_t v212 = v208 & 0x3FFFFFFFFFFFFFFCLL;
                          do
                          {
                            long long v213 = *v210;
                            *((_OWORD *)v211 - 1) = *(v210 - 1);
                            *(_OWORD *)double v211 = v213;
                            v210 += 2;
                            v211 += 32;
                            v212 -= 4;
                          }
                          while (v212);
                          if (v208 == (v208 & 0x3FFFFFFFFFFFFFFCLL))
                          {
                            BOOL v202 = __pd;
LABEL_258:
                            operator delete(v202);
                            goto LABEL_235;
                          }
                          double v206 = &__pd[v209];
                        }
                      }
                      do
                      {
                        uint64_t v214 = *(void *)v206;
                        v206 += 8;
                        *(void *)double v205 = v214;
                        v205 += 8;
                      }
                      while (v205 != v7);
                      BOOL v202 = __pd;
                    }
                    if (v202) {
                      goto LABEL_258;
                    }
                  }
LABEL_235:
                  uint64_t v195 = *--v172;
                  *((void *)v171 - 1) = v195;
                  v171 -= 8;
                  if (v172 == (void *)this[3].i64[1]) {
                    goto LABEL_373;
                  }
                }
              }
              BOOL v173 = __pc;
LABEL_373:
              double v286 = (void *)this[3].i64[0];
              this[3].i64[0] = (uint64_t)v173;
              this[3].i64[1] = (uint64_t)v171;
              this[4].i64[0] = (uint64_t)v7;
              this[4].i64[1] = (uint64_t)v146;
              this[5].i64[0] -= v387;
              if (v286)
              {
                operator delete(v286);
                uint64_t v7 = (char *)this[4].i64[0];
              }
LABEL_383:
              uint64_t v3 = this[5].i64[1];
              uint8x8_t v6 = (char *)this[3].i64[1];
              unint64_t v4 = this[5].i64[0] + v3;
              unint64_t v5 = v4 >> 8;
              unint64_t v15 = v393;
              unint64_t v11 = v397;
              unint64_t v12 = v390;
              goto LABEL_384;
            }
            while (2)
            {
              if (v7 != v146)
              {
                unint64_t v171 = v145;
                goto LABEL_208;
              }
              if (v145 > __pc)
              {
                uint64_t v174 = (v145 - __pc) >> 3;
                if (v174 >= -1) {
                  uint64_t v175 = v174 + 1;
                }
                else {
                  uint64_t v175 = v174 + 2;
                }
                uint64_t v176 = v175 >> 1;
                float v177 = &v145[-8 * (v175 >> 1)];
                float v178 = v146;
                if (v146 != v145)
                {
                  memmove(v177, v145, v146 - v145);
                  float v178 = v145;
                }
                uint64_t v179 = -v176;
                uint64_t v7 = &v177[v146 - v145];
                unint64_t v171 = &v178[8 * v179];
LABEL_208:
                *(void *)uint64_t v7 = *v170;
                v7 += 8;
                float v170 = (void *)(this[3].i64[1] + 8);
                this[3].i64[1] = (uint64_t)v170;
                double v145 = v171;
                if (!--v36) {
                  goto LABEL_205;
                }
                continue;
              }
              break;
            }
            if (v146 == __pc) {
              unint64_t v180 = 1;
            }
            else {
              unint64_t v180 = (v146 - __pc) >> 2;
            }
            if (v180 >> 61) {
              goto LABEL_524;
            }
            float v181 = (char *)operator new(8 * v180);
            unint64_t v182 = v180 >> 2;
            unint64_t v171 = &v181[8 * (v180 >> 2)];
            uint64_t v7 = v171;
            int64_t v183 = v146 - v145;
            if (v146 != v145)
            {
              uint64_t v7 = &v171[v183 & 0xFFFFFFFFFFFFFFF8];
              unint64_t v184 = v183 - 8;
              if (v184 >= 0x38)
              {
                uint64_t v186 = 8 * v182;
                if ((unint64_t)(&v181[8 * v182] - v145) < 0x20)
                {
                  double v185 = &v181[8 * (v180 >> 2)];
                  goto LABEL_230;
                }
                uint64_t v187 = (v184 >> 3) + 1;
                uint64_t v188 = 8 * (v187 & 0x3FFFFFFFFFFFFFFCLL);
                double v185 = &v171[v188];
                float v189 = (long long *)(v145 + 16);
                float v190 = &v181[v186 + 16];
                uint64_t v191 = v187 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v192 = *v189;
                  *((_OWORD *)v190 - 1) = *(v189 - 1);
                  *(_OWORD *)float v190 = v192;
                  v189 += 2;
                  v190 += 32;
                  v191 -= 4;
                }
                while (v191);
                if (v187 != (v187 & 0x3FFFFFFFFFFFFFFCLL))
                {
                  v145 += v188;
                  goto LABEL_230;
                }
              }
              else
              {
                double v185 = &v181[8 * (v180 >> 2)];
                do
                {
LABEL_230:
                  uint64_t v193 = *(void *)v145;
                  v145 += 8;
                  *(void *)double v185 = v193;
                  v185 += 8;
                }
                while (v185 != v7);
              }
            }
            uint64_t v146 = &v181[8 * v180];
            if (__pc)
            {
              int v194 = v181;
              operator delete(__pc);
              __pc = v194;
            }
            else
            {
              __pc = v181;
            }
            goto LABEL_208;
          }
        }
      }
      if (v37)
      {
        while (this[4].i64[1] != this[4].i64[0])
        {
          unint64_t v408 = operator new(0x1000uLL);
          std::__split_buffer<geo::QuadTile *>::push_back((char **)&this[3], &v408);
          if (!--v37)
          {
            uint64_t v7 = (char *)this[4].i64[0];
            goto LABEL_381;
          }
        }
        for (uint64_t i = 0; i != v37; ++i)
        {
          unint64_t v408 = operator new(0x1000uLL);
          std::__split_buffer<geo::QuadTile *>::push_front((void **)&this[3], &v408);
          uint64_t v7 = (char *)this[4].i64[0];
          if (&v7[-this[3].i64[1]] == (char *)8) {
            uint64_t v288 = 255;
          }
          else {
            uint64_t v288 = 256;
          }
          uint64_t v289 = v288 + this[5].i64[0];
          this[5].i64[0] = v289;
        }
        v36 += v37;
      }
      else
      {
LABEL_381:
        uint64_t v289 = this[5].i64[0];
      }
      this[5].i64[0] = v289 - (v36 << 8);
      if (!v36) {
        goto LABEL_383;
      }
      while (1)
      {
        float v293 = (void *)this[3].i64[1];
        float v295 = (char *)(v293 + 1);
        uint64_t v294 = *v293;
        this[3].i64[1] = (uint64_t)(v293 + 1);
        if (v7 == (char *)this[4].i64[1])
        {
          __float2 v296 = (char *)*v16;
          if (v295 <= *v16)
          {
            unint64_t v302 = (v7 - v296) >> 2;
            if (v7 == v296) {
              unint64_t v302 = 1;
            }
            if (v302 >> 61) {
              goto LABEL_524;
            }
            unint64_t v303 = v302 >> 2;
            __pf = (char *)(8 * v302);
            uint64_t v304 = (uint64_t)operator new(8 * v302);
            double v305 = (char *)(v304 + 8 * v303);
            int64_t v306 = v7 - v295;
            BOOL v58 = v7 == v295;
            uint64_t v7 = v305;
            if (!v58)
            {
              uint64_t v7 = &v305[v306 & 0xFFFFFFFFFFFFFFF8];
              unint64_t v307 = v306 - 8;
              if ((unint64_t)(v306 - 8) >= 0x38)
              {
                double v308 = (char *)(v304 + 8 * v303);
                if ((unint64_t)(v308 - v295) < 0x20) {
                  goto LABEL_406;
                }
                uint64_t v309 = (v307 >> 3) + 1;
                uint64_t v310 = 8 * (v309 & 0x3FFFFFFFFFFFFFFCLL);
                double v308 = &v305[v310];
                double v311 = (long long *)(v293 + 3);
                double v312 = (char *)(v304 + 8 * v303 + 16);
                uint64_t v313 = v309 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v314 = *v311;
                  *((_OWORD *)v312 - 1) = *(v311 - 1);
                  *(_OWORD *)double v312 = v314;
                  v311 += 2;
                  v312 += 32;
                  v313 -= 4;
                }
                while (v313);
                if (v309 != (v309 & 0x3FFFFFFFFFFFFFFCLL))
                {
                  v295 += v310;
                  goto LABEL_406;
                }
              }
              else
              {
                double v308 = (char *)(v304 + 8 * v303);
                do
                {
LABEL_406:
                  uint64_t v315 = *(void *)v295;
                  v295 += 8;
                  *(void *)double v308 = v315;
                  v308 += 8;
                }
                while (v308 != v7);
              }
            }
            this[3].i64[0] = v304;
            this[3].i64[1] = (uint64_t)v305;
            this[4].i64[0] = (uint64_t)v7;
            this[4].i64[1] = (uint64_t)&__pf[v304];
            if (v296)
            {
              operator delete(v296);
              uint64_t v7 = (char *)this[4].i64[0];
            }
            goto LABEL_387;
          }
          uint64_t v297 = (v295 - (unsigned char *)*v16) >> 3;
          if (v297 >= -1) {
            uint64_t v298 = v297 + 1;
          }
          else {
            uint64_t v298 = v297 + 2;
          }
          uint64_t v299 = v298 >> 1;
          float v300 = &v295[-8 * (v298 >> 1)];
          int64_t v301 = v7 - v295;
          if (v7 != v295)
          {
            memmove(&v295[-8 * (v298 >> 1)], v295, v7 - v295);
            uint64_t v7 = (char *)this[3].i64[1];
          }
          __double2 v292 = &v7[-8 * v299];
          uint64_t v7 = &v300[v301];
          this[3].i64[1] = (uint64_t)v292;
          this[4].i64[0] = (uint64_t)&v300[v301];
        }
LABEL_387:
        *(void *)uint64_t v7 = v294;
        uint64_t v7 = (char *)(this[4].i64[0] + 8);
        this[4].i64[0] = (uint64_t)v7;
        if (!--v36) {
          goto LABEL_383;
        }
      }
    }
    this[5].i64[0] = v2 - (v36 << 8);
    if (!v36) {
      goto LABEL_383;
    }
    while (1)
    {
      uint64_t v45 = (void *)this[3].i64[1];
      uint64_t v47 = (char *)(v45 + 1);
      uint64_t v46 = *v45;
      this[3].i64[1] = (uint64_t)(v45 + 1);
      if (v7 == (char *)this[4].i64[1])
      {
        uint64_t v48 = (char *)*v16;
        if (v47 <= *v16)
        {
          unint64_t v54 = (v7 - v48) >> 2;
          if (v7 == v48) {
            unint64_t v54 = 1;
          }
          if (v54 >> 61) {
            goto LABEL_524;
          }
          unint64_t v55 = v54 >> 2;
          __p = (char *)(8 * v54);
          uint64_t v56 = (uint64_t)operator new(8 * v54);
          uint64_t v57 = (char *)(v56 + 8 * v55);
          int64_t v59 = v7 - v47;
          BOOL v58 = v7 == v47;
          uint64_t v7 = v57;
          if (!v58)
          {
            uint64_t v7 = &v57[v59 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v60 = v59 - 8;
            if ((unint64_t)(v59 - 8) >= 0x38)
            {
              unint64_t v61 = (char *)(v56 + 8 * v55);
              if ((unint64_t)(v61 - v47) < 0x20) {
                goto LABEL_70;
              }
              uint64_t v62 = (v60 >> 3) + 1;
              uint64_t v63 = 8 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v61 = &v57[v63];
              unint64_t v64 = (long long *)(v45 + 3);
              uint64_t v65 = (char *)(v56 + 8 * v55 + 16);
              uint64_t v66 = v62 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v67 = *v64;
                *((_OWORD *)v65 - 1) = *(v64 - 1);
                *(_OWORD *)uint64_t v65 = v67;
                v64 += 2;
                v65 += 32;
                v66 -= 4;
              }
              while (v66);
              if (v62 != (v62 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v47 += v63;
                goto LABEL_70;
              }
            }
            else
            {
              unint64_t v61 = (char *)(v56 + 8 * v55);
              do
              {
LABEL_70:
                uint64_t v68 = *(void *)v47;
                v47 += 8;
                *(void *)unint64_t v61 = v68;
                v61 += 8;
              }
              while (v61 != v7);
            }
          }
          this[3].i64[0] = v56;
          this[3].i64[1] = (uint64_t)v57;
          this[4].i64[0] = (uint64_t)v7;
          this[4].i64[1] = (uint64_t)&__p[v56];
          if (v48)
          {
            operator delete(v48);
            uint64_t v7 = (char *)this[4].i64[0];
          }
          goto LABEL_51;
        }
        uint64_t v49 = (v47 - (unsigned char *)*v16) >> 3;
        if (v49 >= -1) {
          uint64_t v50 = v49 + 1;
        }
        else {
          uint64_t v50 = v49 + 2;
        }
        uint64_t v51 = v50 >> 1;
        uint64_t v52 = &v47[-8 * (v50 >> 1)];
        int64_t v53 = v7 - v47;
        if (v7 != v47)
        {
          memmove(&v47[-8 * (v50 >> 1)], v47, v7 - v47);
          uint64_t v7 = (char *)this[3].i64[1];
        }
        uint64_t v44 = &v7[-8 * v51];
        uint64_t v7 = &v52[v53];
        this[3].i64[1] = (uint64_t)v44;
        this[4].i64[0] = (uint64_t)&v52[v53];
      }
LABEL_51:
      *(void *)uint64_t v7 = v46;
      uint64_t v7 = (char *)(this[4].i64[0] + 8);
      this[4].i64[0] = (uint64_t)v7;
      if (!--v36) {
        goto LABEL_383;
      }
    }
  }
  unint64_t v17 = v12 - v2;
  if (v12 <= v2) {
    goto LABEL_263;
  }
  uint64_t v18 = 32 * v9 - 1;
  if (v7 == v6)
  {
    uint64_t v18 = 0;
    ++v17;
  }
  if ((_BYTE)v17) {
    unint64_t v19 = (v17 >> 8) + 1;
  }
  else {
    unint64_t v19 = v17 >> 8;
  }
  unint64_t v20 = (v18 - v4) >> 8;
  if (v19 >= v20) {
    unint64_t v21 = v20;
  }
  else {
    unint64_t v21 = v19;
  }
  if (v19 <= v20)
  {
    for (this[5].i64[0] = v2 + (v21 << 8); v21; --v21)
    {
      uint64_t v43 = this[4].i64[0];
      unint64_t v408 = *(void **)(v43 - 8);
      this[4].i64[0] = v43 - 8;
      std::__split_buffer<geo::QuadTile *>::push_front((void **)&this[3], &v408);
    }
    goto LABEL_262;
  }
  unint64_t v22 = v19 - v21;
  uint64_t v23 = (char *)this[3].i64[0];
  uint64_t v24 = this[4].i64[1] - (void)v23;
  uint64_t v25 = (v7 - v6) >> 3;
  if (v19 - v21 <= (v24 >> 3) - v25)
  {
    if (v22)
    {
      if (v6 == v23)
      {
LABEL_80:
        unint64_t v71 = v22;
        do
        {
          unint64_t v408 = operator new(0x1000uLL);
          std::__split_buffer<geo::QuadTile *>::push_back((char **)&this[3], &v408);
          --v71;
        }
        while (v71);
        v21 += v22;
        unint64_t v2 = this[5].u64[0];
      }
      else
      {
        while (1)
        {
          unint64_t v408 = operator new(0x1000uLL);
          std::__split_buffer<geo::QuadTile *>::push_front((void **)&this[3], &v408);
          uint64_t v69 = (void *)this[3].i64[1];
          uint64_t v70 = this[4].i64[0] - (void)v69 == 8 ? 255 : 256;
          unint64_t v2 = v70 + this[5].i64[0];
          this[5].i64[0] = v2;
          if (!--v22) {
            break;
          }
          if (v69 == *v16) {
            goto LABEL_80;
          }
        }
      }
    }
    for (this[5].i64[0] = v2 + (v21 << 8); v21; --v21)
    {
      uint64_t v72 = this[4].i64[0];
      unint64_t v408 = *(void **)(v72 - 8);
      this[4].i64[0] = v72 - 8;
      std::__split_buffer<geo::QuadTile *>::push_front((void **)&this[3], &v408);
    }
    goto LABEL_262;
  }
  unint64_t v389 = v12;
  BOOL v26 = v7 == v6;
  if (v24 >> 2 <= v22 + v25) {
    unint64_t v27 = v22 + v25;
  }
  else {
    unint64_t v27 = v24 >> 2;
  }
  if (!v27)
  {
    uint64_t v28 = 0;
    goto LABEL_91;
  }
  if (v27 >> 61) {
LABEL_524:
  }
    std::__throw_bad_array_new_length[abi:nn180100]();
  uint64_t v28 = (char *)operator new(8 * v27);
LABEL_91:
  unint64_t v386 = (v19 << 8) - v26;
  unint64_t v73 = &v28[8 * v27];
  unint64_t v74 = v28;
  __pa = v28;
  uint64_t v75 = v28;
  unint64_t v394 = v15;
  do
  {
    unint64_t v76 = operator new(0x1000uLL);
    if (v75 != v73) {
      goto LABEL_93;
    }
    if (v74 <= __pa)
    {
      if (v73 == __pa) {
        unint64_t v82 = 1;
      }
      else {
        unint64_t v82 = (v73 - __pa) >> 2;
      }
      if (v82 >> 61) {
        goto LABEL_524;
      }
      uint64_t v83 = (char *)operator new(8 * v82);
      unint64_t v84 = v82 >> 2;
      unint64_t v85 = &v83[8 * (v82 >> 2)];
      uint64_t v75 = v85;
      int64_t v86 = v73 - v74;
      if (v73 == v74) {
        goto LABEL_115;
      }
      uint64_t v75 = &v85[v86 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v87 = v86 - 8;
      if (v87 >= 0x38)
      {
        uint64_t v89 = 8 * v84;
        if ((unint64_t)(&v83[8 * v84] - v74) >= 0x20)
        {
          uint64_t v90 = (v87 >> 3) + 1;
          uint64_t v91 = 8 * (v90 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v88 = &v85[v91];
          BOOL v92 = (long long *)(v74 + 16);
          uint64_t v93 = &v83[v89 + 16];
          uint64_t v94 = v90 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v95 = *v92;
            *((_OWORD *)v93 - 1) = *(v92 - 1);
            *(_OWORD *)uint64_t v93 = v95;
            v92 += 2;
            v93 += 32;
            v94 -= 4;
          }
          while (v94);
          if (v90 == (v90 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_115;
          }
          v74 += v91;
        }
        else
        {
          uint64_t v88 = &v83[8 * (v82 >> 2)];
        }
      }
      else
      {
        uint64_t v88 = &v83[8 * (v82 >> 2)];
      }
      do
      {
        uint64_t v96 = *(void *)v74;
        v74 += 8;
        *(void *)uint64_t v88 = v96;
        v88 += 8;
      }
      while (v88 != v75);
LABEL_115:
      unint64_t v73 = &v83[8 * v82];
      if (__pa)
      {
        int v97 = v83;
        unint64_t v74 = v85;
        operator delete(__pa);
        __pa = v97;
      }
      else
      {
        unint64_t v74 = v85;
        __pa = v83;
      }
      goto LABEL_93;
    }
    uint64_t v77 = (v74 - __pa) >> 3;
    if (v77 >= -1) {
      uint64_t v78 = v77 + 1;
    }
    else {
      uint64_t v78 = v77 + 2;
    }
    uint64_t v79 = v78 >> 1;
    uint64_t v80 = &v74[-8 * (v78 >> 1)];
    uint64_t v81 = v73;
    if (v73 != v74)
    {
      memmove(v80, v74, v73 - v74);
      uint64_t v81 = v74;
    }
    uint64_t v75 = &v80[v73 - v74];
    unint64_t v74 = &v81[-8 * v79];
    unint64_t v15 = v394;
LABEL_93:
    *(void *)uint64_t v75 = v76;
    v75 += 8;
    --v22;
  }
  while (v22);
  uint64_t v98 = this[4].i64[0];
  if (v21)
  {
    while (v75 != v73)
    {
      unint64_t v99 = v74;
LABEL_123:
      *(void *)uint64_t v75 = *(void *)(v98 - 8);
      v75 += 8;
      uint64_t v98 = this[4].i64[0] - 8;
      this[4].i64[0] = v98;
      unint64_t v74 = v99;
      if (!--v21) {
        goto LABEL_120;
      }
    }
    if (v74 > __pa)
    {
      uint64_t v102 = (v74 - __pa) >> 3;
      if (v102 >= -1) {
        uint64_t v103 = v102 + 1;
      }
      else {
        uint64_t v103 = v102 + 2;
      }
      uint64_t v104 = v103 >> 1;
      unint64_t v105 = &v74[-8 * (v103 >> 1)];
      uint64_t v106 = v73;
      if (v73 != v74)
      {
        memmove(v105, v74, v73 - v74);
        uint64_t v106 = v74;
      }
      uint64_t v107 = -v104;
      uint64_t v75 = &v105[v73 - v74];
      unint64_t v99 = &v106[8 * v107];
      goto LABEL_123;
    }
    if (v73 == __pa) {
      unint64_t v108 = 1;
    }
    else {
      unint64_t v108 = (v73 - __pa) >> 2;
    }
    if (v108 >> 61) {
      goto LABEL_524;
    }
    uint64_t v109 = (char *)operator new(8 * v108);
    unint64_t v110 = v108 >> 2;
    unint64_t v99 = &v109[8 * (v108 >> 2)];
    uint64_t v75 = v99;
    int64_t v111 = v73 - v74;
    if (v73 != v74)
    {
      uint64_t v75 = &v99[v111 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v112 = v111 - 8;
      if (v112 >= 0x38)
      {
        uint64_t v114 = 8 * v110;
        if ((unint64_t)(&v109[8 * v110] - v74) >= 0x20)
        {
          uint64_t v115 = (v112 >> 3) + 1;
          uint64_t v116 = 8 * (v115 & 0x3FFFFFFFFFFFFFFCLL);
          double v113 = &v99[v116];
          float32_t v117 = (long long *)(v74 + 16);
          id v118 = &v109[v114 + 16];
          uint64_t v119 = v115 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v120 = *v117;
            *((_OWORD *)v118 - 1) = *(v117 - 1);
            *(_OWORD *)id v118 = v120;
            v117 += 2;
            v118 += 32;
            v119 -= 4;
          }
          while (v119);
          if (v115 == (v115 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_146;
          }
          v74 += v116;
        }
        else
        {
          double v113 = &v109[8 * (v108 >> 2)];
        }
      }
      else
      {
        double v113 = &v109[8 * (v108 >> 2)];
      }
      do
      {
        uint64_t v121 = *(void *)v74;
        v74 += 8;
        *(void *)double v113 = v121;
        v113 += 8;
      }
      while (v113 != v75);
    }
LABEL_146:
    unint64_t v73 = &v109[8 * v108];
    if (__pa)
    {
      int32x2_t v122 = v109;
      operator delete(__pa);
      __pa = v122;
    }
    else
    {
      __pa = v109;
    }
    goto LABEL_123;
  }
  unint64_t v99 = v74;
LABEL_120:
  unint64_t v100 = (uint64_t *)this[3].i64[1];
  if (v100 != (uint64_t *)v98)
  {
    int8x8_t v101 = __pa;
    while (1)
    {
      if (v75 == v73)
      {
        if (v99 <= v101)
        {
          __pb = v101;
          if (v73 == v101) {
            unint64_t v131 = 1;
          }
          else {
            unint64_t v131 = (v73 - v101) >> 2;
          }
          if (v131 >> 61) {
            goto LABEL_524;
          }
          float v132 = (char *)operator new(8 * v131);
          int8x8_t v101 = v132;
          unint64_t v133 = v131 >> 2;
          BOOL v123 = &v132[8 * (v131 >> 2)];
          uint64_t v75 = v123;
          int64_t v134 = v73 - v99;
          if (v73 != v99)
          {
            uint64_t v75 = &v123[v134 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v135 = v134 - 8;
            if (v135 >= 0x38)
            {
              uint64_t v137 = 8 * v133;
              if ((unint64_t)(&v132[8 * v133] - v99) < 0x20)
              {
                float v136 = &v132[8 * (v131 >> 2)];
                goto LABEL_172;
              }
              uint64_t v138 = (v135 >> 3) + 1;
              uint64_t v139 = 8 * (v138 & 0x3FFFFFFFFFFFFFFCLL);
              float v136 = &v123[v139];
              int v140 = (long long *)(v99 + 16);
              int v141 = &v132[v137 + 16];
              uint64_t v142 = v138 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v143 = *v140;
                *((_OWORD *)v141 - 1) = *(v140 - 1);
                *(_OWORD *)int v141 = v143;
                v140 += 2;
                v141 += 32;
                v142 -= 4;
              }
              while (v142);
              if (v138 != (v138 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v99 += v139;
                goto LABEL_172;
              }
            }
            else
            {
              float v136 = &v132[8 * (v131 >> 2)];
              do
              {
LABEL_172:
                uint64_t v144 = *(void *)v99;
                v99 += 8;
                *(void *)float v136 = v144;
                v136 += 8;
              }
              while (v136 != v75);
            }
          }
          unint64_t v73 = &v132[8 * v131];
          if (__pb) {
            operator delete(__pb);
          }
          goto LABEL_150;
        }
        int8x16_t v125 = v101;
        uint64_t v126 = (v99 - v101) >> 3;
        if (v126 >= -1) {
          uint64_t v127 = v126 + 1;
        }
        else {
          uint64_t v127 = v126 + 2;
        }
        uint64_t v128 = v127 >> 1;
        float v129 = &v99[-8 * (v127 >> 1)];
        float v130 = v73;
        if (v73 != v99)
        {
          memmove(v129, v99, v73 - v99);
          float v130 = v99;
        }
        uint64_t v75 = &v129[v73 - v99];
        BOOL v123 = &v130[-8 * v128];
        int8x8_t v101 = v125;
        unint64_t v15 = v394;
      }
      else
      {
        BOOL v123 = v99;
      }
LABEL_150:
      uint64_t v124 = *v100++;
      *(void *)uint64_t v75 = v124;
      v75 += 8;
      unint64_t v99 = v123;
      if (v100 == (uint64_t *)this[4].i64[0]) {
        goto LABEL_260;
      }
    }
  }
  BOOL v123 = v99;
  int8x8_t v101 = __pa;
LABEL_260:
  int v215 = (void *)this[3].i64[0];
  this[3].i64[0] = (uint64_t)v101;
  this[3].i64[1] = (uint64_t)v123;
  this[4].i64[0] = (uint64_t)v75;
  this[4].i64[1] = (uint64_t)v73;
  unint64_t v12 = v389;
  this[5].i64[0] += v386;
  if (v215) {
    operator delete(v215);
  }
LABEL_262:
  unint64_t v2 = this[5].u64[0];
  uint8x8_t v6 = (char *)this[3].i64[1];
  uint64_t v7 = (char *)this[4].i64[0];
  unint64_t v13 = v2 >> 8;
  unint64_t v11 = v397;
LABEL_263:
  float v216 = &v6[8 * v13];
  if (v7 != v6)
  {
    uint64_t v217 = *(void *)v216 + 16 * v2;
    unint64_t v218 = v12 - v15;
    if (v12 > v15) {
      goto LABEL_265;
    }
LABEL_276:
    uint64_t v223 = v217;
    unint64_t v222 = v216;
    if (!v12) {
      goto LABEL_517;
    }
LABEL_281:
    uint64_t v228 = v12 + ((v217 - *(void *)v216) >> 4);
    if (v228 < 1)
    {
      unint64_t v231 = 255 - v228;
      unint64_t v229 = &v216[-8 * (v231 >> 8)];
      uint64_t v230 = *(void *)v229 + 16 * ~(_BYTE)v231;
      if (v230 == v217) {
        goto LABEL_291;
      }
    }
    else
    {
      unint64_t v229 = &v216[8 * ((unint64_t)v228 >> 8)];
      uint64_t v230 = *(void *)v229 + 16 * v228;
      if (v230 == v217) {
        goto LABEL_291;
      }
    }
    uint64_t v232 = v229;
    unint64_t v233 = (void *)v230;
    do
    {
      if (v223 == *(void *)v222)
      {
        uint64_t v235 = *((void *)v222 - 1);
        v222 -= 8;
        uint64_t v223 = v235 + 4096;
      }
      if (v233 == *(void **)v232)
      {
        uint64_t v236 = *((void *)v232 - 1);
        v232 -= 8;
        unint64_t v233 = (void *)(v236 + 4096);
      }
      long long v234 = *((_OWORD *)v233 - 1);
      v233 -= 2;
      *(_OWORD *)(v223 - 16) = v234;
      v223 -= 16;
      void *v233 = 0;
      v233[1] = 0;
      this[5] = vaddq_s64(this[5], (int64x2_t)xmmword_1A28FE980);
    }
    while (v233 != (void *)v217);
LABEL_291:
    if (v12 < v15)
    {
      uint64_t v237 = *(void *)v216;
      uint64_t v238 = v15 + ((v217 - *(void *)v216) >> 4);
      if (v238 < 1)
      {
        unint64_t v241 = 255 - v238;
        unint64_t v239 = &v216[-8 * (v241 >> 8)];
        uint64_t v240 = *(void *)v239 + 16 * ~(_BYTE)v241;
      }
      else
      {
        unint64_t v239 = &v216[8 * ((unint64_t)v238 >> 8)];
        uint64_t v240 = *(void *)v239 + 16 * v238;
      }
      uint64_t v395 = v240;
      if (v229 == v239)
      {
        if (v230 != v240)
        {
          while (1)
          {
            uint64_t v272 = (v237 - v217 + 4096) >> 4;
            if ((v395 - v230) >> 4 < v272) {
              uint64_t v272 = (v395 - v230) >> 4;
            }
            if (v272)
            {
              uint64_t v273 = 16 * v272;
              uint64_t v274 = v230 + 16 * v272;
              do
              {
                long long v275 = *(_OWORD *)v230;
                *(void *)uint64_t v230 = 0;
                *(void *)(v230 + 8) = 0;
                unint64_t v276 = *(std::__shared_weak_count **)(v217 + 8);
                *(_OWORD *)uint64_t v217 = v275;
                if (v276 && !atomic_fetch_add(&v276->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v276->__on_zero_shared)(v276);
                  std::__shared_weak_count::__release_weak(v276);
                }
                v230 += 16;
                v217 += 16;
                v273 -= 16;
              }
              while (v273);
              uint64_t v230 = v274;
            }
            if (v230 == v395) {
              break;
            }
            uint64_t v277 = *((void *)v216 + 1);
            v216 += 8;
            uint64_t v237 = v277;
            uint64_t v217 = v277;
          }
LABEL_355:
          if (*(void *)v216 + 4096 == v217)
          {
            uint64_t v278 = *((void *)v216 + 1);
            v216 += 8;
            uint64_t v217 = v278;
          }
        }
      }
      else
      {
        uint64_t v242 = *(void *)v229 + 4096;
        uint64_t v388 = v239;
        if (v242 != v230)
        {
          while (1)
          {
            uint64_t v243 = (v237 - v217 + 4096) >> 4;
            if ((v242 - v230) >> 4 < v243) {
              uint64_t v243 = (v242 - v230) >> 4;
            }
            if (v243)
            {
              uint64_t v244 = 16 * v243;
              uint64_t v245 = v230 + 16 * v243;
              do
              {
                long long v246 = *(_OWORD *)v230;
                *(void *)uint64_t v230 = 0;
                *(void *)(v230 + 8) = 0;
                unint64_t v247 = *(std::__shared_weak_count **)(v217 + 8);
                *(_OWORD *)uint64_t v217 = v246;
                if (v247 && !atomic_fetch_add(&v247->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v247->__on_zero_shared)(v247);
                  std::__shared_weak_count::__release_weak(v247);
                }
                v230 += 16;
                v217 += 16;
                v244 -= 16;
              }
              while (v244);
              uint64_t v230 = v245;
              unint64_t v11 = v397;
            }
            if (v230 == v242) {
              break;
            }
            uint64_t v248 = *((void *)v216 + 1);
            v216 += 8;
            uint64_t v237 = v248;
            uint64_t v217 = v248;
          }
          uint64_t v237 = *(void *)v216;
          if (*(void *)v216 + 4096 == v217)
          {
            uint64_t v249 = *((void *)v216 + 1);
            v216 += 8;
            uint64_t v237 = v249;
            uint64_t v217 = v249;
          }
          unint64_t v239 = v388;
        }
        unint64_t v250 = v229 + 8;
        if (v229 + 8 != v239)
        {
          do
          {
            uint64_t v251 = 0;
            float v391 = v250;
            __pe = (char *)*v250;
            while (1)
            {
              double v252 = &__pe[16 * v251];
              uint64_t v253 = (v237 - v217 + 4096) >> 4;
              if ((4096 - 16 * v251) >> 4 < v253) {
                uint64_t v253 = (4096 - 16 * v251) >> 4;
              }
              if (v253)
              {
                double v254 = v10;
                double v255 = v216;
                uint64_t v256 = 16 * v253;
                int8x8_t v257 = &__pe[16 * v251];
                uint8x8_t v258 = &v252[16 * v253];
                do
                {
                  long long v259 = *(_OWORD *)v257;
                  *(void *)int8x8_t v257 = 0;
                  *((void *)v257 + 1) = 0;
                  uint64_t v260 = *(std::__shared_weak_count **)(v217 + 8);
                  *(_OWORD *)uint64_t v217 = v259;
                  if (v260 && !atomic_fetch_add(&v260->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v260->__on_zero_shared)(v260);
                    std::__shared_weak_count::__release_weak(v260);
                  }
                  v257 += 16;
                  v217 += 16;
                  v256 -= 16;
                }
                while (v256);
                float v216 = v255;
                uint64_t v10 = v254;
              }
              else
              {
                uint8x8_t v258 = &__pe[16 * v251];
              }
              v251 += (v258 - v252) >> 4;
              if (v251 == 256) {
                break;
              }
              uint64_t v261 = *((void *)v216 + 1);
              v216 += 8;
              uint64_t v237 = v261;
              uint64_t v217 = v261;
            }
            uint64_t v237 = *(void *)v216;
            if (*(void *)v216 + 4096 == v217)
            {
              uint64_t v262 = *((void *)v216 + 1);
              v216 += 8;
              uint64_t v237 = v262;
              uint64_t v217 = v262;
            }
            unint64_t v239 = v388;
            unint64_t v250 = v391 + 1;
          }
          while (v391 + 1 != (void *)v388);
          unint64_t v11 = v397;
        }
        int v263 = *(long long **)v239;
        if (*(void *)v239 != v395)
        {
          uint64_t v264 = *(void *)v216;
          while (1)
          {
            uint64_t v265 = (v264 - v217 + 4096) >> 4;
            if ((v395 - (uint64_t)v263) >> 4 < v265) {
              uint64_t v265 = (v395 - (uint64_t)v263) >> 4;
            }
            if (v265)
            {
              unint64_t v266 = v216;
              uint64_t v267 = 16 * v265;
              uint64_t v268 = &v263[v265];
              do
              {
                long long v269 = *v263;
                *(void *)int v263 = 0;
                *((void *)v263 + 1) = 0;
                unint64_t v270 = *(std::__shared_weak_count **)(v217 + 8);
                *(_OWORD *)uint64_t v217 = v269;
                if (v270 && !atomic_fetch_add(&v270->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v270->__on_zero_shared)(v270);
                  std::__shared_weak_count::__release_weak(v270);
                }
                ++v263;
                v217 += 16;
                v267 -= 16;
              }
              while (v267);
              int v263 = v268;
              float v216 = v266;
            }
            if (v263 == (long long *)v395) {
              break;
            }
            uint64_t v271 = *((void *)v216 + 1);
            v216 += 8;
            uint64_t v264 = v271;
            uint64_t v217 = v271;
          }
          goto LABEL_355;
        }
      }
    }
    if (v10 != v11)
    {
      uint64_t v279 = *(void *)v216;
      while (1)
      {
        uint64_t v280 = (v279 - v217 + 4096) >> 4;
        if ((v11 - v10) >> 4 < v280) {
          uint64_t v280 = (v11 - v10) >> 4;
        }
        if (v280)
        {
          double v281 = &v10[16 * v280];
          do
          {
            uint64_t v283 = *(void *)v10;
            uint64_t v282 = *((void *)v10 + 1);
            if (v282) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v282 + 8), 1uLL, memory_order_relaxed);
            }
            long double v284 = *(std::__shared_weak_count **)(v217 + 8);
            *(void *)uint64_t v217 = v283;
            *(void *)(v217 + 8) = v282;
            if (v284 && !atomic_fetch_add(&v284->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v284->__on_zero_shared)(v284);
              std::__shared_weak_count::__release_weak(v284);
            }
            v10 += 16;
            v217 += 16;
          }
          while (v10 != v281);
          uint64_t v10 = v281;
        }
        if (v10 == v11) {
          break;
        }
        uint64_t v285 = *((void *)v216 + 1);
        v216 += 8;
        uint64_t v279 = v285;
        uint64_t v217 = v285;
      }
    }
    goto LABEL_517;
  }
  uint64_t v217 = 0;
  unint64_t v218 = v12 - v15;
  if (v12 <= v15) {
    goto LABEL_276;
  }
LABEL_265:
  int8x8_t v219 = &v10[16 * v218];
  if (v15 >= v12 >> 1) {
    uint8x8_t v220 = v219;
  }
  else {
    uint8x8_t v220 = &v11[-16 * v15];
  }
  if (v220 == v10)
  {
    uint64_t v223 = v217;
    unint64_t v222 = v216;
  }
  else
  {
    uint64_t v221 = v220;
    unint64_t v222 = v216;
    uint64_t v223 = v217;
    do
    {
      if (v223 == *(void *)v222)
      {
        uint64_t v225 = *((void *)v222 - 1);
        v222 -= 8;
        uint64_t v223 = v225 + 4096;
      }
      uint64_t v226 = *((void *)v221 - 2);
      v221 -= 16;
      *(void *)(v223 - 16) = v226;
      v223 -= 16;
      uint64_t v227 = *((void *)v221 + 1);
      *(void *)(v223 + 8) = v227;
      if (v227)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v227 + 8), 1uLL, memory_order_relaxed);
        unint64_t v2 = this[5].u64[0];
      }
      --v2;
      uint64_t v224 = this[5].i64[1] + 1;
      this[5].i64[0] = v2;
      this[5].i64[1] = v224;
    }
    while (v221 != v10);
    uint64_t v10 = v220;
  }
  unint64_t v12 = v15;
  if (v15) {
    goto LABEL_281;
  }
LABEL_517:
  uint64_t v381 = *v385;
  for (uint64_t j = v384->i64[0]; v381 != j; v381 -= 16)
  {
    uint64_t v383 = *(std::__shared_weak_count **)(v381 - 8);
    if (v383 && !atomic_fetch_add(&v383->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v383->__on_zero_shared)(v383);
      std::__shared_weak_count::__release_weak(v383);
    }
  }
  uint64_t *v385 = j;
}

void sub_1A1BF7E10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL md::SceneContext::isFinishedLoadingRequiredLayers(md::SceneContext *this)
{
  uint64_t v1 = (unsigned __int16 *)*((void *)this + 23);
  unint64_t v2 = (unsigned __int16 *)*((void *)this + 24);
  if (v1 == v2)
  {
LABEL_10:
    unint64_t v5 = (unsigned __int16 *)*((void *)this + 26);
    uint8x8_t v6 = (unsigned __int16 *)*((void *)this + 27);
    if (v5 == v6)
    {
      return 1;
    }
    else
    {
      uint64_t v7 = (unsigned __int16 *)*((void *)this + 14);
      uint64_t v8 = (unsigned __int16 *)*((void *)this + 15);
      do
      {
        unint64_t v12 = v7;
        if (v7 != v8)
        {
          unint64_t v12 = v7;
          while (*v12 != *v5)
          {
            v12 += 56;
            if (v12 == v8)
            {
              unint64_t v12 = v8;
              break;
            }
          }
        }
        int v9 = *((unsigned __int8 *)v12 + 8);
        BOOL result = v9 != 0;
        ++v5;
        if (v9) {
          BOOL v11 = v5 == v6;
        }
        else {
          BOOL v11 = 1;
        }
      }
      while (!v11);
    }
  }
  else
  {
    uint64_t v3 = (unsigned __int16 *)*((void *)this + 15);
    while (1)
    {
      unint64_t v4 = (unsigned __int16 *)*((void *)this + 14);
      if (v4 != v3)
      {
        unint64_t v4 = (unsigned __int16 *)*((void *)this + 14);
        while (*v4 != *v1)
        {
          v4 += 56;
          if (v4 == v3)
          {
            unint64_t v4 = (unsigned __int16 *)*((void *)this + 15);
            break;
          }
        }
      }
      if (!*((unsigned char *)v4 + 8)) {
        return 0;
      }
      if (++v1 == v2) {
        goto LABEL_10;
      }
    }
  }
  return result;
}

void md::FontTrackingCache::updateForDisplay(md::FontTrackingCache *this)
{
  if (*((unsigned char *)this + 124))
  {
    uint64_t v3 = (uint64_t *)*((void *)this + 4);
    if (v3)
    {
      unint64_t v4 = (void *)((char *)this + 64);
      uint64_t v49 = (uint64_t *)((char *)this + 88);
      uint64_t v50 = (char *)this + 64;
      while (1)
      {
        int v5 = *((char *)v3 + 39);
        if (v5 >= 0) {
          uint8x8_t v6 = v3 + 2;
        }
        else {
          uint8x8_t v6 = (uint64_t *)v3[2];
        }
        if (v5 >= 0) {
          unint64_t v7 = *((unsigned __int8 *)v3 + 39);
        }
        else {
          unint64_t v7 = v3[3];
        }
        unint64_t v8 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v6, v7);
        unint64_t v9 = v8;
        unint64_t v10 = *((void *)this + 9);
        if (v10)
        {
          uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
          v11.i16[0] = vaddlv_u8(v11);
          if (v11.u32[0] > 1uLL)
          {
            unint64_t v1 = v8;
            if (v8 >= v10) {
              unint64_t v1 = v8 % v10;
            }
          }
          else
          {
            unint64_t v1 = (v10 - 1) & v8;
          }
          unint64_t v12 = *(uint64_t ***)(*v4 + 8 * v1);
          if (v12)
          {
            unint64_t v13 = *v12;
            if (*v12)
            {
              if (v11.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v19 = v13[1];
                  if (v19 == v9)
                  {
                    uint64_t v20 = *((unsigned __int8 *)v13 + 39);
                    if ((v20 & 0x80u) == 0) {
                      uint64_t v21 = *((unsigned __int8 *)v13 + 39);
                    }
                    else {
                      uint64_t v21 = v13[3];
                    }
                    if (v21 == v7)
                    {
                      unint64_t v22 = (const void **)(v13 + 2);
                      if ((v20 & 0x80) != 0)
                      {
                        if (!memcmp(*v22, v6, v13[3])) {
                          goto LABEL_7;
                        }
                      }
                      else
                      {
                        if (!*((unsigned char *)v13 + 39)) {
                          goto LABEL_7;
                        }
                        uint64_t v23 = v6;
                        while (*(unsigned __int8 *)v22 == *(unsigned __int8 *)v23)
                        {
                          unint64_t v22 = (const void **)((char *)v22 + 1);
                          uint64_t v23 = (uint64_t *)((char *)v23 + 1);
                          if (!--v20) {
                            goto LABEL_7;
                          }
                        }
                      }
                    }
                  }
                  else if ((v19 & (v10 - 1)) != v1)
                  {
                    goto LABEL_55;
                  }
                  unint64_t v13 = (uint64_t *)*v13;
                  if (!v13) {
                    goto LABEL_55;
                  }
                }
              }
              do
              {
                unint64_t v14 = v13[1];
                if (v14 == v9)
                {
                  uint64_t v15 = *((unsigned __int8 *)v13 + 39);
                  if ((v15 & 0x80u) == 0) {
                    uint64_t v16 = *((unsigned __int8 *)v13 + 39);
                  }
                  else {
                    uint64_t v16 = v13[3];
                  }
                  if (v16 == v7)
                  {
                    unint64_t v17 = (const void **)(v13 + 2);
                    if ((v15 & 0x80) != 0)
                    {
                      if (!memcmp(*v17, v6, v13[3])) {
                        goto LABEL_7;
                      }
                    }
                    else
                    {
                      if (!*((unsigned char *)v13 + 39)) {
                        goto LABEL_7;
                      }
                      uint64_t v18 = v6;
                      while (*(unsigned __int8 *)v17 == *(unsigned __int8 *)v18)
                      {
                        unint64_t v17 = (const void **)((char *)v17 + 1);
                        uint64_t v18 = (uint64_t *)((char *)v18 + 1);
                        if (!--v15) {
                          goto LABEL_7;
                        }
                      }
                    }
                  }
                }
                else
                {
                  if (v14 >= v10) {
                    v14 %= v10;
                  }
                  if (v14 != v1) {
                    break;
                  }
                }
                unint64_t v13 = (uint64_t *)*v13;
              }
              while (v13);
            }
LABEL_55:
            unint64_t v4 = v50;
          }
        }
        uint64_t v24 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 12) + 16))(*((void *)this + 12), 176, 8);
        uint64_t v25 = v24;
        *(void *)uint64_t v24 = 0;
        *(void *)(v24 + 8) = v9;
        if (*((char *)v3 + 39) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)(v24 + 16), (const std::string::value_type *)v3[2], v3[3]);
        }
        else
        {
          long long v26 = *((_OWORD *)v3 + 1);
          *(void *)(v24 + 32) = v3[4];
          *(_OWORD *)(v24 + 16) = v26;
        }
        *(_OWORD *)(v25 + 40) = *(_OWORD *)(v3 + 5);
        long long v27 = *(_OWORD *)(v3 + 7);
        long long v28 = *(_OWORD *)(v3 + 9);
        long long v29 = *(_OWORD *)(v3 + 11);
        *(_OWORD *)(v25 + 104) = *(_OWORD *)(v3 + 13);
        *(_OWORD *)(v25 + 88) = v29;
        *(_OWORD *)(v25 + 72) = v28;
        *(_OWORD *)(v25 + 56) = v27;
        long long v30 = *(_OWORD *)(v3 + 15);
        long long v31 = *(_OWORD *)(v3 + 17);
        long long v32 = *(_OWORD *)(v3 + 19);
        *(void *)(v25 + 168) = v3[21];
        *(_OWORD *)(v25 + 152) = v32;
        *(_OWORD *)(v25 + 136) = v31;
        *(_OWORD *)(v25 + 120) = v30;
        float v33 = (float)(unint64_t)(*((void *)this + 13) + 1);
        float v34 = *((float *)this + 28);
        if (!v10 || (float)(v34 * (float)v10) < v33)
        {
          BOOL v35 = v10 < 3 || (v10 & (v10 - 1)) != 0;
          unint64_t v36 = v35 | (2 * v10);
          unint64_t v37 = vcvtps_u32_f32(v33 / v34);
          if (v36 <= v37) {
            size_t prime = v37;
          }
          else {
            size_t prime = v36;
          }
          if (prime == 1)
          {
            size_t prime = 2;
          }
          else if ((prime & (prime - 1)) != 0)
          {
            size_t prime = std::__next_prime(prime);
          }
          int8x8_t v39 = *(int8x8_t *)((char *)this + 72);
          if (prime > *(void *)&v39) {
            goto LABEL_72;
          }
          if (prime < *(void *)&v39)
          {
            unint64_t v40 = vcvtps_u32_f32((float)*((unint64_t *)this + 13) / *((float *)this + 28));
            if (*(void *)&v39 < 3uLL
              || (uint8x8_t v41 = (uint8x8_t)vcnt_s8(v39), v41.i16[0] = vaddlv_u8(v41), v41.u32[0] > 1uLL))
            {
              unint64_t v40 = std::__next_prime(v40);
            }
            else
            {
              uint64_t v42 = 1 << -(char)__clz(v40 - 1);
              if (v40 >= 2) {
                unint64_t v40 = v42;
              }
            }
            if (prime <= v40) {
              size_t prime = v40;
            }
            if (prime < *(void *)&v39) {
LABEL_72:
            }
              std::__hash_table<std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,std::__unordered_map_hasher<VKTrafficFeature * {__strong},std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,md::TrafficFeatureHash,std::equal_to<VKTrafficFeature * {__strong}>,true>,std::__unordered_map_equal<VKTrafficFeature * {__strong},std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,std::equal_to<VKTrafficFeature * {__strong}>,md::TrafficFeatureHash,true>,geo::StdAllocator<std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,mdm::Allocator>>::__do_rehash<true>((uint64_t)v4, prime);
          }
          unint64_t v10 = *((void *)this + 9);
          if ((v10 & (v10 - 1)) != 0)
          {
            if (v9 >= v10) {
              unint64_t v1 = v9 % v10;
            }
            else {
              unint64_t v1 = v9;
            }
          }
          else
          {
            unint64_t v1 = (v10 - 1) & v9;
          }
        }
        uint64_t v43 = *(uint64_t **)(*v4 + 8 * v1);
        if (v43) {
          break;
        }
        *(void *)uint64_t v25 = *v49;
        *uint64_t v49 = v25;
        *(void *)(*v4 + 8 * v1) = v49;
        if (*(void *)v25)
        {
          unint64_t v44 = *(void *)(*(void *)v25 + 8);
          if ((v10 & (v10 - 1)) != 0)
          {
            if (v44 >= v10) {
              v44 %= v10;
            }
          }
          else
          {
            v44 &= v10 - 1;
          }
          uint64_t v43 = (uint64_t *)(*v4 + 8 * v44);
          goto LABEL_5;
        }
LABEL_6:
        ++*((void *)this + 13);
LABEL_7:
        uint64_t v3 = (uint64_t *)*v3;
        unint64_t v4 = v50;
        if (!v3) {
          goto LABEL_95;
        }
      }
      *(void *)uint64_t v25 = *v43;
LABEL_5:
      *uint64_t v43 = v25;
      goto LABEL_6;
    }
LABEL_95:
    if (*((void *)this + 6))
    {
      uint64_t v45 = (uint64_t *)*((void *)this + 4);
      if (v45)
      {
        do
        {
          uint64_t v48 = (uint64_t *)*v45;
          if (*((char *)v45 + 39) < 0) {
            operator delete((void *)v45[2]);
          }
          (*(void (**)(void, uint64_t *, uint64_t))(**((void **)this + 5) + 40))(*((void *)this + 5), v45, 176);
          uint64_t v45 = v48;
        }
        while (v48);
      }
      *((void *)this + 4) = 0;
      uint64_t v46 = *((void *)this + 2);
      if (v46)
      {
        for (uint64_t i = 0; i != v46; ++i)
          *(void *)(*((void *)this + 1) + 8 * i) = 0;
      }
      *((void *)this + 6) = 0;
    }
    *((unsigned char *)this + 124) = 0;
  }
}

void sub_1A1BF8410(_Unwind_Exception *a1)
{
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 96) + 40))(*(void *)(v1 + 96), v2, 176);
  _Unwind_Resume(a1);
}

uint64_t md::CompositeLabeler::synchStagingWithDisplay(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 8);
  for (uint64_t i = *(uint64_t **)(this + 16); v1 != i; this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 48))(v3))
    uint64_t v3 = *v1++;
  return this;
}

void md::MapNavLabeler::synchStagingWithDisplay(md::MapNavLabeler *this)
{
  uint64_t v2 = *((void *)this + 78);
  for (uint64_t i = *((void *)this + 77); v2 != i; v2 -= 16)
  {
    unint64_t v4 = *(std::__shared_weak_count **)(v2 - 8);
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  *((void *)this + 78) = i;
  int v5 = (void (***)(void))*((void *)this + 82);
  uint8x8_t v6 = (void (***)(void))*((void *)this + 81);
  if (v5 != v6)
  {
    unint64_t v7 = v5 - 3;
    unint64_t v8 = v5 - 3;
    unint64_t v9 = v5 - 3;
    do
    {
      unint64_t v10 = *v9;
      v9 -= 3;
      (*v10)(v8);
      v7 -= 3;
      BOOL v11 = v8 == v6;
      unint64_t v8 = v9;
    }
    while (!v11);
  }
  *((void *)this + 82) = v6;
  if (*((void *)this + 13))
  {
    uint64_t v12 = *((void *)this + 86);
    if (*(void *)(v12 + 24))
    {
      unint64_t v13 = *(uint64_t **)(v12 + 184);
      unint64_t v14 = *(uint64_t **)(v12 + 192);
      if (v13 != v14)
      {
        do
        {
          uint64_t v15 = *v13;
          *(void *)&long long v103 = *v13;
          uint64_t v16 = (std::__shared_weak_count *)v13[1];
          *((void *)&v103 + 1) = v16;
          if (v16) {
            atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          *(_DWORD *)(v15 + 324) = *(_DWORD *)(v15 + 296);
          *(void *)(v15 + 328) = *(void *)(v15 + 300);
          if (*(unsigned char *)(v15 + 280))
          {
            *(_DWORD *)(v15 + 268) = *(_DWORD *)(v15 + 276);
            *(unsigned char *)(v15 + 280) = 0;
          }
          uint64_t v17 = *(void *)(v15 + 288);
          if (v17) {
            (*(void (**)(uint64_t))(*(void *)v17 + 968))(v17);
          }
          uint64_t v18 = (void *)*((void *)this + 78);
          if ((unint64_t)v18 >= *((void *)this + 79))
          {
            uint64_t v19 = std::vector<std::shared_ptr<md::LabelMarker>,geo::StdAllocator<std::shared_ptr<md::LabelMarker>,mdm::Allocator>>::__push_back_slow_path<std::shared_ptr<md::LabelMarker> const&>((uint64_t)this + 616, &v103);
          }
          else
          {
            if (v18)
            {
              *uint64_t v18 = v15;
              v18[1] = v16;
              if (v16) {
                atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
              }
            }
            uint64_t v19 = v18 + 2;
          }
          *((void *)this + 78) = v19;
          if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
          v13 += 2;
        }
        while (v13 != v14);
        uint64_t v12 = *((void *)this + 86);
      }
      *((unsigned char *)this + 680) = *(unsigned char *)(v12 + 252);
      long long v103 = 0uLL;
      uint64_t v20 = *(void *)(v12 + 176);
      uint64_t v104 = 0;
      uint64_t v105 = v20;
      uint64_t v21 = *(void *)(v12 + 152);
      uint64_t v22 = *(void *)(v12 + 160);
      uint64_t v101 = v20;
      if (v22 == v21)
      {
        uint64_t v100 = 0;
        uint64_t v28 = 0;
        uint64_t v23 = 0;
      }
      else
      {
        if (0xAAAAAAAAAAAAAAABLL * ((v22 - v21) >> 3) > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 16))(v20);
        uint64_t v24 = 0;
        *(void *)&long long v103 = v23;
        uint64_t v100 = v23 + 8 * ((v22 - v21) >> 3);
        uint64_t v104 = v100;
        do
        {
          if (v23 + v24)
          {
            uint64_t v25 = (void *)(v23 + v24);
            *uint64_t v25 = off_1EF559858;
            v25[1] = 0;
            id v26 = *(id *)(v21 + v24 + 8);
            long long v27 = *(void **)(v23 + v24 + 8);
            v25[1] = v26;
          }
          v24 += 24;
        }
        while (v21 + v24 != v22);
        uint64_t v28 = v23 + v24;
        *((void *)&v103 + 1) = v23 + v24;
      }
      uint64_t v102 = v28;
      uint64_t v29 = v28 - v23;
      if (v29 < 1) {
        goto LABEL_91;
      }
      unint64_t v30 = *((void *)this + 82);
      uint64_t v31 = v29 / 24;
      uint64_t v32 = *((void *)this + 81);
      uint64_t v33 = (uint64_t)(v30 - v32) / 24;
      uint64_t v34 = v32 + 24 * v33;
      uint64_t v35 = *((void *)this + 83);
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v35 - v30) >> 3)) >= v31)
      {
        uint64_t v40 = v30 - v34;
        if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v30 - v34) >> 3)) >= v31)
        {
          uint64_t v41 = v23 + 24 * v31;
          uint64_t v45 = (id *)*((void *)this + 82);
        }
        else
        {
          uint64_t v41 = v23 + 8 * ((uint64_t)(v30 - v34) >> 3);
          uint64_t v42 = v102;
          if (v41 == v102)
          {
            uint64_t v45 = (id *)*((void *)this + 82);
          }
          else
          {
            uint64_t v95 = v31;
            uint64_t v43 = (id *)*((void *)this + 82);
            uint64_t v44 = v23 + 8 * ((uint64_t)(v30 - v34) >> 3);
            uint64_t v45 = v43;
            do
            {
              if (v45)
              {
                *uint64_t v45 = off_1EF559858;
                v45[1] = 0;
                id v46 = *(id *)(v44 + 8);
                id v47 = v45[1];
                v45[1] = v46;

                uint64_t v42 = v102;
              }
              v44 += 24;
              v45 += 3;
              v43 += 3;
            }
            while (v44 != v42);
            uint64_t v40 = v30 - v34;
            uint64_t v33 = (uint64_t)(v30 - v32) / 24;
            uint64_t v31 = v95;
          }
          *((void *)this + 82) = v45;
          if (v40 < 1) {
            goto LABEL_91;
          }
        }
        unint64_t v74 = (void *)(v34 + 24 * v31);
        uint64_t v75 = &v45[-3 * v31];
        unint64_t v76 = v45;
        if ((unint64_t)v75 < v30)
        {
          uint64_t v98 = v74;
          uint64_t v77 = v45 + 1;
          uint64_t v78 = v45;
          do
          {
            if (v77 != (id *)8)
            {
              *(v77 - 1) = off_1EF559858;
              id *v77 = 0;
              objc_storeStrong(v77, v75[1]);
              id v79 = v75[1];
              v75[1] = 0;
            }
            v75 += 3;
            v77 += 3;
            v78 += 3;
          }
          while ((unint64_t)v75 < v30);
          unint64_t v76 = v77 - 1;
          unint64_t v74 = v98;
        }
        *((void *)this + 82) = v76;
        if (v45 != v74)
        {
          uint64_t v80 = v45 - 2;
          uint64_t v81 = 24 * v33 + v32 - 16;
          uint64_t v82 = 8 * (v45 - (id *)v74);
          do
          {
            objc_storeStrong(v80, *(id *)(v81 + v82));
            uint64_t v83 = *(void **)(v81 + v82);
            *(void *)(v81 + v82) = 0;

            v80 -= 3;
            v82 -= 24;
          }
          while (v82);
        }
        if (v41 != v23)
        {
          unint64_t v84 = (void **)(24 * v33 + v32 + 8);
          uint64_t v85 = v23;
          do
          {
            id v86 = *(id *)(v85 + 8);
            unint64_t v87 = *v84;
            void *v84 = v86;
            v84 += 3;

            v85 += 24;
          }
          while (v85 != v41);
        }
      }
      else
      {
        unint64_t v36 = v33 + v31;
        if ((unint64_t)(v33 + v31) > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((v35 - v32) >> 3);
        if (2 * v37 > v36) {
          unint64_t v36 = 2 * v37;
        }
        if (v37 >= 0x555555555555555) {
          uint64_t v38 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          uint64_t v38 = v36;
        }
        uint64_t v93 = v38;
        if (v38) {
          uint64_t v39 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 84) + 16))(*((void *)this + 84), 24 * v38, 8);
        }
        else {
          uint64_t v39 = 0;
        }
        uint64_t v97 = v39;
        uint64_t v99 = (uint64_t)(v30 - v32) / 24;
        uint64_t v48 = (void *)(v39 + 24 * v33);
        uint64_t v96 = v31;
        uint64_t v49 = 24 * v31;
        uint64_t v50 = &v48[3 * v31];
        uint64_t v51 = (id *)(v23 + 8);
        uint64_t v52 = v48;
        BOOL v92 = v48;
        do
        {
          if (v48)
          {
            *uint64_t v48 = off_1EF559858;
            v48[1] = 0;
            id v53 = *v51;
            unint64_t v54 = (void *)v48[1];
            v48[1] = v53;
          }
          v48 += 3;
          v52 += 3;
          v51 += 3;
          v49 -= 24;
        }
        while (v49);
        unint64_t v55 = v92;
        uint64_t v56 = 24 * v93;
        uint64_t v57 = *((void *)this + 81);
        if (v57 != v34)
        {
          uint64_t v94 = 24 * v93;
          uint64_t v58 = v97;
          uint64_t v59 = 24 * v99;
          uint64_t v60 = v97 - 24;
          do
          {
            *(void *)(v58 + v59 - 16) = 0;
            unint64_t v61 = (id *)(v58 + v59 - 16);
            *(v61 - 1) = off_1EF559858;
            objc_storeStrong(v61, *(id *)(v32 + v59 - 16));
            uint64_t v62 = *(void **)(v32 + v59 - 16);
            *(void *)(v32 + v59 - 16) = 0;

            v32 -= 24;
            v58 -= 24;
            v60 -= 24;
          }
          while (v32 + v59 != v57);
          unint64_t v55 = (void *)(v58 + 24 * v99);
          uint64_t v56 = v94;
        }
        uint64_t v63 = v97 + v56;
        uint64_t v64 = *((void *)this + 82);
        if (v64 != v34)
        {
          uint64_t v65 = v97 + 24 * v99 + 24 * v96;
          uint64_t v66 = v50;
          do
          {
            *uint64_t v66 = off_1EF559858;
            v66 += 3;
            v50[1] = 0;
            objc_storeStrong((id *)v50 + 1, *(id *)(v34 + 8));
            long long v67 = *(void **)(v34 + 8);
            *(void *)(v34 + 8) = 0;

            v34 += 24;
            v65 += 24;
            uint64_t v50 = v66;
          }
          while (v34 != v64);
          uint64_t v34 = *((void *)this + 82);
          uint64_t v50 = v66;
        }
        uint64_t v68 = (void (***)(void))*((void *)this + 81);
        *((void *)this + 81) = v55;
        *((void *)this + 82) = v50;
        uint64_t v69 = *((void *)this + 83);
        *((void *)this + 83) = v63;
        if ((void (***)(void))v34 != v68)
        {
          uint64_t v70 = v34 - 24;
          unint64_t v71 = (void (***)(void))(v34 - 24);
          uint64_t v72 = (void (***)(void))(v34 - 24);
          do
          {
            unint64_t v73 = *v72;
            v72 -= 3;
            (*v73)(v71);
            v70 -= 24;
            BOOL v11 = v71 == v68;
            unint64_t v71 = v72;
          }
          while (!v11);
        }
        if (v68) {
          (*(void (**)(void, void (***)(void), uint64_t))(**((void **)this + 84) + 40))(*((void *)this + 84), v68, v69 - (void)v68);
        }
      }
LABEL_91:
      if (v23)
      {
        if (v102 != v23)
        {
          uint64_t v88 = v102 - 24;
          uint64_t v89 = (void (***)(void))(v102 - 24);
          uint64_t v90 = (void (***)(void))(v102 - 24);
          do
          {
            uint64_t v91 = *v90;
            v90 -= 3;
            (*v91)(v89);
            v88 -= 24;
            BOOL v11 = v89 == (void (***)(void))v23;
            uint64_t v89 = v90;
          }
          while (!v11);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v101 + 40))(v101, v23, v100 - v23);
      }
    }
  }
}

void sub_1A1BF8D8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::vector<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::~vector[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1A1BF8DA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'md::StandardLabeler::screenSizeDidChange(uint64_t this)
{
  *(unsigned char *)(this + 360) = 1;
  return this;
}

uint64_t md::LabelManager::tryWaitForBkgdUpdateComplete(md::LabelManager *this, unsigned int a2)
{
  if (!*((unsigned char *)this + 3385)) {
    return 1;
  }
  int64_t v3 = 1000000 * a2;
  unint64_t v4 = *((id *)this + 27);
  dispatch_time_t v5 = dispatch_time(0, v3);
  intptr_t v6 = dispatch_semaphore_wait(v4, v5);

  if (v6) {
    return 0;
  }
  dispatch_semaphore_signal(*((dispatch_semaphore_t *)this + 27));
  uint64_t result = 1;
  if (*((unsigned char *)this + 3385))
  {
    ++*((unsigned char *)this + 3305);
    *((_WORD *)this + 1692) = 1;
  }
  return result;
}

uint64_t std::__function::__func<md::BuildFrameGraphModule,std::allocator<md::BuildFrameGraphModule>,ecs2::ModuleDescriptor ()(void)>::operator()@<X0>(uint64_t a1@<X8>)
{
  uint64_t v140 = *MEMORY[0x1E4F143B8];
  __int16 v1 = gdc::FamilyInfo<ecs2::ModuleDescriptor,unsigned short>::Counter::nextId(void)::counter++;
  *(_WORD *)a1 = v1;
  *(unsigned char *)(a1 + 31) = 21;
  strcpy((char *)(a1 + 8), "BuildFrameGraphModule");
  __int16 v96 = 1;
  uint64_t v43 = &unk_1EF51AEE8;
  uint64_t v44 = 0;
  uint64_t v45 = &v43;
  v46[0] = &unk_1EF5289B8;
  id v47 = v46;
  v48[0] = &unk_1EF528970;
  uint64_t v49 = v48;
  *(void *)uint64_t v50 = operator new(0x20uLL);
  *(_OWORD *)&v50[8] = xmmword_1A28FD670;
  strcpy(*(char **)v50, "md::ita::PrepareBuildFrameGraph");
  __int16 v87 = 28850;
  uint64_t v89 = v88;
  v88[0] = &unk_1EF51AEE8;
  v88[1] = 0;
  uint64_t v91 = v90;
  v90[0] = &unk_1EF5289B8;
  uint64_t v93 = v92;
  long long v94 = *(_OWORD *)v50;
  v92[0] = &unk_1EF528970;
  uint64_t v95 = *(void *)&v50[16];
  uint64_t v97 = 0;
  uint64_t v98 = 0;
  uint64_t v99 = 0;
  uint64_t v97 = (char *)operator new(0x80uLL);
  uint64_t v98 = v97;
  uint64_t v2 = v97 + 128;
  uint64_t v99 = v97 + 128;
  ecs2::ExecutionTaskDescriptor::ExecutionTaskDescriptor((uint64_t)v97, (uint64_t)&v87);
  uint64_t v98 = v2;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v102 = 0u;
  __int16 v83 = -31267;
  uint64_t v85 = v84;
  v84[0] = &unk_1EF51A0D8;
  v84[1] = 0;
  strcpy((char *)v86, "md::DetermineIfLegacy");
  HIBYTE(v86[2]) = 21;
  uint64_t v105 = 0;
  long long v103 = 0;
  uint64_t v104 = 0;
  long long v103 = (char *)operator new(0x40uLL);
  uint64_t v104 = v103;
  int64_t v3 = v103 + 64;
  uint64_t v105 = v103 + 64;
  std::construct_at[abi:nn180100]<ecs2::UtlityTaskDescriptor,ecs2::UtlityTaskDescriptor const&,ecs2::UtlityTaskDescriptor*>((uint64_t)v103, (uint64_t)&v83);
  uint64_t v104 = v3;
  uint64_t v106 = 0;
  uint64_t v108 = 0;
  uint64_t v107 = 0;
  __int16 v109 = 2;
  LOWORD(v131) = -15987;
  float v132 = &unk_1EF51BDD0;
  uint64_t v133 = 0;
  int64_t v134 = &v132;
  v135[0] = &unk_1EF52A788;
  float v136 = v135;
  v137[0] = &unk_1EF52A740;
  uint64_t v138 = v137;
  *(void *)uint64_t v139 = operator new(0x28uLL);
  *(_OWORD *)&v139[8] = xmmword_1A28FD710;
  strcpy(*(char **)v139, "md::ita::BuildSSAODOFCommonFrameGraph");
  v42[0] = -15987;
  uint64_t v45 = &v43;
  uint64_t v43 = &unk_1EF51BDD0;
  uint64_t v44 = 0;
  id v47 = v46;
  v46[0] = &unk_1EF52A788;
  uint64_t v49 = v48;
  v48[0] = &unk_1EF52A740;
  *(void *)&v50[16] = *(void *)&v139[16];
  *(_OWORD *)uint64_t v50 = *(_OWORD *)v139;
  LOWORD(v131) = 23685;
  float v132 = &unk_1EF51A7E0;
  uint64_t v133 = 0;
  int64_t v134 = &v132;
  v135[0] = &unk_1EF527BA8;
  float v136 = v135;
  v137[0] = &unk_1EF527B60;
  uint64_t v138 = v137;
  *(void *)uint64_t v139 = operator new(0x20uLL);
  *(_OWORD *)&v139[8] = xmmword_1A28FD190;
  strcpy(*(char **)v139, "md::ita::BuildSSAOFrameGraph");
  __int16 v51 = 23685;
  v52[3] = v52;
  v52[0] = &unk_1EF51A7E0;
  v52[1] = 0;
  v53[3] = v53;
  v53[0] = &unk_1EF527BA8;
  v54[3] = v54;
  long long v55 = *(_OWORD *)v139;
  v54[0] = &unk_1EF527B60;
  uint64_t v56 = *(void *)&v139[16];
  LOWORD(v131) = -5037;
  float v132 = &unk_1EF51AAF8;
  uint64_t v133 = 0;
  int64_t v134 = &v132;
  v135[0] = &unk_1EF5281D8;
  float v136 = v135;
  v137[0] = &unk_1EF528190;
  uint64_t v138 = v137;
  *(void *)uint64_t v139 = operator new(0x20uLL);
  *(_OWORD *)&v139[8] = xmmword_1A28FD1A0;
  strcpy(*(char **)v139, "md::ita::BuildShadowFrameGraph");
  __int16 v57 = -5037;
  v58[3] = v58;
  v58[0] = &unk_1EF51AAF8;
  v58[1] = 0;
  v59[3] = v59;
  v59[0] = &unk_1EF5281D8;
  v60[3] = v60;
  long long v61 = *(_OWORD *)v139;
  v60[0] = &unk_1EF528190;
  uint64_t v62 = *(void *)&v139[16];
  LOWORD(v131) = -835;
  float v132 = &unk_1EF51AE58;
  uint64_t v133 = 0;
  int64_t v134 = &v132;
  v135[0] = &unk_1EF528898;
  float v136 = v135;
  v137[0] = &unk_1EF528850;
  uint64_t v138 = v137;
  *(void *)uint64_t v139 = operator new(0x20uLL);
  *(_OWORD *)&v139[8] = xmmword_1A28FD670;
  strcpy(*(char **)v139, "md::ita::BuildPrimaryFrameGraph");
  __int16 v63 = -835;
  v64[3] = v64;
  v64[0] = &unk_1EF51AE58;
  v64[1] = 0;
  v65[3] = v65;
  v65[0] = &unk_1EF528898;
  v66[3] = v66;
  long long v67 = *(_OWORD *)v139;
  v66[0] = &unk_1EF528850;
  uint64_t v68 = *(void *)&v139[16];
  LOWORD(v131) = 24904;
  float v132 = &unk_1EF51B3F8;
  uint64_t v133 = 0;
  int64_t v134 = &v132;
  v135[0] = &unk_1EF5293D8;
  float v136 = v135;
  v137[0] = &unk_1EF529390;
  uint64_t v138 = v137;
  *(void *)uint64_t v139 = operator new(0x28uLL);
  *(_OWORD *)&v139[8] = xmmword_1A28FD150;
  strcpy(*(char **)v139, "md::ita::BuildRouteLineFrameGraph");
  __int16 v69 = 24904;
  v70[3] = v70;
  v70[0] = &unk_1EF51B3F8;
  v70[1] = 0;
  v71[3] = v71;
  v71[0] = &unk_1EF5293D8;
  v72[3] = v72;
  v72[0] = &unk_1EF529390;
  long long v73 = *(_OWORD *)v139;
  uint64_t v74 = *(void *)&v139[16];
  LOWORD(v131) = 25963;
  float v132 = &unk_1EF51B440;
  uint64_t v133 = 0;
  int64_t v134 = &v132;
  v135[0] = &unk_1EF529468;
  float v136 = v135;
  v137[0] = &unk_1EF529420;
  uint64_t v138 = v137;
  *(void *)uint64_t v139 = operator new(0x28uLL);
  *(_OWORD *)&v139[8] = xmmword_1A28FD150;
  strcpy(*(char **)v139, "md::ita::EndFrameGraphPreparation");
  __int16 v75 = 25963;
  uint64_t v77 = v76;
  v76[0] = &unk_1EF51B440;
  v76[1] = 0;
  id v79 = v78;
  v78[0] = &unk_1EF529468;
  v80[3] = v80;
  v80[0] = &unk_1EF529420;
  long long v81 = *(_OWORD *)v139;
  uint64_t v82 = *(void *)&v139[16];
  unint64_t v110 = 0;
  int64_t v111 = 0;
  unint64_t v112 = 0;
  unint64_t v4 = (char *)operator new(0x300uLL);
  unint64_t v110 = v4;
  int64_t v111 = v4;
  unint64_t v112 = v4 + 768;
  ecs2::ExecutionTaskDescriptor::ExecutionTaskDescriptor((uint64_t)v4, (uint64_t)v42);
  ecs2::ExecutionTaskDescriptor::ExecutionTaskDescriptor((uint64_t)(v4 + 128), (uint64_t)&v51);
  ecs2::ExecutionTaskDescriptor::ExecutionTaskDescriptor((uint64_t)(v4 + 256), (uint64_t)&v57);
  ecs2::ExecutionTaskDescriptor::ExecutionTaskDescriptor((uint64_t)(v4 + 384), (uint64_t)&v63);
  ecs2::ExecutionTaskDescriptor::ExecutionTaskDescriptor((uint64_t)(v4 + 512), (uint64_t)&v69);
  ecs2::ExecutionTaskDescriptor::ExecutionTaskDescriptor((uint64_t)(v4 + 640), (uint64_t)&v75);
  int64_t v111 = v4 + 768;
  dispatch_time_t v5 = operator new(0x10uLL);
  *dispatch_time_t v5 = xmmword_1A28FC760;
  uint64_t v115 = 0;
  double v113 = 0;
  uint64_t v114 = 0;
  intptr_t v6 = operator new(0x18uLL);
  double v113 = v6;
  uint64_t v115 = v6 + 3;
  v6[1] = 0;
  v6[2] = 0;
  void *v6 = 0;
  unint64_t v7 = operator new(0x10uLL);
  v6[1] = v7 + 1;
  v6[2] = v7 + 1;
  *unint64_t v7 = *v5;
  void *v6 = v7;
  long long v116 = 0u;
  long long v117 = 0u;
  long long v118 = 0u;
  long long v119 = 0u;
  uint64_t v114 = v6 + 3;
  uint64_t v120 = 0;
  __int16 v121 = 31;
  LOWORD(v131) = 9244;
  float v132 = &unk_1EF51B878;
  uint64_t v133 = 0;
  int64_t v134 = &v132;
  v135[0] = &unk_1EF529CD8;
  float v136 = v135;
  v137[0] = &unk_1EF529C90;
  uint64_t v138 = v137;
  *(void *)uint64_t v139 = operator new(0x28uLL);
  *(_OWORD *)&v139[8] = xmmword_1A28FD680;
  strcpy(*(char **)v139, "md::ita::CleanUpFrameGraphResources");
  __int16 v33 = 9244;
  v34[0] = &unk_1EF51B878;
  v34[1] = 0;
  uint64_t v35 = v34;
  v36[0] = &unk_1EF529CD8;
  uint64_t v39 = v38;
  unint64_t v37 = v36;
  v38[0] = &unk_1EF529C90;
  uint64_t v41 = *(void *)&v139[16];
  long long __p = *(_OWORD *)v139;
  BOOL v123 = 0;
  int32x2_t v122 = 0;
  uint64_t v124 = 0;
  int32x2_t v122 = (char *)operator new(0x80uLL);
  BOOL v123 = v122;
  unint64_t v8 = v122 + 128;
  uint64_t v124 = v122 + 128;
  ecs2::ExecutionTaskDescriptor::ExecutionTaskDescriptor((uint64_t)v122, (uint64_t)&v33);
  BOOL v123 = v8;
  long long v125 = 0u;
  long long v126 = 0u;
  long long v127 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  long long v130 = 0u;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  unint64_t v9 = (char *)operator new(0x180uLL);
  *(void *)(a1 + 32) = v9;
  *(void *)(a1 + 40) = v9;
  *(void *)(a1 + 48) = v9 + 384;
  ecs2::ModuleBucketDescriptor::ModuleBucketDescriptor((uint64_t)v9, (uint64_t)&v96);
  ecs2::ModuleBucketDescriptor::ModuleBucketDescriptor((uint64_t)(v9 + 128), (uint64_t)&v109);
  ecs2::ModuleBucketDescriptor::ModuleBucketDescriptor((uint64_t)(v9 + 256), (uint64_t)&v121);
  unint64_t v10 = (void ***)&v131;
  *(void *)(a1 + 40) = v9 + 384;
  do
  {
    ecs2::ModuleBucketLayoutDescriptor::{unnamed type#1}::~ModuleBucketLayoutDescriptor((void **)v10 - 6);
    unint64_t v131 = v10 - 9;
    std::vector<ecs2::ExecutionDebugTaskDescriptor>::__destroy_vector::operator()[abi:nn180100]((void ***)&v131);
    uint64_t v12 = *(v10 - 12);
    if (v12)
    {
      unint64_t v13 = *(v10 - 11);
      unint64_t v14 = *(v10 - 12);
      if (v13 != v12)
      {
        uint64_t v15 = *(v10 - 11);
        do
        {
          uint64_t v17 = *(v15 - 3);
          v15 -= 3;
          uint64_t v16 = v17;
          if (v17)
          {
            *(v13 - 2) = v16;
            operator delete(v16);
          }
          unint64_t v13 = v15;
        }
        while (v15 != v12);
        unint64_t v14 = *(v10 - 12);
      }
      *(v10 - 11) = v12;
      operator delete(v14);
    }
    uint64_t v18 = *(v10 - 15);
    if (v18)
    {
      uint64_t v19 = *(v10 - 14);
      BOOL v11 = *(v10 - 15);
      if (v19 != v18)
      {
        uint64_t v20 = 0;
        do
        {
          uint64_t v21 = &v19[v20];
          if (SHIBYTE(v19[v20 - 1]) < 0) {
            operator delete(*(v21 - 3));
          }
          uint64_t v22 = (void **)*(v21 - 4);
          if (v21 - 7 == v22)
          {
            (*((void (**)(void **))*(v21 - 7) + 4))(v21 - 7);
          }
          else if (v22)
          {
            (*((void (**)(void))*v22 + 5))(*(v21 - 4));
          }
          uint64_t v23 = (uint64_t)&v19[v20 - 11];
          uint64_t v24 = v19[v20 - 8];
          if ((void *)v23 == v24)
          {
            (*(void (**)(void **))(*(void *)v23 + 32))(&v19[v20 - 11]);
          }
          else if (v24)
          {
            (*(void (**)(void *))(*(void *)v24 + 40))(v24);
          }
          uint64_t v25 = (void **)v19[v20 - 12];
          if (v21 - 15 == v25)
          {
            (*((void (**)(void **))*(v21 - 15) + 4))(v21 - 15);
          }
          else if (v25)
          {
            (*((void (**)(void *))*v25 + 5))(v19[v20 - 12]);
          }
          v20 -= 16;
        }
        while (&v19[v20] != v18);
        BOOL v11 = *(v10 - 15);
      }
      *(v10 - 14) = v18;
      operator delete(v11);
    }
    v10 -= 16;
  }
  while (v10 != (void ***)&v96);
  if (SHIBYTE(v41) < 0) {
    operator delete((void *)__p);
  }
  if (v39 == v38)
  {
    (*(void (**)(void *))(v38[0] + 32))(v38);
  }
  else if (v39)
  {
    (*(void (**)(void))(*v39 + 40))();
  }
  if (v37 == v36)
  {
    (*(void (**)(void *))(v36[0] + 32))(v36);
  }
  else if (v37)
  {
    (*(void (**)(void))(*v37 + 40))();
  }
  if (v35 == v34)
  {
    (*(void (**)(void *))(v34[0] + 32))(v34);
  }
  else if (v35)
  {
    (*(void (**)(void))(*v35 + 40))();
  }
  operator delete(v5);
  for (unint64_t i = 0; i != -768; i -= 128)
  {
    long long v27 = (void **)&v42[i / 2];
    if (*((char *)&v82 + i + 7) < 0) {
      operator delete(v27[93]);
    }
    uint64_t v28 = (void **)v27[92];
    if (v27 + 89 == v28)
    {
      (*((void (**)(_WORD *))v27[89] + 4))((_WORD *)v27 + 356);
    }
    else if (v28)
    {
      (*((void (**)(void *))*v28 + 5))(v27[92]);
    }
    uint64_t v29 = (void *)v80[i / 8 - 1];
    if (&v78[i / 8] == v29)
    {
      (*(void (**)(void *))(v78[i / 8] + 32))(&v78[i / 8]);
    }
    else if (v29)
    {
      (*(void (**)(void *))(*v29 + 40))(v29);
    }
    unint64_t v30 = (void **)v78[i / 8 - 1];
    if (v27 + 81 == v30)
    {
      (*((void (**)(_WORD *))v27[81] + 4))((_WORD *)v27 + 324);
    }
    else if (v30)
    {
      (*((void (**)(void))*v30 + 5))(v78[i / 8 - 1]);
    }
  }
  if (SHIBYTE(v86[2]) < 0) {
    operator delete(v86[0]);
  }
  if (v85 == v84)
  {
    (*(void (**)(void *))(v84[0] + 32))(v84);
    if ((SHIBYTE(v95) & 0x80000000) == 0) {
      goto LABEL_67;
    }
    goto LABEL_71;
  }
  if (v85) {
    (*(void (**)(void))(*v85 + 40))();
  }
  if (SHIBYTE(v95) < 0) {
LABEL_71:
  }
    operator delete((void *)v94);
LABEL_67:
  if (v93 == v92)
  {
    (*(void (**)(void *))(v92[0] + 32))(v92);
  }
  else if (v93)
  {
    (*(void (**)(void))(*v93 + 40))();
  }
  if (v91 == v90)
  {
    (*(void (**)(void *))(v90[0] + 32))(v90);
  }
  else if (v91)
  {
    (*(void (**)(void))(*v91 + 40))();
  }
  uint64_t result = (uint64_t)v89;
  if (v89 == v88) {
    return (*(uint64_t (**)(void *))(v88[0] + 32))(v88);
  }
  if (v89) {
    return (*(uint64_t (**)(void))(*v89 + 40))();
  }
  return result;
}

void sub_1A1BFA1AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t v81 = v75 + 184;
  ecs2::ModuleBucketLayoutDescriptor::{unnamed type#1}::~ModuleBucketLayoutDescriptor((void **)&STACK[0x670]);
  *(void *)(v79 - 224) = &STACK[0x658];
  std::vector<ecs2::ExecutionDebugTaskDescriptor>::__destroy_vector::operator()[abi:nn180100]((void ***)(v79 - 224));
  unint64_t v82 = STACK[0x640];
  if (STACK[0x640])
  {
    unint64_t v83 = STACK[0x648];
    unint64_t v84 = (void *)STACK[0x640];
    if (STACK[0x648] != v82)
    {
      unint64_t v85 = STACK[0x648];
      do
      {
        __int16 v87 = *(void **)(v85 - 24);
        v85 -= 24;
        id v86 = v87;
        if (v87)
        {
          *(void *)(v83 - 16) = v86;
          operator delete(v86);
        }
        unint64_t v83 = v85;
      }
      while (v85 != v82);
      unint64_t v84 = (void *)STACK[0x640];
    }
    STACK[0x648] = v82;
    operator delete(v84);
  }
  unint64_t v88 = STACK[0x628];
  if (STACK[0x628])
  {
    uint64_t v89 = STACK[0x630];
    uint64_t v90 = (void *)STACK[0x628];
    if (STACK[0x630] != v88)
    {
      do
      {
        v89 -= 128;
        std::__destroy_at[abi:nn180100]<ecs2::ExecutionTaskDescriptor,0>(v89);
      }
      while (v89 != v88);
      uint64_t v90 = (void *)STACK[0x628];
    }
    STACK[0x630] = v88;
    operator delete(v90);
  }
  ecs2::ModuleBucketLayoutDescriptor::{unnamed type#1}::~ModuleBucketLayoutDescriptor((void **)&STACK[0x5F0]);
  *(void *)(v79 - 224) = v81;
  std::vector<ecs2::ExecutionDebugTaskDescriptor>::__destroy_vector::operator()[abi:nn180100]((void ***)(v79 - 224));
  unint64_t v91 = STACK[0x5C0];
  if (STACK[0x5C0])
  {
    unint64_t v92 = STACK[0x5C8];
    uint64_t v93 = (void *)STACK[0x5C0];
    if (STACK[0x5C8] != v91)
    {
      unint64_t v94 = STACK[0x5C8];
      do
      {
        __int16 v96 = *(void **)(v94 - 24);
        v94 -= 24;
        uint64_t v95 = v96;
        if (v96)
        {
          *(void *)(v92 - 16) = v95;
          operator delete(v95);
        }
        unint64_t v92 = v94;
      }
      while (v94 != v91);
      uint64_t v93 = (void *)STACK[0x5C0];
    }
    STACK[0x5C8] = v91;
    operator delete(v93);
  }
  unint64_t v97 = STACK[0x5A8];
  if (STACK[0x5A8])
  {
    uint64_t v98 = STACK[0x5B0];
    uint64_t v99 = (void *)STACK[0x5A8];
    if (STACK[0x5B0] != v97)
    {
      do
      {
        v98 -= 128;
        std::__destroy_at[abi:nn180100]<ecs2::ExecutionTaskDescriptor,0>(v98);
      }
      while (v98 != v97);
      uint64_t v99 = (void *)STACK[0x5A8];
    }
    STACK[0x5B0] = v97;
    operator delete(v99);
  }
  ecs2::ModuleBucketLayoutDescriptor::{unnamed type#1}::~ModuleBucketLayoutDescriptor((void **)&STACK[0x570]);
  *(void *)(v79 - 224) = &STACK[0x558];
  std::vector<ecs2::ExecutionDebugTaskDescriptor>::__destroy_vector::operator()[abi:nn180100]((void ***)(v79 - 224));
  unint64_t v100 = STACK[0x540];
  if (STACK[0x540])
  {
    unint64_t v101 = STACK[0x548];
    long long v102 = (void *)STACK[0x540];
    if (STACK[0x548] != v100)
    {
      unint64_t v103 = STACK[0x548];
      do
      {
        uint64_t v105 = *(void **)(v103 - 24);
        v103 -= 24;
        uint64_t v104 = v105;
        if (v105)
        {
          *(void *)(v101 - 16) = v104;
          operator delete(v104);
        }
        unint64_t v101 = v103;
      }
      while (v103 != v100);
      long long v102 = (void *)STACK[0x540];
    }
    STACK[0x548] = v100;
    operator delete(v102);
  }
  unint64_t v106 = STACK[0x528];
  if (STACK[0x528])
  {
    uint64_t v107 = STACK[0x530];
    uint64_t v108 = (void *)STACK[0x528];
    if (STACK[0x530] != v106)
    {
      do
      {
        v107 -= 128;
        std::__destroy_at[abi:nn180100]<ecs2::ExecutionTaskDescriptor,0>(v107);
      }
      while (v107 != v106);
      uint64_t v108 = (void *)STACK[0x528];
    }
    STACK[0x530] = v106;
    operator delete(v108);
  }
  if (a55 < 0) {
    operator delete(a50);
  }
  if (a49 == v74)
  {
    (*(void (**)(uint64_t))(a46 + 32))(v74);
  }
  else if (a49)
  {
    (*(void (**)(void))(*(void *)a49 + 40))();
  }
  if (a45 == v73)
  {
    (*(void (**)(uint64_t))(a42 + 32))(v73);
  }
  else if (a45)
  {
    (*(void (**)(void))(*(void *)a45 + 40))();
  }
  if (a41 == v77)
  {
    (*(void (**)(uint64_t))(a38 + 32))(v77);
  }
  else if (a41)
  {
    (*(void (**)(void))(*(void *)a41 + 40))();
  }
  operator delete(v76);
  if (SLOBYTE(STACK[0x45F]) < 0) {
    operator delete((void *)STACK[0x448]);
  }
  unint64_t v109 = STACK[0x440];
  if (STACK[0x440] == v78)
  {
    (*(void (**)(uint64_t))(STACK[0x428] + 32))(v78);
  }
  else if (v109)
  {
    (*(void (**)(unint64_t))(*(void *)v109 + 40))(v109);
  }
  unint64_t v110 = STACK[0x420];
  if (STACK[0x420] == a10)
  {
    (*(void (**)(void))(STACK[0x408] + 32))();
  }
  else if (v110)
  {
    (*(void (**)(unint64_t))(*(void *)v110 + 40))(v110);
  }
  unint64_t v111 = STACK[0x400];
  if (STACK[0x400] == a11)
  {
    (*(void (**)(void))(STACK[0x3E8] + 32))();
  }
  else if (v111)
  {
    (*(void (**)(unint64_t))(*(void *)v111 + 40))(v111);
  }
  if (SLOBYTE(STACK[0x3DF]) < 0) {
    operator delete((void *)STACK[0x3C8]);
  }
  unint64_t v112 = STACK[0x3C0];
  if (STACK[0x3C0] == a12)
  {
    (*(void (**)(void))(STACK[0x3A8] + 32))();
  }
  else if (v112)
  {
    (*(void (**)(unint64_t))(*(void *)v112 + 40))(v112);
  }
  unint64_t v113 = STACK[0x3A0];
  if (STACK[0x3A0] == a13)
  {
    (*(void (**)(void))(STACK[0x388] + 32))();
  }
  else if (v113)
  {
    (*(void (**)(unint64_t))(*(void *)v113 + 40))(v113);
  }
  unint64_t v114 = STACK[0x380];
  if (STACK[0x380] == a14)
  {
    (*(void (**)(void))(STACK[0x368] + 32))();
  }
  else if (v114)
  {
    (*(void (**)(unint64_t))(*(void *)v114 + 40))(v114);
  }
  if (SLOBYTE(STACK[0x35F]) < 0) {
    operator delete((void *)STACK[0x348]);
  }
  unint64_t v115 = STACK[0x340];
  if (STACK[0x340] == a15)
  {
    (*(void (**)(void))(STACK[0x328] + 32))();
  }
  else if (v115)
  {
    (*(void (**)(unint64_t))(*(void *)v115 + 40))(v115);
  }
  unint64_t v116 = STACK[0x320];
  if (STACK[0x320] == a16)
  {
    (*(void (**)(void))(STACK[0x308] + 32))();
  }
  else if (v116)
  {
    (*(void (**)(unint64_t))(*(void *)v116 + 40))(v116);
  }
  unint64_t v117 = STACK[0x300];
  if (STACK[0x300] == a17)
  {
    (*(void (**)(void))(STACK[0x2E8] + 32))();
  }
  else if (v117)
  {
    (*(void (**)(unint64_t))(*(void *)v117 + 40))(v117);
  }
  if (SLOBYTE(STACK[0x2DF]) < 0) {
    operator delete((void *)STACK[0x2C8]);
  }
  unint64_t v118 = STACK[0x2C0];
  if (STACK[0x2C0] == a18)
  {
    (*(void (**)(void))(STACK[0x2A8] + 32))();
  }
  else if (v118)
  {
    (*(void (**)(unint64_t))(*(void *)v118 + 40))(v118);
  }
  unint64_t v119 = STACK[0x2A0];
  if (STACK[0x2A0] == a19)
  {
    (*(void (**)(void))(STACK[0x288] + 32))();
  }
  else if (v119)
  {
    (*(void (**)(unint64_t))(*(void *)v119 + 40))(v119);
  }
  unint64_t v120 = STACK[0x280];
  if (STACK[0x280] == a20)
  {
    (*(void (**)(void))(STACK[0x268] + 32))();
  }
  else if (v120)
  {
    (*(void (**)(unint64_t))(*(void *)v120 + 40))(v120);
  }
  if (SLOBYTE(STACK[0x25F]) < 0) {
    operator delete((void *)STACK[0x248]);
  }
  unint64_t v121 = STACK[0x240];
  if (STACK[0x240] == a21)
  {
    (*(void (**)(void))(STACK[0x228] + 32))();
  }
  else if (v121)
  {
    (*(void (**)(unint64_t))(*(void *)v121 + 40))(v121);
  }
  unint64_t v122 = STACK[0x220];
  if (STACK[0x220] == a22)
  {
    (*(void (**)(void))(STACK[0x208] + 32))();
  }
  else if (v122)
  {
    (*(void (**)(unint64_t))(*(void *)v122 + 40))(v122);
  }
  unint64_t v123 = STACK[0x200];
  if (STACK[0x200] == a23)
  {
    (*(void (**)(void))(a73 + 32))();
  }
  else if (v123)
  {
    (*(void (**)(unint64_t))(*(void *)v123 + 40))(v123);
  }
  if (a72 < 0) {
    operator delete(a69);
  }
  if (a68 == a24)
  {
    (*(void (**)(void))(a65 + 32))();
  }
  else if (a68)
  {
    (*(void (**)(void))(*(void *)a68 + 40))();
  }
  if (a64 == a25)
  {
    (*(void (**)(void))(a61 + 32))();
  }
  else if (a64)
  {
    (*(void (**)(void))(*(void *)a64 + 40))();
  }
  if (a60 == a26)
  {
    (*(void (**)(void))(a57 + 32))();
  }
  else if (a60)
  {
    (*(void (**)(void))(*(void *)a60 + 40))();
  }
  if (SLOBYTE(STACK[0x49F]) < 0) {
    operator delete((void *)STACK[0x488]);
  }
  unint64_t v124 = STACK[0x480];
  if (STACK[0x480] == a32)
  {
    (*(void (**)(void))(STACK[0x468] + 32))();
  }
  else if (v124)
  {
    (*(void (**)(unint64_t))(*(void *)v124 + 40))(v124);
  }
  if (SLOBYTE(STACK[0x51F]) < 0) {
    operator delete((void *)STACK[0x508]);
  }
  unint64_t v125 = STACK[0x500];
  if (STACK[0x500] == a33)
  {
    (*(void (**)(void))(STACK[0x4E8] + 32))();
  }
  else if (v125)
  {
    (*(void (**)(unint64_t))(*(void *)v125 + 40))(v125);
  }
  unint64_t v126 = STACK[0x4E0];
  if (STACK[0x4E0] == a34)
  {
    (*(void (**)(void))(STACK[0x4C8] + 32))();
  }
  else if (v126)
  {
    (*(void (**)(unint64_t))(*(void *)v126 + 40))(v126);
  }
  unint64_t v127 = STACK[0x4C0];
  if (STACK[0x4C0] == a35)
  {
    (*(void (**)(void))(STACK[0x4A8] + 32))();
  }
  else if (v127)
  {
    (*(void (**)(unint64_t))(*(void *)v127 + 40))(v127);
  }
  if (*(char *)(a36 + 31) < 0) {
    operator delete(*(void **)(a36 + 8));
  }
  _Unwind_Resume(a1);
}

void sub_1A1BFBAA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A1BFBB60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A1BFBC1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void md::NonTiledAssetLogic::loadNonTiledIDs(VKResourceManager *)::$_0::operator()(void *a1, uint64_t *a2)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  unint64_t v4 = v3;
  if (!v3) {
    goto LABEL_17;
  }
  if (([v3 hasName] & 1) == 0)
  {
    if (GEOGetVectorKitNonTiledAssetLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitNonTiledAssetLogicLog(void)::onceToken, &__block_literal_global_47892);
    }
    uint64_t v13 = GEOGetVectorKitNonTiledAssetLogicLog(void)::log;
    if (!os_log_type_enabled((os_log_t)GEOGetVectorKitNonTiledAssetLogicLog(void)::log, OS_LOG_TYPE_INFO)) {
      goto LABEL_17;
    }
    LOWORD(buf) = 0;
    unint64_t v14 = "Non-tiled info does not have a name. Skipping";
    uint64_t v15 = v13;
    uint32_t v16 = 2;
LABEL_16:
    _os_log_impl(&dword_1A1780000, v15, OS_LOG_TYPE_INFO, v14, (uint8_t *)&buf, v16);
LABEL_17:

    goto LABEL_18;
  }
  id v5 = [v4 name];
  uint64_t v6 = [v5 cStringUsingEncoding:1];

  if (([v4 hasMuid] & 1) == 0)
  {
    if (GEOGetVectorKitNonTiledAssetLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitNonTiledAssetLogicLog(void)::onceToken, &__block_literal_global_47892);
    }
    uint64_t v17 = GEOGetVectorKitNonTiledAssetLogicLog(void)::log;
    if (!os_log_type_enabled((os_log_t)GEOGetVectorKitNonTiledAssetLogicLog(void)::log, OS_LOG_TYPE_INFO)) {
      goto LABEL_17;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v6;
    unint64_t v14 = "Non-tiled info with name %s does not have a muid. Skipping";
    uint64_t v15 = v17;
    uint32_t v16 = 12;
    goto LABEL_16;
  }

  id v7 = [v4 name];
  unint64_t v8 = (const char *)[v7 cStringUsingEncoding:1];

  uint64_t v9 = [v4 muid];
  size_t v10 = strlen(v8);
  if (v10 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v11 = v10;
  uint64_t v69 = v9;
  if (v10 >= 0x17)
  {
    uint64_t v18 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v18 = v10 | 7;
    }
    uint64_t v19 = v18 + 1;
    p_dst = (long long *)operator new(v18 + 1);
    *((void *)&__dst + 1) = v11;
    int64_t v71 = v19 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
  }
  else
  {
    HIBYTE(v71) = v10;
    p_dst = &__dst;
    if (!v10) {
      goto LABEL_23;
    }
  }
  memmove(p_dst, v8, v11);
LABEL_23:
  *((unsigned char *)p_dst + v11) = 0;
  char v20 = HIBYTE(v71);
  if (v71 >= 0) {
    uint64_t v21 = (uint64_t *)&__dst;
  }
  else {
    uint64_t v21 = (uint64_t *)__dst;
  }
  if (v71 >= 0) {
    unint64_t v22 = HIBYTE(v71);
  }
  else {
    unint64_t v22 = *((void *)&__dst + 1);
  }
  unint64_t v23 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v21, v22);
  size_t v24 = v23;
  unint64_t v25 = a2[1];
  if (!v25) {
    goto LABEL_71;
  }
  uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v25);
  v26.i16[0] = vaddlv_u8(v26);
  if (v26.u32[0] > 1uLL)
  {
    size_t v11 = v23;
    if (v23 >= v25) {
      size_t v11 = v23 % v25;
    }
  }
  else
  {
    size_t v11 = (v25 - 1) & v23;
  }
  long long v27 = *(void ***)(*a2 + 8 * v11);
  if (!v27 || (uint64_t v28 = (unsigned __int8 *)*v27) == 0)
  {
LABEL_71:
    uint64_t v28 = (unsigned __int8 *)operator new(0x30uLL);
    uint64_t v40 = a2 + 2;
    *(void *)&long long buf = v28;
    *((void *)&buf + 1) = a2 + 2;
    *(void *)uint64_t v28 = 0;
    *((void *)v28 + 1) = v24;
    *((_OWORD *)v28 + 1) = __dst;
    int64_t v41 = v71;
    long long __dst = 0uLL;
    int64_t v71 = 0;
    *((void *)v28 + 4) = v41;
    *((void *)v28 + 5) = 0;
    char v73 = 1;
    float v42 = (float)(unint64_t)(a2[3] + 1);
    float v43 = *((float *)a2 + 8);
    if (v25 && (float)(v43 * (float)v25) >= v42)
    {
LABEL_121:
      uint64_t v64 = *a2;
      uint64_t v65 = *(void **)(*a2 + 8 * v11);
      uint64_t v39 = v69;
      if (v65)
      {
        *(void *)uint64_t v28 = *v65;
      }
      else
      {
        *(void *)uint64_t v28 = *v40;
        void *v40 = v28;
        *(void *)(v64 + 8 * v11) = v40;
        if (!*(void *)v28)
        {
LABEL_130:
          ++a2[3];
          char v20 = HIBYTE(v71);
          goto LABEL_131;
        }
        unint64_t v66 = *(void *)(*(void *)v28 + 8);
        if ((v25 & (v25 - 1)) != 0)
        {
          if (v66 >= v25) {
            v66 %= v25;
          }
        }
        else
        {
          v66 &= v25 - 1;
        }
        uint64_t v65 = (void *)(*a2 + 8 * v66);
      }
      *uint64_t v65 = v28;
      goto LABEL_130;
    }
    BOOL v44 = 1;
    if (v25 >= 3) {
      BOOL v44 = (v25 & (v25 - 1)) != 0;
    }
    unint64_t v45 = v44 | (2 * v25);
    unint64_t v46 = vcvtps_u32_f32(v42 / v43);
    if (v45 <= v46) {
      size_t prime = v46;
    }
    else {
      size_t prime = v45;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v25 = a2[1];
    }
    if (prime <= v25)
    {
      if (prime >= v25) {
        goto LABEL_108;
      }
      unint64_t v58 = vcvtps_u32_f32((float)(unint64_t)a2[3] / *((float *)a2 + 8));
      if (v25 < 3 || (uint8x8_t v59 = (uint8x8_t)vcnt_s8((int8x8_t)v25), v59.i16[0] = vaddlv_u8(v59), v59.u32[0] > 1uLL))
      {
        unint64_t v58 = std::__next_prime(v58);
      }
      else
      {
        uint64_t v60 = 1 << -(char)__clz(v58 - 1);
        if (v58 >= 2) {
          unint64_t v58 = v60;
        }
      }
      if (prime <= v58) {
        size_t prime = v58;
      }
      if (prime >= v25)
      {
        unint64_t v25 = a2[1];
LABEL_108:
        if ((v25 & (v25 - 1)) != 0)
        {
          if (v24 >= v25) {
            size_t v11 = v24 % v25;
          }
          else {
            size_t v11 = v24;
          }
        }
        else
        {
          size_t v11 = (v25 - 1) & v24;
        }
        goto LABEL_121;
      }
      if (!prime)
      {
        long long v67 = (void *)*a2;
        *a2 = 0;
        if (v67) {
          operator delete(v67);
        }
        unint64_t v25 = 0;
        a2[1] = 0;
        goto LABEL_108;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v48 = operator new(8 * prime);
    uint64_t v49 = (void *)*a2;
    *a2 = (uint64_t)v48;
    if (v49) {
      operator delete(v49);
    }
    uint64_t v50 = 0;
    a2[1] = prime;
    do
      *(void *)(*a2 + 8 * v50++) = 0;
    while (prime != v50);
    __int16 v51 = (void *)*v40;
    if (!*v40)
    {
LABEL_107:
      unint64_t v25 = prime;
      goto LABEL_108;
    }
    size_t v52 = v51[1];
    size_t v53 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v54 = v52 & v53;
      *(void *)(*a2 + 8 * v54) = v40;
      for (unint64_t i = (void *)*v51; *v51; unint64_t i = (void *)*v51)
      {
        size_t v56 = i[1] & v53;
        if (v56 == v54)
        {
          __int16 v51 = i;
        }
        else if (*(void *)(*a2 + 8 * v56))
        {
          *__int16 v51 = *i;
          uint64_t v57 = 8 * v56;
          void *i = **(void **)(*a2 + v57);
          **(void **)(*a2 + v57) = i;
        }
        else
        {
          *(void *)(*a2 + 8 * v56) = v51;
          __int16 v51 = i;
          size_t v54 = v56;
        }
      }
      goto LABEL_107;
    }
    if (v52 >= prime) {
      v52 %= prime;
    }
    *(void *)(*a2 + 8 * v52) = v40;
    long long v61 = (void *)*v51;
    if (!*v51) {
      goto LABEL_107;
    }
    while (1)
    {
      size_t v63 = v61[1];
      if (v63 >= prime) {
        v63 %= prime;
      }
      if (v63 != v52)
      {
        if (!*(void *)(*a2 + 8 * v63))
        {
          *(void *)(*a2 + 8 * v63) = v51;
          goto LABEL_112;
        }
        *__int16 v51 = *v61;
        uint64_t v62 = 8 * v63;
        void *v61 = **(void **)(*a2 + v62);
        **(void **)(*a2 + v62) = v61;
        long long v61 = v51;
      }
      size_t v63 = v52;
LABEL_112:
      __int16 v51 = v61;
      long long v61 = (void *)*v61;
      size_t v52 = v63;
      if (!v61) {
        goto LABEL_107;
      }
    }
  }
  if (v26.u32[0] < 2uLL)
  {
    unint64_t v29 = v25 - 1;
    while (1)
    {
      uint64_t v34 = *((void *)v28 + 1);
      if (v34 == v24)
      {
        uint64_t v35 = v28[39];
        if ((v35 & 0x80u) == 0) {
          uint64_t v36 = v28[39];
        }
        else {
          uint64_t v36 = *((void *)v28 + 3);
        }
        if (v36 == v22)
        {
          if ((v35 & 0x80) != 0)
          {
            unint64_t v68 = v29;
            int v38 = memcmp(*((const void **)v28 + 2), v21, *((void *)v28 + 3));
            unint64_t v29 = v68;
            if (!v38) {
              goto LABEL_70;
            }
          }
          else
          {
            if (!v28[39]) {
              goto LABEL_70;
            }
            uint64_t v37 = 0;
            while (v28[v37 + 16] == *((unsigned __int8 *)v21 + v37))
            {
              if (v35 == ++v37) {
                goto LABEL_70;
              }
            }
          }
        }
      }
      else if ((v34 & v29) != v11)
      {
        goto LABEL_71;
      }
      uint64_t v28 = *(unsigned __int8 **)v28;
      if (!v28) {
        goto LABEL_71;
      }
    }
  }
  while (1)
  {
    unint64_t v30 = *((void *)v28 + 1);
    if (v30 == v24) {
      break;
    }
    if (v30 >= v25) {
      v30 %= v25;
    }
    if (v30 != v11) {
      goto LABEL_71;
    }
LABEL_40:
    uint64_t v28 = *(unsigned __int8 **)v28;
    if (!v28) {
      goto LABEL_71;
    }
  }
  uint64_t v31 = v28[39];
  if ((v31 & 0x80u) == 0) {
    uint64_t v32 = v28[39];
  }
  else {
    uint64_t v32 = *((void *)v28 + 3);
  }
  if (v32 != v22) {
    goto LABEL_40;
  }
  if ((v31 & 0x80) == 0)
  {
    if (!v28[39]) {
      goto LABEL_70;
    }
    uint64_t v33 = 0;
    while (v28[v33 + 16] == *((unsigned __int8 *)v21 + v33))
    {
      if (v31 == ++v33) {
        goto LABEL_70;
      }
    }
    goto LABEL_40;
  }
  if (memcmp(*((const void **)v28 + 2), v21, *((void *)v28 + 3))) {
    goto LABEL_40;
  }
LABEL_70:
  uint64_t v39 = v69;
LABEL_131:
  *((void *)v28 + 5) = v39;
  if (v20 < 0) {
    operator delete((void *)__dst);
  }
LABEL_18:
}

void sub_1A1BFC3B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,md::DaVinciGroundSettings::Property>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,md::DaVinciGroundSettings::Property>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t *)va);

  _Unwind_Resume(a1);
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)7>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)7>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)7>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)7>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t result = (void *)gdc::Registry::storage<md::ls::SliceAssignmentT<(md::SliceType)7>>(a2);
  id v3 = result;
  if (result[29] && (unint64_t v4 = (void *)result[28]) != 0)
  {
    uint64_t v5 = result[31];
    uint64_t v6 = result[7];
    uint64_t v7 = (result[8] - v6) >> 3;
    while (1)
    {
      v10[0] = v6;
      v10[1] = v7;
      uint64_t v9 = v5;
      uint64_t v8 = v4[6];
      if (!v8) {
        break;
      }
      uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t *, void *))(*(void *)v8 + 48))(v8, &v9, v10);
      unint64_t v4 = (void *)*v4;
      if (!v4) {
        goto LABEL_6;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    return (void *)std::__function::__func<ecs2::ForwardToExecute<md::ita::CreateDepthPeeledRenderItems>,std::allocator<ecs2::ForwardToExecute<md::ita::CreateDepthPeeledRenderItems>>,void ()(ecs2::Runtime &)>::operator()();
  }
  else
  {
LABEL_6:
    v3[8] = v3[7];
    v3[11] = v3[10];
  }
  return result;
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::CreateDepthPeeledRenderItems>,std::allocator<ecs2::ForwardToExecute<md::ita::CreateDepthPeeledRenderItems>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  v40[3] = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  uint64_t v2 = *(int8x8_t **)(a2 + 8);
  uint64_t v3 = gdc::Registry::storage<md::ls::SliceAssignmentT<(md::SliceType)7>>(v2);
  uint64_t v4 = gdc::Registry::storage<md::ls::RenderableMeshVertexFormat>(v2);
  uint64_t v5 = gdc::Registry::storage<md::ls::TileType>(v2);
  uint64_t v6 = gdc::Registry::storage<md::ls::RequiresDepthPeel>(v2);
  uint64_t v7 = gdc::Registry::storage<md::ls::MeshLayerTypeV>(v2);
  uint64_t v8 = gdc::Registry::storage<md::ls::IntendedSceneLayer>(v2);
  uint64_t v9 = gdc::Registry::storage<md::ls::PendingProcessing>(v2);
  gdc::Registry::storage<md::ls::AssociationHandle>(v2);
  gdc::Registry::storage<md::ls::PrepassConstantDataHandle>(v2);
  gdc::Registry::storage<md::ls::ShadowConstantDataHandle>(v2);
  gdc::Registry::storage<md::ls::PreserveHeight>(v2);
  gdc::Registry::storage<md::ls::HasMeshHandle>(v2);
  gdc::Registry::storage<md::ls::PositionScaleInfoConstantDataHandle>(v2);
  gdc::Registry::storage<md::ls::ViewConstantDataHandle>(v2);
  uint64_t v30 = gdc::Registry::storage<md::ls::TransformConstantDataHandle>(v2);
  uint64_t v29 = gdc::Registry::storage<md::ls::IndexRange>(v2);
  uint64_t v28 = gdc::Registry::storage<md::ls::NormalsHandle>(v2);
  uint64_t v27 = gdc::Registry::storage<md::ls::InstanceTransformHandle>(v2);
  uint64_t v26 = gdc::Registry::storage<md::ls::UVsHandle>(v2);
  uint64_t v25 = gdc::Registry::storage<md::ls::NeedsZBias>(v2);
  uint64_t v24 = gdc::Registry::storage<md::ls::ClippingConstantDataHandle>(v2);
  gdc::Registry::storage<md::ls::IsMercator>(v2);
  gdc::Registry::storage<md::ls::ElevationHandle>(v2);
  if (*(void *)(v4 + 64) - *(void *)(v4 + 56) >= *(void *)(v3 + 64) - *(void *)(v3 + 56)) {
    uint64_t v10 = v3 + 32;
  }
  else {
    uint64_t v10 = v4 + 32;
  }
  if (*(void *)(v5 + 64) - *(void *)(v5 + 56) < *(void *)(v10 + 32) - *(void *)(v10 + 24)) {
    uint64_t v10 = v5 + 32;
  }
  unint64_t v32 = *(void *)(v6 + 64) - *(void *)(v6 + 56);
  if (v32 < *(void *)(v10 + 32) - *(void *)(v10 + 24)) {
    uint64_t v10 = v6 + 32;
  }
  unint64_t v31 = *(void *)(v7 + 64) - *(void *)(v7 + 56);
  if (v31 < *(void *)(v10 + 32) - *(void *)(v10 + 24)) {
    uint64_t v10 = v7 + 32;
  }
  if (*(void *)(v8 + 64) - *(void *)(v8 + 56) < *(void *)(v10 + 32) - *(void *)(v10 + 24)) {
    uint64_t v10 = v8 + 32;
  }
  if (*(void *)(v9 + 64) - *(void *)(v9 + 56) < *(void *)(v10 + 32) - *(void *)(v10 + 24)) {
    uint64_t v10 = v9 + 32;
  }
  v35[0] = v10;
  v35[1] = v3;
  v35[2] = v4;
  void v35[3] = v5;
  v35[4] = v6;
  v35[5] = v7;
  v35[6] = v8;
  v35[7] = v9;
  size_t v11 = *(void **)(v10 + 24);
  uint64_t v12 = *(void **)(v10 + 32);
  uint64_t v36 = v11;
  if (v12 != v11
    && !gdc::RegistryQueryView<gdc::All<md::ls::SliceAssignmentT<(md::SliceType)7> const,md::ls::RenderableMeshVertexFormat const,md::ls::TileType const,md::ls::RequiresDepthPeel const,md::ls::MeshLayerTypeV const,md::ls::IntendedSceneLayer const,md::ls::PendingProcessing const>,gdc::Any<md::ls::AssociationHandle,md::ls::PrepassConstantDataHandle,md::ls::ShadowConstantDataHandle,md::ls::PreserveHeight,md::ls::HasMeshHandle,md::ls::PositionScaleInfoConstantDataHandle,md::ls::ViewConstantDataHandle,md::ls::TransformConstantDataHandle,md::ls::IndexRange,md::ls::NormalsHandle,md::ls::InstanceTransformHandle,md::ls::UVsHandle,md::ls::NeedsZBias,md::ls::ClippingConstantDataHandle,md::ls::IsMercator,md::ls::ElevationHandle>,gdc::None<>>::Iterator::isValid(v35))
  {
    uint64_t v13 = v11 + 1;
    do
    {
      size_t v11 = v13;
      uint64_t v36 = v13;
      if (v13 == v12) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::SliceAssignmentT<(md::SliceType)7> const,md::ls::RenderableMeshVertexFormat const,md::ls::TileType const,md::ls::RequiresDepthPeel const,md::ls::MeshLayerTypeV const,md::ls::IntendedSceneLayer const,md::ls::PendingProcessing const>,gdc::Any<md::ls::AssociationHandle,md::ls::PrepassConstantDataHandle,md::ls::ShadowConstantDataHandle,md::ls::PreserveHeight,md::ls::HasMeshHandle,md::ls::PositionScaleInfoConstantDataHandle,md::ls::ViewConstantDataHandle,md::ls::TransformConstantDataHandle,md::ls::IndexRange,md::ls::NormalsHandle,md::ls::InstanceTransformHandle,md::ls::UVsHandle,md::ls::NeedsZBias,md::ls::ClippingConstantDataHandle,md::ls::IsMercator,md::ls::ElevationHandle>,gdc::None<>>::Iterator::isValid(v35);
      uint64_t v13 = v11 + 1;
    }
    while (!isValid);
  }
  uint64_t result = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  unint64_t v23 = v16;
  uint64_t v17 = a1;
  if (v16 != v11)
  {
    *uint64_t result = *v11;
    uint64_t v18 = **(void **)(a1 + 8);
    uint64_t v19 = *(void **)v18;
    char v20 = *(void **)(v18 + 8);
    if (v19 != v20)
    {
      while (*v19 != 0x41D4E9297E100630)
      {
        v19 += 5;
        if (v19 == v20) {
          goto LABEL_28;
        }
      }
    }
    if (v19 == v20)
    {
LABEL_28:
      uint64_t v21 = 0;
    }
    else
    {
      uint64_t v21 = (void *)v19[3];
      unint64_t v22 = (std::__shared_weak_count *)v19[4];
      if (v22)
      {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        if (!atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void *, void *))v22->__on_zero_shared)(v22, v30, v29, v28, v27, v26, v25, v24, v7, v40, v23);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
    }
    if (!v21[1320])
    {
      uint64_t v37 = v21[1312] + 1992;
      unint64_t v33 = geo::packed_array<md::RenderStateStorage,geo::handle<md::RenderStateItem>>::push_back(v21 + 91, &v37);
      int64x2_t v38 = vdupq_n_s64(1uLL);
      LOBYTE(v39) = 1;
      std::__hash_table<std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::RenderStateItem>,std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>,std::hash<geo::handle<md::RenderStateItem>>,std::equal_to<geo::handle<md::RenderStateItem>>,true>,std::__unordered_map_equal<geo::handle<md::RenderStateItem>,std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>,std::equal_to<geo::handle<md::RenderStateItem>>,std::hash<geo::handle<md::RenderStateItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::RenderStateItem>,geo::handle<md::RenderStateItem> const&,md::Counter>((uint64_t)(v21 + 86), v33, v33, (uint64_t)&v38);
      v21[1320] = v33;
      uint64_t v17 = a1;
    }
    gdc::Registry::create(*(gdc::Registry **)(*(void *)(v17 + 8) + 8));
  }
  *uint64_t result = 0xFFFFFFFF00000000;
  *(void *)(a1 + 8) = 0;
  return result;
}

uint64_t gdc::Registry::storage<md::ls::SliceAssignmentT<(md::SliceType)7>>(int8x8_t *a1)
{
  unint64_t v10 = 0xAC1208F38C3ADC06;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xAC1208F38C3ADC06;
    if (*(void *)&v1 <= 0xAC1208F38C3ADC06) {
      unint64_t v3 = 0xAC1208F38C3ADC06 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xAC1208F38C3ADC06;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xAC1208F38C3ADC06)
      {
        if (v5[2] == 0xAC1208F38C3ADC06) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xAC1208F38C3ADC06) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xAC1208F38C3ADC06) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1BFEFCC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::RequiresDepthPeel>(int8x8_t *a1)
{
  unint64_t v10 = 0xCB7F6519084BB4D0;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xCB7F6519084BB4D0;
    if (*(void *)&v1 <= 0xCB7F6519084BB4D0) {
      unint64_t v3 = 0xCB7F6519084BB4D0 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xCB7F6519084BB4D0;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xCB7F6519084BB4D0)
      {
        if (v5[2] == 0xCB7F6519084BB4D0) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xCB7F6519084BB4D0) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xCB7F6519084BB4D0) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1BFF23C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **>(a1, a2, a3, a4);
  uint64_t result = *a5;
  if (*a5 != *a4)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
    if (result)
    {
      uint64_t v11 = *a4;
      *a4 = *a5;
      *a5 = v11;
      uint64_t result = *a4;
      if (*a4 != *a3)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
        if (result)
        {
          uint64_t v12 = *a3;
          *a3 = *a4;
          *a4 = v12;
          uint64_t result = *a3;
          if (*a3 != *a2)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
            if (result)
            {
              uint64_t v13 = *a2;
              *a2 = *a3;
              *a3 = v13;
              uint64_t result = *a2;
              if (*a2 != *a1)
              {
                uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
                if (result)
                {
                  uint64_t v14 = *a1;
                  *a1 = *a2;
                  *a2 = v14;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **>(a1, a2, a3);
  uint64_t result = *a4;
  if (*a4 != *a3)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
    if (result)
    {
      uint64_t v9 = *a3;
      *a3 = *a4;
      *a4 = v9;
      uint64_t result = *a3;
      if (*a3 != *a2)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
        if (result)
        {
          uint64_t v10 = *a2;
          *a2 = *a3;
          *a3 = v10;
          uint64_t result = *a2;
          if (*a2 != *a1)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
            if (result)
            {
              uint64_t v11 = *a1;
              *a1 = *a2;
              *a2 = v11;
            }
          }
        }
      }
    }
  }
  return result;
}

void ggl::StarsShader::typedReflection(ggl::StarsShader *this)
{
  {
    if (v1)
    {
      ggl::StarsShader::typedReflection(void)::ref = (uint64_t)"StarsShader";
      ggl::starsShaderVertexFunctionDescriptor(v1);
      qword_1EB3207A8 = (uint64_t)&ggl::starsShaderVertexFunctionDescriptor(void)::ref;
      uint8x8_t v2 = (ggl *)ggl::crc32::compute<18ul>("StarsShaderVertex");
      dword_1EB3207B0 = (int)v2;
      ggl::starsShaderFragmentFunctionDescriptor(v2);
      qword_1EB3207B8 = (uint64_t)&ggl::starsShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB3207C0 = ggl::crc32::compute<20ul>("StarsShaderFragment");
      qword_1EB3207C8 = (uint64_t)ggl::starsShaderShaderConstants(void)::ref;
      unk_1EB3207D0 = 1;
      qword_1EB3207D8 = (uint64_t)&ggl::starsShaderShaderTextures(void)::ref;
      unk_1EB3207E0 = 0;
      qword_1EB3207E8 = (uint64_t)&ggl::starsShaderShaderSamplers(void)::ref;
      unk_1EB3207F0 = 0;
    }
  }
}

void ggl::starsShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::starsShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<20ul>("StarsShaderFragment");
    *(_DWORD *)algn_1EB32491C = 1;
    qword_1EB324920 = (uint64_t)"StarsShader";
    unk_1EB324928 = 0;
    qword_1EB324930 = 0;
    unk_1EB324938 = &ggl::starsShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB324940 = 0;
    unk_1EB324948 = &ggl::starsShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB324950 = 0;
    unk_1EB324958 = &ggl::starsShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB324960 = 0;
    unk_1EB324968 = &ggl::starsShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB324978 = 0;
    unk_1EB324980 = 0;
    qword_1EB324970 = 0;
  }
}

void ggl::starsShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::starsShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<18ul>("StarsShaderVertex");
    *(_DWORD *)algn_1EB324254 = 0;
    qword_1EB324258 = (uint64_t)"StarsShader";
    unk_1EB324260 = ggl::starsShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB324268 = 1;
    unk_1EB324270 = &ggl::starsShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB324278 = 1;
    unk_1EB324280 = &ggl::starsShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB324288 = 0;
    unk_1EB324290 = &ggl::starsShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB324298 = 0;
    unk_1EB3242A0 = &ggl::starsShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB3242B0 = 0;
    unk_1EB3242B8 = 0;
    qword_1EB3242A8 = 0;
  }
}

void ggl::PointShader::typedReflection(ggl::PointShader *this)
{
  {
    if (v1)
    {
      ggl::PointShader::typedReflection(void)::ref = (uint64_t)"PointShader";
      ggl::pointShaderVertexFunctionDescriptor(v1);
      qword_1EB3206F0 = (uint64_t)&ggl::pointShaderVertexFunctionDescriptor(void)::ref;
      uint8x8_t v2 = (ggl *)ggl::crc32::compute<18ul>("PointShaderVertex");
      dword_1EB3206F8 = (int)v2;
      ggl::pointShaderFragmentFunctionDescriptor(v2);
      qword_1EB320700 = (uint64_t)&ggl::pointShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB320708 = ggl::crc32::compute<20ul>("PointShaderFragment");
      qword_1EB320710 = (uint64_t)ggl::pointShaderShaderConstants(void)::ref;
      unk_1EB320718 = 2;
      qword_1EB320720 = (uint64_t)&ggl::pointShaderShaderTextures(void)::ref;
      unk_1EB320728 = 0;
      qword_1EB320730 = (uint64_t)&ggl::pointShaderShaderSamplers(void)::ref;
      unk_1EB320738 = 0;
    }
  }
}

void ggl::pointShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::pointShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<20ul>("PointShaderFragment");
    *(_DWORD *)algn_1EB3248A4 = 1;
    qword_1EB3248A8 = (uint64_t)"PointShader";
    unk_1EB3248B0 = 0;
    qword_1EB3248B8 = 0;
    unk_1EB3248C0 = &ggl::pointShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB3248C8 = 1;
    unk_1EB3248D0 = &ggl::pointShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB3248D8 = 0;
    unk_1EB3248E0 = &ggl::pointShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB3248E8 = 0;
    unk_1EB3248F0 = &ggl::pointShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB324900 = 0;
    unk_1EB324908 = 0;
    qword_1EB3248F8 = 0;
  }
}

void ggl::pointShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::pointShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<18ul>("PointShaderVertex");
    *(_DWORD *)algn_1EB32416C = 0;
    qword_1EB324170 = (uint64_t)"PointShader";
    unk_1EB324178 = ggl::pointShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB324180 = 1;
    unk_1EB324188 = &ggl::pointShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB324190 = 2;
    unk_1EB324198 = &ggl::pointShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB3241A0 = 0;
    unk_1EB3241A8 = &ggl::pointShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB3241B0 = 0;
    unk_1EB3241B8 = &ggl::pointShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB3241C8 = 0;
    unk_1EB3241D0 = 0;
    qword_1EB3241C0 = 0;
  }
}

void ggl::BlurYShader::typedReflection(ggl::BlurYShader *this)
{
  {
    if (v1)
    {
      ggl::BlurYShader::typedReflection(void)::ref = (uint64_t)"BlurYShader";
      ggl::blurYShaderVertexFunctionDescriptor(v1);
      qword_1EB3205D8 = (uint64_t)&ggl::blurYShaderVertexFunctionDescriptor(void)::ref;
      uint8x8_t v2 = (ggl *)ggl::crc32::compute<18ul>("BlurYShaderVertex");
      dword_1EB3205E0 = (int)v2;
      ggl::blurYShaderFragmentFunctionDescriptor(v2);
      qword_1EB3205E8 = (uint64_t)&ggl::blurYShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB3205F0 = ggl::crc32::compute<20ul>("BlurYShaderFragment");
      qword_1EB3205F8 = (uint64_t)&ggl::blurYShaderShaderConstants(void)::ref;
      unk_1EB320600 = 0;
      qword_1EB320608 = (uint64_t)ggl::blurYShaderShaderTextures(void)::ref;
      unk_1EB320610 = 1;
      qword_1EB320618 = (uint64_t)ggl::blurYShaderShaderSamplers(void)::ref;
      unk_1EB320620 = 1;
    }
  }
}

void ggl::blurYShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::blurYShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<20ul>("BlurYShaderFragment");
    *(_DWORD *)algn_1EB3246DC = 1;
    qword_1EB3246E0 = (uint64_t)"BlurYShader";
    unk_1EB3246E8 = 0;
    qword_1EB3246F0 = 0;
    unk_1EB3246F8 = &ggl::blurYShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB324700 = 0;
    unk_1EB324708 = &ggl::blurYShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB324710 = 0;
    unk_1EB324718 = &ggl::blurYShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB324720 = 1;
    unk_1EB324728 = &ggl::blurYShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB324738 = 0;
    unk_1EB324740 = 0;
    qword_1EB324730 = 1;
  }
}

void ggl::blurYShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::blurYShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<18ul>("BlurYShaderVertex");
    *(_DWORD *)algn_1EB324014 = 0;
    qword_1EB324018 = (uint64_t)"BlurYShader";
    unk_1EB324020 = ggl::blurYShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB324028 = 1;
    unk_1EB324030 = &ggl::blurYShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB324038 = 0;
    unk_1EB324040 = &ggl::blurYShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB324048 = 0;
    unk_1EB324050 = &ggl::blurYShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB324058 = 0;
    unk_1EB324060 = &ggl::blurYShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB324070 = 0;
    unk_1EB324078 = 0;
    qword_1EB324068 = 0;
  }
}

void ggl::BlurXShader::typedReflection(ggl::BlurXShader *this)
{
  {
    if (v1)
    {
      ggl::BlurXShader::typedReflection(void)::ref = (uint64_t)"BlurXShader";
      ggl::blurXShaderVertexFunctionDescriptor(v1);
      qword_1EB320578 = (uint64_t)&ggl::blurXShaderVertexFunctionDescriptor(void)::ref;
      uint8x8_t v2 = (ggl *)ggl::crc32::compute<18ul>("BlurXShaderVertex");
      dword_1EB320580 = (int)v2;
      ggl::blurXShaderFragmentFunctionDescriptor(v2);
      qword_1EB320588 = (uint64_t)&ggl::blurXShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB320590 = ggl::crc32::compute<20ul>("BlurXShaderFragment");
      qword_1EB320598 = (uint64_t)&ggl::blurXShaderShaderConstants(void)::ref;
      unk_1EB3205A0 = 0;
      qword_1EB3205A8 = (uint64_t)ggl::blurXShaderShaderTextures(void)::ref;
      unk_1EB3205B0 = 1;
      qword_1EB3205B8 = (uint64_t)ggl::blurXShaderShaderSamplers(void)::ref;
      unk_1EB3205C0 = 1;
    }
  }
}

void ggl::blurXShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::blurXShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<20ul>("BlurXShaderFragment");
    *(_DWORD *)algn_1EB32466C = 1;
    qword_1EB324670 = (uint64_t)"BlurXShader";
    unk_1EB324678 = 0;
    qword_1EB324680 = 0;
    unk_1EB324688 = &ggl::blurXShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB324690 = 0;
    unk_1EB324698 = &ggl::blurXShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB3246A0 = 0;
    unk_1EB3246A8 = &ggl::blurXShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB3246B0 = 1;
    unk_1EB3246B8 = &ggl::blurXShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB3246C8 = 0;
    unk_1EB3246D0 = 0;
    qword_1EB3246C0 = 1;
  }
}

void ggl::blurXShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::blurXShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<18ul>("BlurXShaderVertex");
    *(_DWORD *)algn_1EB323FA4 = 0;
    qword_1EB323FA8 = (uint64_t)"BlurXShader";
    unk_1EB323FB0 = ggl::blurXShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB323FB8 = 1;
    unk_1EB323FC0 = &ggl::blurXShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB323FC8 = 0;
    unk_1EB323FD0 = &ggl::blurXShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB323FD8 = 0;
    unk_1EB323FE0 = &ggl::blurXShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB323FE8 = 0;
    unk_1EB323FF0 = &ggl::blurXShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB324000 = 0;
    unk_1EB324008 = 0;
    qword_1EB323FF8 = 0;
  }
}

void ggl::ClearShader::typedReflection(ggl::ClearShader *this)
{
  {
    if (v1)
    {
      ggl::ClearShader::typedReflection(void)::ref = (uint64_t)"ClearShader";
      ggl::clearShaderVertexFunctionDescriptor(v1);
      qword_1EB320630 = (uint64_t)&ggl::clearShaderVertexFunctionDescriptor(void)::ref;
      uint8x8_t v2 = (ggl *)ggl::crc32::compute<18ul>("ClearShaderVertex");
      dword_1EB320638 = (int)v2;
      ggl::clearShaderFragmentFunctionDescriptor(v2);
      qword_1EB320640 = (uint64_t)&ggl::clearShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB320648 = ggl::crc32::compute<20ul>("ClearShaderFragment");
      qword_1EB320650 = (uint64_t)ggl::clearShaderShaderConstants(void)::ref;
      unk_1EB320658 = 1;
      qword_1EB320660 = (uint64_t)&ggl::clearShaderShaderTextures(void)::ref;
      unk_1EB320668 = 0;
      qword_1EB320670 = (uint64_t)&ggl::clearShaderShaderSamplers(void)::ref;
      unk_1EB320678 = 0;
    }
  }
}

void ggl::clearShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::clearShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<20ul>("ClearShaderFragment");
    *(_DWORD *)algn_1EB32C974 = 1;
    qword_1EB32C978 = (uint64_t)"ClearShader";
    unk_1EB32C980 = 0;
    qword_1EB32C988 = 0;
    unk_1EB32C990 = &ggl::clearShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB32C998 = 1;
    unk_1EB32C9A0 = &ggl::clearShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB32C9A8 = 0;
    unk_1EB32C9B0 = &ggl::clearShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB32C9B8 = 0;
    unk_1EB32C9C0 = &ggl::clearShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB32C9D0 = 0;
    unk_1EB32C9D8 = 0;
    qword_1EB32C9C8 = 0;
  }
}

void ggl::clearShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::clearShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<18ul>("ClearShaderVertex");
    *(_DWORD *)algn_1EB34D0CC = 0;
    qword_1EB34D0D0 = (uint64_t)"ClearShader";
    unk_1EB34D0D8 = ggl::clearShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB34D0E0 = 1;
    unk_1EB34D0E8 = &ggl::clearShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB34D0F0 = 1;
    unk_1EB34D0F8 = &ggl::clearShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB34D100 = 0;
    unk_1EB34D108 = &ggl::clearShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB34D110 = 0;
    unk_1EB34D118 = &ggl::clearShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB34D128 = 0;
    unk_1EB34D130 = 0;
    qword_1EB34D120 = 0;
  }
}

void ggl::SkyShader::typedReflection(ggl::SkyShader *this)
{
  {
    if (v1)
    {
      ggl::SkyShader::typedReflection(void)::ref = (uint64_t)"SkyShader";
      ggl::skyShaderVertexFunctionDescriptor(v1);
      qword_1EB323B38 = (uint64_t)&ggl::skyShaderVertexFunctionDescriptor(void)::ref;
      uint8x8_t v2 = (ggl *)ggl::crc32::compute<16ul>("SkyShaderVertex");
      dword_1EB323B40 = (int)v2;
      ggl::skyShaderFragmentFunctionDescriptor(v2);
      qword_1EB323B48 = (uint64_t)&ggl::skyShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB323B50 = ggl::crc32::compute<18ul>("SkyShaderFragment");
      qword_1EB323B58 = (uint64_t)ggl::skyShaderShaderConstants(void)::ref;
      unk_1EB323B60 = 1;
      qword_1EB323B68 = (uint64_t)&ggl::skyShaderShaderTextures(void)::ref;
      unk_1EB323B70 = 0;
      qword_1EB323B78 = (uint64_t)&ggl::skyShaderShaderSamplers(void)::ref;
      unk_1EB323B80 = 0;
    }
  }
}

void ggl::FogShader::typedReflection(ggl::FogShader *this)
{
  {
    if (v1)
    {
      ggl::FogShader::typedReflection(void)::ref = (uint64_t)"FogShader";
      ggl::fogShaderVertexFunctionDescriptor(v1);
      qword_1EB323A28 = (uint64_t)&ggl::fogShaderVertexFunctionDescriptor(void)::ref;
      uint8x8_t v2 = (ggl *)ggl::crc32::compute<16ul>("FogShaderVertex");
      dword_1EB323A30 = (int)v2;
      ggl::fogShaderFragmentFunctionDescriptor(v2);
      qword_1EB323A38 = (uint64_t)&ggl::fogShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB323A40 = ggl::crc32::compute<18ul>("FogShaderFragment");
      qword_1EB323A48 = (uint64_t)ggl::fogShaderShaderConstants(void)::ref;
      unk_1EB323A50 = 2;
      qword_1EB323A58 = (uint64_t)&ggl::fogShaderShaderTextures(void)::ref;
      unk_1EB323A60 = 0;
      qword_1EB323A68 = (uint64_t)&ggl::fogShaderShaderSamplers(void)::ref;
      unk_1EB323A70 = 0;
    }
  }
}

uint64_t ggl::crc32::compute<16ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  return ggl::crc32::crc32Table[v12 ^ a1[14]] ^ ~(v12 >> 8);
}

void ggl::skyShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::skyShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<18ul>("SkyShaderFragment");
    *(_DWORD *)algn_1EB3241DC = 1;
    qword_1EB3241E0 = (uint64_t)"SkyShader";
    unk_1EB3241E8 = 0;
    qword_1EB3241F0 = 0;
    unk_1EB3241F8 = &ggl::skyShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB324200 = 1;
    unk_1EB324208 = &ggl::skyShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB324210 = 0;
    unk_1EB324218 = &ggl::skyShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB324220 = 0;
    unk_1EB324228 = &ggl::skyShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB324238 = 0;
    unk_1EB324240 = 0;
    qword_1EB324230 = 0;
  }
}

void ggl::fogShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::fogShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<18ul>("FogShaderFragment");
    *(_DWORD *)algn_1EB3240FC = 1;
    qword_1EB324100 = (uint64_t)"FogShader";
    unk_1EB324108 = 0;
    qword_1EB324110 = 0;
    unk_1EB324118 = &ggl::fogShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB324120 = 0;
    unk_1EB324128 = &ggl::fogShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB324130 = 0;
    unk_1EB324138 = &ggl::fogShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB324140 = 0;
    unk_1EB324148 = &ggl::fogShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB324158 = 0;
    unk_1EB324160 = 0;
    qword_1EB324150 = 0;
  }
}

void ggl::skyShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::skyShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<16ul>("SkyShaderVertex");
    *(_DWORD *)algn_1EB323C64 = 0;
    qword_1EB323C68 = (uint64_t)"SkyShader";
    unk_1EB323C70 = ggl::skyShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB323C78 = 1;
    unk_1EB323C80 = &ggl::skyShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB323C88 = 1;
    unk_1EB323C90 = &ggl::skyShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB323C98 = 0;
    unk_1EB323CA0 = &ggl::skyShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB323CA8 = 0;
    unk_1EB323CB0 = &ggl::skyShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB323CC0 = 0;
    unk_1EB323CC8 = 0;
    qword_1EB323CB8 = 0;
  }
}

void ggl::fogShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::fogShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<16ul>("FogShaderVertex");
    *(_DWORD *)algn_1EB323BF4 = 0;
    qword_1EB323BF8 = (uint64_t)"FogShader";
    unk_1EB323C00 = ggl::fogShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB323C08 = 1;
    unk_1EB323C10 = &ggl::fogShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB323C18 = 2;
    unk_1EB323C20 = &ggl::fogShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB323C28 = 0;
    unk_1EB323C30 = &ggl::fogShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB323C38 = 0;
    unk_1EB323C40 = &ggl::fogShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB323C50 = 0;
    unk_1EB323C58 = 0;
    qword_1EB323C48 = 0;
  }
}

void ggl::ARMeshShader::typedReflection(ggl::ARMeshShader *this)
{
  {
    if (v1)
    {
      ggl::ARMeshShader::typedReflection(void)::ref = (uint64_t)"ARMeshShader";
      ggl::aRMeshShaderVertexFunctionDescriptor(v1);
      qword_1EB31A100 = (uint64_t)&ggl::aRMeshShaderVertexFunctionDescriptor(void)::ref;
      unsigned int v2 = (ggl *)ggl::crc32::compute<19ul>("ARMeshShaderVertex");
      dword_1EB31A108 = (int)v2;
      ggl::aRMeshShaderFragmentFunctionDescriptor(v2);
      qword_1EB31A110 = (uint64_t)&ggl::aRMeshShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB31A118 = ggl::crc32::compute<21ul>("ARMeshShaderFragment");
      qword_1EB31A120 = (uint64_t)ggl::aRMeshShaderShaderConstants(void)::ref;
      unk_1EB31A128 = 7;
      qword_1EB31A130 = (uint64_t)ggl::aRMeshShaderShaderTextures(void)::ref;
      unk_1EB31A138 = 2;
      qword_1EB31A140 = (uint64_t)ggl::aRMeshShaderShaderSamplers(void)::ref;
      unk_1EB31A148 = 2;
    }
  }
}

void ggl::aRMeshShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::aRMeshShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<21ul>("ARMeshShaderFragment");
    *(_DWORD *)algn_1EB31A6DC = 1;
    qword_1EB31A6E0 = (uint64_t)"ARMeshShader";
    unk_1EB31A6E8 = 0;
    qword_1EB31A6F0 = 0;
    unk_1EB31A6F8 = &ggl::aRMeshShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB31A700 = 4;
    unk_1EB31A708 = &ggl::aRMeshShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB31A710 = 0;
    unk_1EB31A718 = &ggl::aRMeshShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB31A720 = 2;
    unk_1EB31A728 = &ggl::aRMeshShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB31A738 = 0;
    unk_1EB31A740 = 0;
    qword_1EB31A730 = 2;
  }
}

void ggl::aRMeshShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::aRMeshShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<19ul>("ARMeshShaderVertex");
    *(_DWORD *)algn_1EB31E45C = 0;
    qword_1EB31E460 = (uint64_t)"ARMeshShader";
    unk_1EB31E468 = ggl::aRMeshShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB31E470 = 2;
    unk_1EB31E478 = &ggl::aRMeshShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB31E480 = 3;
    unk_1EB31E488 = &ggl::aRMeshShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB31E490 = 1;
    unk_1EB31E498 = &ggl::aRMeshShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB31E4A0 = 0;
    unk_1EB31E4A8 = &ggl::aRMeshShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB31E4B8 = 0;
    unk_1EB31E4C0 = 0;
    qword_1EB31E4B0 = 0;
  }
}

void ggl::GridUVShader::typedReflection(ggl::GridUVShader *this)
{
  {
    if (v1)
    {
      ggl::GridUVShader::typedReflection(void)::ref = (uint64_t)"GridUVShader";
      ggl::gridUVShaderVertexFunctionDescriptor(v1);
      qword_1E9582298 = (uint64_t)&ggl::gridUVShaderVertexFunctionDescriptor(void)::ref;
      unsigned int v2 = (ggl *)ggl::crc32::compute<19ul>("GridUVShaderVertex");
      dword_1E95822A0 = (int)v2;
      ggl::gridUVShaderFragmentFunctionDescriptor(v2);
      qword_1E95822A8 = (uint64_t)&ggl::gridUVShaderFragmentFunctionDescriptor(void)::ref;
      dword_1E95822B0 = ggl::crc32::compute<21ul>("GridUVShaderFragment");
      qword_1E95822B8 = (uint64_t)ggl::gridUVShaderShaderConstants(void)::ref;
      unk_1E95822C0 = 4;
      qword_1E95822C8 = (uint64_t)&ggl::gridUVShaderShaderTextures(void)::ref;
      unk_1E95822D0 = 0;
      qword_1E95822D8 = (uint64_t)&ggl::gridUVShaderShaderSamplers(void)::ref;
      unk_1E95822E0 = 0;
    }
  }
}

void ggl::gridUVShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::gridUVShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<21ul>("GridUVShaderFragment");
    *(_DWORD *)algn_1E958C01C = 1;
    qword_1E958C020 = (uint64_t)"GridUVShader";
    unk_1E958C028 = 0;
    qword_1E958C030 = 0;
    unk_1E958C038 = &ggl::gridUVShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1E958C040 = 2;
    unk_1E958C048 = &ggl::gridUVShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1E958C050 = 0;
    unk_1E958C058 = &ggl::gridUVShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1E958C060 = 0;
    unk_1E958C068 = &ggl::gridUVShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1E958C078 = 0;
    unk_1E958C080 = 0;
    qword_1E958C070 = 0;
  }
}

void ggl::gridUVShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::gridUVShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<19ul>("GridUVShaderVertex");
    *(_DWORD *)algn_1E958BF34 = 0;
    qword_1E958BF38 = (uint64_t)"GridUVShader";
    unk_1E958BF40 = ggl::gridUVShaderVertShaderFunctionAttributes(void)::ref;
    qword_1E958BF48 = 1;
    unk_1E958BF50 = &ggl::gridUVShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1E958BF58 = 4;
    unk_1E958BF60 = &ggl::gridUVShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1E958BF68 = 0;
    unk_1E958BF70 = &ggl::gridUVShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1E958BF78 = 0;
    unk_1E958BF80 = &ggl::gridUVShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1E958BF90 = 0;
    unk_1E958BF98 = 0;
    qword_1E958BF88 = 0;
  }
}

void ggl::GridShader::typedReflection(ggl::GridShader *this)
{
  {
    if (v1)
    {
      ggl::GridShader::typedReflection(void)::ref = (uint64_t)"GridShader";
      ggl::gridShaderVertexFunctionDescriptor(v1);
      qword_1EB320418 = (uint64_t)&ggl::gridShaderVertexFunctionDescriptor(void)::ref;
      unsigned int v2 = (ggl *)ggl::crc32::compute<17ul>("GridShaderVertex");
      dword_1EB320420 = (int)v2;
      ggl::gridShaderFragmentFunctionDescriptor(v2);
      qword_1EB320428 = (uint64_t)&ggl::gridShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB320430 = ggl::crc32::compute<19ul>("GridShaderFragment");
      qword_1EB320438 = (uint64_t)ggl::gridShaderShaderConstants(void)::ref;
      unk_1EB320440 = 4;
      qword_1EB320448 = (uint64_t)&ggl::gridShaderShaderTextures(void)::ref;
      unk_1EB320450 = 0;
      qword_1EB320458 = (uint64_t)&ggl::gridShaderShaderSamplers(void)::ref;
      unk_1EB320460 = 0;
    }
  }
}

void ggl::gridShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::gridShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<19ul>("GridShaderFragment");
    *(_DWORD *)algn_1EB32448C = 1;
    qword_1EB324490 = (uint64_t)"GridShader";
    unk_1EB324498 = 0;
    qword_1EB3244A0 = 0;
    unk_1EB3244A8 = &ggl::gridShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB3244B0 = 2;
    unk_1EB3244B8 = &ggl::gridShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB3244C0 = 0;
    unk_1EB3244C8 = &ggl::gridShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB3244D0 = 0;
    unk_1EB3244D8 = &ggl::gridShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB3244E8 = 0;
    unk_1EB3244F0 = 0;
    qword_1EB3244E0 = 0;
  }
}

void ggl::gridShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::gridShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<17ul>("GridShaderVertex");
    *(_DWORD *)algn_1EB323DC4 = 0;
    qword_1EB323DC8 = (uint64_t)"GridShader";
    unk_1EB323DD0 = ggl::gridShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB323DD8 = 1;
    unk_1EB323DE0 = &ggl::gridShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB323DE8 = 4;
    unk_1EB323DF0 = &ggl::gridShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB323DF8 = 0;
    unk_1EB323E00 = &ggl::gridShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB323E08 = 0;
    unk_1EB323E10 = &ggl::gridShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB323E20 = 0;
    unk_1EB323E28 = 0;
    qword_1EB323E18 = 0;
  }
}

void ggl::ClutShader::typedReflection(ggl::ClutShader *this)
{
  {
    if (v1)
    {
      ggl::ClutShader::typedReflection(void)::ref = (uint64_t)"ClutShader";
      ggl::clutShaderVertexFunctionDescriptor(v1);
      qword_1EB320360 = (uint64_t)&ggl::clutShaderVertexFunctionDescriptor(void)::ref;
      unsigned int v2 = (ggl *)ggl::crc32::compute<17ul>("ClutShaderVertex");
      dword_1EB320368 = (int)v2;
      ggl::clutShaderFragmentFunctionDescriptor(v2);
      qword_1EB320370 = (uint64_t)&ggl::clutShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB320378 = ggl::crc32::compute<19ul>("ClutShaderFragment");
      qword_1EB320380 = (uint64_t)ggl::clutShaderShaderConstants(void)::ref;
      unk_1EB320388 = 3;
      qword_1EB320390 = (uint64_t)ggl::clutShaderShaderTextures(void)::ref;
      unk_1EB320398 = 2;
      qword_1EB3203A0 = (uint64_t)ggl::clutShaderShaderSamplers(void)::ref;
      unk_1EB3203A8 = 2;
    }
  }
}

void ggl::clutShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::clutShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<19ul>("ClutShaderFragment");
    *(_DWORD *)algn_1EB3243A4 = 1;
    qword_1EB3243B8 = 0;
    unk_1EB3243C0 = &ggl::clutShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB3243A8 = (uint64_t)"ClutShader";
    unk_1EB3243B0 = 0;
    qword_1EB3243C8 = 1;
    unk_1EB3243D0 = &ggl::clutShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB3243D8 = 0;
    unk_1EB3243E0 = &ggl::clutShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB3243E8 = 2;
    unk_1EB3243F0 = &ggl::clutShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB324400 = 0;
    unk_1EB324408 = 0;
    qword_1EB3243F8 = 2;
  }
}

void ggl::clutShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::clutShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<17ul>("ClutShaderVertex");
    *(_DWORD *)algn_1EB323CDC = 0;
    qword_1EB323CE0 = (uint64_t)"ClutShader";
    unk_1EB323CE8 = ggl::clutShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB323CF0 = 1;
    unk_1EB323CF8 = &ggl::clutShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB323D00 = 3;
    unk_1EB323D08 = &ggl::clutShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB323D10 = 0;
    unk_1EB323D18 = &ggl::clutShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB323D20 = 0;
    unk_1EB323D28 = &ggl::clutShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB323D38 = 0;
    unk_1EB323D40 = 0;
    qword_1EB323D30 = 0;
  }
}

void ggl::LineShader::typedReflection(ggl::LineShader *this)
{
  {
    if (v1)
    {
      ggl::LineShader::typedReflection(void)::ref = (uint64_t)"LineShader";
      ggl::lineShaderVertexFunctionDescriptor(v1);
      qword_1EB3204C8 = (uint64_t)&ggl::lineShaderVertexFunctionDescriptor(void)::ref;
      unsigned int v2 = (ggl *)ggl::crc32::compute<17ul>("LineShaderVertex");
      dword_1EB3204D0 = (int)v2;
      ggl::lineShaderFragmentFunctionDescriptor(v2);
      qword_1EB3204D8 = (uint64_t)&ggl::lineShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB3204E0 = ggl::crc32::compute<19ul>("LineShaderFragment");
      qword_1EB3204E8 = (uint64_t)ggl::lineShaderShaderConstants(void)::ref;
      unk_1EB3204F0 = 2;
      qword_1EB3204F8 = (uint64_t)&ggl::lineShaderShaderTextures(void)::ref;
      unk_1EB320500 = 0;
      qword_1EB320508 = (uint64_t)&ggl::lineShaderShaderSamplers(void)::ref;
      unk_1EB320510 = 0;
    }
  }
}

void ggl::lineShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::lineShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<19ul>("LineShaderFragment");
    *(_DWORD *)algn_1EB32457C = 1;
    qword_1EB324580 = (uint64_t)"LineShader";
    unk_1EB324588 = 0;
    qword_1EB324590 = 0;
    unk_1EB324598 = &ggl::lineShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB3245A0 = 1;
    unk_1EB3245A8 = &ggl::lineShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB3245B0 = 0;
    unk_1EB3245B8 = &ggl::lineShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB3245C0 = 0;
    unk_1EB3245C8 = &ggl::lineShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB3245D8 = 0;
    unk_1EB3245E0 = 0;
    qword_1EB3245D0 = 0;
  }
}

void ggl::lineShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::lineShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<17ul>("LineShaderVertex");
    *(_DWORD *)algn_1EB323EB4 = 0;
    qword_1EB323EB8 = (uint64_t)"LineShader";
    unk_1EB323EC0 = ggl::lineShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB323EC8 = 1;
    unk_1EB323ED0 = &ggl::lineShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB323ED8 = 1;
    unk_1EB323EE0 = &ggl::lineShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB323EE8 = 0;
    unk_1EB323EF0 = &ggl::lineShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB323EF8 = 0;
    unk_1EB323F00 = &ggl::lineShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB323F10 = 0;
    unk_1EB323F18 = 0;
    qword_1EB323F08 = 0;
  }
}

void ggl::ViewShader::typedReflection(ggl::ViewShader *this)
{
  {
    if (v1)
    {
      ggl::ViewShader::typedReflection(void)::ref = (uint64_t)"ViewShader";
      ggl::viewShaderVertexFunctionDescriptor(v1);
      qword_1EB320520 = (uint64_t)&ggl::viewShaderVertexFunctionDescriptor(void)::ref;
      unsigned int v2 = (ggl *)ggl::crc32::compute<17ul>("ViewShaderVertex");
      dword_1EB320528 = (int)v2;
      ggl::viewShaderFragmentFunctionDescriptor(v2);
      qword_1EB320530 = (uint64_t)&ggl::viewShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB320538 = ggl::crc32::compute<19ul>("ViewShaderFragment");
      qword_1EB320540 = (uint64_t)ggl::viewShaderShaderConstants(void)::ref;
      unk_1EB320548 = 2;
      qword_1EB320550 = (uint64_t)ggl::viewShaderShaderTextures(void)::ref;
      unk_1EB320558 = 1;
      qword_1EB320560 = (uint64_t)ggl::viewShaderShaderSamplers(void)::ref;
      unk_1EB320568 = 1;
    }
  }
}

void ggl::IconShader::typedReflection(ggl::IconShader *this)
{
  {
    if (v1)
    {
      ggl::IconShader::typedReflection(void)::ref = (uint64_t)"IconShader";
      ggl::iconShaderVertexFunctionDescriptor(v1);
      qword_1EB320470 = (uint64_t)&ggl::iconShaderVertexFunctionDescriptor(void)::ref;
      unsigned int v2 = (ggl *)ggl::crc32::compute<17ul>("IconShaderVertex");
      dword_1EB320478 = (int)v2;
      ggl::iconShaderFragmentFunctionDescriptor(v2);
      qword_1EB320480 = (uint64_t)&ggl::iconShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB320488 = ggl::crc32::compute<19ul>("IconShaderFragment");
      qword_1EB320490 = (uint64_t)ggl::iconShaderShaderConstants(void)::ref;
      unk_1EB320498 = 3;
      qword_1EB3204A0 = (uint64_t)ggl::iconShaderShaderTextures(void)::ref;
      unk_1EB3204A8 = 2;
      qword_1EB3204B0 = (uint64_t)ggl::iconShaderShaderSamplers(void)::ref;
      unk_1EB3204B8 = 2;
    }
  }
}

uint64_t ggl::crc32::compute<17ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  return ggl::crc32::crc32Table[v13 ^ a1[15]] ^ ~(v13 >> 8);
}

void ggl::viewShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::viewShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<19ul>("ViewShaderFragment");
    *(_DWORD *)algn_1EB3245F4 = 1;
    qword_1EB3245F8 = (uint64_t)"ViewShader";
    unk_1EB324600 = 0;
    qword_1EB324608 = 0;
    unk_1EB324610 = &ggl::viewShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB324618 = 1;
    unk_1EB324620 = &ggl::viewShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB324628 = 0;
    unk_1EB324630 = &ggl::viewShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB324638 = 1;
    unk_1EB324640 = &ggl::viewShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB324650 = 0;
    unk_1EB324658 = 0;
    qword_1EB324648 = 1;
  }
}

void ggl::iconShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::iconShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<19ul>("IconShaderFragment");
    *(_DWORD *)algn_1EB324504 = 1;
    qword_1EB324508 = (uint64_t)"IconShader";
    unk_1EB324510 = 0;
    qword_1EB324518 = 0;
    unk_1EB324520 = &ggl::iconShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB324528 = 1;
    unk_1EB324530 = &ggl::iconShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB324538 = 0;
    unk_1EB324540 = &ggl::iconShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB324548 = 1;
    unk_1EB324550 = &ggl::iconShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB324560 = 0;
    unk_1EB324568 = 0;
    qword_1EB324558 = 1;
  }
}

void ggl::viewShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::viewShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<17ul>("ViewShaderVertex");
    *(_DWORD *)algn_1EB323F2C = 0;
    qword_1EB323F30 = (uint64_t)"ViewShader";
    unk_1EB323F38 = ggl::viewShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB323F40 = 1;
    unk_1EB323F48 = &ggl::viewShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB323F50 = 1;
    unk_1EB323F58 = &ggl::viewShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB323F60 = 0;
    unk_1EB323F68 = &ggl::viewShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB323F70 = 0;
    unk_1EB323F78 = &ggl::viewShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB323F88 = 0;
    unk_1EB323F90 = 0;
    qword_1EB323F80 = 0;
  }
}

void ggl::iconShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::iconShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<17ul>("IconShaderVertex");
    *(_DWORD *)algn_1EB323E3C = 0;
    qword_1EB323E40 = (uint64_t)"IconShader";
    unk_1EB323E48 = ggl::iconShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB323E50 = 1;
    unk_1EB323E58 = &ggl::iconShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB323E60 = 2;
    unk_1EB323E68 = &ggl::iconShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB323E70 = 0;
    unk_1EB323E78 = &ggl::iconShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB323E80 = 1;
    unk_1EB323E88 = &ggl::iconShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB323E98 = 0;
    unk_1EB323EA0 = 0;
    qword_1EB323E90 = 1;
  }
}

void ggl::ShadowShader::typedReflection(ggl::ShadowShader *this)
{
  {
    if (v1)
    {
      ggl::ShadowShader::typedReflection(void)::ref = (uint64_t)"ShadowShader";
      ggl::shadowShaderVertexFunctionDescriptor(v1);
      qword_1E9582440 = (uint64_t)&ggl::shadowShaderVertexFunctionDescriptor(void)::ref;
      unsigned int v2 = (ggl *)ggl::crc32::compute<19ul>("ShadowShaderVertex");
      dword_1E9582448 = (int)v2;
      ggl::shadowShaderFragmentFunctionDescriptor(v2);
      qword_1E9582450 = (uint64_t)&ggl::shadowShaderFragmentFunctionDescriptor(void)::ref;
      dword_1E9582458 = ggl::crc32::compute<21ul>("ShadowShaderFragment");
      qword_1E9582460 = (uint64_t)ggl::shadowShaderShaderConstants(void)::ref;
      unk_1E9582468 = 4;
      qword_1E9582470 = (uint64_t)ggl::shadowShaderShaderTextures(void)::ref;
      unk_1E9582478 = 2;
      qword_1E9582480 = (uint64_t)ggl::shadowShaderShaderSamplers(void)::ref;
      unk_1E9582488 = 2;
    }
  }
}

void ggl::shadowShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::shadowShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<21ul>("ShadowShaderFragment");
    *(_DWORD *)algn_1E958C094 = 1;
    qword_1E958C098 = (uint64_t)"ShadowShader";
    unk_1E958C0A0 = 0;
    qword_1E958C0A8 = 0;
    unk_1E958C0B0 = &ggl::shadowShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1E958C0B8 = 1;
    unk_1E958C0C0 = &ggl::shadowShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1E958C0C8 = 0;
    unk_1E958C0D0 = &ggl::shadowShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1E958C0D8 = 0;
    unk_1E958C0E0 = &ggl::shadowShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1E958C0F0 = 0;
    unk_1E958C0F8 = 0;
    qword_1E958C0E8 = 0;
  }
}

void ggl::shadowShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::shadowShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<19ul>("ShadowShaderVertex");
    *(_DWORD *)algn_1E958BFAC = 0;
    qword_1E958BFB0 = (uint64_t)"ShadowShader";
    unk_1E958BFB8 = ggl::shadowShaderVertShaderFunctionAttributes(void)::ref;
    qword_1E958BFC0 = 1;
    unk_1E958BFC8 = &ggl::shadowShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1E958BFD0 = 3;
    unk_1E958BFD8 = &ggl::shadowShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1E958BFE0 = 0;
    unk_1E958BFE8 = &ggl::shadowShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1E958BFF0 = 2;
    unk_1E958BFF8 = &ggl::shadowShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1E958C008 = 0;
    unk_1E958C010 = 0;
    qword_1E958C000 = 2;
  }
}

uint64_t ggl::CommonLibraryMTLData::CommonLibraryMTLData(void *a1, uint64_t *a2)
{
  unsigned int v2 = a2;
  {
    unsigned int v2 = a2;
    if (v5)
    {
      commonLibraryFunctionIds(void)::ids = ggl::crc32::compute<30ul>("ClearDepthStencilShaderVertex");
      dword_1EB32C7E4 = ggl::crc32::compute<32ul>("ClearDepthStencilShaderFragment");
      dword_1EB32C7E8 = ggl::crc32::compute<18ul>("ClearShaderVertex");
      dword_1EB32C7EC = ggl::crc32::compute<20ul>("ClearShaderFragment");
      dword_1EB32C7F0 = ggl::crc32::compute<19ul>("Clear2ShaderVertex");
      dword_1EB32C7F4 = ggl::crc32::compute<21ul>("Clear2ShaderFragment");
      dword_1EB32C7F8 = ggl::crc32::compute<19ul>("Clear3ShaderVertex");
      dword_1EB32C7FC = ggl::crc32::compute<21ul>("Clear3ShaderFragment");
      dword_1EB32C800 = ggl::crc32::compute<19ul>("Clear4ShaderVertex");
      dword_1EB32C804 = ggl::crc32::compute<21ul>("Clear4ShaderFragment");
      dword_1EB32C808 = ggl::crc32::compute<24ul>("ColoredTextShaderVertex");
      dword_1EB32C80C = ggl::crc32::compute<26ul>("ColoredTextShaderFragment");
      dword_1EB32C810 = ggl::crc32::compute<24ul>("ShadedColorShaderVertex");
      dword_1EB32C814 = ggl::crc32::compute<26ul>("ShadedColorShaderFragment");
      dword_1EB32C818 = ggl::crc32::compute<24ul>("TextureRectShaderVertex");
      dword_1EB32C81C = ggl::crc32::compute<26ul>("TextureRectShaderFragment");
      unsigned int v2 = a2;
    }
  }
  uint64_t result = ggl::MTLShaderLibraryData::MTLShaderLibraryData((uint64_t)a1, 0, v2, (uint64_t)&commonLibraryFunctionIds(void)::ids, (uint64_t)commonLibraryMTLFunctionSignatures(void)::signatures, 0x10uLL);
  *a1 = &unk_1EF55F5F8;
  return result;
}

uint64_t ggl::crc32::compute<19ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  unsigned int v14 = ggl::crc32::crc32Table[v13 ^ a1[15]] ^ (v13 >> 8);
  unsigned int v15 = ggl::crc32::crc32Table[v14 ^ a1[16]] ^ (v14 >> 8);
  return ggl::crc32::crc32Table[v15 ^ a1[17]] ^ ~(v15 >> 8);
}

uint64_t ggl::crc32::compute<21ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  unsigned int v14 = ggl::crc32::crc32Table[v13 ^ a1[15]] ^ (v13 >> 8);
  unsigned int v15 = ggl::crc32::crc32Table[v14 ^ a1[16]] ^ (v14 >> 8);
  unsigned int v16 = ggl::crc32::crc32Table[v15 ^ a1[17]] ^ (v15 >> 8);
  unsigned int v17 = ggl::crc32::crc32Table[v16 ^ a1[18]] ^ (v16 >> 8);
  return ggl::crc32::crc32Table[v17 ^ a1[19]] ^ ~(v17 >> 8);
}

uint64_t ggl::crc32::compute<18ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  unsigned int v14 = ggl::crc32::crc32Table[v13 ^ a1[15]] ^ (v13 >> 8);
  return ggl::crc32::crc32Table[v14 ^ a1[16]] ^ ~(v14 >> 8);
}

uint64_t ggl::MTLShaderLibraryData::MTLShaderLibraryData(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  *(void *)a1 = &unk_1EF55EC78;
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *a3;
  *a3 = 0;
  *(void *)(a1 + 16) = v10;
  *(void *)(a1 + 24) = 0;
  unsigned int v11 = (void *)(a1 + 24);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  {
    operator new();
  }
  uint64_t v12 = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 48) = ggl::Allocator::instance(void)::alloc;
  uint64_t v13 = *(void *)(a1 + 24);
  if (a6 <= (*(void *)(a1 + 40) - v13) >> 2) {
    goto LABEL_13;
  }
  uint64_t v14 = *(void *)(a1 + 32) - v13;
  uint64_t v15 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v12 + 16))(v12, 4 * a6, 4);
  unint64_t v16 = v15 + (v14 & 0xFFFFFFFFFFFFFFFCLL);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v18 = *(void *)(a1 + 32);
  unint64_t v19 = v16;
  if (v18 != v17)
  {
    unint64_t v20 = v18 - v17 - 4;
    if (v20 < 0x2C)
    {
      unint64_t v19 = v15 + (v14 & 0xFFFFFFFFFFFFFFFCLL);
      do
      {
LABEL_10:
        int v27 = *(_DWORD *)(v18 - 4);
        v18 -= 4;
        *(_DWORD *)(v19 - 4) = v27;
        v19 -= 4;
      }
      while (v18 != v17);
      goto LABEL_11;
    }
    unint64_t v19 = v15 + (v14 & 0xFFFFFFFFFFFFFFFCLL);
    if (v18 - (v14 & 0xFFFFFFFFFFFFFFFCLL) - v15 < 0x20) {
      goto LABEL_10;
    }
    uint64_t v21 = (v20 >> 2) + 1;
    uint64_t v22 = v18 - 4 * (v21 & 0x7FFFFFFFFFFFFFF8);
    unint64_t v23 = (_OWORD *)(v15 + 4 * (v14 >> 2) - 16);
    uint64_t v24 = (long long *)(v18 - 16);
    uint64_t v25 = v21 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      long long v26 = *v24;
      *(v23 - 1) = *(v24 - 1);
      _OWORD *v23 = v26;
      v23 -= 2;
      v24 -= 2;
      v25 -= 8;
    }
    while (v25);
    unint64_t v19 = v16 - 4 * (v21 & 0x7FFFFFFFFFFFFFF8);
    uint64_t v18 = v22;
    if (v21 != (v21 & 0x7FFFFFFFFFFFFFF8)) {
      goto LABEL_10;
    }
  }
LABEL_11:
  *(void *)(a1 + 24) = v19;
  *(void *)(a1 + 32) = v16;
  uint64_t v28 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = v15 + 4 * a6;
  if (v17) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), v17, v28 - v17);
  }
LABEL_13:
  uint64_t v29 = 0;
  uint64_t v30 = *(_DWORD **)(a1 + 32);
  do
  {
    unint64_t v31 = *(void *)(a1 + 40);
    if ((unint64_t)v30 < v31)
    {
      if (v30) {
        *uint64_t v30 = *(_DWORD *)(a4 + 4 * v29);
      }
      ++v30;
      goto LABEL_15;
    }
    uint64_t v32 = ((uint64_t)v30 - *v11) >> 2;
    if ((unint64_t)(v32 + 1) >> 62) {
LABEL_96:
    }
      abort();
    uint64_t v33 = v31 - *v11;
    uint64_t v34 = v33 >> 1;
    if (v33 >> 1 <= (unint64_t)(v32 + 1)) {
      uint64_t v34 = v32 + 1;
    }
    if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFFCLL) {
      uint64_t v35 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v35 = v34;
    }
    if (v35)
    {
      uint64_t v36 = 4 * v35;
      uint64_t v37 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 4 * v35, 4);
      int64x2_t v38 = (_DWORD *)(v37 + 4 * v32);
      uint64_t v35 = v37 + v36;
      if (v37) {
        _DWORD *v38 = *(_DWORD *)(a4 + 4 * v29);
      }
    }
    else
    {
      int64x2_t v38 = (_DWORD *)(4 * v32);
    }
    uint64_t v39 = *(void *)(a1 + 24);
    uint64_t v40 = *(void *)(a1 + 32);
    int64_t v41 = v38;
    if (v40 != v39)
    {
      unint64_t v42 = v40 - v39 - 4;
      if (v42 < 0x1C)
      {
        int64_t v41 = v38;
        do
        {
LABEL_37:
          int v49 = *(_DWORD *)(v40 - 4);
          v40 -= 4;
          *--int64_t v41 = v49;
        }
        while (v40 != v39);
        goto LABEL_38;
      }
      int64_t v41 = v38;
      if ((unint64_t)(v40 - (void)v38) < 0x20) {
        goto LABEL_37;
      }
      uint64_t v43 = (v42 >> 2) + 1;
      uint64_t v44 = v40 - 4 * (v43 & 0x7FFFFFFFFFFFFFF8);
      unint64_t v45 = v38 - 4;
      unint64_t v46 = (long long *)(v40 - 16);
      uint64_t v47 = v43 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v48 = *v46;
        *(v45 - 1) = *(v46 - 1);
        *unint64_t v45 = v48;
        v45 -= 2;
        v46 -= 2;
        v47 -= 8;
      }
      while (v47);
      int64_t v41 = &v38[-(v43 & 0x7FFFFFFFFFFFFFF8)];
      uint64_t v40 = v44;
      if (v43 != (v43 & 0x7FFFFFFFFFFFFFF8)) {
        goto LABEL_37;
      }
    }
LABEL_38:
    uint64_t v30 = v38 + 1;
    *(void *)(a1 + 24) = v41;
    *(void *)(a1 + 32) = v38 + 1;
    uint64_t v50 = *(void *)(a1 + 40);
    *(void *)(a1 + 40) = v35;
    if (v39) {
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), v39, v50 - v39);
    }
LABEL_15:
    *(void *)(a1 + 32) = v30;
    ++v29;
  }
  while (v29 != a6);
  *(void *)a1 = &unk_1EF55F618;
  *(void *)(a1 + 56) = 0;
  unint64_t v92 = (void *)(a1 + 56);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  {
    operator new();
  }
  uint64_t v51 = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 80) = ggl::Allocator::instance(void)::alloc;
  *(_DWORD *)(a1 + 88) = a2;
  uint64_t v52 = *(void *)(a1 + 56);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 72) - v52) >> 3) < a6)
  {
    uint64_t v53 = (unsigned __int128)((*(void *)(a1 + 64) - v52) * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
    uint64_t v54 = (v53 >> 2) + ((unint64_t)v53 >> 63);
    uint64_t v55 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v51 + 16))(v51, 24 * a6, 8);
    uint64_t v56 = v55 + 24 * v54;
    unint64_t v57 = v55 + 24 * a6;
    uint64_t v58 = *(void *)(a1 + 56);
    uint64_t v59 = *(void *)(a1 + 64);
    if (v59 == v58)
    {
      *(void *)(a1 + 56) = v56;
      *(void *)(a1 + 64) = v56;
      uint64_t v63 = *(void *)(a1 + 72);
      *(void *)(a1 + 72) = v57;
    }
    else
    {
      uint64_t v60 = v55 + 24 * v54;
      do
      {
        long long v61 = *(_OWORD *)(v59 - 24);
        *(void *)(v60 - 8) = *(void *)(v59 - 8);
        *(_OWORD *)(v60 - 24) = v61;
        v60 -= 24;
        *(void *)(v59 - 16) = 0;
        *(void *)(v59 - 8) = 0;
        *(void *)(v59 - 24) = 0;
        v59 -= 24;
      }
      while (v59 != v58);
      uint64_t v59 = *(void *)(a1 + 56);
      uint64_t v62 = *(void *)(a1 + 64);
      *(void *)(a1 + 56) = v60;
      *(void *)(a1 + 64) = v56;
      uint64_t v63 = *(void *)(a1 + 72);
      *(void *)(a1 + 72) = v57;
      while (v62 != v59)
      {
        if (*(char *)(v62 - 1) < 0) {
          operator delete(*(void **)(v62 - 24));
        }
        v62 -= 24;
      }
    }
    if (v59) {
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 40))(*(void *)(a1 + 80), v59, v63 - v59);
    }
  }
  uint64_t v64 = 0;
  uint64_t v65 = *(void **)(a1 + 64);
  while (2)
  {
    uint64_t v69 = *(const char **)(a5 + 8 * v64);
    unint64_t v70 = *(void *)(a1 + 72);
    if ((unint64_t)v65 >= v70)
    {
      unint64_t v73 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v65 - *v92) >> 3);
      unint64_t v74 = v73 + 1;
      if (v73 + 1 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_96;
      }
      unint64_t v75 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v70 - *v92) >> 3);
      if (2 * v75 > v74) {
        unint64_t v74 = 2 * v75;
      }
      if (v75 >= 0x555555555555555) {
        uint64_t v76 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        uint64_t v76 = v74;
      }
      if (v76)
      {
        uint64_t v77 = 24 * v76;
        uint64_t v78 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), 24 * v76, 8);
        uint64_t v79 = v78 + 24 * v73;
        uint64_t v80 = v78 + v77;
        if (v78)
        {
          size_t v81 = strlen(v69);
          if (v81 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_96;
          }
          size_t v82 = v81;
          if (v81 >= 0x17)
          {
            uint64_t v84 = (v81 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v81 | 7) != 0x17) {
              uint64_t v84 = v81 | 7;
            }
            uint64_t v85 = v84 + 1;
            unint64_t v83 = operator new(v84 + 1);
            *(void *)(v79 + 8) = v82;
            *(void *)(v79 + 16) = v85 | 0x8000000000000000;
            *(void *)uint64_t v79 = v83;
          }
          else
          {
            *(unsigned char *)(v79 + 23) = v81;
            unint64_t v83 = (void *)v79;
            if (!v81) {
              goto LABEL_84;
            }
          }
          memmove(v83, v69, v82);
LABEL_84:
          *((unsigned char *)v83 + v82) = 0;
        }
      }
      else
      {
        uint64_t v80 = 0;
        uint64_t v79 = 8 * (((uint64_t)v65 - *v92) >> 3);
      }
      uint64_t v65 = (void *)(v79 + 24);
      uint64_t v86 = *(void *)(a1 + 56);
      uint64_t v87 = *(void *)(a1 + 64);
      if (v87 == v86)
      {
        *(void *)(a1 + 56) = v79;
        *(void *)(a1 + 64) = v65;
        uint64_t v90 = *(void *)(a1 + 72);
        *(void *)(a1 + 72) = v80;
      }
      else
      {
        do
        {
          long long v88 = *(_OWORD *)(v87 - 24);
          *(void *)(v79 - 8) = *(void *)(v87 - 8);
          *(_OWORD *)(v79 - 24) = v88;
          v79 -= 24;
          *(void *)(v87 - 16) = 0;
          *(void *)(v87 - 8) = 0;
          *(void *)(v87 - 24) = 0;
          v87 -= 24;
        }
        while (v87 != v86);
        uint64_t v87 = *(void *)(a1 + 56);
        uint64_t v89 = *(void *)(a1 + 64);
        *(void *)(a1 + 56) = v79;
        *(void *)(a1 + 64) = v65;
        uint64_t v90 = *(void *)(a1 + 72);
        *(void *)(a1 + 72) = v80;
        while (v89 != v87)
        {
          if (*(char *)(v89 - 1) < 0) {
            operator delete(*(void **)(v89 - 24));
          }
          v89 -= 24;
        }
      }
      if (v87) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 40))(*(void *)(a1 + 80), v87, v90 - v87);
      }
      goto LABEL_60;
    }
    if (v65)
    {
      size_t v71 = strlen(*(const char **)(a5 + 8 * v64));
      if (v71 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_96;
      }
      size_t v72 = v71;
      if (v71 >= 0x17)
      {
        uint64_t v66 = (v71 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v71 | 7) != 0x17) {
          uint64_t v66 = v71 | 7;
        }
        uint64_t v67 = v66 + 1;
        unint64_t v68 = operator new(v66 + 1);
        v65[1] = v72;
        v65[2] = v67 | 0x8000000000000000;
        *uint64_t v65 = v68;
      }
      else
      {
        *((unsigned char *)v65 + 23) = v71;
        unint64_t v68 = v65;
        if (!v71)
        {
LABEL_58:
          v68[v72] = 0;
          goto LABEL_59;
        }
      }
      memmove(v68, v69, v72);
      goto LABEL_58;
    }
LABEL_59:
    v65 += 3;
LABEL_60:
    *(void *)(a1 + 64) = v65;
    if (++v64 != a6) {
      continue;
    }
    return a1;
  }
}

void ggl::FlyoverShader::typedReflection(ggl::FlyoverShader *this)
{
  {
    if (v1)
    {
      ggl::FlyoverShader::typedReflection(void)::ref = (uint64_t)"FlyoverShader";
      ggl::flyoverShaderVertexFunctionDescriptor(v1);
      qword_1EB320AE0 = (uint64_t)&ggl::flyoverShaderVertexFunctionDescriptor(void)::ref;
      unsigned int v2 = (ggl *)ggl::crc32::compute<20ul>("FlyoverShaderVertex");
      dword_1EB320AE8 = (int)v2;
      ggl::flyoverShaderFragmentFunctionDescriptor(v2);
      qword_1EB320AF0 = (uint64_t)&ggl::flyoverShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB320AF8 = ggl::crc32::compute<22ul>("FlyoverShaderFragment");
      qword_1EB320B00 = (uint64_t)ggl::flyoverShaderShaderConstants(void)::ref;
      unk_1EB320B08 = 5;
      qword_1EB320B10 = (uint64_t)ggl::flyoverShaderShaderTextures(void)::ref;
      unk_1EB320B18 = 2;
      qword_1EB320B20 = (uint64_t)ggl::flyoverShaderShaderSamplers(void)::ref;
      unk_1EB320B28 = 2;
    }
  }
}

void ggl::Glyph3dShader::typedReflection(ggl::Glyph3dShader *this)
{
  {
    if (v1)
    {
      ggl::Glyph3dShader::typedReflection(void)::ref = (uint64_t)"Glyph3dShader";
      ggl::glyph3dShaderVertexFunctionDescriptor(v1);
      qword_1EB320B40 = (uint64_t)&ggl::glyph3dShaderVertexFunctionDescriptor(void)::ref;
      unsigned int v2 = (ggl *)ggl::crc32::compute<20ul>("Glyph3dShaderVertex");
      dword_1EB320B48 = (int)v2;
      ggl::glyph3dShaderFragmentFunctionDescriptor(v2);
      qword_1EB320B50 = (uint64_t)&ggl::glyph3dShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB320B58 = ggl::crc32::compute<22ul>("Glyph3dShaderFragment");
      qword_1EB320B60 = (uint64_t)ggl::glyph3dShaderShaderConstants(void)::ref;
      unk_1EB320B68 = 6;
      qword_1EB320B70 = (uint64_t)ggl::glyph3dShaderShaderTextures(void)::ref;
      unk_1EB320B78 = 3;
      qword_1EB320B80 = (uint64_t)ggl::glyph3dShaderShaderSamplers(void)::ref;
      unk_1EB320B88 = 3;
    }
  }
}

uint64_t ggl::crc32::compute<20ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  unsigned int v14 = ggl::crc32::crc32Table[v13 ^ a1[15]] ^ (v13 >> 8);
  unsigned int v15 = ggl::crc32::crc32Table[v14 ^ a1[16]] ^ (v14 >> 8);
  unsigned int v16 = ggl::crc32::crc32Table[v15 ^ a1[17]] ^ (v15 >> 8);
  return ggl::crc32::crc32Table[v16 ^ a1[18]] ^ ~(v16 >> 8);
}

void ggl::DebugLineShader::typedReflection(ggl::DebugLineShader *this)
{
  {
    if (v1)
    {
      ggl::DebugLineShader::typedReflection(void)::ref = (uint64_t)"DebugLineShader";
      ggl::debugLineShaderVertexFunctionDescriptor(v1);
      qword_1EB31BDD8 = (uint64_t)&ggl::debugLineShaderVertexFunctionDescriptor(void)::ref;
      unsigned int v2 = (ggl *)ggl::crc32::compute<22ul>("DebugLineShaderVertex");
      dword_1EB31BDE0 = (int)v2;
      ggl::debugLineShaderFragmentFunctionDescriptor(v2);
      qword_1EB31BDE8 = (uint64_t)&ggl::debugLineShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB31BDF0 = ggl::crc32::compute<24ul>("DebugLineShaderFragment");
      qword_1EB31BDF8 = (uint64_t)ggl::debugLineShaderShaderConstants(void)::ref;
      unk_1EB31BE00 = 4;
      qword_1EB31BE08 = (uint64_t)&ggl::debugLineShaderShaderTextures(void)::ref;
      unk_1EB31BE10 = 0;
      qword_1EB31BE18 = (uint64_t)&ggl::debugLineShaderShaderSamplers(void)::ref;
      unk_1EB31BE20 = 0;
    }
  }
}

uint64_t ggl::crc32::compute<22ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  unsigned int v14 = ggl::crc32::crc32Table[v13 ^ a1[15]] ^ (v13 >> 8);
  unsigned int v15 = ggl::crc32::crc32Table[v14 ^ a1[16]] ^ (v14 >> 8);
  unsigned int v16 = ggl::crc32::crc32Table[v15 ^ a1[17]] ^ (v15 >> 8);
  unsigned int v17 = ggl::crc32::crc32Table[v16 ^ a1[18]] ^ (v16 >> 8);
  unsigned int v18 = ggl::crc32::crc32Table[v17 ^ a1[19]] ^ (v17 >> 8);
  return ggl::crc32::crc32Table[v18 ^ a1[20]] ^ ~(v18 >> 8);
}

void ggl::debugLineShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::debugLineShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<24ul>("DebugLineShaderFragment");
    *(_DWORD *)algn_1EB31C6EC = 1;
    qword_1EB31C6F0 = (uint64_t)"DebugLineShader";
    unk_1EB31C6F8 = 0;
    qword_1EB31C700 = 0;
    unk_1EB31C708 = &ggl::debugLineShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB31C710 = 1;
    unk_1EB31C718 = &ggl::debugLineShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB31C720 = 0;
    unk_1EB31C728 = &ggl::debugLineShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB31C730 = 0;
    unk_1EB31C738 = &ggl::debugLineShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB31C748 = 0;
    unk_1EB31C750 = 0;
    qword_1EB31C740 = 0;
  }
}

void ggl::glyph3dShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::glyph3dShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<22ul>("Glyph3dShaderFragment");
    *(_DWORD *)algn_1EB324D14 = 1;
    qword_1EB324D18 = (uint64_t)"Glyph3dShader";
    unk_1EB324D20 = 0;
    qword_1EB324D28 = 0;
    unk_1EB324D30 = &ggl::glyph3dShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB324D38 = 2;
    unk_1EB324D40 = &ggl::glyph3dShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB324D48 = 0;
    unk_1EB324D50 = &ggl::glyph3dShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB324D58 = 1;
    unk_1EB324D60 = &ggl::glyph3dShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB324D70 = 0;
    unk_1EB324D78 = 0;
    qword_1EB324D68 = 1;
  }
}

void ggl::flyoverShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::flyoverShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<22ul>("FlyoverShaderFragment");
    *(_DWORD *)algn_1EB324C34 = 1;
    qword_1EB324C38 = (uint64_t)"FlyoverShader";
    unk_1EB324C40 = 0;
    qword_1EB324C48 = 0;
    unk_1EB324C50 = &ggl::flyoverShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB324C58 = 2;
    unk_1EB324C60 = &ggl::flyoverShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB324C68 = 0;
    unk_1EB324C70 = &ggl::flyoverShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB324C78 = 1;
    unk_1EB324C80 = &ggl::flyoverShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB324C90 = 0;
    unk_1EB324C98 = 0;
    qword_1EB324C88 = 1;
  }
}

void ggl::debugLineShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::debugLineShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<22ul>("DebugLineShaderVertex");
    *(_DWORD *)algn_1EB31C604 = 0;
    qword_1EB31C608 = (uint64_t)"DebugLineShader";
    unk_1EB31C610 = ggl::debugLineShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB31C618 = 1;
    unk_1EB31C620 = &ggl::debugLineShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB31C628 = 4;
    unk_1EB31C630 = &ggl::debugLineShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB31C638 = 0;
    unk_1EB31C640 = &ggl::debugLineShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB31C648 = 0;
    unk_1EB31C650 = &ggl::debugLineShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB31C660 = 0;
    unk_1EB31C668 = 0;
    qword_1EB31C658 = 0;
  }
}

void ggl::glyph3dShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::glyph3dShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<20ul>("Glyph3dShaderVertex");
    *(_DWORD *)algn_1EB32482C = 0;
    qword_1EB324830 = (uint64_t)"Glyph3dShader";
    unk_1EB324838 = ggl::glyph3dShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB324840 = 1;
    unk_1EB324848 = &ggl::glyph3dShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB324850 = 4;
    unk_1EB324858 = &ggl::glyph3dShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB324860 = 0;
    unk_1EB324868 = &ggl::glyph3dShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB324870 = 2;
    unk_1EB324878 = &ggl::glyph3dShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB324888 = 0;
    unk_1EB324890 = 0;
    qword_1EB324880 = 2;
  }
}

void ggl::flyoverShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::flyoverShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<20ul>("FlyoverShaderVertex");
    *(_DWORD *)algn_1EB3247BC = 0;
    qword_1EB3247C0 = (uint64_t)"FlyoverShader";
    unk_1EB3247C8 = ggl::flyoverShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB3247D0 = 1;
    unk_1EB3247D8 = &ggl::flyoverShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB3247E0 = 5;
    unk_1EB3247E8 = &ggl::flyoverShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB3247F0 = 0;
    unk_1EB3247F8 = &ggl::flyoverShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB324800 = 1;
    unk_1EB324808 = &ggl::flyoverShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB324818 = 0;
    unk_1EB324820 = 0;
    qword_1EB324810 = 1;
  }
}

void grl::FontKey::createDescriptor(grl::FontKey *this@<X0>, void *a2@<X8>)
{
  uint64_t v126 = *MEMORY[0x1E4F143B8];
  grl::createCFMutableDictionary(&v120);
  if (v121)
  {
    grl::createCFMutableDictionary(&v118);
    if (!v119)
    {
      if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1) {
        dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_0);
      }
      unsigned int v10 = GEOGetGeoResourceLibCoreFoundationLog::log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
      {
        unsigned int v11 = (void *)((char *)this + 72);
        if (*((char *)this + 95) < 0) {
          unsigned int v11 = (void *)*v11;
        }
        *(_DWORD *)long long buf = 136315906;
        *(void *)&buf[4] = v11;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
        *(_WORD *)&buf[22] = 2080;
        unint64_t v124 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/FontKey.cpp";
        LOWORD(v125) = 1024;
        *(_DWORD *)((char *)&v125 + 2) = 64;
        _os_log_impl(&dword_1A1780000, v10, OS_LOG_TYPE_ERROR, "Failed to create variations dictionary for font \"%s\".: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
      }
      *a2 = &unk_1EF559278;
      a2[1] = 0;
      goto LABEL_233;
    }
    CFArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    unint64_t v116 = &unk_1EF559158;
    CFArrayRef theArray = Mutable;
    if (!Mutable)
    {
      if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1) {
        dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_0);
      }
      unsigned int v12 = GEOGetGeoResourceLibCoreFoundationLog::log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
      {
        unsigned int v13 = (void *)((char *)this + 72);
        if (*((char *)this + 95) < 0) {
          unsigned int v13 = (void *)*v13;
        }
        *(_DWORD *)long long buf = 136315906;
        *(void *)&buf[4] = v13;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
        *(_WORD *)&buf[22] = 2080;
        unint64_t v124 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/FontKey.cpp";
        LOWORD(v125) = 1024;
        *(_DWORD *)((char *)&v125 + 2) = 68;
        _os_log_impl(&dword_1A1780000, v12, OS_LOG_TYPE_ERROR, "Failed to create settings array for font \"%s\".: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
      }
      *a2 = &unk_1EF559278;
      a2[1] = 0;
      goto LABEL_231;
    }
    int v5 = *((unsigned __int8 *)this + 10);
    if (*((unsigned __int8 *)this + 9) | v5)
    {
      unsigned int v6 = *((unsigned char *)this + 9) ? (grl *)(v5 | 0x40u) : (grl *)*((unsigned __int8 *)this + 10);
      grl::createCFNumber(v6, &v112);
      unsigned int v7 = value;
      if (value)
      {
        CFDictionarySetValue(v121, (const void *)*MEMORY[0x1E4F24610], value);
      }
      else
      {
        if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_0);
        }
        unsigned int v14 = GEOGetGeoResourceLibCoreFoundationLog::log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
        {
          unsigned int v15 = (void *)((char *)this + 72);
          if (*((char *)this + 95) < 0) {
            unsigned int v15 = (void *)*v15;
          }
          *(_DWORD *)long long buf = 136315906;
          *(void *)&buf[4] = v15;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
          *(_WORD *)&buf[22] = 2080;
          unint64_t v124 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/FontKey.cpp";
          LOWORD(v125) = 1024;
          *(_DWORD *)((char *)&v125 + 2) = 89;
          _os_log_impl(&dword_1A1780000, v14, OS_LOG_TYPE_ERROR, "Failed to create CFNumber for CTFontSymbolicTraits, for font name \"%s\".: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
        }
        *a2 = &unk_1EF559278;
        a2[1] = 0;
      }
      unint64_t v112 = (char *)&unk_1EF5591B8;
      CFArrayRef Mutable = (const __CFArray *)value;
      if (value) {
        CFRelease(value);
      }
      if (!v7)
      {
LABEL_231:
        unint64_t v116 = &unk_1EF559158;
        if (theArray) {
          CFRelease(theArray);
        }
LABEL_233:
        unint64_t v118 = &unk_1EF559058;
        if (v119) {
          CFRelease(v119);
        }
        goto LABEL_235;
      }
    }
    if (*((unsigned char *)this + 13))
    {
      if (*((unsigned char *)this + 12)) {
        unsigned int v16 = (const void **)MEMORY[0x1E4F24650];
      }
      else {
        unsigned int v16 = (const void **)MEMORY[0x1E4F24640];
      }
      unsigned int v17 = (const void **)MEMORY[0x1E4F24628];
      if (*((unsigned char *)this + 12)) {
        unsigned int v17 = (const void **)MEMORY[0x1E4F24630];
      }
      if (*((unsigned char *)this + 8)) {
        unsigned int v18 = v17;
      }
      else {
        unsigned int v18 = v16;
      }
      CFDictionarySetValue(v121, (const void *)*MEMORY[0x1E4F24660], *v18);
    }
    uint64_t v19 = *MEMORY[0x1E4F24670];
    unint64_t v112 = 0;
    value = 0;
    unint64_t v114 = 0;
    uint64_t v115 = grl::Allocator::instance(Mutable);
    unint64_t v20 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v115 + 16))(v115, 16, 8);
    unint64_t v112 = v20;
    unint64_t v114 = (unint64_t)(v20 + 16);
    if (v20) {
      *(void *)unint64_t v20 = *MEMORY[0x1E4F24620];
    }
    *((void *)v20 + 1) = v19;
    value = v20 + 16;
    uint64_t v21 = v121;
    uint64_t v22 = (__CFDictionary *)v119;
    unint64_t v109 = 0;
    unint64_t v110 = 0;
    uint64_t v108 = 0;
    uint64_t v111 = grl::Allocator::instance((grl::Allocator *)v20);
    unint64_t v23 = (__CFDictionary **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v111 + 16))(v111, 16, 8);
    uint64_t v108 = v23;
    unint64_t v110 = (char *)(v23 + 2);
    if (v23) {
      _OWORD *v23 = v21;
    }
    v23[1] = v22;
    unint64_t v109 = v23 + 2;
    uint64_t v107 = &v116;
    uint64_t v24 = (int *)*((void *)this + 12);
    uint64_t v25 = (int *)*((void *)this + 13);
    while (v24 != v25)
    {
      int v27 = *v24++;
      int v26 = v27;
      if (v27 >= 0) {
        int v28 = v26;
      }
      else {
        int v28 = -v26;
      }
      grl::FontKey::createDescriptor(void)const::$_0::operator()((uint64_t)&v107, (grl *)0x23, (grl *)(__PAIR64__(v28, v26) >> 31));
    }
    if (*((unsigned char *)this + 120)) {
      grl::FontKey::createDescriptor(void)const::$_0::operator()((uint64_t)&v107, (grl *)0x25, (grl *)*((unsigned __int8 *)this + 120));
    }
    if (!CFArrayGetCount(theArray))
    {
LABEL_103:
      grl::createCFDictionary((uint64_t)&v112, (uint64_t)&v108, &v105);
      if (!attributes)
      {
        if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_0);
        }
        long long v61 = GEOGetGeoResourceLibCoreFoundationLog::log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
        {
          uint64_t v62 = (void *)((char *)this + 72);
          if (*((char *)this + 95) < 0) {
            uint64_t v62 = (void *)*v62;
          }
          *(_DWORD *)long long buf = 136315906;
          *(void *)&buf[4] = v62;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
          *(_WORD *)&buf[22] = 2080;
          unint64_t v124 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/FontKey.cpp";
          LOWORD(v125) = 1024;
          *(_DWORD *)((char *)&v125 + 2) = 158;
          _os_log_impl(&dword_1A1780000, v61, OS_LOG_TYPE_ERROR, "Failed to create CFDictionary for font traits for font name \"%s\".: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
        }
        *a2 = &unk_1EF559278;
        a2[1] = 0;
        goto LABEL_225;
      }
      unint64_t v103 = &unk_1EF559278;
      CFTypeRef cf = 0;
      if (*((unsigned char *)this + 13))
      {
        if ((*((char *)this + 71) & 0x80000000) == 0)
        {
          if (*((unsigned char *)this + 71)) {
            goto LABEL_107;
          }
LABEL_125:
          CFTypeRef cf = CTFontDescriptorCreateWithAttributes(attributes);
LABEL_138:
          float v67 = *((float *)this + 5);
          if (v67 == 100.0 && *((unsigned char *)this + 40) == 3)
          {
            CopyWithAttributes = cf;
            if (!cf)
            {
              if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1) {
                dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_0);
              }
              uint64_t v69 = GEOGetGeoResourceLibCoreFoundationLog::log;
              if (!os_log_type_enabled((os_log_t)GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR)) {
                goto LABEL_222;
              }
              unint64_t v70 = (void *)((char *)this + 72);
              if (*((char *)this + 95) < 0) {
                unint64_t v70 = (void *)*v70;
              }
              *(_DWORD *)long long buf = 136315906;
              *(void *)&buf[4] = v70;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
              *(_WORD *)&buf[22] = 2080;
              unint64_t v124 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/FontKey.cpp";
              LOWORD(v125) = 1024;
              *(_DWORD *)((char *)&v125 + 2) = 184;
LABEL_221:
              _os_log_impl(&dword_1A1780000, v69, OS_LOG_TYPE_ERROR, "Failed to create CTFontDescriptor for font name \"%s\".: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
LABEL_222:
              *a2 = &unk_1EF559278;
              a2[1] = 0;
LABEL_223:
              unint64_t v103 = &unk_1EF559278;
              if (cf) {
                CFRelease(cf);
              }
              goto LABEL_225;
            }
            goto LABEL_214;
          }
          if (v67 == 100.0 && !*((unsigned char *)this + 24)) {
            goto LABEL_194;
          }
          size_t v71 = CTFontCreateWithFontDescriptor((CTFontDescriptorRef)cf, *((float *)this + 4), 0);
          size_t v72 = v71;
          *(void *)long long buf = &unk_1EF5592F8;
          *(void *)&uint8_t buf[8] = v71;
          if (v71)
          {
            CFArrayRef v73 = CTFontCopyVariationAxes(v71);
            *(void *)&v122[0] = &unk_1EF559358;
            *((void *)&v122[0] + 1) = v73;
            if (v73)
            {
              CFIndex Count = CFArrayGetCount(v73);
              if (Count >= 1)
              {
                CFIndex v75 = Count;
                CFIndex v76 = 0;
                char v98 = 0;
                uint64_t v77 = (const void *)*MEMORY[0x1E4F24680];
                while (1)
                {
                  ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)&v122[0] + 1), v76);
                  CFTypeID v79 = CFGetTypeID(ValueAtIndex);
                  if (v79 == CFDictionaryGetTypeID())
                  {
                    CFNumberRef v80 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, v77);
                    if (v80)
                    {
                      CFNumberRef v81 = v80;
                      CFTypeID v82 = CFGetTypeID(v80);
                      if (v82 == CFNumberGetTypeID())
                      {
                        grl::createCFNumber((grl *)0x77676874, &v101);
                        CFComparisonResult v83 = CFNumberCompare(v81, (CFNumberRef)v102, 0);
                        unint64_t v101 = &unk_1EF5591B8;
                        if (v102) {
                          CFRelease(v102);
                        }
                        if (v83 == kCFCompareEqualTo)
                        {
                          esl::toFontWeightAxisValue(*((unsigned __int8 *)this + 40), (uint64_t)v99);
                          if (v99[0])
                          {
                            if (*((unsigned char *)this + 24))
                            {
                              int v88 = *((unsigned __int8 *)this + 40);
                              if (v88 != 8)
                              {
                                esl::toFontWeightAxisValue((v88 + 1), (uint64_t)&v101);
                                float v100 = v100 + (float)(*((float *)this + 7) * (float)(*((float *)&v101 + 1) - v100));
                              }
                            }
                            uint64_t v89 = (__CFDictionary *)v119;
                            grl::createCFNumber(v100, &v101);
                            CFDictionarySetValue(v89, v81, v102);
                            unint64_t v101 = &unk_1EF5591B8;
                            if (v102) {
                              CFRelease(v102);
                            }
                            char v98 = 1;
                          }
                          goto LABEL_176;
                        }
                        grl::createCFNumber((grl *)0x77647468, &v101);
                        CFComparisonResult v84 = CFNumberCompare(v81, (CFNumberRef)v102, 0);
                        unint64_t v101 = &unk_1EF5591B8;
                        if (v102) {
                          CFRelease(v102);
                        }
                        if (v84)
                        {
                          grl::createCFNumber((grl *)0x6F70737A, &v101);
                          CFComparisonResult v85 = CFNumberCompare(v81, (CFNumberRef)v102, 0);
                          unint64_t v101 = &unk_1EF5591B8;
                          if (v102) {
                            CFRelease(v102);
                          }
                          if (v85) {
                            goto LABEL_176;
                          }
                          uint64_t v86 = (__CFDictionary *)v119;
                          float v87 = *((float *)this + 4);
                        }
                        else
                        {
                          uint64_t v86 = (__CFDictionary *)v119;
                          float v87 = *((float *)this + 5);
                        }
                        grl::createCFNumber(v87, &v101);
                        CFDictionarySetValue(v86, v81, v102);
                        unint64_t v101 = &unk_1EF5591B8;
                        if (v102) {
                          CFRelease(v102);
                        }
                      }
                    }
                  }
LABEL_176:
                  if (v75 == ++v76) {
                    goto LABEL_187;
                  }
                }
              }
              char v98 = 0;
LABEL_187:
              *(void *)&v122[0] = &unk_1EF559358;
              if (*((void *)&v122[0] + 1)) {
                CFRelease(*((CFTypeRef *)&v122[0] + 1));
              }
              char v92 = v98;
            }
            else
            {
              char v92 = 0;
            }
          }
          else
          {
            if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1) {
              dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_0);
            }
            uint64_t v90 = GEOGetGeoResourceLibCoreFoundationLog::log;
            if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
            {
              unint64_t v91 = (void *)((char *)this + 72);
              if (*((char *)this + 95) < 0) {
                unint64_t v91 = (void *)*v91;
              }
              LODWORD(v122[0]) = 136315138;
              *(void *)((char *)v122 + 4) = v91;
              _os_log_impl(&dword_1A1780000, v90, OS_LOG_TYPE_ERROR, "Failed to create CTFont for font name \"%s\".", (uint8_t *)v122, 0xCu);
            }
            char v92 = 0;
            *a2 = &unk_1EF559278;
            a2[1] = 0;
          }
          *(void *)long long buf = &unk_1EF5592F8;
          if (*(void *)&buf[8]) {
            CFRelease(*(CFTypeRef *)&buf[8]);
          }
          if (!v72) {
            goto LABEL_223;
          }
          if ((v92 & 1) == 0)
          {
LABEL_194:
            esl::toCGWeight(*((unsigned __int8 *)this + 40), (uint64_t)&v101);
            *(void *)&v122[0] = &unk_1EF5591B8;
            *((void *)&v122[0] + 1) = 0;
            if (!(_BYTE)v101) {
              goto LABEL_199;
            }
            grl::createCFNumber(*((float *)&v101 + 1), buf);
            if (*((void *)&v122[0] + 1)) {
              CFRelease(*((CFTypeRef *)&v122[0] + 1));
            }
            *((void *)&v122[0] + 1) = *(void *)&buf[8];
            if (*(void *)&buf[8])
            {
              CFDictionarySetValue(v121, (const void *)*MEMORY[0x1E4F246D8], *(const void **)&buf[8]);
              int v93 = 1;
            }
            else
            {
LABEL_199:
              if (GEOGetGeoResourceLibFontLog::onceToken != -1) {
                dispatch_once(&GEOGetGeoResourceLibFontLog::onceToken, &__block_literal_global_17_0);
              }
              unint64_t v94 = GEOGetGeoResourceLibFontLog::log;
              if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibFontLog::log, OS_LOG_TYPE_ERROR))
              {
                uint64_t v95 = (void *)((char *)this + 72);
                if (*((char *)this + 95) < 0) {
                  uint64_t v95 = (void *)*v95;
                }
                *(_DWORD *)long long buf = 136315906;
                *(void *)&buf[4] = v95;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
                *(_WORD *)&buf[22] = 2080;
                unint64_t v124 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/FontKey.cpp";
                LOWORD(v125) = 1024;
                *(_DWORD *)((char *)&v125 + 2) = 245;
                _os_log_impl(&dword_1A1780000, v94, OS_LOG_TYPE_ERROR, "Failed to create a CFNumber for font weight for font name \"%s\".: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
              }
              int v93 = 0;
              *a2 = &unk_1EF559278;
              a2[1] = 0;
            }
            *(void *)&v122[0] = &unk_1EF5591B8;
            if (*((void *)&v122[0] + 1)) {
              CFRelease(*((CFTypeRef *)&v122[0] + 1));
            }
            if (!v93) {
              goto LABEL_223;
            }
          }
          grl::createCFDictionary((uint64_t)&v112, (uint64_t)&v108, buf);
          if (attributes) {
            CFRelease(attributes);
          }
          CFDictionaryRef attributes = *(CFDictionaryRef *)&buf[8];
          CopyWithAttributes = CTFontDescriptorCreateCopyWithAttributes((CTFontDescriptorRef)cf, *(CFDictionaryRef *)&buf[8]);
          CFTypeRef v96 = cf;
          CFTypeRef cf = CopyWithAttributes;
          if (v96)
          {
            CFRelease(v96);
            CopyWithAttributes = cf;
          }
          if (!CopyWithAttributes)
          {
            if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1) {
              dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_0);
            }
            uint64_t v69 = GEOGetGeoResourceLibCoreFoundationLog::log;
            if (!os_log_type_enabled((os_log_t)GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR)) {
              goto LABEL_222;
            }
            unint64_t v97 = (void *)((char *)this + 72);
            if (*((char *)this + 95) < 0) {
              unint64_t v97 = (void *)*v97;
            }
            *(_DWORD *)long long buf = 136315906;
            *(void *)&buf[4] = v97;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
            *(_WORD *)&buf[22] = 2080;
            unint64_t v124 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/FontKey.cpp";
            LOWORD(v125) = 1024;
            *(_DWORD *)((char *)&v125 + 2) = 254;
            goto LABEL_221;
          }
LABEL_214:
          *a2 = &unk_1EF559278;
          a2[1] = CopyWithAttributes;
LABEL_225:
          uint64_t v105 = &unk_1EF5591F8;
          if (attributes) {
            CFRelease(attributes);
          }
          if (v108)
          {
            unint64_t v109 = v108;
            (*(void (**)(uint64_t, CFArrayRef *, int64_t))(*(void *)v111 + 40))(v111, v108, v110 - (char *)v108);
          }
          if (v112)
          {
            value = v112;
            (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v115 + 40))(v115, v112, v114 - (void)v112);
          }
          goto LABEL_231;
        }
        if (!*((void *)this + 7)) {
          goto LABEL_125;
        }
      }
LABEL_107:
      grl::createCFString((uint64_t)this + 48, v122);
      if (*((void *)&v122[0] + 1))
      {
        CTFontDescriptorRef v59 = CTFontDescriptorCreateWithNameAndSize(*((CFStringRef *)&v122[0] + 1), *((float *)this + 4));
        unint64_t v101 = &unk_1EF559278;
        CFTypeRef v102 = v59;
        if (v59)
        {
          CFTypeRef cf = CTFontDescriptorCreateCopyWithAttributes(v59, attributes);
          int v60 = 0;
        }
        else
        {
          if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1) {
            dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_0);
          }
          uint64_t v65 = GEOGetGeoResourceLibCoreFoundationLog::log;
          if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
          {
            uint64_t v66 = (void *)((char *)this + 72);
            if (*((char *)this + 95) < 0) {
              uint64_t v66 = (void *)*v66;
            }
            *(_DWORD *)long long buf = 136315906;
            *(void *)&buf[4] = v66;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
            *(_WORD *)&buf[22] = 2080;
            unint64_t v124 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/FontKey.cpp";
            LOWORD(v125) = 1024;
            *(_DWORD *)((char *)&v125 + 2) = 176;
            _os_log_impl(&dword_1A1780000, v65, OS_LOG_TYPE_ERROR, "Failed to create CTFontDescriptor for font name \"%s\".: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
          }
          *a2 = &unk_1EF559278;
          a2[1] = 0;
          int v60 = 1;
        }
        unint64_t v101 = &unk_1EF559278;
        if (v102) {
          CFRelease(v102);
        }
      }
      else
      {
        if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_0);
        }
        uint64_t v63 = GEOGetGeoResourceLibCoreFoundationLog::log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
        {
          uint64_t v64 = (void *)((char *)this + 72);
          if (*((char *)this + 95) < 0) {
            uint64_t v64 = (void *)*v64;
          }
          *(_DWORD *)long long buf = 136315906;
          *(void *)&buf[4] = v64;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
          *(_WORD *)&buf[22] = 2080;
          unint64_t v124 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/FontKey.cpp";
          LOWORD(v125) = 1024;
          *(_DWORD *)((char *)&v125 + 2) = 170;
          _os_log_impl(&dword_1A1780000, v63, OS_LOG_TYPE_ERROR, "Failed to generate a CFString for font name \"%s\".: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
        }
        *a2 = &unk_1EF559278;
        a2[1] = 0;
        int v60 = 1;
      }
      *(void *)&v122[0] = &unk_1EF5591D8;
      if (*((void *)&v122[0] + 1)) {
        CFRelease(*((CFTypeRef *)&v122[0] + 1));
      }
      if (v60) {
        goto LABEL_223;
      }
      goto LABEL_138;
    }
    uint64_t v29 = *MEMORY[0x1E4F24550];
    uint64_t v30 = (char *)value;
    if ((unint64_t)value >= v114)
    {
      uint64_t v32 = ((unsigned char *)value - v112) >> 3;
      unint64_t v33 = v32 + 1;
      if ((unint64_t)(v32 + 1) >> 61) {
        goto LABEL_238;
      }
      uint64_t v34 = v114 - (void)v112;
      if ((uint64_t)(v114 - (void)v112) >> 2 > v33) {
        unint64_t v33 = v34 >> 2;
      }
      if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v35 = v33;
      }
      unint64_t v125 = &v115;
      if (v35)
      {
        uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v115 + 16))(v115, 8 * v35, 8);
        uint64_t v37 = (char *)(v36 + 8 * v32);
        unint64_t v38 = v36 + 8 * v35;
        if (v36) {
          *(void *)uint64_t v37 = v29;
        }
      }
      else
      {
        unint64_t v38 = 0;
        uint64_t v37 = (char *)(8 * v32);
      }
      unint64_t v31 = v37 + 8;
      uint64_t v40 = v112;
      uint64_t v39 = (char *)value;
      if (value == v112)
      {
        unint64_t v42 = value;
      }
      else
      {
        do
        {
          uint64_t v41 = *((void *)v39 - 1);
          v39 -= 8;
          *((void *)v37 - 1) = v41;
          v37 -= 8;
        }
        while (v39 != v40);
        unint64_t v42 = v112;
        uint64_t v39 = (char *)value;
      }
      unint64_t v112 = v37;
      value = v31;
      uint64_t v43 = (const char *)v114;
      unint64_t v114 = v38;
      *(void *)&buf[16] = v39;
      unint64_t v124 = v43;
      *(void *)long long buf = v42;
      *(void *)&uint8_t buf[8] = v42;
      std::__split_buffer<void const*,geo::StdAllocator<void const*,grl::Allocator> &>::~__split_buffer((uint64_t)buf);
    }
    else
    {
      if (value) {
        *(void *)value = v29;
      }
      unint64_t v31 = v30 + 8;
    }
    value = v31;
    CFArrayRef v44 = theArray;
    unint64_t v45 = v109;
    if (v109 < (CFArrayRef *)v110)
    {
      if (v109) {
        CFArrayRef *v109 = theArray;
      }
      unint64_t v46 = v45 + 1;
LABEL_102:
      unint64_t v109 = v46;
      goto LABEL_103;
    }
    uint64_t v47 = v109 - v108;
    unint64_t v48 = v47 + 1;
    if (!((unint64_t)(v47 + 1) >> 61))
    {
      uint64_t v49 = v110 - (char *)v108;
      if ((v110 - (char *)v108) >> 2 > v48) {
        unint64_t v48 = v49 >> 2;
      }
      if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v50 = v48;
      }
      unint64_t v125 = &v111;
      if (v50)
      {
        uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v111 + 16))(v111, 8 * v50, 8);
        uint64_t v52 = (CFArrayRef *)(v51 + 8 * v47);
        uint64_t v53 = v51 + 8 * v50;
        if (v51) {
          CFArrayRef *v52 = v44;
        }
      }
      else
      {
        uint64_t v53 = 0;
        uint64_t v52 = (CFArrayRef *)(8 * v47);
      }
      unint64_t v46 = v52 + 1;
      uint64_t v55 = v108;
      uint64_t v54 = v109;
      if (v109 == v108)
      {
        unint64_t v57 = v109;
      }
      else
      {
        do
        {
          CFArrayRef v56 = *--v54;
          *--uint64_t v52 = v56;
        }
        while (v54 != v55);
        unint64_t v57 = v108;
        uint64_t v54 = v109;
      }
      uint64_t v108 = v52;
      unint64_t v109 = v46;
      uint64_t v58 = v110;
      unint64_t v110 = (char *)v53;
      *(void *)&buf[16] = v54;
      unint64_t v124 = v58;
      *(void *)long long buf = v57;
      *(void *)&uint8_t buf[8] = v57;
      std::__split_buffer<void const*,geo::StdAllocator<void const*,grl::Allocator> &>::~__split_buffer((uint64_t)buf);
      goto LABEL_102;
    }
LABEL_238:
    abort();
  }
  if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1) {
    dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_0);
  }
  unsigned int v8 = GEOGetGeoResourceLibCoreFoundationLog::log;
  if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
  {
    unsigned int v9 = (void *)((char *)this + 72);
    if (*((char *)this + 95) < 0) {
      unsigned int v9 = (void *)*v9;
    }
    *(_DWORD *)long long buf = 136315906;
    *(void *)&buf[4] = v9;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
    *(_WORD *)&buf[22] = 2080;
    unint64_t v124 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/FontKey.cpp";
    LOWORD(v125) = 1024;
    *(_DWORD *)((char *)&v125 + 2) = 60;
    _os_log_impl(&dword_1A1780000, v8, OS_LOG_TYPE_ERROR, "Failed to create traits dictionary for font \"%s\".: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
  }
  *a2 = &unk_1EF559278;
  a2[1] = 0;
LABEL_235:
  unint64_t v120 = &unk_1EF559058;
  if (v121) {
    CFRelease(v121);
  }
}

void grl::createCFNumber(grl *this@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (this >= 0x7FFFFFFF) {
    int v3 = 0x7FFFFFFF;
  }
  else {
    int v3 = (int)this;
  }
  int valuePtr = v3;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  *a2 = &unk_1EF5591B8;
  a2[1] = v4;
  if (!v4)
  {
    if (GEOGetGeoResourceLibMathLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibMathLog::onceToken, &__block_literal_global_25_0);
    }
    int v5 = GEOGetGeoResourceLibMathLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibMathLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      unsigned int v8 = "result";
      __int16 v9 = 2080;
      unsigned int v10 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/CoreGraphicsUtilities.cpp";
      __int16 v11 = 1024;
      int v12 = 20;
      _os_log_impl(&dword_1A1780000, v5, OS_LOG_TYPE_ERROR, "Failed to generate CFNumber for uint32_t.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
    }
  }
}

void grl::createCFNumber(float a1@<S0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  float valuePtr = a1;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  *a2 = &unk_1EF5591B8;
  a2[1] = v4;
  if (!v4)
  {
    if (GEOGetGeoResourceLibMathLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibMathLog::onceToken, &__block_literal_global_25_0);
    }
    int v5 = GEOGetGeoResourceLibMathLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibMathLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      unsigned int v8 = "result";
      __int16 v9 = 2080;
      unsigned int v10 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/CoreGraphicsUtilities.cpp";
      __int16 v11 = 1024;
      int v12 = 28;
      _os_log_impl(&dword_1A1780000, v5, OS_LOG_TYPE_ERROR, "Failed to generate CFNumber for float.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
    }
  }
}

void grl::createCFMutableDictionary(void *a1@<X8>)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  unsigned int v6 = &unk_1EF559058;
  CFTypeRef cf = Mutable;
  if (Mutable)
  {
    *a1 = &unk_1EF559058;
    a1[1] = Mutable;
  }
  else
  {
    if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_0);
    }
    CFNumberRef v4 = GEOGetGeoResourceLibCoreFoundationLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v5 = 0;
      _os_log_impl(&dword_1A1780000, v4, OS_LOG_TYPE_ERROR, "Failed to create CFMutableDictionary.", v5, 2u);
    }
    *a1 = &unk_1EF559058;
    a1[1] = 0;
    unsigned int v6 = &unk_1EF559058;
    if (cf) {
      CFRelease(cf);
    }
  }
}

void grl::createCFDictionary(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 8) - *(void *)a1;
  if (v4 == *(void *)(a2 + 8) - *(void *)a2)
  {
    unint64_t v5 = v4 >> 3;
    if (v5 >= 0x7FFFFFFFFFFFFFFFLL) {
      CFIndex v6 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      CFIndex v6 = v5;
    }
    CFDictionaryRef v7 = CFDictionaryCreate(0, *(const void ***)a1, *(const void ***)a2, v6, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *(void *)long long buf = &unk_1EF5591F8;
    CFTypeRef cf = v7;
    if (v7)
    {
      *a3 = &unk_1EF5591F8;
      a3[1] = v7;
    }
    else
    {
      if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1) {
        dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_0);
      }
      __int16 v9 = GEOGetGeoResourceLibCoreFoundationLog::log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)unsigned int v10 = 0;
        _os_log_impl(&dword_1A1780000, v9, OS_LOG_TYPE_ERROR, "Failed to create CFDictionary.", v10, 2u);
      }
      *a3 = &unk_1EF5591F8;
      a3[1] = 0;
      *(void *)long long buf = &unk_1EF5591F8;
      if (cf) {
        CFRelease(cf);
      }
    }
  }
  else
  {
    if (GEOGetGeoResourceLibCoreFoundationLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibCoreFoundationLog::onceToken, &__block_literal_global_33_0);
    }
    unsigned int v8 = GEOGetGeoResourceLibCoreFoundationLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibCoreFoundationLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1A1780000, v8, OS_LOG_TYPE_ERROR, "Creating CFDictionary with missmatching number of keys and values.", buf, 2u);
    }
    *a3 = &unk_1EF5591F8;
    a3[1] = 0;
  }
}

uint64_t esl::toFontWeightAxisValue@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  switch((int)result)
  {
    case 0:
      *(unsigned char *)a2 = 1;
      int v2 = 1128792064;
      goto LABEL_12;
    case 1:
      *(unsigned char *)a2 = 1;
      int v2 = 1133903872;
      goto LABEL_12;
    case 2:
      *(unsigned char *)a2 = 1;
      int v2 = 1120403456;
      goto LABEL_12;
    case 3:
      *(unsigned char *)a2 = 1;
      int v2 = 1137180672;
      goto LABEL_12;
    case 4:
      *(unsigned char *)a2 = 1;
      int v2 = 1140457472;
      goto LABEL_12;
    case 5:
      *(unsigned char *)a2 = 1;
      int v2 = 1142292480;
      goto LABEL_12;
    case 6:
      *(unsigned char *)a2 = 1;
      int v2 = 1143930880;
      goto LABEL_12;
    case 7:
      *(unsigned char *)a2 = 1;
      int v2 = 1145569280;
      goto LABEL_12;
    case 8:
      *(unsigned char *)a2 = 1;
      int v2 = 1147207680;
LABEL_12:
      *(_DWORD *)(a2 + 4) = v2;
      break;
    default:
      *(unsigned char *)a2 = 0;
      break;
  }
  return result;
}

float esl::toCGWeight@<S0>(int a1@<W0>, uint64_t a2@<X8>)
{
  switch(a1)
  {
    case 0:
      int v2 = (double *)MEMORY[0x1E4F246E0];
      goto LABEL_12;
    case 1:
      int v2 = (double *)MEMORY[0x1E4F246B0];
      goto LABEL_12;
    case 2:
      int v2 = (double *)MEMORY[0x1E4F246D0];
      goto LABEL_12;
    case 3:
      int v2 = (double *)MEMORY[0x1E4F246C0];
      goto LABEL_12;
    case 4:
      int v2 = (double *)MEMORY[0x1E4F246B8];
      goto LABEL_12;
    case 5:
      int v2 = (double *)MEMORY[0x1E4F246C8];
      goto LABEL_12;
    case 6:
      int v2 = (double *)MEMORY[0x1E4F246A0];
      goto LABEL_12;
    case 7:
      int v2 = (double *)MEMORY[0x1E4F246A8];
      goto LABEL_12;
    case 8:
      int v2 = (double *)MEMORY[0x1E4F24698];
LABEL_12:
      float result = *v2;
      *(unsigned char *)a2 = 1;
      *(float *)(a2 + 4) = result;
      break;
    default:
      *(unsigned char *)a2 = 0;
      break;
  }
  return result;
}

void ___ZZ40__VKSceneConfiguration_setStyleManager__ENK3__0clENSt3__110shared_ptrIN3gss17StylesheetManagerINS2_10PropertyIDEEEEEb_block_invoke(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2)
    {
      uint64_t v3 = *(void *)(v2 + 16);
      unsigned __int8 v4 = atomic_load((unsigned __int8 *)(v3 + 2784));
      if ((v4 & 1) == 0) {
        std::__assoc_sub_state::wait(*(std::__assoc_sub_state **)(v3 + 2808));
      }
      unint64_t v5 = *(float **)(v3 + 120);
      CFIndex v6 = *(std::__shared_weak_count **)(v3 + 128);
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *(double *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + 152) = v5[65];
      *(double *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + 160) = v5[66];
      *(double *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + 168) = v5[67];
      *(double *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + 176) = v5[68];
      *(double *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + 184) = v5[69];
      *(double *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + 192) = v5[70];
      *(double *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + 200) = v5[71];
      *(double *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + 208) = v5[80];
      *(double *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + 216) = v5[81];
      *(double *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + 224) = v5[82];
      *(double *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) + 232) = v5[83];
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void md::DrapingLogic::runBeforeLayoutAtVariableRate(uint64_t a1, const md::LayoutContext *a2, void *a3, uint64_t a4)
{
  uint64_t v620 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v4 = (void *)*a3;
  CFIndex v6 = (uint64_t *)a3[2];
  unint64_t v5 = (unsigned __int8 *)a3[3];
  uint64_t v564 = a3[1];
  double v7 = fabs(*(double *)(v564 + 40));
  int v8 = v5[1];
  int v9 = *v5;
  if (v8) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = v9 == 0;
  }
  char v11 = v10;
  if (v7 <= 0.0001) {
    char v11 = 1;
  }
  char v591 = v11;
  v568 = v4;
  uint64_t v12 = v4[21];
  uint64_t v590 = (int8x8_t *)v12;
  v559 = v6;
  uint64_t v13 = (atomic_ullong *)*v6;
  while (1)
  {
    unsigned int v14 = (_WORD *)v13[6];
    unsigned int v15 = (_WORD *)v13[7];
    if (v14 == v15)
    {
      uint64_t v572 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
      uint64_t v17 = a1;
    }
    else
    {
      uint64_t v572 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
      unsigned int v16 = (_WORD *)v13[6];
      uint64_t v17 = a1;
      while (*v16 != 33)
      {
        v16 += 16;
        if (v16 == v15) {
          goto LABEL_23;
        }
      }
      if (v16 == v15)
      {
        unsigned int v18 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
      }
      else
      {
        while (*v14 != 33)
        {
          v14 += 16;
          if (v14 == v15)
          {
            unsigned int v14 = (_WORD *)v13[7];
            break;
          }
        }
        unsigned int v18 = (uint64_t *)(v14 + 4);
      }
      uint64_t v572 = v18;
    }
LABEL_23:
    v589[0] = &v590;
    v589[1] = &v591;
    v589[2] = v17;
    uint64_t v19 = (void *)gdc::Registry::storage<md::overlayComponents::RasterOverlayBase<md::OverlayTileData::OverlayTileResource::RasterTile>>((int8x8_t *)v12);
    unint64_t v20 = (void *)gdc::Registry::storage<std::unordered_map<gdc::Registry*,std::vector<gdc::Entity>>>((int8x8_t *)v12);
    uint64_t v21 = gdc::Registry::storage<std::vector<gdc::Registry*>>((int8x8_t *)v12);
    uint64_t v22 = (void *)v21;
    uint64_t v23 = v21 + 32;
    uint64_t v25 = v19[7];
    uint64_t v24 = v19[8];
    if (v20[8] - v20[7] >= (unint64_t)(v24 - v25)) {
      int v26 = v19 + 4;
    }
    else {
      int v26 = v20 + 4;
    }
    if (*(void *)(v21 + 64) - *(void *)(v21 + 56) >= v26[4] - v26[3]) {
      int v27 = v26;
    }
    else {
      int v27 = (void *)(v21 + 32);
    }
    if (v19 + 4 == v27 && v25 != v24)
    {
      uint64_t v227 = (uint64_t *)v19[10];
      do
      {
        unint64_t v359 = *(unsigned int *)(v25 + 4);
        unint64_t v360 = v359 >> 7;
        uint64_t v361 = v20[4];
        unint64_t v362 = (v20[5] - v361) >> 3;
        if (v359 >> 7 >= v362) {
          goto LABEL_711;
        }
        uint64_t v363 = *(void *)(v361 + 8 * v360);
        if (!v363) {
          goto LABEL_711;
        }
        unint64_t v364 = *(unsigned __int16 *)(v363 + 2 * (v359 & 0x7F));
        uint64_t v366 = v20[7];
        uint64_t v365 = v20[8];
        unint64_t v367 = (v365 - v366) >> 3;
        if (v367 <= v364) {
          goto LABEL_711;
        }
        uint64_t v368 = v366 + 8 * v364;
        if (v368 == v365 || *(_DWORD *)(v368 + 4) != v359) {
          goto LABEL_711;
        }
        uint64_t v370 = v22[4];
        unint64_t v371 = (v22[5] - v370) >> 3;
        if (v360 >= v371) {
          goto LABEL_711;
        }
        uint64_t v372 = *(void *)(v370 + 8 * v360);
        if (!v372) {
          goto LABEL_711;
        }
        unint64_t v373 = *(unsigned __int16 *)(v372 + 2 * (v359 & 0x7F));
        uint64_t v375 = v22[7];
        uint64_t v374 = v22[8];
        unint64_t v376 = (v374 - v375) >> 3;
        if (v376 <= v373) {
          goto LABEL_711;
        }
        uint64_t v377 = v375 + 8 * v373;
        if (v377 == v374 || *(_DWORD *)(v377 + 4) != v359) {
          goto LABEL_711;
        }
        unint64_t v379 = *(void *)v25;
        uint64_t v380 = HIDWORD(*(void *)v25);
        unint64_t v381 = *(void *)v25 >> 39;
        if (v381 < v362
          && (uint64_t v382 = *(void *)(v361 + 8 * v381)) != 0
          && (unint64_t v383 = *(unsigned __int16 *)(v382 + 2 * (HIDWORD(v379) & 0x7F)), v367 > v383)
          && ((uint64_t v384 = v366 + 8 * v383, v384 != v365) ? (v385 = *(_DWORD *)(v384 + 4) == v380) : (v385 = 0), v385))
        {
          uint64_t v386 = v20[10] + 40 * v383;
          if (v381 >= v371) {
            goto LABEL_709;
          }
        }
        else
        {
          uint64_t v386 = v20[11];
          if (v381 >= v371) {
            goto LABEL_709;
          }
        }
        uint64_t v387 = *(void *)(v370 + 8 * v381);
        if (v387)
        {
          unint64_t v388 = *(unsigned __int16 *)(v387 + 2 * (HIDWORD(v379) & 0x7F));
          if (v376 > v388)
          {
            uint64_t v389 = v375 + 8 * v388;
            if (v389 != v374 && *(_DWORD *)(v389 + 4) == v380)
            {
              uint64_t v358 = (unint64_t **)(v22[10] + 24 * v388);
              goto LABEL_710;
            }
          }
        }
LABEL_709:
        uint64_t v358 = (unint64_t **)v22[11];
LABEL_710:
        _ZZN2md12DrapingLogic29runBeforeLayoutAtVariableRateERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_15OverlaysContextENS_13CameraContextENS_19PendingSceneContextENS_16ElevationContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_14DrapingContextEENK3__1clENS5_6EntityERNS_17overlayComponents17RasterOverlayBaseINS_15OverlayTileData19OverlayTileResource10RasterTileEEERNSt3__113unordered_mapIPNS5_8RegistryENSS_6vectorISK_NSS_9allocatorISK_EEEENSS_4hashISV_EENSS_8equal_toISV_EENSX_INSS_4pairIKSV_SZ_EEEEEERNSW_ISV_NSX_ISV_EEEE((uint64_t)v589, v379, v227, v386, v358);
LABEL_711:
        ++v227;
        v25 += 8;
      }
      while (v25 != v24);
    }
    if (v20 + 4 == v27)
    {
      uint64_t v251 = v20[7];
      uint64_t v252 = v20[8];
      if (v251 != v252)
      {
        uint64_t v253 = v20[10];
        do
        {
          unint64_t v425 = *(unsigned int *)(v251 + 4);
          unint64_t v426 = v425 >> 7;
          uint64_t v427 = v19[4];
          unint64_t v428 = (v19[5] - v427) >> 3;
          if (v425 >> 7 >= v428) {
            goto LABEL_785;
          }
          uint64_t v429 = *(void *)(v427 + 8 * v426);
          if (!v429) {
            goto LABEL_785;
          }
          unint64_t v430 = *(unsigned __int16 *)(v429 + 2 * (v425 & 0x7F));
          uint64_t v432 = v19[7];
          uint64_t v431 = v19[8];
          unint64_t v433 = (v431 - v432) >> 3;
          if (v433 <= v430) {
            goto LABEL_785;
          }
          uint64_t v434 = v432 + 8 * v430;
          if (v434 == v431 || *(_DWORD *)(v434 + 4) != v425) {
            goto LABEL_785;
          }
          uint64_t v436 = v22[4];
          unint64_t v437 = (v22[5] - v436) >> 3;
          if (v426 >= v437) {
            goto LABEL_785;
          }
          uint64_t v438 = *(void *)(v436 + 8 * v426);
          if (!v438) {
            goto LABEL_785;
          }
          unint64_t v439 = *(unsigned __int16 *)(v438 + 2 * (v425 & 0x7F));
          uint64_t v441 = v22[7];
          uint64_t v440 = v22[8];
          unint64_t v442 = (v440 - v441) >> 3;
          if (v442 <= v439) {
            goto LABEL_785;
          }
          uint64_t v443 = v441 + 8 * v439;
          if (v443 == v440 || *(_DWORD *)(v443 + 4) != v425) {
            goto LABEL_785;
          }
          unint64_t v445 = *(void *)v251;
          uint64_t v446 = HIDWORD(*(void *)v251);
          unint64_t v447 = *(void *)v251 >> 39;
          if (v447 < v428
            && (uint64_t v448 = *(void *)(v427 + 8 * v447)) != 0
            && (unint64_t v449 = *(unsigned __int16 *)(v448 + 2 * (HIDWORD(v445) & 0x7F)), v433 > v449)
            && ((uint64_t v450 = v432 + 8 * v449, v450 != v431) ? (v451 = *(_DWORD *)(v450 + 4) == v446) : (v451 = 0),
                v451))
          {
            unint64_t v452 = (uint64_t *)(v19[10] + 8 * v449);
            if (v447 >= v437) {
              goto LABEL_783;
            }
          }
          else
          {
            unint64_t v452 = (uint64_t *)v19[11];
            if (v447 >= v437) {
              goto LABEL_783;
            }
          }
          uint64_t v453 = *(void *)(v436 + 8 * v447);
          if (v453)
          {
            unint64_t v454 = *(unsigned __int16 *)(v453 + 2 * (HIDWORD(v445) & 0x7F));
            if (v442 > v454)
            {
              uint64_t v455 = v441 + 8 * v454;
              if (v455 != v440 && *(_DWORD *)(v455 + 4) == v446)
              {
                uint64_t v424 = (unint64_t **)(v22[10] + 24 * v454);
                goto LABEL_784;
              }
            }
          }
LABEL_783:
          uint64_t v424 = (unint64_t **)v22[11];
LABEL_784:
          _ZZN2md12DrapingLogic29runBeforeLayoutAtVariableRateERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_15OverlaysContextENS_13CameraContextENS_19PendingSceneContextENS_16ElevationContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_14DrapingContextEENK3__1clENS5_6EntityERNS_17overlayComponents17RasterOverlayBaseINS_15OverlayTileData19OverlayTileResource10RasterTileEEERNSt3__113unordered_mapIPNS5_8RegistryENSS_6vectorISK_NSS_9allocatorISK_EEEENSS_4hashISV_EENSS_8equal_toISV_EENSX_INSS_4pairIKSV_SZ_EEEEEERNSW_ISV_NSX_ISV_EEEE((uint64_t)v589, v445, v452, v253, v424);
LABEL_785:
          v253 += 40;
          v251 += 8;
        }
        while (v251 != v252);
      }
    }
    if ((void *)v23 == v27)
    {
      uint64_t v254 = v22[7];
      uint64_t v255 = v22[8];
      if (v254 != v255)
      {
        uint64_t v256 = (unint64_t **)v22[10];
        do
        {
          unint64_t v458 = *(unsigned int *)(v254 + 4);
          unint64_t v459 = v458 >> 7;
          uint64_t v460 = v19[4];
          unint64_t v461 = (v19[5] - v460) >> 3;
          if (v458 >> 7 >= v461) {
            goto LABEL_822;
          }
          uint64_t v462 = *(void *)(v460 + 8 * v459);
          if (!v462) {
            goto LABEL_822;
          }
          unint64_t v463 = *(unsigned __int16 *)(v462 + 2 * (v458 & 0x7F));
          uint64_t v465 = v19[7];
          uint64_t v464 = v19[8];
          unint64_t v466 = (v464 - v465) >> 3;
          if (v466 <= v463) {
            goto LABEL_822;
          }
          uint64_t v467 = v465 + 8 * v463;
          if (v467 == v464 || *(_DWORD *)(v467 + 4) != v458) {
            goto LABEL_822;
          }
          uint64_t v469 = v20[4];
          unint64_t v470 = (v20[5] - v469) >> 3;
          if (v459 >= v470) {
            goto LABEL_822;
          }
          uint64_t v471 = *(void *)(v469 + 8 * v459);
          if (!v471) {
            goto LABEL_822;
          }
          unint64_t v472 = *(unsigned __int16 *)(v471 + 2 * (v458 & 0x7F));
          uint64_t v474 = v20[7];
          uint64_t v473 = v20[8];
          unint64_t v475 = (v473 - v474) >> 3;
          if (v475 <= v472) {
            goto LABEL_822;
          }
          uint64_t v476 = v474 + 8 * v472;
          if (v476 == v473 || *(_DWORD *)(v476 + 4) != v458) {
            goto LABEL_822;
          }
          unint64_t v478 = *(void *)v254;
          uint64_t v479 = HIDWORD(*(void *)v254);
          unint64_t v480 = *(void *)v254 >> 39;
          if (v480 < v461
            && (uint64_t v481 = *(void *)(v460 + 8 * v480)) != 0
            && (unint64_t v482 = *(unsigned __int16 *)(v481 + 2 * (HIDWORD(v478) & 0x7F)), v466 > v482)
            && ((uint64_t v483 = v465 + 8 * v482, v483 != v464) ? (v484 = *(_DWORD *)(v483 + 4) == v479) : (v484 = 0),
                v484))
          {
            unint64_t v485 = (uint64_t *)(v19[10] + 8 * v482);
            if (v480 >= v470) {
              goto LABEL_820;
            }
          }
          else
          {
            unint64_t v485 = (uint64_t *)v19[11];
            if (v480 >= v470) {
              goto LABEL_820;
            }
          }
          uint64_t v486 = *(void *)(v469 + 8 * v480);
          if (v486)
          {
            unint64_t v487 = *(unsigned __int16 *)(v486 + 2 * (HIDWORD(v478) & 0x7F));
            if (v475 > v487)
            {
              uint64_t v488 = v474 + 8 * v487;
              if (v488 != v473 && *(_DWORD *)(v488 + 4) == v479)
              {
                uint64_t v457 = v20[10] + 40 * v487;
                goto LABEL_821;
              }
            }
          }
LABEL_820:
          uint64_t v457 = v20[11];
LABEL_821:
          _ZZN2md12DrapingLogic29runBeforeLayoutAtVariableRateERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_15OverlaysContextENS_13CameraContextENS_19PendingSceneContextENS_16ElevationContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_14DrapingContextEENK3__1clENS5_6EntityERNS_17overlayComponents17RasterOverlayBaseINS_15OverlayTileData19OverlayTileResource10RasterTileEEERNSt3__113unordered_mapIPNS5_8RegistryENSS_6vectorISK_NSS_9allocatorISK_EEEENSS_4hashISV_EENSS_8equal_toISV_EENSX_INSS_4pairIKSV_SZ_EEEEEERNSW_ISV_NSX_ISV_EEEE((uint64_t)v589, v478, v485, v457, v256);
LABEL_822:
          v256 += 3;
          v254 += 8;
        }
        while (v254 != v255);
      }
    }
    uint64_t v29 = v590;
    uint64_t v30 = (void *)gdc::Registry::storage<md::overlayComponents::RasterOverlayBase<md::OverlayTileData::OverlayTileResource::Texture>>(v590);
    unint64_t v31 = (void *)gdc::Registry::storage<std::unordered_map<gdc::Registry*,std::vector<gdc::Entity>>>(v29);
    uint64_t v32 = gdc::Registry::storage<std::vector<gdc::Registry*>>(v29);
    unint64_t v33 = (void *)v32;
    uint64_t v34 = v32 + 32;
    uint64_t v36 = v30[7];
    uint64_t v35 = v30[8];
    if (v31[8] - v31[7] >= (unint64_t)(v35 - v36)) {
      uint64_t v37 = v30 + 4;
    }
    else {
      uint64_t v37 = v31 + 4;
    }
    if (*(void *)(v32 + 64) - *(void *)(v32 + 56) >= v37[4] - v37[3]) {
      unint64_t v38 = v37;
    }
    else {
      unint64_t v38 = (void *)(v32 + 32);
    }
    if (v30 + 4 == v38 && v36 != v35)
    {
      uint64_t v228 = (uint64_t *)v30[10];
      do
      {
        unint64_t v392 = *(unsigned int *)(v36 + 4);
        unint64_t v393 = v392 >> 7;
        uint64_t v394 = v31[4];
        unint64_t v395 = (v31[5] - v394) >> 3;
        if (v392 >> 7 >= v395) {
          goto LABEL_748;
        }
        uint64_t v396 = *(void *)(v394 + 8 * v393);
        if (!v396) {
          goto LABEL_748;
        }
        unint64_t v397 = *(unsigned __int16 *)(v396 + 2 * (v392 & 0x7F));
        uint64_t v399 = v31[7];
        uint64_t v398 = v31[8];
        unint64_t v400 = (v398 - v399) >> 3;
        if (v400 <= v397) {
          goto LABEL_748;
        }
        uint64_t v401 = v399 + 8 * v397;
        if (v401 == v398 || *(_DWORD *)(v401 + 4) != v392) {
          goto LABEL_748;
        }
        uint64_t v403 = v33[4];
        unint64_t v404 = (v33[5] - v403) >> 3;
        if (v393 >= v404) {
          goto LABEL_748;
        }
        uint64_t v405 = *(void *)(v403 + 8 * v393);
        if (!v405) {
          goto LABEL_748;
        }
        unint64_t v406 = *(unsigned __int16 *)(v405 + 2 * (v392 & 0x7F));
        uint64_t v408 = v33[7];
        uint64_t v407 = v33[8];
        unint64_t v409 = (v407 - v408) >> 3;
        if (v409 <= v406) {
          goto LABEL_748;
        }
        uint64_t v410 = v408 + 8 * v406;
        if (v410 == v407 || *(_DWORD *)(v410 + 4) != v392) {
          goto LABEL_748;
        }
        unint64_t v412 = *(void *)v36;
        uint64_t v413 = HIDWORD(*(void *)v36);
        unint64_t v414 = *(void *)v36 >> 39;
        if (v414 < v395
          && (uint64_t v415 = *(void *)(v394 + 8 * v414)) != 0
          && (unint64_t v416 = *(unsigned __int16 *)(v415 + 2 * (HIDWORD(v412) & 0x7F)), v400 > v416)
          && ((uint64_t v417 = v399 + 8 * v416, v417 != v398) ? (v418 = *(_DWORD *)(v417 + 4) == v413) : (v418 = 0), v418))
        {
          uint64_t v419 = v31[10] + 40 * v416;
          if (v414 >= v404) {
            goto LABEL_746;
          }
        }
        else
        {
          uint64_t v419 = v31[11];
          if (v414 >= v404) {
            goto LABEL_746;
          }
        }
        uint64_t v420 = *(void *)(v403 + 8 * v414);
        if (v420)
        {
          unint64_t v421 = *(unsigned __int16 *)(v420 + 2 * (HIDWORD(v412) & 0x7F));
          if (v409 > v421)
          {
            uint64_t v422 = v408 + 8 * v421;
            if (v422 != v407 && *(_DWORD *)(v422 + 4) == v413)
            {
              float v391 = (unint64_t **)(v33[10] + 24 * v421);
              goto LABEL_747;
            }
          }
        }
LABEL_746:
        float v391 = (unint64_t **)v33[11];
LABEL_747:
        _ZZN2md12DrapingLogic29runBeforeLayoutAtVariableRateERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_15OverlaysContextENS_13CameraContextENS_19PendingSceneContextENS_16ElevationContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_14DrapingContextEENK3__2clENS5_6EntityERNS_17overlayComponents17RasterOverlayBaseINS_15OverlayTileData19OverlayTileResource7TextureEEERNSt3__113unordered_mapIPNS5_8RegistryENSS_6vectorISK_NSS_9allocatorISK_EEEENSS_4hashISV_EENSS_8equal_toISV_EENSX_INSS_4pairIKSV_SZ_EEEEEERNSW_ISV_NSX_ISV_EEEE((uint64_t)v589, v412, v228, v419, v391);
LABEL_748:
        ++v228;
        v36 += 8;
      }
      while (v36 != v35);
    }
    if (v31 + 4 == v38)
    {
      uint64_t v257 = v31[7];
      uint64_t v258 = v31[8];
      if (v257 != v258)
      {
        uint64_t v259 = v31[10];
        do
        {
          unint64_t v491 = *(unsigned int *)(v257 + 4);
          unint64_t v492 = v491 >> 7;
          uint64_t v493 = v30[4];
          unint64_t v494 = (v30[5] - v493) >> 3;
          if (v491 >> 7 >= v494) {
            goto LABEL_859;
          }
          uint64_t v495 = *(void *)(v493 + 8 * v492);
          if (!v495) {
            goto LABEL_859;
          }
          unint64_t v496 = *(unsigned __int16 *)(v495 + 2 * (v491 & 0x7F));
          uint64_t v498 = v30[7];
          uint64_t v497 = v30[8];
          unint64_t v499 = (v497 - v498) >> 3;
          if (v499 <= v496) {
            goto LABEL_859;
          }
          uint64_t v500 = v498 + 8 * v496;
          if (v500 == v497 || *(_DWORD *)(v500 + 4) != v491) {
            goto LABEL_859;
          }
          uint64_t v502 = v33[4];
          unint64_t v503 = (v33[5] - v502) >> 3;
          if (v492 >= v503) {
            goto LABEL_859;
          }
          uint64_t v504 = *(void *)(v502 + 8 * v492);
          if (!v504) {
            goto LABEL_859;
          }
          unint64_t v505 = *(unsigned __int16 *)(v504 + 2 * (v491 & 0x7F));
          uint64_t v507 = v33[7];
          uint64_t v506 = v33[8];
          unint64_t v508 = (v506 - v507) >> 3;
          if (v508 <= v505) {
            goto LABEL_859;
          }
          uint64_t v509 = v507 + 8 * v505;
          if (v509 == v506 || *(_DWORD *)(v509 + 4) != v491) {
            goto LABEL_859;
          }
          unint64_t v511 = *(void *)v257;
          uint64_t v512 = HIDWORD(*(void *)v257);
          unint64_t v513 = *(void *)v257 >> 39;
          if (v513 < v494
            && (uint64_t v514 = *(void *)(v493 + 8 * v513)) != 0
            && (unint64_t v515 = *(unsigned __int16 *)(v514 + 2 * (HIDWORD(v511) & 0x7F)), v499 > v515)
            && ((uint64_t v516 = v498 + 8 * v515, v516 != v497) ? (v517 = *(_DWORD *)(v516 + 4) == v512) : (v517 = 0),
                v517))
          {
            long long v518 = (uint64_t *)(v30[10] + 8 * v515);
            if (v513 >= v503) {
              goto LABEL_857;
            }
          }
          else
          {
            long long v518 = (uint64_t *)v30[11];
            if (v513 >= v503) {
              goto LABEL_857;
            }
          }
          uint64_t v519 = *(void *)(v502 + 8 * v513);
          if (v519)
          {
            unint64_t v520 = *(unsigned __int16 *)(v519 + 2 * (HIDWORD(v511) & 0x7F));
            if (v508 > v520)
            {
              uint64_t v521 = v507 + 8 * v520;
              if (v521 != v506 && *(_DWORD *)(v521 + 4) == v512)
              {
                uint64_t v490 = (unint64_t **)(v33[10] + 24 * v520);
                goto LABEL_858;
              }
            }
          }
LABEL_857:
          uint64_t v490 = (unint64_t **)v33[11];
LABEL_858:
          _ZZN2md12DrapingLogic29runBeforeLayoutAtVariableRateERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_15OverlaysContextENS_13CameraContextENS_19PendingSceneContextENS_16ElevationContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_14DrapingContextEENK3__2clENS5_6EntityERNS_17overlayComponents17RasterOverlayBaseINS_15OverlayTileData19OverlayTileResource7TextureEEERNSt3__113unordered_mapIPNS5_8RegistryENSS_6vectorISK_NSS_9allocatorISK_EEEENSS_4hashISV_EENSS_8equal_toISV_EENSX_INSS_4pairIKSV_SZ_EEEEEERNSW_ISV_NSX_ISV_EEEE((uint64_t)v589, v511, v518, v259, v490);
LABEL_859:
          v259 += 40;
          v257 += 8;
        }
        while (v257 != v258);
      }
    }
    if ((void *)v34 == v38)
    {
      uint64_t v260 = v33[7];
      uint64_t v261 = v33[8];
      if (v260 != v261)
      {
        uint64_t v262 = (unint64_t **)v33[10];
        do
        {
          unint64_t v524 = *(unsigned int *)(v260 + 4);
          unint64_t v525 = v524 >> 7;
          uint64_t v526 = v30[4];
          unint64_t v527 = (v30[5] - v526) >> 3;
          if (v524 >> 7 >= v527) {
            goto LABEL_896;
          }
          uint64_t v528 = *(void *)(v526 + 8 * v525);
          if (!v528) {
            goto LABEL_896;
          }
          unint64_t v529 = *(unsigned __int16 *)(v528 + 2 * (v524 & 0x7F));
          uint64_t v531 = v30[7];
          uint64_t v530 = v30[8];
          unint64_t v532 = (v530 - v531) >> 3;
          if (v532 <= v529) {
            goto LABEL_896;
          }
          uint64_t v533 = v531 + 8 * v529;
          if (v533 == v530 || *(_DWORD *)(v533 + 4) != v524) {
            goto LABEL_896;
          }
          uint64_t v535 = v31[4];
          unint64_t v536 = (v31[5] - v535) >> 3;
          if (v525 >= v536) {
            goto LABEL_896;
          }
          uint64_t v537 = *(void *)(v535 + 8 * v525);
          if (!v537) {
            goto LABEL_896;
          }
          unint64_t v538 = *(unsigned __int16 *)(v537 + 2 * (v524 & 0x7F));
          uint64_t v540 = v31[7];
          uint64_t v539 = v31[8];
          unint64_t v541 = (v539 - v540) >> 3;
          if (v541 <= v538) {
            goto LABEL_896;
          }
          uint64_t v542 = v540 + 8 * v538;
          if (v542 == v539 || *(_DWORD *)(v542 + 4) != v524) {
            goto LABEL_896;
          }
          unint64_t v544 = *(void *)v260;
          uint64_t v545 = HIDWORD(*(void *)v260);
          unint64_t v546 = *(void *)v260 >> 39;
          if (v546 < v527
            && (uint64_t v547 = *(void *)(v526 + 8 * v546)) != 0
            && (unint64_t v548 = *(unsigned __int16 *)(v547 + 2 * (HIDWORD(v544) & 0x7F)), v532 > v548)
            && ((uint64_t v549 = v531 + 8 * v548, v549 != v530) ? (v550 = *(_DWORD *)(v549 + 4) == v545) : (v550 = 0),
                v550))
          {
            uint64_t v551 = (uint64_t *)(v30[10] + 8 * v548);
            if (v546 >= v536) {
              goto LABEL_894;
            }
          }
          else
          {
            uint64_t v551 = (uint64_t *)v30[11];
            if (v546 >= v536) {
              goto LABEL_894;
            }
          }
          uint64_t v552 = *(void *)(v535 + 8 * v546);
          if (v552)
          {
            unint64_t v553 = *(unsigned __int16 *)(v552 + 2 * (HIDWORD(v544) & 0x7F));
            if (v541 > v553)
            {
              uint64_t v554 = v540 + 8 * v553;
              if (v554 != v539 && *(_DWORD *)(v554 + 4) == v545)
              {
                uint64_t v523 = v31[10] + 40 * v553;
                goto LABEL_895;
              }
            }
          }
LABEL_894:
          uint64_t v523 = v31[11];
LABEL_895:
          _ZZN2md12DrapingLogic29runBeforeLayoutAtVariableRateERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_15OverlaysContextENS_13CameraContextENS_19PendingSceneContextENS_16ElevationContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_14DrapingContextEENK3__2clENS5_6EntityERNS_17overlayComponents17RasterOverlayBaseINS_15OverlayTileData19OverlayTileResource7TextureEEERNSt3__113unordered_mapIPNS5_8RegistryENSS_6vectorISK_NSS_9allocatorISK_EEEENSS_4hashISV_EENSS_8equal_toISV_EENSX_INSS_4pairIKSV_SZ_EEEEEERNSW_ISV_NSX_ISV_EEEE((uint64_t)v589, v544, v551, v523, v262);
LABEL_896:
          v262 += 3;
          v260 += 8;
        }
        while (v260 != v261);
      }
    }
    uint64_t v40 = *(int8x8_t **)(a1 + 168);
    uint64_t v41 = (void *)v40[3];
    if (!v41) {
      goto LABEL_172;
    }
    do
    {
      unint64_t v42 = (void *)v41[8];
      if (v42)
      {
        while (1)
        {
          uint64_t v43 = v42[8];
          uint64_t v44 = *(void *)(v43 + 32);
          if (v44)
          {
            BOOL v45 = *(void *)(v44 + 8) == -1;
            uint64_t v46 = *(void *)(v43 + 48);
            if (!v46) {
              goto LABEL_62;
            }
          }
          else
          {
            BOOL v45 = 1;
            uint64_t v46 = *(void *)(v43 + 48);
            if (!v46) {
              goto LABEL_62;
            }
          }
          if (*(void *)(v46 + 8) == -1) {
            BOOL v45 = 1;
          }
          if (v45)
          {
LABEL_62:
            if (!atomic_load((unsigned __int8 *)v43))
            {
              atomic_store(3u, (unsigned __int8 *)v42[8]);
              atomic_store(1u, (unsigned __int8 *)(*(void *)(v42[8] + 8) + 32));
            }
            int8x8_t v48 = (int8x8_t)v41[7];
            uint64_t v50 = (void *)*v42;
            unint64_t v49 = v42[1];
            uint8x8_t v51 = (uint8x8_t)vcnt_s8(v48);
            v51.i16[0] = vaddlv_u8(v51);
            if (v51.u32[0] > 1uLL)
            {
              if (v49 >= *(void *)&v48) {
                v49 %= *(void *)&v48;
              }
            }
            else
            {
              v49 &= *(void *)&v48 - 1;
            }
            uint64_t v52 = v41[6];
            uint64_t v53 = *(void **)(v52 + 8 * v49);
            do
            {
              uint64_t v54 = v53;
              uint64_t v53 = (void *)*v53;
            }
            while (v53 != v42);
            if (v54 == v41 + 8) {
              goto LABEL_938;
            }
            unint64_t v55 = v54[1];
            if (v51.u32[0] > 1uLL)
            {
              if (v55 >= *(void *)&v48) {
                v55 %= *(void *)&v48;
              }
            }
            else
            {
              v55 &= *(void *)&v48 - 1;
            }
            CFArrayRef v56 = (void *)*v42;
            if (v55 != v49)
            {
LABEL_938:
              if (v50)
              {
                unint64_t v57 = v50[1];
                if (v51.u32[0] > 1uLL)
                {
                  unint64_t v58 = v50[1];
                  if (v57 >= *(void *)&v48) {
                    unint64_t v58 = v57 % *(void *)&v48;
                  }
                }
                else
                {
                  unint64_t v58 = v57 & (*(void *)&v48 - 1);
                }
                CFArrayRef v56 = (void *)*v42;
                if (v58 == v49) {
                  goto LABEL_87;
                }
              }
              *(void *)(v52 + 8 * v49) = 0;
              CFArrayRef v56 = (void *)*v42;
            }
            if (v56)
            {
              unint64_t v57 = v56[1];
LABEL_87:
              if (v51.u32[0] > 1uLL)
              {
                if (v57 >= *(void *)&v48) {
                  v57 %= *(void *)&v48;
                }
              }
              else
              {
                v57 &= *(void *)&v48 - 1;
              }
              if (v57 != v49)
              {
                *(void *)(v41[6] + 8 * v57) = v54;
                CFArrayRef v56 = (void *)*v42;
              }
            }
            void *v54 = v56;
            *unint64_t v42 = 0;
            --v41[9];
            CTFontDescriptorRef v59 = (std::__shared_weak_count *)v42[9];
            if (v59 && !atomic_fetch_add(&v59->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
              std::__shared_weak_count::__release_weak(v59);
            }
            operator delete(v42);
            unint64_t v42 = v50;
            if (!v50) {
              break;
            }
          }
          else
          {
            unint64_t v42 = (void *)*v42;
            if (!v42) {
              break;
            }
          }
        }
      }
      uint64_t v41 = (void *)*v41;
    }
    while (v41);
    int v60 = (int8x8_t *)v40[3];
    if (!v60)
    {
LABEL_172:
      v40[6] = 0;
      goto LABEL_173;
    }
    do
    {
      long long v61 = (int8x8_t *)v60[8];
      if (v61)
      {
        do
        {
          while (1)
          {
            uint64_t v62 = *(void *)(*(void *)&v61[8] + 8);
            if (v62)
            {
              unsigned __int8 v63 = atomic_load((unsigned __int8 *)(v62 + 32));
              if (v63)
              {
                unsigned __int8 v64 = atomic_load((unsigned __int8 *)(*(void *)(*(void *)&v61[8] + 8) + 33));
                if (v64) {
                  break;
                }
                int v65 = atomic_load(*(unsigned __int8 **)&v61[8]);
                if (v65 != 1) {
                  break;
                }
              }
            }
            long long v61 = (int8x8_t *)*v61;
            if (!v61) {
              goto LABEL_138;
            }
          }
          int8x8_t v66 = v60[7];
          unint64_t v67 = (unint64_t)v61[1];
          uint8x8_t v68 = (uint8x8_t)vcnt_s8(v66);
          v68.i16[0] = vaddlv_u8(v68);
          if (v68.u32[0] > 1uLL)
          {
            if (v67 >= *(void *)&v66) {
              v67 %= *(void *)&v66;
            }
          }
          else
          {
            v67 &= *(void *)&v66 - 1;
          }
          uint64_t v69 = (int8x8_t *)*v61;
          int8x8_t v70 = v60[6];
          size_t v71 = *(int8x8_t **)(*(void *)&v70 + 8 * v67);
          do
          {
            size_t v72 = v71;
            size_t v71 = (int8x8_t *)*v71;
          }
          while (v71 != v61);
          if (v72 == &v60[8]) {
            goto LABEL_939;
          }
          unint64_t v73 = (unint64_t)v72[1];
          if (v68.u32[0] > 1uLL)
          {
            if (v73 >= *(void *)&v66) {
              v73 %= *(void *)&v66;
            }
          }
          else
          {
            v73 &= *(void *)&v66 - 1;
          }
          unint64_t v74 = (int8x8_t *)*v61;
          if (v73 != v67)
          {
LABEL_939:
            if (v69)
            {
              unint64_t v75 = (unint64_t)v69[1];
              if (v68.u32[0] > 1uLL)
              {
                unint64_t v76 = (unint64_t)v69[1];
                if (v75 >= *(void *)&v66) {
                  unint64_t v76 = v75 % *(void *)&v66;
                }
              }
              else
              {
                unint64_t v76 = v75 & (*(void *)&v66 - 1);
              }
              unint64_t v74 = (int8x8_t *)*v61;
              if (v76 == v67) {
                goto LABEL_128;
              }
            }
            *(void *)(*(void *)&v70 + 8 * v67) = 0;
            unint64_t v74 = (int8x8_t *)*v61;
          }
          if (v74)
          {
            unint64_t v75 = (unint64_t)v74[1];
LABEL_128:
            if (v68.u32[0] > 1uLL)
            {
              if (v75 >= *(void *)&v66) {
                v75 %= *(void *)&v66;
              }
            }
            else
            {
              v75 &= *(void *)&v66 - 1;
            }
            if (v75 != v67)
            {
              *(void *)(*(void *)&v60[6] + 8 * v75) = v72;
              unint64_t v74 = (int8x8_t *)*v61;
            }
          }
          *size_t v72 = (int8x8_t)v74;
          int8x8_t *v61 = 0;
          --*(void *)&v60[9];
          uint64_t v77 = (std::__shared_weak_count *)v61[9];
          if (v77 && !atomic_fetch_add(&v77->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
            std::__shared_weak_count::__release_weak(v77);
          }
          operator delete(v61);
          long long v61 = v69;
        }
        while (v69);
      }
LABEL_138:
      uint64_t v78 = (int8x8_t *)*v60;
      if (v60[9]) {
        goto LABEL_99;
      }
      int8x8_t v79 = v40[2];
      unint64_t v80 = (unint64_t)v60[1];
      uint8x8_t v81 = (uint8x8_t)vcnt_s8(v79);
      v81.i16[0] = vaddlv_u8(v81);
      if (v81.u32[0] > 1uLL)
      {
        if (v80 >= *(void *)&v79) {
          v80 %= *(void *)&v79;
        }
      }
      else
      {
        v80 &= *(void *)&v79 - 1;
      }
      int8x8_t v82 = v40[1];
      CFComparisonResult v83 = *(int8x8_t **)(*(void *)&v82 + 8 * v80);
      do
      {
        CFComparisonResult v84 = v83;
        CFComparisonResult v83 = (int8x8_t *)*v83;
      }
      while (v83 != v60);
      if (v84 == &v40[3]) {
        goto LABEL_940;
      }
      unint64_t v85 = (unint64_t)v84[1];
      if (v81.u32[0] > 1uLL)
      {
        if (v85 >= *(void *)&v79) {
          v85 %= *(void *)&v79;
        }
      }
      else
      {
        v85 &= *(void *)&v79 - 1;
      }
      uint64_t v86 = (void *)*v60;
      if (v85 != v80)
      {
LABEL_940:
        if (v78)
        {
          unint64_t v87 = (unint64_t)v78[1];
          if (v81.u32[0] > 1uLL)
          {
            if (v87 >= *(void *)&v79) {
              v87 %= *(void *)&v79;
            }
          }
          else
          {
            v87 &= *(void *)&v79 - 1;
          }
          uint64_t v86 = (void *)*v60;
          if (v87 == v80)
          {
LABEL_159:
            unint64_t v88 = v86[1];
            if (v81.u32[0] > 1uLL)
            {
              if (v88 >= *(void *)&v79) {
                v88 %= *(void *)&v79;
              }
            }
            else
            {
              v88 &= *(void *)&v79 - 1;
            }
            if (v88 != v80)
            {
              *(void *)(*(void *)&v40[1] + 8 * v88) = v84;
              uint64_t v86 = (void *)*v60;
            }
            goto LABEL_165;
          }
        }
        *(void *)(*(void *)&v82 + 8 * v80) = 0;
        uint64_t v86 = (void *)*v60;
      }
      if (v86) {
        goto LABEL_159;
      }
LABEL_165:
      int8x8_t *v84 = (int8x8_t)v86;
      int8x8_t *v60 = 0;
      --*(void *)&v40[4];
      uint64_t v89 = (void *)v60[8];
      while (v89)
      {
        unint64_t v91 = v89;
        uint64_t v89 = (void *)*v89;
        char v92 = (std::__shared_weak_count *)v91[9];
        if (v92 && !atomic_fetch_add(&v92->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
          std::__shared_weak_count::__release_weak(v92);
        }
        operator delete(v91);
      }
      uint64_t v90 = (void *)v60[6];
      v60[6] = 0;
      if (v90) {
        operator delete(v90);
      }
      operator delete(v60);
LABEL_99:
      int v60 = v78;
    }
    while (v78);
    unint64_t v229 = (void *)v40[3];
    for (v40[6] = 0; v229; unint64_t v229 = (void *)*v229)
    {
      for (unint64_t i = (void *)v229[8]; i; unint64_t i = (void *)*i)
      {
        uint64_t v231 = *(void *)(i[8] + 8);
        if (v231)
        {
          unsigned __int8 v232 = atomic_load((unsigned __int8 *)(v231 + 33));
          uint64_t v233 = i[8];
          if (v232)
          {
            int v234 = atomic_load((unsigned __int8 *)v233);
            uint64_t v233 = i[8];
            if (v234 == 2)
            {
              uint64_t v235 = *(void *)(v233 + 112);
              uint64_t v236 = *(void *)(v233 + 120);
              if (v235 != v236)
              {
                __int32 v237 = v40[6].i32[0];
                do
                {
                  uint64_t v238 = *(void *)(v235 + 64);
                  if (v238) {
                    uint64_t v238 = (*(void *)(**(void **)(v238 + 64) + 48) - *(void *)(**(void **)(v238 + 64) + 40))
                  }
                         / *(void *)(**(void **)(v238 + 64) + 8);
                  LODWORD(v239) = *(unsigned __int8 *)(v235 + 24);
                  if (*(unsigned char *)(v235 + 24)) {
                    uint64_t v239 = (*(void *)(**(void **)(*(void *)v235 + 64) + 48)
                  }
                          - *(void *)(**(void **)(*(void *)v235 + 64) + 40))
                         / *(void *)(**(void **)(*(void *)v235 + 64) + 8);
                  LODWORD(v240) = *(unsigned __int8 *)(v235 + 56);
                  if (*(unsigned char *)(v235 + 56))
                  {
                    unint64_t v241 = **(void ***)(*(void *)(v235 + 32) + 64);
                    uint64_t v240 = (v241[6] - v241[5]) / v241[1];
                  }
                  v237 += v239 + v238 + v240;
                  v235 += 80;
                }
                while (v235 != v236);
                v40[6].i32[0] = v237;
              }
            }
          }
          unsigned __int8 v242 = atomic_load((unsigned __int8 *)(*(void *)(v233 + 8) + 33));
          if ((v242 & 1) == 0) {
            ++v40[6].i32[1];
          }
        }
      }
    }
LABEL_173:
    int v93 = (unsigned __int16 *)v568[27];
    uint64_t v556 = (char **)(v568 + 27);
    uint64_t v558 = (unsigned __int16 *)v568[28];
    if (v93 != v558)
    {
      unint64_t v94 = v572 + 1;
      while (1)
      {
        float32x2_t v560 = v93;
        int v566 = *v93;
        uint64_t v95 = *v559;
        {
          qword_1EB3176C0 = 0;
          qword_1EB3176B8 = 0;
          md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet = (uint64_t)&qword_1EB3176B8;
          __cxa_atexit((void (*)(void *))std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100], &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet, &dword_1A1780000);
        }
        CFTypeRef v96 = *(unsigned __int16 **)(v95 + 48);
        unint64_t v97 = *(unsigned __int16 **)(v95 + 56);
        if (v96 == v97) {
          goto LABEL_187;
        }
        char v98 = *(unsigned __int16 **)(v95 + 48);
        while (*v98 != v566)
        {
          v98 += 16;
          if (v98 == v97) {
            goto LABEL_187;
          }
        }
        if (v98 == v97)
        {
LABEL_187:
          uint64_t v99 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
        }
        else
        {
          while (*v96 != v566)
          {
            v96 += 16;
            if (v96 == v97)
            {
              CFTypeRef v96 = *(unsigned __int16 **)(v95 + 56);
              break;
            }
          }
          uint64_t v99 = (uint64_t *)(v96 + 4);
        }
        CFTypeRef v102 = (uint64_t *)*v99;
        float v100 = v99 + 1;
        unint64_t v101 = v102;
        if (v102 != v100) {
          break;
        }
LABEL_175:
        int v93 = v560 + 1;
        if (v560 + 1 == v558) {
          goto LABEL_320;
        }
      }
      uint64_t v561 = v100;
LABEL_191:
      uint64_t v103 = v101[4];
      uint64_t v104 = (std::__shared_weak_count *)v101[5];
      uint64_t v592 = v103;
      uint64_t v593 = v104;
      if (v104) {
        atomic_fetch_add_explicit(&v104->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unint64_t v106 = (unsigned __int8 *)v568[23];
      uint64_t v105 = (unsigned __int8 *)v568[24];
      if (v106 == v105) {
        goto LABEL_309;
      }
      unsigned int v562 = v101;
      uint64_t v107 = 0;
      uint64_t v108 = 0;
      long long v575 = (unsigned __int8 *)v568[24];
      long long __p = 0;
      unint64_t v109 = 0;
      unsigned int v110 = *(unsigned __int8 *)(v103 + 169);
      int v583 = *(_DWORD *)(v103 + 172);
      int v582 = *(_DWORD *)(v103 + 176);
      int v584 = *(unsigned __int8 *)(v103 + 168);
      unsigned int v569 = v110;
      while (1)
      {
        if (*v106 != v584) {
          goto LABEL_196;
        }
        unsigned int v111 = v106[1];
        int v113 = *((_DWORD *)v106 + 1);
        int v112 = *((_DWORD *)v106 + 2);
        uint64_t v114 = *((void *)v106 + 3);
        char v115 = v111 - v110;
        if (v111 >= v110)
        {
          if (v111 != v110 || v113 != v583 || v112 != v582)
          {
LABEL_212:
            if (v110 >= v111)
            {
              if (v110 != v111 || v583 != v113 || v582 != v112) {
                goto LABEL_196;
              }
            }
            else
            {
              int v119 = v112 >> v115;
              if (v583 != v113 >> v115 || v582 != v119) {
                goto LABEL_196;
              }
            }
          }
        }
        else if (v113 != v583 >> (v110 - v111) || v112 != v582 >> (v110 - v111))
        {
          goto LABEL_212;
        }
        if (v109 >= v107)
        {
          uint64_t v121 = (v109 - __p) >> 3;
          unint64_t v122 = v121 + 1;
          if ((unint64_t)(v121 + 1) >> 61) {
            abort();
          }
          if ((v107 - __p) >> 2 > v122) {
            unint64_t v122 = (v107 - __p) >> 2;
          }
          if ((unint64_t)(v107 - __p) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v123 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v123 = v122;
          }
          if (v123)
          {
            if (v123 >> 61) {
LABEL_932:
            }
              std::__throw_bad_array_new_length[abi:nn180100]();
            unint64_t v124 = operator new(8 * v123);
          }
          else
          {
            unint64_t v124 = 0;
          }
          unint64_t v125 = &v124[8 * v121];
          *(void *)unint64_t v125 = v114;
          uint64_t v126 = v125 + 8;
          unint64_t v127 = __p;
          if (v109 != __p)
          {
            unint64_t v128 = v109 - 8 - __p;
            if (v128 < 0x168
              || &v124[v109 - __p - 8 - (v128 & 0xFFFFFFFFFFFFFFF8)] > &v124[v109 - __p - 8]
              || &v109[-(v128 & 0xFFFFFFFFFFFFFFF8) - 8] > v109 - 8
              || (unint64_t)(__p - v124) < 0x20)
            {
              long long v129 = v109;
              unint64_t v127 = __p;
              uint64_t v108 = v125 + 8;
            }
            else
            {
              uint64_t v131 = (v128 >> 3) + 1;
              long long v129 = &v109[-8 * (v131 & 0x3FFFFFFFFFFFFFFCLL)];
              float v132 = &v124[8 * v121 - 16];
              uint64_t v133 = v109 - 16;
              uint64_t v134 = v131 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v135 = *(_OWORD *)v133;
                *(v132 - 1) = *((_OWORD *)v133 - 1);
                *float v132 = v135;
                v132 -= 2;
                v133 -= 32;
                v134 -= 4;
              }
              while (v134);
              v125 -= 8 * (v131 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v127 = __p;
              uint64_t v108 = v126;
              if (v131 == (v131 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_237:
                uint64_t v107 = &v124[8 * v123];
                if (v127) {
                  goto LABEL_238;
                }
                goto LABEL_239;
              }
            }
            do
            {
              uint64_t v130 = *((void *)v129 - 1);
              v129 -= 8;
              *((void *)v125 - 1) = v130;
              v125 -= 8;
            }
            while (v129 != v127);
            goto LABEL_237;
          }
          uint64_t v108 = v125 + 8;
          uint64_t v107 = &v124[8 * v123];
          if (__p) {
LABEL_238:
          }
            operator delete(v127);
LABEL_239:
          long long __p = v125;
          unint64_t v109 = v108;
          unsigned int v110 = v569;
          uint64_t v105 = v575;
          goto LABEL_196;
        }
        *(void *)unint64_t v109 = v114;
        v109 += 8;
        uint64_t v108 = v109;
LABEL_196:
        v106 += 32;
        if (v106 == v105)
        {
          float v136 = (int8x8_t **)__p;
          if (__p == v108) {
            goto LABEL_307;
          }
          int64_t v576 = v108;
          while (2)
          {
            uint64_t v137 = *v136;
            unint64_t v138 = (unint64_t)(*v136)[1];
            if ((v138 & (v138 - 1)) != 0)
            {
              unint64_t v140 = 0x64A448A5CD5D38DBLL;
              if (v138 <= 0x64A448A5CD5D38DBLL) {
                unint64_t v140 = 0x64A448A5CD5D38DBLL % v138;
              }
              uint64_t v139 = *(void **)(*(void *)v137 + 8 * v140);
              do
              {
                do
                  uint64_t v139 = (void *)*v139;
                while (v139[1] != 0x64A448A5CD5D38DBLL);
              }
              while (v139[2] != 0x64A448A5CD5D38DBLL);
            }
            else
            {
              uint64_t v139 = *(void **)(*(void *)v137 + 8 * ((v138 - 1) & 0x64A448A5CD5D38DBLL));
              do
              {
                do
                  uint64_t v139 = (void *)*v139;
                while (v139[1] != 0x64A448A5CD5D38DBLL);
              }
              while (v139[2] != 0x64A448A5CD5D38DBLL);
            }
            int v141 = *(unsigned __int8 **)(v139[5] + 32);
            int v142 = v141[1];
            int v143 = *((_DWORD *)v141 + 1);
            int v144 = *((_DWORD *)v141 + 2);
            int v145 = *v141;
            unint64_t v585 = 0;
            uint64_t v586 = 0;
            uint64_t v146 = (void *)*v572;
            if ((uint64_t *)*v572 == v94)
            {
LABEL_298:
              if (GEOGetVectorKitDrapingLogicLog(void)::onceToken != -1) {
                dispatch_once(&GEOGetVectorKitDrapingLogicLog(void)::onceToken, &__block_literal_global_0);
              }
              uint64_t v158 = (int8x8_t **)v576;
              unint64_t v160 = (id)GEOGetVectorKitDrapingLogicLog(void)::log;
              if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 136315650;
                *(void *)&uint8_t buf[4] = "false";
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/Overlays/DrapingLogic.mm";
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&unsigned char buf[24] = 374;
                _os_log_impl(&dword_1A1780000, v160, OS_LOG_TYPE_ERROR, "No backing data for foundation mesh. Check DaVinciGroundTileData.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
              }

              goto LABEL_303;
            }
            while (2)
            {
              uint64_t v147 = v146[4];
              float v148 = (std::__shared_weak_count *)v146[5];
              if (v148) {
                atomic_fetch_add_explicit(&v148->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              if (*(unsigned __int8 *)(v147 + 168) != v145
                || *(unsigned __int8 *)(v147 + 169) != v142
                || *(_DWORD *)(v147 + 172) != v143
                || *(_DWORD *)(v147 + 176) != v144)
              {
                if (v148 && !atomic_fetch_add(&v148->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v148->__on_zero_shared)(v148);
                  std::__shared_weak_count::__release_weak(v148);
                  long double v152 = (uint64_t *)v146[1];
                  if (v152) {
                    goto LABEL_280;
                  }
                }
                else
                {
                  long double v152 = (uint64_t *)v146[1];
                  if (v152)
                  {
                    do
                    {
LABEL_280:
                      double v153 = v152;
                      long double v152 = (uint64_t *)*v152;
                    }
                    while (v152);
                    goto LABEL_264;
                  }
                }
                do
                {
                  double v153 = (uint64_t *)v146[2];
                  BOOL v10 = *v153 == (void)v146;
                  uint64_t v146 = v153;
                }
                while (!v10);
LABEL_264:
                uint64_t v146 = v153;
                if (v153 == v94) {
                  goto LABEL_294;
                }
                continue;
              }
              break;
            }
            if (v148) {
              atomic_fetch_add_explicit(&v148->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            unint64_t v154 = (std::__shared_weak_count *)v586;
            unint64_t v585 = (atomic_ullong *)v147;
            uint64_t v586 = (atomic_ullong *)v148;
            if (v154 && !atomic_fetch_add(&v154->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v154->__on_zero_shared)(v154);
              std::__shared_weak_count::__release_weak(v154);
              if (v148) {
                goto LABEL_291;
              }
            }
            else if (v148)
            {
LABEL_291:
              if (!atomic_fetch_add(&v148->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v148->__on_zero_shared)(v148);
                std::__shared_weak_count::__release_weak(v148);
              }
            }
LABEL_294:
            if (!v585) {
              goto LABEL_298;
            }
            int v155 = *((_DWORD *)v585 + 2);
            LOBYTE(v596) = v145;
            BYTE1(v596) = v142;
            HIDWORD(v596) = v143;
            LODWORD(v597) = v144;
            int v599 = v155;
            uint64_t v156 = v592;
            int v157 = *(_DWORD *)(v592 + 8);
            buf[0] = v584;
            buf[1] = v569;
            *(_DWORD *)&uint8_t buf[4] = v583;
            *(_DWORD *)&uint8_t buf[8] = v582;
            *(_WORD *)&unsigned char buf[24] = v566;
            *(_DWORD *)&buf[28] = v157;
            long long v604 = 0uLL;
            md::DrapingLogic::_drapeKeyPair(a1, (unsigned __int8 *)&v596, buf, (atomic_ullong *)&v585, &v592, (uint64_t)v568, v564, a2, v137);
            uint64_t v158 = (int8x8_t **)v576;
            if (*(unsigned char *)(a1 + 224)
              && md::ElevatedStrokeTileData::groupContainingFeature(*(int8x8_t **)(v156 + 752), *(int8x8_t **)(v156 + 760), *(void *)(a1 + 216)))
            {
              int v159 = *(_DWORD *)(v156 + 8);
              LOBYTE(v617) = v584;
              BYTE1(v617) = v569;
              *(void *)((char *)&v617 + 4) = __PAIR64__(v582, v583);
              WORD4(v618) = v566;
              HIDWORD(v618) = v159;
              long long v619 = *(_OWORD *)(a1 + 216);
              md::DrapingLogic::_drapeKeyPair(a1, (unsigned __int8 *)&v596, (unsigned __int8 *)&v617, (atomic_ullong *)&v585, &v592, (uint64_t)v568, v564, a2, v137);
            }
LABEL_303:
            float v161 = (std::__shared_weak_count *)v586;
            if (v586 && !atomic_fetch_add(v586 + 1, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v161->__on_zero_shared)(v161);
              std::__shared_weak_count::__release_weak(v161);
            }
            if (++v136 != v158) {
              continue;
            }
            break;
          }
          uint64_t v108 = __p;
LABEL_307:
          float v100 = v561;
          unint64_t v101 = v562;
          if (v108) {
            operator delete(v108);
          }
LABEL_309:
          uint64_t v162 = v593;
          if (v593 && !atomic_fetch_add(&v593->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v162->__on_zero_shared)(v162);
            std::__shared_weak_count::__release_weak(v162);
            uint64_t v163 = (uint64_t *)v101[1];
            if (v163) {
              goto LABEL_312;
            }
          }
          else
          {
            uint64_t v163 = (uint64_t *)v101[1];
            if (v163)
            {
              do
              {
LABEL_312:
                uint64_t v164 = v163;
                uint64_t v163 = (uint64_t *)*v163;
              }
              while (v163);
              goto LABEL_190;
            }
          }
          do
          {
            uint64_t v164 = (uint64_t *)v101[2];
            BOOL v10 = *v164 == (void)v101;
            unint64_t v101 = v164;
          }
          while (!v10);
LABEL_190:
          unint64_t v101 = v164;
          if (v164 == v100) {
            goto LABEL_175;
          }
          goto LABEL_191;
        }
      }
    }
LABEL_320:
    uint64_t v165 = *(void *)(a1 + 168);
    if (*(unsigned char *)(a1 + 400))
    {
      long long v617 = 0u;
      long long v618 = 0u;
      LODWORD(v619) = 1065353216;
      uint64_t v166 = *(void **)(v165 + 24);
      if (!v166)
      {
LABEL_491:
        uint64_t v243 = (unsigned char *)v618;
        if ((void)v618)
        {
          do
          {
            if (v243[224]) {
              v243[224] = 0;
            }
            uint64_t v248 = *(unsigned char **)v243;
            uint64_t v249 = (void *)*((void *)v243 + 18);
            if (v249 != *((void **)v243 + 20)) {
              free(v249);
            }
            if (v243[112]) {
              v243[112] = 0;
            }
            unint64_t v250 = (void *)*((void *)v243 + 4);
            if (v250 != *((void **)v243 + 6)) {
              free(v250);
            }
            operator delete(v243);
            uint64_t v243 = v248;
          }
          while (v248);
        }
        uint64_t v244 = (void *)v617;
        *(void *)&long long v617 = 0;
        if (v244) {
          operator delete(v244);
        }
        uint64_t v165 = *(void *)(a1 + 168);
        goto LABEL_495;
      }
      while (1)
      {
        uint64_t v167 = (uint64_t **)v166[8];
        if (v167) {
          break;
        }
LABEL_323:
        uint64_t v166 = (void *)*v166;
        if (!v166)
        {
          if (*((void *)&v618 + 1)) {
            md::DrapingLogic::_fixUpHoles(a1, (void *)v618, v559, v556);
          }
          goto LABEL_491;
        }
      }
      while (1)
      {
        int v168 = atomic_load((unsigned __int8 *)v167[8]);
        if (v168 == 2) {
          goto LABEL_326;
        }
        int v169 = atomic_load((unsigned __int8 *)v167[8]);
        if (v169 == 3) {
          goto LABEL_326;
        }
        float v170 = v167[8];
        if (!(*((_DWORD *)v170 + 15) * *((_DWORD *)v170 + 14))) {
          goto LABEL_326;
        }
        uint64_t v592 = 0;
        uint64_t v593 = 0;
        unint64_t v171 = (std::__shared_weak_count *)v170[4];
        if (v171 && (uint64_t v593 = std::__shared_weak_count::lock(v171)) != 0)
        {
          uint64_t v172 = v170[3];
          uint64_t v592 = v172;
        }
        else
        {
          uint64_t v172 = 0;
        }
        BOOL v173 = v167[8];
        uint64_t v174 = (std::__shared_weak_count *)v173[6];
        if (!v174 || (uint64_t v175 = std::__shared_weak_count::lock(v174), (v586 = (atomic_ullong *)v175) == 0))
        {
LABEL_454:
          uint64_t v225 = v593;
          if (v593) {
            goto LABEL_455;
          }
          goto LABEL_326;
        }
        uint64_t v176 = v175;
        uint64_t v177 = v173[5];
        unint64_t v585 = (atomic_ullong *)v177;
        if (v172)
        {
          if (v177) {
            break;
          }
        }
LABEL_453:
        if (atomic_fetch_add(&v176->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
          goto LABEL_454;
        }
        ((void (*)(std::__shared_weak_count *))v176->__on_zero_shared)(v176);
        std::__shared_weak_count::__release_weak(v176);
        uint64_t v225 = v593;
        if (v593)
        {
LABEL_455:
          if (!atomic_fetch_add(&v225->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v225->__on_zero_shared)(v225);
            std::__shared_weak_count::__release_weak(v225);
          }
        }
LABEL_326:
        uint64_t v167 = (uint64_t **)*v167;
        if (!v167) {
          goto LABEL_323;
        }
      }
      buf[0] = *(unsigned char *)(v172 + 16);
      gdc::LayerDataKey::LayerDataKey((uint64_t)&buf[8], v172 + 24);
      v607[16] = 0;
      if (*(unsigned char *)(v172 + 112))
      {
        *(_DWORD *)&v607[20] = *(_DWORD *)(v172 + 116);
        v607[16] = 1;
      }
      *(void *)&v607[24] = *(void *)(v172 + 120);
      unsigned __int8 v608 = *(unsigned char *)(v177 + 16);
      gdc::LayerDataKey::LayerDataKey((uint64_t)&v609, v177 + 24);
      unsigned __int8 v614 = 0;
      if (*(unsigned char *)(v177 + 112))
      {
        int v615 = *(_DWORD *)(v177 + 116);
        int v178 = 1;
        unsigned __int8 v614 = 1;
      }
      else
      {
        int v178 = 0;
      }
      unint64_t v616 = *(void *)(v177 + 120);
      unint64_t v179 = (*(void *)&v607[24] + (v616 << 6) + (v616 >> 2) - 0x61C8864680B583EBLL) ^ v616;
      unint64_t v180 = *((void *)&v617 + 1);
      if (*((void *)&v617 + 1))
      {
        uint8x8_t v181 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v617 + 8));
        v181.i16[0] = vaddlv_u8(v181);
        if (v181.u32[0] > 1uLL)
        {
          uint64_t v177 = (*(void *)&v607[24] + (v616 << 6) + (v616 >> 2) - 0x61C8864680B583EBLL) ^ v616;
          if (v179 >= *((void *)&v617 + 1)) {
            uint64_t v177 = v179 % *((void *)&v617 + 1);
          }
        }
        else
        {
          uint64_t v177 = v179 & (*((void *)&v617 + 1) - 1);
        }
        unint64_t v182 = *(uint64_t ****)(v617 + 8 * v177);
        if (v182)
        {
          int64_t v183 = *v182;
          if (*v182)
          {
            int v184 = buf[0];
            int v185 = *(unsigned __int16 *)&buf[8];
            uint64_t v186 = *(uint64_t **)v607;
            uint64_t v187 = *(void **)&buf[16];
            size_t v188 = *(void *)&buf[24] - *(void *)&buf[16];
            int v570 = v608;
            LODWORD(v568) = v609;
            unint64_t v567 = v613;
            __s2 = v610;
            a2 = (const md::LayoutContext *)(v611 - (void)v610);
            if (v181.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v195 = v183[1];
                if (v195 == (uint64_t *)v179)
                {
                  if (*((unsigned __int8 *)v183 + 16) == v184
                    && *((unsigned __int16 *)v183 + 12) == v185
                    && v183[12] == v186)
                  {
                    uint64_t v196 = v183[4];
                    if ((char *)v183[5] - (char *)v196 == v188)
                    {
                      __pb = v187;
                      uint64_t v564 = v188;
                      int v578 = v185;
                      float32x2_t v574 = v186;
                      int v197 = memcmp(v196, v187, v188);
                      size_t v188 = v564;
                      uint64_t v187 = __pb;
                      uint64_t v186 = v574;
                      int v185 = v578;
                      if (!v197
                        && *((unsigned __int8 *)v183 + 128) == v570
                        && *((unsigned __int16 *)v183 + 68) == v568
                        && v183[26] == v567)
                      {
                        uint64_t v198 = v183[18];
                        if ((const md::LayoutContext *)((char *)v183[19] - (char *)v198) == a2)
                        {
                          int v199 = memcmp(v198, __s2, (size_t)a2);
                          size_t v188 = v564;
                          uint64_t v187 = __pb;
                          uint64_t v186 = v574;
                          int v185 = v578;
                          if (!v199) {
                            goto LABEL_445;
                          }
                        }
                      }
                    }
                  }
                }
                else if (((unint64_t)v195 & (v180 - 1)) != v177)
                {
                  goto LABEL_382;
                }
                int64_t v183 = (uint64_t **)*v183;
                if (!v183) {
                  goto LABEL_382;
                }
              }
            }
            do
            {
              unint64_t v189 = (unint64_t)v183[1];
              if (v189 == v179)
              {
                if (*((unsigned __int8 *)v183 + 16) == v184
                  && *((unsigned __int16 *)v183 + 12) == v185
                  && v183[12] == v186)
                {
                  float v190 = v183[4];
                  if ((char *)v183[5] - (char *)v190 == v188)
                  {
                    __pa = v187;
                    size_t v191 = v188;
                    int v577 = v185;
                    unint64_t v573 = v186;
                    int v192 = memcmp(v190, v187, v188);
                    size_t v188 = v191;
                    uint64_t v187 = __pa;
                    uint64_t v186 = v573;
                    int v185 = v577;
                    if (!v192
                      && *((unsigned __int8 *)v183 + 128) == v570
                      && *((unsigned __int16 *)v183 + 68) == v568
                      && v183[26] == v567)
                    {
                      uint64_t v193 = v183[18];
                      if ((const md::LayoutContext *)((char *)v183[19] - (char *)v193) == a2)
                      {
                        int v194 = memcmp(v193, __s2, (size_t)a2);
                        size_t v188 = v191;
                        uint64_t v187 = __pa;
                        uint64_t v186 = v573;
                        int v185 = v577;
                        if (!v194) {
                          goto LABEL_445;
                        }
                      }
                    }
                  }
                }
              }
              else
              {
                if (v189 >= v180) {
                  v189 %= v180;
                }
                if (v189 != v177) {
                  break;
                }
              }
              int64_t v183 = (uint64_t **)*v183;
            }
            while (v183);
          }
        }
      }
LABEL_382:
      unint64_t v200 = operator new(0xF0uLL);
      int v596 = v200;
      int v597 = (gdc::Registry **)&v618;
      LOBYTE(v598) = 0;
      *unint64_t v200 = 0;
      v200[1] = v179;
      *((unsigned char *)v200 + 16) = buf[0];
      gdc::LayerDataKey::LayerDataKey((uint64_t)(v200 + 3), (uint64_t)&buf[8]);
      *((unsigned char *)v200 + 112) = 0;
      if (v607[16])
      {
        *((_DWORD *)v200 + 29) = *(_DWORD *)&v607[20];
        *((unsigned char *)v200 + 112) = 1;
      }
      v200[15] = *(void *)&v607[24];
      *((unsigned char *)v200 + 128) = v608;
      gdc::LayerDataKey::LayerDataKey((uint64_t)(v200 + 17), (uint64_t)&v609);
      *((unsigned char *)v200 + 224) = 0;
      if (v614)
      {
        *((_DWORD *)v200 + 57) = v615;
        *((unsigned char *)v200 + 224) = 1;
      }
      v200[29] = v616;
      LOBYTE(v598) = 1;
      float v201 = (float)(unint64_t)(*((void *)&v618 + 1) + 1);
      if (v180 && (float)(*(float *)&v619 * (float)v180) >= v201)
      {
LABEL_435:
        unint64_t v222 = *(void **)(v617 + 8 * v177);
        uint64_t v223 = v596;
        if (v222)
        {
          void *v596 = *v222;
        }
        else
        {
          void *v596 = v618;
          *(void *)&long long v618 = v223;
          *(void *)(v617 + 8 * v177) = &v618;
          if (!*v223) {
            goto LABEL_444;
          }
          unint64_t v224 = *(void *)(*v223 + 8);
          if ((v180 & (v180 - 1)) != 0)
          {
            if (v224 >= v180) {
              v224 %= v180;
            }
          }
          else
          {
            v224 &= v180 - 1;
          }
          unint64_t v222 = (void *)(v617 + 8 * v224);
        }
        *unint64_t v222 = v223;
LABEL_444:
        ++*((void *)&v618 + 1);
        int v178 = v614;
LABEL_445:
        if (v178) {
          unsigned __int8 v614 = 0;
        }
        if (v610 != v612) {
          free(v610);
        }
        if (v607[16]) {
          v607[16] = 0;
        }
        if (*(void *)&buf[16] != (void)v604) {
          free(*(void **)&buf[16]);
        }
        goto LABEL_453;
      }
      BOOL v202 = (v180 & (v180 - 1)) != 0;
      if (v180 < 3) {
        BOOL v202 = 1;
      }
      unint64_t v203 = v202 | (2 * v180);
      unint64_t v204 = vcvtps_u32_f32(v201 / *(float *)&v619);
      if (v203 <= v204) {
        size_t prime = v204;
      }
      else {
        size_t prime = v203;
      }
      if (prime == 1)
      {
        size_t prime = 2;
      }
      else if ((prime & (prime - 1)) != 0)
      {
        size_t prime = std::__next_prime(prime);
      }
      unint64_t v180 = *((void *)&v617 + 1);
      if (prime <= *((void *)&v617 + 1))
      {
        if (prime >= *((void *)&v617 + 1)) {
          goto LABEL_422;
        }
        unint64_t v216 = vcvtps_u32_f32((float)*((unint64_t *)&v618 + 1) / *(float *)&v619);
        if (*((void *)&v617 + 1) < 3uLL
          || (uint8x8_t v217 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v617 + 8)),
              v217.i16[0] = vaddlv_u8(v217),
              v217.u32[0] > 1uLL))
        {
          unint64_t v216 = std::__next_prime(v216);
        }
        else
        {
          uint64_t v218 = 1 << -(char)__clz(v216 - 1);
          if (v216 >= 2) {
            unint64_t v216 = v218;
          }
        }
        if (prime <= v216) {
          size_t prime = v216;
        }
        if (prime >= v180)
        {
          unint64_t v180 = *((void *)&v617 + 1);
LABEL_422:
          if ((v180 & (v180 - 1)) != 0)
          {
            if (v179 >= v180) {
              uint64_t v177 = v179 % v180;
            }
            else {
              uint64_t v177 = v179;
            }
          }
          else
          {
            uint64_t v177 = (v180 - 1) & v179;
          }
          goto LABEL_435;
        }
        if (!prime)
        {
          uint64_t v226 = (void *)v617;
          *(void *)&long long v617 = 0;
          if (v226) {
            operator delete(v226);
          }
          unint64_t v180 = 0;
          *((void *)&v617 + 1) = 0;
          goto LABEL_422;
        }
      }
      if (prime >> 61) {
        goto LABEL_932;
      }
      double v206 = operator new(8 * prime);
      uint64_t v207 = (void *)v617;
      *(void *)&long long v617 = v206;
      if (v207) {
        operator delete(v207);
      }
      uint64_t v208 = 0;
      *((void *)&v617 + 1) = prime;
      do
        *(void *)(v617 + 8 * v208++) = 0;
      while (prime != v208);
      uint64_t v209 = (void **)v618;
      if (!(void)v618)
      {
LABEL_421:
        unint64_t v180 = prime;
        goto LABEL_422;
      }
      size_t v210 = *(void *)(v618 + 8);
      size_t v211 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        size_t v212 = v210 & v211;
        *(void *)(v617 + 8 * v212) = &v618;
        while (1)
        {
          long long v213 = *v209;
          if (!*v209) {
            break;
          }
          size_t v214 = v213[1] & v211;
          if (v214 == v212)
          {
            uint64_t v209 = (void **)*v209;
          }
          else if (*(void *)(v617 + 8 * v214))
          {
            *uint64_t v209 = (void *)*v213;
            uint64_t v215 = 8 * v214;
            *long long v213 = **(void **)(v617 + v215);
            **(void **)(v617 + v215) = v213;
          }
          else
          {
            *(void *)(v617 + 8 * v214) = v209;
            uint64_t v209 = (void **)v213;
            size_t v212 = v214;
          }
        }
        goto LABEL_421;
      }
      if (v210 >= prime) {
        v210 %= prime;
      }
      *(void *)(v617 + 8 * v210) = &v618;
      int8x8_t v219 = *v209;
      if (!*v209) {
        goto LABEL_421;
      }
      while (1)
      {
        size_t v221 = v219[1];
        if (v221 >= prime) {
          v221 %= prime;
        }
        if (v221 != v210)
        {
          if (!*(void *)(v617 + 8 * v221))
          {
            *(void *)(v617 + 8 * v221) = v209;
            goto LABEL_426;
          }
          *uint64_t v209 = (void *)*v219;
          uint64_t v220 = 8 * v221;
          *int8x8_t v219 = **(void **)(v617 + v220);
          **(void **)(v617 + v220) = v219;
          int8x8_t v219 = v209;
        }
        size_t v221 = v210;
LABEL_426:
        uint64_t v209 = (void **)v219;
        int8x8_t v219 = (void *)*v219;
        size_t v210 = v221;
        if (!v219) {
          goto LABEL_421;
        }
      }
    }
LABEL_495:
    *(void *)(a4 + 16) = v165 + 8;
    uint64_t v245 = +[VKDebugSettings sharedSettings];
    int v246 = [v245 daVinciDrawCollisionMesh];

    if (!v246) {
      goto LABEL_579;
    }
    uint64_t v247 = *(void *)(a1 + 120);
    v601[0] = &unk_1EF56DD88;
    unint64_t v602 = v601;
    md::RegistryManager::entering(&v617, v247, v601);
    if (v602 == v601)
    {
      (*(void (**)(void *))(v601[0] + 32))(v601);
    }
    else if (v602)
    {
      (*(void (**)(void))(*v602 + 40))();
    }
    md::FilteredIterator<std::vector<gdc::Registry *>>::begin(&v596, (uint64_t)&v617);
    md::FilteredIterator<std::vector<gdc::Registry *>>::end(&v592, (uint64_t *)&v617);
    int v263 = v597;
    if (v593 == (std::__shared_weak_count *)v597) {
      break;
    }
    uint64_t v12 = 1;
LABEL_520:
    unint64_t v588 = 0;
    uint64_t v264 = *v263;
    unint64_t v588 = v264;
    uint64_t v265 = (void *)gdc::Registry::storage<md::components::MeshInstance>((int8x8_t *)v264);
    uint64_t v266 = gdc::Registry::storage<md::overlayComponents::FoundationMeshType<(gss::MeshType)24>>((int8x8_t *)v264);
    uint64_t v267 = (void *)v266;
    unint64_t v585 = 0;
    uint64_t v586 = 0;
    uint64_t v587 = 0;
    uint64_t v268 = v266 + 32;
    uint64_t v270 = v265[7];
    uint64_t v269 = v265[8];
    if (*(void *)(v266 + 64) - *(void *)(v266 + 56) >= (unint64_t)(v269 - v270)) {
      uint64_t v271 = v265 + 4;
    }
    else {
      uint64_t v271 = (void *)(v266 + 32);
    }
    if (v265 + 4 == v271)
    {
      *(void *)long long buf = &v588;
      *(void *)&uint8_t buf[8] = &v585;
      if (v270 != v269)
      {
        uint64_t v274 = (_OWORD *)v265[10];
        do
        {
          unint64_t v275 = *(unsigned int *)(v270 + 4);
          uint64_t v276 = v267[4];
          if (v275 >> 7 < (v267[5] - v276) >> 3)
          {
            uint64_t v277 = *(void *)(v276 + 8 * (v275 >> 7));
            if (v277)
            {
              unint64_t v278 = *(unsigned __int16 *)(v277 + 2 * (v275 & 0x7F));
              uint64_t v280 = v267[7];
              uint64_t v279 = v267[8];
              if (v278 < (v279 - v280) >> 3)
              {
                uint64_t v281 = v280 + 8 * v278;
                if (v281 != v279 && *(_DWORD *)(v281 + 4) == v275) {
                  _ZZN2md12DrapingLogic29runBeforeLayoutAtVariableRateERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_15OverlaysContextENS_13CameraContextENS_19PendingSceneContextENS_16ElevationContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_14DrapingContextEENK3__4clENS5_6EntityERNS_10components12MeshInstanceE((uint64_t)buf, *(void *)v270, v274);
                }
              }
            }
          }
          v274 += 7;
          v270 += 8;
        }
        while (v270 != v269);
      }
    }
    if ((void *)v268 == v271)
    {
      *(void *)long long buf = &v588;
      *(void *)&uint8_t buf[8] = &v585;
      uint64_t v283 = v267[7];
      uint64_t v284 = v267[8];
      while (v283 != v284)
      {
        unint64_t v286 = *(unsigned int *)(v283 + 4);
        uint64_t v287 = v265[4];
        unint64_t v288 = (v265[5] - v287) >> 3;
        if (v286 >> 7 < v288)
        {
          uint64_t v289 = *(void *)(v287 + 8 * (v286 >> 7));
          if (v289)
          {
            unint64_t v290 = *(unsigned __int16 *)(v289 + 2 * (v286 & 0x7F));
            uint64_t v292 = v265[7];
            uint64_t v291 = v265[8];
            unint64_t v293 = (v291 - v292) >> 3;
            if (v293 > v290)
            {
              uint64_t v294 = v292 + 8 * v290;
              if (v294 != v291 && *(_DWORD *)(v294 + 4) == v286)
              {
                unint64_t v296 = *(void *)v283;
                unint64_t v297 = *(void *)v283 >> 39;
                if (v297 < v288
                  && (uint64_t v298 = *(void *)(v287 + 8 * v297)) != 0
                  && (unint64_t v299 = *(unsigned __int16 *)(v298 + 2 * (HIDWORD(v296) & 0x7F)), v293 > v299)
                  && ((uint64_t v300 = v292 + 8 * v299, v300 != v291)
                    ? (BOOL v301 = *(_DWORD *)(v300 + 4) == HIDWORD(v296))
                    : (BOOL v301 = 0),
                      v301))
                {
                  uint64_t v285 = (_OWORD *)(v265[10] + 112 * v299);
                }
                else
                {
                  uint64_t v285 = (_OWORD *)v265[11];
                }
                _ZZN2md12DrapingLogic29runBeforeLayoutAtVariableRateERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_15OverlaysContextENS_13CameraContextENS_19PendingSceneContextENS_16ElevationContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_14DrapingContextEENK3__4clENS5_6EntityERNS_10components12MeshInstanceE((uint64_t)buf, v296, v285);
              }
            }
          }
        }
        v283 += 8;
      }
    }
    uint64_t v13 = v585;
    if (v585 != v586)
    {
      uint64_t v272 = (char *)operator new(0x60uLL);
      *((void *)v272 + 1) = 0;
      *(void *)uint64_t v272 = &unk_1EF581440;
      v272[32] = 1;
      *(_OWORD *)(v272 + 40) = 0u;
      *(_OWORD *)(v272 + 56) = 0u;
      *((void *)v272 + 9) = &md::ZeroBlendFactor;
      *((void *)v272 + 2) = 0;
      *((void *)v272 + 3) = &unk_1EF540968;
      *((_OWORD *)v272 + 5) = xmmword_1A28FC6C0;
      uint64_t v273 = v588;
      long long v605 = *((_OWORD *)v13 + 3);
      long long v606 = *((_OWORD *)v13 + 4);
      *(_OWORD *)long long v607 = *((_OWORD *)v13 + 5);
      *(_OWORD *)&v607[12] = *(_OWORD *)((char *)v13 + 92);
      *(_OWORD *)long long buf = *(_OWORD *)v13;
      *(_OWORD *)&buf[16] = *((_OWORD *)v13 + 1);
      long long v604 = *((_OWORD *)v13 + 2);
      atomic_fetch_add_explicit((atomic_ullong *volatile)v272 + 1, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit((atomic_ullong *volatile)v272 + 1, 1uLL, memory_order_relaxed);
      gdc::Registry::create(v273);
    }
    if (v585)
    {
      uint64_t v586 = v585;
      operator delete(v585);
    }
    while (1)
    {
      int v263 = v597 + 1;
      int v597 = v263;
      if (v263 == (gdc::Registry **)v596[1]) {
        goto LABEL_519;
      }
      if (!v600) {
        break;
      }
      if ((*(unsigned int (**)(uint64_t *))(*v600 + 48))(v600))
      {
        int v263 = v597;
LABEL_519:
        if (v593 == (std::__shared_weak_count *)v263) {
          goto LABEL_567;
        }
        goto LABEL_520;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
LABEL_934:
    {
      qword_1EB3176C0 = 0;
      qword_1EB3176B8 = 0;
      md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet = (uint64_t)&qword_1EB3176B8;
      __cxa_atexit((void (*)(void *))std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100], &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet, &dword_1A1780000);
    }
  }
LABEL_567:
  if (v595 == v594)
  {
    (*(void (**)(void *))(v594[0] + 32))(v594);
  }
  else if (v595)
  {
    (*(void (**)(void))(*v595 + 40))();
  }
  if (v600 == &v598)
  {
    (*(void (**)(uint64_t *))(v598 + 32))(&v598);
  }
  else if (v600)
  {
    (*(void (**)(void))(*v600 + 40))();
  }
  if (*((long long **)&v619 + 1) == &v618)
  {
    (*(void (**)(long long *))(v618 + 32))(&v618);
  }
  else if (*((void *)&v619 + 1))
  {
    (*(void (**)(void))(**((void **)&v619 + 1) + 40))();
  }
LABEL_579:
  for (uint64_t j = *(void **)(*(void *)(a1 + 168) + 24); j; uint64_t j = (void *)*j)
  {
    unint64_t v303 = (unsigned __int8 *)j[8];
    if (!v303) {
      continue;
    }
    do
    {
      while (1)
      {
        int v304 = atomic_load(*((unsigned __int8 **)v303 + 8));
        if (v304 != 1)
        {
          int v305 = atomic_load(*((unsigned __int8 **)v303 + 8));
          if (v305 != 2)
          {
            int64_t v306 = (void *)*((void *)v303 + 8);
            unint64_t v307 = v306[3];
            double v308 = (std::__shared_weak_count *)v306[4];
            if (v308)
            {
              atomic_fetch_add_explicit(&v308->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              int64_t v306 = (void *)*((void *)v303 + 8);
            }
            unint64_t v309 = v306[5];
            uint64_t v310 = (std::__shared_weak_count *)v306[6];
            if (v310) {
              atomic_fetch_add_explicit(&v310->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            }
            if (!v308
              || (int v311 = *((unsigned __int16 *)v303 + 20), (v312 = std::__shared_weak_count::lock(v308)) == 0))
            {
              int v314 = 1;
              if (v310) {
                goto LABEL_659;
              }
              goto LABEL_660;
            }
            uint64_t v313 = v312;
            int v314 = 1;
            if (!v307 || !v310) {
              goto LABEL_657;
            }
            uint64_t v315 = std::__shared_weak_count::lock(v310);
            if (!v315)
            {
              int v314 = 1;
              goto LABEL_657;
            }
            unint64_t v316 = v315;
            if (!v309)
            {
              int v314 = 1;
              goto LABEL_655;
            }
            uint64_t v317 = *v559;
            {
              qword_1EB3176C0 = 0;
              qword_1EB3176B8 = 0;
              md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet = (uint64_t)&qword_1EB3176B8;
              __cxa_atexit((void (*)(void *))std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100], &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet, &dword_1A1780000);
            }
            double v318 = *(_WORD **)(v317 + 48);
            __double2 v319 = *(_WORD **)(v317 + 56);
            if (v318 == v319) {
              goto LABEL_612;
            }
            double v320 = *(_WORD **)(v317 + 48);
            while (*v320 != 33)
            {
              v320 += 16;
              if (v320 == v319) {
                goto LABEL_612;
              }
            }
            if (v320 == v319)
            {
LABEL_612:
              uint64_t v321 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
            }
            else
            {
              while (*v318 != 33)
              {
                v318 += 16;
                if (v318 == v319)
                {
                  double v318 = *(_WORD **)(v317 + 56);
                  break;
                }
              }
              uint64_t v321 = (uint64_t *)(v318 + 4);
            }
            p_shared_owners = &v313->__shared_owners_;
            int v314 = 1;
            atomic_fetch_add_explicit(&v313->__shared_owners_, 1uLL, memory_order_relaxed);
            atomic_fetch_add_explicit(&v313->__shared_owners_, 1uLL, memory_order_relaxed);
            uint64_t v323 = v321[1];
            if (!v323) {
              goto LABEL_652;
            }
            while (1)
            {
              int v324 = *(char *)(v323 + 48);
              unint64_t v325 = *(void *)(v323 + 32);
              BOOL v326 = v307 < v325;
              if (*(unsigned char *)(v323 + 48)) {
                BOOL v326 = v324 > 0;
              }
              if (v326) {
                goto LABEL_615;
              }
              BOOL v327 = v325 < v307;
              BOOL v10 = v324 == 0;
              BOOL v328 = v324 < 0;
              if (v10) {
                BOOL v328 = v327;
              }
              if (!v328) {
                break;
              }
              v323 += 8;
LABEL_615:
              uint64_t v323 = *(void *)v323;
              if (!v323)
              {
                int v314 = 1;
                if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
                  goto LABEL_624;
                }
                goto LABEL_653;
              }
            }
            uint64_t v329 = *v559;
            {
              p_shared_owners = &v313->__shared_owners_;
              if (v356)
              {
                qword_1EB3176C0 = 0;
                qword_1EB3176B8 = 0;
                md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet = (uint64_t)&qword_1EB3176B8;
                __cxa_atexit((void (*)(void *))std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100], &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet, &dword_1A1780000);
                p_shared_owners = &v313->__shared_owners_;
              }
            }
            uint64_t v330 = *(unsigned __int16 **)(v329 + 48);
            uint64_t v331 = *(unsigned __int16 **)(v329 + 56);
            if (v330 == v331)
            {
              __double2 v333 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
            }
            else
            {
              uint64_t v332 = *(unsigned __int16 **)(v329 + 48);
              while (*v332 != v311)
              {
                v332 += 16;
                if (v332 == v331) {
                  goto LABEL_637;
                }
              }
              if (v332 == v331)
              {
LABEL_637:
                __double2 v333 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
                goto LABEL_638;
              }
              while (*v330 != v311)
              {
                v330 += 16;
                if (v330 == v331)
                {
                  uint64_t v330 = *(unsigned __int16 **)(v329 + 56);
                  break;
                }
              }
              __double2 v333 = (uint64_t *)(v330 + 4);
            }
LABEL_638:
            uint64_t v334 = &v316->__shared_owners_;
            int v314 = 1;
            atomic_fetch_add_explicit(&v316->__shared_owners_, 1uLL, memory_order_relaxed);
            atomic_fetch_add_explicit(&v316->__shared_owners_, 1uLL, memory_order_relaxed);
            uint64_t v335 = v333[1];
            if (!v335)
            {
              if (!atomic_fetch_add(v334, 0xFFFFFFFFFFFFFFFFLL)) {
                goto LABEL_650;
              }
              goto LABEL_651;
            }
            while (2)
            {
              int v336 = *(char *)(v335 + 48);
              unint64_t v337 = *(void *)(v335 + 32);
              BOOL v338 = v309 < v337;
              if (*(unsigned char *)(v335 + 48)) {
                BOOL v338 = v336 > 0;
              }
              if (v338)
              {
LABEL_641:
                uint64_t v335 = *(void *)v335;
                if (!v335)
                {
                  int v314 = 1;
                  if (atomic_fetch_add(v334, 0xFFFFFFFFFFFFFFFFLL)) {
                    goto LABEL_651;
                  }
                  goto LABEL_650;
                }
                continue;
              }
              break;
            }
            BOOL v339 = v337 < v309;
            BOOL v10 = v336 == 0;
            BOOL v340 = v336 < 0;
            if (v10) {
              BOOL v340 = v339;
            }
            if (v340)
            {
              v335 += 8;
              goto LABEL_641;
            }
            int v314 = 0;
            if (atomic_fetch_add(v334, 0xFFFFFFFFFFFFFFFFLL)) {
              goto LABEL_651;
            }
LABEL_650:
            unint64_t v341 = p_shared_owners;
            ((void (*)(std::__shared_weak_count *))v316->__on_zero_shared)(v316);
            std::__shared_weak_count::__release_weak(v316);
            p_shared_owners = v341;
LABEL_651:
            if (atomic_fetch_add(&v316->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
LABEL_652:
              if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
                goto LABEL_653;
              }
            }
            else
            {
              uint64_t v355 = p_shared_owners;
              ((void (*)(std::__shared_weak_count *))v316->__on_zero_shared)(v316);
              std::__shared_weak_count::__release_weak(v316);
              if (atomic_fetch_add(v355, 0xFFFFFFFFFFFFFFFFLL)) {
                goto LABEL_653;
              }
            }
LABEL_624:
            ((void (*)(std::__shared_weak_count *))v313->__on_zero_shared)(v313);
            std::__shared_weak_count::__release_weak(v313);
LABEL_653:
            if (!atomic_fetch_add(&v313->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v313->__on_zero_shared)(v313);
              std::__shared_weak_count::__release_weak(v313);
            }
LABEL_655:
            if (!atomic_fetch_add(&v316->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v316->__on_zero_shared)(v316);
              std::__shared_weak_count::__release_weak(v316);
            }
LABEL_657:
            if (atomic_fetch_add(&v313->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              if (v310) {
                goto LABEL_659;
              }
            }
            else
            {
              ((void (*)(std::__shared_weak_count *))v313->__on_zero_shared)(v313);
              std::__shared_weak_count::__release_weak(v313);
              if (v310) {
LABEL_659:
              }
                std::__shared_weak_count::__release_weak(v310);
            }
LABEL_660:
            if (!v308)
            {
              if (v314) {
                break;
              }
              goto LABEL_584;
            }
            std::__shared_weak_count::__release_weak(v308);
            if (v314) {
              break;
            }
          }
        }
LABEL_584:
        unint64_t v303 = *(unsigned __int8 **)v303;
        if (!v303) {
          goto LABEL_581;
        }
      }
      if (!atomic_load(*((unsigned __int8 **)v303 + 8)))
      {
        atomic_store(3u, *((unsigned __int8 **)v303 + 8));
        atomic_store(1u, (unsigned __int8 *)(*(void *)(*((void *)v303 + 8) + 8) + 32));
      }
      int8x8_t v343 = (int8x8_t)j[7];
      uint64_t v345 = *(unsigned __int8 **)v303;
      unint64_t v344 = *((void *)v303 + 1);
      uint8x8_t v346 = (uint8x8_t)vcnt_s8(v343);
      v346.i16[0] = vaddlv_u8(v346);
      if (v346.u32[0] > 1uLL)
      {
        if (v344 >= *(void *)&v343) {
          v344 %= *(void *)&v343;
        }
      }
      else
      {
        v344 &= *(void *)&v343 - 1;
      }
      uint64_t v347 = j[6];
      float v348 = *(unsigned __int8 **)(v347 + 8 * v344);
      do
      {
        uint64_t v349 = v348;
        float v348 = *(unsigned __int8 **)v348;
      }
      while (v348 != v303);
      if (v349 == j + 8) {
        goto LABEL_941;
      }
      unint64_t v350 = v349[1];
      if (v346.u32[0] > 1uLL)
      {
        if (v350 >= *(void *)&v343) {
          v350 %= *(void *)&v343;
        }
      }
      else
      {
        v350 &= *(void *)&v343 - 1;
      }
      uint64_t v351 = *(unsigned __int8 **)v303;
      if (v350 == v344)
      {
LABEL_687:
        if (v351)
        {
          unint64_t v352 = *((void *)v351 + 1);
          goto LABEL_689;
        }
      }
      else
      {
LABEL_941:
        if (!v345) {
          goto LABEL_686;
        }
        unint64_t v352 = *((void *)v345 + 1);
        if (v346.u32[0] > 1uLL)
        {
          unint64_t v353 = *((void *)v345 + 1);
          if (v352 >= *(void *)&v343) {
            unint64_t v353 = v352 % *(void *)&v343;
          }
        }
        else
        {
          unint64_t v353 = v352 & (*(void *)&v343 - 1);
        }
        uint64_t v351 = *(unsigned __int8 **)v303;
        if (v353 != v344)
        {
LABEL_686:
          *(void *)(v347 + 8 * v344) = 0;
          uint64_t v351 = *(unsigned __int8 **)v303;
          goto LABEL_687;
        }
LABEL_689:
        if (v346.u32[0] > 1uLL)
        {
          if (v352 >= *(void *)&v343) {
            v352 %= *(void *)&v343;
          }
        }
        else
        {
          v352 &= *(void *)&v343 - 1;
        }
        if (v352 != v344)
        {
          *(void *)(j[6] + 8 * v352) = v349;
          uint64_t v351 = *(unsigned __int8 **)v303;
        }
      }
      *uint64_t v349 = v351;
      *(void *)unint64_t v303 = 0;
      --j[9];
      uint64_t v354 = (std::__shared_weak_count *)*((void *)v303 + 9);
      if (v354 && !atomic_fetch_add(&v354->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v354->__on_zero_shared)(v354);
        std::__shared_weak_count::__release_weak(v354);
      }
      operator delete(v303);
      unint64_t v303 = v345;
    }
    while (v345);
LABEL_581:
    ;
  }
  uint64_t v357 = *(void *)(a1 + 216);
  *(unsigned char *)(a4 + 8) = *(unsigned char *)(a1 + 224);
  *(void *)a4 = v357;
}

void sub_1A1C0846C(_Unwind_Exception *a1)
{
  std::unordered_set<md::FoundationOverlayPair,md::FoundationOverlayPairHash,std::equal_to<md::FoundationOverlayPair>,std::allocator<md::FoundationOverlayPair>>::~unordered_set[abi:nn180100](v1 - 160);
  _Unwind_Resume(a1);
}

void sub_1A1C084F0()
{
}

void sub_1A1C084F8()
{
}

void sub_1A1C08500()
{
}

void sub_1A1C08508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a48) {
    operator delete(a48);
  }
  md::FilteredIterator<std::vector<gdc::Registry *>>::~FilteredIterator(&a57);
  md::FilteredIterator<std::vector<gdc::Registry *>>::~FilteredIterator(&a63);
  md::FilteredIterator<std::vector<gdc::Registry *>>::~FilteredIterator(v63 - 160);
  _Unwind_Resume(a1);
}

void sub_1A1C08510(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58)
{
}

uint64_t gdc::Registry::storage<std::vector<gdc::Registry*>>(int8x8_t *a1)
{
  unint64_t v10 = 0x9256643C7714E8FELL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0x9256643C7714E8FELL;
    if (*(void *)&v1 <= 0x9256643C7714E8FELL) {
      unint64_t v3 = 0x9256643C7714E8FELL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0x9256643C7714E8FELL;
  }
  unsigned __int8 v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (unint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x9256643C7714E8FELL)
      {
        if (v5[2] == 0x9256643C7714E8FELL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x9256643C7714E8FELL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    unint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x9256643C7714E8FELL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1C08898(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<std::unordered_map<gdc::Registry*,std::vector<gdc::Entity>>>(int8x8_t *a1)
{
  uint64_t v10 = 0x1A70CFEE213578E3;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x1A70CFEE213578E3;
    if (*(void *)&v1 <= 0x1A70CFEE213578E3uLL) {
      uint64_t v3 = 0x1A70CFEE213578E3uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x1A70CFEE213578E3;
  }
  unsigned __int8 v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (unint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x1A70CFEE213578E3)
      {
        if (v5[2] == 0x1A70CFEE213578E3) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x1A70CFEE213578E3) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    unint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x1A70CFEE213578E3) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1C08B08(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::overlayComponents::RasterOverlayBase<md::OverlayTileData::OverlayTileResource::Texture>>(int8x8_t *a1)
{
  uint64_t v10 = 0x4719908BF4103968;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x4719908BF4103968;
    if (*(void *)&v1 <= 0x4719908BF4103968uLL) {
      uint64_t v3 = 0x4719908BF4103968uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x4719908BF4103968;
  }
  unsigned __int8 v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (unint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x4719908BF4103968)
      {
        if (v5[2] == 0x4719908BF4103968) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x4719908BF4103968) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    unint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x4719908BF4103968) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1C08D78(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::overlayComponents::RasterOverlayBase<md::OverlayTileData::OverlayTileResource::RasterTile>>(int8x8_t *a1)
{
  uint64_t v10 = 0x6BD391B11DF783CLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x6BD391B11DF783CLL;
    if (*(void *)&v1 <= 0x6BD391B11DF783CuLL) {
      uint64_t v3 = 0x6BD391B11DF783CuLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x6BD391B11DF783CLL;
  }
  unsigned __int8 v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (unint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x6BD391B11DF783CLL)
      {
        if (v5[2] == 0x6BD391B11DF783CLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      unint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x6BD391B11DF783CLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    unint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x6BD391B11DF783CLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1C08FE8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void md::DrapingLogic::_drapeKeyPair(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, atomic_ullong *a4, void *a5, uint64_t a6, uint64_t a7, const md::LayoutContext *a8, int8x8_t *a9)
{
  uint64_t v13 = a1;
  uint64_t v595 = *MEMORY[0x1E4F143B8];
  unsigned int v14 = *(int8x8_t **)(a6 + 168);
  unsigned int v15 = std::__hash_table<std::__hash_value_type<md::FoundationKey,md::DrapingTaskEntry>,std::__unordered_map_hasher<md::FoundationKey,std::__hash_value_type<md::FoundationKey,md::DrapingTaskEntry>,md::FoundationKeyHash,std::equal_to<md::FoundationKey>,true>,std::__unordered_map_equal<md::FoundationKey,std::__hash_value_type<md::FoundationKey,md::DrapingTaskEntry>,std::equal_to<md::FoundationKey>,md::FoundationKeyHash,true>,std::allocator<std::__hash_value_type<md::FoundationKey,md::DrapingTaskEntry>>>::find<md::FoundationKey>((void *)(*(void *)(a1 + 168) + 8), a2);
  double v543 = a3;
  if (!v15
    || (unsigned int v16 = std::__hash_table<std::__hash_value_type<md::OverlayKey,std::shared_ptr<md::DrapingTaskInfo>>,std::__unordered_map_hasher<md::OverlayKey,std::__hash_value_type<md::OverlayKey,std::shared_ptr<md::DrapingTaskInfo>>,md::OverlayKeyHash,std::equal_to<md::OverlayKey>,true>,std::__unordered_map_equal<md::OverlayKey,std::__hash_value_type<md::OverlayKey,std::shared_ptr<md::DrapingTaskInfo>>,std::equal_to<md::OverlayKey>,md::OverlayKeyHash,true>,std::allocator<std::__hash_value_type<md::OverlayKey,std::shared_ptr<md::DrapingTaskInfo>>>>::find<md::OverlayKey>(v15 + 6, a3)) == 0)
  {
    uint64_t v538 = a6;
    uint64_t v25 = (char *)operator new(0xA0uLL);
    int v26 = (atomic_ullong *)v25;
    *((void *)v25 + 1) = 0;
    *((void *)v25 + 2) = 0;
    *(void *)uint64_t v25 = &unk_1EF57FE60;
    *(_OWORD *)(v25 + 24) = 0u;
    *(_OWORD *)(v25 + 40) = 0u;
    *(_OWORD *)(v25 + 56) = 0u;
    *(_OWORD *)(v25 + 72) = 0u;
    *(_OWORD *)(v25 + 88) = 0u;
    *(_OWORD *)(v25 + 104) = 0u;
    *(_OWORD *)(v25 + 120) = 0u;
    *(_OWORD *)(v25 + 136) = 0u;
    *((void *)v25 + 19) = 0;
    uint64_t v540 = (std::__shared_weak_count *)(v25 + 24);
    int v583 = v25 + 24;
    int v584 = (std::__shared_weak_count *)v25;
    atomic_ullong v27 = *a4;
    atomic_ullong v28 = a4[1];
    if (v28)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 16), 1uLL, memory_order_relaxed);
      uint64_t v29 = (std::__shared_weak_count *)*((void *)v25 + 7);
      v26[6] = v27;
      v26[7] = v28;
      uint64_t v30 = a5;
      if (v29) {
        std::__shared_weak_count::__release_weak(v29);
      }
      atomic_ullong v32 = *a5;
      atomic_ullong v31 = a5[1];
      if (v31) {
        goto LABEL_13;
      }
    }
    else
    {
      *((void *)v25 + 6) = v27;
      *((void *)v25 + 7) = 0;
      uint64_t v30 = a5;
      atomic_ullong v32 = *a5;
      atomic_ullong v31 = a5[1];
      if (v31) {
LABEL_13:
      }
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 16), 1uLL, memory_order_relaxed);
    }
    unint64_t v33 = (std::__shared_weak_count *)v26[9];
    v26[8] = v32;
    v26[9] = v31;
    if (v33) {
      std::__shared_weak_count::__release_weak(v33);
    }
    unsigned __int8 v535 = a3[1];
    double v34 = *(double *)(a7 + 1384);
    double v35 = *(double *)(a7 + 3768);
    double v36 = *(double *)(a7 + 1368);
    uint64_t v37 = *(std::__shared_weak_count **)(v13 + 184);
    uint64_t v537 = *(std::__shared_weak_count **)(v13 + 176);
    if (v37) {
      atomic_fetch_add_explicit(&v37->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v541 = v37;
    unint64_t v38 = *(std::__shared_weak_count **)(v13 + 200);
    unint64_t v536 = *(std::__shared_weak_count **)(v13 + 192);
    if (v38) {
      atomic_fetch_add_explicit(&v38->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    atomic_fetch_add_explicit(v26 + 2, 1uLL, memory_order_relaxed);
    memset(&v582, 0, sizeof(v582));
    uint64_t v555 = (std::__shared_weak_count *)v26;
    uint64_t v542 = v38;
    uint64_t v546 = v13;
    if (a3[40])
    {
      if (!*(unsigned char *)(v13 + 224))
      {
        std::__throw_bad_optional_access[abi:nn180100]();
        __break(1u);
        return;
      }
      unint64_t v39 = *(void *)(v13 + 216);
      uint64_t v40 = md::ElevatedStrokeTileData::groupContainingFeature(*(int8x8_t **)(*v30 + 752), *(int8x8_t **)(*v30 + 760), v39);
      uint64_t v41 = (uint64_t *)v40;
      uint64_t v42 = *((void *)a8 + 92);
      int8x8_t v43 = v40[16];
      if (!*(void *)&v43) {
        goto LABEL_61;
      }
      uint8x8_t v44 = (uint8x8_t)vcnt_s8(v43);
      v44.i16[0] = vaddlv_u8(v44);
      if (v44.u32[0] > 1uLL)
      {
        unint64_t v45 = v39;
        if (*(void *)&v43 <= v39) {
          unint64_t v45 = v39 % *(void *)&v43;
        }
      }
      else
      {
        unint64_t v45 = (*(void *)&v43 - 1) & v39;
      }
      uint64_t v63 = *(uint64_t ***)(*(void *)&v40[15] + 8 * v45);
      if (!v63 || (unsigned __int8 v64 = *v63) == 0)
      {
LABEL_61:
        memset(buf, 0, 24);
        goto LABEL_62;
      }
      if (v44.u32[0] < 2uLL)
      {
        uint64_t v65 = *(void *)&v43 - 1;
        while (1)
        {
          uint64_t v67 = v64[1];
          if (v67 == v39)
          {
            if (v64[2] == v39) {
              goto LABEL_186;
            }
          }
          else if ((v67 & v65) != v45)
          {
            goto LABEL_61;
          }
          unsigned __int8 v64 = (uint64_t *)*v64;
          if (!v64) {
            goto LABEL_61;
          }
        }
      }
      while (1)
      {
        unint64_t v66 = v64[1];
        if (v66 == v39) {
          break;
        }
        if (v66 >= *(void *)&v43) {
          v66 %= *(void *)&v43;
        }
        if (v66 != v45) {
          goto LABEL_61;
        }
LABEL_51:
        unsigned __int8 v64 = (uint64_t *)*v64;
        if (!v64) {
          goto LABEL_61;
        }
      }
      if (v64[2] != v39) {
        goto LABEL_51;
      }
LABEL_186:
      int8x8_t v129 = v40[8];
      unsigned int v130 = *((_DWORD *)v64 + 6);
      unsigned int v131 = *((_DWORD *)v64 + 7);
      memset(buf, 0, 24);
      if (v131 != v130)
      {
        uint64_t v529 = *(void *)&v129 + 88 * v131;
        uint64_t v531 = *(void *)&v129 + 88 * v130;
        if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((v529 - v531) >> 3)) >= 0x2E8BA2E8BA2E8BBLL) {
          abort();
        }
        uint64_t v527 = v42;
        float v132 = (char *)operator new(v529 - v531);
        uint64_t v133 = 0;
        *(void *)long long buf = v132;
        *(void *)&uint8_t buf[8] = v132;
        *(void *)&buf[16] = &v132[8 * ((v529 - v531) >> 3)];
        do
        {
          uint64_t v137 = v531 + v133;
          unint64_t v138 = &v132[v133];
          *(void *)unint64_t v138 = 0;
          *((void *)v138 + 1) = 0;
          *((void *)v138 + 2) = 0;
          unint64_t v140 = *(unsigned char **)(v531 + v133);
          uint64_t v139 = *(unsigned char **)(v531 + v133 + 8);
          uint64_t v141 = v139 - v140;
          if (v139 != v140)
          {
            if (v141 < 0) {
              abort();
            }
            int v142 = (char *)operator new((size_t)&v139[-*(void *)v137]);
            *(void *)unint64_t v138 = v142;
            *((void *)v138 + 1) = v142;
            *((void *)v138 + 2) = &v142[8 * (v141 >> 3)];
            size_t v143 = v141 & 0xFFFFFFFFFFFFFFF8;
            memcpy(v142, v140, v143);
            *((void *)v138 + 1) = &v142[v143];
          }
          *((void *)v138 + 3) = 0;
          *((void *)v138 + 4) = 0;
          *((void *)v138 + 5) = 0;
          int v145 = *(unsigned char **)(v137 + 24);
          int v144 = *(unsigned char **)(v137 + 32);
          int64_t v146 = v144 - v145;
          if (v144 != v145)
          {
            if (v146 < 0) {
              abort();
            }
            uint64_t v147 = (char *)operator new(v144 - v145);
            *((void *)v138 + 3) = v147;
            *((void *)v138 + 4) = v147;
            float v148 = &v147[16 * (v146 >> 4)];
            *((void *)v138 + 5) = v148;
            memcpy(v147, v145, v146);
            *((void *)v138 + 4) = v148;
          }
          uint64_t v134 = &v132[v133];
          long long v135 = *(_OWORD *)(v137 + 48);
          long long v136 = *(_OWORD *)(v137 + 64);
          *((void *)v134 + 10) = *(void *)(v137 + 80);
          *((_OWORD *)v134 + 3) = v135;
          *((_OWORD *)v134 + 4) = v136;
          v133 += 88;
        }
        while (v137 + 88 != v529);
        *(void *)&uint8_t buf[8] = &v132[v133];
        uint64_t v30 = a5;
        uint64_t v13 = v546;
        uint64_t v42 = v527;
      }
LABEL_62:
      uint8x8_t v68 = operator new(0xE8uLL);
      v68[1] = 0;
      v68[2] = 0;
      *uint8x8_t v68 = &unk_1EF586DB8;
      uint64_t v69 = ggl::BufferData::BufferData((uint64_t)(v68 + 3), qword_1E9552208, 2, 1, 6, 1);
      v68[28] = ggl::Tile::View::reflection(void)::reflection;
      v68[3] = &unk_1EF55E258;
      *(void *)&long long v578 = v69;
      *((void *)&v578 + 1) = v68;
      md::GeometryLogic::createUnitTransformConstantData((md::GeometryLogic *)&__p);
      int v585 = 1057360530;
      md::PolygonOverlayMeshBuilder::buildPolygonMeshesFromMeshInfos((uint64_t *)&v586, (uint64_t **)buf, (void *)(v42 + 32), (uint64_t *)&v578, (uint64_t *)&__p, v41 + 4, &v585);
      size = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
      if (__p.__r_.__value_.__l.__size_
        && !atomic_fetch_add((atomic_ullong *volatile)(__p.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
      size_t v71 = (std::__shared_weak_count *)*((void *)&v578 + 1);
      if (*((void *)&v578 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v578 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
        std::__shared_weak_count::__release_weak(v71);
      }
      uint64_t v72 = *(void *)buf;
      if (*(void *)buf)
      {
        uint64_t v73 = *(void *)&buf[8];
        unint64_t v74 = *(void **)buf;
        if (*(void *)&buf[8] != *(void *)buf)
        {
          do
          {
            unint64_t v75 = *(void **)(v73 - 64);
            if (v75)
            {
              *(void *)(v73 - 56) = v75;
              operator delete(v75);
            }
            unint64_t v76 = *(void **)(v73 - 88);
            if (v76)
            {
              *(void *)(v73 - 80) = v76;
              operator delete(v76);
            }
            v73 -= 88;
          }
          while (v73 != v72);
          unint64_t v74 = *(void **)buf;
        }
        *(void *)&uint8_t buf[8] = v72;
        operator delete(v74);
      }
      uint64_t v77 = *v30;
      md::ElevatedStrokeGroup::selectedStyleQuery(&v580, v41);
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = v586;
      if ((void)v586) {
        operator new();
      }
      *(void *)&long long v586 = 0;
      *(_OWORD *)&buf[16] = __PAIR128__(*((unint64_t *)&v586 + 1), 0);
      if (*((void *)&v586 + 1)) {
        operator new();
      }
      *((void *)&v586 + 1) = 0;
      long long v590 = 0u;
      memset(&buf[32], 0, 24);
      char v591 = v580;
      uint64_t v592 = v581;
      if (v581)
      {
        atomic_fetch_add_explicit(&v581->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v78 = v581;
        uint64_t v593 = v77;
        char v594 = 0;
        if (v581 && !atomic_fetch_add(&v581->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
          std::__shared_weak_count::__release_weak(v78);
        }
      }
      else
      {
        uint64_t v593 = v77;
        char v594 = 0;
      }
      md::overlayComponents::VectorOverlay::drapingStyle((md::overlayComponents::VectorOverlay *)&v578, (const md::LayoutContext *)buf, *(float *)(*(void *)(v13 + 208) + 8), fmaxf(*(float *)(a7 + 3080) + *(float *)(a7 + 3076), 1.0), a8);
      std::vector<md::DrapingLogic::_drapeKeyPair(md::FoundationKey const&,md::OverlayKey const&,std::shared_ptr<md::DaVinciGroundTileData> const&,std::shared_ptr<md::ElevatedStrokeTileData> const&,md::OverlaysContext const&,md::CameraContext const&,md::LayoutContext const&,gdc::Registry *)::DrapingItem,std::allocator<md::DrapingLogic::_drapeKeyPair(md::FoundationKey const&,md::OverlayKey const&,std::shared_ptr<md::DaVinciGroundTileData> const&,std::shared_ptr<md::ElevatedStrokeTileData> const&,md::OverlaysContext const&,md::CameraContext const&,md::LayoutContext const&,gdc::Registry *)::DrapingItem>>::emplace_back<md::overlayComponents::VectorOverlay &,md::DrapingStyle>((void **)&v582.__r_.__value_.__l.__data_, (uint64_t)buf, &v578);
      int v79 = -858993459 * (((unint64_t)v41 - *(void *)(*v30 + 752)) >> 5);
      unint64_t v80 = (std::__shared_weak_count *)v583;
      int8x8_t v82 = (char *)*((void *)v583 + 12);
      unint64_t v81 = *((void *)v583 + 13);
      if ((unint64_t)v82 < v81)
      {
        *(_DWORD *)int8x8_t v82 = v79;
        CFComparisonResult v83 = (std::__shared_weak_count_vtbl *)(v82 + 4);
        goto LABEL_108;
      }
      CFComparisonResult v84 = (char *)*((void *)v583 + 11);
      uint64_t v85 = (v82 - v84) >> 2;
      unint64_t v86 = v85 + 1;
      if ((unint64_t)(v85 + 1) >> 62) {
        abort();
      }
      uint64_t v87 = v81 - (void)v84;
      if (v87 >> 1 > v86) {
        unint64_t v86 = v87 >> 1;
      }
      if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v88 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v88 = v86;
      }
      if (v88)
      {
        if (!(v88 >> 62))
        {
          uint64_t v89 = operator new(4 * v88);
          goto LABEL_99;
        }
LABEL_790:
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v89 = 0;
LABEL_99:
      uint64_t v90 = &v89[4 * v85];
      unint64_t v91 = &v89[4 * v88];
      _DWORD *v90 = v79;
      CFComparisonResult v83 = (std::__shared_weak_count_vtbl *)(v90 + 1);
      if (v82 != v84)
      {
        unint64_t v92 = v82 - v84 - 4;
        if (v92 < 0x2C) {
          goto LABEL_806;
        }
        if ((unint64_t)(v84 - v89) < 0x20) {
          goto LABEL_806;
        }
        uint64_t v93 = (v92 >> 2) + 1;
        unint64_t v94 = &v89[4 * v85 - 16];
        uint64_t v95 = v82 - 16;
        uint64_t v96 = v93 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v97 = *(_OWORD *)v95;
          *(v94 - 1) = *((_OWORD *)v95 - 1);
          _OWORD *v94 = v97;
          v94 -= 2;
          v95 -= 32;
          v96 -= 8;
        }
        while (v96);
        v90 -= v93 & 0x7FFFFFFFFFFFFFF8;
        v82 -= 4 * (v93 & 0x7FFFFFFFFFFFFFF8);
        if (v93 != (v93 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_806:
          do
          {
            int v98 = *((_DWORD *)v82 - 1);
            v82 -= 4;
            *--uint64_t v90 = v98;
          }
          while (v82 != v84);
        }
      }
      v80[3].__shared_weak_owners_ = (uint64_t)v90;
      v80[4].__vftable = v83;
      v80[4].__shared_owners_ = (uint64_t)v91;
      if (v84) {
        operator delete(v84);
      }
LABEL_108:
      v80[4].__vftable = v83;
      md::overlayComponents::VectorOverlay::~VectorOverlay((md::overlayComponents::VectorOverlay *)buf);
      uint64_t v99 = *((void *)&v586 + 1);
      *((void *)&v586 + 1) = 0;
      if (v99) {
        (*(void (**)(uint64_t))(*(void *)v99 + 8))(v99);
      }
      uint64_t v100 = v586;
      *(void *)&long long v586 = 0;
      if (v100)
      {
        unint64_t v101 = *(std::__shared_weak_count **)(v100 + 72);
        if (v101 && !atomic_fetch_add(&v101->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
          std::__shared_weak_count::__release_weak(v101);
        }
        CFTypeRef v102 = *(std::__shared_weak_count **)(v100 + 8);
        if (v102 && !atomic_fetch_add(&v102->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v102->__on_zero_shared)(v102);
          std::__shared_weak_count::__release_weak(v102);
        }
        MEMORY[0x1A6239270](v100, 0x1020C408635837CLL);
        unint64_t v80 = (std::__shared_weak_count *)v583;
      }
LABEL_242:
      LODWORD(v80[2].__shared_owners_) = -252645135
                                       * ((v582.__r_.__value_.__l.__size_ - v582.__r_.__value_.__r.__words[0]) >> 3);
      if (GEOGetVectorKitElevatedStrokesLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitElevatedStrokesLog_onceToken, &__block_literal_global_49_16498);
      }
      unint64_t v189 = (id)GEOGetVectorKitElevatedStrokesLog_log;
      if (os_log_type_enabled(v189, OS_LOG_TYPE_DEBUG))
      {
        int64_t v576 = *(_WORD *)a3;
        uint64_t v577 = *(void *)(a3 + 4);
        md::debugString<geo::QuadTile>(&v578, (char *)&v576);
        int v190 = SHIBYTE(v579);
        size_t v191 = (long long *)v578;
        unint64_t v573 = *(_WORD *)a2;
        uint64_t v574 = *(void *)(a2 + 4);
        md::debugString<geo::QuadTile>(&__p, (char *)&v573);
        int v192 = &v578;
        if (v190 < 0) {
          int v192 = v191;
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        int shared_owners = v80[2].__shared_owners_;
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v192;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = p_p;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = shared_owners;
        _os_log_impl(&dword_1A1780000, v189, OS_LOG_TYPE_DEBUG, "Draping Overlay Tile %s onto Foundation Tile %s.  Mesh CFIndex Count = %d", buf, 0x1Cu);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
          if (SHIBYTE(v579) < 0) {
            goto LABEL_483;
          }
        }
        else
        {
          if ((SHIBYTE(v579) & 0x80000000) == 0) {
            goto LABEL_252;
          }
LABEL_483:
          operator delete((void *)v578);
        }
      }
LABEL_252:

      uint64_t v195 = a9;
      uint64_t v196 = (void *)gdc::Registry::storage<md::components::MeshInstance>(a9);
      uint64_t v197 = gdc::Registry::storage<md::overlayComponents::Overlayable>(a9);
      uint64_t v198 = (void *)v197;
      int v199 = 0;
      uint64_t v200 = v197 + 32;
      BOOL v202 = (uint64_t *)v196[7];
      float v201 = (uint64_t *)v196[8];
      if (*(void *)(v197 + 64) - *(void *)(v197 + 56) >= (unint64_t)((char *)v201 - (char *)v202)) {
        unint64_t v203 = v196 + 4;
      }
      else {
        unint64_t v203 = (void *)(v197 + 32);
      }
      unint64_t v204 = 0;
      double v205 = 0;
      double v206 = 0;
      uint64_t v207 = 0;
      if (v196 + 4 == v203 && v202 != v201)
      {
        int v199 = 0;
        unint64_t v204 = 0;
        double v205 = 0;
        double v206 = 0;
        uint64_t v207 = 0;
        uint64_t v528 = v203;
        uint64_t v530 = v197 + 32;
        do
        {
          unint64_t v208 = *((unsigned int *)v202 + 1);
          uint64_t v209 = v198[4];
          if (v208 >> 7 < (v198[5] - v209) >> 3)
          {
            uint64_t v210 = *(void *)(v209 + 8 * (v208 >> 7));
            if (v210)
            {
              unint64_t v211 = *(unsigned __int16 *)(v210 + 2 * (v208 & 0x7F));
              uint64_t v213 = v198[7];
              uint64_t v212 = v198[8];
              if (v211 < (v212 - v213) >> 3)
              {
                uint64_t v214 = v213 + 8 * v211;
                if (v214 != v212 && *(_DWORD *)(v214 + 4) == v208)
                {
                  uint64_t v216 = *v202;
                  ++v207;
                  if (v206 >= v205)
                  {
                    uint8x8_t v217 = v205;
                    uint64_t v218 = v199;
                    int8x8_t v219 = v206;
                    uint64_t v220 = v206 - v199;
                    uint64_t v221 = v220 >> 3;
                    unint64_t v222 = (v220 >> 3) + 1;
                    if (v222 >> 61) {
                      abort();
                    }
                    BOOL v550 = v218;
                    unint64_t v223 = v217 - v218;
                    unint64_t v224 = (v217 - v218) >> 2;
                    if (v224 > v222) {
                      unint64_t v222 = v224;
                    }
                    if (v223 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v225 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v225 = v222;
                    }
                    uint64_t v532 = v207;
                    if (v225)
                    {
                      if (v225 >> 61) {
                        goto LABEL_790;
                      }
                      unint64_t v226 = v225;
                      uint64_t v227 = (char *)operator new(8 * v225);
                      unint64_t v225 = v226;
                    }
                    else
                    {
                      uint64_t v227 = 0;
                    }
                    uint64_t v228 = &v227[8 * v221];
                    *(void *)uint64_t v228 = v216;
                    unint64_t v204 = v228 + 8;
                    unint64_t v229 = v550;
                    if (v219 != v550)
                    {
                      unint64_t v230 = v219 - 8 - v550;
                      if (v230 < 0x168)
                      {
                        uint64_t v231 = v219;
                        unint64_t v229 = v550;
                        goto LABEL_286;
                      }
                      if (&v227[v220 - 8 - (v230 & 0xFFFFFFFFFFFFFFF8)] > &v227[v220 - 8]
                        || &v219[-(v230 & 0xFFFFFFFFFFFFFFF8) - 8] > v219 - 8
                        || (unint64_t)(v219 - &v227[v220]) < 0x20)
                      {
                        uint64_t v231 = v219;
                        unint64_t v229 = v550;
                        goto LABEL_286;
                      }
                      uint64_t v233 = (v230 >> 3) + 1;
                      uint64_t v231 = &v219[-8 * (v233 & 0x3FFFFFFFFFFFFFFCLL)];
                      int v234 = &v227[8 * v221 - 16];
                      uint64_t v235 = (long long *)(v219 - 16);
                      uint64_t v236 = v233 & 0x3FFFFFFFFFFFFFFCLL;
                      unint64_t v229 = v550;
                      do
                      {
                        long long v237 = *v235;
                        *((_OWORD *)v234 - 1) = *(v235 - 1);
                        *(_OWORD *)int v234 = v237;
                        v234 -= 32;
                        v235 -= 2;
                        v236 -= 4;
                      }
                      while (v236);
                      v228 -= 8 * (v233 & 0x3FFFFFFFFFFFFFFCLL);
                      if (v233 != (v233 & 0x3FFFFFFFFFFFFFFCLL))
                      {
                        do
                        {
LABEL_286:
                          uint64_t v232 = *((void *)v231 - 1);
                          v231 -= 8;
                          *((void *)v228 - 1) = v232;
                          v228 -= 8;
                        }
                        while (v231 != v229);
                      }
                    }
                    double v205 = &v227[8 * v225];
                    if (v229) {
                      operator delete(v229);
                    }
                    int v199 = v228;
                    double v206 = v204;
                    uint64_t v195 = a9;
                    uint64_t v200 = v530;
                    uint64_t v207 = v532;
                    unint64_t v203 = v528;
                    goto LABEL_259;
                  }
                  *(void *)double v206 = v216;
                  v206 += 8;
                  unint64_t v204 = v206;
                }
              }
            }
          }
LABEL_259:
          ++v202;
        }
        while (v202 != v201);
      }
      if ((void *)v200 != v203 || (unint64_t v250 = (uint64_t *)v198[7], v249 = (uint64_t *)v198[8], v250 == v249))
      {
LABEL_295:
        if (*(unsigned char *)(v538 + 208)) {
          BOOL v238 = v207 == 0;
        }
        else {
          BOOL v238 = 0;
        }
        if (!v238)
        {
LABEL_309:
          long long v578 = 0uLL;
          uint64_t v579 = 0;
          uint64_t v551 = v199;
          std::vector<md::Mesh>::reserve((uint64_t)&v578, (v204 - v199) >> 3);
          uint64_t v247 = v583;
          std::vector<BOOL>::reserve((uint64_t)(v583 + 64), (v204 - v199) >> 3);
          if (v199 != v204)
          {
            uint64_t v248 = (unint64_t *)v199;
            do
            {
              unint64_t v310 = *v248;
              int v311 = (void *)gdc::Registry::storage<md::components::MeshInstance>(v195);
              uint64_t v312 = v311[4];
              if (v310 >> 39 < (v311[5] - v312) >> 3)
              {
                uint64_t v313 = *(void *)(v312 + 8 * (v310 >> 39));
                if (v313)
                {
                  unint64_t v314 = *(unsigned __int16 *)(v313 + 2 * (HIDWORD(v310) & 0x7F));
                  uint64_t v316 = v311[7];
                  uint64_t v315 = v311[8];
                  if (v314 < (v315 - v316) >> 3)
                  {
                    uint64_t v317 = v316 + 8 * v314;
                    if (v317 != v315 && *(_DWORD *)(v317 + 4) == HIDWORD(v310))
                    {
                      uint64_t v319 = v311[10];
                      double v320 = (uint64_t *)(v319 + 112 * v314);
                      BOOL v321 = v320 == (uint64_t *)v311[11] || v319 == 0;
                      if (!v321 && *(unsigned char *)(*v320 + 32) == 3)
                      {
                        unint64_t v322 = *v248;
                        uint64_t v323 = (void *)gdc::Registry::storage<md::overlayComponents::FoundationMeshType<(gss::MeshType)24>>(v195);
                        uint64_t v324 = v323[4];
                        if (v322 >> 39 < (v323[5] - v324) >> 3
                          && (uint64_t v325 = *(void *)(v324 + 8 * (v322 >> 39))) != 0
                          && (unint64_t v326 = *(unsigned __int16 *)(v325 + 2 * (HIDWORD(v322) & 0x7F)),
                              uint64_t v328 = v323[7],
                              uint64_t v327 = v323[8],
                              v326 < (v327 - v328) >> 3)
                          && ((uint64_t v329 = v328 + 8 * v326, v329 != v327)
                            ? (BOOL v330 = *(_DWORD *)(v329 + 4) == HIDWORD(v322))
                            : (BOOL v330 = 0),
                              v330))
                        {
                          unint64_t v331 = v323[11];
                          unint64_t v332 = v323[10] + v326;
                        }
                        else
                        {
                          unint64_t v331 = v323[11];
                          unint64_t v332 = v331;
                        }
                        BOOL v334 = v332 == v331 || v332 == 0;
                        uint64_t v335 = v583;
                        unint64_t v336 = *((void *)v583 + 9);
                        uint64_t v337 = *((void *)v583 + 10);
                        if (v336 == v337 << 6)
                        {
                          if ((uint64_t)(v336 + 1) < 0) {
                            abort();
                          }
                          if (v336 > 0x3FFFFFFFFFFFFFFELL)
                          {
                            unint64_t v340 = 0x7FFFFFFFFFFFFFFFLL;
                          }
                          else
                          {
                            unint64_t v338 = v337 << 7;
                            unint64_t v339 = (v336 & 0xFFFFFFFFFFFFFFC0) + 64;
                            if (v338 <= v339) {
                              unint64_t v340 = v339;
                            }
                            else {
                              unint64_t v340 = v338;
                            }
                          }
                          std::vector<BOOL>::reserve((uint64_t)(v583 + 64), v340);
                          unint64_t v336 = *((void *)v335 + 9);
                        }
                        *((void *)v335 + 9) = v336 + 1;
                        uint64_t v341 = *((void *)v335 + 8);
                        unint64_t v342 = v336 >> 6;
                        uint64_t v343 = 1 << v336;
                        if (v334) {
                          uint64_t v344 = *(void *)(v341 + 8 * v342) & ~v343;
                        }
                        else {
                          uint64_t v344 = *(void *)(v341 + 8 * v342) | v343;
                        }
                        *(void *)(v341 + 8 * v342) = v344;
                        uint64_t v345 = *v320;
                        uint64_t v346 = *((void *)&v578 + 1);
                        if (*((void *)&v578 + 1) >= (unint64_t)v579)
                        {
                          uint64_t v351 = (char *)v578;
                          unint64_t v352 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&v578 + 1) - v578) >> 4);
                          unint64_t v353 = v352 + 1;
                          if (v352 + 1 > 0x333333333333333) {
                            abort();
                          }
                          if (0x999999999999999ALL * ((uint64_t)&v579[-v578] >> 4) > v353) {
                            unint64_t v353 = 0x999999999999999ALL * ((uint64_t)&v579[-v578] >> 4);
                          }
                          if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v579[-v578] >> 4) >= 0x199999999999999) {
                            unint64_t v354 = 0x333333333333333;
                          }
                          else {
                            unint64_t v354 = v353;
                          }
                          if (v354)
                          {
                            if (v354 > 0x333333333333333) {
                              goto LABEL_790;
                            }
                            uint64_t v355 = (char *)operator new(80 * v354);
                          }
                          else
                          {
                            uint64_t v355 = 0;
                          }
                          int v356 = &v355[80 * v352];
                          *(void *)int v356 = *(void *)v345;
                          uint64_t v357 = *(void *)(v345 + 8);
                          *((void *)v356 + 1) = v357;
                          if (v357) {
                            atomic_fetch_add_explicit((atomic_ullong *volatile)(v357 + 8), 1uLL, memory_order_relaxed);
                          }
                          uint64_t v358 = &v355[80 * v352];
                          long long v359 = *(_OWORD *)(v345 + 16);
                          long long v360 = *(_OWORD *)(v345 + 32);
                          *(_OWORD *)(v358 + 46) = *(_OWORD *)(v345 + 46);
                          *((_OWORD *)v358 + 1) = v359;
                          *((_OWORD *)v358 + 2) = v360;
                          *((void *)v358 + 8) = *(void *)(v345 + 64);
                          uint64_t v361 = *(void *)(v345 + 72);
                          *((void *)v358 + 9) = v361;
                          if (v361) {
                            atomic_fetch_add_explicit((atomic_ullong *volatile)(v361 + 8), 1uLL, memory_order_relaxed);
                          }
                          unint64_t v362 = &v355[80 * v354];
                          unint64_t v309 = v356 + 80;
                          uint64_t v363 = (char *)*((void *)&v578 + 1);
                          uint64_t v195 = a9;
                          if (*((char **)&v578 + 1) == v351)
                          {
                            *(void *)&long long v578 = v356;
                            *((void *)&v578 + 1) = v356 + 80;
                            uint64_t v579 = &v355[80 * v354];
                          }
                          else
                          {
                            do
                            {
                              long long v364 = *((_OWORD *)v363 - 5);
                              v363 -= 80;
                              *((_OWORD *)v356 - 5) = v364;
                              v356 -= 80;
                              *(void *)uint64_t v363 = 0;
                              *((void *)v363 + 1) = 0;
                              long long v365 = *((_OWORD *)v363 + 1);
                              long long v366 = *((_OWORD *)v363 + 2);
                              *(_OWORD *)(v356 + 46) = *(_OWORD *)(v363 + 46);
                              *((_OWORD *)v356 + 1) = v365;
                              *((_OWORD *)v356 + 2) = v366;
                              *((_OWORD *)v356 + 4) = *((_OWORD *)v363 + 4);
                              *((void *)v363 + 8) = 0;
                              *((void *)v363 + 9) = 0;
                            }
                            while (v363 != v351);
                            unint64_t v367 = (char *)*((void *)&v578 + 1);
                            uint64_t v351 = (char *)v578;
                            *(void *)&long long v578 = v356;
                            *((void *)&v578 + 1) = v309;
                            uint64_t v579 = v362;
                            while (v367 != v351)
                            {
                              uint64_t v368 = (std::__shared_weak_count *)*((void *)v367 - 1);
                              if (v368 && !atomic_fetch_add(&v368->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                              {
                                ((void (*)(std::__shared_weak_count *))v368->__on_zero_shared)(v368);
                                std::__shared_weak_count::__release_weak(v368);
                              }
                              uint64_t v369 = (std::__shared_weak_count *)*((void *)v367 - 9);
                              if (v369 && !atomic_fetch_add(&v369->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                              {
                                ((void (*)(std::__shared_weak_count *))v369->__on_zero_shared)(v369);
                                std::__shared_weak_count::__release_weak(v369);
                              }
                              v367 -= 80;
                            }
                          }
                          if (v351) {
                            operator delete(v351);
                          }
                        }
                        else
                        {
                          **((void **)&v578 + 1) = *(void *)v345;
                          uint64_t v347 = *(void *)(v345 + 8);
                          *(void *)(v346 + 8) = v347;
                          uint64_t v195 = a9;
                          if (v347) {
                            atomic_fetch_add_explicit((atomic_ullong *volatile)(v347 + 8), 1uLL, memory_order_relaxed);
                          }
                          long long v348 = *(_OWORD *)(v345 + 16);
                          long long v349 = *(_OWORD *)(v345 + 32);
                          *(_OWORD *)(v346 + 46) = *(_OWORD *)(v345 + 46);
                          *(_OWORD *)(v346 + 16) = v348;
                          *(_OWORD *)(v346 + 32) = v349;
                          *(void *)(v346 + 64) = *(void *)(v345 + 64);
                          uint64_t v350 = *(void *)(v345 + 72);
                          *(void *)(v346 + 72) = v350;
                          if (v350) {
                            atomic_fetch_add_explicit((atomic_ullong *volatile)(v350 + 8), 1uLL, memory_order_relaxed);
                          }
                          unint64_t v309 = (char *)(v346 + 80);
                        }
                        *((void *)&v578 + 1) = v309;
                      }
                    }
                  }
                }
              }
              ++v248;
            }
            while (v248 != (unint64_t *)v204);
            uint64_t v247 = v583;
          }
          *((_DWORD *)v247 + 15) = -858993459 * ((*((void *)&v578 + 1) - (void)v578) >> 4);
          uint64_t v370 = *(void *)(v546 + 168);
          unint64_t v371 = v541;
          v560[0] = v536;
          v560[1] = v542;
          if (v542) {
            atomic_fetch_add_explicit(&v542->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          v561[0] = v537;
          v561[1] = v541;
          if (v541) {
            atomic_fetch_add_explicit(&v541->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          v562[0] = v540;
          v562[1] = v555;
          atomic_fetch_add_explicit(&v555->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          __int16 v563 = *(_WORD *)a2;
          uint64_t v564 = *(void *)(a2 + 4);
          __int16 v565 = *(_WORD *)v543;
          uint64_t v566 = *(void *)(v543 + 4);
          float v372 = v35 * v34 / (v36 * (float)(1.0 / (float)(1 << v535)));
          float v567 = v372;
          std::vector<md::DrapingLogic::_drapeKeyPair(md::FoundationKey const&,md::OverlayKey const&,std::shared_ptr<md::DaVinciGroundTileData> const&,std::shared_ptr<md::ElevatedStrokeTileData> const&,md::OverlaysContext const&,md::CameraContext const&,md::LayoutContext const&,gdc::Registry *)::DrapingItem,std::allocator<md::DrapingLogic::_drapeKeyPair(md::FoundationKey const&,md::OverlayKey const&,std::shared_ptr<md::DaVinciGroundTileData> const&,std::shared_ptr<md::ElevatedStrokeTileData> const&,md::OverlaysContext const&,md::CameraContext const&,md::LayoutContext const&,gdc::Registry *)::DrapingItem>>::vector(&v568, (uint64_t *)&v582);
          uint64_t v570 = 0;
          uint64_t v571 = 0;
          unint64_t v572 = 0;
          uint64_t v374 = *((void *)&v578 + 1);
          uint64_t v373 = v578;
          int64_t v375 = *((void *)&v578 + 1) - v578;
          if (*((void *)&v578 + 1) == (void)v578)
          {
            uint64_t v377 = 0;
          }
          else
          {
            unint64_t v376 = 0xCCCCCCCCCCCCCCCDLL * (v375 >> 4);
            if (v376 > 0x333333333333333) {
              abort();
            }
            uint64_t v377 = (uint64_t)operator new(v375);
            uint64_t v570 = v377;
            uint64_t v571 = v377;
            unint64_t v572 = v377 + 80 * v376;
            unint64_t v371 = v541;
            do
            {
              *(void *)uint64_t v377 = *(void *)v373;
              uint64_t v378 = *(void *)(v373 + 8);
              *(void *)(v377 + 8) = v378;
              if (v378) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v378 + 8), 1uLL, memory_order_relaxed);
              }
              long long v379 = *(_OWORD *)(v373 + 16);
              long long v380 = *(_OWORD *)(v373 + 32);
              *(_OWORD *)(v377 + 46) = *(_OWORD *)(v373 + 46);
              *(_OWORD *)(v377 + 16) = v379;
              *(_OWORD *)(v377 + 32) = v380;
              *(void *)(v377 + 64) = *(void *)(v373 + 64);
              uint64_t v381 = *(void *)(v373 + 72);
              *(void *)(v377 + 72) = v381;
              if (v381) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v381 + 8), 1uLL, memory_order_relaxed);
              }
              v377 += 80;
              v373 += 80;
            }
            while (v373 != v374);
            uint64_t v571 = v377;
          }
          unint64_t v588 = 0;
          uint64_t v382 = (char *)operator new(0xA0uLL);
          long long v383 = *(_OWORD *)v561;
          *(_OWORD *)(v382 + 8) = *(_OWORD *)v560;
          *(void *)uint64_t v382 = &unk_1EF56DB90;
          v560[0] = 0;
          v560[1] = 0;
          *(_OWORD *)(v382 + 24) = v383;
          v561[0] = 0;
          v561[1] = 0;
          *(_OWORD *)(v382 + 40) = *(_OWORD *)v562;
          v562[0] = 0;
          v562[1] = 0;
          *((_WORD *)v382 + 28) = v563;
          *(void *)(v382 + 60) = v564;
          *((_WORD *)v382 + 40) = v565;
          *(void *)(v382 + 84) = v566;
          *((float *)v382 + 26) = v567;
          *((_OWORD *)v382 + 7) = v568;
          long long v568 = 0uLL;
          uint64_t v384 = v569;
          uint64_t v385 = v570;
          uint64_t v569 = 0;
          *((void *)v382 + 16) = v384;
          *((void *)v382 + 17) = v385;
          unint64_t v386 = v572;
          *((void *)v382 + 18) = v377;
          *((void *)v382 + 19) = v386;
          uint64_t v570 = 0;
          uint64_t v571 = 0;
          unint64_t v572 = 0;
          unint64_t v588 = v382;
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
          uint64_t v387 = (std::__shared_weak_count *)*((void *)v247 + 4);
          unint64_t v388 = v542;
          if (!v387) {
            goto LABEL_757;
          }
          __p.__r_.__value_.__l.__size_ = (std::string::size_type)std::__shared_weak_count::lock(v387);
          if (!__p.__r_.__value_.__l.__size_) {
            goto LABEL_757;
          }
          __p.__r_.__value_.__r.__words[0] = *((void *)v247 + 3);
          if (!__p.__r_.__value_.__r.__words[0]) {
            goto LABEL_757;
          }
          uint64_t v389 = *a2;
          uint64_t v390 = a2[1];
          unint64_t v391 = (v390
                + ((v389 - 0x61C8864680B583EBLL) << 6)
                + ((unint64_t)(v389 - 0x61C8864680B583EBLL) >> 2)
                - 0x61C8864680B583EBLL) ^ (v389 - 0x61C8864680B583EBLL);
          uint64_t v392 = *((int *)a2 + 1);
          uint64_t v393 = *((int *)a2 + 2);
          unint64_t v394 = (v392 + (v391 << 6) + (v391 >> 2) - 0x61C8864680B583EBLL) ^ v391;
          unint64_t v395 = (v393 + (v394 << 6) + (v394 >> 2) - 0x61C8864680B583EBLL) ^ v394;
          uint64_t v396 = *((unsigned int *)a2 + 6);
          unint64_t v397 = (v396 + (v395 << 6) + (v395 >> 2) - 0x61C8864680B583EBLL) ^ v395;
          unint64_t v398 = *(void *)(v370 + 16);
          if (v398)
          {
            uint8x8_t v399 = (uint8x8_t)vcnt_s8((int8x8_t)v398);
            v399.i16[0] = vaddlv_u8(v399);
            if (v399.u32[0] > 1uLL)
            {
              uint64_t v377 = (v396 + (v395 << 6) + (v395 >> 2) - 0x61C8864680B583EBLL) ^ v395;
              if (v397 >= v398) {
                uint64_t v377 = v397 % v398;
              }
            }
            else
            {
              uint64_t v377 = v397 & (v398 - 1);
            }
            unint64_t v430 = *(void ***)(*(void *)(v370 + 8) + 8 * v377);
            if (v430)
            {
              uint64_t v431 = (unsigned __int8 *)*v430;
              if (*v430)
              {
                if (v399.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    uint64_t v433 = *((void *)v431 + 1);
                    if (v433 == v397)
                    {
                      if (__PAIR64__(v431[17], v431[16]) == __PAIR64__(v390, v389)
                        && *(void *)(v431 + 20) == __PAIR64__(v393, v392)
                        && *((_DWORD *)v431 + 10) == v396)
                      {
                        goto LABEL_545;
                      }
                    }
                    else if ((v433 & (v398 - 1)) != v377)
                    {
                      goto LABEL_546;
                    }
                    uint64_t v431 = *(unsigned __int8 **)v431;
                    if (!v431) {
                      goto LABEL_546;
                    }
                  }
                }
                do
                {
                  unint64_t v432 = *((void *)v431 + 1);
                  if (v432 == v397)
                  {
                    if (__PAIR64__(v431[17], v431[16]) == __PAIR64__(v390, v389)
                      && *(void *)(v431 + 20) == __PAIR64__(v393, v392)
                      && *((_DWORD *)v431 + 10) == v396)
                    {
LABEL_545:
                      unint64_t v434 = 0x9E3779B97F4A7C15;
                      goto LABEL_615;
                    }
                  }
                  else
                  {
                    if (v432 >= v398) {
                      v432 %= v398;
                    }
                    if (v432 != v377) {
                      break;
                    }
                  }
                  uint64_t v431 = *(unsigned __int8 **)v431;
                }
                while (v431);
              }
            }
          }
LABEL_546:
          uint64_t v431 = (unsigned __int8 *)operator new(0x58uLL);
          *(void *)long long buf = v431;
          *(void *)&uint8_t buf[8] = v370 + 24;
          uint64_t v547 = (void *)(v370 + 24);
          *(void *)uint64_t v431 = 0;
          *((void *)v431 + 1) = v397;
          v431[16] = v389;
          v431[17] = v390;
          *(void *)(v431 + 20) = *(void *)(a2 + 4);
          *((_DWORD *)v431 + 10) = v396;
          *((void *)v431 + 10) = 0;
          *((_OWORD *)v431 + 3) = 0u;
          *((_OWORD *)v431 + 4) = 0u;
          *((_DWORD *)v431 + 20) = 1065353216;
          buf[16] = 1;
          float v435 = (float)(unint64_t)(*(void *)(v370 + 32) + 1);
          float v436 = *(float *)(v370 + 40);
          if (v398 && (float)(v436 * (float)v398) >= v435)
          {
            unint64_t v434 = 0x9E3779B97F4A7C15;
            goto LABEL_605;
          }
          BOOL v437 = 1;
          if (v398 >= 3) {
            BOOL v437 = (v398 & (v398 - 1)) != 0;
          }
          unint64_t v438 = v437 | (2 * v398);
          unint64_t v439 = vcvtps_u32_f32(v435 / v436);
          if (v438 <= v439) {
            size_t prime = v439;
          }
          else {
            size_t prime = v438;
          }
          unint64_t v434 = 0x9E3779B97F4A7C15;
          if (prime == 1)
          {
            size_t prime = 2;
          }
          else if ((prime & (prime - 1)) != 0)
          {
            size_t prime = std::__next_prime(prime);
            unint64_t v398 = *(void *)(v370 + 16);
          }
          if (prime <= v398)
          {
            if (prime >= v398) {
              goto LABEL_600;
            }
            unint64_t v452 = vcvtps_u32_f32((float)*(unint64_t *)(v370 + 32) / *(float *)(v370 + 40));
            if (v398 < 3
              || (uint8x8_t v453 = (uint8x8_t)vcnt_s8((int8x8_t)v398), v453.i16[0] = vaddlv_u8(v453), v453.u32[0] > 1uLL))
            {
              unint64_t v452 = std::__next_prime(v452);
            }
            else
            {
              uint64_t v454 = 1 << -(char)__clz(v452 - 1);
              if (v452 >= 2) {
                unint64_t v452 = v454;
              }
            }
            if (prime <= v452) {
              size_t prime = v452;
            }
            if (prime >= v398) {
              goto LABEL_600;
            }
            if (!prime)
            {
              unint64_t v459 = *(void **)(v370 + 8);
              *(void *)(v370 + 8) = 0;
              if (v459) {
                operator delete(v459);
              }
              *(void *)(v370 + 16) = 0;
              goto LABEL_600;
            }
          }
          if (prime >> 61) {
            goto LABEL_790;
          }
          uint64_t v441 = operator new(8 * prime);
          unint64_t v442 = *(void **)(v370 + 8);
          *(void *)(v370 + 8) = v441;
          if (v442) {
            operator delete(v442);
          }
          uint64_t v443 = 0;
          *(void *)(v370 + 16) = prime;
          do
            *(void *)(*(void *)(v370 + 8) + 8 * v443++) = 0;
          while (prime != v443);
          uint64_t v444 = (void *)*v547;
          if (!*v547) {
            goto LABEL_600;
          }
          size_t v445 = v444[1];
          size_t v446 = prime - 1;
          if ((prime & (prime - 1)) == 0)
          {
            size_t v447 = v445 & v446;
            *(void *)(*(void *)(v370 + 8) + 8 * v447) = v547;
            while (1)
            {
              uint64_t v448 = (void *)*v444;
              if (!*v444) {
                break;
              }
              size_t v449 = v448[1] & v446;
              if (v449 == v447)
              {
                uint64_t v444 = (void *)*v444;
              }
              else
              {
                uint64_t v450 = *(void *)(v370 + 8);
                if (*(void *)(v450 + 8 * v449))
                {
                  *uint64_t v444 = *v448;
                  uint64_t v451 = 8 * v449;
                  *uint64_t v448 = **(void **)(*(void *)(v370 + 8) + v451);
                  **(void **)(*(void *)(v370 + 8) + v451) = v448;
                }
                else
                {
                  *(void *)(v450 + 8 * v449) = v444;
                  uint64_t v444 = v448;
                  size_t v447 = v449;
                }
              }
            }
LABEL_600:
            unint64_t v398 = *(void *)(v370 + 16);
            if ((v398 & (v398 - 1)) != 0)
            {
              if (v397 >= v398) {
                uint64_t v377 = v397 % v398;
              }
              else {
                uint64_t v377 = v397;
              }
            }
            else
            {
              uint64_t v377 = (v398 - 1) & v397;
            }
LABEL_605:
            uint64_t v460 = *(void *)(v370 + 8);
            unint64_t v461 = *(void **)(v460 + 8 * v377);
            if (v461)
            {
              *(void *)uint64_t v431 = *v461;
            }
            else
            {
              *(void *)uint64_t v431 = *v547;
              *uint64_t v547 = v431;
              *(void *)(v460 + 8 * v377) = v547;
              if (!*(void *)v431)
              {
LABEL_614:
                ++*(void *)(v370 + 32);
LABEL_615:
                uint64_t v463 = *v543;
                unint64_t v464 = (v543[1]
                      - 0x61C8864680B583EBLL
                      + ((v463 - 0x61C8864680B583EBLL) << 6)
                      + ((unint64_t)(v463 - 0x61C8864680B583EBLL) >> 2)) ^ (v463 - 0x61C8864680B583EBLL);
                uint64_t v465 = *((int *)v543 + 1);
                uint64_t v466 = *((int *)v543 + 2);
                unint64_t v467 = (v465 - 0x61C8864680B583EBLL + (v464 << 6) + (v464 >> 2)) ^ v464;
                unint64_t v468 = (v466 - 0x61C8864680B583EBLL + (v467 << 6) + (v467 >> 2)) ^ v467;
                uint64_t v469 = *((unsigned __int16 *)v543 + 12);
                unint64_t v470 = (v469 - 0x61C8864680B583EBLL + (v468 << 6) + (v468 >> 2)) ^ v468;
                uint64_t v471 = *((unsigned int *)v543 + 7);
                unint64_t v472 = (v471 - 0x61C8864680B583EBLL + (v470 << 6) + (v470 >> 2)) ^ v470;
                if (v543[40]) {
                  v472 ^= (v472 << 6) - 0x61C8864680B583EBLL + (v472 >> 2) + *((void *)v543 + 4);
                }
                unint64_t v473 = *((void *)v431 + 7);
                unsigned int v548 = v543[1];
                if (v473)
                {
                  uint8x8_t v474 = (uint8x8_t)vcnt_s8((int8x8_t)v473);
                  v474.i16[0] = vaddlv_u8(v474);
                  if (v474.u32[0] > 1uLL)
                  {
                    unint64_t v475 = v472;
                    if (v472 >= v473) {
                      unint64_t v475 = v472 % v473;
                    }
                  }
                  else
                  {
                    unint64_t v475 = (v473 - 1) & v472;
                  }
                  unint64_t v434 = v475;
                  uint64_t v476 = *(void ***)(*((void *)v431 + 6) + 8 * v475);
                  if (v476)
                  {
                    unint64_t v477 = (unsigned __int8 *)*v476;
                    if (*v476)
                    {
                      uint64_t v478 = *((void *)v543 + 4);
                      if (v474.u32[0] <= 1uLL)
                      {
                        unint64_t v479 = v473 - 1;
                        if (v543[40])
                        {
                          while (1)
                          {
                            uint64_t v480 = *((void *)v477 + 1);
                            if (v480 == v472)
                            {
                              if (__PAIR64__(v477[17], v477[16]) == __PAIR64__(v548, v463)
                                && *(void *)(v477 + 20) == __PAIR64__(v466, v465)
                                && __PAIR64__(*((_DWORD *)v477 + 11), *((unsigned __int16 *)v477 + 20)) == __PAIR64__(v471, v469)
                                && v477[56]
                                && *((void *)v477 + 6) == v478)
                              {
                                goto LABEL_736;
                              }
                            }
                            else if ((v480 & v479) != v475)
                            {
                              goto LABEL_669;
                            }
                            unint64_t v477 = *(unsigned __int8 **)v477;
                            if (!v477) {
                              goto LABEL_669;
                            }
                          }
                        }
                        while (1)
                        {
                          uint64_t v483 = *((void *)v477 + 1);
                          if (v483 == v472)
                          {
                            if (__PAIR64__(v477[17], v477[16]) == __PAIR64__(v548, v463)
                              && *(void *)(v477 + 20) == __PAIR64__(v466, v465)
                              && __PAIR64__(*((_DWORD *)v477 + 11), *((unsigned __int16 *)v477 + 20)) == __PAIR64__(v471, v469)
                              && !v477[56])
                            {
                              goto LABEL_736;
                            }
                          }
                          else if ((v483 & v479) != v475)
                          {
                            goto LABEL_669;
                          }
                          unint64_t v477 = *(unsigned __int8 **)v477;
                          if (!v477) {
                            goto LABEL_669;
                          }
                        }
                      }
                      if (!v543[40])
                      {
                        while (1)
                        {
                          unint64_t v482 = *((void *)v477 + 1);
                          if (v482 == v472)
                          {
                            if (__PAIR64__(v477[17], v477[16]) == __PAIR64__(v548, v463)
                              && *(void *)(v477 + 20) == __PAIR64__(v466, v465)
                              && __PAIR64__(*((_DWORD *)v477 + 11), *((unsigned __int16 *)v477 + 20)) == __PAIR64__(v471, v469)
                              && !v477[56])
                            {
                              goto LABEL_736;
                            }
                          }
                          else
                          {
                            if (v482 >= v473) {
                              v482 %= v473;
                            }
                            if (v482 != v475) {
                              goto LABEL_669;
                            }
                          }
                          unint64_t v477 = *(unsigned __int8 **)v477;
                          if (!v477) {
                            goto LABEL_669;
                          }
                        }
                      }
                      do
                      {
                        unint64_t v481 = *((void *)v477 + 1);
                        if (v481 == v472)
                        {
                          if (__PAIR64__(v477[17], v477[16]) == __PAIR64__(v548, v463)
                            && *(void *)(v477 + 20) == __PAIR64__(v466, v465)
                            && __PAIR64__(*((_DWORD *)v477 + 11), *((unsigned __int16 *)v477 + 20)) == __PAIR64__(v471, v469)
                            && v477[56]
                            && *((void *)v477 + 6) == v478)
                          {
                            goto LABEL_736;
                          }
                        }
                        else
                        {
                          if (v481 >= v473) {
                            v481 %= v473;
                          }
                          if (v481 != v475) {
                            break;
                          }
                        }
                        unint64_t v477 = *(unsigned __int8 **)v477;
                      }
                      while (v477);
                    }
                  }
                }
LABEL_669:
                unint64_t v477 = (unsigned __int8 *)operator new(0x50uLL);
                BOOL v484 = v431 + 64;
                *(void *)long long buf = v477;
                *(void *)&uint8_t buf[8] = v431 + 64;
                *(void *)unint64_t v477 = 0;
                *((void *)v477 + 1) = v472;
                v477[16] = v463;
                v477[17] = v548;
                *(void *)(v477 + 20) = *(void *)(v543 + 4);
                *(_OWORD *)(v477 + 40) = *(_OWORD *)(v543 + 24);
                v477[56] = v543[40];
                *((void *)v477 + 8) = 0;
                *((void *)v477 + 9) = 0;
                buf[16] = 1;
                float v485 = (float)(unint64_t)(*((void *)v431 + 9) + 1);
                float v486 = *((float *)v431 + 20);
                if (v473 && (float)(v486 * (float)v473) >= v485)
                {
                  unint64_t v472 = v434;
                  goto LABEL_726;
                }
                BOOL v487 = 1;
                if (v473 >= 3) {
                  BOOL v487 = (v473 & (v473 - 1)) != 0;
                }
                unint64_t v488 = v487 | (2 * v473);
                unint64_t v489 = vcvtps_u32_f32(v485 / v486);
                if (v488 <= v489) {
                  size_t v490 = v489;
                }
                else {
                  size_t v490 = v488;
                }
                if (v490 == 1)
                {
                  size_t v490 = 2;
                }
                else if ((v490 & (v490 - 1)) != 0)
                {
                  size_t v490 = std::__next_prime(v490);
                  unint64_t v473 = *((void *)v431 + 7);
                }
                if (v490 <= v473)
                {
                  if (v490 >= v473) {
                    goto LABEL_722;
                  }
                  unint64_t v502 = vcvtps_u32_f32((float)*((unint64_t *)v431 + 9) / *((float *)v431 + 20));
                  if (v473 < 3
                    || (uint8x8_t v503 = (uint8x8_t)vcnt_s8((int8x8_t)v473), v503.i16[0] = vaddlv_u8(v503), v503.u32[0] > 1uLL))
                  {
                    unint64_t v502 = std::__next_prime(v502);
                  }
                  else
                  {
                    uint64_t v504 = 1 << -(char)__clz(v502 - 1);
                    if (v502 >= 2) {
                      unint64_t v502 = v504;
                    }
                  }
                  if (v490 <= v502) {
                    size_t v490 = v502;
                  }
                  if (v490 >= v473) {
                    goto LABEL_722;
                  }
                  if (!v490)
                  {
                    uint64_t v509 = (void *)*((void *)v431 + 6);
                    *((void *)v431 + 6) = 0;
                    if (v509) {
                      operator delete(v509);
                    }
                    *((void *)v431 + 7) = 0;
                    goto LABEL_722;
                  }
                }
                if (v490 >> 61) {
                  goto LABEL_790;
                }
                unint64_t v491 = operator new(8 * v490);
                unint64_t v492 = (void *)*((void *)v431 + 6);
                *((void *)v431 + 6) = v491;
                if (v492) {
                  operator delete(v492);
                }
                uint64_t v493 = 0;
                *((void *)v431 + 7) = v490;
                do
                  *(void *)(*((void *)v431 + 6) + 8 * v493++) = 0;
                while (v490 != v493);
                unint64_t v494 = (void *)*v484;
                if (!*v484) {
                  goto LABEL_722;
                }
                size_t v495 = v494[1];
                size_t v496 = v490 - 1;
                if ((v490 & (v490 - 1)) == 0)
                {
                  size_t v497 = v495 & v496;
                  *(void *)(*((void *)v431 + 6) + 8 * v497) = v484;
                  while (1)
                  {
                    uint64_t v498 = (void *)*v494;
                    if (!*v494) {
                      break;
                    }
                    size_t v499 = v498[1] & v496;
                    if (v499 == v497)
                    {
                      unint64_t v494 = (void *)*v494;
                    }
                    else
                    {
                      uint64_t v500 = *((void *)v431 + 6);
                      if (*(void *)(v500 + 8 * v499))
                      {
                        void *v494 = *v498;
                        uint64_t v501 = 8 * v499;
                        void *v498 = **(void **)(*((void *)v431 + 6) + v501);
                        **(void **)(*((void *)v431 + 6) + v501) = v498;
                      }
                      else
                      {
                        *(void *)(v500 + 8 * v499) = v494;
                        unint64_t v494 = v498;
                        size_t v497 = v499;
                      }
                    }
                  }
LABEL_722:
                  unint64_t v473 = *((void *)v431 + 7);
                  if ((v473 & (v473 - 1)) != 0)
                  {
                    if (v472 >= v473) {
                      v472 %= v473;
                    }
                  }
                  else
                  {
                    v472 &= v473 - 1;
                  }
LABEL_726:
                  uint64_t v510 = *((void *)v431 + 6);
                  unint64_t v511 = *(void **)(v510 + 8 * v472);
                  if (v511)
                  {
                    *(void *)unint64_t v477 = *v511;
                  }
                  else
                  {
                    *(void *)unint64_t v477 = *v484;
                    *BOOL v484 = v477;
                    *(void *)(v510 + 8 * v472) = v484;
                    if (!*(void *)v477)
                    {
LABEL_735:
                      ++*((void *)v431 + 9);
                      uint64_t v247 = v583;
LABEL_736:
                      unint64_t v388 = v542;
                      unint64_t v513 = v584;
                      if (v584) {
                        atomic_fetch_add_explicit(&v584->__shared_owners_, 1uLL, memory_order_relaxed);
                      }
                      uint64_t v514 = (std::__shared_weak_count *)*((void *)v477 + 9);
                      *((void *)v477 + 8) = v247;
                      *((void *)v477 + 9) = v513;
                      if (v514 && !atomic_fetch_add(&v514->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v514->__on_zero_shared)(v514);
                        std::__shared_weak_count::__release_weak(v514);
                      }
                      uint64_t v515 = *(void *)(*(void *)v370 + 128);
                      unint64_t v371 = v541;
                      if (!v515) {
                        goto LABEL_757;
                      }
                      uint64_t v516 = (uint64_t)v588;
                      if (v588)
                      {
                        if (v588 == v587)
                        {
                          *(void *)&unsigned char buf[24] = buf;
                          (*(void (**)(void *, uint8_t *))(v587[0] + 24))(v587, buf);
LABEL_747:
                          geo::TaskQueue::async((std::__shared_weak_count_vtbl **)&v586, v515, buf);
                          long long v517 = v586;
                          long long v586 = 0uLL;
                          long long v518 = (std::__shared_weak_count *)*((void *)v583 + 2);
                          *(_OWORD *)(v583 + 8) = v517;
                          if (v518 && !atomic_fetch_add(&v518->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v518->__on_zero_shared)(v518);
                            std::__shared_weak_count::__release_weak(v518);
                          }
                          uint64_t v519 = (std::__shared_weak_count *)*((void *)&v586 + 1);
                          if (*((void *)&v586 + 1)
                            && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v586 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v519->__on_zero_shared)(v519);
                            std::__shared_weak_count::__release_weak(v519);
                          }
                          if (*(uint8_t **)&buf[24] == buf)
                          {
                            (*(void (**)(uint8_t *))(*(void *)buf + 32))(buf);
                          }
                          else if (*(void *)&buf[24])
                          {
                            (*(void (**)(void))(**(void **)&buf[24] + 40))();
                          }
LABEL_757:
                          unint64_t v520 = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
                          if (__p.__r_.__value_.__l.__size_
                            && !atomic_fetch_add((atomic_ullong *volatile)(__p.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v520->__on_zero_shared)(v520);
                            std::__shared_weak_count::__release_weak(v520);
                          }
                          if (v588 == v587)
                          {
                            (*(void (**)(void *))(v587[0] + 32))(v587);
                          }
                          else if (v588)
                          {
                            (*(void (**)(void))(*v588 + 40))();
                          }
                          *(void *)long long buf = &v570;
                          std::vector<md::Mesh>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
                          uint64_t v521 = v568;
                          if ((void)v568)
                          {
                            uint64_t v522 = *((void *)&v568 + 1);
                            uint64_t v523 = (void *)v568;
                            if (*((void *)&v568 + 1) != (void)v568)
                            {
                              do
                                md::overlayComponents::VectorOverlay::~VectorOverlay((md::overlayComponents::VectorOverlay *)(v522 - 136));
                              while (v522 != v521);
                              uint64_t v523 = (void *)v568;
                            }
                            *((void *)&v568 + 1) = v521;
                            operator delete(v523);
                          }
                          if (v562[1]) {
                            std::__shared_weak_count::__release_weak(v562[1]);
                          }
                          if (v561[1]) {
                            std::__shared_weak_count::__release_weak(v561[1]);
                          }
                          if (v560[1]) {
                            std::__shared_weak_count::__release_weak(v560[1]);
                          }
                          *(void *)long long buf = &v578;
                          std::vector<md::Mesh>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
                          if (v551) {
                            operator delete(v551);
                          }
                          unint64_t v524 = (void *)v582.__r_.__value_.__r.__words[0];
                          if (v582.__r_.__value_.__r.__words[0])
                          {
                            std::string::size_type v525 = v582.__r_.__value_.__l.__size_;
                            if (v582.__r_.__value_.__l.__size_ != v582.__r_.__value_.__r.__words[0])
                            {
                              do
                                md::overlayComponents::VectorOverlay::~VectorOverlay((md::overlayComponents::VectorOverlay *)(v525 - 136));
                              while ((void *)v525 != v524);
                            }
                            operator delete(v524);
                          }
                          std::__shared_weak_count::__release_weak(v555);
                          if (v388) {
                            std::__shared_weak_count::__release_weak(v388);
                          }
                          if (v371) {
                            std::__shared_weak_count::__release_weak(v371);
                          }
                          uint64_t v526 = v584;
                          if (v584 && !atomic_fetch_add(&v584->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v526->__on_zero_shared)(v526);
                            std::__shared_weak_count::__release_weak(v526);
                          }
                          return;
                        }
                        uint64_t v516 = (*(uint64_t (**)(void))(*v588 + 16))();
                      }
                      *(void *)&unsigned char buf[24] = v516;
                      goto LABEL_747;
                    }
                    unint64_t v512 = *(void *)(*(void *)v477 + 8);
                    if ((v473 & (v473 - 1)) != 0)
                    {
                      if (v512 >= v473) {
                        v512 %= v473;
                      }
                    }
                    else
                    {
                      v512 &= v473 - 1;
                    }
                    unint64_t v511 = (void *)(*((void *)v431 + 6) + 8 * v512);
                  }
                  *unint64_t v511 = v477;
                  goto LABEL_735;
                }
                if (v495 >= v490) {
                  v495 %= v490;
                }
                *(void *)(*((void *)v431 + 6) + 8 * v495) = v484;
                unint64_t v505 = (void *)*v494;
                if (!*v494) {
                  goto LABEL_722;
                }
                while (1)
                {
                  size_t v507 = v505[1];
                  if (v507 >= v490) {
                    v507 %= v490;
                  }
                  if (v507 != v495)
                  {
                    uint64_t v508 = *((void *)v431 + 6);
                    if (!*(void *)(v508 + 8 * v507))
                    {
                      *(void *)(v508 + 8 * v507) = v494;
                      goto LABEL_708;
                    }
                    void *v494 = *v505;
                    uint64_t v506 = 8 * v507;
                    void *v505 = **(void **)(*((void *)v431 + 6) + v506);
                    **(void **)(*((void *)v431 + 6) + v506) = v505;
                    unint64_t v505 = v494;
                  }
                  size_t v507 = v495;
LABEL_708:
                  unint64_t v494 = v505;
                  unint64_t v505 = (void *)*v505;
                  size_t v495 = v507;
                  if (!v505) {
                    goto LABEL_722;
                  }
                }
              }
              unint64_t v462 = *(void *)(*(void *)v431 + 8);
              if ((v398 & (v398 - 1)) != 0)
              {
                if (v462 >= v398) {
                  v462 %= v398;
                }
              }
              else
              {
                v462 &= v398 - 1;
              }
              unint64_t v461 = (void *)(*(void *)(v370 + 8) + 8 * v462);
            }
            *unint64_t v461 = v431;
            goto LABEL_614;
          }
          if (v445 >= prime) {
            v445 %= prime;
          }
          *(void *)(*(void *)(v370 + 8) + 8 * v445) = v547;
          uint64_t v455 = (void *)*v444;
          if (!*v444) {
            goto LABEL_600;
          }
          while (1)
          {
            size_t v457 = v455[1];
            if (v457 >= prime) {
              v457 %= prime;
            }
            if (v457 != v445)
            {
              uint64_t v458 = *(void *)(v370 + 8);
              if (!*(void *)(v458 + 8 * v457))
              {
                *(void *)(v458 + 8 * v457) = v444;
                goto LABEL_585;
              }
              *uint64_t v444 = *v455;
              uint64_t v456 = 8 * v457;
              *uint64_t v455 = **(void **)(*(void *)(v370 + 8) + v456);
              **(void **)(*(void *)(v370 + 8) + v456) = v455;
              uint64_t v455 = v444;
            }
            size_t v457 = v445;
LABEL_585:
            uint64_t v444 = v455;
            uint64_t v455 = (void *)*v455;
            size_t v445 = v457;
            if (!v455) {
              goto LABEL_600;
            }
          }
        }
        uint64_t v239 = (void *)gdc::Registry::storage<md::components::MeshInstance>(v195);
        uint64_t v240 = gdc::Registry::storage<md::overlayComponents::OverlayableFallback>(v195);
        unint64_t v241 = (void *)v240;
        uint64_t v242 = v240 + 32;
        uint64_t v244 = (uint64_t *)v239[7];
        uint64_t v243 = (uint64_t *)v239[8];
        if (*(void *)(v240 + 64) - *(void *)(v240 + 56) >= (unint64_t)((char *)v243 - (char *)v244)) {
          uint64_t v245 = v239 + 4;
        }
        else {
          uint64_t v245 = (void *)(v240 + 32);
        }
        if (v239 + 4 == v245 && v244 != v243)
        {
          uint64_t v539 = v240 + 32;
          uint64_t v534 = v245;
          do
          {
            unint64_t v279 = *((unsigned int *)v244 + 1);
            uint64_t v280 = v241[4];
            if (v279 >> 7 < (v241[5] - v280) >> 3)
            {
              uint64_t v281 = *(void *)(v280 + 8 * (v279 >> 7));
              if (v281)
              {
                unint64_t v282 = *(unsigned __int16 *)(v281 + 2 * (v279 & 0x7F));
                uint64_t v284 = v241[7];
                uint64_t v283 = v241[8];
                if (v282 < (v283 - v284) >> 3)
                {
                  uint64_t v285 = v284 + 8 * v282;
                  if (v285 != v283 && *(_DWORD *)(v285 + 4) == v279)
                  {
                    uint64_t v287 = *v244;
                    if (v206 >= v205)
                    {
                      unint64_t v288 = v205;
                      uint64_t v289 = v199;
                      unint64_t v290 = v206;
                      uint64_t v291 = v206 - v199;
                      uint64_t v292 = v291 >> 3;
                      unint64_t v293 = (v291 >> 3) + 1;
                      if (v293 >> 61) {
LABEL_794:
                      }
                        abort();
                      unint64_t v553 = v289;
                      unint64_t v294 = v288 - v289;
                      unint64_t v295 = (v288 - v289) >> 2;
                      if (v295 > v293) {
                        unint64_t v293 = v295;
                      }
                      if (v294 >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v296 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v296 = v293;
                      }
                      if (v296)
                      {
                        if (v296 >> 61) {
                          goto LABEL_790;
                        }
                        unint64_t v297 = v296;
                        uint64_t v298 = (char *)operator new(8 * v296);
                        unint64_t v296 = v297;
                      }
                      else
                      {
                        uint64_t v298 = 0;
                      }
                      unint64_t v299 = &v298[8 * v292];
                      *(void *)unint64_t v299 = v287;
                      unint64_t v204 = v299 + 8;
                      uint64_t v300 = v553;
                      if (v290 != v553)
                      {
                        unint64_t v301 = v290 - 8 - v553;
                        if (v301 < 0x168)
                        {
                          unint64_t v302 = v290;
                          uint64_t v300 = v553;
                          goto LABEL_378;
                        }
                        if (&v298[v291 - 8 - (v301 & 0xFFFFFFFFFFFFFFF8)] > &v298[v291 - 8]
                          || &v290[-(v301 & 0xFFFFFFFFFFFFFFF8) - 8] > v290 - 8
                          || (unint64_t)(v290 - &v298[v291]) < 0x20)
                        {
                          unint64_t v302 = v290;
                          uint64_t v300 = v553;
                          goto LABEL_378;
                        }
                        uint64_t v304 = (v301 >> 3) + 1;
                        unint64_t v302 = &v290[-8 * (v304 & 0x3FFFFFFFFFFFFFFCLL)];
                        int v305 = &v298[8 * v292 - 16];
                        int64_t v306 = (long long *)(v290 - 16);
                        uint64_t v307 = v304 & 0x3FFFFFFFFFFFFFFCLL;
                        uint64_t v300 = v553;
                        do
                        {
                          long long v308 = *v306;
                          *((_OWORD *)v305 - 1) = *(v306 - 1);
                          *(_OWORD *)int v305 = v308;
                          v305 -= 32;
                          v306 -= 2;
                          v307 -= 4;
                        }
                        while (v307);
                        v299 -= 8 * (v304 & 0x3FFFFFFFFFFFFFFCLL);
                        if (v304 != (v304 & 0x3FFFFFFFFFFFFFFCLL))
                        {
                          do
                          {
LABEL_378:
                            uint64_t v303 = *((void *)v302 - 1);
                            v302 -= 8;
                            *((void *)v299 - 1) = v303;
                            v299 -= 8;
                          }
                          while (v302 != v300);
                        }
                      }
                      double v205 = &v298[8 * v296];
                      if (v300) {
                        operator delete(v300);
                      }
                      int v199 = v299;
                      double v206 = v204;
                      uint64_t v195 = a9;
                      uint64_t v242 = v539;
                      uint64_t v245 = v534;
                      goto LABEL_351;
                    }
                    *(void *)double v206 = v287;
                    v206 += 8;
                    unint64_t v204 = v206;
                  }
                }
              }
            }
LABEL_351:
            ++v244;
          }
          while (v244 != v243);
        }
        if ((void *)v242 != v245) {
          goto LABEL_309;
        }
        unint64_t v400 = (uint64_t *)v241[7];
        uint64_t v401 = (uint64_t *)v241[8];
        if (v400 == v401) {
          goto LABEL_309;
        }
        while (1)
        {
          while (1)
          {
            unint64_t v402 = *((unsigned int *)v400 + 1);
            uint64_t v403 = v239[4];
            if (v402 >> 7 < (v239[5] - v403) >> 3)
            {
              uint64_t v404 = *(void *)(v403 + 8 * (v402 >> 7));
              if (v404)
              {
                unint64_t v405 = *(unsigned __int16 *)(v404 + 2 * (v402 & 0x7F));
                uint64_t v407 = v239[7];
                uint64_t v406 = v239[8];
                if (v405 < (v406 - v407) >> 3)
                {
                  uint64_t v408 = v407 + 8 * v405;
                  if (v408 != v406 && *(_DWORD *)(v408 + 4) == v402) {
                    break;
                  }
                }
              }
            }
LABEL_487:
            if (++v400 == v401) {
              goto LABEL_309;
            }
          }
          uint64_t v410 = *v400;
          if (v206 >= v205) {
            break;
          }
          *(void *)double v206 = v410;
          v206 += 8;
          unint64_t v204 = v206;
          if (++v400 == v401) {
            goto LABEL_309;
          }
        }
        uint64_t v411 = v199;
        unint64_t v412 = v206;
        uint64_t v413 = v206 - v199;
        uint64_t v414 = v413 >> 3;
        unint64_t v415 = (v413 >> 3) + 1;
        if (v415 >> 61) {
          goto LABEL_794;
        }
        uint64_t v554 = v411;
        unint64_t v416 = v205 - v411;
        unint64_t v417 = (v205 - v411) >> 2;
        if (v417 > v415) {
          unint64_t v415 = v417;
        }
        if (v416 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v418 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v418 = v415;
        }
        if (v418)
        {
          if (v418 >> 61) {
            goto LABEL_790;
          }
          uint64_t v419 = (char *)operator new(8 * v418);
        }
        else
        {
          uint64_t v419 = 0;
        }
        uint64_t v420 = &v419[8 * v414];
        *(void *)uint64_t v420 = v410;
        unint64_t v204 = v420 + 8;
        unint64_t v421 = v554;
        if (v412 != v554)
        {
          unint64_t v422 = v412 - 8 - v554;
          if (v422 >= 0x168)
          {
            if (&v419[v413 - 8 - (v422 & 0xFFFFFFFFFFFFFFF8)] <= &v419[v413 - 8]
              && &v412[-(v422 & 0xFFFFFFFFFFFFFFF8) - 8] <= v412 - 8
              && (unint64_t)(v412 - &v419[v413]) >= 0x20)
            {
              uint64_t v425 = (v422 >> 3) + 1;
              uint64_t v423 = &v412[-8 * (v425 & 0x3FFFFFFFFFFFFFFCLL)];
              unint64_t v426 = &v419[8 * v414 - 16];
              uint64_t v427 = (long long *)(v412 - 16);
              uint64_t v428 = v425 & 0x3FFFFFFFFFFFFFFCLL;
              unint64_t v421 = v554;
              do
              {
                long long v429 = *v427;
                *((_OWORD *)v426 - 1) = *(v427 - 1);
                *(_OWORD *)unint64_t v426 = v429;
                v426 -= 32;
                v427 -= 2;
                v428 -= 4;
              }
              while (v428);
              v420 -= 8 * (v425 & 0x3FFFFFFFFFFFFFFCLL);
              if (v425 == (v425 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_517;
              }
            }
            else
            {
              uint64_t v423 = v412;
              unint64_t v421 = v554;
            }
          }
          else
          {
            uint64_t v423 = v412;
            unint64_t v421 = v554;
          }
          do
          {
            uint64_t v424 = *((void *)v423 - 1);
            v423 -= 8;
            *((void *)v420 - 1) = v424;
            v420 -= 8;
          }
          while (v423 != v421);
        }
LABEL_517:
        double v205 = &v419[8 * v418];
        if (v421) {
          operator delete(v421);
        }
        int v199 = v420;
        double v206 = v204;
        uint64_t v195 = a9;
        goto LABEL_487;
      }
      while (1)
      {
        while (1)
        {
          unint64_t v251 = *((unsigned int *)v250 + 1);
          uint64_t v252 = v196[4];
          if (v251 >> 7 < (v196[5] - v252) >> 3)
          {
            uint64_t v253 = *(void *)(v252 + 8 * (v251 >> 7));
            if (v253)
            {
              unint64_t v254 = *(unsigned __int16 *)(v253 + 2 * (v251 & 0x7F));
              uint64_t v256 = v196[7];
              uint64_t v255 = v196[8];
              if (v254 < (v255 - v256) >> 3)
              {
                uint64_t v257 = v256 + 8 * v254;
                if (v257 != v255 && *(_DWORD *)(v257 + 4) == v251) {
                  break;
                }
              }
            }
          }
LABEL_314:
          if (++v250 == v249) {
            goto LABEL_295;
          }
        }
        uint64_t v259 = *v250;
        ++v207;
        if (v206 >= v205) {
          break;
        }
        *(void *)double v206 = v259;
        v206 += 8;
        unint64_t v204 = v206;
        if (++v250 == v249) {
          goto LABEL_295;
        }
      }
      uint64_t v260 = v199;
      uint64_t v261 = v206;
      uint64_t v262 = v206 - v199;
      uint64_t v263 = v262 >> 3;
      unint64_t v264 = (v262 >> 3) + 1;
      if (v264 >> 61) {
        abort();
      }
      uint64_t v552 = v260;
      unint64_t v265 = v205 - v260;
      unint64_t v266 = (v205 - v260) >> 2;
      if (v266 > v264) {
        unint64_t v264 = v266;
      }
      if (v265 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v267 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v267 = v264;
      }
      uint64_t v533 = v207;
      if (v267)
      {
        if (v267 >> 61) {
          goto LABEL_790;
        }
        uint64_t v268 = (char *)operator new(8 * v267);
      }
      else
      {
        uint64_t v268 = 0;
      }
      uint64_t v269 = &v268[8 * v263];
      *(void *)uint64_t v269 = v259;
      unint64_t v204 = v269 + 8;
      uint64_t v270 = v552;
      if (v261 != v552)
      {
        unint64_t v271 = v261 - 8 - v552;
        if (v271 >= 0x168)
        {
          if (&v268[v262 - 8 - (v271 & 0xFFFFFFFFFFFFFFF8)] <= &v268[v262 - 8]
            && &v261[-(v271 & 0xFFFFFFFFFFFFFFF8) - 8] <= v261 - 8
            && (unint64_t)(v261 - &v268[v262]) >= 0x20)
          {
            uint64_t v274 = (v271 >> 3) + 1;
            uint64_t v272 = &v261[-8 * (v274 & 0x3FFFFFFFFFFFFFFCLL)];
            unint64_t v275 = &v268[8 * v263 - 16];
            uint64_t v276 = (long long *)(v261 - 16);
            uint64_t v277 = v274 & 0x3FFFFFFFFFFFFFFCLL;
            uint64_t v270 = v552;
            do
            {
              long long v278 = *v276;
              *((_OWORD *)v275 - 1) = *(v276 - 1);
              *(_OWORD *)unint64_t v275 = v278;
              v275 -= 32;
              v276 -= 2;
              v277 -= 4;
            }
            while (v277);
            v269 -= 8 * (v274 & 0x3FFFFFFFFFFFFFFCLL);
            if (v274 == (v274 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_344;
            }
          }
          else
          {
            uint64_t v272 = v261;
            uint64_t v270 = v552;
          }
        }
        else
        {
          uint64_t v272 = v261;
          uint64_t v270 = v552;
        }
        do
        {
          uint64_t v273 = *((void *)v272 - 1);
          v272 -= 8;
          *((void *)v269 - 1) = v273;
          v269 -= 8;
        }
        while (v272 != v270);
      }
LABEL_344:
      double v205 = &v268[8 * v267];
      if (v270) {
        operator delete(v270);
      }
      int v199 = v269;
      double v206 = v204;
      uint64_t v195 = a9;
      uint64_t v207 = v533;
      goto LABEL_314;
    }
    uint64_t v52 = *v30;
    uint64_t v53 = *(void *)(*v30 + 736) - *(void *)(*v30 + 728);
    if (!v53) {
      goto LABEL_203;
    }
    if ((unint64_t)v53 >= 0xF0F0F0F0F0F0F09) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v54 = v53 >> 3;
    v582.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(136 * (v53 >> 3));
    v582.__r_.__value_.__l.__size_ = v582.__r_.__value_.__r.__words[0];
    v582.__r_.__value_.__r.__words[2] = v582.__r_.__value_.__r.__words[0] + 136 * v54;
    uint64_t v55 = *(void *)(v52 + 736) - *(void *)(v52 + 728);
    uint64_t v56 = v55 >> 3;
    unint64_t v57 = (unsigned char *)v26[14];
    if (v55 >> 3 <= (unint64_t)((v26[16] - (uint64_t)v57) >> 2)) {
      goto LABEL_203;
    }
    if (v55 < 0) {
      abort();
    }
    unint64_t v58 = (unsigned char *)v26[15];
    CTFontDescriptorRef v59 = (char *)operator new((unint64_t)v55 >> 1);
    uint64_t v60 = v58 - v57;
    long long v61 = &v59[(v58 - v57) & 0xFFFFFFFFFFFFFFFCLL];
    uint64_t v62 = v61;
    if (v58 != v57)
    {
      if ((unint64_t)(v60 - 4) < 0x2C)
      {
        uint64_t v62 = &v59[(v58 - v57) & 0xFFFFFFFFFFFFFFFCLL];
        do
        {
LABEL_200:
          int v155 = *((_DWORD *)v58 - 1);
          v58 -= 4;
          *((_DWORD *)v62 - 1) = v155;
          v62 -= 4;
        }
        while (v58 != v57);
        goto LABEL_201;
      }
      uint64_t v62 = &v59[(v58 - v57) & 0xFFFFFFFFFFFFFFFCLL];
      if ((unint64_t)(&v58[-(v60 & 0xFFFFFFFFFFFFFFFCLL)] - v59) < 0x20) {
        goto LABEL_200;
      }
      uint64_t v149 = v60 >> 2;
      unint64_t v150 = ((unint64_t)(v60 - 4) >> 2) + 1;
      uint64_t v151 = &v59[4 * v149 - 16];
      long double v152 = (long long *)(v58 - 16);
      uint64_t v153 = v150 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v154 = *v152;
        *((_OWORD *)v151 - 1) = *(v152 - 1);
        *(_OWORD *)uint64_t v151 = v154;
        v151 -= 32;
        v152 -= 2;
        v153 -= 8;
      }
      while (v153);
      uint64_t v62 = &v61[-4 * (v150 & 0x7FFFFFFFFFFFFFF8)];
      v58 -= 4 * (v150 & 0x7FFFFFFFFFFFFFF8);
      if (v150 != (v150 & 0x7FFFFFFFFFFFFFF8)) {
        goto LABEL_200;
      }
    }
LABEL_201:
    v26[14] = (atomic_ullong)v62;
    v26[15] = (atomic_ullong)v61;
    v26[16] = (atomic_ullong)&v59[4 * v56];
    if (v57) {
      operator delete(v57);
    }
LABEL_203:
    uint64_t v156 = *(void *)(v52 + 728);
    unint64_t v80 = v540;
    if (*(void *)(v52 + 736) == v156) {
      goto LABEL_242;
    }
    uint64_t v157 = 0;
    unsigned int v158 = 0;
    while (1)
    {
      unint64_t v160 = *(void *)(v156 + 8 * v157);
      float v161 = (void *)gdc::Registry::storage<md::overlayComponents::VectorOverlay>(v14);
      uint64_t v162 = v161[4];
      if (v160 >> 39 >= (v161[5] - v162) >> 3) {
        goto LABEL_214;
      }
      uint64_t v163 = *(void *)(v162 + 8 * (v160 >> 39));
      if (!v163) {
        goto LABEL_214;
      }
      unint64_t v164 = *(unsigned __int16 *)(v163 + 2 * (HIDWORD(v160) & 0x7F));
      uint64_t v166 = v161[7];
      uint64_t v165 = v161[8];
      if (v164 >= (v165 - v166) >> 3) {
        goto LABEL_214;
      }
      uint64_t v167 = v166 + 8 * v164;
      if (v167 != v165 && *(_DWORD *)(v167 + 4) == HIDWORD(v160))
      {
        uint64_t v169 = v161[11];
        uint64_t v170 = v161[10] + 104 * v164;
      }
      else
      {
LABEL_214:
        uint64_t v169 = v161[11];
        uint64_t v170 = v169;
      }
      unint64_t v171 = &v555->__vftable;
      uint64_t v172 = v170 == v169 ? 0 : (const md::LayoutContext *)v170;
      md::overlayComponents::VectorOverlay::drapingStyle((md::overlayComponents::VectorOverlay *)buf, v172, *(float *)(*(void *)(v546 + 208) + 8), fmaxf(*(float *)(a7 + 3080) + *(float *)(a7 + 3076), 1.0), a8);
      std::vector<md::DrapingLogic::_drapeKeyPair(md::FoundationKey const&,md::OverlayKey const&,std::shared_ptr<md::DaVinciGroundTileData> const&,std::shared_ptr<md::ElevatedStrokeTileData> const&,md::OverlaysContext const&,md::CameraContext const&,md::LayoutContext const&,gdc::Registry *)::DrapingItem,std::allocator<md::DrapingLogic::_drapeKeyPair(md::FoundationKey const&,md::OverlayKey const&,std::shared_ptr<md::DaVinciGroundTileData> const&,std::shared_ptr<md::ElevatedStrokeTileData> const&,md::OverlaysContext const&,md::CameraContext const&,md::LayoutContext const&,gdc::Registry *)::DrapingItem>>::emplace_back<md::overlayComponents::VectorOverlay &,md::DrapingStyle>((void **)&v582.__r_.__value_.__l.__data_, (uint64_t)v172, (long long *)buf);
      uint64_t v174 = (char *)v555[5].__vftable;
      unint64_t v173 = v555[5].__shared_owners_;
      if ((unint64_t)v174 >= v173) {
        break;
      }
      *(_DWORD *)uint64_t v174 = v158;
      int v159 = v174 + 4;
LABEL_206:
      v171[15] = v159;
      uint64_t v156 = *(void *)(v52 + 728);
      uint64_t v157 = ++v158;
      if (v158 >= (unint64_t)((*(void *)(v52 + 736) - v156) >> 3))
      {
        unint64_t v80 = v540;
        a3 = v543;
        goto LABEL_242;
      }
    }
    shared_weak_owners = (char *)v555[4].__shared_weak_owners_;
    uint64_t v176 = (v174 - shared_weak_owners) >> 2;
    unint64_t v177 = v176 + 1;
    if ((unint64_t)(v176 + 1) >> 62) {
      abort();
    }
    uint64_t v178 = v173 - (void)shared_weak_owners;
    if (v178 >> 1 > v177) {
      unint64_t v177 = v178 >> 1;
    }
    if ((unint64_t)v178 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v179 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v179 = v177;
    }
    if (v179)
    {
      if (v179 >> 62) {
        goto LABEL_790;
      }
      unint64_t v180 = operator new(4 * v179);
    }
    else
    {
      unint64_t v180 = 0;
    }
    uint8x8_t v181 = (unsigned int *)&v180[4 * v176];
    *uint8x8_t v181 = v158;
    int v159 = v181 + 1;
    if (v174 == shared_weak_owners)
    {
      unint64_t v171 = &v555->__vftable;
      goto LABEL_238;
    }
    unint64_t v182 = v174 - 4 - shared_weak_owners;
    if (v182 >= 0x2C)
    {
      unint64_t v171 = &v555->__vftable;
      if ((unint64_t)(shared_weak_owners - v180) >= 0x20)
      {
        uint64_t v183 = (v182 >> 2) + 1;
        int v184 = &v180[4 * v176 - 16];
        int v185 = v174 - 16;
        uint64_t v186 = v183 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v187 = *(_OWORD *)v185;
          *(v184 - 1) = *((_OWORD *)v185 - 1);
          *int v184 = v187;
          v184 -= 2;
          v185 -= 32;
          v186 -= 8;
        }
        while (v186);
        v181 -= v183 & 0x7FFFFFFFFFFFFFF8;
        v174 -= 4 * (v183 & 0x7FFFFFFFFFFFFFF8);
        if (v183 == (v183 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_238:
          v171[14] = v181;
          v171[15] = v159;
          v171[16] = &v180[4 * v179];
          if (shared_weak_owners) {
            operator delete(shared_weak_owners);
          }
          goto LABEL_206;
        }
      }
    }
    else
    {
      unint64_t v171 = &v555->__vftable;
    }
    do
    {
      unsigned int v188 = *((_DWORD *)v174 - 1);
      v174 -= 4;
      *--uint8x8_t v181 = v188;
    }
    while (v174 != shared_weak_owners);
    goto LABEL_238;
  }
  uint64_t v17 = v16;
  uint64_t v18 = v16[8];
  uint64_t v19 = *(std::__shared_weak_count **)(v18 + 32);
  if (!v19 || (unint64_t v20 = std::__shared_weak_count::lock(v19)) == 0)
  {
    uint64_t v24 = a5;
    if (!*a4) {
      goto LABEL_143;
    }
LABEL_26:
    if (GEOGetVectorKitElevatedStrokesLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitElevatedStrokesLog_onceToken, &__block_literal_global_49_16498);
    }
    uint64_t v46 = (id)GEOGetVectorKitElevatedStrokesLog_log;
    if (!os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_142;
    }
    uint64_t v558 = *(_WORD *)a2;
    uint64_t v559 = *(void *)(a2 + 4);
    md::debugString<geo::QuadTile>(&v578, (char *)&v558);
    if (SHIBYTE(v579) >= 0) {
      uint64_t v47 = (uint64_t)&v578;
    }
    else {
      uint64_t v47 = v578;
    }
    uint64_t v48 = v17[8];
    unint64_t v49 = *(std::__shared_weak_count **)(v48 + 32);
    if (v49)
    {
      uint64_t v50 = std::__shared_weak_count::lock(v49);
      if (v50)
      {
        uint64_t v51 = *(void *)(v48 + 24);
        goto LABEL_120;
      }
    }
    else
    {
      uint64_t v50 = 0;
    }
    uint64_t v51 = 0;
LABEL_120:
    atomic_ullong v103 = *a4;
    uint64_t v104 = v17[8];
    uint64_t v105 = *(std::__shared_weak_count **)(v104 + 32);
    if (v105)
    {
      unint64_t v106 = std::__shared_weak_count::lock(v105);
      if (v106)
      {
        uint64_t v107 = *(void *)(v104 + 24);
LABEL_125:
        uint64_t v108 = &v582;
        gdc::LayerDataRequestKey::keysInt32Str(&v582, (unsigned __int16 *)(v107 + 16));
        if ((v582.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v108 = (std::string *)v582.__r_.__value_.__r.__words[0];
        }
        gdc::LayerDataRequestKey::keysInt32Str(&__p, (unsigned __int16 *)(*a4 + 16));
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unint64_t v109 = &__p;
        }
        else {
          unint64_t v109 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)long long buf = 136316162;
        *(void *)&uint8_t buf[4] = v47;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v51;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&unsigned char buf[24] = v103;
        *(_WORD *)&unsigned char buf[32] = 2080;
        *(void *)&buf[34] = v108;
        *(_WORD *)&buf[42] = 2080;
        *(void *)&buf[44] = v109;
        _os_log_impl(&dword_1A1780000, v46, OS_LOG_TYPE_DEBUG, "For draping key %s : Mismatch of ground tile data ptrs %p and %p.  Keys are %s, %s", buf, 0x34u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        a3 = v543;
        uint64_t v24 = a5;
        if (SHIBYTE(v582.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v582.__r_.__value_.__l.__data_);
        }
        if (v106 && !atomic_fetch_add(&v106->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
          std::__shared_weak_count::__release_weak(v106);
        }
        if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
          std::__shared_weak_count::__release_weak(v50);
        }
        if (SHIBYTE(v579) < 0) {
          operator delete((void *)v578);
        }
LABEL_142:

        goto LABEL_143;
      }
    }
    else
    {
      unint64_t v106 = 0;
    }
    uint64_t v107 = 0;
    goto LABEL_125;
  }
  uint64_t v21 = v20;
  uint64_t v22 = *(void *)(v18 + 24);
  atomic_ullong v23 = *a4;
  if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v21);
  }
  uint64_t v24 = a5;
  if (v22 != v23) {
    goto LABEL_26;
  }
LABEL_143:
  uint64_t v110 = v17[8];
  unsigned int v111 = *(std::__shared_weak_count **)(v110 + 48);
  if (v111 && (int v112 = std::__shared_weak_count::lock(v111)) != 0)
  {
    int v113 = v112;
    uint64_t v114 = *(void *)(v110 + 40);
    uint64_t v115 = *v24;
    if (atomic_fetch_add(&v112->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      if (v114 == v115) {
        return;
      }
LABEL_149:
      if (GEOGetVectorKitElevatedStrokesLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitElevatedStrokesLog_onceToken, &__block_literal_global_49_16498);
      }
      unint64_t v116 = (id)GEOGetVectorKitElevatedStrokesLog_log;
      if (!os_log_type_enabled(v116, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_185;
      }
      uint64_t v556 = *(_WORD *)a3;
      uint64_t v557 = *(void *)(a3 + 4);
      md::debugString<geo::QuadTile>(&v578, (char *)&v556);
      if (SHIBYTE(v579) >= 0) {
        uint64_t v117 = (uint64_t)&v578;
      }
      else {
        uint64_t v117 = v578;
      }
      uint64_t v118 = v17[8];
      int v119 = *(std::__shared_weak_count **)(v118 + 48);
      if (v119)
      {
        unint64_t v120 = std::__shared_weak_count::lock(v119);
        if (v120)
        {
          uint64_t v121 = *(void *)(v118 + 40);
          goto LABEL_162;
        }
      }
      else
      {
        unint64_t v120 = 0;
      }
      uint64_t v121 = 0;
LABEL_162:
      uint64_t v122 = *a5;
      uint64_t v123 = v17[8];
      unint64_t v124 = *(std::__shared_weak_count **)(v123 + 48);
      if (v124)
      {
        unint64_t v125 = std::__shared_weak_count::lock(v124);
        if (v125)
        {
          uint64_t v126 = *(void *)(v123 + 40);
          goto LABEL_167;
        }
      }
      else
      {
        unint64_t v125 = 0;
      }
      uint64_t v126 = 0;
LABEL_167:
      unint64_t v127 = &v582;
      gdc::LayerDataRequestKey::keysInt32Str(&v582, (unsigned __int16 *)(v126 + 16));
      if ((v582.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        unint64_t v127 = (std::string *)v582.__r_.__value_.__r.__words[0];
      }
      gdc::LayerDataRequestKey::keysInt32Str(&__p, (unsigned __int16 *)(*a5 + 16));
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v128 = &__p;
      }
      else {
        unint64_t v128 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long buf = 136316162;
      *(void *)&uint8_t buf[4] = v117;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v121;
      *(_WORD *)&buf[22] = 2048;
      *(void *)&unsigned char buf[24] = v122;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = v127;
      *(_WORD *)&buf[42] = 2080;
      *(void *)&buf[44] = v128;
      _os_log_impl(&dword_1A1780000, v116, OS_LOG_TYPE_DEBUG, "For draping key %s : Mismatch of overlay tile data ptrs %p and %p.  Keys are %s, %s", buf, 0x34u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v582.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_174:
          if (!v125)
          {
LABEL_180:
            if (v120 && !atomic_fetch_add(&v120->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v120->__on_zero_shared)(v120);
              std::__shared_weak_count::__release_weak(v120);
            }
            if (SHIBYTE(v579) < 0) {
              operator delete((void *)v578);
            }
LABEL_185:

            return;
          }
LABEL_178:
          if (!atomic_fetch_add(&v125->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v125->__on_zero_shared)(v125);
            std::__shared_weak_count::__release_weak(v125);
          }
          goto LABEL_180;
        }
      }
      else if ((SHIBYTE(v582.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_174;
      }
      operator delete(v582.__r_.__value_.__l.__data_);
      if (!v125) {
        goto LABEL_180;
      }
      goto LABEL_178;
    }
    ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
    std::__shared_weak_count::__release_weak(v113);
    if (v114 != v115) {
      goto LABEL_149;
    }
  }
  else if (*v24)
  {
    goto LABEL_149;
  }
}

void sub_1A1C0C320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,std::__shared_weak_count *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32,uint64_t a33,std::__shared_weak_count *a34,uint64_t a35,std::__shared_weak_count *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void *a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  std::vector<md::DrapingLogic::_drapeKeyPair(md::FoundationKey const&,md::OverlayKey const&,std::shared_ptr<md::DaVinciGroundTileData> const&,std::shared_ptr<md::ElevatedStrokeTileData> const&,md::OverlaysContext const&,md::CameraContext const&,md::LayoutContext const&,gdc::Registry *)::DrapingItem,std::allocator<md::DrapingLogic::_drapeKeyPair(md::FoundationKey const&,md::OverlayKey const&,std::shared_ptr<md::DaVinciGroundTileData> const&,std::shared_ptr<md::ElevatedStrokeTileData> const&,md::OverlaysContext const&,md::CameraContext const&,md::LayoutContext const&,gdc::Registry *)::DrapingItem>>::~vector[abi:nn180100](&a65);
  std::__shared_weak_count::__release_weak(a24);
  if (a18) {
    std::__shared_weak_count::__release_weak(a18);
  }
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a68);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<md::OverlayKey,std::shared_ptr<md::DrapingTaskInfo>>,std::__unordered_map_hasher<md::OverlayKey,std::__hash_value_type<md::OverlayKey,std::shared_ptr<md::DrapingTaskInfo>>,md::OverlayKeyHash,std::equal_to<md::OverlayKey>,true>,std::__unordered_map_equal<md::OverlayKey,std::__hash_value_type<md::OverlayKey,std::shared_ptr<md::DrapingTaskInfo>>,std::equal_to<md::OverlayKey>,md::OverlayKeyHash,true>,std::allocator<std::__hash_value_type<md::OverlayKey,std::shared_ptr<md::DrapingTaskInfo>>>>::find<md::OverlayKey>(void *a1, unsigned __int8 *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  unint64_t v4 = (v3
      + ((v2 - 0x61C8864680B583EBLL) << 6)
      + ((unint64_t)(v2 - 0x61C8864680B583EBLL) >> 2)
      - 0x61C8864680B583EBLL) ^ (v2 - 0x61C8864680B583EBLL);
  uint64_t v5 = *((int *)a2 + 1);
  uint64_t v6 = *((int *)a2 + 2);
  unint64_t v7 = (v5 + (v4 << 6) + (v4 >> 2) - 0x61C8864680B583EBLL) ^ v4;
  unint64_t v8 = (v6 + (v7 << 6) + (v7 >> 2) - 0x61C8864680B583EBLL) ^ v7;
  uint64_t v9 = *((unsigned __int16 *)a2 + 12);
  unint64_t v10 = (v9 + (v8 << 6) + (v8 >> 2) - 0x61C8864680B583EBLL) ^ v8;
  uint64_t v11 = *((unsigned int *)a2 + 7);
  unint64_t v12 = (v11 + (v10 << 6) + (v10 >> 2) - 0x61C8864680B583EBLL) ^ v10;
  if (a2[40]) {
    v12 ^= (v12 << 6) - 0x61C8864680B583EBLL + (v12 >> 2) + *((void *)a2 + 4);
  }
  int8x8_t v13 = (int8x8_t)a1[1];
  if (!*(void *)&v13) {
    return 0;
  }
  uint8x8_t v14 = (uint8x8_t)vcnt_s8(v13);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.u32[0] > 1uLL)
  {
    unint64_t v15 = v12;
    if (v12 >= *(void *)&v13) {
      unint64_t v15 = v12 % *(void *)&v13;
    }
  }
  else
  {
    unint64_t v15 = (*(void *)&v13 - 1) & v12;
  }
  unsigned int v16 = *(uint64_t ***)(*a1 + 8 * v15);
  if (!v16) {
    return 0;
  }
  uint64_t v17 = *v16;
  if (!v17) {
    return 0;
  }
  uint64_t v18 = *((void *)a2 + 4);
  if (v14.u32[0] <= 1uLL)
  {
    uint64_t v19 = *(void *)&v13 - 1;
    if (!a2[40])
    {
      while (1)
      {
        uint64_t v22 = v17[1];
        if (v22 == v12)
        {
          if (__PAIR64__(*((unsigned __int8 *)v17 + 17), *((unsigned __int8 *)v17 + 16)) == __PAIR64__(v3, v2)
            && *(uint64_t *)((char *)v17 + 20) == __PAIR64__(v6, v5)
            && __PAIR64__(*((_DWORD *)v17 + 11), *((unsigned __int16 *)v17 + 20)) == __PAIR64__(v11, v9)
            && !*((unsigned char *)v17 + 56))
          {
            return v17;
          }
        }
        else if ((v22 & v19) != v15)
        {
          return 0;
        }
        float result = 0;
        uint64_t v17 = (uint64_t *)*v17;
        if (!v17) {
          return result;
        }
      }
    }
    while (1)
    {
      uint64_t v20 = v17[1];
      if (v20 == v12)
      {
        if (*((unsigned __int8 *)v17 + 16) == v2
          && *((unsigned __int8 *)v17 + 17) == v3
          && *((_DWORD *)v17 + 5) == v5
          && *((_DWORD *)v17 + 6) == v6
          && *((unsigned __int16 *)v17 + 20) == v9
          && *((_DWORD *)v17 + 11) == v11
          && *((unsigned char *)v17 + 56)
          && v17[6] == v18)
        {
          return v17;
        }
      }
      else if ((v20 & v19) != v15)
      {
        return 0;
      }
      uint64_t v17 = (uint64_t *)*v17;
      if (!v17) {
        return 0;
      }
    }
  }
  if (!a2[40])
  {
    while (1)
    {
      unint64_t v24 = v17[1];
      if (v24 == v12)
      {
        if (__PAIR64__(*((unsigned __int8 *)v17 + 17), *((unsigned __int8 *)v17 + 16)) == __PAIR64__(v3, v2)
          && *(uint64_t *)((char *)v17 + 20) == __PAIR64__(v6, v5)
          && __PAIR64__(*((_DWORD *)v17 + 11), *((unsigned __int16 *)v17 + 20)) == __PAIR64__(v11, v9)
          && !*((unsigned char *)v17 + 56))
        {
          return v17;
        }
      }
      else
      {
        if (v24 >= *(void *)&v13) {
          v24 %= *(void *)&v13;
        }
        if (v24 != v15) {
          return 0;
        }
      }
      float result = 0;
      uint64_t v17 = (uint64_t *)*v17;
      if (!v17) {
        return result;
      }
    }
  }
  while (1)
  {
    unint64_t v23 = v17[1];
    if (v23 == v12) {
      break;
    }
    if (v23 >= *(void *)&v13) {
      v23 %= *(void *)&v13;
    }
    if (v23 != v15) {
      return 0;
    }
LABEL_37:
    uint64_t v17 = (uint64_t *)*v17;
    if (!v17) {
      return 0;
    }
  }
  if (*((unsigned __int8 *)v17 + 16) != v2
    || *((unsigned __int8 *)v17 + 17) != v3
    || *((_DWORD *)v17 + 5) != v5
    || *((_DWORD *)v17 + 6) != v6
    || *((unsigned __int16 *)v17 + 20) != v9
    || *((_DWORD *)v17 + 11) != v11
    || !*((unsigned char *)v17 + 56)
    || v17[6] != v18)
  {
    goto LABEL_37;
  }
  return v17;
}

void std::__function::__func<md::DrapingLogic::_drapeKeyPair(md::FoundationKey const&,md::OverlayKey const&,std::shared_ptr<md::DaVinciGroundTileData> const&,std::shared_ptr<md::ElevatedStrokeTileData> const&,md::OverlaysContext const&,md::CameraContext const&,md::LayoutContext const&,gdc::Registry *)::$_0,std::allocator<md::DrapingLogic::_drapeKeyPair(md::FoundationKey const&,md::OverlayKey const&,std::shared_ptr<md::DaVinciGroundTileData> const&,std::shared_ptr<md::ElevatedStrokeTileData> const&,md::OverlaysContext const&,md::CameraContext const&,md::LayoutContext const&,gdc::Registry *)::$_0>,void ()(void)>::destroy_deallocate(void *a1)
{
  std::__function::__alloc_func<md::DrapingLogic::_drapeKeyPair(md::FoundationKey const&,md::OverlayKey const&,std::shared_ptr<md::DaVinciGroundTileData> const&,std::shared_ptr<md::ElevatedStrokeTileData> const&,md::OverlaysContext const&,md::CameraContext const&,md::LayoutContext const&,gdc::Registry *)::$_0,std::allocator<md::DrapingLogic::_drapeKeyPair(md::FoundationKey const&,md::OverlayKey const&,std::shared_ptr<md::DaVinciGroundTileData> const&,std::shared_ptr<md::ElevatedStrokeTileData> const&,md::OverlaysContext const&,md::CameraContext const&,md::LayoutContext const&,gdc::Registry *)::$_0>,void ()(void)>::destroy[abi:nn180100]((uint64_t)a1 + 8);
  operator delete(a1);
}

uint64_t gdc::Registry::storage<md::overlayComponents::Overlayable>(int8x8_t *a1)
{
  uint64_t v10 = 0x41A3BFA74D47A0E8;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x41A3BFA74D47A0E8;
    if (*(void *)&v1 <= 0x41A3BFA74D47A0E8uLL) {
      uint64_t v3 = 0x41A3BFA74D47A0E8uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x41A3BFA74D47A0E8;
  }
  unint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x41A3BFA74D47A0E8)
      {
        if (v5[2] == 0x41A3BFA74D47A0E8) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x41A3BFA74D47A0E8) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x41A3BFA74D47A0E8) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1C0CB50(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_1A1C0DCC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, std::mutex *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46)
{
  _Unwind_Resume(a1);
}

void sub_1A1C0E238(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1C0E570(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *md::LabelSettings::setTrafficEnabled(md::LabelSettings *this, uint64_t a2, unsigned int a3)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a2 + 25) = a3;
  *((unsigned char *)this + 3568) = a3;
  v4[0] = &unk_1EF56E568;
  v4[1] = this;
  v4[2] = a3;
  uint64_t v5 = v4;
  md::LabelManager::queueCommand(this, 14, 1, v4);
  float result = v5;
  if (v5 == v4) {
    return (void *)(*(uint64_t (**)(void *))(v4[0] + 32))(v4);
  }
  if (v5) {
    return (void *)(*(uint64_t (**)(void))(*v5 + 40))();
  }
  return result;
}

void sub_1A1C0EAF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
    _Unwind_Resume(exception_object);
  }
  if (a13) {
    (*(void (**)(void))(*a13 + 40))();
  }
  _Unwind_Resume(exception_object);
}

void sub_1A1C0EE14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1C0F328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  geo::write_lock_guard::~write_lock_guard((pthread_rwlock_t **)va);

  _Unwind_Resume(a1);
}

void gss::ClientStyleState<gss::PropertyID>::setTargetMapDisplayStyle(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = (pthread_rwlock_t *)(a1 + 16);
  uint64_t v20 = a2;
  uint64_t v3 = (geo::read_write_lock *)pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  if (v3) {
    geo::read_write_lock::logFailure(v3, (uint64_t)"write lock", v4);
  }
  gss::DisplayStyle::applyDisplayStyle((unsigned __int8 *)&v20, (uint64_t *)(a1 + 232));
  geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::sort(a1 + 232);
  float v5 = COERCE_FLOAT(atomic_load((unsigned int *)(a1 + 256)));
  LOBYTE(v6) = 1;
  if (v5 <= 0.0)
  {
    unint64_t v6 = *(unsigned __int16 *)(a1 + 242);
    if (v6 != *(unsigned __int16 *)(a1 + 226)) {
      goto LABEL_13;
    }
    if (!*(_WORD *)(a1 + 242)) {
      goto LABEL_14;
    }
    unint64_t v7 = *(_DWORD **)(a1 + 232);
    uint64_t v8 = *(_DWORD **)(a1 + 216);
    if (*v7 == *v8
      && (uint64_t v9 = *(unsigned __int16 *)(a1 + 224),
          uint64_t v10 = *(unsigned __int16 *)(a1 + 240),
          *(unsigned __int16 *)((char *)v7 + v10) == *(unsigned __int16 *)((char *)v8 + v9)))
    {
      unint64_t v11 = 0;
      unint64_t v12 = v7 + 1;
      int8x8_t v13 = v8 + 1;
      uint64_t v14 = (uint64_t)v7 + v10 + 2;
      uint64_t v15 = (uint64_t)v8 + v9 + 2;
      while (v6 - 1 != v11)
      {
        uint64_t v16 = v11++;
        if (v12[v16] != v13[v16]) {
          goto LABEL_20;
        }
        if (*(unsigned __int16 *)(v14 + 2 * v16) != *(unsigned __int16 *)(v15 + 2 * v16))
        {
          unint64_t v11 = v16 + 1;
          goto LABEL_20;
        }
      }
      unint64_t v11 = *(unsigned __int16 *)(a1 + 242);
LABEL_20:
      LOBYTE(v6) = v11 < v6;
    }
    else
    {
LABEL_13:
      LOBYTE(v6) = 1;
    }
  }
LABEL_14:
  atomic_store(v6, (unsigned __int8 *)(a1 + 254));
  atomic_fetch_add((atomic_uint *volatile)(a1 + 248), 1u);
  uint64_t v17 = (geo::read_write_lock *)pthread_rwlock_unlock(v19);
  if (v17)
  {
    geo::read_write_lock::logFailure(v17, (uint64_t)"unlock", v18);
  }
}

void sub_1A1C0F510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, pthread_rwlock_t *a9)
{
}

void sub_1A1C0F5F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void gss::ClientStyleState<gss::ScenePropertyID>::setTargetMapDisplayStyle(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = (pthread_rwlock_t *)(a1 + 16);
  uint64_t v20 = a2;
  uint64_t v3 = (geo::read_write_lock *)pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  if (v3) {
    geo::read_write_lock::logFailure(v3, (uint64_t)"write lock", v4);
  }
  gss::DisplayStyle::applyDisplayStyle((unsigned __int8 *)&v20, (uint64_t *)(a1 + 232));
  geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::sort(a1 + 232);
  float v5 = COERCE_FLOAT(atomic_load((unsigned int *)(a1 + 256)));
  LOBYTE(v6) = 1;
  if (v5 <= 0.0)
  {
    unint64_t v6 = *(unsigned __int16 *)(a1 + 242);
    if (v6 != *(unsigned __int16 *)(a1 + 226)) {
      goto LABEL_13;
    }
    if (!*(_WORD *)(a1 + 242)) {
      goto LABEL_14;
    }
    unint64_t v7 = *(_DWORD **)(a1 + 232);
    uint64_t v8 = *(_DWORD **)(a1 + 216);
    if (*v7 == *v8
      && (uint64_t v9 = *(unsigned __int16 *)(a1 + 224),
          uint64_t v10 = *(unsigned __int16 *)(a1 + 240),
          *(unsigned __int16 *)((char *)v7 + v10) == *(unsigned __int16 *)((char *)v8 + v9)))
    {
      unint64_t v11 = 0;
      unint64_t v12 = v7 + 1;
      int8x8_t v13 = v8 + 1;
      uint64_t v14 = (uint64_t)v7 + v10 + 2;
      uint64_t v15 = (uint64_t)v8 + v9 + 2;
      while (v6 - 1 != v11)
      {
        uint64_t v16 = v11++;
        if (v12[v16] != v13[v16]) {
          goto LABEL_20;
        }
        if (*(unsigned __int16 *)(v14 + 2 * v16) != *(unsigned __int16 *)(v15 + 2 * v16))
        {
          unint64_t v11 = v16 + 1;
          goto LABEL_20;
        }
      }
      unint64_t v11 = *(unsigned __int16 *)(a1 + 242);
LABEL_20:
      LOBYTE(v6) = v11 < v6;
    }
    else
    {
LABEL_13:
      LOBYTE(v6) = 1;
    }
  }
LABEL_14:
  atomic_store(v6, (unsigned __int8 *)(a1 + 254));
  atomic_fetch_add((atomic_uint *volatile)(a1 + 248), 1u);
  uint64_t v17 = (geo::read_write_lock *)pthread_rwlock_unlock(v19);
  if (v17)
  {
    geo::read_write_lock::logFailure(v17, (uint64_t)"unlock", v18);
  }
}

void sub_1A1C0F78C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, pthread_rwlock_t *a9)
{
}

void sub_1A1C0F820(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::StyleLogic::setEmphasis(uint64_t a1, int a2, float a3)
{
  if (*(unsigned __int8 *)(a1 + 164) != a2)
  {
    unint64_t v6 = *(void **)(a1 + 1184);
    if (v6) {
      [v6 stop];
    }
    *(unsigned char *)(a1 + 164) = a2;
    gss::ClientStyleState<gss::PropertyID>::setTargetClientStyleAttribute(*(void *)(a1 + 208), 0x10045u, a2);
    gss::ClientStyleState<gss::ScenePropertyID>::setTargetClientStyleAttribute(*(void *)(a1 + 224), 0x10045u, *(unsigned __int8 *)(a1 + 164));
    if (*(unsigned char *)(a1 + 1116))
    {
      *(float *)(a1 + 1120) = fmaxf(*(float *)(a1 + 1120), a3);
    }
    else
    {
      *(unsigned char *)(a1 + 1116) = 1;
      *(float *)(a1 + 1120) = a3;
      char v10 = 4;
      unint64_t v7 = *(char **)(a1 + 1128);
      uint64_t v8 = *(char **)(a1 + 1136);
      if (v7 != v8)
      {
        while (*v7 <= 3u)
        {
          if (++v7 == v8) {
            goto LABEL_12;
          }
        }
      }
      if (v7 == v8 || (uint64_t v8 = v7, *v7 != 4)) {
LABEL_12:
      }
        std::vector<md::StyleManagerEvent>::insert(a1 + 1128, v8, &v10);
      uint64_t v9 = **(void **)(a1 + 1240);
      if (v9)
      {
        char v11 = 12;
        md::MapEngine::setNeedsTick(v9, &v11);
      }
    }
  }
}

void gss::ClientStyleState<gss::ScenePropertyID>::setTargetClientStyleAttribute(uint64_t a1, unsigned int a2, int a3)
{
  unint64_t v6 = (pthread_rwlock_t *)(a1 + 16);
  double v36 = (pthread_rwlock_t *)(a1 + 16);
  unint64_t v7 = (geo::read_write_lock *)pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  if (v7) {
    geo::read_write_lock::logFailure(v7, (uint64_t)"write lock", v8);
  }
  uint64_t v9 = *(unsigned __int16 *)(a1 + 242);
  if (!*(_WORD *)(a1 + 242)) {
    goto LABEL_31;
  }
  uint64_t v10 = *(void *)(a1 + 232);
  if (*(unsigned char *)(a1 + 247))
  {
    if (v9 >= 0x1E)
    {
      uint64_t v16 = *(_DWORD **)(a1 + 232);
      unint64_t v17 = *(unsigned __int16 *)(a1 + 242);
      do
      {
        unint64_t v18 = v17 >> 1;
        uint64_t v19 = &v16[v17 >> 1];
        unsigned int v21 = *v19;
        uint64_t v20 = v19 + 1;
        v17 += ~(v17 >> 1);
        if (v21 < a2) {
          uint64_t v16 = v20;
        }
        else {
          unint64_t v17 = v18;
        }
      }
      while (v17);
      if (v16 == (_DWORD *)(v10 + 4 * v9)) {
        goto LABEL_31;
      }
      if (*v16 != a2) {
        goto LABEL_31;
      }
      unint64_t v15 = ((unint64_t)v16 - v10) >> 2;
      if (v9 == (unsigned __int16)v15) {
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v11 = 0;
      while (1)
      {
        unsigned int v12 = *(_DWORD *)(v10 + 4 * v11);
        if (v12 >= a2) {
          break;
        }
        if (v9 == ++v11) {
          goto LABEL_31;
        }
      }
      if (v12 == a2) {
        LOWORD(v15) = v11;
      }
      else {
        LOWORD(v15) = *(_WORD *)(a1 + 242);
      }
      if (v9 == (unsigned __int16)v15) {
        goto LABEL_31;
      }
    }
  }
  else
  {
    uint64_t v13 = 4 * v9;
    uint64_t v14 = *(_DWORD **)(a1 + 232);
    while (*v14 != a2)
    {
      ++v14;
      v13 -= 4;
      if (!v13)
      {
        uint64_t v14 = (_DWORD *)(v10 + 4 * v9);
        break;
      }
    }
    unint64_t v15 = ((unint64_t)v14 - v10) >> 2;
    if (v9 == (unsigned __int16)v15) {
      goto LABEL_31;
    }
  }
  if (*(unsigned __int16 *)(*(void *)(a1 + 232) + *(unsigned __int16 *)(a1 + 240) + 2 * (unsigned __int16)v15) == a3) {
    goto LABEL_43;
  }
LABEL_31:
  *(_WORD *)geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[]((uint64_t *)(a1 + 232), a2) = a3;
  geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::sort(a1 + 232);
  float v22 = COERCE_FLOAT(atomic_load((unsigned int *)(a1 + 256)));
  LOBYTE(v23) = 1;
  if (v22 <= 0.0)
  {
    unint64_t v23 = *(unsigned __int16 *)(a1 + 242);
    if (v23 != *(unsigned __int16 *)(a1 + 226))
    {
LABEL_41:
      LOBYTE(v23) = 1;
      goto LABEL_42;
    }
    if (*(_WORD *)(a1 + 242))
    {
      unint64_t v24 = *(_DWORD **)(a1 + 232);
      uint64_t v25 = *(_DWORD **)(a1 + 216);
      if (*v24 == *v25)
      {
        uint64_t v26 = *(unsigned __int16 *)(a1 + 224);
        uint64_t v27 = *(unsigned __int16 *)(a1 + 240);
        if (*(unsigned __int16 *)((char *)v24 + v27) == *(unsigned __int16 *)((char *)v25 + v26))
        {
          unint64_t v28 = 0;
          uint64_t v29 = v24 + 1;
          uint64_t v30 = v25 + 1;
          uint64_t v31 = (uint64_t)v24 + v27 + 2;
          uint64_t v32 = (uint64_t)v25 + v26 + 2;
          while (v23 - 1 != v28)
          {
            uint64_t v33 = v28++;
            if (v29[v33] != v30[v33]) {
              goto LABEL_49;
            }
            if (*(unsigned __int16 *)(v31 + 2 * v33) != *(unsigned __int16 *)(v32 + 2 * v33))
            {
              unint64_t v28 = v33 + 1;
              goto LABEL_49;
            }
          }
          unint64_t v28 = *(unsigned __int16 *)(a1 + 242);
LABEL_49:
          LOBYTE(v23) = v28 < v23;
          goto LABEL_42;
        }
      }
      goto LABEL_41;
    }
  }
LABEL_42:
  atomic_store(v23, (unsigned __int8 *)(a1 + 254));
  atomic_fetch_add((atomic_uint *volatile)(a1 + 248), 1u);
  unint64_t v6 = v36;
LABEL_43:
  double v34 = (geo::read_write_lock *)pthread_rwlock_unlock(v6);
  if (v34)
  {
    geo::read_write_lock::logFailure(v34, (uint64_t)"unlock", v35);
  }
}

void sub_1A1C0FC1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  geo::write_lock_guard::~write_lock_guard((pthread_rwlock_t **)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::LabelManager::setStyleManager(std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&)::$_0,std::allocator<md::LabelManager::setStyleManager(std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(void *)(v1 + 3488))
  {
    md::LabelManager::updateStyleManagerClientStyleAttributes(*(md::LabelManager **)(a1 + 8));
    uint64_t v2 = *(void *)(v1 + 3488);
    uint64_t v3 = *(void *)(v1 + 336);
    if (v2)
    {
      unint64_t v4 = *(std::__shared_weak_count **)(v2 + 24);
      v19[0] = *(void *)(v2 + 16);
      v19[1] = v4;
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      gss::StylesheetManager<gss::PropertyID>::initWithStyleSheet(&v20, v19);
      long long v18 = v20;
      long long v20 = 0uLL;
      if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
      if (!(void)v18) {
        goto LABEL_27;
      }
      uint64_t v5 = *(void *)(v18 + 520);
      unint64_t v6 = *(std::__shared_weak_count **)(v18 + 528);
      if (v6
        && (atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed),
            !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
        if (v5)
        {
LABEL_12:
          uint64_t v7 = *(void *)(v1 + 3488);
          uint64_t v8 = *(void *)(v7 + 520);
          uint64_t v9 = *(std::__shared_weak_count **)(v7 + 528);
          if (v9
            && (atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed),
                !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
          {
            ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
            std::__shared_weak_count::__release_weak(v9);
            if (!v8) {
              goto LABEL_27;
            }
          }
          else if (!v8)
          {
            goto LABEL_27;
          }
          uint64_t v10 = *(void *)(v18 + 520);
          uint64_t v11 = *(std::__shared_weak_count **)(v18 + 528);
          if (v11) {
            atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v12 = *(void *)(v1 + 3488);
          uint64_t v13 = *(void *)(v12 + 520);
          uint64_t v14 = *(std::__shared_weak_count **)(v12 + 528);
          if (v14) {
            atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          gss::ClientStyleState<gss::PropertyID>::setStateWithClientStyleState(v10, v13);
          if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
          if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
LABEL_27:
          std::mutex::lock((std::mutex *)v3);
          std::mutex::lock((std::mutex *)(v3 + 64));
          if (*((void *)&v18 + 1)) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v18 + 1) + 8), 1uLL, memory_order_relaxed);
          }
          unint64_t v15 = *(std::__shared_weak_count **)(v3 + 192);
          *(_OWORD *)(v3 + 184) = v18;
          if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
            std::__shared_weak_count::__release_weak(v15);
          }
          std::mutex::unlock((std::mutex *)(v3 + 64));
          std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::StdAllocator<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,mdm::Allocator>>::clear(v3 + 240);
          std::__list_imp<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,geo::StdAllocator<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,mdm::Allocator>>::clear((uint64_t *)(v3 + 208));
          *(void *)(v3 + 308) = 0;
          *(void *)(v3 + 300) = 0;
          std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::StdAllocator<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,mdm::Allocator>>::clear(v3 + 352);
          std::__list_imp<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,geo::StdAllocator<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,mdm::Allocator>>::clear((uint64_t *)(v3 + 320));
          *(void *)(v3 + 420) = 0;
          *(void *)(v3 + 412) = 0;
          uint64_t v16 = *(std::__shared_weak_count **)(v3 + 456);
          *(void *)(v3 + 448) = 0;
          *(void *)(v3 + 456) = 0;
          if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
          unint64_t v17 = *(std::__shared_weak_count **)(v3 + 472);
          *(void *)(v3 + 464) = 0;
          *(void *)(v3 + 472) = 0;
          if (v17)
          {
            if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
              std::__shared_weak_count::__release_weak(v17);
            }
          }
          std::mutex::unlock((std::mutex *)v3);
          md::LabelStyleContext::initialize(*(md::LabelStyleContext **)(v3 + 136));
        }
      }
      else if (v5)
      {
        goto LABEL_12;
      }
      operator new();
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v1 + 336);
  }
  long long v18 = 0u;
  goto LABEL_27;
}

void sub_1A1C105C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  MEMORY[0x1A6239270](v10, 0x1030C406D3438E8);
  if (a10)
  {
    if (!atomic_fetch_add(&a10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
      _Unwind_Resume(a1);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t gss::ClientStyleState<gss::PropertyID>::setStateWithClientStyleState(uint64_t result, uint64_t a2)
{
  unsigned int v2 = atomic_load((unsigned int *)(result + 248));
  if (v2 != *(_DWORD *)(a2 + 248))
  {
    uint64_t v4 = result;
    *(void *)((char *)&v26 + 7) = 0;
    *(void *)&long long v26 = 0;
    HIBYTE(v26) = 1;
    *(void *)((char *)&v25 + 7) = 0;
    HIBYTE(v25) = 1;
    uint64_t v5 = (pthread_rwlock_t *)(a2 + 16);
    *(void *)&long long v25 = 0;
    unint64_t v6 = (geo::read_write_lock *)pthread_rwlock_rdlock((pthread_rwlock_t *)(a2 + 16));
    if (v6) {
      geo::read_write_lock::logFailure(v6, (uint64_t)"read lock", v7);
    }
    geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator=(&v26, a2 + 216);
    geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator=(&v25, a2 + 232);
    unsigned int v8 = *(_DWORD *)(a2 + 248);
    uint64_t v9 = (geo::read_write_lock *)pthread_rwlock_unlock(v5);
    if (v9) {
      geo::read_write_lock::logFailure(v9, (uint64_t)"unlock", v10);
    }
    uint64_t v11 = (geo::read_write_lock *)pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 16));
    if (v11) {
      geo::read_write_lock::logFailure(v11, (uint64_t)"write lock", v12);
    }
    uint64_t v13 = (void *)(v4 + 216);
    if ((long long *)(v4 + 216) != &v26)
    {
      if (!*(unsigned char *)(v4 + 230) && *v13)
      {
        uint64_t v14 = gss::Allocator::instance(v11);
        uint64_t v11 = (geo::read_write_lock *)(*(uint64_t (**)(uint64_t, void, void))(*(void *)v14 + 40))(v14, *(void *)(v4 + 216), *(unsigned __int16 *)(v4 + 228));
        void *v13 = 0;
      }
      uint64_t v15 = *((void *)&v26 + 1);
      *(void *)(v4 + 216) = v26;
      *(_DWORD *)(v4 + 224) = v15;
      *(_WORD *)(v4 + 228) = WORD2(v15);
      *(_WORD *)(v4 + 230) = HIWORD(v26);
      *(void *)((char *)&v26 + 7) = 0;
      *(void *)&long long v26 = 0;
      HIBYTE(v26) = 1;
    }
    uint64_t v16 = (void *)(v4 + 232);
    if ((long long *)(v4 + 232) != &v25)
    {
      if (!*(unsigned char *)(v4 + 246) && *v16)
      {
        uint64_t v17 = gss::Allocator::instance(v11);
        (*(void (**)(uint64_t, void, void))(*(void *)v17 + 40))(v17, *(void *)(v4 + 232), *(unsigned __int16 *)(v4 + 244));
        *uint64_t v16 = 0;
      }
      uint64_t v18 = *((void *)&v25 + 1);
      *(void *)(v4 + 232) = v25;
      *(_DWORD *)(v4 + 240) = v18;
      *(_WORD *)(v4 + 244) = WORD2(v18);
      *(_WORD *)(v4 + 246) = HIWORD(v25);
      *(void *)((char *)&v25 + 7) = 0;
      *(void *)&long long v25 = 0;
      HIBYTE(v25) = 1;
    }
    atomic_store(v8, (unsigned int *)(v4 + 248));
    uint64_t v19 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 16));
    if (v19) {
      geo::read_write_lock::logFailure(v19, (uint64_t)"unlock", v20);
    }
    unsigned int v21 = atomic_load((unsigned int *)(a2 + 256));
    atomic_store(v21, (unsigned int *)(v4 + 256));
    float v22 = COERCE_FLOAT(atomic_load((unsigned int *)(v4 + 256)));
    float result = v22 > 0.0 || gss::ClientStyleState<gss::PropertyID>::hasTargetStyleAttributes(v4);
    atomic_store(result, (unsigned __int8 *)(v4 + 254));
    if (!BYTE14(v25) && (void)v25)
    {
      uint64_t v23 = gss::Allocator::instance((gss::Allocator *)result);
      float result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v23 + 40))(v23, v25, WORD6(v25));
    }
    if (!BYTE14(v26))
    {
      if ((void)v26)
      {
        uint64_t v24 = gss::Allocator::instance((gss::Allocator *)result);
        return (*(uint64_t (**)(uint64_t, void, void))(*(void *)v24 + 40))(v24, v26, WORD6(v26));
      }
    }
  }
  return result;
}

void sub_1A1C10ABC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, pthread_rwlock_t *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  uint64_t v7 = va_arg(va2, void);
  geo::write_lock_guard::~write_lock_guard((pthread_rwlock_t **)va);
  gss::QueryOverrides::~QueryOverrides((gss::QueryOverrides *)va1);
  gss::QueryOverrides::~QueryOverrides((gss::QueryOverrides *)va2);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::LabelManager::setLocalizeLabels(BOOL)::$_0,std::allocator<md::LabelManager::setLocalizeLabels(BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 336);
  int v4 = *(unsigned __int8 *)(a1 + 16);
  std::mutex::lock((std::mutex *)v3);
  if (*(unsigned __int8 *)(v3 + 156) == v4)
  {
    std::mutex::unlock((std::mutex *)v3);
  }
  else
  {
    *(unsigned char *)(v3 + 156) = v4;
    std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::StdAllocator<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,mdm::Allocator>>::clear(v3 + 240);
    std::__list_imp<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,geo::StdAllocator<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,mdm::Allocator>>::clear((uint64_t *)(v3 + 208));
    *(void *)(v3 + 308) = 0;
    *(void *)(v3 + 300) = 0;
    std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::StdAllocator<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,mdm::Allocator>>::clear(v3 + 352);
    std::__list_imp<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,geo::StdAllocator<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,mdm::Allocator>>::clear((uint64_t *)(v3 + 320));
    *(void *)(v3 + 420) = 0;
    *(void *)(v3 + 412) = 0;
    uint64_t v5 = *(void *)(v3 + 432);
    int v6 = *(unsigned __int8 *)(v3 + 156);
    if (*(unsigned __int8 *)(v5 + 92) != v6)
    {
      *(unsigned char *)(v5 + 92) = v6;
      *(unsigned char *)(v5 + 136) = -1;
      *(unsigned char *)(v5 + 125) = 0;
      uint64_t v7 = *(std::__shared_weak_count **)(v5 + 416);
      *(void *)(v5 + 408) = 0;
      *(void *)(v5 + 416) = 0;
      if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
      unsigned int v8 = *(std::__shared_weak_count **)(v5 + 432);
      *(void *)(v5 + 424) = 0;
      *(void *)(v5 + 432) = 0;
      if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    std::mutex::unlock((std::mutex *)v3);
    atomic_store(*(unsigned char *)(a1 + 16), (unsigned __int8 *)(v2 + 3392));
    md::LabelManager::clearScene(v2, 2);
    uint64_t v9 = *(std::mutex **)(v2 + 288);
    int v10 = *(unsigned __int8 *)(a1 + 16);
    std::mutex::lock(v9);
    uint64_t v11 = &v9[5].__m_.__opaque[40];
    while (1)
    {
      uint64_t v11 = *(char **)v11;
      if (!v11) {
        break;
      }
      uint64_t v12 = *((void *)v11 + 2);
      if (v12) {
        uint64_t v13 = v12 + 8;
      }
      else {
        uint64_t v13 = 0;
      }
      (*(void (**)(void, void, BOOL))(**(void **)(v13 + 8) + 32))(*(void *)(v13 + 8), *(void *)(v13 + 56), v10 != 0);
    }
    uint64_t v14 = &v9[1].__m_.__opaque[16];
    while (1)
    {
      uint64_t v14 = *(char **)v14;
      if (!v14) {
        break;
      }
      uint64_t v15 = *((void *)v14 + 2);
      if (v15) {
        uint64_t v16 = v15 + 8;
      }
      else {
        uint64_t v16 = 0;
      }
      (*(void (**)(void, void, BOOL))(**(void **)(v16 + 8) + 32))(*(void *)(v16 + 8), *(void *)(v16 + 56), v10 != 0);
    }
    opaque = v9[3].__m_.__opaque;
    while (1)
    {
      opaque = *(char **)opaque;
      if (!opaque) {
        break;
      }
      uint64_t v18 = *((void *)opaque + 2);
      if (v18) {
        uint64_t v19 = v18 + 8;
      }
      else {
        uint64_t v19 = 0;
      }
      (*(void (**)(void, void, BOOL))(**(void **)(v19 + 8) + 32))(*(void *)(v19 + 8), *(void *)(v19 + 56), v10 != 0);
    }
    long long v20 = &v9[6].__m_.__opaque[32];
    while (1)
    {
      long long v20 = *(char **)v20;
      if (!v20) {
        break;
      }
      uint64_t v21 = *((void *)v20 + 2);
      if (v21) {
        uint64_t v22 = v21 + 8;
      }
      else {
        uint64_t v22 = 0;
      }
      (*(void (**)(void, void, BOOL))(**(void **)(v22 + 8) + 32))(*(void *)(v22 + 8), *(void *)(v22 + 56), v10 != 0);
    }
    std::mutex::unlock(v9);
    uint64_t v23 = *(unsigned int **)(v2 + 296);
    unsigned int v24 = v23[3];
    BOOL v25 = __CFADD__(v24, 1);
    unsigned int v26 = v24 + 1;
    v23[3] = v26;
    if (v25)
    {
      *(void *)(v23 + 3) = 0x100000002;
      unsigned int v26 = 2;
    }
    v23[4] = v26 - 1;
    atomic_store(v26, v23 + 2);
    uint64_t v27 = *(uint64_t ***)(v2 + 168);
    unint64_t v28 = *v27;
    uint64_t v29 = v27[1];
    if (*v27 != v29)
    {
      do
      {
        uint64_t v30 = *v28++;
        (*(void (**)(uint64_t))(*(void *)v30 + 16))(v30);
      }
      while (v28 != v29);
    }
  }
}

void sub_1A1C10E74(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void md::LabelManager::clearScene(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 3053) && *(unsigned char *)(a1 + 128))
  {
    *(unsigned char *)(a1 + 3053) = 1;
    if (a2)
    {
      if (a2 == 3)
      {
        int v4 = *(unsigned int **)(a1 + 296);
        unsigned int v5 = v4[3];
        BOOL v6 = __CFADD__(v5, 1);
        unsigned int v7 = v5 + 1;
        void v4[3] = v7;
        if (v6)
        {
          *(void *)(v4 + 3) = 0x100000002;
          unsigned int v7 = 2;
        }
        v4[4] = v7 - 1;
        atomic_store(v7, v4 + 2);
      }
    }
    else
    {
      uint64_t v37 = 0;
      unint64_t v38 = 0;
      md::LabelManager::setSelectedLabelMarker(a1, &v37);
    }
    (*(void (**)(void))(**(void **)(a1 + 240) + 272))(*(void *)(a1 + 240));
    unsigned int v8 = *(std::__shared_weak_count **)(a1 + 16);
    uint64_t v37 = *(void *)(a1 + 8);
    if (!v8 || (unint64_t v38 = std::__shared_weak_count::lock(v8)) == 0)
    {
      std::__throw_bad_weak_ptr[abi:nn180100]();
      double v36 = v35;
      std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&v37);
      _Unwind_Resume(v36);
    }
    if (a2 == 1)
    {
      uint64_t v9 = *(void *)(a1 + 336);
      std::mutex::lock((std::mutex *)v9);
      *(_DWORD *)(v9 + 312) = 0;
      uint64_t v10 = *(void *)(v9 + 264);
      if (v10)
      {
        int v11 = 0;
        do
        {
          while (1)
          {
            if (!*(unsigned char *)(v10 + 56))
            {
              uint64_t v12 = *(void *)(v10 + 40);
              if (v12)
              {
                if (*(void *)(v12 + 8) != -1) {
                  break;
                }
              }
            }
            uint64_t v10 = std::__hash_table<std::__hash_value_type<std::shared_ptr<md::LabelImageKey const>,md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::MapEntry>,std::__unordered_map_hasher<std::shared_ptr<md::LabelImageKey const>,std::__hash_value_type<std::shared_ptr<md::LabelImageKey const>,md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::MapEntry>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>,true>,std::__unordered_map_equal<std::shared_ptr<md::LabelImageKey const>,std::__hash_value_type<std::shared_ptr<md::LabelImageKey const>,md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::MapEntry>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,true>,geo::StdAllocator<std::__hash_value_type<std::shared_ptr<md::LabelImageKey const>,md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::MapEntry>,mdm::Allocator>>::erase(v9 + 240, (uint64_t *)v10);
            if (!v10) {
              goto LABEL_44;
            }
          }
          *(void *)(v10 + 48) = v9 + 208;
          uint64_t v10 = *(void *)v10;
          ++v11;
        }
        while (v10);
      }
      else
      {
        int v11 = 0;
      }
LABEL_44:
      *(_DWORD *)(v9 + 308) = v11;
      std::__list_imp<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,geo::StdAllocator<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,mdm::Allocator>>::clear((uint64_t *)(v9 + 208));
      *(_DWORD *)(v9 + 424) = 0;
      uint64_t v24 = *(void *)(v9 + 376);
      if (v24)
      {
        int v25 = 0;
        do
        {
          while (1)
          {
            if (!*(unsigned char *)(v24 + 56))
            {
              uint64_t v26 = *(void *)(v24 + 40);
              if (v26)
              {
                if (*(void *)(v26 + 8) != -1) {
                  break;
                }
              }
            }
            uint64_t v24 = std::__hash_table<std::__hash_value_type<std::shared_ptr<md::LabelImageKey const>,md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::MapEntry>,std::__unordered_map_hasher<std::shared_ptr<md::LabelImageKey const>,std::__hash_value_type<std::shared_ptr<md::LabelImageKey const>,md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::MapEntry>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>,true>,std::__unordered_map_equal<std::shared_ptr<md::LabelImageKey const>,std::__hash_value_type<std::shared_ptr<md::LabelImageKey const>,md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::MapEntry>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,true>,geo::StdAllocator<std::__hash_value_type<std::shared_ptr<md::LabelImageKey const>,md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::MapEntry>,mdm::Allocator>>::erase(v9 + 352, (uint64_t *)v24);
            if (!v24) {
              goto LABEL_53;
            }
          }
          *(void *)(v24 + 48) = v9 + 320;
          uint64_t v24 = *(void *)v24;
          ++v25;
        }
        while (v24);
      }
      else
      {
        int v25 = 0;
      }
LABEL_53:
      *(_DWORD *)(v9 + 420) = v25;
      std::__list_imp<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,geo::StdAllocator<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,mdm::Allocator>>::clear((uint64_t *)(v9 + 320));
      std::mutex::unlock((std::mutex *)v9);
      uint64_t v27 = *(void *)(a1 + 304);
      *(unsigned char *)(v27 + 120) = 1;
      md::FontAtlas::clearCells((md::FontAtlas *)v27);
      *(_DWORD *)(v27 + 116) = 0;
      operator new();
    }
    (*(void (**)(void))(**(void **)(a1 + 240) + 200))(*(void *)(a1 + 240));
    uint64_t v13 = *(void *)(a1 + 336);
    std::mutex::lock((std::mutex *)v13);
    std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::StdAllocator<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,mdm::Allocator>>::clear(v13 + 240);
    std::__list_imp<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,geo::StdAllocator<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,mdm::Allocator>>::clear((uint64_t *)(v13 + 208));
    *(void *)(v13 + 308) = 0;
    *(void *)(v13 + 300) = 0;
    std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::StdAllocator<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,mdm::Allocator>>::clear(v13 + 352);
    std::__list_imp<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,geo::StdAllocator<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,mdm::Allocator>>::clear((uint64_t *)(v13 + 320));
    *(void *)(v13 + 420) = 0;
    *(void *)(v13 + 412) = 0;
    std::mutex::unlock((std::mutex *)v13);
    if (*(void *)(a1 + 416))
    {
      uint64_t v14 = *(void **)(a1 + 400);
      while (v14)
      {
        uint64_t v15 = v14;
        uint64_t v14 = (void *)*v14;
        uint64_t v16 = (std::__shared_weak_count *)v15[3];
        if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
        (*(void (**)(void, void *, uint64_t))(**(void **)(a1 + 408) + 40))(*(void *)(a1 + 408), v15, 32);
      }
      *(void *)(a1 + 400) = 0;
      uint64_t v17 = *(void *)(a1 + 384);
      if (v17)
      {
        for (uint64_t i = 0; i != v17; ++i)
          *(void *)(*(void *)(a1 + 376) + 8 * i) = 0;
      }
      *(void *)(a1 + 416) = 0;
    }
    if (a2 == 2)
    {
      uint64_t v19 = *(void *)(a1 + 264);
      if (*(void *)(v19 + 72))
      {
        long long v20 = *(void **)(v19 + 56);
        while (v20)
        {
          uint64_t v21 = v20;
          long long v20 = (void *)*v20;
          uint64_t v22 = (std::__shared_weak_count *)v21[5];
          if (v22) {
            std::__shared_weak_count::__release_weak(v22);
          }
          uint64_t v23 = (std::__shared_weak_count *)v21[3];
          if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
          (*(void (**)(void, void *, uint64_t))(**(void **)(v19 + 64) + 40))(*(void *)(v19 + 64), v21, 64);
        }
        *(void *)(v19 + 56) = 0;
        uint64_t v28 = *(void *)(v19 + 40);
        if (v28)
        {
          for (uint64_t j = 0; j != v28; ++j)
            *(void *)(*(void *)(v19 + 32) + 8 * j) = 0;
        }
        *(void *)(v19 + 72) = 0;
      }
      std::__list_imp<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,geo::StdAllocator<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,mdm::Allocator>>::clear((uint64_t *)v19);
      *(void *)(v19 + 100) = 0;
      *(void *)(v19 + 92) = 0;
    }
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 240) + 104))(*(void *)(a1 + 240), a2);
    uint64_t v30 = *(void *)(*(void *)(a1 + 336) + 184);
    if (v30) {
      gss::StylesheetManager<gss::PropertyID>::clearCaches(v30);
    }
    *(unsigned char *)(a1 + 3045) = 1;
    *(unsigned char *)(a1 + 3047) = 1;
    unsigned __int8 v31 = atomic_load((unsigned __int8 *)(a1 + 3058));
    if (v31)
    {
      uint64_t v32 = *(void *)(a1 + 136);
      if (v32)
      {
        uint64_t v33 = *(void *)(v32 + 56);
        if (v33)
        {
          uint64_t v40 = a1;
          char v39 = 9;
          (*(void (**)(uint64_t, uint64_t *, char *))(*(void *)v33 + 48))(v33, &v40, &v39);
        }
      }
    }
    *(unsigned char *)(a1 + 3053) = 0;
    double v34 = v38;
    if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
}

void sub_1A1C114C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *std::__list_imp<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,geo::StdAllocator<md::LabelCachingStore<std::shared_ptr<md::LabelImageKey const>,std::shared_ptr<md::LabelIcon>,std::weak_ptr<md::LabelIcon>,md::LabelPtrHash<std::shared_ptr<md::LabelImageKey const>>,md::LabelPtrEqual<std::shared_ptr<md::LabelImageKey const>>>::ListEntry,mdm::Allocator>>::clear(uint64_t *result)
{
  if (result[2])
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    uint64_t v3 = (uint64_t *)result[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*result + 8);
    **(void **)(v2 + 8) = v4;
    result[2] = 0;
    if (v3 != result)
    {
      do
      {
        unsigned int v5 = (uint64_t *)v3[1];
        BOOL v6 = (std::__shared_weak_count *)v3[5];
        if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
          unsigned int v7 = (std::__shared_weak_count *)v3[3];
          if (v7)
          {
LABEL_8:
            if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
              std::__shared_weak_count::__release_weak(v7);
            }
          }
        }
        else
        {
          unsigned int v7 = (std::__shared_weak_count *)v3[3];
          if (v7) {
            goto LABEL_8;
          }
        }
        float result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v1[3] + 40))(v1[3], v3, 48);
        uint64_t v3 = v5;
      }
      while (v5 != v1);
    }
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::StdAllocator<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,md::LabelCachingStore<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::shared_ptr<md::LabelStyle>,std::weak_ptr<md::LabelStyle>,md::LabelPtrHash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,md::LabelPtrEqual<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>>::MapEntry>,mdm::Allocator>>::clear(uint64_t result)
{
  if (*(void *)(result + 40))
  {
    uint64_t v1 = result;
    for (uint64_t i = *(void **)(result + 24);
          i;
          float result = (*(uint64_t (**)(void, void *, uint64_t))(**(void **)(v1 + 32) + 40))(*(void *)(v1 + 32), v3, 64))
    {
      uint64_t v3 = i;
      uint64_t i = (void *)*i;
      uint64_t v4 = (std::__shared_weak_count *)v3[5];
      if (v4) {
        std::__shared_weak_count::__release_weak(v4);
      }
      unsigned int v5 = (std::__shared_weak_count *)v3[3];
      if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    *(void *)(v1 + 24) = 0;
    uint64_t v6 = *(void *)(v1 + 8);
    if (v6)
    {
      for (uint64_t j = 0; j != v6; ++j)
        *(void *)(*(void *)v1 + 8 * j) = 0;
    }
    *(void *)(v1 + 40) = 0;
  }
  return result;
}

uint64_t md::FontGlyphCache::FontGlyphCache(uint64_t this, char a2)
{
  *(void *)this = this;
  *(void *)(this + 8) = this;
  *(void *)(this + 16) = 0;
  uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v20 = this;
    char v15 = a2;
    uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a2 = v15;
    int v6 = v5;
    this = v20;
    if (v6) {
      operator new();
    }
  }
  uint64_t v3 = *((void *)v2 + 91);
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = 0;
  *(void *)(this + 24) = v3;
  {
    uint64_t v21 = this;
    char v16 = a2;
    uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a2 = v16;
    int v8 = v7;
    this = v21;
    if (v8) {
      operator new();
    }
  }
  *(void *)(this + 48) = *((void *)v2 + 91);
  *(void *)(this + 56) = 0;
  {
    uint64_t v22 = this;
    char v17 = a2;
    uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a2 = v17;
    int v10 = v9;
    this = v22;
    if (v10) {
      operator new();
    }
  }
  *(void *)(this + 64) = *((void *)v2 + 91);
  *(void *)(this + 72) = 0;
  *(_DWORD *)(this + 80) = 1065353216;
  *(void *)(this + 88) = 0;
  *(void *)(this + 96) = 0;
  {
    uint64_t v23 = this;
    char v18 = a2;
    uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a2 = v18;
    int v12 = v11;
    this = v23;
    if (v12) {
      operator new();
    }
  }
  *(void *)(this + 104) = *((void *)v2 + 91);
  *(void *)(this + 112) = 0;
  {
    uint64_t v24 = this;
    char v19 = a2;
    uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a2 = v19;
    int v14 = v13;
    this = v24;
    if (v14) {
      operator new();
    }
  }
  *(void *)(this + 120) = *((void *)v2 + 91);
  *(void *)(this + 128) = 0;
  *(_DWORD *)(this + 136) = 1065353216;
  *(void *)(this + 144) = 0;
  *(void *)(this + 152) = 0;
  *(_DWORD *)(this + 160) = 0;
  *(unsigned char *)(this + 164) = a2;
  do
  {
    unsigned int add = atomic_fetch_add(md::FontGlyphCache::FontGlyphCache(BOOL)::nextGlyphCacheStamp, 1u);
    *(_DWORD *)(this + 156) = add + 1;
  }
  while (add == -1);
  return this;
}

uint64_t md::CompositeLabeler::clearScene(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(result + 8);
  for (uint64_t i = *(uint64_t **)(result + 16);
        v2 != i;
        float result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 104))(v5, a2))
  {
    uint64_t v5 = *v2++;
  }
  return result;
}

uint64_t md::MapStandardLabeler::clearScene(uint64_t a1, uint64_t **a2)
{
  int v2 = (int)a2;
  uint64_t result = md::StandardLabeler::clearScene(a1, a2);
  if (v2 != 1)
  {
    if (v2 == 3)
    {
      uint64_t v6 = *(void *)(a1 + 392);
      if (*(void *)(v6 + 128) != *(void *)(v6 + 136)) {
        md::LabelFeatureStyler::styleExternalFeatures(*(unsigned int **)(*(void *)(v6 + 16) + 296), (uint64_t **)(v6 + 128));
      }
      uint64_t v5 = (uint64_t **)(v6 + 240);
      if (*(void *)(v6 + 240) != *(void *)(v6 + 248)) {
        md::LabelFeatureStyler::styleExternalFeatures(*(unsigned int **)(*(void *)(v6 + 16) + 296), v5);
      }
    }
    uint64_t v7 = *(void *)(*(void *)(a1 + 400) + 32);
    if (v7) {
      (*(void (**)(uint64_t, uint64_t **))(*(void *)v7 + 32))(v7, v5);
    }
    operator new();
  }
  uint64_t v8 = *(void *)(a1 + 392);
  if (*(void *)(v8 + 408))
  {
    int v9 = *(void **)(v8 + 392);
    if (v9)
    {
      do
      {
        int v10 = (void *)*v9;
        uint64_t result = (*(uint64_t (**)(void))(**(void **)(v8 + 400) + 40))(*(void *)(v8 + 400));
        int v9 = v10;
      }
      while (v10);
    }
    *(void *)(v8 + 392) = 0;
    uint64_t v11 = *(void *)(v8 + 376);
    if (v11)
    {
      for (uint64_t i = 0; i != v11; ++i)
        *(void *)(*(void *)(v8 + 368) + 8 * i) = 0;
    }
    *(void *)(v8 + 408) = 0;
  }
  return result;
}

uint64_t md::StandardLabeler::clearScene(uint64_t a1, uint64_t **a2)
{
  if (a2)
  {
    if (a2 == 1)
    {
      md::LabelFeaturePool::flushRemovedTiles(*(md::LabelFeaturePool **)(a1 + 64));
      goto LABEL_41;
    }
    if (a2 == 3)
    {
      md::LabelCustomFeatureSupport::updateStylesForFeatures(*(md::LabelCustomFeatureSupport **)(a1 + 32));
      uint64_t v3 = *(uint64_t ***)(a1 + 40);
      a2 = v3 + 1;
      if (v3[1] != v3[2]) {
        md::LabelFeatureStyler::styleExternalFeatures((unsigned int *)(*v3)[37], a2);
      }
    }
    uint64_t v4 = *(void *)(a1 + 48);
    uint64_t v5 = *(void **)(v4 + 224);
    if (v5 != (void *)(v4 + 232))
    {
      do
      {
        uint64_t v6 = v5[6];
        *(unsigned char *)(v6 + 1252) = 0;
        if (!*(unsigned char *)(v6 + 1251)
          || (*(unsigned char *)(v6 + 1251) = 0, md::Label::clearAnimation((md::Label *)v6), !*(unsigned char *)(v6 + 1251)))
        {
          *(_WORD *)(v6 + 1283) = 0;
          *(unsigned char *)(v6 + 1250) = 0;
          *(unsigned char *)(v6 + 1285) = 0;
          uint64_t v7 = *(void *)(v6 + 264);
          *(void *)(v6 + 264) = 0;
          if (v7) {
            (*(void (**)(uint64_t, uint64_t **))(*(void *)v7 + 8))(v7, a2);
          }
          uint64_t v8 = *(void *)(v6 + 272);
          *(void *)(v6 + 272) = 0;
          if (v8) {
            (*(void (**)(uint64_t, uint64_t **))(*(void *)v8 + 8))(v8, a2);
          }
          uint64_t v9 = *(void *)(v6 + 304);
          *(void *)(v6 + 304) = 0;
          if (v9) {
            (*(void (**)(uint64_t, uint64_t **))(*(void *)v9 + 8))(v9, a2);
          }
          if (*(void *)(v6 + 288))
          {
            *(void *)(v6 + 288) = 0;
            *(unsigned char *)(v6 + 1247) = 1;
          }
        }
        int v10 = (void *)v5[1];
        if (v10)
        {
          do
          {
            uint64_t v11 = v10;
            int v10 = (void *)*v10;
          }
          while (v10);
        }
        else
        {
          do
          {
            uint64_t v11 = (void *)v5[2];
            BOOL v12 = *v11 == (void)v5;
            uint64_t v5 = v11;
          }
          while (!v12);
        }
        uint64_t v5 = v11;
      }
      while (v11 != (void *)(v4 + 232));
    }
    *(unsigned char *)(v4 + 758) = 1;
  }
  else
  {
    md::LabelPool::clear(*(int64x2_t **)(a1 + 48));
  }
  uint64_t v13 = *(void *)(a1 + 72);
  for (uint64_t i = *(void *)(a1 + 80); i != v13; i -= 16)
  {
    char v15 = *(std::__shared_weak_count **)(i - 8);
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *, uint64_t **))v15->__on_zero_shared)(v15, a2);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  *(void *)(a1 + 80) = v13;
  uint64_t v16 = *(void *)(a1 + 104);
  for (uint64_t j = *(void *)(a1 + 112); j != v16; j -= 16)
  {
    char v18 = *(std::__shared_weak_count **)(j - 8);
    if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *, uint64_t **))v18->__on_zero_shared)(v18, a2);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  *(void *)(a1 + 112) = v16;
LABEL_41:
  uint64_t v19 = *(void *)(a1 + 48);
  md::LabelPool::pruneCachedLabels(v19);
  return md::LabelPool::pruneCustomFeatureLabels(v19);
}

uint64_t md::LabelPool::pruneCachedLabels(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 192);
  int v2 = (uint64_t *)(this + 200);
  if (v1 != (uint64_t *)(this + 200))
  {
    uint64_t v3 = this;
    do
    {
      uint64_t v4 = v1[7];
      if (!v4 || *(void *)(v4 + 8) == -1)
      {
        uint64_t v8 = (uint64_t *)v1[1];
        uint64_t v9 = v1;
        if (v8)
        {
          do
          {
            uint64_t v6 = v8;
            uint64_t v8 = (uint64_t *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v6 = (uint64_t *)v9[2];
            BOOL v7 = *v6 == (void)v9;
            uint64_t v9 = v6;
          }
          while (!v7);
        }
        if (*(uint64_t **)(v3 + 192) == v1) {
          *(void *)(v3 + 192) = v6;
        }
        --*(void *)(v3 + 216);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v3 + 200), v1);
        int v10 = (std::__shared_weak_count *)v1[7];
        if (v10) {
          std::__shared_weak_count::__release_weak(v10);
        }
        this = (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(v3 + 208) + 40))(*(void *)(v3 + 208), v1, 64);
      }
      else
      {
        uint64_t v5 = (uint64_t *)v1[1];
        if (v5)
        {
          do
          {
            uint64_t v6 = v5;
            uint64_t v5 = (uint64_t *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v6 = (uint64_t *)v1[2];
            BOOL v7 = *v6 == (void)v1;
            uint64_t v1 = v6;
          }
          while (!v7);
        }
      }
      uint64_t v1 = v6;
    }
    while (v6 != v2);
  }
  return this;
}

void md::MapNavLabeler::clearScene(uint64_t a1, int a2)
{
  if (a2 == 3)
  {
    md::RouteLineSupport::restyleFeatures(*(md::RouteLineSupport **)(a1 + 64));
    [*(id *)(a1 + 56) clearSceneIsMemoryWarning:0];
  }
  else
  {
    [*(id *)(a1 + 56) clearSceneIsMemoryWarning:a2 == 1];
    if (a2 == 1) {
      goto LABEL_5;
    }
  }
  md::LabelNavEtaLabeler::clearEtaFeatures(*(md::LabelNavEtaLabeler **)(a1 + 688));
LABEL_5:
  uint64_t v4 = *(void *)(a1 + 592);
  for (uint64_t i = *(void *)(a1 + 584); v4 != i; v4 -= 16)
  {
    uint64_t v6 = *(std::__shared_weak_count **)(v4 - 8);
    if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  *(void *)(a1 + 592) = i;
  uint64_t v7 = *(void *)(a1 + 624);
  for (uint64_t j = *(void *)(a1 + 616); v7 != j; v7 -= 16)
  {
    uint64_t v9 = *(std::__shared_weak_count **)(v7 - 8);
    if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  *(void *)(a1 + 624) = j;
  int v10 = *(void (****)(void))(a1 + 656);
  uint64_t v11 = *(void (****)(void))(a1 + 648);
  if (v10 != v11)
  {
    BOOL v12 = v10 - 3;
    uint64_t v13 = v10 - 3;
    int v14 = v10 - 3;
    do
    {
      char v15 = *v14;
      v14 -= 3;
      (*v15)(v13);
      v12 -= 3;
      BOOL v16 = v13 == v11;
      uint64_t v13 = v14;
    }
    while (!v16);
  }
  *(void *)(a1 + 656) = v11;
  char v17 = *(void **)(a1 + 696);
  char v18 = (void *)*v17;
  if (*(void *)(*v17 + 32))
  {
    uint64_t v19 = (void *)v18[3];
    if (v19)
    {
      do
      {
        uint64_t v20 = (void *)*v19;
        operator delete(v19);
        uint64_t v19 = v20;
      }
      while (v20);
    }
    v18[3] = 0;
    uint64_t v21 = v18[2];
    if (v21)
    {
      for (uint64_t k = 0; k != v21; ++k)
        *(void *)(v18[1] + 8 * k) = 0;
    }
    v18[4] = 0;
  }
  if (v18[8])
  {
    uint64_t v23 = v18 + 6;
    uint64_t v24 = v18[6];
    int v25 = (uint64_t *)v18[7];
    uint64_t v26 = *v25;
    *(void *)(v26 + 8) = *(void *)(v24 + 8);
    **(void **)(v24 + 8) = v26;
    v18[8] = 0;
    if (v25 != v18 + 6)
    {
      do
      {
        uint64_t v27 = (uint64_t *)v25[1];
        v25[3] = (uint64_t)&unk_1EF559778;

        operator delete(v25);
        int v25 = v27;
      }
      while (v27 != v23);
    }
  }
  uint64_t v28 = (void *)v17[1];
  if (v28[4])
  {
    uint64_t v29 = (void *)v28[3];
    if (v29)
    {
      do
      {
        uint64_t v30 = (void *)*v29;
        operator delete(v29);
        uint64_t v29 = v30;
      }
      while (v30);
    }
    v28[3] = 0;
    uint64_t v31 = v28[2];
    if (v31)
    {
      for (uint64_t m = 0; m != v31; ++m)
        *(void *)(v28[1] + 8 * m) = 0;
    }
    v28[4] = 0;
  }
  if (v28[8])
  {
    uint64_t v33 = v28 + 6;
    uint64_t v34 = v28[6];
    double v35 = (uint64_t *)v28[7];
    uint64_t v36 = *v35;
    *(void *)(v36 + 8) = *(void *)(v34 + 8);
    **(void **)(v34 + 8) = v36;
    v28[8] = 0;
    if (v35 != v28 + 6)
    {
      do
      {
        uint64_t v37 = (uint64_t *)v35[1];
        unint64_t v38 = (std::__shared_weak_count *)v35[4];
        if (v38)
        {
          if (!atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
            std::__shared_weak_count::__release_weak(v38);
          }
        }
        operator delete(v35);
        double v35 = v37;
      }
      while (v37 != v33);
    }
  }
}

void md::TransitNodeFeaturePool::resetCache(md::TransitNodeFeaturePool *this)
{
  if (!*((void *)this + 16))
  {
    uint64_t v1 = *((void *)this + 15);
    *((void *)this + 15) = 0;
    *((void *)this + 16) = v1;
  }
  operator new();
}

uint64_t md::LabelNavEtaLabeler::clearEtaFeatures(md::LabelNavEtaLabeler *this)
{
  std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)this + 488, *((void *)this + 62));
  *((void *)this + 64) = 0;
  *((void *)this + 61) = (char *)this + 496;
  *((void *)this + 62) = 0;
  std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)this + 520, *((void *)this + 66));
  *((void *)this + 68) = 0;
  *((void *)this + 65) = (char *)this + 528;
  *((void *)this + 66) = 0;
  std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::destroy((uint64_t)this + 576, *((void *)this + 73));
  *((void *)this + 75) = 0;
  *((void *)this + 72) = (char *)this + 584;
  *((void *)this + 73) = 0;
  std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::destroy((uint64_t)this + 608, *((void *)this + 77));
  *((void *)this + 79) = 0;
  *((void *)this + 76) = (char *)this + 616;
  *((void *)this + 77) = 0;
  std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::destroy((uint64_t)this + 640, *((void *)this + 81));
  *((void *)this + 83) = 0;
  *((void *)this + 80) = (char *)this + 648;
  *((void *)this + 81) = 0;
  std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::destroy((uint64_t)this + 672, *((void *)this + 85));
  *((void *)this + 87) = 0;
  *((void *)this + 84) = (char *)this + 680;
  *((void *)this + 85) = 0;
  std::__tree<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,mdm::Allocator>>::destroy((uint64_t)this + 256, *((void **)this + 33));
  *((void *)this + 35) = 0;
  *((void *)this + 32) = (char *)this + 264;
  *((void *)this + 33) = 0;
  std::__tree<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::__map_value_compare<VKLabelNavRouteEta * {__strong},std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::less<VKLabelNavRouteEta * {__strong}>,true>,geo::StdAllocator<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,mdm::Allocator>>::destroy((uint64_t)this + 352, *((void *)this + 45));
  *((void *)this + 47) = 0;
  *((void *)this + 44) = (char *)this + 360;
  *((void *)this + 45) = 0;
  uint64_t v3 = (void (***)(void))*((void *)this + 19);
  int v2 = (void (***)(void))*((void *)this + 20);
  if (v2 != v3)
  {
    uint64_t v4 = v2 - 3;
    uint64_t v5 = v2 - 3;
    uint64_t v6 = v2 - 3;
    do
    {
      uint64_t v7 = *v6;
      v6 -= 3;
      (*v7)(v5);
      v4 -= 3;
      BOOL v8 = v5 == v3;
      uint64_t v5 = v6;
    }
    while (!v8);
  }
  *((void *)this + 20) = v3;
  uint64_t v9 = *((void *)this + 23);
  for (uint64_t i = *((void *)this + 24); i != v9; i -= 16)
  {
    uint64_t v11 = *(std::__shared_weak_count **)(i - 8);
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  *((void *)this + 24) = v9;
  uint64_t v12 = *((void *)this + 36);
  for (uint64_t j = *((void *)this + 37); j != v12; j -= 8)
  {
    int v14 = *(void **)(j - 8);
  }
  *((void *)this + 37) = v12;
  uint64_t v15 = *((void *)this + 40);
  for (uint64_t k = *((void *)this + 41); k != v15; k -= 8)
  {
    char v17 = *(void **)(k - 8);
  }
  *((void *)this + 41) = v15;
  uint64_t result = std::__tree<std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,std::__map_value_compare<VKRouteInfo * {__strong},std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,std::less<VKRouteInfo * {__strong}>,true>,geo::StdAllocator<std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,mdm::Allocator>>::destroy((uint64_t)this + 416, *((void *)this + 53));
  *((void *)this + 55) = 0;
  *((void *)this + 52) = (char *)this + 424;
  *((void *)this + 53) = 0;
  *((_WORD *)this + 352) = 0;
  *((unsigned char *)this + 706) = 0;
  return result;
}

uint64_t std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::destroy(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::destroy(result, *(void *)a2);
    std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::destroy(v3, *(void *)(a2 + 8));
    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(a2 + 48, *(void *)(a2 + 56));

    uint64_t v4 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v4();
  }
  return result;
}

uint64_t std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,mdm::Allocator>>::destroy(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,mdm::Allocator>>::destroy(result, *(void *)a2);
    std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,mdm::Allocator>>::destroy(v3, *(void *)(a2 + 8));
    uint64_t v4 = *(void *)(a2 + 40);
    if (v4)
    {
      uint64_t v5 = *(void *)(a2 + 48);
      uint64_t v6 = *(void *)(a2 + 40);
      if (v5 != v4)
      {
        do
        {
          std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v5 - 32, *(void *)(v5 - 24));

          uint64_t v7 = *(void **)(v5 - 48);
          v5 -= 48;
        }
        while (v5 != v4);
        uint64_t v6 = *(void *)(a2 + 40);
      }
      *(void *)(a2 + 48) = v4;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 64) + 40))(*(void *)(a2 + 64), v6, *(void *)(a2 + 56) - v6);
    }

    BOOL v8 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v8();
  }
  return result;
}

uint64_t std::__tree<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::__map_value_compare<VKLabelNavRouteEta * {__strong},std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::less<VKLabelNavRouteEta * {__strong}>,true>,geo::StdAllocator<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,mdm::Allocator>>::destroy(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::__map_value_compare<VKLabelNavRouteEta * {__strong},std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::less<VKLabelNavRouteEta * {__strong}>,true>,geo::StdAllocator<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,mdm::Allocator>>::destroy(result, *(void *)a2);
    std::__tree<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::__map_value_compare<VKLabelNavRouteEta * {__strong},std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::less<VKLabelNavRouteEta * {__strong}>,true>,geo::StdAllocator<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,mdm::Allocator>>::destroy(v3, *(void *)(a2 + 8));
    *(void *)(a2 + 40) = off_1EF559858;

    uint64_t v4 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v4();
  }
  return result;
}

uint64_t std::__tree<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,mdm::Allocator>>::destroy(uint64_t result, void *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,mdm::Allocator>>::destroy(result, *a2);
    std::__tree<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,mdm::Allocator>>::destroy(v3, a2[1]);
    std::__destroy_at[abi:nn180100]<std::pair<GEOComposedRoute * const {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,GEOComposedRoute * const {__strong}::_retain_ptr<VKLabelNavRouteEta * {__strong},GEOComposedRoute * const {__strong}::_retain_objc_arc,GEOComposedRoute * const {__strong}::_release_objc_arc,GEOComposedRoute * const {__strong}::_hash_objc,GEOComposedRoute * const {__strong}::_equal_objc>,std::equal_to<md>,std::allocator<std::pair<md,GEOComposedRoute * const {__strong}::_equal_objc>>,std::vector<std::allocator,std::pair<md,GEOComposedRoute * const {__strong}::_equal_objc>>>>,0>((uint64_t)(a2 + 4));
    uint64_t v4 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v4();
  }
  return result;
}

uint64_t std::__tree<std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,std::__map_value_compare<VKRouteInfo * {__strong},std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,std::less<VKRouteInfo * {__strong}>,true>,geo::StdAllocator<std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,mdm::Allocator>>::destroy(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,std::__map_value_compare<VKRouteInfo * {__strong},std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,std::less<VKRouteInfo * {__strong}>,true>,geo::StdAllocator<std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,mdm::Allocator>>::destroy(result, *(void *)a2);
    std::__tree<std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,std::__map_value_compare<VKRouteInfo * {__strong},std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,std::less<VKRouteInfo * {__strong}>,true>,geo::StdAllocator<std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,mdm::Allocator>>::destroy(v3, *(void *)(a2 + 8));

    uint64_t v4 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v4();
  }
  return result;
}

void sub_1A1C130E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,geo::StdAllocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,mdm::Allocator>>::clear(uint64_t result)
{
  if (*(void *)(result + 40))
  {
    uint64_t v1 = result;
    int v2 = *(uint64_t **)(result + 24);
    if (v2)
    {
      do
      {
        uint64_t v3 = (uint64_t *)*v2;
        uint64_t v4 = (std::__shared_weak_count *)v2[7];
        if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
        if (*((char *)v2 + 39) < 0) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[5] + 40))(v2[5], v2[2], v2[4] & 0x7FFFFFFFFFFFFFFFLL);
        }
        uint64_t result = (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(v1 + 32) + 40))(*(void *)(v1 + 32), v2, 64);
        int v2 = v3;
      }
      while (v3);
    }
    *(void *)(v1 + 24) = 0;
    uint64_t v5 = *(void *)(v1 + 8);
    if (v5)
    {
      for (uint64_t i = 0; i != v5; ++i)
        *(void *)(*(void *)v1 + 8 * i) = 0;
    }
    *(void *)(v1 + 40) = 0;
  }
  return result;
}

void md::TransitNodeTextureAtlas::~TransitNodeTextureAtlas(md::TransitNodeTextureAtlas *this)
{
  uint64_t v2 = *((void *)this + 14);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 15);
    uint64_t v4 = (void *)*((void *)this + 14);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 14);
    }
    *((void *)this + 15) = v2;
    operator delete(v4);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 12));
  std::__tree<std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>,std::__map_value_compare<karo::media::C3mmFileIndex,std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>,std::less<karo::media::C3mmFileIndex>,true>,std::allocator<std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>>>::destroy(*((void **)this + 9));
  uint64_t v6 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  *(void *)this = &unk_1EF559798;
}

void md::FontGlyphCache::~FontGlyphCache(md::FontGlyphCache *this)
{
  uint64_t v2 = (void *)*((void *)this + 14);
  if (v2)
  {
    uint64_t v3 = (void *)*((void *)this + 14);
    do
    {
      *(unsigned char *)(v3[2] + 61) = 0;
      uint64_t v3 = (void *)*v3;
    }
    while (v3);
    do
    {
      uint64_t v4 = (void *)*v2;
      (*(void (**)(void))(**((void **)this + 15) + 40))(*((void *)this + 15));
      uint64_t v2 = v4;
    }
    while (v4);
  }
  uint64_t v5 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v5) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 13) + 40))(*((void *)this + 13), v5, 8 * *((void *)this + 12));
  }
  uint64_t v6 = (void *)*((void *)this + 7);
  if (v6)
  {
    do
    {
      uint64_t v7 = (void *)*v6;
      (*(void (**)(void))(**((void **)this + 8) + 40))(*((void *)this + 8));
      uint64_t v6 = v7;
    }
    while (v7);
  }
  uint64_t v8 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v8) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 6) + 40))(*((void *)this + 6), v8, 8 * *((void *)this + 5));
  }
  if (*((void *)this + 2))
  {
    uint64_t v9 = *(void *)this;
    int v10 = (md::FontGlyphCache *)*((void *)this + 1);
    uint64_t v11 = *(void *)v10;
    *(void *)(v11 + 8) = *(void *)(*(void *)this + 8);
    **(void **)(v9 + 8) = v11;
    *((void *)this + 2) = 0;
    if (v10 != this)
    {
      do
      {
        uint64_t v12 = (md::FontGlyphCache *)*((void *)v10 + 1);
        uint64_t v13 = (std::__shared_weak_count *)*((void *)v10 + 5);
        if (v13)
        {
          if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
        (*(void (**)(void, md::FontGlyphCache *, uint64_t))(**((void **)this + 3) + 40))(*((void *)this + 3), v10, 48);
        int v10 = v12;
      }
      while (v12 != this);
    }
  }
}

void non-virtual thunk to'md::LabelCustomFeatureSupport::localizeLabelsDidChange(md::LabelCustomFeatureSupport *this)
{
}

void non-virtual thunk to'md::LabelCustomFeatureSupport::styleManagerDidChange(md::LabelCustomFeatureSupport *this)
{
  uint64_t v1 = (void *)*((void *)this + 8);
  uint64_t v2 = (char *)this + 72;
  if (v1 != (void *)((char *)this + 72))
  {
    do
    {
      md::LabelCustomFeatureProvider::refreshFeatures((md::LabelCustomFeatureProvider *)(v1 + 5));
      uint64_t v3 = (void *)v1[1];
      if (v3)
      {
        do
        {
          uint64_t v4 = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v1[2];
          BOOL v5 = *v4 == (void)v1;
          uint64_t v1 = v4;
        }
        while (!v5);
      }
      uint64_t v1 = v4;
    }
    while (v4 != (void *)v2);
  }
}

void md::LabelCustomFeatureProvider::refreshFeatures(md::LabelCustomFeatureProvider *this)
{
  if (*((unsigned char *)this + 240))
  {
    uint64_t v2 = *((void *)this + 29);
    *(_WORD *)(v2 + 128) = 0;
    uint64_t v3 = *(void *)(v2 + 112);
    if (v3)
    {
      *(void *)(v3 + 8) = 0;
      uint64_t v4 = *(std::__shared_weak_count **)(v2 + 120);
      *(void *)(v2 + 112) = 0;
      *(void *)(v2 + 120) = 0;
      if (v4)
      {
        if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
    }
    BOOL v5 = *(void **)(v2 + 80);
    if (v5)
    {
      *(void *)(v2 + 80) = 0;
    }
    md::LabelCustomFeatureProvider::clearFeatures(this, 1);
  }
  *(unsigned char *)(*(void *)this + 232) = 1;
  md::LabelCustomFeatureProvider::featuresDidChangeForRect((uint64_t)this);
}

void md::LabelCustomFeatureProvider::clearFeatures(md::LabelCustomFeatureProvider *this, char a2)
{
  uint64_t v4 = (char *)*((void *)this + 8);
  BOOL v5 = (char *)this + 72;
  if (v4 != (char *)this + 72)
  {
    do
    {
      v4[176] = 0;
      int v25 = (void *)*((void *)v4 + 20);
      if (v25)
      {
        *((void *)v4 + 20) = 0;
      }
      uint64_t v26 = (char *)*((void *)v4 + 1);
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          uint64_t v26 = *(char **)v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (char *)*((void *)v4 + 2);
          BOOL v28 = *(void *)v27 == (void)v4;
          uint64_t v4 = v27;
        }
        while (!v28);
      }
      uint64_t v4 = v27;
    }
    while (v27 != v5);
  }
  uint64_t v36 = 0;
  HIDWORD(v37) = 0;
  if ((a2 & 1) == 0) {
    goto LABEL_16;
  }
  uint64_t v6 = (void *)*((void *)this + 17);
  if (!v6) {
    goto LABEL_16;
  }
  id v7 = v6;
  uint64_t v8 = (void *)*((void *)this + 26);
  if (!v8) {
    goto LABEL_15;
  }
  uint64_t v9 = (void *)((char *)this + 208);
  do
  {
    unint64_t v10 = v8[4];
    BOOL v11 = v10 >= (unint64_t)v7;
    if (v10 >= (unint64_t)v7) {
      uint64_t v12 = v8;
    }
    else {
      uint64_t v12 = v8 + 1;
    }
    if (v11) {
      uint64_t v9 = v8;
    }
    uint64_t v8 = (void *)*v12;
  }
  while (*v12);
  if (v9 == (void *)((char *)this + 208) || (unint64_t)v7 < v9[4])
  {
LABEL_15:

LABEL_16:
    uint64_t v13 = (void *)*((void *)this + 17);
    if (v13)
    {
      *((void *)this + 17) = 0;
    }
    int v14 = 0;
    uint64_t v15 = 0;
    LODWORD(v16) = 0;
    char v17 = 0;
    goto LABEL_19;
  }

  uint64_t v15 = v9[5];
  int v14 = (std::__shared_weak_count *)v9[6];
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v36 = v14;
  unint64_t v35 = v9[7];
  HIDWORD(v37) = HIDWORD(v35);
  std::__tree<std::__value_type<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},md::LabelCustomFeatureProvider::FeatureInfo>,std::__map_value_compare<objc_object  {objcproto25VKCustomFeatureAnnotation}*,md::LabelCustomFeatureProvider::FeatureInfo,std::less<objc_object  {objcproto25VKCustomFeatureAnnotation}*>,true>,geo::StdAllocator<md::LabelCustomFeatureProvider::FeatureInfo,mdm::Allocator>>::erase((uint64_t)this + 200, (uint64_t)v9);
  unint64_t v16 = HIDWORD(v35);
  char v17 = 1;
LABEL_19:
  char v18 = (void **)((char *)this + 200);
  uint64_t v19 = (uint64_t *)*((void *)this + 25);
  uint64_t v20 = (uint64_t **)((char *)this + 208);
  if (v19 != (uint64_t *)((char *)this + 208))
  {
    do
    {
      (*(void (**)(uint64_t))(*(void *)v19[5] + 88))(v19[5]);
      uint64_t v29 = (uint64_t *)v19[1];
      if (v29)
      {
        do
        {
          uint64_t v30 = (uint64_t **)v29;
          uint64_t v29 = (uint64_t *)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          uint64_t v30 = (uint64_t **)v19[2];
          BOOL v28 = *v30 == v19;
          uint64_t v19 = (uint64_t *)v30;
        }
        while (!v28);
      }
      uint64_t v19 = (uint64_t *)v30;
    }
    while (v30 != v20);
  }
  std::__tree<std::__value_type<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},md::LabelCustomFeatureProvider::FeatureInfo>,std::__map_value_compare<objc_object  {objcproto25VKCustomFeatureAnnotation}*,md::LabelCustomFeatureProvider::FeatureInfo,std::less<objc_object  {objcproto25VKCustomFeatureAnnotation}*>,true>,geo::StdAllocator<md::LabelCustomFeatureProvider::FeatureInfo,mdm::Allocator>>::destroy((uint64_t)this + 200, *((void *)this + 26));
  *((void *)this + 28) = 0;
  *((void *)this + 25) = v20;
  *((void *)this + 26) = 0;
  if ((v17 & 1) == 0)
  {
LABEL_49:
    if (!v14) {
      return;
    }
    goto LABEL_50;
  }
  LODWORD(v37) = v16;
  id v21 = *((id *)this + 17);
  uint64_t v22 = (uint64_t)v21;
  uint64_t v23 = (uint64_t *)*((void *)this + 26);
  uint64_t v24 = (uint64_t **)((char *)this + 208);
  if (!v23)
  {
LABEL_44:
    uint64_t v32 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 27) + 16))(*((void *)this + 27), 64, 8);
    uint64_t v33 = v32;
    v32[4] = v22;
    v32[5] = v15;
    v32[6] = (uint64_t)v14;
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v32[7] = v37;
    *uint64_t v32 = 0;
    v32[1] = 0;
    v32[2] = (uint64_t)v24;
    *uint64_t v20 = v32;
    uint64_t v34 = (void *)**v18;
    if (v34)
    {
      *char v18 = v34;
      uint64_t v33 = *v20;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 26), v33);
    ++*((void *)this + 28);
    int v14 = v36;
    goto LABEL_49;
  }
  while (1)
  {
    while (1)
    {
      uint64_t v24 = (uint64_t **)v23;
      unint64_t v31 = v23[4];
      if ((unint64_t)v21 >= v31) {
        break;
      }
      uint64_t v23 = *v24;
      uint64_t v20 = v24;
      if (!*v24) {
        goto LABEL_44;
      }
    }
    if (v31 >= (unint64_t)v21) {
      break;
    }
    uint64_t v23 = v24[1];
    if (!v23)
    {
      uint64_t v20 = v24 + 1;
      goto LABEL_44;
    }
  }

  if (v14)
  {
LABEL_50:
    if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void sub_1A1C139F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},md::LabelCustomFeatureProvider::FeatureInfo>,std::__map_value_compare<objc_object  {objcproto25VKCustomFeatureAnnotation}*,md::LabelCustomFeatureProvider::FeatureInfo,std::less<objc_object  {objcproto25VKCustomFeatureAnnotation}*>,true>,geo::StdAllocator<md::LabelCustomFeatureProvider::FeatureInfo,mdm::Allocator>>::destroy(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},md::LabelCustomFeatureProvider::FeatureInfo>,std::__map_value_compare<objc_object  {objcproto25VKCustomFeatureAnnotation}*,md::LabelCustomFeatureProvider::FeatureInfo,std::less<objc_object  {objcproto25VKCustomFeatureAnnotation}*>,true>,geo::StdAllocator<md::LabelCustomFeatureProvider::FeatureInfo,mdm::Allocator>>::destroy(result, *(void *)a2);
    std::__tree<std::__value_type<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},md::LabelCustomFeatureProvider::FeatureInfo>,std::__map_value_compare<objc_object  {objcproto25VKCustomFeatureAnnotation}*,md::LabelCustomFeatureProvider::FeatureInfo,std::less<objc_object  {objcproto25VKCustomFeatureAnnotation}*>,true>,geo::StdAllocator<md::LabelCustomFeatureProvider::FeatureInfo,mdm::Allocator>>::destroy(v3, *(void *)(a2 + 8));
    uint64_t v4 = *(std::__shared_weak_count **)(a2 + 48);
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }

    BOOL v5 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v5();
  }
  return result;
}

void non-virtual thunk to'md::LabelTransitSupport::localizeLabelsDidChange(md::LabelTransitSupport *this)
{
  uint64_t v2 = (uint64_t **)((char *)this + 120);
  if (*((void *)this + 15) != *((void *)this + 16))
  {
    uint64_t v3 = *(unsigned int **)(*((void *)this + 1) + 296);
    unsigned __int8 v4 = atomic_load((unsigned __int8 *)(*(void *)v3 + 3392));
    BOOL v5 = (uint64_t *)*((void *)this + 15);
    uint64_t v6 = (uint64_t *)*((void *)this + 16);
    if (v5 != v6)
    {
      uint64_t v7 = v4 & 1;
      do
      {
        uint64_t v8 = *v5;
        v5 += 2;
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)v8 + 32))(v8, 0, v7);
      }
      while (v5 != v6);
    }
    md::LabelFeatureStyler::styleExternalFeatures(v3, v2);
  }
  if (*((void *)this + 29) != *((void *)this + 30))
  {
    uint64_t v9 = *(unsigned int **)(*((void *)this + 1) + 296);
    unsigned __int8 v10 = atomic_load((unsigned __int8 *)(*(void *)v9 + 3392));
    uint64_t v11 = *((void *)this + 30) - *((void *)this + 29);
    if (v11)
    {
      uint64_t v12 = 0;
      unint64_t v13 = v11 >> 4;
      if (v13 <= 1) {
        uint64_t v14 = 1;
      }
      else {
        uint64_t v14 = v13;
      }
      uint64_t v15 = v10 & 1;
      do
      {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(*((void *)this + 29) + v12) + 40))(*(void *)(*((void *)this + 29) + v12), *((void *)this + 26) + v12, v15);
        v12 += 16;
        --v14;
      }
      while (v14);
    }
    md::LabelFeatureStyler::styleExternalFeatures(v9, (uint64_t **)this + 29);
  }
}

void non-virtual thunk to'md::MapNavLabeler::styleManagerDidChange(md::MapNavLabeler *this)
{
  uint64_t v2 = (void *)*((void *)this + 5);
  uint64_t v3 = *(void *)(*((void *)this + 1) + 336);
  uint64_t v5 = *(void *)(v3 + 184);
  unsigned __int8 v4 = *(std::__shared_weak_count **)(v3 + 192);
  uint64_t v7 = v5;
  uint64_t v8 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  [v2 setStyleManager:&v7];
  uint64_t v6 = v8;
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  *((unsigned char *)this + 810) = 1;
}

void sub_1A1C13CF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    if (!atomic_fetch_add(&a10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

void md::FontAtlas::clearCells(md::FontAtlas *this)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 2);
  uint64_t v3 = (uint64_t *)*((void *)this + 3);
  if (v2 != v3)
  {
    do
    {
      for (uint64_t i = 0; i != 1536; i += 48)
      {
        uint64_t v5 = *v2;
        uint64_t v6 = (void *)(*v2 + i);
        uint64_t v7 = v6[1];
        if (v7) {
          *(void *)(v7 + 96) = 0;
        }
        uint64_t v8 = v6[4];
        if (v8)
        {
          (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
          uint64_t v9 = *(std::__shared_weak_count **)(v5 + i + 40);
          v6[4] = 0;
          v6[5] = 0;
          if (v9)
          {
            if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
              std::__shared_weak_count::__release_weak(v9);
            }
          }
        }
      }
      ++v2;
    }
    while (v2 != v3);
    unsigned __int8 v10 = (uint64_t *)*((void *)this + 2);
    uint64_t v2 = (uint64_t *)*((void *)this + 3);
    if (v2 != v10)
    {
      do
      {
        uint64_t v12 = *--v2;
        uint64_t v11 = v12;
        *uint64_t v2 = 0;
        if (v12)
        {
          uint64_t v15 = *(void *)(v11 - 8);
          uint64_t v14 = v11 - 8;
          uint64_t v13 = v15;
          if (v15)
          {
            uint64_t v16 = 48 * v13;
            do
            {
              char v17 = *(std::__shared_weak_count **)(v14 + v16);
              if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
                std::__shared_weak_count::__release_weak(v17);
              }
              v16 -= 48;
            }
            while (v16);
          }
          MEMORY[0x1A6239250](v14 - 8, 0x1020C80D08A26EBLL);
        }
      }
      while (v2 != v10);
      uint64_t v2 = v10;
    }
  }
  *((void *)this + 3) = v2;
  *((void *)this + 7) = *((void *)this + 6);
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  char v18 = (void *)*((void *)this + 17);
  uint64_t v19 = *((void *)this + 18) - (void)v18;
  if (v19 >= 1)
  {
    bzero(v18, 4 * (((unint64_t)v19 >> 2) - ((unint64_t)v19 > 3)) + 4);
  }
}

void md::LabelCustomFeatureSupport::localizeLabelsDidChange(md::LabelCustomFeatureSupport *this)
{
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  {
    operator new();
  }
  uint64_t v17 = mdm::Allocator::instance(void)::alloc;
  uint64_t v2 = (md::LabelCustomFeatureSupport *)*((void *)this + 9);
  if (v2 != (md::LabelCustomFeatureSupport *)((char *)this + 80))
  {
    do
    {
      md::LabelCustomFeatureProvider::populateAllLabelFeatures((void *)v2 + 5, &v14);
      uint64_t v3 = (md::LabelCustomFeatureSupport *)*((void *)v2 + 1);
      if (v3)
      {
        do
        {
          unsigned __int8 v4 = v3;
          uint64_t v3 = *(md::LabelCustomFeatureSupport **)v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          unsigned __int8 v4 = (md::LabelCustomFeatureSupport *)*((void *)v2 + 2);
          BOOL v5 = *(void *)v4 == (void)v2;
          uint64_t v2 = v4;
        }
        while (!v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != (md::LabelCustomFeatureSupport *)((char *)this + 80));
    uint64_t v6 = v14;
    if (v14 == v15)
    {
      uint64_t v9 = v14;
      if (!v14) {
        return;
      }
    }
    else
    {
      uint64_t v7 = *(unsigned int **)(*((void *)this + 2) + 296);
      unsigned __int8 v8 = atomic_load((unsigned __int8 *)(*(void *)v7 + 3392));
      uint64_t v9 = v14;
      uint64_t v6 = v15;
      uint64_t v10 = v8 & 1;
      uint64_t v11 = v14;
      do
      {
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)*v11 + 32))(*v11, 0, v10);
        v11 += 2;
      }
      while (v11 != v6);
      md::LabelFeatureStyler::styleExternalFeatures(v7, &v14);
      if (!v9) {
        return;
      }
    }
    for (; v6 != v9; v6 -= 2)
    {
      uint64_t v12 = (std::__shared_weak_count *)*(v6 - 1);
      if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    uint64_t v13 = *(void (**)(void))(*(void *)v17 + 40);
    v13();
  }
}

void sub_1A1C1419C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void md::LabelStyleContext::initialize(md::LabelStyleContext *a1)
{
}

uint64_t md::LabelWorldTraits::styleManagerDidChange(uint64_t this)
{
  if (*(unsigned char *)(this + 16) == 2)
  {
    uint64_t v1 = this;
    this = md::LabelSettingsStyleCache::muninPointStyle(*(md::LabelSettingsStyleCache **)(*(void *)(*(void *)(this + 8) + 336)
                                                                                        + 200));
    float v2 = *(float *)(this + 40);
    if (v2 == 0.0) {
      float v2 = 400.0;
    }
    if (*(float *)(v1 + 44) != v2)
    {
      *(float *)(v1 + 44) = v2;
      uint64_t v3 = *(uint64_t ***)(*(void *)(v1 + 8) + 168);
      unsigned __int8 v4 = *v3;
      BOOL v5 = v3[1];
      if (*v3 != v5)
      {
        do
        {
          uint64_t v6 = *v4++;
          this = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 40))(v6);
        }
        while (v4 != v5);
      }
    }
  }
  return this;
}

void md::LabelManager::setSelectedLabelMarker(uint64_t a1, uint64_t *a2)
{
  if (*(void *)(a1 + 3400) != *a2)
  {
    if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
    }
    unsigned __int8 v4 = (uint64_t *)(a1 + 3400);
    BOOL v5 = (id)GEOGetVectorKitPerformanceLog_log;
    if (os_signpost_enabled(v5))
    {
      LOWORD(v18) = 0;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v5, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LabelsSelectLabel", "", (uint8_t *)&v18, 2u);
    }

    if (*v4)
    {
      uint64_t v6 = *(void *)(a1 + 240);
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 176))(v6, &v18);
      uint64_t v7 = v19;
      if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
      uint64_t v8 = *(void *)(a1 + 136);
      if (v8)
      {
        uint64_t v9 = *(void *)(v8 + 184);
        if (v9)
        {
          uint64_t v18 = a1;
          (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v9 + 48))(v9, &v18, a1 + 3400);
        }
      }
    }
    uint64_t v10 = *a2;
    uint64_t v11 = a2[1];
    if (v11) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)(a1 + 3400) = v10;
    uint64_t v12 = *(std::__shared_weak_count **)(a1 + 3408);
    *(void *)(a1 + 3408) = v11;
    if (v12)
    {
      if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
      uint64_t v10 = *v4;
    }
    if (v10)
    {
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 240) + 176))(*(void *)(a1 + 240), a1 + 3400);
      uint64_t v13 = *(void *)(a1 + 136);
      if (v13)
      {
        uint64_t v14 = *(void *)(v13 + 184);
        if (v14)
        {
          uint64_t v18 = a1;
          (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v14 + 48))(v14, &v18, a1 + 3400);
        }
      }
      *(void *)(a1 + 3424) = *(void *)(a1 + 3288);
      *(unsigned char *)(a1 + 3416) = 1;
    }
    *(unsigned char *)(a1 + 3380) = 1;
    *(unsigned char *)(a1 + 3043) = 1;
    *(unsigned char *)(a1 + 3045) = 1;
    *(unsigned char *)(a1 + 3047) = 1;
    unsigned __int8 v15 = atomic_load((unsigned __int8 *)(a1 + 3058));
    if (v15)
    {
      uint64_t v16 = *(void *)(a1 + 136);
      if (v16)
      {
        uint64_t v17 = *(void *)(v16 + 56);
        if (v17)
        {
          uint64_t v18 = a1;
          char v20 = 9;
          (*(void (**)(uint64_t, uint64_t *, char *))(*(void *)v17 + 48))(v17, &v18, &v20);
        }
      }
    }
  }
}

void sub_1A1C14910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t ___registerStateCaptureCallbacks_block_invoke()
{
  _stateCaptureCallbackRegistration = 1;
  return MEMORY[0x1F411C598](0, _getConfigStoreStringKeysForStateCapture);
}

unint64_t *ggl::FragmentedPool<ggl::GlyphWithNormalHalo::DefaultPipelineSetup>::FragmentedPool(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  {
    operator new();
  }
  uint64_t v6 = ggl::Allocator::instance(void)::alloc;
  a1[4] = 0;
  a1[3] = v6;
  a1[5] = 0;
  a1[6] = 0;
  {
    operator new();
  }
  a1[7] = ggl::Allocator::instance(void)::alloc;
  uint64_t v7 = *(void *)(a2 + 24);
  if (!v7) {
    goto LABEL_6;
  }
  if (v7 != a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
LABEL_6:
    a1[11] = v7;
    goto LABEL_8;
  }
  a1[11] = (unint64_t)(a1 + 8);
  (*(void (**)(void, unint64_t *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1 + 8);
LABEL_8:
  uint64_t v8 = *(void *)(a3 + 24);
  if (!v8)
  {
LABEL_11:
    a1[15] = v8;
    goto LABEL_13;
  }
  if (v8 != a3)
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
    goto LABEL_11;
  }
  a1[15] = (unint64_t)(a1 + 12);
  (*(void (**)(void, unint64_t *))(**(void **)(a3 + 24) + 24))(*(void *)(a3 + 24), a1 + 12);
LABEL_13:
  a1[16] = 2000;
  unint64_t v9 = *a1;
  if (a1[2] - *a1 > 0x31F) {
    goto LABEL_26;
  }
  unint64_t v10 = a1[1];
  uint64_t v11 = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 800, 8);
  uint64_t v12 = v10 - v9;
  unint64_t v13 = v11 + ((v10 - v9) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v15 = *a1;
  unint64_t v14 = a1[1];
  unint64_t v16 = v14 - *a1;
  if (v14 == *a1)
  {
    unint64_t v18 = v11 + ((v10 - v9) & 0xFFFFFFFFFFFFFFF8);
    goto LABEL_24;
  }
  unint64_t v17 = v16 - 8;
  if (v16 - 8 >= 0x58)
  {
    unint64_t v18 = v11 + ((v10 - v9) & 0xFFFFFFFFFFFFFFF8);
    if (v14 - (v12 & 0xFFFFFFFFFFFFFFF8) - v11 >= 0x20)
    {
      uint64_t v19 = v12 >> 3;
      uint64_t v20 = (v17 >> 3) + 1;
      id v21 = (_OWORD *)(v11 + 8 * v19 - 16);
      uint64_t v22 = (long long *)(v14 - 16);
      uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v24 = *v22;
        *(v21 - 1) = *(v22 - 1);
        *id v21 = v24;
        v21 -= 2;
        v22 -= 2;
        v23 -= 4;
      }
      while (v23);
      unint64_t v18 = v13 - 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
      v14 -= 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
      if (v20 == (v20 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    unint64_t v18 = v11 + ((v10 - v9) & 0xFFFFFFFFFFFFFFF8);
  }
  do
  {
    uint64_t v25 = *(void *)(v14 - 8);
    v14 -= 8;
    *(void *)(v18 - 8) = v25;
    v18 -= 8;
  }
  while (v14 != v15);
LABEL_23:
  unint64_t v14 = *a1;
LABEL_24:
  *a1 = v18;
  a1[1] = v13;
  unint64_t v26 = a1[2];
  a1[2] = v11 + 800;
  if (v14) {
    (*(void (**)(unint64_t, unint64_t, unint64_t))(*(void *)a1[3] + 40))(a1[3], v14, v26 - v14);
  }
LABEL_26:
  unint64_t v27 = a1[4];
  if (a1[6] - v27 > 0x31F) {
    return a1;
  }
  unint64_t v28 = a1[5];
  uint64_t v29 = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)a1[7] + 16))(a1[7], 800, 8);
  uint64_t v30 = v28 - v27;
  unint64_t v31 = v29 + ((v28 - v27) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v33 = a1[4];
  unint64_t v32 = a1[5];
  unint64_t v34 = v32 - v33;
  if (v32 == v33)
  {
    unint64_t v36 = v29 + ((v28 - v27) & 0xFFFFFFFFFFFFFFF8);
    goto LABEL_37;
  }
  unint64_t v35 = v34 - 8;
  if (v34 - 8 >= 0x58)
  {
    unint64_t v36 = v29 + ((v28 - v27) & 0xFFFFFFFFFFFFFFF8);
    if (v32 - (v30 & 0xFFFFFFFFFFFFFFF8) - v29 >= 0x20)
    {
      uint64_t v37 = v30 >> 3;
      uint64_t v38 = (v35 >> 3) + 1;
      char v39 = (_OWORD *)(v29 + 8 * v37 - 16);
      uint64_t v40 = (long long *)(v32 - 16);
      uint64_t v41 = v38 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v42 = *v40;
        *(v39 - 1) = *(v40 - 1);
        _OWORD *v39 = v42;
        v39 -= 2;
        v40 -= 2;
        v41 -= 4;
      }
      while (v41);
      unint64_t v36 = v31 - 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
      v32 -= 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
      if (v38 == (v38 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_36;
      }
    }
  }
  else
  {
    unint64_t v36 = v29 + ((v28 - v27) & 0xFFFFFFFFFFFFFFF8);
  }
  do
  {
    uint64_t v43 = *(void *)(v32 - 8);
    v32 -= 8;
    *(void *)(v36 - 8) = v43;
    v36 -= 8;
  }
  while (v32 != v33);
LABEL_36:
  unint64_t v32 = a1[4];
LABEL_37:
  a1[4] = v36;
  a1[5] = v31;
  unint64_t v44 = a1[6];
  a1[6] = v29 + 800;
  if (v32) {
    (*(void (**)(unint64_t, unint64_t, unint64_t))(*(void *)a1[7] + 40))(a1[7], v32, v44 - v32);
  }
  return a1;
}

void sub_1A1C14FC0(_Unwind_Exception *a1)
{
  std::function<ggl::GlyphWithNormalHalo::DefaultPipelineSetup * ()(void)>::~function(v3);
  gss::FeatureAttributeSet::~FeatureAttributeSet(v2);
  gss::FeatureAttributeSet::~FeatureAttributeSet(v1);
  _Unwind_Resume(a1);
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_19GlyphWithNormalHalo20DefaultPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57B868;
}

uint64_t std::__function::__func<md::LabelRenderer::LabelRenderer(md::LabelWorldTraits const&,ggl::StandardLibrary const&,ggl::RenderTargetFormat const&,gdc::ServiceLocator &)::$_9,std::allocator<md::LabelRenderer::LabelRenderer(md::LabelWorldTraits const&,ggl::StandardLibrary const&,ggl::RenderTargetFormat const&,gdc::ServiceLocator &)::$_9>,ggl::GlyphWithNormalHalo::DefaultPipelineSetup * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56FA80;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::LabelRenderer::LabelRenderer(md::LabelWorldTraits const&,ggl::StandardLibrary const&,ggl::RenderTargetFormat const&,gdc::ServiceLocator &)::$_8,std::allocator<md::LabelRenderer::LabelRenderer(md::LabelWorldTraits const&,ggl::StandardLibrary const&,ggl::RenderTargetFormat const&,gdc::ServiceLocator &)::$_8>,ggl::GlyphWithNormalHalo::DefaultPipelineSetup * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56FA38;
  a2[1] = v2;
  return result;
}

unint64_t *ggl::FragmentedPool<ggl::PolygonOverlay::FillPipelineSetup>::FragmentedPool(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  {
    operator new();
  }
  uint64_t v6 = ggl::Allocator::instance(void)::alloc;
  a1[4] = 0;
  a1[3] = v6;
  a1[5] = 0;
  a1[6] = 0;
  {
    operator new();
  }
  a1[7] = ggl::Allocator::instance(void)::alloc;
  uint64_t v7 = *(void *)(a2 + 24);
  if (!v7) {
    goto LABEL_6;
  }
  if (v7 != a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
LABEL_6:
    a1[11] = v7;
    goto LABEL_8;
  }
  a1[11] = (unint64_t)(a1 + 8);
  (*(void (**)(void, unint64_t *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1 + 8);
LABEL_8:
  uint64_t v8 = *(void *)(a3 + 24);
  if (!v8)
  {
LABEL_11:
    a1[15] = v8;
    goto LABEL_13;
  }
  if (v8 != a3)
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
    goto LABEL_11;
  }
  a1[15] = (unint64_t)(a1 + 12);
  (*(void (**)(void, unint64_t *))(**(void **)(a3 + 24) + 24))(*(void *)(a3 + 24), a1 + 12);
LABEL_13:
  a1[16] = 2000;
  unint64_t v9 = *a1;
  if (a1[2] - *a1 > 0x31F) {
    goto LABEL_26;
  }
  unint64_t v10 = a1[1];
  uint64_t v11 = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 800, 8);
  uint64_t v12 = v10 - v9;
  unint64_t v13 = v11 + ((v10 - v9) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v15 = *a1;
  unint64_t v14 = a1[1];
  unint64_t v16 = v14 - *a1;
  if (v14 == *a1)
  {
    unint64_t v18 = v11 + ((v10 - v9) & 0xFFFFFFFFFFFFFFF8);
    goto LABEL_24;
  }
  unint64_t v17 = v16 - 8;
  if (v16 - 8 >= 0x58)
  {
    unint64_t v18 = v11 + ((v10 - v9) & 0xFFFFFFFFFFFFFFF8);
    if (v14 - (v12 & 0xFFFFFFFFFFFFFFF8) - v11 >= 0x20)
    {
      uint64_t v19 = v12 >> 3;
      uint64_t v20 = (v17 >> 3) + 1;
      id v21 = (_OWORD *)(v11 + 8 * v19 - 16);
      uint64_t v22 = (long long *)(v14 - 16);
      uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v24 = *v22;
        *(v21 - 1) = *(v22 - 1);
        *id v21 = v24;
        v21 -= 2;
        v22 -= 2;
        v23 -= 4;
      }
      while (v23);
      unint64_t v18 = v13 - 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
      v14 -= 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
      if (v20 == (v20 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    unint64_t v18 = v11 + ((v10 - v9) & 0xFFFFFFFFFFFFFFF8);
  }
  do
  {
    uint64_t v25 = *(void *)(v14 - 8);
    v14 -= 8;
    *(void *)(v18 - 8) = v25;
    v18 -= 8;
  }
  while (v14 != v15);
LABEL_23:
  unint64_t v14 = *a1;
LABEL_24:
  *a1 = v18;
  a1[1] = v13;
  unint64_t v26 = a1[2];
  a1[2] = v11 + 800;
  if (v14) {
    (*(void (**)(unint64_t, unint64_t, unint64_t))(*(void *)a1[3] + 40))(a1[3], v14, v26 - v14);
  }
LABEL_26:
  unint64_t v27 = a1[4];
  if (a1[6] - v27 > 0x31F) {
    return a1;
  }
  unint64_t v28 = a1[5];
  uint64_t v29 = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)a1[7] + 16))(a1[7], 800, 8);
  uint64_t v30 = v28 - v27;
  unint64_t v31 = v29 + ((v28 - v27) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v33 = a1[4];
  unint64_t v32 = a1[5];
  unint64_t v34 = v32 - v33;
  if (v32 == v33)
  {
    unint64_t v36 = v29 + ((v28 - v27) & 0xFFFFFFFFFFFFFFF8);
    goto LABEL_37;
  }
  unint64_t v35 = v34 - 8;
  if (v34 - 8 >= 0x58)
  {
    unint64_t v36 = v29 + ((v28 - v27) & 0xFFFFFFFFFFFFFFF8);
    if (v32 - (v30 & 0xFFFFFFFFFFFFFFF8) - v29 >= 0x20)
    {
      uint64_t v37 = v30 >> 3;
      uint64_t v38 = (v35 >> 3) + 1;
      char v39 = (_OWORD *)(v29 + 8 * v37 - 16);
      uint64_t v40 = (long long *)(v32 - 16);
      uint64_t v41 = v38 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v42 = *v40;
        *(v39 - 1) = *(v40 - 1);
        _OWORD *v39 = v42;
        v39 -= 2;
        v40 -= 2;
        v41 -= 4;
      }
      while (v41);
      unint64_t v36 = v31 - 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
      v32 -= 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
      if (v38 == (v38 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_36;
      }
    }
  }
  else
  {
    unint64_t v36 = v29 + ((v28 - v27) & 0xFFFFFFFFFFFFFFF8);
  }
  do
  {
    uint64_t v43 = *(void *)(v32 - 8);
    v32 -= 8;
    *(void *)(v36 - 8) = v43;
    v36 -= 8;
  }
  while (v32 != v33);
LABEL_36:
  unint64_t v32 = a1[4];
LABEL_37:
  a1[4] = v36;
  a1[5] = v31;
  unint64_t v44 = a1[6];
  a1[6] = v29 + 800;
  if (v32) {
    (*(void (**)(unint64_t, unint64_t, unint64_t))(*(void *)a1[7] + 40))(a1[7], v32, v44 - v32);
  }
  return a1;
}

void sub_1A1C154F4(_Unwind_Exception *a1)
{
  std::function<ggl::PolygonOverlay::FillPipelineSetup * ()(void)>::~function(v3);
  gss::FeatureAttributeSet::~FeatureAttributeSet(v2);
  gss::FeatureAttributeSet::~FeatureAttributeSet(v1);
  _Unwind_Resume(a1);
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_14PolygonOverlay17FillPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57AF20;
}

uint64_t std::__function::__func<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,ggl::PolygonOverlay::FillPipelineSetup * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF578180;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::PolygonOverlayRenderResources::PolygonOverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::PolygonOverlay::FillPipelineSetup * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF578138;
  a2[1] = v2;
  return result;
}

void geo::Cache<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>,std::hash<grl::FontKey>,geo::LRUPolicy>::insert(uint64_t a1, esl::FontKey *this, CFTypeRef cf)
{
  uint64_t v6 = (void **)(a1 + 8);
  if (cf) {
    CFRetain(cf);
  }
  CFTypeRef cfa = cf;
  uint64_t v7 = std::__hash_table<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::__unordered_map_hasher<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::hash<grl::FontKey>,std::equal_to<grl::FontKey>,true>,std::__unordered_map_equal<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::equal_to<grl::FontKey>,std::hash<grl::FontKey>,true>,std::allocator<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>>>::find<grl::FontKey>(v6, this);
  if (v7)
  {
    uint64_t v8 = v7;
    unint64_t v9 = (uint64_t *)v7[18];
    uint64_t v10 = *v9;
    *(void *)(v10 + 8) = v9[1];
    *(void *)v9[1] = v10;
    --*(void *)(a1 + 64);
    std::__destroy_at[abi:nn180100]<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,0>((esl::FontKey *)(v9 + 2));
    operator delete(v9);
    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)&v61, v6, v8);
    std::unique_ptr<std::__hash_node<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,void *>>>>::reset[abi:nn180100]((uint64_t *)&v61);
  }
  uint64_t v11 = (char *)operator new(0xA8uLL);
  uint64_t v12 = v11;
  *(void *)uint64_t v11 = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = &unk_1EF554E58;
  *(_OWORD *)(v11 + 24) = *(_OWORD *)((char *)this + 8);
  v11[40] = 0;
  if (*((unsigned char *)this + 24))
  {
    *((_DWORD *)v11 + 11) = *((_DWORD *)this + 7);
    v11[40] = 1;
  }
  v11[48] = 0;
  if (*((unsigned char *)this + 32))
  {
    *((_DWORD *)v11 + 13) = *((_DWORD *)this + 9);
    v11[48] = 1;
  }
  v11[56] = *((unsigned char *)this + 40);
  unint64_t v13 = (std::string *)(v11 + 64);
  CTFontDescriptorRef v59 = v6;
  if (*((char *)this + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v13, *((const std::string::value_type **)this + 6), *((void *)this + 7));
  }
  else
  {
    *(_OWORD *)&v13->__r_.__value_.__l.__data_ = *((_OWORD *)this + 3);
    *((void *)v12 + 10) = *((void *)this + 8);
  }
  unint64_t v58 = (uint64_t *)(a1 + 48);
  unint64_t v14 = (std::string *)(v12 + 88);
  unint64_t v15 = (_OWORD *)((char *)this + 72);
  if (*((char *)this + 95) < 0)
  {
    std::string::__init_copy_ctor_external(v14, *((const std::string::value_type **)this + 9), *((void *)this + 10));
  }
  else
  {
    *(_OWORD *)&v14->__r_.__value_.__l.__data_ = *v15;
    *((void *)v12 + 13) = *((void *)this + 11);
  }
  std::vector<int>::vector((std::vector<int> *)(v12 + 112), (const std::vector<int> *)this + 4);
  v12[136] = *((unsigned char *)this + 120);
  *((void *)v12 + 2) = &unk_1EF5672D0;
  *((void *)v12 + 18) = &unk_1EF5592F8;
  unint64_t v16 = (unint64_t)cfa;
  if (cfa) {
    CFRetain(cfa);
  }
  *((void *)v12 + 19) = cfa;
  unint64_t v17 = *(void **)(a1 + 56);
  *(void *)uint64_t v12 = v58;
  *((void *)v12 + 1) = v17;
  *unint64_t v17 = v12;
  uint64_t v18 = *(void *)(a1 + 64) + 1;
  *(void *)(a1 + 56) = v12;
  *(void *)(a1 + 64) = v18;
  unint64_t v19 = esl::FontKey::hash(this);
  unint64_t v20 = v19;
  unint64_t v21 = *(void *)(a1 + 16);
  if (v21)
  {
    uint8x8_t v22 = (uint8x8_t)vcnt_s8((int8x8_t)v21);
    v22.i16[0] = vaddlv_u8(v22);
    unint64_t v23 = v22.u32[0];
    if (v22.u32[0] > 1uLL)
    {
      unint64_t v16 = v19;
      if (v19 >= v21) {
        unint64_t v16 = v19 % v21;
      }
    }
    else
    {
      unint64_t v16 = (v21 - 1) & v19;
    }
    long long v24 = (void *)*((void *)*v59 + v16);
    if (v24)
    {
      uint64_t v25 = (void *)*v24;
      if (*v24)
      {
        do
        {
          unint64_t v26 = v25[1];
          if (v26 == v20)
          {
            if (esl::FontKey::operator==((uint64_t)(v25 + 2), (uint64_t)this)) {
              goto LABEL_101;
            }
          }
          else
          {
            if (v23 > 1)
            {
              if (v26 >= v21) {
                v26 %= v21;
              }
            }
            else
            {
              v26 &= v21 - 1;
            }
            if (v26 != v16) {
              break;
            }
          }
          uint64_t v25 = (void *)*v25;
        }
        while (v25);
      }
    }
  }
  unint64_t v27 = (char *)operator new(0x98uLL);
  unint64_t v28 = v27;
  long long v61 = v27;
  *(void *)&long long v62 = a1 + 24;
  unint64_t v57 = (void *)(a1 + 24);
  *(void *)unint64_t v27 = 0;
  *((void *)v27 + 1) = v20;
  *((void *)v27 + 2) = &unk_1EF554E58;
  *(_OWORD *)(v27 + 24) = *(_OWORD *)((char *)this + 8);
  v27[40] = 0;
  if (*((unsigned char *)this + 24))
  {
    *((_DWORD *)v27 + 11) = *((_DWORD *)this + 7);
    v27[40] = 1;
  }
  v27[48] = 0;
  if (*((unsigned char *)this + 32))
  {
    *((_DWORD *)v27 + 13) = *((_DWORD *)this + 9);
    v27[48] = 1;
  }
  v27[56] = *((unsigned char *)this + 40);
  uint64_t v29 = (std::string *)(v27 + 64);
  if (*((char *)this + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v29, *((const std::string::value_type **)this + 6), *((void *)this + 7));
  }
  else
  {
    *(_OWORD *)&v29->__r_.__value_.__l.__data_ = *((_OWORD *)this + 3);
    *((void *)v28 + 10) = *((void *)this + 8);
  }
  uint64_t v30 = (std::string *)(v28 + 88);
  if (*((char *)this + 95) < 0)
  {
    std::string::__init_copy_ctor_external(v30, *((const std::string::value_type **)this + 9), *((void *)this + 10));
  }
  else
  {
    *(_OWORD *)&v30->__r_.__value_.__l.__data_ = *v15;
    *((void *)v28 + 13) = *((void *)this + 11);
  }
  std::vector<int>::vector((std::vector<int> *)(v28 + 112), (const std::vector<int> *)this + 4);
  v28[136] = *((unsigned char *)this + 120);
  *((void *)v28 + 2) = &unk_1EF5672D0;
  *((void *)v28 + 18) = v12;
  BYTE8(v62) = 1;
  float v31 = (float)(unint64_t)(*(void *)(a1 + 32) + 1);
  float v32 = *(float *)(a1 + 40);
  if (!v21 || (float)(v32 * (float)v21) < v31)
  {
    BOOL v33 = v21 < 3 || (v21 & (v21 - 1)) != 0;
    unint64_t v34 = v33 | (2 * v21);
    unint64_t v35 = vcvtps_u32_f32(v31 / v32);
    if (v34 <= v35) {
      int8x8_t prime = (int8x8_t)v35;
    }
    else {
      int8x8_t prime = (int8x8_t)v34;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v21 = *(void *)(a1 + 16);
    if (*(void *)&prime > v21) {
      goto LABEL_57;
    }
    if (*(void *)&prime < v21)
    {
      unint64_t v43 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 32) / *(float *)(a1 + 40));
      if (v21 < 3 || (uint8x8_t v44 = (uint8x8_t)vcnt_s8((int8x8_t)v21), v44.i16[0] = vaddlv_u8(v44), v44.u32[0] > 1uLL))
      {
        unint64_t v43 = std::__next_prime(v43);
      }
      else
      {
        uint64_t v45 = 1 << -(char)__clz(v43 - 1);
        if (v43 >= 2) {
          unint64_t v43 = v45;
        }
      }
      if (*(void *)&prime <= v43) {
        int8x8_t prime = (int8x8_t)v43;
      }
      if (*(void *)&prime >= v21)
      {
        unint64_t v21 = *(void *)(a1 + 16);
      }
      else
      {
        if (prime)
        {
LABEL_57:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v37 = operator new(8 * *(void *)&prime);
          uint64_t v38 = *v59;
          *CTFontDescriptorRef v59 = v37;
          if (v38) {
            operator delete(v38);
          }
          uint64_t v39 = 0;
          *(int8x8_t *)(a1 + 16) = prime;
          do
            *((void *)*v59 + v39++) = 0;
          while (*(void *)&prime != v39);
          uint64_t v40 = (void *)*v57;
          if (*v57)
          {
            unint64_t v41 = v40[1];
            uint8x8_t v42 = (uint8x8_t)vcnt_s8(prime);
            v42.i16[0] = vaddlv_u8(v42);
            if (v42.u32[0] > 1uLL)
            {
              if (v41 >= *(void *)&prime) {
                v41 %= *(void *)&prime;
              }
            }
            else
            {
              v41 &= *(void *)&prime - 1;
            }
            *((void *)*v59 + v41) = v57;
            uint64_t v46 = (void *)*v40;
            if (*v40)
            {
              do
              {
                unint64_t v47 = v46[1];
                if (v42.u32[0] > 1uLL)
                {
                  if (v47 >= *(void *)&prime) {
                    v47 %= *(void *)&prime;
                  }
                }
                else
                {
                  v47 &= *(void *)&prime - 1;
                }
                if (v47 != v41)
                {
                  if (!*((void *)*v59 + v47))
                  {
                    *((void *)*v59 + v47) = v40;
                    goto LABEL_82;
                  }
                  void *v40 = *v46;
                  *uint64_t v46 = **((void **)*v59 + v47);
                  **((void **)*v59 + v47) = v46;
                  uint64_t v46 = v40;
                }
                unint64_t v47 = v41;
LABEL_82:
                uint64_t v40 = v46;
                uint64_t v46 = (void *)*v46;
                unint64_t v41 = v47;
              }
              while (v46);
            }
          }
          unint64_t v21 = (unint64_t)prime;
          goto LABEL_86;
        }
        uint64_t v56 = *v59;
        *CTFontDescriptorRef v59 = 0;
        if (v56) {
          operator delete(v56);
        }
        unint64_t v21 = 0;
        *(void *)(a1 + 16) = 0;
      }
    }
LABEL_86:
    if ((v21 & (v21 - 1)) != 0)
    {
      if (v20 >= v21) {
        unint64_t v16 = v20 % v21;
      }
      else {
        unint64_t v16 = v20;
      }
    }
    else
    {
      unint64_t v16 = (v21 - 1) & v20;
    }
  }
  uint64_t v48 = *v59;
  unint64_t v49 = (void *)*((void *)*v59 + v16);
  if (v49)
  {
    *(void *)unint64_t v28 = *v49;
LABEL_99:
    *unint64_t v49 = v28;
    goto LABEL_100;
  }
  *(void *)unint64_t v28 = *v57;
  *unint64_t v57 = v28;
  v48[v16] = v57;
  if (*(void *)v28)
  {
    unint64_t v50 = *(void *)(*(void *)v28 + 8);
    if ((v21 & (v21 - 1)) != 0)
    {
      if (v50 >= v21) {
        v50 %= v21;
      }
    }
    else
    {
      v50 &= v21 - 1;
    }
    unint64_t v49 = (char *)*v59 + 8 * v50;
    goto LABEL_99;
  }
LABEL_100:
  long long v61 = 0;
  ++*(void *)(a1 + 32);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,void *>>>>::reset[abi:nn180100]((uint64_t *)&v61);
LABEL_101:
  if (cfa) {
    CFRelease(cfa);
  }
  while (*(void *)(a1 + 64) > *(void *)a1)
  {
    uint64_t v51 = *v58;
    long long v61 = &unk_1EF554E58;
    long long v62 = *(_OWORD *)(v51 + 24);
    char v63 = 0;
    if (*(unsigned char *)(v51 + 40))
    {
      int v64 = *(_DWORD *)(v51 + 44);
      char v63 = 1;
    }
    char v65 = 0;
    if (*(unsigned char *)(v51 + 48))
    {
      int v66 = *(_DWORD *)(v51 + 52);
      char v65 = 1;
    }
    char v67 = *(unsigned char *)(v51 + 56);
    if (*(char *)(v51 + 87) < 0) {
      std::string::__init_copy_ctor_external(&v68, *(const std::string::value_type **)(v51 + 64), *(void *)(v51 + 72));
    }
    else {
      std::string v68 = *(std::string *)(v51 + 64);
    }
    if (*(char *)(v51 + 111) < 0) {
      std::string::__init_copy_ctor_external(&v69, *(const std::string::value_type **)(v51 + 88), *(void *)(v51 + 96));
    }
    else {
      std::string v69 = *(std::string *)(v51 + 88);
    }
    std::vector<int>::vector(&v70, (const std::vector<int> *)(v51 + 112));
    char v71 = *(unsigned char *)(v51 + 136);
    long long v61 = &unk_1EF5672D0;
    uint64_t v72 = &unk_1EF5592F8;
    uint64_t v52 = *(const void **)(v51 + 152);
    if (v52) {
      CFRetain(v52);
    }
    CFTypeRef v73 = v52;
    uint64_t v53 = *(uint64_t **)(a1 + 48);
    uint64_t v54 = *v53;
    *(void *)(v54 + 8) = v53[1];
    *(void *)v53[1] = v54;
    --*(void *)(a1 + 64);
    std::__destroy_at[abi:nn180100]<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,0>((esl::FontKey *)(v53 + 2));
    operator delete(v53);
    uint64_t v55 = std::__hash_table<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::__unordered_map_hasher<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::hash<grl::FontKey>,std::equal_to<grl::FontKey>,true>,std::__unordered_map_equal<grl::FontKey,std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,std::equal_to<grl::FontKey>,std::hash<grl::FontKey>,true>,std::allocator<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>>>::find<grl::FontKey>(v59, (esl::FontKey *)&v61);
    if (v55)
    {
      std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)v74, v59, v55);
      std::unique_ptr<std::__hash_node<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<grl::FontKey,std::__list_iterator<std::pair<grl::FontKey,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,void *>>,void *>>>>::reset[abi:nn180100](v74);
    }
    uint64_t v72 = &unk_1EF5592F8;
    if (v73) {
      CFRelease(v73);
    }
    esl::FontKey::~FontKey((esl::FontKey *)&v61);
  }
}