void md::FlyoverRenderLayer::~FlyoverRenderLayer(md::FlyoverRenderLayer *this)
{
  uint64_t vars8;

  *(void *)this = off_1EF538FD0;
  md::FlyoverRenderResources::~FlyoverRenderResources((md::FlyoverRenderLayer *)((char *)this + 368));
  md::CartographicTiledVectorRenderLayer<md::FlyoverRenderable>::~CartographicTiledVectorRenderLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t vars8;

  *(void *)this = off_1EF538FD0;
  md::FlyoverRenderResources::~FlyoverRenderResources((md::FlyoverRenderLayer *)((char *)this + 368));
  md::CartographicTiledVectorRenderLayer<md::FlyoverRenderable>::~CartographicTiledVectorRenderLayer(this);
}

void md::FlyoverRenderResources::~FlyoverRenderResources(md::FlyoverRenderResources *this)
{
  uint64_t v2 = *((void *)this + 158);
  *((void *)this + 158) = 0;
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C4049ECCB0CLL);
  }
  uint64_t v3 = *((void *)this + 157);
  *((void *)this + 157) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 156);
  *((void *)this + 156) = 0;
  if (v4)
  {
    uint64_t v5 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>::~FragmentedPool(v4);
    MEMORY[0x1A6239270](v5, 0x10A0C40D234DDC7);
  }
  uint64_t v6 = *((void *)this + 155);
  *((void *)this + 155) = 0;
  if (v6)
  {
    uint64_t v7 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>::~FragmentedPool(v6);
    MEMORY[0x1A6239270](v7, 0x10A0C40D234DDC7);
  }
  uint64_t v8 = *((void *)this + 154);
  *((void *)this + 154) = 0;
  if (v8)
  {
    uint64_t v9 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>::~FragmentedPool(v8);
    MEMORY[0x1A6239270](v9, 0x10A0C40D234DDC7);
  }
  uint64_t v10 = *((void *)this + 153);
  *((void *)this + 153) = 0;
  if (v10)
  {
    uint64_t v11 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>::~FragmentedPool(v10);
    MEMORY[0x1A6239270](v11, 0x10A0C40D234DDC7);
  }
  uint64_t v12 = *((void *)this + 152);
  *((void *)this + 152) = 0;
  if (v12)
  {
    uint64_t v13 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>::~FragmentedPool(v12);
    MEMORY[0x1A6239270](v13, 0x10A0C40D234DDC7);
  }
  v14 = (std::__shared_weak_count *)*((void *)this + 151);
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  uint64_t v15 = *((void *)this + 149);
  *((void *)this + 149) = 0;
  if (v15)
  {
    uint64_t v16 = ggl::FragmentedPool<ggl::FlyoverNight::FlyoverPolarPipelineSetup>::~FragmentedPool(v15);
    MEMORY[0x1A6239270](v16, 0x10A0C40D234DDC7);
  }
  v17 = (std::__shared_weak_count *)*((void *)this + 148);
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v18 = *((void *)this + 146);
  *((void *)this + 146) = 0;
  if (v18)
  {
    uint64_t v19 = ggl::FragmentedPool<ggl::FlyoverNight::FlyoverPipelineSetup>::~FragmentedPool(v18);
    MEMORY[0x1A6239270](v19, 0x10A0C40D234DDC7);
  }
  v20 = (std::__shared_weak_count *)*((void *)this + 145);
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  uint64_t v21 = *((void *)this + 143);
  *((void *)this + 143) = 0;
  if (v21)
  {
    uint64_t v22 = ggl::FragmentedPool<ggl::Flyover::FlyoverPolarPipelineSetup>::~FragmentedPool(v21);
    MEMORY[0x1A6239270](v22, 0x10A0C40D234DDC7);
  }
  v23 = (std::__shared_weak_count *)*((void *)this + 142);
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  uint64_t v24 = *((void *)this + 140);
  *((void *)this + 140) = 0;
  if (v24)
  {
    uint64_t v25 = ggl::FragmentedPool<ggl::Flyover::FlyoverPipelineSetup>::~FragmentedPool(v24);
    MEMORY[0x1A6239270](v25, 0x10A0C40D234DDC7);
  }
  v26 = (std::__shared_weak_count *)*((void *)this + 139);
  if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  *((void *)this + 111) = &unk_1EF55D4B8;
  uint64_t v27 = *((void *)this + 112);
  if (v27)
  {
    (*(void (**)(uint64_t, void))(*(void *)v27 + 16))(v27, *((void *)this + 114));
    *((void *)this + 114) = 3735927469;
  }
  v28 = (std::__shared_weak_count *)*((void *)this + 113);
  if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
  *((void *)this + 84) = &unk_1EF55D4B8;
  uint64_t v29 = *((void *)this + 85);
  if (v29)
  {
    (*(void (**)(uint64_t, void))(*(void *)v29 + 16))(v29, *((void *)this + 87));
    *((void *)this + 87) = 3735927469;
  }
  v30 = (std::__shared_weak_count *)*((void *)this + 86);
  if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
  }
  *((void *)this + 57) = &unk_1EF55D4B8;
  uint64_t v31 = *((void *)this + 58);
  if (v31)
  {
    (*(void (**)(uint64_t, void))(*(void *)v31 + 16))(v31, *((void *)this + 60));
    *((void *)this + 60) = 3735927469;
  }
  v32 = (std::__shared_weak_count *)*((void *)this + 59);
  if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
    std::__shared_weak_count::__release_weak(v32);
  }
  *((void *)this + 30) = &unk_1EF55D4B8;
  uint64_t v33 = *((void *)this + 31);
  if (v33)
  {
    (*(void (**)(uint64_t, void))(*(void *)v33 + 16))(v33, *((void *)this + 33));
    *((void *)this + 33) = 3735927469;
  }
  v34 = (std::__shared_weak_count *)*((void *)this + 32);
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  *((void *)this + 3) = &unk_1EF55D4B8;
  uint64_t v35 = *((void *)this + 4);
  if (v35)
  {
    (*(void (**)(uint64_t, void))(*(void *)v35 + 16))(v35, *((void *)this + 6));
    *((void *)this + 6) = 3735927469;
  }
  v36 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
  }
  v37 = *(void **)this;
  do
  {
    if (v37[1])
    {
      unint64_t v38 = 0;
      v39 = v37 + 2;
      v40 = v37 + 2;
      v41 = (void (***)(void))(v37 + 2);
      do
      {
        v42 = (void (**)(void *))*v41;
        v41 += 15;
        (*v42)(v40);
        ++v38;
        v39 += 15;
        v40 = v41;
      }
      while (v38 < v37[1]);
    }
    v37[1] = 0;
    v37 = (void *)*v37;
  }
  while (v37);
  v43 = *(void ***)this;
  *((void *)this + 1) = *(void *)this;
  v44 = *v43;
  *v43 = 0;
  if (v44)
  {
    do
    {
      v45 = (void *)*v44;
      free(v44);
      v44 = v45;
    }
    while (v45);
    v43 = *(void ***)this;
  }
  free(v43);
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::FlyoverNight::FlyoverPolarPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::FlyoverNight::FlyoverPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Flyover::FlyoverPolarPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Flyover::FlyoverPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void *std::function<void ()(ggl::Flyover::FlyoverPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Flyover::FlyoverPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::Flyover::FlyoverPolarPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Flyover::FlyoverPolarPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::FlyoverNight::FlyoverPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::FlyoverNight::FlyoverPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::FlyoverNight::FlyoverPolarPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::FlyoverNight::FlyoverPolarPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform> *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform> * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform> *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform> * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip> *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip> * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::ConstantDataTyped<ggl::FlyoverCommon::Material> *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material> * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords> *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords> * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords>>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Material>>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip>>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform>>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform>>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::FlyoverNight::FlyoverPolarPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::FlyoverNight::FlyoverPolarPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::FlyoverNight::FlyoverPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::FlyoverNight::FlyoverPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Flyover::FlyoverPolarPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Flyover::FlyoverPolarPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Flyover::FlyoverPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Flyover::FlyoverPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17ConstantDataTypedINS2_13FlyoverCommon9TexcoordsEEEEC1ENS_8functionIFPS7_vEEENS9_IFvSA_EEEmmEd1_UlSA_E_NS_9allocatorISF_EESD_E7__cloneEv()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF57B280;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17ConstantDataTypedINS2_13FlyoverCommon9TexcoordsEEEEC1ENS_8functionIFPS7_vEEENS9_IFvSA_EEEmmEd1_UlSA_E_NS_9allocatorISF_EESD_ED0Ev()
{
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_12,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_12>,ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords> * ()(void)>::operator()()
{
}

void *std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_12,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_12>,ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords> * ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF51E9F8;
  return result;
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_12,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_12>,ggl::ConstantDataTyped<ggl::FlyoverCommon::Texcoords> * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17ConstantDataTypedINS2_13FlyoverCommon8MaterialEEEEC1ENS_8functionIFPS7_vEEENS9_IFvSA_EEEmmEd1_UlSA_E_NS_9allocatorISF_EESD_E7__cloneEv()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF57B238;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17ConstantDataTypedINS2_13FlyoverCommon8MaterialEEEEC1ENS_8functionIFPS7_vEEENS9_IFvSA_EEEmmEd1_UlSA_E_NS_9allocatorISF_EESD_ED0Ev()
{
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_11,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_11>,ggl::ConstantDataTyped<ggl::FlyoverCommon::Material> * ()(void)>::operator()()
{
}

void *std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_11,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_11>,ggl::ConstantDataTyped<ggl::FlyoverCommon::Material> * ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF51E9B0;
  return result;
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_11,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_11>,ggl::ConstantDataTyped<ggl::FlyoverCommon::Material> * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17ConstantDataTypedINS2_13FlyoverCommon4ClipEEEEC1ENS_8functionIFPS7_vEEENS9_IFvSA_EEEmmEd1_UlSA_E_NS_9allocatorISF_EESD_E7__cloneEv()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF57B1F0;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17ConstantDataTypedINS2_13FlyoverCommon4ClipEEEEC1ENS_8functionIFPS7_vEEENS9_IFvSA_EEEmmEd1_UlSA_E_NS_9allocatorISF_EESD_ED0Ev()
{
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_10,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_10>,ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip> * ()(void)>::operator()()
{
}

void *std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_10,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_10>,ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip> * ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF51E968;
  return result;
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_10,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_10>,ggl::ConstantDataTyped<ggl::FlyoverCommon::Clip> * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17ConstantDataTypedINS2_13FlyoverCommon11S2TransformEEEEC1ENS_8functionIFPS7_vEEENS9_IFvSA_EEEmmEd1_UlSA_E_NS_9allocatorISF_EESD_E7__cloneEv()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF521500;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17ConstantDataTypedINS2_13FlyoverCommon11S2TransformEEEEC1ENS_8functionIFPS7_vEEENS9_IFvSA_EEEmmEd1_UlSA_E_NS_9allocatorISF_EESD_ED0Ev()
{
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_9,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_9>,ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform> * ()(void)>::operator()()
{
}

void *std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_9,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_9>,ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform> * ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF51E920;
  return result;
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_9,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_9>,ggl::ConstantDataTyped<ggl::FlyoverCommon::S2Transform> * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17ConstantDataTypedINS2_13FlyoverCommon9TransformEEEEC1ENS_8functionIFPS7_vEEENS9_IFvSA_EEEmmEd1_UlSA_E_NS_9allocatorISF_EESD_E7__cloneEv()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF57B2C8;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17ConstantDataTypedINS2_13FlyoverCommon9TransformEEEEC1ENS_8functionIFPS7_vEEENS9_IFvSA_EEEmmEd1_UlSA_E_NS_9allocatorISF_EESD_ED0Ev()
{
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_8,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_8>,ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform> * ()(void)>::operator()()
{
}

void *std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_8,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_8>,ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform> * ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF51E8D8;
  return result;
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_8,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_8>,ggl::ConstantDataTyped<ggl::FlyoverCommon::Transform> * ()(void)>::~__func()
{
}

void *std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_7,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_7>,void ()(ggl::FlyoverNight::FlyoverPolarPipelineSetup *)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF51E890;
  return result;
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_7,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_7>,void ()(ggl::FlyoverNight::FlyoverPolarPipelineSetup *)>::~__func()
{
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_6,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_6>,ggl::FlyoverNight::FlyoverPolarPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_6,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_6>,ggl::FlyoverNight::FlyoverPolarPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51E848;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_6,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_6>,ggl::FlyoverNight::FlyoverPolarPipelineSetup * ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverNight::FlyoverPolarPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverNight::FlyoverPolarPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E370;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverNight::FlyoverPolarPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E370;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_5,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_5>,void ()(ggl::FlyoverNight::FlyoverPipelineSetup *)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF51E800;
  return result;
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_5,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_5>,void ()(ggl::FlyoverNight::FlyoverPipelineSetup *)>::~__func()
{
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_4,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_4>,ggl::FlyoverNight::FlyoverPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_4,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_4>,ggl::FlyoverNight::FlyoverPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51E7B8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_4,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_4>,ggl::FlyoverNight::FlyoverPipelineSetup * ()(void)>::~__func()
{
}

void *std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_3,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_3>,void ()(ggl::Flyover::FlyoverPolarPipelineSetup *)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF51E770;
  return result;
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_3,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_3>,void ()(ggl::Flyover::FlyoverPolarPipelineSetup *)>::~__func()
{
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::Flyover::FlyoverPolarPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::Flyover::FlyoverPolarPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51E728;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::Flyover::FlyoverPolarPipelineSetup * ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::Flyover::FlyoverPolarPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Flyover::FlyoverPolarPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E488;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Flyover::FlyoverPolarPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E488;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,void ()(ggl::Flyover::FlyoverPipelineSetup *)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF51E6E0;
  return result;
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,void ()(ggl::Flyover::FlyoverPipelineSetup *)>::~__func()
{
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::Flyover::FlyoverPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::Flyover::FlyoverPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51E698;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::FlyoverRenderResources::FlyoverRenderResources(md::SharedDeviceResources const&,VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::Flyover::FlyoverPipelineSetup * ()(void)>::~__func()
{
}

uint64_t **std::__hash_table<std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,std::__unordered_map_hasher<md::MaterialKey,std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,md::MaterialKeyHasher,std::equal_to<md::MaterialKey>,true>,std::__unordered_map_equal<md::MaterialKey,std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,std::equal_to<md::MaterialKey>,md::MaterialKeyHasher,true>,std::allocator<std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>>>::find<md::MaterialKey>(void *a1, uint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint64_t v3 = *((unsigned __int8 *)a2 + 8);
  uint64_t v4 = (uint64_t *)*a2;
  unint64_t v5 = (*a2 + ((v3 - 0x61C8864680B583EBLL) << 6) - 0x3A3AA7D820E2E4E6) ^ (v3 - 0x61C8864680B583EBLL);
  uint64_t v6 = *((unsigned __int8 *)a2 + 9);
  unint64_t v7 = ((v6 | (v5 << 6)) + (v5 >> 2) - 0x61C8864680B583EBLL) ^ v5;
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(v2);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.u32[0] > 1uLL)
  {
    uint64_t v9 = ((v6 | (v5 << 6)) + (v5 >> 2) - 0x61C8864680B583EBLL) ^ v5;
    if (v7 >= *(void *)&v2) {
      uint64_t v9 = v7 % *(void *)&v2;
    }
  }
  else
  {
    uint64_t v9 = v7 & (*(void *)&v2 - 1);
  }
  uint64_t v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  result = *v10;
  if (*v10)
  {
    if (v8.u32[0] < 2uLL)
    {
      uint64_t v12 = *(void *)&v2 - 1;
      while (1)
      {
        v14 = result[1];
        if (v14 == (uint64_t *)v7)
        {
          if (result[2] == v4
            && __PAIR64__(*((unsigned __int8 *)result + 25), *((unsigned __int8 *)result + 24)) == __PAIR64__(v6, v3))
          {
            return result;
          }
        }
        else if (((unint64_t)v14 & v12) != v9)
        {
          return 0;
        }
        result = (uint64_t **)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v13 = (unint64_t)result[1];
      if (v13 == v7)
      {
        if (result[2] == v4
          && __PAIR64__(*((unsigned __int8 *)result + 25), *((unsigned __int8 *)result + 24)) == __PAIR64__(v6, v3))
        {
          return result;
        }
      }
      else
      {
        if (v13 >= *(void *)&v2) {
          v13 %= *(void *)&v2;
        }
        if (v13 != v9) {
          return 0;
        }
      }
      result = (uint64_t **)*result;
    }
    while (result);
  }
  return result;
}

unint64_t md::MaterialResourceStore::createMaterialHandle(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v160[0] = a2;
  v160[1] = a3;
  uint64_t v6 = (void **)(a1 + 232);
  unint64_t v7 = std::__hash_table<std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,std::__unordered_map_hasher<md::MaterialKey,std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,md::MaterialKeyHasher,std::equal_to<md::MaterialKey>,true>,std::__unordered_map_equal<md::MaterialKey,std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,std::equal_to<md::MaterialKey>,md::MaterialKeyHasher,true>,std::allocator<std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>>>::find<md::MaterialKey>((void *)(a1 + 232), v160);
  if (v7)
  {
    unint64_t v8 = (unint64_t)v7[4];
    if (v8) {
      return v8;
    }
  }
  uint64_t v9 = *(void *)(a1 + 104);
  if (*(void *)(a1 + 96) == v9)
  {
    uint64_t v11 = ((*(void *)(a1 + 152) - *(void *)(a1 + 144)) >> 3) | 0x100000000;
    unint64_t v13 = *(uint64_t **)(a1 + 128);
    unint64_t v12 = *(void *)(a1 + 136);
    if ((unint64_t)v13 >= v12)
    {
      uint64_t v15 = *(uint64_t **)(a1 + 120);
      uint64_t v16 = v13 - v15;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        goto LABEL_318;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          goto LABEL_319;
        }
        v20 = operator new(8 * v19);
      }
      else
      {
        v20 = 0;
      }
      uint64_t v21 = (uint64_t *)&v20[8 * v16];
      uint64_t v22 = &v20[8 * v19];
      *uint64_t v21 = v11;
      v14 = v21 + 1;
      if (v13 == v15)
      {
        uint64_t v15 = v13;
      }
      else
      {
        unint64_t v23 = (char *)v13 - (char *)v15 - 8;
        if (v23 < 0x58) {
          goto LABEL_322;
        }
        if ((unint64_t)((char *)v15 - v20) < 0x20) {
          goto LABEL_322;
        }
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = &v20[8 * v16 - 16];
        v26 = v13 - 2;
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          *uint64_t v25 = v28;
          v25 -= 2;
          v26 -= 4;
          v27 -= 4;
        }
        while (v27);
        v21 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        v13 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_322:
          do
          {
            uint64_t v29 = *--v13;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
          uint64_t v15 = *(uint64_t **)(a1 + 120);
        }
      }
      *(void *)(a1 + 120) = v21;
      *(void *)(a1 + 128) = v14;
      *(void *)(a1 + 136) = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *unint64_t v13 = v11;
      v14 = v13 + 1;
    }
    *(void *)(a1 + 128) = v14;
    unint64_t v8 = *(v14 - 1);
  }
  else
  {
    uint64_t v10 = *(void *)(v9 - 8);
    *(void *)(a1 + 104) = v9 - 8;
    *(_DWORD *)(*(void *)(a1 + 120) + 8 * v10) = (*(void *)(a1 + 152) - *(void *)(a1 + 144)) >> 3;
    *(_DWORD *)(*(void *)(a1 + 120) + 8 * v10 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 120)
                                                                                           + 8 * v10
                                                                                           + 4) << 32)
                                                      + 0x100000000) >> 32;
    unint64_t v8 = v10 | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 120) + 8 * v10 + 4) << 32);
  }
  uint64_t v31 = *(char **)(a1 + 152);
  unint64_t v30 = *(void *)(a1 + 160);
  if ((unint64_t)v31 >= v30)
  {
    v36 = *(char **)(a1 + 144);
    uint64_t v37 = (v31 - v36) >> 3;
    unint64_t v38 = v37 + 1;
    if ((unint64_t)(v37 + 1) >> 61) {
      goto LABEL_318;
    }
    uint64_t v39 = v30 - (void)v36;
    if (v39 >> 2 > v38) {
      unint64_t v38 = v39 >> 2;
    }
    if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v40 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v40 = v38;
    }
    if (v40)
    {
      if (v40 >> 61) {
        goto LABEL_319;
      }
      v41 = operator new(8 * v40);
    }
    else
    {
      v41 = 0;
    }
    v42 = (uint64_t *)&v41[8 * v37];
    v43 = &v41[8 * v40];
    uint64_t *v42 = a2;
    uint64_t v35 = v42 + 1;
    if (v31 != v36)
    {
      unint64_t v44 = v31 - v36 - 8;
      if (v44 < 0x58) {
        goto LABEL_323;
      }
      if ((unint64_t)(v36 - v41) < 0x20) {
        goto LABEL_323;
      }
      uint64_t v45 = (v44 >> 3) + 1;
      v46 = &v41[8 * v37 - 16];
      v47 = v31 - 16;
      uint64_t v48 = v45 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v49 = *(_OWORD *)v47;
        *(v46 - 1) = *((_OWORD *)v47 - 1);
        _OWORD *v46 = v49;
        v46 -= 2;
        v47 -= 32;
        v48 -= 4;
      }
      while (v48);
      v42 -= v45 & 0x3FFFFFFFFFFFFFFCLL;
      v31 -= 8 * (v45 & 0x3FFFFFFFFFFFFFFCLL);
      if (v45 != (v45 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_323:
        do
        {
          uint64_t v50 = *((void *)v31 - 1);
          v31 -= 8;
          *--v42 = v50;
        }
        while (v31 != v36);
      }
    }
    uint64_t v34 = a2;
    uint64_t v33 = a3;
    *(void *)(a1 + 144) = v42;
    *(void *)(a1 + 152) = v35;
    *(void *)(a1 + 160) = v43;
    if (v36) {
      operator delete(v36);
    }
  }
  else
  {
    uint64_t v32 = a2;
    uint64_t v33 = a3;
    uint64_t v34 = v32;
    *(void *)uint64_t v31 = v32;
    uint64_t v35 = v31 + 8;
  }
  *(void *)(a1 + 152) = v35;
  unint64_t v52 = *(void *)(a1 + 176);
  unint64_t v51 = *(void *)(a1 + 184);
  if (v52 < v51)
  {
    *(void *)unint64_t v52 = v8;
    v52 += 8;
    unint64_t v53 = v52;
    goto LABEL_73;
  }
  v54 = *(unsigned char **)(a1 + 168);
  uint64_t v55 = (uint64_t)(v52 - (void)v54) >> 3;
  unint64_t v56 = v55 + 1;
  if ((unint64_t)(v55 + 1) >> 61) {
LABEL_318:
  }
    abort();
  uint64_t v57 = v51 - (void)v54;
  if (v57 >> 2 > v56) {
    unint64_t v56 = v57 >> 2;
  }
  if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v58 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v58 = v56;
  }
  if (v58)
  {
    if (v58 >> 61) {
      goto LABEL_319;
    }
    v59 = operator new(8 * v58);
  }
  else
  {
    v59 = 0;
  }
  v60 = &v59[8 * v55];
  v61 = &v59[8 * v58];
  void *v60 = v8;
  unint64_t v53 = (unint64_t)(v60 + 1);
  if ((unsigned char *)v52 != v54)
  {
    unint64_t v62 = v52 - (void)v54 - 8;
    if (v62 < 0x58) {
      goto LABEL_324;
    }
    if ((unint64_t)(v54 - v59) < 0x20) {
      goto LABEL_324;
    }
    uint64_t v63 = (v62 >> 3) + 1;
    v64 = &v59[8 * v55 - 16];
    v65 = (long long *)(v52 - 16);
    uint64_t v66 = v63 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v67 = *v65;
      *(v64 - 1) = *(v65 - 1);
      _OWORD *v64 = v67;
      v64 -= 2;
      v65 -= 2;
      v66 -= 4;
    }
    while (v66);
    v60 -= v63 & 0x3FFFFFFFFFFFFFFCLL;
    v52 -= 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
    if (v63 != (v63 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_324:
      do
      {
        uint64_t v68 = *(void *)(v52 - 8);
        v52 -= 8;
        *--v60 = v68;
      }
      while ((unsigned char *)v52 != v54);
    }
  }
  *(void *)(a1 + 168) = v60;
  *(void *)(a1 + 176) = v53;
  *(void *)(a1 + 184) = v61;
  if (v54) {
    operator delete(v54);
  }
LABEL_73:
  *(void *)(a1 + 176) = v53;
  v69 = (uint64_t *)(a1 + 56);
  unint64_t v70 = *(void *)(a1 + 64);
  if (v70)
  {
    uint8x8_t v71 = (uint8x8_t)vcnt_s8((int8x8_t)v70);
    v71.i16[0] = vaddlv_u8(v71);
    if (v71.u32[0] > 1uLL)
    {
      unint64_t v53 = v8;
      if (v8 >= v70) {
        unint64_t v53 = v8 % v70;
      }
    }
    else
    {
      unint64_t v53 = (v70 - 1) & v8;
    }
    v72 = *(void **)(*v69 + 8 * v53);
    if (v72)
    {
      v73 = (void *)*v72;
      if (v73)
      {
        if (v71.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v75 = v73[1];
            if (v75 == v8)
            {
              if (v73[2] == v8) {
                goto LABEL_133;
              }
            }
            else if ((v75 & (v70 - 1)) != v53)
            {
              goto LABEL_94;
            }
            v73 = (void *)*v73;
            if (!v73) {
              goto LABEL_94;
            }
          }
        }
        do
        {
          unint64_t v74 = v73[1];
          if (v74 == v8)
          {
            if (v73[2] == v8) {
              goto LABEL_133;
            }
          }
          else
          {
            if (v74 >= v70) {
              v74 %= v70;
            }
            if (v74 != v53) {
              break;
            }
          }
          v73 = (void *)*v73;
        }
        while (v73);
      }
    }
  }
LABEL_94:
  unint64_t v52 = (unint64_t)operator new(0x30uLL);
  *(void *)unint64_t v52 = 0;
  *(void *)(v52 + 8) = v8;
  *(void *)(v52 + 16) = v8;
  *(int64x2_t *)(v52 + 24) = vdupq_n_s64(1uLL);
  *(unsigned char *)(v52 + 40) = 0;
  float v76 = (float)(unint64_t)(*(void *)(a1 + 80) + 1);
  float v77 = *(float *)(a1 + 88);
  if (!v70 || (float)(v77 * (float)v70) < v76)
  {
    BOOL v78 = v70 < 3 || (v70 & (v70 - 1)) != 0;
    unint64_t v79 = v78 | (2 * v70);
    unint64_t v80 = vcvtps_u32_f32(v76 / v77);
    if (v79 <= v80) {
      size_t prime = v80;
    }
    else {
      size_t prime = v79;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v70 = *(void *)(a1 + 64);
    }
    if (prime > v70) {
      goto LABEL_107;
    }
    if (prime < v70)
    {
      unint64_t v82 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 80) / *(float *)(a1 + 88));
      if (v70 < 3 || (uint8x8_t v83 = (uint8x8_t)vcnt_s8((int8x8_t)v70), v83.i16[0] = vaddlv_u8(v83), v83.u32[0] > 1uLL))
      {
        unint64_t v82 = std::__next_prime(v82);
      }
      else
      {
        uint64_t v84 = 1 << -(char)__clz(v82 - 1);
        if (v82 >= 2) {
          unint64_t v82 = v84;
        }
      }
      if (prime <= v82) {
        size_t prime = v82;
      }
      if (prime < v70) {
LABEL_107:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 56, prime);
    }
    unint64_t v70 = *(void *)(a1 + 64);
    if ((v70 & (v70 - 1)) != 0)
    {
      if (v8 >= v70) {
        unint64_t v53 = v8 % v70;
      }
      else {
        unint64_t v53 = v8;
      }
    }
    else
    {
      unint64_t v53 = (v70 - 1) & v8;
    }
  }
  uint64_t v85 = *v69;
  v86 = *(unint64_t **)(*v69 + 8 * v53);
  if (v86)
  {
    *(void *)unint64_t v52 = *v86;
LABEL_131:
    unint64_t *v86 = v52;
    goto LABEL_132;
  }
  *(void *)unint64_t v52 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = v52;
  *(void *)(v85 + 8 * v53) = a1 + 72;
  if (*(void *)v52)
  {
    unint64_t v87 = *(void *)(*(void *)v52 + 8);
    if ((v70 & (v70 - 1)) != 0)
    {
      if (v87 >= v70) {
        v87 %= v70;
      }
    }
    else
    {
      v87 &= v70 - 1;
    }
    v86 = (unint64_t *)(*v69 + 8 * v87);
    goto LABEL_131;
  }
LABEL_132:
  ++*(void *)(a1 + 80);
LABEL_133:
  unint64_t v88 = (v34 + ((v33 - 0x61C8864680B583EBLL) << 6) - 0x3A3AA7D820E2E4E6) ^ (v33
                                                                                             - 0x61C8864680B583EBLL);
  unint64_t v89 = ((v88 << 6) + BYTE1(v33) + (v88 >> 2) - 0x61C8864680B583EBLL) ^ v88;
  unint64_t v90 = *(void *)(a1 + 240);
  if (v90)
  {
    uint8x8_t v91 = (uint8x8_t)vcnt_s8((int8x8_t)v90);
    v91.i16[0] = vaddlv_u8(v91);
    if (v91.u32[0] > 1uLL)
    {
      unint64_t v52 = ((v88 << 6) + BYTE1(v33) + (v88 >> 2) - 0x61C8864680B583EBLL) ^ v88;
      if (v89 >= v90) {
        unint64_t v52 = v89 % v90;
      }
    }
    else
    {
      unint64_t v52 = v89 & (v90 - 1);
    }
    v92 = (uint64_t *)*((void *)*v6 + v52);
    if (v92)
    {
      uint64_t v93 = *v92;
      if (*v92)
      {
        if (v91.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v95 = *(void *)(v93 + 8);
            if (v95 == v89)
            {
              if (*(void *)(v93 + 16) == v34
                && __PAIR64__(*(unsigned __int8 *)(v93 + 25), *(unsigned __int8 *)(v93 + 24)) == __PAIR64__(BYTE1(v33), v33))
              {
                goto LABEL_217;
              }
            }
            else if ((v95 & (v90 - 1)) != v52)
            {
              goto LABEL_157;
            }
            uint64_t v93 = *(void *)v93;
            if (!v93) {
              goto LABEL_157;
            }
          }
        }
        do
        {
          unint64_t v94 = *(void *)(v93 + 8);
          if (v94 == v89)
          {
            if (*(void *)(v93 + 16) == v34
              && __PAIR64__(*(unsigned __int8 *)(v93 + 25), *(unsigned __int8 *)(v93 + 24)) == __PAIR64__(BYTE1(v33), v33))
            {
              goto LABEL_217;
            }
          }
          else
          {
            if (v94 >= v90) {
              v94 %= v90;
            }
            if (v94 != v52) {
              break;
            }
          }
          uint64_t v93 = *(void *)v93;
        }
        while (v93);
      }
    }
  }
LABEL_157:
  uint64_t v93 = (uint64_t)operator new(0x28uLL);
  *(void *)uint64_t v93 = 0;
  *(void *)(v93 + 8) = v89;
  *(void *)(v93 + 16) = v34;
  *(void *)(v93 + 24) = v33;
  *(void *)(v93 + 32) = 0;
  float v96 = (float)(unint64_t)(*(void *)(a1 + 256) + 1);
  float v97 = *(float *)(a1 + 264);
  if (!v90 || (float)(v97 * (float)v90) < v96)
  {
    BOOL v98 = 1;
    if (v90 >= 3) {
      BOOL v98 = (v90 & (v90 - 1)) != 0;
    }
    unint64_t v99 = v98 | (2 * v90);
    unint64_t v100 = vcvtps_u32_f32(v96 / v97);
    if (v99 <= v100) {
      size_t v101 = v100;
    }
    else {
      size_t v101 = v99;
    }
    if (v101 == 1)
    {
      size_t v101 = 2;
    }
    else if ((v101 & (v101 - 1)) != 0)
    {
      size_t v101 = std::__next_prime(v101);
      unint64_t v90 = *(void *)(a1 + 240);
    }
    if (v101 <= v90)
    {
      if (v101 >= v90) {
        goto LABEL_194;
      }
      unint64_t v113 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 256) / *(float *)(a1 + 264));
      if (v90 < 3 || (uint8x8_t v114 = (uint8x8_t)vcnt_s8((int8x8_t)v90), v114.i16[0] = vaddlv_u8(v114), v114.u32[0] > 1uLL))
      {
        unint64_t v113 = std::__next_prime(v113);
      }
      else
      {
        uint64_t v115 = 1 << -(char)__clz(v113 - 1);
        if (v113 >= 2) {
          unint64_t v113 = v115;
        }
      }
      if (v101 <= v113) {
        size_t v101 = v113;
      }
      if (v101 >= v90)
      {
        unint64_t v90 = *(void *)(a1 + 240);
LABEL_194:
        if ((v90 & (v90 - 1)) != 0)
        {
          if (v89 >= v90) {
            unint64_t v52 = v89 % v90;
          }
          else {
            unint64_t v52 = v89;
          }
        }
        else
        {
          unint64_t v52 = (v90 - 1) & v89;
        }
        goto LABEL_207;
      }
      if (!v101)
      {
        v158 = *v6;
        *uint64_t v6 = 0;
        if (v158) {
          operator delete(v158);
        }
        unint64_t v90 = 0;
        *(void *)(a1 + 240) = 0;
        goto LABEL_194;
      }
    }
    if (v101 >> 61) {
      goto LABEL_319;
    }
    v102 = operator new(8 * v101);
    v103 = *v6;
    *uint64_t v6 = v102;
    if (v103) {
      operator delete(v103);
    }
    uint64_t v104 = 0;
    *(void *)(a1 + 240) = v101;
    do
      *((void *)*v6 + v104++) = 0;
    while (v101 != v104);
    uint64_t v106 = a1 + 248;
    v105 = *(void **)(a1 + 248);
    if (!v105)
    {
LABEL_193:
      unint64_t v90 = v101;
      goto LABEL_194;
    }
    size_t v107 = v105[1];
    size_t v108 = v101 - 1;
    if ((v101 & (v101 - 1)) == 0)
    {
      size_t v109 = v107 & v108;
      *((void *)*v6 + v109) = v106;
      for (i = (void *)*v105; *v105; i = (void *)*v105)
      {
        size_t v111 = i[1] & v108;
        if (v111 == v109)
        {
          v105 = i;
        }
        else if (*((void *)*v6 + v111))
        {
          void *v105 = *i;
          uint64_t v112 = 8 * v111;
          void *i = **(void **)((char *)*v6 + v112);
          **(void **)((char *)*v6 + v112) = i;
        }
        else
        {
          *((void *)*v6 + v111) = v105;
          v105 = i;
          size_t v109 = v111;
        }
      }
      goto LABEL_193;
    }
    if (v107 >= v101) {
      v107 %= v101;
    }
    *((void *)*v6 + v107) = v106;
    v116 = (void *)*v105;
    if (!*v105) {
      goto LABEL_193;
    }
    while (1)
    {
      size_t v118 = v116[1];
      if (v118 >= v101) {
        v118 %= v101;
      }
      if (v118 != v107)
      {
        if (!*((void *)*v6 + v118))
        {
          *((void *)*v6 + v118) = v105;
          goto LABEL_198;
        }
        void *v105 = *v116;
        uint64_t v117 = 8 * v118;
        void *v116 = **(void **)((char *)*v6 + v117);
        **(void **)((char *)*v6 + v117) = v116;
        v116 = v105;
      }
      size_t v118 = v107;
LABEL_198:
      v105 = v116;
      v116 = (void *)*v116;
      size_t v107 = v118;
      if (!v116) {
        goto LABEL_193;
      }
    }
  }
LABEL_207:
  v119 = *v6;
  v120 = (uint64_t *)*((void *)*v6 + v52);
  if (v120)
  {
    *(void *)uint64_t v93 = *v120;
LABEL_215:
    uint64_t *v120 = v93;
    goto LABEL_216;
  }
  *(void *)uint64_t v93 = *(void *)(a1 + 248);
  *(void *)(a1 + 248) = v93;
  v119[v52] = a1 + 248;
  if (*(void *)v93)
  {
    unint64_t v121 = *(void *)(*(void *)v93 + 8);
    if ((v90 & (v90 - 1)) != 0)
    {
      if (v121 >= v90) {
        v121 %= v90;
      }
    }
    else
    {
      v121 &= v90 - 1;
    }
    v120 = (uint64_t *)((char *)*v6 + 8 * v121);
    goto LABEL_215;
  }
LABEL_216:
  ++*(void *)(a1 + 256);
LABEL_217:
  *(void *)(v93 + 32) = v8;
  unint64_t v122 = *(void *)(a1 + 280);
  if (v122)
  {
    uint8x8_t v123 = (uint8x8_t)vcnt_s8((int8x8_t)v122);
    v123.i16[0] = vaddlv_u8(v123);
    if (v123.u32[0] > 1uLL)
    {
      uint64_t v93 = v8;
      if (v8 >= v122) {
        uint64_t v93 = v8 % v122;
      }
    }
    else
    {
      uint64_t v93 = (v122 - 1) & v8;
    }
    v124 = *(void **)(*(void *)(a1 + 272) + 8 * v93);
    if (v124)
    {
      v125 = (void *)*v124;
      if (*v124)
      {
        if (v123.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v127 = v125[1];
            if (v127 == v8)
            {
              if (v125[2] == v8) {
                goto LABEL_298;
              }
            }
            else if ((v127 & (v122 - 1)) != v93)
            {
              goto LABEL_238;
            }
            v125 = (void *)*v125;
            if (!v125) {
              goto LABEL_238;
            }
          }
        }
        do
        {
          unint64_t v126 = v125[1];
          if (v126 == v8)
          {
            if (v125[2] == v8) {
              goto LABEL_298;
            }
          }
          else
          {
            if (v126 >= v122) {
              v126 %= v122;
            }
            if (v126 != v93) {
              break;
            }
          }
          v125 = (void *)*v125;
        }
        while (v125);
      }
    }
  }
LABEL_238:
  v125 = operator new(0x28uLL);
  void *v125 = 0;
  v125[1] = v8;
  v125[3] = 0;
  v125[4] = 0;
  v125[2] = v8;
  float v128 = (float)(unint64_t)(*(void *)(a1 + 296) + 1);
  float v129 = *(float *)(a1 + 304);
  if (!v122 || (float)(v129 * (float)v122) < v128)
  {
    BOOL v130 = 1;
    if (v122 >= 3) {
      BOOL v130 = (v122 & (v122 - 1)) != 0;
    }
    unint64_t v131 = v130 | (2 * v122);
    unint64_t v132 = vcvtps_u32_f32(v128 / v129);
    if (v131 <= v132) {
      size_t v133 = v132;
    }
    else {
      size_t v133 = v131;
    }
    if (v133 == 1)
    {
      size_t v133 = 2;
    }
    else if ((v133 & (v133 - 1)) != 0)
    {
      size_t v133 = std::__next_prime(v133);
      unint64_t v122 = *(void *)(a1 + 280);
    }
    if (v133 <= v122)
    {
      if (v133 >= v122) {
        goto LABEL_275;
      }
      unint64_t v146 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 296) / *(float *)(a1 + 304));
      if (v122 < 3 || (uint8x8_t v147 = (uint8x8_t)vcnt_s8((int8x8_t)v122), v147.i16[0] = vaddlv_u8(v147), v147.u32[0] > 1uLL))
      {
        unint64_t v146 = std::__next_prime(v146);
      }
      else
      {
        uint64_t v148 = 1 << -(char)__clz(v146 - 1);
        if (v146 >= 2) {
          unint64_t v146 = v148;
        }
      }
      if (v133 <= v146) {
        size_t v133 = v146;
      }
      if (v133 >= v122)
      {
        unint64_t v122 = *(void *)(a1 + 280);
LABEL_275:
        if ((v122 & (v122 - 1)) != 0)
        {
          if (v8 >= v122) {
            uint64_t v93 = v8 % v122;
          }
          else {
            uint64_t v93 = v8;
          }
        }
        else
        {
          uint64_t v93 = (v122 - 1) & v8;
        }
        goto LABEL_288;
      }
      if (!v133)
      {
        v159 = *(void **)(a1 + 272);
        *(void *)(a1 + 272) = 0;
        if (v159) {
          operator delete(v159);
        }
        unint64_t v122 = 0;
        *(void *)(a1 + 280) = 0;
        goto LABEL_275;
      }
    }
    if (!(v133 >> 61))
    {
      v134 = operator new(8 * v133);
      v135 = *(void **)(a1 + 272);
      *(void *)(a1 + 272) = v134;
      if (v135) {
        operator delete(v135);
      }
      uint64_t v136 = 0;
      *(void *)(a1 + 280) = v133;
      do
        *(void *)(*(void *)(a1 + 272) + 8 * v136++) = 0;
      while (v133 != v136);
      v137 = *(void **)(a1 + 288);
      if (!v137) {
        goto LABEL_274;
      }
      uint64_t v138 = a1 + 288;
      size_t v139 = v137[1];
      size_t v140 = v133 - 1;
      if ((v133 & (v133 - 1)) == 0)
      {
        size_t v141 = v139 & v140;
        *(void *)(*(void *)(a1 + 272) + 8 * v141) = v138;
        for (j = (void *)*v137; *v137; j = (void *)*v137)
        {
          size_t v143 = j[1] & v140;
          if (v143 == v141)
          {
            v137 = j;
          }
          else
          {
            uint64_t v144 = *(void *)(a1 + 272);
            if (*(void *)(v144 + 8 * v143))
            {
              void *v137 = *j;
              uint64_t v145 = 8 * v143;
              void *j = **(void **)(*(void *)(a1 + 272) + v145);
              **(void **)(*(void *)(a1 + 272) + v145) = j;
            }
            else
            {
              *(void *)(v144 + 8 * v143) = v137;
              v137 = j;
              size_t v141 = v143;
            }
          }
        }
LABEL_274:
        unint64_t v122 = v133;
        goto LABEL_275;
      }
      if (v139 >= v133) {
        v139 %= v133;
      }
      *(void *)(*(void *)(a1 + 272) + 8 * v139) = v138;
      v149 = (void *)*v137;
      if (!*v137) {
        goto LABEL_274;
      }
      while (1)
      {
        size_t v151 = v149[1];
        if (v151 >= v133) {
          v151 %= v133;
        }
        if (v151 != v139)
        {
          uint64_t v152 = *(void *)(a1 + 272);
          if (!*(void *)(v152 + 8 * v151))
          {
            *(void *)(v152 + 8 * v151) = v137;
            goto LABEL_279;
          }
          void *v137 = *v149;
          uint64_t v150 = 8 * v151;
          void *v149 = **(void **)(*(void *)(a1 + 272) + v150);
          **(void **)(*(void *)(a1 + 272) + v150) = v149;
          v149 = v137;
        }
        size_t v151 = v139;
LABEL_279:
        v137 = v149;
        v149 = (void *)*v149;
        size_t v139 = v151;
        if (!v149) {
          goto LABEL_274;
        }
      }
    }
LABEL_319:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_288:
  uint64_t v153 = *(void *)(a1 + 272);
  v154 = *(void **)(v153 + 8 * v93);
  if (v154)
  {
    void *v125 = *v154;
  }
  else
  {
    uint64_t v155 = *(void *)(a1 + 288);
    void *v125 = v155;
    *(void *)(a1 + 288) = v125;
    *(void *)(v153 + 8 * v93) = a1 + 288;
    if (!v155) {
      goto LABEL_297;
    }
    unint64_t v156 = *(void *)(v155 + 8);
    if ((v122 & (v122 - 1)) != 0)
    {
      if (v156 >= v122) {
        v156 %= v122;
      }
    }
    else
    {
      v156 &= v122 - 1;
    }
    v154 = (void *)(*(void *)(a1 + 272) + 8 * v156);
  }
  void *v154 = v125;
LABEL_297:
  ++*(void *)(a1 + 296);
LABEL_298:
  v125[3] = v34;
  *((_WORD *)v125 + 16) = v33;
  return v8;
}

uint64_t **md::MaterialResourceStore::canDeleteMaterial(void *a1, uint64_t a2, uint64_t a3)
{
  v18[0] = a2;
  v18[1] = a3;
  uint64_t v4 = a1 + 29;
  result = std::__hash_table<std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,std::__unordered_map_hasher<md::MaterialKey,std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,md::MaterialKeyHasher,std::equal_to<md::MaterialKey>,true>,std::__unordered_map_equal<md::MaterialKey,std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,std::equal_to<md::MaterialKey>,md::MaterialKeyHasher,true>,std::allocator<std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>>>::find<md::MaterialKey>(a1 + 29, v18);
  if (result)
  {
    unint64_t v6 = (unint64_t)result[4];
    unint64_t v17 = v6;
    if (!v6) {
      return 0;
    }
    uint64_t v7 = std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>((uint64_t)(a1 + 7), v6, &v17)[4];
    if (v7 | std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>((uint64_t)(a1 + 7), v6, &v17)[3])
    {
      return 0;
    }
    else
    {
      geo::packed_array<md::MaterialIDStorage,geo::handle<md::MaterialIDStorage>>::erase((uint64_t)(a1 + 12), &v17);
      int8x8_t v8 = (int8x8_t)a1[8];
      if (v8)
      {
        uint8x8_t v9 = (uint8x8_t)vcnt_s8(v8);
        v9.i16[0] = vaddlv_u8(v9);
        if (v9.u32[0] > 1uLL)
        {
          unint64_t v10 = v6;
          if (v6 >= *(void *)&v8) {
            unint64_t v10 = v6 % *(void *)&v8;
          }
        }
        else
        {
          unint64_t v10 = (*(void *)&v8 - 1) & v6;
        }
        uint64_t v11 = *(void ***)(a1[7] + 8 * v10);
        if (v11)
        {
          unint64_t v12 = *v11;
          if (*v11)
          {
            if (v9.u32[0] < 2uLL)
            {
              uint64_t v13 = *(void *)&v8 - 1;
              while (1)
              {
                uint64_t v15 = v12[1];
                if (v15 == v6)
                {
                  if (v12[2] == v6) {
                    goto LABEL_26;
                  }
                }
                else if ((v15 & v13) != v10)
                {
                  goto LABEL_28;
                }
                unint64_t v12 = (void *)*v12;
                if (!v12) {
                  goto LABEL_28;
                }
              }
            }
            do
            {
              unint64_t v14 = v12[1];
              if (v14 == v6)
              {
                if (v12[2] == v6)
                {
LABEL_26:
                  std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)__p, a1 + 7, v12);
                  if (__p[0]) {
                    operator delete(__p[0]);
                  }
                  break;
                }
              }
              else
              {
                if (v14 >= *(void *)&v8) {
                  v14 %= *(void *)&v8;
                }
                if (v14 != v10) {
                  break;
                }
              }
              unint64_t v12 = (void *)*v12;
            }
            while (v12);
          }
        }
      }
LABEL_28:
      std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::MaterialKey>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::MaterialKey>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::MaterialKey>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::MaterialKey>>>::__erase_unique<geo::handle<md::MaterialIDStorage>>(a1 + 34, v6);
      uint64_t v16 = std::__hash_table<std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,std::__unordered_map_hasher<md::MaterialKey,std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,md::MaterialKeyHasher,std::equal_to<md::MaterialKey>,true>,std::__unordered_map_equal<md::MaterialKey,std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,std::equal_to<md::MaterialKey>,md::MaterialKeyHasher,true>,std::allocator<std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>>>::find<md::MaterialKey>(v4, v18);
      if (v16)
      {
        std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)__p, v4, v16);
        if (__p[0]) {
          operator delete(__p[0]);
        }
      }
      return (uint64_t **)1;
    }
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint8x8_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            unint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unint64_t v10 = operator new(0x30uLL);
  *unint64_t v10 = 0;
  v10[1] = a2;
  v10[2] = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[5] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_44;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_44:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }
  uint64_t v22 = *(void *)a1;
  unint64_t v23 = *(void **)(*(void *)a1 + 8 * v3);
  if (v23)
  {
    *unint64_t v10 = *v23;
LABEL_58:
    void *v23 = v10;
    goto LABEL_59;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    unint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void geo::packed_array<md::MaterialIDStorage,geo::handle<md::MaterialIDStorage>>::erase(uint64_t a1, void *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v2 < (*(void *)(a1 + 32) - v3) >> 3)
  {
    unint64_t v4 = *(void *)(v3 + 8 * v2);
    BOOL v6 = v4 == 0;
    unint64_t v5 = HIDWORD(v4);
    BOOL v6 = !v6 && HIDWORD(*a2) == v5;
    if (v6)
    {
      unint64_t v10 = *(unint64_t **)(a1 + 8);
      unint64_t v9 = *(void *)(a1 + 16);
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = *(unint64_t **)a1;
        uint64_t v13 = (uint64_t)v10 - *(void *)a1;
        uint64_t v14 = v13 >> 3;
        unint64_t v15 = (v13 >> 3) + 1;
        if (v15 >> 61) {
          abort();
        }
        uint64_t v16 = v9 - (void)v12;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * v17);
        }
        else
        {
          uint64_t v18 = 0;
        }
        unint64_t v19 = (unint64_t *)&v18[8 * v14];
        uint8x8_t v20 = &v18[8 * v17];
        *unint64_t v19 = v2;
        unint64_t v11 = v19 + 1;
        if (v10 != v12)
        {
          unint64_t v21 = (char *)v10 - (char *)v12 - 8;
          if (v21 < 0x58) {
            goto LABEL_34;
          }
          if ((unint64_t)((char *)v10 - v18 - v13) < 0x20) {
            goto LABEL_34;
          }
          uint64_t v22 = (v21 >> 3) + 1;
          unint64_t v23 = &v18[8 * v14 - 16];
          unint64_t v24 = v10 - 2;
          uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v26 = *(_OWORD *)v24;
            *(v23 - 1) = *((_OWORD *)v24 - 1);
            _OWORD *v23 = v26;
            v23 -= 2;
            v24 -= 4;
            v25 -= 4;
          }
          while (v25);
          v19 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          v10 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_34:
            do
            {
              unint64_t v27 = *--v10;
              *--unint64_t v19 = v27;
            }
            while (v10 != v12);
          }
        }
        *(void *)a1 = v19;
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = v20;
        if (v12)
        {
          operator delete(v12);
          uint64_t v3 = *(void *)(a1 + 24);
        }
      }
      else
      {
        *unint64_t v10 = v2;
        unint64_t v11 = v10 + 1;
      }
      *(void *)(a1 + 8) = v11;
      uint64_t v28 = *(void *)(v3 + 8 * *(unsigned int *)a2);
      uint64_t v30 = *(void *)(a1 + 48);
      uint64_t v29 = *(void *)(a1 + 56);
      uint64_t v31 = 8 * v28;
      uint64_t v32 = *(void *)(v30 + v31);
      uint64_t v33 = *(void *)(v29 - v30 + *(void *)(a1 + 72) - 8);
      *(void *)(v30 + v31) = *(void *)(v29 - 8);
      *(void *)(v29 - 8) = v32;
      *(_DWORD *)(v3 + 8 * v33) = v28;
      uint64_t v34 = *(void *)(a1 + 72);
      uint64_t v35 = *(void **)(a1 + 80);
      uint64_t v36 = *(void *)(v34 + v31);
      uint64_t v37 = *--v35;
      *(void *)(v34 + v31) = v37;
      *uint64_t v35 = v36;
      *(void *)(a1 + 56) -= 8;
      *(void *)(a1 + 80) = v35;
      uint64_t v38 = 8 * *(unsigned int *)a2;
      *(_DWORD *)(*(void *)(a1 + 24) + v38 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 24) + v38 + 4) << 32)
                                                   + 0x100000000) >> 32;
      *(_DWORD *)(*(void *)(a1 + 24) + v38) = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    }
  }
}

void std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::MaterialKey>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::MaterialKey>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::MaterialKey>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::MaterialKey>>>::__erase_unique<geo::handle<md::MaterialIDStorage>>(uint64_t *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (*(void *)&v2 <= a2) {
        unint64_t v4 = a2 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v4 = (*(void *)&v2 - 1) & a2;
    }
    uint64_t v5 = *a1;
    BOOL v6 = *(uint64_t ***)(*a1 + 8 * v4);
    if (v6)
    {
      unint64_t v7 = *v6;
      if (v7)
      {
        uint64_t v8 = *(void *)&v2 - 1;
        if (v3.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v9 = v7[1];
            if (v9 == a2)
            {
              if (v7[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v9 & v8) != v4)
            {
              return;
            }
            unint64_t v7 = (uint64_t *)*v7;
            if (!v7) {
              return;
            }
          }
        }
        do
        {
          unint64_t v10 = v7[1];
          if (v10 == a2)
          {
            if (v7[2] == a2)
            {
LABEL_22:
              if (v3.u32[0] > 1uLL)
              {
                if (*(void *)&v2 <= a2) {
                  a2 %= *(void *)&v2;
                }
              }
              else
              {
                a2 &= v8;
              }
              unint64_t v11 = *(uint64_t **)(v5 + 8 * a2);
              do
              {
                uint64_t v12 = v11;
                unint64_t v11 = (uint64_t *)*v11;
              }
              while (v11 != v7);
              if (v12 == a1 + 2) {
                goto LABEL_39;
              }
              unint64_t v13 = v12[1];
              if (v3.u32[0] > 1uLL)
              {
                if (v13 >= *(void *)&v2) {
                  v13 %= *(void *)&v2;
                }
              }
              else
              {
                v13 &= v8;
              }
              if (v13 != a2)
              {
LABEL_39:
                if (!*v7) {
                  goto LABEL_40;
                }
                unint64_t v14 = *(void *)(*v7 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v14 >= *(void *)&v2) {
                    v14 %= *(void *)&v2;
                  }
                }
                else
                {
                  v14 &= v8;
                }
                if (v14 != a2) {
LABEL_40:
                }
                  *(void *)(v5 + 8 * a2) = 0;
              }
              uint64_t v15 = *v7;
              if (*v7)
              {
                unint64_t v16 = *(void *)(v15 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v16 >= *(void *)&v2) {
                    v16 %= *(void *)&v2;
                  }
                }
                else
                {
                  v16 &= v8;
                }
                if (v16 != a2)
                {
                  *(void *)(*a1 + 8 * v16) = v12;
                  uint64_t v15 = *v7;
                }
              }
              *uint64_t v12 = v15;
              *unint64_t v7 = 0;
              --a1[3];
              operator delete(v7);
              return;
            }
          }
          else
          {
            if (v10 >= *(void *)&v2) {
              v10 %= *(void *)&v2;
            }
            if (v10 != v4) {
              return;
            }
          }
          unint64_t v7 = (uint64_t *)*v7;
        }
        while (v7);
      }
    }
  }
}

unint64_t md::MaterialResourceStore::createColorData(uint64_t a1, long long *a2, uint64_t a3)
{
  if (!*(unsigned char *)(a3 + 16))
  {
    uint64_t v6 = gdc::FamilyInfo<UniqueKey,unsigned long long>::Counter::nextId(void)::counter++;
    *(unsigned char *)(a3 + 16) = 1;
    *(void *)a3 = v6 - 0x61C8864680B583EBLL;
    *(void *)(a3 + 8) = 0;
  }
  unint64_t v7 = (void **)(a1 + 1120);
  uint64_t v8 = std::__hash_table<std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,std::__unordered_map_hasher<md::MaterialKey,std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,md::MaterialKeyHasher,std::equal_to<md::MaterialKey>,true>,std::__unordered_map_equal<md::MaterialKey,std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>,std::equal_to<md::MaterialKey>,md::MaterialKeyHasher,true>,std::allocator<std::__hash_value_type<md::MaterialKey,geo::handle<md::MaterialIDStorage>>>>::find<md::MaterialKey>((void *)(a1 + 1120), (uint64_t *)a3);
  if (v8)
  {
    unint64_t v9 = (unint64_t)v8[4];
    if (v9) {
      return v9;
    }
  }
  int v10 = *((_DWORD *)a2 + 4);
  long long v158 = *a2;
  uint64_t v11 = *(void *)(a1 + 992);
  if (*(void *)(a1 + 984) == v11)
  {
    uint64_t v13 = (-858993459 * ((*(void *)(a1 + 1040) - *(void *)(a1 + 1032)) >> 2)) | 0x100000000;
    unint64_t v14 = *(uint64_t **)(a1 + 1016);
    unint64_t v15 = *(void *)(a1 + 1024);
    if ((unint64_t)v14 >= v15)
    {
      unint64_t v17 = *(uint64_t **)(a1 + 1008);
      uint64_t v18 = v14 - v17;
      unint64_t v19 = v18 + 1;
      if ((unint64_t)(v18 + 1) >> 61) {
        goto LABEL_313;
      }
      uint64_t v20 = v15 - (void)v17;
      if (v20 >> 2 > v19) {
        unint64_t v19 = v20 >> 2;
      }
      if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v21 = v19;
      }
      if (v21)
      {
        if (v21 >> 61) {
          goto LABEL_312;
        }
        uint64_t v22 = operator new(8 * v21);
      }
      else
      {
        uint64_t v22 = 0;
      }
      unint64_t v23 = (uint64_t *)&v22[8 * v18];
      unint64_t v24 = &v22[8 * v21];
      uint64_t *v23 = v13;
      unint64_t v16 = v23 + 1;
      if (v14 == v17)
      {
        unint64_t v17 = v14;
      }
      else
      {
        unint64_t v25 = (char *)v14 - (char *)v17 - 8;
        if (v25 < 0x58) {
          goto LABEL_316;
        }
        if ((unint64_t)((char *)v17 - v22) < 0x20) {
          goto LABEL_316;
        }
        uint64_t v26 = (v25 >> 3) + 1;
        unint64_t v27 = &v22[8 * v18 - 16];
        uint64_t v28 = v14 - 2;
        uint64_t v29 = v26 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v30 = *(_OWORD *)v28;
          *(v27 - 1) = *((_OWORD *)v28 - 1);
          *unint64_t v27 = v30;
          v27 -= 2;
          v28 -= 4;
          v29 -= 4;
        }
        while (v29);
        v23 -= v26 & 0x3FFFFFFFFFFFFFFCLL;
        v14 -= v26 & 0x3FFFFFFFFFFFFFFCLL;
        if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_316:
          do
          {
            uint64_t v31 = *--v14;
            *--unint64_t v23 = v31;
          }
          while (v14 != v17);
          unint64_t v17 = *(uint64_t **)(a1 + 1008);
        }
      }
      *(void *)(a1 + 1008) = v23;
      *(void *)(a1 + 1016) = v16;
      *(void *)(a1 + 1024) = v24;
      if (v17) {
        operator delete(v17);
      }
    }
    else
    {
      uint64_t *v14 = v13;
      unint64_t v16 = v14 + 1;
    }
    *(void *)(a1 + 1016) = v16;
    unint64_t v9 = *(v16 - 1);
  }
  else
  {
    uint64_t v12 = *(void *)(v11 - 8);
    *(void *)(a1 + 992) = v11 - 8;
    *(_DWORD *)(*(void *)(a1 + 1008) + 8 * v12) = -858993459
                                                  * ((*(void *)(a1 + 1040) - *(void *)(a1 + 1032)) >> 2);
    *(_DWORD *)(*(void *)(a1 + 1008) + 8 * v12 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 1008)
                                                                                            + 8 * v12
                                                                                            + 4) << 32)
                                                       + 0x100000000) >> 32;
    unint64_t v9 = v12 | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 1008) + 8 * v12 + 4) << 32);
  }
  uint64_t v32 = *(char **)(a1 + 1040);
  unint64_t v33 = *(void *)(a1 + 1048);
  if ((unint64_t)v32 >= v33)
  {
    uint64_t v35 = *(char **)(a1 + 1032);
    unint64_t v36 = 0xCCCCCCCCCCCCCCCDLL * ((v32 - v35) >> 2) + 1;
    if (v36 > 0xCCCCCCCCCCCCCCCLL) {
      goto LABEL_313;
    }
    unint64_t v37 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v33 - (void)v35) >> 2);
    if (2 * v37 > v36) {
      unint64_t v36 = 2 * v37;
    }
    if (v37 >= 0x666666666666666) {
      unint64_t v38 = 0xCCCCCCCCCCCCCCCLL;
    }
    else {
      unint64_t v38 = v36;
    }
    if (v38 > 0xCCCCCCCCCCCCCCCLL) {
      goto LABEL_312;
    }
    uint64_t v39 = 20 * v38;
    unint64_t v40 = (char *)operator new(20 * v38);
    v41 = &v40[4 * ((v32 - v35) >> 2)];
    v42 = &v40[v39];
    *(_OWORD *)v41 = v158;
    *((_DWORD *)v41 + 4) = v10;
    uint64_t v34 = v41 + 20;
    if (v32 == v35)
    {
      v43 = &v40[4 * ((v32 - v35) >> 2)];
    }
    else
    {
      do
      {
        v43 = v41 - 20;
        *(_OWORD *)(v41 - 20) = *(_OWORD *)(v32 - 20);
        *((_DWORD *)v41 - 1) = *((_DWORD *)v32 - 1);
        v32 -= 20;
        v41 -= 20;
      }
      while (v32 != v35);
    }
    *(void *)(a1 + 1032) = v43;
    *(void *)(a1 + 1040) = v34;
    *(void *)(a1 + 1048) = v42;
    if (v35) {
      operator delete(v35);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v32 = v158;
    *((_DWORD *)v32 + 4) = v10;
    uint64_t v34 = v32 + 20;
  }
  *(void *)(a1 + 1040) = v34;
  unint64_t v44 = *(void *)(a1 + 1064);
  unint64_t v45 = *(void *)(a1 + 1072);
  if (v44 < v45)
  {
    *(void *)unint64_t v44 = v9;
    v44 += 8;
    unint64_t v46 = v44;
    goto LABEL_67;
  }
  v47 = *(unsigned char **)(a1 + 1056);
  uint64_t v48 = (uint64_t)(v44 - (void)v47) >> 3;
  unint64_t v49 = v48 + 1;
  if ((unint64_t)(v48 + 1) >> 61) {
LABEL_313:
  }
    abort();
  uint64_t v50 = v45 - (void)v47;
  if (v50 >> 2 > v49) {
    unint64_t v49 = v50 >> 2;
  }
  if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v51 = v49;
  }
  if (v51)
  {
    if (v51 >> 61) {
      goto LABEL_312;
    }
    unint64_t v52 = operator new(8 * v51);
  }
  else
  {
    unint64_t v52 = 0;
  }
  unint64_t v53 = &v52[8 * v48];
  v54 = &v52[8 * v51];
  *unint64_t v53 = v9;
  unint64_t v46 = (unint64_t)(v53 + 1);
  if ((unsigned char *)v44 != v47)
  {
    unint64_t v55 = v44 - (void)v47 - 8;
    if (v55 < 0x58) {
      goto LABEL_317;
    }
    if ((unint64_t)(v47 - v52) < 0x20) {
      goto LABEL_317;
    }
    uint64_t v56 = (v55 >> 3) + 1;
    uint64_t v57 = &v52[8 * v48 - 16];
    unint64_t v58 = (long long *)(v44 - 16);
    uint64_t v59 = v56 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v60 = *v58;
      *(v57 - 1) = *(v58 - 1);
      *uint64_t v57 = v60;
      v57 -= 2;
      v58 -= 2;
      v59 -= 4;
    }
    while (v59);
    v53 -= v56 & 0x3FFFFFFFFFFFFFFCLL;
    v44 -= 8 * (v56 & 0x3FFFFFFFFFFFFFFCLL);
    if (v56 != (v56 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_317:
      do
      {
        uint64_t v61 = *(void *)(v44 - 8);
        v44 -= 8;
        *--unint64_t v53 = v61;
      }
      while ((unsigned char *)v44 != v47);
    }
  }
  *(void *)(a1 + 1056) = v53;
  *(void *)(a1 + 1064) = v46;
  *(void *)(a1 + 1072) = v54;
  if (v47) {
    operator delete(v47);
  }
LABEL_67:
  *(void *)(a1 + 1064) = v46;
  unint64_t v62 = (uint64_t *)(a1 + 944);
  unint64_t v63 = *(void *)(a1 + 952);
  if (v63)
  {
    uint8x8_t v64 = (uint8x8_t)vcnt_s8((int8x8_t)v63);
    v64.i16[0] = vaddlv_u8(v64);
    if (v64.u32[0] > 1uLL)
    {
      unint64_t v46 = v9;
      if (v9 >= v63) {
        unint64_t v46 = v9 % v63;
      }
    }
    else
    {
      unint64_t v46 = (v63 - 1) & v9;
    }
    v65 = *(void **)(*v62 + 8 * v46);
    if (v65)
    {
      uint64_t v66 = (void *)*v65;
      if (v66)
      {
        if (v64.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v68 = v66[1];
            if (v68 == v9)
            {
              if (v66[2] == v9) {
                goto LABEL_127;
              }
            }
            else if ((v68 & (v63 - 1)) != v46)
            {
              goto LABEL_88;
            }
            uint64_t v66 = (void *)*v66;
            if (!v66) {
              goto LABEL_88;
            }
          }
        }
        do
        {
          unint64_t v67 = v66[1];
          if (v67 == v9)
          {
            if (v66[2] == v9) {
              goto LABEL_127;
            }
          }
          else
          {
            if (v67 >= v63) {
              v67 %= v63;
            }
            if (v67 != v46) {
              break;
            }
          }
          uint64_t v66 = (void *)*v66;
        }
        while (v66);
      }
    }
  }
LABEL_88:
  unint64_t v44 = (unint64_t)operator new(0x30uLL);
  *(void *)unint64_t v44 = 0;
  *(void *)(v44 + 8) = v9;
  *(void *)(v44 + 16) = v9;
  *(int64x2_t *)(v44 + 24) = vdupq_n_s64(1uLL);
  *(unsigned char *)(v44 + 40) = 0;
  float v69 = (float)(unint64_t)(*(void *)(a1 + 968) + 1);
  float v70 = *(float *)(a1 + 976);
  if (!v63 || (float)(v70 * (float)v63) < v69)
  {
    BOOL v71 = v63 < 3 || (v63 & (v63 - 1)) != 0;
    unint64_t v72 = v71 | (2 * v63);
    unint64_t v73 = vcvtps_u32_f32(v69 / v70);
    if (v72 <= v73) {
      size_t prime = v73;
    }
    else {
      size_t prime = v72;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v63 = *(void *)(a1 + 952);
    }
    if (prime > v63) {
      goto LABEL_101;
    }
    if (prime < v63)
    {
      unint64_t v75 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 968) / *(float *)(a1 + 976));
      if (v63 < 3 || (uint8x8_t v76 = (uint8x8_t)vcnt_s8((int8x8_t)v63), v76.i16[0] = vaddlv_u8(v76), v76.u32[0] > 1uLL))
      {
        unint64_t v75 = std::__next_prime(v75);
      }
      else
      {
        uint64_t v77 = 1 << -(char)__clz(v75 - 1);
        if (v75 >= 2) {
          unint64_t v75 = v77;
        }
      }
      if (prime <= v75) {
        size_t prime = v75;
      }
      if (prime < v63) {
LABEL_101:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 944, prime);
    }
    unint64_t v63 = *(void *)(a1 + 952);
    if ((v63 & (v63 - 1)) != 0)
    {
      if (v9 >= v63) {
        unint64_t v46 = v9 % v63;
      }
      else {
        unint64_t v46 = v9;
      }
    }
    else
    {
      unint64_t v46 = (v63 - 1) & v9;
    }
  }
  uint64_t v78 = *v62;
  unint64_t v79 = *(unint64_t **)(*v62 + 8 * v46);
  if (v79)
  {
    *(void *)unint64_t v44 = *v79;
LABEL_125:
    *unint64_t v79 = v44;
    goto LABEL_126;
  }
  *(void *)unint64_t v44 = *(void *)(a1 + 960);
  *(void *)(a1 + 960) = v44;
  *(void *)(v78 + 8 * v46) = a1 + 960;
  if (*(void *)v44)
  {
    unint64_t v80 = *(void *)(*(void *)v44 + 8);
    if ((v63 & (v63 - 1)) != 0)
    {
      if (v80 >= v63) {
        v80 %= v63;
      }
    }
    else
    {
      v80 &= v63 - 1;
    }
    unint64_t v79 = (unint64_t *)(*v62 + 8 * v80);
    goto LABEL_125;
  }
LABEL_126:
  ++*(void *)(a1 + 968);
LABEL_127:
  uint64_t v81 = *(unsigned __int8 *)(a3 + 8);
  uint64_t v82 = *(void *)a3;
  unint64_t v83 = (*(void *)a3 + ((v81 - 0x61C8864680B583EBLL) << 6) - 0x3A3AA7D820E2E4E6) ^ (v81 - 0x61C8864680B583EBLL);
  uint64_t v84 = *(unsigned __int8 *)(a3 + 9);
  unint64_t v85 = (v84 | (v83 << 6)) + (v83 >> 2);
  unint64_t v86 = (v85 - 0x61C8864680B583EBLL) ^ v83;
  unint64_t v87 = *(void *)(a1 + 1128);
  if (v87)
  {
    uint8x8_t v88 = (uint8x8_t)vcnt_s8((int8x8_t)v87);
    v88.i16[0] = vaddlv_u8(v88);
    if (v88.u32[0] > 1uLL)
    {
      unint64_t v44 = (v85 - 0x61C8864680B583EBLL) ^ v83;
      if (v86 >= v87) {
        unint64_t v44 = v86 % v87;
      }
    }
    else
    {
      unint64_t v44 = v86 & (v87 - 1);
    }
    unint64_t v89 = (uint64_t *)*((void *)*v7 + v44);
    if (v89)
    {
      uint64_t v90 = *v89;
      if (*v89)
      {
        if (v88.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v92 = *(void *)(v90 + 8);
            if (v92 == v86)
            {
              if (*(void *)(v90 + 16) == v82
                && __PAIR64__(*(unsigned __int8 *)(v90 + 25), *(unsigned __int8 *)(v90 + 24)) == __PAIR64__(v84, v81))
              {
                goto LABEL_211;
              }
            }
            else if ((v92 & (v87 - 1)) != v44)
            {
              goto LABEL_151;
            }
            uint64_t v90 = *(void *)v90;
            if (!v90) {
              goto LABEL_151;
            }
          }
        }
        do
        {
          unint64_t v91 = *(void *)(v90 + 8);
          if (v91 == v86)
          {
            if (*(void *)(v90 + 16) == v82
              && __PAIR64__(*(unsigned __int8 *)(v90 + 25), *(unsigned __int8 *)(v90 + 24)) == __PAIR64__(v84, v81))
            {
              goto LABEL_211;
            }
          }
          else
          {
            if (v91 >= v87) {
              v91 %= v87;
            }
            if (v91 != v44) {
              break;
            }
          }
          uint64_t v90 = *(void *)v90;
        }
        while (v90);
      }
    }
  }
LABEL_151:
  uint64_t v90 = (uint64_t)operator new(0x28uLL);
  *(void *)uint64_t v90 = 0;
  *(void *)(v90 + 8) = v86;
  *(_OWORD *)(v90 + 16) = *(_OWORD *)a3;
  *(void *)(v90 + 32) = 0;
  float v93 = (float)(unint64_t)(*(void *)(a1 + 1144) + 1);
  float v94 = *(float *)(a1 + 1152);
  if (!v87 || (float)(v94 * (float)v87) < v93)
  {
    BOOL v95 = 1;
    if (v87 >= 3) {
      BOOL v95 = (v87 & (v87 - 1)) != 0;
    }
    unint64_t v96 = v95 | (2 * v87);
    unint64_t v97 = vcvtps_u32_f32(v93 / v94);
    if (v96 <= v97) {
      size_t v98 = v97;
    }
    else {
      size_t v98 = v96;
    }
    if (v98 == 1)
    {
      size_t v98 = 2;
    }
    else if ((v98 & (v98 - 1)) != 0)
    {
      size_t v98 = std::__next_prime(v98);
      unint64_t v87 = *(void *)(a1 + 1128);
    }
    if (v98 <= v87)
    {
      if (v98 >= v87) {
        goto LABEL_188;
      }
      unint64_t v110 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 1144) / *(float *)(a1 + 1152));
      if (v87 < 3 || (uint8x8_t v111 = (uint8x8_t)vcnt_s8((int8x8_t)v87), v111.i16[0] = vaddlv_u8(v111), v111.u32[0] > 1uLL))
      {
        unint64_t v110 = std::__next_prime(v110);
      }
      else
      {
        uint64_t v112 = 1 << -(char)__clz(v110 - 1);
        if (v110 >= 2) {
          unint64_t v110 = v112;
        }
      }
      if (v98 <= v110) {
        size_t v98 = v110;
      }
      if (v98 >= v87)
      {
        unint64_t v87 = *(void *)(a1 + 1128);
LABEL_188:
        if ((v87 & (v87 - 1)) != 0)
        {
          if (v86 >= v87) {
            unint64_t v44 = v86 % v87;
          }
          else {
            unint64_t v44 = v86;
          }
        }
        else
        {
          unint64_t v44 = (v87 - 1) & v86;
        }
        goto LABEL_201;
      }
      if (!v98)
      {
        unint64_t v156 = *v7;
        *unint64_t v7 = 0;
        if (v156) {
          operator delete(v156);
        }
        unint64_t v87 = 0;
        *(void *)(a1 + 1128) = 0;
        goto LABEL_188;
      }
    }
    if (v98 >> 61) {
      goto LABEL_312;
    }
    unint64_t v99 = operator new(8 * v98);
    unint64_t v100 = *v7;
    *unint64_t v7 = v99;
    if (v100) {
      operator delete(v100);
    }
    uint64_t v101 = 0;
    *(void *)(a1 + 1128) = v98;
    do
      *((void *)*v7 + v101++) = 0;
    while (v98 != v101);
    v102 = *(void **)(a1 + 1136);
    if (!v102)
    {
LABEL_187:
      unint64_t v87 = v98;
      goto LABEL_188;
    }
    uint64_t v103 = a1 + 1136;
    size_t v104 = v102[1];
    size_t v105 = v98 - 1;
    if ((v98 & (v98 - 1)) == 0)
    {
      size_t v106 = v104 & v105;
      *((void *)*v7 + v106) = v103;
      for (i = (void *)*v102; *v102; i = (void *)*v102)
      {
        size_t v108 = i[1] & v105;
        if (v108 == v106)
        {
          v102 = i;
        }
        else if (*((void *)*v7 + v108))
        {
          void *v102 = *i;
          uint64_t v109 = 8 * v108;
          void *i = **(void **)((char *)*v7 + v109);
          **(void **)((char *)*v7 + v109) = i;
        }
        else
        {
          *((void *)*v7 + v108) = v102;
          v102 = i;
          size_t v106 = v108;
        }
      }
      goto LABEL_187;
    }
    if (v104 >= v98) {
      v104 %= v98;
    }
    *((void *)*v7 + v104) = v103;
    unint64_t v113 = (void *)*v102;
    if (!*v102) {
      goto LABEL_187;
    }
    while (1)
    {
      size_t v115 = v113[1];
      if (v115 >= v98) {
        v115 %= v98;
      }
      if (v115 != v104)
      {
        if (!*((void *)*v7 + v115))
        {
          *((void *)*v7 + v115) = v102;
          goto LABEL_192;
        }
        void *v102 = *v113;
        uint64_t v114 = 8 * v115;
        *unint64_t v113 = **(void **)((char *)*v7 + v114);
        **(void **)((char *)*v7 + v114) = v113;
        unint64_t v113 = v102;
      }
      size_t v115 = v104;
LABEL_192:
      v102 = v113;
      unint64_t v113 = (void *)*v113;
      size_t v104 = v115;
      if (!v113) {
        goto LABEL_187;
      }
    }
  }
LABEL_201:
  v116 = *v7;
  uint64_t v117 = (uint64_t *)*((void *)*v7 + v44);
  if (v117)
  {
    *(void *)uint64_t v90 = *v117;
LABEL_209:
    *uint64_t v117 = v90;
    goto LABEL_210;
  }
  *(void *)uint64_t v90 = *(void *)(a1 + 1136);
  *(void *)(a1 + 1136) = v90;
  v116[v44] = a1 + 1136;
  if (*(void *)v90)
  {
    unint64_t v118 = *(void *)(*(void *)v90 + 8);
    if ((v87 & (v87 - 1)) != 0)
    {
      if (v118 >= v87) {
        v118 %= v87;
      }
    }
    else
    {
      v118 &= v87 - 1;
    }
    uint64_t v117 = (uint64_t *)((char *)*v7 + 8 * v118);
    goto LABEL_209;
  }
LABEL_210:
  ++*(void *)(a1 + 1144);
LABEL_211:
  *(void *)(v90 + 32) = v9;
  unint64_t v119 = *(void *)(a1 + 1168);
  if (v119)
  {
    uint8x8_t v120 = (uint8x8_t)vcnt_s8((int8x8_t)v119);
    v120.i16[0] = vaddlv_u8(v120);
    if (v120.u32[0] > 1uLL)
    {
      uint64_t v90 = v9;
      if (v9 >= v119) {
        uint64_t v90 = v9 % v119;
      }
    }
    else
    {
      uint64_t v90 = (v119 - 1) & v9;
    }
    unint64_t v121 = *(void **)(*(void *)(a1 + 1160) + 8 * v90);
    if (v121)
    {
      unint64_t v122 = (void *)*v121;
      if (*v121)
      {
        if (v120.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v124 = v122[1];
            if (v124 == v9)
            {
              if (v122[2] == v9) {
                goto LABEL_292;
              }
            }
            else if ((v124 & (v119 - 1)) != v90)
            {
              goto LABEL_232;
            }
            unint64_t v122 = (void *)*v122;
            if (!v122) {
              goto LABEL_232;
            }
          }
        }
        do
        {
          unint64_t v123 = v122[1];
          if (v123 == v9)
          {
            if (v122[2] == v9) {
              goto LABEL_292;
            }
          }
          else
          {
            if (v123 >= v119) {
              v123 %= v119;
            }
            if (v123 != v90) {
              break;
            }
          }
          unint64_t v122 = (void *)*v122;
        }
        while (v122);
      }
    }
  }
LABEL_232:
  unint64_t v122 = operator new(0x28uLL);
  *unint64_t v122 = 0;
  v122[1] = v9;
  v122[3] = 0;
  v122[4] = 0;
  v122[2] = v9;
  float v125 = (float)(unint64_t)(*(void *)(a1 + 1184) + 1);
  float v126 = *(float *)(a1 + 1192);
  if (!v119 || (float)(v126 * (float)v119) < v125)
  {
    BOOL v127 = 1;
    if (v119 >= 3) {
      BOOL v127 = (v119 & (v119 - 1)) != 0;
    }
    unint64_t v128 = v127 | (2 * v119);
    unint64_t v129 = vcvtps_u32_f32(v125 / v126);
    if (v128 <= v129) {
      size_t v130 = v129;
    }
    else {
      size_t v130 = v128;
    }
    if (v130 == 1)
    {
      size_t v130 = 2;
    }
    else if ((v130 & (v130 - 1)) != 0)
    {
      size_t v130 = std::__next_prime(v130);
      unint64_t v119 = *(void *)(a1 + 1168);
    }
    if (v130 <= v119)
    {
      if (v130 >= v119) {
        goto LABEL_269;
      }
      unint64_t v143 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 1184) / *(float *)(a1 + 1192));
      if (v119 < 3 || (uint8x8_t v144 = (uint8x8_t)vcnt_s8((int8x8_t)v119), v144.i16[0] = vaddlv_u8(v144), v144.u32[0] > 1uLL))
      {
        unint64_t v143 = std::__next_prime(v143);
      }
      else
      {
        uint64_t v145 = 1 << -(char)__clz(v143 - 1);
        if (v143 >= 2) {
          unint64_t v143 = v145;
        }
      }
      if (v130 <= v143) {
        size_t v130 = v143;
      }
      if (v130 >= v119)
      {
        unint64_t v119 = *(void *)(a1 + 1168);
LABEL_269:
        if ((v119 & (v119 - 1)) != 0)
        {
          if (v9 >= v119) {
            uint64_t v90 = v9 % v119;
          }
          else {
            uint64_t v90 = v9;
          }
        }
        else
        {
          uint64_t v90 = (v119 - 1) & v9;
        }
        goto LABEL_282;
      }
      if (!v130)
      {
        v157 = *(void **)(a1 + 1160);
        *(void *)(a1 + 1160) = 0;
        if (v157) {
          operator delete(v157);
        }
        unint64_t v119 = 0;
        *(void *)(a1 + 1168) = 0;
        goto LABEL_269;
      }
    }
    if (!(v130 >> 61))
    {
      unint64_t v131 = operator new(8 * v130);
      unint64_t v132 = *(void **)(a1 + 1160);
      *(void *)(a1 + 1160) = v131;
      if (v132) {
        operator delete(v132);
      }
      uint64_t v133 = 0;
      *(void *)(a1 + 1168) = v130;
      do
        *(void *)(*(void *)(a1 + 1160) + 8 * v133++) = 0;
      while (v130 != v133);
      v134 = *(void **)(a1 + 1176);
      if (!v134) {
        goto LABEL_268;
      }
      uint64_t v135 = a1 + 1176;
      size_t v136 = v134[1];
      size_t v137 = v130 - 1;
      if ((v130 & (v130 - 1)) == 0)
      {
        size_t v138 = v136 & v137;
        *(void *)(*(void *)(a1 + 1160) + 8 * v138) = v135;
        for (j = (void *)*v134; *v134; j = (void *)*v134)
        {
          size_t v140 = j[1] & v137;
          if (v140 == v138)
          {
            v134 = j;
          }
          else
          {
            uint64_t v141 = *(void *)(a1 + 1160);
            if (*(void *)(v141 + 8 * v140))
            {
              void *v134 = *j;
              uint64_t v142 = 8 * v140;
              void *j = **(void **)(*(void *)(a1 + 1160) + v142);
              **(void **)(*(void *)(a1 + 1160) + v142) = j;
            }
            else
            {
              *(void *)(v141 + 8 * v140) = v134;
              v134 = j;
              size_t v138 = v140;
            }
          }
        }
LABEL_268:
        unint64_t v119 = v130;
        goto LABEL_269;
      }
      if (v136 >= v130) {
        v136 %= v130;
      }
      *(void *)(*(void *)(a1 + 1160) + 8 * v136) = v135;
      unint64_t v146 = (void *)*v134;
      if (!*v134) {
        goto LABEL_268;
      }
      while (1)
      {
        size_t v148 = v146[1];
        if (v148 >= v130) {
          v148 %= v130;
        }
        if (v148 != v136)
        {
          uint64_t v149 = *(void *)(a1 + 1160);
          if (!*(void *)(v149 + 8 * v148))
          {
            *(void *)(v149 + 8 * v148) = v134;
            goto LABEL_273;
          }
          void *v134 = *v146;
          uint64_t v147 = 8 * v148;
          *unint64_t v146 = **(void **)(*(void *)(a1 + 1160) + v147);
          **(void **)(*(void *)(a1 + 1160) + v147) = v146;
          unint64_t v146 = v134;
        }
        size_t v148 = v136;
LABEL_273:
        v134 = v146;
        unint64_t v146 = (void *)*v146;
        size_t v136 = v148;
        if (!v146) {
          goto LABEL_268;
        }
      }
    }
LABEL_312:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_282:
  uint64_t v150 = *(void *)(a1 + 1160);
  size_t v151 = *(void **)(v150 + 8 * v90);
  if (v151)
  {
    *unint64_t v122 = *v151;
  }
  else
  {
    uint64_t v152 = *(void *)(a1 + 1176);
    *unint64_t v122 = v152;
    *(void *)(a1 + 1176) = v122;
    *(void *)(v150 + 8 * v90) = a1 + 1176;
    if (!v152) {
      goto LABEL_291;
    }
    unint64_t v153 = *(void *)(v152 + 8);
    if ((v119 & (v119 - 1)) != 0)
    {
      if (v153 >= v119) {
        v153 %= v119;
      }
    }
    else
    {
      v153 &= v119 - 1;
    }
    size_t v151 = (void *)(*(void *)(a1 + 1160) + 8 * v153);
  }
  *size_t v151 = v122;
LABEL_291:
  ++*(void *)(a1 + 1184);
LABEL_292:
  uint64_t v154 = *(void *)a3;
  *((_WORD *)v122 + 16) = *(_WORD *)(a3 + 8);
  v122[3] = v154;
  return v9;
}

int8x8_t *md::MaterialResourceStore::disconnect<geo::handle<md::MaterialIDStorage>>(int8x8_t *result, unint64_t a2)
{
  int8x8_t v2 = result[8];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (*(void *)&v2 <= a2) {
        unint64_t v4 = a2 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v4 = (*(void *)&v2 - 1) & a2;
    }
    uint64_t v5 = *(void **)(*(void *)&result[7] + 8 * v4);
    if (v5)
    {
      uint64_t v6 = (void *)*v5;
      if (v6)
      {
        if (v3.u32[0] < 2uLL)
        {
          uint64_t v7 = *(void *)&v2 - 1;
          while (1)
          {
            uint64_t v9 = v6[1];
            if (v9 == a2)
            {
              if (v6[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v9 & v7) != v4)
            {
              return result;
            }
            uint64_t v6 = (void *)*v6;
            if (!v6) {
              return result;
            }
          }
        }
        do
        {
          unint64_t v8 = v6[1];
          if (v8 == a2)
          {
            if (v6[2] == a2)
            {
LABEL_22:
              uint64_t v10 = v6[4];
              if (!v10 || (uint64_t v11 = v10 - 1, (v6[4] = v11) == 0)) {
                v6[3] = 0;
              }
              return result;
            }
          }
          else
          {
            if (v8 >= *(void *)&v2) {
              v8 %= *(void *)&v2;
            }
            if (v8 != v4) {
              return result;
            }
          }
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
    }
  }
  return result;
}

int8x8_t *md::MaterialResourceStore::disconnect<geo::handle<md::ls::ColorData>>(int8x8_t *result, unint64_t a2)
{
  int8x8_t v2 = result[119];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (*(void *)&v2 <= a2) {
        unint64_t v4 = a2 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v4 = (*(void *)&v2 - 1) & a2;
    }
    uint64_t v5 = *(void **)(*(void *)&result[118] + 8 * v4);
    if (v5)
    {
      uint64_t v6 = (void *)*v5;
      if (v6)
      {
        if (v3.u32[0] < 2uLL)
        {
          uint64_t v7 = *(void *)&v2 - 1;
          while (1)
          {
            uint64_t v9 = v6[1];
            if (v9 == a2)
            {
              if (v6[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v9 & v7) != v4)
            {
              return result;
            }
            uint64_t v6 = (void *)*v6;
            if (!v6) {
              return result;
            }
          }
        }
        do
        {
          unint64_t v8 = v6[1];
          if (v8 == a2)
          {
            if (v6[2] == a2)
            {
LABEL_22:
              uint64_t v10 = v6[4];
              if (!v10 || (uint64_t v11 = v10 - 1, (v6[4] = v11) == 0)) {
                v6[3] = 0;
              }
              return result;
            }
          }
          else
          {
            if (v8 >= *(void *)&v2) {
              v8 %= *(void *)&v2;
            }
            if (v8 != v4) {
              return result;
            }
          }
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
    }
  }
  return result;
}

float geo::packed_array<md::ls::ColorData,geo::handle<md::ls::ColorData>>::erase(uint64_t a1, void *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v2 < (*(void *)(a1 + 32) - v3) >> 3)
  {
    unint64_t v4 = *(void *)(v3 + 8 * v2);
    BOOL v6 = v4 == 0;
    unint64_t v5 = HIDWORD(v4);
    BOOL v6 = !v6 && HIDWORD(*a2) == v5;
    if (v6)
    {
      uint64_t v10 = *(unint64_t **)(a1 + 8);
      unint64_t v9 = *(void *)(a1 + 16);
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = *(unint64_t **)a1;
        uint64_t v13 = (uint64_t)v10 - *(void *)a1;
        uint64_t v14 = v13 >> 3;
        unint64_t v15 = (v13 >> 3) + 1;
        if (v15 >> 61) {
          abort();
        }
        uint64_t v16 = v9 - (void)v12;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * v17);
        }
        else
        {
          uint64_t v18 = 0;
        }
        unint64_t v19 = (unint64_t *)&v18[8 * v14];
        uint64_t v20 = &v18[8 * v17];
        *unint64_t v19 = v2;
        uint64_t v11 = v19 + 1;
        if (v10 != v12)
        {
          unint64_t v21 = (char *)v10 - (char *)v12 - 8;
          if (v21 < 0x58) {
            goto LABEL_34;
          }
          if ((unint64_t)((char *)v10 - v18 - v13) < 0x20) {
            goto LABEL_34;
          }
          uint64_t v22 = (v21 >> 3) + 1;
          unint64_t v23 = &v18[8 * v14 - 16];
          unint64_t v24 = v10 - 2;
          uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v26 = *(_OWORD *)v24;
            *(v23 - 1) = *((_OWORD *)v24 - 1);
            _OWORD *v23 = v26;
            v23 -= 2;
            v24 -= 4;
            v25 -= 4;
          }
          while (v25);
          v19 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          v10 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_34:
            do
            {
              unint64_t v27 = *--v10;
              *--unint64_t v19 = v27;
            }
            while (v10 != v12);
          }
        }
        *(void *)a1 = v19;
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = v20;
        if (v12)
        {
          operator delete(v12);
          uint64_t v3 = *(void *)(a1 + 24);
        }
      }
      else
      {
        *uint64_t v10 = v2;
        uint64_t v11 = v10 + 1;
      }
      *(void *)(a1 + 8) = v11;
      uint64_t v28 = *(void *)(v3 + 8 * *(unsigned int *)a2);
      uint64_t v30 = *(void *)(a1 + 48);
      uint64_t v29 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(*(void *)(a1 + 72) + 0x6666666666666668 * ((unint64_t)(v29 - v30) >> 2) - 8);
      uint64_t v32 = (float *)(v30 + 20 * v28);
      float result = v32[4];
      long long v34 = *(_OWORD *)v32;
      float *v32 = *(float *)(v29 - 20);
      v32[1] = *(float *)(v29 - 16);
      v32[2] = *(float *)(v29 - 12);
      v32[3] = *(float *)(v29 - 8);
      v32[4] = *(float *)(v29 - 4);
      *(_OWORD *)(v29 - 20) = v34;
      *(float *)(v29 - 4) = result;
      *(_DWORD *)(v3 + 8 * v31) = v28;
      uint64_t v35 = 8 * v28;
      uint64_t v36 = *(void *)(a1 + 72);
      unint64_t v37 = *(void **)(a1 + 80);
      uint64_t v38 = *(void *)(v36 + v35);
      uint64_t v39 = *--v37;
      *(void *)(v36 + v35) = v39;
      void *v37 = v38;
      *(void *)(a1 + 56) -= 20;
      *(void *)(a1 + 80) = v37;
      uint64_t v40 = 8 * *(unsigned int *)a2;
      *(_DWORD *)(*(void *)(a1 + 24) + v40 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 24) + v40 + 4) << 32)
                                                   + 0x100000000) >> 32;
      *(_DWORD *)(*(void *)(a1 + 24) + v40) = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    }
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<geo::handle<md::ls::ColorData>,std::unique_ptr<md::ls::ColorData>>,std::__unordered_map_hasher<geo::handle<md::ls::ColorData>,std::__hash_value_type<geo::handle<md::ls::ColorData>,std::unique_ptr<md::ls::ColorData>>,std::hash<geo::handle<md::ls::ColorData>>,std::equal_to<geo::handle<md::ls::ColorData>>,true>,std::__unordered_map_equal<geo::handle<md::ls::ColorData>,std::__hash_value_type<geo::handle<md::ls::ColorData>,std::unique_ptr<md::ls::ColorData>>,std::equal_to<geo::handle<md::ls::ColorData>>,std::hash<geo::handle<md::ls::ColorData>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ls::ColorData>,std::unique_ptr<md::ls::ColorData>>>>::__erase_unique<geo::handle<md::ls::ColorData>>(uint64_t *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (*(void *)&v2 <= a2) {
        unint64_t v4 = a2 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v4 = (*(void *)&v2 - 1) & a2;
    }
    uint64_t v5 = *a1;
    BOOL v6 = *(uint64_t ***)(*a1 + 8 * v4);
    if (v6)
    {
      uint64_t v7 = *v6;
      if (*v6)
      {
        uint64_t v8 = *(void *)&v2 - 1;
        if (v3.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v9 = v7[1];
            if (v9 == a2)
            {
              if (v7[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v9 & v8) != v4)
            {
              return;
            }
            uint64_t v7 = (uint64_t *)*v7;
            if (!v7) {
              return;
            }
          }
        }
        do
        {
          unint64_t v10 = v7[1];
          if (v10 == a2)
          {
            if (v7[2] == a2)
            {
LABEL_22:
              if (v3.u32[0] > 1uLL)
              {
                if (*(void *)&v2 <= a2) {
                  a2 %= *(void *)&v2;
                }
              }
              else
              {
                a2 &= v8;
              }
              uint64_t v11 = *(uint64_t **)(v5 + 8 * a2);
              do
              {
                uint64_t v12 = v11;
                uint64_t v11 = (uint64_t *)*v11;
              }
              while (v11 != v7);
              if (v12 == a1 + 2) {
                goto LABEL_39;
              }
              unint64_t v13 = v12[1];
              if (v3.u32[0] > 1uLL)
              {
                if (v13 >= *(void *)&v2) {
                  v13 %= *(void *)&v2;
                }
              }
              else
              {
                v13 &= v8;
              }
              if (v13 != a2)
              {
LABEL_39:
                if (!*v7) {
                  goto LABEL_40;
                }
                unint64_t v14 = *(void *)(*v7 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v14 >= *(void *)&v2) {
                    v14 %= *(void *)&v2;
                  }
                }
                else
                {
                  v14 &= v8;
                }
                if (v14 != a2) {
LABEL_40:
                }
                  *(void *)(v5 + 8 * a2) = 0;
              }
              uint64_t v15 = *v7;
              if (*v7)
              {
                unint64_t v16 = *(void *)(v15 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v16 >= *(void *)&v2) {
                    v16 %= *(void *)&v2;
                  }
                }
                else
                {
                  v16 &= v8;
                }
                if (v16 != a2)
                {
                  *(void *)(*a1 + 8 * v16) = v12;
                  uint64_t v15 = *v7;
                }
              }
              *uint64_t v12 = v15;
              *uint64_t v7 = 0;
              --a1[3];
              uint64_t v17 = v7[3];
              v7[3] = 0;
              if (v17) {
                MEMORY[0x1A6239270](v17, 0x1000C40A86A77D5);
              }
              operator delete(v7);
              return;
            }
          }
          else
          {
            if (v10 >= *(void *)&v2) {
              v10 %= *(void *)&v2;
            }
            if (v10 != v4) {
              return;
            }
          }
          uint64_t v7 = (uint64_t *)*v7;
        }
        while (v7);
      }
    }
  }
}

void geo::packed_array<md::ls::ZIndex,geo::handle<md::ls::ZIndex>>::erase(uint64_t a1, void *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v2 < (*(void *)(a1 + 32) - v3) >> 3)
  {
    unint64_t v4 = *(void *)(v3 + 8 * v2);
    BOOL v6 = v4 == 0;
    unint64_t v5 = HIDWORD(v4);
    BOOL v6 = !v6 && HIDWORD(*a2) == v5;
    if (v6)
    {
      unint64_t v10 = *(unint64_t **)(a1 + 8);
      unint64_t v9 = *(void *)(a1 + 16);
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = *(unint64_t **)a1;
        uint64_t v13 = (uint64_t)v10 - *(void *)a1;
        uint64_t v14 = v13 >> 3;
        unint64_t v15 = (v13 >> 3) + 1;
        if (v15 >> 61) {
          abort();
        }
        uint64_t v16 = v9 - (void)v12;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * v17);
        }
        else
        {
          uint64_t v18 = 0;
        }
        unint64_t v19 = (unint64_t *)&v18[8 * v14];
        uint64_t v20 = &v18[8 * v17];
        *unint64_t v19 = v2;
        uint64_t v11 = v19 + 1;
        if (v10 != v12)
        {
          unint64_t v21 = (char *)v10 - (char *)v12 - 8;
          if (v21 < 0x58) {
            goto LABEL_34;
          }
          if ((unint64_t)((char *)v10 - v18 - v13) < 0x20) {
            goto LABEL_34;
          }
          uint64_t v22 = (v21 >> 3) + 1;
          unint64_t v23 = &v18[8 * v14 - 16];
          unint64_t v24 = v10 - 2;
          uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v26 = *(_OWORD *)v24;
            *(v23 - 1) = *((_OWORD *)v24 - 1);
            _OWORD *v23 = v26;
            v23 -= 2;
            v24 -= 4;
            v25 -= 4;
          }
          while (v25);
          v19 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          v10 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_34:
            do
            {
              unint64_t v27 = *--v10;
              *--unint64_t v19 = v27;
            }
            while (v10 != v12);
          }
        }
        *(void *)a1 = v19;
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = v20;
        if (v12)
        {
          operator delete(v12);
          uint64_t v3 = *(void *)(a1 + 24);
        }
      }
      else
      {
        *unint64_t v10 = v2;
        uint64_t v11 = v10 + 1;
      }
      *(void *)(a1 + 8) = v11;
      uint64_t v28 = *(void *)(v3 + 8 * *(unsigned int *)a2);
      uint64_t v30 = *(void *)(a1 + 48);
      uint64_t v29 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(v29 - v30 + *(void *)(a1 + 72) - 8);
      uint64_t v32 = 8 * v28;
      uint64_t v33 = *(void *)(v30 + v32);
      *(void *)(v30 + v32) = *(void *)(v29 - 8);
      *(void *)(v29 - 8) = v33;
      *(_DWORD *)(*(void *)(a1 + 24) + 8 * v31) = v28;
      uint64_t v34 = *(void *)(a1 + 72);
      uint64_t v35 = *(void **)(a1 + 80);
      uint64_t v36 = *(void *)(v34 + v32);
      uint64_t v37 = *--v35;
      *(void *)(v34 + v32) = v37;
      *uint64_t v35 = v36;
      *(void *)(a1 + 56) -= 8;
      *(void *)(a1 + 80) = v35;
      uint64_t v38 = 8 * *(unsigned int *)a2;
      *(_DWORD *)(*(void *)(a1 + 24) + v38 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 24) + v38 + 4) << 32)
                                                   + 0x100000000) >> 32;
      *(_DWORD *)(*(void *)(a1 + 24) + v38) = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    }
  }
}

void std::__hash_table<std::__hash_value_type<geo::handle<md::ls::ZIndex>,std::unique_ptr<md::ls::ZIndex>>,std::__unordered_map_hasher<geo::handle<md::ls::ZIndex>,std::__hash_value_type<geo::handle<md::ls::ZIndex>,std::unique_ptr<md::ls::ZIndex>>,std::hash<geo::handle<md::ls::ZIndex>>,std::equal_to<geo::handle<md::ls::ZIndex>>,true>,std::__unordered_map_equal<geo::handle<md::ls::ZIndex>,std::__hash_value_type<geo::handle<md::ls::ZIndex>,std::unique_ptr<md::ls::ZIndex>>,std::equal_to<geo::handle<md::ls::ZIndex>>,std::hash<geo::handle<md::ls::ZIndex>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ls::ZIndex>,std::unique_ptr<md::ls::ZIndex>>>>::__erase_unique<geo::handle<md::ls::ZIndex>>(uint64_t *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (*(void *)&v2 <= a2) {
        unint64_t v4 = a2 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v4 = (*(void *)&v2 - 1) & a2;
    }
    uint64_t v5 = *a1;
    BOOL v6 = *(uint64_t ***)(*a1 + 8 * v4);
    if (v6)
    {
      uint64_t v7 = *v6;
      if (*v6)
      {
        uint64_t v8 = *(void *)&v2 - 1;
        if (v3.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v9 = v7[1];
            if (v9 == a2)
            {
              if (v7[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v9 & v8) != v4)
            {
              return;
            }
            uint64_t v7 = (uint64_t *)*v7;
            if (!v7) {
              return;
            }
          }
        }
        do
        {
          unint64_t v10 = v7[1];
          if (v10 == a2)
          {
            if (v7[2] == a2)
            {
LABEL_22:
              if (v3.u32[0] > 1uLL)
              {
                if (*(void *)&v2 <= a2) {
                  a2 %= *(void *)&v2;
                }
              }
              else
              {
                a2 &= v8;
              }
              uint64_t v11 = *(uint64_t **)(v5 + 8 * a2);
              do
              {
                uint64_t v12 = v11;
                uint64_t v11 = (uint64_t *)*v11;
              }
              while (v11 != v7);
              if (v12 == a1 + 2) {
                goto LABEL_39;
              }
              unint64_t v13 = v12[1];
              if (v3.u32[0] > 1uLL)
              {
                if (v13 >= *(void *)&v2) {
                  v13 %= *(void *)&v2;
                }
              }
              else
              {
                v13 &= v8;
              }
              if (v13 != a2)
              {
LABEL_39:
                if (!*v7) {
                  goto LABEL_40;
                }
                unint64_t v14 = *(void *)(*v7 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v14 >= *(void *)&v2) {
                    v14 %= *(void *)&v2;
                  }
                }
                else
                {
                  v14 &= v8;
                }
                if (v14 != a2) {
LABEL_40:
                }
                  *(void *)(v5 + 8 * a2) = 0;
              }
              uint64_t v15 = *v7;
              if (*v7)
              {
                unint64_t v16 = *(void *)(v15 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v16 >= *(void *)&v2) {
                    v16 %= *(void *)&v2;
                  }
                }
                else
                {
                  v16 &= v8;
                }
                if (v16 != a2)
                {
                  *(void *)(*a1 + 8 * v16) = v12;
                  uint64_t v15 = *v7;
                }
              }
              *uint64_t v12 = v15;
              *uint64_t v7 = 0;
              --a1[3];
              uint64_t v17 = v7[3];
              v7[3] = 0;
              if (v17) {
                MEMORY[0x1A6239270](v17, 0x1000C4090D0E795);
              }
              operator delete(v7);
              return;
            }
          }
          else
          {
            if (v10 >= *(void *)&v2) {
              v10 %= *(void *)&v2;
            }
            if (v10 != v4) {
              return;
            }
          }
          uint64_t v7 = (uint64_t *)*v7;
        }
        while (v7);
      }
    }
  }
}

void geo::packed_array<md::ls::MaterialVisibilityOptions,geo::handle<md::ls::MaterialVisibilityOptions>>::erase(uint64_t a1, void *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v2 < (*(void *)(a1 + 32) - v3) >> 3)
  {
    unint64_t v4 = *(void *)(v3 + 8 * v2);
    BOOL v6 = v4 == 0;
    unint64_t v5 = HIDWORD(v4);
    BOOL v6 = !v6 && HIDWORD(*a2) == v5;
    if (v6)
    {
      unint64_t v10 = *(unint64_t **)(a1 + 8);
      unint64_t v9 = *(void *)(a1 + 16);
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = *(unint64_t **)a1;
        uint64_t v13 = (uint64_t)v10 - *(void *)a1;
        uint64_t v14 = v13 >> 3;
        unint64_t v15 = (v13 >> 3) + 1;
        if (v15 >> 61) {
          abort();
        }
        uint64_t v16 = v9 - (void)v12;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * v17);
        }
        else
        {
          uint64_t v18 = 0;
        }
        unint64_t v19 = (unint64_t *)&v18[8 * v14];
        uint64_t v20 = &v18[8 * v17];
        *unint64_t v19 = v2;
        uint64_t v11 = v19 + 1;
        if (v10 != v12)
        {
          unint64_t v21 = (char *)v10 - (char *)v12 - 8;
          if (v21 < 0x58) {
            goto LABEL_34;
          }
          if ((unint64_t)((char *)v10 - v18 - v13) < 0x20) {
            goto LABEL_34;
          }
          uint64_t v22 = (v21 >> 3) + 1;
          unint64_t v23 = &v18[8 * v14 - 16];
          unint64_t v24 = v10 - 2;
          uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v26 = *(_OWORD *)v24;
            *(v23 - 1) = *((_OWORD *)v24 - 1);
            _OWORD *v23 = v26;
            v23 -= 2;
            v24 -= 4;
            v25 -= 4;
          }
          while (v25);
          v19 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          v10 -= v22 & 0x3FFFFFFFFFFFFFFCLL;
          if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_34:
            do
            {
              unint64_t v27 = *--v10;
              *--unint64_t v19 = v27;
            }
            while (v10 != v12);
          }
        }
        *(void *)a1 = v19;
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = v20;
        if (v12)
        {
          operator delete(v12);
          uint64_t v3 = *(void *)(a1 + 24);
        }
      }
      else
      {
        *unint64_t v10 = v2;
        uint64_t v11 = v10 + 1;
      }
      *(void *)(a1 + 8) = v11;
      uint64_t v28 = *(void *)(v3 + 8 * *(unsigned int *)a2);
      uint64_t v30 = *(void *)(a1 + 48);
      uint64_t v29 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(*(void *)(a1 + 72) + 0x5555555555555558 * (v29 - v30) - 8);
      uint64_t v32 = (__int16 *)(v30 + 3 * v28);
      char v33 = *((unsigned char *)v32 + 2);
      __int16 v34 = *v32;
      char v35 = *(unsigned char *)(v29 - 1);
      __int16 *v32 = *(_WORD *)(v29 - 3);
      *((unsigned char *)v32 + 2) = v35;
      *(_WORD *)(v29 - 3) = v34;
      *(unsigned char *)(v29 - 1) = v33;
      *(_DWORD *)(*(void *)(a1 + 24) + 8 * v31) = v28;
      uint64_t v36 = 8 * v28;
      uint64_t v37 = *(void *)(a1 + 72);
      uint64_t v38 = *(void **)(a1 + 80);
      uint64_t v39 = *(void *)(v37 + v36);
      uint64_t v40 = *--v38;
      *(void *)(v37 + v36) = v40;
      *uint64_t v38 = v39;
      *(void *)(a1 + 56) -= 3;
      *(void *)(a1 + 80) = v38;
      uint64_t v41 = 8 * *(unsigned int *)a2;
      *(_DWORD *)(*(void *)(a1 + 24) + v41 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 24) + v41 + 4) << 32)
                                                   + 0x100000000) >> 32;
      *(_DWORD *)(*(void *)(a1 + 24) + v41) = (*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3;
    }
  }
}

void std::__hash_table<std::__hash_value_type<geo::handle<md::ls::MaterialVisibilityOptions>,std::unique_ptr<md::ls::MaterialVisibilityOptions>>,std::__unordered_map_hasher<geo::handle<md::ls::MaterialVisibilityOptions>,std::__hash_value_type<geo::handle<md::ls::MaterialVisibilityOptions>,std::unique_ptr<md::ls::MaterialVisibilityOptions>>,std::hash<geo::handle<md::ls::MaterialVisibilityOptions>>,std::equal_to<geo::handle<md::ls::MaterialVisibilityOptions>>,true>,std::__unordered_map_equal<geo::handle<md::ls::MaterialVisibilityOptions>,std::__hash_value_type<geo::handle<md::ls::MaterialVisibilityOptions>,std::unique_ptr<md::ls::MaterialVisibilityOptions>>,std::equal_to<geo::handle<md::ls::MaterialVisibilityOptions>>,std::hash<geo::handle<md::ls::MaterialVisibilityOptions>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ls::MaterialVisibilityOptions>,std::unique_ptr<md::ls::MaterialVisibilityOptions>>>>::__erase_unique<geo::handle<md::ls::MaterialVisibilityOptions>>(uint64_t *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (*(void *)&v2 <= a2) {
        unint64_t v4 = a2 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v4 = (*(void *)&v2 - 1) & a2;
    }
    uint64_t v5 = *a1;
    BOOL v6 = *(uint64_t ***)(*a1 + 8 * v4);
    if (v6)
    {
      uint64_t v7 = *v6;
      if (*v6)
      {
        uint64_t v8 = *(void *)&v2 - 1;
        if (v3.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v9 = v7[1];
            if (v9 == a2)
            {
              if (v7[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v9 & v8) != v4)
            {
              return;
            }
            uint64_t v7 = (uint64_t *)*v7;
            if (!v7) {
              return;
            }
          }
        }
        do
        {
          unint64_t v10 = v7[1];
          if (v10 == a2)
          {
            if (v7[2] == a2)
            {
LABEL_22:
              if (v3.u32[0] > 1uLL)
              {
                if (*(void *)&v2 <= a2) {
                  a2 %= *(void *)&v2;
                }
              }
              else
              {
                a2 &= v8;
              }
              uint64_t v11 = *(uint64_t **)(v5 + 8 * a2);
              do
              {
                uint64_t v12 = v11;
                uint64_t v11 = (uint64_t *)*v11;
              }
              while (v11 != v7);
              if (v12 == a1 + 2) {
                goto LABEL_39;
              }
              unint64_t v13 = v12[1];
              if (v3.u32[0] > 1uLL)
              {
                if (v13 >= *(void *)&v2) {
                  v13 %= *(void *)&v2;
                }
              }
              else
              {
                v13 &= v8;
              }
              if (v13 != a2)
              {
LABEL_39:
                if (!*v7) {
                  goto LABEL_40;
                }
                unint64_t v14 = *(void *)(*v7 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v14 >= *(void *)&v2) {
                    v14 %= *(void *)&v2;
                  }
                }
                else
                {
                  v14 &= v8;
                }
                if (v14 != a2) {
LABEL_40:
                }
                  *(void *)(v5 + 8 * a2) = 0;
              }
              uint64_t v15 = *v7;
              if (*v7)
              {
                unint64_t v16 = *(void *)(v15 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v16 >= *(void *)&v2) {
                    v16 %= *(void *)&v2;
                  }
                }
                else
                {
                  v16 &= v8;
                }
                if (v16 != a2)
                {
                  *(void *)(*a1 + 8 * v16) = v12;
                  uint64_t v15 = *v7;
                }
              }
              *uint64_t v12 = v15;
              *uint64_t v7 = 0;
              --a1[3];
              uint64_t v17 = v7[3];
              v7[3] = 0;
              if (v17) {
                MEMORY[0x1A6239270](v17, 0x1000C4033FC2DF1);
              }
              operator delete(v7);
              return;
            }
          }
          else
          {
            if (v10 >= *(void *)&v2) {
              v10 %= *(void *)&v2;
            }
            if (v10 != v4) {
              return;
            }
          }
          uint64_t v7 = (uint64_t *)*v7;
        }
        while (v7);
      }
    }
  }
}

void std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,std::unique_ptr<std::shared_ptr<gms::Material<ggl::Texture2D>>>>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,std::unique_ptr<std::shared_ptr<gms::Material<ggl::Texture2D>>>>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,std::unique_ptr<std::shared_ptr<gms::Material<ggl::Texture2D>>>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,std::unique_ptr<std::shared_ptr<gms::Material<ggl::Texture2D>>>>>>::__erase_unique<geo::handle<md::MaterialIDStorage>>(uint64_t *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (*(void *)&v2 <= a2) {
        unint64_t v4 = a2 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v4 = (*(void *)&v2 - 1) & a2;
    }
    uint64_t v5 = *a1;
    BOOL v6 = *(uint64_t ***)(*a1 + 8 * v4);
    if (v6)
    {
      uint64_t v7 = *v6;
      if (*v6)
      {
        uint64_t v8 = *(void *)&v2 - 1;
        if (v3.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v9 = v7[1];
            if (v9 == a2)
            {
              if (v7[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v9 & v8) != v4)
            {
              return;
            }
            uint64_t v7 = (uint64_t *)*v7;
            if (!v7) {
              return;
            }
          }
        }
        do
        {
          unint64_t v10 = v7[1];
          if (v10 == a2)
          {
            if (v7[2] == a2)
            {
LABEL_22:
              if (v3.u32[0] > 1uLL)
              {
                if (*(void *)&v2 <= a2) {
                  a2 %= *(void *)&v2;
                }
              }
              else
              {
                a2 &= v8;
              }
              uint64_t v11 = *(uint64_t **)(v5 + 8 * a2);
              do
              {
                uint64_t v12 = v11;
                uint64_t v11 = (uint64_t *)*v11;
              }
              while (v11 != v7);
              if (v12 == a1 + 2) {
                goto LABEL_39;
              }
              unint64_t v13 = v12[1];
              if (v3.u32[0] > 1uLL)
              {
                if (v13 >= *(void *)&v2) {
                  v13 %= *(void *)&v2;
                }
              }
              else
              {
                v13 &= v8;
              }
              if (v13 != a2)
              {
LABEL_39:
                if (!*v7) {
                  goto LABEL_40;
                }
                unint64_t v14 = *(void *)(*v7 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v14 >= *(void *)&v2) {
                    v14 %= *(void *)&v2;
                  }
                }
                else
                {
                  v14 &= v8;
                }
                if (v14 != a2) {
LABEL_40:
                }
                  *(void *)(v5 + 8 * a2) = 0;
              }
              uint64_t v15 = *v7;
              if (*v7)
              {
                unint64_t v16 = *(void *)(v15 + 8);
                if (v3.u32[0] > 1uLL)
                {
                  if (v16 >= *(void *)&v2) {
                    v16 %= *(void *)&v2;
                  }
                }
                else
                {
                  v16 &= v8;
                }
                if (v16 != a2)
                {
                  *(void *)(*a1 + 8 * v16) = v12;
                  uint64_t v15 = *v7;
                }
              }
              *uint64_t v12 = v15;
              *uint64_t v7 = 0;
              --a1[3];
              uint64_t v17 = v7[3];
              v7[3] = 0;
              if (v17)
              {
                uint64_t v18 = *(std::__shared_weak_count **)(v17 + 8);
                if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
                  std::__shared_weak_count::__release_weak(v18);
                }
                MEMORY[0x1A6239270](v17, 0x20C40A4A59CD2);
              }
              operator delete(v7);
              return;
            }
          }
          else
          {
            if (v10 >= *(void *)&v2) {
              v10 %= *(void *)&v2;
            }
            if (v10 != v4) {
              return;
            }
          }
          uint64_t v7 = (uint64_t *)*v7;
        }
        while (v7);
      }
    }
  }
}

void md::YFlipPass::~YFlipPass(md::YFlipPass *this)
{
  uint64_t v2 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *(ggl::RenderQueue **)this;
  *(void *)this = 0;
  if (v7)
  {
    ggl::RenderQueue::~RenderQueue(v7);
    MEMORY[0x1A6239270]();
  }
}

void sub_1A235A170(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A235A3E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id location, uint64_t a12)
{
}

void sub_1A235A45C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A235B860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<ggl::RenderBuffer *,std::shared_ptr<ggl::RenderBuffer>::__shared_ptr_default_delete<ggl::RenderBuffer,ggl::RenderBuffer>,std::allocator<ggl::RenderBuffer>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ggl::RenderBuffer *,std::shared_ptr<ggl::RenderBuffer>::__shared_ptr_default_delete<ggl::RenderBuffer,ggl::RenderBuffer>,std::allocator<ggl::RenderBuffer>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<ggl::Texture2D *,std::shared_ptr<ggl::Texture2DAbstract>::__shared_ptr_default_delete<ggl::Texture2DAbstract,ggl::Texture2D>,std::allocator<ggl::Texture2D>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ggl::Texture2D *,std::shared_ptr<ggl::Texture2DAbstract>::__shared_ptr_default_delete<ggl::Texture2DAbstract,ggl::Texture2D>,std::allocator<ggl::Texture2D>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<ggl::Texture2D *,std::shared_ptr<ggl::Texture>::__shared_ptr_default_delete<ggl::Texture,ggl::Texture2D>,std::allocator<ggl::Texture2D>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ggl::Texture2D *,std::shared_ptr<ggl::Texture>::__shared_ptr_default_delete<ggl::Texture,ggl::Texture2D>,std::allocator<ggl::Texture2D>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<ggl::RenderBuffer *,std::shared_ptr<ggl::Texture2DAbstract>::__shared_ptr_default_delete<ggl::Texture2DAbstract,ggl::RenderBuffer>,std::allocator<ggl::RenderBuffer>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ggl::RenderBuffer *,std::shared_ptr<ggl::Texture2DAbstract>::__shared_ptr_default_delete<ggl::Texture2DAbstract,ggl::RenderBuffer>,std::allocator<ggl::RenderBuffer>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::RenderBuffer::~RenderBuffer(ggl::RenderBuffer *this)
{
  *((void *)this - 5) = &unk_1EF55EFB8;
  *(void *)this = &unk_1EF55EFD8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *((void *)this - 5) = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this - 4);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this - 2));
    *((void *)this - 2) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this - 3);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *((void *)this - 5) = &unk_1EF55EFB8;
  *(void *)this = &unk_1EF55EFD8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *((void *)this - 5) = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this - 4);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this - 2));
    *((void *)this - 2) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this - 3);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void ggl::RenderBuffer::~RenderBuffer(ggl::RenderBuffer *this)
{
  *(void *)this = &unk_1EF55EFB8;
  *((void *)this + 5) = &unk_1EF55EFD8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55EFB8;
  *((void *)this + 5) = &unk_1EF55EFD8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1A235C2B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  MEMORY[0x1A6239270](v11, 0x10F1C400DC7F665);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1A235C590(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<ggl::IOSurfaceBitmapData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::IOSurfaceBitmapData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588280;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::IOSurfaceBitmapData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588280;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A235DA6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }

  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<GGLImageCanvasRendererProvider>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {

    MEMORY[0x1A6239270](v2, 0x81C40803F642BLL);
  }
  return a1;
}

uint64_t std::__shared_ptr_pointer<GGLImageCanvasRendererProvider *,std::shared_ptr<GGLImageCanvasRendererProvider>::__shared_ptr_default_delete<GGLImageCanvasRendererProvider,GGLImageCanvasRendererProvider>,std::allocator<GGLImageCanvasRendererProvider>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {

    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<GGLImageCanvasRendererProvider *,std::shared_ptr<GGLImageCanvasRendererProvider>::__shared_ptr_default_delete<GGLImageCanvasRendererProvider,GGLImageCanvasRendererProvider>,std::allocator<GGLImageCanvasRendererProvider>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t GGLImageCanvasRendererProvider::signpost(id *this)
{
  return [this[1] signpost];
}

uint64_t GGLImageCanvasRendererProvider::renderer(id *this)
{
  return [this[1] renderer];
}

uint64_t std::__shared_ptr_pointer<GGLImageCanvasRenderTargetPreparer *,std::shared_ptr<GGLImageCanvasRenderTargetPreparer>::__shared_ptr_default_delete<GGLImageCanvasRenderTargetPreparer,GGLImageCanvasRenderTargetPreparer>,std::allocator<GGLImageCanvasRenderTargetPreparer>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<GGLImageCanvasRenderTargetPreparer *,std::shared_ptr<GGLImageCanvasRenderTargetPreparer>::__shared_ptr_default_delete<GGLImageCanvasRenderTargetPreparer,GGLImageCanvasRenderTargetPreparer>,std::allocator<GGLImageCanvasRenderTargetPreparer>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t GGLImageCanvasRenderTargetPreparer::prepareSnapshotTargets(id *this)
{
  return [this[1] flipTarget];
}

uint64_t GGLImageCanvasRenderTargetPreparer::prepareInteractiveTargets()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  v0 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_FAULT))
  {
    int v2 = 136315650;
    uint64_t v3 = "false";
    __int16 v4 = 2080;
    uint64_t v5 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/GGLImageCanvas.mm";
    __int16 v6 = 1024;
    int v7 = 57;
    _os_log_impl(&dword_1A1780000, v0, OS_LOG_TYPE_FAULT, "GGLImageCanvas should not participate in interactive frames: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)&v2, 0x1Cu);
  }

  return 0;
}

void GGLImageCanvasRenderTargetPreparer::~GGLImageCanvasRenderTargetPreparer(id *this)
{
  JUMPOUT(0x1A6239270);
}

{
}

uint64_t std::__shared_ptr_pointer<GGLImageCanvasYFlipInjector *,std::shared_ptr<GGLImageCanvasYFlipInjector>::__shared_ptr_default_delete<GGLImageCanvasYFlipInjector,GGLImageCanvasYFlipInjector>,std::allocator<GGLImageCanvasYFlipInjector>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<GGLImageCanvasYFlipInjector *,std::shared_ptr<GGLImageCanvasYFlipInjector>::__shared_ptr_default_delete<GGLImageCanvasYFlipInjector,GGLImageCanvasYFlipInjector>,std::allocator<GGLImageCanvasYFlipInjector>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void GGLImageCanvasYFlipInjector::inject(id *this, ggl::RenderQueue *a2, ggl::RenderTarget *a3)
{
  uint64_t v6 = [this[1] renderTarget];
  int v7 = (uint64_t *)[this[1] flipPass];
  uint64_t v8 = (ggl::RenderQueue **)v7;
  uint64_t v9 = *(void *)(v6 + 184);
  if (!v9) {
    uint64_t v9 = *(void *)(v6 + 88);
  }
  **(void **)(v7[3] + 96) = v9;
  uint64_t v10 = v7[1];
  uint64_t v11 = *(void *)(v10 + 72);
  if (*(void *)(v10 + 80) != v11) {
    *(void *)(v10 + 80) = v11;
  }
  if (**(void **)(v7[3] + 96)) {
    ggl::CommandBuffer::pushRenderItem(v7[1], v7[4]);
  }
  uint64_t v12 = *v8;
  ggl::RenderQueue::attachPass(a2, a3, v12);
}

void GGLImageCanvasYFlipInjector::~GGLImageCanvasYFlipInjector(id *this)
{
  JUMPOUT(0x1A6239270);
}

{
}

void *md::realistic::PostchainRenderLayer::layout(md::realistic::PostchainRenderLayer *this, const md::LayoutContext *a2)
{
  uint64_t v133 = *MEMORY[0x1E4F143B8];
  v129[0] = &unk_1EF57A220;
  v129[1] = a2;
  v127[0] = &unk_1EF57A268;
  v127[1] = a2;
  unint64_t v128 = v127;
  unint64_t v132 = v131;
  size_t v130 = v129;
  v131[0] = &unk_1EF57A268;
  v131[1] = a2;
  std::__function::__func<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()((uint64_t)v129);
  if (v128 == v127)
  {
    (*(void (**)(void *))(v127[0] + 32))(v127);
  }
  else if (v128)
  {
    (*(void (**)(void))(*v128 + 40))();
  }
  if (v130 == v129)
  {
    (*(void (**)(void *))(v129[0] + 32))(v129);
  }
  else if (v130)
  {
    (*(void (**)(void))(*v130 + 40))();
  }
  __int16 v4 = (void *)*((void *)a2 + 1);
  int8x8_t v5 = (int8x8_t)v4[1];
  if (!*(void *)&v5) {
    goto LABEL_32;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    uint64_t v7 = 0x1AF456233693CD46;
    if (*(void *)&v5 <= 0x1AF456233693CD46uLL) {
      uint64_t v7 = 0x1AF456233693CD46uLL % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v7 = (*(void *)&v5 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v8 = *(void **)(*v4 + 8 * v7);
  if (!v8) {
    goto LABEL_32;
  }
  uint64_t v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_32;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v10 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v12 = v9[1];
      if (v12 == 0x1AF456233693CD46)
      {
        if (v9[2] == 0x1AF456233693CD46) {
          goto LABEL_30;
        }
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_32;
      }
      uint64_t v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_32;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v9[1];
    if (v11 == 0x1AF456233693CD46) {
      break;
    }
    if (v11 >= *(void *)&v5) {
      v11 %= *(void *)&v5;
    }
    if (v11 != v7) {
      goto LABEL_32;
    }
LABEL_19:
    uint64_t v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_32;
    }
  }
  if (v9[2] != 0x1AF456233693CD46) {
    goto LABEL_19;
  }
LABEL_30:
  uint64_t v13 = v9[5];
  if (*(void *)(v13 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v14 = *(void *)(v13 + 32);
    goto LABEL_33;
  }
LABEL_32:
  uint64_t v14 = 0;
LABEL_33:
  uint64_t v15 = *(void **)(*((void *)this + 5) + 24);
  unint64_t v16 = (void *)v15[1];
  uint64_t v17 = v16[3];
  uint64_t v18 = v16[4];
  if (v18 == v17)
  {
    uint64_t v125 = 0;
    uint64_t v26 = 0;
    uint64_t v122 = 0;
    uint64_t v24 = 0;
LABEL_67:
    uint64_t v39 = 0;
LABEL_68:
    uint64_t v126 = 0;
LABEL_69:
    uint64_t v124 = 0;
    goto LABEL_70;
  }
  uint64_t v19 = 0;
  while (1)
  {
    uint64_t v20 = *(unsigned __int8 **)(v17 + 8 * v19);
    if (*v20 == *((unsigned __int8 *)this + 49))
    {
      unint64_t v21 = *((void *)v20 + 1);
      uint64_t v22 = v16[15];
      if (v21 < (v16[16] - v22) >> 3) {
        break;
      }
    }
    if (++v19 >= (unint64_t)((v18 - v17) >> 3)) {
      goto LABEL_41;
    }
  }
  uint64_t v23 = *(void *)(v22 + 8 * v21);
  if (!v23)
  {
LABEL_41:
    uint64_t v24 = 0;
    uint64_t v25 = v18 - v17;
    if (v18 != v17) {
      goto LABEL_42;
    }
LABEL_40:
    uint64_t v125 = 0;
    uint64_t v26 = 0;
    uint64_t v122 = 0;
    goto LABEL_67;
  }
  uint64_t v24 = *(void *)(*(void *)(v23 + 24) + 8 * *((unsigned __int8 *)this + 50));
  uint64_t v25 = v18 - v17;
  if (v18 == v17) {
    goto LABEL_40;
  }
LABEL_42:
  uint64_t v27 = 0;
  unint64_t v28 = v25 >> 3;
  while (1)
  {
    uint64_t v29 = *(unsigned __int8 **)(v17 + 8 * v27);
    if (*v29 == *((unsigned __int8 *)this + 61))
    {
      unint64_t v30 = *((void *)v29 + 1);
      uint64_t v31 = v16[15];
      if (v30 < (v16[16] - v31) >> 3) {
        break;
      }
    }
    if (++v27 >= v28) {
      goto LABEL_49;
    }
  }
  uint64_t v32 = *(void *)(v31 + 8 * v30);
  if (v32)
  {
    uint64_t v33 = *(void *)(*(void *)(v32 + 24) + 8 * *((unsigned __int8 *)this + 62));
    goto LABEL_50;
  }
LABEL_49:
  uint64_t v33 = 0;
LABEL_50:
  uint64_t v122 = v33;
  if (v18 == v17)
  {
    uint64_t v125 = 0;
    uint64_t v26 = 0;
    goto LABEL_67;
  }
  uint64_t v34 = 0;
  while (1)
  {
    char v35 = *(unsigned __int8 **)(v17 + 8 * v34);
    if (*v35 == *((unsigned __int8 *)this + 51))
    {
      unint64_t v36 = *((void *)v35 + 1);
      uint64_t v37 = v16[15];
      if (v36 < (v16[16] - v37) >> 3) {
        break;
      }
    }
    if (++v34 >= (unint64_t)((v18 - v17) >> 3)) {
      goto LABEL_58;
    }
  }
  uint64_t v38 = *(void *)(v37 + 8 * v36);
  if (!v38)
  {
LABEL_58:
    uint64_t v39 = 0;
    uint64_t v40 = v18 - v17;
    if (v18 != v17) {
      goto LABEL_59;
    }
LABEL_57:
    uint64_t v125 = 0;
    uint64_t v26 = 0;
    goto LABEL_68;
  }
  uint64_t v39 = *(void *)(*(void *)(v38 + 24) + 8 * *((unsigned __int8 *)this + 52));
  uint64_t v40 = v18 - v17;
  if (v18 == v17) {
    goto LABEL_57;
  }
LABEL_59:
  uint64_t v41 = 0;
  unint64_t v42 = v40 >> 3;
  while (1)
  {
    v43 = *(unsigned __int8 **)(v17 + 8 * v41);
    if (*v43 == *((unsigned __int8 *)this + 53))
    {
      unint64_t v44 = *((void *)v43 + 1);
      uint64_t v45 = v16[15];
      if (v44 < (v16[16] - v45) >> 3) {
        break;
      }
    }
    if (++v41 >= v42) {
      goto LABEL_135;
    }
  }
  uint64_t v46 = *(void *)(v45 + 8 * v44);
  if (!v46)
  {
LABEL_135:
    uint64_t v26 = 0;
    uint64_t v47 = v18 - v17;
    if (v18 != v17) {
      goto LABEL_136;
    }
LABEL_65:
    uint64_t v125 = 0;
    goto LABEL_68;
  }
  uint64_t v26 = *(void *)(*(void *)(v46 + 24) + 8 * *((unsigned __int8 *)this + 54));
  uint64_t v47 = v18 - v17;
  if (v18 == v17) {
    goto LABEL_65;
  }
LABEL_136:
  uint64_t v101 = 0;
  unint64_t v102 = v47 >> 3;
  while (1)
  {
    uint64_t v103 = *(unsigned __int8 **)(v17 + 8 * v101);
    if (*v103 == *((unsigned __int8 *)this + 55))
    {
      unint64_t v104 = *((void *)v103 + 1);
      uint64_t v105 = v16[15];
      if (v104 < (v16[16] - v105) >> 3) {
        break;
      }
    }
    if (++v101 >= v102) {
      goto LABEL_143;
    }
  }
  uint64_t v106 = *(void *)(v105 + 8 * v104);
  if (v106)
  {
    uint64_t v126 = *(void *)(*(void *)(v106 + 24) + 8 * *((unsigned __int8 *)this + 56));
    uint64_t v107 = v18 - v17;
    if (v18 == v17)
    {
LABEL_142:
      uint64_t v124 = 0;
      uint64_t v125 = 0;
      goto LABEL_70;
    }
  }
  else
  {
LABEL_143:
    uint64_t v126 = 0;
    uint64_t v107 = v18 - v17;
    if (v18 == v17) {
      goto LABEL_142;
    }
  }
  uint64_t v108 = 0;
  unint64_t v109 = v107 >> 3;
  while (1)
  {
    unint64_t v110 = *(unsigned __int8 **)(v17 + 8 * v108);
    if (*v110 == *((unsigned __int8 *)this + 57))
    {
      unint64_t v111 = *((void *)v110 + 1);
      uint64_t v112 = v16[15];
      if (v111 < (v16[16] - v112) >> 3) {
        break;
      }
    }
    if (++v108 >= v109) {
      goto LABEL_150;
    }
  }
  uint64_t v113 = *(void *)(v112 + 8 * v111);
  if (v113)
  {
    uint64_t v114 = *(void *)(*(void *)(v113 + 24) + 8 * *((unsigned __int8 *)this + 58));
    goto LABEL_151;
  }
LABEL_150:
  uint64_t v114 = 0;
LABEL_151:
  uint64_t v115 = v18 - v17;
  uint64_t v125 = v114;
  if (v18 == v17) {
    goto LABEL_69;
  }
  uint64_t v116 = 0;
  unint64_t v117 = v115 >> 3;
  while (1)
  {
    unint64_t v118 = *(unsigned __int8 **)(v17 + 8 * v116);
    if (*v118 == *((unsigned __int8 *)this + 59))
    {
      unint64_t v119 = *((void *)v118 + 1);
      uint64_t v120 = v16[15];
      if (v119 < (v16[16] - v120) >> 3) {
        break;
      }
    }
    if (++v116 >= v117) {
      goto LABEL_69;
    }
  }
  uint64_t v121 = *(void *)(v120 + 8 * v119);
  if (!v121) {
    goto LABEL_69;
  }
  uint64_t v124 = *(void *)(*(void *)(v121 + 24) + 8 * *((unsigned __int8 *)this + 60));
LABEL_70:
  double v48 = *(double *)(v14 + 32);
  unint64_t v49 = (void *)*((void *)this + 8);
  unint64_t v50 = v49[1];
  unint64_t v51 = (float32x2_t *)v49[9];
  *unint64_t v51 = vcvt_f32_f64(*(float64x2_t *)(v14 + 968));
  *(float *)&double v48 = v48;
  v51[1].i32[0] = LODWORD(v48);
  unint64_t v52 = +[VKDebugSettings sharedSettings];
  [v52 dofStrength];
  v51[1].f32[1] = v53 * 6.0;

  v54 = +[VKDebugSettings sharedSettings];
  [v54 dofStrength];
  if (v55 <= 0.1)
  {
    v51[2].i32[0] = 1065353216;
  }
  else
  {
    uint64_t v56 = +[VKDebugSettings sharedSettings];
    [v56 dofStrength];
    float32_t v58 = 0.1 / v57;
    v51[2].f32[0] = v58;
  }
  uint64_t v59 = v15[4];
  if (v59)
  {
    unint64_t v60 = *(void *)(v59 + 32);
    uint64_t v61 = *(void *)(v15[1] + 96);
    uint64_t v62 = v24;
    if (v60 >= (*(void *)(v15[1] + 104) - v61) >> 3) {
      uint64_t v59 = 0;
    }
    else {
      uint64_t v59 = *(void *)(*(void *)(v61 + 8 * v60) + 16);
    }
  }
  else
  {
    uint64_t v62 = v24;
  }
  **(void **)(*((void *)this + 23) + 96) = v59;
  uint64_t v63 = v15[5];
  if (v63)
  {
    unint64_t v64 = *(void *)(v63 + 32);
    uint64_t v65 = *(void *)(v15[1] + 96);
    if (v64 >= (*(void *)(v15[1] + 104) - v65) >> 3) {
      uint64_t v63 = 0;
    }
    else {
      uint64_t v63 = *(void *)(*(void *)(v65 + 8 * v64) + 16);
    }
  }
  *(void *)(*(void *)(*((void *)this + 23) + 96) + 8) = v63;
  ggl::CommandBuffer::pushRenderItem(v62, *((void *)this + 25));
  uint64_t v66 = v15[7];
  if (v66)
  {
    unint64_t v67 = *(void *)(v66 + 32);
    uint64_t v68 = *(void *)(v15[1] + 96);
    uint64_t v69 = v39;
    if (v67 >= (*(void *)(v15[1] + 104) - v68) >> 3) {
      uint64_t v66 = 0;
    }
    else {
      uint64_t v66 = *(void *)(*(void *)(v68 + 8 * v67) + 16);
    }
  }
  else
  {
    uint64_t v69 = v39;
  }
  **(void **)(*((void *)this + 30) + 96) = v66;
  ggl::CommandBuffer::pushRenderItem(v69, *((void *)this + 32));
  uint64_t v70 = v15[7];
  if (v70)
  {
    unint64_t v71 = *(void *)(v70 + 32);
    uint64_t v72 = *(void *)(v15[1] + 96);
    if (v71 >= (*(void *)(v15[1] + 104) - v72) >> 3) {
      uint64_t v70 = 0;
    }
    else {
      uint64_t v70 = *(void *)(*(void *)(v72 + 8 * v71) + 16);
    }
  }
  **(void **)(*((void *)this + 39) + 96) = v70;
  uint64_t v73 = v15[6];
  if (v73)
  {
    unint64_t v74 = *(void *)(v73 + 32);
    uint64_t v75 = *(void *)(v15[1] + 96);
    if (v74 >= (*(void *)(v15[1] + 104) - v75) >> 3) {
      uint64_t v73 = 0;
    }
    else {
      uint64_t v73 = *(void *)(*(void *)(v75 + 8 * v74) + 16);
    }
  }
  *(void *)(*(void *)(*((void *)this + 39) + 96) + 8) = v73;
  ggl::CommandBuffer::pushRenderItem(v26, *((void *)this + 43));
  uint64_t v76 = v15[8];
  if (v76)
  {
    unint64_t v77 = *(void *)(v76 + 32);
    uint64_t v78 = *(void *)(v15[1] + 96);
    if (v77 >= (*(void *)(v15[1] + 104) - v78) >> 3) {
      uint64_t v76 = 0;
    }
    else {
      uint64_t v76 = *(void *)(*(void *)(v78 + 8 * v77) + 16);
    }
  }
  **(void **)(*((void *)this + 41) + 96) = v76;
  ggl::CommandBuffer::pushRenderItem(v126, *((void *)this + 44));
  uint64_t v79 = v15[9];
  if (v79)
  {
    unint64_t v80 = *(void *)(v79 + 32);
    uint64_t v81 = *(void *)(v15[1] + 96);
    uint64_t v82 = v125;
    if (v80 >= (*(void *)(v15[1] + 104) - v81) >> 3) {
      uint64_t v79 = 0;
    }
    else {
      uint64_t v79 = *(void *)(*(void *)(v81 + 8 * v80) + 16);
    }
  }
  else
  {
    uint64_t v82 = v125;
  }
  **(void **)(*((void *)this + 51) + 96) = v79;
  ggl::CommandBuffer::pushRenderItem(v82, *((void *)this + 55));
  uint64_t v83 = v15[10];
  if (v83)
  {
    unint64_t v84 = *(void *)(v83 + 32);
    uint64_t v85 = *(void *)(v15[1] + 96);
    if (v84 >= (*(void *)(v15[1] + 104) - v85) >> 3) {
      uint64_t v83 = 0;
    }
    else {
      uint64_t v83 = *(void *)(*(void *)(v85 + 8 * v84) + 16);
    }
  }
  **(void **)(*((void *)this + 53) + 96) = v83;
  ggl::CommandBuffer::pushRenderItem(v124, *((void *)this + 56));
  uint64_t v86 = v15[4];
  if (v86)
  {
    unint64_t v87 = *(void *)(v86 + 32);
    uint64_t v88 = *(void *)(v15[1] + 96);
    uint64_t v89 = v123;
    if (v87 >= (*(void *)(v15[1] + 104) - v88) >> 3) {
      uint64_t v86 = 0;
    }
    else {
      uint64_t v86 = *(void *)(*(void *)(v88 + 8 * v87) + 16);
    }
  }
  else
  {
    uint64_t v89 = v123;
  }
  **(void **)(*((void *)this + 14) + 96) = v86;
  uint64_t v90 = v15[5];
  if (v90)
  {
    unint64_t v91 = *(void *)(v90 + 32);
    uint64_t v92 = *(void *)(v15[1] + 96);
    if (v91 >= (*(void *)(v15[1] + 104) - v92) >> 3) {
      uint64_t v90 = 0;
    }
    else {
      uint64_t v90 = *(void *)(*(void *)(v92 + 8 * v91) + 16);
    }
  }
  *(void *)(*(void *)(*((void *)this + 14) + 96) + 8) = v90;
  uint64_t v93 = v15[11];
  if (v93)
  {
    unint64_t v94 = *(void *)(v93 + 32);
    uint64_t v95 = *(void *)(v15[1] + 96);
    if (v94 >= (*(void *)(v15[1] + 104) - v95) >> 3) {
      uint64_t v93 = 0;
    }
    else {
      uint64_t v93 = *(void *)(*(void *)(v95 + 8 * v94) + 16);
    }
  }
  *(void *)(*(void *)(*((void *)this + 14) + 96) + 16) = v93;
  uint64_t v96 = v15[12];
  if (v96)
  {
    unint64_t v97 = *(void *)(v96 + 32);
    uint64_t v98 = *(void *)(v15[1] + 96);
    if (v97 >= (*(void *)(v15[1] + 104) - v98) >> 3) {
      uint64_t v96 = 0;
    }
    else {
      uint64_t v96 = *(void *)(*(void *)(v98 + 8 * v97) + 16);
    }
  }
  *(void *)(*(void *)(*((void *)this + 14) + 96) + 24) = v96;
  ggl::CommandBuffer::pushRenderItem(v89, *((void *)this + 18));
  if (v50)
  {
    unint64_t v99 = v49[8];
    if (v99 <= v50) {
      unint64_t v99 = v50;
    }
    v49[7] = 0;
    v49[8] = v99;
  }
  if (!v132)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
  (*(void (**)(void *))(*v132 + 48))(v132);
  uint64_t result = v132;
  if (v132 == v131) {
    return (void *)(*(uint64_t (**)(void *))(v131[0] + 32))(v131);
  }
  if (v132) {
    return (void *)(*(uint64_t (**)(void))(*v132 + 40))();
  }
  return result;
}

void sub_1A235F244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a13);
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)&a27);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  int v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)int8x8_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "PostchainLayout", "", v5, 2u);
  }
}

void std::__function::__func<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  int v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)int8x8_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "PostchainLayout", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57A268;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57A268;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57A220;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57A220;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::realistic::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::~__func()
{
}

void md::realistic::PostchainRenderLayer::~PostchainRenderLayer(md::realistic::PostchainRenderLayer *this)
{
  md::realistic::PostchainRenderLayer::~PostchainRenderLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  std::__shared_weak_count *v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;
  std::__shared_weak_count *v28;
  std::__shared_weak_count *v29;
  void *v30;

  *(void *)this = &unk_1EF554998;
  uint64_t v2 = *((void *)this + 56);
  *((void *)this + 56) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 55);
  *((void *)this + 55) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  os_signpost_id_t v4 = (std::__shared_weak_count *)*((void *)this + 54);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    int8x8_t v5 = (std::__shared_weak_count *)*((void *)this + 52);
    if (!v5) {
      goto LABEL_11;
    }
  }
  else
  {
    int8x8_t v5 = (std::__shared_weak_count *)*((void *)this + 52);
    if (!v5) {
      goto LABEL_11;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_11:
  uint8x8_t v6 = (std::__shared_weak_count *)*((void *)this + 50);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 48);
    if (!v7) {
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 48);
    if (!v7) {
      goto LABEL_17;
    }
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
LABEL_17:
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 46);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  uint64_t v9 = *((void *)this + 44);
  *((void *)this + 44) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *((void *)this + 43);
  *((void *)this + 43) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  unint64_t v11 = (std::__shared_weak_count *)*((void *)this + 42);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
    uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 40);
    if (!v12) {
      goto LABEL_30;
    }
  }
  else
  {
    uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 40);
    if (!v12) {
      goto LABEL_30;
    }
  }
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
LABEL_30:
  uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    uint64_t v14 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v14) {
      goto LABEL_36;
    }
  }
  else
  {
    uint64_t v14 = (std::__shared_weak_count *)*((void *)this + 36);
    if (!v14) {
      goto LABEL_36;
    }
  }
  if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
LABEL_36:
  uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 34);
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  unint64_t v16 = *((void *)this + 32);
  *((void *)this + 32) = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  uint64_t v17 = (std::__shared_weak_count *)*((void *)this + 31);
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
    uint64_t v18 = (std::__shared_weak_count *)*((void *)this + 29);
    if (!v18) {
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v18 = (std::__shared_weak_count *)*((void *)this + 29);
    if (!v18) {
      goto LABEL_47;
    }
  }
  if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
LABEL_47:
  uint64_t v19 = (std::__shared_weak_count *)*((void *)this + 27);
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  uint64_t v20 = *((void *)this + 25);
  *((void *)this + 25) = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  unint64_t v21 = (std::__shared_weak_count *)*((void *)this + 24);
  if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
    uint64_t v22 = (std::__shared_weak_count *)*((void *)this + 22);
    if (!v22) {
      goto LABEL_58;
    }
  }
  else
  {
    uint64_t v22 = (std::__shared_weak_count *)*((void *)this + 22);
    if (!v22) {
      goto LABEL_58;
    }
  }
  if (!atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
LABEL_58:
  uint64_t v23 = (std::__shared_weak_count *)*((void *)this + 20);
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  uint64_t v24 = *((void *)this + 18);
  *((void *)this + 18) = 0;
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
  }
  uint64_t v25 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
    uint64_t v26 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v26) {
      goto LABEL_69;
    }
  }
  else
  {
    uint64_t v26 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v26) {
      goto LABEL_69;
    }
  }
  if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
LABEL_69:
  uint64_t v27 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
    unint64_t v28 = (std::__shared_weak_count *)*((void *)this + 11);
    if (!v28) {
      goto LABEL_75;
    }
  }
  else
  {
    unint64_t v28 = (std::__shared_weak_count *)*((void *)this + 11);
    if (!v28) {
      goto LABEL_75;
    }
  }
  if (!atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
LABEL_75:
  uint64_t v29 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  *(void *)this = &unk_1EF530C60;
  unint64_t v30 = (void *)*((void *)this + 1);
  if (v30)
  {
    *((void *)this + 2) = v30;
    operator delete(v30);
  }
}

void md::realistic::PostchainRenderLayer::PostchainRenderLayer(md::realistic::PostchainRenderLayer *this, md::realistic::RealisticRenderer *a2)
{
  uint64_t v178 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (char *)a2 + 120;
  __int16 v4 = *(unsigned __int8 *)(*(void *)(*((void *)a2 + 15) + 32) + 19);
  *(_WORD *)v173 = (v4 << 8) | 5;
  *(_WORD *)&v173[2] = (v4 << 8) | 6;
  *(_WORD *)&v173[4] = (v4 << 8) | 7;
  *(_WORD *)&v173[6] = (v4 << 8) | 8;
  *(_WORD *)&v173[8] = (v4 << 8) | 9;
  *(_WORD *)&v173[10] = (v4 << 8) | 0xA;
  *(_WORD *)&v173[12] = (v4 << 8) | 0xB;
  md::realistic::RealisticRenderLayer::RealisticRenderLayer((uint64_t)this, 7, (uint64_t)a2, v173, 7);
  *(void *)this = &unk_1EF554998;
  *(_WORD *)((char *)this + 49) = (*(unsigned __int8 *)(*(void *)(*(void *)v3 + 32) + 19) << 8) | 5;
  *(_WORD *)((char *)this + 51) = (*(unsigned __int8 *)(*(void *)(*(void *)v3 + 32) + 19) << 8) | 6;
  *(_WORD *)((char *)this + 53) = (*(unsigned __int8 *)(*(void *)(*(void *)v3 + 32) + 19) << 8) | 7;
  *(_WORD *)((char *)this + 55) = (*(unsigned __int8 *)(*(void *)(*(void *)v3 + 32) + 19) << 8) | 8;
  *(_WORD *)((char *)this + 57) = (*(unsigned __int8 *)(*(void *)(*(void *)v3 + 32) + 19) << 8) | 9;
  *(_WORD *)((char *)this + 59) = (*(unsigned __int8 *)(*(void *)(*(void *)v3 + 32) + 19) << 8) | 0xA;
  __int16 v5 = (*(unsigned __int8 *)(*(void *)(*(void *)v3 + 32) + 19) << 8) | 0xB;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  uint8x8_t v6 = (char *)this + 128;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *(_WORD *)((char *)this + 61) = v5;
  *((_OWORD *)this + 15) = 0u;
  *((void *)this + 56) = 0;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  uint64_t v7 = [*(id *)(*((void *)this + 5) + 104) format];
  int v8 = *(_DWORD *)v7;
  uint64_t v9 = *(void *)(v7 + 8);
  int v10 = *(_DWORD *)(v7 + 24);
  v177[0] = *(_OWORD *)v7;
  *(_OWORD *)((char *)v177 + 12) = *(_OWORD *)(v7 + 12);
  long long v175 = *(_OWORD *)(v7 + 4);
  uint64_t v176 = *(void *)(v7 + 20);
  unint64_t v11 = operator new(0xE8uLL);
  v11[1] = 0;
  v11[2] = 0;
  *unint64_t v11 = &unk_1EF5863E0;
  uint64_t v12 = ggl::BufferData::BufferData((uint64_t)(v11 + 3), qword_1E9568448, 2, 1, 6, 1);
  v11[28] = ggl::PostchainCommon::CameraProperties::reflection(void)::reflection;
  v11[3] = &unk_1EF55DC78;
  uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 9);
  *((void *)this + 8) = v12;
  *((void *)this + 9) = v11;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  uint64_t v14 = *(void *)(*(void *)(*((void *)this + 5) + 200) + 80);
  uint64_t v16 = *(void *)(v14 + 368);
  uint64_t v15 = *(void *)(v14 + 376);
  *(void *)v160 = v16;
  *(void *)&v160[8] = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v163 = 0;
  uint64_t v17 = (char *)operator new(0x198uLL);
  *((void *)v17 + 1) = 0;
  *((void *)v17 + 2) = 0;
  *(void *)uint64_t v17 = &unk_1EF5855E0;
  *(_OWORD *)v173 = *(_OWORD *)v7;
  *(_OWORD *)&v173[16] = *(_OWORD *)(v7 + 16);
  {
    {
      {
        {
          ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::attributesReflection(void)::r = (uint64_t)&ggl::CommonMesh::bufferPos2UVReflection;
        }
        ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::attributesReflection(void)::r;
        unk_1EB32B448 = 1;
      }
      ggl::FlyoverPostchain::CompositePipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::typedReflection(void)::r;
      unk_1E9592390 = &ggl::FlyoverPostchain::pipelineDataCompositePipelineDeviceStructs(void)::ref;
      qword_1E9592398 = 0;
      {
        ggl::FlyoverPostchain::pipelineDataCompositePipelineConstantStructs(void)::ref = (uint64_t)ggl::PostchainCommon::CameraProperties::reflection(void)::reflection;
      }
      qword_1E95923A0 = (uint64_t)&ggl::FlyoverPostchain::pipelineDataCompositePipelineConstantStructs(void)::ref;
      unk_1E95923A8 = xmmword_1A28FC960;
    }
    ggl::FlyoverPostchain::CompositePipelineState::typedReflection(void)::ref = (uint64_t)&ggl::FlyoverPostchain::CompositePipelineSetup::typedReflection(void)::ref;
    {
      ggl::FlyoverPostchainCompositeShader::typedReflection(void)::ref = (uint64_t)"FlyoverPostchainCompositeShader";
      {
        int v159 = ggl::crc32::compute<38ul>("FlyoverPostchainCompositeShaderVertex");
        qword_1EB31CD38 = (uint64_t)"FlyoverPostchainCompositeShader";
        unk_1EB31CD40 = ggl::flyoverPostchainCompositeShaderVertShaderFunctionAttributes(void)::ref;
        qword_1EB31CD48 = 1;
        unk_1EB31CD50 = &ggl::flyoverPostchainCompositeShaderVertShaderFunctionConstantMapping(void)::ref;
        qword_1EB31CD58 = 0;
        unk_1EB31CD60 = &ggl::flyoverPostchainCompositeShaderVertShaderFunctionBufferMapping(void)::ref;
        qword_1EB31CD68 = 0;
        unk_1EB31CD70 = &ggl::flyoverPostchainCompositeShaderVertShaderFunctionTextureMapping(void)::ref;
        ggl::flyoverPostchainCompositeShaderVertexFunctionDescriptor(void)::ref = v159;
        *(_DWORD *)algn_1EB31CD34 = 0;
        qword_1EB31CD78 = 0;
        unk_1EB31CD80 = &ggl::flyoverPostchainCompositeShaderVertShaderFunctionSamplerMapping(void)::ref;
        qword_1EB31CD90 = 0;
        unk_1EB31CD98 = 0;
        qword_1EB31CD88 = 0;
      }
      qword_1EB31C128 = (uint64_t)&ggl::flyoverPostchainCompositeShaderVertexFunctionDescriptor(void)::ref;
      dword_1EB31C130 = ggl::crc32::compute<38ul>("FlyoverPostchainCompositeShaderVertex");
      {
        ggl::flyoverPostchainCompositeShaderFragmentFunctionDescriptor(void)::ref = 0x11EFF1393;
        qword_1EB31D0E0 = (uint64_t)"FlyoverPostchainCompositeShader";
        unk_1EB31D0E8 = 0;
        qword_1EB31D0F0 = 0;
        unk_1EB31D0F8 = &ggl::flyoverPostchainCompositeShaderFragShaderFunctionConstantMapping(void)::ref;
        qword_1EB31D100 = 1;
        unk_1EB31D108 = &ggl::flyoverPostchainCompositeShaderFragShaderFunctionBufferMapping(void)::ref;
        qword_1EB31D110 = 0;
        unk_1EB31D118 = &ggl::flyoverPostchainCompositeShaderFragShaderFunctionTextureMapping(void)::ref;
        qword_1EB31D120 = 4;
        unk_1EB31D128 = &ggl::flyoverPostchainCompositeShaderFragShaderFunctionSamplerMapping(void)::ref;
        qword_1EB31D138 = 0;
        unk_1EB31D140 = 0;
        qword_1EB31D130 = 4;
      }
      qword_1EB31C138 = (uint64_t)&ggl::flyoverPostchainCompositeShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB31C140 = 520033171;
      qword_1EB31C148 = (uint64_t)ggl::flyoverPostchainCompositeShaderShaderConstants(void)::ref;
      unk_1EB31C150 = 1;
      qword_1EB31C158 = (uint64_t)ggl::flyoverPostchainCompositeShaderShaderTextures(void)::ref;
      unk_1EB31C160 = 4;
      qword_1EB31C168 = (uint64_t)ggl::flyoverPostchainCompositeShaderShaderSamplers(void)::ref;
      unk_1EB31C170 = 4;
    }
    qword_1E9592338 = (uint64_t)&ggl::FlyoverPostchainCompositeShader::typedReflection(void)::ref;
    {
      ggl::FlyoverPostchain::pipelineStateCompositePipelineAttributeStructBinding(void)::attr = 0;
      *(void *)algn_1E9592698 = 0;
      qword_1E95926A0 = (uint64_t)"";
      dword_1E95926A8 = 0;
      qword_1E95926B0 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateCompositePipelineAttributeBinding_0(void)::attr;
      unk_1E95926B8 = 2;
    }
    qword_1E9592340 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateCompositePipelineAttributeStructBinding(void)::attr;
    *(void *)algn_1E9592348 = 1;
    qword_1E9592350 = 0;
    unk_1E9592358 = 4;
    qword_1E9592360 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateCompositePipelineDeviceStructBinding(void)::ref;
    unk_1E9592368 = 0;
    {
      ggl::FlyoverPostchain::pipelineStateCompositePipelineConstantStructBinding(void)::ref = 0;
      *(void *)algn_1E95926D8 = 0;
      qword_1E95926E0 = (uint64_t)"cameraProperties";
      dword_1E95926E8 = 3;
      qword_1E95926F0 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateCompositePipelineConstantCameraPropertiesBinding(void)::reflection;
      unk_1E95926F8 = 5;
    }
    qword_1E9592370 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateCompositePipelineConstantStructBinding(void)::ref;
    *(void *)algn_1E9592378 = 1;
  }
  long long v18 = *(_OWORD *)v160;
  if (*(void *)&v160[8]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v160[8] + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)v17 + 4) = 0;
  *((void *)v17 + 5) = 0;
  *((_DWORD *)v17 + 14) = 0;
  *((void *)v17 + 6) = 0;
  *((void *)v17 + 3) = &unk_1EF55B208;
  *((void *)v17 + 8) = &ggl::FlyoverPostchain::CompositePipelineState::typedReflection(void)::ref;
  *(_OWORD *)(v17 + 72) = v18;
  if (*((void *)&v18 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v18 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  v17[136] = 0;
  *(_OWORD *)(v17 + 140) = xmmword_1A28FC970;
  *(void *)(v17 + 156) = 0;
  *(void *)(v17 + 172) = 0;
  *(void *)(v17 + 164) = 0;
  v17[184] = 0;
  *(_OWORD *)(v17 + 188) = xmmword_1A28FC970;
  *(void *)(v17 + 204) = 0;
  *(void *)(v17 + 220) = 0;
  *(void *)(v17 + 212) = 0;
  v17[232] = 0;
  *(_OWORD *)(v17 + 236) = xmmword_1A28FC970;
  *(void *)(v17 + 252) = 0;
  *(void *)(v17 + 268) = 0;
  *(void *)(v17 + 260) = 0;
  long long v19 = *(_OWORD *)&v173[16];
  *(_OWORD *)(v17 + 280) = *(_OWORD *)v173;
  *(_OWORD *)(v17 + 296) = v19;
  v17[312] = 0;
  *((void *)v17 + 48) = 0;
  *((_OWORD *)v17 + 22) = 0u;
  *((_OWORD *)v17 + 23) = 0u;
  *((_OWORD *)v17 + 20) = 0u;
  *((_OWORD *)v17 + 21) = 0u;
  *((void *)v17 + 49) = 0x100000001;
  v17[400] = 0;
  v17[88] = 0;
  *(_WORD *)(v17 + 89) = v170;
  v17[91] = BYTE2(v170);
  *(_OWORD *)(v17 + 92) = xmmword_1A28FC970;
  *(void *)(v17 + 108) = v163;
  *((_DWORD *)v17 + 29) = 0;
  *((void *)v17 + 15) = 0;
  *((_DWORD *)v17 + 32) = 0;
  v17[132] = 15;
  if (*((void *)&v18 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v18 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**((void **)&v18 + 1) + 16))(*((void *)&v18 + 1));
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v18 + 1));
  }
  *((void *)v17 + 3) = &unk_1EF55D238;
  uint64_t v20 = (std::__shared_weak_count *)*((void *)this + 13);
  *((void *)this + 12) = v17 + 24;
  *((void *)this + 13) = v17;
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  if (*(void *)&v160[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v160[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**(void **)&v160[8] + 16))(*(void *)&v160[8]);
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v160[8]);
  }
  unint64_t v21 = operator new(0x100uLL);
  uint64_t v22 = v21;
  v21[1] = 0;
  v21[2] = 0;
  *unint64_t v21 = &unk_1EF5855A8;
  uint64_t v23 = v21 + 3;
  uint64_t v24 = *((void *)this + 12);
  uint64_t v25 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v25)
  {
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::PipelineSetup::PipelineSetup(v21 + 3, v24, (uint64_t)v25);
    if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  else
  {
    ggl::PipelineSetup::PipelineSetup(v21 + 3, v24, 0);
  }
  v22[3] = &unk_1EF55D208;
  uint64_t v26 = (std::__shared_weak_count *)*((void *)this + 15);
  *((void *)this + 14) = v23;
  *((void *)this + 15) = v22;
  if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  uint64_t v27 = *((void *)this + 14);
  unint64_t v28 = *(void **)(v27 + 64);
  v28[1] = 0;
  uint64_t v29 = *((void *)this + 8);
  void *v28 = v29;
  unint64_t v30 = *(void **)(v27 + 160);
  uint64_t v31 = *((void *)this + 9);
  if (v31) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v32 = (std::__shared_weak_count *)v30[1];
  void *v30 = v29;
  v30[1] = v31;
  if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
    std::__shared_weak_count::__release_weak(v32);
  }
  uint64_t v33 = operator new(0xF0uLL);
  v33[1] = 0;
  v33[2] = 0;
  *uint64_t v33 = &unk_1EF583548;
  v33[5] = 0;
  v33[6] = 0;
  *((_DWORD *)v33 + 14) = 0;
  v33[3] = &unk_1EF55A890;
  v33[4] = 0;
  *(void *)((char *)v33 + 60) = 65537;
  *((_DWORD *)v33 + 17) = 0;
  v33[9] = 1;
  *((_WORD *)v33 + 40) = 0;
  *((unsigned char *)v33 + 82) = 3;
  *(void *)((char *)v33 + 91) = 0;
  *(void *)((char *)v33 + 83) = 0;
  *((unsigned char *)v33 + 99) = 0;
  *(void *)((char *)v33 + 156) = 0;
  *(void *)((char *)v33 + 148) = 0;
  *((_WORD *)v33 + 106) = 257;
  v33[27] = 0;
  v33[28] = 0;
  *((unsigned char *)v33 + 232) = 0;
  uint64_t v34 = (std::__shared_weak_count *)*((void *)this + 11);
  *((void *)this + 10) = v33 + 3;
  *((void *)this + 11) = v33;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  *(unsigned char *)(*((void *)this + 10) + 58) = 3;
  uint64_t v170 = 0;
  uint64_t v167 = 0;
  uint64_t v35 = *(void *)(*(void *)(*((void *)this + 5) + 200) + 80);
  uint64_t v37 = *(void *)(v35 + 392);
  uint64_t v36 = *(void *)(v35 + 400);
  *(void *)v173 = v37;
  *(void *)&v173[8] = v36;
  if (v36) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v36 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v38 = (char *)operator new(0x198uLL);
  *((void *)v38 + 1) = 0;
  *((void *)v38 + 2) = 0;
  *(void *)uint64_t v38 = &unk_1EF585650;
  {
    {
      {
        {
          ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::attributesReflection(void)::r = (uint64_t)&ggl::CommonMesh::bufferPos2UVReflection;
        }
        ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::attributesReflection(void)::r;
        unk_1EB32B448 = 1;
      }
      ggl::FlyoverPostchain::DepthSplitPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::typedReflection(void)::r;
      unk_1E9592420 = &ggl::FlyoverPostchain::pipelineDataDepthSplitPipelineDeviceStructs(void)::ref;
      qword_1E9592428 = 0;
      {
        ggl::FlyoverPostchain::pipelineDataDepthSplitPipelineConstantStructs(void)::ref = (uint64_t)ggl::PostchainCommon::CameraProperties::reflection(void)::reflection;
      }
      qword_1E9592430 = (uint64_t)&ggl::FlyoverPostchain::pipelineDataDepthSplitPipelineConstantStructs(void)::ref;
      unk_1E9592438 = xmmword_1A28FC6E0;
    }
    ggl::FlyoverPostchain::DepthSplitPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::FlyoverPostchain::DepthSplitPipelineSetup::typedReflection(void)::ref;
    {
      ggl::FlyoverPostchainSplitFrameShader::typedReflection(void)::ref = (uint64_t)"FlyoverPostchainSplitFrameShader";
      {
        qword_1EB31CF78 = (uint64_t)"FlyoverPostchainSplitFrameShader";
        unk_1EB31CF80 = ggl::flyoverPostchainSplitFrameShaderVertShaderFunctionAttributes(void)::ref;
        qword_1EB31CF88 = 1;
        unk_1EB31CF90 = &ggl::flyoverPostchainSplitFrameShaderVertShaderFunctionConstantMapping(void)::ref;
        qword_1EB31CF98 = 0;
        unk_1EB31CFA0 = &ggl::flyoverPostchainSplitFrameShaderVertShaderFunctionBufferMapping(void)::ref;
        qword_1EB31CFA8 = 0;
        unk_1EB31CFB0 = &ggl::flyoverPostchainSplitFrameShaderVertShaderFunctionTextureMapping(void)::ref;
        ggl::flyoverPostchainSplitFrameShaderVertexFunctionDescriptor(void)::ref = 2595229844;
        qword_1EB31CFB8 = 0;
        unk_1EB31CFC0 = &ggl::flyoverPostchainSplitFrameShaderVertShaderFunctionSamplerMapping(void)::ref;
        qword_1EB31CFD0 = 0;
        unk_1EB31CFD8 = 0;
        qword_1EB31CFC8 = 0;
      }
      qword_1EB31C248 = (uint64_t)&ggl::flyoverPostchainSplitFrameShaderVertexFunctionDescriptor(void)::ref;
      dword_1EB31C250 = -1699737452;
      {
        ggl::flyoverPostchainSplitFrameShaderFragmentFunctionDescriptor(void)::ref = 0x148DF32F9;
        qword_1EB31D330 = (uint64_t)"FlyoverPostchainSplitFrameShader";
        unk_1EB31D338 = 0;
        qword_1EB31D340 = 0;
        unk_1EB31D348 = &ggl::flyoverPostchainSplitFrameShaderFragShaderFunctionConstantMapping(void)::ref;
        qword_1EB31D350 = 1;
        unk_1EB31D358 = &ggl::flyoverPostchainSplitFrameShaderFragShaderFunctionBufferMapping(void)::ref;
        qword_1EB31D360 = 0;
        unk_1EB31D368 = &ggl::flyoverPostchainSplitFrameShaderFragShaderFunctionTextureMapping(void)::ref;
        qword_1EB31D370 = 2;
        unk_1EB31D378 = &ggl::flyoverPostchainSplitFrameShaderFragShaderFunctionSamplerMapping(void)::ref;
        qword_1EB31D388 = 0;
        unk_1EB31D390 = 0;
        qword_1EB31D380 = 2;
      }
      qword_1EB31C258 = (uint64_t)&ggl::flyoverPostchainSplitFrameShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB31C260 = 1222587129;
      qword_1EB31C268 = (uint64_t)ggl::flyoverPostchainSplitFrameShaderShaderConstants(void)::ref;
      unk_1EB31C270 = 1;
      qword_1EB31C278 = (uint64_t)ggl::flyoverPostchainSplitFrameShaderShaderTextures(void)::ref;
      unk_1EB31C280 = 2;
      qword_1EB31C288 = (uint64_t)ggl::flyoverPostchainSplitFrameShaderShaderSamplers(void)::ref;
      unk_1EB31C290 = 2;
    }
    qword_1E95923C8 = (uint64_t)&ggl::FlyoverPostchainSplitFrameShader::typedReflection(void)::ref;
    {
      ggl::FlyoverPostchain::pipelineStateDepthSplitPipelineAttributeStructBinding(void)::attr = 0;
      *(void *)algn_1E9592728 = 0;
      qword_1E9592730 = (uint64_t)"";
      dword_1E9592738 = 0;
      qword_1E9592740 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateDepthSplitPipelineAttributeBinding_0(void)::attr;
      unk_1E9592748 = 2;
    }
    qword_1E95923D0 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateDepthSplitPipelineAttributeStructBinding(void)::attr;
    *(void *)algn_1E95923D8 = 1;
    qword_1E95923E0 = 0;
    unk_1E95923E8 = 2;
    qword_1E95923F0 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateDepthSplitPipelineDeviceStructBinding(void)::ref;
    unk_1E95923F8 = 0;
    {
      ggl::FlyoverPostchain::pipelineStateDepthSplitPipelineConstantStructBinding(void)::ref = 0;
      *(void *)algn_1E9592768 = 0;
      qword_1E9592770 = (uint64_t)"cameraProperties";
      dword_1E9592778 = 3;
      qword_1E9592780 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateDepthSplitPipelineConstantCameraPropertiesBinding(void)::reflection;
      unk_1E9592788 = 5;
    }
    qword_1E9592400 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateDepthSplitPipelineConstantStructBinding(void)::ref;
    *(void *)algn_1E9592408 = 1;
  }
  long long v39 = *(_OWORD *)v173;
  if (*(void *)&v173[8]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v173[8] + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)v38 + 4) = 0;
  *((void *)v38 + 5) = 0;
  *((_DWORD *)v38 + 14) = 0;
  *((void *)v38 + 6) = 0;
  *((void *)v38 + 3) = &unk_1EF55B208;
  *((void *)v38 + 8) = &ggl::FlyoverPostchain::DepthSplitPipelineState::typedReflection(void)::ref;
  *(_OWORD *)(v38 + 72) = v39;
  if (*((void *)&v39 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v39 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  v38[184] = 0;
  *(_OWORD *)(v38 + 188) = xmmword_1A28FC970;
  *(void *)(v38 + 204) = 0;
  *(void *)(v38 + 220) = 0;
  *(void *)(v38 + 212) = 0;
  v38[232] = 0;
  *(_OWORD *)(v38 + 236) = xmmword_1A28FC970;
  *(void *)(v38 + 252) = 0;
  *(void *)(v38 + 268) = 0;
  *(void *)(v38 + 260) = 0;
  *((_DWORD *)v38 + 70) = v8;
  *((_DWORD *)v38 + 71) = v8;
  *((void *)v38 + 36) = v9;
  *((void *)v38 + 37) = 2;
  *((_DWORD *)v38 + 76) = v10;
  *((_DWORD *)v38 + 77) = 0;
  v38[312] = 0;
  *((_OWORD *)v38 + 20) = 0u;
  *((_OWORD *)v38 + 21) = 0u;
  *((_OWORD *)v38 + 22) = 0u;
  *((_OWORD *)v38 + 23) = 0u;
  *((void *)v38 + 48) = 0;
  *((void *)v38 + 49) = 0x100000001;
  v38[400] = 0;
  v38[88] = 0;
  v38[91] = v172;
  *(_WORD *)(v38 + 89) = v171;
  *(_OWORD *)(v38 + 92) = xmmword_1A28FC970;
  *(void *)(v38 + 108) = v170;
  *(void *)(v38 + 124) = 0;
  *(void *)(v38 + 116) = 0;
  v38[132] = 15;
  v38[136] = 0;
  *(_WORD *)(v38 + 137) = v168;
  v38[139] = v169;
  *(_OWORD *)(v38 + 140) = xmmword_1A28FC970;
  *(void *)(v38 + 156) = v167;
  *(void *)(v38 + 164) = 0;
  *(void *)(v38 + 172) = 0;
  v38[180] = 15;
  if (*((void *)&v39 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v39 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**((void **)&v39 + 1) + 16))(*((void *)&v39 + 1));
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v39 + 1));
  }
  *((void *)v38 + 3) = &unk_1EF55D288;
  uint64_t v40 = (std::__shared_weak_count *)*((void *)this + 22);
  *((void *)this + 21) = v38 + 24;
  *((void *)this + 22) = v38;
  if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
  }
  uint64_t v41 = *(std::__shared_weak_count **)&v173[8];
  if (*(void *)&v173[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v173[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
    std::__shared_weak_count::__release_weak(v41);
  }
  unint64_t v42 = operator new(0x100uLL);
  v43 = v42;
  v42[1] = 0;
  v42[2] = 0;
  void *v42 = &unk_1EF585618;
  unint64_t v44 = v42 + 3;
  uint64_t v45 = *((void *)this + 21);
  uint64_t v46 = (std::__shared_weak_count *)*((void *)this + 22);
  if (v46)
  {
    atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::PipelineSetup::PipelineSetup(v42 + 3, v45, (uint64_t)v46);
    if (!atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
  else
  {
    ggl::PipelineSetup::PipelineSetup(v42 + 3, v45, 0);
  }
  v43[3] = &unk_1EF55D258;
  uint64_t v47 = (std::__shared_weak_count *)*((void *)this + 24);
  *((void *)this + 23) = v44;
  *((void *)this + 24) = v43;
  if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
    std::__shared_weak_count::__release_weak(v47);
  }
  uint64_t v48 = *((void *)this + 23);
  unint64_t v49 = *(void **)(v48 + 64);
  v49[1] = 0;
  uint64_t v50 = *((void *)this + 8);
  *unint64_t v49 = v50;
  unint64_t v51 = *(void **)(v48 + 160);
  uint64_t v52 = *((void *)this + 9);
  if (v52) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v52 + 8), 1uLL, memory_order_relaxed);
  }
  float v53 = (std::__shared_weak_count *)v51[1];
  *unint64_t v51 = v50;
  v51[1] = v52;
  if (v53 && !atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
  }
  v54 = operator new(0xF0uLL);
  v54[1] = 0;
  v54[2] = 0;
  void *v54 = &unk_1EF583548;
  v54[5] = 0;
  v54[6] = 0;
  *((_DWORD *)v54 + 14) = 0;
  v54[3] = &unk_1EF55A890;
  v54[4] = 0;
  *(void *)((char *)v54 + 60) = 65537;
  *((_DWORD *)v54 + 17) = 0;
  v54[9] = 1;
  *((_WORD *)v54 + 40) = 0;
  *((unsigned char *)v54 + 82) = 3;
  *(void *)((char *)v54 + 91) = 0;
  *(void *)((char *)v54 + 83) = 0;
  *((unsigned char *)v54 + 99) = 0;
  *(void *)((char *)v54 + 156) = 0;
  *(void *)((char *)v54 + 148) = 0;
  *((_WORD *)v54 + 106) = 257;
  v54[27] = 0;
  v54[28] = 0;
  *((unsigned char *)v54 + 232) = 0;
  float v55 = (std::__shared_weak_count *)*((void *)this + 20);
  *((void *)this + 19) = v54 + 3;
  *((void *)this + 20) = v54;
  if (v55 && !atomic_fetch_add(&v55->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
    std::__shared_weak_count::__release_weak(v55);
  }
  *(unsigned char *)(*((void *)this + 19) + 58) = 3;
  uint64_t v56 = *(void *)(*(void *)(*((void *)this + 5) + 200) + 80);
  uint64_t v58 = *(void *)(v56 + 416);
  uint64_t v57 = *(void *)(v56 + 424);
  *(void *)v160 = v58;
  *(void *)&v160[8] = v57;
  if (v57) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v57 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v163 = 0;
  uint64_t v59 = (char *)operator new(0x198uLL);
  *((void *)v59 + 1) = 0;
  *((void *)v59 + 2) = 0;
  *(void *)uint64_t v59 = &unk_1EF5856C0;
  *(_OWORD *)v173 = v175;
  *(void *)&v173[16] = v176;
  {
    {
      {
        {
          ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::attributesReflection(void)::r = (uint64_t)&ggl::CommonMesh::bufferPos2UVReflection;
        }
        ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::attributesReflection(void)::r;
        unk_1EB32B448 = 1;
      }
      ggl::FlyoverPostchain::DownsampleCoCPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::typedReflection(void)::r;
      unk_1E95924B0 = &ggl::FlyoverPostchain::pipelineDataDownsampleCoCPipelineDeviceStructs(void)::ref;
      qword_1E95924B8 = 0;
      unk_1E95924C0 = &ggl::FlyoverPostchain::pipelineDataDownsampleCoCPipelineConstantStructs(void)::ref;
      xmmword_1E95924C8 = xmmword_1A28FC760;
    }
    ggl::FlyoverPostchain::DownsampleCoCPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::FlyoverPostchain::DownsampleCoCPipelineSetup::typedReflection(void)::ref;
    {
      ggl::FlyoverPostchainDownsampleCoCShader::typedReflection(void)::ref = (uint64_t)"FlyoverPostchainDownsampleCoCShader";
      {
        qword_1EB31D418 = (uint64_t)"FlyoverPostchainDownsampleCoCShader";
        unk_1EB31D420 = ggl::flyoverPostchainDownsampleCoCShaderVertShaderFunctionAttributes(void)::ref;
        qword_1EB31D428 = 1;
        unk_1EB31D430 = &ggl::flyoverPostchainDownsampleCoCShaderVertShaderFunctionConstantMapping(void)::ref;
        qword_1EB31D438 = 0;
        unk_1EB31D440 = &ggl::flyoverPostchainDownsampleCoCShaderVertShaderFunctionBufferMapping(void)::ref;
        qword_1EB31D448 = 0;
        unk_1EB31D450 = &ggl::flyoverPostchainDownsampleCoCShaderVertShaderFunctionTextureMapping(void)::ref;
        ggl::flyoverPostchainDownsampleCoCShaderVertexFunctionDescriptor(void)::ref = 3177222361;
        qword_1EB31D458 = 0;
        unk_1EB31D460 = &ggl::flyoverPostchainDownsampleCoCShaderVertShaderFunctionSamplerMapping(void)::ref;
        qword_1EB31D470 = 0;
        unk_1EB31D478 = 0;
        qword_1EB31D468 = 0;
      }
      qword_1EB31C3C8 = (uint64_t)&ggl::flyoverPostchainDownsampleCoCShaderVertexFunctionDescriptor(void)::ref;
      dword_1EB31C3D0 = -1117744935;
      {
        ggl::flyoverPostchainDownsampleCoCShaderFragmentFunctionDescriptor(void)::ref = 0x1E0B0A741;
        qword_1EB31D6D0 = (uint64_t)"FlyoverPostchainDownsampleCoCShader";
        unk_1EB31D6D8 = 0;
        qword_1EB31D6E0 = 0;
        unk_1EB31D6E8 = &ggl::flyoverPostchainDownsampleCoCShaderFragShaderFunctionConstantMapping(void)::ref;
        qword_1EB31D6F0 = 0;
        unk_1EB31D6F8 = &ggl::flyoverPostchainDownsampleCoCShaderFragShaderFunctionBufferMapping(void)::ref;
        qword_1EB31D700 = 0;
        unk_1EB31D708 = &ggl::flyoverPostchainDownsampleCoCShaderFragShaderFunctionTextureMapping(void)::ref;
        qword_1EB31D710 = 1;
        unk_1EB31D718 = &ggl::flyoverPostchainDownsampleCoCShaderFragShaderFunctionSamplerMapping(void)::ref;
        qword_1EB31D728 = 0;
        unk_1EB31D730 = 0;
        qword_1EB31D720 = 1;
      }
      qword_1EB31C3D8 = (uint64_t)&ggl::flyoverPostchainDownsampleCoCShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB31C3E0 = -525293759;
      qword_1EB31C3E8 = (uint64_t)&ggl::flyoverPostchainDownsampleCoCShaderShaderConstants(void)::ref;
      unk_1EB31C3F0 = 0;
      qword_1EB31C3F8 = (uint64_t)ggl::flyoverPostchainDownsampleCoCShaderShaderTextures(void)::ref;
      unk_1EB31C400 = 1;
      qword_1EB31C408 = (uint64_t)ggl::flyoverPostchainDownsampleCoCShaderShaderSamplers(void)::ref;
      unk_1EB31C410 = 1;
    }
    qword_1E9592458 = (uint64_t)&ggl::FlyoverPostchainDownsampleCoCShader::typedReflection(void)::ref;
    {
      ggl::FlyoverPostchain::pipelineStateDownsampleCoCPipelineAttributeStructBinding(void)::attr = 0;
      *(void *)algn_1E95927B8 = 0;
      qword_1E95927C0 = (uint64_t)"";
      dword_1E95927C8 = 0;
      qword_1E95927D0 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateDownsampleCoCPipelineAttributeBinding_0(void)::attr;
      unk_1E95927D8 = 2;
    }
    qword_1E9592460 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateDownsampleCoCPipelineAttributeStructBinding(void)::attr;
    *(void *)algn_1E9592468 = 1;
    qword_1E9592470 = 0;
    unk_1E9592478 = 1;
    qword_1E9592480 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateDownsampleCoCPipelineDeviceStructBinding(void)::ref;
    unk_1E9592488 = 0;
    qword_1E9592490 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateDownsampleCoCPipelineConstantStructBinding(void)::ref;
    unk_1E9592498 = 0;
  }
  long long v60 = *(_OWORD *)v160;
  if (*(void *)&v160[8]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v160[8] + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)v59 + 4) = 0;
  *((void *)v59 + 5) = 0;
  *((_DWORD *)v59 + 14) = 0;
  *((void *)v59 + 6) = 0;
  *((void *)v59 + 3) = &unk_1EF55B208;
  *((void *)v59 + 8) = &ggl::FlyoverPostchain::DownsampleCoCPipelineState::typedReflection(void)::ref;
  *(_OWORD *)(v59 + 72) = v60;
  if (*((void *)&v60 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v60 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  v59[136] = 0;
  *(_OWORD *)(v59 + 140) = xmmword_1A28FC970;
  *(void *)(v59 + 156) = 0;
  *(void *)(v59 + 172) = 0;
  *(void *)(v59 + 164) = 0;
  v59[184] = 0;
  *(_OWORD *)(v59 + 188) = xmmword_1A28FC970;
  *(void *)(v59 + 204) = 0;
  *(void *)(v59 + 220) = 0;
  *(void *)(v59 + 212) = 0;
  v59[232] = 0;
  *(_OWORD *)(v59 + 236) = xmmword_1A28FC970;
  *(void *)(v59 + 252) = 0;
  *(void *)(v59 + 268) = 0;
  *(void *)(v59 + 260) = 0;
  *((_DWORD *)v59 + 70) = 2;
  long long v61 = *(_OWORD *)v173;
  *(void *)(v59 + 300) = *(void *)&v173[16];
  *(_OWORD *)(v59 + 284) = v61;
  *((_DWORD *)v59 + 77) = 0;
  v59[312] = 0;
  *((void *)v59 + 48) = 0;
  *((_OWORD *)v59 + 22) = 0u;
  *((_OWORD *)v59 + 23) = 0u;
  *((_OWORD *)v59 + 20) = 0u;
  *((_OWORD *)v59 + 21) = 0u;
  *((void *)v59 + 49) = 0x100000001;
  v59[400] = 0;
  v59[88] = 0;
  *(_WORD *)(v59 + 89) = v165;
  v59[91] = v166;
  *(_OWORD *)(v59 + 92) = xmmword_1A28FC970;
  *(void *)(v59 + 108) = v163;
  *((_DWORD *)v59 + 32) = 0;
  *((void *)v59 + 15) = 0;
  *((_DWORD *)v59 + 29) = 0;
  v59[132] = 15;
  if (*((void *)&v60 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v60 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**((void **)&v60 + 1) + 16))(*((void *)&v60 + 1));
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v60 + 1));
  }
  *((void *)v59 + 3) = &unk_1EF55D2D8;
  uint64_t v62 = (std::__shared_weak_count *)*((void *)this + 29);
  *((void *)this + 28) = v59 + 24;
  *((void *)this + 29) = v59;
  if (v62 && !atomic_fetch_add(&v62->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
    std::__shared_weak_count::__release_weak(v62);
  }
  if (*(void *)&v160[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v160[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**(void **)&v160[8] + 16))(*(void *)&v160[8]);
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v160[8]);
  }
  uint64_t v63 = operator new(0x100uLL);
  unint64_t v64 = v63;
  v63[1] = 0;
  v63[2] = 0;
  *uint64_t v63 = &unk_1EF585688;
  uint64_t v65 = v63 + 3;
  uint64_t v66 = *((void *)this + 28);
  unint64_t v67 = (std::__shared_weak_count *)*((void *)this + 29);
  if (v67)
  {
    atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::PipelineSetup::PipelineSetup(v63 + 3, v66, (uint64_t)v67);
    if (!atomic_fetch_add(&v67->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
      std::__shared_weak_count::__release_weak(v67);
    }
  }
  else
  {
    ggl::PipelineSetup::PipelineSetup(v63 + 3, v66, 0);
  }
  v64[3] = &unk_1EF55D2A8;
  uint64_t v68 = (std::__shared_weak_count *)*((void *)this + 31);
  *((void *)this + 30) = v65;
  *((void *)this + 31) = v64;
  if (v68 && !atomic_fetch_add(&v68->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
    std::__shared_weak_count::__release_weak(v68);
  }
  uint64_t v69 = operator new(0xF0uLL);
  v69[1] = 0;
  v69[2] = 0;
  void *v69 = &unk_1EF583548;
  v69[5] = 0;
  v69[6] = 0;
  *((_DWORD *)v69 + 14) = 0;
  v69[3] = &unk_1EF55A890;
  v69[4] = 0;
  *(void *)((char *)v69 + 60) = 65537;
  *((_DWORD *)v69 + 17) = 0;
  v69[9] = 1;
  *((_WORD *)v69 + 40) = 0;
  *((unsigned char *)v69 + 82) = 3;
  *(void *)((char *)v69 + 91) = 0;
  *(void *)((char *)v69 + 83) = 0;
  *((unsigned char *)v69 + 99) = 0;
  *(void *)((char *)v69 + 156) = 0;
  *(void *)((char *)v69 + 148) = 0;
  *((_WORD *)v69 + 106) = 257;
  v69[27] = 0;
  v69[28] = 0;
  *((unsigned char *)v69 + 232) = 0;
  uint64_t v70 = (std::__shared_weak_count *)*((void *)this + 27);
  *((void *)this + 26) = v69 + 3;
  *((void *)this + 27) = v69;
  if (v70 && !atomic_fetch_add(&v70->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
    std::__shared_weak_count::__release_weak(v70);
  }
  *(unsigned char *)(*((void *)this + 26) + 58) = 3;
  uint64_t v71 = *(void *)(*(void *)(*((void *)this + 5) + 200) + 80);
  uint64_t v73 = *(void *)(v71 + 464);
  uint64_t v72 = *(void *)(v71 + 472);
  *(void *)v160 = v73;
  *(void *)&v160[8] = v72;
  if (v72) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v72 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v163 = 0;
  unint64_t v74 = (char *)operator new(0x198uLL);
  *((void *)v74 + 1) = 0;
  *((void *)v74 + 2) = 0;
  *(void *)unint64_t v74 = &unk_1EF585500;
  *(_OWORD *)v173 = v177[0];
  *(_OWORD *)&v173[12] = *(_OWORD *)((char *)v177 + 12);
  {
    if (v157)
    {
      {
        if (v157)
        {
          {
            {
              ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::attributesReflection(void)::r = (uint64_t)&ggl::CommonMesh::bufferPos2UVReflection;
            }
            ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::attributesReflection(void)::r;
            unk_1EB32B448 = 1;
          }
          ggl::FlyoverPostchain::FGBlurPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::typedReflection(void)::r;
          unk_1E9592540 = &ggl::FlyoverPostchain::pipelineDataFGBlurPipelineDeviceStructs(void)::ref;
          qword_1E9592548 = 0;
          {
            ggl::FlyoverPostchain::pipelineDataFGBlurPipelineConstantStructs(void)::ref = (uint64_t)ggl::PostchainCommon::CameraProperties::reflection(void)::reflection;
          }
          qword_1E9592550 = (uint64_t)&ggl::FlyoverPostchain::pipelineDataFGBlurPipelineConstantStructs(void)::ref;
          unk_1E9592558 = xmmword_1A28FC6E0;
        }
      }
      ggl::FlyoverPostchain::FGBlurPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::FlyoverPostchain::FGBlurPipelineSetup::typedReflection(void)::ref;
      ggl::FlyoverPostchainFGBlurShader::typedReflection(v157);
      qword_1E95924E8 = (uint64_t)&ggl::FlyoverPostchainFGBlurShader::typedReflection(void)::ref;
      {
        ggl::FlyoverPostchain::pipelineStateFGBlurPipelineAttributeStructBinding(void)::attr = 0;
        unk_1E9592810 = 0;
        qword_1E9592818 = (uint64_t)"";
        dword_1E9592820 = 0;
        qword_1E9592828 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateFGBlurPipelineAttributeBinding_0(void)::attr;
        unk_1E9592830 = 2;
      }
      qword_1E95924F0 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateFGBlurPipelineAttributeStructBinding(void)::attr;
      *(void *)algn_1E95924F8 = 1;
      qword_1E9592500 = 0;
      unk_1E9592508 = 2;
      qword_1E9592510 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateFGBlurPipelineDeviceStructBinding(void)::ref;
      unk_1E9592518 = 0;
      {
        ggl::FlyoverPostchain::pipelineStateFGBlurPipelineConstantStructBinding(void)::ref = 0;
        unk_1E9592850 = 0;
        qword_1E9592858 = (uint64_t)"cameraProperties";
        dword_1E9592860 = 3;
        qword_1E9592868 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateFGBlurPipelineConstantCameraPropertiesBinding(void)::reflection;
        unk_1E9592870 = 5;
      }
      qword_1E9592520 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateFGBlurPipelineConstantStructBinding(void)::ref;
      *(void *)algn_1E9592528 = 1;
    }
  }
  long long v75 = *(_OWORD *)v160;
  if (*(void *)&v160[8]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v160[8] + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)v74 + 4) = 0;
  *((void *)v74 + 5) = 0;
  *((_DWORD *)v74 + 14) = 0;
  *((void *)v74 + 6) = 0;
  *((void *)v74 + 3) = &unk_1EF55B208;
  *((void *)v74 + 8) = &ggl::FlyoverPostchain::FGBlurPipelineState::typedReflection(void)::ref;
  *(_OWORD *)(v74 + 72) = v75;
  if (*((void *)&v75 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v75 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  v74[136] = 0;
  *(_OWORD *)(v74 + 140) = xmmword_1A28FC970;
  *(void *)(v74 + 156) = 0;
  *(void *)(v74 + 172) = 0;
  *(void *)(v74 + 164) = 0;
  v74[184] = 0;
  *(_OWORD *)(v74 + 188) = xmmword_1A28FC970;
  *(void *)(v74 + 204) = 0;
  *(void *)(v74 + 220) = 0;
  *(void *)(v74 + 212) = 0;
  v74[232] = 0;
  *(_OWORD *)(v74 + 236) = xmmword_1A28FC970;
  *(void *)(v74 + 252) = 0;
  *(void *)(v74 + 268) = 0;
  *(void *)(v74 + 260) = 0;
  *(_OWORD *)(v74 + 280) = *(_OWORD *)v173;
  *(_OWORD *)(v74 + 292) = *(_OWORD *)&v173[12];
  *((_DWORD *)v74 + 77) = 0;
  v74[312] = 0;
  *((void *)v74 + 48) = 0;
  *((_OWORD *)v74 + 22) = 0u;
  *((_OWORD *)v74 + 23) = 0u;
  *((_OWORD *)v74 + 20) = 0u;
  *((_OWORD *)v74 + 21) = 0u;
  *((void *)v74 + 49) = 0x100000001;
  v74[400] = 0;
  v74[88] = 0;
  *(_WORD *)(v74 + 89) = v165;
  v74[91] = v166;
  *(_OWORD *)(v74 + 92) = xmmword_1A28FC970;
  *(void *)(v74 + 108) = v163;
  *((_DWORD *)v74 + 32) = 0;
  *((void *)v74 + 15) = 0;
  *((_DWORD *)v74 + 29) = 0;
  v74[132] = 15;
  if (*((void *)&v75 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v75 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**((void **)&v75 + 1) + 16))(*((void *)&v75 + 1));
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v75 + 1));
  }
  *((void *)v74 + 3) = &unk_1EF55D198;
  uint64_t v76 = (std::__shared_weak_count *)*((void *)this + 36);
  *((void *)this + 35) = v74 + 24;
  *((void *)this + 36) = v74;
  if (v76 && !atomic_fetch_add(&v76->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
    std::__shared_weak_count::__release_weak(v76);
  }
  if (*(void *)&v160[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v160[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**(void **)&v160[8] + 16))(*(void *)&v160[8]);
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v160[8]);
  }
  uint64_t v77 = *(void *)(*(void *)(*((void *)this + 5) + 200) + 80);
  uint64_t v79 = *(void *)(v77 + 440);
  uint64_t v78 = *(void *)(v77 + 448);
  *(void *)v160 = v79;
  *(void *)&v160[8] = v78;
  if (v78) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v78 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v163 = 0;
  unint64_t v80 = (char *)operator new(0x198uLL);
  *((void *)v80 + 1) = 0;
  *((void *)v80 + 2) = 0;
  *(void *)unint64_t v80 = &unk_1EF585490;
  *(_OWORD *)v173 = v177[0];
  *(_OWORD *)&v173[12] = *(_OWORD *)((char *)v177 + 12);
  {
    if (v158)
    {
      {
        if (v158)
        {
          {
            {
              ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::attributesReflection(void)::r = (uint64_t)&ggl::CommonMesh::bufferPos2UVReflection;
            }
            ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::attributesReflection(void)::r;
            unk_1EB32B448 = 1;
          }
          ggl::FlyoverPostchain::BGBlurPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::typedReflection(void)::r;
          unk_1E95925D0 = &ggl::FlyoverPostchain::pipelineDataBGBlurPipelineDeviceStructs(void)::ref;
          qword_1E95925D8 = 0;
          {
            ggl::FlyoverPostchain::pipelineDataBGBlurPipelineConstantStructs(void)::ref = (uint64_t)ggl::PostchainCommon::CameraProperties::reflection(void)::reflection;
          }
          qword_1E95925E0 = (uint64_t)&ggl::FlyoverPostchain::pipelineDataBGBlurPipelineConstantStructs(void)::ref;
          unk_1E95925E8 = vdupq_n_s64(1uLL);
        }
      }
      ggl::FlyoverPostchain::BGBlurPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::FlyoverPostchain::BGBlurPipelineSetup::typedReflection(void)::ref;
      ggl::FlyoverPostchainBGBlurShader::typedReflection(v158);
      qword_1E9592578 = (uint64_t)&ggl::FlyoverPostchainBGBlurShader::typedReflection(void)::ref;
      {
        ggl::FlyoverPostchain::pipelineStateBGBlurPipelineAttributeStructBinding(void)::attr = 0;
        unk_1E95928A0 = 0;
        qword_1E95928A8 = (uint64_t)"";
        dword_1E95928B0 = 0;
        qword_1E95928B8 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateBGBlurPipelineAttributeBinding_0(void)::attr;
        unk_1E95928C0 = 2;
      }
      qword_1E9592580 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateBGBlurPipelineAttributeStructBinding(void)::attr;
      *(void *)algn_1E9592588 = 1;
      qword_1E9592590 = 0;
      unk_1E9592598 = 1;
      qword_1E95925A0 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateBGBlurPipelineDeviceStructBinding(void)::ref;
      unk_1E95925A8 = 0;
      {
        ggl::FlyoverPostchain::pipelineStateBGBlurPipelineConstantStructBinding(void)::ref = 0;
        unk_1E95928E0 = 0;
        qword_1E95928E8 = (uint64_t)"cameraProperties";
        dword_1E95928F0 = 3;
        qword_1E95928F8 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateBGBlurPipelineConstantCameraPropertiesBinding(void)::reflection;
        unk_1E9592900 = 5;
      }
      qword_1E95925B0 = (uint64_t)&ggl::FlyoverPostchain::pipelineStateBGBlurPipelineConstantStructBinding(void)::ref;
      *(void *)algn_1E95925B8 = 1;
    }
  }
  long long v81 = *(_OWORD *)v160;
  if (*(void *)&v160[8]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v160[8] + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)v80 + 4) = 0;
  *((void *)v80 + 5) = 0;
  *((_DWORD *)v80 + 14) = 0;
  *((void *)v80 + 6) = 0;
  *((void *)v80 + 3) = &unk_1EF55B208;
  *((void *)v80 + 8) = &ggl::FlyoverPostchain::BGBlurPipelineState::typedReflection(void)::ref;
  *(_OWORD *)(v80 + 72) = v81;
  if (*((void *)&v81 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v81 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  v80[136] = 0;
  *(_OWORD *)(v80 + 140) = xmmword_1A28FC970;
  *(void *)(v80 + 156) = 0;
  *(void *)(v80 + 172) = 0;
  *(void *)(v80 + 164) = 0;
  v80[184] = 0;
  *(_OWORD *)(v80 + 188) = xmmword_1A28FC970;
  *(void *)(v80 + 204) = 0;
  *(void *)(v80 + 220) = 0;
  *(void *)(v80 + 212) = 0;
  v80[232] = 0;
  *(_OWORD *)(v80 + 236) = xmmword_1A28FC970;
  *(void *)(v80 + 252) = 0;
  *(void *)(v80 + 268) = 0;
  *(void *)(v80 + 260) = 0;
  *(_OWORD *)(v80 + 280) = *(_OWORD *)v173;
  *(_OWORD *)(v80 + 292) = *(_OWORD *)&v173[12];
  *((_DWORD *)v80 + 77) = 0;
  v80[312] = 0;
  *((void *)v80 + 48) = 0;
  *((_OWORD *)v80 + 22) = 0u;
  *((_OWORD *)v80 + 23) = 0u;
  *((_OWORD *)v80 + 20) = 0u;
  *((_OWORD *)v80 + 21) = 0u;
  *((void *)v80 + 49) = 0x100000001;
  v80[400] = 0;
  v80[88] = 0;
  *(_WORD *)(v80 + 89) = v165;
  v80[91] = v166;
  *(_OWORD *)(v80 + 92) = xmmword_1A28FC970;
  *(void *)(v80 + 108) = v163;
  *((_DWORD *)v80 + 32) = 0;
  *((void *)v80 + 15) = 0;
  *((_DWORD *)v80 + 29) = 0;
  v80[132] = 15;
  if (*((void *)&v81 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v81 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**((void **)&v81 + 1) + 16))(*((void *)&v81 + 1));
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v81 + 1));
  }
  *((void *)v80 + 3) = &unk_1EF55D148;
  uint64_t v82 = (std::__shared_weak_count *)*((void *)this + 38);
  *((void *)this + 37) = v80 + 24;
  *((void *)this + 38) = v80;
  if (v82 && !atomic_fetch_add(&v82->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
    std::__shared_weak_count::__release_weak(v82);
  }
  if (*(void *)&v160[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v160[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**(void **)&v160[8] + 16))(*(void *)&v160[8]);
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v160[8]);
  }
  uint64_t v83 = operator new(0x100uLL);
  unint64_t v84 = v83;
  v83[1] = 0;
  v83[2] = 0;
  *uint64_t v83 = &unk_1EF5854C8;
  uint64_t v85 = v83 + 3;
  uint64_t v86 = *((void *)this + 35);
  unint64_t v87 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v87)
  {
    atomic_fetch_add_explicit(&v87->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::PipelineSetup::PipelineSetup(v83 + 3, v86, (uint64_t)v87);
    if (!atomic_fetch_add(&v87->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
      std::__shared_weak_count::__release_weak(v87);
    }
  }
  else
  {
    ggl::PipelineSetup::PipelineSetup(v83 + 3, v86, 0);
  }
  v84[3] = &unk_1EF55D168;
  uint64_t v88 = (std::__shared_weak_count *)*((void *)this + 40);
  *((void *)this + 39) = v85;
  *((void *)this + 40) = v84;
  if (v88 && !atomic_fetch_add(&v88->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
    std::__shared_weak_count::__release_weak(v88);
  }
  uint64_t v89 = *((void *)this + 39);
  uint64_t v90 = *(void **)(v89 + 64);
  v90[1] = 0;
  uint64_t v91 = *((void *)this + 8);
  *uint64_t v90 = v91;
  uint64_t v92 = *(void **)(v89 + 160);
  uint64_t v93 = *((void *)this + 9);
  if (v93) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v93 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v94 = (std::__shared_weak_count *)v92[1];
  void *v92 = v91;
  v92[1] = v93;
  if (v94 && !atomic_fetch_add(&v94->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
    std::__shared_weak_count::__release_weak(v94);
  }
  uint64_t v95 = operator new(0x100uLL);
  uint64_t v96 = v95;
  v95[1] = 0;
  v95[2] = 0;
  *uint64_t v95 = &unk_1EF585458;
  unint64_t v97 = v95 + 3;
  uint64_t v98 = *((void *)this + 37);
  unint64_t v99 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v99)
  {
    atomic_fetch_add_explicit(&v99->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::PipelineSetup::PipelineSetup(v95 + 3, v98, (uint64_t)v99);
    if (!atomic_fetch_add(&v99->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v99->__on_zero_shared)(v99);
      std::__shared_weak_count::__release_weak(v99);
    }
  }
  else
  {
    ggl::PipelineSetup::PipelineSetup(v95 + 3, v98, 0);
  }
  v96[3] = &unk_1EF55D118;
  unint64_t v100 = (std::__shared_weak_count *)*((void *)this + 42);
  *((void *)this + 41) = v97;
  *((void *)this + 42) = v96;
  if (v100 && !atomic_fetch_add(&v100->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
    std::__shared_weak_count::__release_weak(v100);
  }
  uint64_t v101 = *((void *)this + 41);
  unint64_t v102 = *(void **)(v101 + 64);
  v102[1] = 0;
  uint64_t v103 = *((void *)this + 8);
  void *v102 = v103;
  unint64_t v104 = *(void **)(v101 + 160);
  uint64_t v105 = *((void *)this + 9);
  if (v105) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v105 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v106 = (std::__shared_weak_count *)v104[1];
  *unint64_t v104 = v103;
  v104[1] = v105;
  if (v106 && !atomic_fetch_add(&v106->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
    std::__shared_weak_count::__release_weak(v106);
  }
  uint64_t v107 = *(void *)(*(void *)(*((void *)this + 5) + 200) + 80);
  uint64_t v109 = *(void *)(v107 + 488);
  uint64_t v108 = *(std::__shared_weak_count **)(v107 + 496);
  uint64_t v163 = v109;
  v164 = v108;
  if (v108) {
    atomic_fetch_add_explicit(&v108->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)&v173[20] = 0uLL;
  *(void *)v174 = 0;
  v173[0] = 0;
  *(_OWORD *)&v173[4] = xmmword_1A28FC970;
  v174[8] = 15;
  unint64_t v110 = operator new(0x198uLL);
  v110[1] = 0;
  v110[2] = 0;
  *unint64_t v110 = &unk_1EF585570;
  *(_OWORD *)v160 = v177[0];
  *(_OWORD *)&v160[12] = *(_OWORD *)((char *)v177 + 12);
  *(_DWORD *)&v160[28] = 0;
  uint64_t v111 = ggl::FlyoverPostchain::TentBlurPipelineState::TentBlurPipelineState((uint64_t)(v110 + 3), &v163, (uint64_t)v173, v160);
  uint64_t v112 = (std::__shared_weak_count *)*((void *)this + 48);
  *((void *)this + 47) = v111;
  *((void *)this + 48) = v110;
  if (v112 && !atomic_fetch_add(&v112->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
    std::__shared_weak_count::__release_weak(v112);
  }
  uint64_t v113 = v164;
  if (v164 && !atomic_fetch_add(&v164->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
    std::__shared_weak_count::__release_weak(v113);
  }
  uint64_t v114 = *(void *)(*(void *)(*((void *)this + 5) + 200) + 80);
  uint64_t v116 = *(void *)(v114 + 488);
  uint64_t v115 = *(std::__shared_weak_count **)(v114 + 496);
  uint64_t v163 = v116;
  v164 = v115;
  if (v115) {
    atomic_fetch_add_explicit(&v115->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)&v173[28] = 0;
  *(void *)&v173[20] = 0;
  *(void *)v174 = 0;
  v173[0] = 0;
  *(_OWORD *)&v173[4] = xmmword_1A28FC970;
  v174[8] = 15;
  unint64_t v117 = operator new(0x198uLL);
  v117[1] = 0;
  v117[2] = 0;
  *unint64_t v117 = &unk_1EF585570;
  *(_OWORD *)v160 = v177[0];
  *(_OWORD *)&v160[12] = *(_OWORD *)((char *)v177 + 12);
  *(_DWORD *)&v160[28] = 0;
  uint64_t v118 = ggl::FlyoverPostchain::TentBlurPipelineState::TentBlurPipelineState((uint64_t)(v117 + 3), &v163, (uint64_t)v173, v160);
  unint64_t v119 = (std::__shared_weak_count *)*((void *)this + 50);
  *((void *)this + 49) = v118;
  *((void *)this + 50) = v117;
  if (v119 && !atomic_fetch_add(&v119->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
    std::__shared_weak_count::__release_weak(v119);
  }
  uint64_t v120 = v164;
  if (v164 && !atomic_fetch_add(&v164->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v120->__on_zero_shared)(v120);
    std::__shared_weak_count::__release_weak(v120);
  }
  uint64_t v121 = operator new(0x100uLL);
  uint64_t v122 = v121;
  v121[1] = 0;
  v121[2] = 0;
  *uint64_t v121 = &unk_1EF585538;
  uint64_t v123 = v121 + 3;
  uint64_t v124 = *((void *)this + 47);
  uint64_t v125 = (std::__shared_weak_count *)*((void *)this + 48);
  if (v125)
  {
    atomic_fetch_add_explicit(&v125->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::PipelineSetup::PipelineSetup(v121 + 3, v124, (uint64_t)v125);
    if (!atomic_fetch_add(&v125->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v125->__on_zero_shared)(v125);
      std::__shared_weak_count::__release_weak(v125);
    }
  }
  else
  {
    ggl::PipelineSetup::PipelineSetup(v121 + 3, v124, 0);
  }
  v122[3] = &unk_1EF55D1B8;
  uint64_t v126 = (std::__shared_weak_count *)*((void *)this + 52);
  *((void *)this + 51) = v123;
  *((void *)this + 52) = v122;
  if (v126 && !atomic_fetch_add(&v126->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v126->__on_zero_shared)(v126);
    std::__shared_weak_count::__release_weak(v126);
  }
  BOOL v127 = operator new(0x100uLL);
  unint64_t v128 = v127;
  v127[1] = 0;
  v127[2] = 0;
  *BOOL v127 = &unk_1EF585538;
  unint64_t v129 = v127 + 3;
  uint64_t v130 = *((void *)this + 49);
  unint64_t v131 = (std::__shared_weak_count *)*((void *)this + 50);
  if (v131)
  {
    atomic_fetch_add_explicit(&v131->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::PipelineSetup::PipelineSetup(v127 + 3, v130, (uint64_t)v131);
    if (!atomic_fetch_add(&v131->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v131->__on_zero_shared)(v131);
      std::__shared_weak_count::__release_weak(v131);
    }
  }
  else
  {
    ggl::PipelineSetup::PipelineSetup(v127 + 3, v130, 0);
  }
  v128[3] = &unk_1EF55D1B8;
  unint64_t v132 = (std::__shared_weak_count *)*((void *)this + 54);
  *((void *)this + 53) = v129;
  *((void *)this + 54) = v128;
  if (v132 && !atomic_fetch_add(&v132->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v132->__on_zero_shared)(v132);
    std::__shared_weak_count::__release_weak(v132);
  }
  uint64_t v133 = operator new(0xF0uLL);
  v133[1] = 0;
  v133[2] = 0;
  *uint64_t v133 = &unk_1EF583548;
  v133[5] = 0;
  v133[6] = 0;
  *((_DWORD *)v133 + 14) = 0;
  v133[3] = &unk_1EF55A890;
  v133[4] = 0;
  *(void *)((char *)v133 + 60) = 65537;
  *((_DWORD *)v133 + 17) = 0;
  v133[9] = 1;
  *((_WORD *)v133 + 40) = 0;
  *((unsigned char *)v133 + 82) = 3;
  *(void *)((char *)v133 + 91) = 0;
  *(void *)((char *)v133 + 83) = 0;
  *((unsigned char *)v133 + 99) = 0;
  *(void *)((char *)v133 + 156) = 0;
  *(void *)((char *)v133 + 148) = 0;
  *((_WORD *)v133 + 106) = 257;
  v133[27] = 0;
  v133[28] = 0;
  *((unsigned char *)v133 + 232) = 0;
  v134 = (std::__shared_weak_count *)*((void *)this + 34);
  *((void *)this + 33) = v133 + 3;
  *((void *)this + 34) = v133;
  if (v134 && !atomic_fetch_add(&v134->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v134->__on_zero_shared)(v134);
    std::__shared_weak_count::__release_weak(v134);
  }
  *(unsigned char *)(*((void *)this + 33) + 58) = 3;
  uint64_t v135 = operator new(0xA8uLL);
  v135[1] = 0;
  v135[2] = 0;
  void *v135 = &unk_1EF583078;
  size_t v136 = ggl::CommonMesh::Pos2UVMesh::Pos2UVMesh((ggl::CommonMesh::Pos2UVMesh *)(v135 + 3), "/Postchain/ScreenMesh");
  size_t v137 = (std::__shared_weak_count *)*((void *)this + 17);
  *((void *)this + 16) = v136;
  *((void *)this + 17) = v135;
  if (v137 && !atomic_fetch_add(&v137->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v137->__on_zero_shared)(v137);
    std::__shared_weak_count::__release_weak(v137);
  }
  uint64_t v138 = **(void **)(*(void *)v6 + 64);
  unint64_t v139 = 4 * *(void *)(v138 + 8);
  uint64_t v140 = *(void *)(v138 + 72);
  unint64_t v141 = *(void *)(v138 + 80) - v140;
  if (v139 != v141)
  {
    if (v139 <= v141)
    {
      if (v139 < v141) {
        *(void *)(v138 + 80) = v140 + v139;
      }
    }
    else
    {
      std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v138 + 72, v139 - v141);
    }
    uint64_t v142 = *(std::__shared_weak_count **)(v138 + 32);
    *(void *)(v138 + 24) = 0;
    *(void *)(v138 + 32) = 0;
    if (v142 && !atomic_fetch_add(&v142->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v142->__on_zero_shared)(v142);
      std::__shared_weak_count::__release_weak(v142);
    }
    *(void *)(v138 + 120) = 0;
    *(_DWORD *)(v138 + 112) = 0;
    uint64_t v143 = *(void *)(v138 + 80) - *(void *)(v138 + 72);
    *(void *)(v138 + 40) = 0;
    *(void *)(v138 + 48) = v143;
    *(void *)(v138 + 56) = 0;
    *(void *)(v138 + 64) = v143;
    uint64_t v138 = **(void **)(*(void *)v6 + 64);
    unint64_t v139 = 4 * *(void *)(v138 + 8);
  }
  memset(v173, 0, 24);
  *(void *)&long long v144 = 0;
  *((void *)&v144 + 1) = v138;
  uint64_t v145 = *(void *)(v138 + 72);
  *(_OWORD *)v173 = v144;
  *(void *)&v173[24] = v139;
  *(void *)&v174[4] = v145;
  *(_WORD *)&v173[32] = 1;
  *(void *)uint64_t v145 = 0;
  *(void *)(v145 + 8) = 0;
  __asm { FMOV            V1.4S, #1.0 }
  *(_OWORD *)(v145 + 16) = xmmword_1A28FD280;
  *(_OWORD *)(v145 + 32) = _Q1;
  *(_OWORD *)(v145 + 48) = xmmword_1A28FD290;
  size_t v151 = (std::__shared_weak_count *)operator new(0xF8uLL);
  v151->__shared_owners_ = 0;
  v151->__shared_weak_owners_ = 0;
  v151->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583D28;
  uint64_t v152 = ggl::BufferData::BufferData((uint64_t)&v151[1], 2, 1, 0, 6, 6);
  LODWORD(v151[10].__vftable) = 0;
  v151[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55B630;
  v151[1].__shared_owners_ = 2;
  v151[9].__shared_owners_ = (uint64_t)&unk_1EF55B650;
  v151[9].__shared_weak_owners_ = (uint64_t)"index data";
  uint64_t v163 = v152;
  v164 = v151;
  *(_OWORD *)v160 = 0uLL;
  *(void *)&long long v153 = 0;
  *((void *)&v153 + 1) = v152;
  uint64_t v154 = v151[4].__vftable;
  *(_OWORD *)v160 = v153;
  *(_OWORD *)&v160[16] = xmmword_1A28FCD20;
  v162 = v154;
  __int16 v161 = 1;
  v154->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))0x200010000;
  LODWORD(v154->~__shared_weak_count_0) = 196610;
  uint64_t v155 = *(void *)v6;
  atomic_fetch_add_explicit(&v151->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v151->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v156 = *(std::__shared_weak_count **)(v155 + 104);
  *(void *)(v155 + 96) = v152;
  *(void *)(v155 + 104) = v151;
  if (v156 && !atomic_fetch_add(&v156->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v156->__on_zero_shared)(v156);
    std::__shared_weak_count::__release_weak(v156);
  }
  if (!atomic_fetch_add(&v151->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v151->__on_zero_shared)(v151);
    std::__shared_weak_count::__release_weak(v151);
  }
  operator new();
}

void sub_1A2363604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a35);
  uint64_t v38 = v35[56];
  v35[56] = 0;
  if (v38) {
    (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
  }
  uint64_t v39 = v35[55];
  v35[55] = 0;
  if (v39) {
    (*(void (**)(uint64_t))(*(void *)v39 + 8))(v39);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v35 + 53));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v35 + 51));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v35 + 49));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v35 + 47));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v35 + 45));
  uint64_t v40 = v35[44];
  v35[44] = 0;
  if (v40) {
    (*(void (**)(uint64_t))(*(void *)v40 + 8))(v40);
  }
  uint64_t v41 = v35[43];
  v35[43] = 0;
  if (v41) {
    (*(void (**)(uint64_t))(*(void *)v41 + 8))(v41);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v35 + 41));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v35 + 39));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v35 + 37));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v35 + 35));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a18);
  uint64_t v42 = v35[32];
  v35[32] = 0;
  if (v42) {
    (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a11);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a12);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a13);
  uint64_t v43 = v35[25];
  v35[25] = 0;
  if (v43) {
    (*(void (**)(uint64_t))(*(void *)v43 + 8))(v43);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v35 + 23));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v35 + 21));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v35 + 19));
  uint64_t v44 = v35[18];
  v35[18] = 0;
  if (v44) {
    (*(void (**)(uint64_t))(*(void *)v44 + 8))(v44);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v36);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a14);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a15);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a16);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a17);
  *uint64_t v35 = &unk_1EF530C60;
  uint64_t v45 = (void *)v35[1];
  if (!v45) {
    _Unwind_Resume(a1);
  }
  v35[2] = v45;
  operator delete(v45);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverPostchain::TentBlurPipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::TentBlurPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585538;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::TentBlurPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585538;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverPostchain::TentBlurPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::TentBlurPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585570;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::TentBlurPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585570;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverPostchain::BGBlurPipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::BGBlurPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585458;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::BGBlurPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585458;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverPostchain::FGBlurPipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::FGBlurPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5854C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::FGBlurPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5854C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverPostchain::BGBlurPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::BGBlurPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585490;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::BGBlurPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585490;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverPostchain::FGBlurPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::FGBlurPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585500;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::FGBlurPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585500;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverPostchain::DownsampleCoCPipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::DownsampleCoCPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585688;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::DownsampleCoCPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585688;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverPostchain::DownsampleCoCPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::DownsampleCoCPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5856C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::DownsampleCoCPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5856C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverPostchain::DepthSplitPipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::DepthSplitPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585618;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::DepthSplitPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585618;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverPostchain::DepthSplitPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::DepthSplitPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585650;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::DepthSplitPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585650;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverPostchain::CompositePipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::CompositePipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5855A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::CompositePipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5855A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverPostchain::CompositePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::CompositePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5855E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverPostchain::CompositePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5855E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A2364318(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2364394(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2364884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2364A20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(a11);

  _Unwind_Resume(a1);
}

void sub_1A2364B04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2364B78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2364D2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL31GEOGetVectorKitVKMapSnapshotLogv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.VectorKit", "VKMapSnapshot");
  uint64_t v1 = (void *)GEOGetVectorKitVKMapSnapshotLog(void)::log;
  GEOGetVectorKitVKMapSnapshotLog(void)::log = (uint64_t)v0;
}

void sub_1A236500C(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::function<void ()(void)>::~function((uint64_t *)va);

  _Unwind_Resume(a1);
}

void geo::_retain_ptr<VKMapSnapshotCreator * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559958;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKMapSnapshotCreator * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559958;

  return a1;
}

void sub_1A236578C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::function<void ()(void)>::~function(va);

  _Unwind_Resume(a1);
}

void sub_1A23661F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

uint64_t gdc::Context::get<md::SceneContext>(void *a1)
{
  int8x8_t v1 = (int8x8_t)a1[1];
  if (!*(void *)&v1) {
    return 0;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0x99BED48DEFBBD82BLL;
    if (*(void *)&v1 <= 0x99BED48DEFBBD82BLL) {
      unint64_t v3 = 0x99BED48DEFBBD82BLL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0x99BED48DEFBBD82BLL;
  }
  __int16 v4 = *(void **)(*a1 + 8 * v3);
  if (!v4) {
    return 0;
  }
  __int16 v5 = (void *)*v4;
  if (!v5) {
    return 0;
  }
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x99BED48DEFBBD82BLL)
      {
        if (v5[2] == 0x99BED48DEFBBD82BLL) {
          goto LABEL_22;
        }
      }
      else if ((v8 & v6) != v3)
      {
        return 0;
      }
      __int16 v5 = (void *)*v5;
      if (!v5) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x99BED48DEFBBD82BLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      return 0;
    }
LABEL_11:
    __int16 v5 = (void *)*v5;
    if (!v5) {
      return 0;
    }
  }
  if (v5[2] != 0x99BED48DEFBBD82BLL) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v9 = v5[5];
  if (*(void *)(v9 + 8) == 0x99BED48DEFBBD82BLL) {
    return *(void *)(v9 + 32);
  }
  return 0;
}

void sub_1A23666A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236690C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2366B60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2366C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2366C74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2366D00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2366D74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2366DDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2367228(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236744C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2367A2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2368044(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A23688D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, char a11)
{
  _Unwind_Resume(a1);
}

void sub_1A2368BE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2368EC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2369228(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23692D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2369550(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23697D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2369A00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VKMapSnapshotCreator;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A236A600(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location, id a20,char a21,uint64_t a22,void *__p,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  if (__p) {
    operator delete(__p);
  }
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

id GEOGetVectorKitVKMapSnapshotLog(void)
{
  if (GEOGetVectorKitVKMapSnapshotLog(void)::onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKMapSnapshotLog(void)::onceToken, &__block_literal_global_22154);
  }
  os_log_t v0 = (void *)GEOGetVectorKitVKMapSnapshotLog(void)::log;
  return v0;
}

uint64_t md::LogicManager::logic<md::StyleLogic>(int8x8_t *a1)
{
  int8x8_t v1 = a1[2];
  if (!*(void *)&v1) {
    return 0;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x2FED70A4459DFCA1;
    if (*(void *)&v1 <= 0x2FED70A4459DFCA1uLL) {
      uint64_t v3 = 0x2FED70A4459DFCA1uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x2FED70A4459DFCA1;
  }
  __int16 v4 = *(void **)(*(void *)&a1[1] + 8 * v3);
  if (!v4) {
    return 0;
  }
  __int16 v5 = (void *)*v4;
  if (!v5) {
    return 0;
  }
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x2FED70A4459DFCA1)
      {
        if (v5[2] == 0x2FED70A4459DFCA1) {
          return v5[5];
        }
      }
      else if ((v8 & v6) != v3)
      {
        return 0;
      }
      __int16 v5 = (void *)*v5;
      if (!v5) {
        return 0;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x2FED70A4459DFCA1) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      return 0;
    }
LABEL_11:
    __int16 v5 = (void *)*v5;
    if (!v5) {
      return 0;
    }
  }
  if (v5[2] != 0x2FED70A4459DFCA1) {
    goto LABEL_11;
  }
  return v5[5];
}

void sub_1A236A978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A236AB18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A236ACB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A236AE74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void geo::_retain_ptr<NSMutableSet<objc_object  {objcproto29VKARWalkingFeatureSetObserver}*> * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5594D8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<NSMutableSet<objc_object  {objcproto29VKARWalkingFeatureSetObserver}*> * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5594D8;

  return a1;
}

void sub_1A236B0D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236B20C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236B2E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  std::mutex::unlock(v10);

  _Unwind_Resume(a1);
}

void sub_1A236B368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  std::mutex::unlock(v10);

  _Unwind_Resume(a1);
}

void sub_1A236B50C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A236B5A8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A236B6B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236B780(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236B9BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236BB6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236BD44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236BE74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236BF7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236C58C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236C724(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236C8D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236CA40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236CBDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236CD44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236CE34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236CEFC(_Unwind_Exception *a1)
{
  __int16 v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A236CFF0(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void sub_1A236D2A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A236D53C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236D728(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236D994(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void geo::_retain_ptr<VKARWalkingFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5597D8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKARWalkingFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5597D8;

  return a1;
}

void sub_1A236DC50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236DD44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A236DE80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::LabelMarker::isLabelHitAtScreenPoint(md::LabelMarker *this, const CGPoint *a2, uint64_t a3)
{
  md::LabelMarker::acquireDisplayLock((md::LabelMarker *)&v11, (uint64_t)this);
  if (!v11)
  {
    uint64_t v8 = 0;
    if (!v14) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  double v6 = *(float *)(v11 + 480);
  float v7 = a2->x * v6;
  *(float *)&double v6 = *(float *)(v11 + 1508) - a2->y * v6;
  *(float *)uint64_t v15 = v7;
  v15[1] = LODWORD(v6);
  uint64_t v8 = (*(uint64_t (**)(void, md::LabelMarker *, _DWORD *, uint64_t))(**(void **)(v11 + 240) + 224))(*(void *)(v11 + 240), this, v15, a3);
  if (v14) {
LABEL_3:
  }
    std::recursive_mutex::unlock(v13);
LABEL_4:
  uint64_t v9 = v12;
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  return v8;
}

void sub_1A236E010(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::pair<std::shared_ptr<md::LabelManager>,std::unique_lock<std::recursive_mutex>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

void md::LabelMarker::acquireDisplayLock(md::LabelMarker *this, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 240);
  if (v3 && (__int16 v5 = std::__shared_weak_count::lock(v3)) != 0)
  {
    double v6 = v5;
    uint64_t v7 = *(void *)(a2 + 232);
    if (v7)
    {
      uint64_t v8 = v7 + 24;
      std::recursive_mutex::lock((std::recursive_mutex *)(v7 + 24));
      char v9 = 1;
    }
    else
    {
      uint64_t v8 = 0;
      char v9 = 0;
    }
    *(void *)this = v7;
    *((void *)this + 1) = v6;
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    *((void *)this + 2) = v8;
    *((unsigned char *)this + 24) = v9;
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  else
  {
    *(void *)this = 0;
    *((void *)this + 1) = 0;
    *((void *)this + 2) = 0;
    *((unsigned char *)this + 24) = 0;
  }
}

void sub_1A236E11C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t md::LabelMarker::isVisible(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isSelected(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isSelectable(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::routeInfo(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isRouteEta(md::LabelMarker *this)
{
  return 0;
}

void sub_1A236E510(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1A236E808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A236EAF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *md::RenderItemPool::construct(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v9 = *(_OWORD *)(a2 + 8);
  long long v10 = *(_OWORD *)(a2 + 24);
  long long v14 = *(_OWORD *)(a2 + 88);
  long long v15 = *(_OWORD *)(a2 + 104);
  long long v13 = *(_OWORD *)(a2 + 72);
  long long v11 = *(_OWORD *)(a2 + 40);
  long long v12 = *(_OWORD *)(a2 + 56);
  __int16 v5 = *(void **)(a1 + 8);
  uint64_t v6 = v5[1];
  if (v6 == *(void *)(a1 + 16))
  {
    __int16 v5 = (void *)*v5;
    if (!v5)
    {
      __int16 v5 = malloc_type_malloc(120 * v6 + 16, 0xB644C221uLL);
      *__int16 v5 = 0;
      v5[1] = 0;
      **(void **)(a1 + 8) = v5;
    }
    *(void *)(a1 + 8) = v5;
    uint64_t v6 = v5[1];
  }
  uint64_t v7 = &v5[15 * v6];
  v5[1] = v6 + 1;
  v7[2] = &off_1EF55A458;
  *(_OWORD *)(v7 + 9) = v12;
  *(_OWORD *)(v7 + 7) = v11;
  *(_OWORD *)(v7 + 5) = v10;
  *(_OWORD *)(v7 + 3) = v9;
  *(_OWORD *)(v7 + 15) = v15;
  *(_OWORD *)(v7 + 13) = v14;
  *(_OWORD *)(v7 + 11) = v13;
  v7[10] = a3;
  return v7 + 2;
}

uint64_t *md::RenderItemPool::reset(uint64_t *this)
{
  int8x8_t v1 = this;
  uint8x8_t v2 = (void *)*this;
  if (*this)
  {
    do
    {
      if (v2[1])
      {
        unint64_t v4 = 0;
        __int16 v5 = v2 + 2;
        this = v2 + 2;
        uint64_t v6 = v2 + 2;
        do
        {
          uint64_t v7 = (void (**)(uint64_t *))*v6;
          v6 += 15;
          (*v7)(this);
          ++v4;
          v5 += 15;
          this = v6;
        }
        while (v4 < v2[1]);
      }
      v2[1] = 0;
      uint8x8_t v2 = (void *)*v2;
    }
    while (v2);
    uint64_t v3 = *v1;
  }
  else
  {
    uint64_t v3 = 0;
  }
  v1[1] = v3;
  return this;
}

uint64_t altitude::TrafficCacheNode::getCacheKeyForKey@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a2;
  *(_OWORD *)(a3 + 16) = v4;
  *(_DWORD *)(a3 + 32) = *(_DWORD *)(a2 + 32);
  uint64_t result = altitude::GeoResourceManager::getTileIdWithDataForTileId(*(void *)(*(void *)(a1 + 160) + 32), (long long *)(a3 + 16), 12);
  *(void *)(a3 + 16) = result;
  *(void *)(a3 + 24) = v6;
  *(_DWORD *)a3 = 12;
  return result;
}

void altitude::TrafficCacheNode::fetchData(uint64_t a1@<X1>, void *a2@<X8>)
{
  long long v4 = *(void **)a1;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (((*(uint64_t (**)(void *))(*v4 + 40))(v4) & 1) == 0)
  {
    *a2 = 0;
    a2[1] = 0;
    if (!v3) {
      return;
    }
    goto LABEL_9;
  }
  uint64_t v5 = v4[36];
  *a2 = v4[35];
  a2[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  if (v3)
  {
LABEL_9:
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

BOOL altitude::TrafficCacheNode::hasValidKey(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_DWORD *)(a3 + 32) >= *(_DWORD *)(a1 + 168);
}

uint64_t altitude::GenericCacheNode<altitude::StampedTileKey,altitude::TrafficDynamicData>::clear(uint64_t a1)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 136));
  if (*(void *)(a1 + 120))
  {
    uint8x8_t v2 = *(void **)(a1 + 112);
    if (v2)
    {
      do
      {
        uint64_t v7 = (void *)*v2;
        uint64_t v8 = (std::__shared_weak_count *)v2[8];
        if (v8) {
          std::__shared_weak_count::__release_weak(v8);
        }
        operator delete(v2);
        uint8x8_t v2 = v7;
      }
      while (v7);
    }
    *(void *)(a1 + 112) = 0;
    uint64_t v3 = *(void *)(a1 + 104);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*(void *)(a1 + 96) + 8 * i) = 0;
    }
    *(void *)(a1 + 120) = 0;
  }
  uint64_t v5 = *(pthread_mutex_t **)(a1 + 136);
  return pthread_mutex_unlock(v5);
}

BOOL altitude::TrafficCacheNode::hasDataAvailable(uint64_t a1, uint64_t a2)
{
  return altitude::GeoResourceManager::getTileIdWithDataForTileId(*(void *)(*(void *)(a1 + 160) + 32), (long long *)(a2 + 16), 12) != 0;
}

void altitude::GenericCacheNode<altitude::StampedTileKey,altitude::TrafficDynamicData>::requestCached(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1) & 1) == 0)
  {
    *a5 = 0;
    a5[1] = 0;
    a5[3] = 0;
    a5[4] = 0;
    a5[2] = (uint64_t)off_1EF5677B0;
    return;
  }
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 144))(__p, a1, a2);
  long long v10 = *(_OWORD *)(a2 + 16);
  v61[0] = *(_OWORD *)a2;
  v61[1] = v10;
  int v11 = *(_DWORD *)(a2 + 32);
  long long v63 = *(_OWORD *)__p;
  long long v64 = v59;
  int v62 = v11;
  int v65 = v60;
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 136));
  int8x8_t v12 = *(int8x8_t *)(a1 + 104);
  if (!*(void *)&v12) {
    goto LABEL_41;
  }
  unint64_t v13 = ((unint64_t)v64 << 58) | ((unint64_t)(DWORD1(v64) & 0x1FFFFFFF) << 29) | DWORD2(v64) & 0x1FFFFFFF;
  uint8x8_t v14 = (uint8x8_t)vcnt_s8(v12);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.u32[0] > 1uLL)
  {
    unint64_t v15 = ((unint64_t)v64 << 58) | ((unint64_t)(DWORD1(v64) & 0x1FFFFFFF) << 29) | DWORD2(v64) & 0x1FFFFFFF;
    if (v13 >= *(void *)&v12) {
      unint64_t v15 = v13 % *(void *)&v12;
    }
  }
  else
  {
    unint64_t v15 = v13 & (*(void *)&v12 - 1);
  }
  uint64_t v16 = *(std::__shared_weak_count ***)(*(void *)(a1 + 96) + 8 * v15);
  if (!v16) {
    goto LABEL_41;
  }
  uint64_t v17 = *v16;
  if (!*v16)
  {
LABEL_42:
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 136));
    goto LABEL_43;
  }
  if (v14.u32[0] < 2uLL)
  {
    uint64_t v18 = *(void *)&v12 - 1;
    while (1)
    {
      uint64_t shared_owners = v17->__shared_owners_;
      if (shared_owners == v13)
      {
        if (LODWORD(v17[1].__shared_owners_) == v64
          && *(uint64_t *)((char *)&v17[1].__shared_owners_ + 4) == *(void *)((char *)&v64 + 4)
          && HIDWORD(v64) == HIDWORD(v17[1].__shared_weak_owners_)
          && LODWORD(v17->__shared_weak_owners_) == v63
          && *(uint64_t *)((char *)&v17->__shared_weak_owners_ + 4) == *(void *)((char *)&v63 + 4))
        {
          goto LABEL_31;
        }
      }
      else if ((shared_owners & v18) != v15)
      {
        goto LABEL_41;
      }
      uint64_t v17 = (std::__shared_weak_count *)v17->__vftable;
      if (!v17) {
        goto LABEL_42;
      }
    }
  }
  while (1)
  {
    unint64_t v19 = v17->__shared_owners_;
    if (v19 == v13) {
      break;
    }
    if (v19 >= *(void *)&v12) {
      v19 %= *(void *)&v12;
    }
    if (v19 != v15) {
      goto LABEL_41;
    }
LABEL_13:
    uint64_t v17 = (std::__shared_weak_count *)v17->__vftable;
    if (!v17) {
      goto LABEL_42;
    }
  }
  if (LODWORD(v17[1].__shared_owners_) != v64
    || *(uint64_t *)((char *)&v17[1].__shared_owners_ + 4) != *(void *)((char *)&v64 + 4)
    || HIDWORD(v64) != HIDWORD(v17[1].__shared_weak_owners_)
    || LODWORD(v17->__shared_weak_owners_) != v63
    || *(uint64_t *)((char *)&v17->__shared_weak_owners_ + 4) != *(void *)((char *)&v63 + 4))
  {
    goto LABEL_13;
  }
LABEL_31:
  if (((*(uint64_t (**)(uint64_t, long long *, uint64_t *))(*(void *)a1 + 128))(a1, &v63, &v17->__shared_weak_owners_) & 1) == 0)
  {
    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)__p, (void *)(a1 + 96), v17);
    uint64_t v23 = __p[0];
    if (__p[0])
    {
      if ((_BYTE)v59)
      {
        uint64_t v24 = (std::__shared_weak_count *)*((void *)__p[0] + 8);
        if (v24) {
          std::__shared_weak_count::__release_weak(v24);
        }
      }
      operator delete(v23);
    }
    goto LABEL_41;
  }
  shared_weak_owners = (std::__shared_weak_count *)v17[2].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
LABEL_41:
    uint64_t v17 = 0;
    goto LABEL_42;
  }
  uint64_t v22 = v17[2].__shared_owners_;
  atomic_fetch_add_explicit(&shared_weak_owners->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  uint64_t v17 = std::__shared_weak_count::lock(shared_weak_owners);
  std::__shared_weak_count::__release_weak(shared_weak_owners);
  if (!v17) {
    goto LABEL_42;
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 136));
  if (v22)
  {
    __p[1] = 0;
    *(void *)&long long v59 = 0;
    __p[0] = off_1EF5677B0;
    *a5 = v22;
    a5[1] = (uint64_t)v17;
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    a5[3] = 0;
    a5[4] = 0;
    a5[2] = (uint64_t)off_1EF5677B0;
    goto LABEL_92;
  }
LABEL_43:
  (*(void (**)(void (***__return_ptr)(karo::AsyncRequestManager::RequestHandle *__hidden), uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 80))(&v55, a1, v61, a3, a4, 300, 1, 0);
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v55) == 4)
  {
    uint64_t v52 = 0;
    float v53 = 0;
    uint64_t v54 = 0;
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, _OWORD *, void **))(*(void *)a1 + 136))(&v50, a1, &v56, v61, &v52);
    pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 136));
    uint64_t v25 = std::__hash_table<std::__hash_value_type<altitude::StampedTileKey,std::weak_ptr<altitude::TrafficDynamicData>>,std::__unordered_map_hasher<altitude::StampedTileKey,std::__hash_value_type<altitude::StampedTileKey,std::weak_ptr<altitude::TrafficDynamicData>>,std::hash<altitude::StampedTileKey>,std::equal_to<altitude::StampedTileKey>,true>,std::__unordered_map_equal<altitude::StampedTileKey,std::__hash_value_type<altitude::StampedTileKey,std::weak_ptr<altitude::TrafficDynamicData>>,std::equal_to<altitude::StampedTileKey>,std::hash<altitude::StampedTileKey>,true>,std::allocator<std::__hash_value_type<altitude::StampedTileKey,std::weak_ptr<altitude::TrafficDynamicData>>>>::__emplace_unique_key_args<altitude::StampedTileKey,std::piecewise_construct_t const&,std::tuple<altitude::StampedTileKey const&>,std::tuple<>>((float *)(a1 + 96), (int *)&v63, (uint64_t)&v63);
    uint64_t v27 = v50;
    uint64_t v26 = v51;
    if (v51) {
      atomic_fetch_add_explicit(&v51->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v28 = (std::__shared_weak_count *)v25[8];
    v25[7] = v27;
    v25[8] = v26;
    if (v28) {
      std::__shared_weak_count::__release_weak(v28);
    }
    uint64_t v29 = (int *)v52;
    if (v52 != v53)
    {
      do
      {
        unint64_t v30 = std::__hash_table<std::__hash_value_type<altitude::StampedTileKey,std::weak_ptr<altitude::TrafficDynamicData>>,std::__unordered_map_hasher<altitude::StampedTileKey,std::__hash_value_type<altitude::StampedTileKey,std::weak_ptr<altitude::TrafficDynamicData>>,std::hash<altitude::StampedTileKey>,std::equal_to<altitude::StampedTileKey>,true>,std::__unordered_map_equal<altitude::StampedTileKey,std::__hash_value_type<altitude::StampedTileKey,std::weak_ptr<altitude::TrafficDynamicData>>,std::equal_to<altitude::StampedTileKey>,std::hash<altitude::StampedTileKey>,true>,std::allocator<std::__hash_value_type<altitude::StampedTileKey,std::weak_ptr<altitude::TrafficDynamicData>>>>::__emplace_unique_key_args<altitude::StampedTileKey,std::piecewise_construct_t const&,std::tuple<altitude::StampedTileKey const&>,std::tuple<>>((float *)(a1 + 96), v29, (uint64_t)v29);
        uint64_t v32 = v50;
        uint64_t v31 = v51;
        if (v51) {
          atomic_fetch_add_explicit(&v51->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v33 = (std::__shared_weak_count *)v30[8];
        v30[7] = v32;
        v30[8] = v31;
        if (v33) {
          std::__shared_weak_count::__release_weak(v33);
        }
        v29 += 9;
      }
      while (v29 != v53);
    }
    unsigned int v36 = *(_DWORD *)(a1 + 144) + 1;
    *(_DWORD *)(a1 + 144) = v36;
    if (v36 > 0x14)
    {
      *(_DWORD *)(a1 + 144) = 0;
      for (uint64_t i = *(void **)(a1 + 112); i; uint64_t i = (void *)*i)
      {
        while (1)
        {
          uint64_t v38 = (std::__shared_weak_count *)i[8];
          if (!v38) {
            goto LABEL_71;
          }
          uint64_t v39 = std::__shared_weak_count::lock(v38);
          if (!v39) {
            goto LABEL_71;
          }
          uint64_t v40 = v39;
          uint64_t v41 = i[7];
          if (atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            break;
          }
          ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
          std::__shared_weak_count::__release_weak(v40);
          if (v41) {
            goto LABEL_68;
          }
LABEL_71:
          uint64_t v42 = (void *)*i;
          std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)__p, (void *)(a1 + 96), i);
          uint64_t v43 = __p[0];
          if (__p[0])
          {
            if ((_BYTE)v59)
            {
              uint64_t v44 = (std::__shared_weak_count *)*((void *)__p[0] + 8);
              if (v44) {
                std::__shared_weak_count::__release_weak(v44);
              }
            }
            operator delete(v43);
          }
          uint64_t i = v42;
          if (!v42) {
            goto LABEL_75;
          }
        }
        if (!v41) {
          goto LABEL_71;
        }
LABEL_68:
        ;
      }
    }
LABEL_75:
    uint64_t v45 = v51;
    *a5 = v50;
    a5[1] = (uint64_t)v45;
    if (v45) {
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v46 = v56;
    uint64_t v47 = v57;
    a5[2] = (uint64_t)off_1EF5677B0;
    a5[3] = v46;
    a5[4] = (uint64_t)v47;
    if (v47)
    {
      atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v46 = a5[3];
    }
    if (v46) {
      atomic_fetch_add((atomic_uint *volatile)(v46 + 128), 1u);
    }
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 136));
    uint64_t v48 = v51;
    if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
    if (v52)
    {
      float v53 = v52;
      operator delete(v52);
    }
  }
  else
  {
    *a5 = 0;
    a5[1] = 0;
    uint64_t v34 = v56;
    uint64_t v35 = v57;
    a5[2] = (uint64_t)off_1EF5677B0;
    a5[3] = v34;
    a5[4] = (uint64_t)v35;
    if (v35)
    {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v34 = a5[3];
    }
    if (v34) {
      atomic_fetch_add((atomic_uint *volatile)(v34 + 128), 1u);
    }
  }
  float v55 = off_1EF5677B0;
  if (v56) {
    atomic_fetch_add((atomic_uint *volatile)(v56 + 128), 0xFFFFFFFF);
  }
  unint64_t v49 = v57;
  if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
    std::__shared_weak_count::__release_weak(v49);
  }
  if (v17)
  {
LABEL_92:
    if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

void *std::__hash_table<std::__hash_value_type<altitude::StampedTileKey,std::weak_ptr<altitude::TrafficDynamicData>>,std::__unordered_map_hasher<altitude::StampedTileKey,std::__hash_value_type<altitude::StampedTileKey,std::weak_ptr<altitude::TrafficDynamicData>>,std::hash<altitude::StampedTileKey>,std::equal_to<altitude::StampedTileKey>,true>,std::__unordered_map_equal<altitude::StampedTileKey,std::__hash_value_type<altitude::StampedTileKey,std::weak_ptr<altitude::TrafficDynamicData>>,std::equal_to<altitude::StampedTileKey>,std::hash<altitude::StampedTileKey>,true>,std::allocator<std::__hash_value_type<altitude::StampedTileKey,std::weak_ptr<altitude::TrafficDynamicData>>>>::__emplace_unique_key_args<altitude::StampedTileKey,std::piecewise_construct_t const&,std::tuple<altitude::StampedTileKey const&>,std::tuple<>>(float *a1, int *a2, uint64_t a3)
{
  uint64_t v6 = a2[4];
  unsigned int v7 = a2[5];
  int v8 = a2[6];
  unint64_t v9 = (v6 << 58) | ((unint64_t)(v7 & 0x1FFFFFFF) << 29) | v8 & 0x1FFFFFFF;
  unint64_t v10 = *((void *)a1 + 1);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = (v6 << 58) | ((unint64_t)(v7 & 0x1FFFFFFF) << 29) | v8 & 0x1FFFFFFF;
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
    }
    else
    {
      unint64_t v3 = v9 & (v10 - 1);
    }
    int8x8_t v12 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      unint64_t v13 = *v12;
      if (*v12)
      {
        int v14 = a2[7];
        int v15 = *a2;
        int v16 = a2[1];
        int v17 = a2[2];
        if (v11.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v19 = v13[1];
            if (v19 == v9)
            {
              if (v13[4] == __PAIR64__(v7, v6)
                && *((_DWORD *)v13 + 10) == v8
                && v14 == *((_DWORD *)v13 + 11)
                && *((_DWORD *)v13 + 4) == v15
                && *((_DWORD *)v13 + 5) == v16
                && *((_DWORD *)v13 + 6) == v17)
              {
                return v13;
              }
            }
            else if ((v19 & (v10 - 1)) != v3)
            {
              goto LABEL_33;
            }
            unint64_t v13 = (void *)*v13;
            if (!v13) {
              goto LABEL_33;
            }
          }
        }
        do
        {
          unint64_t v18 = v13[1];
          if (v18 == v9)
          {
            if (v13[4] == __PAIR64__(v7, v6)
              && *((_DWORD *)v13 + 10) == v8
              && v14 == *((_DWORD *)v13 + 11)
              && *((_DWORD *)v13 + 4) == v15
              && *((_DWORD *)v13 + 5) == v16
              && *((_DWORD *)v13 + 6) == v17)
            {
              return v13;
            }
          }
          else
          {
            if (v18 >= v10) {
              v18 %= v10;
            }
            if (v18 != v3) {
              break;
            }
          }
          unint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_33:
  unint64_t v13 = operator new(0x48uLL);
  *unint64_t v13 = 0;
  v13[1] = v9;
  long long v20 = *(_OWORD *)(a3 + 16);
  *((_OWORD *)v13 + 1) = *(_OWORD *)a3;
  *((_OWORD *)v13 + 2) = v20;
  *((_DWORD *)v13 + 12) = *(_DWORD *)(a3 + 32);
  v13[7] = 0;
  v13[8] = 0;
  float v21 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v22 = a1[8];
  if (!v10 || (float)(v22 * (float)v10) < v21)
  {
    BOOL v23 = 1;
    if (v10 >= 3) {
      BOOL v23 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v10);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v10 = *((void *)a1 + 1);
    }
    if (prime <= v10)
    {
      if (prime >= v10) {
        goto LABEL_70;
      }
      unint64_t v38 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v10 < 3 || (uint8x8_t v39 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v39.i16[0] = vaddlv_u8(v39), v39.u32[0] > 1uLL))
      {
        unint64_t v38 = std::__next_prime(v38);
      }
      else
      {
        uint64_t v40 = 1 << -(char)__clz(v38 - 1);
        if (v38 >= 2) {
          unint64_t v38 = v40;
        }
      }
      if (prime <= v38) {
        size_t prime = v38;
      }
      if (prime >= v10)
      {
        unint64_t v10 = *((void *)a1 + 1);
LABEL_70:
        if ((v10 & (v10 - 1)) != 0)
        {
          if (v9 >= v10) {
            unint64_t v3 = v9 % v10;
          }
          else {
            unint64_t v3 = v9;
          }
        }
        else
        {
          unint64_t v3 = (v10 - 1) & v9;
        }
        goto LABEL_83;
      }
      if (!prime)
      {
        uint64_t v48 = *(void **)a1;
        *(void *)a1 = 0;
        if (v48) {
          operator delete(v48);
        }
        unint64_t v10 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_70;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v27 = operator new(8 * prime);
    unint64_t v28 = *(void **)a1;
    *(void *)a1 = v27;
    if (v28) {
      operator delete(v28);
    }
    uint64_t v29 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v29++) = 0;
    while (prime != v29);
    uint64_t v31 = (uint64_t *)(a1 + 4);
    unint64_t v30 = (void *)*((void *)a1 + 2);
    if (!v30)
    {
LABEL_69:
      unint64_t v10 = prime;
      goto LABEL_70;
    }
    size_t v32 = v30[1];
    size_t v33 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v34 = v32 & v33;
      *(void *)(*(void *)a1 + 8 * v34) = v31;
      for (uint64_t i = (void *)*v30; *v30; uint64_t i = (void *)*v30)
      {
        size_t v36 = i[1] & v33;
        if (v36 == v34)
        {
          unint64_t v30 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v36))
        {
          void *v30 = *i;
          uint64_t v37 = 8 * v36;
          void *i = **(void **)(*(void *)a1 + v37);
          **(void **)(*(void *)a1 + v37) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v36) = v30;
          unint64_t v30 = i;
          size_t v34 = v36;
        }
      }
      goto LABEL_69;
    }
    if (v32 >= prime) {
      v32 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v32) = v31;
    uint64_t v41 = (void *)*v30;
    if (!*v30) {
      goto LABEL_69;
    }
    while (1)
    {
      size_t v43 = v41[1];
      if (v43 >= prime) {
        v43 %= prime;
      }
      if (v43 != v32)
      {
        if (!*(void *)(*(void *)a1 + 8 * v43))
        {
          *(void *)(*(void *)a1 + 8 * v43) = v30;
          goto LABEL_74;
        }
        void *v30 = *v41;
        uint64_t v42 = 8 * v43;
        void *v41 = **(void **)(*(void *)a1 + v42);
        **(void **)(*(void *)a1 + v42) = v41;
        uint64_t v41 = v30;
      }
      size_t v43 = v32;
LABEL_74:
      unint64_t v30 = v41;
      uint64_t v41 = (void *)*v41;
      size_t v32 = v43;
      if (!v41) {
        goto LABEL_69;
      }
    }
  }
LABEL_83:
  uint64_t v44 = *(void **)a1;
  uint64_t v45 = *(void **)(*(void *)a1 + 8 * v3);
  if (v45)
  {
    *unint64_t v13 = *v45;
LABEL_91:
    void *v45 = v13;
    goto LABEL_92;
  }
  *unint64_t v13 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v13;
  v44[v3] = a1 + 4;
  if (*v13)
  {
    unint64_t v46 = *(void *)(*v13 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v46 >= v10) {
        v46 %= v10;
      }
    }
    else
    {
      v46 &= v10 - 1;
    }
    uint64_t v45 = (void *)(*(void *)a1 + 8 * v46);
    goto LABEL_91;
  }
LABEL_92:
  ++*((void *)a1 + 3);
  return v13;
}

void karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::StampedTileKey>,karo::AsyncRequestManagerNoArgs>::getRequest(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t **a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  int v8 = (void **)(a1 + 8);
  unint64_t v9 = (uint64_t **)std::__tree<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::StampedTileKey>,std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::StampedTileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::find<altitude::KeyPair<altitude::StampedTileKey>>((uint64_t)(a1 + 8), (_DWORD *)a2);
  unint64_t v10 = v9;
  if (a1 + 9 != v9)
  {
    int8x8_t v12 = v9[13];
    uint8x8_t v11 = v9[14];
    if (v11) {
      atomic_fetch_add_explicit(v11 + 1, 1uLL, memory_order_relaxed);
    }
    *a4 = v12;
    a4[1] = v11;
    return;
  }
  (*(void (**)(uint64_t **__return_ptr, void *, uint64_t, uint64_t))(*a1 + 64))(&v44, a1, a2, a3);
  int v14 = v44;
  unint64_t v13 = v45;
  *a4 = v44;
  a4[1] = (uint64_t *)v13;
  int v15 = *v10;
  if (*v10)
  {
    unsigned int v16 = *(_DWORD *)(a2 + 52);
    unsigned int v17 = *(_DWORD *)(a2 + 56);
    unsigned int v18 = *(_DWORD *)(a2 + 60);
    unsigned int v19 = *(_DWORD *)(a2 + 64);
    unsigned int v20 = *(_DWORD *)(a2 + 36);
    unsigned int v21 = *(_DWORD *)(a2 + 40);
    unsigned int v22 = *(_DWORD *)(a2 + 44);
    while (1)
    {
      unint64_t v24 = (char *)v15;
      unsigned int v25 = *((_DWORD *)v15 + 21);
      if (v16 == v25 && v17 == *((_DWORD *)v24 + 22) && v18 == *((_DWORD *)v24 + 23) && *((_DWORD *)v24 + 24) == v19)
      {
        unsigned int v26 = *((_DWORD *)v24 + 17);
        BOOL v27 = v20 >= v26;
        if (v20 == v26 && (v28 = *((_DWORD *)v24 + 18), BOOL v27 = v21 >= v28, v21 == v28))
        {
          if (v22 >= *((_DWORD *)v24 + 19)) {
            goto LABEL_30;
          }
        }
        else if (v27)
        {
          goto LABEL_30;
        }
LABEL_8:
        int v15 = *(uint64_t **)v24;
        BOOL v23 = (uint64_t **)v24;
        if (!*(void *)v24) {
          goto LABEL_47;
        }
      }
      else
      {
        if (v16 < v25) {
          goto LABEL_8;
        }
        if (v16 <= v25)
        {
          unsigned int v29 = *((_DWORD *)v24 + 22);
          if (v17 < v29) {
            goto LABEL_8;
          }
          if (v17 <= v29)
          {
            unsigned int v30 = *((_DWORD *)v24 + 23);
            if (v18 < v30 || v18 <= v30 && v19 < *((_DWORD *)v24 + 24)) {
              goto LABEL_8;
            }
          }
        }
        if (v16 != v25 || *((_DWORD *)v24 + 22) != v17 || *((_DWORD *)v24 + 23) != v18)
        {
LABEL_37:
          if (v25 >= v16)
          {
            if (v25 > v16) {
              goto LABEL_50;
            }
            unsigned int v34 = *((_DWORD *)v24 + 22);
            if (v34 >= v17)
            {
              if (v34 > v17) {
                goto LABEL_50;
              }
              unsigned int v35 = *((_DWORD *)v24 + 23);
              if (v35 >= v18 && (v35 > v18 || *((_DWORD *)v24 + 24) >= v19)) {
                goto LABEL_50;
              }
            }
          }
          goto LABEL_44;
        }
LABEL_30:
        if (v19 != *((_DWORD *)v24 + 24)) {
          goto LABEL_37;
        }
        unsigned int v31 = *((_DWORD *)v24 + 17);
        BOOL v32 = v31 >= v20;
        if (v31 == v20)
        {
          unsigned int v33 = *((_DWORD *)v24 + 18);
          BOOL v32 = v33 >= v21;
          if (v33 == v21) {
            BOOL v32 = *((_DWORD *)v24 + 19) >= v22;
          }
        }
        if (v32) {
          goto LABEL_50;
        }
LABEL_44:
        BOOL v23 = (uint64_t **)(v24 + 8);
        int v15 = (uint64_t *)*((void *)v24 + 1);
        if (!v15) {
          goto LABEL_47;
        }
      }
    }
  }
  unint64_t v24 = (char *)v10;
  BOOL v23 = v10;
LABEL_47:
  size_t v36 = v24;
  unint64_t v24 = (char *)operator new(0x78uLL);
  long long v37 = *(_OWORD *)(a2 + 16);
  *((_OWORD *)v24 + 2) = *(_OWORD *)a2;
  *((_OWORD *)v24 + 3) = v37;
  *((_OWORD *)v24 + 4) = *(_OWORD *)(a2 + 32);
  *((_DWORD *)v24 + 20) = *(_DWORD *)(a2 + 48);
  *(_OWORD *)(v24 + 84) = *(_OWORD *)(a2 + 52);
  *((_DWORD *)v24 + 25) = *(_DWORD *)(a2 + 68);
  *((void *)v24 + 13) = 0;
  *((void *)v24 + 14) = 0;
  *(void *)unint64_t v24 = 0;
  *((void *)v24 + 1) = 0;
  *((void *)v24 + 2) = v36;
  void *v23 = (uint64_t *)v24;
  unint64_t v38 = (void *)**v8;
  uint8x8_t v39 = (uint64_t *)v24;
  if (v38)
  {
    *int v8 = v38;
    uint8x8_t v39 = *v23;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*v10, v39);
  ++a1[10];
LABEL_50:
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v40 = (std::__shared_weak_count *)*((void *)v24 + 14);
  *((void *)v24 + 13) = v14;
  *((void *)v24 + 14) = v13;
  if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
  }
  unint64_t v41 = a1[6];
  if (v41)
  {
    uint64_t v42 = *a4;
    size_t v43 = (std::__shared_weak_count *)a4[1];
    uint64_t v44 = v42;
    uint64_t v45 = v43;
    if (v43)
    {
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::JobManager::queueJob(v41, &v44);
      if (!atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
      }
    }
    else
    {
      karo::JobManager::queueJob(v41, &v44);
    }
  }
}

_DWORD *std::__tree<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::StampedTileKey>,std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::StampedTileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::find<altitude::KeyPair<altitude::StampedTileKey>>(uint64_t a1, _DWORD *a2)
{
  long long v4 = *(uint64_t **)(a1 + 8);
  uint8x8_t v2 = (_DWORD *)(a1 + 8);
  unint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  unsigned int v6 = a2[13];
  unsigned int v5 = a2[14];
  unsigned int v8 = a2[15];
  unsigned int v7 = a2[16];
  unsigned int v10 = a2[9];
  unsigned int v9 = a2[10];
  uint8x8_t v11 = v2;
  unsigned int v12 = a2[11];
  do
  {
    while (1)
    {
      unsigned int v13 = *((_DWORD *)v3 + 21);
      if (v13 == v6 && *((_DWORD *)v3 + 22) == v5 && *((_DWORD *)v3 + 23) == v8 && v7 == *((_DWORD *)v3 + 24)) {
        break;
      }
      if (v13 < v6) {
        goto LABEL_3;
      }
      if (v13 > v6) {
        goto LABEL_21;
      }
      unsigned int v17 = *((_DWORD *)v3 + 22);
      if (v17 < v5) {
        goto LABEL_3;
      }
      if (v17 > v5) {
        goto LABEL_21;
      }
      unsigned int v18 = *((_DWORD *)v3 + 23);
      if (v18 < v8) {
        goto LABEL_3;
      }
      if (v18 > v8) {
        goto LABEL_21;
      }
      BOOL v15 = *((_DWORD *)v3 + 24) >= v7;
LABEL_19:
      if (v15) {
        goto LABEL_21;
      }
LABEL_3:
      unint64_t v3 = (uint64_t *)v3[1];
      if (!v3) {
        goto LABEL_22;
      }
    }
    unsigned int v14 = *((_DWORD *)v3 + 17);
    BOOL v15 = v14 >= v10;
    if (v14 != v10) {
      goto LABEL_19;
    }
    unsigned int v16 = *((_DWORD *)v3 + 18);
    BOOL v15 = v16 >= v9;
    if (v16 != v9) {
      goto LABEL_19;
    }
    if (*((_DWORD *)v3 + 19) < v12) {
      goto LABEL_3;
    }
LABEL_21:
    uint8x8_t v11 = v3;
    unint64_t v3 = (uint64_t *)*v3;
  }
  while (v3);
LABEL_22:
  if (v11 == v2) {
    return v2;
  }
  unsigned int v19 = v11[21];
  if (v6 != v19 || v5 != v11[22] || v8 != v11[23] || v11[24] != v7)
  {
    if (v6 < v19) {
      return v2;
    }
    if (v6 > v19) {
      return v11;
    }
    unsigned int v23 = v11[22];
    if (v5 < v23) {
      return v2;
    }
    if (v5 > v23) {
      return v11;
    }
    unsigned int v24 = v11[23];
    if (v8 < v24) {
      return v2;
    }
    if (v8 > v24) {
      return v11;
    }
    BOOL v21 = v7 >= v11[24];
    goto LABEL_38;
  }
  unsigned int v20 = v11[17];
  BOOL v21 = v10 >= v20;
  if (v10 != v20 || (v22 = v11[18], BOOL v21 = v9 >= v22, v9 != v22))
  {
LABEL_38:
    if (!v21) {
      return v2;
    }
    return v11;
  }
  if (v12 >= v11[19]) {
    return v11;
  }
  return v2;
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::StampedTileKey>,karo::AsyncRequestManagerNoArgs>::waitOnRequest(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unsigned int v6 = std::__tree<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::StampedTileKey>,std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::StampedTileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::find<altitude::KeyPair<altitude::StampedTileKey>>(a1 + 64, a2);
  if ((_DWORD *)(a1 + 72) == v6)
  {
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
    return 0;
  }
  else
  {
    uint64_t v8 = *((void *)v6 + 13);
    unsigned int v7 = (std::__shared_weak_count *)*((void *)v6 + 14);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
    if (v8)
    {
      karo::Job::waitToFinish((karo::Job *)v8, a3);
      pthread_mutex_lock(*(pthread_mutex_t **)(v8 + 152));
      uint64_t v9 = *(_DWORD *)(v8 + 160) & 1;
      pthread_mutex_unlock(*(pthread_mutex_t **)(v8 + 152));
      if (!v7) {
        return v9;
      }
    }
    else
    {
      uint64_t v9 = 0;
      if (!v7) {
        return v9;
      }
    }
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return v9;
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::StampedTileKey>,karo::AsyncRequestManagerNoArgs>::requestT@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, unsigned int a5@<W4>, char a6@<W5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  if (!a3) {
    a3 = *(_DWORD *)(a1 + 88) + 1;
  }
  (*(void (**)(unsigned int **__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 96))(&v22, a1, a2, a7);
  unsigned int v16 = v22;
  unsigned int v17 = atomic_load(v22 + 4);
  if (v17 != a4) {
    (*(void (**)(unsigned int *, uint64_t))(*(void *)v22 + 24))(v22, a4);
  }
  v16[45] = a3;
  v16[46] = a5;
  *((unsigned char *)v16 + 176) = a6;
  unsigned int v18 = v22;
  unsigned int v19 = v23;
  *a8 = off_1EF5677B0;
  a8[1] = v18;
  a8[2] = v19;
  if (v19)
  {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    unsigned int v18 = (unsigned int *)a8[1];
  }
  if (v18) {
    atomic_fetch_add((atomic_uint *volatile)v18 + 32, 1u);
  }
  unsigned int v20 = v23;
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  return pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::StampedTileKey>,karo::AsyncRequestManagerNoArgs>::requestT(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  if (!a4) {
    a4 = *(_DWORD *)(a1 + 88) + 1;
  }
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  if (*a2 != v9)
  {
    do
    {
      uint64_t v10 = v8 + 72;
      (*(void (**)(unsigned int **__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 96))(&v22, a1, v8, v8 + 72);
      uint8x8_t v11 = v22;
      int v12 = *(_DWORD *)(v8 + 76);
      unsigned int v13 = *(_DWORD *)(v8 + 80);
      char v14 = *(unsigned char *)(v8 + 84);
      unsigned int v15 = atomic_load(v22 + 4);
      if (v15 != v12) {
        (*(void (**)(unsigned int *))(*(void *)v22 + 24))(v22);
      }
      v11[45] = a4;
      v11[46] = v13;
      *((unsigned char *)v11 + 176) = v14;
      unsigned int v16 = *(void **)(a3 + 8);
      if ((unint64_t)v16 >= *(void *)(a3 + 16))
      {
        unsigned int v19 = std::vector<karo::AsyncRequestManager::RequestHandle>::__emplace_back_slow_path<std::shared_ptr<karo::AsyncRequestManager::Request> &>((void **)a3, (uint64_t)v22, (uint64_t)v23);
      }
      else
      {
        *unsigned int v16 = off_1EF5677B0;
        unsigned int v17 = v22;
        v16[1] = v22;
        uint64_t v18 = (uint64_t)v23;
        v16[2] = v23;
        if (v18)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
          unsigned int v17 = (unsigned int *)v16[1];
        }
        if (v17) {
          atomic_fetch_add((atomic_uint *volatile)v17 + 32, 1u);
        }
        unsigned int v19 = v16 + 3;
      }
      *(void *)(a3 + 8) = v19;
      unsigned int v20 = v23;
      if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
      uint64_t v8 = v10 + 16;
    }
    while (v10 + 16 != v9);
  }
  return pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
}

void altitude::TrafficCacheNode::createRequest()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t std::__shared_ptr_pointer<altitude::TrafficCacheNodeJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::TrafficCacheNodeJob>,std::allocator<altitude::TrafficCacheNodeJob>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::TrafficCacheNodeJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::TrafficCacheNodeJob>,std::allocator<altitude::TrafficCacheNodeJob>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t altitude::TrafficCacheNodeJob::succeeded(altitude::TrafficCacheNodeJob *this)
{
  return *((unsigned __int8 *)this + 225);
}

void altitude::TrafficCacheNodeJob::jobStep(altitude::TrafficCacheNodeJob *this)
{
  atomic_load((unsigned int *)this + 4);
  (*(void (**)(void *__return_ptr))(**((void **)this + 29) + 104))(&v10);
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v10) == 4)
  {
    uint8x8_t v2 = v13;
    pthread_mutex_lock(v13[19]);
    int v3 = *((_DWORD *)v2 + 40);
    pthread_mutex_unlock(v2[19]);
    if (v3) {
      long long v4 = (const unsigned __int8 *)(*(uint64_t (**)(pthread_mutex_t **))&(*v13)->__opaque[48])(v13);
    }
    else {
      long long v4 = 0;
    }
    if ((*(uint64_t (**)(pthread_mutex_t **))&(*v13)->__opaque[40])(v13))
    {
      zilch::ReadBitstream::ReadBitstream((zilch::ReadBitstream *)v9, v4);
      operator new();
    }
    goto LABEL_11;
  }
  if (!karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v10))
  {
LABEL_11:
    (*(void (**)(altitude::TrafficCacheNodeJob *))(*(void *)this + 16))(this);
    goto LABEL_13;
  }
  unsigned int v5 = v12;
  v8[0] = v11;
  v8[1] = v12;
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    karo::Job::addBlockingSubJob((uint64_t *)this, v8, 1, 0);
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    karo::Job::addBlockingSubJob((uint64_t *)this, v8, 1, 0);
  }
LABEL_13:
  uint64_t v10 = off_1EF5676C0;
  unsigned int v6 = v14;
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  uint64_t v10 = off_1EF5677B0;
  if (v11) {
    atomic_fetch_add((atomic_uint *volatile)(v11 + 128), 0xFFFFFFFF);
  }
  unsigned int v7 = v12;
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

uint64_t std::__shared_ptr_pointer<altitude::TrafficDynamicData *,std::shared_ptr<altitude::TrafficDynamicData>::__shared_ptr_default_delete<altitude::TrafficDynamicData,altitude::TrafficDynamicData>,std::allocator<altitude::TrafficDynamicData>>::__on_zero_shared(uint64_t result)
{
  int8x8_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint8x8_t v2 = (void *)v1[4];
    if (v2)
    {
      do
      {
        int v3 = (void *)*v2;
        operator delete(v2);
        uint8x8_t v2 = v3;
      }
      while (v3);
    }
    long long v4 = (void *)v1[2];
    v1[2] = 0;
    if (v4) {
      operator delete(v4);
    }
    unsigned int v5 = (std::__shared_weak_count *)v1[1];
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::TrafficDynamicData *,std::shared_ptr<altitude::TrafficDynamicData>::__shared_ptr_default_delete<altitude::TrafficDynamicData,altitude::TrafficDynamicData>,std::allocator<altitude::TrafficDynamicData>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void altitude::TrafficCacheNodeJob::~TrafficCacheNodeJob(altitude::TrafficCacheNodeJob *this)
{
  *(void *)this = &unk_1EF56A338;
  uint8x8_t v2 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF56A2A8;
  if (*((char *)this + 223) < 0) {
    operator delete(*((void **)this + 25));
  }
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 24));
  uint64_t v3 = *((void *)this + 24);
  if (v3) {
    MEMORY[0x1A6239270](v3, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 24) = 0;
  karo::Job::~Job(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF56A338;
  uint8x8_t v2 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF56A2A8;
  if (*((char *)this + 223) < 0) {
    operator delete(*((void **)this + 25));
  }
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 24));
  uint64_t v3 = *((void *)this + 24);
  if (v3) {
    MEMORY[0x1A6239270](v3, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 24) = 0;
  karo::Job::~Job(this);
}

void karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::StampedTileKey>,karo::AsyncRequestManagerNoArgs>::createAndQueueRequest(void *a1@<X0>, uint64_t *a2@<X8>)
{
  (*(void (**)(void *))(*a1 + 64))(a1);
  unint64_t v4 = a1[6];
  if (v4)
  {
    uint64_t v5 = *a2;
    unsigned int v6 = (std::__shared_weak_count *)a2[1];
    v7[0] = v5;
    v7[1] = v6;
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::JobManager::queueJob(v4, v7);
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    else
    {
      karo::JobManager::queueJob(v4, v7);
    }
  }
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::StampedTileKey>,karo::AsyncRequestManagerNoArgs>::clearRequest(uint64_t a1, _DWORD *a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = (uint64_t **)(a1 + 64);
  uint64_t v5 = (uint64_t *)std::__tree<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::StampedTileKey>,std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::StampedTileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::find<altitude::KeyPair<altitude::StampedTileKey>>(a1 + 64, a2);
  if ((uint64_t *)(a1 + 72) != v5)
  {
    unsigned int v6 = v5;
    (*(void (**)(uint64_t))(*(void *)v5[13] + 16))(v5[13]);
    unsigned int v7 = (uint64_t *)v6[1];
    if (v7)
    {
      do
      {
        uint64_t v8 = v7;
        unsigned int v7 = (uint64_t *)*v7;
      }
      while (v7);
    }
    else
    {
      uint64_t v9 = v6;
      do
      {
        uint64_t v8 = (uint64_t *)v9[2];
        BOOL v10 = *v8 == (void)v9;
        uint64_t v9 = v8;
      }
      while (!v10);
    }
    if (*v4 == v6) {
      *unint64_t v4 = v8;
    }
    uint64_t v11 = *(uint64_t **)(a1 + 72);
    --*(void *)(a1 + 80);
    std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v11, v6);
    int v12 = (std::__shared_weak_count *)v6[14];
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    operator delete(v6);
  }
  unsigned int v13 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v13);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::StampedTileKey>,karo::AsyncRequestManagerNoArgs>::removeFromRequests(uint64_t a1, uint64_t a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = *(uint64_t **)(a1 + 64);
  if (v4 != (uint64_t *)(a1 + 72))
  {
    uint64_t v5 = *(uint64_t **)(a1 + 64);
    while (1)
    {
      unsigned int v6 = (uint64_t *)v5[1];
      if (v5[13] == a2) {
        break;
      }
      if (v6)
      {
        do
        {
          unsigned int v7 = v6;
          unsigned int v6 = (uint64_t *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          unsigned int v7 = (uint64_t *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v8);
      }
      uint64_t v5 = v7;
      if (v7 == (uint64_t *)(a1 + 72)) {
        goto LABEL_23;
      }
    }
    if (v6)
    {
      do
      {
        uint64_t v9 = v6;
        unsigned int v6 = (uint64_t *)*v6;
      }
      while (v6);
    }
    else
    {
      BOOL v10 = v5;
      do
      {
        uint64_t v9 = (uint64_t *)v10[2];
        BOOL v8 = *v9 == (void)v10;
        BOOL v10 = v9;
      }
      while (!v8);
    }
    if (v4 == v5) {
      *(void *)(a1 + 64) = v9;
    }
    uint64_t v11 = *(uint64_t **)(a1 + 72);
    --*(void *)(a1 + 80);
    std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v11, v5);
    int v12 = (std::__shared_weak_count *)v5[14];
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    operator delete(v5);
  }
LABEL_23:
  unsigned int v13 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v13);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::StampedTileKey>,karo::AsyncRequestManagerNoArgs>::pruneRequests(uint64_t a1, int a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = *(uint64_t **)(a1 + 64);
  if (v4 != (uint64_t *)(a1 + 72))
  {
    do
    {
      uint64_t v5 = (uint64_t *)v4[1];
      unsigned int v6 = v4;
      if (v5)
      {
        do
        {
          unsigned int v7 = v5;
          uint64_t v5 = (uint64_t *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          unsigned int v7 = (uint64_t *)v6[2];
          BOOL v8 = *v7 == (void)v6;
          unsigned int v6 = v7;
        }
        while (!v8);
      }
      uint64_t v9 = v4[13];
      if (atomic_load((unsigned int *)(v9 + 128))) {
        *(_DWORD *)(v9 + 180) = a2;
      }
      pthread_mutex_lock(*(pthread_mutex_t **)(v9 + 152));
      int v11 = *(_DWORD *)(v9 + 160);
      pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 152));
      if ((v11 & 1) != 0 && *(unsigned char *)(v9 + 176) && *(_DWORD *)(v9 + 180) != a2
        || (a2 - *(_DWORD *)(v9 + 180)) > *(_DWORD *)(v9 + 184))
      {
        (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
        int v12 = (uint64_t *)v4[1];
        unsigned int v13 = v4;
        if (v12)
        {
          do
          {
            char v14 = v12;
            int v12 = (uint64_t *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            char v14 = (uint64_t *)v13[2];
            BOOL v8 = *v14 == (void)v13;
            unsigned int v13 = v14;
          }
          while (!v8);
        }
        if (*(uint64_t **)(a1 + 64) == v4) {
          *(void *)(a1 + 64) = v14;
        }
        unsigned int v15 = *(uint64_t **)(a1 + 72);
        --*(void *)(a1 + 80);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v15, v4);
        unsigned int v16 = (std::__shared_weak_count *)v4[14];
        if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
        operator delete(v4);
      }
      unint64_t v4 = v7;
    }
    while (v7 != (uint64_t *)(a1 + 72));
  }
  *(_DWORD *)(a1 + 88) = a2;
  unsigned int v17 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v17);
}

void altitude::TrafficCacheNode::~TrafficCacheNode(altitude::TrafficCacheNode *this)
{
  altitude::GenericCacheNode<altitude::StampedTileKey,altitude::TrafficDynamicData>::~GenericCacheNode(this);
  JUMPOUT(0x1A6239270);
}

void altitude::GenericCacheNode<altitude::StampedTileKey,altitude::TrafficDynamicData>::~GenericCacheNode(karo::AsyncRequestManager *a1)
{
  *(void *)a1 = &unk_1EF5692B0;
  pthread_mutex_destroy(*((pthread_mutex_t **)a1 + 17));
  uint64_t v2 = *((void *)a1 + 17);
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40FA0F61DDLL);
  }
  *((void *)a1 + 17) = 0;
  uint64_t v3 = (void *)*((void *)a1 + 14);
  if (v3)
  {
    do
    {
      uint64_t v5 = (void *)*v3;
      unsigned int v6 = (std::__shared_weak_count *)v3[8];
      if (v6) {
        std::__shared_weak_count::__release_weak(v6);
      }
      operator delete(v3);
      uint64_t v3 = v5;
    }
    while (v5);
  }
  unint64_t v4 = (void *)*((void *)a1 + 12);
  *((void *)a1 + 12) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)a1 = &unk_1EF567B08;
  while (*((void *)a1 + 10))
    (*(void (**)(karo::AsyncRequestManager *, uint64_t))(*(void *)a1 + 48))(a1, *((void *)a1 + 8) + 32);
  std::__tree<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::StampedTileKey>,std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::StampedTileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)a1 + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(a1);
}

void std::__tree<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::StampedTileKey>,std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::StampedTileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::StampedTileKey>,std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::StampedTileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*a1);
    std::__tree<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::StampedTileKey>,std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::StampedTileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::StampedTileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(a1[1]);
    uint64_t v2 = (std::__shared_weak_count *)a1[14];
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete(a1);
  }
}

__n128 altitude::GenericCacheNode<altitude::StampedTileKey,altitude::TrafficDynamicData>::getCacheKeyForKey@<Q0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
  return result;
}

uint64_t altitude::GenericCacheNode<altitude::StampedTileKey,altitude::TrafficDynamicData>::hasValidKey()
{
  return 1;
}

void md::Logic<md::PolygonLogic,md::PolygonContext,md::LogicDependencies<gdc::TypeList<md::SettingsContext,md::SceneContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  long long v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    int v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

uint64_t _ZNKSt3__110__function6__funcIZN2md12PolygonLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_15SettingsContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14PolygonContextEE3__1NS_9allocatorISK_EEFvvEE7__cloneEPNS0_6__baseISN_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56F690;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md12PolygonLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_15SettingsContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14PolygonContextEE3__1NS_9allocatorISK_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56F690;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md12PolygonLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_15SettingsContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14PolygonContextEE3__1NS_9allocatorISK_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md12PolygonLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_15SettingsContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14PolygonContextEE3__0NS_9allocatorISK_EEFvvEE7__cloneEPNS0_6__baseISN_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56F648;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md12PolygonLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_15SettingsContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14PolygonContextEE3__0NS_9allocatorISK_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF56F648;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md12PolygonLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_15SettingsContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14PolygonContextEE3__0NS_9allocatorISK_EEFvvEED0Ev()
{
}

uint64_t md::Logic<md::PolygonLogic,md::PolygonContext,md::LogicDependencies<gdc::TypeList<md::SettingsContext,md::SceneContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::PolygonLogic,md::PolygonContext,md::LogicDependencies<gdc::TypeList<md::SettingsContext,md::SceneContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x401D4CCE847AB1D1 && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    v8[0] = md::LogicDependencies<gdc::TypeList<md::SettingsContext,md::SceneContext>,gdc::TypeList<>>::buildRequiredTuple<md::SettingsContext,md::SceneContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    v8[1] = v7;
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v8, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t gdc::ObjectHolder<md::PolygonContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::PolygonContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555460;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0x1000C4004CED998);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::PolygonContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555460;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C4004CED998);
  }
  return a1;
}

void md::PolygonLogic::~PolygonLogic(md::PolygonLogic *this)
{
  *(void *)this = &unk_1EF531C60;
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 216);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable((uint64_t)this + 136);
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF531C60;
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 216);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable((uint64_t)this + 136);
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

uint64_t md::NavLabel::type(md::NavLabel *this)
{
  return 5;
}

void md::NavLabel::~NavLabel(md::NavLabel *this)
{
  md::NavLabel::~NavLabel(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;

  *(void *)this = &unk_1EF553DB0;
  if (*((unsigned char *)this + 26))
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      *(unsigned char *)(v2 + 285) = 1;
    }
  }
  uint64_t v3 = *((void *)this + 36);
  *((void *)this + 36) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 23);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 21);
    if (!v5) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 21);
    if (!v5) {
      goto LABEL_12;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_12:
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 9);
    if (!v7) {
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 9);
    if (!v7) {
      goto LABEL_18;
    }
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
LABEL_18:
  if (*((char *)this + 55) < 0)
  {
    (*(void (**)(void, void, uint64_t))(**((void **)this + 7) + 40))(*((void *)this + 7), *((void *)this + 4), *((void *)this + 6) & 0x7FFFFFFFFFFFFFFFLL);
    BOOL v8 = (std::__shared_weak_count *)*((void *)this + 2);
    if (!v8) {
      return;
    }
  }
  else
  {
    BOOL v8 = (std::__shared_weak_count *)*((void *)this + 2);
    if (!v8) {
      return;
    }
  }
  if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
}

void md::NavLabel::worldPointForDisplay(md::NavLabel *this, const md::NavContext *a2)
{
  uint64_t v3 = (void *)*((void *)this + 20);
  if (v3)
  {
    if (a2)
    {
      if (!v3[1])
      {
        uint64_t v4 = **(void **)(*((void *)a2 + 4) + 144);
        (*(void (**)(void *__return_ptr))(*v3 + 64))(v10);
        md::AnchorManager::newAnchorAtCoordinate(&v11, v4, (uint64_t)v10, 0);
      }
    }
    (*(void (**)(void *))(*v3 + 48))(v3);
  }
  else if (a2 && !*(unsigned char *)(*((void *)a2 + 3) + 8))
  {
    long double v5 = *((double *)this + 14) * 6.28318531;
    long double v6 = exp(*((double *)this + 15) * 6.28318531 + -3.14159265);
    double v7 = atan(v6) * 2.0 + -1.57079633;
    long double v8 = fmod(v5, 6.28318531);
    double v9 = fmod(v8 + 6.28318531, 6.28318531) + -3.14159265;
    __sincos_stret(v7);
    __sincos_stret(v9);
  }
}

void md::NavLabel::layoutForStagingWithNavContext(md::NavLabel *this, md::NavContext *a2)
{
  uint64_t v2 = *((void *)this + 36);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 640);
    if (v3)
    {
      unsigned __int8 v4 = atomic_load((unsigned __int8 *)(v3 + 144));
      if (v4)
      {
        *((unsigned char *)this + 299) = 0;
        float v7 = 0.0;
        if (*((unsigned char *)this + 296))
        {
LABEL_5:
          if (!*((void *)this + 10)
            || (*(unsigned int (**)(md::NavLabel *))(*(void *)this + 16))(this) == 4)
          {
            if (*((void *)this + 8)
              && (*(unsigned int (**)(md::NavLabel *))(*(void *)this + 16))(this) == 4)
            {
              md::LabelStyle::setZoom(*((md::LabelStyle **)this + 8), v7);
              long double v8 = (unsigned char *)*((void *)this + 8);
              char v9 = v8[240];
              LOBYTE(v10) = v8[112];
              float v11 = (float)v10;
              if (v7 >= v11)
              {
                LOBYTE(v11) = v8[113];
                *((unsigned char *)this + 298) = v7 <= (float)LODWORD(v11);
              }
              else
              {
                *((unsigned char *)this + 298) = 0;
              }
            }
            else
            {
              if ((*(unsigned int (**)(md::NavLabel *))(*(void *)this + 16))(this) == 4
                || *((void *)this + 10) && !*((void *)this + 8))
              {
                (*(void (**)(md::NavLabel *))(*(void *)this + 16))(this);
              }
              char v9 = 0;
              *((unsigned char *)this + 298) = 0;
            }
            goto LABEL_82;
          }
          uint64_t v15 = *((void *)this + 10);
          unsigned int v16 = (std::__shared_weak_count *)*((void *)this + 11);
          *(void *)&long long v85 = v15;
          *((void *)&v85 + 1) = v16;
          if (v16) {
            atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)&v82, v15, (uint64_t)v16);
          if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
          if (!v84)
          {
            gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v82);
            return;
          }
          *((void *)this + 12) = 0;
          unsigned int v17 = (float *)((char *)this + 96);
          unsigned int v18 = (int)v7;
          *((unsigned char *)this + 104) = 0;
          uint64_t v19 = *(void *)(v82 + 24);
          if ((int)v7 >= 0x17) {
            unsigned int v20 = 23;
          }
          else {
            unsigned int v20 = (int)v7;
          }
          BOOL v21 = *(float **)v19;
          if (*(void *)v19
            && (float v22 = *v21, LODWORD(v21) = *v21 == 1.0, *(unsigned char *)(v19 + 10))
            && (v22 != 0.0 ? (BOOL v23 = v22 == 1.0) : (BOOL v23 = 1), !v23)
            || (v24 = *(unsigned __int8 *)(v19 + v21 + 11), float v22 = 0.0, v24 == 2))
          {
            LOBYTE(v85) = 1;
            LOBYTE(v87) = 1;
            int v25 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v19, 0x157u, v20, 0, &v85);
            int v26 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v19, 0x157u, v20, 1u, &v87);
            if (v22 < 1.0) {
              LOBYTE(v26) = v25;
            }
          }
          else
          {
            int v26 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(v82 + 24), 0x157u, v20, v24, 0);
          }
          *((unsigned char *)this + 104) = v26;
          LOBYTE(v85) = 1;
          char v30 = gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<int>(*(void *)(v82 + 24), 0x84u, v20, (BOOL *)&v85);
          if ((_BYTE)v85) {
            char v9 = v30;
          }
          else {
            char v9 = 10;
          }
          unsigned int v31 = (*(uint64_t (**)(md::NavLabel *))(*(void *)this + 16))(this);
          if (v31 >= 3)
          {
            if (v31 == 3)
            {
              if (!*((unsigned char *)this + 296))
              {
                BOOL v32 = gss::QueryableLocker<gss::PropertyID>::valueAtZ<(gss::PropertyID)220>(*(void *)(v82 + 24), v18);
                goto LABEL_54;
              }
              goto LABEL_52;
            }
            if (v31 != 6)
            {
              *((unsigned char *)this + 298) = 0;
LABEL_55:
              uint64_t v33 = *((void *)this + 10);
              unsigned int v34 = *(std::__shared_weak_count **)(v33 + 16);
              if (v34 && (unsigned int v35 = std::__shared_weak_count::lock(v34), (*((void *)&v85 + 1) = v35) != 0))
              {
                size_t v36 = v35;
                *(void *)&long long v85 = *(void *)(v33 + 8);
                if ((void)v85)
                {
                  uint64_t v37 = *((void *)this + 10);
                  unint64_t v87 = 0;
                  uint64_t v88 = 0;
                  unint64_t v38 = *(std::__shared_weak_count **)(v37 + 16);
                  if (v38)
                  {
                    uint64_t v88 = std::__shared_weak_count::lock(v38);
                    if (v88)
                    {
                      unint64_t v38 = *(std::__shared_weak_count **)(v37 + 8);
                      unint64_t v87 = v38;
                    }
                    else
                    {
                      unint64_t v38 = v87;
                    }
                  }
                  float *v17 = gss::StylesheetManager<gss::PropertyID>::shieldBrightnessForMapMode((uint64_t)v38);
                  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&v87);
                }
                else
                {
                  float *v17 = 1.0;
                }
                if (!atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
                  std::__shared_weak_count::__release_weak(v36);
                }
              }
              else
              {
                float *v17 = 1.0;
              }
              uint64_t v51 = *(void *)(v82 + 24);
              uint64_t v52 = *(float **)v51;
              if (*(void *)v51
                && (float v53 = *v52, LODWORD(v52) = *v52 == 1.0, *(unsigned char *)(v51 + 10))
                && v53 != 0.0
                && v53 != 1.0
                || (v54 = *(unsigned __int8 *)(v51 + v52 + 11), float v53 = 0.0, v54 == 2))
              {
                LOBYTE(v85) = 1;
                LOBYTE(v87) = 1;
                float v55 = (float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v51, 0xDEu, 0, &v85);
                float v56 = *v55
                    + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v51, 0xDEu, 1u, &v87)- *v55)* v53);
              }
              else
              {
                float v56 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(*(void *)(v82 + 24), 0xDEu, v54, 0);
              }
              *((float *)this + 25) = v56;
              gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v82);
LABEL_82:
              *(float32x2_t *)&long long v82 = vadd_f32(*(float32x2_t *)((char *)this + 256), *(float32x2_t *)((char *)this + 300));
              (*(void (**)(void, char *))(**((void **)this + 36) + 952))(*((void *)this + 36), (char *)this + 96);
              uint64_t v57 = (unsigned char *)*((void *)this + 36);
              v57[556] = 4 * v9;
              (*(void (**)(void))(*(void *)v57 + 960))();
              *((float *)this + 77) = (*(float (**)(void))(**((void **)this + 36) + 264))();
              *((_DWORD *)this + 78) = v58;
              *((_DWORD *)this + 79) = v59;
              *((_DWORD *)this + 80) = v60;
              if ((*(unsigned int (**)(md::NavLabel *))(*(void *)this + 16))(this) == 6)
              {
                long long v61 = (float *)*((void *)a2 + 4);
                if (v61[14] > *((float *)this + 77)
                  && v61[12] < *((float *)this + 79)
                  && v61[15] > *((float *)this + 78)
                  && v61[13] < *((float *)this + 80))
                {
                  BOOL v62 = 1;
LABEL_101:
                  *((unsigned char *)this + 299) = v62;
                  return;
                }
LABEL_100:
                BOOL v62 = 0;
                goto LABEL_101;
              }
              float v63 = *((float *)this + 79) - *((float *)this + 77);
              float v64 = *((float *)this + 71);
              uint64_t v65 = *((void *)this + 36);
              uint64_t v66 = *(void *)(v65 + 640);
              if (v66 && (unsigned __int8 v67 = atomic_load((unsigned __int8 *)(v66 + 143)), (v67 & 1) != 0)) {
                int v68 = (*(uint64_t (**)(void))(**(void **)(v65 + 640) + 24))(*(void *)(v65 + 640));
              }
              else {
                int v68 = 0;
              }
              float v69 = v63 * 0.5;
              float v70 = v63 * v64;
              float v71 = *((float *)this + 77);
              float v72 = *((float *)this + 79) - v71;
              float v73 = *((float *)this + 78);
              float v74 = *((float *)this + 80) - v73;
              long long v75 = (float *)*((void *)a2 + 4);
              float v76 = v75[12];
              if (v68)
              {
                float v77 = (float)(v71 + v69) + (float)(v72 * 0.5);
                if (v77 < v76) {
                  goto LABEL_100;
                }
                float v78 = v75[14];
                if (v77 >= v78) {
                  goto LABEL_100;
                }
                float v79 = v73 + (float)(v74 * 0.5);
                if (v79 < v75[13]) {
                  goto LABEL_100;
                }
                float v80 = v77 - v70;
              }
              else
              {
                float v81 = (float)(v71 - v69) + (float)(v72 * 0.5);
                if (v81 < v76) {
                  goto LABEL_100;
                }
                float v78 = v75[14];
                if (v81 >= v78) {
                  goto LABEL_100;
                }
                float v79 = v73 + (float)(v74 * 0.5);
                if (v79 < v75[13]) {
                  goto LABEL_100;
                }
                float v80 = v81 + v70;
              }
              BOOL v62 = v79 < v75[15];
              if (v80 < v76) {
                BOOL v62 = 0;
              }
              if (v80 >= v78) {
                BOOL v62 = 0;
              }
              goto LABEL_101;
            }
          }
          if (!*((unsigned char *)this + 296))
          {
            BOOL v32 = gss::QueryableLocker<gss::PropertyID>::valueAtZ<(gss::PropertyID)221>(*(void *)(v82 + 24), v18);
            goto LABEL_54;
          }
LABEL_52:
          BOOL v32 = *((unsigned char *)this + 297) != 0;
LABEL_54:
          *((unsigned char *)this + 298) = v32;
          goto LABEL_55;
        }
        if (*((void *)this + 20))
        {
          double v12 = *((double *)this + 19);
          long long v13 = *(_OWORD *)((char *)this + 136);
          long long v85 = v13;
          double v14 = *((double *)&v13 + 1);
        }
        else
        {
          if (a2)
          {
            uint64_t v27 = *((void *)a2 + 3);
            double v28 = *(float *)(v27 + 48);
            *(void *)&long long v13 = *((void *)this + 14);
            double v14 = *((double *)this + 15);
            double v29 = *((double *)this + 16);
            if (*(unsigned char *)(v27 + 8))
            {
              double v12 = v28 * (0.0000000249532021 * v29);
            }
            else
            {
              double v39 = v29 * v28;
              long double v40 = *(double *)&v13 * 6.28318531;
              long double v41 = exp(v14 * 6.28318531 + -3.14159265);
              double v42 = atan(v41) * 2.0 + -1.57079633;
              long double v43 = fmod(v40, 6.28318531);
              double v44 = fmod(v43 + 6.28318531, 6.28318531) + -3.14159265;
              __double2 v45 = __sincos_stret(v42);
              double v46 = 6378137.0 / sqrt(v45.__sinval * v45.__sinval * -0.00669437999 + 1.0);
              double v47 = (v46 + v39) * v45.__cosval;
              __double2 v48 = __sincos_stret(v44);
              *(double *)&long long v13 = v47 * v48.__cosval;
              double v14 = v47 * v48.__sinval;
              double v12 = (v39 + v46 * 0.99330562) * v45.__sinval;
            }
          }
          else
          {
            *(void *)&long long v13 = 0;
            double v14 = 0.0;
            double v12 = 0.0;
          }
          *(void *)&long long v85 = v13;
          *((double *)&v85 + 1) = v14;
        }
        double v86 = v12;
        unint64_t v49 = (float64x2_t *)*((void *)a2 + 3);
        *(float32x2_t *)((char *)this + 300) = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v49[60], v49[54], *(double *)&v13), v49[56], v14), v49[58], v12), 1.0/ (v49[61].f64[1]+ v49[55].f64[1] * *(double *)&v13+ v49[57].f64[1] * v14+ v49[59].f64[1] * v12)));
        long long v82 = xmmword_1A28FCDD0;
        double v83 = 0.0;
        char v84 = 0;
        LOBYTE(v87) = 0;
        BYTE4(v88) = 0;
        md::LabelLayoutContext::evaluateWorldPoint((uint64_t)v49, (uint64_t)&v85, (uint64_t)&v87, 1u, 0, (uint64_t)&v82, 1.0);
        if (!v84)
        {
          float v7 = *(float *)&v82;
          float v50 = v83;
          *((float *)this + 50) = v50;
          goto LABEL_5;
        }
      }
    }
  }
}

void sub_1A237298C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

void md::NavLabel::layoutForDisplayWithNavContext(float32x2_t *this, float64x2_t **a2)
{
  float32x2_t v2 = this[36];
  if (v2)
  {
    uint64_t v3 = *(void *)(*(void *)&v2 + 640);
    if (v3)
    {
      unsigned __int8 v4 = atomic_load((unsigned __int8 *)(v3 + 144));
      if (v4)
      {
        if (this[40].i8[4])
        {
          float32x2_t v7 = this[41];
        }
        else
        {
          md::NavLabel::worldPointForDisplay((md::NavLabel *)this, (const md::NavContext *)a2);
          *(double *)&long long v19 = v8;
          *((double *)&v19 + 1) = v9;
          double v20 = v10;
          float v11 = a2[3];
          double v16 = v10;
          float32x2_t v7 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v11[60], v11[54], v8), v11[56], v9), v11[58], v10), 1.0 / (v11[61].f64[1] + v11[55].f64[1] * v8 + v11[57].f64[1] * v9 + v11[59].f64[1] * v10)));
          this[41] = v7;
          double v18 = 0.0;
          v21[0] = 0;
          v21[12] = 0;
          md::LabelLayoutContext::evaluateWorldPoint((uint64_t)v11, (uint64_t)&v19, (uint64_t)v21, 1u, 0, (uint64_t)v17, 1.0);
          *(_OWORD *)this[26].f32 = v19;
          *(double *)&this[28] = v16;
          float32_t v12 = v18;
          this[31].f32[0] = v12;
        }
        v17[0] = vadd_f32(this[32], v7);
        (*(void (**)(void, float64x2_t **, void *, float32x2_t *))(**(void **)&this[36] + 976))(*(void *)&this[36], a2, v17, this + 32);
        this[42].f32[0] = (*(float (**)(void))(**(void **)&this[36] + 256))();
        this[42].i32[1] = v13;
        this[43].i32[0] = v14;
        this[43].i32[1] = v15;
      }
    }
  }
}

BOOL gss::QueryableLocker<gss::PropertyID>::valueAtZ<(gss::PropertyID)221>(uint64_t a1, unsigned int a2)
{
  if (a2 >= 0x17) {
    unsigned int v3 = 23;
  }
  else {
    unsigned int v3 = a2;
  }
  unsigned __int8 v4 = *(float **)a1;
  if (*(void *)a1
    && (float v5 = *v4, LODWORD(v4) = *v4 == 1.0, *(unsigned char *)(a1 + 10))
    && (v5 != 0.0 ? (BOOL v6 = v5 == 1.0) : (BOOL v6 = 1), !v6)
    || (v7 = *(unsigned __int8 *)(a1 + v4 + 11), float v5 = 0.0, v7 == 2))
  {
    char v12 = 1;
    char v11 = 1;
    char v8 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)a1, 0xDDu, v3, 0, &v12);
    char v9 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)a1, 0xDDu, v3, 1, &v11);
    if (v5 < 1.0) {
      char v9 = v8;
    }
  }
  else
  {
    char v9 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)a1, 0xDDu, v3, v7, 0);
  }
  return v9 != 0;
}

BOOL gss::QueryableLocker<gss::PropertyID>::valueAtZ<(gss::PropertyID)220>(uint64_t a1, unsigned int a2)
{
  if (a2 >= 0x17) {
    unsigned int v3 = 23;
  }
  else {
    unsigned int v3 = a2;
  }
  unsigned __int8 v4 = *(float **)a1;
  if (*(void *)a1
    && (float v5 = *v4, LODWORD(v4) = *v4 == 1.0, *(unsigned char *)(a1 + 10))
    && (v5 != 0.0 ? (BOOL v6 = v5 == 1.0) : (BOOL v6 = 1), !v6)
    || (v7 = *(unsigned __int8 *)(a1 + v4 + 11), float v5 = 0.0, v7 == 2))
  {
    char v12 = 1;
    char v11 = 1;
    char v8 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)a1, 0xDCu, v3, 0, &v12);
    char v9 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)a1, 0xDCu, v3, 1, &v11);
    if (v5 < 1.0) {
      char v9 = v8;
    }
  }
  else
  {
    char v9 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)a1, 0xDCu, v3, v7, 0);
  }
  return v9 != 0;
}

float gss::StylesheetManager<gss::PropertyID>::shieldBrightnessForMapMode(uint64_t a1)
{
  __int16 v16 = 0;
  uint64_t v2 = *(void *)(a1 + 520);
  float v3 = 1.0;
  if (!v2) {
    return v3;
  }
  gss::ClientStyleState<gss::PropertyID>::queryNightMode(v2, (BOOL *)&v16 + 1, (BOOL *)&v16);
  if (!HIBYTE(v16))
  {
    if (!(_BYTE)v16) {
      return v3;
    }
    uint64_t v8 = *(void *)(a1 + 16);
    unsigned __int8 v9 = atomic_load((unsigned __int8 *)(v8 + 2784));
    if ((v9 & 1) == 0) {
      std::__assoc_sub_state::wait(*(std::__assoc_sub_state **)(v8 + 2808));
    }
    uint64_t v10 = *(void *)(v8 + 120);
    char v11 = *(std::__shared_weak_count **)(v8 + 128);
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v10)
    {
      float v12 = *(float *)(v10 + 92) + -1.0;
      if (!v11) {
        return (float)(v12 * *(float *)(*(void *)(a1 + 520) + 256)) + 1.0;
      }
    }
    else
    {
      float v12 = 0.0;
      if (!v11) {
        return (float)(v12 * *(float *)(*(void *)(a1 + 520) + 256)) + 1.0;
      }
    }
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    return (float)(v12 * *(float *)(*(void *)(a1 + 520) + 256)) + 1.0;
  }
  uint64_t v4 = *(void *)(a1 + 16);
  unsigned __int8 v5 = atomic_load((unsigned __int8 *)(v4 + 2784));
  if ((_BYTE)v16)
  {
    if ((v5 & 1) == 0) {
      std::__assoc_sub_state::wait(*(std::__assoc_sub_state **)(v4 + 2808));
    }
    uint64_t v6 = *(void *)(v4 + 120);
    int v7 = *(std::__shared_weak_count **)(v4 + 128);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6) {
      float v3 = *(float *)(v6 + 92);
    }
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  else
  {
    if ((v5 & 1) == 0) {
      std::__assoc_sub_state::wait(*(std::__assoc_sub_state **)(v4 + 2808));
    }
    uint64_t v13 = *(void *)(v4 + 120);
    __int32 v14 = *(std::__shared_weak_count **)(v4 + 128);
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v13) {
      float v3 = *(float *)(v13 + 92);
    }
    if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
    return v3 + (float)((float)(1.0 - v3) * *(float *)(*(void *)(a1 + 520) + 256));
  }
  return v3;
}

void ggl::FlyoverRoadStrokeProcedural::DefaultPipelineState::~DefaultPipelineState(ggl::FlyoverRoadStrokeProcedural::DefaultPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::FlyoverRoadStrokeProcedural::DefaultPipelineSetup::textureIsEnabled(ggl::FlyoverRoadStrokeProcedural::DefaultPipelineSetup *this)
{
  return 0;
}

BOOL ggl::FlyoverRoadStrokeProcedural::DefaultPipelineSetup::constantDataIsEnabled(ggl::FlyoverRoadStrokeProcedural::DefaultPipelineSetup *this, unint64_t a2)
{
  return a2 < 5;
}

void ggl::FlyoverRoadStrokeProcedural::DefaultPipelineSetup::~DefaultPipelineSetup(ggl::FlyoverRoadStrokeProcedural::DefaultPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void *ggl::FlyoverRoadStrokeProcedural::DefaultPipelineSetup::DefaultPipelineSetup(void *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::PipelineSetup::PipelineSetup(a1, a2, (uint64_t)a3);
    if (!atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }
  else
  {
    ggl::PipelineSetup::PipelineSetup(a1, a2, 0);
  }
  *a1 = &unk_1EF560018;
  __int32 v15 = (uint64_t *)a1[8];
  uint64_t v16 = *a4;
  uint64_t v17 = a4[1];
  *__int32 v15 = *a4;
  v15[1] = 0;
  double v18 = (void *)a1[20];
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  long long v19 = (std::__shared_weak_count *)v18[1];
  *double v18 = v16;
  v18[1] = v17;
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  uint64_t v20 = a1[8];
  uint64_t v21 = *a5;
  uint64_t v22 = a5[1];
  *(void *)(v20 + 16) = *a5;
  *(void *)(v20 + 24) = 0;
  uint64_t v23 = a1[20];
  if (v22) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
  }
  unsigned int v24 = *(std::__shared_weak_count **)(v23 + 24);
  *(void *)(v23 + 16) = v21;
  *(void *)(v23 + 24) = v22;
  if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  uint64_t v25 = a1[8];
  uint64_t v26 = *a6;
  uint64_t v27 = a6[1];
  *(void *)(v25 + 32) = *a6;
  *(void *)(v25 + 40) = 0;
  uint64_t v28 = a1[20];
  if (v27) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
  }
  double v29 = *(std::__shared_weak_count **)(v28 + 40);
  *(void *)(v28 + 32) = v26;
  *(void *)(v28 + 40) = v27;
  if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  uint64_t v30 = a1[8];
  uint64_t v31 = *a7;
  uint64_t v32 = a7[1];
  *(void *)(v30 + 48) = *a7;
  *(void *)(v30 + 56) = 0;
  uint64_t v33 = a1[20];
  if (v32) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v32 + 8), 1uLL, memory_order_relaxed);
  }
  unsigned int v34 = *(std::__shared_weak_count **)(v33 + 56);
  *(void *)(v33 + 48) = v31;
  *(void *)(v33 + 56) = v32;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  uint64_t v35 = a1[8];
  uint64_t v36 = *a8;
  uint64_t v37 = a8[1];
  *(void *)(v35 + 64) = *a8;
  *(void *)(v35 + 72) = 0;
  uint64_t v38 = a1[20];
  if (v37) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v37 + 8), 1uLL, memory_order_relaxed);
  }
  double v39 = *(std::__shared_weak_count **)(v38 + 72);
  *(void *)(v38 + 64) = v36;
  *(void *)(v38 + 72) = v37;
  if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
    std::__shared_weak_count::__release_weak(v39);
  }
  return a1;
}

void *geo::Cache<unsigned long,geo::_retain_ptr<VKRoadSignArtwork * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::hash<unsigned long>,geo::LRUPolicy>::~Cache(void *a1)
{
  if (a1[8])
  {
    uint64_t v2 = a1 + 6;
    uint64_t v3 = a1[6];
    uint64_t v4 = (uint64_t *)a1[7];
    uint64_t v5 = *v4;
    *(void *)(v5 + 8) = *(void *)(v3 + 8);
    **(void **)(v3 + 8) = v5;
    a1[8] = 0;
    if (v4 != a1 + 6)
    {
      do
      {
        uint64_t v6 = (uint64_t *)v4[1];
        v4[3] = (uint64_t)&unk_1EF559778;

        operator delete(v4);
        uint64_t v4 = v6;
      }
      while (v6 != v2);
    }
  }
  int v7 = (void *)a1[3];
  if (v7)
  {
    do
    {
      uint64_t v8 = (void *)*v7;
      operator delete(v7);
      int v7 = v8;
    }
    while (v8);
  }
  unsigned __int8 v9 = (void *)a1[1];
  a1[1] = 0;
  if (v9) {
    operator delete(v9);
  }
  return a1;
}

void *geo::Cache<unsigned long,std::shared_ptr<md::LabelIcon>,std::hash<unsigned long>,geo::LRUPolicy>::~Cache(void *a1)
{
  if (a1[8])
  {
    uint64_t v2 = a1 + 6;
    uint64_t v3 = a1[6];
    uint64_t v4 = (uint64_t *)a1[7];
    uint64_t v5 = *v4;
    *(void *)(v5 + 8) = *(void *)(v3 + 8);
    **(void **)(v3 + 8) = v5;
    a1[8] = 0;
    if (v4 != a1 + 6)
    {
      do
      {
        uint64_t v6 = (uint64_t *)v4[1];
        int v7 = (std::__shared_weak_count *)v4[4];
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        operator delete(v4);
        uint64_t v4 = v6;
      }
      while (v6 != v2);
    }
  }
  uint64_t v8 = (void *)a1[3];
  if (v8)
  {
    do
    {
      unsigned __int8 v9 = (void *)*v8;
      operator delete(v8);
      uint64_t v8 = v9;
    }
    while (v9);
  }
  uint64_t v10 = (void *)a1[1];
  a1[1] = 0;
  if (v10) {
    operator delete(v10);
  }
  return a1;
}

void geo::_retain_ptr<VKRoadSignArtwork * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559778;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKRoadSignArtwork * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559778;

  return a1;
}

void VKLabelNavArtworkCache::~VKLabelNavArtworkCache(VKLabelNavArtworkCache *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (uint64_t *)*((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v3)
  {
    v3[7] = (uint64_t)&unk_1EF559018;
    uint64_t v4 = (const void *)v3[8];
    if (v4) {
      CFRelease(v4);
    }
    uint64_t v5 = (void *)v3[3];
    if (v5)
    {
      do
      {
        uint64_t v6 = (void *)*v5;
        (*(void (**)(uint64_t))(*(void *)v3[4] + 40))(v3[4]);
        uint64_t v5 = v6;
      }
      while (v6);
    }
    uint64_t v7 = *v3;
    *uint64_t v3 = 0;
    if (v7) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 40))(v3[2], v7, 8 * v3[1]);
    }
    MEMORY[0x1A6239270](v3, 0x10A0C4047D11187);
  }
  uint64_t v8 = (void *)*((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v8)
  {
    unsigned __int8 v9 = geo::Cache<unsigned long,std::shared_ptr<md::LabelIcon>,std::hash<unsigned long>,geo::LRUPolicy>::~Cache(v8);
    MEMORY[0x1A6239270](v9, 0x10A0C407D9D2971);
  }
  uint64_t v10 = *(void **)this;
  *(void *)this = 0;
  if (v10)
  {
    char v11 = geo::Cache<unsigned long,geo::_retain_ptr<VKRoadSignArtwork * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::hash<unsigned long>,geo::LRUPolicy>::~Cache(v10);
    MEMORY[0x1A6239270](v11, 0x10A0C407D9D2971);
  }
}

id VKLabelNavArtworkCache::getRoadSignArtwork(VKLabelNavArtworkCache *this, NSString *a2, const RoadSignMetrics *a3, const RoadSignColoring *a4, const md::RoadSignTextMetrics *a5)
{
  unsigned __int8 v9 = a2;
  unint64_t RoadSignKey = VKLabelNavArtworkCache::getRoadSignKey((VKLabelNavArtworkCache *)v9, 0, (double *)&a3->_orientation, (const RoadSignMetrics *)a5, (const md::RoadSignTextMetrics *)a4, v10);
  double v42 = &unk_1EF559778;
  id v43 = 0;
  uint64_t v11 = geo::LRUPolicy<unsigned long,geo::_retain_ptr<VKRoadSignArtwork * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::hash<unsigned long>>::get(*(void *)this + 48, *(void *)(*(void *)this + 8), *(void *)(*(void *)this + 16), RoadSignKey);
  if (*(void *)this + 48 != v11)
  {
    id v12 = v43;
    id v43 = *(id *)(v11 + 32);
    goto LABEL_19;
  }
  uint64_t v13 = *((void *)this + 2);
  long long v14 = *(_OWORD *)&a3->_horizontalMargin;
  v41[6] = *(_OWORD *)&a3->_signHeight;
  v41[7] = v14;
  long long v15 = *(_OWORD *)&a3->_glyphSize.height;
  v41[8] = *(_OWORD *)&a3->_cornerRadius;
  v41[9] = v15;
  long long v16 = *(_OWORD *)&a3->_arrowJoinCornerRadius;
  v41[2] = *(_OWORD *)&a3->_arrowLength;
  v41[3] = v16;
  long long v17 = *(_OWORD *)&a3->_strokeWeight;
  v41[4] = *(_OWORD *)&a3->_shadowOffset.height;
  v41[5] = v17;
  long long v18 = *(_OWORD *)&a3->_contentScale;
  v41[0] = *(_OWORD *)&a3->_orientation;
  v41[1] = v18;
  long long v19 = *((_OWORD *)a5 + 1);
  v31[0] = *(_OWORD *)a5;
  v31[1] = v19;
  v31[2] = *((_OWORD *)a5 + 2);
  uint64_t v20 = *((void *)a5 + 10);
  uint64_t v32 = *((void *)a5 + 6);
  uint64_t v35 = v20;
  if (*((char *)a5 + 79) < 0)
  {
    std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)&v33, *((void **)a5 + 7), *((void *)a5 + 8));
  }
  else
  {
    long long v33 = *(_OWORD *)((char *)a5 + 56);
    uint64_t v34 = *((void *)a5 + 9);
  }
  uint64_t v38 = *((void *)a5 + 14);
  if (*((char *)a5 + 111) < 0)
  {
    std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)&v36, *((void **)a5 + 11), *((void *)a5 + 12));
  }
  else
  {
    long long v36 = *(_OWORD *)((char *)a5 + 88);
    uint64_t v37 = *((void *)a5 + 13);
  }
  long long v39 = *(_OWORD *)((char *)a5 + 120);
  __int16 v40 = *((_WORD *)a5 + 68);
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v21 = (std::__shared_weak_count *)*((void *)this + 6);
  uint64_t v27 = *((void *)this + 5);
  uint64_t v28 = v21;
  if (v21) {
    atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  md::RoadSignArtworkGenerator::generateRoadSignArtwork(v13, v9, (uint64_t)v41, v31, (uint64_t)a4, &v29, &v27);
  id v12 = (id)objc_claimAutoreleasedReturnValue();
  if (v28) {
    std::__shared_weak_count::__release_weak(v28);
  }
  uint64_t v22 = v30;
  if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  if (SHIBYTE(v37) < 0)
  {
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v38 + 40))(v38, v36, v37 & 0x7FFFFFFFFFFFFFFFLL);
    if ((SHIBYTE(v34) & 0x80000000) == 0) {
      goto LABEL_18;
    }
LABEL_23:
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v35 + 40))(v35, v33, v34 & 0x7FFFFFFFFFFFFFFFLL);
    goto LABEL_18;
  }
  if (SHIBYTE(v34) < 0) {
    goto LABEL_23;
  }
LABEL_18:
  objc_storeStrong(&v43, v12);
  uint64_t v23 = *(void *)this;
  id v26 = v43;
  geo::Cache<unsigned long,geo::_retain_ptr<VKRoadSignArtwork * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::hash<unsigned long>,geo::LRUPolicy>::insert(v23, &RoadSignKey, v26);

LABEL_19:
  id v24 = v43;
  double v42 = &unk_1EF559778;

  return v24;
}

void sub_1A2373C04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, char a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (SHIBYTE(a26) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a27 + 40))(a27, a24, a26 & 0x7FFFFFFFFFFFFFFFLL);
  }
  *(void *)(v29 - 112) = v28;

  _Unwind_Resume(a1);
}

uint64_t VKLabelNavArtworkCache::getRoadSignKey(VKLabelNavArtworkCache *this, NSString *a2, double *a3, const RoadSignMetrics *a4, const md::RoadSignTextMetrics *a5, const RoadSignColoring *a6)
{
  uint64_t v10 = this;
  uint64_t v11 = v10;
  if (v10) {
    unint64_t v12 = [(VKLabelNavArtworkCache *)v10 hash];
  }
  else {
    unint64_t v12 = 0;
  }
  uint64_t v13 = *(unsigned __int8 *)a3;
  double v14 = a3[1];
  double v15 = a3[2];
  double v184 = a3[3];
  double v185 = a3[4];
  double v186 = a3[7];
  double v187 = a3[8];
  double v188 = a3[9];
  double v189 = a3[10];
  double v190 = a3[12];
  double v191 = a3[13];
  double v192 = a3[14];
  double v193 = a3[15];
  double v194 = a3[16];
  double v195 = a3[17];
  double v196 = a3[18];
  double v197 = a3[19];
  double v16 = *(double *)&a4->_orientation;
  double scale = a4->_scale;
  double contentScale = a4->_contentScale;
  double arrowWeight = a4->_arrowWeight;
  double arrowLength = a4->_arrowLength;
  double arrowTipCornerRadius = a4->_arrowTipCornerRadius;
  int shadowRadius_high = SHIBYTE(a4->_shadowRadius);
  if (shadowRadius_high >= 0) {
    *(void *)&CGFloat width = &a4->_shadowOffset;
  }
  else {
    CGFloat width = a4->_shadowOffset.width;
  }
  if (shadowRadius_high >= 0) {
    unint64_t v23 = HIBYTE(a4->_shadowRadius);
  }
  else {
    unint64_t v23 = *(void *)&a4->_shadowOffset.height;
  }
  double arrowJoinCornerRadius = a4->_arrowJoinCornerRadius;
  unint64_t v25 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](*(uint64_t **)&width, v23);
  double innerStrokeWeight = a4->_innerStrokeWeight;
  p_double innerStrokeWeight = &a4->_innerStrokeWeight;
  double v26 = innerStrokeWeight;
  int v29 = *((char *)p_innerStrokeWeight + 23);
  if (v29 >= 0) {
    uint64_t v30 = (uint64_t *)p_innerStrokeWeight;
  }
  else {
    uint64_t v30 = *(uint64_t **)&v26;
  }
  if (v29 >= 0) {
    unint64_t v31 = *((unsigned __int8 *)p_innerStrokeWeight + 23);
  }
  else {
    unint64_t v31 = *((void *)p_innerStrokeWeight + 1);
  }
  unint64_t v32 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v30, v31);
  if (!*(unsigned char *)a5)
  {
    unint64_t v41 = 0;
    if (!*((unsigned char *)a5 + 3)) {
      goto LABEL_35;
    }
    goto LABEL_26;
  }
  double v33 = *((double *)a5 + 2);
  unint64_t v34 = *((void *)a5 + 1) - 0x61C8864680B583EBLL;
  if (*((double *)a5 + 1) == 0.0) {
    unint64_t v34 = 0x9E3779B97F4A7C15;
  }
  unint64_t v35 = *(void *)&v33 - 0x61C8864680B583EBLL;
  if (v33 == 0.0) {
    unint64_t v35 = 0x9E3779B97F4A7C15;
  }
  double v36 = *((double *)a5 + 4);
  unint64_t v37 = ((v34 >> 2) + (v34 << 6) + v35) ^ v34;
  uint64_t v38 = *((void *)a5 + 3) - 0x61C8864680B583EBLL;
  if (*((double *)a5 + 3) == 0.0) {
    uint64_t v38 = 0x9E3779B97F4A7C15;
  }
  unint64_t v39 = ((v37 >> 2) + (v37 << 6) + v38) ^ v37;
  unint64_t v40 = *(void *)&v36 - 0x61C8864680B583EBLL;
  if (v36 == 0.0) {
    unint64_t v40 = 0x9E3779B97F4A7C15;
  }
  unint64_t v41 = ((v39 >> 2) + (v39 << 6) + v40) ^ v39;
  if (*((unsigned char *)a5 + 3))
  {
LABEL_26:
    double v42 = *((double *)a5 + 14);
    uint64_t v43 = *((void *)a5 + 13) - 0x61C8864680B583EBLL;
    if (*((double *)a5 + 13) == 0.0) {
      uint64_t v43 = 0x9E3779B97F4A7C15;
    }
    unint64_t v44 = *(void *)&v42 - 0x61C8864680B583EBLL;
    if (v42 == 0.0) {
      unint64_t v44 = 0x9E3779B97F4A7C15;
    }
    double v45 = *((double *)a5 + 16);
    unint64_t v46 = (((((v41 >> 2) + (v41 << 6) + v43) ^ v41) >> 2) + ((((v41 >> 2) + (v41 << 6) + v43) ^ v41) << 6) + v44) ^ ((v41 >> 2) + (v41 << 6) + v43) ^ v41;
    uint64_t v47 = *((void *)a5 + 15) - 0x61C8864680B583EBLL;
    if (*((double *)a5 + 15) == 0.0) {
      uint64_t v47 = 0x9E3779B97F4A7C15;
    }
    unint64_t v48 = ((v46 >> 2) + (v46 << 6) + v47) ^ v46;
    unint64_t v49 = *(void *)&v45 - 0x61C8864680B583EBLL;
    if (v45 == 0.0) {
      unint64_t v49 = 0x9E3779B97F4A7C15;
    }
    unint64_t v41 = ((v48 >> 2) + (v48 << 6) + v49) ^ v48;
  }
LABEL_35:
  if (*((unsigned char *)a5 + 4))
  {
    double v50 = *((double *)a5 + 18);
    uint64_t v51 = *((void *)a5 + 17) - 0x61C8864680B583EBLL;
    if (*((double *)a5 + 17) == 0.0) {
      uint64_t v51 = 0x9E3779B97F4A7C15;
    }
    unint64_t v52 = *(void *)&v50 - 0x61C8864680B583EBLL;
    if (v50 == 0.0) {
      unint64_t v52 = 0x9E3779B97F4A7C15;
    }
    double v53 = *((double *)a5 + 20);
    unint64_t v54 = (((((v41 >> 2) + (v41 << 6) + v51) ^ v41) >> 2) + ((((v41 >> 2) + (v41 << 6) + v51) ^ v41) << 6) + v52) ^ ((v41 >> 2) + (v41 << 6) + v51) ^ v41;
    uint64_t v55 = *((void *)a5 + 19) - 0x61C8864680B583EBLL;
    if (*((double *)a5 + 19) == 0.0) {
      uint64_t v55 = 0x9E3779B97F4A7C15;
    }
    unint64_t v56 = ((v54 >> 2) + (v54 << 6) + v55) ^ v54;
    unint64_t v57 = *(void *)&v53 - 0x61C8864680B583EBLL;
    if (v53 == 0.0) {
      unint64_t v57 = 0x9E3779B97F4A7C15;
    }
    unint64_t v41 = ((v56 >> 2) + (v56 << 6) + v57) ^ v56;
  }
  if (*((unsigned char *)a5 + 1))
  {
    double v58 = *((double *)a5 + 6);
    uint64_t v59 = *((void *)a5 + 5) - 0x61C8864680B583EBLL;
    if (*((double *)a5 + 5) == 0.0) {
      uint64_t v59 = 0x9E3779B97F4A7C15;
    }
    unint64_t v60 = *(void *)&v58 - 0x61C8864680B583EBLL;
    if (v58 == 0.0) {
      unint64_t v60 = 0x9E3779B97F4A7C15;
    }
    double v61 = *((double *)a5 + 8);
    uint64_t v62 = *((void *)a5 + 7) - 0x61C8864680B583EBLL;
    if (*((double *)a5 + 7) == 0.0) {
      uint64_t v62 = 0x9E3779B97F4A7C15;
    }
    unint64_t v63 = *(void *)&v61 - 0x61C8864680B583EBLL;
    if (v61 == 0.0) {
      unint64_t v63 = 0x9E3779B97F4A7C15;
    }
    double v64 = *((double *)a5 + 10);
    uint64_t v65 = *((void *)a5 + 9) - 0x61C8864680B583EBLL;
    if (*((double *)a5 + 9) == 0.0) {
      uint64_t v65 = 0x9E3779B97F4A7C15;
    }
    unint64_t v66 = *(void *)&v64 - 0x61C8864680B583EBLL;
    if (v64 == 0.0) {
      unint64_t v66 = 0x9E3779B97F4A7C15;
    }
    double v67 = *((double *)a5 + 12);
    unint64_t v68 = (((((v41 >> 2) + (v41 << 6) + v59) ^ v41) >> 2) + ((((v41 >> 2) + (v41 << 6) + v59) ^ v41) << 6) + v60) ^ ((v41 >> 2) + (v41 << 6) + v59) ^ v41;
    unint64_t v69 = ((v68 >> 2) + (v68 << 6) + v62) ^ v68;
    unint64_t v70 = ((v69 >> 2) + (v69 << 6) + v63) ^ v69;
    unint64_t v71 = ((v70 >> 2) + (v70 << 6) + v65) ^ v70;
    unint64_t v72 = ((v71 >> 2) + (v71 << 6) + v66) ^ v71;
    uint64_t v73 = *((void *)a5 + 11) - 0x61C8864680B583EBLL;
    if (*((double *)a5 + 11) == 0.0) {
      uint64_t v73 = 0x9E3779B97F4A7C15;
    }
    unint64_t v74 = ((v72 >> 2) + (v72 << 6) + v73) ^ v72;
    unint64_t v75 = *(void *)&v67 - 0x61C8864680B583EBLL;
    if (v67 == 0.0) {
      unint64_t v75 = 0x9E3779B97F4A7C15;
    }
    unint64_t v41 = ((v74 >> 2) + (v74 << 6) + v75) ^ v74;
  }
  if (*((unsigned char *)a5 + 5))
  {
    double v76 = *((double *)a5 + 22);
    uint64_t v77 = *((void *)a5 + 21) - 0x61C8864680B583EBLL;
    if (*((double *)a5 + 21) == 0.0) {
      uint64_t v77 = 0x9E3779B97F4A7C15;
    }
    unint64_t v78 = *(void *)&v76 - 0x61C8864680B583EBLL;
    if (v76 == 0.0) {
      unint64_t v78 = 0x9E3779B97F4A7C15;
    }
    double v79 = *((double *)a5 + 24);
    unint64_t v80 = (((((v41 >> 2) + (v41 << 6) + v77) ^ v41) >> 2) + ((((v41 >> 2) + (v41 << 6) + v77) ^ v41) << 6) + v78) ^ ((v41 >> 2) + (v41 << 6) + v77) ^ v41;
    uint64_t v81 = *((void *)a5 + 23) - 0x61C8864680B583EBLL;
    if (*((double *)a5 + 23) == 0.0) {
      uint64_t v81 = 0x9E3779B97F4A7C15;
    }
    unint64_t v82 = ((v80 >> 2) + (v80 << 6) + v81) ^ v80;
    unint64_t v83 = *(void *)&v79 - 0x61C8864680B583EBLL;
    if (v79 == 0.0) {
      unint64_t v83 = 0x9E3779B97F4A7C15;
    }
    unint64_t v41 = ((v82 >> 2) + (v82 << 6) + v83) ^ v82;
  }
  if (*((unsigned char *)a5 + 6))
  {
    double v84 = *((double *)a5 + 26);
    uint64_t v85 = *((void *)a5 + 25) - 0x61C8864680B583EBLL;
    if (*((double *)a5 + 25) == 0.0) {
      uint64_t v85 = 0x9E3779B97F4A7C15;
    }
    unint64_t v86 = *(void *)&v84 - 0x61C8864680B583EBLL;
    if (v84 == 0.0) {
      unint64_t v86 = 0x9E3779B97F4A7C15;
    }
    double v87 = *((double *)a5 + 28);
    unint64_t v88 = (((((v41 >> 2) + (v41 << 6) + v85) ^ v41) >> 2) + ((((v41 >> 2) + (v41 << 6) + v85) ^ v41) << 6) + v86) ^ ((v41 >> 2) + (v41 << 6) + v85) ^ v41;
    uint64_t v89 = *((void *)a5 + 27) - 0x61C8864680B583EBLL;
    if (*((double *)a5 + 27) == 0.0) {
      uint64_t v89 = 0x9E3779B97F4A7C15;
    }
    unint64_t v90 = ((v88 >> 2) + (v88 << 6) + v89) ^ v88;
    unint64_t v91 = *(void *)&v87 - 0x61C8864680B583EBLL;
    if (v87 == 0.0) {
      unint64_t v91 = 0x9E3779B97F4A7C15;
    }
    unint64_t v41 = ((v90 >> 2) + (v90 << 6) + v91) ^ v90;
  }
  double v93 = p_innerStrokeWeight[4];
  double v92 = p_innerStrokeWeight[5];
  if (*((unsigned char *)a5 + 7))
  {
    double v94 = *((double *)a5 + 30);
    uint64_t v95 = *((void *)a5 + 29) - 0x61C8864680B583EBLL;
    if (*((double *)a5 + 29) == 0.0) {
      uint64_t v95 = 0x9E3779B97F4A7C15;
    }
    unint64_t v96 = *(void *)&v94 - 0x61C8864680B583EBLL;
    if (v94 == 0.0) {
      unint64_t v96 = 0x9E3779B97F4A7C15;
    }
    double v97 = *((double *)a5 + 32);
    unint64_t v98 = (((((v41 >> 2) + (v41 << 6) + v95) ^ v41) >> 2) + ((((v41 >> 2) + (v41 << 6) + v95) ^ v41) << 6) + v96) ^ ((v41 >> 2) + (v41 << 6) + v95) ^ v41;
    uint64_t v99 = *((void *)a5 + 31) - 0x61C8864680B583EBLL;
    if (*((double *)a5 + 31) == 0.0) {
      uint64_t v99 = 0x9E3779B97F4A7C15;
    }
    unint64_t v100 = ((v98 >> 2) + (v98 << 6) + v99) ^ v98;
    unint64_t v101 = *(void *)&v97 - 0x61C8864680B583EBLL;
    if (v97 == 0.0) {
      unint64_t v101 = 0x9E3779B97F4A7C15;
    }
    unint64_t v41 = ((v100 >> 2) + (v100 << 6) + v101) ^ v100;
  }
  if (*((unsigned char *)p_innerStrokeWeight + 49)) {
    unint64_t v102 = 0x9E3779B97F4A7C16;
  }
  else {
    unint64_t v102 = 0x9E3779B97F4A7C15;
  }
  unint64_t v103 = *(void *)&v16 - 0x61C8864680B583EBLL;
  if (v16 == 0.0) {
    unint64_t v103 = 0x9E3779B97F4A7C15;
  }
  unint64_t v104 = *(void *)&scale - 0x61C8864680B583EBLL;
  if (scale == 0.0) {
    unint64_t v104 = 0x9E3779B97F4A7C15;
  }
  unint64_t v105 = ((v103 >> 2) + (v103 << 6) + v104) ^ v103;
  double v106 = round(v16 * contentScale * scale);
  uint64_t v107 = *(void *)&v106 - 0x61C8864680B583EBLL;
  if (v106 == 0.0) {
    uint64_t v107 = 0x9E3779B97F4A7C15;
  }
  unint64_t v108 = (v107 + (v105 << 6) + (v105 >> 2)) ^ v105;
  double v109 = round(v16 * arrowWeight * scale);
  uint64_t v110 = *(void *)&v109 - 0x61C8864680B583EBLL;
  if (v109 == 0.0) {
    uint64_t v110 = 0x9E3779B97F4A7C15;
  }
  unint64_t v111 = (v110 + (v108 << 6) + (v108 >> 2)) ^ v108;
  double v112 = round(v16 * arrowLength * scale);
  uint64_t v113 = *(void *)&v112 - 0x61C8864680B583EBLL;
  if (v112 == 0.0) {
    uint64_t v113 = 0x9E3779B97F4A7C15;
  }
  unint64_t v114 = (v113 + (v111 << 6) + (v111 >> 2)) ^ v111;
  double v115 = round(v16 * arrowTipCornerRadius * scale);
  uint64_t v116 = *(void *)&v115 - 0x61C8864680B583EBLL;
  if (v115 == 0.0) {
    uint64_t v116 = 0x9E3779B97F4A7C15;
  }
  unint64_t v117 = (v116 + (v114 << 6) + (v114 >> 2)) ^ v114;
  double v118 = round(v16 * arrowJoinCornerRadius * scale);
  uint64_t v119 = *(void *)&v118 - 0x61C8864680B583EBLL;
  if (v118 == 0.0) {
    uint64_t v119 = 0x9E3779B97F4A7C15;
  }
  unint64_t v120 = (v119 + (v117 << 6) + (v117 >> 2)) ^ v117;
  unint64_t v121 = (v25 - 0x61C8864680B583EBLL + (v120 << 6) + (v120 >> 2)) ^ v120;
  unint64_t v122 = (v32 - 0x61C8864680B583EBLL + (v121 << 6) + (v121 >> 2)) ^ v121;
  unint64_t v123 = *(void *)&v93 - 0x61C8864680B583EBLL;
  if (v93 == 0.0) {
    unint64_t v123 = 0x9E3779B97F4A7C15;
  }
  unint64_t v124 = (v123 + (v122 << 6) + (v122 >> 2)) ^ v122;
  unint64_t v125 = *(void *)&v92 - 0x61C8864680B583EBLL;
  if (v92 == 0.0) {
    unint64_t v125 = 0x9E3779B97F4A7C15;
  }
  unint64_t v126 = (v125 + (v124 << 6) + (v124 >> 2)) ^ v124;
  unint64_t v127 = (*((unsigned __int8 *)p_innerStrokeWeight + 48) - 0x61C8864680B583EBLL + (v126 << 6) + (v126 >> 2)) ^ v126;
  unint64_t v128 = (v102 + (v127 << 6) + (v127 >> 2)) ^ v127;
  unint64_t v129 = *(void *)&v14 - 0x61C8864680B583EBLL;
  if (v14 == 0.0) {
    unint64_t v129 = 0x9E3779B97F4A7C15;
  }
  unint64_t v131 = *(void *)&v15 - 0x61C8864680B583EBLL;
  if (v15 == 0.0) {
    unint64_t v131 = 0x9E3779B97F4A7C15;
  }
  unint64_t v130 = (((unint64_t)(v13 - 0x61C8864680B583EBLL) >> 2) + ((v13 - 0x61C8864680B583EBLL) << 6) + v129) ^ (v13 - 0x61C8864680B583EBLL);
  unint64_t v132 = (v131 + (v130 << 6) + (v130 >> 2)) ^ v130;
  double v133 = round(v14 * v184 * v15);
  uint64_t v134 = *(void *)&v133 - 0x61C8864680B583EBLL;
  if (v133 == 0.0) {
    uint64_t v134 = 0x9E3779B97F4A7C15;
  }
  unint64_t v135 = (v134 + (v132 << 6) + (v132 >> 2)) ^ v132;
  double v136 = round(v14 * v185 * v15);
  uint64_t v137 = *(void *)&v136 - 0x61C8864680B583EBLL;
  if (v136 == 0.0) {
    uint64_t v137 = 0x9E3779B97F4A7C15;
  }
  unint64_t v138 = (v137 + (v135 << 6) + (v135 >> 2)) ^ v135;
  double v139 = round(v15 * v14 * v186);
  uint64_t v140 = *(void *)&v139 - 0x61C8864680B583EBLL;
  if (v139 == 0.0) {
    uint64_t v140 = 0x9E3779B97F4A7C15;
  }
  unint64_t v141 = (v140 + (v138 << 6) + (v138 >> 2)) ^ v138;
  double v142 = round(v15 * v14 * v187);
  uint64_t v143 = *(void *)&v142 - 0x61C8864680B583EBLL;
  if (v142 == 0.0) {
    uint64_t v143 = 0x9E3779B97F4A7C15;
  }
  unint64_t v144 = (v143 + (v141 << 6) + (v141 >> 2)) ^ v141;
  double v145 = round(v14 * v188 * v15);
  uint64_t v146 = *(void *)&v145 - 0x61C8864680B583EBLL;
  if (v145 == 0.0) {
    uint64_t v146 = 0x9E3779B97F4A7C15;
  }
  unint64_t v147 = (v146 + (v144 << 6) + (v144 >> 2)) ^ v144;
  double v148 = round(v14 * v189 * v15);
  uint64_t v149 = *(void *)&v148 - 0x61C8864680B583EBLL;
  if (v148 == 0.0) {
    uint64_t v149 = 0x9E3779B97F4A7C15;
  }
  unint64_t v150 = (v149 + (v147 << 6) + (v147 >> 2)) ^ v147;
  double v151 = round(v14 * v190 * v15);
  uint64_t v152 = *(void *)&v151 - 0x61C8864680B583EBLL;
  if (v151 == 0.0) {
    uint64_t v152 = 0x9E3779B97F4A7C15;
  }
  unint64_t v153 = (v152 + (v150 << 6) + (v150 >> 2)) ^ v150;
  double v154 = round(v14 * v191 * v15);
  uint64_t v155 = *(void *)&v154 - 0x61C8864680B583EBLL;
  if (v154 == 0.0) {
    uint64_t v155 = 0x9E3779B97F4A7C15;
  }
  unint64_t v156 = (v155 + (v153 << 6) + (v153 >> 2)) ^ v153;
  double v157 = round(v14 * v192 * v15);
  uint64_t v158 = *(void *)&v157 - 0x61C8864680B583EBLL;
  if (v157 == 0.0) {
    uint64_t v158 = 0x9E3779B97F4A7C15;
  }
  unint64_t v159 = (v158 + (v156 << 6) + (v156 >> 2)) ^ v156;
  double v160 = round(v14 * v193 * v15);
  uint64_t v161 = *(void *)&v160 - 0x61C8864680B583EBLL;
  if (v160 == 0.0) {
    uint64_t v161 = 0x9E3779B97F4A7C15;
  }
  unint64_t v162 = (v161 + (v159 << 6) + (v159 >> 2)) ^ v159;
  double v163 = round(v14 * v194 * v15);
  uint64_t v164 = *(void *)&v163 - 0x61C8864680B583EBLL;
  if (v163 == 0.0) {
    uint64_t v164 = 0x9E3779B97F4A7C15;
  }
  unint64_t v165 = (v164 + (v162 << 6) + (v162 >> 2)) ^ v162;
  double v166 = ceil(v195 * v14);
  double v167 = floor(v195 * v14);
  if (v14 < 1.0) {
    double v167 = v166;
  }
  double v168 = ceil(v196 * v14);
  double v169 = floor(v196 * v14);
  if (v14 < 1.0) {
    double v169 = v168;
  }
  double v170 = ceil(v197 * v14);
  double v171 = floor(v197 * v14);
  if (v14 < 1.0) {
    double v171 = v170;
  }
  unint64_t v172 = *(void *)&v167 - 0x61C8864680B583EBLL;
  if (v167 == 0.0) {
    unint64_t v172 = 0x9E3779B97F4A7C15;
  }
  unint64_t v173 = (v172 + (v165 << 6) + (v165 >> 2)) ^ v165;
  unint64_t v174 = *(void *)&v169 - 0x61C8864680B583EBLL;
  if (v169 == 0.0) {
    unint64_t v174 = 0x9E3779B97F4A7C15;
  }
  unint64_t v175 = (v174 + (v173 << 6) + (v173 >> 2)) ^ v173;
  unint64_t v176 = *(void *)&v171 - 0x61C8864680B583EBLL;
  if (v171 == 0.0) {
    unint64_t v176 = 0x9E3779B97F4A7C15;
  }
  uint64_t v177 = ((v176 + (v175 << 6) + (v175 >> 2)) ^ v175) - 0x61C8864680B583EBLL;
  unint64_t v178 = ((unint64_t)&a2[8 * v12 - 0xC3910C8D016B07ELL].super.isa + (v12 >> 2) + 5) ^ v12;
  unint64_t v179 = (v177 + (v178 << 6) + (v178 >> 2)) ^ v178;
  unint64_t v180 = ((v179 << 6) - 0x61C8864680B583EBLL + (v179 >> 2) + v128) ^ v179;
  uint64_t v181 = ((v180 << 6) - 0x61C8864680B583EBLL + (v180 >> 2) + v41) ^ v180;

  return v181;
}

void sub_1A23746F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t geo::LRUPolicy<unsigned long,geo::_retain_ptr<VKRoadSignArtwork * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::hash<unsigned long>>::get(uint64_t result, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (a3)
  {
    uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
    {
      unint64_t v5 = a4;
      if (a4 >= a3) {
        unint64_t v5 = a4 % a3;
      }
    }
    else
    {
      unint64_t v5 = (a3 - 1) & a4;
    }
    uint64_t v6 = *(void **)(a2 + 8 * v5);
    if (v6)
    {
      uint64_t v7 = (void *)*v6;
      if (v7)
      {
        if (v4.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v9 = v7[1];
            if (v9 == a4)
            {
              if (v7[2] == a4) {
                goto LABEL_22;
              }
            }
            else if ((v9 & (a3 - 1)) != v5)
            {
              return result;
            }
            uint64_t v7 = (void *)*v7;
            if (!v7) {
              return result;
            }
          }
        }
        do
        {
          unint64_t v8 = v7[1];
          if (v8 == a4)
          {
            if (v7[2] == a4)
            {
LABEL_22:
              uint64_t v10 = *(uint64_t **)(result + 8);
              uint64_t v11 = (uint64_t *)v7[3];
              if (v10 == v11) {
                return *(void *)(result + 8);
              }
              unint64_t v12 = (uint64_t *)v11[1];
              if (v12 == v10) {
                return *(void *)(result + 8);
              }
              uint64_t v13 = *v11;
              *(void *)(v13 + 8) = v12;
              *(void *)v11[1] = v13;
              uint64_t v14 = *v10;
              *(void *)(v14 + 8) = v11;
              *uint64_t v11 = v14;
              *uint64_t v10 = (uint64_t)v11;
              v11[1] = (uint64_t)v10;
              return *(void *)(result + 8);
            }
          }
          else
          {
            if (v8 >= a3) {
              v8 %= a3;
            }
            if (v8 != v5) {
              return result;
            }
          }
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
    }
  }
  return result;
}

void geo::Cache<unsigned long,geo::_retain_ptr<VKRoadSignArtwork * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::hash<unsigned long>,geo::LRUPolicy>::insert(uint64_t a1, unint64_t *a2, void *a3)
{
  uint64_t v6 = (void **)(a1 + 8);
  id v71 = a3;
  unint64_t v7 = *a2;
  int8x8_t v8 = *(int8x8_t *)(a1 + 16);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = *a2;
      if (v7 >= *(void *)&v8) {
        unint64_t v10 = v7 % *(void *)&v8;
      }
    }
    else
    {
      unint64_t v10 = (*(void *)&v8 - 1) & v7;
    }
    uint64_t v11 = (void **)*((void *)*v6 + v10);
    if (v11)
    {
      unint64_t v12 = *v11;
      if (*v11)
      {
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v13 = *(void *)&v8 - 1;
          while (1)
          {
            uint64_t v15 = v12[1];
            if (v15 == v7)
            {
              if (v12[2] == v7) {
                goto LABEL_22;
              }
            }
            else if ((v15 & v13) != v10)
            {
              goto LABEL_25;
            }
            unint64_t v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_25;
            }
          }
        }
        do
        {
          unint64_t v14 = v12[1];
          if (v14 == v7)
          {
            if (v12[2] == v7)
            {
LABEL_22:
              double v16 = (uint64_t *)v12[3];
              uint64_t v17 = *v16;
              *(void *)(v17 + 8) = v16[1];
              *(void *)v16[1] = v17;
              --*(void *)(a1 + 64);
              v16[3] = (uint64_t)&unk_1EF559778;

              operator delete(v16);
              std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)&__p, v6, v12);
              if (__p) {
                operator delete(__p);
              }
              unint64_t v7 = *a2;
              break;
            }
          }
          else
          {
            if (v14 >= *(void *)&v8) {
              v14 %= *(void *)&v8;
            }
            if (v14 != v10) {
              break;
            }
          }
          unint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_25:
  long long v18 = operator new(0x30uLL);
  *long long v18 = 0;
  v18[1] = 0;
  uint64_t v18[2] = v7;
  v18[3] = &unk_1EF559778;
  v18[4] = 0;
  id v19 = v71;
  uint64_t v20 = (void *)v18[4];
  v18[4] = v19;

  uint64_t v21 = *(void **)(a1 + 56);
  *long long v18 = a1 + 48;
  v18[1] = v21;
  *uint64_t v21 = v18;
  uint64_t v22 = *(void *)(a1 + 64) + 1;
  *(void *)(a1 + 56) = v18;
  *(void *)(a1 + 64) = v22;
  unint64_t v23 = *a2;
  unint64_t v24 = *(void *)(a1 + 16);
  if (v24)
  {
    uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v24);
    v25.i16[0] = vaddlv_u8(v25);
    if (v25.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v23 >= v24) {
        unint64_t v3 = v23 % v24;
      }
    }
    else
    {
      unint64_t v3 = (v24 - 1) & v23;
    }
    double v26 = (void *)*((void *)*v6 + v3);
    if (v26)
    {
      uint64_t v27 = (void *)*v26;
      if (v27)
      {
        if (v25.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v29 = v27[1];
            if (v29 == v23)
            {
              if (v27[2] == v23) {
                goto LABEL_106;
              }
            }
            else if ((v29 & (v24 - 1)) != v3)
            {
              goto LABEL_46;
            }
            uint64_t v27 = (void *)*v27;
            if (!v27) {
              goto LABEL_46;
            }
          }
        }
        do
        {
          unint64_t v28 = v27[1];
          if (v28 == v23)
          {
            if (v27[2] == v23) {
              goto LABEL_106;
            }
          }
          else
          {
            if (v28 >= v24) {
              v28 %= v24;
            }
            if (v28 != v3) {
              break;
            }
          }
          uint64_t v27 = (void *)*v27;
        }
        while (v27);
      }
    }
  }
LABEL_46:
  uint64_t v30 = operator new(0x20uLL);
  void *v30 = 0;
  v30[1] = v23;
  v30[2] = v23;
  v30[3] = v18;
  float v31 = (float)(unint64_t)(*(void *)(a1 + 32) + 1);
  float v32 = *(float *)(a1 + 40);
  if (!v24 || (float)(v32 * (float)v24) < v31)
  {
    BOOL v33 = 1;
    if (v24 >= 3) {
      BOOL v33 = (v24 & (v24 - 1)) != 0;
    }
    unint64_t v34 = v33 | (2 * v24);
    unint64_t v35 = vcvtps_u32_f32(v31 / v32);
    if (v34 <= v35) {
      size_t prime = v35;
    }
    else {
      size_t prime = v34;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v24 = *(void *)(a1 + 16);
    }
    if (prime <= v24)
    {
      if (prime >= v24) {
        goto LABEL_83;
      }
      unint64_t v48 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 32) / *(float *)(a1 + 40));
      if (v24 < 3 || (uint8x8_t v49 = (uint8x8_t)vcnt_s8((int8x8_t)v24), v49.i16[0] = vaddlv_u8(v49), v49.u32[0] > 1uLL))
      {
        unint64_t v48 = std::__next_prime(v48);
      }
      else
      {
        uint64_t v50 = 1 << -(char)__clz(v48 - 1);
        if (v48 >= 2) {
          unint64_t v48 = v50;
        }
      }
      if (prime <= v48) {
        size_t prime = v48;
      }
      if (prime >= v24)
      {
        unint64_t v24 = *(void *)(a1 + 16);
LABEL_83:
        if ((v24 & (v24 - 1)) != 0)
        {
          if (v23 >= v24) {
            unint64_t v3 = v23 % v24;
          }
          else {
            unint64_t v3 = v23;
          }
        }
        else
        {
          unint64_t v3 = (v24 - 1) & v23;
        }
        goto LABEL_96;
      }
      if (!prime)
      {
        unint64_t v70 = *v6;
        *uint64_t v6 = 0;
        if (v70) {
          operator delete(v70);
        }
        unint64_t v24 = 0;
        *(void *)(a1 + 16) = 0;
        goto LABEL_83;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v37 = operator new(8 * prime);
    uint64_t v38 = *v6;
    *uint64_t v6 = v37;
    if (v38) {
      operator delete(v38);
    }
    uint64_t v39 = 0;
    *(void *)(a1 + 16) = prime;
    do
      *((void *)*v6 + v39++) = 0;
    while (prime != v39);
    uint64_t v41 = a1 + 24;
    unint64_t v40 = *(void **)(a1 + 24);
    if (!v40)
    {
LABEL_82:
      unint64_t v24 = prime;
      goto LABEL_83;
    }
    size_t v42 = v40[1];
    size_t v43 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v44 = v42 & v43;
      *((void *)*v6 + v44) = v41;
      for (uint64_t i = (void *)*v40; *v40; uint64_t i = (void *)*v40)
      {
        size_t v46 = i[1] & v43;
        if (v46 == v44)
        {
          unint64_t v40 = i;
        }
        else if (*((void *)*v6 + v46))
        {
          void *v40 = *i;
          uint64_t v47 = 8 * v46;
          void *i = **(void **)((char *)*v6 + v47);
          **(void **)((char *)*v6 + v47) = i;
        }
        else
        {
          *((void *)*v6 + v46) = v40;
          unint64_t v40 = i;
          size_t v44 = v46;
        }
      }
      goto LABEL_82;
    }
    if (v42 >= prime) {
      v42 %= prime;
    }
    *((void *)*v6 + v42) = v41;
    uint64_t v51 = (void *)*v40;
    if (!*v40) {
      goto LABEL_82;
    }
    while (1)
    {
      size_t v53 = v51[1];
      if (v53 >= prime) {
        v53 %= prime;
      }
      if (v53 != v42)
      {
        if (!*((void *)*v6 + v53))
        {
          *((void *)*v6 + v53) = v40;
          goto LABEL_87;
        }
        void *v40 = *v51;
        uint64_t v52 = 8 * v53;
        *uint64_t v51 = **(void **)((char *)*v6 + v52);
        **(void **)((char *)*v6 + v52) = v51;
        uint64_t v51 = v40;
      }
      size_t v53 = v42;
LABEL_87:
      unint64_t v40 = v51;
      uint64_t v51 = (void *)*v51;
      size_t v42 = v53;
      if (!v51) {
        goto LABEL_82;
      }
    }
  }
LABEL_96:
  unint64_t v54 = *v6;
  uint64_t v55 = (void *)*((void *)*v6 + v3);
  if (v55)
  {
    void *v30 = *v55;
LABEL_104:
    *uint64_t v55 = v30;
    goto LABEL_105;
  }
  void *v30 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v30;
  v54[v3] = a1 + 24;
  if (*v30)
  {
    unint64_t v56 = *(void *)(*v30 + 8);
    if ((v24 & (v24 - 1)) != 0)
    {
      if (v56 >= v24) {
        v56 %= v24;
      }
    }
    else
    {
      v56 &= v24 - 1;
    }
    uint64_t v55 = (char *)*v6 + 8 * v56;
    goto LABEL_104;
  }
LABEL_105:
  ++*(void *)(a1 + 32);
LABEL_106:

  while (*(void *)(a1 + 64) > *(void *)a1)
  {
    uint64_t v57 = *(void *)(a1 + 48);
    __p = *(void **)(v57 + 16);
    uint64_t v73 = &unk_1EF559778;
    id v74 = 0;
    id v58 = *(id *)(v57 + 32);
    id v59 = v74;
    id v74 = v58;

    unint64_t v60 = *(uint64_t **)(a1 + 48);
    uint64_t v61 = *v60;
    *(void *)(v61 + 8) = v60[1];
    *(void *)v60[1] = v61;
    --*(void *)(a1 + 64);
    v60[3] = (uint64_t)&unk_1EF559778;

    operator delete(v60);
    unint64_t v62 = *(void *)(a1 + 16);
    if (v62)
    {
      uint8x8_t v63 = (uint8x8_t)vcnt_s8((int8x8_t)v62);
      v63.i16[0] = vaddlv_u8(v63);
      if (v63.u32[0] > 1uLL)
      {
        unint64_t v64 = (unint64_t)__p;
        if ((unint64_t)__p >= v62) {
          unint64_t v64 = (unint64_t)__p % v62;
        }
      }
      else
      {
        unint64_t v64 = (v62 - 1) & (unint64_t)__p;
      }
      uint64_t v65 = (uint64_t ***)*((void *)*v6 + v64);
      if (v65)
      {
        unint64_t v66 = *v65;
        if (*v65)
        {
          if (v63.u32[0] < 2uLL)
          {
            unint64_t v67 = v62 - 1;
            while (1)
            {
              unint64_t v69 = (unint64_t)v66[1];
              if ((void *)v69 == __p)
              {
                if (v66[2] == __p) {
                  goto LABEL_130;
                }
              }
              else if ((v69 & v67) != v64)
              {
                goto LABEL_108;
              }
              unint64_t v66 = (uint64_t **)*v66;
              if (!v66) {
                goto LABEL_108;
              }
            }
          }
          do
          {
            unint64_t v68 = (unint64_t)v66[1];
            if ((void *)v68 == __p)
            {
              if (v66[2] == __p)
              {
LABEL_130:
                std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)&v75, v6, v66);
                if (v75) {
                  operator delete(v75);
                }
                break;
              }
            }
            else
            {
              if (v68 >= v62) {
                v68 %= v62;
              }
              if (v68 != v64) {
                break;
              }
            }
            unint64_t v66 = (uint64_t **)*v66;
          }
          while (v66);
        }
      }
    }
LABEL_108:
    uint64_t v73 = &unk_1EF559778;
  }
}

void sub_1A2375010(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  operator delete(v10);

  _Unwind_Resume(a1);
}

uint64_t karo::media::SkyLoader::loadFromChunk(uint64_t a1, uint64_t a2, uint64_t a3, char **a4)
{
  unint64_t v6 = 0;
  unint64_t v7 = a3 - 12;
  int8x8_t v8 = a4[1];
  do
  {
    int v11 = *(_DWORD *)(a2 + v6);
    int v10 = *(_DWORD *)(a2 + v6 + 4);
    int v12 = *(_DWORD *)(a2 + v6 + 8);
    unint64_t v13 = (unint64_t)a4[2];
    if ((unint64_t)v8 < v13)
    {
      *(_DWORD *)int8x8_t v8 = v11;
      *((_DWORD *)v8 + 1) = v10;
      uint8x8_t v9 = v8 + 12;
      *((_DWORD *)v8 + 2) = v12;
    }
    else
    {
      unint64_t v14 = *a4;
      unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v8 - *a4) >> 2);
      unint64_t v16 = v15 + 1;
      if (v15 + 1 > 0x1555555555555555) {
        abort();
      }
      unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v14) >> 2);
      if (2 * v17 > v16) {
        unint64_t v16 = 2 * v17;
      }
      if (v17 >= 0xAAAAAAAAAAAAAAALL) {
        unint64_t v18 = 0x1555555555555555;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        if (v18 > 0x1555555555555555) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        id v19 = (char *)operator new(12 * v18);
      }
      else
      {
        id v19 = 0;
      }
      uint64_t v20 = &v19[12 * v15];
      *(_DWORD *)uint64_t v20 = v11;
      *((_DWORD *)v20 + 1) = v10;
      *((_DWORD *)v20 + 2) = v12;
      uint64_t v21 = v20;
      if (v8 != v14)
      {
        do
        {
          uint64_t v22 = *(void *)(v8 - 12);
          v8 -= 12;
          int v23 = *((_DWORD *)v8 + 2);
          *(void *)(v21 - 12) = v22;
          v21 -= 12;
          *((_DWORD *)v21 + 2) = v23;
        }
        while (v8 != v14);
        int8x8_t v8 = *a4;
      }
      uint8x8_t v9 = v20 + 12;
      *a4 = v21;
      a4[1] = v20 + 12;
      a4[2] = &v19[12 * v18];
      if (v8) {
        operator delete(v8);
      }
    }
    a4[1] = v9;
    v6 += 12;
    int8x8_t v8 = v9;
  }
  while (v6 <= v7);
  return 1;
}

void md::mun::MuninOverlayRenderLayer::layout(md::mun::MuninOverlayRenderLayer *this, const md::LayoutContext *a2)
{
  uint64_t v2 = (uint64_t *)*((void *)a2 + 1);
  int8x8_t v3 = (int8x8_t)v2[1];
  if (!*(void *)&v3) {
    return;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v3);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = 0xC83717EF586624DCLL;
    if (*(void *)&v3 <= 0xC83717EF586624DCLL) {
      unint64_t v7 = 0xC83717EF586624DCLL % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v3 - 1) & 0xC83717EF586624DCLL;
  }
  uint64_t v8 = *v2;
  uint8x8_t v9 = *(void **)(v8 + 8 * v7);
  if (!v9) {
    goto LABEL_24;
  }
  int v10 = (void *)*v9;
  if (!v10) {
    goto LABEL_24;
  }
  if (v6.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v12 = v10[1];
      if (v12 == 0xC83717EF586624DCLL)
      {
        if (v10[2] == 0xC83717EF586624DCLL) {
          goto LABEL_22;
        }
      }
      else if ((v12 & (*(void *)&v3 - 1)) != v7)
      {
        goto LABEL_24;
      }
      int v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_24;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v10[1];
    if (v11 == 0xC83717EF586624DCLL) {
      break;
    }
    if (v11 >= *(void *)&v3) {
      v11 %= *(void *)&v3;
    }
    if (v11 != v7) {
      goto LABEL_24;
    }
LABEL_11:
    int v10 = (void *)*v10;
    if (!v10) {
      goto LABEL_24;
    }
  }
  if (v10[2] != 0xC83717EF586624DCLL) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v13 = v10[5];
  if (*(void *)(v13 + 8) == 0xC83717EF586624DCLL)
  {
    uint64_t v14 = *(void *)(v13 + 32);
    goto LABEL_25;
  }
LABEL_24:
  uint64_t v14 = 0;
LABEL_25:
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v15 = 0xA60DDA5A69582425;
    if (*(void *)&v3 <= 0xA60DDA5A69582425) {
      unint64_t v15 = 0xA60DDA5A69582425 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v15 = (*(void *)&v3 - 1) & 0xA60DDA5A69582425;
  }
  unint64_t v16 = *(void **)(v8 + 8 * v15);
  if (!v16) {
    goto LABEL_47;
  }
  unint64_t v17 = (void *)*v16;
  if (!v17) {
    goto LABEL_47;
  }
  if (v6.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v19 = v17[1];
      if (v19 == 0xA60DDA5A69582425)
      {
        if (v17[2] == 0xA60DDA5A69582425) {
          goto LABEL_45;
        }
      }
      else if ((v19 & (*(void *)&v3 - 1)) != v15)
      {
        goto LABEL_47;
      }
      unint64_t v17 = (void *)*v17;
      if (!v17) {
        goto LABEL_47;
      }
    }
  }
  while (2)
  {
    unint64_t v18 = v17[1];
    if (v18 != 0xA60DDA5A69582425)
    {
      if (v18 >= *(void *)&v3) {
        v18 %= *(void *)&v3;
      }
      if (v18 != v15) {
        goto LABEL_47;
      }
      goto LABEL_34;
    }
    if (v17[2] != 0xA60DDA5A69582425)
    {
LABEL_34:
      unint64_t v17 = (void *)*v17;
      if (!v17) {
        goto LABEL_47;
      }
      continue;
    }
    break;
  }
LABEL_45:
  uint64_t v20 = v17[5];
  if (*(void *)(v20 + 8) == 0xA60DDA5A69582425)
  {
    uint64_t v21 = *(id **)(v20 + 32);
    goto LABEL_48;
  }
LABEL_47:
  uint64_t v21 = 0;
LABEL_48:
  if (v6.u32[0] > 1uLL)
  {
    uint64_t v22 = 0x1AF456233693CD46;
    if (*(void *)&v3 <= 0x1AF456233693CD46uLL) {
      uint64_t v22 = 0x1AF456233693CD46uLL % *(void *)&v3;
    }
  }
  else
  {
    uint64_t v22 = (*(void *)&v3 - 1) & 0x1AF456233693CD46;
  }
  int v23 = *(void **)(v8 + 8 * v22);
  if (!v23) {
    return;
  }
  unint64_t v24 = (void *)*v23;
  if (!v24) {
    return;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v25 = *(void *)&v3 - 1;
    while (1)
    {
      uint64_t v27 = v24[1];
      if (v27 == 0x1AF456233693CD46)
      {
        if (v24[2] == 0x1AF456233693CD46) {
          goto LABEL_68;
        }
      }
      else if ((v27 & v25) != v22)
      {
        return;
      }
      unint64_t v24 = (void *)*v24;
      if (!v24) {
        return;
      }
    }
  }
  while (2)
  {
    unint64_t v26 = v24[1];
    if (v26 != 0x1AF456233693CD46)
    {
      if (v26 >= *(void *)&v3) {
        v26 %= *(void *)&v3;
      }
      if (v26 != v22) {
        return;
      }
      goto LABEL_57;
    }
    if (v24[2] != 0x1AF456233693CD46)
    {
LABEL_57:
      unint64_t v24 = (void *)*v24;
      if (!v24) {
        return;
      }
      continue;
    }
    break;
  }
LABEL_68:
  uint64_t v28 = v24[5];
  if (*(void *)(v28 + 8) == 0x1AF456233693CD46)
  {
    if (v14)
    {
      if (v21)
      {
        if (*(void *)(v28 + 32))
        {
          id v34 = *v21;
          if (!*((void *)this + 44)) {
            operator new();
          }
          uint64_t v30 = *(void *)(v14 + 64);
          float v31 = (md::mun::TapAnnotation *)*((void *)this + 45);
          if (!v31)
          {
            BOOL v32 = 0;
            goto LABEL_80;
          }
          if (v30 && *(void *)(v30 + 72) == *((void *)v31 + 12)) {
            goto LABEL_84;
          }
          *((void *)this + 45) = 0;
          md::mun::TapAnnotation::~TapAnnotation(v31);
          MEMORY[0x1A6239270]();
          float v31 = (md::mun::TapAnnotation *)*((void *)this + 45);
          BOOL v32 = v31 != 0;
LABEL_80:
          if (!v32 && v30) {
            operator new();
          }
          if (v31)
          {
LABEL_84:
            BOOL v33 = (ggl::CommandBuffer *)md::PassList::commandBufferForId(*(void **)(*(void *)(*((void *)this + 5) + 24) + 8), 0, 1u);
            md::mun::TapAnnotation::layout(v31, a2, v33);
          }
          md::mun::MuninOverlayRenderLayer::debugLayout(this, (uint64_t **)a2);
        }
      }
    }
  }
}

void sub_1A2375768(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void md::mun::TapRenderResources::TapRenderResources(md::mun::TapRenderResources *this, VKSharedResources *a2, id *a3)
{
  unint64_t v5 = a2;
  *((_OWORD *)this + 1) = 0u;
  *(_OWORD *)this = 0u;
  *((void *)this + 4) = 0;
  uint8x8_t v6 = (long long *)[*a3 format];
  long long v20 = *v6;
  long long v21 = v6[1];
  uint64_t v7 = *(void *)([(VKSharedResources *)v5 device] + 24);
  uint64_t v8 = *(void *)(v7 + 48);
  uint64_t v9 = *(void *)(v7 + 56);
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *(void *)(v8 + 80);
  uint64_t v12 = *(void *)(v10 + 176);
  unint64_t v11 = *(std::__shared_weak_count **)(v10 + 184);
  uint64_t v18 = v12;
  uint64_t v19 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = (char *)operator new(0x198uLL);
  *((void *)v13 + 1) = 0;
  *((void *)v13 + 2) = 0;
  *(void *)uint64_t v13 = &unk_1EF589C88;
  {
    if (v15)
    {
      {
        if (v15)
        {
          {
            {
              ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r = (uint64_t)&ggl::VSCommon::vertexReflection;
            }
            ggl::MeshTyped<ggl::VSCommon::Vertex>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
            *(void *)algn_1E957EFF0 = 1;
          }
          ggl::VSSprite::PipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::VSCommon::Vertex>::typedReflection(void)::r;
          *(void *)algn_1E957E628 = &ggl::VSSprite::pipelineDataPipelineDeviceStructs(void)::ref;
          qword_1E957E630 = 0;
          {
            ggl::VSSprite::pipelineDataPipelineConstantStructs(void)::ref = (uint64_t)ggl::VSSprite::Sprite::reflection(void)::reflection;
          }
          qword_1E957E638 = (uint64_t)&ggl::VSSprite::pipelineDataPipelineConstantStructs(void)::ref;
          unk_1E957E640 = xmmword_1A28FC6E0;
        }
      }
      ggl::VSSprite::PipelineState::typedReflection(void)::ref = (uint64_t)&ggl::VSSprite::PipelineSetup::typedReflection(void)::ref;
      ggl::VSSpriteShader::typedReflection(v15);
      qword_1E957EF80 = (uint64_t)&ggl::VSSpriteShader::typedReflection(void)::ref;
      {
        ggl::VSSprite::pipelineStatePipelineAttributeStructBinding(void)::attr = 0;
        unk_1E957E6A0 = 0;
        qword_1E957E6A8 = (uint64_t)"";
        dword_1E957E6B0 = 0;
        qword_1E957E6B8 = (uint64_t)&ggl::VSSprite::pipelineStatePipelineAttributeBinding_0(void)::attr;
        unk_1E957E6C0 = 2;
      }
      qword_1E957EF88 = (uint64_t)&ggl::VSSprite::pipelineStatePipelineAttributeStructBinding(void)::attr;
      unk_1E957EF90 = 1;
      qword_1E957EF98 = 0;
      unk_1E957EFA0 = 2;
      qword_1E957EFA8 = (uint64_t)&ggl::VSSprite::pipelineStatePipelineDeviceStructBinding(void)::ref;
      unk_1E957EFB0 = 0;
      {
        ggl::VSSprite::pipelineStatePipelineConstantStructBinding(void)::ref = 0;
        unk_1E957E670 = 0;
        qword_1E957E678 = (uint64_t)"sprite";
        dword_1E957E680 = 3;
        qword_1E957E688 = (uint64_t)&ggl::VSSprite::pipelineStatePipelineConstantSpriteBinding(void)::reflection;
        unk_1E957E690 = 3;
      }
      qword_1E957EFB8 = (uint64_t)&ggl::VSSprite::pipelineStatePipelineConstantStructBinding(void)::ref;
      unk_1E957EFC0 = 1;
    }
  }
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *((void *)v13 + 4) = 0;
  *((void *)v13 + 5) = 0;
  *((_DWORD *)v13 + 14) = 0;
  *((void *)v13 + 6) = 0;
  *((void *)v13 + 3) = &unk_1EF55B208;
  *((void *)v13 + 8) = &ggl::VSSprite::PipelineState::typedReflection(void)::ref;
  *((void *)v13 + 9) = v18;
  *((void *)v13 + 10) = v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v13[136] = 0;
  *(_OWORD *)(v13 + 140) = xmmword_1A28FC970;
  *(void *)(v13 + 156) = 0;
  *(void *)(v13 + 172) = 0;
  *(void *)(v13 + 164) = 0;
  v13[184] = 0;
  *(_OWORD *)(v13 + 188) = xmmword_1A28FC970;
  *(void *)(v13 + 204) = 0;
  *(void *)(v13 + 220) = 0;
  *(void *)(v13 + 212) = 0;
  v13[232] = 0;
  *(_OWORD *)(v13 + 236) = xmmword_1A28FC970;
  *(void *)(v13 + 252) = 0;
  *(void *)(v13 + 268) = 0;
  *(void *)(v13 + 260) = 0;
  *(_OWORD *)(v13 + 280) = v20;
  *(_OWORD *)(v13 + 296) = v21;
  v13[312] = 0;
  *((void *)v13 + 48) = 0;
  *((_OWORD *)v13 + 22) = 0u;
  *((_OWORD *)v13 + 23) = 0u;
  *((_OWORD *)v13 + 20) = 0u;
  *((_OWORD *)v13 + 21) = 0u;
  *((void *)v13 + 49) = 0x100000001;
  v13[400] = 0;
  v13[88] = 1;
  *(_WORD *)(v13 + 89) = v16;
  v13[91] = v17;
  *(_OWORD *)(v13 + 92) = xmmword_1A28FCEC0;
  *((_DWORD *)v13 + 27) = 7;
  *((void *)v13 + 14) = 0;
  *((void *)v13 + 15) = 0;
  *((_DWORD *)v13 + 32) = 0;
  v13[132] = 15;
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  *((void *)v13 + 3) = &unk_1EF561A90;
  uint64_t v14 = (std::__shared_weak_count *)*((void *)this + 3);
  *((void *)this + 2) = v13 + 24;
  *((void *)this + 3) = v13;
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  if (v19)
  {
    if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  operator new();
}

void sub_1A2375ECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  uint64_t v9 = *(void *)(v5 + 32);
  *(void *)(v5 + 32) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v7);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v5);

  _Unwind_Resume(a1);
}

void std::default_delete<md::mun::TapRenderResources>::operator()[abi:nn180100](void *a1)
{
  uint64_t v2 = a1[4];
  a1[4] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  int8x8_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint8x8_t v4 = (std::__shared_weak_count *)a1[1];
    if (!v4) {
      goto LABEL_9;
    }
  }
  else
  {
    uint8x8_t v4 = (std::__shared_weak_count *)a1[1];
    if (!v4) {
      goto LABEL_9;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_9:
  JUMPOUT(0x1A6239270);
}

void md::mun::TapAnnotation::~TapAnnotation(md::mun::TapAnnotation *this)
{
  uint64_t v2 = *((void *)this + 14);
  *((void *)this + 14) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  int8x8_t v3 = (uint64_t *)*((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v3)
  {
    uint8x8_t v4 = (std::__shared_weak_count *)v3[3];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    uint64_t v5 = v3[1];
    v3[1] = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    uint64_t v6 = *v3;
    *int8x8_t v3 = 0;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
    MEMORY[0x1A6239270](v3, 0x20C40DC1BFBCFLL);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v7)
  {
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void md::mun::TapAnnotation::TapAnnotation(uint64_t a1, uint64_t a2, char a3, uint64_t a4, long long *a5, uint64_t a6, float a7)
{
  *(void *)a1 = a2;
  *(unsigned char *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  long long v8 = *a5;
  *(void *)(a1 + 56) = *((void *)a5 + 2);
  *(_OWORD *)(a1 + 40) = v8;
  long long v9 = *(long long *)((char *)a5 + 24);
  *(void *)(a1 + 80) = *((void *)a5 + 5);
  *(_OWORD *)(a1 + 64) = v9;
  *(void *)&long long v9 = *((void *)a5 + 6);
  *(_OWORD *)(a1 + 104) = 0u;
  *(void *)(a1 + 88) = v9;
  *(void *)(a1 + 96) = a6;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(void *)(a1 + 168) = 0x3FF0000000000000;
  uint64_t v10 = (std::__shared_weak_count *)operator new(0xF8uLL);
  v10->__shared_owners_ = 0;
  v10->__shared_weak_owners_ = 0;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585308;
  ggl::BufferData::BufferData((uint64_t)&v10[1], 32, 0, 0, 7, 4);
  v10[9].__shared_weak_owners_ = (uint64_t)"tap destination vertex data";
  v10[10].__vftable = (std::__shared_weak_count_vtbl *)&ggl::VSCommon::vertexReflection;
  v10[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55CFC8;
  v10[9].__shared_owners_ = (uint64_t)&unk_1EF55CFE8;
  unint64_t v11 = (std::__shared_weak_count *)operator new(0xF8uLL);
  v11->__shared_owners_ = 0;
  v11->__shared_weak_owners_ = 0;
  v11->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583D28;
  ggl::BufferData::BufferData((uint64_t)&v11[1], 2, 1, 0, 7, 6);
  LODWORD(v11[10].__vftable) = 0;
  v11[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55B630;
  v11[1].__shared_owners_ = 2;
  v11[9].__shared_owners_ = (uint64_t)&unk_1EF55B650;
  v11[9].__shared_weak_owners_ = (uint64_t)"tap destination index data";
  unint64_t shared_owners = v10[1].__shared_owners_;
  unint64_t v13 = (unint64_t)v10[3].__vftable - v10[2].__shared_weak_owners_;
  uint64_t v14 = v10[4].__vftable;
  float v15 = -(float)(a7 * 0.5);
  *(float *)&v14->~__shared_weak_count = v15;
  HIDWORD(v14->~__shared_weak_count) = 0;
  *(float *)&v14->~__shared_weak_count_0 = v15;
  v14->__on_zero_shared = (void (__cdecl *)(std::__shared_count *__hidden))0x3F80000000000000;
  __asm { FMOV            V2.2S, #1.0 }
  v14[1].~__shared_weak_count_0 = _D2;
  *(float *)&v14->__on_zero_shared_weak = a7 * 0.5;
  HIDWORD(v14->__on_zero_shared_weak) = 0;
  *(float *)&v14[1].~__shared_weak_count = v15;
  *(float *)&v14[1].__get_deleter = a7 * 0.5;
  HIDWORD(v14[1].__get_deleter) = 0;
  *(float *)&v14[1].__on_zero_shared_weak = a7 * 0.5;
  v14[2].~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))1065353216;
  *(float *)&v14[2].__on_zero_shared = v15;
  HIDWORD(v14[2].__on_zero_shared) = 0;
  *(float *)&v14[2].__get_deleter = a7 * 0.5;
  v14[2].__on_zero_shared_weak = 0;
  unint64_t shared_weak_owners = v13 - v13 % shared_owners;
  if (shared_weak_owners)
  {
    if (v10[3].__shared_weak_owners_ > shared_weak_owners) {
      unint64_t shared_weak_owners = v10[3].__shared_weak_owners_;
    }
    v10[3].__shared_owners_ = 0;
    v10[3].__shared_weak_owners_ = shared_weak_owners;
  }
  unint64_t v22 = ((unint64_t)v11[3].__vftable - v11[2].__shared_weak_owners_) & 0xFFFFFFFFFFFFFFFELL;
  int v23 = v11[4].__vftable;
  v23->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))0x2000200010000;
  LODWORD(v23->~__shared_weak_count_0) = 3;
  if (v11[3].__shared_weak_owners_ > v22) {
    unint64_t v22 = v11[3].__shared_weak_owners_;
  }
  v11[3].__shared_owners_ = 0;
  v11[3].__shared_weak_owners_ = v22;
  unint64_t v24 = operator new(0xA8uLL);
  v24[1] = 0;
  v24[2] = 0;
  *unint64_t v24 = &unk_1EF589C50;
  uint64_t v27 = &v10[1].__vftable;
  uint64_t v28 = v10;
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  v26[0] = (uint64_t)&v11[1];
  v26[1] = (uint64_t)v11;
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  ggl::VSCommon::Mesh::Mesh((uint64_t)(v24 + 3), (uint64_t)"destination mesh", (uint64_t *)&v27, v26);
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  uint64_t v25 = v28;
  if (v28)
  {
    if (!atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  operator new();
}

void sub_1A2376A80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  uint64_t v17 = *(void *)(v13 + 112);
  *(void *)(v13 + 112) = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  std::unique_ptr<ggl::Drawable>::~unique_ptr[abi:nn180100](v15);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v14);
  _Unwind_Resume(a1);
}

void md::mun::TapAnnotation::layout(md::mun::TapAnnotation *this, const md::LayoutContext *a2, ggl::CommandBuffer *a3)
{
  if (!*((void *)this + 13))
  {
    uint64_t v6 = (void *)*((void *)a2 + 1);
    unint64_t v7 = v6[1];
    if ((v7 & (v7 - 1)) != 0)
    {
      unint64_t v9 = 0xA60DDA5A69582425;
      if (v7 <= 0xA60DDA5A69582425) {
        unint64_t v9 = 0xA60DDA5A69582425 % v7;
      }
      long long v8 = *(void **)(*v6 + 8 * v9);
      do
      {
        do
          long long v8 = (void *)*v8;
        while (v8[1] != 0xA60DDA5A69582425);
      }
      while (v8[2] != 0xA60DDA5A69582425);
    }
    else
    {
      long long v8 = *(void **)(*v6 + 8 * ((v7 - 1) & 0xA60DDA5A69582425));
      do
      {
        do
          long long v8 = (void *)*v8;
        while (v8[1] != 0xA60DDA5A69582425);
      }
      while (v8[2] != 0xA60DDA5A69582425);
    }
    id v10 = **(id **)(v8[5] + 32);
    unint64_t v11 = operator new(0x70uLL);
    *(void *)&double v89 = v11 + 7;
    *unint64_t v11 = xmmword_1A28FCDD0;
    v11[1] = xmmword_1A28FCE90;
    v11[2] = xmmword_1A28FE9D0;
    v11[3] = xmmword_1A28FE9E0;
    v11[4] = xmmword_1A28FD2A0;
    v11[5] = xmmword_1A28FD280;
    v11[6] = xmmword_1A28FC6C0;
    __p[0] = v11;
    __p[1] = v11 + 7;
  }
  uint64_t v12 = (void *)*((void *)a2 + 1);
  int8x8_t v13 = (int8x8_t)v12[1];
  if (!*(void *)&v13) {
    goto LABEL_36;
  }
  uint8x8_t v14 = (uint8x8_t)vcnt_s8(v13);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.u32[0] > 1uLL)
  {
    uint64_t v15 = 0x1AF456233693CD46;
    if (*(void *)&v13 <= 0x1AF456233693CD46uLL) {
      uint64_t v15 = 0x1AF456233693CD46uLL % *(void *)&v13;
    }
  }
  else
  {
    uint64_t v15 = (*(void *)&v13 - 1) & 0x1AF456233693CD46;
  }
  __int16 v16 = *(void **)(*v12 + 8 * v15);
  if (!v16) {
    goto LABEL_36;
  }
  uint64_t v17 = (void *)*v16;
  if (!v17) {
    goto LABEL_36;
  }
  if (v14.u32[0] < 2uLL)
  {
    uint64_t v18 = *(void *)&v13 - 1;
    while (1)
    {
      uint64_t v20 = v17[1];
      if (v20 == 0x1AF456233693CD46)
      {
        if (v17[2] == 0x1AF456233693CD46) {
          goto LABEL_34;
        }
      }
      else if ((v20 & v18) != v15)
      {
        goto LABEL_36;
      }
      uint64_t v17 = (void *)*v17;
      if (!v17) {
        goto LABEL_36;
      }
    }
  }
  while (1)
  {
    unint64_t v19 = v17[1];
    if (v19 == 0x1AF456233693CD46) {
      break;
    }
    if (v19 >= *(void *)&v13) {
      v19 %= *(void *)&v13;
    }
    if (v19 != v15) {
      goto LABEL_36;
    }
LABEL_23:
    uint64_t v17 = (void *)*v17;
    if (!v17) {
      goto LABEL_36;
    }
  }
  if (v17[2] != 0x1AF456233693CD46) {
    goto LABEL_23;
  }
LABEL_34:
  uint64_t v21 = v17[5];
  if (*(void *)(v21 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v22 = *(void *)(v21 + 32);
    goto LABEL_37;
  }
LABEL_36:
  uint64_t v22 = 0;
LABEL_37:
  double v23 = *((double *)this + 9);
  double v24 = *((double *)this + 10);
  double v25 = *((double *)this + 11);
  double v26 = v23 + v23;
  double v27 = (v23 + v23) * v23;
  double v28 = (v24 + v24) * v24;
  uint64_t v30 = *((void *)this + 7);
  double v29 = *((double *)this + 8);
  double v31 = v29 + v29;
  double v32 = (v29 + v29) * v23;
  double v33 = (v24 + v24) * v25;
  double v34 = v24 * (v29 + v29);
  double v35 = 1.0 - (v29 + v29) * v29;
  double v36 = v26 * v24;
  v84[0] = 1.0 - (v27 + v28);
  v84[1] = v33 + v32;
  v84[4] = v32 - v33;
  v84[5] = v35 - v28;
  v84[8] = v25 * v26 + v34;
  v84[9] = v36 - v25 * v31;
  v84[2] = v34 - v25 * v26;
  v84[6] = v25 * v31 + v36;
  v84[10] = v35 - v27;
  v84[3] = 0.0;
  v84[7] = 0.0;
  v84[11] = 0.0;
  long long v85 = *(_OWORD *)((char *)this + 40);
  uint64_t v86 = v30;
  uint64_t v87 = 0x3FF0000000000000;
  gm::operator*<double,4,4,4>((double *)__p, (double *)(v22 + 808), v84);
  float v38 = *(double *)&__p[1];
  float v39 = v89;
  float v40 = v90;
  float v41 = v91;
  float v42 = v92;
  float v43 = v93;
  float v44 = v94;
  float v45 = v95;
  float v46 = v96;
  float v47 = v97;
  float v48 = v98;
  float v49 = v99;
  float v50 = v100;
  float v51 = v101;
  float v52 = v102;
  size_t v53 = (uint64_t *)*((void *)this + 3);
  unint64_t v54 = **(void ***)(v53[1] + 64);
  unint64_t v55 = v54[1];
  if (v55) {
    uint64_t v56 = v54[9];
  }
  else {
    uint64_t v56 = 0;
  }
  float v81 = *(double *)__p;
  float v82 = *(double *)&__p[1];
  float v37 = *(double *)__p;
  *(float *)uint64_t v56 = v37;
  *(float *)(v56 + 4) = v38;
  float v79 = v39;
  float v80 = v40;
  *(float *)(v56 + 8) = v39;
  *(float *)(v56 + 12) = v40;
  float v77 = v41;
  float v78 = v42;
  *(float *)(v56 + 16) = v41;
  *(float *)(v56 + 20) = v42;
  float v75 = v43;
  float v76 = v44;
  *(float *)(v56 + 24) = v43;
  *(float *)(v56 + 28) = v44;
  *(float *)(v56 + 32) = v45;
  *(float *)(v56 + 36) = v46;
  float v74 = v46;
  *(float *)(v56 + 40) = v47;
  *(float *)(v56 + 44) = v48;
  *(float *)(v56 + 48) = v49;
  *(float *)(v56 + 52) = v50;
  *(float *)(v56 + 56) = v51;
  *(float *)(v56 + 60) = v52;
  uint64_t v57 = *((void *)this + 2);
  unint64_t v58 = *(void *)(v57 + 88);
  unint64_t v59 = *(void *)(v57 + 80)
      + vcvtad_u64_f64(fmin(fmax((*(double *)(v57 + 64) - *(double *)(v57 + 48)) / (*(double *)(v57 + 56) - *(double *)(v57 + 48)), 0.0), 1.0)* (double)(v58 - *(void *)(v57 + 80)));
  if (v59 >= v58) {
    unint64_t v59 = *(void *)(v57 + 88);
  }
  unint64_t v60 = *(unsigned int *)(v57 + 24);
  double v61 = *(double *)(v57 + 32);
  double v62 = *(double *)(v57 + 40);
  float v63 = v61 * (double)(v59 % v60);
  float v64 = v62 * (double)(v59 / v60 % *(unsigned int *)(v57 + 28));
  *(float *)(v56 + 72) = v63;
  *(float *)(v56 + 76) = v64;
  float v65 = v61;
  *(float *)&double v61 = v62;
  *(float *)(v56 + 64) = v65;
  *(_DWORD *)(v56 + 68) = LODWORD(v61);
  if (v56 && v55)
  {
    if (v54[8] > v55) {
      unint64_t v55 = v54[8];
    }
    v54[7] = 0;
    v54[8] = v55;
  }
  ggl::CommandBuffer::pushRenderItem((uint64_t)a3, *v53);
  unint64_t v66 = +[VKDebugSettings sharedSettings];
  if ([v66 muninDebugLayer])
  {
    unint64_t v67 = (uint64_t *)*((void *)this + 13);
    if (v67)
    {
      uint64_t v68 = **(void **)(v67[1] + 64);
      __p[0] = 0;
      __p[1] = 0;
      double v69 = *(double *)(v68 + 8);
      *(void *)&long long v70 = 0;
      *((void *)&v70 + 1) = v68;
      double v71 = v69 == 0.0 ? 0.0 : *(double *)(v68 + 72);
      float v72 = v82;
      long long v83 = v70;
      *(_OWORD *)__p = v70;
      double v89 = 0.0;
      double v90 = v69;
      double v92 = v71;
      LOWORD(v91) = 1;
      **(float **)&double v71 = v81;
      *(float *)(*(void *)&v71 + 4) = v72;
      *(float *)(*(void *)&v71 + 8) = v79;
      *(float *)(*(void *)&v71 + 12) = v80;
      *(float *)(*(void *)&v71 + 16) = v77;
      *(float *)(*(void *)&v71 + 20) = v78;
      *(float *)(*(void *)&v71 + 24) = v75;
      *(float *)(*(void *)&v71 + 28) = v76;
      *(float *)(*(void *)&v71 + 32) = v45;
      *(float *)(*(void *)&v71 + 36) = v74;
      *(float *)(*(void *)&v71 + 40) = v47;
      *(float *)(*(void *)&v71 + 44) = v48;
      *(float *)(*(void *)&v71 + 48) = v49;
      *(float *)(*(void *)&v71 + 52) = v50;
      *(float *)(*(void *)&v71 + 56) = v51;
      *(float *)(*(void *)&v71 + 60) = v52;
      ggl::CommandBuffer::pushRenderItem((uint64_t)a3, *v67);
      if (v69 != 0.0)
      {
        if ((void)v83 && *(unsigned char *)(*((void *)&v83 + 1) + 17) != 2) {
          (*(void (**)(void))(*(void *)v83 + 64))();
        }
        double v73 = *(double *)(*((void *)&v83 + 1) + 64);
        if (*(void *)&v73 <= *(void *)&v69) {
          double v73 = v69;
        }
        *(void *)(*((void *)&v83 + 1) + 56) = 0;
        *(double *)(*((void *)&v83 + 1) + 64) = v73;
      }
    }
  }
}

void sub_1A23772EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32)
{
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&__p);

  _Unwind_Resume(a1);
}

void md::mun::MuninOverlayRenderLayer::debugLayout(md::mun::MuninOverlayRenderLayer *this, uint64_t **a2)
{
  uint64_t v2 = (const md::LayoutContext *)a2;
  uint64_t v583 = *MEMORY[0x1E4F143B8];
  v571 = 0;
  uint8x8_t v4 = a2[1];
  int8x8_t v5 = (int8x8_t)v4[1];
  if (!*(void *)&v5) {
    goto LABEL_47;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = 0xC83717EF586624DCLL;
    if (*(void *)&v5 <= 0xC83717EF586624DCLL) {
      unint64_t v7 = 0xC83717EF586624DCLL % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v5 - 1) & 0xC83717EF586624DCLL;
  }
  uint64_t v8 = *v4;
  unint64_t v9 = *(void **)(v8 + 8 * v7);
  if (!v9) {
    goto LABEL_24;
  }
  id v10 = (void *)*v9;
  if (!v10) {
    goto LABEL_24;
  }
  if (v6.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v12 = v10[1];
      if (v12 == 0xC83717EF586624DCLL)
      {
        if (v10[2] == 0xC83717EF586624DCLL) {
          goto LABEL_22;
        }
      }
      else if ((v12 & (*(void *)&v5 - 1)) != v7)
      {
        goto LABEL_24;
      }
      id v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_24;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v10[1];
    if (v11 == 0xC83717EF586624DCLL) {
      break;
    }
    if (v11 >= *(void *)&v5) {
      v11 %= *(void *)&v5;
    }
    if (v11 != v7) {
      goto LABEL_24;
    }
LABEL_11:
    id v10 = (void *)*v10;
    if (!v10) {
      goto LABEL_24;
    }
  }
  if (v10[2] != 0xC83717EF586624DCLL) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v13 = v10[5];
  if (*(void *)(v13 + 8) == 0xC83717EF586624DCLL)
  {
    uint8x8_t v14 = *(void **)(v13 + 32);
    goto LABEL_25;
  }
LABEL_24:
  uint8x8_t v14 = 0;
LABEL_25:
  v571 = v14;
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v15 = 0xA60DDA5A69582425;
    if (*(void *)&v5 <= 0xA60DDA5A69582425) {
      unint64_t v15 = 0xA60DDA5A69582425 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v15 = (*(void *)&v5 - 1) & 0xA60DDA5A69582425;
  }
  __int16 v16 = *(void **)(v8 + 8 * v15);
  if (!v16) {
    goto LABEL_47;
  }
  uint64_t v17 = (void *)*v16;
  if (!v17) {
    goto LABEL_47;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v18 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v20 = v17[1];
      if (v20 == 0xA60DDA5A69582425)
      {
        if (v17[2] == 0xA60DDA5A69582425) {
          goto LABEL_45;
        }
      }
      else if ((v20 & v18) != v15)
      {
        goto LABEL_47;
      }
      uint64_t v17 = (void *)*v17;
      if (!v17) {
        goto LABEL_47;
      }
    }
  }
  while (2)
  {
    unint64_t v19 = v17[1];
    if (v19 != 0xA60DDA5A69582425)
    {
      if (v19 >= *(void *)&v5) {
        v19 %= *(void *)&v5;
      }
      if (v19 != v15) {
        goto LABEL_47;
      }
      goto LABEL_34;
    }
    if (v17[2] != 0xA60DDA5A69582425)
    {
LABEL_34:
      uint64_t v17 = (void *)*v17;
      if (!v17) {
        goto LABEL_47;
      }
      continue;
    }
    break;
  }
LABEL_45:
  uint64_t v21 = v17[5];
  if (*(void *)(v21 + 8) == 0xA60DDA5A69582425)
  {
    uint64_t v22 = *(id **)(v21 + 32);
    goto LABEL_48;
  }
LABEL_47:
  uint64_t v22 = 0;
LABEL_48:
  id v570 = +[VKDebugSettings sharedSettings];
  v522 = this;
  if ([v570 muninDebugLayer])
  {
    id v572 = *v22;
    id v23 = *(id *)v2;
    [v23 size];
    v519 = (id *)v2;
    if (v24 == *((double *)this + 8))
    {
      id v25 = *(id *)v2;
      [v25 size];
      double v27 = v26;
      double v28 = *((double *)this + 9);

      if (v27 == v28) {
        goto LABEL_85;
      }
    }
    else
    {
    }
    double v29 = (void *)*((void *)v2 + 1);
    int8x8_t v30 = (int8x8_t)v29[1];
    if (v30)
    {
      uint8x8_t v31 = (uint8x8_t)vcnt_s8(v30);
      v31.i16[0] = vaddlv_u8(v31);
      if (v31.u32[0] > 1uLL)
      {
        unint64_t v32 = 0xA60DDA5A69582425;
        if (*(void *)&v30 <= 0xA60DDA5A69582425) {
          unint64_t v32 = 0xA60DDA5A69582425 % *(void *)&v30;
        }
      }
      else
      {
        unint64_t v32 = (*(void *)&v30 - 1) & 0xA60DDA5A69582425;
      }
      double v33 = *(void **)(*v29 + 8 * v32);
      if (v33)
      {
        double v34 = (void *)*v33;
        if (v34)
        {
          if (v31.u32[0] < 2uLL)
          {
            uint64_t v35 = *(void *)&v30 - 1;
            while (1)
            {
              uint64_t v37 = v34[1];
              if (v37 == 0xA60DDA5A69582425)
              {
                if (v34[2] == 0xA60DDA5A69582425) {
                  goto LABEL_74;
                }
              }
              else if ((v37 & v35) != v32)
              {
                goto LABEL_84;
              }
              double v34 = (void *)*v34;
              if (!v34) {
                goto LABEL_84;
              }
            }
          }
          do
          {
            unint64_t v36 = v34[1];
            if (v36 == 0xA60DDA5A69582425)
            {
              if (v34[2] == 0xA60DDA5A69582425)
              {
LABEL_74:
                uint64_t v38 = v34[5];
                if (*(void *)(v38 + 8) == 0xA60DDA5A69582425)
                {
                  float v39 = *(id **)(v38 + 32);
                  if (v39)
                  {
                    uint64_t v40 = *(void *)([*v39 device] + 24);
                    std::string::size_type v42 = *(void *)(v40 + 16);
                    std::string::size_type v41 = *(void *)(v40 + 24);
                    v537.__r_.__value_.__r.__words[0] = v42;
                    v537.__r_.__value_.__l.__size_ = v41;
                    if (v41) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v41 + 8), 1uLL, memory_order_relaxed);
                    }
                    id v43 = *(id *)v2;
                    float v44 = (_OWORD *)[v43 format];
                    v549[0] = *v44;
                    v549[1] = v44[1];

                    uint64_t v45 = *(void *)(v42 + 80);
                    float v46 = *(std::__shared_weak_count **)(v45 + 400);
                    v565.__r_.__value_.__r.__words[0] = *(void *)(v45 + 392);
                    v565.__r_.__value_.__l.__size_ = (std::string::size_type)v46;
                    if (v46) {
                      atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    long long v551 = 0uLL;
                    LODWORD(v552) = 0;
                    v550[0] = 1;
                    *(_OWORD *)&v550[4] = xmmword_1A28FCEC0;
                    *(_DWORD *)&v550[20] = 7;
                    BYTE4(v552) = 15;
                    float v47 = operator new(0x198uLL);
                    v47[1] = 0;
                    v47[2] = 0;
                    void *v47 = &unk_1EF589048;
                    float64x2_t __p = (float64x2_t)v549[0];
                    float64x2_t v574 = (float64x2_t)v549[1];
                    v528.__r_.__value_.__r.__words[0] = ggl::Debug::BasePipelineState::BasePipelineState((uint64_t)(v47 + 3), &v565, (uint64_t)v550, &__p);
                    v528.__r_.__value_.__l.__size_ = (std::string::size_type)v47;
                    if (v46 && !atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
                      std::__shared_weak_count::__release_weak(v46);
                    }
                    operator new();
                  }
                }
                break;
              }
            }
            else
            {
              if (v36 >= *(void *)&v30) {
                v36 %= *(void *)&v30;
              }
              if (v36 != v32) {
                break;
              }
            }
            double v34 = (void *)*v34;
          }
          while (v34);
        }
      }
    }
LABEL_84:
    id v48 = *(id *)v2;
    [v48 size];
    *((void *)this + 8) = v49;
    *((void *)this + 9) = v50;

LABEL_85:
    float v51 = *(void **)(*(void *)(*((void *)this + 6) + 24) + 8);
    uint64_t v52 = v51[3];
    uint64_t v53 = v51[4];
    uint64_t v54 = v53 - v52;
    if (v53 == v52) {
      goto LABEL_92;
    }
    uint64_t v55 = 0;
    unint64_t v56 = v54 >> 3;
    while (1)
    {
      uint64_t v57 = *(void *)(v52 + 8 * v55);
      if (!*(unsigned char *)v57)
      {
        unint64_t v58 = *(void *)(v57 + 8);
        uint64_t v59 = v51[15];
        if (v58 < (v51[16] - v59) >> 3) {
          break;
        }
      }
      if (++v55 >= v56) {
        goto LABEL_92;
      }
    }
    uint64_t v60 = *(void *)(v59 + 8 * v58);
    if (!v60) {
LABEL_92:
    }
      uint64_t v61 = 0;
    else {
      uint64_t v61 = *(void *)(*(void *)(v60 + 24) + 8);
    }
    ggl::CommandBuffer::pushRenderItem(v61, **((void **)this + 10));
    double v62 = (void *)*((void *)v2 + 1);
    unint64_t v63 = v62[1];
    if ((v63 & (v63 - 1)) != 0)
    {
      unint64_t v65 = 0x1AF456233693CD46;
      if (v63 <= 0x1AF456233693CD46) {
        unint64_t v65 = 0x1AF456233693CD46 % v63;
      }
      float v64 = *(void **)(*v62 + 8 * v65);
      do
      {
        do
          float v64 = (void *)*v64;
        while (v64[1] != 0x1AF456233693CD46);
      }
      while (v64[2] != 0x1AF456233693CD46);
    }
    else
    {
      float v64 = *(void **)(*v62 + 8 * ((v63 - 1) & 0x1AF456233693CD46));
      do
      {
        do
          float v64 = (void *)*v64;
        while (v64[1] != 0x1AF456233693CD46);
      }
      while (v64[2] != 0x1AF456233693CD46);
    }
    unint64_t v66 = *(double **)(v64[5] + 32);
    double v67 = v66[62];
    double v68 = v66[63];
    double v69 = v66[64];
    double v70 = v66[65];
    double v71 = v66[66];
    double v72 = v66[67];
    double v73 = v66[68];
    double v74 = 1.0 / sqrt(v67 * v67 + v68 * v68 + v69 * v69);
    double v75 = v74 * v67;
    double v76 = v74 * v68;
    double v77 = v74 * v69;
    double v78 = v72 * (v70 + v70) + v73 * (v71 + v71);
    double v79 = -(v73 * (v70 + v70) - (v71 + v71) * v72);
    double v80 = 1.0 - ((v71 + v71) * v71 + (v70 + v70) * v70);
    double v81 = -(v79 * v77 - v80 * v76);
    double v82 = -(v75 * v80 - v78 * v77);
    double v83 = -(v78 * v76 - v79 * v75);
    double v84 = 1.0 / sqrt(v81 * v81 + v82 * v82 + v83 * v83);
    double v85 = v84 * v81;
    double v86 = v84 * v82;
    double v87 = v84 * v83;
    double v88 = -(v84 * v82 * v77 - v84 * v83 * v76);
    double v89 = -(v84 * v83 * v75 - v85 * v77);
    double v90 = -(v85 * v76 - v86 * v75);
    double v91 = v89 + v85 + v77;
    if (v91 <= 0.0)
    {
      if (v85 <= v89 || v85 <= v77)
      {
        double v98 = sqrt(v77 + 1.0 - (v89 + v85));
        double v99 = 1.0 / (v98 + v98);
        double v100 = (v87 + v75) * v99;
        double v101 = v76 - (v85 * v76 - v86 * v75);
        double v102 = v101 * v99;
        double v103 = v98 * 0.5;
        double v104 = (v86 - v88) * v99;
        double v105 = sqrt(1.0 - (v77 + v85) + v89);
        double v106 = 1.0 / (v105 + v105);
        double v107 = (v88 + v86) * v106;
        double v94 = v105 * 0.5;
        double v108 = v101 * v106;
        double v96 = (v75 - v87) * v106;
        if (v89 > v77) {
          double v93 = v107;
        }
        else {
          double v93 = v100;
        }
        if (v89 > v77)
        {
          double v95 = v108;
        }
        else
        {
          double v94 = v102;
          double v95 = v103;
        }
        if (v89 <= v77) {
          double v96 = v104;
        }
      }
      else
      {
        double v109 = sqrt(v85 + 1.0 - (v77 + v89));
        double v110 = v109 + v109;
        double v93 = v109 * 0.5;
        double v111 = v88 + v86;
        double v112 = 1.0 / v110;
        double v94 = v111 * (1.0 / v110);
        double v95 = (v87 + v75) * v112;
        double v96 = (v90 - v76) * v112;
      }
    }
    else
    {
      double v92 = 0.5 / sqrt(v91 + 1.0);
      double v93 = v92 * (v90 - v76);
      double v94 = v92 * (v75 - v87);
      double v95 = v92 * (v86 - v88);
      double v96 = 0.25 / v92;
    }
    *(double *)&v565.__r_.__value_.__l.__data_ = v67 + v75 * 100.0;
    *(double *)&v565.__r_.__value_.__l.__size_ = v68 + v76 * 100.0;
    *(double *)&v565.__r_.__value_.__r.__words[2] = v69 + v77 * 100.0;
    double v566 = v93;
    double v567 = v94;
    double v568 = v95;
    double v569 = v96;
    double v113 = -(*(double *)&v565.__r_.__value_.__r.__words[2] * v94 - *(double *)&v565.__r_.__value_.__l.__size_ * v95)
         - (*(double *)&v565.__r_.__value_.__r.__words[2] * v94
          - *(double *)&v565.__r_.__value_.__l.__size_ * v95);
    double v114 = -(v95 * *(double *)&v565.__r_.__value_.__l.__data_ - *(double *)&v565.__r_.__value_.__r.__words[2] * v93)
         - (v95 * *(double *)&v565.__r_.__value_.__l.__data_
          - *(double *)&v565.__r_.__value_.__r.__words[2] * v93);
    double v115 = -(*(double *)&v565.__r_.__value_.__l.__size_ * v93 - v94 * *(double *)&v565.__r_.__value_.__l.__data_)
         - (*(double *)&v565.__r_.__value_.__l.__size_ * v93
          - v94 * *(double *)&v565.__r_.__value_.__l.__data_);
    *(double *)&v561.__r_.__value_.__l.__data_ = -(*(double *)&v565.__r_.__value_.__l.__data_
                                                 + v114 * v95
                                                 + v113 * v96
                                                 - v115 * v94);
    *(double *)&v561.__r_.__value_.__l.__size_ = -(*(double *)&v565.__r_.__value_.__l.__size_
                                                 + v114 * v96
                                                 + v115 * v93
                                                 - v113 * v95);
    *(double *)&v561.__r_.__value_.__r.__words[2] = -(*(double *)&v565.__r_.__value_.__r.__words[2]
                                                    + v113 * v94
                                                    + v115 * v96
                                                    - v114 * v93);
    *(double *)&long long v562 = -v93;
    *((double *)&v562 + 1) = -v94;
    double v563 = -v95;
    double v564 = v96;
    unint64_t v116 = v62[1];
    uint64_t v517 = v61;
    if ((v116 & (v116 - 1)) != 0)
    {
      unint64_t v118 = 0x1AF456233693CD46;
      if (v116 <= 0x1AF456233693CD46) {
        unint64_t v118 = 0x1AF456233693CD46 % v116;
      }
      unint64_t v117 = *(void **)(*v62 + 8 * v118);
      do
      {
        do
          unint64_t v117 = (void *)*v117;
        while (v117[1] != 0x1AF456233693CD46);
      }
      while (v117[2] != 0x1AF456233693CD46);
    }
    else
    {
      unint64_t v117 = *(void **)(*v62 + 8 * ((v116 - 1) & 0x1AF456233693CD46));
      do
      {
        do
          unint64_t v117 = (void *)*v117;
        while (v117[1] != 0x1AF456233693CD46);
      }
      while (v117[2] != 0x1AF456233693CD46);
    }
    double v119 = *(double *)(*(void *)(v117[5] + 32) + 480);
    id v120 = *(id *)v2;
    [v120 size];
    double v122 = v121;
    [*(id *)v2 size];
    double v124 = v123;

    uint64_t v125 = *((void *)v2 + 4);
    unint64_t v126 = (std::__shared_weak_count *)*((void *)v2 + 5);
    if (v126) {
      atomic_fetch_add_explicit(&v126->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v127 = *(unsigned __int8 *)(v125 + 72);
    *(double *)v550 = (v124 + v124) / (v122 * 190.0);
    *(_OWORD *)&v550[8] = 0u;
    long long v551 = 0u;
    uint64_t v552 = 0x3F858ED2308158EDLL;
    double v128 = v119 + -1.0;
    if (!v127) {
      double v128 = 1.0 - v119;
    }
    long long v553 = 0uLL;
    long long v554 = 0uLL;
    double v555 = v128 * -0.001;
    uint64_t v557 = 0;
    uint64_t v556 = 0;
    unint64_t v558 = 0x8000000000000000;
    double v559 = v119;
    uint64_t v560 = 0x3FF0000000000000;
    if (v126 && !atomic_fetch_add(&v126->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v126->__on_zero_shared)(v126);
      std::__shared_weak_count::__release_weak(v126);
    }
    uint64_t v130 = v571[5];
    uint64_t v129 = v571[6];
    if (v130 != v129)
    {
      while (*(unsigned char *)v130 != 1)
      {
        v130 += 272;
        if (v130 == v129) {
          goto LABEL_138;
        }
      }
      if (*(unsigned char *)(v130 + 128))
      {
        unint64_t v135 = (void *)*((void *)this + 40);
        *((void *)this + 41) = v135;
        unint64_t v136 = 0x367D6E020E64C149 * ((uint64_t)(*(void *)(v130 + 144) - *(void *)(v130 + 136)) >> 3);
        if (v136 > (uint64_t)(*((void *)this + 42) - (void)v135) >> 3)
        {
          if (v136 >> 61) {
            abort();
          }
          uint64_t v137 = (char *)operator new(0xB3EB701073260A48 * ((uint64_t)(*(void *)(v130 + 144) - *(void *)(v130 + 136)) >> 3));
          *((void *)this + 40) = v137;
          *((void *)this + 41) = v137;
          *((void *)this + 42) = &v137[8 * v136];
          if (v135) {
            operator delete(v135);
          }
        }
        unint64_t v138 = *(void **)(v130 + 136);
        double v139 = *(void **)(v130 + 144);
        if (v138 != v139)
        {
          uint64_t v140 = (char *)*((void *)this + 41);
          while (1)
          {
            unint64_t v142 = *((void *)this + 42);
            if ((unint64_t)v140 >= v142) {
              break;
            }
            *(void *)uint64_t v140 = *v138;
            unint64_t v141 = v140 + 8;
LABEL_151:
            *((void *)this + 41) = v141;
            v138 += 249;
            uint64_t v140 = v141;
            if (v138 == v139) {
              goto LABEL_272;
            }
          }
          uint64_t v143 = (char *)*((void *)this + 40);
          uint64_t v144 = (v140 - v143) >> 3;
          unint64_t v145 = v144 + 1;
          if ((unint64_t)(v144 + 1) >> 61) {
            abort();
          }
          uint64_t v146 = v142 - (void)v143;
          if (v146 >> 2 > v145) {
            unint64_t v145 = v146 >> 2;
          }
          if ((unint64_t)v146 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v147 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v147 = v145;
          }
          if (v147)
          {
            if (v147 >> 61) {
LABEL_479:
            }
              std::__throw_bad_array_new_length[abi:nn180100]();
            double v148 = operator new(8 * v147);
          }
          else
          {
            double v148 = 0;
          }
          uint64_t v149 = &v148[8 * v144];
          void *v149 = *v138;
          unint64_t v141 = (char *)(v149 + 1);
          if (v140 == v143)
          {
            this = v522;
            uint64_t v2 = (const md::LayoutContext *)v519;
            goto LABEL_169;
          }
          unint64_t v150 = v140 - 8 - v143;
          if (v150 < 0x168
            || &v148[v140 - v143 - 8 - (v150 & 0xFFFFFFFFFFFFFFF8)] > &v148[v140 - v143 - 8]
            || &v140[-(v150 & 0xFFFFFFFFFFFFFFF8) - 8] > v140 - 8
            || (unint64_t)(v143 - v148) < 0x20)
          {
            double v151 = v140;
            this = v522;
            uint64_t v2 = (const md::LayoutContext *)v519;
          }
          else
          {
            uint64_t v153 = (v150 >> 3) + 1;
            double v151 = &v140[-8 * (v153 & 0x3FFFFFFFFFFFFFFCLL)];
            double v154 = &v148[8 * v144 - 16];
            uint64_t v155 = v140 - 16;
            uint64_t v156 = v153 & 0x3FFFFFFFFFFFFFFCLL;
            uint64_t v2 = (const md::LayoutContext *)v519;
            do
            {
              long long v157 = *(_OWORD *)v155;
              *(v154 - 1) = *((_OWORD *)v155 - 1);
              _OWORD *v154 = v157;
              v154 -= 2;
              v155 -= 32;
              v156 -= 4;
            }
            while (v156);
            v149 -= v153 & 0x3FFFFFFFFFFFFFFCLL;
            this = v522;
            if (v153 == (v153 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_169:
              *((void *)this + 40) = v149;
              *((void *)this + 41) = v141;
              *((void *)this + 42) = &v148[8 * v147];
              if (v143) {
                operator delete(v143);
              }
              goto LABEL_151;
            }
          }
          do
          {
            uint64_t v152 = *((void *)v151 - 1);
            v151 -= 8;
            *--uint64_t v149 = v152;
          }
          while (v151 != v143);
          goto LABEL_169;
        }
LABEL_272:
        v259 = (uint64_t *)*((void *)this + 12);
        *((void *)this + 12) = 0;
        if (v259)
        {
          v260 = (std::__shared_weak_count *)v259[3];
          if (v260 && !atomic_fetch_add(&v260->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v260->__on_zero_shared)(v260);
            std::__shared_weak_count::__release_weak(v260);
          }
          uint64_t v261 = v259[1];
          v259[1] = 0;
          if (v261) {
            (*(void (**)(uint64_t))(*(void *)v261 + 8))(v261);
          }
          uint64_t v262 = *v259;
          uint64_t *v259 = 0;
          uint64_t v2 = (const md::LayoutContext *)v519;
          if (v262) {
            (*(void (**)(uint64_t))(*(void *)v262 + 8))(v262);
          }
          MEMORY[0x1A6239270](v259, 0x20C40DC1BFBCFLL);
        }
        uint64_t v263 = *(void *)(v130 + 136);
        uint64_t v264 = *(void *)(v130 + 144);
        if (v263 != v264)
        {
          float64_t v265 = 0.0;
          uint64_t v266 = 0;
          float64x2_t __p = 0uLL;
          v574.f64[0] = 0.0;
          uint64_t v267 = v263;
          while (1)
          {
            unint64_t v269 = 0x367D6E020E64C149 * ((uint64_t)(*(void *)(v130 + 144) - *(void *)(v130 + 136)) >> 3);
            float v270 = (double)(3 * v266 % v269) / (double)(v269 - 1);
            unint64_t v271 = *(void *)(v267 + 80);
            unint64_t v272 = *(void *)(v263 + 80);
            unint64_t v273 = v272 - v271;
            BOOL v274 = v271 >= v272;
            unint64_t v275 = v271 - v272;
            if (v275 == 0 || !v274) {
              unint64_t v275 = v273;
            }
            double v277 = *(double *)(v267 + 16);
            double v276 = *(double *)(v267 + 24);
            double v278 = *(double *)(v267 + 8);
            double v279 = *(double *)&v561.__r_.__value_.__l.__data_ + v278;
            double v280 = v277 * v563;
            double v281 = -(v276 * *(double *)&v562 - v278 * v563);
            double v282 = -(v278 * *((double *)&v562 + 1) - v277 * *(double *)&v562);
            if (v275 >= 0xEA61) {
              break;
            }
            double v289 = -(v280 - v276 * *((double *)&v562 + 1)) - (v280 - v276 * *((double *)&v562 + 1));
            double v290 = v281 + v281;
            double v291 = v282 + v282;
            float v292 = v279 + v289 * v564 + v291 * *((double *)&v562 + 1) - v290 * v563;
            float v293 = *(double *)&v561.__r_.__value_.__l.__size_
                 + v277
                 + v289 * v563
                 + v290 * v564
                 - v291 * *(double *)&v562;
            float v294 = *(double *)&v561.__r_.__value_.__r.__words[2]
                 + v276
                 - v289 * *((double *)&v562 + 1)
                 + v290 * *(double *)&v562
                 + v291 * v564;
            if (*(void *)&v265 < *(void *)&v574.f64[0])
            {
              **(float **)&float64_t v265 = v292;
              *(float *)(*(void *)&v265 + 4) = v293;
              *(float *)(*(void *)&v265 + 8) = v294;
              *(_DWORD *)(*(void *)&v265 + 12) = 0;
              *(float *)(*(void *)&v265 + 16) = v270;
              *(void *)&float64_t v268 = *(void *)&v265 + 28;
              *(void *)(*(void *)&v265 + 20) = 0x3F0000003F800000;
              goto LABEL_284;
            }
            float64_t v295 = __p.f64[0];
            uint64_t v296 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v265 - *(void *)&__p.f64[0]) >> 2);
            unint64_t v297 = v296 + 1;
            if ((unint64_t)(v296 + 1) > 0x924924924924924) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            if (0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*(void *)&v574.f64[0] - *(void *)&__p.f64[0]) >> 2) > v297) {
              unint64_t v297 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*(void *)&v574.f64[0] - *(void *)&__p.f64[0]) >> 2);
            }
            if ((unint64_t)(0x6DB6DB6DB6DB6DB7
                                  * ((uint64_t)(*(void *)&v574.f64[0] - *(void *)&__p.f64[0]) >> 2)) >= 0x492492492492492)
              unint64_t v298 = 0x924924924924924;
            else {
              unint64_t v298 = v297;
            }
            if (v298 > 0x924924924924924) {
              goto LABEL_479;
            }
            v299 = (char *)operator new(28 * v298);
            v300 = &v299[4 * ((uint64_t)(*(void *)&v265 - *(void *)&__p.f64[0]) >> 2)];
            *(float *)v300 = v292;
            *((float *)v300 + 1) = v293;
            *((float *)v300 + 2) = v294;
            *((_DWORD *)v300 + 3) = 0;
            *((float *)v300 + 4) = v270;
            *(void *)(v300 + 20) = 0x3F0000003F800000;
            *(void *)&float64_t v301 = &v299[28 * v296];
            if (*(void *)&v265 != *(void *)&v295)
            {
              do
              {
                uint64_t v302 = *(void *)(*(void *)&v265 - 28);
                *(void *)&v265 -= 28;
                int v303 = *(_DWORD *)(*(void *)&v265 + 8);
                *(void *)(*(void *)&v301 - 28) = v302;
                *(void *)&v301 -= 28;
                *(_DWORD *)(*(void *)&v301 + 8) = v303;
                *(_OWORD *)(*(void *)&v301 + 12) = *(_OWORD *)(*(void *)&v265 + 12);
              }
              while (*(void *)&v265 != *(void *)&v295);
LABEL_310:
              float64_t v265 = v295;
            }
LABEL_311:
            *(void *)&float64_t v268 = v300 + 28;
            __p.f64[0] = v301;
            *(void *)&__p.f64[1] = v300 + 28;
            *(void *)&v574.f64[0] = &v299[28 * v298];
            if (v265 != 0.0) {
              operator delete(*(void **)&v265);
            }
LABEL_284:
            ++v266;
            __p.f64[1] = v268;
            uint64_t v263 = v267;
            float64_t v265 = v268;
            v267 += 1992;
            if (v267 == v264) {
          }
            }
          double v283 = -(v280 - v276 * *((double *)&v562 + 1)) - (v280 - v276 * *((double *)&v562 + 1));
          double v284 = v281 + v281;
          double v285 = v282 + v282;
          float v286 = v279 + v283 * v564 + v285 * *((double *)&v562 + 1) - v284 * v563;
          float v287 = *(double *)&v561.__r_.__value_.__l.__size_ + v277 + v283 * v563 + v284 * v564 - v285 * *(double *)&v562;
          float v288 = *(double *)&v561.__r_.__value_.__r.__words[2]
               + v276
               - v283 * *((double *)&v562 + 1)
               + v284 * *(double *)&v562
               + v285 * v564;
          if (*(void *)&v265 < *(void *)&v574.f64[0])
          {
            **(float **)&float64_t v265 = v286;
            *(float *)(*(void *)&v265 + 4) = v287;
            *(float *)(*(void *)&v265 + 8) = v288;
            *(_DWORD *)(*(void *)&v265 + 12) = 1065353216;
            *(float *)(*(void *)&v265 + 16) = v270;
            *(void *)&float64_t v268 = *(void *)&v265 + 28;
            *(void *)(*(void *)&v265 + 20) = 0x3F00000000000000;
            goto LABEL_284;
          }
          float64_t v295 = __p.f64[0];
          uint64_t v304 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v265 - *(void *)&__p.f64[0]) >> 2);
          unint64_t v305 = v304 + 1;
          if ((unint64_t)(v304 + 1) > 0x924924924924924) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          if (0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*(void *)&v574.f64[0] - *(void *)&__p.f64[0]) >> 2) > v305) {
            unint64_t v305 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*(void *)&v574.f64[0] - *(void *)&__p.f64[0]) >> 2);
          }
          if ((unint64_t)(0x6DB6DB6DB6DB6DB7
                                * ((uint64_t)(*(void *)&v574.f64[0] - *(void *)&__p.f64[0]) >> 2)) >= 0x492492492492492)
            unint64_t v298 = 0x924924924924924;
          else {
            unint64_t v298 = v305;
          }
          if (v298 > 0x924924924924924) {
            goto LABEL_479;
          }
          v299 = (char *)operator new(28 * v298);
          v300 = &v299[4 * ((uint64_t)(*(void *)&v265 - *(void *)&__p.f64[0]) >> 2)];
          *(float *)v300 = v286;
          *((float *)v300 + 1) = v287;
          *((float *)v300 + 2) = v288;
          *((_DWORD *)v300 + 3) = 1065353216;
          *((float *)v300 + 4) = v270;
          *(void *)(v300 + 20) = 0x3F00000000000000;
          *(void *)&float64_t v301 = &v299[28 * v304];
          if (*(void *)&v265 == *(void *)&v295) {
            goto LABEL_311;
          }
          do
          {
            uint64_t v306 = *(void *)(*(void *)&v265 - 28);
            *(void *)&v265 -= 28;
            int v307 = *(_DWORD *)(*(void *)&v265 + 8);
            *(void *)(*(void *)&v301 - 28) = v306;
            *(void *)&v301 -= 28;
            *(_DWORD *)(*(void *)&v301 + 8) = v307;
            *(_OWORD *)(*(void *)&v301 + 12) = *(_OWORD *)(*(void *)&v265 + 12);
          }
          while (*(void *)&v265 != *(void *)&v295);
          goto LABEL_310;
        }
      }
    }
LABEL_138:
    unint64_t v131 = v571;
    uint64_t v132 = v571[5];
    double v133 = (unsigned char *)v571[6];
    if ((unsigned char *)v132 == v133) {
      goto LABEL_374;
    }
    uint64_t v134 = (unsigned char *)v571[5];
    while (*v134 != 3)
    {
      v134 += 272;
      if (v134 == v133) {
        goto LABEL_370;
      }
    }
    id v158 = *(id *)v2;
    [v158 size];
    double v160 = v159;
    [*(id *)v2 size];
    double v162 = v161;

    uint64_t v163 = v571[29];
    double v164 = v564;
    unint64_t v165 = (char *)operator new(0x70uLL);
    *(void *)unint64_t v165 = &unk_1EF578C30;
    double v166 = v160 * 95.0 / v162;
    *((double *)v165 + 1) = -v166;
    *((_OWORD *)v165 + 1) = xmmword_1A28FEA00;
    *((double *)v165 + 4) = v166;
    *(_OWORD *)(v165 + 40) = xmmword_1A28FEA10;
    *(std::string *)(v165 + 56) = v561;
    *((_OWORD *)v165 + 5) = v562;
    *((double *)v165 + 12) = v563;
    *((double *)v165 + 13) = v164;
    *(void *)&v574.f64[1] = v165;
    memset(v549, 0, 24);
    double v167 = (pthread_rwlock_t *)(v163 + 96);
    v537.__r_.__value_.__r.__words[0] = v163 + 96;
    double v168 = (geo::read_write_lock *)pthread_rwlock_rdlock((pthread_rwlock_t *)(v163 + 96));
    if (v168) {
      geo::read_write_lock::logFailure(v168, (uint64_t)"read lock", v169);
    }
    double v170 = *(void **)(v163 + 48);
    v518 = (void *)(v163 + 56);
    if (v170 == (void *)(v163 + 56))
    {
LABEL_315:
      v308 = (geo::read_write_lock *)pthread_rwlock_unlock(v167);
      if (v308) {
        geo::read_write_lock::logFailure(v308, (uint64_t)"unlock", v309);
      }
      if (*(float64x2_t **)&v574.f64[1] == &__p)
      {
        (*(void (**)(float64x2_t *))(*(void *)&__p.f64[0] + 32))(&__p);
      }
      else if (*(void *)&v574.f64[1])
      {
        (*(void (**)(void))(**(void **)&v574.f64[1] + 40))();
      }
      unint64_t v310 = 126 - 2 * __clz(0x63FB9AEB1FDCD759 * ((uint64_t)(*((void *)&v549[0] + 1) - *(void *)&v549[0]) >> 3));
      if (*((void *)&v549[0] + 1) == *(void *)&v549[0]) {
        uint64_t v311 = 0;
      }
      else {
        uint64_t v311 = v310;
      }
      std::__introsort<std::_ClassicAlgPolicy,md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_0 &,md::mun::CollectionPoint *,false>(*(uint64_t **)&v549[0], *((uint64_t **)&v549[0] + 1), v311, 1);
      LODWORD(v575.f64[0]) = -2133507750;
      float64x2_t __p = (float64x2_t)xmmword_1A29C30BC;
      float64x2_t v574 = (float64x2_t)unk_1A29C30CC;
      v312 = (uint64_t *)*((void *)this + 20);
      *((void *)this + 20) = 0;
      if (v312)
      {
        v313 = (std::__shared_weak_count *)v312[3];
        if (v313 && !atomic_fetch_add(&v313->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v313->__on_zero_shared)(v313);
          std::__shared_weak_count::__release_weak(v313);
        }
        uint64_t v314 = v312[1];
        v312[1] = 0;
        if (v314) {
          (*(void (**)(uint64_t))(*(void *)v314 + 8))(v314);
        }
        uint64_t v315 = *v312;
        uint64_t *v312 = 0;
        uint64_t v2 = (const md::LayoutContext *)v519;
        if (v315) {
          (*(void (**)(uint64_t))(*(void *)v315 + 8))(v315);
        }
        MEMORY[0x1A6239270](v312, 0x20C40DC1BFBCFLL);
      }
      v316 = (uint64_t *)*((void *)this + 21);
      *((void *)this + 21) = 0;
      if (v316)
      {
        v317 = (std::__shared_weak_count *)v316[3];
        if (v317 && !atomic_fetch_add(&v317->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v317->__on_zero_shared)(v317);
          std::__shared_weak_count::__release_weak(v317);
        }
        uint64_t v318 = v316[1];
        v316[1] = 0;
        if (v318) {
          (*(void (**)(uint64_t))(*(void *)v318 + 8))(v318);
        }
        uint64_t v319 = *v316;
        uint64_t *v316 = 0;
        uint64_t v2 = (const md::LayoutContext *)v519;
        if (v319) {
          (*(void (**)(uint64_t))(*(void *)v319 + 8))(v319);
        }
        MEMORY[0x1A6239270](v316, 0x20C40DC1BFBCFLL);
      }
      v320 = *(void **)&v549[0];
      if (*(void *)&v549[0] != *((void *)&v549[0] + 1))
      {
        memset(&v537, 0, sizeof(v537));
        memset(&v528, 0, sizeof(v528));
        v524.__r_.__value_.__r.__words[0] = 0;
        v523.__r_.__value_.__r.__words[0] = 0;
        uint64_t v321 = v571[29];
        v582 = 0;
        v322 = operator new(0x70uLL);
        void *v322 = &unk_1EF578C78;
        v322[1] = &v561;
        v322[2] = &v537;
        v322[3] = &v570;
        v322[4] = &v571;
        v322[5] = &v528;
        v322[6] = v549;
        v322[7] = &v524;
        v322[8] = &v523;
        v322[9] = &__p;
        v322[10] = this;
        v322[11] = v2;
        v322[12] = &v572;
        v322[13] = &v565;
        v582 = v322;
        md::mun::MuninMetadataContainer::navigationGraphAccessor(v321, (uint64_t)v581);
        if (v582 == v581)
        {
          (*(void (**)(void *))(v581[0] + 32))(v581);
        }
        else if (v582)
        {
          (*(void (**)(void))(*v582 + 40))();
        }
        if (v528.__r_.__value_.__r.__words[0])
        {
          v528.__r_.__value_.__l.__size_ = v528.__r_.__value_.__r.__words[0];
          operator delete(v528.__r_.__value_.__l.__data_);
        }
        if (v537.__r_.__value_.__r.__words[0])
        {
          v537.__r_.__value_.__l.__size_ = v537.__r_.__value_.__r.__words[0];
          operator delete(v537.__r_.__value_.__l.__data_);
        }
        v320 = *(void **)&v549[0];
      }
      if (v320)
      {
        uint64_t v323 = *((void *)&v549[0] + 1);
        v324 = v320;
        if (*((void **)&v549[0] + 1) != v320)
        {
          do
          {
            v325 = (void *)(v323 - 1864);
            v326 = *(void **)(v323 - 1776);
            v327 = *(void **)(v323 - 1768);
            if (v326 != v327)
            {
              do
              {
                v328 = (void *)v326[31];
                if (v328 != (void *)v326[33]) {
                  free(v328);
                }
                v326 += 36;
              }
              while (v326 != v327);
              v326 = *(void **)(v323 - 1776);
            }
            if (v326 != *(void **)(v323 - 1760)) {
              free(v326);
            }
            v323 -= 1864;
          }
          while (v325 != v320);
          v324 = *(void **)&v549[0];
          uint64_t v2 = (const md::LayoutContext *)v519;
        }
        *((void *)&v549[0] + 1) = v320;
        operator delete(v324);
      }
      unint64_t v131 = v571;
      uint64_t v132 = v571[5];
      double v133 = (unsigned char *)v571[6];
LABEL_370:
      while ((unsigned char *)v132 != v133)
      {
        if (!*(unsigned char *)v132)
        {
          if (*(unsigned char *)(v132 + 8))
          {
            double v329 = *(double *)(v132 + 80);
            double v330 = *(double *)(v132 + 88);
            double v332 = *(double *)(v132 + 96);
            double v331 = *(double *)(v132 + 104);
            double v333 = *(double *)(v132 + 112);
            double v334 = *(double *)(v132 + 120);
            double v335 = fmin(sqrt((v331 - v329) * (v331 - v329) + (v333 - v330) * (v333 - v330) + (v334 - v332) * (v334 - v332)), *(double *)(v131[28] + 16));
            double v336 = v329 - v331;
            double v337 = v330 - v333;
            double v338 = v332 - v334;
            double v339 = v335 / sqrt(v336 * v336 + v337 * v337 + v338 * v338);
            *((void *)this + 33) = 0;
            *((void *)this + 34) = 0;
            *((void *)this + 35) = 0;
            *((void *)this + 36) = 0x3FF0000000000000;
            *((double *)this + 30) = v331 + v339 * v336;
            *((double *)this + 31) = v333 + v339 * v337;
            *((double *)this + 32) = v334 + v339 * v338;
          }
          break;
        }
        v132 += 272;
      }
LABEL_374:
      v340 = (uint64_t *)*((void *)this + 11);
      uint64_t v341 = *(void *)(v340[1] + 64);
      v342 = *(void **)v341;
      unint64_t v343 = *(void *)(*(void *)v341 + 8);
      if (v343) {
        v344 = (float32x4_t *)v342[9];
      }
      else {
        v344 = 0;
      }
      double v345 = *((double *)&v562 + 1);
      double v346 = v563;
      double v347 = v345 + v345;
      double v348 = (v345 + v345) * v345;
      double v349 = (v346 + v346) * v346;
      double v350 = *(double *)&v562;
      double v351 = (v350 + v350) * *((double *)&v562 + 1);
      double v352 = (v346 + v346) * v564;
      double v353 = v563 * (v350 + v350);
      double v354 = 1.0 - (v350 + v350) * v350;
      *(double *)&v537.__r_.__value_.__l.__data_ = 1.0 - (v348 + v349);
      *(double *)&v537.__r_.__value_.__l.__size_ = v352 + v351;
      double v539 = v351 - v352;
      double v540 = v354 - v349;
      double v355 = v564 * (v350 + v350);
      double v543 = v564 * v347 + v353;
      double v544 = v347 * v563 - v355;
      *(double *)&v537.__r_.__value_.__r.__words[2] = v353 - v564 * v347;
      double v541 = v355 + v347 * v563;
      double v545 = v354 - v348;
      uint64_t v538 = 0;
      uint64_t v542 = 0;
      uint64_t v546 = 0;
      std::string v547 = v561;
      uint64_t v548 = 0x3FF0000000000000;
      gm::operator*<double,4,4,4>((double *)v549, (double *)v550, (double *)&v537);
      v356 = (void *)*((void *)v2 + 1);
      unint64_t v357 = v356[1];
      if ((v357 & (v357 - 1)) != 0)
      {
        unint64_t v359 = 0x1AF456233693CD46;
        if (v357 <= 0x1AF456233693CD46) {
          unint64_t v359 = 0x1AF456233693CD46 % v357;
        }
        v358 = *(void **)(*v356 + 8 * v359);
        do
        {
          do
            v358 = (void *)*v358;
          while (v358[1] != 0x1AF456233693CD46);
        }
        while (v358[2] != 0x1AF456233693CD46);
      }
      else
      {
        v358 = *(void **)(*v356 + 8 * ((v357 - 1) & 0x1AF456233693CD46));
        do
        {
          do
            v358 = (void *)*v358;
          while (v358[1] != 0x1AF456233693CD46);
        }
        while (v358[2] != 0x1AF456233693CD46);
      }
      uint64_t v360 = *(void *)(v358[5] + 32);
      uint64_t v361 = *(void *)(v360 + 512);
      long long v362 = *(_OWORD *)(v360 + 496);
      *(_OWORD *)&v528.__r_.__value_.__l.__data_ = xmmword_1A28FCBD0;
      v528.__r_.__value_.__r.__words[2] = 0;
      uint64_t v529 = 0;
      long long v530 = xmmword_1A28FCCC0;
      long long v531 = 0u;
      long long v532 = 0u;
      long long v533 = xmmword_1A28FCBD0;
      long long v534 = v362;
      uint64_t v535 = v361;
      uint64_t v536 = 0x3FF0000000000000;
      gm::operator*<double,4,4,4>(__p.f64, (double *)v549, (double *)&v528);
      float32x4_t *v344 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(__p), v574);
      v344[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v575), v576);
      v344[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v577), v578);
      v344[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v579), v580);
      if (v343)
      {
        unint64_t v363 = v342[8];
        if (v363 <= v343) {
          unint64_t v363 = v343;
        }
        v342[7] = 0;
        v342[8] = v363;
      }
      uint64_t v364 = v517;
      ggl::CommandBuffer::pushRenderItem(v517, *v340);
      uint64_t v365 = *((void *)this + 20);
      if (v365)
      {
        uint64_t v366 = *(void *)(*(void *)(*(void *)(v365 + 8) + 64) + 16);
        *(_OWORD *)&v524.__r_.__value_.__l.__data_ = 0uLL;
        unint64_t v367 = *(void *)(v366 + 8);
        *(void *)&long long v368 = 0;
        *((void *)&v368 + 1) = v366;
        if (v367) {
          v369 = *(float32x4_t **)(v366 + 72);
        }
        else {
          v369 = 0;
        }
        *(_OWORD *)&v524.__r_.__value_.__l.__data_ = v368;
        v524.__r_.__value_.__r.__words[2] = 0;
        unint64_t v525 = v367;
        v527 = v369;
        __int16 v526 = 1;
        double v370 = *((double *)&v562 + 1);
        double v371 = v563;
        double v372 = v370 + v370;
        double v373 = (v370 + v370) * v370;
        double v374 = (v371 + v371) * v371;
        double v375 = *(double *)&v562;
        double v376 = v375 + v375;
        double v377 = (v375 + v375) * *((double *)&v562 + 1);
        double v378 = (v371 + v371) * v564;
        double v379 = v563 * (v375 + v375);
        double v380 = 1.0 - (v375 + v375) * v375;
        *(double *)&v537.__r_.__value_.__l.__data_ = 1.0 - (v373 + v374);
        *(double *)&v537.__r_.__value_.__l.__size_ = v378 + v377;
        double v539 = v377 - v378;
        double v540 = v380 - v374;
        double v543 = v564 * v372 + v379;
        double v544 = v372 * v563 - v564 * v376;
        *(double *)&v537.__r_.__value_.__r.__words[2] = v379 - v564 * v372;
        double v541 = v564 * v376 + v372 * v563;
        double v545 = v380 - v373;
        uint64_t v538 = 0;
        uint64_t v542 = 0;
        uint64_t v546 = 0;
        std::string v547 = v561;
        uint64_t v548 = 0x3FF0000000000000;
        gm::operator*<double,4,4,4>((double *)v549, (double *)v550, (double *)&v537);
        double v381 = *((double *)this + 26);
        double v382 = *((double *)this + 27);
        double v383 = *((double *)this + 28);
        double v384 = v381 + v381;
        double v385 = (v381 + v381) * v381;
        double v386 = (v382 + v382) * v382;
        uint64_t v388 = *((void *)this + 24);
        double v387 = *((double *)this + 25);
        double v389 = v387 + v387;
        double v390 = (v387 + v387) * v381;
        double v391 = (v382 + v382) * v383;
        double v392 = v382 * (v387 + v387);
        double v393 = 1.0 - (v387 + v387) * v387;
        double v394 = v384 * v382;
        *(double *)&v528.__r_.__value_.__l.__data_ = 1.0 - (v385 + v386);
        *(double *)&v528.__r_.__value_.__l.__size_ = v391 + v390;
        *(double *)&long long v530 = v390 - v391;
        *((double *)&v530 + 1) = v393 - v386;
        *(double *)&long long v532 = v383 * v384 + v392;
        *((double *)&v532 + 1) = v394 - v383 * v389;
        *(double *)&v528.__r_.__value_.__r.__words[2] = v392 - v383 * v384;
        long long v531 = COERCE_UNSIGNED_INT64(v383 * v389 + v394);
        *(double *)&long long v533 = v393 - v385;
        uint64_t v529 = 0;
        *((void *)&v533 + 1) = 0;
        long long v534 = *((_OWORD *)this + 11);
        uint64_t v535 = v388;
        uint64_t v536 = 0x3FF0000000000000;
        gm::operator*<double,4,4,4>(__p.f64, (double *)v549, (double *)&v528);
        v395 = v527;
        float32x4_t *v527 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(__p), v574);
        v395[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v575), v576);
        v395[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v577), v578);
        v395[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v579), v580);
        ggl::CommandBuffer::pushRenderItem(v517, **((void **)this + 20));
        unint64_t v397 = v524.__r_.__value_.__r.__words[2];
        unint64_t v396 = v525;
        if (v525 != v524.__r_.__value_.__r.__words[2])
        {
          size = (void *)v524.__r_.__value_.__l.__size_;
          int v399 = v526;
          int v400 = HIBYTE(v526);
          if (v524.__r_.__value_.__r.__words[0] && *(unsigned char *)(v524.__r_.__value_.__l.__size_ + 17) != 2) {
            (*(void (**)(void))(*(void *)v524.__r_.__value_.__l.__data_ + 64))();
          }
          if (v399 && !v400)
          {
            unint64_t v402 = size[7];
            unint64_t v401 = size[8];
            if (v401 == v402) {
              unint64_t v402 = size[10] - size[9];
            }
            if (v397 < v402) {
              unint64_t v402 = v397;
            }
            if (v401 <= v396) {
              unint64_t v401 = v396;
            }
            if (v401 == v402) {
              unint64_t v401 = v402 + size[10] - size[9];
            }
            size[7] = v402;
            size[8] = v401;
          }
        }
        uint64_t v2 = (const md::LayoutContext *)v519;
        uint64_t v364 = v517;
      }
      uint64_t v403 = *((void *)this + 21);
      if (v403)
      {
        uint64_t v404 = *(void *)(*(void *)(*(void *)(v403 + 8) + 64) + 16);
        *(_OWORD *)&v524.__r_.__value_.__l.__data_ = 0uLL;
        unint64_t v405 = *(void *)(v404 + 8);
        *(void *)&long long v406 = 0;
        *((void *)&v406 + 1) = v404;
        if (v405) {
          v407 = *(float32x4_t **)(v404 + 72);
        }
        else {
          v407 = 0;
        }
        *(_OWORD *)&v524.__r_.__value_.__l.__data_ = v406;
        v524.__r_.__value_.__r.__words[2] = 0;
        unint64_t v525 = v405;
        v527 = v407;
        __int16 v526 = 1;
        double v408 = *((double *)&v562 + 1);
        double v409 = v563;
        double v410 = v408 + v408;
        double v411 = (v408 + v408) * v408;
        double v412 = (v409 + v409) * v409;
        double v413 = *(double *)&v562;
        double v414 = v413 + v413;
        double v415 = (v413 + v413) * *((double *)&v562 + 1);
        double v416 = (v409 + v409) * v564;
        double v417 = v563 * (v413 + v413);
        double v418 = 1.0 - (v413 + v413) * v413;
        *(double *)&v537.__r_.__value_.__l.__data_ = 1.0 - (v411 + v412);
        *(double *)&v537.__r_.__value_.__l.__size_ = v416 + v415;
        double v539 = v415 - v416;
        double v540 = v418 - v412;
        double v543 = v564 * v410 + v417;
        double v544 = v410 * v563 - v564 * v414;
        *(double *)&v537.__r_.__value_.__r.__words[2] = v417 - v564 * v410;
        double v541 = v564 * v414 + v410 * v563;
        double v545 = v418 - v411;
        uint64_t v538 = 0;
        uint64_t v542 = 0;
        uint64_t v546 = 0;
        std::string v547 = v561;
        uint64_t v548 = 0x3FF0000000000000;
        gm::operator*<double,4,4,4>((double *)v549, (double *)v550, (double *)&v537);
        double v419 = *((double *)this + 26);
        double v420 = *((double *)this + 27);
        double v421 = *((double *)this + 28);
        double v422 = v419 + v419;
        double v423 = (v419 + v419) * v419;
        double v424 = (v420 + v420) * v420;
        uint64_t v426 = *((void *)this + 24);
        double v425 = *((double *)this + 25);
        double v427 = v425 + v425;
        double v428 = (v425 + v425) * v419;
        double v429 = (v420 + v420) * v421;
        double v430 = v420 * (v425 + v425);
        double v431 = 1.0 - (v425 + v425) * v425;
        double v432 = v422 * v420;
        *(double *)&v528.__r_.__value_.__l.__data_ = 1.0 - (v423 + v424);
        *(double *)&v528.__r_.__value_.__l.__size_ = v429 + v428;
        *(double *)&long long v530 = v428 - v429;
        *((double *)&v530 + 1) = v431 - v424;
        *(double *)&long long v532 = v421 * v422 + v430;
        *((double *)&v532 + 1) = v432 - v421 * v427;
        *(double *)&v528.__r_.__value_.__r.__words[2] = v430 - v421 * v422;
        long long v531 = COERCE_UNSIGNED_INT64(v421 * v427 + v432);
        *(double *)&long long v533 = v431 - v423;
        uint64_t v529 = 0;
        *((void *)&v533 + 1) = 0;
        long long v534 = *((_OWORD *)this + 11);
        uint64_t v535 = v426;
        uint64_t v536 = 0x3FF0000000000000;
        gm::operator*<double,4,4,4>(__p.f64, (double *)v549, (double *)&v528);
        v433 = v527;
        float32x4_t *v527 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(__p), v574);
        v433[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v575), v576);
        v433[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v577), v578);
        v433[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v579), v580);
        ggl::CommandBuffer::pushRenderItem(v364, **((void **)this + 21));
        unint64_t v435 = v524.__r_.__value_.__r.__words[2];
        unint64_t v434 = v525;
        if (v525 != v524.__r_.__value_.__r.__words[2])
        {
          v436 = (void *)v524.__r_.__value_.__l.__size_;
          int v437 = v526;
          int v438 = HIBYTE(v526);
          if (v524.__r_.__value_.__r.__words[0] && *(unsigned char *)(v524.__r_.__value_.__l.__size_ + 17) != 2) {
            (*(void (**)(void))(*(void *)v524.__r_.__value_.__l.__data_ + 64))();
          }
          if (v437 && !v438)
          {
            unint64_t v440 = v436[7];
            unint64_t v439 = v436[8];
            if (v439 == v440) {
              unint64_t v440 = v436[10] - v436[9];
            }
            if (v435 < v440) {
              unint64_t v440 = v435;
            }
            if (v439 <= v434) {
              unint64_t v439 = v434;
            }
            if (v439 == v440) {
              unint64_t v439 = v440 + v436[10] - v436[9];
            }
            v436[7] = v440;
            v436[8] = v439;
          }
        }
        uint64_t v2 = (const md::LayoutContext *)v519;
        uint64_t v364 = v517;
      }
      uint64_t v441 = *((void *)this + 12);
      if (v441)
      {
        uint64_t v442 = **(void **)(*(void *)(v441 + 8) + 64);
        *(_OWORD *)&v524.__r_.__value_.__l.__data_ = 0uLL;
        unint64_t v443 = *(void *)(v442 + 8);
        *(void *)&long long v444 = 0;
        *((void *)&v444 + 1) = v442;
        if (v443) {
          v445 = *(float32x4_t **)(v442 + 72);
        }
        else {
          v445 = 0;
        }
        *(_OWORD *)&v524.__r_.__value_.__l.__data_ = v444;
        v524.__r_.__value_.__r.__words[2] = 0;
        unint64_t v525 = v443;
        v527 = v445;
        __int16 v526 = 1;
        double v446 = *((double *)&v562 + 1);
        double v447 = v563;
        double v448 = v446 + v446;
        double v449 = (v446 + v446) * v446;
        double v450 = (v447 + v447) * v447;
        double v451 = *(double *)&v562;
        double v452 = v451 + v451;
        double v453 = (v451 + v451) * *((double *)&v562 + 1);
        double v454 = (v447 + v447) * v564;
        double v455 = v563 * (v451 + v451);
        double v456 = 1.0 - (v451 + v451) * v451;
        *(double *)&v537.__r_.__value_.__l.__data_ = 1.0 - (v449 + v450);
        *(double *)&v537.__r_.__value_.__l.__size_ = v454 + v453;
        double v539 = v453 - v454;
        double v540 = v456 - v450;
        double v543 = v564 * v448 + v455;
        double v544 = v448 * v563 - v564 * v452;
        *(double *)&v537.__r_.__value_.__r.__words[2] = v455 - v564 * v448;
        double v541 = v564 * v452 + v448 * v563;
        double v545 = v456 - v449;
        uint64_t v538 = 0;
        uint64_t v542 = 0;
        uint64_t v546 = 0;
        std::string v547 = v561;
        uint64_t v548 = 0x3FF0000000000000;
        gm::operator*<double,4,4,4>((double *)v549, (double *)v550, (double *)&v537);
        double v457 = *((double *)this + 17);
        double v458 = *((double *)this + 18);
        double v459 = *((double *)this + 19);
        double v460 = v457 + v457;
        double v461 = (v457 + v457) * v457;
        double v462 = (v458 + v458) * v458;
        uint64_t v464 = *((void *)this + 15);
        double v463 = *((double *)this + 16);
        double v465 = v463 + v463;
        double v466 = (v463 + v463) * v457;
        double v467 = (v458 + v458) * v459;
        double v468 = v458 * (v463 + v463);
        double v469 = 1.0 - (v463 + v463) * v463;
        double v470 = v460 * v458;
        *(double *)&v528.__r_.__value_.__l.__data_ = 1.0 - (v461 + v462);
        *(double *)&v528.__r_.__value_.__l.__size_ = v467 + v466;
        *(double *)&long long v530 = v466 - v467;
        *((double *)&v530 + 1) = v469 - v462;
        *(double *)&long long v532 = v459 * v460 + v468;
        *((double *)&v532 + 1) = v470 - v459 * v465;
        *(double *)&v528.__r_.__value_.__r.__words[2] = v468 - v459 * v460;
        long long v531 = COERCE_UNSIGNED_INT64(v459 * v465 + v470);
        *(double *)&long long v533 = v469 - v461;
        uint64_t v529 = 0;
        *((void *)&v533 + 1) = 0;
        long long v534 = *(_OWORD *)((char *)this + 104);
        uint64_t v535 = v464;
        uint64_t v536 = 0x3FF0000000000000;
        gm::operator*<double,4,4,4>(__p.f64, (double *)v549, (double *)&v528);
        v471 = v527;
        float32x4_t *v527 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(__p), v574);
        v471[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v575), v576);
        v471[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v577), v578);
        v471[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v579), v580);
        ggl::CommandBuffer::pushRenderItem(v364, **((void **)this + 12));
        unint64_t v473 = v524.__r_.__value_.__r.__words[2];
        unint64_t v472 = v525;
        if (v525 != v524.__r_.__value_.__r.__words[2])
        {
          v474 = (void *)v524.__r_.__value_.__l.__size_;
          int v475 = v526;
          int v476 = HIBYTE(v526);
          if (v524.__r_.__value_.__r.__words[0] && *(unsigned char *)(v524.__r_.__value_.__l.__size_ + 17) != 2) {
            (*(void (**)(void))(*(void *)v524.__r_.__value_.__l.__data_ + 64))();
          }
          if (v475 && !v476)
          {
            unint64_t v478 = v474[7];
            unint64_t v477 = v474[8];
            if (v477 == v478) {
              unint64_t v478 = v474[10] - v474[9];
            }
            if (v473 < v478) {
              unint64_t v478 = v473;
            }
            if (v477 <= v472) {
              unint64_t v477 = v472;
            }
            if (v477 == v478) {
              unint64_t v477 = v478 + v474[10] - v474[9];
            }
            v474[7] = v478;
            v474[8] = v477;
          }
        }
        uint64_t v2 = (const md::LayoutContext *)v519;
        uint64_t v364 = v517;
      }
      if (*((double *)this + 30) * *((double *)this + 30)
         + *((double *)this + 31) * *((double *)this + 31)
         + *((double *)this + 32) * *((double *)this + 32) > 0.0)
      {
        uint64_t v479 = **(void **)(*(void *)(*((void *)this + 29) + 8) + 64);
        *(_OWORD *)&v524.__r_.__value_.__l.__data_ = 0uLL;
        unint64_t v480 = *(void *)(v479 + 8);
        *(void *)&long long v481 = 0;
        *((void *)&v481 + 1) = v479;
        if (v480) {
          v482 = *(float32x4_t **)(v479 + 72);
        }
        else {
          v482 = 0;
        }
        *(_OWORD *)&v524.__r_.__value_.__l.__data_ = v481;
        v524.__r_.__value_.__r.__words[2] = 0;
        unint64_t v525 = v480;
        v527 = v482;
        __int16 v526 = 1;
        double v483 = *((double *)&v562 + 1);
        double v484 = v563;
        double v485 = v483 + v483;
        double v486 = (v483 + v483) * v483;
        double v487 = (v484 + v484) * v484;
        double v488 = *(double *)&v562;
        double v489 = v488 + v488;
        double v490 = (v488 + v488) * *((double *)&v562 + 1);
        double v491 = (v484 + v484) * v564;
        double v492 = v563 * (v488 + v488);
        double v493 = 1.0 - (v488 + v488) * v488;
        *(double *)&v537.__r_.__value_.__l.__data_ = 1.0 - (v486 + v487);
        *(double *)&v537.__r_.__value_.__l.__size_ = v491 + v490;
        double v539 = v490 - v491;
        double v540 = v493 - v487;
        double v543 = v564 * v485 + v492;
        double v544 = v485 * v563 - v564 * v489;
        *(double *)&v537.__r_.__value_.__r.__words[2] = v492 - v564 * v485;
        double v541 = v564 * v489 + v485 * v563;
        double v545 = v493 - v486;
        uint64_t v538 = 0;
        uint64_t v542 = 0;
        uint64_t v546 = 0;
        std::string v547 = v561;
        uint64_t v548 = 0x3FF0000000000000;
        gm::operator*<double,4,4,4>((double *)v549, (double *)v550, (double *)&v537);
        double v494 = *((double *)this + 34);
        double v495 = *((double *)this + 35);
        double v496 = *((double *)this + 36);
        double v497 = v494 + v494;
        double v498 = (v494 + v494) * v494;
        double v499 = (v495 + v495) * v495;
        uint64_t v501 = *((void *)this + 32);
        double v500 = *((double *)this + 33);
        double v502 = v500 + v500;
        double v503 = (v500 + v500) * v494;
        double v504 = (v495 + v495) * v496;
        double v505 = v495 * (v500 + v500);
        double v506 = 1.0 - (v500 + v500) * v500;
        double v507 = v497 * v495;
        *(double *)&v528.__r_.__value_.__l.__data_ = 1.0 - (v498 + v499);
        *(double *)&v528.__r_.__value_.__l.__size_ = v504 + v503;
        *(double *)&long long v530 = v503 - v504;
        *((double *)&v530 + 1) = v506 - v499;
        *(double *)&long long v532 = v496 * v497 + v505;
        *((double *)&v532 + 1) = v507 - v496 * v502;
        *(double *)&v528.__r_.__value_.__r.__words[2] = v505 - v496 * v497;
        long long v531 = COERCE_UNSIGNED_INT64(v496 * v502 + v507);
        *(double *)&long long v533 = v506 - v498;
        uint64_t v529 = 0;
        *((void *)&v533 + 1) = 0;
        long long v534 = *((_OWORD *)this + 15);
        uint64_t v535 = v501;
        uint64_t v536 = 0x3FF0000000000000;
        gm::operator*<double,4,4,4>(__p.f64, (double *)v549, (double *)&v528);
        v508 = v527;
        float32x4_t *v527 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(__p), v574);
        v508[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v575), v576);
        v508[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v577), v578);
        v508[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v579), v580);
        ggl::CommandBuffer::pushRenderItem(v364, **((void **)this + 29));
        unint64_t v510 = v524.__r_.__value_.__r.__words[2];
        unint64_t v509 = v525;
        if (v525 != v524.__r_.__value_.__r.__words[2])
        {
          v511 = (void *)v524.__r_.__value_.__l.__size_;
          int v512 = v526;
          int v513 = HIBYTE(v526);
          if (v524.__r_.__value_.__r.__words[0] && *(unsigned char *)(v524.__r_.__value_.__l.__size_ + 17) != 2) {
            (*(void (**)(void))(*(void *)v524.__r_.__value_.__l.__data_ + 64))();
          }
          if (v512 && !v513)
          {
            unint64_t v515 = v511[7];
            unint64_t v514 = v511[8];
            if (v514 == v515) {
              unint64_t v515 = v511[10] - v511[9];
            }
            if (v510 < v515) {
              unint64_t v515 = v510;
            }
            if (v514 <= v509) {
              unint64_t v514 = v509;
            }
            if (v514 == v515) {
              unint64_t v514 = v515 + v511[10] - v511[9];
            }
            v511[7] = v515;
            v511[8] = v514;
          }
        }
        uint64_t v2 = (const md::LayoutContext *)v519;
      }

      goto LABEL_472;
    }
    while (1)
    {
      uint64_t v171 = v170[4];
      uint64_t v173 = *(void *)(v171 + 168);
      uint64_t v172 = *(void *)(v171 + 176);
      uint64_t v520 = v172;
      if (v173 != v172) {
        break;
      }
LABEL_184:
      unint64_t v174 = (void *)v170[1];
      if (v174)
      {
        do
        {
          unint64_t v175 = v174;
          unint64_t v174 = (void *)*v174;
        }
        while (v174);
      }
      else
      {
        do
        {
          unint64_t v175 = (void *)v170[2];
          BOOL v176 = *v175 == (void)v170;
          double v170 = v175;
        }
        while (!v176);
      }
      double v170 = v175;
      if (v175 == v518)
      {
        double v167 = (pthread_rwlock_t *)v537.__r_.__value_.__r.__words[0];
        goto LABEL_315;
      }
    }
LABEL_193:
    if (!*(void *)&v574.f64[1])
    {
      std::__throw_bad_function_call[abi:nn180100]();
      __break(1u);
      return;
    }
    if (!(*(unsigned int (**)(void, uint64_t))(**(void **)&v574.f64[1] + 48))(*(void *)&v574.f64[1], v173))goto LABEL_192; {
    uint64_t v178 = *((void *)&v549[0] + 1);
    }
    if (*((void *)&v549[0] + 1) >= *(void *)&v549[1])
    {
      uint64_t v177 = std::vector<md::mun::CollectionPoint>::__push_back_slow_path<md::mun::CollectionPoint const&>((uint64_t *)v549, v173);
      goto LABEL_191;
    }
    **((void **)&v549[0] + 1) = *(void *)v173;
    long long v179 = *(_OWORD *)(v173 + 8);
    *(void *)(v178 + 24) = *(void *)(v173 + 24);
    *(_OWORD *)(v178 + 8) = v179;
    uint64_t v180 = *(void *)(v173 + 32);
    *(_DWORD *)(v178 + 40) = *(_DWORD *)(v173 + 40);
    *(void *)(v178 + 32) = v180;
    *(void *)(v178 + 44) = *(void *)(v173 + 44);
    long long v181 = *(_OWORD *)(v173 + 56);
    *(_OWORD *)(v178 + 72) = *(_OWORD *)(v173 + 72);
    *(_OWORD *)(v178 + 56) = v181;
    v182 = (char *)(v178 + 120);
    *(void *)(v178 + 88) = v178 + 120;
    *(void *)(v178 + 96) = v178 + 120;
    *(void *)(v178 + 104) = v178 + 120;
    *(void *)(v178 + 112) = 6;
    v183 = *(long long **)(v173 + 88);
    double v184 = *(long long **)(v173 + 96);
    unint64_t v185 = 0x8E38E38E38E38E39 * (((char *)v184 - (char *)v183) >> 5);
    if (v185 < 7) {
      goto LABEL_227;
    }
    if (v185 <= 8) {
      unint64_t v186 = 8;
    }
    else {
      unint64_t v186 = 0x8E38E38E38E38E39 * (((char *)v184 - (char *)v183) >> 5);
    }
    double v187 = (char *)malloc_type_malloc(288 * v186, 0x1010040C6D9B592uLL);
    v182 = v187;
    double v188 = *(long long **)(v178 + 88);
    double v189 = *(long long **)(v178 + 96);
    if (v188 == v189) {
      goto LABEL_226;
    }
    uint64_t v190 = 0;
    double v191 = v187;
    while (1)
    {
      long long v192 = *v188;
      *((void *)v191 + 2) = *((void *)v188 + 2);
      *(_OWORD *)double v191 = v192;
      uint64_t v193 = *((void *)v188 + 3);
      *((_DWORD *)v191 + 8) = *((_DWORD *)v188 + 8);
      *((void *)v191 + 3) = v193;
      *(void *)(v191 + 36) = *(void *)((char *)v188 + 36);
      long long v194 = *(long long *)((char *)v188 + 44);
      long long v195 = *(long long *)((char *)v188 + 60);
      long long v196 = *(long long *)((char *)v188 + 76);
      *(_OWORD *)(v191 + 92) = *(long long *)((char *)v188 + 92);
      *(_OWORD *)(v191 + 76) = v196;
      *(_OWORD *)(v191 + 60) = v195;
      *(_OWORD *)(v191 + 44) = v194;
      long long v197 = *(long long *)((char *)v188 + 108);
      long long v198 = *(long long *)((char *)v188 + 124);
      long long v199 = *(long long *)((char *)v188 + 140);
      *(_OWORD *)(v191 + 156) = *(long long *)((char *)v188 + 156);
      *(_OWORD *)(v191 + 140) = v199;
      *(_OWORD *)(v191 + 124) = v198;
      *(_OWORD *)(v191 + 108) = v197;
      long long v200 = *(long long *)((char *)v188 + 172);
      long long v201 = *(long long *)((char *)v188 + 188);
      long long v202 = *(long long *)((char *)v188 + 204);
      *(_OWORD *)(v191 + 220) = *(long long *)((char *)v188 + 220);
      *(_OWORD *)(v191 + 204) = v202;
      *(_OWORD *)(v191 + 188) = v201;
      *(_OWORD *)(v191 + 172) = v200;
      v203 = v191 + 280;
      *((void *)v191 + 31) = v191 + 280;
      v204 = (char *)*((void *)v188 + 31);
      *((_DWORD *)v191 + 59) = *((_DWORD *)v188 + 59);
      v191[240] = *((unsigned char *)v188 + 240);
      *((void *)v191 + 32) = v191 + 280;
      *((void *)v191 + 33) = v191 + 280;
      *((void *)v191 + 34) = *((void *)v188 + 34);
      if (v204 == *((char **)v188 + 33))
      {
        *((void *)v191 + 32) = &v203[*((void *)v188 + 32) - (void)v204];
        v205 = (char *)*((void *)v188 + 32);
        if (v204 != v205)
        {
          unint64_t v206 = v205 - v204;
          if ((unint64_t)(v205 - v204) >= 8 && (unint64_t)(&v182[288 * v190 + 280] - v204) >= 0x20)
          {
            if (v206 < 0x20)
            {
              unint64_t v207 = 0;
              goto LABEL_214;
            }
            uint64_t v208 = 0;
            unint64_t v207 = v206 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v209 = *(_OWORD *)&v204[v208 + 16];
              *(_OWORD *)&v191[v208 + 280] = *(_OWORD *)&v204[v208];
              *(_OWORD *)&v191[v208 + 296] = v209;
              v208 += 32;
            }
            while (v207 != v208);
            if (v206 == v207) {
              goto LABEL_203;
            }
            if ((v206 & 0x18) != 0)
            {
LABEL_214:
              unint64_t v210 = v206 & 0xFFFFFFFFFFFFFFF8;
              v203 += v206 & 0xFFFFFFFFFFFFFFF8;
              do
              {
                *(void *)&v191[v207 + 280] = *(void *)&v204[v207];
                v207 += 8;
              }
              while (v210 != v207);
              if (v206 == v210) {
                goto LABEL_203;
              }
              v204 += v210;
            }
            else
            {
              v204 += v207;
              v203 += v207;
            }
          }
          do
          {
            char v211 = *v204++;
            *v203++ = v211;
          }
          while (v204 != v205);
        }
      }
      else
      {
        *((void *)v191 + 31) = v204;
        *((void *)v191 + 32) = *((void *)v188 + 32);
        *(long long *)((char *)v188 + 248) = 0u;
        *(long long *)((char *)v188 + 264) = 0u;
      }
LABEL_203:
      v191 += 288;
      v188 += 18;
      ++v190;
      if (v188 == v189)
      {
        uint64_t v212 = *(void *)(v178 + 88);
        uint64_t v213 = *(void *)(v178 + 96);
        while (v212 != v213)
        {
          v214 = *(void **)(v212 + 248);
          if (v214 != *(void **)(v212 + 264)) {
            free(v214);
          }
          v212 += 288;
        }
LABEL_226:
        *(void *)(v178 + 88) = v182;
        *(void *)(v178 + 96) = v182;
        *(void *)(v178 + 112) = v186;
        unint64_t v185 = 0x8E38E38E38E38E39 * (((char *)v184 - (char *)v183) >> 5);
        this = v522;
LABEL_227:
        if (v183 == v184) {
          goto LABEL_271;
        }
        unint64_t v521 = v185;
        while (2)
        {
          long long v216 = *v183;
          *((void *)v182 + 2) = *((void *)v183 + 2);
          *(_OWORD *)v182 = v216;
          uint64_t v217 = *((void *)v183 + 3);
          *((_DWORD *)v182 + 8) = *((_DWORD *)v183 + 8);
          *((void *)v182 + 3) = v217;
          *(void *)(v182 + 36) = *(void *)((char *)v183 + 36);
          long long v218 = *(long long *)((char *)v183 + 44);
          long long v219 = *(long long *)((char *)v183 + 60);
          long long v220 = *(long long *)((char *)v183 + 76);
          *(_OWORD *)(v182 + 92) = *(long long *)((char *)v183 + 92);
          *(_OWORD *)(v182 + 76) = v220;
          *(_OWORD *)(v182 + 60) = v219;
          *(_OWORD *)(v182 + 44) = v218;
          long long v221 = *(long long *)((char *)v183 + 108);
          long long v222 = *(long long *)((char *)v183 + 124);
          long long v223 = *(long long *)((char *)v183 + 140);
          *(_OWORD *)(v182 + 156) = *(long long *)((char *)v183 + 156);
          *(_OWORD *)(v182 + 140) = v223;
          *(_OWORD *)(v182 + 124) = v222;
          *(_OWORD *)(v182 + 108) = v221;
          long long v224 = *(long long *)((char *)v183 + 172);
          long long v225 = *(long long *)((char *)v183 + 188);
          long long v226 = *(long long *)((char *)v183 + 204);
          *(_OWORD *)(v182 + 220) = *(long long *)((char *)v183 + 220);
          *(_OWORD *)(v182 + 204) = v226;
          *(_OWORD *)(v182 + 188) = v225;
          *(_OWORD *)(v182 + 172) = v224;
          *((_DWORD *)v182 + 59) = *((_DWORD *)v183 + 59);
          v182[240] = *((unsigned char *)v183 + 240);
          v215 = v182 + 280;
          *((void *)v182 + 31) = v182 + 280;
          *((void *)v182 + 32) = v182 + 280;
          *((void *)v182 + 33) = v182 + 280;
          *((void *)v182 + 34) = 2;
          v228 = (char *)*((void *)v183 + 31);
          v227 = (char *)*((void *)v183 + 32);
          unint64_t v229 = v227 - v228;
          if ((unint64_t)(v227 - v228) < 3) {
            goto LABEL_252;
          }
          if (v229 <= 4) {
            size_t v230 = 4;
          }
          else {
            size_t v230 = v227 - v228;
          }
          v215 = (char *)malloc_type_malloc(v230, 0x100004077774924uLL);
          v231 = (char *)*((void *)v182 + 31);
          v232 = (char *)*((void *)v182 + 32);
          if (v231 == v232) {
            goto LABEL_251;
          }
          unint64_t v233 = v232 - v231;
          if ((unint64_t)(v232 - v231) < 8)
          {
            v234 = v215;
            goto LABEL_250;
          }
          v234 = v215;
          if ((unint64_t)(v215 - v231) < 0x20) {
            goto LABEL_250;
          }
          if (v233 >= 0x20)
          {
            unint64_t v235 = v233 & 0xFFFFFFFFFFFFFFE0;
            v236 = (long long *)(v231 + 16);
            v237 = v215 + 16;
            unint64_t v238 = v233 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v239 = *v236;
              *(v237 - 1) = *(v236 - 1);
              _OWORD *v237 = v239;
              v236 += 2;
              v237 += 2;
              v238 -= 32;
            }
            while (v238);
            if (v233 == v235) {
              goto LABEL_251;
            }
            if ((v233 & 0x18) != 0) {
              goto LABEL_245;
            }
            v231 += v235;
            v234 = &v215[v235];
            do
            {
LABEL_250:
              char v245 = *v231++;
              *v234++ = v245;
            }
            while (v231 != v232);
            goto LABEL_251;
          }
          unint64_t v235 = 0;
LABEL_245:
          unint64_t v240 = v233 & 0xFFFFFFFFFFFFFFF8;
          v234 = &v215[v233 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v241 = v235 - (v233 & 0xFFFFFFFFFFFFFFF8);
          v242 = (uint64_t *)&v231[v235];
          v243 = &v215[v235];
          do
          {
            uint64_t v244 = *v242++;
            *(void *)v243 = v244;
            v243 += 8;
            v241 += 8;
          }
          while (v241);
          if (v233 != v240)
          {
            v231 += v240;
            goto LABEL_250;
          }
LABEL_251:
          *((void *)v182 + 31) = v215;
          *((void *)v182 + 32) = v215;
          *((void *)v182 + 34) = v230;
LABEL_252:
          if (v228 == v227) {
            goto LABEL_230;
          }
          if (v229 < 8)
          {
            v247 = v215;
            goto LABEL_268;
          }
          if ((unint64_t)(v215 - v228) < 0x20)
          {
            v247 = v215;
            goto LABEL_268;
          }
          if (v229 >= 0x20)
          {
            unint64_t v246 = v229 & 0xFFFFFFFFFFFFFFE0;
            v248 = (long long *)(v228 + 16);
            v249 = v215 + 16;
            unint64_t v250 = v229 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v251 = *v248;
              *(v249 - 1) = *(v248 - 1);
              _OWORD *v249 = v251;
              v248 += 2;
              v249 += 2;
              v250 -= 32;
            }
            while (v250);
            if (v229 == v246) {
              goto LABEL_229;
            }
            if ((v229 & 0x18) != 0) {
              goto LABEL_263;
            }
            v228 += v246;
            v247 = &v215[v246];
            do
            {
LABEL_268:
              char v257 = *v228++;
              *v247++ = v257;
            }
            while (v228 != v227);
            goto LABEL_229;
          }
          unint64_t v246 = 0;
LABEL_263:
          unint64_t v252 = v229 & 0xFFFFFFFFFFFFFFF8;
          v247 = &v215[v229 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v253 = v246 - (v229 & 0xFFFFFFFFFFFFFFF8);
          v254 = (uint64_t *)&v228[v246];
          v255 = &v215[v246];
          do
          {
            uint64_t v256 = *v254++;
            *(void *)v255 = v256;
            v255 += 8;
            v253 += 8;
          }
          while (v253);
          if (v229 != v252)
          {
            v228 += v252;
            goto LABEL_268;
          }
LABEL_229:
          v215 = (char *)*((void *)v182 + 32);
LABEL_230:
          *((void *)v182 + 32) = &v215[v229];
          v183 += 18;
          v182 += 288;
          if (v183 != v184) {
            continue;
          }
          break;
        }
        v182 = *(char **)(v178 + 96);
        this = v522;
        unint64_t v185 = v521;
LABEL_271:
        *(void *)(v178 + 96) = &v182[288 * v185];
        uint64_t v258 = *(void *)(v173 + 1848);
        *(void *)(v178 + 1853) = *(void *)(v173 + 1853);
        *(void *)(v178 + 1848) = v258;
        uint64_t v177 = (char *)(v178 + 1864);
        uint64_t v2 = (const md::LayoutContext *)v519;
        uint64_t v172 = v520;
LABEL_191:
        *((void *)&v549[0] + 1) = v177;
LABEL_192:
        v173 += 1864;
        if (v173 == v172) {
          goto LABEL_184;
        }
        goto LABEL_193;
      }
    }
  }
LABEL_472:
  if (objc_msgSend(v570, "muninShowRigTransitionInfo", v517)
    && *(void *)v2
    && (objc_opt_respondsToSelector() & 1) != 0)
  {
    v516 = (ggl::DebugConsole *)[*(id *)v2 debugConsoleForId:17];
    if (v516) {
      ggl::DebugConsole::begin(v516);
    }
  }
}

void sub_1A237BC80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41)
{
  id v43 = (void *)STACK[0x320];
  if (STACK[0x320])
  {
    STACK[0x328] = (unint64_t)v43;
    operator delete(v43);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a41);

  _Unwind_Resume(a1);
}

void anonymous namespace'::createPointsDrawable(id *a1, void *a2)
{
  uint64_t v3 = *(void *)([a2 device] + 24);
  uint64_t v5 = *(void *)(v3 + 16);
  uint64_t v4 = *(void *)(v3 + 24);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint8x8_t v6 = (long long *)[*a1 format];
  long long v88 = *v6;
  long long v89 = v6[1];
  uint64_t v7 = *(void *)(v5 + 80);
  uint64_t v8 = *(void *)(v7 + 1928);
  unint64_t v9 = *(std::__shared_weak_count **)(v7 + 1936);
  uint64_t v86 = v8;
  double v87 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  id v10 = (char *)operator new(0x198uLL);
  *((void *)v10 + 1) = 0;
  *((void *)v10 + 2) = 0;
  *(void *)id v10 = &unk_1EF589198;
  {
    if (v83)
    {
      {
        if (v83)
        {
          {
            {
              ggl::MeshTyped<ggl::CommonMesh::BufferPos4,ggl::Point::ExtendedVbo>::attributesReflection(void)::r = (uint64_t)&ggl::CommonMesh::bufferPos4Reflection;
              *(void *)algn_1E958FA18 = &ggl::Point::extendedVboReflection;
            }
            ggl::MeshTyped<ggl::CommonMesh::BufferPos4,ggl::Point::ExtendedVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::CommonMesh::BufferPos4,ggl::Point::ExtendedVbo>::attributesReflection(void)::r;
            unk_1E958FA00 = 2;
          }
          ggl::Point::ExtendedPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::CommonMesh::BufferPos4,ggl::Point::ExtendedVbo>::typedReflection(void)::r;
          *(void *)algn_1E958F888 = &ggl::Point::pipelineDataExtendedPipelineDeviceStructs(void)::ref;
          qword_1E958F890 = 0;
          {
            ggl::Point::pipelineDataExtendedPipelineConstantStructs(void)::ref = (uint64_t)ggl::Point::View::reflection(void)::reflection;
            *(void *)algn_1E958F9E8 = ggl::Tile::Transform::reflection(void)::reflection;
          }
          qword_1E958F898 = (uint64_t)&ggl::Point::pipelineDataExtendedPipelineConstantStructs(void)::ref;
          unk_1E958F8A0 = xmmword_1A28FCED0;
        }
      }
      ggl::Point::ExtendedPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::Point::ExtendedPipelineSetup::typedReflection(void)::ref;
      ggl::PointExtendedShader::typedReflection(v83);
      qword_1E958F830 = (uint64_t)&ggl::PointExtendedShader::typedReflection(void)::ref;
      {
        ggl::Point::pipelineStateExtendedPipelineAttributeStructBinding(void)::attr = 0;
        *(void *)algn_1E958F908 = 0;
        qword_1E958F910 = (uint64_t)"";
        dword_1E958F918 = 0;
        qword_1E958F920 = (uint64_t)&ggl::Point::pipelineStateExtendedPipelineAttributeBinding_0(void)::attr;
        unk_1E958F928 = vdupq_n_s64(1uLL);
        qword_1E958F938 = 1;
        unk_1E958F940 = "";
        dword_1E958F948 = 0;
        qword_1E958F950 = (uint64_t)&ggl::Point::pipelineStateExtendedPipelineAttributeBinding_1(void)::attr;
        unk_1E958F958 = 2;
      }
      qword_1E958F838 = (uint64_t)&ggl::Point::pipelineStateExtendedPipelineAttributeStructBinding(void)::attr;
      unk_1E958F840 = 2;
      qword_1E958F848 = 0;
      unk_1E958F850 = 0;
      qword_1E958F858 = (uint64_t)&ggl::Point::pipelineStateExtendedPipelineDeviceStructBinding(void)::ref;
      unk_1E958F860 = 0;
      {
        ggl::Point::pipelineStateExtendedPipelineConstantStructBinding(void)::ref = 0;
        *(void *)algn_1E958F978 = 0;
        qword_1E958F980 = (uint64_t)"view";
        dword_1E958F988 = 3;
        qword_1E958F990 = (uint64_t)&ggl::Point::pipelineStateExtendedPipelineConstantViewBinding(void)::reflection;
        unk_1E958F998 = xmmword_1A28FE1F0;
        qword_1E958F9A8 = 1;
        unk_1E958F9B0 = "transform";
        dword_1E958F9B8 = 3;
        qword_1E958F9C0 = (uint64_t)&ggl::Point::pipelineStateExtendedPipelineConstantTransformBinding(void)::reflection;
        unk_1E958F9C8 = 10;
      }
      qword_1E958F868 = (uint64_t)&ggl::Point::pipelineStateExtendedPipelineConstantStructBinding(void)::ref;
      unk_1E958F870 = 2;
    }
  }
  if (v87) {
    atomic_fetch_add_explicit(&v87->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *((void *)v10 + 4) = 0;
  *((void *)v10 + 5) = 0;
  *((_DWORD *)v10 + 14) = 0;
  *((void *)v10 + 6) = 0;
  *((void *)v10 + 3) = &unk_1EF55B208;
  *((void *)v10 + 8) = &ggl::Point::ExtendedPipelineState::typedReflection(void)::ref;
  *((void *)v10 + 9) = v86;
  *((void *)v10 + 10) = v87;
  if (v87) {
    atomic_fetch_add_explicit(&v87->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v10[136] = 0;
  *(_OWORD *)(v10 + 140) = xmmword_1A28FC970;
  *(void *)(v10 + 156) = 0;
  *(void *)(v10 + 172) = 0;
  *(void *)(v10 + 164) = 0;
  v10[184] = 0;
  *(_OWORD *)(v10 + 188) = xmmword_1A28FC970;
  *(void *)(v10 + 204) = 0;
  *(void *)(v10 + 220) = 0;
  *(void *)(v10 + 212) = 0;
  v10[232] = 0;
  *(_OWORD *)(v10 + 236) = xmmword_1A28FC970;
  *(void *)(v10 + 252) = 0;
  *(void *)(v10 + 268) = 0;
  *(void *)(v10 + 260) = 0;
  *(_OWORD *)(v10 + 280) = v88;
  *(_OWORD *)(v10 + 296) = v89;
  v10[312] = 0;
  *((void *)v10 + 48) = 0;
  *((_OWORD *)v10 + 22) = 0u;
  *((_OWORD *)v10 + 23) = 0u;
  *((_OWORD *)v10 + 20) = 0u;
  *((_OWORD *)v10 + 21) = 0u;
  *((void *)v10 + 49) = 0x100000001;
  v10[400] = 0;
  v10[88] = 1;
  *(_WORD *)(v10 + 89) = v84;
  v10[91] = v85;
  *(_OWORD *)(v10 + 92) = xmmword_1A28FCEC0;
  *((_DWORD *)v10 + 27) = 7;
  *((void *)v10 + 14) = 0;
  *((void *)v10 + 15) = 0;
  *((_DWORD *)v10 + 32) = 0;
  v10[132] = 15;
  if (v87 && !atomic_fetch_add(&v87->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
    std::__shared_weak_count::__release_weak(v87);
  }
  v10[329] = 0;
  int8x16_t v11 = *(int8x16_t *)(v10 + 344);
  int8x16_t v12 = vceqzq_s8(*(int8x16_t *)(v10 + 328));
  int16x8_t v13 = vmovl_high_s8(v12);
  int32x4_t v14 = vmovl_s16(*(int16x4_t *)v13.i8);
  v15.i64[0] = v14.u32[0];
  v15.i64[1] = v14.u32[1];
  int8x16_t v16 = v15;
  int16x8_t v17 = vmovl_s8(*(int8x8_t *)v12.i8);
  int32x4_t v18 = vmovl_s16(*(int16x4_t *)v17.i8);
  *((void *)v10 + 3) = &unk_1EF560A40;
  v15.i64[0] = v18.u32[0];
  v15.i64[1] = v18.u32[1];
  int8x16_t v19 = v15;
  int32x4_t v20 = vmovl_high_s16(v13);
  v15.i64[0] = v20.u32[0];
  v15.i64[1] = v20.u32[1];
  int8x16_t v21 = v15;
  int32x4_t v22 = vmovl_high_s16(v17);
  v15.i64[0] = v22.u32[0];
  v15.i64[1] = v22.u32[1];
  int8x16_t v23 = v15;
  v15.i64[0] = v14.u32[2];
  v15.i64[1] = v14.u32[3];
  int8x16_t v24 = v15;
  v15.i64[0] = v18.u32[2];
  v15.i64[1] = v18.u32[3];
  int8x16_t v25 = v15;
  v15.i64[0] = v20.u32[2];
  v15.i64[1] = v20.u32[3];
  int8x16_t v26 = v15;
  v15.i64[0] = v22.u32[2];
  v15.i64[1] = v22.u32[3];
  int8x16_t v27 = vbicq_s8((int8x16_t)xmmword_1A28FC980, v15);
  int8x16_t v28 = vbicq_s8((int8x16_t)xmmword_1A28FC990, v26);
  int8x16_t v29 = vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v25);
  int8x16_t v30 = vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v21);
  int8x16_t v31 = vceqzq_s8(v11);
  int16x8_t v32 = vmovl_high_s8(v31);
  int32x4_t v33 = vmovl_s16(*(int16x4_t *)v32.i8);
  v15.i64[0] = v33.u32[0];
  v15.i64[1] = v33.u32[1];
  int8x16_t v34 = v15;
  int16x8_t v35 = vmovl_s8(*(int8x8_t *)v31.i8);
  int32x4_t v36 = vmovl_s16(*(int16x4_t *)v35.i8);
  v15.i64[0] = v36.u32[0];
  v15.i64[1] = v36.u32[1];
  int8x16_t v37 = v15;
  int32x4_t v38 = vmovl_high_s16(v32);
  v15.i64[0] = v38.u32[0];
  v15.i64[1] = v38.u32[1];
  int8x16_t v39 = v15;
  int32x4_t v40 = vmovl_high_s16(v35);
  v15.i64[0] = v40.u32[0];
  v15.i64[1] = v40.u32[1];
  int8x16_t v41 = v15;
  v15.i64[0] = v33.u32[2];
  v15.i64[1] = v33.u32[3];
  int8x16_t v42 = v15;
  v15.i64[0] = v36.u32[2];
  v15.i64[1] = v36.u32[3];
  int8x16_t v43 = v15;
  v15.i64[0] = v38.u32[2];
  v15.i64[1] = v38.u32[3];
  int8x16_t v44 = v15;
  v15.i64[0] = v40.u32[2];
  v15.i64[1] = v40.u32[3];
  int8x16_t v45 = vbicq_s8((int8x16_t)xmmword_1A28FCA00, v44);
  int8x16_t v46 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA60, v34), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v16));
  int8x16_t v47 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v37), vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v19));
  int8x16_t v48 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA40, v39), v30);
  int8x16_t v49 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v41), vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v23));
  int8x16_t v50 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA20, v42), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v24));
  int8x16_t v51 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v43), v29);
  int8x16_t v52 = vorrq_s8(v45, v28);
  int8x16_t v53 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v15), v27);
  int8x16_t v54 = vceqzq_s8(*(int8x16_t *)(v10 + 360));
  int16x8_t v55 = vmovl_s8(*(int8x8_t *)v54.i8);
  int32x4_t v56 = vmovl_high_s16(v55);
  v15.i64[0] = v56.i32[2];
  v15.i64[1] = v56.i32[3];
  int8x16_t v57 = v15;
  int16x8_t v58 = vmovl_high_s8(v54);
  int32x4_t v59 = vmovl_high_s16(v58);
  v15.i64[0] = v59.i32[2];
  v15.i64[1] = v59.i32[3];
  int8x16_t v60 = v15;
  int32x4_t v61 = vmovl_s16(*(int16x4_t *)v55.i8);
  v15.i64[0] = v61.i32[2];
  v15.i64[1] = v61.i32[3];
  int8x16_t v62 = v15;
  int32x4_t v63 = vmovl_s16(*(int16x4_t *)v58.i8);
  v15.i64[0] = v63.i32[2];
  v15.i64[1] = v63.i32[3];
  int8x16_t v64 = v15;
  v15.i64[0] = v56.i32[0];
  v15.i64[1] = v56.i32[1];
  int8x16_t v65 = v15;
  v15.i64[0] = v59.i32[0];
  v15.i64[1] = v59.i32[1];
  int8x16_t v66 = v15;
  v15.i64[0] = v61.i32[0];
  v15.i64[1] = v61.i32[1];
  int8x16_t v67 = v15;
  v15.i64[0] = v63.i32[0];
  v15.i64[1] = v63.i32[1];
  int8x16_t v68 = vbicq_s8((int8x16_t)xmmword_1A28FCA70, v15);
  int8x16_t v69 = vceqzq_s8(*(int8x16_t *)(v10 + 376));
  int16x8_t v70 = vmovl_high_s8(v69);
  int32x4_t v71 = vmovl_s16(*(int16x4_t *)v70.i8);
  v15.i64[0] = v71.i32[0];
  v15.i64[1] = v71.i32[1];
  int8x16_t v72 = v15;
  int16x8_t v73 = vmovl_s8(*(int8x8_t *)v69.i8);
  int32x4_t v74 = vmovl_s16(*(int16x4_t *)v73.i8);
  v15.i64[0] = v74.i32[0];
  v15.i64[1] = v74.i32[1];
  int8x16_t v75 = v15;
  int32x4_t v76 = vmovl_high_s16(v70);
  v15.i64[0] = v76.i32[0];
  v15.i64[1] = v76.i32[1];
  int8x16_t v77 = v15;
  int32x4_t v78 = vmovl_high_s16(v73);
  v15.i64[0] = v78.i32[0];
  v15.i64[1] = v78.i32[1];
  int8x16_t v79 = v15;
  v15.i64[0] = v71.i32[2];
  v15.i64[1] = v71.i32[3];
  int8x16_t v80 = v15;
  v15.i64[0] = v74.i32[2];
  v15.i64[1] = v74.i32[3];
  int8x16_t v81 = v15;
  v15.i64[0] = v76.i32[2];
  v15.i64[1] = v76.i32[3];
  int8x16_t v82 = v15;
  v15.i64[0] = v78.i32[2];
  v15.i64[1] = v78.i32[3];
  *((void *)v10 + 40) = vaddvq_s64(vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB50, v75), vbicq_s8((int8x16_t)xmmword_1A28FCA80, v67)), v47), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB60, v72), v68), v46)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB30, v79), vbicq_s8((int8x16_t)xmmword_1A28FCAA0, v65)), v49), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB40, v77), vbicq_s8((int8x16_t)xmmword_1A28FCA90, v66)),
                                               v48))),
                              (int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB10, v81), vbicq_s8((int8x16_t)xmmword_1A28FCAC0, v62)), v51), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB20, v80), vbicq_s8((int8x16_t)xmmword_1A28FCAB0, v64)), v50)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAF0, v15), vbicq_s8((int8x16_t)xmmword_1A28FCAE0, v57)), v53), vorrq_s8(vorrq_s8(
                                                 vbicq_s8((int8x16_t)xmmword_1A28FCB00, v82),
                                                 vbicq_s8((int8x16_t)xmmword_1A28FCAD0, v60)),
                                               v52)))));
  v10[312] = 1;
  if (v87)
  {
    if (!atomic_fetch_add(&v87->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
      std::__shared_weak_count::__release_weak(v87);
    }
  }
  operator new();
}

void sub_1A237D7D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,char a27,uint64_t a28,char a29)
{
  (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a21);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a19);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a25);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a27);
  (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a29);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v31 - 160);

  _Unwind_Resume(a1);
}

void std::__introsort<std::_ClassicAlgPolicy,md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_0 &,md::mun::CollectionPoint *,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
void *std::function<BOOL ()(md::mun::CollectionPoint const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(md::mun::MuninNavigationGraph const*)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_2,std::allocator<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_2>,void ()(md::mun::MuninNavigationGraph const*)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v26 = *a2;
  long long v3 = *(_OWORD *)(a1 + 24);
  v23[0] = *(_OWORD *)(a1 + 8);
  v23[1] = v3;
  uint64_t v4 = *(void *)(a1 + 40);
  char v5 = *(uint64_t ***)(a1 + 48);
  int8x16_t v24 = &v26;
  uint64_t v25 = v4;
  uint8x8_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (*v5 != v7)
  {
    uint64_t v8 = 0;
    int32x4_t v9 = vdupq_n_s32(0x3B808081u);
    float32x4_t v21 = (float32x4_t)v9;
    do
    {
      uint64_t v10 = **(void **)(a1 + 56);
      if (!v10) {
        goto LABEL_8;
      }
      unint64_t v11 = v6[10];
      unint64_t v12 = *(void *)(v10 + 80);
      unint64_t v13 = v12 - v11;
      _CF = v11 >= v12;
      unint64_t v15 = v11 - v12;
      if (v15 == 0 || !_CF) {
        unint64_t v15 = v13;
      }
      if (v15 >= 0xEA61) {
LABEL_8:
      }
        ++**(void **)(a1 + 64);
      int8x16_t v16 = v6;
      if (*v6 != *(void *)(**(void **)(a1 + 32) + 80))
      {
        v9.i32[0] = *(_DWORD *)(*(void *)(a1 + 72) + 4 * (**(void **)(a1 + 64) % 9uLL));
        float32x4_t v22 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v9.i8))), v21);
        md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_2::operator() const(md::mun::MuninNavigationGraph const*)::{lambda(md::mun::CollectionPoint const&,geo::Color<float,4,(geo::ColorSpace)0> const&,BOOL)#1}::operator()((double **)v23, v6, (long long *)&v22, 0);
        **(void **)(a1 + 56) = v6;
        int8x16_t v16 = v8;
      }
      v6 += 233;
      uint64_t v8 = v16;
    }
    while (v6 != v7);
    if (v16)
    {
      __asm { FMOV            V0.4S, #1.0 }
      float32x4_t v22 = _Q0;
      md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_2::operator() const(md::mun::MuninNavigationGraph const*)::{lambda(md::mun::CollectionPoint const&,geo::Color<float,4,(geo::ColorSpace)0> const&,BOOL)#1}::operator()((double **)v23, v16, (long long *)&v22, 1);
    }
  }
}

void md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_2::operator() const(md::mun::MuninNavigationGraph const*)::{lambda(md::mun::CollectionPoint const&,geo::Color<float,4,(geo::ColorSpace)0> const&,BOOL)#1}::operator()(double **a1, uint64_t *a2, long long *a3, int a4)
{
  uint64_t v8 = (float **)a1[1];
  double v9 = (*a1)[4];
  double v10 = (*a1)[5];
  double v11 = (*a1)[6];
  double v13 = *((double *)a2 + 2);
  double v12 = *((double *)a2 + 3);
  double v14 = *((double *)a2 + 1);
  double v15 = (*a1)[3];
  double v16 = -(v13 * v10 - v12 * v9) - (v13 * v10 - v12 * v9);
  double v17 = -(v12 * v15 - v14 * v10) - (v12 * v15 - v14 * v10);
  double v18 = -(v14 * v9 - v13 * v15) - (v14 * v9 - v13 * v15);
  double v19 = (*a1)[1] + v13 + v16 * v10 + v17 * v11 - v18 * v15;
  double v20 = (*a1)[2] + v12 - v16 * v9 + v17 * v15 + v18 * v11;
  float v21 = **a1 + v14 + v16 * v11 + v18 * v9 - v17 * v10;
  float v22 = v19;
  *(float *)&double v16 = v20;
  LODWORD(v20) = *((_DWORD *)a2 + 9);
  float v23 = *((float *)a2 + 10);
  float v185 = v23;
  float v187 = -(float)(*(float *)&v20 * (float)(*(float *)&v20 + *(float *)&v20));
  *(float *)&double v14 = (float)(1.0 - (float)(*(float *)&v20 * (float)(*(float *)&v20 + *(float *)&v20)))
                 - (float)((float)(v23 + v23) * v23);
  float v176 = *((float *)a2 + 8);
  float v179 = v176 + v176;
  float v180 = *((float *)a2 + 11);
  float v183 = *(float *)&v20 + *(float *)&v20;
  *(float *)&double v20 = (float)((float)(v176 + v176) * *(float *)&v20) + (float)((float)(v23 + v23) * v180);
  float v177 = v180 * v183;
  float v178 = v23 * (float)(v176 + v176);
  *(float *)&double v19 = v178 - (float)(v180 * v183);
  float v24 = v15;
  float v25 = v9;
  float v26 = v10;
  float v27 = v11;
  *(float *)&double v9 = (float)-(float)((float)(*(float *)&v20 * v26) - (float)(*(float *)&v19 * v25))
                - (float)((float)(*(float *)&v20 * v26) - (float)(*(float *)&v19 * v25));
  *(float *)&double v10 = (float)-(float)((float)(*(float *)&v19 * v24) - (float)(*(float *)&v14 * v26))
                 - (float)((float)(*(float *)&v19 * v24) - (float)(*(float *)&v14 * v26));
  *(float *)&double v11 = (float)-(float)((float)(*(float *)&v14 * v25) - (float)(*(float *)&v20 * v24))
                 - (float)((float)(*(float *)&v14 * v25) - (float)(*(float *)&v20 * v24));
  float v28 = (float)((float)(*(float *)&v14 + (float)(*(float *)&v11 * v25)) + (float)(*(float *)&v9 * v27))
      - (float)(*(float *)&v10 * v26);
  float v29 = (float)((float)(*(float *)&v20 - (float)(*(float *)&v11 * v24)) + (float)(*(float *)&v9 * v26))
      + (float)(*(float *)&v10 * v27);
  float v30 = (float)((float)(*(float *)&v19 + (float)(*(float *)&v11 * v27)) + (float)(*(float *)&v10 * v24))
      - (float)(*(float *)&v9 * v25);
  float v31 = v21 - v28;
  float v32 = v22 - v29;
  float v189 = *(float *)&v16;
  float v33 = *(float *)&v16 - v30;
  long long v191 = *a3;
  unint64_t v35 = v8[1];
  unint64_t v34 = (unint64_t)v8[2];
  if ((unint64_t)v35 >= v34)
  {
    int8x16_t v37 = *v8;
    uint64_t v38 = ((char *)v35 - (char *)*v8) >> 5;
    unint64_t v39 = v38 + 1;
    if ((unint64_t)(v38 + 1) >> 59) {
      goto LABEL_133;
    }
    uint64_t v40 = v34 - (void)v37;
    if (v40 >> 4 > v39) {
      unint64_t v39 = v40 >> 4;
    }
    if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v41 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v41 = v39;
    }
    float v173 = v22;
    if (v41)
    {
      unint64_t v172 = __PAIR64__(LODWORD(v28), LODWORD(v29));
      float v174 = v21;
      if (v41 >> 59) {
        goto LABEL_134;
      }
      int8x16_t v42 = (char *)operator new(32 * v41);
      float v22 = v173;
      float v21 = v174;
      float v28 = *((float *)&v172 + 1);
      LODWORD(v29) = v172;
    }
    else
    {
      int8x16_t v42 = 0;
    }
    unint64_t v43 = (float *)&v42[32 * v38];
    float *v43 = v31;
    v43[1] = v32;
    v43[2] = v33;
    *((_OWORD *)v43 + 1) = *a3;
    unint64_t v36 = v43 + 8;
    if (v35 != v37)
    {
      do
      {
        uint64_t v44 = *((void *)v35 - 4);
        v35 -= 8;
        int v45 = *((_DWORD *)v35 + 2);
        *((void *)v43 - 4) = v44;
        v43 -= 8;
        *((_DWORD *)v43 + 2) = v45;
        *((_OWORD *)v43 + 1) = *((_OWORD *)v35 + 1);
      }
      while (v35 != v37);
      unint64_t v35 = *v8;
    }
    *uint64_t v8 = v43;
    v8[1] = v36;
    void v8[2] = (float *)&v42[32 * v41];
    if (v35)
    {
      float v46 = v21;
      float v47 = v28;
      float v48 = v29;
      operator delete(v35);
      float v29 = v48;
      float v28 = v47;
      float v21 = v46;
      float v22 = v173;
    }
  }
  else
  {
    *unint64_t v35 = v31;
    v35[1] = v32;
    v35[2] = v33;
    *((_OWORD *)v35 + 1) = v191;
    unint64_t v36 = v35 + 8;
  }
  v8[1] = v36;
  int8x16_t v49 = (float **)a1[1];
  float v50 = v28 + v21;
  float v51 = v29 + v22;
  float v52 = v30 + v189;
  float v53 = v189;
  long long v192 = *a3;
  int16x8_t v55 = v49[1];
  unint64_t v54 = (unint64_t)v49[2];
  if ((unint64_t)v55 >= v54)
  {
    int16x8_t v58 = *v49;
    uint64_t v59 = ((char *)v55 - (char *)*v49) >> 5;
    unint64_t v60 = v59 + 1;
    if ((unint64_t)(v59 + 1) >> 59) {
      goto LABEL_133;
    }
    uint64_t v61 = v54 - (void)v58;
    if (v61 >> 4 > v60) {
      unint64_t v60 = v61 >> 4;
    }
    if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v62 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v62 = v60;
    }
    if (v62)
    {
      float v175 = v21;
      if (v62 >> 59) {
        goto LABEL_134;
      }
      float v63 = v22;
      int8x16_t v64 = (char *)operator new(32 * v62);
      float v22 = v63;
      float v21 = v175;
      float v53 = v189;
    }
    else
    {
      int8x16_t v64 = 0;
    }
    int8x16_t v65 = (float *)&v64[32 * v59];
    float *v65 = v50;
    v65[1] = v51;
    v65[2] = v52;
    *((_OWORD *)v65 + 1) = *a3;
    int32x4_t v56 = v65 + 8;
    if (v55 == v58)
    {
      float v57 = v176;
    }
    else
    {
      float v57 = v176;
      do
      {
        uint64_t v66 = *((void *)v55 - 4);
        v55 -= 8;
        int v67 = *((_DWORD *)v55 + 2);
        *((void *)v65 - 4) = v66;
        v65 -= 8;
        *((_DWORD *)v65 + 2) = v67;
        *((_OWORD *)v65 + 1) = *((_OWORD *)v55 + 1);
      }
      while (v55 != v58);
      int16x8_t v55 = *v49;
    }
    *int8x16_t v49 = v65;
    v49[1] = v56;
    v49[2] = (float *)&v64[32 * v62];
    if (v55)
    {
      float v68 = v22;
      float v69 = v21;
      operator delete(v55);
      float v21 = v69;
      float v22 = v68;
    }
  }
  else
  {
    *int16x8_t v55 = v50;
    v55[1] = v51;
    v55[2] = v52;
    *((_OWORD *)v55 + 1) = v192;
    int32x4_t v56 = v55 + 8;
    float v57 = v176;
  }
  float v70 = -(float)((float)(v180 * v179) - (float)(v183 * v185));
  float v71 = (float)(1.0 - (float)(v179 * v57)) + v187;
  float v72 = -(float)((float)(v71 * v24) - (float)((float)(v177 + v178) * v26));
  float v73 = -(float)((float)((float)(v177 + v178) * v25) - (float)(v70 * v24));
  float v74 = (float)-(float)((float)(v70 * v26) - (float)(v71 * v25)) - (float)((float)(v70 * v26) - (float)(v71 * v25));
  float v75 = v72 + v72;
  float v76 = v73 + v73;
  float v77 = (float)((float)(v71 + (float)(v76 * v27)) + (float)(v75 * v24)) - (float)(v74 * v25);
  float v78 = -(float)((float)((float)((float)(v74 * v26) - (float)((float)(v180 * v179) - (float)(v183 * v185)))
                       + (float)(v75 * v27))
               - (float)(v76 * v24));
  v49[1] = v56;
  int8x16_t v79 = (float **)a1[1];
  float v80 = v21
      + (float)((float)-(float)((float)((float)((float)(v177 + v178) + (float)(v76 * v25)) + (float)(v74 * v27))
                              - (float)(v75 * v26))
              * 2.0);
  float v81 = v22 + (float)(v78 * 2.0);
  float v82 = v53 - (float)(v77 * 2.0);
  long long v193 = *a3;
  __int16 v84 = v79[1];
  unint64_t v83 = (unint64_t)v79[2];
  float v188 = v81;
  float v190 = v80;
  float v186 = v82;
  if ((unint64_t)v84 >= v83)
  {
    uint64_t v86 = *v79;
    uint64_t v87 = ((char *)v84 - (char *)*v79) >> 5;
    unint64_t v88 = v87 + 1;
    if (!((unint64_t)(v87 + 1) >> 59))
    {
      uint64_t v89 = v83 - (void)v86;
      if (v89 >> 4 > v88) {
        unint64_t v88 = v89 >> 4;
      }
      if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v90 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v90 = v88;
      }
      if (!v90)
      {
        double v93 = 0;
        goto LABEL_49;
      }
      if (!(v90 >> 59))
      {
        float v91 = v82;
        float v92 = v81;
        double v93 = (char *)operator new(32 * v90);
        float v80 = v190;
        float v81 = v92;
        float v82 = v91;
LABEL_49:
        double v94 = (float *)&v93[32 * v87];
        *double v94 = v80;
        v94[1] = v81;
        v94[2] = v82;
        *((_OWORD *)v94 + 1) = *a3;
        char v85 = v94 + 8;
        if (v84 != v86)
        {
          do
          {
            uint64_t v95 = *((void *)v84 - 4);
            v84 -= 8;
            int v96 = *((_DWORD *)v84 + 2);
            *((void *)v94 - 4) = v95;
            v94 -= 8;
            *((_DWORD *)v94 + 2) = v96;
            *((_OWORD *)v94 + 1) = *((_OWORD *)v84 + 1);
          }
          while (v84 != v86);
          __int16 v84 = *v79;
        }
        *int8x16_t v79 = v94;
        v79[1] = v85;
        v79[2] = (float *)&v93[32 * v90];
        if (v84) {
          operator delete(v84);
        }
        goto LABEL_54;
      }
LABEL_134:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_133:
    abort();
  }
  *__int16 v84 = v80;
  v84[1] = v81;
  v84[2] = v82;
  *((_OWORD *)v84 + 1) = v193;
  char v85 = v84 + 8;
LABEL_54:
  v79[1] = v85;
  if (objc_msgSend(*(id *)a1[2], "muninGraphConnections", v172)) {
    BOOL v97 = a4 == 0;
  }
  else {
    BOOL v97 = 1;
  }
  if (v97) {
    return;
  }
  uint64_t v98 = *(void *)(*(void *)a1[3] + 232);
  unint64_t v99 = *a2;
  double v100 = (geo::read_write_lock *)pthread_rwlock_rdlock((pthread_rwlock_t *)(v98 + 96));
  if (v100) {
    geo::read_write_lock::logFailure(v100, (uint64_t)"read lock", v101);
  }
  double v102 = *(void **)(v98 + 48);
  if (v102 == (void *)(v98 + 56))
  {
LABEL_61:
    unint64_t v103 = 0;
    goto LABEL_62;
  }
  while (1)
  {
    double v110 = (void *)v102[4];
    int8x8_t v111 = (int8x8_t)v110[25];
    if (v111)
    {
      uint8x8_t v112 = (uint8x8_t)vcnt_s8(v111);
      v112.i16[0] = vaddlv_u8(v112);
      if (v112.u32[0] > 1uLL)
      {
        unint64_t v113 = v99;
        if (*(void *)&v111 <= v99) {
          unint64_t v113 = v99 % *(void *)&v111;
        }
      }
      else
      {
        unint64_t v113 = (*(void *)&v111 - 1) & v99;
      }
      double v114 = *(uint64_t ****)(v110[24] + 8 * v113);
      if (v114)
      {
        double v115 = *v114;
        if (v115) {
          break;
        }
      }
    }
LABEL_90:
    id v120 = (void *)v102[1];
    if (v120)
    {
      do
      {
        double v121 = v120;
        id v120 = (void *)*v120;
      }
      while (v120);
    }
    else
    {
      do
      {
        double v121 = (void *)v102[2];
        BOOL v97 = *v121 == (void)v102;
        double v102 = v121;
      }
      while (!v97);
    }
    double v102 = v121;
    if (v121 == (void *)(v98 + 56)) {
      goto LABEL_61;
    }
  }
  if (v112.u32[0] < 2uLL)
  {
    uint64_t v116 = *(void *)&v111 - 1;
    while (1)
    {
      unint64_t v118 = v115[1];
      if (v118 == (uint64_t *)v99)
      {
        if (v115[2] == (uint64_t *)v99) {
          goto LABEL_89;
        }
      }
      else if (((unint64_t)v118 & v116) != v113)
      {
        goto LABEL_90;
      }
      double v115 = (uint64_t **)*v115;
      if (!v115) {
        goto LABEL_90;
      }
    }
  }
  while (1)
  {
    unint64_t v117 = (unint64_t)v115[1];
    if (v117 == v99) {
      break;
    }
    if (v117 >= *(void *)&v111) {
      v117 %= *(void *)&v111;
    }
    if (v117 != v113) {
      goto LABEL_90;
    }
LABEL_78:
    double v115 = (uint64_t **)*v115;
    if (!v115) {
      goto LABEL_90;
    }
  }
  if (v115[2] != (uint64_t *)v99) {
    goto LABEL_78;
  }
LABEL_89:
  uint64_t v119 = v110[21];
  if (!v119) {
    goto LABEL_90;
  }
  unint64_t v103 = v119 + 1864 * *((unsigned __int16 *)v115 + 12);
LABEL_62:
  double v104 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(v98 + 96));
  if (v104) {
    geo::read_write_lock::logFailure(v104, (uint64_t)"unlock", v105);
  }
  double v106 = std::__hash_table<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::__unordered_map_hasher<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::hash<md::mun::CollectionPoint const*>,std::equal_to<md::mun::CollectionPoint const*>,true>,std::__unordered_map_equal<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::equal_to<md::mun::CollectionPoint const*>,std::hash<md::mun::CollectionPoint const*>,true>,std::allocator<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>>>::find<md::mun::CollectionPoint const*>((void *)(*(void *)a1[4] + 24), v103);
  float v107 = v190;
  if (v106)
  {
    uint64_t v108 = v106[3];
    for (uint64_t i = v106[4]; v108 != i; v108 += 8)
    {
      double v124 = (*a1)[4];
      double v123 = (*a1)[5];
      double v125 = (*a1)[6];
      double v127 = *(double *)(*(void *)v108 + 16);
      double v126 = *(double *)(*(void *)v108 + 24);
      double v128 = *(double *)(*(void *)v108 + 8);
      double v130 = **a1;
      double v129 = (*a1)[1];
      double v131 = (*a1)[2];
      double v132 = (*a1)[3];
      double v133 = a1[5];
      long long v194 = *a3;
      unint64_t v135 = (_DWORD *)*((void *)v133 + 1);
      unint64_t v134 = *((void *)v133 + 2);
      if ((unint64_t)v135 >= v134)
      {
        uint64_t v137 = *(_DWORD **)v133;
        uint64_t v138 = ((uint64_t)v135 - *(void *)v133) >> 5;
        unint64_t v139 = v138 + 1;
        if ((unint64_t)(v138 + 1) >> 59) {
          goto LABEL_133;
        }
        uint64_t v140 = v134 - (void)v137;
        if (v140 >> 4 > v139) {
          unint64_t v139 = v140 >> 4;
        }
        if ((unint64_t)v140 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v141 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v141 = v139;
        }
        double v184 = **a1;
        if (v141)
        {
          double v181 = (*a1)[4];
          if (v141 >> 59) {
            goto LABEL_134;
          }
          unint64_t v142 = (char *)operator new(32 * v141);
          float v107 = v190;
          double v124 = v181;
          double v130 = v184;
        }
        else
        {
          unint64_t v142 = 0;
        }
        uint64_t v143 = &v142[32 * v138];
        *(float *)uint64_t v143 = v107;
        *((float *)v143 + 1) = v188;
        *((float *)v143 + 2) = v186;
        *((_OWORD *)v143 + 1) = *a3;
        uint64_t v144 = v143;
        if (v135 != v137)
        {
          do
          {
            uint64_t v145 = *((void *)v135 - 4);
            v135 -= 8;
            int v146 = v135[2];
            *((void *)v144 - 4) = v145;
            v144 -= 32;
            *((_DWORD *)v144 + 2) = v146;
            *((_OWORD *)v144 + 1) = *((_OWORD *)v135 + 1);
          }
          while (v135 != v137);
          unint64_t v135 = *(_DWORD **)v133;
        }
        unint64_t v147 = &v142[32 * v141];
        unint64_t v136 = v143 + 32;
        *(void *)double v133 = v144;
        *((void *)v133 + 1) = v143 + 32;
        *((void *)v133 + 2) = v147;
        if (v135)
        {
          double v182 = v126;
          double v148 = v124;
          operator delete(v135);
          double v124 = v148;
          double v126 = v182;
          double v130 = v184;
          float v107 = v190;
        }
      }
      else
      {
        *(float *)unint64_t v135 = v107;
        *((float *)v135 + 1) = v188;
        *((float *)v135 + 2) = v186;
        *((_OWORD *)v135 + 1) = v194;
        unint64_t v136 = v135 + 8;
      }
      double v149 = -(v127 * v123 - v126 * v124) - (v127 * v123 - v126 * v124);
      double v150 = -(v126 * v132 - v128 * v123) - (v126 * v132 - v128 * v123);
      double v151 = -(v128 * v124 - v127 * v132) - (v128 * v124 - v127 * v132);
      double v152 = v130 + v128 + v149 * v125 + v151 * v124 - v150 * v123;
      double v153 = v129 + v127 + v149 * v123 + v150 * v125 - v151 * v132;
      double v154 = v131 + v126 - v149 * v124 + v150 * v132 + v151 * v125;
      float v155 = v152;
      float v156 = v153;
      float v157 = v154;
      *((void *)v133 + 1) = v136;
      id v158 = (void **)a1[5];
      long long v195 = *a3;
      double v160 = (float *)v158[1];
      unint64_t v159 = (unint64_t)v158[2];
      if ((unint64_t)v160 < v159)
      {
        *double v160 = v155;
        v160[1] = v156;
        uint64_t v160[2] = v157;
        *((_OWORD *)v160 + 1) = v195;
        double v122 = (char *)(v160 + 8);
      }
      else
      {
        double v161 = (float *)*v158;
        uint64_t v162 = ((char *)v160 - (unsigned char *)*v158) >> 5;
        unint64_t v163 = v162 + 1;
        if ((unint64_t)(v162 + 1) >> 59) {
          goto LABEL_133;
        }
        uint64_t v164 = v159 - (void)v161;
        if (v164 >> 4 > v163) {
          unint64_t v163 = v164 >> 4;
        }
        if ((unint64_t)v164 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v165 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v165 = v163;
        }
        if (v165)
        {
          if (v165 >> 59) {
            goto LABEL_134;
          }
          double v166 = (char *)operator new(32 * v165);
          float v107 = v190;
        }
        else
        {
          double v166 = 0;
        }
        double v167 = &v166[32 * v162];
        *(float *)double v167 = v155;
        *((float *)v167 + 1) = v156;
        *((float *)v167 + 2) = v157;
        *((_OWORD *)v167 + 1) = *a3;
        double v168 = v167;
        if (v160 != v161)
        {
          do
          {
            uint64_t v169 = *((void *)v160 - 4);
            v160 -= 8;
            int v170 = *((_DWORD *)v160 + 2);
            *((void *)v168 - 4) = v169;
            v168 -= 32;
            *((_DWORD *)v168 + 2) = v170;
            *((_OWORD *)v168 + 1) = *((_OWORD *)v160 + 1);
          }
          while (v160 != v161);
          double v160 = (float *)*v158;
        }
        uint64_t v171 = &v166[32 * v165];
        double v122 = v167 + 32;
        ggl::FlyoverPostchainBGBlurShader *v158 = v168;
        v158[1] = v167 + 32;
        v158[2] = v171;
        if (v160)
        {
          operator delete(v160);
          float v107 = v190;
        }
      }
      v158[1] = v122;
    }
  }
}

void anonymous namespace'::createMeshDrawable(id *a1, void *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)([a2 device] + 24);
  uint64_t v5 = *(void *)(v3 + 16);
  uint64_t v4 = *(void *)(v3 + 24);
  uint64_t v14 = v5;
  uint64_t v15 = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint8x8_t v6 = (long long *)[*a1 format];
  long long v7 = v6[1];
  long long v12 = *v6;
  long long v13 = v7;
  uint64_t v8 = *(void *)(v5 + 80);
  double v9 = *(std::__shared_weak_count **)(v8 + 424);
  v11[0] = *(void *)(v8 + 416);
  v11[1] = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  int v22 = 0;
  char v17 = 1;
  long long v18 = xmmword_1A28FCEC0;
  int v19 = 7;
  char v23 = 15;
  double v10 = operator new(0x198uLL);
  v10[1] = 0;
  v10[2] = 0;
  *double v10 = &unk_1EF5890B8;
  v16[0] = v12;
  v16[1] = v13;
  v11[2] = ggl::Debug::ExtendedPipelineState::ExtendedPipelineState((uint64_t)(v10 + 3), v11, (uint64_t)&v17, v16);
  v11[3] = v10;
  if (v9)
  {
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  operator new();
}

void sub_1A237FBA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,char a29)
{
  (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a19);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v32 + 32);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a29);
  (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a21);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a27);

  _Unwind_Resume(a1);
}

uint64_t ___ZN12_GLOBAL__N_118createMeshDrawableERKN2md13LayoutContextEP17VKSharedResourcesRKNSt3__110unique_ptrIN3ggl11RenderStateENS6_14default_deleteIS9_EEEERKNS6_6vectorINS8_5Debug11ExtendedVboENS6_9allocatorISH_EEEE_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 32);
  unint64_t v2 = v1[6] - v1[5];
  unint64_t v3 = v2 / v1[1] * v1[1];
  unint64_t v4 = v2 % v1[1];
  if (v2 == v4) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v1[9];
  }
  uint8x8_t v6 = *(uint64_t **)(result + 48);
  uint64_t v7 = *v6;
  uint64_t v8 = v6[1] - *v6;
  if (v8)
  {
    unint64_t v9 = v8 >> 5;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    double v10 = (_DWORD *)(v5 + 16);
    double v11 = (_DWORD *)(v7 + 16);
    do
    {
      *(v10 - 4) = *(v11 - 4);
      *(v10 - 3) = *(v11 - 3);
      *(v10 - 2) = *(v11 - 2);
      *double v10 = *v11;
      v10[1] = v11[1];
      v10[2] = v11[2];
      void v10[3] = v11[3];
      v10 += 8;
      v11 += 8;
      --v9;
    }
    while (v9);
  }
  if (v5 && v2 != v4)
  {
    if (v1[8] > v3) {
      unint64_t v3 = v1[8];
    }
    v1[7] = 0;
    v1[8] = v3;
  }
  return result;
}

uint64_t std::__shared_ptr_emplace<ggl::Debug::ExtendedMesh>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Debug::ExtendedMesh>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589010;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Debug::ExtendedMesh>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589010;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void __destroy_helper_block_ea8_32c75_ZTSNSt3__110shared_ptrIN3ggl15VertexDataTypedINS1_5Debug11ExtendedVboEEEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_ea8_32c75_ZTSNSt3__110shared_ptrIN3ggl15VertexDataTypedINS1_5Debug11ExtendedVboEEEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::Debug::ExtendedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::Debug::ExtendedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::Debug::ExtendedVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Debug::ExtendedVbo>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Debug::ExtendedVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584EA8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Debug::ExtendedVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584EA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

__n128 std::__function::__func<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_2,std::allocator<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_2>,void ()(md::mun::MuninNavigationGraph const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF578C78;
  long long v2 = *(_OWORD *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(_OWORD *)(a2 + 8) = v2;
  __n128 result = *(__n128 *)(a1 + 56);
  long long v5 = *(_OWORD *)(a1 + 72);
  long long v6 = *(_OWORD *)(a1 + 88);
  *(void *)(a2 + 104) = *(void *)(a1 + 104);
  *(_OWORD *)(a2 + 88) = v6;
  *(_OWORD *)(a2 + 72) = v5;
  *(__n128 *)(a2 + 56) = result;
  return result;
}

__n128 std::__function::__func<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_2,std::allocator<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_2>,void ()(md::mun::MuninNavigationGraph const*)>::__clone(uint64_t a1)
{
  long long v2 = (char *)operator new(0x70uLL);
  *(void *)long long v2 = &unk_1EF578C78;
  *(_OWORD *)(v2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v2 + 72) = *(_OWORD *)(a1 + 72);
  *(_OWORD *)(v2 + 88) = *(_OWORD *)(a1 + 88);
  *((void *)v2 + 13) = *(void *)(a1 + 104);
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

void std::__function::__func<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_2,std::allocator<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_2>,void ()(md::mun::MuninNavigationGraph const*)>::~__func()
{
}

void std::swap[abi:nn180100]<md::mun::CollectionPoint>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v44 = *a1;
  long long v45 = *(_OWORD *)(a1 + 1);
  uint64_t v3 = a1[4];
  uint64_t v46 = a1[3];
  *(void *)float v47 = v3;
  *(_DWORD *)&v47[8] = *((_DWORD *)a1 + 10);
  *(void *)&v47[12] = *(uint64_t *)((char *)a1 + 44);
  long long v4 = *(_OWORD *)(a1 + 9);
  long long v48 = *(_OWORD *)(a1 + 7);
  long long v49 = v4;
  long long v5 = v54;
  float v50 = v54;
  uint64_t v6 = a1[14];
  uint64_t v7 = a1[11];
  float v52 = v54;
  uint64_t v53 = v6;
  if (v7 != a1[13])
  {
    uint64_t v8 = (unsigned char *)a1[12];
    float v50 = (unsigned char *)v7;
    float v51 = v8;
    *(_OWORD *)(a1 + 11) = 0u;
    *(_OWORD *)(a1 + 13) = 0u;
    goto LABEL_3;
  }
  uint64_t v14 = a1[12];
  float v51 = &v54[v14 - v7];
  if (v14 != v7)
  {
    uint64_t v15 = 0;
    double v16 = &v56;
    char v17 = v55;
    do
    {
      long long v18 = *(_OWORD *)v7;
      *((void *)v5 + 2) = *(void *)(v7 + 16);
      *(_OWORD *)long long v5 = v18;
      uint64_t v19 = *(void *)(v7 + 24);
      *((_DWORD *)v5 + 8) = *(_DWORD *)(v7 + 32);
      *((void *)v5 + 3) = v19;
      *(void *)(v5 + 36) = *(void *)(v7 + 36);
      long long v20 = *(_OWORD *)(v7 + 44);
      long long v21 = *(_OWORD *)(v7 + 60);
      long long v22 = *(_OWORD *)(v7 + 76);
      *(_OWORD *)(v5 + 92) = *(_OWORD *)(v7 + 92);
      *(_OWORD *)(v5 + 76) = v22;
      *(_OWORD *)(v5 + 60) = v21;
      *(_OWORD *)(v5 + 44) = v20;
      long long v23 = *(_OWORD *)(v7 + 108);
      long long v24 = *(_OWORD *)(v7 + 124);
      long long v25 = *(_OWORD *)(v7 + 140);
      *(_OWORD *)(v5 + 156) = *(_OWORD *)(v7 + 156);
      *(_OWORD *)(v5 + 140) = v25;
      *(_OWORD *)(v5 + 124) = v24;
      *(_OWORD *)(v5 + 108) = v23;
      long long v26 = *(_OWORD *)(v7 + 172);
      long long v27 = *(_OWORD *)(v7 + 188);
      long long v28 = *(_OWORD *)(v7 + 204);
      *(_OWORD *)(v5 + 220) = *(_OWORD *)(v7 + 220);
      *(_OWORD *)(v5 + 204) = v28;
      *(_OWORD *)(v5 + 188) = v27;
      *(_OWORD *)(v5 + 172) = v26;
      float v29 = v5 + 280;
      *((void *)v5 + 31) = v5 + 280;
      uint64_t v30 = *(char **)(v7 + 248);
      *((_DWORD *)v5 + 59) = *(_DWORD *)(v7 + 236);
      v5[240] = *(unsigned char *)(v7 + 240);
      *((void *)v5 + 32) = v5 + 280;
      *((void *)v5 + 33) = v5 + 280;
      *((void *)v5 + 34) = *(void *)(v7 + 272);
      if (v30 == *(char **)(v7 + 264))
      {
        *((void *)v5 + 32) = &v29[*(void *)(v7 + 256) - (void)v30];
        uint64_t v31 = *(char **)(v7 + 256);
        if (v30 != v31)
        {
          unint64_t v32 = v31 - v30;
          if ((unint64_t)(v31 - v30) >= 8 && (unint64_t)(&v55[288 * v15] - v30) >= 0x20)
          {
            if (v32 < 0x20)
            {
              unint64_t v33 = 0;
              goto LABEL_30;
            }
            unint64_t v33 = v32 & 0xFFFFFFFFFFFFFFE0;
            unint64_t v34 = (long long *)(v30 + 16);
            unint64_t v35 = v16;
            unint64_t v36 = v32 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v37 = *v34;
              *((_OWORD *)v35 - 1) = *(v34 - 1);
              *(_OWORD *)unint64_t v35 = v37;
              v34 += 2;
              v35 += 4;
              v36 -= 32;
            }
            while (v36);
            if (v32 == v33) {
              goto LABEL_19;
            }
            if ((v32 & 0x18) != 0)
            {
LABEL_30:
              unint64_t v38 = v32 & 0xFFFFFFFFFFFFFFF8;
              v29 += v32 & 0xFFFFFFFFFFFFFFF8;
              unint64_t v39 = v33 - (v32 & 0xFFFFFFFFFFFFFFF8);
              uint64_t v40 = (uint64_t *)&v30[v33];
              unint64_t v41 = &v17[v33];
              do
              {
                uint64_t v42 = *v40++;
                *v41++ = v42;
                v39 += 8;
              }
              while (v39);
              if (v32 == v38) {
                goto LABEL_19;
              }
              v30 += v38;
            }
            else
            {
              v30 += v33;
              v29 += v33;
            }
          }
          do
          {
            char v43 = *v30++;
            *v29++ = v43;
          }
          while (v30 != v31);
        }
      }
      else
      {
        *((void *)v5 + 31) = v30;
        *((void *)v5 + 32) = *(void *)(v7 + 256);
        *(_OWORD *)(v7 + 248) = 0uLL;
        *(_OWORD *)(v7 + 264) = 0uLL;
      }
LABEL_19:
      v5 += 288;
      v7 += 288;
      ++v15;
      v16 += 36;
      v17 += 288;
    }
    while (v7 != v14);
  }
LABEL_3:
  unint64_t v9 = a1 + 231;
  *(void *)((char *)v57 + 5) = *(uint64_t *)((char *)a1 + 1853);
  v57[0] = a1[231];
  *a1 = *a2;
  *((_DWORD *)a1 + 8) = *((_DWORD *)a2 + 8);
  *((_DWORD *)a1 + 9) = *((_DWORD *)a2 + 9);
  *((_DWORD *)a1 + 10) = *((_DWORD *)a2 + 10);
  *((_DWORD *)a1 + 11) = *((_DWORD *)a2 + 11);
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  *((_DWORD *)a1 + 12) = *((_DWORD *)a2 + 12);
  a1[7] = a2[7];
  a1[8] = a2[8];
  a1[9] = a2[9];
  a1[10] = a2[10];
  if (a1 != a2) {
    geo::small_vector_base<md::mun::PhotoInfo>::move((uint64_t)(a1 + 11), a2 + 11, (uint64_t)(a1 + 15));
  }
  uint64_t v10 = a2[231];
  *(void *)((char *)v9 + 5) = *(uint64_t *)((char *)a2 + 1853);
  *unint64_t v9 = v10;
  *a2 = v44;
  *((_OWORD *)a2 + 2) = *(_OWORD *)v47;
  *(_OWORD *)(a2 + 1) = v45;
  a2[3] = v46;
  *((_DWORD *)a2 + 12) = *(_DWORD *)&v47[16];
  *(_OWORD *)(a2 + 7) = v48;
  *(_OWORD *)(a2 + 9) = v49;
  if (&v44 != a2) {
    geo::small_vector_base<md::mun::PhotoInfo>::move((uint64_t)(a2 + 11), (uint64_t *)&v50, (uint64_t)(a2 + 15));
  }
  a2[231] = v57[0];
  *(uint64_t *)((char *)a2 + 1853) = *(void *)((char *)v57 + 5);
  double v11 = v50;
  long long v12 = v51;
  if (v50 != v51)
  {
    do
    {
      long long v13 = (void *)v11[31];
      if (v13 != (void *)v11[33]) {
        free(v13);
      }
      v11 += 36;
    }
    while (v11 != v12);
    double v11 = v50;
  }
  if (v11 != (void *)v52) {
    free(v11);
  }
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_0 &,md::mun::CollectionPoint *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v7 = a1;
  unint64_t v8 = a2[10];
  unint64_t v9 = a3[10];
  if (v8 >= a1[10])
  {
    if (v9 < v8)
    {
      std::swap[abi:nn180100]<md::mun::CollectionPoint>(a2, a3);
      if (a2[10] < (unint64_t)v7[10])
      {
        a1 = v7;
        uint64_t v10 = a2;
        goto LABEL_9;
      }
    }
  }
  else
  {
    if (v9 < v8)
    {
LABEL_5:
      uint64_t v10 = a3;
LABEL_9:
      std::swap[abi:nn180100]<md::mun::CollectionPoint>(a1, v10);
      goto LABEL_10;
    }
    std::swap[abi:nn180100]<md::mun::CollectionPoint>(a1, a2);
    if (a3[10] < (unint64_t)a2[10])
    {
      a1 = a2;
      goto LABEL_5;
    }
  }
LABEL_10:
  if (a4[10] < (unint64_t)a3[10])
  {
    std::swap[abi:nn180100]<md::mun::CollectionPoint>(a3, a4);
    if (a3[10] < (unint64_t)a2[10])
    {
      std::swap[abi:nn180100]<md::mun::CollectionPoint>(a2, a3);
      if (a2[10] < (unint64_t)v7[10])
      {
        std::swap[abi:nn180100]<md::mun::CollectionPoint>(v7, a2);
      }
    }
  }
}

void std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_0 &,md::mun::CollectionPoint *>(uint64_t *a1, uint64_t *a2)
{
  if (a1 != a2)
  {
    v113[13] = v2;
    v113[14] = v3;
    long long v4 = a2;
    uint64_t v6 = a1 + 233;
    if (a1 + 233 != a2)
    {
      uint64_t v7 = 0;
      unint64_t v8 = a1 + 283;
      unint64_t v9 = a1 + 285;
      double v94 = a1 + 283;
      uint64_t v10 = a1;
      while (1)
      {
        double v11 = v6;
        if (v10[243] < (unint64_t)v10[10]) {
          break;
        }
LABEL_5:
        uint64_t v6 = v11 + 233;
        ++v7;
        unint64_t v9 = (_OWORD *)((char *)v9 + 1864);
        v8 += 233;
        uint64_t v10 = v11;
        if (v11 + 233 == v4) {
          return;
        }
      }
      uint64_t v98 = *v6;
      long long v99 = *((_OWORD *)v10 + 117);
      uint64_t v100 = v10[236];
      uint64_t v101 = v10[237];
      int v102 = *((_DWORD *)v10 + 476);
      uint64_t v103 = *(uint64_t *)((char *)v10 + 1908);
      long long v12 = *((_OWORD *)v10 + 121);
      long long v104 = *((_OWORD *)v10 + 120);
      long long v105 = v12;
      double v106 = v110;
      uint64_t v13 = v10[247];
      uint64_t v108 = v110;
      uint64_t v109 = v13;
      uint64_t v14 = (long long *)v10[244];
      if (v14 != (long long *)v10[246])
      {
        uint64_t v15 = (unsigned char *)v10[245];
        double v106 = (void *)v10[244];
        float v107 = v15;
        *((_OWORD *)v10 + 122) = 0u;
        *((_OWORD *)v10 + 123) = 0u;
        goto LABEL_9;
      }
      unint64_t v62 = (long long *)v10[245];
      float v107 = &v110[(char *)v62 - (char *)v14];
      if (v62 == v14)
      {
LABEL_9:
        uint64_t v16 = 0;
        uint64_t v96 = v7;
        BOOL v97 = &v94[233 * v7];
        v113[0] = v10[464];
        *(void *)((char *)v113 + 5) = *(uint64_t *)((char *)v10 + 3717);
        char v17 = v8;
        long long v18 = v9;
        uint64_t v95 = v11;
        uint64_t v19 = v11;
        while (1)
        {
          long long v20 = v10;
          *uint64_t v19 = *v10;
          *((_DWORD *)v19 + 8) = *((_DWORD *)v10 + 8);
          *((_DWORD *)v19 + 9) = *((_DWORD *)v10 + 9);
          *((_DWORD *)v19 + 10) = *((_DWORD *)v10 + 10);
          *((_DWORD *)v19 + 11) = *((_DWORD *)v10 + 11);
          v19[1] = v10[1];
          v19[2] = v10[2];
          v19[3] = v10[3];
          *((_DWORD *)v19 + 12) = *((_DWORD *)v10 + 12);
          v19[7] = v10[7];
          v19[8] = v10[8];
          v19[9] = v10[9];
          v19[10] = v10[10];
          long long v21 = (void *)v19[11];
          long long v22 = (void *)v19[12];
          if (v21 != v22)
          {
            do
            {
              long long v23 = (void *)v21[31];
              if (v23 != (void *)v21[33]) {
                free(v23);
              }
              v21 += 36;
            }
            while (v21 != v22);
            long long v21 = (void *)v19[11];
          }
          if (v21 != (void *)v19[13]) {
            free(v21);
          }
          long long v24 = v19 + 15;
          v19[13] = (uint64_t)(v19 + 15);
          long long v25 = (long long *)v20[11];
          if (v25 != (long long *)v20[13])
          {
            v19[11] = (uint64_t)v25;
            v19[12] = v20[12];
            *(_OWORD *)(v20 + 11) = 0u;
            *(_OWORD *)(v20 + 13) = 0u;
            goto LABEL_20;
          }
          v19[11] = (uint64_t)v24;
          long long v28 = (long long *)v20[12];
          v19[12] = (uint64_t)v24 + (char *)v28 - (char *)v25;
          if (v28 != v25) {
            break;
          }
LABEL_20:
          v19[14] = v20[14];
          long long v26 = v20 + 231;
          v19[231] = v20[231];
          *(uint64_t *)((char *)v19 + 1853) = *(uint64_t *)((char *)v20 + 1853);
          uint64_t v27 = *((void *)&v105 + 1);
          if (v20 == a1)
          {
            long long v20 = a1;
LABEL_45:
            uint64_t *v20 = v98;
            v20[4] = v101;
            *((_DWORD *)v20 + 10) = v102;
            *((_DWORD *)v20 + 11) = v103;
            *(_OWORD *)(v20 + 1) = v99;
            v20[3] = v100;
            *((_DWORD *)v20 + 12) = HIDWORD(v103);
            *(_OWORD *)(v20 + 7) = v104;
            v20[9] = v105;
            v20[10] = v27;
            if (v20 != &v98) {
              geo::small_vector_base<md::mun::PhotoInfo>::move((uint64_t)(v20 + 11), (uint64_t *)&v106, (uint64_t)(v20 + 15));
            }
            uint64_t v58 = v113[0];
            *(void *)((char *)v26 + 5) = *(void *)((char *)v113 + 5);
            void *v26 = v58;
            unint64_t v60 = v106;
            uint64_t v59 = v107;
            uint64_t v7 = v96;
            if (v106 == v107)
            {
              long long v4 = a2;
            }
            else
            {
              do
              {
                uint64_t v61 = (void *)v60[31];
                if (v61 != (void *)v60[33]) {
                  free(v61);
                }
                v60 += 36;
              }
              while (v60 != v59);
              unint64_t v60 = v106;
              long long v4 = a2;
            }
            if (v60 != (void *)v108) {
              free(v60);
            }
            double v11 = v95;
            goto LABEL_5;
          }
          uint64_t v10 = v20 - 233;
          ++v16;
          long long v18 = (_OWORD *)((char *)v18 - 1864);
          v17 -= 233;
          uint64_t v19 = v20;
          if (*((void *)&v105 + 1) >= (unint64_t)*(v20 - 223)) {
            goto LABEL_45;
          }
        }
        uint64_t v29 = 0;
        uint64_t v30 = v17;
        uint64_t v31 = v18;
        while (1)
        {
          long long v32 = *v25;
          v24[2] = *((void *)v25 + 2);
          *(_OWORD *)long long v24 = v32;
          uint64_t v33 = *((void *)v25 + 3);
          *((_DWORD *)v24 + 8) = *((_DWORD *)v25 + 8);
          v24[3] = v33;
          *(void *)((char *)v24 + 36) = *(void *)((char *)v25 + 36);
          long long v34 = *(long long *)((char *)v25 + 44);
          long long v35 = *(long long *)((char *)v25 + 60);
          long long v36 = *(long long *)((char *)v25 + 76);
          *(_OWORD *)((char *)v24 + 92) = *(long long *)((char *)v25 + 92);
          *(_OWORD *)((char *)v24 + 76) = v36;
          *(_OWORD *)((char *)v24 + 60) = v35;
          *(_OWORD *)((char *)v24 + 44) = v34;
          long long v37 = *(long long *)((char *)v25 + 108);
          long long v38 = *(long long *)((char *)v25 + 124);
          long long v39 = *(long long *)((char *)v25 + 140);
          *(_OWORD *)((char *)v24 + 156) = *(long long *)((char *)v25 + 156);
          *(_OWORD *)((char *)v24 + 140) = v39;
          *(_OWORD *)((char *)v24 + 124) = v38;
          *(_OWORD *)((char *)v24 + 108) = v37;
          long long v40 = *(long long *)((char *)v25 + 172);
          long long v41 = *(long long *)((char *)v25 + 188);
          long long v42 = *(long long *)((char *)v25 + 204);
          *(_OWORD *)((char *)v24 + 220) = *(long long *)((char *)v25 + 220);
          *(_OWORD *)((char *)v24 + 204) = v42;
          *(_OWORD *)((char *)v24 + 188) = v41;
          *(_OWORD *)((char *)v24 + 172) = v40;
          char v43 = v24 + 35;
          v24[31] = v24 + 35;
          uint64_t v44 = (char *)*((void *)v25 + 31);
          *((_DWORD *)v24 + 59) = *((_DWORD *)v25 + 59);
          *((unsigned char *)v24 + 240) = *((unsigned char *)v25 + 240);
          v24[32] = v24 + 35;
          v24[33] = v24 + 35;
          v24[34] = *((void *)v25 + 34);
          if (v44 == *((char **)v25 + 33))
          {
            v24[32] = &v43[*((void *)v25 + 32) - (void)v44];
            long long v45 = (char *)*((void *)v25 + 32);
            if (v44 != v45)
            {
              unint64_t v46 = v45 - v44;
              if ((unint64_t)(v45 - v44) >= 8
                && (unint64_t)((char *)&v97[36 * v29 + -233 * v16] - v44) >= 0x20)
              {
                if (v46 < 0x20)
                {
                  unint64_t v47 = 0;
                  goto LABEL_37;
                }
                unint64_t v47 = v46 & 0xFFFFFFFFFFFFFFE0;
                long long v48 = (long long *)(v44 + 16);
                long long v49 = v31;
                unint64_t v50 = v46 & 0xFFFFFFFFFFFFFFE0;
                do
                {
                  long long v51 = *v48;
                  *(v49 - 1) = *(v48 - 1);
                  *long long v49 = v51;
                  v48 += 2;
                  v49 += 2;
                  v50 -= 32;
                }
                while (v50);
                if (v46 == v47) {
                  goto LABEL_26;
                }
                if ((v46 & 0x18) != 0)
                {
LABEL_37:
                  unint64_t v52 = v46 & 0xFFFFFFFFFFFFFFF8;
                  v43 += v46 & 0xFFFFFFFFFFFFFFF8;
                  unint64_t v53 = v47 - (v46 & 0xFFFFFFFFFFFFFFF8);
                  unint64_t v54 = (uint64_t *)&v44[v47];
                  int16x8_t v55 = (void *)((char *)v30 + v47);
                  do
                  {
                    uint64_t v56 = *v54++;
                    *v55++ = v56;
                    v53 += 8;
                  }
                  while (v53);
                  if (v46 == v52) {
                    goto LABEL_26;
                  }
                  v44 += v52;
                }
                else
                {
                  v44 += v47;
                  v43 += v47;
                }
              }
              do
              {
                char v57 = *v44++;
                *v43++ = v57;
              }
              while (v44 != v45);
            }
          }
          else
          {
            v24[31] = v44;
            v24[32] = *((void *)v25 + 32);
            *(long long *)((char *)v25 + 248) = 0u;
            *(long long *)((char *)v25 + 264) = 0u;
          }
LABEL_26:
          v24 += 36;
          v25 += 18;
          ++v29;
          v31 += 18;
          v30 += 36;
          if (v25 == v28) {
            goto LABEL_20;
          }
        }
      }
      uint64_t v63 = 0;
      int8x16_t v64 = v111;
      int8x16_t v65 = &v112;
      uint64_t v66 = v110;
      while (1)
      {
        long long v67 = *v14;
        *((void *)v66 + 2) = *((void *)v14 + 2);
        *(_OWORD *)uint64_t v66 = v67;
        uint64_t v68 = *((void *)v14 + 3);
        *((_DWORD *)v66 + 8) = *((_DWORD *)v14 + 8);
        *((void *)v66 + 3) = v68;
        *(void *)(v66 + 36) = *(void *)((char *)v14 + 36);
        long long v69 = *(long long *)((char *)v14 + 44);
        long long v70 = *(long long *)((char *)v14 + 60);
        long long v71 = *(long long *)((char *)v14 + 76);
        *(_OWORD *)(v66 + 92) = *(long long *)((char *)v14 + 92);
        *(_OWORD *)(v66 + 76) = v71;
        *(_OWORD *)(v66 + 60) = v70;
        *(_OWORD *)(v66 + 44) = v69;
        long long v72 = *(long long *)((char *)v14 + 108);
        long long v73 = *(long long *)((char *)v14 + 124);
        long long v74 = *(long long *)((char *)v14 + 140);
        *(_OWORD *)(v66 + 156) = *(long long *)((char *)v14 + 156);
        *(_OWORD *)(v66 + 140) = v74;
        *(_OWORD *)(v66 + 124) = v73;
        *(_OWORD *)(v66 + 108) = v72;
        long long v75 = *(long long *)((char *)v14 + 172);
        long long v76 = *(long long *)((char *)v14 + 188);
        long long v77 = *(long long *)((char *)v14 + 204);
        *(_OWORD *)(v66 + 220) = *(long long *)((char *)v14 + 220);
        *(_OWORD *)(v66 + 204) = v77;
        *(_OWORD *)(v66 + 188) = v76;
        *(_OWORD *)(v66 + 172) = v75;
        float v78 = v66 + 280;
        *((void *)v66 + 31) = v66 + 280;
        int8x16_t v79 = (char *)*((void *)v14 + 31);
        *((_DWORD *)v66 + 59) = *((_DWORD *)v14 + 59);
        v66[240] = *((unsigned char *)v14 + 240);
        *((void *)v66 + 32) = v66 + 280;
        *((void *)v66 + 33) = v66 + 280;
        *((void *)v66 + 34) = *((void *)v14 + 34);
        if (v79 == *((char **)v14 + 33))
        {
          *((void *)v66 + 32) = &v78[*((void *)v14 + 32) - (void)v79];
          float v80 = (char *)*((void *)v14 + 32);
          if (v79 != v80)
          {
            unint64_t v81 = v80 - v79;
            if ((unint64_t)(v80 - v79) >= 8 && (unint64_t)(&v111[288 * v63] - v79) >= 0x20)
            {
              if (v81 < 0x20)
              {
                unint64_t v82 = 0;
                goto LABEL_67;
              }
              unint64_t v82 = v81 & 0xFFFFFFFFFFFFFFE0;
              unint64_t v83 = (long long *)(v79 + 16);
              __int16 v84 = v65;
              unint64_t v85 = v81 & 0xFFFFFFFFFFFFFFE0;
              do
              {
                long long v86 = *v83;
                *((_OWORD *)v84 - 1) = *(v83 - 1);
                *(_OWORD *)__int16 v84 = v86;
                v83 += 2;
                v84 += 4;
                v85 -= 32;
              }
              while (v85);
              if (v81 == v82) {
                goto LABEL_56;
              }
              if ((v81 & 0x18) != 0)
              {
LABEL_67:
                unint64_t v87 = v81 & 0xFFFFFFFFFFFFFFF8;
                v78 += v81 & 0xFFFFFFFFFFFFFFF8;
                unint64_t v88 = v82 - (v81 & 0xFFFFFFFFFFFFFFF8);
                uint64_t v89 = (uint64_t *)&v79[v82];
                unint64_t v90 = &v64[v82];
                do
                {
                  uint64_t v91 = *v89++;
                  *v90++ = v91;
                  v88 += 8;
                }
                while (v88);
                if (v81 == v87) {
                  goto LABEL_56;
                }
                v79 += v87;
              }
              else
              {
                v79 += v82;
                v78 += v82;
              }
            }
            do
            {
              char v92 = *v79++;
              *v78++ = v92;
            }
            while (v79 != v80);
          }
        }
        else
        {
          *((void *)v66 + 31) = v79;
          *((void *)v66 + 32) = *((void *)v14 + 32);
          *(long long *)((char *)v14 + 248) = 0u;
          *(long long *)((char *)v14 + 264) = 0u;
        }
LABEL_56:
        v66 += 288;
        v14 += 18;
        ++v63;
        v65 += 36;
        v64 += 288;
        if (v14 == v62) {
          goto LABEL_9;
        }
      }
    }
  }
}

uint64_t *std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_0 &,md::mun::CollectionPoint *>(uint64_t *result, uint64_t *a2)
{
  if (result != a2)
  {
    v111[13] = v2;
    v111[14] = v3;
    long long v4 = a2;
    long long v5 = result + 233;
    if (result + 233 != a2)
    {
      uint64_t v6 = 0;
      uint64_t v7 = result + 283;
      unint64_t v8 = result + 285;
      char v92 = result + 283;
      while (1)
      {
        unint64_t v9 = v5;
        if (result[243] >= (unint64_t)result[10]) {
          goto LABEL_5;
        }
        uint64_t v96 = *v5;
        long long v97 = *((_OWORD *)result + 117);
        uint64_t v98 = result[236];
        uint64_t v99 = result[237];
        int v100 = *((_DWORD *)result + 476);
        uint64_t v101 = *(uint64_t *)((char *)result + 1908);
        long long v10 = *((_OWORD *)result + 121);
        long long v102 = *((_OWORD *)result + 120);
        long long v103 = v10;
        long long v104 = v108;
        uint64_t v11 = result[247];
        double v106 = v108;
        uint64_t v107 = v11;
        long long v12 = (long long *)result[244];
        if (v12 != (long long *)result[246])
        {
          uint64_t v13 = (unsigned char *)result[245];
          long long v104 = (void *)result[244];
          long long v105 = v13;
          *((_OWORD *)result + 122) = 0u;
          *((_OWORD *)result + 123) = 0u;
          goto LABEL_9;
        }
        unint64_t v60 = (long long *)result[245];
        long long v105 = &v108[(char *)v60 - (char *)v12];
        if (v60 != v12) {
          break;
        }
LABEL_9:
        uint64_t v14 = 0;
        double v93 = v8;
        uint64_t v94 = v6;
        uint64_t v15 = &v92[233 * v6];
        v111[0] = result[464];
        *(void *)((char *)v111 + 5) = *(uint64_t *)((char *)result + 3717);
        uint64_t v16 = v7;
        char v17 = v8;
        uint64_t v95 = v9;
        long long v18 = v9;
        do
        {
          long long v20 = v18;
          long long v18 = result;
          uint64_t *v20 = *result;
          *((_DWORD *)v20 + 8) = *((_DWORD *)result + 8);
          *((_DWORD *)v20 + 9) = *((_DWORD *)result + 9);
          *((_DWORD *)v20 + 10) = *((_DWORD *)result + 10);
          *((_DWORD *)v20 + 11) = *((_DWORD *)result + 11);
          v20[1] = result[1];
          v20[2] = result[2];
          v20[3] = result[3];
          *((_DWORD *)v20 + 12) = *((_DWORD *)result + 12);
          v20[7] = result[7];
          v20[8] = result[8];
          v20[9] = result[9];
          v20[10] = result[10];
          long long v22 = (void *)v20[11];
          long long v21 = (void *)v20[12];
          if (v22 != v21)
          {
            do
            {
              long long v23 = (void *)v22[31];
              if (v23 != (void *)v22[33]) {
                free(v23);
              }
              v22 += 36;
            }
            while (v22 != v21);
            long long v22 = (void *)v20[11];
          }
          if (v22 != (void *)v20[13]) {
            free(v22);
          }
          long long v24 = v20 + 15;
          v20[13] = (uint64_t)(v20 + 15);
          long long v25 = (long long *)v18[11];
          if (v25 == (long long *)v18[13])
          {
            v20[11] = (uint64_t)v24;
            long long v26 = (long long *)v18[12];
            v20[12] = (uint64_t)v24 + (char *)v26 - (char *)v25;
            if (v26 != v25)
            {
              uint64_t v27 = 0;
              long long v28 = v16;
              uint64_t v29 = v17;
              do
              {
                long long v30 = *v25;
                v24[2] = *((void *)v25 + 2);
                *(_OWORD *)long long v24 = v30;
                uint64_t v31 = *((void *)v25 + 3);
                *((_DWORD *)v24 + 8) = *((_DWORD *)v25 + 8);
                v24[3] = v31;
                *(void *)((char *)v24 + 36) = *(void *)((char *)v25 + 36);
                long long v32 = *(long long *)((char *)v25 + 44);
                long long v33 = *(long long *)((char *)v25 + 60);
                long long v34 = *(long long *)((char *)v25 + 76);
                *(_OWORD *)((char *)v24 + 92) = *(long long *)((char *)v25 + 92);
                *(_OWORD *)((char *)v24 + 76) = v34;
                *(_OWORD *)((char *)v24 + 60) = v33;
                *(_OWORD *)((char *)v24 + 44) = v32;
                long long v35 = *(long long *)((char *)v25 + 108);
                long long v36 = *(long long *)((char *)v25 + 124);
                long long v37 = *(long long *)((char *)v25 + 140);
                *(_OWORD *)((char *)v24 + 156) = *(long long *)((char *)v25 + 156);
                *(_OWORD *)((char *)v24 + 140) = v37;
                *(_OWORD *)((char *)v24 + 124) = v36;
                *(_OWORD *)((char *)v24 + 108) = v35;
                long long v38 = *(long long *)((char *)v25 + 172);
                long long v39 = *(long long *)((char *)v25 + 188);
                long long v40 = *(long long *)((char *)v25 + 204);
                *(_OWORD *)((char *)v24 + 220) = *(long long *)((char *)v25 + 220);
                *(_OWORD *)((char *)v24 + 204) = v40;
                *(_OWORD *)((char *)v24 + 188) = v39;
                *(_OWORD *)((char *)v24 + 172) = v38;
                long long v41 = v24 + 35;
                v24[31] = v24 + 35;
                long long v42 = (char *)*((void *)v25 + 31);
                *((_DWORD *)v24 + 59) = *((_DWORD *)v25 + 59);
                *((unsigned char *)v24 + 240) = *((unsigned char *)v25 + 240);
                v24[32] = v24 + 35;
                v24[33] = v24 + 35;
                v24[34] = *((void *)v25 + 34);
                if (v42 == *((char **)v25 + 33))
                {
                  v24[32] = &v41[*((void *)v25 + 32) - (void)v42];
                  char v43 = (char *)*((void *)v25 + 32);
                  if (v42 != v43)
                  {
                    unint64_t v44 = v43 - v42;
                    if ((unint64_t)(v43 - v42) >= 8
                      && (unint64_t)((char *)&v15[36 * v27 + -233 * v14] - v42) >= 0x20)
                    {
                      if (v44 < 0x20)
                      {
                        unint64_t v45 = 0;
                        goto LABEL_35;
                      }
                      unint64_t v45 = v44 & 0xFFFFFFFFFFFFFFE0;
                      unint64_t v46 = (long long *)(v42 + 16);
                      unint64_t v47 = v29;
                      unint64_t v48 = v44 & 0xFFFFFFFFFFFFFFE0;
                      do
                      {
                        long long v49 = *v46;
                        *(v47 - 1) = *(v46 - 1);
                        _OWORD *v47 = v49;
                        v46 += 2;
                        v47 += 2;
                        v48 -= 32;
                      }
                      while (v48);
                      if (v44 == v45) {
                        goto LABEL_24;
                      }
                      if ((v44 & 0x18) != 0)
                      {
LABEL_35:
                        unint64_t v50 = v44 & 0xFFFFFFFFFFFFFFF8;
                        v41 += v44 & 0xFFFFFFFFFFFFFFF8;
                        unint64_t v51 = v45 - (v44 & 0xFFFFFFFFFFFFFFF8);
                        unint64_t v52 = (uint64_t *)&v42[v45];
                        unint64_t v53 = (void *)((char *)v28 + v45);
                        do
                        {
                          uint64_t v54 = *v52++;
                          *v53++ = v54;
                          v51 += 8;
                        }
                        while (v51);
                        if (v44 == v50) {
                          goto LABEL_24;
                        }
                        v42 += v50;
                      }
                      else
                      {
                        v42 += v45;
                        v41 += v45;
                      }
                    }
                    do
                    {
                      char v55 = *v42++;
                      *v41++ = v55;
                    }
                    while (v42 != v43);
                  }
                }
                else
                {
                  v24[31] = v42;
                  v24[32] = *((void *)v25 + 32);
                  *(long long *)((char *)v25 + 248) = 0u;
                  *(long long *)((char *)v25 + 264) = 0u;
                }
LABEL_24:
                v24 += 36;
                v25 += 18;
                ++v27;
                v29 += 18;
                v28 += 36;
              }
              while (v25 != v26);
            }
          }
          else
          {
            v20[11] = (uint64_t)v25;
            v20[12] = v18[12];
            *(_OWORD *)(v18 + 11) = 0u;
            *(_OWORD *)(v18 + 13) = 0u;
          }
          v20[14] = v18[14];
          v20[231] = v18[231];
          *(uint64_t *)((char *)v20 + 1853) = *(uint64_t *)((char *)v18 + 1853);
          __n128 result = v18 - 233;
          uint64_t v19 = *((void *)&v103 + 1);
          ++v14;
          char v17 = (_OWORD *)((char *)v17 - 1864);
          v16 -= 233;
        }
        while (*((void *)&v103 + 1) < (unint64_t)*(v18 - 223));
        *long long v18 = v96;
        v18[4] = v99;
        *((_DWORD *)v18 + 10) = v100;
        *((_DWORD *)v18 + 11) = v101;
        *(_OWORD *)(v18 + 1) = v97;
        v18[3] = v98;
        *((_DWORD *)v18 + 12) = HIDWORD(v101);
        *(_OWORD *)(v18 + 7) = v102;
        v18[9] = v103;
        v18[10] = v19;
        if (v18 != &v96) {
          geo::small_vector_base<md::mun::PhotoInfo>::move((uint64_t)(v18 + 11), (uint64_t *)&v104, (uint64_t)(v18 + 15));
        }
        uint64_t v56 = v111[0];
        *(uint64_t *)((char *)v18 + 1853) = *(void *)((char *)v111 + 5);
        v18[231] = v56;
        uint64_t v58 = v104;
        char v57 = v105;
        if (v104 == v105)
        {
          long long v4 = a2;
          unint64_t v8 = v93;
          uint64_t v6 = v94;
        }
        else
        {
          unint64_t v8 = v93;
          uint64_t v6 = v94;
          do
          {
            uint64_t v59 = (void *)v58[31];
            if (v59 != (void *)v58[33]) {
              free(v59);
            }
            v58 += 36;
          }
          while (v58 != v57);
          uint64_t v58 = v104;
          long long v4 = a2;
        }
        if (v58 != (void *)v106) {
          free(v58);
        }
        unint64_t v9 = v95;
LABEL_5:
        long long v5 = v9 + 233;
        ++v6;
        unint64_t v8 = (_OWORD *)((char *)v8 + 1864);
        v7 += 233;
        __n128 result = v9;
        if (v9 + 233 == v4) {
          return result;
        }
      }
      uint64_t v61 = 0;
      unint64_t v62 = v109;
      uint64_t v63 = &v110;
      int8x16_t v64 = v108;
      while (1)
      {
        long long v65 = *v12;
        *((void *)v64 + 2) = *((void *)v12 + 2);
        *(_OWORD *)int8x16_t v64 = v65;
        uint64_t v66 = *((void *)v12 + 3);
        *((_DWORD *)v64 + 8) = *((_DWORD *)v12 + 8);
        *((void *)v64 + 3) = v66;
        *(void *)(v64 + 36) = *(void *)((char *)v12 + 36);
        long long v67 = *(long long *)((char *)v12 + 44);
        long long v68 = *(long long *)((char *)v12 + 60);
        long long v69 = *(long long *)((char *)v12 + 76);
        *(_OWORD *)(v64 + 92) = *(long long *)((char *)v12 + 92);
        *(_OWORD *)(v64 + 76) = v69;
        *(_OWORD *)(v64 + 60) = v68;
        *(_OWORD *)(v64 + 44) = v67;
        long long v70 = *(long long *)((char *)v12 + 108);
        long long v71 = *(long long *)((char *)v12 + 124);
        long long v72 = *(long long *)((char *)v12 + 140);
        *(_OWORD *)(v64 + 156) = *(long long *)((char *)v12 + 156);
        *(_OWORD *)(v64 + 140) = v72;
        *(_OWORD *)(v64 + 124) = v71;
        *(_OWORD *)(v64 + 108) = v70;
        long long v73 = *(long long *)((char *)v12 + 172);
        long long v74 = *(long long *)((char *)v12 + 188);
        long long v75 = *(long long *)((char *)v12 + 204);
        *(_OWORD *)(v64 + 220) = *(long long *)((char *)v12 + 220);
        *(_OWORD *)(v64 + 204) = v75;
        *(_OWORD *)(v64 + 188) = v74;
        *(_OWORD *)(v64 + 172) = v73;
        long long v76 = v64 + 280;
        *((void *)v64 + 31) = v64 + 280;
        long long v77 = (char *)*((void *)v12 + 31);
        *((_DWORD *)v64 + 59) = *((_DWORD *)v12 + 59);
        v64[240] = *((unsigned char *)v12 + 240);
        *((void *)v64 + 32) = v64 + 280;
        *((void *)v64 + 33) = v64 + 280;
        *((void *)v64 + 34) = *((void *)v12 + 34);
        if (v77 == *((char **)v12 + 33))
        {
          *((void *)v64 + 32) = &v76[*((void *)v12 + 32) - (void)v77];
          float v78 = (char *)*((void *)v12 + 32);
          if (v77 != v78)
          {
            unint64_t v79 = v78 - v77;
            if ((unint64_t)(v78 - v77) >= 8 && (unint64_t)(&v109[288 * v61] - v77) >= 0x20)
            {
              if (v79 < 0x20)
              {
                unint64_t v80 = 0;
                goto LABEL_64;
              }
              unint64_t v80 = v79 & 0xFFFFFFFFFFFFFFE0;
              unint64_t v81 = (long long *)(v77 + 16);
              unint64_t v82 = v63;
              unint64_t v83 = v79 & 0xFFFFFFFFFFFFFFE0;
              do
              {
                long long v84 = *v81;
                *((_OWORD *)v82 - 1) = *(v81 - 1);
                *(_OWORD *)unint64_t v82 = v84;
                v81 += 2;
                v82 += 4;
                v83 -= 32;
              }
              while (v83);
              if (v79 == v80) {
                goto LABEL_53;
              }
              if ((v79 & 0x18) != 0)
              {
LABEL_64:
                unint64_t v85 = v79 & 0xFFFFFFFFFFFFFFF8;
                v76 += v79 & 0xFFFFFFFFFFFFFFF8;
                unint64_t v86 = v80 - (v79 & 0xFFFFFFFFFFFFFFF8);
                unint64_t v87 = (uint64_t *)&v77[v80];
                unint64_t v88 = &v62[v80];
                do
                {
                  uint64_t v89 = *v87++;
                  *v88++ = v89;
                  v86 += 8;
                }
                while (v86);
                if (v79 == v85) {
                  goto LABEL_53;
                }
                v77 += v85;
              }
              else
              {
                v77 += v80;
                v76 += v80;
              }
            }
            do
            {
              char v90 = *v77++;
              *v76++ = v90;
            }
            while (v77 != v78);
          }
        }
        else
        {
          *((void *)v64 + 31) = v77;
          *((void *)v64 + 32) = *((void *)v12 + 32);
          *(long long *)((char *)v12 + 248) = 0u;
          *(long long *)((char *)v12 + 264) = 0u;
        }
LABEL_53:
        v64 += 288;
        v12 += 18;
        ++v61;
        v63 += 36;
        v62 += 288;
        if (v12 == v60) {
          goto LABEL_9;
        }
      }
    }
  }
  return result;
}

void std::__partial_sort[abi:nn180100]<std::_ClassicAlgPolicy,md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_0 &,md::mun::CollectionPoint *,md::mun::CollectionPoint *>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v145 = a2;
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v5 = (uint64_t)a2 - a1;
    uint64_t v6 = ((uint64_t)a2 - a1) / 1864;
    if ((uint64_t)a2 - a1 >= 1865)
    {
      unint64_t v7 = (unint64_t)(v6 - 2) >> 1;
      unint64_t v8 = v7 + 1;
      unint64_t v9 = (uint64_t *)(a1 + 1864 * v7);
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_0 &,md::mun::CollectionPoint *>(a1, v6, v9);
        v9 -= 233;
        --v8;
      }
      while (v8);
    }
    if (v145 != a3)
    {
      long long v10 = v145;
      do
      {
        if ((unint64_t)v10[10] < *(void *)(a1 + 80))
        {
          std::swap[abi:nn180100]<md::mun::CollectionPoint>(v10, (uint64_t *)a1);
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_0 &,md::mun::CollectionPoint *>(a1, v6, (uint64_t *)a1);
        }
        v10 += 233;
      }
      while (v10 != a3);
    }
    if (v5 >= 1865)
    {
      int64_t v11 = v5 / 0x748uLL;
      while (1)
      {
        uint64_t v146 = *(void *)a1;
        long long v147 = *(_OWORD *)(a1 + 8);
        uint64_t v148 = *(void *)(a1 + 24);
        *(void *)double v149 = *(void *)(a1 + 32);
        *(_DWORD *)&v149[8] = *(_DWORD *)(a1 + 40);
        *(void *)&v149[12] = *(void *)(a1 + 44);
        long long v13 = *(_OWORD *)(a1 + 72);
        long long v150 = *(_OWORD *)(a1 + 56);
        long long v151 = v13;
        double v152 = v156;
        uint64_t v15 = *(long long **)(a1 + 104);
        uint64_t v14 = *(void *)(a1 + 112);
        double v154 = v156;
        uint64_t v155 = v14;
        uint64_t v16 = *(long long **)(a1 + 88);
        if (v16 == v15) {
          break;
        }
        char v17 = *(unsigned char **)(a1 + 96);
        double v152 = *(unsigned char **)(a1 + 88);
        double v153 = v17;
        *(_OWORD *)(a1 + 88) = 0u;
        *(_OWORD *)(a1 + 104) = 0u;
LABEL_15:
        uint64_t v18 = 0;
        v159[0] = *(void *)(a1 + 1848);
        *(void *)((char *)v159 + 5) = *(void *)(a1 + 1853);
        uint64_t v19 = a1;
        do
        {
          uint64_t v22 = v19 + 1864 * v18 + 1864;
          uint64_t v23 = 2 * v18;
          uint64_t v18 = (2 * v18) | 1;
          uint64_t v24 = v23 + 2;
          if (v23 + 2 < v11)
          {
            unint64_t v25 = *(void *)(v22 + 80);
            unint64_t v26 = *(void *)(v22 + 1944);
            v22 += 1864 * (v25 < v26);
            if (v25 < v26) {
              uint64_t v18 = v24;
            }
          }
          *(void *)uint64_t v19 = *(void *)v22;
          *(_DWORD *)(v19 + 32) = *(_DWORD *)(v22 + 32);
          *(_DWORD *)(v19 + 36) = *(_DWORD *)(v22 + 36);
          *(_DWORD *)(v19 + 40) = *(_DWORD *)(v22 + 40);
          *(_DWORD *)(v19 + 44) = *(_DWORD *)(v22 + 44);
          *(void *)(v19 + 8) = *(void *)(v22 + 8);
          *(void *)(v19 + 16) = *(void *)(v22 + 16);
          *(void *)(v19 + 24) = *(void *)(v22 + 24);
          *(_DWORD *)(v19 + 48) = *(_DWORD *)(v22 + 48);
          *(void *)(v19 + 56) = *(void *)(v22 + 56);
          *(void *)(v19 + 64) = *(void *)(v22 + 64);
          *(void *)(v19 + 72) = *(void *)(v22 + 72);
          *(void *)(v19 + 80) = *(void *)(v22 + 80);
          if (v19 != v22)
          {
            uint64_t v27 = *(void **)(v19 + 88);
            long long v28 = *(void **)(v19 + 96);
            if (v27 != v28)
            {
              do
              {
                uint64_t v29 = (void *)v27[31];
                if (v29 != (void *)v27[33]) {
                  free(v29);
                }
                v27 += 36;
              }
              while (v27 != v28);
              uint64_t v27 = *(void **)(v19 + 88);
            }
            if (v27 != *(void **)(v19 + 104)) {
              free(v27);
            }
            uint64_t v30 = v19 + 120;
            *(void *)(v19 + 104) = v19 + 120;
            uint64_t v31 = *(void *)(v22 + 88);
            if (v31 == *(void *)(v22 + 104))
            {
              *(void *)(v19 + 88) = v30;
              long long v32 = *(long long **)(v22 + 88);
              *(void *)(v19 + 96) = v30 + *(void *)(v22 + 96) - (void)v32;
              long long v33 = *(long long **)(v22 + 96);
              if (v32 != v33)
              {
                uint64_t v34 = 0;
                long long v35 = (_OWORD *)(v19 + 416);
                uint64_t v36 = v19 + 400;
                do
                {
                  long long v37 = *v32;
                  *(void *)(v30 + 16) = *((void *)v32 + 2);
                  *(_OWORD *)uint64_t v30 = v37;
                  uint64_t v38 = *((void *)v32 + 3);
                  *(_DWORD *)(v30 + 32) = *((_DWORD *)v32 + 8);
                  *(void *)(v30 + 24) = v38;
                  *(void *)(v30 + 36) = *(void *)((char *)v32 + 36);
                  long long v39 = *(long long *)((char *)v32 + 44);
                  long long v40 = *(long long *)((char *)v32 + 60);
                  long long v41 = *(long long *)((char *)v32 + 76);
                  *(_OWORD *)(v30 + 92) = *(long long *)((char *)v32 + 92);
                  *(_OWORD *)(v30 + 76) = v41;
                  *(_OWORD *)(v30 + 60) = v40;
                  *(_OWORD *)(v30 + 44) = v39;
                  long long v42 = *(long long *)((char *)v32 + 108);
                  long long v43 = *(long long *)((char *)v32 + 124);
                  long long v44 = *(long long *)((char *)v32 + 140);
                  *(_OWORD *)(v30 + 156) = *(long long *)((char *)v32 + 156);
                  *(_OWORD *)(v30 + 140) = v44;
                  *(_OWORD *)(v30 + 124) = v43;
                  *(_OWORD *)(v30 + 108) = v42;
                  long long v45 = *(long long *)((char *)v32 + 172);
                  long long v46 = *(long long *)((char *)v32 + 188);
                  long long v47 = *(long long *)((char *)v32 + 204);
                  *(_OWORD *)(v30 + 220) = *(long long *)((char *)v32 + 220);
                  *(_OWORD *)(v30 + 204) = v47;
                  *(_OWORD *)(v30 + 188) = v46;
                  *(_OWORD *)(v30 + 172) = v45;
                  unint64_t v48 = (unsigned char *)(v30 + 280);
                  *(void *)(v30 + 248) = v30 + 280;
                  long long v49 = (char *)*((void *)v32 + 31);
                  *(_DWORD *)(v30 + 236) = *((_DWORD *)v32 + 59);
                  *(unsigned char *)(v30 + 240) = *((unsigned char *)v32 + 240);
                  *(void *)(v30 + 256) = v30 + 280;
                  *(void *)(v30 + 264) = v30 + 280;
                  *(void *)(v30 + 272) = *((void *)v32 + 34);
                  if (v49 == *((char **)v32 + 33))
                  {
                    *(void *)(v30 + 256) = &v48[*((void *)v32 + 32) - (void)v49];
                    unint64_t v50 = (char *)*((void *)v32 + 32);
                    if (v49 != v50)
                    {
                      unint64_t v51 = v50 - v49;
                      if ((unint64_t)(v50 - v49) >= 8
                        && (unint64_t)(v19 + 400 + 288 * v34 - (void)v49) >= 0x20)
                      {
                        if (v51 < 0x20)
                        {
                          unint64_t v52 = 0;
                          goto LABEL_46;
                        }
                        unint64_t v52 = v51 & 0xFFFFFFFFFFFFFFE0;
                        unint64_t v53 = (long long *)(v49 + 16);
                        uint64_t v54 = v35;
                        unint64_t v55 = v51 & 0xFFFFFFFFFFFFFFE0;
                        do
                        {
                          long long v56 = *v53;
                          *(v54 - 1) = *(v53 - 1);
                          _OWORD *v54 = v56;
                          v53 += 2;
                          v54 += 2;
                          v55 -= 32;
                        }
                        while (v55);
                        if (v51 == v52) {
                          goto LABEL_35;
                        }
                        if ((v51 & 0x18) != 0)
                        {
LABEL_46:
                          unint64_t v57 = v51 & 0xFFFFFFFFFFFFFFF8;
                          v48 += v51 & 0xFFFFFFFFFFFFFFF8;
                          unint64_t v58 = v52 - (v51 & 0xFFFFFFFFFFFFFFF8);
                          uint64_t v59 = (uint64_t *)&v49[v52];
                          unint64_t v60 = (void *)(v36 + v52);
                          do
                          {
                            uint64_t v61 = *v59++;
                            *v60++ = v61;
                            v58 += 8;
                          }
                          while (v58);
                          if (v51 == v57) {
                            goto LABEL_35;
                          }
                          v49 += v57;
                        }
                        else
                        {
                          v49 += v52;
                          v48 += v52;
                        }
                      }
                      do
                      {
                        char v62 = *v49++;
                        *v48++ = v62;
                      }
                      while (v49 != v50);
                    }
                  }
                  else
                  {
                    *(void *)(v30 + 248) = v49;
                    *(void *)(v30 + 256) = *((void *)v32 + 32);
                    *(long long *)((char *)v32 + 248) = 0u;
                    *(long long *)((char *)v32 + 264) = 0u;
                  }
LABEL_35:
                  v30 += 288;
                  v32 += 18;
                  ++v34;
                  v35 += 18;
                  v36 += 288;
                }
                while (v32 != v33);
              }
            }
            else
            {
              *(void *)(v19 + 88) = v31;
              *(void *)(v19 + 96) = *(void *)(v22 + 96);
              *(_OWORD *)(v22 + 88) = 0u;
              *(_OWORD *)(v22 + 104) = 0u;
            }
            *(void *)(v19 + 112) = *(void *)(v22 + 112);
          }
          long long v20 = (uint64_t *)(v22 + 1848);
          uint64_t v21 = *(void *)(v22 + 1848);
          *(void *)(v19 + 1853) = *(void *)(v22 + 1853);
          *(void *)(v19 + 1848) = v21;
          uint64_t v19 = v22;
        }
        while (v18 <= (uint64_t)((unint64_t)(v11 - 2) >> 1));
        uint64_t v63 = v145 - 233;
        if ((uint64_t *)v22 == v145 - 233)
        {
          *(void *)uint64_t v22 = v146;
          *(_OWORD *)(v22 + 32) = *(_OWORD *)v149;
          *(_OWORD *)(v22 + 8) = v147;
          *(void *)(v22 + 24) = v148;
          *(_DWORD *)(v22 + 48) = *(_DWORD *)&v149[16];
          *(_OWORD *)(v22 + 56) = v150;
          *(_OWORD *)(v22 + 72) = v151;
          if ((uint64_t *)v22 != &v146) {
            geo::small_vector_base<md::mun::PhotoInfo>::move(v22 + 88, (uint64_t *)&v152, v22 + 120);
          }
          uint64_t v110 = v159[0];
          *(void *)(v22 + 1853) = *(void *)((char *)v159 + 5);
          uint64_t *v20 = v110;
          goto LABEL_99;
        }
        *(void *)uint64_t v22 = *v63;
        *(_DWORD *)(v22 + 32) = *((_DWORD *)v145 - 458);
        *(_DWORD *)(v22 + 36) = *((_DWORD *)v145 - 457);
        *(_DWORD *)(v22 + 40) = *((_DWORD *)v145 - 456);
        *(_DWORD *)(v22 + 44) = *((_DWORD *)v145 - 455);
        *(void *)(v22 + 8) = *(v145 - 232);
        *(void *)(v22 + 16) = *(v145 - 231);
        *(void *)(v22 + 24) = *(v145 - 230);
        *(_DWORD *)(v22 + 48) = *((_DWORD *)v145 - 454);
        *(void *)(v22 + 56) = *(v145 - 226);
        *(void *)(v22 + 64) = *(v145 - 225);
        *(void *)(v22 + 72) = *(v145 - 224);
        *(void *)(v22 + 80) = *(v145 - 223);
        geo::small_vector_base<md::mun::PhotoInfo>::move(v22 + 88, v145 - 222, v22 + 120);
        uint64_t v64 = *(v145 - 2);
        *(void *)(v22 + 1853) = *(uint64_t *)((char *)v145 - 11);
        uint64_t *v20 = v64;
        *uint64_t v63 = v146;
        *(_OWORD *)(v145 - 229) = *(_OWORD *)v149;
        *((_OWORD *)v145 - 116) = v147;
        *(v145 - 230) = v148;
        *((_DWORD *)v145 - 454) = *(_DWORD *)&v149[16];
        *((_OWORD *)v145 - 113) = v150;
        *((_OWORD *)v145 - 112) = v151;
        if (v63 != &v146) {
          geo::small_vector_base<md::mun::PhotoInfo>::move((uint64_t)(v145 - 222), (uint64_t *)&v152, (uint64_t)(v145 - 218));
        }
        *(v145 - 2) = v159[0];
        *(uint64_t *)((char *)v145 - 11) = *(void *)((char *)v159 + 5);
        uint64_t v65 = v22 - a1 + 1864;
        if (v65 >= 1865)
        {
          unint64_t v66 = (v65 / 0x748uLL - 2) >> 1;
          unint64_t v67 = a1 + 1864 * v66;
          if (*(void *)(v67 + 80) < *(void *)(v22 + 80))
          {
            uint64_t v160 = *(void *)v22;
            long long v68 = *(_OWORD *)(v22 + 8);
            uint64_t v162 = *(void *)(v22 + 24);
            long long v161 = v68;
            uint64_t v69 = *(void *)(v22 + 32);
            *(_DWORD *)&v163[8] = *(_DWORD *)(v22 + 40);
            *(void *)unint64_t v163 = v69;
            *(void *)&v163[12] = *(void *)(v22 + 44);
            long long v70 = *(_OWORD *)(v22 + 72);
            long long v164 = *(_OWORD *)(v22 + 56);
            long long v165 = v70;
            double v166 = v170;
            double v168 = v170;
            uint64_t v169 = *(void *)(v22 + 112);
            long long v71 = *(long long **)(v22 + 88);
            if (v71 != *(long long **)(v22 + 104))
            {
              double v166 = *(void **)(v22 + 88);
              double v167 = *(unsigned char **)(v22 + 96);
              *(_OWORD *)(v22 + 88) = 0u;
              *(_OWORD *)(v22 + 104) = 0u;
              goto LABEL_60;
            }
            double v114 = *(long long **)(v22 + 96);
            double v167 = &v170[(char *)v114 - (char *)v71];
            if (v114 == v71)
            {
LABEL_60:
              uint64_t v72 = *v20;
              *(void *)((char *)v173 + 5) = *(void *)(v22 + 1853);
              v173[0] = v72;
              do
              {
                uint64_t v73 = v67;
                *(void *)uint64_t v22 = *(void *)v67;
                *(_DWORD *)(v22 + 32) = *(_DWORD *)(v67 + 32);
                *(_DWORD *)(v22 + 36) = *(_DWORD *)(v67 + 36);
                *(_DWORD *)(v22 + 40) = *(_DWORD *)(v67 + 40);
                *(_DWORD *)(v22 + 44) = *(_DWORD *)(v67 + 44);
                *(void *)(v22 + 8) = *(void *)(v67 + 8);
                *(void *)(v22 + 16) = *(void *)(v67 + 16);
                *(void *)(v22 + 24) = *(void *)(v67 + 24);
                *(_DWORD *)(v22 + 48) = *(_DWORD *)(v67 + 48);
                *(void *)(v22 + 56) = *(void *)(v67 + 56);
                *(void *)(v22 + 64) = *(void *)(v67 + 64);
                *(void *)(v22 + 72) = *(void *)(v67 + 72);
                *(void *)(v22 + 80) = *(void *)(v67 + 80);
                if (v22 != v67) {
                  geo::small_vector_base<md::mun::PhotoInfo>::move(v22 + 88, (uint64_t *)(v67 + 88), v22 + 120);
                }
                uint64_t v74 = *(void *)(v73 + 1848);
                *(void *)(v22 + 1853) = *(void *)(v73 + 1853);
                *(void *)(v22 + 1848) = v74;
                uint64_t v75 = *((void *)&v165 + 1);
                if (!v66) {
                  break;
                }
                unint64_t v66 = (v66 - 1) >> 1;
                unint64_t v67 = a1 + 1864 * v66;
                uint64_t v22 = v73;
              }
              while (*(void *)(v67 + 80) < *((void *)&v165 + 1));
              *(void *)uint64_t v73 = v160;
              *(_OWORD *)(v73 + 32) = *(_OWORD *)v163;
              *(_OWORD *)(v73 + 8) = v161;
              *(void *)(v73 + 24) = v162;
              *(_DWORD *)(v73 + 48) = *(_DWORD *)&v163[16];
              *(_OWORD *)(v73 + 56) = v164;
              *(void *)(v73 + 72) = v165;
              *(void *)(v73 + 80) = v75;
              if ((uint64_t *)v73 != &v160) {
                geo::small_vector_base<md::mun::PhotoInfo>::move(v73 + 88, (uint64_t *)&v166, v73 + 120);
              }
              *(void *)(v73 + 1848) = v173[0];
              *(void *)(v73 + 1853) = *(void *)((char *)v173 + 5);
              long long v76 = v166;
              long long v77 = v167;
              if (v166 != v167)
              {
                do
                {
                  float v78 = (void *)v76[31];
                  if (v78 != (void *)v76[33]) {
                    free(v78);
                  }
                  v76 += 36;
                }
                while (v76 != v77);
                long long v76 = v166;
              }
              if (v76 != (void *)v168) {
                free(v76);
              }
              goto LABEL_99;
            }
            uint64_t v115 = 0;
            uint64_t v116 = v171;
            unint64_t v117 = &v172;
            unint64_t v118 = v170;
            while (2)
            {
              long long v119 = *v71;
              *((void *)v118 + 2) = *((void *)v71 + 2);
              *(_OWORD *)unint64_t v118 = v119;
              uint64_t v120 = *((void *)v71 + 3);
              *((_DWORD *)v118 + 8) = *((_DWORD *)v71 + 8);
              *((void *)v118 + 3) = v120;
              *(void *)(v118 + 36) = *(void *)((char *)v71 + 36);
              long long v121 = *(long long *)((char *)v71 + 44);
              long long v122 = *(long long *)((char *)v71 + 60);
              long long v123 = *(long long *)((char *)v71 + 76);
              *(_OWORD *)(v118 + 92) = *(long long *)((char *)v71 + 92);
              *(_OWORD *)(v118 + 76) = v123;
              *(_OWORD *)(v118 + 60) = v122;
              *(_OWORD *)(v118 + 44) = v121;
              long long v124 = *(long long *)((char *)v71 + 108);
              long long v125 = *(long long *)((char *)v71 + 124);
              long long v126 = *(long long *)((char *)v71 + 140);
              *(_OWORD *)(v118 + 156) = *(long long *)((char *)v71 + 156);
              *(_OWORD *)(v118 + 140) = v126;
              *(_OWORD *)(v118 + 124) = v125;
              *(_OWORD *)(v118 + 108) = v124;
              long long v127 = *(long long *)((char *)v71 + 172);
              long long v128 = *(long long *)((char *)v71 + 188);
              long long v129 = *(long long *)((char *)v71 + 204);
              *(_OWORD *)(v118 + 220) = *(long long *)((char *)v71 + 220);
              *(_OWORD *)(v118 + 204) = v129;
              *(_OWORD *)(v118 + 188) = v128;
              *(_OWORD *)(v118 + 172) = v127;
              double v130 = v118 + 280;
              *((void *)v118 + 31) = v118 + 280;
              double v131 = (char *)*((void *)v71 + 31);
              *((_DWORD *)v118 + 59) = *((_DWORD *)v71 + 59);
              v118[240] = *((unsigned char *)v71 + 240);
              *((void *)v118 + 32) = v118 + 280;
              *((void *)v118 + 33) = v118 + 280;
              *((void *)v118 + 34) = *((void *)v71 + 34);
              if (v131 != *((char **)v71 + 33))
              {
                *((void *)v118 + 31) = v131;
                *((void *)v118 + 32) = *((void *)v71 + 32);
                *(long long *)((char *)v71 + 248) = 0u;
                *(long long *)((char *)v71 + 264) = 0u;
                goto LABEL_110;
              }
              *((void *)v118 + 32) = &v130[*((void *)v71 + 32) - (void)v131];
              double v132 = (char *)*((void *)v71 + 32);
              if (v131 != v132)
              {
                unint64_t v133 = v132 - v131;
                if ((unint64_t)(v132 - v131) >= 8 && (unint64_t)(&v171[288 * v115] - v131) >= 0x20)
                {
                  if (v133 < 0x20)
                  {
                    uint64_t v134 = 0;
LABEL_121:
                    unint64_t v139 = v133 & 0xFFFFFFFFFFFFFFF8;
                    v130 += v133 & 0xFFFFFFFFFFFFFFF8;
                    uint64_t v140 = v134 - (v133 & 0xFFFFFFFFFFFFFFF8);
                    unint64_t v141 = (uint64_t *)&v131[v134];
                    unint64_t v142 = &v116[v134];
                    do
                    {
                      uint64_t v143 = *v141++;
                      *v142++ = v143;
                      v140 += 8;
                    }
                    while (v140);
                    if (v133 != v139)
                    {
                      v131 += v139;
                      goto LABEL_126;
                    }
                    goto LABEL_110;
                  }
                  uint64_t v134 = v133 & 0xFFFFFFFFFFFFFFE0;
                  unint64_t v135 = (long long *)(v131 + 16);
                  unint64_t v136 = v117;
                  unint64_t v137 = v133 & 0xFFFFFFFFFFFFFFE0;
                  do
                  {
                    long long v138 = *v135;
                    *((_OWORD *)v136 - 1) = *(v135 - 1);
                    *(_OWORD *)unint64_t v136 = v138;
                    v135 += 2;
                    v136 += 4;
                    v137 -= 32;
                  }
                  while (v137);
                  if (v133 == v134) {
                    goto LABEL_110;
                  }
                  if ((v133 & 0x18) != 0) {
                    goto LABEL_121;
                  }
                  v131 += v134;
                  v130 += v134;
                }
                do
                {
LABEL_126:
                  char v144 = *v131++;
                  *v130++ = v144;
                }
                while (v131 != v132);
              }
LABEL_110:
              v118 += 288;
              v71 += 18;
              ++v115;
              v117 += 36;
              v116 += 288;
              if (v71 == v114) {
                goto LABEL_60;
              }
              continue;
            }
          }
        }
LABEL_99:
        int8x8_t v111 = v152;
        uint64_t v112 = v153;
        if (v152 != v153)
        {
          do
          {
            unint64_t v113 = (void *)v111[31];
            if (v113 != (void *)v111[33]) {
              free(v113);
            }
            v111 += 36;
          }
          while (v111 != v112);
          int8x8_t v111 = v152;
        }
        if (v111 != (void *)v154) {
          free(v111);
        }
        v145 -= 233;
        if (v11-- <= 2) {
          return;
        }
      }
      unint64_t v79 = *(long long **)(a1 + 96);
      double v153 = &v156[(char *)v79 - (char *)v16];
      if (v79 == v16) {
        goto LABEL_15;
      }
      uint64_t v80 = 0;
      unint64_t v81 = v157;
      unint64_t v82 = &v158;
      unint64_t v83 = v156;
      while (1)
      {
        long long v84 = *v16;
        *((void *)v83 + 2) = *((void *)v16 + 2);
        *(_OWORD *)unint64_t v83 = v84;
        uint64_t v85 = *((void *)v16 + 3);
        *((_DWORD *)v83 + 8) = *((_DWORD *)v16 + 8);
        *((void *)v83 + 3) = v85;
        *(void *)(v83 + 36) = *(void *)((char *)v16 + 36);
        long long v86 = *(long long *)((char *)v16 + 44);
        long long v87 = *(long long *)((char *)v16 + 60);
        long long v88 = *(long long *)((char *)v16 + 76);
        *(_OWORD *)(v83 + 92) = *(long long *)((char *)v16 + 92);
        *(_OWORD *)(v83 + 76) = v88;
        *(_OWORD *)(v83 + 60) = v87;
        *(_OWORD *)(v83 + 44) = v86;
        long long v89 = *(long long *)((char *)v16 + 108);
        long long v90 = *(long long *)((char *)v16 + 124);
        long long v91 = *(long long *)((char *)v16 + 140);
        *(_OWORD *)(v83 + 156) = *(long long *)((char *)v16 + 156);
        *(_OWORD *)(v83 + 140) = v91;
        *(_OWORD *)(v83 + 124) = v90;
        *(_OWORD *)(v83 + 108) = v89;
        long long v92 = *(long long *)((char *)v16 + 172);
        long long v93 = *(long long *)((char *)v16 + 188);
        long long v94 = *(long long *)((char *)v16 + 204);
        *(_OWORD *)(v83 + 220) = *(long long *)((char *)v16 + 220);
        *(_OWORD *)(v83 + 204) = v94;
        *(_OWORD *)(v83 + 188) = v93;
        *(_OWORD *)(v83 + 172) = v92;
        uint64_t v95 = v83 + 280;
        *((void *)v83 + 31) = v83 + 280;
        uint64_t v96 = (char *)*((void *)v16 + 31);
        *((_DWORD *)v83 + 59) = *((_DWORD *)v16 + 59);
        v83[240] = *((unsigned char *)v16 + 240);
        *((void *)v83 + 32) = v83 + 280;
        *((void *)v83 + 33) = v83 + 280;
        *((void *)v83 + 34) = *((void *)v16 + 34);
        if (v96 == *((char **)v16 + 33))
        {
          *((void *)v83 + 32) = &v95[*((void *)v16 + 32) - (void)v96];
          long long v97 = (char *)*((void *)v16 + 32);
          if (v96 != v97)
          {
            unint64_t v98 = v97 - v96;
            if ((unint64_t)(v97 - v96) >= 8 && (unint64_t)(&v157[288 * v80] - v96) >= 0x20)
            {
              if (v98 < 0x20)
              {
                unint64_t v99 = 0;
                goto LABEL_86;
              }
              unint64_t v99 = v98 & 0xFFFFFFFFFFFFFFE0;
              int v100 = (long long *)(v96 + 16);
              uint64_t v101 = v82;
              unint64_t v102 = v98 & 0xFFFFFFFFFFFFFFE0;
              do
              {
                long long v103 = *v100;
                *((_OWORD *)v101 - 1) = *(v100 - 1);
                *(_OWORD *)uint64_t v101 = v103;
                v100 += 2;
                v101 += 4;
                v102 -= 32;
              }
              while (v102);
              if (v98 == v99) {
                goto LABEL_75;
              }
              if ((v98 & 0x18) != 0)
              {
LABEL_86:
                unint64_t v104 = v98 & 0xFFFFFFFFFFFFFFF8;
                v95 += v98 & 0xFFFFFFFFFFFFFFF8;
                unint64_t v105 = v99 - (v98 & 0xFFFFFFFFFFFFFFF8);
                double v106 = (uint64_t *)&v96[v99];
                uint64_t v107 = &v81[v99];
                do
                {
                  uint64_t v108 = *v106++;
                  *v107++ = v108;
                  v105 += 8;
                }
                while (v105);
                if (v98 == v104) {
                  goto LABEL_75;
                }
                v96 += v104;
              }
              else
              {
                v96 += v99;
                v95 += v99;
              }
            }
            do
            {
              char v109 = *v96++;
              *v95++ = v109;
            }
            while (v96 != v97);
          }
        }
        else
        {
          *((void *)v83 + 31) = v96;
          *((void *)v83 + 32) = *((void *)v16 + 32);
          *(long long *)((char *)v16 + 248) = 0u;
          *(long long *)((char *)v16 + 264) = 0u;
        }
LABEL_75:
        v83 += 288;
        v16 += 18;
        ++v80;
        v82 += 36;
        v81 += 288;
        if (v16 == v79) {
          goto LABEL_15;
        }
      }
    }
  }
}

uint64_t *std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,md::mun::CollectionPoint *,md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_0 &>(uint64_t a1, uint64_t *a2)
{
  uint64_t v57 = *(void *)a1;
  long long v58 = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v59 = *(void *)(a1 + 24);
  uint64_t v60 = v3;
  int v61 = *(_DWORD *)(a1 + 40);
  uint64_t v62 = *(void *)(a1 + 44);
  long long v4 = *(_OWORD *)(a1 + 72);
  long long v63 = *(_OWORD *)(a1 + 56);
  long long v64 = v4;
  uint64_t v5 = v69;
  uint64_t v65 = v69;
  uint64_t v6 = *(void *)(a1 + 112);
  unint64_t v8 = (_OWORD *)(a1 + 88);
  uint64_t v7 = *(void *)(a1 + 88);
  unint64_t v67 = v69;
  uint64_t v68 = v6;
  if (v7 != *(void *)(a1 + 104))
  {
    unint64_t v9 = *(unsigned char **)(a1 + 96);
    uint64_t v65 = (unsigned char *)v7;
    unint64_t v66 = v9;
    *unint64_t v8 = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    goto LABEL_3;
  }
  uint64_t v27 = *(void *)(a1 + 96);
  unint64_t v66 = &v69[v27 - v7];
  if (v27 != v7)
  {
    uint64_t v28 = 0;
    uint64_t v29 = &v71;
    uint64_t v30 = v70;
    do
    {
      long long v31 = *(_OWORD *)v7;
      *((void *)v5 + 2) = *(void *)(v7 + 16);
      *(_OWORD *)uint64_t v5 = v31;
      uint64_t v32 = *(void *)(v7 + 24);
      *((_DWORD *)v5 + 8) = *(_DWORD *)(v7 + 32);
      *((void *)v5 + 3) = v32;
      *(void *)(v5 + 36) = *(void *)(v7 + 36);
      long long v33 = *(_OWORD *)(v7 + 44);
      long long v34 = *(_OWORD *)(v7 + 60);
      long long v35 = *(_OWORD *)(v7 + 76);
      *(_OWORD *)(v5 + 92) = *(_OWORD *)(v7 + 92);
      *(_OWORD *)(v5 + 76) = v35;
      *(_OWORD *)(v5 + 60) = v34;
      *(_OWORD *)(v5 + 44) = v33;
      long long v36 = *(_OWORD *)(v7 + 108);
      long long v37 = *(_OWORD *)(v7 + 124);
      long long v38 = *(_OWORD *)(v7 + 140);
      *(_OWORD *)(v5 + 156) = *(_OWORD *)(v7 + 156);
      *(_OWORD *)(v5 + 140) = v38;
      *(_OWORD *)(v5 + 124) = v37;
      *(_OWORD *)(v5 + 108) = v36;
      long long v39 = *(_OWORD *)(v7 + 172);
      long long v40 = *(_OWORD *)(v7 + 188);
      long long v41 = *(_OWORD *)(v7 + 204);
      *(_OWORD *)(v5 + 220) = *(_OWORD *)(v7 + 220);
      *(_OWORD *)(v5 + 204) = v41;
      *(_OWORD *)(v5 + 188) = v40;
      *(_OWORD *)(v5 + 172) = v39;
      long long v42 = v5 + 280;
      *((void *)v5 + 31) = v5 + 280;
      long long v43 = *(char **)(v7 + 248);
      *((_DWORD *)v5 + 59) = *(_DWORD *)(v7 + 236);
      v5[240] = *(unsigned char *)(v7 + 240);
      *((void *)v5 + 32) = v5 + 280;
      *((void *)v5 + 33) = v5 + 280;
      *((void *)v5 + 34) = *(void *)(v7 + 272);
      if (v43 == *(char **)(v7 + 264))
      {
        *((void *)v5 + 32) = &v42[*(void *)(v7 + 256) - (void)v43];
        long long v44 = *(char **)(v7 + 256);
        if (v43 != v44)
        {
          unint64_t v45 = v44 - v43;
          if ((unint64_t)(v44 - v43) >= 8 && (unint64_t)(&v70[288 * v28] - v43) >= 0x20)
          {
            if (v45 < 0x20)
            {
              unint64_t v46 = 0;
              goto LABEL_45;
            }
            unint64_t v46 = v45 & 0xFFFFFFFFFFFFFFE0;
            long long v47 = (long long *)(v43 + 16);
            unint64_t v48 = v29;
            unint64_t v49 = v45 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v50 = *v47;
              *((_OWORD *)v48 - 1) = *(v47 - 1);
              *(_OWORD *)unint64_t v48 = v50;
              v47 += 2;
              v48 += 4;
              v49 -= 32;
            }
            while (v49);
            if (v45 == v46) {
              goto LABEL_34;
            }
            if ((v45 & 0x18) != 0)
            {
LABEL_45:
              unint64_t v51 = v45 & 0xFFFFFFFFFFFFFFF8;
              v42 += v45 & 0xFFFFFFFFFFFFFFF8;
              unint64_t v52 = v46 - (v45 & 0xFFFFFFFFFFFFFFF8);
              unint64_t v53 = (uint64_t *)&v43[v46];
              uint64_t v54 = &v30[v46];
              do
              {
                uint64_t v55 = *v53++;
                *v54++ = v55;
                v52 += 8;
              }
              while (v52);
              if (v45 == v51) {
                goto LABEL_34;
              }
              v43 += v51;
            }
            else
            {
              v43 += v46;
              v42 += v46;
            }
          }
          do
          {
            char v56 = *v43++;
            *v42++ = v56;
          }
          while (v43 != v44);
        }
      }
      else
      {
        *((void *)v5 + 31) = v43;
        *((void *)v5 + 32) = *(void *)(v7 + 256);
        *(_OWORD *)(v7 + 248) = 0uLL;
        *(_OWORD *)(v7 + 264) = 0uLL;
      }
LABEL_34:
      v5 += 288;
      v7 += 288;
      ++v28;
      v29 += 36;
      v30 += 288;
    }
    while (v7 != v27);
  }
LABEL_3:
  *(void *)((char *)v72 + 5) = *(void *)(a1 + 1853);
  v72[0] = *(void *)(a1 + 1848);
  uint64_t v10 = *((void *)&v64 + 1);
  if (*((void *)&v64 + 1) >= (unint64_t)*(a2 - 223))
  {
    uint64_t v14 = (uint64_t *)(a1 + 1864);
    do
    {
      long long v12 = v14;
      if (v14 >= a2) {
        break;
      }
      unint64_t v15 = v14[10];
      v14 += 233;
    }
    while (*((void *)&v64 + 1) >= v15);
  }
  else
  {
    uint64_t v11 = a1;
    do
    {
      long long v12 = (uint64_t *)(v11 + 1864);
      unint64_t v13 = *(void *)(v11 + 1944);
      v11 += 1864;
    }
    while (*((void *)&v64 + 1) >= v13);
  }
  if (v12 >= a2)
  {
    uint64_t v16 = a2;
  }
  else
  {
    do
    {
      uint64_t v16 = a2 - 233;
      unint64_t v17 = *(a2 - 223);
      a2 -= 233;
    }
    while (*((void *)&v64 + 1) < v17);
  }
  while (v12 < v16)
  {
    std::swap[abi:nn180100]<md::mun::CollectionPoint>(v12, v16);
    uint64_t v10 = *((void *)&v64 + 1);
    do
    {
      unint64_t v18 = v12[243];
      v12 += 233;
    }
    while (*((void *)&v64 + 1) >= v18);
    do
    {
      uint64_t v19 = v16 - 223;
      v16 -= 233;
    }
    while (*((void *)&v64 + 1) < (unint64_t)*v19);
  }
  long long v20 = v12 - 233;
  if (v12 - 233 != (uint64_t *)a1)
  {
    *(void *)a1 = *v20;
    *(_DWORD *)(a1 + 32) = *((_DWORD *)v12 - 458);
    *(_DWORD *)(a1 + 36) = *((_DWORD *)v12 - 457);
    *(_DWORD *)(a1 + 40) = *((_DWORD *)v12 - 456);
    *(_DWORD *)(a1 + 44) = *((_DWORD *)v12 - 455);
    *(void *)(a1 + 8) = *(v12 - 232);
    *(void *)(a1 + 16) = *(v12 - 231);
    *(void *)(a1 + 24) = *(v12 - 230);
    *(_DWORD *)(a1 + 48) = *((_DWORD *)v12 - 454);
    *(void *)(a1 + 56) = *(v12 - 226);
    *(void *)(a1 + 64) = *(v12 - 225);
    *(void *)(a1 + 72) = *(v12 - 224);
    *(void *)(a1 + 80) = *(v12 - 223);
    geo::small_vector_base<md::mun::PhotoInfo>::move((uint64_t)v8, v12 - 222, a1 + 120);
    uint64_t v21 = *(v12 - 2);
    *(void *)(a1 + 1853) = *(uint64_t *)((char *)v12 - 11);
    *(void *)(a1 + 1848) = v21;
    uint64_t v10 = *((void *)&v64 + 1);
  }
  uint64_t *v20 = v57;
  *(v12 - 229) = v60;
  *((_DWORD *)v12 - 456) = v61;
  *((_DWORD *)v12 - 455) = v62;
  *((_OWORD *)v12 - 116) = v58;
  *(v12 - 230) = v59;
  *((_DWORD *)v12 - 454) = HIDWORD(v62);
  *((_OWORD *)v12 - 113) = v63;
  *(v12 - 224) = v64;
  *(v12 - 223) = v10;
  if (v20 != &v57) {
    geo::small_vector_base<md::mun::PhotoInfo>::move((uint64_t)(v12 - 222), (uint64_t *)&v65, (uint64_t)(v12 - 218));
  }
  uint64_t v22 = v72[0];
  *(uint64_t *)((char *)v12 - 11) = *(void *)((char *)v72 + 5);
  *(v12 - 2) = v22;
  uint64_t v23 = v65;
  uint64_t v24 = v66;
  if (v65 != v66)
  {
    do
    {
      unint64_t v25 = (void *)v23[31];
      if (v25 != (void *)v23[33]) {
        free(v25);
      }
      v23 += 36;
    }
    while (v23 != v24);
    uint64_t v23 = v65;
  }
  if (v23 != (void *)v67) {
    free(v23);
  }
  return v12;
}

uint64_t *std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,md::mun::CollectionPoint *,md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_0 &>(uint64_t a1, uint64_t *a2)
{
  uint64_t v57 = *(void *)a1;
  long long v58 = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v59 = *(void *)(a1 + 24);
  uint64_t v60 = v3;
  int v61 = *(_DWORD *)(a1 + 40);
  uint64_t v62 = *(void *)(a1 + 44);
  long long v4 = *(_OWORD *)(a1 + 72);
  long long v63 = *(_OWORD *)(a1 + 56);
  long long v64 = v4;
  uint64_t v5 = v69;
  uint64_t v65 = v69;
  uint64_t v6 = *(void *)(a1 + 112);
  unint64_t v8 = (_OWORD *)(a1 + 88);
  uint64_t v7 = *(void *)(a1 + 88);
  unint64_t v67 = v69;
  uint64_t v68 = v6;
  if (v7 == *(void *)(a1 + 104))
  {
    uint64_t v27 = *(void *)(a1 + 96);
    unint64_t v66 = &v69[v27 - v7];
    if (v27 == v7) {
      goto LABEL_3;
    }
    uint64_t v28 = 0;
    uint64_t v29 = &v71;
    uint64_t v30 = v70;
    while (1)
    {
      long long v31 = *(_OWORD *)v7;
      *((void *)v5 + 2) = *(void *)(v7 + 16);
      *(_OWORD *)uint64_t v5 = v31;
      uint64_t v32 = *(void *)(v7 + 24);
      *((_DWORD *)v5 + 8) = *(_DWORD *)(v7 + 32);
      *((void *)v5 + 3) = v32;
      *(void *)(v5 + 36) = *(void *)(v7 + 36);
      long long v33 = *(_OWORD *)(v7 + 44);
      long long v34 = *(_OWORD *)(v7 + 60);
      long long v35 = *(_OWORD *)(v7 + 76);
      *(_OWORD *)(v5 + 92) = *(_OWORD *)(v7 + 92);
      *(_OWORD *)(v5 + 76) = v35;
      *(_OWORD *)(v5 + 60) = v34;
      *(_OWORD *)(v5 + 44) = v33;
      long long v36 = *(_OWORD *)(v7 + 108);
      long long v37 = *(_OWORD *)(v7 + 124);
      long long v38 = *(_OWORD *)(v7 + 140);
      *(_OWORD *)(v5 + 156) = *(_OWORD *)(v7 + 156);
      *(_OWORD *)(v5 + 140) = v38;
      *(_OWORD *)(v5 + 124) = v37;
      *(_OWORD *)(v5 + 108) = v36;
      long long v39 = *(_OWORD *)(v7 + 172);
      long long v40 = *(_OWORD *)(v7 + 188);
      long long v41 = *(_OWORD *)(v7 + 204);
      *(_OWORD *)(v5 + 220) = *(_OWORD *)(v7 + 220);
      *(_OWORD *)(v5 + 204) = v41;
      *(_OWORD *)(v5 + 188) = v40;
      *(_OWORD *)(v5 + 172) = v39;
      long long v42 = v5 + 280;
      *((void *)v5 + 31) = v5 + 280;
      long long v43 = *(char **)(v7 + 248);
      *((_DWORD *)v5 + 59) = *(_DWORD *)(v7 + 236);
      v5[240] = *(unsigned char *)(v7 + 240);
      *((void *)v5 + 32) = v5 + 280;
      *((void *)v5 + 33) = v5 + 280;
      *((void *)v5 + 34) = *(void *)(v7 + 272);
      if (v43 == *(char **)(v7 + 264))
      {
        *((void *)v5 + 32) = &v42[*(void *)(v7 + 256) - (void)v43];
        long long v44 = *(char **)(v7 + 256);
        if (v43 != v44)
        {
          unint64_t v45 = v44 - v43;
          if ((unint64_t)(v44 - v43) >= 8 && (unint64_t)(&v70[288 * v28] - v43) >= 0x20)
          {
            if (v45 < 0x20)
            {
              unint64_t v46 = 0;
              goto LABEL_44;
            }
            unint64_t v46 = v45 & 0xFFFFFFFFFFFFFFE0;
            long long v47 = (long long *)(v43 + 16);
            unint64_t v48 = v29;
            unint64_t v49 = v45 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v50 = *v47;
              *((_OWORD *)v48 - 1) = *(v47 - 1);
              *(_OWORD *)unint64_t v48 = v50;
              v47 += 2;
              v48 += 4;
              v49 -= 32;
            }
            while (v49);
            if (v45 == v46) {
              goto LABEL_33;
            }
            if ((v45 & 0x18) != 0)
            {
LABEL_44:
              unint64_t v51 = v45 & 0xFFFFFFFFFFFFFFF8;
              v42 += v45 & 0xFFFFFFFFFFFFFFF8;
              unint64_t v52 = v46 - (v45 & 0xFFFFFFFFFFFFFFF8);
              unint64_t v53 = (uint64_t *)&v43[v46];
              uint64_t v54 = &v30[v46];
              do
              {
                uint64_t v55 = *v53++;
                *v54++ = v55;
                v52 += 8;
              }
              while (v52);
              if (v45 == v51) {
                goto LABEL_33;
              }
              v43 += v51;
            }
            else
            {
              v43 += v46;
              v42 += v46;
            }
          }
          do
          {
            char v56 = *v43++;
            *v42++ = v56;
          }
          while (v43 != v44);
        }
      }
      else
      {
        *((void *)v5 + 31) = v43;
        *((void *)v5 + 32) = *(void *)(v7 + 256);
        *(_OWORD *)(v7 + 248) = 0uLL;
        *(_OWORD *)(v7 + 264) = 0uLL;
      }
LABEL_33:
      v5 += 288;
      v7 += 288;
      ++v28;
      v29 += 36;
      v30 += 288;
      if (v7 == v27) {
        goto LABEL_3;
      }
    }
  }
  unint64_t v9 = *(unsigned char **)(a1 + 96);
  uint64_t v65 = (unsigned char *)v7;
  unint64_t v66 = v9;
  *unint64_t v8 = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
LABEL_3:
  *(void *)((char *)v72 + 5) = *(void *)(a1 + 1853);
  v72[0] = *(void *)(a1 + 1848);
  uint64_t v10 = *((void *)&v64 + 1);
  uint64_t v11 = (uint64_t *)a1;
  do
  {
    long long v12 = v11;
    v11 += 233;
  }
  while ((unint64_t)v12[243] < *((void *)&v64 + 1));
  if (v12 == (uint64_t *)a1)
  {
    while (v11 < a2)
    {
      unint64_t v13 = a2 - 233;
      unint64_t v15 = *(a2 - 223);
      a2 -= 233;
      if (v15 < *((void *)&v64 + 1)) {
        goto LABEL_11;
      }
    }
    unint64_t v13 = a2;
  }
  else
  {
    do
    {
      unint64_t v13 = a2 - 233;
      unint64_t v14 = *(a2 - 223);
      a2 -= 233;
    }
    while (v14 >= *((void *)&v64 + 1));
  }
LABEL_11:
  uint64_t v16 = v11;
  if (v11 < v13)
  {
    unint64_t v17 = v13;
    do
    {
      std::swap[abi:nn180100]<md::mun::CollectionPoint>(v16, v17);
      uint64_t v10 = *((void *)&v64 + 1);
      do
      {
        unint64_t v18 = v16[243];
        v16 += 233;
      }
      while (v18 < *((void *)&v64 + 1));
      do
      {
        uint64_t v19 = v17 - 223;
        v17 -= 233;
      }
      while ((unint64_t)*v19 >= *((void *)&v64 + 1));
    }
    while (v16 < v17);
  }
  long long v20 = v16 - 233;
  if (v16 - 233 != (uint64_t *)a1)
  {
    *(void *)a1 = *v20;
    *(_DWORD *)(a1 + 32) = *((_DWORD *)v16 - 458);
    *(_DWORD *)(a1 + 36) = *((_DWORD *)v16 - 457);
    *(_DWORD *)(a1 + 40) = *((_DWORD *)v16 - 456);
    *(_DWORD *)(a1 + 44) = *((_DWORD *)v16 - 455);
    *(void *)(a1 + 8) = *(v16 - 232);
    *(void *)(a1 + 16) = *(v16 - 231);
    *(void *)(a1 + 24) = *(v16 - 230);
    *(_DWORD *)(a1 + 48) = *((_DWORD *)v16 - 454);
    *(void *)(a1 + 56) = *(v16 - 226);
    *(void *)(a1 + 64) = *(v16 - 225);
    *(void *)(a1 + 72) = *(v16 - 224);
    *(void *)(a1 + 80) = *(v16 - 223);
    geo::small_vector_base<md::mun::PhotoInfo>::move((uint64_t)v8, v16 - 222, a1 + 120);
    uint64_t v21 = *(v16 - 2);
    *(void *)(a1 + 1853) = *(uint64_t *)((char *)v16 - 11);
    *(void *)(a1 + 1848) = v21;
    uint64_t v10 = *((void *)&v64 + 1);
  }
  uint64_t *v20 = v57;
  *(v16 - 229) = v60;
  *((_DWORD *)v16 - 456) = v61;
  *((_DWORD *)v16 - 455) = v62;
  *((_OWORD *)v16 - 116) = v58;
  *(v16 - 230) = v59;
  *((_DWORD *)v16 - 454) = HIDWORD(v62);
  *((_OWORD *)v16 - 113) = v63;
  *(v16 - 224) = v64;
  *(v16 - 223) = v10;
  if (v20 != &v57) {
    geo::small_vector_base<md::mun::PhotoInfo>::move((uint64_t)(v16 - 222), (uint64_t *)&v65, (uint64_t)(v16 - 218));
  }
  uint64_t v22 = v72[0];
  *(uint64_t *)((char *)v16 - 11) = *(void *)((char *)v72 + 5);
  *(v16 - 2) = v22;
  uint64_t v23 = v65;
  uint64_t v24 = v66;
  if (v65 != v66)
  {
    do
    {
      unint64_t v25 = (void *)v23[31];
      if (v25 != (void *)v23[33]) {
        free(v25);
      }
      v23 += 36;
    }
    while (v23 != v24);
    uint64_t v23 = v65;
  }
  if (v23 != (void *)v67) {
    free(v23);
  }
  return v16 - 233;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_0 &,md::mun::CollectionPoint *>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(0x63FB9AEB1FDCD759 * v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(a2 - 223) < (unint64_t)a1[10])
      {
        uint64_t v6 = a2 - 233;
        uint64_t v7 = a1;
        goto LABEL_71;
      }
      return result;
    case 3:
      unint64_t v8 = a1 + 233;
      unint64_t v9 = a1[243];
      uint64_t v11 = a2 - 223;
      unint64_t v10 = *(a2 - 223);
      if (v9 < a1[10])
      {
        if (v10 >= v9)
        {
          std::swap[abi:nn180100]<md::mun::CollectionPoint>(a1, a1 + 233);
          if (*v11 >= (unint64_t)a1[243]) {
            return 1;
          }
          uint64_t v7 = a1 + 233;
        }
        else
        {
          uint64_t v7 = a1;
        }
        uint64_t v6 = v2 - 233;
        goto LABEL_71;
      }
      if (v10 < v9)
      {
        unint64_t v17 = a1 + 233;
        unint64_t v18 = a2 - 233;
        goto LABEL_19;
      }
      return result;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_0 &,md::mun::CollectionPoint *>(a1, a1 + 233, a1 + 466, a2 - 233);
      return 1;
    case 5:
      unint64_t v8 = a1 + 233;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_0 &,md::mun::CollectionPoint *>(a1, a1 + 233, a1 + 466, a1 + 699);
      if (*(v2 - 223) < (unint64_t)a1[709])
      {
        std::swap[abi:nn180100]<md::mun::CollectionPoint>(a1 + 699, v2 - 233);
        if (a1[709] < (unint64_t)a1[476])
        {
          std::swap[abi:nn180100]<md::mun::CollectionPoint>(a1 + 466, a1 + 699);
          if (a1[476] < (unint64_t)a1[243])
          {
            unint64_t v17 = a1 + 233;
            unint64_t v18 = a1 + 466;
LABEL_19:
            std::swap[abi:nn180100]<md::mun::CollectionPoint>(v17, v18);
            if (a1[243] < (unint64_t)a1[10])
            {
              uint64_t v7 = a1;
              uint64_t v6 = v8;
LABEL_71:
              std::swap[abi:nn180100]<md::mun::CollectionPoint>(v7, v6);
            }
          }
        }
      }
      return 1;
    default:
      long long v12 = a1 + 466;
      unint64_t v13 = a1[243];
      unint64_t v14 = a1[476];
      if (v13 < a1[10])
      {
        unint64_t v15 = a1;
        if (v14 >= v13)
        {
          std::swap[abi:nn180100]<md::mun::CollectionPoint>(a1, a1 + 233);
          if (a1[476] >= (unint64_t)a1[243]) {
            goto LABEL_25;
          }
          unint64_t v15 = a1 + 233;
        }
        uint64_t v16 = a1 + 466;
        goto LABEL_24;
      }
      if (v14 < v13)
      {
        std::swap[abi:nn180100]<md::mun::CollectionPoint>(a1 + 233, a1 + 466);
        if (a1[243] < (unint64_t)a1[10])
        {
          unint64_t v15 = a1;
          uint64_t v16 = a1 + 233;
LABEL_24:
          std::swap[abi:nn180100]<md::mun::CollectionPoint>(v15, v16);
        }
      }
LABEL_25:
      uint64_t v19 = a1 + 699;
      if (a1 + 699 != v2)
      {
        uint64_t v20 = 0;
        int v21 = 0;
        uint64_t v22 = a1 + 697;
        uint64_t v23 = 5576;
        uint64_t v72 = v2;
        while (1)
        {
          if (v19[10] >= (unint64_t)v12[10]) {
            goto LABEL_28;
          }
          uint64_t v74 = *v19;
          long long v75 = *(_OWORD *)(v19 + 1);
          uint64_t v24 = v19[4];
          uint64_t v76 = v19[3];
          *(void *)long long v77 = v24;
          *(_DWORD *)&v77[8] = *((_DWORD *)v19 + 10);
          uint64_t v78 = *(uint64_t *)((char *)v19 + 44);
          long long v25 = *(_OWORD *)(v19 + 9);
          long long v79 = *(_OWORD *)(v19 + 7);
          long long v80 = v25;
          unint64_t v81 = v85;
          uint64_t v26 = v19[14];
          uint64_t v27 = v19[11];
          unint64_t v83 = v85;
          uint64_t v84 = v26;
          if (v27 == v19[13]) {
            break;
          }
          uint64_t v28 = (unsigned char *)v19[12];
          unint64_t v81 = (unsigned char *)v27;
          unint64_t v82 = v28;
          *(_OWORD *)(v19 + 11) = 0u;
          *(_OWORD *)(v19 + 13) = 0u;
LABEL_32:
          int v73 = v21;
          v88[0] = v19[231];
          *(void *)((char *)v88 + 5) = *(uint64_t *)((char *)v19 + 1853);
          uint64_t v29 = v23;
          uint64_t v30 = v20;
          while (1)
          {
            long long v31 = (char *)a1 + v30;
            uint64_t v32 = v29;
            *((void *)v31 + 699) = *(uint64_t *)((char *)a1 + v30 + 3728);
            *((_DWORD *)v31 + 1406) = *(_DWORD *)((char *)a1 + v30 + 3760);
            *(void *)(v31 + 5628) = *(uint64_t *)((char *)a1 + v30 + 3764);
            *((_DWORD *)v31 + 1409) = *(_DWORD *)((char *)a1 + v30 + 3772);
            *((_OWORD *)v31 + 350) = *(_OWORD *)((char *)a1 + v30 + 3736);
            *((void *)v31 + 702) = *(uint64_t *)((char *)a1 + v30 + 3752);
            *((_DWORD *)v31 + 1410) = *(_DWORD *)((char *)a1 + v30 + 3776);
            *((void *)v31 + 706) = *(uint64_t *)((char *)a1 + v30 + 3784);
            *((void *)v31 + 707) = *(uint64_t *)((char *)a1 + v30 + 3792);
            uint64_t v33 = *(uint64_t *)((char *)a1 + v30 + 3800);
            *((void *)v31 + 709) = *(uint64_t *)((char *)a1 + v30 + 3808);
            *((void *)v31 + 708) = v33;
            geo::small_vector_base<md::mun::PhotoInfo>::move((uint64_t)v22 + v30 + 104, (uint64_t *)((char *)a1 + v30 + 3816), (uint64_t)v22 + v30 + 136);
            *((void *)v31 + 930) = *((void *)v31 + 697);
            *(void *)(v31 + 7445) = *(void *)(v31 + 5581);
            uint64_t v34 = *((void *)&v80 + 1);
            if (v30 == -3728) {
              break;
            }
            v30 -= 1864;
            uint64_t v29 = v32 - 1864;
            if (*((void *)&v80 + 1) >= *((void *)v31 + 243))
            {
              uint64_t v35 = (uint64_t)v22 + v30 + 16;
              long long v36 = (uint64_t *)((char *)a1 + v32);
              goto LABEL_37;
            }
          }
          long long v36 = (uint64_t *)((char *)a1 + v32);
          uint64_t v35 = (uint64_t)a1;
LABEL_37:
          *(void *)uint64_t v35 = v74;
          *(_DWORD *)(v35 + 32) = *(_DWORD *)v77;
          *(void *)(v35 + 36) = *(void *)&v77[4];
          *(_DWORD *)(v35 + 44) = v78;
          *(_OWORD *)(v35 + 8) = v75;
          *(void *)(v35 + 24) = v76;
          *(_DWORD *)(v35 + 48) = HIDWORD(v78);
          uint64_t v37 = *((void *)&v79 + 1);
          *(void *)(v35 + 56) = v79;
          *(void *)(v35 + 64) = v37;
          *(void *)(v35 + 72) = v80;
          *(void *)(v35 + 80) = v34;
          if ((uint64_t *)v35 != &v74) {
            geo::small_vector_base<md::mun::PhotoInfo>::move(v35 + 88, (uint64_t *)&v81, v35 + 120);
          }
          void *v36 = v88[0];
          *(void *)((char *)v36 + 5) = *(void *)((char *)v88 + 5);
          long long v38 = v81;
          long long v39 = v82;
          if (v81 != v82)
          {
            do
            {
              long long v40 = (void *)v38[31];
              if (v40 != (void *)v38[33]) {
                free(v40);
              }
              v38 += 36;
            }
            while (v38 != v39);
            long long v38 = v81;
          }
          uint64_t v2 = v72;
          if (v38 != (void *)v83) {
            free(v38);
          }
          int v21 = v73 + 1;
          if (v73 == 7) {
            return v19 + 233 == v72;
          }
LABEL_28:
          long long v12 = v19;
          v20 += 1864;
          v23 += 1864;
          v19 += 233;
          if (v19 == v2) {
            return 1;
          }
        }
        uint64_t v41 = v19[12];
        unint64_t v82 = &v85[v41 - v27];
        if (v41 == v27) {
          goto LABEL_32;
        }
        uint64_t v42 = 0;
        long long v43 = v86;
        long long v44 = &v87;
        unint64_t v45 = v85;
        while (1)
        {
          long long v46 = *(_OWORD *)v27;
          *((void *)v45 + 2) = *(void *)(v27 + 16);
          *(_OWORD *)unint64_t v45 = v46;
          uint64_t v47 = *(void *)(v27 + 24);
          *((_DWORD *)v45 + 8) = *(_DWORD *)(v27 + 32);
          *((void *)v45 + 3) = v47;
          *(void *)(v45 + 36) = *(void *)(v27 + 36);
          long long v48 = *(_OWORD *)(v27 + 44);
          long long v49 = *(_OWORD *)(v27 + 60);
          long long v50 = *(_OWORD *)(v27 + 76);
          *(_OWORD *)(v45 + 92) = *(_OWORD *)(v27 + 92);
          *(_OWORD *)(v45 + 76) = v50;
          *(_OWORD *)(v45 + 60) = v49;
          *(_OWORD *)(v45 + 44) = v48;
          long long v51 = *(_OWORD *)(v27 + 108);
          long long v52 = *(_OWORD *)(v27 + 124);
          long long v53 = *(_OWORD *)(v27 + 140);
          *(_OWORD *)(v45 + 156) = *(_OWORD *)(v27 + 156);
          *(_OWORD *)(v45 + 140) = v53;
          *(_OWORD *)(v45 + 124) = v52;
          *(_OWORD *)(v45 + 108) = v51;
          long long v54 = *(_OWORD *)(v27 + 172);
          long long v55 = *(_OWORD *)(v27 + 188);
          long long v56 = *(_OWORD *)(v27 + 204);
          *(_OWORD *)(v45 + 220) = *(_OWORD *)(v27 + 220);
          *(_OWORD *)(v45 + 204) = v56;
          *(_OWORD *)(v45 + 188) = v55;
          *(_OWORD *)(v45 + 172) = v54;
          uint64_t v57 = v45 + 280;
          *((void *)v45 + 31) = v45 + 280;
          long long v58 = *(char **)(v27 + 248);
          *((_DWORD *)v45 + 59) = *(_DWORD *)(v27 + 236);
          v45[240] = *(unsigned char *)(v27 + 240);
          *((void *)v45 + 32) = v45 + 280;
          *((void *)v45 + 33) = v45 + 280;
          *((void *)v45 + 34) = *(void *)(v27 + 272);
          if (v58 == *(char **)(v27 + 264))
          {
            *((void *)v45 + 32) = &v57[*(void *)(v27 + 256) - (void)v58];
            uint64_t v59 = *(char **)(v27 + 256);
            if (v58 != v59)
            {
              unint64_t v60 = v59 - v58;
              if ((unint64_t)(v59 - v58) >= 8 && (unint64_t)(&v86[288 * v42] - v58) >= 0x20)
              {
                if (v60 < 0x20)
                {
                  unint64_t v61 = 0;
                  goto LABEL_61;
                }
                unint64_t v61 = v60 & 0xFFFFFFFFFFFFFFE0;
                uint64_t v62 = (long long *)(v58 + 16);
                long long v63 = v44;
                unint64_t v64 = v60 & 0xFFFFFFFFFFFFFFE0;
                do
                {
                  long long v65 = *v62;
                  *((_OWORD *)v63 - 1) = *(v62 - 1);
                  *(_OWORD *)long long v63 = v65;
                  v62 += 2;
                  v63 += 4;
                  v64 -= 32;
                }
                while (v64);
                if (v60 == v61) {
                  goto LABEL_50;
                }
                if ((v60 & 0x18) != 0)
                {
LABEL_61:
                  unint64_t v66 = v60 & 0xFFFFFFFFFFFFFFF8;
                  v57 += v60 & 0xFFFFFFFFFFFFFFF8;
                  unint64_t v67 = v61 - (v60 & 0xFFFFFFFFFFFFFFF8);
                  uint64_t v68 = (uint64_t *)&v58[v61];
                  uint64_t v69 = &v43[v61];
                  do
                  {
                    uint64_t v70 = *v68++;
                    *v69++ = v70;
                    v67 += 8;
                  }
                  while (v67);
                  if (v60 == v66) {
                    goto LABEL_50;
                  }
                  v58 += v66;
                }
                else
                {
                  v58 += v61;
                  v57 += v61;
                }
              }
              do
              {
                char v71 = *v58++;
                *v57++ = v71;
              }
              while (v58 != v59);
            }
          }
          else
          {
            *((void *)v45 + 31) = v58;
            *((void *)v45 + 32) = *(void *)(v27 + 256);
            *(_OWORD *)(v27 + 248) = 0u;
            *(_OWORD *)(v27 + 264) = 0u;
          }
LABEL_50:
          v45 += 288;
          v27 += 288;
          ++v42;
          v44 += 36;
          v43 += 288;
          if (v27 == v41) {
            goto LABEL_32;
          }
        }
      }
      return 1;
  }
}

void std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_0 &,md::mun::CollectionPoint *>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v5 = a2 - 2;
  if (a2 < 2) {
    return;
  }
  v74[13] = v3;
  v74[14] = v4;
  uint64_t v6 = a3;
  int64_t v8 = v5 >> 1;
  if ((uint64_t)(v5 >> 1) < 0x63FB9AEB1FDCD759 * (((uint64_t)a3 - a1) >> 3)) {
    return;
  }
  int64_t v10 = (0xC7F735D63FB9AEB2 * (((uint64_t)a3 - a1) >> 3)) | 1;
  uint64_t v11 = (uint64_t *)(a1 + 1864 * v10);
  if ((uint64_t)(0xC7F735D63FB9AEB2 * (((uint64_t)a3 - a1) >> 3) + 2) < a2)
  {
    unint64_t v12 = v11[10];
    unint64_t v13 = v11[243];
    v11 += 233 * (v12 < v13);
    if (v12 < v13) {
      int64_t v10 = 0xC7F735D63FB9AEB2 * (((uint64_t)a3 - a1) >> 3) + 2;
    }
  }
  if (v11[10] < (unint64_t)a3[10]) {
    return;
  }
  uint64_t v59 = *a3;
  long long v60 = *(_OWORD *)(a3 + 1);
  uint64_t v14 = a3[4];
  uint64_t v61 = a3[3];
  uint64_t v62 = v14;
  int v63 = *((_DWORD *)a3 + 10);
  uint64_t v64 = *(uint64_t *)((char *)a3 + 44);
  long long v65 = *(_OWORD *)(a3 + 7);
  long long v66 = *(_OWORD *)(a3 + 9);
  unint64_t v15 = v71;
  unint64_t v67 = v71;
  uint64_t v16 = a3[14];
  uint64_t v17 = a3[11];
  uint64_t v69 = v71;
  uint64_t v70 = v16;
  if (v17 != a3[13])
  {
    unint64_t v18 = (unsigned char *)a3[12];
    unint64_t v67 = (unsigned char *)v17;
    uint64_t v68 = v18;
    *(_OWORD *)(a3 + 11) = 0u;
    *(_OWORD *)(a3 + 13) = 0u;
    goto LABEL_9;
  }
  uint64_t v29 = a3[12];
  uint64_t v68 = &v71[v29 - v17];
  if (v29 != v17)
  {
    uint64_t v30 = 0;
    long long v31 = &v73;
    uint64_t v32 = v72;
    do
    {
      long long v33 = *(_OWORD *)v17;
      *((void *)v15 + 2) = *(void *)(v17 + 16);
      *(_OWORD *)unint64_t v15 = v33;
      uint64_t v34 = *(void *)(v17 + 24);
      *((_DWORD *)v15 + 8) = *(_DWORD *)(v17 + 32);
      *((void *)v15 + 3) = v34;
      *(void *)(v15 + 36) = *(void *)(v17 + 36);
      long long v35 = *(_OWORD *)(v17 + 44);
      long long v36 = *(_OWORD *)(v17 + 60);
      long long v37 = *(_OWORD *)(v17 + 76);
      *(_OWORD *)(v15 + 92) = *(_OWORD *)(v17 + 92);
      *(_OWORD *)(v15 + 76) = v37;
      *(_OWORD *)(v15 + 60) = v36;
      *(_OWORD *)(v15 + 44) = v35;
      long long v38 = *(_OWORD *)(v17 + 108);
      long long v39 = *(_OWORD *)(v17 + 124);
      long long v40 = *(_OWORD *)(v17 + 140);
      *(_OWORD *)(v15 + 156) = *(_OWORD *)(v17 + 156);
      *(_OWORD *)(v15 + 140) = v40;
      *(_OWORD *)(v15 + 124) = v39;
      *(_OWORD *)(v15 + 108) = v38;
      long long v41 = *(_OWORD *)(v17 + 172);
      long long v42 = *(_OWORD *)(v17 + 188);
      long long v43 = *(_OWORD *)(v17 + 204);
      *(_OWORD *)(v15 + 220) = *(_OWORD *)(v17 + 220);
      *(_OWORD *)(v15 + 204) = v43;
      *(_OWORD *)(v15 + 188) = v42;
      *(_OWORD *)(v15 + 172) = v41;
      long long v44 = v15 + 280;
      *((void *)v15 + 31) = v15 + 280;
      unint64_t v45 = *(char **)(v17 + 248);
      *((_DWORD *)v15 + 59) = *(_DWORD *)(v17 + 236);
      v15[240] = *(unsigned char *)(v17 + 240);
      *((void *)v15 + 32) = v15 + 280;
      *((void *)v15 + 33) = v15 + 280;
      *((void *)v15 + 34) = *(void *)(v17 + 272);
      if (v45 == *(char **)(v17 + 264))
      {
        *((void *)v15 + 32) = &v44[*(void *)(v17 + 256) - (void)v45];
        long long v46 = *(char **)(v17 + 256);
        if (v45 != v46)
        {
          unint64_t v47 = v46 - v45;
          if ((unint64_t)(v46 - v45) >= 8 && (unint64_t)(&v72[288 * v30] - v45) >= 0x20)
          {
            if (v47 < 0x20)
            {
              unint64_t v48 = 0;
              goto LABEL_44;
            }
            unint64_t v48 = v47 & 0xFFFFFFFFFFFFFFE0;
            long long v49 = (long long *)(v45 + 16);
            long long v50 = v31;
            unint64_t v51 = v47 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v52 = *v49;
              *((_OWORD *)v50 - 1) = *(v49 - 1);
              *(_OWORD *)long long v50 = v52;
              v49 += 2;
              v50 += 4;
              v51 -= 32;
            }
            while (v51);
            if (v47 == v48) {
              goto LABEL_33;
            }
            if ((v47 & 0x18) != 0)
            {
LABEL_44:
              unint64_t v53 = v47 & 0xFFFFFFFFFFFFFFF8;
              v44 += v47 & 0xFFFFFFFFFFFFFFF8;
              unint64_t v54 = v48 - (v47 & 0xFFFFFFFFFFFFFFF8);
              long long v55 = (uint64_t *)&v45[v48];
              long long v56 = &v32[v48];
              do
              {
                uint64_t v57 = *v55++;
                *v56++ = v57;
                v54 += 8;
              }
              while (v54);
              if (v47 == v53) {
                goto LABEL_33;
              }
              v45 += v53;
            }
            else
            {
              v45 += v48;
              v44 += v48;
            }
          }
          do
          {
            char v58 = *v45++;
            *v44++ = v58;
          }
          while (v45 != v46);
        }
      }
      else
      {
        *((void *)v15 + 31) = v45;
        *((void *)v15 + 32) = *(void *)(v17 + 256);
        *(_OWORD *)(v17 + 248) = 0uLL;
        *(_OWORD *)(v17 + 264) = 0uLL;
      }
LABEL_33:
      v15 += 288;
      v17 += 288;
      ++v30;
      v31 += 36;
      v32 += 288;
    }
    while (v17 != v29);
  }
LABEL_9:
  *(void *)((char *)v74 + 5) = *(uint64_t *)((char *)v6 + 1853);
  v74[0] = v6[231];
  while (1)
  {
    uint64_t v20 = v11;
    *uint64_t v6 = *v11;
    *((_DWORD *)v6 + 8) = *((_DWORD *)v11 + 8);
    *((_DWORD *)v6 + 9) = *((_DWORD *)v11 + 9);
    *((_DWORD *)v6 + 10) = *((_DWORD *)v11 + 10);
    *((_DWORD *)v6 + 11) = *((_DWORD *)v11 + 11);
    v6[1] = v11[1];
    v6[2] = v11[2];
    v6[3] = v11[3];
    *((_DWORD *)v6 + 12) = *((_DWORD *)v11 + 12);
    v6[7] = v11[7];
    v6[8] = v11[8];
    v6[9] = v11[9];
    v6[10] = v11[10];
    if (v6 != v11) {
      geo::small_vector_base<md::mun::PhotoInfo>::move((uint64_t)(v6 + 11), v11 + 11, (uint64_t)(v6 + 15));
    }
    uint64_t v21 = v20[231];
    *(uint64_t *)((char *)v6 + 1853) = *(uint64_t *)((char *)v20 + 1853);
    v6[231] = v21;
    if (v8 < v10) {
      break;
    }
    uint64_t v22 = (2 * v10) | 1;
    uint64_t v11 = (uint64_t *)(a1 + 1864 * v22);
    if (2 * v10 + 2 < a2)
    {
      unint64_t v23 = v11[10];
      unint64_t v24 = v11[243];
      v11 += 233 * (v23 < v24);
      if (v23 < v24) {
        uint64_t v22 = 2 * v10 + 2;
      }
    }
    uint64_t v19 = *((void *)&v66 + 1);
    uint64_t v6 = v20;
    int64_t v10 = v22;
    if ((unint64_t)v11[10] < *((void *)&v66 + 1)) {
      goto LABEL_19;
    }
  }
  uint64_t v19 = *((void *)&v66 + 1);
LABEL_19:
  uint64_t *v20 = v59;
  v20[4] = v62;
  *((_DWORD *)v20 + 10) = v63;
  *((_DWORD *)v20 + 11) = v64;
  *(_OWORD *)(v20 + 1) = v60;
  v20[3] = v61;
  *((_DWORD *)v20 + 12) = HIDWORD(v64);
  *(_OWORD *)(v20 + 7) = v65;
  v20[9] = v66;
  v20[10] = v19;
  if (v20 != &v59) {
    geo::small_vector_base<md::mun::PhotoInfo>::move((uint64_t)(v20 + 11), (uint64_t *)&v67, (uint64_t)(v20 + 15));
  }
  uint64_t v25 = v74[0];
  *(uint64_t *)((char *)v20 + 1853) = *(void *)((char *)v74 + 5);
  v20[231] = v25;
  uint64_t v26 = v67;
  uint64_t v27 = v68;
  if (v67 != v68)
  {
    do
    {
      uint64_t v28 = (void *)v26[31];
      if (v28 != (void *)v26[33]) {
        free(v28);
      }
      v26 += 36;
    }
    while (v26 != v27);
    uint64_t v26 = v67;
  }
  if (v26 != (void *)v69) {
    free(v26);
  }
}

BOOL std::__function::__func<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_1,std::allocator<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_1>,BOOL ()(md::mun::CollectionPoint const&)>::operator()(double *a1, double *a2)
{
  double v2 = a1[10];
  double v3 = a1[11];
  double v4 = a1[12];
  double v5 = a1[13];
  double v6 = a2[2];
  double v7 = a2[3];
  double v8 = a2[1];
  double v9 = -(v6 * v4 - v7 * v3) - (v6 * v4 - v7 * v3);
  double v10 = -(v7 * v2 - v8 * v4) - (v7 * v2 - v8 * v4);
  double v11 = -(v8 * v3 - v6 * v2) - (v8 * v3 - v6 * v2);
  double v12 = a1[7] + v8 + v9 * v5 + v11 * v3 - v10 * v4;
  if (v12 < a1[1]) {
    return 0;
  }
  double v14 = v7 - v9 * v3 + v10 * v2 + v11 * v5 + a1[9];
  double v15 = v6 + v9 * v4 + v10 * v5 - v11 * v2 + a1[8];
  BOOL v16 = v12 < a1[4];
  if (v15 < a1[2]) {
    BOOL v16 = 0;
  }
  if (v15 >= a1[5]) {
    BOOL v16 = 0;
  }
  if (v14 < a1[3]) {
    BOOL v16 = 0;
  }
  return v14 < a1[6] && v16;
}

double std::__function::__func<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_1,std::allocator<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_1>,BOOL ()(md::mun::CollectionPoint const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF578C30;
  long long v2 = *(_OWORD *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(_OWORD *)(a2 + 8) = v2;
  long long v4 = *(_OWORD *)(a1 + 56);
  *(void *)(a2 + 72) = *(void *)(a1 + 72);
  *(_OWORD *)(a2 + 56) = v4;
  long long v5 = *(_OWORD *)(a1 + 80);
  *(void *)(a2 + 96) = *(void *)(a1 + 96);
  *(_OWORD *)(a2 + 80) = v5;
  double result = *(double *)(a1 + 104);
  *(double *)(a2 + 104) = result;
  return result;
}

double std::__function::__func<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_1,std::allocator<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_1>,BOOL ()(md::mun::CollectionPoint const&)>::__clone(uint64_t a1)
{
  long long v2 = (char *)operator new(0x70uLL);
  *(void *)long long v2 = &unk_1EF578C30;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v2 + 56) = *(_OWORD *)(a1 + 56);
  *((void *)v2 + 9) = *(void *)(a1 + 72);
  *((_OWORD *)v2 + 5) = *(_OWORD *)(a1 + 80);
  *((void *)v2 + 12) = *(void *)(a1 + 96);
  double result = *(double *)(a1 + 104);
  *((double *)v2 + 13) = result;
  return result;
}

void std::__function::__func<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_1,std::allocator<md::mun::MuninOverlayRenderLayer::debugLayout(md::LayoutContext const&)::$_1>,BOOL ()(md::mun::CollectionPoint const&)>::~__func()
{
}

unint64_t ___ZN12_GLOBAL__N_120createPointsDrawableERKN2md13LayoutContextEP17VKSharedResourcesRKNSt3__110unique_ptrIN3ggl11RenderStateENS6_14default_deleteIS9_EEEEfRKNS6_6vectorINS_15PointDescriptorENS6_9allocatorISG_EEEE_block_invoke(void *a1)
{
  uint64_t v1 = (void *)a1[4];
  unint64_t v2 = v1[6] - v1[5];
  unint64_t v3 = v2 / v1[1] * v1[1];
  unint64_t v4 = v2 % v1[1];
  if (v2 == v4) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v1[9];
  }
  double v6 = (void *)a1[6];
  unint64_t v7 = v6[6] - v6[5];
  unint64_t v8 = v7 / v6[1] * v6[1];
  unint64_t v9 = v7 % v6[1];
  if (v7 == v9) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = v6[9];
  }
  double v11 = (uint64_t *)a1[8];
  uint64_t v12 = *v11;
  unint64_t result = v11[1] - *v11;
  if (result)
  {
    unint64_t result = (uint64_t)result / 28;
    if (result <= 1) {
      unint64_t result = 1;
    }
    double v14 = (_DWORD *)(v12 + 24);
    double v15 = (_DWORD *)(v10 + 28);
    uint64_t v16 = v5;
    do
    {
      uint64_t v17 = *((void *)v14 - 3);
      *(_DWORD *)(v16 + 8) = *(v14 - 4);
      *(void *)uint64_t v16 = v17;
      *(_DWORD *)(v16 + 12) = 1065353216;
      *(v15 - 7) = 1065353216;
      *(v15 - 3) = *(v14 - 3);
      *(v15 - 2) = *(v14 - 2);
      *(v15 - 1) = *(v14 - 1);
      int v18 = *v14;
      v14 += 7;
      *double v15 = v18;
      v15 += 8;
      v16 += 16;
      --result;
    }
    while (result);
  }
  if (v10 && v7 != v9)
  {
    if (v6[8] > v8) {
      unint64_t v8 = v6[8];
    }
    v6[7] = 0;
    v6[8] = v8;
  }
  if (v5 && v2 != v4)
  {
    if (v1[8] > v3) {
      unint64_t v3 = v1[8];
    }
    v1[7] = 0;
    v1[8] = v3;
  }
  return result;
}

uint64_t std::__shared_ptr_emplace<ggl::Point::ExtendedMesh>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Point::ExtendedMesh>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589128;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Point::ExtendedMesh>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589128;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void __destroy_helper_block_ea8_32c80_ZTSNSt3__110shared_ptrIN3ggl15VertexDataTypedINS1_10CommonMesh10BufferPos4EEEEE48c75_ZTSNSt3__110shared_ptrIN3ggl15VertexDataTypedINS1_5Point11ExtendedVboEEEEE(uint64_t a1)
{
  unint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    unint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v3) {
      return;
    }
  }
  else
  {
    unint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v3) {
      return;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *__copy_helper_block_ea8_32c80_ZTSNSt3__110shared_ptrIN3ggl15VertexDataTypedINS1_10CommonMesh10BufferPos4EEEEE48c75_ZTSNSt3__110shared_ptrIN3ggl15VertexDataTypedINS1_5Point11ExtendedVboEEEEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Point::ExtendedVbo>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Point::ExtendedVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584F88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Point::ExtendedVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584F88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Point::ExtendedPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Point::ExtendedPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589198;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Point::ExtendedPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589198;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t ___ZN2md3mun23MuninOverlayRenderLayer20updateDebugDrawablesERKNS_13LayoutContextE_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 32);
  unint64_t v2 = v1[6] - v1[5];
  unint64_t v3 = v1[1];
  unint64_t v4 = (_OWORD *)v1[9];
  *unint64_t v4 = xmmword_1A28FD2B0;
  v4[1] = xmmword_1A28FE3C0;
  v4[2] = xmmword_1A28FD270;
  v4[3] = xmmword_1A28FE3D0;
  unint64_t v5 = v2 - v2 % v3;
  if (v5)
  {
    if (v1[8] > v5) {
      unint64_t v5 = v1[8];
    }
    v1[7] = 0;
    v1[8] = v5;
  }
  double v6 = *(void **)(result + 48);
  unint64_t v7 = v6[6] - v6[5];
  unint64_t v8 = v7 % v6[1];
  uint64_t v9 = v6[9];
  *(void *)uint64_t v9 = 0x2000200010000;
  *(_DWORD *)(v9 + 8) = 3;
  unint64_t v10 = v7 - v8;
  if (v10)
  {
    if (v6[8] > v10) {
      unint64_t v10 = v6[8];
    }
    v6[7] = 0;
    v6[8] = v10;
  }
  return result;
}

uint64_t std::construct_at[abi:nn180100]<ggl::CommonMesh::Pos4Mesh,char const(&)[17],std::shared_ptr<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos4>> &,std::shared_ptr<ggl::IndexDataTyped<unsigned short>> &,ggl::CommonMesh::Pos4Mesh*>(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t *a4)
{
  uint64_t v9 = a2;
  unint64_t v10 = a3;
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v5 = (std::__shared_weak_count *)a4[1];
  v8[0] = *a4;
  v8[1] = (uint64_t)v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::CommonMesh::Pos4Mesh::Pos4Mesh(a1, (uint64_t)"screen quad mesh", &v9, v8);
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    ggl::CommonMesh::Pos4Mesh::Pos4Mesh(a1, (uint64_t)"screen quad mesh", &v9, v8);
  }
  double v6 = v10;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  return a1;
}

void __destroy_helper_block_ea8_32c80_ZTSNSt3__110shared_ptrIN3ggl15VertexDataTypedINS1_10CommonMesh10BufferPos4EEEEE48c51_ZTSNSt3__110shared_ptrIN3ggl14IndexDataTypedItEEEE(uint64_t a1)
{
  unint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    unint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v3) {
      return;
    }
  }
  else
  {
    unint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v3) {
      return;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *__copy_helper_block_ea8_32c80_ZTSNSt3__110shared_ptrIN3ggl15VertexDataTypedINS1_10CommonMesh10BufferPos4EEEEE48c51_ZTSNSt3__110shared_ptrIN3ggl14IndexDataTypedItEEEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<ggl::Drawable *,std::shared_ptr<ggl::Drawable>::__shared_ptr_default_delete<ggl::Drawable,ggl::Drawable>,std::allocator<ggl::Drawable>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(uint64_t **)(result + 24);
  if (v1)
  {
    uint64_t v2 = (std::__shared_weak_count *)v1[3];
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    uint64_t v3 = v1[1];
    v1[1] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = *v1;
    uint64_t *v1 = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<ggl::Drawable *,std::shared_ptr<ggl::Drawable>::__shared_ptr_default_delete<ggl::Drawable,ggl::Drawable>,std::allocator<ggl::Drawable>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::ConstantDataTyped<ggl::VSSprite::Sprite>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::VSSprite::Sprite>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::VSSprite::Sprite>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::VSSprite::Sprite>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5878E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::VSSprite::Sprite>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5878E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::VSSprite::PipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VSSprite::PipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589C88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VSSprite::PipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589C88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::mun::MuninOverlayRenderLayer::~MuninOverlayRenderLayer(md::mun::MuninOverlayRenderLayer *this)
{
  md::mun::MuninOverlayRenderLayer::~MuninOverlayRenderLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  md::mun::TapAnnotation *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;

  *(void *)this = &unk_1EF550570;
  uint64_t v2 = (md::mun::TapAnnotation *)*((void *)this + 45);
  *((void *)this + 45) = 0;
  if (v2)
  {
    md::mun::TapAnnotation::~TapAnnotation(v2);
    MEMORY[0x1A6239270]();
  }
  uint64_t v3 = (void *)*((void *)this + 44);
  *((void *)this + 44) = 0;
  if (v3) {
    std::default_delete<md::mun::TapRenderResources>::operator()[abi:nn180100](v3);
  }
  uint64_t v4 = (void *)*((void *)this + 40);
  if (v4)
  {
    *((void *)this + 41) = v4;
    operator delete(v4);
  }
  unint64_t v5 = *((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  double v6 = *((void *)this + 38);
  *((void *)this + 38) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  unint64_t v7 = *((void *)this + 37);
  *((void *)this + 37) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  unint64_t v8 = (uint64_t *)*((void *)this + 29);
  *((void *)this + 29) = 0;
  if (v8)
  {
    uint64_t v9 = (std::__shared_weak_count *)v8[3];
    if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    unint64_t v10 = v8[1];
    v8[1] = 0;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
    double v11 = *v8;
    *unint64_t v8 = 0;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    }
    MEMORY[0x1A6239270](v8, 0x20C40DC1BFBCFLL);
  }
  uint64_t v12 = (uint64_t *)*((void *)this + 21);
  *((void *)this + 21) = 0;
  if (v12)
  {
    unint64_t v13 = (std::__shared_weak_count *)v12[3];
    if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    double v14 = v12[1];
    v12[1] = 0;
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
    double v15 = *v12;
    *uint64_t v12 = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
    MEMORY[0x1A6239270](v12, 0x20C40DC1BFBCFLL);
  }
  uint64_t v16 = (uint64_t *)*((void *)this + 20);
  *((void *)this + 20) = 0;
  if (v16)
  {
    uint64_t v17 = (std::__shared_weak_count *)v16[3];
    if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
    int v18 = v16[1];
    v16[1] = 0;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    }
    uint64_t v19 = *v16;
    *uint64_t v16 = 0;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
    MEMORY[0x1A6239270](v16, 0x20C40DC1BFBCFLL);
  }
  uint64_t v20 = (uint64_t *)*((void *)this + 12);
  *((void *)this + 12) = 0;
  if (v20)
  {
    uint64_t v21 = (std::__shared_weak_count *)v20[3];
    if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
    uint64_t v22 = v20[1];
    v20[1] = 0;
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
    }
    unint64_t v23 = *v20;
    uint64_t *v20 = 0;
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
    }
    MEMORY[0x1A6239270](v20, 0x20C40DC1BFBCFLL);
  }
  unint64_t v24 = (uint64_t *)*((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v24)
  {
    uint64_t v25 = (std::__shared_weak_count *)v24[3];
    if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
    uint64_t v26 = v24[1];
    v24[1] = 0;
    if (v26) {
      (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
    }
    uint64_t v27 = *v24;
    *unint64_t v24 = 0;
    if (v27) {
      (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
    }
    MEMORY[0x1A6239270](v24, 0x20C40DC1BFBCFLL);
  }
  uint64_t v28 = (uint64_t *)*((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v28)
  {
    uint64_t v29 = (std::__shared_weak_count *)v28[3];
    if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
    uint64_t v30 = v28[1];
    v28[1] = 0;
    if (v30) {
      (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
    }
    long long v31 = *v28;
    void *v28 = 0;
    if (v31) {
      (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
    }
    MEMORY[0x1A6239270](v28, 0x20C40DC1BFBCFLL);
  }
  *(void *)this = &unk_1EF530C60;
  uint64_t v32 = (void *)*((void *)this + 1);
  if (v32)
  {
    *((void *)this + 2) = v32;
    operator delete(v32);
  }
}

void md::TransitLineSegment::addRibbons(unint64_t a1, uint64_t a2, int a3, uint64x2_t *a4, uint64_t a5, _DWORD *a6)
{
  unint64_t v6 = a1;
  *(_DWORD *)(a1 + 32) = a3;
  uint64_t v7 = *(void *)(*(void *)(*(void *)(a2 + 640) - 8) + 56);
  uint64_t v8 = *(void *)(*(void *)(*(void *)(a2 + 640) - 8) + 64) - v7;
  if (v8)
  {
    unint64_t v9 = v8 >> 3;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    if (v9 >= 2)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      unint64_t v11 = v9 & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v14 = v7 + 8;
      unint64_t v15 = v9 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        uint64_t v12 = *(void *)(*(void *)(v14 - 8) + 16) + v12 - *(void *)(*(void *)(v14 - 8) + 8);
        uint64_t v13 = *(void *)(*(void *)v14 + 16) + v13 - *(void *)(*(void *)v14 + 8);
        v14 += 16;
        v15 -= 2;
      }
      while (v15);
      uint64_t v10 = v13 + v12;
      if (v9 == v11) {
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v10 = 0;
      unint64_t v11 = 0;
    }
    unint64_t v16 = v9 - v11;
    uint64_t v17 = (uint64_t *)(v7 + 8 * v11);
    do
    {
      uint64_t v18 = *v17++;
      uint64_t v10 = *(void *)(v18 + 16) + v10 - *(void *)(v18 + 8);
      --v16;
    }
    while (v16);
  }
  else
  {
    uint64_t v10 = 0;
  }
LABEL_12:
  memset(v134, 0, 24);
  memset(&__p, 0, sizeof(__p));
  uint64_t v19 = *(uint64_t **)(a1 + 8);
  if (!*(_DWORD *)(*v19 + 20)) {
    goto LABEL_115;
  }
  unint64_t v20 = 0;
  __asm { FMOV            V0.2D, #0.5 }
  float64x2_t v116 = _Q0;
  do
  {
    uint64_t v25 = v19[7];
    unint64_t v130 = 0;
    uint64_t v26 = geo::codec::transitLinkPoints(*v19, v20, &v130);
    unint64_t v27 = v130;
    if (v130)
    {
      if (v130 >> 62) {
        abort();
      }
      uint64_t v28 = (void *)v26;
      uint64_t v29 = (int *)operator new(4 * v130);
      bzero(v29, 4 * v27);
      if (v27 < 2) {
        goto LABEL_15;
      }
      unint64_t v30 = v25 + 96 * v20;
      long long v31 = *(float **)(v6 + 8);
      float v32 = *(float *)(v30 + 80);
      float v33 = v31[54] - v32;
      float v34 = v31[55] - v32;
      float v35 = v31[56] - v32;
      float v36 = v31[57] - v32;
      long long v127 = 0;
      uint64_t v128 = 0;
      uint64_t v129 = 0;
      _ZF = v33 == v35 && v34 == v36;
      uint64_t v125 = v10;
      if (_ZF)
      {
        uint64_t v39 = 0;
        long long v40 = 0;
      }
      else
      {
        float v38 = *(float *)(v6 + 28);
        if (vabds_f32(*(float *)(v6 + 20), v38) > 0.2)
        {
          addEasingPointsInRegion(v25 + 96 * v20, (uint64_t)&v127, v33, v34);
          float v38 = *(float *)(v6 + 28);
        }
        if (vabds_f32(*(float *)(v6 + 24), v38) > 0.2) {
          addEasingPointsInRegion(v25 + 96 * v20, (uint64_t)&v127, v35, v36);
        }
        unint64_t v27 = v130;
        long long v40 = v127;
        uint64_t v39 = v128;
      }
      unint64_t v41 = (v39 - (uint64_t)v40) >> 2;
      *a6 += v41;
      if (*(unsigned char *)(v30 + 32) == 2)
      {
        long long v42 = (float *)(v30 + 8);
        uint64_t v43 = *(unsigned __int8 *)(v30 + 33);
        if (!*(unsigned char *)(a5 + v43))
        {
          long long v44 = (float *)&tileEdgeLinkStartNormals[v43];
          float v45 = v44[1];
          float v46 = (float)(*(float *)(v30 + 8) * *v44) + (float)(*(float *)(v30 + 12) * v45);
          if (v46 > 0.0)
          {
            float v47 = 1.0 / v46;
            if (v47 < 4.0)
            {
              v131[0] = v47 * *v44;
              v131[1] = v47 * v45;
              long long v42 = v131;
            }
          }
        }
      }
      else
      {
        unint64_t v48 = *(int8x8_t **)(v30 + 24);
        if (v48) {
          long long v42 = (float *)md::TransitJunction::normalForLineSegment(v48, v6);
        }
        else {
          long long v42 = 0;
        }
      }
      long long v123 = v42;
      unint64_t v49 = v25 + 96 * v20;
      if (*(unsigned char *)(v49 + 72) == 2)
      {
        long long v50 = (float32x2_t *)(v49 + 48);
        uint64_t v51 = *(unsigned __int8 *)(v49 + 73);
        if (!*(unsigned char *)(a5 + v51))
        {
          float32x2_t v52 = vneg_f32(tileEdgeLinkStartNormals[v51]);
          v53.i32[0] = v52.i32[0];
          v53.i32[1] = HIDWORD(*(void *)&tileEdgeLinkStartNormals[v51]);
          float32x2_t v54 = vmul_f32(*v50, v53);
          float v55 = vsub_f32(v54, (float32x2_t)vdup_lane_s32((int32x2_t)v54, 1)).f32[0];
          if (v55 > 0.0)
          {
            float v56 = 1.0 / v55;
            if (v56 < 4.0)
            {
              float32x2_t v132 = vmul_n_f32(v52, v56);
              long long v50 = &v132;
            }
          }
        }
      }
      else
      {
        long long v50 = *(float32x2_t **)(v49 + 64);
        if (v50) {
          long long v50 = (float32x2_t *)md::TransitJunction::normalForLineSegment((int8x8_t *)v50, v6);
        }
      }
      long long v122 = v50;
      unint64_t v57 = *(unsigned int *)(v6 + 32);
      unint64_t v58 = a4[4].u64[1];
      uint64_t v120 = a4[5].i64[0];
      uint64x2_t v121 = a4[3];
      {
        operator new();
      }
      uint64_t v59 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 16))(mdm::Allocator::instance(void)::alloc, 152, 8);
      uint64_t v60 = v59;
      unint64_t v61 = v41 + v27;
      *(_OWORD *)(v59 + 49) = 0u;
      *(_OWORD *)(v59 + 40) = 0u;
      *(_OWORD *)(v59 + 24) = 0u;
      *(_OWORD *)(v59 + 8) = 0u;
      *(void *)(v59 + 56) = v61;
      *(void *)uint64_t v59 = &unk_1EF553D90;
      *(void *)(v59 + 80) = 0;
      *(void *)(v59 + 88) = 0;
      *(void *)(v59 + 72) = 0;
      if (v61)
      {
        *(void *)(v59 + 88) = v61;
        {
          operator new();
        }
        uint64_t v62 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                            + 16))(mdm::Allocator::instance(void)::alloc, 12 * v61, 8);
        *(void *)(v60 + 72) = v62;
        *(unsigned char *)(v60 + 64) = 1;
      }
      else
      {
        uint64_t v62 = 0;
      }
      v63.i64[0] = v120 * (v57 % v58);
      v63.i64[1] = v57 / v58;
      *(_WORD *)(v60 + 96) = 0;
      *(void *)uint64_t v60 = &unk_1EF533448;
      *(float32x2_t *)(v60 + 100) = vcvt_f32_f64(vdivq_f64(vaddq_f64(vcvtq_f64_f32(vcvt_f32_f64(vcvtq_f64_u64(v63))), v116), vcvtq_f64_u64(v121)));
      *(_OWORD *)(v60 + 108) = xmmword_1A28FEA20;
      *(_DWORD *)(v60 + 124) = 2139095039;
      *(_WORD *)(v60 + 132) = 0;
      if (v123)
      {
        *(float *)(v60 + 136) = *v123;
        *(float *)(v60 + 140) = v123[1];
        *(unsigned char *)(v60 + 132) = 1;
      }
      if (v122)
      {
        *(_DWORD *)(v60 + 144) = v122->i32[0];
        *(_DWORD *)(v60 + 148) = v122->i32[1];
        *(unsigned char *)(v60 + 133) = 1;
      }
      *(_WORD *)(v60 + 96) = 0;
      unint64_t v64 = v25 + 96 * v20;
      *(_DWORD *)(v60 + 108) = *(_DWORD *)(v64 + 88);
      *(float *)(v60 + 112) = v33;
      *(float *)(v60 + 116) = v34;
      *(float *)(v60 + 120) = v35;
      *(float *)(v60 + 124) = v36;
      *(_DWORD *)(v60 + 128) = *(_DWORD *)(v64 + 84);
      int v65 = *v29;
      *(void *)uint64_t v62 = *v28;
      *(_DWORD *)(v62 + 8) = v65;
      unint64_t v66 = v130;
      if (v130 >= 2)
      {
        unint64_t v67 = 0;
        float v68 = 0.0;
        uint64_t v69 = 1;
        uint64_t v70 = 1;
        do
        {
          uint64_t v74 = (float *)&v28[v69];
          long long v75 = (float32x2_t *)&v28[v69 - 1];
          v76.f32[0] = *v74;
          float v71 = v74[1];
          float v77 = sqrtf((float)((float)(*v74 - v75->f32[0]) * (float)(*v74 - v75->f32[0]))+ (float)((float)(v71 - v75->f32[1]) * (float)(v71 - v75->f32[1])));
          float v78 = v77 + v68;
          if (v67 < v41)
          {
            long long v79 = (float *)(v62 + 8 + 12 * v70);
            float v80 = 1.0 / v77;
            while (1)
            {
              float v81 = v40[v67];
              v76.f32[0] = *v74;
              if (v78 < v81) {
                break;
              }
              float v82 = fminf(fmaxf((float)(v81 - v68) * v80, 0.0), 1.0);
              float v83 = *(float *)&v29[v69 - 1] + (float)((float)(*(float *)&v29[v69] - *(float *)&v29[v69 - 1]) * v82);
              v76.f32[1] = v74[1];
              *((float32x2_t *)v79 - 1) = vmla_n_f32(*v75, vsub_f32(v76, *v75), v82);
              *long long v79 = v83;
              v79 += 3;
              ++v70;
              if (v41 == ++v67)
              {
                v76.f32[0] = *v74;
                unint64_t v67 = v41;
                break;
              }
            }
            float v71 = v74[1];
          }
          int v72 = v29[v69];
          uint64_t v73 = v62 + 12 * v70;
          *(_DWORD *)uint64_t v73 = v76.i32[0];
          *(float *)(v73 + 4) = v71;
          *(_DWORD *)(v73 + 8) = v72;
          ++v70;
          ++v69;
          float v68 = v78;
        }
        while (v69 != v66);
      }
      md::Ribbons::RibbonWriter<md::Ribbons::TransitRibbonDescriptor>::computeMeshSize(v60, v134, &__p);
      uint64_t v85 = *(void *)(v60 + 8);
      uint64_t v84 = *(void *)(v60 + 16);
      if ((unint64_t)(v84 + v125 - v85) >= 0x10000) {
        operator new();
      }
      uint64_t v86 = *(void *)(*(void *)(a2 + 640) - 8);
      long long v126 = (void (***)(void))v60;
      uint64_t v87 = *(uint64_t **)(v86 + 64);
      unint64_t v88 = *(void *)(v86 + 72);
      if ((unint64_t)v87 < v88)
      {
        if (v87)
        {
          long long v126 = 0;
          *uint64_t v87 = v60;
        }
        long long v89 = v87 + 1;
        goto LABEL_96;
      }
      uint64_t v90 = *(void *)(v86 + 56);
      uint64_t v91 = ((uint64_t)v87 - v90) >> 3;
      unint64_t v92 = v91 + 1;
      if ((unint64_t)(v91 + 1) >> 61) {
        abort();
      }
      uint64_t v93 = v88 - v90;
      if (v93 >> 2 > v92) {
        unint64_t v92 = v93 >> 2;
      }
      if ((unint64_t)v93 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v94 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v94 = v92;
      }
      if (v94)
      {
        uint64_t v95 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v86 + 80) + 16))(*(void *)(v86 + 80), 8 * v94, 8);
        uint64_t v96 = (uint64_t *)(v95 + 8 * v91);
        uint64_t v97 = v95 + 8 * v94;
        if (v95)
        {
          long long v126 = 0;
          *uint64_t v96 = v60;
        }
      }
      else
      {
        uint64_t v97 = 0;
        uint64_t v96 = (uint64_t *)(8 * v91);
      }
      long long v89 = v96 + 1;
      unint64_t v98 = *(char **)(v86 + 56);
      unint64_t v99 = *(char **)(v86 + 64);
      if (v99 == v98)
      {
        *(void *)(v86 + 56) = v96;
        *(void *)(v86 + 64) = v89;
        uint64_t v105 = *(void *)(v86 + 72);
        *(void *)(v86 + 72) = v97;
        if (!v99) {
          goto LABEL_96;
        }
        goto LABEL_95;
      }
      unint64_t v100 = v99 - v98 - 8;
      if (v100 > 0x57
        && ((unint64_t v101 = (v98 - v99 + 7) & 0xFFFFFFFFFFFFFFF8, &v99[v101] >= (char *)v96) || (char *)v96 + v101 >= v99))
      {
        uint64_t v108 = (v100 >> 3) + 1;
        unint64_t v102 = &v99[-8 * (v108 & 0x3FFFFFFFFFFFFFFCLL)];
        char v109 = v96 - 2;
        uint64_t v110 = v99 - 32;
        uint64_t v111 = v108 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v113 = *(_OWORD *)v110;
          long long v112 = *((_OWORD *)v110 + 1);
          *(_OWORD *)uint64_t v110 = 0uLL;
          *((_OWORD *)v110 + 1) = 0uLL;
          v110 -= 32;
          *((_OWORD *)v109 - 1) = v113;
          *(_OWORD *)char v109 = v112;
          v109 -= 4;
          v111 -= 4;
        }
        while (v111);
        v96 -= v108 & 0x3FFFFFFFFFFFFFFCLL;
        if (v108 == (v108 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_85:
          unint64_t v99 = *(char **)(v86 + 56);
          unint64_t v104 = *(char **)(v86 + 64);
          *(void *)(v86 + 56) = v96;
          *(void *)(v86 + 64) = v89;
          uint64_t v105 = *(void *)(v86 + 72);
          *(void *)(v86 + 72) = v97;
          if (v104 != v99)
          {
            uint64_t v124 = v105;
            do
            {
              uint64_t v107 = (void (***)(void))*((void *)v104 - 1);
              v104 -= 8;
              double v106 = v107;
              *(void *)unint64_t v104 = 0;
              if (v107)
              {
                (**v106)(v106);
                {
                  operator new();
                }
                (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                        + 40))(mdm::Allocator::instance(void)::alloc, v106, 152);
              }
            }
            while (v104 != v99);
            uint64_t v105 = v124;
          }
          if (!v99) {
            goto LABEL_96;
          }
LABEL_95:
          (*(void (**)(void, char *, uint64_t))(**(void **)(v86 + 80) + 40))(*(void *)(v86 + 80), v99, v105 - (void)v99);
LABEL_96:
          *(void *)(v86 + 64) = v89;
          if (v126)
          {
            (**v126)(v126);
            {
              operator new();
            }
            (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                    + 40))(mdm::Allocator::instance(void)::alloc, v126, 152);
          }
          if (v40) {
            operator delete(v40);
          }
          uint64_t v10 = v84 + v125 - v85;
          unint64_t v6 = a1;
LABEL_15:
          operator delete(v29);
          goto LABEL_16;
        }
      }
      else
      {
        unint64_t v102 = *(char **)(v86 + 64);
      }
      do
      {
        uint64_t v103 = *((void *)v102 - 1);
        v102 -= 8;
        *(void *)unint64_t v102 = 0;
        *--uint64_t v96 = v103;
      }
      while (v102 != v98);
      goto LABEL_85;
    }
LABEL_16:
    ++v20;
    uint64_t v19 = *(uint64_t **)(v6 + 8);
  }
  while (v20 < *(unsigned int *)(*v19 + 20));
  if (__p.__begin_) {
    operator delete(__p.__begin_);
  }
LABEL_115:
  if (v134[0]) {
    operator delete(v134[0]);
  }
}

void sub_1A2385B70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,int a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p)
{
  std::unique_ptr<md::Ribbons::RibbonSection<md::Ribbons::TransitRibbonDescriptor>>::reset[abi:nn180100](&a28);
  long long v40 = (mdm::Allocator *)(**v35)(v35);
  uint64_t v41 = mdm::Allocator::instance(v40);
  (*(void (**)(uint64_t, uint64_t (***)(void), uint64_t))(*(void *)v41 + 40))(v41, v35, 152);
  if (v37)
  {
    a30 = (uint64_t)v37;
    operator delete(v37);
  }
  operator delete(v36);
  if (__p)
  {
    operator delete(__p);
    long long v42 = *(void **)(v38 - 176);
    if (!v42) {
LABEL_5:
    }
      _Unwind_Resume(a1);
  }
  else
  {
    long long v42 = *(void **)(v38 - 176);
    if (!v42) {
      goto LABEL_5;
    }
  }
  operator delete(v42);
  _Unwind_Resume(a1);
}

void addEasingPointsInRegion(uint64_t a1, uint64_t a2, float a3, float a4)
{
  float v7 = *(float *)(a1 + 88) + -0.001;
  if (a3 > 0.001 && v7 > a3)
  {
    unint64_t v11 = *(float **)(a2 + 8);
    unint64_t v10 = *(void *)(a2 + 16);
    if ((unint64_t)v11 >= v10)
    {
      uint64_t v13 = *(float **)a2;
      uint64_t v14 = (uint64_t)v11 - *(void *)a2;
      uint64_t v15 = v14 >> 2;
      unint64_t v16 = (v14 >> 2) + 1;
      if (v16 >> 62) {
        goto LABEL_54;
      }
      uint64_t v17 = v10 - (void)v13;
      if (v17 >> 1 > v16) {
        unint64_t v16 = v17 >> 1;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        if (v18 >> 62) {
          goto LABEL_55;
        }
        uint64_t v19 = operator new(4 * v18);
      }
      else
      {
        uint64_t v19 = 0;
      }
      unint64_t v20 = (float *)&v19[4 * v15];
      uint64_t v21 = &v19[4 * v18];
      float *v20 = a3;
      uint64_t v12 = v20 + 1;
      if (v11 != v13)
      {
        unint64_t v22 = (char *)v11 - (char *)v13 - 4;
        if (v22 < 0x2C) {
          goto LABEL_58;
        }
        if ((unint64_t)((char *)v11 - v19 - v14) < 0x20) {
          goto LABEL_58;
        }
        uint64_t v23 = (v22 >> 2) + 1;
        unint64_t v24 = &v19[4 * v15 - 16];
        uint64_t v25 = v11 - 4;
        uint64_t v26 = v23 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v27 = *(_OWORD *)v25;
          *(v24 - 1) = *((_OWORD *)v25 - 1);
          *unint64_t v24 = v27;
          v24 -= 2;
          v25 -= 8;
          v26 -= 8;
        }
        while (v26);
        v20 -= v23 & 0x7FFFFFFFFFFFFFF8;
        v11 -= v23 & 0x7FFFFFFFFFFFFFF8;
        if (v23 != (v23 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_58:
          do
          {
            int v28 = *((_DWORD *)v11-- - 1);
            *((_DWORD *)v20-- - 1) = v28;
          }
          while (v11 != v13);
        }
      }
      *(void *)a2 = v20;
      *(void *)(a2 + 8) = v12;
      *(void *)(a2 + 16) = v21;
      if (v13) {
        operator delete(v13);
      }
    }
    else
    {
      *unint64_t v11 = a3;
      uint64_t v12 = v11 + 1;
    }
    *(void *)(a2 + 8) = v12;
    float v7 = *(float *)(a1 + 88) + -0.001;
  }
  if (a4 > 0.001 && v7 > a4)
  {
    long long v31 = *(float **)(a2 + 8);
    unint64_t v30 = *(void *)(a2 + 16);
    if ((unint64_t)v31 < v30)
    {
      *long long v31 = a4;
      float v32 = v31 + 1;
LABEL_52:
      *(void *)(a2 + 8) = v32;
      return;
    }
    float v33 = *(float **)a2;
    uint64_t v34 = (uint64_t)v31 - *(void *)a2;
    uint64_t v35 = v34 >> 2;
    unint64_t v36 = (v34 >> 2) + 1;
    if (!(v36 >> 62))
    {
      uint64_t v37 = v30 - (void)v33;
      if (v37 >> 1 > v36) {
        unint64_t v36 = v37 >> 1;
      }
      if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v38 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v38 = v36;
      }
      if (!v38)
      {
        uint64_t v39 = 0;
LABEL_43:
        long long v40 = (float *)&v39[4 * v35];
        uint64_t v41 = &v39[4 * v38];
        float *v40 = a4;
        float v32 = v40 + 1;
        if (v31 != v33)
        {
          unint64_t v42 = (char *)v31 - (char *)v33 - 4;
          if (v42 < 0x2C) {
            goto LABEL_59;
          }
          if ((unint64_t)((char *)v31 - &v39[v34]) < 0x20) {
            goto LABEL_59;
          }
          uint64_t v43 = (v42 >> 2) + 1;
          long long v44 = &v39[4 * v35 - 16];
          float v45 = v31 - 4;
          uint64_t v46 = v43 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v47 = *(_OWORD *)v45;
            *(v44 - 1) = *((_OWORD *)v45 - 1);
            _OWORD *v44 = v47;
            v44 -= 2;
            v45 -= 8;
            v46 -= 8;
          }
          while (v46);
          v40 -= v43 & 0x7FFFFFFFFFFFFFF8;
          v31 -= v43 & 0x7FFFFFFFFFFFFFF8;
          if (v43 != (v43 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_59:
            do
            {
              int v48 = *((_DWORD *)v31-- - 1);
              *((_DWORD *)v40-- - 1) = v48;
            }
            while (v31 != v33);
          }
        }
        *(void *)a2 = v40;
        *(void *)(a2 + 8) = v32;
        *(void *)(a2 + 16) = v41;
        if (v33) {
          operator delete(v33);
        }
        goto LABEL_52;
      }
      if (!(v38 >> 62))
      {
        uint64_t v39 = operator new(4 * v38);
        goto LABEL_43;
      }
LABEL_55:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_54:
    abort();
  }
}

void md::Ribbons::RibbonWriter<md::Ribbons::TransitRibbonDescriptor>::computeMeshSize(uint64_t a1, float **a2, std::vector<unsigned int> *a3)
{
  unint64_t v50 = 1;
  md::Ribbons::RibbonWriter<md::Ribbons::DaVinciTrafficRibbonDescriptor>::eliminateDuplicates(a1, (uint64_t)a2, a3, (uint64_t *)&v50);
  unint64_t v5 = v50;
  unint64_t v6 = v50 - 2;
  if (v50 >= 2)
  {
    float v7 = *a2;
    uint64_t v8 = v7 + 3;
    float v9 = *v7;
    uint64_t v10 = 1;
    uint64_t v49 = a1;
    while (1)
    {
      if (vabds_f32(*v8, v9) >= 1.0e-10)
      {
        float v15 = v8[1] - v7[1];
        goto LABEL_9;
      }
      float v11 = v7[1];
      float v12 = v8[1];
      if (vabds_f32(v12, v11) >= 1.0e-10) {
        break;
      }
      ++v10;
      v8 += 3;
      if (v50 == v10)
      {
        float v13 = 0.0;
        float v14 = 1.0;
        goto LABEL_10;
      }
    }
    float v15 = v12 - v11;
LABEL_9:
    float v16 = *v8 - v9;
    float v17 = 1.0 / sqrtf((float)(v16 * v16) + (float)(v15 * v15));
    float v14 = v17 * v16;
    float v13 = v17 * v15;
LABEL_10:
    unint64_t v18 = v50 - 1;
    if (v50 - 1 >= 2)
    {
      uint64_t v19 = v7 + 7;
      uint64_t v20 = 1;
      uint64_t v21 = 2;
      while (1)
      {
        float v26 = v14;
        float v27 = v13;
        uint64_t v28 = v20 + 1;
        if (v20 + 1 < v5)
        {
          uint64_t v29 = &v7[3 * v20];
          float v30 = *v29;
          float v31 = v29[1];
          float v32 = v19;
          unint64_t v33 = v6;
          while (1)
          {
            float v34 = *(v32 - 1);
            float v35 = vabds_f32(*v32, v31);
            if (vabds_f32(v34, v30) >= 1.0e-10 || v35 >= 1.0e-10) {
              break;
            }
            v32 += 3;
            if (!--v33) {
              goto LABEL_26;
            }
          }
          float v37 = v34 - v30;
          float v38 = *v32 - v31;
          float v39 = 1.0 / sqrtf((float)(v37 * v37) + (float)(v38 * v38));
          float v14 = v39 * v37;
          float v13 = v39 * v38;
        }
LABEL_26:
        float v40 = atan2f(v13, v14);
        float v23 = v40 - atan2f(v27, v26);
        double v41 = v23;
        if (v23 > 3.14159265)
        {
          double v22 = -6.28318531;
        }
        else
        {
          if (v41 >= -3.14159265) {
            goto LABEL_14;
          }
          double v22 = 6.28318531;
        }
        float v23 = v41 + v22;
LABEL_14:
        float v24 = fmaxf(ceilf(fabsf(v23) * 0.64377), 1.0);
        if ((unint64_t)v24 >= 2) {
          unint64_t v25 = 2 * (unint64_t)v24;
        }
        else {
          unint64_t v25 = 2;
        }
        v21 += v25;
        --v6;
        v19 += 3;
        uint64_t v20 = v28;
        if (v28 == v18) {
          goto LABEL_30;
        }
      }
    }
    uint64_t v21 = 2;
LABEL_30:
    uint64_t v42 = 2;
    if (*(unsigned char *)(v49 + 96)) {
      uint64_t v42 = 4;
    }
    unint64_t v43 = v42 + v21;
    if (*(unsigned char *)(v49 + 97)) {
      v43 += 2;
    }
    if (v43 < 0x10000)
    {
      if (*(unsigned char *)(v49 + 96)) {
        uint64_t v47 = -1;
      }
      else {
        uint64_t v47 = 0;
      }
      unint64_t v48 = ((v43 + 2 * (v47 - (*(unsigned char *)(v49 + 97) != 0))) & 0xFFFFFFFFFFFFFFFELL) + *(void *)(v49 + 40);
      unint64_t v44 = *(void *)(v49 + 8) + v43;
      uint64_t v45 = 3 * v43 + *(void *)(v49 + 24) - 6;
      unint64_t v46 = v48 - 2;
    }
    else
    {
      unint64_t v44 = *(void *)(v49 + 8);
      uint64_t v45 = *(void *)(v49 + 24);
      unint64_t v46 = *(void *)(v49 + 40);
    }
    *(void *)(v49 + 16) = v44;
    *(void *)(v49 + 32) = v45;
    *(void *)(v49 + 48) = v46;
  }
}

void (****std::unique_ptr<md::TransitRibbon,mdm::TypeDeleter<md::TransitRibbon>>::~unique_ptr[abi:nn180100](void (****a1)(void)))(void)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    (**v2)(v2);
    uint64_t v3 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      uint64_t v3 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      if (v5) {
        operator new();
      }
    }
    (*(void (**)(void, void (***)(void), uint64_t))(**((void **)v3 + 91) + 40))(*((void *)v3 + 91), v2, 152);
  }
  return a1;
}

void md::TransitRibbon::~TransitRibbon(md::TransitRibbon *this)
{
  *(void *)this = &unk_1EF553D90;
  if (*((unsigned char *)this + 64))
  {
    uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      if (v3) {
        operator new();
      }
    }
    (*(void (**)(void, void, void))(**((void **)v2 + 91) + 40))(*((void *)v2 + 91), *((void *)this + 9), 0);
  }
  JUMPOUT(0x1A6239270);
}

{
  float *v2;
  int v3;

  *(void *)this = &unk_1EF553D90;
  if (*((unsigned char *)this + 64))
  {
    uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      if (v3) {
        operator new();
      }
    }
    (*(void (**)(void, void, void))(**((void **)v2 + 91) + 40))(*((void *)v2 + 91), *((void *)this + 9), 0);
  }
}

id md::TransitLineSegment::debugString(md::TransitLineSegment *this)
{
  uint64_t v2 = [MEMORY[0x1E4F28E78] string];
  [v2 appendFormat:@"Mergetype=%i, mergedIndex=%i\n", *((unsigned __int8 *)this + 52), *((unsigned int *)this + 10)];
  objc_msgSend(v2, "appendFormat:", @"Offsets: Start=%.1f Middle=%.1f End=%.1f\n", *((float *)this + 5), *((float *)this + 7), *((float *)this + 6));
  int v3 = geo::codec::transitLinkGetFromNodeID(**((void **)this + 1), *((unsigned int *)this + 9));
  uint64_t v4 = geo::codec::transitLinkGetToNodeID(**((void **)this + 1), *((unsigned int *)this + 9));
  int LineDirection = geo::codec::transitLinkGetLineDirection(**((void ***)this + 1), *((unsigned int *)this + 9));
  if (LineDirection == 1) {
    LODWORD(v6) = 80;
  }
  else {
    LODWORD(v6) = 66;
  }
  if (LineDirection == 2) {
    uint64_t v6 = 78;
  }
  else {
    uint64_t v6 = v6;
  }
  objc_msgSend(v2, "appendFormat:", @"NodeID From=%llu To=%llu Dir=%c\n", v3, v4, v6);
  return v2;
}

void sub_1A2386648(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void non-virtual thunk to'ggl::FlyoverRoad::DefaultMesh::~DefaultMesh(ggl::FlyoverRoad::DefaultMesh *this)
{
  ggl::Mesh::~Mesh((ggl::FlyoverRoad::DefaultMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::FlyoverRoad::DefaultMesh *)((char *)this - 16));
}

void ggl::FlyoverRoad::DefaultMesh::~DefaultMesh(ggl::FlyoverRoad::DefaultMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::FlyoverRoad::Default>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::FlyoverRoad::Default>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void md::PolygonSection::initialize(uint64_t a1, void *a2, unint64_t a3)
{
  unint64_t v21 = 0;
  int v5 = geo::codec::multiSectionFeaturePoints(a2, a3, &v21);
  uint64_t v6 = *(void *)(a1 + 16);
  *(void *)(a1 + 8) = v5;
  unint64_t v7 = v21;
  *(void *)(a1 + 88) = v21;
  unint64_t v8 = (*(void *)(a1 + 24) - v6) >> 3;
  BOOL v9 = v7 >= v8;
  unint64_t v10 = v7 - v8;
  if (v10 != 0 && v9)
  {
    std::vector<gm::Matrix<float,2,1>>::__append(a1 + 16, v10);
    unint64_t v7 = *(void *)(a1 + 88);
  }
  else if (!v9)
  {
    *(void *)(a1 + 24) = v6 + 8 * v7;
  }
  uint64_t v11 = *(void *)(a1 + 40);
  unint64_t v12 = (*(void *)(a1 + 48) - v11) >> 3;
  BOOL v13 = v7 >= v12;
  unint64_t v14 = v7 - v12;
  if (v14 != 0 && v13)
  {
    std::vector<gm::Matrix<float,2,1>>::__append(a1 + 40, v14);
    unint64_t v7 = *(void *)(a1 + 88);
  }
  else if (!v13)
  {
    *(void *)(a1 + 48) = v11 + 8 * v7;
  }
  std::vector<BOOL>::resize(a1 + 64, v7);
  uint64_t v15 = a2[5];
  *(void *)(a1 + 96) = v21;
  *(void *)(a1 + 104) = v15;
  uint64_t v16 = *(void *)(a1 + 112);
  uint64_t v17 = *(void *)(a1 + 120);
  unint64_t v18 = *(void *)(a1 + 88);
  std::vector<unsigned int>::value_type __x = 0;
  unint64_t v19 = (v17 - v16) >> 2;
  if (v18 <= v19)
  {
    if (v18 < v19) {
      *(void *)(a1 + 120) = v16 + 4 * v18;
    }
  }
  else
  {
    std::vector<unsigned int>::__append((std::vector<unsigned int> *)(a1 + 112), v18 - v19, &__x);
  }
}

void md::PolygonSection::calculateTangentVectors(void *a1, void *a2, uint64_t a3, uint64_t a4, double a5, __n128 a6, __n128 a7)
{
  if (a2)
  {
    unint64_t v49 = 0;
    CharacteristicPointsForSection = geo::codec::polygonFeatureGetCharacteristicPointsForSection(a2, a4, (uint64_t *)&v49);
    if (CharacteristicPointsForSection)
    {
      a1[12] = 0;
      if (a1[11])
      {
        unint64_t v9 = 0;
        unint64_t v10 = 0;
        while (1)
        {
          unint64_t v13 = v10 >> 6;
          if (v9 >= v49) {
            break;
          }
          unint64_t v14 = &CharacteristicPointsForSection[100 * v9 + 12];
          unint64_t v15 = v9;
          while (1)
          {
            int v16 = *(_DWORD *)v14;
            v14 += 100;
            if (v10 == v16) {
              break;
            }
            if (v49 == ++v15) {
              goto LABEL_12;
            }
          }
          uint64_t v11 = (void *)(a1[8] + 8 * v13);
          uint64_t v12 = 1 << v10;
          if (!CharacteristicPointsForSection[100 * v15 + 28]) {
            goto LABEL_13;
          }
          *v11 |= v12;
LABEL_7:
          ++v10;
          unint64_t v9 = v15;
          if (v10 >= a1[11]) {
            goto LABEL_14;
          }
        }
LABEL_12:
        uint64_t v11 = (void *)(a1[8] + 8 * v13);
        uint64_t v12 = 1 << v10;
        unint64_t v15 = v9;
LABEL_13:
        *v11 &= ~v12;
        ++a1[12];
        goto LABEL_7;
      }
    }
  }
LABEL_14:
  uint64_t v17 = a1[11];
  if (v17)
  {
    unint64_t v18 = 0;
    uint64_t v19 = a1[12];
    uint64_t v20 = 4;
    unint64_t v21 = a1[11];
    while (1)
    {
      unint64_t v22 = (v21 + v18 - 1) % v21;
      unint64_t v23 = v18 + 1;
      if (v18 + 1 == v21) {
        unint64_t v24 = 0;
      }
      else {
        unint64_t v24 = v18 + 1;
      }
      if (v19 == v17) {
        goto LABEL_21;
      }
      uint64_t v31 = a1[8];
      uint64_t v32 = *(void *)(v31 + ((v18 >> 3) & 0x1FFFFFFFFFFFFFF8));
      uint64_t v33 = *(void *)(v31 + ((v22 >> 3) & 0x1FFFFFFFFFFFFFF8)) & (1 << v22);
      uint64_t v34 = v32 & (1 << v18);
      if (v34 || !v33) {
        break;
      }
      GhostPoint = (float32x2_t *)geo::codec::multiSectionFeatureGetGhostPoint(a3, a4, v18);
      if (!GhostPoint) {
        goto LABEL_21;
      }
      uint64_t v35 = a1[1];
      float32x2_t v27 = *(float32x2_t *)(v35 + 8 * v18);
      float32x2_t v28 = vsub_f32(*(float32x2_t *)(v35 + 8 * v24), v27);
LABEL_23:
      float32x2_t v30 = *GhostPoint;
      a6.n128_u64[0] = (unint64_t)vmul_f32(v28, v28);
      a6.n128_f32[0] = sqrtf(vaddv_f32((float32x2_t)a6.n128_u64[0]));
      __n128 v46 = a6;
      if (a6.n128_f32[0] <= 0.00000011921)
      {
        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
        }
        unint64_t v36 = (id)GEOGetVectorKitVKDefaultLog_log;
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1A1780000, v36, OS_LOG_TYPE_ERROR, "Zero Length edge on polygon boundary", buf, 2u);
        }
      }
      else
      {
        *(float32x2_t *)(a1[2] + 8 * v18) = vdiv_f32(v28, (float32x2_t)vdup_lane_s32((int32x2_t)a6.n128_u64[0], 0));
      }
      float32x2_t v37 = vsub_f32(v27, v30);
      a7.n128_f32[0] = sqrtf(vaddv_f32(vmul_f32(v37, v37)));
      if (a7.n128_f32[0] <= 0.00000011921)
      {
        __n128 v45 = a7;
        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
        }
        float v39 = (id)GEOGetVectorKitVKDefaultLog_log;
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v47 = 0;
          _os_log_impl(&dword_1A1780000, v39, OS_LOG_TYPE_ERROR, "Zero Length edge on polygon boundary", v47, 2u);
        }

        a7 = v45;
        float32x2_t v38 = (float32x2_t)0x3F80000000000000;
        if (v46.n128_f32[0] > 0.00000011921) {
          goto LABEL_43;
        }
      }
      else
      {
        float32x2_t v38 = vdiv_f32(v37, (float32x2_t)vdup_lane_s32((int32x2_t)a7.n128_u64[0], 0));
        *(float32x2_t *)(a1[5] + 8 * v18) = v38;
        a6.n128_u64[1] = v46.n128_u64[1];
        if (v46.n128_f32[0] > 0.00000011921) {
          goto LABEL_43;
        }
      }
      *(float32x2_t *)(a1[2] + 8 * v18) = v38;
LABEL_43:
      if (a7.n128_f32[0] <= 0.00000011921)
      {
        float v40 = (_DWORD *)(a1[2] + v20);
        double v41 = (_DWORD *)(a1[5] + v20);
        *(v41 - 1) = *(v40 - 1);
        _DWORD *v41 = *v40;
      }
      unint64_t v21 = a1[11];
      v20 += 8;
      ++v18;
      if (v23 >= v21) {
        return;
      }
    }
    if (v34 && !v33 && (uint64_t v42 = (float32x2_t *)geo::codec::multiSectionFeatureGetGhostPoint(a3, a4, v18)) != 0)
    {
      uint64_t v25 = a1[1];
      float32x2_t v26 = *v42;
    }
    else
    {
LABEL_21:
      uint64_t v25 = a1[1];
      float32x2_t v26 = *(float32x2_t *)(v25 + 8 * v24);
    }
    float32x2_t v27 = *(float32x2_t *)(v25 + 8 * v18);
    float32x2_t v28 = vsub_f32(v26, v27);
    GhostPoint = (float32x2_t *)(v25 + 8 * v22);
    goto LABEL_23;
  }
}

uint64_t md::PolygonSection::PolygonSection(uint64_t a1, void *a2, unint64_t a3)
{
  *(void *)a1 = &unk_1EF534428;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_DWORD *)(a1 + 136) = 0;
  md::PolygonSection::initialize(a1, a2, a3);
  md::PolygonSection::calculateTangentVectors((void *)a1, 0, (uint64_t)a2, a3, v6, v7, v8);
  return a1;
}

void sub_1A2386CB4(_Unwind_Exception *exception_object)
{
  int v3 = (void *)v1[14];
  if (v3)
  {
    v1[15] = v3;
    operator delete(v3);
    uint64_t v4 = (void *)v1[8];
    if (!v4)
    {
LABEL_3:
      int v5 = (void *)v1[5];
      if (!v5) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v4 = (void *)v1[8];
    if (!v4) {
      goto LABEL_3;
    }
  }
  operator delete(v4);
  int v5 = (void *)v1[5];
  if (!v5)
  {
LABEL_4:
    double v6 = (void *)v1[2];
    if (!v6) {
      goto LABEL_5;
    }
    goto LABEL_9;
  }
LABEL_8:
  v1[6] = v5;
  operator delete(v5);
  double v6 = (void *)v1[2];
  if (!v6) {
LABEL_5:
  }
    _Unwind_Resume(exception_object);
LABEL_9:
  v1[3] = v6;
  operator delete(v6);
  _Unwind_Resume(exception_object);
}

void *md::PolygonSection::PolygonSection(uint64_t a1, void *a2, unint64_t a3)
{
  uint64_t v3 = a3;
  int v5 = (void *)a1;
  *(void *)a1 = &unk_1EF534428;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_DWORD *)(a1 + 136) = 0;
  md::PolygonSection::initialize(a1, a2, a3);
  md::PolygonSection::calculateTangentVectors(v5, a2, (uint64_t)a2, v3, v6, v7, v8);
  unint64_t v73 = 0;
  StrokeSpecifications = geo::codec::polygonFeatureGetStrokeSpecifications(a2, (uint64_t *)&v73);
  unint64_t v9 = v73;
  if (!v73) {
    return v5;
  }
  float v71 = 0;
  uint64_t v72 = 0;
  unint64_t v10 = operator new(0x28uLL);
  unint64_t v11 = 0;
  *unint64_t v10 = 0;
  v10[1] = 0;
  v10[2] = &v71;
  uint64_t v70 = v10;
  float v71 = v10;
  uint64_t v12 = 1;
  *((unsigned char *)v10 + 24) = 1;
  uint64_t v72 = 1;
  *((_DWORD *)v10 + 7) = 0;
  *((_DWORD *)v10 + 8) = 0;
  do
  {
    unint64_t v13 = v9;
    unsigned int v14 = *(_DWORD *)&StrokeSpecifications[16 * v11 + 12];
    unint64_t v15 = &v71;
    int v16 = &v71;
    if (v71)
    {
      uint64_t v17 = &v71;
      unint64_t v18 = v71;
      do
      {
        uint64_t v19 = v18;
        uint64_t v20 = v17;
        unsigned int v21 = *((_DWORD *)v18 + 7);
        if (v21 >= v14) {
          uint64_t v17 = (uint64_t **)v18;
        }
        else {
          ++v18;
        }
        unint64_t v18 = (uint64_t *)*v18;
      }
      while (v18);
      if (v17 != &v71)
      {
        if (v21 < v14) {
          uint64_t v19 = (uint64_t *)v20;
        }
        if (v14 >= *((_DWORD *)v19 + 7))
        {
          unint64_t v9 = v13;
          goto LABEL_4;
        }
      }
      unint64_t v22 = v71;
      while (1)
      {
        while (1)
        {
          int v16 = (uint64_t **)v22;
          unsigned int v23 = *((_DWORD *)v22 + 7);
          if (v14 >= v23) {
            break;
          }
          unint64_t v22 = *v16;
          unint64_t v15 = v16;
          if (!*v16) {
            goto LABEL_21;
          }
        }
        if (v23 >= v14) {
          break;
        }
        unint64_t v22 = v16[1];
        if (!v22)
        {
          unint64_t v15 = v16 + 1;
          goto LABEL_21;
        }
      }
      uint64_t v26 = v12;
      unint64_t v24 = v16;
      unint64_t v9 = v13;
    }
    else
    {
LABEL_21:
      unint64_t v24 = operator new(0x28uLL);
      v24[7] = v14;
      v24[8] = 0;
      *(void *)unint64_t v24 = 0;
      *((void *)v24 + 1) = 0;
      *((void *)v24 + 2) = v16;
      *unint64_t v15 = (uint64_t *)v24;
      uint64_t v25 = (uint64_t *)v24;
      if (*v70)
      {
        uint64_t v70 = (void *)*v70;
        uint64_t v25 = *v15;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v71, v25);
      unint64_t v9 = v73;
      uint64_t v26 = ++v72;
    }
    v24[8] = v12;
    uint64_t v12 = v26;
LABEL_4:
    ++v11;
  }
  while (v11 < v9);
  if (v9)
  {
    uint64_t v69 = v5;
    uint64_t v27 = 0;
    unsigned int v28 = 0;
    unsigned int v66 = 0;
    char v67 = 1;
    uint64_t v64 = v3;
    do
    {
      uint64_t v29 = &StrokeSpecifications[16 * v27];
      if (*((_DWORD *)v29 + 1) == v3)
      {
        unsigned int v32 = *((_DWORD *)v29 + 2);
        uint64_t v31 = (unsigned int *)(v29 + 8);
        unsigned int v30 = v32;
        if (v67)
        {
          unsigned int v28 = *(_DWORD *)&StrokeSpecifications[16 * v27 + 12];
          unsigned int v66 = v30;
        }
        else if (v66 < v30)
        {
          unint64_t v65 = v9;
          unint64_t v33 = v66;
          do
          {
            uint64_t v35 = &v71;
            unint64_t v36 = &v71;
            if (v71)
            {
              float32x2_t v37 = v71;
              while (1)
              {
                while (1)
                {
                  unint64_t v36 = (uint64_t **)v37;
                  unsigned int v38 = *((_DWORD *)v37 + 7);
                  if (v28 >= v38) {
                    break;
                  }
                  float32x2_t v37 = *v36;
                  uint64_t v35 = v36;
                  if (!*v36) {
                    goto LABEL_46;
                  }
                }
                if (v38 >= v28) {
                  break;
                }
                float32x2_t v37 = v36[1];
                if (!v37)
                {
                  uint64_t v35 = v36 + 1;
                  goto LABEL_46;
                }
              }
              int v34 = *((_DWORD *)v36 + 8);
            }
            else
            {
LABEL_46:
              float v39 = (uint64_t *)operator new(0x28uLL);
              *((_DWORD *)v39 + 7) = v28;
              *((_DWORD *)v39 + 8) = 0;
              uint64_t *v39 = 0;
              v39[1] = 0;
              v39[2] = (uint64_t)v36;
              *uint64_t v35 = v39;
              if (*v70)
              {
                uint64_t v70 = (void *)*v70;
                float v39 = *v35;
              }
              float v40 = v71;
              BOOL v41 = v39 == v71;
              *((unsigned char *)v39 + 24) = v39 == v71;
              if (!v41)
              {
                do
                {
                  uint64_t v42 = v39[2];
                  if (*(unsigned char *)(v42 + 24)) {
                    break;
                  }
                  unint64_t v43 = *(uint64_t **)(v42 + 16);
                  uint64_t v44 = *v43;
                  if (*v43 == v42)
                  {
                    uint64_t v47 = v43[1];
                    if (!v47 || (v48 = *(unsigned __int8 *)(v47 + 24), __n128 v45 = (unsigned char *)(v47 + 24), v48))
                    {
                      if (*(uint64_t **)v42 == v39)
                      {
                        uint64_t v49 = v39[2];
                      }
                      else
                      {
                        uint64_t v49 = *(void *)(v42 + 8);
                        uint64_t v50 = *(void *)v49;
                        *(void *)(v42 + 8) = *(void *)v49;
                        if (v50)
                        {
                          *(void *)(v50 + 16) = v42;
                          unint64_t v43 = *(uint64_t **)(v42 + 16);
                        }
                        *(void *)(v49 + 16) = v43;
                        *(void *)(*(void *)(v42 + 16) + 8 * (**(void **)(v42 + 16) != v42)) = v49;
                        *(void *)uint64_t v49 = v42;
                        *(void *)(v42 + 16) = v49;
                        unint64_t v43 = *(uint64_t **)(v49 + 16);
                        uint64_t v42 = *v43;
                      }
                      *(unsigned char *)(v49 + 24) = 1;
                      *((unsigned char *)v43 + 24) = 0;
                      uint64_t v53 = *(void *)(v42 + 8);
                      uint64_t *v43 = v53;
                      if (v53) {
                        *(void *)(v53 + 16) = v43;
                      }
                      *(void *)(v42 + 16) = v43[2];
                      *(void *)(v43[2] + 8 * (*(void *)v43[2] != (void)v43)) = v42;
                      *(void *)(v42 + 8) = v43;
                      goto LABEL_36;
                    }
                  }
                  else if (!v44 || (v46 = *(unsigned __int8 *)(v44 + 24), __n128 v45 = (unsigned char *)(v44 + 24), v46))
                  {
                    if (*(uint64_t **)v42 == v39)
                    {
                      uint64_t v51 = v39[1];
                      *(void *)uint64_t v42 = v51;
                      if (v51)
                      {
                        *(void *)(v51 + 16) = v42;
                        unint64_t v43 = *(uint64_t **)(v42 + 16);
                      }
                      v39[2] = (uint64_t)v43;
                      *(void *)(*(void *)(v42 + 16) + 8 * (**(void **)(v42 + 16) != v42)) = v39;
                      v39[1] = v42;
                      *(void *)(v42 + 16) = v39;
                      unint64_t v43 = (uint64_t *)v39[2];
                    }
                    else
                    {
                      float v39 = (uint64_t *)v39[2];
                    }
                    *((unsigned char *)v39 + 24) = 1;
                    *((unsigned char *)v43 + 24) = 0;
                    uint64_t v42 = v43[1];
                    float32x2_t v52 = *(uint64_t **)v42;
                    v43[1] = *(void *)v42;
                    if (v52) {
                      v52[2] = (uint64_t)v43;
                    }
                    *(void *)(v42 + 16) = v43[2];
                    *(void *)(v43[2] + 8 * (*(void *)v43[2] != (void)v43)) = v42;
                    *(void *)uint64_t v42 = v43;
LABEL_36:
                    v43[2] = v42;
                    break;
                  }
                  *(unsigned char *)(v42 + 24) = 1;
                  float v39 = v43;
                  *((unsigned char *)v43 + 24) = v43 == v40;
                  unsigned char *v45 = 1;
                }
                while (v43 != v40);
              }
              int v34 = 0;
              uint64_t v72 = ++v12;
            }
            *(_DWORD *)(v69[14] + 4 * v33++) = v34;
          }
          while (v33 < *v31);
          uint64_t v3 = v64;
          unint64_t v9 = v65;
        }
        v67 ^= 1u;
      }
      ++v27;
    }
    while (v27 != v9);
    int v5 = v69;
    unsigned int v54 = v66;
    if ((v67 & 1) == 0)
    {
      unint64_t v56 = v66;
      unint64_t v57 = v69[11];
      while (v57 > v56)
      {
        unint64_t v58 = &v71;
        uint64_t v59 = &v71;
        if (v71)
        {
          uint64_t v60 = v71;
          while (1)
          {
            while (1)
            {
              uint64_t v59 = (uint64_t **)v60;
              unsigned int v61 = *((_DWORD *)v60 + 7);
              if (v28 >= v61) {
                break;
              }
              uint64_t v60 = *v59;
              unint64_t v58 = v59;
              if (!*v59) {
                goto LABEL_90;
              }
            }
            if (v61 >= v28) {
              break;
            }
            uint64_t v60 = v59[1];
            if (!v60)
            {
              unint64_t v58 = v59 + 1;
              goto LABEL_90;
            }
          }
          uint64_t v62 = v59;
        }
        else
        {
LABEL_90:
          uint64_t v62 = operator new(0x28uLL);
          v62[7] = v28;
          v62[8] = 0;
          *(void *)uint64_t v62 = 0;
          *((void *)v62 + 1) = 0;
          *((void *)v62 + 2) = v59;
          *unint64_t v58 = (uint64_t *)v62;
          uint64x2_t v63 = (uint64_t *)v62;
          if (*v70)
          {
            uint64_t v70 = (void *)*v70;
            uint64x2_t v63 = *v58;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v71, v63);
          ++v72;
          unint64_t v57 = v69[11];
        }
        *(_DWORD *)(v69[14] + 4 * v56) = v62[8];
        unint64_t v56 = ++v54;
      }
    }
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v71);
  return v5;
}

void sub_1A23872D4(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(0);
  uint64_t v3 = (void *)v1[14];
  if (v3)
  {
    v1[15] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)v1[8];
  if (v4) {
    operator delete(v4);
  }
  int v5 = (void *)v1[5];
  if (v5)
  {
    v1[6] = v5;
    operator delete(v5);
    double v6 = (void *)v1[2];
    if (!v6) {
LABEL_7:
    }
      _Unwind_Resume(a1);
  }
  else
  {
    double v6 = (void *)v1[2];
    if (!v6) {
      goto LABEL_7;
    }
  }
  v1[3] = v6;
  operator delete(v6);
  _Unwind_Resume(a1);
}

void md::BorderLabelPart::debugCompositeClassName(char *a1@<X8>)
{
  a1[23] = 6;
  strcpy(a1, "Border");
}

char *md::BorderLabelPart::populateDebugNode(md::BorderLabelPart *this, gdc::DebugTreeNode *a2)
{
  char v9 = 15;
  strcpy((char *)&v8, "BorderLabelPart");
  unint64_t result = gdc::DebugTreeNode::createChildNode((uint64_t)a2, &v8);
  int v5 = (uint64_t *)*((void *)this + 72);
  for (uint64_t i = (uint64_t *)*((void *)this + 73);
        v5 != i;
        unint64_t result = (char *)(*(uint64_t (**)(uint64_t, gdc::DebugTreeNode *))(*(void *)v7 + 800))(v7, a2))
  {
    uint64_t v7 = *v5++;
  }
  return result;
}

void md::BorderLabelPart::~BorderLabelPart(md::BorderLabelPart *this)
{
  md::CompositeLabelPart::~CompositeLabelPart(this);
  uint64_t v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  uint64_t v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

md::BorderLabelPart *md::BorderLabelPart::BorderLabelPart(md::BorderLabelPart *this, md::TextLabelPart *a2, md::TextLabelPart *a3)
{
  *((_DWORD *)this + 2) = 1065353216;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = this;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((void *)this + 8) = 0;
  *(_OWORD *)((char *)this + 72) = xmmword_1A28FC750;
  *((void *)this + 11) = 1065353216;
  *((_DWORD *)this + 24) = 1065353216;
  *(_OWORD *)((char *)this + 100) = 0u;
  *((_DWORD *)this + 29) = 0;
  *(_OWORD *)((char *)this + 120) = xmmword_1A28FC750;
  *(_OWORD *)((char *)this + 136) = xmmword_1A28FC750;
  *(_OWORD *)((char *)this + 152) = xmmword_1A28FC750;
  *(_OWORD *)((char *)this + 168) = xmmword_1A28FCDA0;
  *((unsigned char *)this + 224) = 0;
  *((unsigned char *)this + 200) = 0;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 257) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 280) = xmmword_1A28FCE90;
  *(_OWORD *)((char *)this + 296) = xmmword_1A28FCEA0;
  *(_OWORD *)((char *)this + 312) = xmmword_1A28FC750;
  *((void *)this + 41) = 1065353216;
  *((_DWORD *)this + 84) = 1065353216;
  *((_DWORD *)this + 89) = 0;
  *(_OWORD *)((char *)this + 340) = 0u;
  *(_OWORD *)((char *)this + 360) = xmmword_1A28FC750;
  *(_OWORD *)((char *)this + 376) = xmmword_1A28FC750;
  *(_OWORD *)((char *)this + 392) = xmmword_1A28FC750;
  *(_OWORD *)((char *)this + 408) = xmmword_1A28FCDA0;
  *((unsigned char *)this + 464) = 0;
  *(_OWORD *)((char *)this + 424) = 0u;
  *((unsigned char *)this + 440) = 0;
  *(_OWORD *)((char *)this + 497) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 520) = xmmword_1A28FCE90;
  *((_DWORD *)this + 134) = 1065353216;
  *(_OWORD *)((char *)this + 540) = 0u;
  *((_WORD *)this + 278) = 512;
  *((unsigned char *)this + 562) = 0;
  *(_DWORD *)((char *)this + 558) = 0;
  *(_WORD *)((char *)this + 563) = -1;
  *(_DWORD *)((char *)this + 565) = 0;
  *(void *)this = &unk_1EF538820;
  *((_OWORD *)this + 36) = 0u;
  *((void *)this + 74) = 0;
  int v5 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    long long v8 = a2;
    int v5 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a2 = v8;
    if (v7) {
      operator new();
    }
  }
  *((void *)this + 75) = *((void *)v5 + 91);
  *((unsigned char *)this + 608) = 0;
  *((unsigned char *)this + 616) = 0;
  *((_WORD *)this + 314) = 1;
  *((unsigned char *)this + 630) = 0;
  *(void *)this = &unk_1EF5349A0;
  md::CompositeLabelPart::addLabelPart((uint64_t)this, a2);
  md::CompositeLabelPart::addLabelPart((uint64_t)this, a3);
  return this;
}

void sub_1A2387724(_Unwind_Exception *a1)
{
  md::CompositeLabelPart::~CompositeLabelPart(v1);
  _Unwind_Resume(a1);
}

void md::Logic<md::TileSelectionLogic,md::TileSelectionContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext,md::StyleLogicContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  int v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    int v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      int v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void *std::pair<md::TileSelectionTileSetType,gdc::TileSelectionResults>::~pair(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2)
  {
    do
    {
      int v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)a1[8];
  a1[8] = 0;
  if (v4) {
    operator delete(v4);
  }
  int v5 = (void *)a1[4];
  if (v5)
  {
    do
    {
      double v6 = (void *)*v5;
      operator delete(v5);
      int v5 = v6;
    }
    while (v6);
  }
  char v7 = (void *)a1[2];
  a1[2] = 0;
  if (v7) {
    operator delete(v7);
  }
  return a1;
}

void gdc::TileSelectionResults::~TileSelectionResults(gdc::TileSelectionResults *this)
{
  uint64_t v2 = (void *)*((void *)this + 9);
  if (v2)
  {
    do
    {
      int v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)*((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v4) {
    operator delete(v4);
  }
  int v5 = (void *)*((void *)this + 3);
  if (v5)
  {
    do
    {
      double v6 = (void *)*v5;
      operator delete(v5);
      int v5 = v6;
    }
    while (v6);
  }
  char v7 = (void *)*((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v7) {
    operator delete(v7);
  }
}

void __GEOGetVectorKitTileSelectionLogicLog_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.VectorKit", "TileSelectionLogic");
  uint64_t v1 = (void *)GEOGetVectorKitTileSelectionLogicLog::log;
  GEOGetVectorKitTileSelectionLogicLog::log = (uint64_t)v0;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>,void *>>>::operator()[abi:nn180100](char a1, void *__p)
{
  if (a1)
  {
    int v3 = (void *)__p[12];
    if (v3)
    {
      do
      {
        uint64_t v4 = (void *)*v3;
        operator delete(v3);
        int v3 = v4;
      }
      while (v4);
    }
    int v5 = (void *)__p[10];
    __p[10] = 0;
    if (v5) {
      operator delete(v5);
    }
    double v6 = (void *)__p[6];
    if (v6)
    {
      do
      {
        char v7 = (void *)*v6;
        operator delete(v6);
        double v6 = v7;
      }
      while (v7);
    }
    long long v8 = (void *)__p[4];
    __p[4] = 0;
    if (v8) {
      operator delete(v8);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t std::__function::__func<md::TileSelectionLogic::processActiveTileSelection(geo::linear_set<md::TileSelectionTileSetType,std::less<md::TileSelectionTileSetType>,std::allocator<md::TileSelectionTileSetType>,std::vector<md::TileSelectionTileSetType>> const&,std::unordered_map<md::TileSelectionTileSetType,gdc::TileSelectionResults> &,md::CameraContext const&,md::TileSelectionContext &,md::LayoutContext const&,md::StyleLogicContext const&)::$_1,std::allocator<md::TileSelectionLogic::processActiveTileSelection(geo::linear_set<md::TileSelectionTileSetType,std::less<md::TileSelectionTileSetType>,std::allocator<md::TileSelectionTileSetType>,std::vector<md::TileSelectionTileSetType>> const&,std::unordered_map<md::TileSelectionTileSetType,gdc::TileSelectionResults> &,md::CameraContext const&,md::TileSelectionContext &,md::LayoutContext const&,md::StyleLogicContext const&)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51E0B0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::TileSelectionLogic::processActiveTileSelection(geo::linear_set<md::TileSelectionTileSetType,std::less<md::TileSelectionTileSetType>,std::allocator<md::TileSelectionTileSetType>,std::vector<md::TileSelectionTileSetType>> const&,std::unordered_map<md::TileSelectionTileSetType,gdc::TileSelectionResults> &,md::CameraContext const&,md::TileSelectionContext &,md::LayoutContext const&,md::StyleLogicContext const&)::$_1,std::allocator<md::TileSelectionLogic::processActiveTileSelection(geo::linear_set<md::TileSelectionTileSetType,std::less<md::TileSelectionTileSetType>,std::allocator<md::TileSelectionTileSetType>,std::vector<md::TileSelectionTileSetType>> const&,std::unordered_map<md::TileSelectionTileSetType,gdc::TileSelectionResults> &,md::CameraContext const&,md::TileSelectionContext &,md::LayoutContext const&,md::StyleLogicContext const&)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51E0B0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::TileSelectionLogic::processActiveTileSelection(geo::linear_set<md::TileSelectionTileSetType,std::less<md::TileSelectionTileSetType>,std::allocator<md::TileSelectionTileSetType>,std::vector<md::TileSelectionTileSetType>> const&,std::unordered_map<md::TileSelectionTileSetType,gdc::TileSelectionResults> &,md::CameraContext const&,md::TileSelectionContext &,md::LayoutContext const&,md::StyleLogicContext const&)::$_1,std::allocator<md::TileSelectionLogic::processActiveTileSelection(geo::linear_set<md::TileSelectionTileSetType,std::less<md::TileSelectionTileSetType>,std::allocator<md::TileSelectionTileSetType>,std::vector<md::TileSelectionTileSetType>> const&,std::unordered_map<md::TileSelectionTileSetType,gdc::TileSelectionResults> &,md::CameraContext const&,md::TileSelectionContext &,md::LayoutContext const&,md::StyleLogicContext const&)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::TileSelectionLogic::processActiveTileSelection(geo::linear_set<md::TileSelectionTileSetType,std::less<md::TileSelectionTileSetType>,std::allocator<md::TileSelectionTileSetType>,std::vector<md::TileSelectionTileSetType>> const&,std::unordered_map<md::TileSelectionTileSetType,gdc::TileSelectionResults> &,md::CameraContext const&,md::TileSelectionContext &,md::LayoutContext const&,md::StyleLogicContext const&)::$_0,std::allocator<md::TileSelectionLogic::processActiveTileSelection(geo::linear_set<md::TileSelectionTileSetType,std::less<md::TileSelectionTileSetType>,std::allocator<md::TileSelectionTileSetType>,std::vector<md::TileSelectionTileSetType>> const&,std::unordered_map<md::TileSelectionTileSetType,gdc::TileSelectionResults> &,md::CameraContext const&,md::TileSelectionContext &,md::LayoutContext const&,md::StyleLogicContext const&)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51E068;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::TileSelectionLogic::processActiveTileSelection(geo::linear_set<md::TileSelectionTileSetType,std::less<md::TileSelectionTileSetType>,std::allocator<md::TileSelectionTileSetType>,std::vector<md::TileSelectionTileSetType>> const&,std::unordered_map<md::TileSelectionTileSetType,gdc::TileSelectionResults> &,md::CameraContext const&,md::TileSelectionContext &,md::LayoutContext const&,md::StyleLogicContext const&)::$_0,std::allocator<md::TileSelectionLogic::processActiveTileSelection(geo::linear_set<md::TileSelectionTileSetType,std::less<md::TileSelectionTileSetType>,std::allocator<md::TileSelectionTileSetType>,std::vector<md::TileSelectionTileSetType>> const&,std::unordered_map<md::TileSelectionTileSetType,gdc::TileSelectionResults> &,md::CameraContext const&,md::TileSelectionContext &,md::LayoutContext const&,md::StyleLogicContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51E068;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::TileSelectionLogic::processActiveTileSelection(geo::linear_set<md::TileSelectionTileSetType,std::less<md::TileSelectionTileSetType>,std::allocator<md::TileSelectionTileSetType>,std::vector<md::TileSelectionTileSetType>> const&,std::unordered_map<md::TileSelectionTileSetType,gdc::TileSelectionResults> &,md::CameraContext const&,md::TileSelectionContext &,md::LayoutContext const&,md::StyleLogicContext const&)::$_0,std::allocator<md::TileSelectionLogic::processActiveTileSelection(geo::linear_set<md::TileSelectionTileSetType,std::less<md::TileSelectionTileSetType>,std::allocator<md::TileSelectionTileSetType>,std::vector<md::TileSelectionTileSetType>> const&,std::unordered_map<md::TileSelectionTileSetType,gdc::TileSelectionResults> &,md::CameraContext const&,md::TileSelectionContext &,md::LayoutContext const&,md::StyleLogicContext const&)::$_0>,void ()(void)>::~__func()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md18TileSelectionLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__2NS_9allocatorISL_EEFvNS2_17StyleManagerEventEEE7__cloneEPNS0_6__baseISP_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF573FF8;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md18TileSelectionLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__2NS_9allocatorISL_EEFvNS2_17StyleManagerEventEEE7__cloneEv(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF573FF8;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md18TileSelectionLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__2NS_9allocatorISL_EEFvNS2_17StyleManagerEventEEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md18TileSelectionLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__1NS_9allocatorISL_EEFvvEE7__cloneEPNS0_6__baseISO_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF573FB0;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md18TileSelectionLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__1NS_9allocatorISL_EEFvvEE7__cloneEv(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF573FB0;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md18TileSelectionLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__1NS_9allocatorISL_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md18TileSelectionLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__0NS_9allocatorISL_EEFvvEE7__cloneEPNS0_6__baseISO_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF573F68;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md18TileSelectionLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__0NS_9allocatorISL_EEFvvEE7__cloneEv(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF573F68;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md18TileSelectionLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__0NS_9allocatorISL_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md18TileSelectionLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__1NS_9allocatorISL_EEFvvEE7__cloneEPNS0_6__baseISO_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF574118;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md18TileSelectionLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__1NS_9allocatorISL_EEFvvEE7__cloneEv(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF574118;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md18TileSelectionLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__1NS_9allocatorISL_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md18TileSelectionLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__0NS_9allocatorISL_EEFvvEE7__cloneEPNS0_6__baseISO_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5740D0;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md18TileSelectionLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__0NS_9allocatorISL_EEFvvEE7__cloneEv(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5740D0;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md18TileSelectionLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_20TileSelectionContextEE3__0NS_9allocatorISL_EEFvvEED0Ev()
{
}

uint64_t md::Logic<md::TileSelectionLogic,md::TileSelectionContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext,md::StyleLogicContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::TileSelectionLogic,md::TileSelectionContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext,md::StyleLogicContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x64780CBD71DF7CF5 && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext,md::StyleLogicContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::ElevationContext,md::StyleLogicContext>(v7, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v7, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

void md::TileSelectionContext::~TileSelectionContext(md::TileSelectionContext *this)
{
  std::__hash_table<std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>,std::__unordered_map_hasher<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>,std::hash<md::TileSelectionTileSetType>,std::equal_to<md::TileSelectionTileSetType>,true>,std::__unordered_map_equal<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>,std::equal_to<md::TileSelectionTileSetType>,std::hash<md::TileSelectionTileSetType>,true>,std::allocator<std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>>>::__deallocate_node(*((void **)this + 13));
  uint64_t v2 = (void *)*((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v2) {
    operator delete(v2);
  }
  std::__hash_table<std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>,std::__unordered_map_hasher<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>,std::hash<md::TileSelectionTileSetType>,std::equal_to<md::TileSelectionTileSetType>,true>,std::__unordered_map_equal<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>,std::equal_to<md::TileSelectionTileSetType>,std::hash<md::TileSelectionTileSetType>,true>,std::allocator<std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>>>::__deallocate_node(*((void **)this + 8));
  uint64_t v3 = (void *)*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v3) {
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 3);
  if (v4)
  {
    *((void *)this + 4) = v4;
    operator delete(v4);
  }
  int v5 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v5;
    operator delete(v5);
  }
}

uint64_t gdc::ObjectHolder<md::TileSelectionContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::TileSelectionContext>::~ManagedObjectHolder(void *a1)
{
  gdc::ManagedObjectHolder<md::TileSelectionContext>::~ManagedObjectHolder(a1);
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::TileSelectionContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555898;
  uint64_t v2 = a1[4];
  if (v2)
  {
    std::__hash_table<std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>,std::__unordered_map_hasher<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>,std::hash<md::TileSelectionTileSetType>,std::equal_to<md::TileSelectionTileSetType>,true>,std::__unordered_map_equal<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>,std::equal_to<md::TileSelectionTileSetType>,std::hash<md::TileSelectionTileSetType>,true>,std::allocator<std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>>>::__deallocate_node(*(void **)(v2 + 104));
    uint64_t v3 = *(void **)(v2 + 88);
    *(void *)(v2 + 88) = 0;
    if (v3) {
      operator delete(v3);
    }
    std::__hash_table<std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>,std::__unordered_map_hasher<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>,std::hash<md::TileSelectionTileSetType>,std::equal_to<md::TileSelectionTileSetType>,true>,std::__unordered_map_equal<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>,std::equal_to<md::TileSelectionTileSetType>,std::hash<md::TileSelectionTileSetType>,true>,std::allocator<std::__hash_value_type<md::TileSelectionTileSetType,gdc::TileSelectionResults>>>::__deallocate_node(*(void **)(v2 + 64));
    uint64_t v4 = *(void **)(v2 + 48);
    *(void *)(v2 + 48) = 0;
    if (v4) {
      operator delete(v4);
    }
    int v5 = *(void **)(v2 + 24);
    if (v5)
    {
      *(void *)(v2 + 32) = v5;
      operator delete(v5);
    }
    uint64_t v6 = *(void **)v2;
    if (*(void *)v2)
    {
      *(void *)(v2 + 8) = v6;
      operator delete(v6);
    }
    MEMORY[0x1A6239270](v2, 0x10A0C40149C9738);
  }
  return a1;
}

void md::TileSelectionLogic::createDebugNode(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  strcpy((char *)a2, "TileSelectionLogic");
  *(_WORD *)(a2 + 23) = 18;
  *(_OWORD *)(a2 + 47) = 0u;
  *(_OWORD *)(a2 + 63) = 0u;
  *(_OWORD *)(a2 + 79) = 0u;
  *(unsigned char *)(a2 + 95) = 0;
  uint64_t v3 = a1 + 128;
  uint64_t v4 = (char *)&md::TileSelectionTileSetTypeList;
  do
  {
    uint64_t v5 = *(void *)(v3 + 8 * *(unsigned __int16 *)v4);
    if (!v5) {
      goto LABEL_2;
    }
    (*(void (**)(void **__return_ptr))(*(void *)v5 + 24))(v16);
    gdc::DebugTreeNode::addChildNode((void *)a2, (long long *)v16);
    uint64_t v6 = (void **)__p;
    if (__p)
    {
      char v7 = v22;
      long long v8 = __p;
      if (v22 != __p)
      {
        do
        {
          char v9 = (void **)*(v7 - 3);
          if (v9)
          {
            unint64_t v10 = (void **)*(v7 - 2);
            unint64_t v11 = *(v7 - 3);
            if (v10 != v9)
            {
              do
              {
                if (*((char *)v10 - 1) < 0) {
                  operator delete(*(v10 - 3));
                }
                v10 -= 3;
              }
              while (v10 != v9);
              unint64_t v11 = *(v7 - 3);
            }
            *(v7 - 2) = v9;
            operator delete(v11);
          }
          uint64_t v12 = (void **)*(v7 - 6);
          if (v12)
          {
            uint64_t v13 = (void **)*(v7 - 5);
            unsigned int v14 = *(v7 - 6);
            if (v13 != v12)
            {
              do
              {
                if (*((char *)v13 - 9) < 0) {
                  operator delete(*(v13 - 4));
                }
                v13 -= 8;
              }
              while (v13 != v12);
              unsigned int v14 = *(v7 - 6);
            }
            *(v7 - 5) = v12;
            operator delete(v14);
          }
          unint64_t v15 = v7 - 10;
          if (*((char *)v7 - 57) < 0) {
            operator delete(*v15);
          }
          v7 -= 10;
        }
        while (v15 != v6);
        long long v8 = __p;
      }
      unint64_t v22 = v6;
      operator delete(v8);
    }
    std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v20);
    if (v19 < 0)
    {
      operator delete(v18);
      if ((v17 & 0x80000000) == 0) {
        goto LABEL_2;
      }
    }
    else if ((v17 & 0x80000000) == 0)
    {
      goto LABEL_2;
    }
    operator delete(v16[0]);
LABEL_2:
    v4 += 2;
  }
  while (v4 != &md::MapEngineSettingList);
}

void sub_1A23881D8(_Unwind_Exception *a1)
{
  gdc::DebugTreeNode::~DebugTreeNode(v1);
  _Unwind_Resume(a1);
}

void md::TileSelectionLogic::didBecomeInactive(md::TileSelectionLogic *this)
{
  uint64_t v2 = (char *)this + 296;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 37));
  *((void *)this + 37) = 0;
  *((void *)this + 38) = 0;
  *((void *)this + 36) = v2;
}

void md::TileSelectionLogic::~TileSelectionLogic(md::TileSelectionLogic *this)
{
  md::TileSelectionLogic::~TileSelectionLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  md::TileSelectionLogic *v4;
  md::TileSelectionLogic *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  *(void *)this = &unk_1EF53AD88;
  uint64_t v2 = (void *)*((void *)this + 52);
  *((void *)this + 52) = 0;
  if (v2)
  {
    uint64_t v3 = (void *)v2[3];
    if (v3 == v2)
    {
      (*(void (**)(void *))(*v2 + 32))(v2);
    }
    else if (v3)
    {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    MEMORY[0x1A6239270](v2, 0x1020C40E2194266);
  }
  if (*((unsigned char *)this + 408))
  {
    uint64_t v4 = (md::TileSelectionLogic *)*((void *)this + 50);
    if (v4 == (md::TileSelectionLogic *)((char *)this + 376))
    {
      (*(void (**)(char *))(*((void *)this + 47) + 32))((char *)this + 376);
      if (!*((unsigned char *)this + 368)) {
        goto LABEL_18;
      }
      goto LABEL_12;
    }
    if (v4) {
      (*(void (**)(md::TileSelectionLogic *))(*(void *)v4 + 40))(v4);
    }
  }
  if (!*((unsigned char *)this + 368)) {
    goto LABEL_18;
  }
LABEL_12:
  uint64_t v5 = (md::TileSelectionLogic *)*((void *)this + 45);
  if (v5 == (md::TileSelectionLogic *)((char *)this + 336))
  {
    (*(void (**)(char *))(*((void *)this + 42) + 32))((char *)this + 336);
  }
  else if (v5)
  {
    (*(void (**)(md::TileSelectionLogic *))(*(void *)v5 + 40))(v5);
  }
LABEL_18:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 37));
  uint64_t v6 = (void *)*((void *)this + 33);
  if (v6)
  {
    *((void *)this + 34) = v6;
    operator delete(v6);
  }
  char v7 = (void *)*((void *)this + 30);
  if (v7)
  {
    *((void *)this + 31) = v7;
    operator delete(v7);
  }
  long long v8 = (void *)*((void *)this + 27);
  if (v8)
  {
    do
    {
      char v9 = (void *)*v8;
      operator delete(v8);
      long long v8 = v9;
    }
    while (v9);
  }
  unint64_t v10 = (void *)*((void *)this + 25);
  *((void *)this + 25) = 0;
  if (v10) {
    operator delete(v10);
  }
  std::array<std::unique_ptr<gdc::TileSelector>,9ul>::~array((uint64_t *)this + 16);
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

uint64_t *std::array<std::unique_ptr<gdc::TileSelector>,9ul>::~array(uint64_t *a1)
{
  uint64_t v2 = a1[8];
  a1[8] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[7];
  a1[7] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[6];
  a1[6] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = a1[5];
  a1[5] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = a1[4];
  a1[4] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = a1[3];
  a1[3] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = a1[2];
  a1[2] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = a1[1];
  a1[1] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *a1;
  *a1 = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  return a1;
}

void *std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_4,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_4>,geo::optional<gm::Range<double>> ()(geo::QuadTile const&)>::__clone(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5741F0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_4,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_4>,geo::optional<gm::Range<double>> ()(geo::QuadTile const&)>::~__func()
{
}

void std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_3,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_3>,void ()(unsigned int,gdc::GlobeTileSelectorOptions &)>::operator()(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v4 = +[VKDebugSettings sharedSettings];
  *a3 = 0;
  id v6 = v4;
  if ([v4 daVinciCameraController]) {
    char v5 = [v6 daVinciBiasLatitudeGlobeTileSelection];
  }
  else {
    char v5 = 1;
  }
  a3[1] = v5;
  a3[2] = 20;
}

void sub_1A2388734(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_3,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_3>,void ()(unsigned int,gdc::GlobeTileSelectorOptions &)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF590618;
}

void *std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_3,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_3>,void ()(unsigned int,gdc::GlobeTileSelectorOptions &)>::__clone()
{
  unint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF590618;
  return result;
}

void std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_3,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_3>,void ()(unsigned int,gdc::GlobeTileSelectorOptions &)>::~__func()
{
}

void *std::__function::__func<md::GlobeGridBoundsProvider::boundsQuery(void)::{lambda(geo::QuadTile const&)#1},std::allocator<md::GlobeGridBoundsProvider::boundsQuery(void)::{lambda(geo::QuadTile const&)#1}>,geo::optional<gm::Range<double>> ()(geo::QuadTile const&)>::__clone(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51EBF0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::GlobeGridBoundsProvider::boundsQuery(void)::{lambda(geo::QuadTile const&)#1},std::allocator<md::GlobeGridBoundsProvider::boundsQuery(void)::{lambda(geo::QuadTile const&)#1}>,geo::optional<gm::Range<double>> ()(geo::QuadTile const&)>::~__func()
{
}

void *std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_2,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_2>,geo::optional<gm::Range<double>> ()(geo::QuadTile const&)>::__clone(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5741A8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_2,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_2>,geo::optional<gm::Range<double>> ()(geo::QuadTile const&)>::~__func()
{
}

void std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_1,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_1>,void ()(unsigned int,gdc::GlobeTileSelectorOptions &)>::operator()(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *a2;
  id v14 = +[VKDebugSettings sharedSettings];
  *(unsigned char *)a3 = [v14 daVinciPitchedGlobeTileSelection];
  if ([v14 daVinciCameraController]) {
    char v6 = [v14 daVinciBiasLatitudeGlobeTileSelection];
  }
  else {
    char v6 = 1;
  }
  *(unsigned char *)(a3 + 1) = v6;
  *(_WORD *)(a3 + 3) = *(_WORD *)(v4 + 324);
  *(_WORD *)(a3 + 88) = *(_WORD *)(v4 + 326);
  std::__optional_storage_base<std::function<gdc::CameraFrame<geo::Radians,double> ()(void)>,false>::__assign_from[abi:nn180100]<std::__optional_copy_assign_base<std::function<gdc::CameraFrame<geo::Radians,double> ()(void)>,false> const&>((unsigned char *)(a3 + 8), (unsigned char *)(v4 + 376));
  uint64_t v7 = *(void *)(v4 + 120);
  if (*(void *)(v7 + 240))
  {
    *(unsigned char *)(a3 + 2) = 0;
    uint64_t v8 = *(uint64_t **)(v7 + 232);
    if (!v8) {
      goto LABEL_26;
    }
    unsigned __int8 v9 = 0;
    if (v5)
    {
      do
      {
        unint64_t v10 = *((unsigned int *)v8 + 4);
        if (v10)
        {
          if (v10 >= v5)
          {
            int v12 = 0;
          }
          else
          {
            int v12 = 0;
            do
            {
              ++v12;
              v10 *= 2;
            }
            while (v10 < v5);
          }
          for (unint64_t i = v5; v10 > i; i *= 2)
            --v12;
          LODWORD(v10) = -v12 & ~(-v12 >> 31);
        }
        unsigned int v11 = *((_DWORD *)v8 + 6) + v10;
        if (v11 > v9) {
          unsigned __int8 v9 = v11;
        }
        uint64_t v8 = (uint64_t *)*v8;
      }
      while (v8);
    }
    else
    {
      do
      {
        if (*((_DWORD *)v8 + 6) > v9) {
          unsigned __int8 v9 = *((_DWORD *)v8 + 6);
        }
        uint64_t v8 = (uint64_t *)*v8;
      }
      while (v8);
    }
  }
  else
  {
    unsigned __int8 v9 = 25;
  }
  *(unsigned char *)(a3 + 2) = v9;
LABEL_26:
}

void sub_1A23889E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_1,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_1>,void ()(unsigned int,gdc::GlobeTileSelectorOptions &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5905D0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_1,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_1>,void ()(unsigned int,gdc::GlobeTileSelectorOptions &)>::__clone(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5905D0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_1,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_1>,void ()(unsigned int,gdc::GlobeTileSelectorOptions &)>::~__func()
{
}

double std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_0,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_0>,geo::optional<gm::Range<double>> ()(geo::QuadTile const&)>::operator()@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, double *a3@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 8);
  md::TileSelectionLogic::_elevationBoundsForTile((md::TileSelectionLogic *)a3, (const QuadTile *)v4, a2);
  if (*(unsigned char *)a3)
  {
    double result = a3[2] * *(float *)(v4 + 320);
    a3[2] = result;
  }
  return result;
}

void *std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_0,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_0>,geo::optional<gm::Range<double>> ()(geo::QuadTile const&)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF574160;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_0,std::allocator<md::TileSelectionLogic::TileSelectionLogic(md::World *)::$_0>,geo::optional<gm::Range<double>> ()(geo::QuadTile const&)>::~__func()
{
}

__n128 std::__function::__func<md::TileSelectionLogic::configurationDidChange(void)::$_1,std::allocator<md::TileSelectionLogic::configurationDidChange(void)::$_1>,void ()(unsigned short,gdc::LayerDataSource *,gdc::DataKeyRequester *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF574088;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::TileSelectionLogic::configurationDidChange(void)::$_1,std::allocator<md::TileSelectionLogic::configurationDidChange(void)::$_1>,void ()(unsigned short,gdc::LayerDataSource *,gdc::DataKeyRequester *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF574088;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::TileSelectionLogic::configurationDidChange(void)::$_1,std::allocator<md::TileSelectionLogic::configurationDidChange(void)::$_1>,void ()(unsigned short,gdc::LayerDataSource *,gdc::DataKeyRequester *)>::~__func()
{
}

__n128 std::__function::__func<md::TileSelectionLogic::configurationDidChange(void)::$_0,std::allocator<md::TileSelectionLogic::configurationDidChange(void)::$_0>,void ()(unsigned short,gdc::LayerDataSource *,gdc::DataKeyRequester *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF574040;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::TileSelectionLogic::configurationDidChange(void)::$_0,std::allocator<md::TileSelectionLogic::configurationDidChange(void)::$_0>,void ()(unsigned short,gdc::LayerDataSource *,gdc::DataKeyRequester *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF574040;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::TileSelectionLogic::configurationDidChange(void)::$_0,std::allocator<md::TileSelectionLogic::configurationDidChange(void)::$_0>,void ()(unsigned short,gdc::LayerDataSource *,gdc::DataKeyRequester *)>::~__func()
{
}

void karo::AsyncRequestManagerTemplate<std::pair<altitude::TileKey,md::RasterOverlayLevel>,altitude::OverlayRequestArgs>::getRequest(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  uint64_t v8 = (uint64_t **)(a1 + 72);
  uint64_t v9 = *(void *)(a1 + 72);
  if (v9)
  {
    int v10 = *(_DWORD *)(a2 + 32);
    uint64_t v11 = a1 + 72;
    do
    {
      char v13 = std::__synth_three_way[abi:nn180100]<altitude::TileKey,altitude::TileKey>((_DWORD *)(v9 + 32), (_DWORD *)a2);
      if (!v13)
      {
        int v14 = *(_DWORD *)(v9 + 64);
        BOOL v15 = v14 == v10;
        if (v14 < v10) {
          char v16 = -1;
        }
        else {
          char v16 = 1;
        }
        if (v15) {
          char v13 = 0;
        }
        else {
          char v13 = v16;
        }
      }
      if (v13 >= 0) {
        int v12 = (uint64_t *)v9;
      }
      else {
        int v12 = (uint64_t *)(v9 + 8);
      }
      if (v13 >= 0) {
        uint64_t v11 = v9;
      }
      uint64_t v9 = *v12;
    }
    while (*v12);
    if ((uint64_t **)v11 != v8)
    {
      if ((v17 = std::__synth_three_way[abi:nn180100]<altitude::TileKey,altitude::TileKey>((_DWORD *)a2, (_DWORD *)(v11 + 32))) == 0&& ((int v18 = *(_DWORD *)(v11 + 64), v10 < v18) ? (v17 = -1) : (v17 = 1), v10 == v18)|| (v17 & 0x80) == 0)
      {
        uint64_t v20 = *(void *)(v11 + 72);
        uint64_t v19 = *(void *)(v11 + 80);
        if (v19) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
        }
        *a4 = v20;
        a4[1] = v19;
        return;
      }
    }
  }
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 64))(&v41, a1, a2, a3);
  long long v21 = v41;
  *(_OWORD *)a4 = v41;
  unint64_t v22 = *v8;
  unsigned int v23 = v8;
  if (*v8)
  {
    int v24 = *(_DWORD *)(a2 + 32);
    long long v40 = v21;
    while (1)
    {
      while (1)
      {
        unsigned int v23 = v22;
        uint64_t v25 = v22 + 4;
        char v26 = std::__synth_three_way[abi:nn180100]<altitude::TileKey,altitude::TileKey>((_DWORD *)a2, (_DWORD *)v22 + 8);
        if (!v26)
        {
          int v27 = *((_DWORD *)v23 + 16);
          char v26 = v24 < v27 ? -1 : 1;
          if (v24 == v27) {
            break;
          }
        }
        if ((v26 & 0x80) == 0) {
          break;
        }
        unint64_t v22 = (uint64_t *)*v23;
        uint64_t v8 = (uint64_t **)v23;
        if (!*v23) {
          goto LABEL_42;
        }
      }
      char v28 = std::__synth_three_way[abi:nn180100]<altitude::TileKey,altitude::TileKey>(v25, (_DWORD *)a2);
      long long v29 = v40;
      if (!v28)
      {
        int v30 = *((_DWORD *)v23 + 16);
        char v28 = v30 < v24 ? -1 : 1;
        if (v30 == v24) {
          break;
        }
      }
      if ((v28 & 0x80) == 0) {
        break;
      }
      uint64_t v8 = (uint64_t **)(v23 + 1);
      unint64_t v22 = (uint64_t *)v23[1];
      if (!v22) {
        goto LABEL_42;
      }
    }
    uint64_t v31 = (char *)v23;
    uint64_t v35 = *((void *)&v40 + 1);
    if (!*((void *)&v40 + 1)) {
      goto LABEL_46;
    }
  }
  else
  {
LABEL_42:
    uint64_t v31 = (char *)operator new(0x58uLL);
    long long v32 = *(_OWORD *)(a2 + 16);
    *((_OWORD *)v31 + 2) = *(_OWORD *)a2;
    *((_OWORD *)v31 + 3) = v32;
    *((_DWORD *)v31 + 16) = *(_DWORD *)(a2 + 32);
    *((void *)v31 + 9) = 0;
    *((void *)v31 + 10) = 0;
    *(void *)uint64_t v31 = 0;
    *((void *)v31 + 1) = 0;
    *((void *)v31 + 2) = v23;
    *uint64_t v8 = (uint64_t *)v31;
    uint64_t v33 = **(void **)(a1 + 64);
    int v34 = (uint64_t *)v31;
    if (v33)
    {
      *(void *)(a1 + 64) = v33;
      int v34 = *v8;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 72), v34);
    ++*(void *)(a1 + 80);
    long long v29 = *(_OWORD *)a4;
    uint64_t v35 = a4[1];
    if (!v35) {
      goto LABEL_46;
    }
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v35 + 8), 1uLL, memory_order_relaxed);
LABEL_46:
  unint64_t v36 = (std::__shared_weak_count *)*((void *)v31 + 10);
  *(_OWORD *)(v31 + 72) = v29;
  if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
  }
  unint64_t v37 = *(void *)(a1 + 48);
  if (v37)
  {
    uint64_t v38 = *a4;
    float v39 = (std::__shared_weak_count *)a4[1];
    *(void *)&long long v41 = v38;
    *((void *)&v41 + 1) = v39;
    if (v39)
    {
      atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::JobManager::queueJob(v37, &v41);
      if (!atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
    else
    {
      karo::JobManager::queueJob(v37, &v41);
    }
  }
}

void sub_1A2388F74(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::__synth_three_way[abi:nn180100]<altitude::TileKey,altitude::TileKey>(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2 = a1[4];
  unsigned int v3 = a2[4];
  if (v2 == v3 && a1[5] == a2[5] && a1[6] == a2[6] && a2[7] == a1[7])
  {
    if (*a1 == *a2)
    {
      unsigned int v4 = a1[1];
      unsigned int v5 = a2[1];
      if (v4 == v5)
      {
        if (a1[2] < a2[2]) {
          return 255;
        }
      }
      else if (v4 < v5)
      {
        return 255;
      }
    }
    else if (*a1 < *a2)
    {
      return 255;
    }
  }
  else
  {
    if (v2 < v3) {
      return 255;
    }
    if (v2 <= v3)
    {
      unsigned int v7 = a1[5];
      unsigned int v8 = a2[5];
      if (v7 < v8) {
        return 255;
      }
      if (v7 <= v8)
      {
        unsigned int v9 = a1[6];
        unsigned int v10 = a2[6];
        if (v9 < v10) {
          return 255;
        }
        if (v9 <= v10 && a1[7] < a2[7]) {
          return 255;
        }
      }
    }
    if (v2 != v3 || a2[5] != a1[5] || a2[6] != a1[6]) {
      goto LABEL_33;
    }
  }
  if (a1[7] == a2[7])
  {
    if (*a2 == *a1)
    {
      unsigned int v11 = a2[1];
      unsigned int v12 = a1[1];
      if (v11 == v12) {
        return a2[2] < a1[2];
      }
      if (v11 >= v12) {
        return 0;
      }
    }
    else if (*a2 >= *a1)
    {
      return 0;
    }
    return 1;
  }
LABEL_33:
  if (v3 < v2) {
    return 1;
  }
  if (v3 > v2) {
    return 0;
  }
  unsigned int v13 = a2[5];
  unsigned int v14 = a1[5];
  if (v13 < v14) {
    return 1;
  }
  if (v13 > v14) {
    return 0;
  }
  unsigned int v15 = a2[6];
  unsigned int v16 = a1[6];
  if (v15 < v16) {
    return 1;
  }
  if (v15 > v16) {
    return 0;
  }
  return a2[7] < a1[7];
}

uint64_t karo::AsyncRequestManagerTemplate<std::pair<altitude::TileKey,md::RasterOverlayLevel>,altitude::OverlayRequestArgs>::waitOnRequest(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  char v6 = (pthread_mutex_t **)(a1 + 40);
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  uint64_t v9 = *(void *)(a1 + 72);
  uint64_t v7 = a1 + 72;
  uint64_t v8 = v9;
  if (!v9) {
    goto LABEL_27;
  }
  int v10 = a2[8];
  uint64_t v11 = v7;
  do
  {
    char v13 = std::__synth_three_way[abi:nn180100]<altitude::TileKey,altitude::TileKey>((_DWORD *)(v8 + 32), a2);
    if (!v13)
    {
      int v14 = *(_DWORD *)(v8 + 64);
      BOOL v15 = v14 == v10;
      if (v14 < v10) {
        char v16 = -1;
      }
      else {
        char v16 = 1;
      }
      if (v15) {
        char v13 = 0;
      }
      else {
        char v13 = v16;
      }
    }
    if (v13 >= 0) {
      unsigned int v12 = (uint64_t *)v8;
    }
    else {
      unsigned int v12 = (uint64_t *)(v8 + 8);
    }
    if (v13 >= 0) {
      uint64_t v11 = v8;
    }
    uint64_t v8 = *v12;
  }
  while (*v12);
  if (v11 == v7
    || ((char v17 = std::__synth_three_way[abi:nn180100]<altitude::TileKey,altitude::TileKey>(a2, (_DWORD *)(v11 + 32))) != 0
     || ((int v18 = *(_DWORD *)(v11 + 64), v10 < v18) ? (v17 = -1) : (v17 = 1), v10 != v18))
    && v17 < 0)
  {
LABEL_27:
    uint64_t v19 = 0;
    uint64_t v23 = 0;
LABEL_28:
    pthread_mutex_unlock(*v6);
    if (!v19) {
      return v23;
    }
    goto LABEL_29;
  }
  uint64_t v20 = *(karo::Job **)(v11 + 72);
  uint64_t v19 = *(std::__shared_weak_count **)(v11 + 80);
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(*v6);
  if (v20)
  {
    karo::Job::waitToFinish(v20, a3);
    unint64_t v22 = (pthread_mutex_t *)*((void *)v20 + 19);
    long long v21 = (pthread_mutex_t **)((char *)v20 + 152);
    pthread_mutex_lock(v22);
    uint64_t v23 = (_BYTE)v21[1] & 1;
    char v6 = v21;
    goto LABEL_28;
  }
  uint64_t v23 = 0;
  if (!v19) {
    return v23;
  }
LABEL_29:
  if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  return v23;
}

void sub_1A238930C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t karo::AsyncRequestManagerTemplate<std::pair<altitude::TileKey,md::RasterOverlayLevel>,altitude::OverlayRequestArgs>::requestT@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, unsigned int a5@<W4>, char a6@<W5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  if (!a3) {
    a3 = *(_DWORD *)(a1 + 88) + 1;
  }
  (*(void (**)(unsigned int **__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 96))(&v22, a1, a2, a7);
  char v16 = v22;
  unsigned int v17 = atomic_load(v22 + 4);
  if (v17 != a4) {
    (*(void (**)(unsigned int *, uint64_t))(*(void *)v22 + 24))(v22, a4);
  }
  v16[45] = a3;
  v16[46] = a5;
  *((unsigned char *)v16 + 176) = a6;
  int v18 = v22;
  uint64_t v19 = v23;
  *a8 = off_1EF5677B0;
  a8[1] = v18;
  a8[2] = v19;
  if (v19)
  {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    int v18 = (unsigned int *)a8[1];
  }
  if (v18) {
    atomic_fetch_add((atomic_uint *volatile)v18 + 32, 1u);
  }
  uint64_t v20 = v23;
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  return pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
}

void sub_1A23894A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 40));
  _Unwind_Resume(a1);
}

uint64_t karo::AsyncRequestManagerTemplate<std::pair<altitude::TileKey,md::RasterOverlayLevel>,altitude::OverlayRequestArgs>::requestT(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  if (!a4) {
    a4 = *(_DWORD *)(a1 + 88) + 1;
  }
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  if (*a2 != v9)
  {
    do
    {
      uint64_t v10 = v8 + 40;
      (*(void (**)(unsigned int **__return_ptr, uint64_t))(*(void *)a1 + 96))(&v22, a1);
      uint64_t v11 = v22;
      int v12 = *(_DWORD *)(v10 + 32);
      unsigned int v13 = *(_DWORD *)(v10 + 36);
      char v14 = *(unsigned char *)(v10 + 40);
      unsigned int v15 = atomic_load(v22 + 4);
      if (v15 != v12) {
        (*(void (**)(unsigned int *))(*(void *)v22 + 24))(v22);
      }
      v11[45] = a4;
      v11[46] = v13;
      *((unsigned char *)v11 + 176) = v14;
      char v16 = *(void **)(a3 + 8);
      if ((unint64_t)v16 >= *(void *)(a3 + 16))
      {
        uint64_t v19 = std::vector<karo::AsyncRequestManager::RequestHandle>::__emplace_back_slow_path<std::shared_ptr<karo::AsyncRequestManager::Request> &>((void **)a3, (uint64_t)v22, (uint64_t)v23);
      }
      else
      {
        *char v16 = off_1EF5677B0;
        unsigned int v17 = v22;
        v16[1] = v22;
        uint64_t v18 = (uint64_t)v23;
        _OWORD v16[2] = v23;
        if (v18)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
          unsigned int v17 = (unsigned int *)v16[1];
        }
        if (v17) {
          atomic_fetch_add((atomic_uint *volatile)v17 + 32, 1u);
        }
        uint64_t v19 = v16 + 3;
        *(void *)(a3 + 8) = v16 + 3;
      }
      *(void *)(a3 + 8) = v19;
      uint64_t v20 = v23;
      if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
      uint64_t v8 = v10 + 48;
    }
    while (v10 + 48 != v9);
  }
  return pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
}

void sub_1A2389694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 40));
  _Unwind_Resume(a1);
}

void altitude::OverlayRequestManager::createRequest()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1A23898E8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_1A238991C(_Unwind_Exception *a1)
{
  karo::Job::~Job((karo::Job *)v1);
  MEMORY[0x1A6239270]();
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<OverlayLoadJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,OverlayLoadJob>,std::allocator<OverlayLoadJob>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<OverlayLoadJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,OverlayLoadJob>,std::allocator<OverlayLoadJob>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t OverlayLoadJob::succeeded(OverlayLoadJob *this)
{
  return *((unsigned __int8 *)this + 188);
}

void OverlayLoadJob::jobStep(OverlayLoadJob *this)
{
  uint64_t v132 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 29);
  long long v127 = *((_OWORD *)this + 15);
  v126[1] = v2;
  v126[0] = 17;
  char v85 = (*(uint64_t (**)(void, void *))(**((void **)this + 33) + 112))(*((void *)this + 33), v126);
  uint64_t v3 = *((_DWORD *)this + 64) != 0;
  int v4 = *((_DWORD *)this + 60);
  int v6 = *((_DWORD *)this + 61);
  uint64_t v5 = *((unsigned int *)this + 62);
  long long v122 = 0u;
  long long v123 = 0u;
  long long v124 = 0u;
  long long v125 = 0u;
  id v7 = *((id *)this + 24);
  uint64_t v8 = [v7 countByEnumeratingWithState:&v122 objects:v131 count:16];
  if (!v8)
  {
LABEL_11:

    *((unsigned char *)this + 188) = 0;
    goto LABEL_115;
  }
  uint64_t v9 = *(void *)v123;
  unint64_t v10 = v5 | ((unint64_t)((1 << v4) + ~v6) << 32);
  uint64_t v11 = v4 | 0x200000000;
LABEL_3:
  uint64_t v12 = 0;
  while (1)
  {
    if (*(void *)v123 != v9) {
      objc_enumerationMutation(v7);
    }
    unsigned int v13 = *(void **)(*((void *)&v122 + 1) + 8 * v12);
    *(void *)&long long v94 = v10;
    *((void *)&v94 + 1) = v11;
    if ([v13 level] == v3 && (objc_msgSend(v13, "canDrawKey:", &v94) & 1) != 0) {
      break;
    }
    if (v8 == ++v12)
    {
      uint64_t v8 = [v7 countByEnumeratingWithState:&v122 objects:v131 count:16];
      if (!v8) {
        goto LABEL_11;
      }
      goto LABEL_3;
    }
  }

  if ((v85 & 1) == 0) {
    goto LABEL_36;
  }
  if (*((void *)this + 34))
  {
LABEL_34:
    if (*(void *)karo::Job::getSubJob((pthread_mutex_t **)this, 1)) {
      return;
    }
    if (*((void *)this + 34)) {
      goto LABEL_36;
    }
    pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
    BOOL v81 = (*((_DWORD *)this + 40) & 2) == 0;
    pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
    *((unsigned char *)this + 188) = v81;
LABEL_115:
    pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
    *((_DWORD *)this + 40) |= 1u;
    pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
    return;
  }
  uint64_t v14 = *((void *)this + 1);
  atomic_load((unsigned int *)this + 4);
  (*(void (**)(long long *__return_ptr))(**((void **)this + 33) + 104))(&v94);
  uint64_t v15 = v94;
  if ((void)v94)
  {
    uint64_t v16 = *((void *)&v94 + 1);
    if (*((void *)&v94 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v94 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    unsigned int v17 = (std::__shared_weak_count *)*((void *)this + 35);
    *((void *)this + 34) = v15;
    *((void *)this + 35) = v16;
    if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
    karo::Job::removeSubJob((pthread_mutex_t **)this, 1);
    uint64_t v18 = *((void *)this + 33);
    uint64_t v19 = *((void *)this + 34);
    uint64_t v118 = 0;
    uint64_t v117 = 0;
    long long v119 = *(_OWORD *)(v19 + 136);
    (*(void (**)(long long *__return_ptr))(*(void *)v18 + 144))(&__dst);
    DWORD1(__dst) = *(_DWORD *)(*((void *)this + 34) + 152);
    HIDWORD(__dst) = altitude::GeoResourceManager::getVersionForGEOType(v14, __dst, DWORD1(__dst));
    uint64_t v20 = (void **)((char *)this + 328);
    long long v21 = std::__tree<altitude::TileKey>::__find_equal<altitude::TileKey>((uint64_t)this + 328, &v117, (unsigned int *)&__dst);
    if (!*v21)
    {
      unint64_t v22 = v21;
      uint64_t v23 = (char *)operator new(0x40uLL);
      long long v24 = v121;
      *(_OWORD *)(v23 + 28) = __dst;
      *(_OWORD *)(v23 + 44) = v24;
      uint64_t v25 = v117;
      *(void *)uint64_t v23 = 0;
      *((void *)v23 + 1) = 0;
      *((void *)v23 + 2) = v25;
      *unint64_t v22 = (uint64_t)v23;
      char v26 = (void *)**v20;
      if (v26)
      {
        std::__shared_weak_count *v20 = v26;
        uint64_t v23 = (char *)*v22;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 42), (uint64_t *)v23);
      ++*((void *)this + 43);
    }
    goto LABEL_24;
  }
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)v95))
  {
    float v82 = *(std::__shared_weak_count **)&v95[16];
    v116[0] = *(void *)&v95[8];
    v116[1] = *(void *)&v95[16];
    if (*(void *)&v95[16])
    {
      int v27 = 1;
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v95[16] + 8), 1uLL, memory_order_relaxed);
      karo::Job::addBlockingSubJob((uint64_t *)this, v116, 1, 0);
      if (!atomic_fetch_add(&v82->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
        std::__shared_weak_count::__release_weak(v82);
LABEL_24:
        int v27 = 1;
      }
    }
    else
    {
      int v27 = 1;
      karo::Job::addBlockingSubJob((uint64_t *)this, v116, 1, 0);
    }
  }
  else
  {
    karo::Job::removeSubJob((pthread_mutex_t **)this, 1);
    (*(void (**)(OverlayLoadJob *))(*(void *)this + 16))(this);
    int v27 = 0;
  }
  *(void *)uint64_t v95 = off_1EF5677B0;
  if (*(void *)&v95[8]) {
    atomic_fetch_add((atomic_uint *volatile)(*(void *)&v95[8] + 128), 0xFFFFFFFF);
  }
  char v28 = *(std::__shared_weak_count **)&v95[16];
  if (*(void *)&v95[16]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v95[16] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
  long long v29 = (std::__shared_weak_count *)*((void *)&v94 + 1);
  if (*((void *)&v94 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v94 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  if (v27) {
    goto LABEL_34;
  }
LABEL_36:
  unsigned int v30 = *((_DWORD *)this + 60);
  if (v30 >= 0x1F) {
    char v31 = 31;
  }
  else {
    char v31 = *((_DWORD *)this + 60);
  }
  int v32 = ~(-1 << v31) - *((_DWORD *)this + 61);
  int v33 = *((_DWORD *)this + 62);
  LOBYTE(v117) = -1;
  BYTE1(v117) = v30;
  HIDWORD(v117) = v32;
  LODWORD(v118) = v33;
  v115[0] = v10;
  v115[1] = v11;
  int v34 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA48]), "initWithCapacity:", objc_msgSend(*((id *)this + 24), "count"));
  long long v113 = 0u;
  long long v114 = 0u;
  long long v111 = 0u;
  long long v112 = 0u;
  id v35 = *((id *)this + 24);
  uint64_t v36 = [v35 countByEnumeratingWithState:&v111 objects:v130 count:16];
  if (v36)
  {
    uint64_t v37 = *(void *)v112;
    do
    {
      for (uint64_t i = 0; i != v36; ++i)
      {
        if (*(void *)v112 != v37) {
          objc_enumerationMutation(v35);
        }
        float v39 = *(void **)(*((void *)&v111 + 1) + 8 * i);
        if ([v39 level] == v3 && objc_msgSend(v39, "canDrawKey:", v115)) {
          [v34 addObject:v39];
        }
      }
      uint64_t v36 = [v35 countByEnumeratingWithState:&v111 objects:v130 count:16];
    }
    while (v36);
  }

  if ([v34 count])
  {
    long long v40 = (char *)operator new(0x48uLL);
    *((void *)v40 + 1) = 0;
    *((void *)v40 + 2) = 0;
    *(void *)long long v40 = &unk_1EF5804B8;
    long long v41 = 0uLL;
    *(_OWORD *)(v40 + 40) = 0u;
    *(_OWORD *)(v40 + 24) = 0u;
    *((_DWORD *)v40 + 14) = 512;
    *(void *)(v40 + 60) = 1065353216;
    uint64_t v42 = (std::__shared_weak_count *)*((void *)this + 40);
    *((void *)this + 39) = v40 + 24;
    *((void *)this + 40) = v40;
    if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
      long long v41 = 0uLL;
    }
    long long v109 = v41;
    long long v110 = v41;
    long long v107 = v41;
    long long v108 = v41;
    id v43 = v34;
    uint64_t v44 = [v43 countByEnumeratingWithState:&v107 objects:v129 count:16];
    if (v44)
    {
      uint64_t v45 = *(void *)v108;
      do
      {
        for (uint64_t j = 0; j != v44; ++j)
        {
          if (*(void *)v108 != v45) {
            objc_enumerationMutation(v43);
          }
          uint64_t v47 = *(void **)(*((void *)&v107 + 1) + 8 * j);
          int v48 = (CGContext *)md::RasterOverlayData::drawContext(*((md::RasterOverlayData **)this + 39));
          memset(v95, 0, 32);
          long long v94 = 0u;
          CGContextGetBaseCTM();
          CGContextSaveGState(v48);
          [v47 drawKey:v115 inContext:v48];
          CGContextRestoreGState(v48);
          long long v104 = v94;
          long long v105 = *(_OWORD *)v95;
          long long v106 = *(_OWORD *)&v95[16];
          CGContextSetBaseCTM();
          uint64_t v49 = [v47 blendMode];
        }
        uint64_t v50 = v49;
        uint64_t v44 = [v43 countByEnumeratingWithState:&v107 objects:v129 count:16];
      }
      while (v44);
    }
    else
    {
      uint64_t v50 = 0;
    }
  }
  else
  {
    uint64_t v50 = 0;
  }
  if (*((void *)this + 39))
  {
    unint64_t v51 = *((void *)this + 34);
    float32x2_t v52 = (std::__shared_weak_count *)*((void *)this + 35);
    if (v52)
    {
      atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
      *(void *)&long long v94 = v51;
      *((void *)&v94 + 1) = v52;
      atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    else
    {
      long long v94 = v51;
    }
    uint64_t v96 = 0;
    memset(&v95[8], 0, 32);
    int v97 = -1;
    memset(v98, 0, sizeof(v98));
    uint64_t v99 = 0x3FF0000000000000;
    v100[24] = 255;
    int v102 = 0;
    int v101 = 0;
    char v103 = 0;
    if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
    unsigned int v53 = BYTE1(v117);
    if (*((void *)this + 34)) {
      int v54 = 32;
    }
    else {
      int v54 = 16;
    }
    if (BYTE1(v117) == 1) {
      int v55 = 32;
    }
    else {
      int v55 = v54;
    }
    if (BYTE1(v117)) {
      unsigned int v56 = v55;
    }
    else {
      unsigned int v56 = 64;
    }
    altitude::HeightMeshBuilder::buildHeightMesh((uint64_t)&v94, (const QuadTile *)&v117, v56, 3u, *(float *)(*((void *)this + 39) + 40));
    if ((unint64_t)(v50 - 1) < 0x11) {
      int v57 = v50;
    }
    else {
      int v57 = 0;
    }
    *((_DWORD *)this + 76) = v57;
    v91[0] = v53;
    v91[1] = ~(-1 << v53) - HIDWORD(v117);
    v91[2] = v118;
    v91[3] = 0;
    char v90 = 12;
    strcpy((char *)v89, "/dtmoverlay/");
    char v88 = 0;
    LOBYTE(v87) = 0;
    altitude::Tile::createTileName(v92, v91, v89, (uint64_t *)&v87);
    uint64_t v58 = *((void *)this + 1);
    uint64_t v59 = **((void **)this + 39);
    if (!v59)
    {
      uint64_t v60 = (char *)operator new(0x58uLL);
      *((void *)v60 + 1) = 0;
      *(void *)uint64_t v60 = &unk_1EF583858;
      *((void *)v60 + 5) = 0;
      *((void *)v60 + 6) = 0;
      *((void *)v60 + 4) = 0;
      *((_DWORD *)v60 + 14) = 0;
      *((void *)v60 + 2) = 0;
      *((void *)v60 + 3) = &unk_1EF55AE58;
      *(void *)&long long v61 = 0x100000001;
      *((void *)&v61 + 1) = 0x100000001;
      *(_OWORD *)(v60 + 60) = v61;
      *(void *)(v60 + 76) = 0x100000001;
      *((_DWORD *)v60 + 21) = 0;
      operator new();
    }
    int v62 = (char)v93;
    if ((v93 & 0x80u) == 0) {
      size_t v63 = v93;
    }
    else {
      size_t v63 = (size_t)v92[1];
    }
    unint64_t v64 = v63 + 8;
    if (v63 + 8 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    int v86 = *((_DWORD *)this + 76);
    if (v64 >= 0x17)
    {
      uint64_t v66 = (v64 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v64 | 7) != 0x17) {
        uint64_t v66 = v64 | 7;
      }
      uint64_t v67 = v66 + 1;
      p_dst = (long long *)operator new(v66 + 1);
      *(void *)&long long v121 = v67 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
      *((void *)&__dst + 1) = v63 + 8;
    }
    else
    {
      *(void *)&long long v121 = 0;
      long long __dst = 0uLL;
      p_dst = &__dst;
      BYTE7(v121) = v63 + 8;
      if (!v63) {
        goto LABEL_100;
      }
    }
    if (v62 >= 0) {
      float v68 = v92;
    }
    else {
      float v68 = (void **)v92[0];
    }
    memmove(p_dst, v68, v63);
LABEL_100:
    strcpy((char *)p_dst + v63, "/Element");
    uint64_t v69 = (char *)operator new(0xA8uLL);
    *((void *)v69 + 1) = 0;
    *((void *)v69 + 2) = 0;
    *(void *)uint64_t v69 = &unk_1EF58AC80;
    *((void *)v69 + 3) = &unk_1EF562D20;
    uint64_t v70 = (std::string *)(v69 + 32);
    int v71 = SBYTE7(v121);
    if (SBYTE7(v121) < 0)
    {
      std::string::__init_copy_ctor_external(v70, (const std::string::value_type *)__dst, *((std::string::size_type *)&__dst + 1));
    }
    else
    {
      *(_OWORD *)&v70->__r_.__value_.__l.__data_ = __dst;
      *((void *)v69 + 6) = v121;
    }
    *((void *)v69 + 3) = &unk_1EF5690C0;
    *((void *)v69 + 7) = 0;
    v69[64] = 1;
    *(_OWORD *)(v69 + 72) = 0u;
    *(_OWORD *)(v69 + 88) = 0u;
    *(_OWORD *)(v69 + 104) = 0u;
    *(_OWORD *)(v69 + 120) = 0u;
    *((void *)v69 + 17) = 0;
    v69[144] = 1;
    *((void *)v69 + 19) = 0;
    *((void *)v69 + 20) = 0;
    if (v71 < 0) {
      operator delete((void *)__dst);
    }
    uint64_t v83 = v59;
    uint64_t v84 = v58;
    uint64_t v72 = *(const void **)&v95[24];
    unint64_t v73 = *(void *)&v95[32] - *(void *)&v95[24];
    uint64_t v74 = operator new(0xF8uLL);
    v74[1] = 0;
    v74[2] = 0;
    *uint64_t v74 = &unk_1EF583D28;
    uint64_t v75 = (v73 >> 1);
    ggl::BufferData::BufferData((uint64_t)(v74 + 3), 2, 1, 0, 7, v75);
    *((_DWORD *)v74 + 60) = 0;
    v74[3] = &unk_1EF55B630;
    v74[4] = 2;
    v74[28] = &unk_1EF55B650;
    v74[29] = "/render/tilebasic/indexdata";
    size_t v76 = 2 * v75;
    if ((v73 >> 1))
    {
      float v77 = (void *)v74[12];
      memcpy(v77, v72, 2 * v75);
      if (v77)
      {
        unint64_t v78 = v74[11];
        if (v78 <= v76) {
          unint64_t v78 = 2 * v75;
        }
        v74[10] = 0;
        v74[11] = v78;
      }
    }
    else
    {
      memcpy(0, v72, v76);
    }
    uint64_t v79 = *(void *)(*(void *)(*(void *)(v58 + 8) + 40) + 48);
    *(void *)&long long __dst = v74 + 3;
    *((void *)&__dst + 1) = v74;
    atomic_fetch_add_explicit(v74 + 1, 1uLL, memory_order_relaxed);
    uint64_t v80 = *(void *)(v79 + 224);
    v128[0] = *(void *)(v79 + 216);
    v128[1] = v80;
    if (v80)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v80 + 8), 1uLL, memory_order_relaxed);
      altitude::Renderable::createOverlayElement(*(void *)(*(void *)(*(void *)(v84 + 8) + 40) + 48), (uint64_t)v98, (uint64_t)v100, *(uint64_t *)&v95[8], *(uint64_t *)&v95[16], (uint64_t *)&__dst, v128, v83, v86);
    }
    altitude::Renderable::createOverlayElement(*(void *)(*(void *)(*(void *)(v84 + 8) + 40) + 48), (uint64_t)v98, (uint64_t)v100, *(uint64_t *)&v95[8], *(uint64_t *)&v95[16], (uint64_t *)&__dst, v128, v83, v86);
  }
  *((unsigned char *)this + 188) = 0;
  pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
  *((_DWORD *)this + 40) |= 1u;
  pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
}

void sub_1A238AB7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
}

void sub_1A238AB98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::RasterOverlayData>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (CGContext *)a1[6];
  if (v2) {
    CGContextRelease(v2);
  }
  uint64_t v3 = a1[3];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  int v4 = (std::__shared_weak_count *)a1[5];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void std::__shared_ptr_emplace<md::RasterOverlayData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5804B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::RasterOverlayData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5804B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void OverlayLoadJob::~OverlayLoadJob(OverlayLoadJob *this)
{
  OverlayLoadJob::~OverlayLoadJob(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  void *v5;
  uint64_t vars8;

  *(void *)this = &unk_1EF52FB40;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 42));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 40);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 37);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 37);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  int v4 = (std::__shared_weak_count *)*((void *)this + 35);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 25);
  *((void *)this + 25) = 0;

  karo::Job::~Job(this);
}

void karo::AsyncRequestManagerTemplate<std::pair<altitude::TileKey,md::RasterOverlayLevel>,altitude::OverlayRequestArgs>::createAndQueueRequest(void *a1@<X0>, uint64_t *a2@<X8>)
{
  (*(void (**)(void *))(*a1 + 64))(a1);
  unint64_t v4 = a1[6];
  if (v4)
  {
    uint64_t v5 = *a2;
    int v6 = (std::__shared_weak_count *)a2[1];
    v7[0] = v5;
    v7[1] = v6;
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::JobManager::queueJob(v4, v7);
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    else
    {
      karo::JobManager::queueJob(v4, v7);
    }
  }
}

uint64_t karo::AsyncRequestManagerTemplate<std::pair<altitude::TileKey,md::RasterOverlayLevel>,altitude::OverlayRequestArgs>::clearRequest(uint64_t a1, _DWORD *a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  uint64_t v4 = *(void *)(a1 + 72);
  if (v4)
  {
    int v5 = a2[8];
    uint64_t v6 = a1 + 72;
    do
    {
      char v8 = std::__synth_three_way[abi:nn180100]<altitude::TileKey,altitude::TileKey>((_DWORD *)(v4 + 32), a2);
      if (!v8)
      {
        int v9 = *(_DWORD *)(v4 + 64);
        BOOL v10 = v9 == v5;
        if (v9 < v5) {
          char v11 = -1;
        }
        else {
          char v11 = 1;
        }
        if (v10) {
          char v8 = 0;
        }
        else {
          char v8 = v11;
        }
      }
      if (v8 >= 0) {
        id v7 = (uint64_t *)v4;
      }
      else {
        id v7 = (uint64_t *)(v4 + 8);
      }
      if (v8 >= 0) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v7;
    }
    while (*v7);
    if (v6 != a1 + 72)
    {
      if ((char v12 = std::__synth_three_way[abi:nn180100]<altitude::TileKey,altitude::TileKey>(a2, (_DWORD *)(v6 + 32))) == 0
        && ((v13 = *(_DWORD *)(v6 + 64), v5 < v13) ? (char v12 = -1) : (char v12 = 1), v5 == v13)
        || (v12 & 0x80) == 0)
      {
        (*(void (**)(void))(**(void **)(v6 + 72) + 16))(*(void *)(v6 + 72));
        uint64_t v14 = *(void **)(v6 + 8);
        if (v14)
        {
          do
          {
            uint64_t v15 = v14;
            uint64_t v14 = (void *)*v14;
          }
          while (v14);
        }
        else
        {
          uint64_t v16 = (void *)v6;
          do
          {
            uint64_t v15 = (void *)v16[2];
            BOOL v10 = *v15 == (void)v16;
            uint64_t v16 = v15;
          }
          while (!v10);
        }
        if (*(void *)(a1 + 64) == v6) {
          *(void *)(a1 + 64) = v15;
        }
        unsigned int v17 = *(uint64_t **)(a1 + 72);
        --*(void *)(a1 + 80);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v17, (uint64_t *)v6);
        uint64_t v18 = *(std::__shared_weak_count **)(v6 + 80);
        if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
        operator delete((void *)v6);
      }
    }
  }
  uint64_t v19 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v19);
}

void sub_1A238B134(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(*(pthread_mutex_t **)(v1 + 40));
  _Unwind_Resume(a1);
}

uint64_t karo::AsyncRequestManagerTemplate<std::pair<altitude::TileKey,md::RasterOverlayLevel>,altitude::OverlayRequestArgs>::removeFromRequests(uint64_t a1, uint64_t a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  uint64_t v4 = *(uint64_t **)(a1 + 64);
  if (v4 != (uint64_t *)(a1 + 72))
  {
    int v5 = *(uint64_t **)(a1 + 64);
    while (1)
    {
      uint64_t v6 = (uint64_t *)v5[1];
      if (v5[9] == a2) {
        break;
      }
      if (v6)
      {
        do
        {
          id v7 = v6;
          uint64_t v6 = (uint64_t *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          id v7 = (uint64_t *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          int v5 = v7;
        }
        while (!v8);
      }
      int v5 = v7;
      if (v7 == (uint64_t *)(a1 + 72)) {
        goto LABEL_23;
      }
    }
    if (v6)
    {
      do
      {
        int v9 = v6;
        uint64_t v6 = (uint64_t *)*v6;
      }
      while (v6);
    }
    else
    {
      BOOL v10 = v5;
      do
      {
        int v9 = (uint64_t *)v10[2];
        BOOL v8 = *v9 == (void)v10;
        BOOL v10 = v9;
      }
      while (!v8);
    }
    if (v4 == v5) {
      *(void *)(a1 + 64) = v9;
    }
    char v11 = *(uint64_t **)(a1 + 72);
    --*(void *)(a1 + 80);
    std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v11, v5);
    char v12 = (std::__shared_weak_count *)v5[10];
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    operator delete(v5);
  }
LABEL_23:
  int v13 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v13);
}

uint64_t karo::AsyncRequestManagerTemplate<std::pair<altitude::TileKey,md::RasterOverlayLevel>,altitude::OverlayRequestArgs>::pruneRequests(uint64_t a1, int a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  uint64_t v4 = *(uint64_t **)(a1 + 64);
  if (v4 != (uint64_t *)(a1 + 72))
  {
    do
    {
      int v5 = (uint64_t *)v4[1];
      uint64_t v6 = v4;
      if (v5)
      {
        do
        {
          id v7 = v5;
          int v5 = (uint64_t *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          id v7 = (uint64_t *)v6[2];
          BOOL v8 = *v7 == (void)v6;
          uint64_t v6 = v7;
        }
        while (!v8);
      }
      uint64_t v9 = v4[9];
      if (atomic_load((unsigned int *)(v9 + 128))) {
        *(_DWORD *)(v9 + 180) = a2;
      }
      pthread_mutex_lock(*(pthread_mutex_t **)(v9 + 152));
      int v11 = *(_DWORD *)(v9 + 160);
      pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 152));
      if ((v11 & 1) != 0 && *(unsigned char *)(v9 + 176) && *(_DWORD *)(v9 + 180) != a2
        || (a2 - *(_DWORD *)(v9 + 180)) > *(_DWORD *)(v9 + 184))
      {
        (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
        char v12 = (uint64_t *)v4[1];
        int v13 = v4;
        if (v12)
        {
          do
          {
            uint64_t v14 = v12;
            char v12 = (uint64_t *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            uint64_t v14 = (uint64_t *)v13[2];
            BOOL v8 = *v14 == (void)v13;
            int v13 = v14;
          }
          while (!v8);
        }
        if (*(uint64_t **)(a1 + 64) == v4) {
          *(void *)(a1 + 64) = v14;
        }
        uint64_t v15 = *(uint64_t **)(a1 + 72);
        --*(void *)(a1 + 80);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v15, v4);
        uint64_t v16 = (std::__shared_weak_count *)v4[10];
        if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
        operator delete(v4);
      }
      uint64_t v4 = v7;
    }
    while (v7 != (uint64_t *)(a1 + 72));
  }
  *(_DWORD *)(a1 + 88) = a2;
  unsigned int v17 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v17);
}

void sub_1A238B458(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(*(pthread_mutex_t **)(v1 + 40));
  _Unwind_Resume(a1);
}

void altitude::OverlayRequestManager::~OverlayRequestManager(altitude::OverlayRequestManager *this)
{
  *(void *)this = &unk_1EF567EC8;
  while (*((void *)this + 10))
    (*(void (**)(altitude::OverlayRequestManager *, uint64_t))(*(void *)this + 48))(this, *((void *)this + 8) + 32);
  std::__tree<std::__value_type<altitude::HeightFallbackRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::HeightFallbackRequestId,std::__value_type<altitude::HeightFallbackRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::HeightFallbackRequestId>,true>,std::allocator<std::__value_type<altitude::HeightFallbackRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)this + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EF567EC8;
  while (*((void *)this + 10))
    (*(void (**)(altitude::OverlayRequestManager *, uint64_t))(*(void *)this + 48))(this, *((void *)this + 8) + 32);
  std::__tree<std::__value_type<altitude::HeightFallbackRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::HeightFallbackRequestId,std::__value_type<altitude::HeightFallbackRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::HeightFallbackRequestId>,true>,std::allocator<std::__value_type<altitude::HeightFallbackRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)this + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(this);
}

void sub_1A238B514(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<altitude::HeightFallbackRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::HeightFallbackRequestId,std::__value_type<altitude::HeightFallbackRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::HeightFallbackRequestId>,true>,std::allocator<std::__value_type<altitude::HeightFallbackRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)v1 + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(v1);
  _Unwind_Resume(a1);
}

void sub_1A238B5CC(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<altitude::HeightFallbackRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::HeightFallbackRequestId,std::__value_type<altitude::HeightFallbackRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::HeightFallbackRequestId>,true>,std::allocator<std::__value_type<altitude::HeightFallbackRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)v1 + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(v1);
  _Unwind_Resume(a1);
}

void karo::StaticSphereTreeElement::~StaticSphereTreeElement(karo::StaticSphereTreeElement *this)
{
}

void karo::StaticSphereTreeElement::build(uint64_t a1, void *a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  while (1)
  {
    *(void *)(a1 + 8) = a5;
    *(void *)(a1 + 16) = a6;
    if (a4 <= a3) {
      break;
    }
    unint64_t v6 = a4;
    unint64_t v7 = a3;
    BOOL v8 = a2;
    uint64_t v9 = a1;
    uint64_t v10 = *a2;
    int v11 = (int8x16_t *)(*a2 + 8 * a3);
    float64x2_t v12 = *(float64x2_t *)(v11->i64[0] + 40);
    float64x2_t v13 = *(float64x2_t *)(v11->i64[0] + 56);
    if (a3 + 1 < a4)
    {
      unint64_t v14 = ~a3 + a4;
      uint64_t v15 = &v11->i64[1];
      while (1)
      {
        float64x2_t v20 = *(float64x2_t *)(*v15 + 40);
        float64x2_t v21 = vsubq_f64(v20, v12);
        float64x2_t v22 = vmulq_f64(v21, v21);
        float64x2_t v23 = vaddq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v22, 1), v22);
        float64x2_t v19 = *(float64x2_t *)(*v15 + 56);
        float64x2_t v24 = vsubq_f64(v19, v13);
        double v25 = sqrt(vmlaq_f64(v23, v24, v24).f64[0]);
        double v26 = *(double *)(*v15 + 64);
        double v27 = v25 + v26;
        if (v26 + v13.f64[1] >= v25)
        {
          if (v13.f64[1] >= v27)
          {
            float64x2_t v19 = v13;
            goto LABEL_5;
          }
          if (v26 >= v25 + v13.f64[1]) {
            goto LABEL_6;
          }
        }
        double v16 = fmin(v25 - v26, -v13.f64[1]);
        double v17 = (fmax(v13.f64[1], v27) - v16) * 0.5;
        double v18 = (v17 + v16) / v25;
        v19.f64[0] = v13.f64[0] + v18 * v24.f64[0];
        float64x2_t v12 = vmlaq_n_f64(v12, v21, v18);
        v19.f64[1] = v17;
LABEL_5:
        float64x2_t v20 = v12;
LABEL_6:
        ++v15;
        float64x2_t v13 = v19;
        float64x2_t v12 = v20;
        if (!--v14) {
          goto LABEL_13;
        }
      }
    }
    float64x2_t v19 = *(float64x2_t *)(v11->i64[0] + 56);
    float64x2_t v20 = *(float64x2_t *)(v11->i64[0] + 40);
LABEL_13:
    *(float64x2_t *)(v9 + 40) = v20;
    *(float64x2_t *)(v9 + 56) = v19;
    unint64_t v28 = a4 - 1;
    unint64_t v29 = a4 - a3;
    if (a4 == a3)
    {
      unsigned int v56 = karo::elementLess<0>;
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**,false>((uint64_t)v11, v11, (unsigned int (**)(uint64_t))&v56, 0, 1);
      uint64_t v30 = 8 * v28;
      char v31 = (int8x16_t *)(*v8 + 8 * v7);
      double v32 = *(double *)(*(void *)(*v8 + 8 * v28) + 40) - *(double *)(v31->i64[0] + 40);
      if (v32 >= 0.0) {
        int v33 = 0;
      }
      else {
        int v33 = -1;
      }
      if (v32 >= 0.0) {
        double v34 = v32;
      }
      else {
        double v34 = 0.0;
      }
      unsigned int v56 = karo::elementLess<1>;
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**,false>((uint64_t)v31, v31, (unsigned int (**)(uint64_t))&v56, 0, 1);
      id v35 = (int8x16_t *)(*v8 + 8 * v7);
      double v36 = *(double *)(*(void *)(*v8 + v30) + 48) - *(double *)(v35->i64[0] + 48);
      if (v36 >= v34) {
        int v33 = 1;
      }
      double v37 = fmax(v36, v34);
      unsigned int v56 = karo::elementLess<2>;
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**,false>((uint64_t)v35, v35, (unsigned int (**)(uint64_t))&v56, 0, 1);
      uint64_t v38 = *v8;
      double v39 = *(double *)(*(void *)(*v8 + v30) + 56);
      uint64_t v40 = *(void *)(*v8 + 8 * v7);
    }
    else
    {
      uint64_t v41 = 8 * a4;
      unsigned int v56 = karo::elementLess<0>;
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**,false>((uint64_t)v11, (int8x16_t *)(v10 + 8 * a4), (unsigned int (**)(uint64_t))&v56, 126 - 2 * __clz((uint64_t)(v10 + 8 * a4 - (void)v11) >> 3), 1);
      uint64_t v42 = *v8;
      uint64_t v43 = 8 * v28;
      uint64_t v44 = *v8 + 8 * v7;
      double v45 = *(double *)(*(void *)(*v8 + 8 * v28) + 40) - *(double *)(*(void *)v44 + 40);
      if (v45 >= 0.0) {
        int v33 = 0;
      }
      else {
        int v33 = -1;
      }
      if (v45 >= 0.0) {
        double v46 = v45;
      }
      else {
        double v46 = 0.0;
      }
      unsigned int v56 = karo::elementLess<1>;
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**,false>(v44, (int8x16_t *)(v42 + v41), (unsigned int (**)(uint64_t))&v56, 126 - 2 * __clz((v42 + v41 - v44) >> 3), 1);
      uint64_t v47 = *v8;
      uint64_t v48 = *v8 + 8 * v7;
      double v49 = *(double *)(*(void *)(*v8 + v43) + 48) - *(double *)(*(void *)v48 + 48);
      if (v49 >= v46) {
        int v33 = 1;
      }
      double v37 = fmax(v49, v46);
      unsigned int v56 = karo::elementLess<2>;
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**,false>(v48, (int8x16_t *)(v47 + v41), (unsigned int (**)(uint64_t))&v56, 126 - 2 * __clz((v47 + v41 - v48) >> 3), 1);
      uint64_t v38 = *v8;
      double v39 = *(double *)(*(void *)(*v8 + v43) + 56);
      uint64_t v40 = *(void *)(*v8 + 8 * v7);
    }
    if (v39 - *(double *)(v40 + 56) >= v37)
    {
      int v33 = 2;
    }
    else if (v33 < 0)
    {
      goto LABEL_40;
    }
    uint64_t v50 = v38 + 8 * v7;
    unint64_t v51 = (int8x16_t *)(v38 + 8 * v6);
    unsigned int v56 = (BOOL (*)(uint64_t, uint64_t))off_1EF590650[v33];
    unint64_t v52 = 126 - 2 * __clz(((uint64_t)v51->i64 - v50) >> 3);
    if (v6 == v7) {
      uint64_t v53 = 0;
    }
    else {
      uint64_t v53 = v52;
    }
    std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**,false>(v50, v51, (unsigned int (**)(uint64_t))&v56, v53, 1);
LABEL_40:
    uint64_t v54 = (v29 >> 1);
    if ((v29 & 0x1FFFFFFFELL) == 2)
    {
      *(void *)(v9 + 24) = *(void *)(*v8 + 8 * v7);
    }
    else
    {
      karo::Pool<karo::StaticSphereTreeElement>::construct<>((uint64_t **)(*(void *)(v9 + 8) + 8));
      *(void *)(v9 + 24) = v55;
      if (!v55) {
        goto LABEL_44;
      }
    }
    karo::StaticSphereTreeElement::build();
LABEL_44:
    if (v29 - (v29 >> 1) == 1)
    {
      a3 = v54 + v7;
      a1 = *(void *)(*v8 + 8 * (v54 + v7));
      *(void *)(v9 + 32) = a1;
      a5 = *(void *)(v9 + 8);
      a2 = v8;
      a4 = v54 + v7;
    }
    else
    {
      karo::Pool<karo::StaticSphereTreeElement>::construct<>((uint64_t **)(*(void *)(v9 + 8) + 8));
      *(void *)(v9 + 32) = a1;
      if (!a1) {
        return;
      }
      a3 = v54 + v7;
      a4 = v54 + v7 + v29 - (v29 >> 1);
      a5 = *(void *)(v9 + 8);
      a2 = v8;
    }
    a6 = v9;
  }
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**,false>(uint64_t result, int8x16_t *a2, unsigned int (**a3)(uint64_t), uint64_t a4, char a5)
{
  uint64_t v9 = (int8x16_t *)result;
  while (2)
  {
    uint64_t v10 = a2;
    int v11 = &a2[-1].i64[1];
    float64x2_t v12 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = v12;
          uint64_t v13 = (char *)v10 - (char *)v12;
          uint64_t v14 = ((char *)v10 - (char *)v12) >> 3;
          if (v6 || !v5)
          {
            switch(v14)
            {
              case 0:
              case 1:
                return result;
              case 2:
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12->i64[0]);
                if (!result) {
                  return result;
                }
                uint64_t v77 = v12->i64[0];
                v12->i64[0] = *v11;
                goto LABEL_169;
              case 3:
                char v78 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v12->i64[1], v12->i64[0]);
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12->i64[1]);
                if (v78)
                {
                  uint64_t v79 = v12->i64[0];
                  if (result)
                  {
                    v12->i64[0] = *v11;
                    *int v11 = v79;
                  }
                  else
                  {
                    v12->i64[0] = v12->i64[1];
                    v12->i64[1] = v79;
                    uint64_t result = ((uint64_t (*)(uint64_t))*a3)(*v11);
                    if (result)
                    {
                      uint64_t v77 = v12->i64[1];
                      v12->i64[1] = *v11;
LABEL_169:
                      *int v11 = v77;
                    }
                  }
                }
                else if (result)
                {
                  uint64_t v105 = v12->i64[1];
                  v12->i64[1] = *v11;
                  *int v11 = v105;
                  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v12->i64[1], v12->i64[0]);
LABEL_143:
                  if (result) {
                    *float64x2_t v12 = vextq_s8(*v12, *v12, 8uLL);
                  }
                }
                break;
              case 4:
                return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**>(v12, &v12->i64[1], (int8x16_t *)v12[1].i64, v11, a3);
              case 5:
                uint64_t v80 = v12 + 1;
                BOOL v81 = &v12[1].i64[1];
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**>(v12, &v12->i64[1], (int8x16_t *)v12[1].i64, &v12[1].i64[1], a3);
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12[1].i64[1]);
                if (!result) {
                  return result;
                }
                uint64_t v82 = *v81;
                *BOOL v81 = *v11;
                *int v11 = v82;
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v81, v80->i64[0]);
                if (!result) {
                  return result;
                }
                uint64_t v83 = v80->i64[0];
                v80->i64[0] = *v81;
                *BOOL v81 = v83;
                uint64_t result = ((uint64_t (*)(void))*a3)();
                if (!result) {
                  return result;
                }
                uint64_t v85 = v12->i64[1];
                uint64_t v84 = v12[1].i64[0];
                uint64_t v86 = v12->i64[0];
                v12->i64[1] = v84;
                v12[1].i64[0] = v85;
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v84, v86);
                goto LABEL_143;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v13 <= 191)
          {
            uint64_t v87 = &v12->i64[1];
            BOOL v89 = v12 == v10 || v87 == (uint64_t *)v10;
            if (a5)
            {
              if (!v89)
              {
                uint64_t v90 = 0;
                uint64_t v91 = (uint64_t *)v12;
                do
                {
                  uint64_t v94 = *v91;
                  uint64_t v93 = v91[1];
                  uint64_t v91 = v87;
                  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v93, v94);
                  if (result)
                  {
                    uint64_t v95 = *v91;
                    uint64_t v96 = v90;
                    do
                    {
                      *(uint64_t *)((char *)&v12->i64[1] + v96) = *(uint64_t *)((char *)v12->i64 + v96);
                      if (!v96)
                      {
                        unint64_t v92 = (uint64_t *)v12;
                        goto LABEL_117;
                      }
                      uint64_t result = ((uint64_t (*)(uint64_t, void))*a3)(v95, *(uint64_t *)((char *)&v12->i64[-1] + v96));
                      v96 -= 8;
                    }
                    while ((result & 1) != 0);
                    unint64_t v92 = (uint64_t *)((char *)&v12->i64[1] + v96);
LABEL_117:
                    uint64_t *v92 = v95;
                  }
                  uint64_t v87 = v91 + 1;
                  v90 += 8;
                }
                while (v91 + 1 != (uint64_t *)a2);
              }
            }
            else if (!v89)
            {
              do
              {
                uint64_t v107 = v9->i64[0];
                uint64_t v106 = v9->i64[1];
                uint64_t v9 = (int8x16_t *)v87;
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v106, v107);
                if (result)
                {
                  uint64_t v108 = v9->i64[0];
                  long long v109 = (uint64_t *)v9;
                  do
                  {
                    long long v110 = v109;
                    uint64_t v111 = *--v109;
                    *long long v110 = v111;
                    uint64_t result = ((uint64_t (*)(uint64_t, void))*a3)(v108, *(v110 - 2));
                  }
                  while ((result & 1) != 0);
                  *long long v109 = v108;
                }
                uint64_t v87 = &v9->i64[1];
              }
              while (&v9->u64[1] != (unint64_t *)a2);
            }
            return result;
          }
          if (!a4)
          {
            if (v12 != v10)
            {
              int64_t v97 = (unint64_t)(v14 - 2) >> 1;
              int64_t v128 = v97;
              do
              {
                if (v128 >= v97)
                {
                  uint64_t v99 = (2 * v97) | 1;
                  unint64_t v100 = &v9->i64[v99];
                  if (2 * v97 + 2 < v14 && ((unsigned int (*)(uint64_t, uint64_t))*a3)(*v100, v100[1]))
                  {
                    ++v100;
                    uint64_t v99 = 2 * v97 + 2;
                  }
                  int v101 = &v9->i64[v97];
                  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v100, *v101);
                  if ((result & 1) == 0)
                  {
                    uint64_t v126 = *v101;
                    do
                    {
                      int v102 = v100;
                      *int v101 = *v100;
                      if (v128 < v99) {
                        break;
                      }
                      uint64_t v103 = (2 * v99) | 1;
                      unint64_t v100 = &v9->i64[v103];
                      uint64_t v104 = 2 * v99 + 2;
                      if (v104 < v14 && ((unsigned int (*)(uint64_t, uint64_t))*a3)(*v100, v100[1]))
                      {
                        ++v100;
                        uint64_t v103 = v104;
                      }
                      uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v100, v126);
                      int v101 = v102;
                      uint64_t v99 = v103;
                    }
                    while (!result);
                    uint64_t *v102 = v126;
                  }
                }
                BOOL v98 = v97-- <= 0;
              }
              while (!v98);
              uint64_t v112 = (unint64_t)v13 >> 3;
              do
              {
                uint64_t v113 = 0;
                uint64_t v114 = v9->i64[0];
                uint64_t v115 = (uint64_t *)v9;
                do
                {
                  float64x2_t v116 = (unint64_t *)&v115[v113 + 1];
                  uint64_t v117 = (2 * v113) | 1;
                  uint64_t v118 = 2 * v113 + 2;
                  if (v118 < v112)
                  {
                    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v115[v113 + 1], v115[v113 + 2]);
                    if (result)
                    {
                      ++v116;
                      uint64_t v117 = v118;
                    }
                  }
                  *uint64_t v115 = *v116;
                  uint64_t v115 = (uint64_t *)v116;
                  uint64_t v113 = v117;
                }
                while (v117 <= (uint64_t)((unint64_t)(v112 - 2) >> 1));
                long long v119 = &a2[-1].i64[1];
                BOOL v6 = v116 == &a2[-1].u64[1];
                a2 = (int8x16_t *)((char *)a2 - 8);
                if (v6)
                {
                  unint64_t *v116 = v114;
                }
                else
                {
                  unint64_t *v116 = *v119;
                  uint64_t *v119 = v114;
                  uint64_t v120 = (char *)v116 - (char *)v9 + 8;
                  if (v120 >= 9)
                  {
                    unint64_t v121 = (((unint64_t)v120 >> 3) - 2) >> 1;
                    long long v122 = &v9->i64[v121];
                    uint64_t result = ((uint64_t (*)(uint64_t, unint64_t))*a3)(*v122, *v116);
                    if (result)
                    {
                      unint64_t v123 = *v116;
                      do
                      {
                        long long v124 = v122;
                        unint64_t *v116 = *v122;
                        if (!v121) {
                          break;
                        }
                        unint64_t v121 = (v121 - 1) >> 1;
                        long long v122 = &v9->i64[v121];
                        uint64_t result = ((uint64_t (*)(uint64_t, unint64_t))*a3)(*v122, v123);
                        float64x2_t v116 = (unint64_t *)v124;
                      }
                      while ((result & 1) != 0);
                      uint64_t *v124 = v123;
                    }
                  }
                }
                BOOL v98 = v112-- <= 2;
              }
              while (!v98);
            }
            return result;
          }
          unint64_t v15 = (unint64_t)v14 >> 1;
          double v16 = *a3;
          if ((unint64_t)v13 >= 0x401)
          {
            char v17 = ((uint64_t (*)(uint64_t, uint64_t))v16)(v9->i64[v15], v9->i64[0]);
            int v18 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v9->i64[v15]);
            if (v17)
            {
              uint64_t v19 = v9->i64[0];
              if (v18)
              {
                v9->i64[0] = *v11;
                *int v11 = v19;
              }
              else
              {
                v9->i64[0] = v9->i64[v15];
                v9->i64[v15] = v19;
                if ((*a3)(*v11))
                {
                  uint64_t v27 = v9->i64[v15];
                  v9->i64[v15] = *v11;
                  *int v11 = v27;
                }
              }
            }
            else if (v18)
            {
              uint64_t v23 = v9->i64[v15];
              v9->i64[v15] = *v11;
              *int v11 = v23;
              if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v9->i64[v15], v9->i64[0]))
              {
                uint64_t v24 = v9->i64[0];
                v9->i64[0] = v9->i64[v15];
                v9->i64[v15] = v24;
              }
            }
            unint64_t v28 = v15 - 1;
            uint64_t v29 = v15 - 1;
            char v30 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[v29], v9->i64[1]);
            int v31 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v10[-1].i64[0], v9->i64[v29]);
            uint64_t v125 = a4;
            if (v30)
            {
              uint64_t v32 = v9->i64[1];
              if (v31)
              {
                v9->i64[1] = v10[-1].i64[0];
                v10[-1].i64[0] = v32;
              }
              else
              {
                v9->i64[1] = v9->i64[v29];
                v9->i64[v29] = v32;
                if ((*a3)(v10[-1].i64[0]))
                {
                  uint64_t v36 = v9->i64[v29];
                  v9->i64[v29] = v10[-1].i64[0];
                  v10[-1].i64[0] = v36;
                }
              }
            }
            else if (v31)
            {
              uint64_t v33 = v9->i64[v29];
              v9->i64[v29] = v10[-1].i64[0];
              v10[-1].i64[0] = v33;
              if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v9->i64[v29], v9->i64[1]))
              {
                uint64_t v34 = v9->i64[1];
                v9->i64[1] = v9->i64[v29];
                v9->i64[v29] = v34;
              }
            }
            unint64_t v37 = v15 + 1;
            uint64_t v38 = v15 + 1;
            char v39 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[v38], v9[1].i64[0]);
            int v40 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v10[-2].i64[1], v9->i64[v38]);
            if (v39)
            {
              uint64_t v41 = v9[1].i64[0];
              if (v40)
              {
                v9[1].i64[0] = v10[-2].i64[1];
                v10[-2].i64[1] = v41;
              }
              else
              {
                v9[1].i64[0] = v9->i64[v38];
                v9->i64[v38] = v41;
                if ((*a3)(v10[-2].i64[1]))
                {
                  uint64_t v44 = v9->i64[v38];
                  v9->i64[v38] = v10[-2].i64[1];
                  v10[-2].i64[1] = v44;
                }
              }
            }
            else if (v40)
            {
              uint64_t v42 = v9->i64[v38];
              v9->i64[v38] = v10[-2].i64[1];
              v10[-2].i64[1] = v42;
              if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v9->i64[v38], v9[1].i64[0]))
              {
                uint64_t v43 = v9[1].i64[0];
                v9[1].i64[0] = v9->i64[v38];
                v9->i64[v38] = v43;
              }
            }
            char v45 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[v15], v9->i64[v28]);
            int v46 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[v37], v9->i64[v15]);
            if (v45)
            {
              uint64_t v47 = v9->i64[v28];
              if (v46)
              {
                v9->i64[v28] = v9->i64[v38];
                v9->i64[v38] = v47;
                uint64_t v48 = v9->i64[v15];
                int v11 = &a2[-1].i64[1];
              }
              else
              {
                v9->i64[v28] = v9->i64[v15];
                v9->i64[v15] = v47;
                unsigned int v51 = (*a3)(v9->i64[v37]);
                uint64_t v48 = v9->i64[v15];
                int v11 = &a2[-1].i64[1];
                if (v51)
                {
                  uint64_t v52 = v9->i64[v38];
                  v9->i64[v15] = v52;
                  v9->i64[v38] = v48;
                  uint64_t v48 = v52;
                }
              }
              a4 = v125;
            }
            else
            {
              uint64_t v48 = v9->i64[v15];
              a4 = v125;
              if (v46)
              {
                v9->i64[v15] = v9->i64[v38];
                v9->i64[v38] = v48;
                int v49 = ((uint64_t (*)(void))*a3)();
                uint64_t v48 = v9->i64[v15];
                if (v49)
                {
                  uint64_t v50 = v9->i64[v29];
                  v9->i64[v29] = v48;
                  v9->i64[v15] = v50;
                  uint64_t v48 = v50;
                }
              }
              int v11 = &a2[-1].i64[1];
            }
            uint64_t v53 = v9->i64[0];
            v9->i64[0] = v48;
            v9->i64[v15] = v53;
          }
          else
          {
            char v20 = ((uint64_t (*)(uint64_t, uint64_t))v16)(v9->i64[0], v9->i64[v15]);
            int v21 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v9->i64[0]);
            if (v20)
            {
              uint64_t v22 = v9->i64[v15];
              if (v21)
              {
                v9->i64[v15] = *v11;
                *int v11 = v22;
              }
              else
              {
                v9->i64[v15] = v9->i64[0];
                v9->i64[0] = v22;
                if ((*a3)(*v11))
                {
                  uint64_t v35 = v9->i64[0];
                  v9->i64[0] = *v11;
                  *int v11 = v35;
                }
              }
            }
            else if (v21)
            {
              uint64_t v25 = v9->i64[0];
              v9->i64[0] = *v11;
              *int v11 = v25;
              if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v9->i64[0], v9->i64[v15]))
              {
                uint64_t v26 = v9->i64[v15];
                v9->i64[v15] = v9->i64[0];
                v9->i64[0] = v26;
              }
            }
          }
          --a4;
          uint64_t v54 = v9->i64[0];
          if (a5) {
            break;
          }
          char v55 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9[-1].i64[1], v9->i64[0]);
          uint64_t v54 = v9->i64[0];
          if (v55) {
            break;
          }
          uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[0], *v11);
          if (result)
          {
            float64x2_t v12 = v9;
            do
            {
              uint64_t v69 = v12->i64[1];
              float64x2_t v12 = (int8x16_t *)((char *)v12 + 8);
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v54, v69);
            }
            while ((result & 1) == 0);
          }
          else
          {
            uint64_t v70 = (int8x16_t *)&v9->u64[1];
            do
            {
              float64x2_t v12 = v70;
              if (v70 >= a2) {
                break;
              }
              uint64_t v70 = (int8x16_t *)((char *)v70 + 8);
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v54, v12->i64[0]);
            }
            while (!result);
          }
          uint64_t v10 = a2;
          int v71 = a2;
          if (v12 < a2)
          {
            int v71 = a2;
            do
            {
              uint64_t v72 = v71[-1].i64[1];
              int v71 = (int8x16_t *)((char *)v71 - 8);
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v54, v72);
            }
            while ((result & 1) != 0);
          }
          while (v12 < v71)
          {
            uint64_t v73 = v12->i64[0];
            v12->i64[0] = v71->i64[0];
            v71->i64[0] = v73;
            do
            {
              uint64_t v74 = v12->i64[1];
              float64x2_t v12 = (int8x16_t *)((char *)v12 + 8);
            }
            while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v54, v74));
            do
            {
              uint64_t v75 = v71[-1].i64[1];
              int v71 = (int8x16_t *)((char *)v71 - 8);
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v54, v75);
            }
            while ((result & 1) != 0);
          }
          size_t v76 = &v12[-1].i64[1];
          BOOL v5 = &v12[-1].u64[1] >= (unint64_t *)v9;
          BOOL v6 = &v12[-1].u64[1] == (unint64_t *)v9;
          if (&v12[-1].u64[1] != (unint64_t *)v9) {
            v9->i64[0] = *v76;
          }
          a5 = 0;
          *size_t v76 = v54;
        }
        unsigned int v56 = (uint64_t *)v9;
        do
        {
          int v57 = (int8x16_t *)v56;
          uint64_t v58 = v56[1];
          ++v56;
        }
        while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v58, v54) & 1) != 0);
        uint64_t v59 = a4;
        uint64_t v60 = (uint64_t *)v10;
        if (v57 == v9)
        {
          uint64_t v60 = (uint64_t *)v10;
          do
          {
            if (v56 >= v60) {
              break;
            }
            uint64_t v62 = *--v60;
          }
          while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v62, v54) & 1) == 0);
        }
        else
        {
          do
            uint64_t v61 = *--v60;
          while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v61, v54));
        }
        if (v56 < v60)
        {
          size_t v63 = (int8x16_t *)v56;
          unint64_t v64 = (int8x16_t *)v60;
          do
          {
            uint64_t v65 = v63->i64[0];
            v63->i64[0] = v64->i64[0];
            v64->i64[0] = v65;
            do
            {
              int v57 = v63;
              uint64_t v66 = v63->i64[1];
              size_t v63 = (int8x16_t *)((char *)v63 + 8);
            }
            while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v66, v54) & 1) != 0);
            do
            {
              uint64_t v67 = v64[-1].i64[1];
              unint64_t v64 = (int8x16_t *)((char *)v64 - 8);
            }
            while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v67, v54));
          }
          while (v63 < v64);
        }
        if (v57 != v9) {
          v9->i64[0] = v57->i64[0];
        }
        v57->i64[0] = v54;
        uint64_t v10 = a2;
        a4 = v59;
        if (v56 >= v60) {
          break;
        }
LABEL_73:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**,false>(v9, v57, a3, a4, a5 & 1);
        a5 = 0;
        float64x2_t v12 = (int8x16_t *)&v57->u64[1];
      }
      BOOL v68 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**>(v9, v57, a3);
      float64x2_t v12 = (int8x16_t *)&v57->u64[1];
      uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**>(&v57->i64[1], a2, a3);
      if (result) {
        break;
      }
      if (!v68) {
        goto LABEL_73;
      }
    }
    a2 = v57;
    if (!v68) {
      continue;
    }
    return result;
  }
}

BOOL karo::elementLess<2>(uint64_t a1, uint64_t a2)
{
  return *(double *)(a1 + 56) < *(double *)(a2 + 56);
}

BOOL karo::elementLess<1>(uint64_t a1, uint64_t a2)
{
  return *(double *)(a1 + 48) < *(double *)(a2 + 48);
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**>(void *a1, void *a2, unsigned int (**a3)(uint64_t))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(void, void))*a3)(*(a2 - 1), *a1))
      {
        uint64_t v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      char v9 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
      int v10 = ((uint64_t (*)(void, void))*a3)(*(a2 - 1), a1[1]);
      if (v9)
      {
        uint64_t v11 = *a1;
        if (v10)
        {
          *a1 = *(a2 - 1);
          *(a2 - 1) = v11;
        }
        else
        {
          *a1 = a1[1];
          a1[1] = v11;
          if ((*a3)(*(a2 - 1)))
          {
            uint64_t v26 = a1[1];
            a1[1] = *(a2 - 1);
            *(a2 - 1) = v26;
          }
        }
      }
      else if (v10)
      {
        uint64_t v24 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v24;
        int v19 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
LABEL_17:
        if (v19) {
          *(int8x16_t *)a1 = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
        }
      }
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      float64x2_t v12 = a1 + 2;
      uint64_t v13 = a1 + 3;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**>(a1, a1 + 1, a1 + 2, a1 + 3, a3);
      if (!((unsigned int (*)(void, void))*a3)(*(a2 - 1), a1[3])) {
        return 1;
      }
      uint64_t v14 = *v13;
      *uint64_t v13 = *(a2 - 1);
      *(a2 - 1) = v14;
      if (!((unsigned int (*)(void, void))*a3)(*v13, *v12)) {
        return 1;
      }
      uint64_t v15 = *v12;
      *float64x2_t v12 = *v13;
      *uint64_t v13 = v15;
      if (!((unsigned int (*)(void))*a3)()) {
        return 1;
      }
      uint64_t v17 = a1[1];
      uint64_t v16 = a1[2];
      uint64_t v18 = *a1;
      a1[1] = v16;
      a1[2] = v17;
      int v19 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v16, v18);
      goto LABEL_17;
    default:
      char v20 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
      int v21 = a1 + 2;
      int v22 = ((uint64_t (*)(void, void))*a3)(a1[2], a1[1]);
      if (v20)
      {
        uint64_t v23 = *a1;
        if (v22)
        {
          *a1 = a1[2];
          a1[2] = v23;
        }
        else
        {
          uint64_t v27 = a1[2];
          *a1 = a1[1];
          a1[1] = v23;
          if ((*a3)(v27)) {
            *(int8x16_t *)(a1 + 1) = vextq_s8(*(int8x16_t *)(a1 + 1), *(int8x16_t *)(a1 + 1), 8uLL);
          }
        }
      }
      else if (v22)
      {
        uint64_t v25 = a1[1];
        a1[1] = a1[2];
        a1[2] = v25;
        if (((unsigned int (*)(void))*a3)()) {
          *(int8x16_t *)a1 = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
        }
      }
      unint64_t v28 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v29 = 0;
      int v30 = 0;
      break;
  }
  while (1)
  {
    if (((unsigned int (*)(void, void))*a3)(*v28, *v21))
    {
      uint64_t v32 = *v28;
      uint64_t v33 = v29;
      do
      {
        uint64_t v34 = (char *)a1 + v33;
        *(void *)((char *)a1 + v33 + 24) = *(void *)((char *)a1 + v33 + 16);
        if (v33 == -16)
        {
          int v31 = a1;
          goto LABEL_29;
        }
        v33 -= 8;
      }
      while ((((uint64_t (*)(uint64_t, void))*a3)(v32, *((void *)v34 + 1)) & 1) != 0);
      int v31 = (void *)((char *)a1 + v33 + 24);
LABEL_29:
      *int v31 = v32;
      if (++v30 == 8) {
        return v28 + 1 == a2;
      }
    }
    int v21 = v28;
    v29 += 8;
    if (++v28 == a2) {
      return 1;
    }
  }
}

BOOL karo::elementLess<0>(uint64_t a1, uint64_t a2)
{
  return *(double *)(a1 + 40) < *(double *)(a2 + 40);
}

uint64_t md::Ribbons::RibbonBatch<md::Ribbons::DottedRouteLineRibbonDescriptor>::~RibbonBatch(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5539F0;
  uint64_t v2 = *(uint64_t **)(a1 + 248);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 256);
    uint64_t v4 = *(void **)(a1 + 248);
    if (v3 != v2)
    {
      do
        std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](--v3, 0);
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 248);
    }
    *(void *)(a1 + 256) = v2;
    operator delete(v4);
  }
  BOOL v5 = *(void **)(a1 + 224);
  do
  {
    if (v5[1])
    {
      unint64_t v6 = 0;
      unint64_t v7 = v5 + 2;
      uint64_t v8 = v5 + 2;
      char v9 = (void (***)(void))(v5 + 2);
      do
      {
        int v10 = (void (**)(void *))*v9;
        v9 += 15;
        (*v10)(v8);
        ++v6;
        v7 += 15;
        uint64_t v8 = v9;
      }
      while (v6 < v5[1]);
    }
    v5[1] = 0;
    BOOL v5 = (void *)*v5;
  }
  while (v5);
  uint64_t v11 = *(void ***)(a1 + 224);
  *(void *)(a1 + 232) = v11;
  float64x2_t v12 = *v11;
  *uint64_t v11 = 0;
  if (v12)
  {
    do
    {
      uint64_t v13 = (void *)*v12;
      free(v12);
      float64x2_t v12 = v13;
    }
    while (v13);
    uint64_t v11 = *(void ***)(a1 + 224);
  }
  free(v11);
  uint64_t v14 = *(void **)(a1 + 200);
  if (v14)
  {
    *(void *)(a1 + 208) = v14;
    operator delete(v14);
  }
  uint64_t v15 = *(void *)(a1 + 168);
  if (v15)
  {
    uint64_t v16 = *(void *)(a1 + 176);
    uint64_t v17 = *(void *)(a1 + 168);
    if (v16 != v15)
    {
      uint64_t v18 = *(void *)(a1 + 176);
      do
      {
        char v20 = *(void **)(v18 - 24);
        v18 -= 24;
        int v19 = v20;
        if (v20)
        {
          *(void *)(v16 - 16) = v19;
          operator delete(v19);
        }
        uint64_t v16 = v18;
      }
      while (v18 != v15);
      uint64_t v17 = *(void *)(a1 + 168);
    }
    *(void *)(a1 + 176) = v15;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 192) + 40))(*(void *)(a1 + 192), v17, *(void *)(a1 + 184) - v17);
  }
  int v21 = *(void **)(a1 + 144);
  if (v21)
  {
    *(void *)(a1 + 152) = v21;
    operator delete(v21);
  }
  *(void *)(a1 + 16) = &off_1EF55A458;
  *(void *)(a1 + 32) = 3131955885;
  return a1;
}

uint64_t *std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  void *result = a2;
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 56);
    if (v3)
    {
      uint64_t v4 = *(void **)(v2 + 64);
      uint64_t v5 = *(void *)(v2 + 56);
      if (v4 != v3)
      {
        do
        {
          unint64_t v7 = (void (***)(void, uint64_t))*--v4;
          unint64_t v6 = v7;
          *uint64_t v4 = 0;
          if (v7)
          {
            (**v6)(v6, v5);
            {
              operator new();
            }
            (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                             + 40))(mdm::Allocator::instance(void)::alloc, v6, 112);
          }
        }
        while (v4 != v3);
        uint64_t v5 = *(void *)(v2 + 56);
      }
      *(void *)(v2 + 64) = v3;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 80) + 40))(*(void *)(v2 + 80), v5, *(void *)(v2 + 72) - v5);
    }
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void md::Ribbons::RibbonBatch<md::Ribbons::DottedRouteLineRibbonDescriptor>::~RibbonBatch(uint64_t a1)
{
  md::Ribbons::RibbonBatch<md::Ribbons::DottedRouteLineRibbonDescriptor>::~RibbonBatch(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::ConstantDataTyped<ggl::RouteLine::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::RouteLine::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::RouteLine::Style>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::RouteLine::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587988;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::RouteLine::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587988;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::DottedRouteLineBatch::~DottedRouteLineBatch(md::DottedRouteLineBatch *this)
{
  *(void *)this = &unk_1EF53D500;
  uint64_t v2 = *((void *)this + 36);
  *((void *)this + 36) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  md::Ribbons::RibbonBatch<md::Ribbons::DottedRouteLineRibbonDescriptor>::~RibbonBatch((uint64_t)this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF53D500;
  uint64_t v2 = *((void *)this + 36);
  *((void *)this + 36) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  md::Ribbons::RibbonBatch<md::Ribbons::DottedRouteLineRibbonDescriptor>::~RibbonBatch((uint64_t)this);
}

void md::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::RibbonLayer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    int v73 = a6[24];
    if (a6[24])
    {
      char v6 = a6[1];
      char v74 = *a6;
      uint64_t v8 = *(void *)(a6 + 4);
    }
    else
    {
      char v74 = 0;
    }
    *(void *)a1 = &unk_1EF553C30;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(void *)(a1 + 72) = 0;
    *(unsigned char *)(a1 + 80) = 0;
    *(unsigned char *)(a1 + 104) = 0;
    *(_OWORD *)(a1 + 48) = 0u;
    *(unsigned char *)(a1 + 64) = 0;
    if (v73)
    {
      *(unsigned char *)(a1 + 80) = v74;
      *(unsigned char *)(a1 + 81) = v6;
      *(void *)(a1 + 84) = v8;
      *(unsigned char *)(a1 + 104) = 1;
    }
    uint64_t v75 = operator new(0xF8uLL);
    v75[1] = 0;
    v75[2] = 0;
    *uint64_t v75 = &unk_1EF5849D8;
    ggl::BufferData::BufferData((uint64_t)(v75 + 3), 64, 0, 0, 1, 0);
    v75[29] = "BatchType/VData";
    v75[30] = &ggl::DottedRouteLine::defaultVboReflection;
    v75[3] = &unk_1EF55C5C8;
    v75[28] = &unk_1EF55C5E8;
    size_t v76 = operator new(0xF8uLL);
    v76[1] = 0;
    v76[2] = 0;
    *size_t v76 = &unk_1EF583D28;
    ggl::BufferData::BufferData((uint64_t)(v76 + 3), 2, 1, 0, 1, 0);
    *((_DWORD *)v76 + 60) = 0;
    v76[3] = &unk_1EF55B630;
    v76[4] = 2;
    v76[28] = &unk_1EF55B650;
    v76[29] = "BatchType/IData";
    operator new();
  }
  long long v78 = 0uLL;
  {
    operator new();
  }
  uint64_t v79 = mdm::Allocator::instance(void)::alloc;
  uint64_t v80 = 0;
  {
    operator new();
  }
  uint64_t v81 = mdm::Allocator::instance(void)::alloc;
  unint64_t v82 = 0;
  float v83 = 1.0;
  char v9 = *(uint64_t **)(a3 + 24);
  int v10 = *(uint64_t **)(a3 + 32);
  while (1)
  {
    if (v9 == v10) {
      operator new();
    }
    unsigned int v12 = ggl::CullingGrid::intersectedCellsForRibbon(*(void *)(*v9 + 88), *(void **)(*v9 + 72));
    unsigned int v13 = v12;
    unint64_t v14 = v12;
    size_t v15 = *((void *)&v78 + 1);
    if (*((void *)&v78 + 1))
    {
      uint8x8_t v16 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v78 + 8));
      v16.i16[0] = vaddlv_u8(v16);
      if (v16.u32[0] > 1uLL)
      {
        unint64_t v7 = v12;
        if (*((void *)&v78 + 1) <= (unint64_t)v12) {
          unint64_t v7 = (unint64_t)v12 % *((void *)&v78 + 1);
        }
      }
      else
      {
        unint64_t v7 = (DWORD2(v78) - 1) & v12;
      }
      uint64_t v17 = *(uint64_t **)(v78 + 8 * v7);
      if (v17)
      {
        uint64_t v18 = *v17;
        if (*v17)
        {
          if (v16.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v20 = *(void *)(v18 + 8);
              if (v20 == v12)
              {
                if (*(_DWORD *)(v18 + 16) == v12) {
                  goto LABEL_88;
                }
              }
              else if ((v20 & (*((void *)&v78 + 1) - 1)) != v7)
              {
                goto LABEL_28;
              }
              uint64_t v18 = *(void *)v18;
              if (!v18) {
                goto LABEL_28;
              }
            }
          }
          do
          {
            unint64_t v19 = *(void *)(v18 + 8);
            if (v19 == v12)
            {
              if (*(_DWORD *)(v18 + 16) == v12) {
                goto LABEL_88;
              }
            }
            else
            {
              if (v19 >= *((void *)&v78 + 1)) {
                v19 %= *((void *)&v78 + 1);
              }
              if (v19 != v7) {
                break;
              }
            }
            uint64_t v18 = *(void *)v18;
          }
          while (v18);
        }
      }
    }
LABEL_28:
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v81 + 16))(v81, 56, 8);
    *(void *)uint64_t v18 = 0;
    *(void *)(v18 + 8) = v14;
    *(_DWORD *)(v18 + 16) = v13;
    *(void *)(v18 + 32) = 0;
    *(void *)(v18 + 40) = 0;
    *(void *)(v18 + 24) = 0;
    {
      operator new();
    }
    *(void *)(v18 + 48) = mdm::Allocator::instance(void)::alloc;
    float v21 = (float)(v82 + 1);
    if (!*((void *)&v78 + 1) || (float)(v83 * (float)*((unint64_t *)&v78 + 1)) < v21) {
      break;
    }
LABEL_78:
    uint64_t v42 = *(uint64_t **)(v78 + 8 * v7);
    if (v42)
    {
      *(void *)uint64_t v18 = *v42;
LABEL_86:
      uint64_t *v42 = v18;
      goto LABEL_87;
    }
    *(void *)uint64_t v18 = v80;
    uint64_t v80 = v18;
    *(void *)(v78 + 8 * v7) = &v80;
    if (*(void *)v18)
    {
      size_t v43 = *(void *)(*(void *)v18 + 8);
      if ((v15 & (v15 - 1)) != 0)
      {
        if (v43 >= v15) {
          v43 %= v15;
        }
      }
      else
      {
        v43 &= v15 - 1;
      }
      uint64_t v42 = (uint64_t *)(v78 + 8 * v43);
      goto LABEL_86;
    }
LABEL_87:
    ++v82;
LABEL_88:
    uint64_t v44 = *(void **)(v18 + 32);
    unint64_t v45 = *(void *)(v18 + 40);
    if ((unint64_t)v44 < v45)
    {
      if (v44)
      {
        uint64_t v46 = *v9;
        *char v9 = 0;
        void *v44 = v46;
      }
      uint64_t v11 = v44 + 1;
      goto LABEL_6;
    }
    uint64_t v47 = *(void *)(v18 + 24);
    uint64_t v48 = ((uint64_t)v44 - v47) >> 3;
    unint64_t v49 = v48 + 1;
    if ((unint64_t)(v48 + 1) >> 61) {
      abort();
    }
    uint64_t v50 = v45 - v47;
    if (v50 >> 2 > v49) {
      unint64_t v49 = v50 >> 2;
    }
    if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v51 = v49;
    }
    if (v51)
    {
      uint64_t v52 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v18 + 48) + 16))(*(void *)(v18 + 48), 8 * v51, 8);
      uint64_t v53 = (void *)(v52 + 8 * v48);
      uint64_t v54 = v52 + 8 * v51;
      if (v52)
      {
        uint64_t v55 = *v9;
        *char v9 = 0;
        *uint64_t v53 = v55;
      }
    }
    else
    {
      uint64_t v54 = 0;
      uint64_t v53 = (void *)(8 * v48);
    }
    uint64_t v11 = v53 + 1;
    unsigned int v56 = *(void **)(v18 + 24);
    unint64_t v57 = *(void *)(v18 + 32);
    if ((void *)v57 == v56)
    {
      *(void *)(v18 + 24) = v53;
      *(void *)(v18 + 32) = v11;
      unint64_t v7 = *(void *)(v18 + 40);
      *(void *)(v18 + 40) = v54;
      if (!v57) {
        goto LABEL_6;
      }
LABEL_117:
      (*(void (**)(void, unint64_t, unint64_t))(**(void **)(v18 + 48) + 40))(*(void *)(v18 + 48), v57, v7 - v57);
      goto LABEL_6;
    }
    unint64_t v58 = v57 - (void)v56 - 8;
    if (v58 > 0x47
      && ((unint64_t v59 = v58 >> 3, v57 - 8 * v59 - 8 >= (unint64_t)v53) || (unint64_t)&v53[-v59 - 1] >= v57))
    {
      unint64_t v65 = v59 + 1;
      uint64_t v66 = (v59 + 1) & 0x3FFFFFFFFFFFFFFCLL;
      uint64_t v60 = (void *)(v57 - 8 * v66);
      uint64_t v67 = v53 - 2;
      BOOL v68 = (long long *)(v57 - 32);
      uint64_t v69 = v66;
      do
      {
        long long v71 = *v68;
        long long v70 = v68[1];
        *BOOL v68 = 0uLL;
        v68[1] = 0uLL;
        v68 -= 2;
        *(v67 - 1) = v71;
        *uint64_t v67 = v70;
        v67 -= 2;
        v69 -= 4;
      }
      while (v69);
      v53 -= v66;
      if (v65 == v66) {
        goto LABEL_107;
      }
    }
    else
    {
      uint64_t v60 = *(void **)(v18 + 32);
    }
    do
    {
      uint64_t v61 = *--v60;
      void *v60 = 0;
      *--uint64_t v53 = v61;
    }
    while (v60 != v56);
LABEL_107:
    unint64_t v57 = *(void *)(v18 + 24);
    uint64_t v62 = *(void **)(v18 + 32);
    *(void *)(v18 + 24) = v53;
    *(void *)(v18 + 32) = v11;
    unint64_t v7 = *(void *)(v18 + 40);
    *(void *)(v18 + 40) = v54;
    while (v62 != (void *)v57)
    {
      unint64_t v64 = (void (***)(void))*--v62;
      size_t v63 = v64;
      *uint64_t v62 = 0;
      if (v64)
      {
        (**v63)(v63);
        {
          operator new();
        }
        (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                + 40))(mdm::Allocator::instance(void)::alloc, v63, 112);
      }
    }
    if (v57) {
      goto LABEL_117;
    }
LABEL_6:
    *(void *)(v18 + 32) = v11;
    ++v9;
  }
  BOOL v22 = (*((void *)&v78 + 1) & (*((void *)&v78 + 1) - 1)) != 0;
  if (*((void *)&v78 + 1) < 3uLL) {
    BOOL v22 = 1;
  }
  unint64_t v23 = v22 | (2 * *((void *)&v78 + 1));
  unint64_t v24 = vcvtps_u32_f32(v21 / v83);
  if (v23 <= v24) {
    size_t prime = v24;
  }
  else {
    size_t prime = v23;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
  }
  size_t v15 = *((void *)&v78 + 1);
  if (prime <= *((void *)&v78 + 1))
  {
    if (prime >= *((void *)&v78 + 1)) {
      goto LABEL_65;
    }
    unint64_t v36 = vcvtps_u32_f32((float)v82 / v83);
    if (*((void *)&v78 + 1) < 3uLL
      || (uint8x8_t v37 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v78 + 8)), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
    {
      unint64_t v36 = std::__next_prime(v36);
    }
    else
    {
      uint64_t v38 = 1 << -(char)__clz(v36 - 1);
      if (v36 >= 2) {
        unint64_t v36 = v38;
      }
    }
    if (prime <= v36) {
      size_t prime = v36;
    }
    if (prime >= *((void *)&v78 + 1))
    {
      size_t v15 = *((void *)&v78 + 1);
LABEL_65:
      if ((v15 & (v15 - 1)) != 0)
      {
        if (v15 <= v14) {
          unint64_t v7 = v14 % v15;
        }
        else {
          unint64_t v7 = v14;
        }
      }
      else
      {
        unint64_t v7 = (v15 - 1) & v14;
      }
      goto LABEL_78;
    }
    if (!prime)
    {
      uint64_t v72 = v78;
      *(void *)&long long v78 = 0;
      if (v72) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v79 + 40))(v79, v72, 8 * *((void *)&v78 + 1));
      }
      size_t v15 = 0;
      *((void *)&v78 + 1) = 0;
      goto LABEL_65;
    }
  }
  uint64_t v26 = (*(uint64_t (**)(uint64_t, size_t, uint64_t))(*(void *)v79 + 16))(v79, 8 * prime, 8);
  uint64_t v27 = v78;
  *(void *)&long long v78 = v26;
  if (v27) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v79 + 40))(v79, v27, 8 * *((void *)&v78 + 1));
  }
  uint64_t v28 = 0;
  *((void *)&v78 + 1) = prime;
  do
    *(void *)(v78 + 8 * v28++) = 0;
  while (prime != v28);
  uint64_t v29 = (void **)v80;
  if (!v80)
  {
LABEL_64:
    size_t v15 = prime;
    goto LABEL_65;
  }
  size_t v30 = *(void *)(v80 + 8);
  size_t v31 = prime - 1;
  if ((prime & (prime - 1)) == 0)
  {
    size_t v32 = v30 & v31;
    *(void *)(v78 + 8 * v32) = &v80;
    for (uint64_t i = *v29; *v29; uint64_t i = *v29)
    {
      size_t v34 = i[1] & v31;
      if (v34 == v32)
      {
        uint64_t v29 = (void **)i;
      }
      else if (*(void *)(v78 + 8 * v34))
      {
        *uint64_t v29 = (void *)*i;
        uint64_t v35 = 8 * v34;
        void *i = **(void **)(v78 + v35);
        **(void **)(v78 + v35) = i;
      }
      else
      {
        *(void *)(v78 + 8 * v34) = v29;
        uint64_t v29 = (void **)i;
        size_t v32 = v34;
      }
    }
    goto LABEL_64;
  }
  if (v30 >= prime) {
    v30 %= prime;
  }
  *(void *)(v78 + 8 * v30) = &v80;
  char v39 = *v29;
  if (!*v29) {
    goto LABEL_64;
  }
  while (1)
  {
    size_t v41 = v39[1];
    if (v41 >= prime) {
      v41 %= prime;
    }
    if (v41 != v30)
    {
      if (!*(void *)(v78 + 8 * v41))
      {
        *(void *)(v78 + 8 * v41) = v29;
        goto LABEL_69;
      }
      *uint64_t v29 = (void *)*v39;
      uint64_t v40 = 8 * v41;
      void *v39 = **(void **)(v78 + v40);
      **(void **)(v78 + v40) = v39;
      char v39 = v29;
    }
    size_t v41 = v30;
LABEL_69:
    uint64_t v29 = (void **)v39;
    char v39 = (void *)*v39;
    size_t v30 = v41;
    if (!v39) {
      goto LABEL_64;
    }
  }
}

void sub_1A2391210(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **a9, uint64_t a10, uint64_t *a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,void *__p,uint64_t a42,uint64_t a43,void *a44)
{
  MEMORY[0x1A6239270](v44, 0x1020C4007FF0C4BLL);
  if (v45) {
    operator delete(v45);
  }
  std::unique_ptr<gdc::GlobeTileGrid>::~unique_ptr[abi:nn180100](a11);
  uint64_t v47 = *a12;
  if (*a12)
  {
    *(void *)(a19 + 40) = v47;
    operator delete(v47);
  }
  uint64_t v48 = *a9;
  if (*a9)
  {
    *(void *)(a19 + 16) = v48;
    operator delete(v48);
    if (a39)
    {
LABEL_7:
      operator delete(a39);
      _Unwind_Resume(a1);
    }
  }
  else if (a39)
  {
    goto LABEL_7;
  }
  _Unwind_Resume(a1);
}

void md::DottedRouteLineLayer::~DottedRouteLineLayer(md::DottedRouteLineLayer *this)
{
  *(void *)this = &unk_1EF5310F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::~RibbonLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF5310F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::~RibbonLayer(this);
}

void *md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::~RibbonLayer(void *a1)
{
  *a1 = &unk_1EF553C30;
  uint64_t v2 = (void *)a1[1];
  uint64_t v3 = (void *)a1[2];
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = (void *)a1[4];
  uint64_t v5 = (void *)a1[5];
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = a1[9];
  a1[9] = 0;
  if (v6)
  {
    uint64_t v7 = *(void *)(v6 + 2584);
    if (v7) {
      MEMORY[0x1A6239250](v7, 0x1000C8000313F17);
    }
    MEMORY[0x1A6239270](v6, 0x1020C4007FF0C4BLL);
  }
  uint64_t v8 = (void *)a1[4];
  if (v8)
  {
    a1[5] = v8;
    operator delete(v8);
  }
  char v9 = (void *)a1[1];
  if (v9)
  {
    a1[2] = v9;
    operator delete(v9);
  }
  return a1;
}

void md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::~RibbonLayer(void *a1)
{
  md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::~RibbonLayer(a1);
  JUMPOUT(0x1A6239270);
}

void md::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::~RibbonLayer(void *a1)
{
  *a1 = &unk_1EF5310F8;
  uint64_t v2 = (std::__shared_weak_count *)a1[17];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[15];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[15];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::~RibbonLayer(a1);
  JUMPOUT(0x1A6239270);
}

void *md::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::~RibbonLayer(void *a1)
{
  *a1 = &unk_1EF5310F8;
  uint64_t v2 = (std::__shared_weak_count *)a1[17];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[15];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[15];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  return md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::~RibbonLayer(a1);
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DottedRouteLine::DefaultVbo>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DottedRouteLine::DefaultVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5849D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DottedRouteLine::DefaultVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5849D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::batch(std::unordered_map<md::DottedRouteLineBatchKey,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DottedRouteLineBatchKey,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*,false>(uint64_t result, int8x16_t *a2, uint64_t a3, char a4)
{
  uint64_t v6 = (int8x16_t *)result;
LABEL_2:
  uint64_t v160 = &a2[-1].i64[1];
  uint64_t v7 = v6;
  while (1)
  {
    uint64_t v6 = v7;
    uint64_t v8 = (char *)a2 - (char *)v7;
    uint64_t v9 = ((char *)a2 - (char *)v7) >> 3;
    if (!(!v5 & v4))
    {
      switch(v9)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v65 = *v160;
          uint64_t v66 = v7->i64[0];
          BOOL result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v160 + 96), v7->i64[0]);
          if (result)
          {
            v7->i64[0] = v65;
            *uint64_t v160 = v66;
          }
          break;
        case 3:
          BOOL result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7->i64, &v7->i64[1], v160);
          break;
        case 4:
          uint64_t v67 = v7 + 1;
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7->i64, &v7->i64[1], v7[1].i64);
          uint64_t v68 = *v160;
          uint64_t v69 = v7[1].i64[0];
          BOOL result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v160 + 96), v69);
          if (result)
          {
            v67->i64[0] = v68;
            *uint64_t v160 = v69;
            BOOL result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v67->i64[0] + 96), v7->i64[1]);
            if (result)
            {
              int8x16_t v70 = *(int8x16_t *)((char *)v7 + 8);
              *(int8x16_t *)((char *)v7 + 8) = vextq_s8(v70, v70, 8uLL);
              BOOL result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v70.i64[1] + 96), v7->i64[0]);
              if (result) {
                *uint64_t v7 = vextq_s8(*v7, *v7, 8uLL);
              }
            }
          }
          break;
        case 5:
          BOOL result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7->i64, &v7->i64[1], v7[1].i64, &v7[1].i64[1], v160);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v8 <= 191)
    {
      long long v71 = (int8x16_t *)&v7->u64[1];
      BOOL v73 = v7 == a2 || v71 == a2;
      if (a4)
      {
        if (!v73)
        {
          char v74 = (uint64_t *)v7;
          do
          {
            size_t v76 = v71;
            uint64_t v77 = v74[1];
            BOOL result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v77 + 96), *v74);
            if (result)
            {
              long long v78 = (uint64_t *)v76;
              uint64_t v79 = 0;
              *long long v78 = 0;
              uint64_t v167 = v77;
              uint64_t v80 = *v74;
              unint64_t v163 = v78;
              for (i = v78; ; uint64_t v79 = *i)
              {
                uint64_t *i = v80;
                uint64_t i = v74;
                *char v74 = 0;
                if (v79)
                {
                  uint64_t v81 = *(void **)(v79 + 56);
                  if (v81)
                  {
                    unint64_t v82 = *(void **)(v79 + 64);
                    uint64_t v83 = *(void *)(v79 + 56);
                    if (v82 != v81)
                    {
                      do
                      {
                        uint64_t v85 = (void (***)(void, uint64_t))*--v82;
                        uint64_t v84 = v85;
                        *unint64_t v82 = 0;
                        if (v85)
                        {
                          (**v84)(v84, v83);
                          {
                            operator new();
                          }
                          (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v84, 112);
                        }
                      }
                      while (v82 != v81);
                      uint64_t v83 = *(void *)(v79 + 56);
                    }
                    *(void *)(v79 + 64) = v81;
                    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v79 + 80) + 40))(*(void *)(v79 + 80), v83, *(void *)(v79 + 72) - v83);
                  }
                  MEMORY[0x1A6239270](v79, 0x1020C4010FC18DELL);
                }
                uint64_t v86 = v167;
                if (i == (uint64_t *)v6) {
                  break;
                }
                unint64_t v87 = *(unsigned int *)(v167 + 96);
                if ((v87 & 0xF000) != 0) {
                  uint64_t v88 = 3;
                }
                else {
                  uint64_t v88 = 0;
                }
                if ((v87 & 0xF00) != 0) {
                  uint64_t v88 = 2;
                }
                if ((v87 & 0xF0) != 0) {
                  uint64_t v88 = 1;
                }
                if ((v87 & 0xF) != 0) {
                  uint64_t v88 = 0;
                }
                int v89 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v88];
                int v90 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v87 >> 12];
                int v91 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v87 >> 8) & 0xF];
                int v92 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v87 >> 4];
                unsigned int v93 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v87 & 0xF];
                char v74 = i - 1;
                uint64_t v80 = *(i - 1);
                unint64_t v94 = *(unsigned int *)(v80 + 96);
                if ((v94 & 0xF000) != 0) {
                  uint64_t v95 = 3;
                }
                else {
                  uint64_t v95 = 0;
                }
                if ((v94 & 0xF00) != 0) {
                  uint64_t v95 = 2;
                }
                if ((v94 & 0xF0) != 0) {
                  uint64_t v95 = 1;
                }
                if ((v94 & 0xF) != 0) {
                  uint64_t v95 = 0;
                }
                if (((v90 << 12) | (v89 << 16) | (v91 << 8) | (16 * v92) | v93) >= ((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v94 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v95] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v94 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v94 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v94 & 0xF])) {
                  goto LABEL_128;
                }
              }
              uint64_t i = (uint64_t *)v6;
LABEL_128:
              uint64_t v167 = 0;
              std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](i, v86);
              BOOL result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
              size_t v76 = (int8x16_t *)v163;
            }
            long long v71 = (int8x16_t *)&v76->u64[1];
            char v74 = (uint64_t *)v76;
          }
          while (&v76->u64[1] != (unint64_t *)a2);
        }
      }
      else if (!v73)
      {
        do
        {
          long long v138 = v71;
          uint64_t v139 = v6->i64[1];
          BOOL result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v139 + 96), v6->i64[0]);
          if (result)
          {
            uint64_t v140 = (uint64_t *)v138;
            uint64_t v141 = 0;
            *uint64_t v140 = 0;
            uint64_t v167 = v139;
            uint64_t v142 = v6->i64[0];
            long long v164 = v140;
            for (j = v140; ; uint64_t v141 = *j)
            {
              uint64_t *j = v142;
              uint64_t j = (uint64_t *)v6;
              v6->i64[0] = 0;
              if (v141)
              {
                char v144 = *(void **)(v141 + 56);
                if (v144)
                {
                  uint64_t v145 = *(void **)(v141 + 64);
                  uint64_t v146 = *(void *)(v141 + 56);
                  if (v145 != v144)
                  {
                    do
                    {
                      uint64_t v148 = (void (***)(void, uint64_t))*--v145;
                      long long v147 = v148;
                      *uint64_t v145 = 0;
                      if (v148)
                      {
                        (**v147)(v147, v146);
                        {
                          operator new();
                        }
                        (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v147, 112);
                      }
                    }
                    while (v145 != v144);
                    uint64_t v146 = *(void *)(v141 + 56);
                  }
                  *(void *)(v141 + 64) = v144;
                  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v141 + 80) + 40))(*(void *)(v141 + 80), v146, *(void *)(v141 + 72) - v146);
                }
                MEMORY[0x1A6239270](v141, 0x1020C4010FC18DELL);
              }
              uint64_t v149 = v167;
              unint64_t v150 = *(unsigned int *)(v167 + 96);
              if ((v150 & 0xF000) != 0) {
                uint64_t v151 = 3;
              }
              else {
                uint64_t v151 = 0;
              }
              if ((v150 & 0xF00) != 0) {
                uint64_t v151 = 2;
              }
              if ((v150 & 0xF0) != 0) {
                uint64_t v151 = 1;
              }
              if ((v150 & 0xF) != 0) {
                uint64_t v151 = 0;
              }
              int v152 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v151];
              int v153 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v150 >> 12];
              int v154 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v150 >> 8) & 0xF];
              int v155 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v150 >> 4];
              unsigned int v156 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v150 & 0xF];
              uint64_t v6 = (int8x16_t *)(j - 1);
              uint64_t v142 = *(j - 1);
              unint64_t v157 = *(unsigned int *)(v142 + 96);
              if ((v157 & 0xF000) != 0) {
                uint64_t v158 = 3;
              }
              else {
                uint64_t v158 = 0;
              }
              if ((v157 & 0xF00) != 0) {
                uint64_t v158 = 2;
              }
              if ((v157 & 0xF0) != 0) {
                uint64_t v158 = 1;
              }
              if ((v157 & 0xF) != 0) {
                uint64_t v158 = 0;
              }
              if (((v153 << 12) | (v152 << 16) | (v154 << 8) | (16 * v155) | v156) >= ((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v157 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v158] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v157 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v157 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v157 & 0xF])) {
                break;
              }
            }
            uint64_t v167 = 0;
            std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](j, v149);
            BOOL result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
            long long v138 = (int8x16_t *)v164;
          }
          long long v71 = (int8x16_t *)&v138->u64[1];
          uint64_t v6 = v138;
        }
        while (&v138->u64[1] != (unint64_t *)a2);
      }
      return result;
    }
    if (!a3) {
      break;
    }
    unint64_t v10 = (unint64_t)v9 >> 1;
    uint64_t v11 = &v7->i64[(unint64_t)v9 >> 1];
    if ((unint64_t)v8 < 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v11, v7->i64, v160);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7->i64, v11, v160);
      uint64_t v12 = v10;
      unsigned int v13 = &v7->i64[v10];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(&v7->i64[1], v13 - 1, a2[-1].i64);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7[1].i64, &v7->i64[v12 + 1], &a2[-2].i64[1]);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v13 - 1, v11, &v7->i64[v12 + 1]);
      uint64_t v14 = v7->i64[0];
      v7->i64[0] = *v13;
      *unsigned int v13 = v14;
    }
    --a3;
    uint64_t v15 = v7->i64[0];
    if ((a4 & 1) != 0
      || md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v7[-1].i64[1] + 96), v7->i64[0]))
    {
      v7->i64[0] = 0;
      uint64_t v167 = v15;
      uint8x8_t v16 = v7;
      do
      {
        uint64_t v17 = v16;
        uint64_t v19 = v16->i64[1];
        uint8x8_t v16 = (int8x16_t *)((char *)v16 + 8);
        uint64_t v18 = v19;
      }
      while (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v19 + 96), v15));
      uint64_t v20 = (uint64_t *)a2;
      if (v17 == v6)
      {
        uint64_t v20 = (uint64_t *)a2;
        do
        {
          if (v16 >= (int8x16_t *)v20) {
            break;
          }
          uint64_t v22 = *--v20;
        }
        while (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v22 + 96), v15));
      }
      else
      {
        do
          uint64_t v21 = *--v20;
        while (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v21 + 96), v15));
      }
      if (v16 < (int8x16_t *)v20)
      {
        uint64_t v23 = *v20;
        unint64_t v24 = (uint64_t *)v16;
        uint64_t v25 = v20;
        do
        {
          *unint64_t v24 = v23;
          *uint64_t v25 = v18;
          uint64_t v15 = v167;
          unint64_t v26 = *(unsigned int *)(v167 + 96);
          int v27 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v26 >> 8) & 0xF];
          int v28 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v26 >> 12] << 12;
          int v29 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v26 >> 4];
          int v30 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v26 & 0xF];
          if ((v26 & 0xF000) != 0) {
            uint64_t v31 = 3;
          }
          else {
            uint64_t v31 = 0;
          }
          if ((v26 & 0xF00) != 0) {
            uint64_t v31 = 2;
          }
          if (*(_DWORD *)(v167 + 96)) {
            BOOL v32 = (*(_DWORD *)(v167 + 96) & 0xF) == 0;
          }
          else {
            BOOL v32 = v31;
          }
          unsigned int v33 = v28 | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v32] << 16) | (v27 << 8) | (16 * v29) | v30;
          do
          {
            uint64_t v34 = v24[1];
            ++v24;
            uint64_t v18 = v34;
            unint64_t v35 = *(unsigned int *)(v34 + 96);
            if ((v35 & 0xF000) != 0) {
              uint64_t v36 = 3;
            }
            else {
              uint64_t v36 = 0;
            }
            if ((v35 & 0xF00) != 0) {
              uint64_t v36 = 2;
            }
            if ((v35 & 0xF0) != 0) {
              uint64_t v36 = 1;
            }
            if ((v35 & 0xF) != 0) {
              uint64_t v36 = 0;
            }
          }
          while (((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v35 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v36] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v35 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v35 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v35 & 0xF]) < v33);
          uint64_t v17 = (int8x16_t *)(v24 - 1);
          do
          {
            uint64_t v37 = *--v25;
            uint64_t v23 = v37;
            unint64_t v38 = *(unsigned int *)(v37 + 96);
            if ((v38 & 0xF000) != 0) {
              uint64_t v39 = 3;
            }
            else {
              uint64_t v39 = 0;
            }
            if ((v38 & 0xF00) != 0) {
              uint64_t v39 = 2;
            }
            if ((v38 & 0xF0) != 0) {
              uint64_t v39 = 1;
            }
            if ((v38 & 0xF) != 0) {
              uint64_t v39 = 0;
            }
          }
          while (((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v38 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v39] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v38 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v38 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v38 & 0xF]) >= v33);
        }
        while (v24 < v25);
      }
      if (v17 != v6)
      {
        uint64_t v40 = v17->i64[0];
        v17->i64[0] = 0;
        std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](v6->i64, v40);
        uint64_t v15 = v167;
      }
      uint64_t v167 = 0;
      std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](v17->i64, v15);
      std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
      if (v16 < (int8x16_t *)v20) {
        goto LABEL_58;
      }
      char v41 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::batch(std::unordered_map<md::DottedRouteLineBatchKey,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DottedRouteLineBatchKey,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v6, v17);
      uint64_t v7 = (int8x16_t *)&v17->u64[1];
      BOOL result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::batch(std::unordered_map<md::DottedRouteLineBatchKey,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DottedRouteLineBatchKey,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>((int8x16_t *)&v17->u64[1], a2);
      if (result)
      {
        a2 = v17;
        if (v41) {
          return result;
        }
        goto LABEL_2;
      }
      if ((v41 & 1) == 0)
      {
LABEL_58:
        BOOL result = std::__introsort<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::batch(std::unordered_map<md::DottedRouteLineBatchKey,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DottedRouteLineBatchKey,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*,false>(v6, v17, a3, a4 & 1);
        a4 = 0;
        uint64_t v7 = (int8x16_t *)&v17->u64[1];
      }
    }
    else
    {
      v7->i64[0] = 0;
      uint64_t v167 = v15;
      unint64_t v42 = *(unsigned int *)(v15 + 96);
      if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(v42, *v160))
      {
        do
        {
          uint64_t v43 = v7->i64[1];
          uint64_t v7 = (int8x16_t *)((char *)v7 + 8);
        }
        while (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(v42, v43));
      }
      else
      {
        uint64_t v44 = (int8x16_t *)&v7->u64[1];
        do
        {
          uint64_t v7 = v44;
          if (v44 >= a2) {
            break;
          }
          uint64_t v44 = (int8x16_t *)((char *)v44 + 8);
        }
        while (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(v42, v7->i64[0]));
      }
      unint64_t v45 = a2;
      if (v7 < a2)
      {
        unint64_t v45 = a2;
        do
        {
          uint64_t v46 = v45[-1].i64[1];
          unint64_t v45 = (int8x16_t *)((char *)v45 - 8);
        }
        while (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(v42, v46));
      }
      if (v7 < v45)
      {
        uint64_t v47 = v7->i64[0];
        uint64_t v48 = v45->i64[0];
        do
        {
          v7->i64[0] = v48;
          v45->i64[0] = v47;
          uint64_t v15 = v167;
          unint64_t v49 = *(unsigned int *)(v167 + 96);
          int v50 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v49 >> 8) & 0xF];
          int v51 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v49 >> 4];
          int v52 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v49 & 0xF];
          int v53 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v49 >> 12] << 12;
          if ((v49 & 0xF000) != 0) {
            uint64_t v54 = 3;
          }
          else {
            uint64_t v54 = 0;
          }
          if ((v49 & 0xF00) != 0) {
            uint64_t v54 = 2;
          }
          if (*(_DWORD *)(v167 + 96)) {
            BOOL v55 = (*(_DWORD *)(v167 + 96) & 0xF) == 0;
          }
          else {
            BOOL v55 = v54;
          }
          unsigned int v56 = v53 | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v55] << 16) | (v50 << 8) | (16 * v51) | v52;
          do
          {
            uint64_t v57 = v7->i64[1];
            uint64_t v7 = (int8x16_t *)((char *)v7 + 8);
            uint64_t v47 = v57;
            unint64_t v58 = *(unsigned int *)(v57 + 96);
            if ((v58 & 0xF000) != 0) {
              uint64_t v59 = 3;
            }
            else {
              uint64_t v59 = 0;
            }
            if ((v58 & 0xF00) != 0) {
              uint64_t v59 = 2;
            }
            if ((v58 & 0xF0) != 0) {
              uint64_t v59 = 1;
            }
            if ((v58 & 0xF) != 0) {
              uint64_t v59 = 0;
            }
          }
          while (v56 >= ((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v58 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v59] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v58 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v58 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v58 & 0xF]));
          do
          {
            uint64_t v60 = v45[-1].i64[1];
            unint64_t v45 = (int8x16_t *)((char *)v45 - 8);
            uint64_t v48 = v60;
            unint64_t v61 = *(unsigned int *)(v60 + 96);
            if ((v61 & 0xF000) != 0) {
              uint64_t v62 = 3;
            }
            else {
              uint64_t v62 = 0;
            }
            if ((v61 & 0xF00) != 0) {
              uint64_t v62 = 2;
            }
            if ((v61 & 0xF0) != 0) {
              uint64_t v62 = 1;
            }
            if ((v61 & 0xF) != 0) {
              uint64_t v62 = 0;
            }
          }
          while (v56 < ((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v61 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v62] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v61 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v61 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v61 & 0xF]));
        }
        while (v7 < v45);
      }
      size_t v63 = &v7[-1].i64[1];
      if (&v7[-1].u64[1] != (unint64_t *)v6)
      {
        uint64_t v64 = *v63;
        *size_t v63 = 0;
        std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](v6->i64, v64);
        uint64_t v15 = v167;
      }
      uint64_t v167 = 0;
      std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](&v7[-1].i64[1], v15);
      BOOL result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
      a4 = 0;
    }
  }
  if (v7 != a2)
  {
    unint64_t v161 = (char *)a2 - (char *)v7;
    int64_t v96 = (unint64_t)(v9 - 2) >> 1;
    int64_t v97 = v96;
    do
    {
      int64_t v98 = v97;
      if (v96 >= v97)
      {
        uint64_t v99 = (2 * v97) | 1;
        unint64_t v100 = &v6->i64[v99];
        if (2 * v97 + 2 < v9)
        {
          uint64_t v101 = *v100;
          uint64_t v102 = v100[1];
          BOOL v103 = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v100 + 96), v102);
          if (v103) {
            uint64_t v104 = v102;
          }
          else {
            uint64_t v104 = v101;
          }
          if (v103)
          {
            ++v100;
            uint64_t v99 = 2 * v98 + 2;
          }
        }
        else
        {
          uint64_t v104 = *v100;
        }
        uint64_t v105 = &v6->i64[v98];
        uint64_t v106 = *v105;
        BOOL result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v104 + 96), *v105);
        if ((result & 1) == 0)
        {
          uint64_t *v105 = 0;
          uint64_t v167 = v106;
          uint64_t v107 = *v100;
          while (1)
          {
            uint64_t v111 = v100;
            *unint64_t v100 = 0;
            std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](v105, v107);
            if (v96 < v99) {
              break;
            }
            uint64_t v112 = (2 * v99) | 1;
            unint64_t v100 = &v6->i64[v112];
            uint64_t v113 = 2 * v99 + 2;
            if (v113 < v9)
            {
              uint64_t v108 = *v100;
              uint64_t v107 = v100[1];
              BOOL v109 = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v100 + 96), v107);
              if (v109) {
                ++v100;
              }
              else {
                uint64_t v107 = v108;
              }
              if (v109) {
                uint64_t v99 = v113;
              }
              else {
                uint64_t v99 = v112;
              }
            }
            else
            {
              uint64_t v107 = *v100;
              uint64_t v99 = (2 * v99) | 1;
            }
            uint64_t v110 = v167;
            uint64_t v105 = v111;
            if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v107 + 96), v167))
            {
              goto LABEL_168;
            }
          }
          uint64_t v110 = v167;
LABEL_168:
          uint64_t v167 = 0;
          std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](v111, v110);
          BOOL result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
        }
      }
      int64_t v97 = v98 - 1;
    }
    while (v98);
    uint64_t v114 = v161 >> 3;
    while (2)
    {
      if (v114 >= 2)
      {
        uint64_t v118 = 0;
        uint64_t v119 = v6->i64[0];
        v6->i64[0] = 0;
        uint64_t v166 = v119;
        uint64_t v120 = (uint64_t *)v6;
        do
        {
          uint64_t v125 = &v120[v118 + 1];
          uint64_t v126 = (2 * v118) | 1;
          uint64_t v127 = 2 * v118 + 2;
          if (v127 < v114)
          {
            uint64_t v121 = *v125;
            uint64_t v122 = v120[v118 + 2];
            BOOL v123 = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v125 + 96), v125[1]);
            if (v123) {
              uint64_t v124 = v122;
            }
            else {
              uint64_t v124 = v121;
            }
            if (v123)
            {
              ++v125;
              uint64_t v118 = v127;
            }
            else
            {
              uint64_t v118 = v126;
            }
          }
          else
          {
            uint64_t v124 = *v125;
            uint64_t v118 = (2 * v118) | 1;
          }
          uint64_t *v125 = 0;
          std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](v120, v124);
          uint64_t v120 = v125;
        }
        while (v118 <= (uint64_t)((unint64_t)(v114 - 2) >> 1));
        int64_t v128 = &a2[-1].i64[1];
        if (v125 == (uint64_t *)&a2[-1].u64[1])
        {
          uint64_t v115 = v166;
          uint64_t v166 = 0;
          float64x2_t v116 = v125;
          goto LABEL_193;
        }
        uint64_t v129 = *v128;
        *int64_t v128 = 0;
        std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](v125, v129);
        uint64_t v130 = v166;
        uint64_t v166 = 0;
        std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](v128, v130);
        uint64_t v131 = (char *)v125 - (char *)v6 + 8;
        if (v131 >= 9)
        {
          unint64_t v132 = (unint64_t)((v131 >> 3) - 2) >> 1;
          unint64_t v133 = &v6->i64[v132];
          uint64_t v134 = *v125;
          if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v133 + 96), *v125))
          {
            uint64_t *v125 = 0;
            uint64_t v167 = v134;
            uint64_t v135 = *v133;
            do
            {
              unint64_t v136 = v133;
              *unint64_t v133 = 0;
              std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](v125, v135);
              uint64_t v137 = v167;
              if (!v132) {
                break;
              }
              unint64_t v132 = (v132 - 1) >> 1;
              unint64_t v133 = &v6->i64[v132];
              uint64_t v135 = *v133;
              uint64_t v125 = v136;
            }
            while (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v133 + 96), v167));
            uint64_t v167 = 0;
            std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](v136, v137);
            float64x2_t v116 = &v167;
            uint64_t v115 = 0;
LABEL_193:
            std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](v116, v115);
          }
        }
        BOOL result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](&v166, 0);
      }
      a2 = (int8x16_t *)((char *)a2 - 8);
      if ((unint64_t)v114-- <= 2) {
        return result;
      }
      continue;
    }
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,geo::StdAllocator<std::__hash_value_type<unsigned int,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>>,mdm::Allocator>>::__deallocate_node(uint64_t result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    uint64_t v3 = result;
    do
    {
      char v5 = (uint64_t *)*v2;
      uint64_t v6 = (void *)v2[3];
      if (v6)
      {
        uint64_t v7 = (void *)v2[4];
        uint64_t v4 = v2[3];
        if (v7 != v6)
        {
          do
          {
            uint64_t v9 = (void (***)(void, uint64_t))*--v7;
            uint64_t v8 = v9;
            *uint64_t v7 = 0;
            if (v9)
            {
              (**v8)(v8, v4);
              {
                  operator new();
              }
              (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                               + 40))(mdm::Allocator::instance(void)::alloc, v8, 112);
            }
          }
          while (v7 != v6);
          uint64_t v4 = v2[3];
        }
        v2[4] = (uint64_t)v6;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[6] + 40))(v2[6], v4, v2[5] - v4);
      }
      BOOL result = (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(v3 + 32) + 40))(*(void *)(v3 + 32), v2, 56);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  return result;
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::batch(std::unordered_map<md::DottedRouteLineBatchKey,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DottedRouteLineBatchKey,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(int8x16_t *a1, int8x16_t *a2)
{
  BOOL v4 = 1;
  switch(((char *)a2 - (char *)a1) >> 3)
  {
    case 0:
    case 1:
      return v4;
    case 2:
      uint64_t v5 = a2[-1].i64[1];
      uint64_t v6 = a1->i64[0];
      if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v5 + 96), a1->i64[0]))
      {
        a1->i64[0] = v5;
        a2[-1].i64[1] = v6;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(a1->i64, &a1->i64[1], &a2[-1].i64[1]);
      return v4;
    case 4:
      uint8x8_t v16 = a1 + 1;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(a1->i64, &a1->i64[1], a1[1].i64);
      uint64_t v17 = a2[-1].i64[1];
      uint64_t v18 = a1[1].i64[0];
      if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v17 + 96), v18))
      {
        v16->i64[0] = v17;
        a2[-1].i64[1] = v18;
        if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v16->i64[0] + 96), a1->i64[1]))
        {
          int8x16_t v19 = *(int8x16_t *)((char *)a1 + 8);
          *(int8x16_t *)((char *)a1 + 8) = vextq_s8(v19, v19, 8uLL);
          if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v19.i64[1] + 96), a1->i64[0]))
          {
            *a1 = vextq_s8(*a1, *a1, 8uLL);
          }
        }
      }
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(a1->i64, &a1->i64[1], a1[1].i64, &a1[1].i64[1], &a2[-1].i64[1]);
      return v4;
    default:
      i64 = a1[1].i64;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(a1->i64, &a1->i64[1], a1[1].i64);
      uint64_t v8 = &a1[1].i64[1];
      if (&a1[1].u64[1] == (unint64_t *)a2) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (1)
  {
    uint64_t v11 = *v8;
    if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v8 + 96), *i64))
    {
      break;
    }
LABEL_6:
    i64 = v8;
    v9 += 8;
    if (++v8 == (uint64_t *)a2) {
      return 1;
    }
  }
  *uint64_t v8 = 0;
  uint64_t v21 = v11;
  uint64_t v12 = *i64;
  uint64_t v13 = v9;
  while (1)
  {
    *(uint64_t *)((char *)a1[1].i64 + v13) = 0;
    std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100]((uint64_t *)((char *)&a1[1].i64[1] + v13), v12);
    uint64_t v14 = v21;
    if (v13 == -16) {
      break;
    }
    uint64_t v12 = *(uint64_t *)((char *)&a1->i64[1] + v13);
    v13 -= 8;
    if (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v21 + 96), v12))
    {
      uint64_t v15 = (uint64_t *)((char *)&a1[1].i64[1] + v13);
      goto LABEL_13;
    }
  }
  uint64_t v15 = (uint64_t *)a1;
LABEL_13:
  uint64_t v21 = 0;
  std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](v15, v14);
  if (++v10 != 8)
  {
    std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](&v21, 0);
    goto LABEL_6;
  }
  BOOL v4 = v8 + 1 == (uint64_t *)a2;
  std::unique_ptr<md::RibbonSection<md::Ribbons::DottedRouteLineRibbonDescriptor>>::reset[abi:nn180100](&v21, 0);
  return v4;
}

uint64_t std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<unsigned int,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>>,void *>,mdm::Allocator>>::operator()[abi:nn180100](uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(unsigned char *)(result + 8))
  {
    BOOL v4 = *(void **)(a2 + 24);
    if (v4)
    {
      uint64_t v5 = *(void **)(a2 + 32);
      uint64_t v6 = *(void *)(a2 + 24);
      if (v5 != v4)
      {
        do
        {
          uint64_t v8 = (void (***)(void, uint64_t))*--v5;
          uint64_t v7 = v8;
          *uint64_t v5 = 0;
          if (v8)
          {
            (**v7)(v7, v6);
            {
              operator new();
            }
            (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                             + 40))(mdm::Allocator::instance(void)::alloc, v7, 112);
          }
        }
        while (v5 != v4);
        uint64_t v6 = *(void *)(a2 + 24);
      }
      *(void *)(a2 + 32) = v4;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 48) + 40))(*(void *)(a2 + 48), v6, *(void *)(a2 + 40) - v6);
    }
  }
  else if (!a2)
  {
    return result;
  }
  uint64_t v9 = *(uint64_t (**)(void))(***(void ***)v3 + 40);
  return v9();
}

void *std::function<ecs2::ModuleDescriptor ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void ecs2::Flow::~Flow(ecs2::Flow *this)
{
  uint64_t v2 = (void *)*((void *)this + 27);
  if (v2)
  {
    *((void *)this + 28) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (gdc::Registry *)*((void *)this + 24);
  *((void *)this + 24) = 0;
  if (v3)
  {
    gdc::Registry::~Registry(v3);
    MEMORY[0x1A6239270]();
  }
  uint64_t v88 = 0;
  uint64_t v89 = 0;
  unint64_t v87 = &v88;
  BOOL v4 = (void *)*((void *)this + 23);
  if (v4)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = &v88;
      uint64_t v7 = &v88;
      if (v88)
      {
        uint64_t v8 = v88;
        while (1)
        {
          while (1)
          {
            uint64_t v7 = (uint64_t **)v8;
            unint64_t v9 = v8[4];
            if ((unint64_t)v4 >= v9) {
              break;
            }
            uint64_t v8 = *v7;
            uint64_t v6 = v7;
            if (!*v7) {
              goto LABEL_16;
            }
          }
          if (v9 >= (unint64_t)v4) {
            break;
          }
          uint64_t v8 = v7[1];
          if (!v8)
          {
            uint64_t v6 = v7 + 1;
            goto LABEL_16;
          }
        }
      }
      else
      {
LABEL_16:
        int v10 = (uint64_t *)operator new(0x28uLL);
        v10[4] = (uint64_t)v4;
        *int v10 = 0;
        v10[1] = 0;
        v10[2] = (uint64_t)v7;
        *uint64_t v6 = v10;
        if (*v87)
        {
          unint64_t v87 = (uint64_t **)*v87;
          int v10 = *v6;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v88, v10);
        uint64_t v5 = ++v89;
        BOOL v4 = (void *)*((void *)this + 23);
      }
      BOOL v4 = (void *)*v4;
      *((void *)this + 23) = v4;
    }
    while (v4);
  }
  else
  {
    uint64_t v5 = 0;
  }
  unint64_t v11 = *((void *)this + 21);
  uint64_t v12 = (char *)*((void *)this + 18);
  uint64_t v13 = (char *)this + 152;
  BOOL v14 = v5 == *((void *)this + 20) * v11 || v12 == v13;
  if (!v14 && v11 != 0)
  {
    uint64_t v16 = 1;
    uint64_t v86 = (char *)this + 152;
    do
    {
      if (v16)
      {
        unint64_t v17 = 0;
        uint64_t v18 = *((void *)v12 + 4);
        do
        {
          int8x16_t v19 = (void *)(v18 + 248 * v17);
          uint64_t v20 = v88;
          if (!v88) {
            goto LABEL_43;
          }
          uint64_t v21 = &v88;
          do
          {
            uint64_t v22 = v20;
            uint64_t v23 = v21;
            unint64_t v24 = v20[4];
            uint64_t v25 = (uint64_t **)(v20 + 1);
            if (v24 >= (unint64_t)v19)
            {
              uint64_t v25 = (uint64_t **)v22;
              uint64_t v21 = (uint64_t **)v22;
            }
            uint64_t v20 = *v25;
          }
          while (v20);
          if (v21 == &v88) {
            goto LABEL_43;
          }
          if (v24 < (unint64_t)v19) {
            uint64_t v22 = (uint64_t *)v23;
          }
          if ((unint64_t)v19 < v22[4])
          {
LABEL_43:
            unint64_t v26 = (void *)v19[28];
            if (v26)
            {
              do
              {
                unsigned int v33 = (void *)*v26;
                uint64_t v34 = (void *)v26[7];
                if (v34)
                {
                  do
                  {
                    unint64_t v35 = (void *)*v34;
                    operator delete(v34);
                    uint64_t v34 = v35;
                  }
                  while (v35);
                }
                uint64_t v36 = (void *)v26[5];
                v26[5] = 0;
                if (v36) {
                  operator delete(v36);
                }
                operator delete(v26);
                unint64_t v26 = v33;
              }
              while (v33);
            }
            int v27 = (void *)v19[26];
            v19[26] = 0;
            if (v27) {
              operator delete(v27);
            }
            int v28 = (void *)v19[23];
            if (v28)
            {
              do
              {
                uint64_t v37 = (void *)*v28;
                unint64_t v38 = (void *)v28[7];
                if (v38)
                {
                  do
                  {
                    uint64_t v39 = (void *)*v38;
                    operator delete(v38);
                    unint64_t v38 = v39;
                  }
                  while (v39);
                }
                uint64_t v40 = (void *)v28[5];
                v28[5] = 0;
                if (v40) {
                  operator delete(v40);
                }
                operator delete(v28);
                int v28 = v37;
              }
              while (v37);
            }
            int v29 = (void *)v19[21];
            v19[21] = 0;
            if (v29) {
              operator delete(v29);
            }
            int v30 = (void *)v19[18];
            if (v30)
            {
              do
              {
                uint64_t v31 = (void *)*v30;
                operator delete(v30);
                int v30 = v31;
              }
              while (v31);
            }
            BOOL v32 = (void *)v19[16];
            v19[16] = 0;
            if (v32) {
              operator delete(v32);
            }
            gdc::tf::Taskflow::~Taskflow((gdc::tf::Taskflow *)(v19 + 5));
            unint64_t v11 = *((void *)this + 21);
          }
          ++v17;
          uint64_t v16 = v11;
        }
        while (v17 < v11);
      }
      char v41 = (char *)*((void *)v12 + 1);
      if (v41)
      {
        do
        {
          unint64_t v42 = v41;
          char v41 = *(char **)v41;
        }
        while (v41);
      }
      else
      {
        do
        {
          unint64_t v42 = (char *)*((void *)v12 + 2);
          BOOL v14 = *(void *)v42 == (void)v12;
          uint64_t v12 = v42;
        }
        while (!v14);
      }
      uint64_t v12 = v42;
      uint64_t v13 = (char *)this + 152;
    }
    while (v42 != v86);
    uint64_t v12 = (char *)*((void *)this + 18);
    if (v12 == v86) {
      goto LABEL_70;
    }
    goto LABEL_76;
  }
  if (v12 != v13)
  {
    do
    {
LABEL_76:
      free(*((void **)v12 + 4));
      uint64_t v47 = (char *)*((void *)v12 + 1);
      if (v47)
      {
        do
        {
          uint64_t v48 = v47;
          uint64_t v47 = *(char **)v47;
        }
        while (v47);
      }
      else
      {
        do
        {
          uint64_t v48 = (char *)*((void *)v12 + 2);
          BOOL v14 = *(void *)v48 == (void)v12;
          uint64_t v12 = v48;
        }
        while (!v14);
      }
      uint64_t v12 = v48;
    }
    while (v48 != v13);
  }
LABEL_70:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 19));
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 18) = v13;
  *((void *)this + 23) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v88);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 19));
  uint64_t v43 = (void *)*((void *)this + 15);
  if (v43)
  {
    *((void *)this + 16) = v43;
    operator delete(v43);
  }
  uint64_t v44 = *((void *)this + 12);
  if (!v44) {
    goto LABEL_160;
  }
  uint64_t v45 = *((void *)this + 13);
  uint64_t v46 = (void *)*((void *)this + 12);
  if (v45 == v44) {
    goto LABEL_159;
  }
  while (2)
  {
    uint64_t v49 = *(void *)(v45 - 24);
    if (!v49) {
      goto LABEL_156;
    }
    uint64_t v50 = *(void *)(v45 - 16);
    int v51 = *(void **)(v45 - 24);
    if (v50 == v49) {
      goto LABEL_155;
    }
    while (2)
    {
      uint64_t v53 = *(void *)(v50 - 24);
      if (v53)
      {
        uint64_t v54 = *(void *)(v50 - 16);
        BOOL v55 = *(void **)(v50 - 24);
        if (v54 != v53)
        {
          uint64_t v56 = v54 - 56;
          do
          {
            if (*(char *)(v54 - 1) < 0) {
              operator delete(*(void **)(v54 - 24));
            }
            uint64_t v57 = *(void *)(v54 - 32);
            if (v54 - 56 == v57)
            {
              (*(void (**)(uint64_t))(*(void *)(v54 - 56) + 32))(v54 - 56);
            }
            else if (v57)
            {
              (*(void (**)(uint64_t))(*(void *)v57 + 40))(v57);
            }
            v54 -= 64;
            v56 -= 64;
          }
          while (v54 != v53);
          BOOL v55 = *(void **)(v50 - 24);
        }
        *(void *)(v50 - 16) = v53;
        operator delete(v55);
      }
      uint64_t v58 = *(void *)(v50 - 48);
      if (v58)
      {
        uint64_t v59 = *(void *)(v50 - 40);
        uint64_t v60 = *(void **)(v50 - 48);
        if (v59 != v58)
        {
          uint64_t v61 = v59 - 56;
          do
          {
            if (*(char *)(v59 - 1) < 0) {
              operator delete(*(void **)(v59 - 24));
            }
            uint64_t v62 = *(void *)(v59 - 32);
            if (v59 - 56 == v62)
            {
              (*(void (**)(uint64_t))(*(void *)(v59 - 56) + 32))(v59 - 56);
            }
            else if (v62)
            {
              (*(void (**)(uint64_t))(*(void *)v62 + 40))(v62);
            }
            v59 -= 64;
            v61 -= 64;
          }
          while (v59 != v58);
          uint64_t v60 = *(void **)(v50 - 48);
        }
        *(void *)(v50 - 40) = v58;
        operator delete(v60);
      }
      size_t v63 = *(void **)(v50 - 72);
      if (!v63) {
        goto LABEL_128;
      }
      uint64_t v64 = *(void **)(v50 - 64);
      uint64_t v65 = *(void **)(v50 - 72);
      if (v64 == v63) {
        goto LABEL_127;
      }
      uint64_t v66 = v64 - 4;
      uint64_t v67 = v64 - 4;
      do
      {
        uint64_t v69 = (void *)v67[3];
        if (v67 == v69)
        {
          (*(void (**)(void *))(*v67 + 32))(v67);
          int8x16_t v70 = (void *)*(v67 - 3);
          if (v70) {
            goto LABEL_121;
          }
        }
        else
        {
          if (v69) {
            (*(void (**)(void *))(*v69 + 40))(v69);
          }
          int8x16_t v70 = (void *)*(v67 - 3);
          if (v70)
          {
LABEL_121:
            *(v67 - 2) = v70;
            operator delete(v70);
          }
        }
        long long v71 = (void *)*(v67 - 6);
        if (v71)
        {
          *(v67 - 5) = v71;
          operator delete(v71);
        }
        uint64_t v68 = v67 - 6;
        v67 -= 10;
        v66 -= 10;
      }
      while (v68 != v63);
      uint64_t v65 = *(void **)(v50 - 72);
LABEL_127:
      *(void *)(v50 - 64) = v63;
      operator delete(v65);
LABEL_128:
      uint64_t v72 = *(void *)(v50 - 96);
      if (v72)
      {
        uint64_t v73 = *(void *)(v50 - 88);
        char v74 = *(void **)(v50 - 96);
        if (v73 != v72)
        {
          uint64_t v75 = *(void *)(v50 - 88);
          do
          {
            uint64_t v77 = *(void **)(v75 - 24);
            v75 -= 24;
            size_t v76 = v77;
            if (v77)
            {
              *(void *)(v73 - 16) = v76;
              operator delete(v76);
            }
            uint64_t v73 = v75;
          }
          while (v75 != v72);
          char v74 = *(void **)(v50 - 96);
        }
        *(void *)(v50 - 88) = v72;
        operator delete(v74);
      }
      uint64_t v78 = *(void *)(v50 - 120);
      if (v78)
      {
        uint64_t v79 = *(void *)(v50 - 112);
        int v52 = *(void **)(v50 - 120);
        if (v79 != v78)
        {
          uint64_t v80 = 0;
          do
          {
            uint64_t v81 = v79 + v80;
            if (*(char *)(v79 + v80 - 1) < 0) {
              operator delete(*(void **)(v81 - 24));
            }
            uint64_t v82 = *(void *)(v81 - 32);
            if (v81 - 56 == v82)
            {
              (*(void (**)(uint64_t))(*(void *)(v81 - 56) + 32))(v81 - 56);
            }
            else if (v82)
            {
              (*(void (**)(void))(*(void *)v82 + 40))(*(void *)(v81 - 32));
            }
            uint64_t v83 = v79 + v80 - 88;
            uint64_t v84 = *(void *)(v79 + v80 - 64);
            if (v83 == v84)
            {
              (*(void (**)(uint64_t))(*(void *)v83 + 32))(v79 + v80 - 88);
            }
            else if (v84)
            {
              (*(void (**)(uint64_t))(*(void *)v84 + 40))(v84);
            }
            uint64_t v85 = *(void *)(v79 + v80 - 96);
            if (v81 - 120 == v85)
            {
              (*(void (**)(uint64_t))(*(void *)(v81 - 120) + 32))(v81 - 120);
            }
            else if (v85)
            {
              (*(void (**)(void))(*(void *)v85 + 40))(*(void *)(v79 + v80 - 96));
            }
            v80 -= 128;
          }
          while (v79 + v80 != v78);
          int v52 = *(void **)(v50 - 120);
        }
        *(void *)(v50 - 112) = v78;
        operator delete(v52);
      }
      v50 -= 128;
      if (v50 != v49) {
        continue;
      }
      break;
    }
    int v51 = *(void **)(v45 - 24);
LABEL_155:
    *(void *)(v45 - 16) = v49;
    operator delete(v51);
LABEL_156:
    if (*(char *)(v45 - 25) < 0) {
      operator delete(*(void **)(v45 - 48));
    }
    v45 -= 64;
    if (v45 != v44) {
      continue;
    }
    break;
  }
  uint64_t v46 = (void *)*((void *)this + 12);
LABEL_159:
  *((void *)this + 13) = v44;
  operator delete(v46);
LABEL_160:
  ecs2::FlowDescriptor::~FlowDescriptor(this);
}

void sub_1A2393A90(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v2);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 152));
  _Unwind_Resume(a1);
}

void *std::vector<std::function<ecs2::ModuleDescriptor ()(void)>>::~vector[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)*a1;
  if (*a1)
  {
    uint64_t v3 = (void *)a1[1];
    BOOL v4 = (void *)*a1;
    if (v3 != v2)
    {
      uint64_t v5 = v3 - 4;
      uint64_t v6 = v3 - 4;
      do
      {
        uint64_t v8 = (void *)v6[3];
        if (v6 == v8)
        {
          (*(void (**)(void *))(*v6 + 32))(v6);
        }
        else if (v8)
        {
          (*(void (**)(void *))(*v8 + 40))(v8);
        }
        v5 -= 4;
        BOOL v7 = v6 == v2;
        v6 -= 4;
      }
      while (!v7);
      BOOL v4 = (void *)*a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void gdc::ResourceRequestRouter::~ResourceRequestRouter(gdc::ResourceRequestRouter *this)
{
  uint64_t v2 = (void *)*((void *)this + 31);
  if (v2)
  {
    *((void *)this + 32) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 28);
  if (v3)
  {
    BOOL v4 = (void *)*((void *)this + 29);
    uint64_t v5 = (void *)*((void *)this + 28);
    if (v4 != v3)
    {
      uint64_t v6 = v4 - 4;
      BOOL v7 = v4 - 4;
      do
      {
        unint64_t v9 = (void *)v7[3];
        if (v7 == v9)
        {
          (*(void (**)(void *))(*v7 + 32))(v7);
        }
        else if (v9)
        {
          (*(void (**)(void *))(*v9 + 40))(v9);
        }
        uint64_t v8 = v7 - 1;
        v7 -= 5;
        v6 -= 5;
      }
      while (v8 != v3);
      uint64_t v5 = (void *)*((void *)this + 28);
    }
    *((void *)this + 29) = v3;
    operator delete(v5);
  }
  int v10 = (void *)*((void *)this + 25);
  if (v10)
  {
    *((void *)this + 26) = v10;
    operator delete(v10);
  }
  unint64_t v11 = (void *)*((void *)this + 22);
  if (v11)
  {
    *((void *)this + 23) = v11;
    operator delete(v11);
  }
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 112));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 64));
  std::mutex::~mutex((std::mutex *)this);
}

gdc::ResourceRequestRouter **std::unique_ptr<gdc::ResourceRequestRouter>::~unique_ptr[abi:nn180100](gdc::ResourceRequestRouter **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    gdc::ResourceRequestRouter::~ResourceRequestRouter(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

md::FeatureFlagProvider **std::unique_ptr<md::FeatureFlagProvider>::~unique_ptr[abi:nn180100](md::FeatureFlagProvider **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::FeatureFlagProvider::~FeatureFlagProvider(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void md::MapEngineSignals::ThreadSafeSignal<unsigned long>::~ThreadSafeSignal(uint64_t a1)
{
  std::mutex::lock((std::mutex *)a1);
  if (*(void *)(a1 + 96))
  {
    uint64_t v2 = *(void **)(a1 + 88);
    while (v2)
    {
      unint64_t v9 = v2;
      uint64_t v2 = (void *)*v2;
      int v10 = (void *)v9[6];
      if (v10 == v9 + 3)
      {
        (*(void (**)(void *))(v9[3] + 32))(v9 + 3);
      }
      else if (v10)
      {
        (*(void (**)(void *))(*v10 + 40))(v10);
      }
      operator delete(v9);
    }
    *(void *)(a1 + 88) = 0;
    uint64_t v3 = *(void *)(a1 + 80);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*(void *)(a1 + 72) + 8 * i) = 0;
    }
    *(void *)(a1 + 96) = 0;
  }
  std::mutex::unlock((std::mutex *)a1);
  uint64_t v5 = *(void **)(a1 + 88);
  while (v5)
  {
    BOOL v7 = v5;
    uint64_t v5 = (void *)*v5;
    uint64_t v8 = (void *)v7[6];
    if (v8 == v7 + 3)
    {
      (*(void (**)(void *))(v7[3] + 32))(v7 + 3);
    }
    else if (v8)
    {
      (*(void (**)(void *))(*v8 + 40))(v8);
    }
    operator delete(v7);
  }
  uint64_t v6 = *(void **)(a1 + 72);
  *(void *)(a1 + 72) = 0;
  if (v6) {
    operator delete(v6);
  }
  std::mutex::~mutex((std::mutex *)a1);
}

void sub_1A2393EB4(_Unwind_Exception *a1)
{
  gdc::Signal<unsigned long>::~Signal((uint64_t)&v1[1]);
  std::mutex::~mutex(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<md::MapEngineSignals>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::MapEngineSignals::ThreadSafeSignal<unsigned long>::~ThreadSafeSignal(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void md::VKMRenderResourcesStore::~VKMRenderResourcesStore(md::VKMRenderResourcesStore *this)
{
  uint64_t v2 = (void *)*((void *)this + 1330);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  BOOL v4 = (void *)*((void *)this + 1328);
  *((void *)this + 1328) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 1327);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 1324);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  uint64_t v7 = *((void *)this + 1322);
  *((void *)this + 1322) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = (void *)*((void *)this + 1309);
  if (v8)
  {
    do
    {
      unint64_t v9 = (void *)*v8;
      operator delete(v8);
      uint64_t v8 = v9;
    }
    while (v9);
  }
  int v10 = (void *)*((void *)this + 1307);
  *((void *)this + 1307) = 0;
  if (v10) {
    operator delete(v10);
  }
  unint64_t v11 = (void *)*((void *)this + 1304);
  if (v11)
  {
    *((void *)this + 1305) = v11;
    operator delete(v11);
  }
  uint64_t v12 = (void *)*((void *)this + 1301);
  if (v12)
  {
    *((void *)this + 1302) = v12;
    operator delete(v12);
  }
  uint64_t v13 = (void *)*((void *)this + 1298);
  if (v13)
  {
    *((void *)this + 1299) = v13;
    operator delete(v13);
  }
  BOOL v14 = (void *)*((void *)this + 1295);
  if (v14)
  {
    *((void *)this + 1296) = v14;
    operator delete(v14);
  }
  uint64_t v15 = (void *)*((void *)this + 1292);
  if (v15)
  {
    do
    {
      uint64_t v16 = (void *)*v15;
      operator delete(v15);
      uint64_t v15 = v16;
    }
    while (v16);
  }
  unint64_t v17 = (void *)*((void *)this + 1290);
  *((void *)this + 1290) = 0;
  if (v17) {
    operator delete(v17);
  }
  uint64_t v18 = (void *)*((void *)this + 1287);
  if (v18)
  {
    do
    {
      int8x16_t v19 = (void *)*v18;
      operator delete(v18);
      uint64_t v18 = v19;
    }
    while (v19);
  }
  uint64_t v20 = (void *)*((void *)this + 1285);
  *((void *)this + 1285) = 0;
  if (v20) {
    operator delete(v20);
  }
  uint64_t v21 = (void *)*((void *)this + 1282);
  if (v21)
  {
    *((void *)this + 1283) = v21;
    operator delete(v21);
  }
  uint64_t v22 = *((void *)this + 1279);
  if (v22)
  {
    uint64_t v23 = *((void *)this + 1280);
    unint64_t v24 = (void *)*((void *)this + 1279);
    if (v23 != v22)
    {
      do
      {
        uint64_t v25 = *(void **)(v23 - 24);
        if (v25)
        {
          *(void *)(v23 - 16) = v25;
          operator delete(v25);
        }
        unint64_t v26 = *(void **)(v23 - 48);
        if (v26)
        {
          *(void *)(v23 - 40) = v26;
          operator delete(v26);
        }
        v23 -= 56;
      }
      while (v23 != v22);
      unint64_t v24 = (void *)*((void *)this + 1279);
    }
    *((void *)this + 1280) = v22;
    operator delete(v24);
  }
  int v27 = (void *)*((void *)this + 1276);
  if (v27)
  {
    *((void *)this + 1277) = v27;
    operator delete(v27);
  }
  int v28 = (void *)*((void *)this + 1273);
  if (v28)
  {
    *((void *)this + 1274) = v28;
    operator delete(v28);
  }
  int v29 = (void *)*((void *)this + 1270);
  if (v29)
  {
    do
    {
      int v30 = (void *)*v29;
      operator delete(v29);
      int v29 = v30;
    }
    while (v30);
  }
  uint64_t v31 = (void *)*((void *)this + 1268);
  *((void *)this + 1268) = 0;
  if (v31) {
    operator delete(v31);
  }
  BOOL v32 = (void *)*((void *)this + 1265);
  if (v32)
  {
    do
    {
      unsigned int v33 = (void *)*v32;
      operator delete(v32);
      BOOL v32 = v33;
    }
    while (v33);
  }
  uint64_t v34 = (void *)*((void *)this + 1263);
  *((void *)this + 1263) = 0;
  if (v34) {
    operator delete(v34);
  }
  unint64_t v35 = (void *)*((void *)this + 1260);
  if (v35)
  {
    *((void *)this + 1261) = v35;
    operator delete(v35);
  }
  uint64_t v36 = (void *)*((void *)this + 1257);
  if (v36)
  {
    *((void *)this + 1258) = v36;
    operator delete(v36);
  }
  uint64_t v37 = (void *)*((void *)this + 1254);
  if (v37)
  {
    *((void *)this + 1255) = v37;
    operator delete(v37);
  }
  unint64_t v38 = (void *)*((void *)this + 1251);
  if (v38)
  {
    *((void *)this + 1252) = v38;
    operator delete(v38);
  }
  uint64_t v39 = (void *)*((void *)this + 1248);
  if (v39)
  {
    do
    {
      uint64_t v40 = (void *)*v39;
      operator delete(v39);
      uint64_t v39 = v40;
    }
    while (v40);
  }
  char v41 = (void *)*((void *)this + 1246);
  *((void *)this + 1246) = 0;
  if (v41) {
    operator delete(v41);
  }
  unint64_t v42 = (void *)*((void *)this + 1243);
  if (v42)
  {
    do
    {
      uint64_t v43 = (void *)*v42;
      operator delete(v42);
      unint64_t v42 = v43;
    }
    while (v43);
  }
  uint64_t v44 = (void *)*((void *)this + 1241);
  *((void *)this + 1241) = 0;
  if (v44) {
    operator delete(v44);
  }
  uint64_t v45 = (void *)*((void *)this + 1238);
  if (v45)
  {
    *((void *)this + 1239) = v45;
    operator delete(v45);
  }
  uint64_t v46 = (void *)*((void *)this + 1235);
  if (v46)
  {
    *((void *)this + 1236) = v46;
    operator delete(v46);
  }
  uint64_t v47 = (void *)*((void *)this + 1232);
  if (v47)
  {
    *((void *)this + 1233) = v47;
    operator delete(v47);
  }
  uint64_t v48 = (void *)*((void *)this + 1229);
  if (v48)
  {
    *((void *)this + 1230) = v48;
    operator delete(v48);
  }
  uint64_t v49 = (void *)*((void *)this + 1226);
  if (v49)
  {
    do
    {
      uint64_t v50 = (void *)*v49;
      operator delete(v49);
      uint64_t v49 = v50;
    }
    while (v50);
  }
  int v51 = (void *)*((void *)this + 1224);
  *((void *)this + 1224) = 0;
  if (v51) {
    operator delete(v51);
  }
  int v52 = (void *)*((void *)this + 1221);
  if (v52)
  {
    do
    {
      uint64_t v53 = (void *)*v52;
      operator delete(v52);
      int v52 = v53;
    }
    while (v53);
  }
  uint64_t v54 = (void *)*((void *)this + 1219);
  *((void *)this + 1219) = 0;
  if (v54) {
    operator delete(v54);
  }
  BOOL v55 = (void *)*((void *)this + 1216);
  if (v55)
  {
    *((void *)this + 1217) = v55;
    operator delete(v55);
  }
  uint64_t v56 = (void *)*((void *)this + 1213);
  if (v56)
  {
    *((void *)this + 1214) = v56;
    operator delete(v56);
  }
  uint64_t v57 = (void *)*((void *)this + 1210);
  if (v57)
  {
    *((void *)this + 1211) = v57;
    operator delete(v57);
  }
  uint64_t v58 = (void *)*((void *)this + 1207);
  if (v58)
  {
    *((void *)this + 1208) = v58;
    operator delete(v58);
  }
  uint64_t v59 = (void *)*((void *)this + 1204);
  if (v59)
  {
    do
    {
      uint64_t v60 = (void *)*v59;
      operator delete(v59);
      uint64_t v59 = v60;
    }
    while (v60);
  }
  uint64_t v61 = (void *)*((void *)this + 1202);
  *((void *)this + 1202) = 0;
  if (v61) {
    operator delete(v61);
  }
  uint64_t v62 = (void *)*((void *)this + 1199);
  if (v62)
  {
    do
    {
      size_t v63 = (void *)*v62;
      operator delete(v62);
      uint64_t v62 = v63;
    }
    while (v63);
  }
  uint64_t v64 = (void *)*((void *)this + 1197);
  *((void *)this + 1197) = 0;
  if (v64) {
    operator delete(v64);
  }
  uint64_t v65 = (void *)*((void *)this + 1194);
  if (v65)
  {
    *((void *)this + 1195) = v65;
    operator delete(v65);
  }
  uint64_t v66 = (void *)*((void *)this + 1191);
  if (v66)
  {
    *((void *)this + 1192) = v66;
    operator delete(v66);
  }
  uint64_t v67 = (void *)*((void *)this + 1188);
  if (v67)
  {
    *((void *)this + 1189) = v67;
    operator delete(v67);
  }
  uint64_t v68 = (void *)*((void *)this + 1185);
  if (v68)
  {
    *((void *)this + 1186) = v68;
    operator delete(v68);
  }
  uint64_t v69 = (void *)*((void *)this + 1182);
  if (v69)
  {
    do
    {
      int8x16_t v70 = (void *)*v69;
      operator delete(v69);
      uint64_t v69 = v70;
    }
    while (v70);
  }
  long long v71 = (void *)*((void *)this + 1180);
  *((void *)this + 1180) = 0;
  if (v71) {
    operator delete(v71);
  }
  uint64_t v72 = (void *)*((void *)this + 1177);
  if (v72)
  {
    do
    {
      uint64_t v73 = (void *)*v72;
      operator delete(v72);
      uint64_t v72 = v73;
    }
    while (v73);
  }
  char v74 = (void *)*((void *)this + 1175);
  *((void *)this + 1175) = 0;
  if (v74) {
    operator delete(v74);
  }
  uint64_t v75 = (void *)*((void *)this + 1172);
  if (v75)
  {
    *((void *)this + 1173) = v75;
    operator delete(v75);
  }
  size_t v76 = (void *)*((void *)this + 1169);
  if (v76)
  {
    *((void *)this + 1170) = v76;
    operator delete(v76);
  }
  uint64_t v77 = (void *)*((void *)this + 1166);
  if (v77)
  {
    *((void *)this + 1167) = v77;
    operator delete(v77);
  }
  uint64_t v78 = (void *)*((void *)this + 1163);
  if (v78)
  {
    *((void *)this + 1164) = v78;
    operator delete(v78);
  }
  uint64_t v79 = (void *)*((void *)this + 1160);
  if (v79)
  {
    do
    {
      uint64_t v80 = (void *)*v79;
      operator delete(v79);
      uint64_t v79 = v80;
    }
    while (v80);
  }
  uint64_t v81 = (void *)*((void *)this + 1158);
  *((void *)this + 1158) = 0;
  if (v81) {
    operator delete(v81);
  }
  uint64_t v82 = (void *)*((void *)this + 1155);
  if (v82)
  {
    do
    {
      uint64_t v83 = (void *)*v82;
      operator delete(v82);
      uint64_t v82 = v83;
    }
    while (v83);
  }
  uint64_t v84 = (void *)*((void *)this + 1153);
  *((void *)this + 1153) = 0;
  if (v84) {
    operator delete(v84);
  }
  uint64_t v85 = (void *)*((void *)this + 1150);
  if (v85)
  {
    *((void *)this + 1151) = v85;
    operator delete(v85);
  }
  uint64_t v86 = (void *)*((void *)this + 1147);
  if (v86)
  {
    *((void *)this + 1148) = v86;
    operator delete(v86);
  }
  unint64_t v87 = (void *)*((void *)this + 1144);
  if (v87)
  {
    *((void *)this + 1145) = v87;
    operator delete(v87);
  }
  uint64_t v88 = (void *)*((void *)this + 1141);
  if (v88)
  {
    *((void *)this + 1142) = v88;
    operator delete(v88);
  }
  uint64_t v89 = (void *)*((void *)this + 1138);
  if (v89)
  {
    do
    {
      int v90 = (void *)*v89;
      operator delete(v89);
      uint64_t v89 = v90;
    }
    while (v90);
  }
  int v91 = (void *)*((void *)this + 1136);
  *((void *)this + 1136) = 0;
  if (v91) {
    operator delete(v91);
  }
  int v92 = (void *)*((void *)this + 1133);
  if (v92)
  {
    do
    {
      unsigned int v93 = (void *)*v92;
      operator delete(v92);
      int v92 = v93;
    }
    while (v93);
  }
  unint64_t v94 = (void *)*((void *)this + 1131);
  *((void *)this + 1131) = 0;
  if (v94) {
    operator delete(v94);
  }
  uint64_t v95 = (void *)*((void *)this + 1128);
  if (v95)
  {
    *((void *)this + 1129) = v95;
    operator delete(v95);
  }
  int64_t v96 = (void *)*((void *)this + 1125);
  if (v96)
  {
    *((void *)this + 1126) = v96;
    operator delete(v96);
  }
  int64_t v97 = (void *)*((void *)this + 1122);
  if (v97)
  {
    *((void *)this + 1123) = v97;
    operator delete(v97);
  }
  int64_t v98 = (void *)*((void *)this + 1119);
  if (v98)
  {
    *((void *)this + 1120) = v98;
    operator delete(v98);
  }
  uint64_t v99 = (void *)*((void *)this + 1116);
  if (v99)
  {
    do
    {
      unint64_t v100 = (void *)*v99;
      operator delete(v99);
      uint64_t v99 = v100;
    }
    while (v100);
  }
  uint64_t v101 = (void *)*((void *)this + 1114);
  *((void *)this + 1114) = 0;
  if (v101) {
    operator delete(v101);
  }
  uint64_t v102 = (void *)*((void *)this + 1111);
  if (v102)
  {
    do
    {
      BOOL v103 = (void *)*v102;
      operator delete(v102);
      uint64_t v102 = v103;
    }
    while (v103);
  }
  uint64_t v104 = (void *)*((void *)this + 1109);
  *((void *)this + 1109) = 0;
  if (v104) {
    operator delete(v104);
  }
  uint64_t v105 = (void *)*((void *)this + 1106);
  if (v105)
  {
    *((void *)this + 1107) = v105;
    operator delete(v105);
  }
  uint64_t v106 = (void *)*((void *)this + 1103);
  if (v106)
  {
    *((void *)this + 1104) = v106;
    operator delete(v106);
  }
  uint64_t v107 = (void *)*((void *)this + 1100);
  if (v107)
  {
    *((void *)this + 1101) = v107;
    operator delete(v107);
  }
  uint64_t v108 = (void *)*((void *)this + 1097);
  if (v108)
  {
    *((void *)this + 1098) = v108;
    operator delete(v108);
  }
  BOOL v109 = (void *)*((void *)this + 1094);
  if (v109)
  {
    do
    {
      uint64_t v110 = (void *)*v109;
      operator delete(v109);
      BOOL v109 = v110;
    }
    while (v110);
  }
  uint64_t v111 = (void *)*((void *)this + 1092);
  *((void *)this + 1092) = 0;
  if (v111) {
    operator delete(v111);
  }
  uint64_t v112 = (void *)*((void *)this + 1089);
  if (v112)
  {
    do
    {
      uint64_t v113 = (void *)*v112;
      operator delete(v112);
      uint64_t v112 = v113;
    }
    while (v113);
  }
  uint64_t v114 = (void *)*((void *)this + 1087);
  *((void *)this + 1087) = 0;
  if (v114) {
    operator delete(v114);
  }
  uint64_t v115 = (void *)*((void *)this + 1084);
  if (v115)
  {
    *((void *)this + 1085) = v115;
    operator delete(v115);
  }
  float64x2_t v116 = (void *)*((void *)this + 1081);
  if (v116)
  {
    *((void *)this + 1082) = v116;
    operator delete(v116);
  }
  uint64_t v117 = (void *)*((void *)this + 1078);
  if (v117)
  {
    *((void *)this + 1079) = v117;
    operator delete(v117);
  }
  uint64_t v118 = (void *)*((void *)this + 1075);
  if (v118)
  {
    *((void *)this + 1076) = v118;
    operator delete(v118);
  }
  uint64_t v119 = (void *)*((void *)this + 1072);
  if (v119)
  {
    do
    {
      uint64_t v120 = (void *)*v119;
      operator delete(v119);
      uint64_t v119 = v120;
    }
    while (v120);
  }
  uint64_t v121 = (void *)*((void *)this + 1070);
  *((void *)this + 1070) = 0;
  if (v121) {
    operator delete(v121);
  }
  uint64_t v122 = (void *)*((void *)this + 1067);
  if (v122)
  {
    do
    {
      BOOL v123 = (void *)*v122;
      operator delete(v122);
      uint64_t v122 = v123;
    }
    while (v123);
  }
  uint64_t v124 = (void *)*((void *)this + 1065);
  *((void *)this + 1065) = 0;
  if (v124) {
    operator delete(v124);
  }
  uint64_t v125 = (void *)*((void *)this + 1062);
  if (v125)
  {
    do
    {
      uint64_t v126 = (void *)*v125;
      operator delete(v125);
      uint64_t v125 = v126;
    }
    while (v126);
  }
  uint64_t v127 = (void *)*((void *)this + 1060);
  *((void *)this + 1060) = 0;
  if (v127) {
    operator delete(v127);
  }
  int64_t v128 = (void *)*((void *)this + 1057);
  if (v128)
  {
    do
    {
      uint64_t v129 = (void *)*v128;
      operator delete(v128);
      int64_t v128 = v129;
    }
    while (v129);
  }
  uint64_t v130 = (void *)*((void *)this + 1055);
  *((void *)this + 1055) = 0;
  if (v130) {
    operator delete(v130);
  }
  uint64_t v131 = (void *)*((void *)this + 1052);
  if (v131)
  {
    do
    {
      uint64_t v137 = (void *)*v131;
      uint64_t v138 = v131[3];
      void v131[3] = 0;
      if (v138) {
        (*(void (**)(uint64_t))(*(void *)v138 + 8))(v138);
      }
      operator delete(v131);
      uint64_t v131 = v137;
    }
    while (v137);
  }
  unint64_t v132 = (void *)*((void *)this + 1050);
  *((void *)this + 1050) = 0;
  if (v132) {
    operator delete(v132);
  }
  unint64_t v133 = (void *)*((void *)this + 1047);
  if (v133)
  {
    *((void *)this + 1048) = v133;
    operator delete(v133);
  }
  uint64_t v134 = *((void *)this + 1044);
  if (v134)
  {
    uint64_t v135 = *((void *)this + 1045);
    unint64_t v136 = (void *)*((void *)this + 1044);
    if (v135 != v134)
    {
      do
      {
        uint64_t v139 = *(std::__shared_weak_count **)(v135 - 8);
        if (v139 && !atomic_fetch_add(&v139->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v139->__on_zero_shared)(v139);
          std::__shared_weak_count::__release_weak(v139);
        }
        v135 -= 24;
      }
      while (v135 != v134);
      unint64_t v136 = (void *)*((void *)this + 1044);
    }
    *((void *)this + 1045) = v134;
    operator delete(v136);
  }
  uint64_t v140 = (void *)*((void *)this + 1041);
  if (v140)
  {
    *((void *)this + 1042) = v140;
    operator delete(v140);
  }
  uint64_t v141 = (void *)*((void *)this + 1038);
  if (v141)
  {
    *((void *)this + 1039) = v141;
    operator delete(v141);
  }
  uint64_t v142 = (void *)*((void *)this + 1035);
  if (v142)
  {
    do
    {
      uint64_t v143 = (void *)*v142;
      operator delete(v142);
      uint64_t v142 = v143;
    }
    while (v143);
  }
  char v144 = (void *)*((void *)this + 1033);
  *((void *)this + 1033) = 0;
  if (v144) {
    operator delete(v144);
  }
  uint64_t v145 = (void *)*((void *)this + 1030);
  if (v145)
  {
    do
    {
      uint64_t v146 = (void *)*v145;
      operator delete(v145);
      uint64_t v145 = v146;
    }
    while (v146);
  }
  long long v147 = (void *)*((void *)this + 1028);
  *((void *)this + 1028) = 0;
  if (v147) {
    operator delete(v147);
  }
  uint64_t v148 = (void *)*((void *)this + 1025);
  if (v148)
  {
    do
    {
      uint64_t v149 = (void *)*v148;
      operator delete(v148);
      uint64_t v148 = v149;
    }
    while (v149);
  }
  unint64_t v150 = (void *)*((void *)this + 1023);
  *((void *)this + 1023) = 0;
  if (v150) {
    operator delete(v150);
  }
  uint64_t v151 = (void *)*((void *)this + 1020);
  if (v151)
  {
    do
    {
      int v152 = (void *)*v151;
      operator delete(v151);
      uint64_t v151 = v152;
    }
    while (v152);
  }
  int v153 = (void *)*((void *)this + 1018);
  *((void *)this + 1018) = 0;
  if (v153) {
    operator delete(v153);
  }
  int v154 = (void *)*((void *)this + 1015);
  if (v154)
  {
    do
    {
      uint64_t v160 = (void *)*v154;
      uint64_t v161 = v154[3];
      v154[3] = 0;
      if (v161) {
        (*(void (**)(uint64_t))(*(void *)v161 + 8))(v161);
      }
      operator delete(v154);
      int v154 = v160;
    }
    while (v160);
  }
  int v155 = (void *)*((void *)this + 1013);
  *((void *)this + 1013) = 0;
  if (v155) {
    operator delete(v155);
  }
  unsigned int v156 = (void *)*((void *)this + 1010);
  if (v156)
  {
    *((void *)this + 1011) = v156;
    operator delete(v156);
  }
  uint64_t v157 = *((void *)this + 1007);
  if (v157)
  {
    uint64_t v158 = *((void *)this + 1008);
    unint64_t v159 = (void *)*((void *)this + 1007);
    if (v158 != v157)
    {
      do
      {
        uint64_t v162 = *(std::__shared_weak_count **)(v158 - 8);
        if (v162 && !atomic_fetch_add(&v162->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v162->__on_zero_shared)(v162);
          std::__shared_weak_count::__release_weak(v162);
        }
        v158 -= 24;
      }
      while (v158 != v157);
      unint64_t v159 = (void *)*((void *)this + 1007);
    }
    *((void *)this + 1008) = v157;
    operator delete(v159);
  }
  unint64_t v163 = (void *)*((void *)this + 1004);
  if (v163)
  {
    *((void *)this + 1005) = v163;
    operator delete(v163);
  }
  long long v164 = (void *)*((void *)this + 1001);
  if (v164)
  {
    *((void *)this + 1002) = v164;
    operator delete(v164);
  }
  long long v165 = (void *)*((void *)this + 998);
  if (v165)
  {
    do
    {
      uint64_t v166 = (void *)*v165;
      operator delete(v165);
      long long v165 = v166;
    }
    while (v166);
  }
  uint64_t v167 = (void *)*((void *)this + 996);
  *((void *)this + 996) = 0;
  if (v167) {
    operator delete(v167);
  }
  double v168 = (void *)*((void *)this + 993);
  if (v168)
  {
    do
    {
      uint64_t v169 = (void *)*v168;
      operator delete(v168);
      double v168 = v169;
    }
    while (v169);
  }
  int v170 = (void *)*((void *)this + 991);
  *((void *)this + 991) = 0;
  if (v170) {
    operator delete(v170);
  }
  uint64_t v171 = (void *)*((void *)this + 988);
  if (v171)
  {
    do
    {
      uint64_t v172 = (void *)*v171;
      operator delete(v171);
      uint64_t v171 = v172;
    }
    while (v172);
  }
  float v173 = (void *)*((void *)this + 986);
  *((void *)this + 986) = 0;
  if (v173) {
    operator delete(v173);
  }
  float v174 = (void *)*((void *)this + 983);
  if (v174)
  {
    do
    {
      float v175 = (void *)*v174;
      operator delete(v174);
      float v174 = v175;
    }
    while (v175);
  }
  float v176 = (void *)*((void *)this + 981);
  *((void *)this + 981) = 0;
  if (v176) {
    operator delete(v176);
  }
  float v177 = (void *)*((void *)this + 978);
  if (v177)
  {
    do
    {
      float v183 = (void *)*v177;
      uint64_t v184 = v177[3];
      v177[3] = 0;
      if (v184) {
        (*(void (**)(uint64_t))(*(void *)v184 + 8))(v184);
      }
      operator delete(v177);
      float v177 = v183;
    }
    while (v183);
  }
  float v178 = (void *)*((void *)this + 976);
  *((void *)this + 976) = 0;
  if (v178) {
    operator delete(v178);
  }
  float v179 = (void *)*((void *)this + 973);
  if (v179)
  {
    *((void *)this + 974) = v179;
    operator delete(v179);
  }
  uint64_t v180 = *((void *)this + 970);
  if (v180)
  {
    uint64_t v181 = *((void *)this + 971);
    double v182 = (void *)*((void *)this + 970);
    if (v181 != v180)
    {
      do
      {
        float v185 = *(std::__shared_weak_count **)(v181 - 8);
        if (v185 && !atomic_fetch_add(&v185->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v185->__on_zero_shared)(v185);
          std::__shared_weak_count::__release_weak(v185);
        }
        v181 -= 24;
      }
      while (v181 != v180);
      double v182 = (void *)*((void *)this + 970);
    }
    *((void *)this + 971) = v180;
    operator delete(v182);
  }
  float v186 = (void *)*((void *)this + 967);
  if (v186)
  {
    *((void *)this + 968) = v186;
    operator delete(v186);
  }
  float v187 = (void *)*((void *)this + 964);
  if (v187)
  {
    *((void *)this + 965) = v187;
    operator delete(v187);
  }
  float v188 = (void *)*((void *)this + 961);
  if (v188)
  {
    do
    {
      float v189 = (void *)*v188;
      operator delete(v188);
      float v188 = v189;
    }
    while (v189);
  }
  float v190 = (void *)*((void *)this + 959);
  *((void *)this + 959) = 0;
  if (v190) {
    operator delete(v190);
  }
  long long v191 = (void *)*((void *)this + 956);
  if (v191)
  {
    do
    {
      long long v192 = (void *)*v191;
      operator delete(v191);
      long long v191 = v192;
    }
    while (v192);
  }
  long long v193 = (void *)*((void *)this + 954);
  *((void *)this + 954) = 0;
  if (v193) {
    operator delete(v193);
  }
  long long v194 = (void *)*((void *)this + 951);
  if (v194)
  {
    do
    {
      long long v195 = (void *)*v194;
      operator delete(v194);
      long long v194 = v195;
    }
    while (v195);
  }
  long long v196 = (void *)*((void *)this + 949);
  *((void *)this + 949) = 0;
  if (v196) {
    operator delete(v196);
  }
  long long v197 = (void *)*((void *)this + 946);
  if (v197)
  {
    do
    {
      long long v198 = (void *)*v197;
      operator delete(v197);
      long long v197 = v198;
    }
    while (v198);
  }
  long long v199 = (void *)*((void *)this + 944);
  *((void *)this + 944) = 0;
  if (v199) {
    operator delete(v199);
  }
  long long v200 = (void *)*((void *)this + 941);
  if (v200)
  {
    do
    {
      unint64_t v206 = (void *)*v200;
      uint64_t v207 = v200[3];
      v200[3] = 0;
      if (v207) {
        (*(void (**)(uint64_t))(*(void *)v207 + 8))(v207);
      }
      operator delete(v200);
      long long v200 = v206;
    }
    while (v206);
  }
  long long v201 = (void *)*((void *)this + 939);
  *((void *)this + 939) = 0;
  if (v201) {
    operator delete(v201);
  }
  long long v202 = (void *)*((void *)this + 936);
  if (v202)
  {
    *((void *)this + 937) = v202;
    operator delete(v202);
  }
  uint64_t v203 = *((void *)this + 933);
  if (v203)
  {
    uint64_t v204 = *((void *)this + 934);
    v205 = (void *)*((void *)this + 933);
    if (v204 != v203)
    {
      do
      {
        uint64_t v208 = *(std::__shared_weak_count **)(v204 - 8);
        if (v208 && !atomic_fetch_add(&v208->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v208->__on_zero_shared)(v208);
          std::__shared_weak_count::__release_weak(v208);
        }
        v204 -= 24;
      }
      while (v204 != v203);
      v205 = (void *)*((void *)this + 933);
    }
    *((void *)this + 934) = v203;
    operator delete(v205);
  }
  long long v209 = (void *)*((void *)this + 930);
  if (v209)
  {
    *((void *)this + 931) = v209;
    operator delete(v209);
  }
  unint64_t v210 = (void *)*((void *)this + 927);
  if (v210)
  {
    *((void *)this + 928) = v210;
    operator delete(v210);
  }
  char v211 = (void *)*((void *)this + 924);
  if (v211)
  {
    do
    {
      uint64_t v212 = (void *)*v211;
      operator delete(v211);
      char v211 = v212;
    }
    while (v212);
  }
  uint64_t v213 = (void *)*((void *)this + 922);
  *((void *)this + 922) = 0;
  if (v213) {
    operator delete(v213);
  }
  v214 = (void *)*((void *)this + 919);
  if (v214)
  {
    do
    {
      v215 = (void *)*v214;
      operator delete(v214);
      v214 = v215;
    }
    while (v215);
  }
  long long v216 = (void *)*((void *)this + 917);
  *((void *)this + 917) = 0;
  if (v216) {
    operator delete(v216);
  }
  uint64_t v217 = (void *)*((void *)this + 914);
  if (v217)
  {
    do
    {
      long long v218 = (void *)*v217;
      operator delete(v217);
      uint64_t v217 = v218;
    }
    while (v218);
  }
  long long v219 = (void *)*((void *)this + 912);
  *((void *)this + 912) = 0;
  if (v219) {
    operator delete(v219);
  }
  long long v220 = (void *)*((void *)this + 909);
  if (v220)
  {
    do
    {
      long long v221 = (void *)*v220;
      operator delete(v220);
      long long v220 = v221;
    }
    while (v221);
  }
  long long v222 = (void *)*((void *)this + 907);
  *((void *)this + 907) = 0;
  if (v222) {
    operator delete(v222);
  }
  long long v223 = (void *)*((void *)this + 904);
  if (v223)
  {
    do
    {
      unint64_t v229 = (void *)*v223;
      uint64_t v230 = v223[3];
      v223[3] = 0;
      if (v230) {
        (*(void (**)(uint64_t))(*(void *)v230 + 8))(v230);
      }
      operator delete(v223);
      long long v223 = v229;
    }
    while (v229);
  }
  long long v224 = (void *)*((void *)this + 902);
  *((void *)this + 902) = 0;
  if (v224) {
    operator delete(v224);
  }
  long long v225 = (void *)*((void *)this + 899);
  if (v225)
  {
    *((void *)this + 900) = v225;
    operator delete(v225);
  }
  uint64_t v226 = *((void *)this + 896);
  if (v226)
  {
    uint64_t v227 = *((void *)this + 897);
    v228 = (void *)*((void *)this + 896);
    if (v227 != v226)
    {
      do
      {
        v231 = *(std::__shared_weak_count **)(v227 - 8);
        if (v231 && !atomic_fetch_add(&v231->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v231->__on_zero_shared)(v231);
          std::__shared_weak_count::__release_weak(v231);
        }
        v227 -= 24;
      }
      while (v227 != v226);
      v228 = (void *)*((void *)this + 896);
    }
    *((void *)this + 897) = v226;
    operator delete(v228);
  }
  v232 = (void *)*((void *)this + 893);
  if (v232)
  {
    *((void *)this + 894) = v232;
    operator delete(v232);
  }
  unint64_t v233 = (void *)*((void *)this + 890);
  if (v233)
  {
    *((void *)this + 891) = v233;
    operator delete(v233);
  }
  v234 = (void *)*((void *)this + 887);
  if (v234)
  {
    do
    {
      unint64_t v235 = (void *)*v234;
      operator delete(v234);
      v234 = v235;
    }
    while (v235);
  }
  v236 = (void *)*((void *)this + 885);
  *((void *)this + 885) = 0;
  if (v236) {
    operator delete(v236);
  }
  v237 = (void *)*((void *)this + 882);
  if (v237)
  {
    do
    {
      unint64_t v238 = (void *)*v237;
      operator delete(v237);
      v237 = v238;
    }
    while (v238);
  }
  long long v239 = (void *)*((void *)this + 880);
  *((void *)this + 880) = 0;
  if (v239) {
    operator delete(v239);
  }
  unint64_t v240 = (void *)*((void *)this + 877);
  if (v240)
  {
    *((void *)this + 878) = v240;
    operator delete(v240);
  }
  uint64_t v241 = *((void *)this + 874);
  if (v241)
  {
    uint64_t v242 = *((void *)this + 875);
    v243 = (void *)*((void *)this + 874);
    if (v242 != v241)
    {
      do
      {
        uint64_t v244 = *(std::__shared_weak_count **)(v242 - 8);
        if (v244 && !atomic_fetch_add(&v244->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v244->__on_zero_shared)(v244);
          std::__shared_weak_count::__release_weak(v244);
        }
        v242 -= 24;
      }
      while (v242 != v241);
      v243 = (void *)*((void *)this + 874);
    }
    *((void *)this + 875) = v241;
    operator delete(v243);
  }
  char v245 = (void *)*((void *)this + 871);
  if (v245)
  {
    *((void *)this + 872) = v245;
    operator delete(v245);
  }
  unint64_t v246 = (void *)*((void *)this + 868);
  if (v246)
  {
    *((void *)this + 869) = v246;
    operator delete(v246);
  }
  v247 = (void *)*((void *)this + 865);
  if (v247)
  {
    do
    {
      v248 = (void *)*v247;
      operator delete(v247);
      v247 = v248;
    }
    while (v248);
  }
  v249 = (void *)*((void *)this + 863);
  *((void *)this + 863) = 0;
  if (v249) {
    operator delete(v249);
  }
  unint64_t v250 = (void *)*((void *)this + 860);
  if (v250)
  {
    do
    {
      long long v251 = (void *)*v250;
      operator delete(v250);
      unint64_t v250 = v251;
    }
    while (v251);
  }
  unint64_t v252 = (void *)*((void *)this + 858);
  *((void *)this + 858) = 0;
  if (v252) {
    operator delete(v252);
  }
  unint64_t v253 = (void *)*((void *)this + 855);
  if (v253)
  {
    do
    {
      v254 = (void *)*v253;
      operator delete(v253);
      unint64_t v253 = v254;
    }
    while (v254);
  }
  v255 = (void *)*((void *)this + 853);
  *((void *)this + 853) = 0;
  if (v255) {
    operator delete(v255);
  }
  uint64_t v256 = (void *)*((void *)this + 850);
  if (v256)
  {
    do
    {
      char v257 = (void *)*v256;
      operator delete(v256);
      uint64_t v256 = v257;
    }
    while (v257);
  }
  uint64_t v258 = (void *)*((void *)this + 848);
  *((void *)this + 848) = 0;
  if (v258) {
    operator delete(v258);
  }
  v259 = (void *)*((void *)this + 845);
  if (v259)
  {
    do
    {
      float64_t v265 = (void *)*v259;
      uint64_t v266 = v259[3];
      v259[3] = 0;
      if (v266) {
        (*(void (**)(uint64_t))(*(void *)v266 + 8))(v266);
      }
      operator delete(v259);
      v259 = v265;
    }
    while (v265);
  }
  v260 = (void *)*((void *)this + 843);
  *((void *)this + 843) = 0;
  if (v260) {
    operator delete(v260);
  }
  uint64_t v261 = (void *)*((void *)this + 840);
  if (v261)
  {
    *((void *)this + 841) = v261;
    operator delete(v261);
  }
  uint64_t v262 = *((void *)this + 837);
  if (v262)
  {
    uint64_t v263 = *((void *)this + 838);
    uint64_t v264 = (void *)*((void *)this + 837);
    if (v263 != v262)
    {
      do
      {
        uint64_t v267 = *(std::__shared_weak_count **)(v263 - 8);
        if (v267 && !atomic_fetch_add(&v267->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v267->__on_zero_shared)(v267);
          std::__shared_weak_count::__release_weak(v267);
        }
        v263 -= 24;
      }
      while (v263 != v262);
      uint64_t v264 = (void *)*((void *)this + 837);
    }
    *((void *)this + 838) = v262;
    operator delete(v264);
  }
  float64_t v268 = (void *)*((void *)this + 834);
  if (v268)
  {
    *((void *)this + 835) = v268;
    operator delete(v268);
  }
  unint64_t v269 = (void *)*((void *)this + 831);
  if (v269)
  {
    *((void *)this + 832) = v269;
    operator delete(v269);
  }
  float v270 = (void *)*((void *)this + 828);
  if (v270)
  {
    do
    {
      unint64_t v271 = (void *)*v270;
      operator delete(v270);
      float v270 = v271;
    }
    while (v271);
  }
  unint64_t v272 = (void *)*((void *)this + 826);
  *((void *)this + 826) = 0;
  if (v272) {
    operator delete(v272);
  }
  unint64_t v273 = (void *)*((void *)this + 823);
  if (v273)
  {
    do
    {
      BOOL v274 = (void *)*v273;
      operator delete(v273);
      unint64_t v273 = v274;
    }
    while (v274);
  }
  unint64_t v275 = (void *)*((void *)this + 821);
  *((void *)this + 821) = 0;
  if (v275) {
    operator delete(v275);
  }
  double v276 = (void *)*((void *)this + 818);
  if (v276)
  {
    do
    {
      double v277 = (void *)*v276;
      operator delete(v276);
      double v276 = v277;
    }
    while (v277);
  }
  double v278 = (void *)*((void *)this + 816);
  *((void *)this + 816) = 0;
  if (v278) {
    operator delete(v278);
  }
  double v279 = (void *)*((void *)this + 813);
  if (v279)
  {
    do
    {
      double v280 = (void *)*v279;
      operator delete(v279);
      double v279 = v280;
    }
    while (v280);
  }
  double v281 = (void *)*((void *)this + 811);
  *((void *)this + 811) = 0;
  if (v281) {
    operator delete(v281);
  }
  double v282 = (void *)*((void *)this + 808);
  if (v282)
  {
    do
    {
      float v288 = (void *)*v282;
      uint64_t v289 = v282[3];
      v282[3] = 0;
      if (v289) {
        (*(void (**)(uint64_t))(*(void *)v289 + 8))(v289);
      }
      operator delete(v282);
      double v282 = v288;
    }
    while (v288);
  }
  double v283 = (void *)*((void *)this + 806);
  *((void *)this + 806) = 0;
  if (v283) {
    operator delete(v283);
  }
  double v284 = (void *)*((void *)this + 803);
  if (v284)
  {
    *((void *)this + 804) = v284;
    operator delete(v284);
  }
  uint64_t v285 = *((void *)this + 800);
  if (v285)
  {
    uint64_t v286 = *((void *)this + 801);
    float v287 = (void *)*((void *)this + 800);
    if (v286 != v285)
    {
      do
      {
        double v290 = *(std::__shared_weak_count **)(v286 - 8);
        if (v290 && !atomic_fetch_add(&v290->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v290->__on_zero_shared)(v290);
          std::__shared_weak_count::__release_weak(v290);
        }
        v286 -= 24;
      }
      while (v286 != v285);
      float v287 = (void *)*((void *)this + 800);
    }
    *((void *)this + 801) = v285;
    operator delete(v287);
  }
  double v291 = (void *)*((void *)this + 797);
  if (v291)
  {
    *((void *)this + 798) = v291;
    operator delete(v291);
  }
  float v292 = (void *)*((void *)this + 794);
  if (v292)
  {
    *((void *)this + 795) = v292;
    operator delete(v292);
  }
  float v293 = (void *)*((void *)this + 791);
  if (v293)
  {
    do
    {
      float v294 = (void *)*v293;
      operator delete(v293);
      float v293 = v294;
    }
    while (v294);
  }
  float64_t v295 = (void *)*((void *)this + 789);
  *((void *)this + 789) = 0;
  if (v295) {
    operator delete(v295);
  }
  uint64_t v296 = (void *)*((void *)this + 786);
  if (v296)
  {
    do
    {
      unint64_t v297 = (void *)*v296;
      operator delete(v296);
      uint64_t v296 = v297;
    }
    while (v297);
  }
  unint64_t v298 = (void *)*((void *)this + 784);
  *((void *)this + 784) = 0;
  if (v298) {
    operator delete(v298);
  }
  v299 = (void *)*((void *)this + 781);
  if (v299)
  {
    do
    {
      v300 = (void *)*v299;
      operator delete(v299);
      v299 = v300;
    }
    while (v300);
  }
  float64_t v301 = (void *)*((void *)this + 779);
  *((void *)this + 779) = 0;
  if (v301) {
    operator delete(v301);
  }
  uint64_t v302 = (void *)*((void *)this + 776);
  if (v302)
  {
    do
    {
      int v303 = (void *)*v302;
      operator delete(v302);
      uint64_t v302 = v303;
    }
    while (v303);
  }
  uint64_t v304 = (void *)*((void *)this + 774);
  *((void *)this + 774) = 0;
  if (v304) {
    operator delete(v304);
  }
  unint64_t v305 = (void *)*((void *)this + 771);
  if (v305)
  {
    do
    {
      uint64_t v311 = (void *)*v305;
      uint64_t v312 = v305[3];
      v305[3] = 0;
      if (v312) {
        (*(void (**)(uint64_t))(*(void *)v312 + 8))(v312);
      }
      operator delete(v305);
      unint64_t v305 = v311;
    }
    while (v311);
  }
  uint64_t v306 = (void *)*((void *)this + 769);
  *((void *)this + 769) = 0;
  if (v306) {
    operator delete(v306);
  }
  int v307 = (void *)*((void *)this + 766);
  if (v307)
  {
    *((void *)this + 767) = v307;
    operator delete(v307);
  }
  uint64_t v308 = *((void *)this + 763);
  if (v308)
  {
    uint64_t v309 = *((void *)this + 764);
    unint64_t v310 = (void *)*((void *)this + 763);
    if (v309 != v308)
    {
      do
      {
        v313 = *(std::__shared_weak_count **)(v309 - 8);
        if (v313 && !atomic_fetch_add(&v313->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v313->__on_zero_shared)(v313);
          std::__shared_weak_count::__release_weak(v313);
        }
        v309 -= 24;
      }
      while (v309 != v308);
      unint64_t v310 = (void *)*((void *)this + 763);
    }
    *((void *)this + 764) = v308;
    operator delete(v310);
  }
  uint64_t v314 = (void *)*((void *)this + 760);
  if (v314)
  {
    *((void *)this + 761) = v314;
    operator delete(v314);
  }
  uint64_t v315 = (void *)*((void *)this + 757);
  if (v315)
  {
    *((void *)this + 758) = v315;
    operator delete(v315);
  }
  v316 = (void *)*((void *)this + 754);
  if (v316)
  {
    do
    {
      v317 = (void *)*v316;
      operator delete(v316);
      v316 = v317;
    }
    while (v317);
  }
  uint64_t v318 = (void *)*((void *)this + 752);
  *((void *)this + 752) = 0;
  if (v318) {
    operator delete(v318);
  }
  uint64_t v319 = (void *)*((void *)this + 749);
  if (v319)
  {
    do
    {
      v320 = (void *)*v319;
      operator delete(v319);
      uint64_t v319 = v320;
    }
    while (v320);
  }
  uint64_t v321 = (void *)*((void *)this + 747);
  *((void *)this + 747) = 0;
  if (v321) {
    operator delete(v321);
  }
  v322 = (void *)*((void *)this + 744);
  if (v322)
  {
    *((void *)this + 745) = v322;
    operator delete(v322);
  }
  uint64_t v323 = *((void *)this + 741);
  if (v323)
  {
    uint64_t v324 = *((void *)this + 742);
    v325 = (void *)*((void *)this + 741);
    if (v324 != v323)
    {
      do
      {
        v326 = *(std::__shared_weak_count **)(v324 - 8);
        if (v326 && !atomic_fetch_add(&v326->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v326->__on_zero_shared)(v326);
          std::__shared_weak_count::__release_weak(v326);
        }
        v324 -= 24;
      }
      while (v324 != v323);
      v325 = (void *)*((void *)this + 741);
    }
    *((void *)this + 742) = v323;
    operator delete(v325);
  }
  v327 = (void *)*((void *)this + 738);
  if (v327)
  {
    *((void *)this + 739) = v327;
    operator delete(v327);
  }
  v328 = (void *)*((void *)this + 735);
  if (v328)
  {
    *((void *)this + 736) = v328;
    operator delete(v328);
  }
  double v329 = (void *)*((void *)this + 732);
  if (v329)
  {
    do
    {
      double v330 = (void *)*v329;
      operator delete(v329);
      double v329 = v330;
    }
    while (v330);
  }
  double v331 = (void *)*((void *)this + 730);
  *((void *)this + 730) = 0;
  if (v331) {
    operator delete(v331);
  }
  double v332 = (void *)*((void *)this + 727);
  if (v332)
  {
    do
    {
      double v333 = (void *)*v332;
      operator delete(v332);
      double v332 = v333;
    }
    while (v333);
  }
  double v334 = (void *)*((void *)this + 725);
  *((void *)this + 725) = 0;
  if (v334) {
    operator delete(v334);
  }
  double v335 = (void *)*((void *)this + 722);
  if (v335)
  {
    do
    {
      uint64_t v341 = (void *)*v335;
      uint64_t v342 = v335[3];
      v335[3] = 0;
      if (v342) {
        (*(void (**)(uint64_t))(*(void *)v342 + 8))(v342);
      }
      operator delete(v335);
      double v335 = v341;
    }
    while (v341);
  }
  double v336 = (void *)*((void *)this + 720);
  *((void *)this + 720) = 0;
  if (v336) {
    operator delete(v336);
  }
  double v337 = (void *)*((void *)this + 717);
  if (v337)
  {
    *((void *)this + 718) = v337;
    operator delete(v337);
  }
  uint64_t v338 = *((void *)this + 714);
  if (v338)
  {
    uint64_t v339 = *((void *)this + 715);
    v340 = (void *)*((void *)this + 714);
    if (v339 != v338)
    {
      do
      {
        unint64_t v343 = *(std::__shared_weak_count **)(v339 - 8);
        if (v343 && !atomic_fetch_add(&v343->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v343->__on_zero_shared)(v343);
          std::__shared_weak_count::__release_weak(v343);
        }
        v339 -= 24;
      }
      while (v339 != v338);
      v340 = (void *)*((void *)this + 714);
    }
    *((void *)this + 715) = v338;
    operator delete(v340);
  }
  v344 = (void *)*((void *)this + 711);
  if (v344)
  {
    *((void *)this + 712) = v344;
    operator delete(v344);
  }
  double v345 = (void *)*((void *)this + 708);
  if (v345)
  {
    *((void *)this + 709) = v345;
    operator delete(v345);
  }
  double v346 = (void *)*((void *)this + 705);
  if (v346)
  {
    do
    {
      double v347 = (void *)*v346;
      operator delete(v346);
      double v346 = v347;
    }
    while (v347);
  }
  double v348 = (void *)*((void *)this + 703);
  *((void *)this + 703) = 0;
  if (v348) {
    operator delete(v348);
  }
  double v349 = (void *)*((void *)this + 700);
  if (v349)
  {
    do
    {
      double v350 = (void *)*v349;
      operator delete(v349);
      double v349 = v350;
    }
    while (v350);
  }
  double v351 = (void *)*((void *)this + 698);
  *((void *)this + 698) = 0;
  if (v351) {
    operator delete(v351);
  }
  double v352 = (void *)*((void *)this + 695);
  if (v352)
  {
    *((void *)this + 696) = v352;
    operator delete(v352);
  }
  uint64_t v353 = *((void *)this + 692);
  if (v353)
  {
    uint64_t v354 = *((void *)this + 693);
    double v355 = (void *)*((void *)this + 692);
    if (v354 != v353)
    {
      do
      {
        v356 = *(std::__shared_weak_count **)(v354 - 8);
        if (v356 && !atomic_fetch_add(&v356->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v356->__on_zero_shared)(v356);
          std::__shared_weak_count::__release_weak(v356);
        }
        v354 -= 24;
      }
      while (v354 != v353);
      double v355 = (void *)*((void *)this + 692);
    }
    *((void *)this + 693) = v353;
    operator delete(v355);
  }
  unint64_t v357 = (void *)*((void *)this + 689);
  if (v357)
  {
    *((void *)this + 690) = v357;
    operator delete(v357);
  }
  v358 = (void *)*((void *)this + 686);
  if (v358)
  {
    *((void *)this + 687) = v358;
    operator delete(v358);
  }
  unint64_t v359 = (void *)*((void *)this + 683);
  if (v359)
  {
    do
    {
      uint64_t v360 = (void *)*v359;
      operator delete(v359);
      unint64_t v359 = v360;
    }
    while (v360);
  }
  uint64_t v361 = (void *)*((void *)this + 681);
  *((void *)this + 681) = 0;
  if (v361) {
    operator delete(v361);
  }
  long long v362 = (void *)*((void *)this + 678);
  if (v362)
  {
    do
    {
      unint64_t v363 = (void *)*v362;
      operator delete(v362);
      long long v362 = v363;
    }
    while (v363);
  }
  uint64_t v364 = (void *)*((void *)this + 676);
  *((void *)this + 676) = 0;
  if (v364) {
    operator delete(v364);
  }
  uint64_t v365 = (void *)*((void *)this + 673);
  if (v365)
  {
    do
    {
      double v371 = (void *)*v365;
      uint64_t v372 = v365[3];
      v365[3] = 0;
      if (v372) {
        (*(void (**)(uint64_t))(*(void *)v372 + 8))(v372);
      }
      operator delete(v365);
      uint64_t v365 = v371;
    }
    while (v371);
  }
  uint64_t v366 = (void *)*((void *)this + 671);
  *((void *)this + 671) = 0;
  if (v366) {
    operator delete(v366);
  }
  unint64_t v367 = (void *)*((void *)this + 668);
  if (v367)
  {
    *((void *)this + 669) = v367;
    operator delete(v367);
  }
  uint64_t v368 = *((void *)this + 665);
  if (v368)
  {
    uint64_t v369 = *((void *)this + 666);
    double v370 = (void *)*((void *)this + 665);
    if (v369 != v368)
    {
      do
      {
        double v373 = *(std::__shared_weak_count **)(v369 - 8);
        if (v373 && !atomic_fetch_add(&v373->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v373->__on_zero_shared)(v373);
          std::__shared_weak_count::__release_weak(v373);
        }
        v369 -= 24;
      }
      while (v369 != v368);
      double v370 = (void *)*((void *)this + 665);
    }
    *((void *)this + 666) = v368;
    operator delete(v370);
  }
  double v374 = (void *)*((void *)this + 662);
  if (v374)
  {
    *((void *)this + 663) = v374;
    operator delete(v374);
  }
  double v375 = (void *)*((void *)this + 659);
  if (v375)
  {
    *((void *)this + 660) = v375;
    operator delete(v375);
  }
  double v376 = (void *)*((void *)this + 656);
  if (v376)
  {
    do
    {
      double v377 = (void *)*v376;
      operator delete(v376);
      double v376 = v377;
    }
    while (v377);
  }
  double v378 = (void *)*((void *)this + 654);
  *((void *)this + 654) = 0;
  if (v378) {
    operator delete(v378);
  }
  double v379 = (void *)*((void *)this + 651);
  if (v379)
  {
    do
    {
      double v380 = (void *)*v379;
      operator delete(v379);
      double v379 = v380;
    }
    while (v380);
  }
  double v381 = (void *)*((void *)this + 649);
  *((void *)this + 649) = 0;
  if (v381) {
    operator delete(v381);
  }
  double v382 = (void *)*((void *)this + 646);
  if (v382)
  {
    do
    {
      uint64_t v388 = (void *)*v382;
      uint64_t v389 = v382[3];
      v382[3] = 0;
      if (v389) {
        (*(void (**)(uint64_t))(*(void *)v389 + 8))(v389);
      }
      operator delete(v382);
      double v382 = v388;
    }
    while (v388);
  }
  double v383 = (void *)*((void *)this + 644);
  *((void *)this + 644) = 0;
  if (v383) {
    operator delete(v383);
  }
  double v384 = (void *)*((void *)this + 641);
  if (v384)
  {
    *((void *)this + 642) = v384;
    operator delete(v384);
  }
  uint64_t v385 = *((void *)this + 638);
  if (v385)
  {
    uint64_t v386 = *((void *)this + 639);
    double v387 = (void *)*((void *)this + 638);
    if (v386 != v385)
    {
      do
      {
        double v390 = *(std::__shared_weak_count **)(v386 - 8);
        if (v390 && !atomic_fetch_add(&v390->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v390->__on_zero_shared)(v390);
          std::__shared_weak_count::__release_weak(v390);
        }
        v386 -= 24;
      }
      while (v386 != v385);
      double v387 = (void *)*((void *)this + 638);
    }
    *((void *)this + 639) = v385;
    operator delete(v387);
  }
  double v391 = (void *)*((void *)this + 635);
  if (v391)
  {
    *((void *)this + 636) = v391;
    operator delete(v391);
  }
  double v392 = (void *)*((void *)this + 632);
  if (v392)
  {
    *((void *)this + 633) = v392;
    operator delete(v392);
  }
  double v393 = (void *)*((void *)this + 629);
  if (v393)
  {
    do
    {
      double v394 = (void *)*v393;
      operator delete(v393);
      double v393 = v394;
    }
    while (v394);
  }
  v395 = (void *)*((void *)this + 627);
  *((void *)this + 627) = 0;
  if (v395) {
    operator delete(v395);
  }
  unint64_t v396 = (void *)*((void *)this + 624);
  if (v396)
  {
    do
    {
      unint64_t v397 = (void *)*v396;
      operator delete(v396);
      unint64_t v396 = v397;
    }
    while (v397);
  }
  v398 = (void *)*((void *)this + 622);
  *((void *)this + 622) = 0;
  if (v398) {
    operator delete(v398);
  }
  int v399 = (void *)*((void *)this + 619);
  if (v399)
  {
    do
    {
      unint64_t v405 = (void *)*v399;
      uint64_t v406 = v399[3];
      v399[3] = 0;
      if (v406) {
        (*(void (**)(uint64_t))(*(void *)v406 + 8))(v406);
      }
      operator delete(v399);
      int v399 = v405;
    }
    while (v405);
  }
  int v400 = (void *)*((void *)this + 617);
  *((void *)this + 617) = 0;
  if (v400) {
    operator delete(v400);
  }
  unint64_t v401 = (void *)*((void *)this + 614);
  if (v401)
  {
    *((void *)this + 615) = v401;
    operator delete(v401);
  }
  uint64_t v402 = *((void *)this + 611);
  if (v402)
  {
    uint64_t v403 = *((void *)this + 612);
    uint64_t v404 = (void *)*((void *)this + 611);
    if (v403 != v402)
    {
      do
      {
        v407 = *(std::__shared_weak_count **)(v403 - 8);
        if (v407 && !atomic_fetch_add(&v407->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v407->__on_zero_shared)(v407);
          std::__shared_weak_count::__release_weak(v407);
        }
        v403 -= 24;
      }
      while (v403 != v402);
      uint64_t v404 = (void *)*((void *)this + 611);
    }
    *((void *)this + 612) = v402;
    operator delete(v404);
  }
  double v408 = (void *)*((void *)this + 608);
  if (v408)
  {
    *((void *)this + 609) = v408;
    operator delete(v408);
  }
  double v409 = (void *)*((void *)this + 605);
  if (v409)
  {
    *((void *)this + 606) = v409;
    operator delete(v409);
  }
  double v410 = (void *)*((void *)this + 602);
  if (v410)
  {
    do
    {
      double v411 = (void *)*v410;
      operator delete(v410);
      double v410 = v411;
    }
    while (v411);
  }
  double v412 = (void *)*((void *)this + 600);
  *((void *)this + 600) = 0;
  if (v412) {
    operator delete(v412);
  }
  double v413 = (void *)*((void *)this + 597);
  if (v413)
  {
    do
    {
      double v414 = (void *)*v413;
      operator delete(v413);
      double v413 = v414;
    }
    while (v414);
  }
  double v415 = (void *)*((void *)this + 595);
  *((void *)this + 595) = 0;
  if (v415) {
    operator delete(v415);
  }
  double v416 = (void *)*((void *)this + 592);
  if (v416)
  {
    do
    {
      double v422 = (void *)*v416;
      uint64_t v423 = v416[3];
      v416[3] = 0;
      if (v423) {
        (*(void (**)(uint64_t))(*(void *)v423 + 8))(v423);
      }
      operator delete(v416);
      double v416 = v422;
    }
    while (v422);
  }
  double v417 = (void *)*((void *)this + 590);
  *((void *)this + 590) = 0;
  if (v417) {
    operator delete(v417);
  }
  double v418 = (void *)*((void *)this + 587);
  if (v418)
  {
    *((void *)this + 588) = v418;
    operator delete(v418);
  }
  uint64_t v419 = *((void *)this + 584);
  if (v419)
  {
    uint64_t v420 = *((void *)this + 585);
    double v421 = (void *)*((void *)this + 584);
    if (v420 != v419)
    {
      do
      {
        double v424 = *(std::__shared_weak_count **)(v420 - 8);
        if (v424 && !atomic_fetch_add(&v424->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v424->__on_zero_shared)(v424);
          std::__shared_weak_count::__release_weak(v424);
        }
        v420 -= 24;
      }
      while (v420 != v419);
      double v421 = (void *)*((void *)this + 584);
    }
    *((void *)this + 585) = v419;
    operator delete(v421);
  }
  double v425 = (void *)*((void *)this + 581);
  if (v425)
  {
    *((void *)this + 582) = v425;
    operator delete(v425);
  }
  uint64_t v426 = (void *)*((void *)this + 578);
  if (v426)
  {
    *((void *)this + 579) = v426;
    operator delete(v426);
  }
  double v427 = (void *)*((void *)this + 575);
  if (v427)
  {
    do
    {
      double v428 = (void *)*v427;
      operator delete(v427);
      double v427 = v428;
    }
    while (v428);
  }
  double v429 = (void *)*((void *)this + 573);
  *((void *)this + 573) = 0;
  if (v429) {
    operator delete(v429);
  }
  double v430 = (void *)*((void *)this + 570);
  if (v430)
  {
    do
    {
      double v431 = (void *)*v430;
      operator delete(v430);
      double v430 = v431;
    }
    while (v431);
  }
  double v432 = (void *)*((void *)this + 568);
  *((void *)this + 568) = 0;
  if (v432) {
    operator delete(v432);
  }
  v433 = (void *)*((void *)this + 565);
  if (v433)
  {
    do
    {
      unint64_t v439 = (void *)*v433;
      uint64_t v440 = v433[3];
      v433[3] = 0;
      if (v440) {
        (*(void (**)(uint64_t))(*(void *)v440 + 8))(v440);
      }
      operator delete(v433);
      v433 = v439;
    }
    while (v439);
  }
  unint64_t v434 = (void *)*((void *)this + 563);
  *((void *)this + 563) = 0;
  if (v434) {
    operator delete(v434);
  }
  unint64_t v435 = (void *)*((void *)this + 560);
  if (v435)
  {
    *((void *)this + 561) = v435;
    operator delete(v435);
  }
  uint64_t v436 = *((void *)this + 557);
  if (v436)
  {
    uint64_t v437 = *((void *)this + 558);
    int v438 = (void *)*((void *)this + 557);
    if (v437 != v436)
    {
      do
      {
        uint64_t v441 = *(std::__shared_weak_count **)(v437 - 8);
        if (v441 && !atomic_fetch_add(&v441->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v441->__on_zero_shared)(v441);
          std::__shared_weak_count::__release_weak(v441);
        }
        v437 -= 24;
      }
      while (v437 != v436);
      int v438 = (void *)*((void *)this + 557);
    }
    *((void *)this + 558) = v436;
    operator delete(v438);
  }
  uint64_t v442 = (void *)*((void *)this + 554);
  if (v442)
  {
    *((void *)this + 555) = v442;
    operator delete(v442);
  }
  unint64_t v443 = (void *)*((void *)this + 551);
  if (v443)
  {
    *((void *)this + 552) = v443;
    operator delete(v443);
  }
  long long v444 = (void *)*((void *)this + 548);
  if (v444)
  {
    do
    {
      v445 = (void *)*v444;
      operator delete(v444);
      long long v444 = v445;
    }
    while (v445);
  }
  double v446 = (void *)*((void *)this + 546);
  *((void *)this + 546) = 0;
  if (v446) {
    operator delete(v446);
  }
  double v447 = (void *)*((void *)this + 543);
  if (v447)
  {
    do
    {
      double v448 = (void *)*v447;
      operator delete(v447);
      double v447 = v448;
    }
    while (v448);
  }
  double v449 = (void *)*((void *)this + 541);
  *((void *)this + 541) = 0;
  if (v449) {
    operator delete(v449);
  }
  double v450 = (void *)*((void *)this + 538);
  if (v450)
  {
    do
    {
      double v456 = (void *)*v450;
      uint64_t v457 = v450[3];
      v450[3] = 0;
      if (v457) {
        (*(void (**)(uint64_t))(*(void *)v457 + 8))(v457);
      }
      operator delete(v450);
      double v450 = v456;
    }
    while (v456);
  }
  double v451 = (void *)*((void *)this + 536);
  *((void *)this + 536) = 0;
  if (v451) {
    operator delete(v451);
  }
  double v452 = (void *)*((void *)this + 533);
  if (v452)
  {
    *((void *)this + 534) = v452;
    operator delete(v452);
  }
  uint64_t v453 = *((void *)this + 530);
  if (v453)
  {
    uint64_t v454 = *((void *)this + 531);
    double v455 = (void *)*((void *)this + 530);
    if (v454 != v453)
    {
      do
      {
        double v458 = *(std::__shared_weak_count **)(v454 - 8);
        if (v458 && !atomic_fetch_add(&v458->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v458->__on_zero_shared)(v458);
          std::__shared_weak_count::__release_weak(v458);
        }
        v454 -= 24;
      }
      while (v454 != v453);
      double v455 = (void *)*((void *)this + 530);
    }
    *((void *)this + 531) = v453;
    operator delete(v455);
  }
  double v459 = (void *)*((void *)this + 527);
  if (v459)
  {
    *((void *)this + 528) = v459;
    operator delete(v459);
  }
  double v460 = (void *)*((void *)this + 524);
  if (v460)
  {
    *((void *)this + 525) = v460;
    operator delete(v460);
  }
  double v461 = (void *)*((void *)this + 521);
  if (v461)
  {
    do
    {
      double v462 = (void *)*v461;
      operator delete(v461);
      double v461 = v462;
    }
    while (v462);
  }
  double v463 = (void *)*((void *)this + 519);
  *((void *)this + 519) = 0;
  if (v463) {
    operator delete(v463);
  }
  uint64_t v464 = (void *)*((void *)this + 516);
  if (v464)
  {
    do
    {
      double v465 = (void *)*v464;
      operator delete(v464);
      uint64_t v464 = v465;
    }
    while (v465);
  }
  double v466 = (void *)*((void *)this + 514);
  *((void *)this + 514) = 0;
  if (v466) {
    operator delete(v466);
  }
  double v467 = (void *)*((void *)this + 511);
  if (v467)
  {
    *((void *)this + 512) = v467;
    operator delete(v467);
  }
  uint64_t v468 = *((void *)this + 508);
  if (v468)
  {
    uint64_t v469 = *((void *)this + 509);
    double v470 = (void *)*((void *)this + 508);
    if (v469 != v468)
    {
      do
      {
        v471 = *(std::__shared_weak_count **)(v469 - 8);
        if (v471 && !atomic_fetch_add(&v471->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v471->__on_zero_shared)(v471);
          std::__shared_weak_count::__release_weak(v471);
        }
        v469 -= 24;
      }
      while (v469 != v468);
      double v470 = (void *)*((void *)this + 508);
    }
    *((void *)this + 509) = v468;
    operator delete(v470);
  }
  unint64_t v472 = (void *)*((void *)this + 505);
  if (v472)
  {
    *((void *)this + 506) = v472;
    operator delete(v472);
  }
  unint64_t v473 = (void *)*((void *)this + 502);
  if (v473)
  {
    *((void *)this + 503) = v473;
    operator delete(v473);
  }
  v474 = (void *)*((void *)this + 499);
  if (v474)
  {
    do
    {
      int v475 = (void *)*v474;
      operator delete(v474);
      v474 = v475;
    }
    while (v475);
  }
  int v476 = (void *)*((void *)this + 497);
  *((void *)this + 497) = 0;
  if (v476) {
    operator delete(v476);
  }
  unint64_t v477 = (void *)*((void *)this + 494);
  if (v477)
  {
    do
    {
      unint64_t v478 = (void *)*v477;
      operator delete(v477);
      unint64_t v477 = v478;
    }
    while (v478);
  }
  uint64_t v479 = (void *)*((void *)this + 492);
  *((void *)this + 492) = 0;
  if (v479) {
    operator delete(v479);
  }
  unint64_t v480 = (void *)*((void *)this + 489);
  if (v480)
  {
    *((void *)this + 490) = v480;
    operator delete(v480);
  }
  uint64_t v481 = *((void *)this + 486);
  if (v481)
  {
    uint64_t v482 = *((void *)this + 487);
    double v483 = (void *)*((void *)this + 486);
    if (v482 != v481)
    {
      do
      {
        double v484 = *(std::__shared_weak_count **)(v482 - 8);
        if (v484 && !atomic_fetch_add(&v484->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v484->__on_zero_shared)(v484);
          std::__shared_weak_count::__release_weak(v484);
        }
        v482 -= 24;
      }
      while (v482 != v481);
      double v483 = (void *)*((void *)this + 486);
    }
    *((void *)this + 487) = v481;
    operator delete(v483);
  }
  double v485 = (void *)*((void *)this + 483);
  if (v485)
  {
    *((void *)this + 484) = v485;
    operator delete(v485);
  }
  double v486 = (void *)*((void *)this + 480);
  if (v486)
  {
    *((void *)this + 481) = v486;
    operator delete(v486);
  }
  double v487 = (void *)*((void *)this + 477);
  if (v487)
  {
    do
    {
      double v488 = (void *)*v487;
      operator delete(v487);
      double v487 = v488;
    }
    while (v488);
  }
  double v489 = (void *)*((void *)this + 475);
  *((void *)this + 475) = 0;
  if (v489) {
    operator delete(v489);
  }
  double v490 = (void *)*((void *)this + 472);
  if (v490)
  {
    do
    {
      double v491 = (void *)*v490;
      operator delete(v490);
      double v490 = v491;
    }
    while (v491);
  }
  double v492 = (void *)*((void *)this + 470);
  *((void *)this + 470) = 0;
  if (v492) {
    operator delete(v492);
  }
  double v493 = (void *)*((void *)this + 467);
  if (v493)
  {
    *((void *)this + 468) = v493;
    operator delete(v493);
  }
  uint64_t v494 = *((void *)this + 464);
  if (v494)
  {
    uint64_t v495 = *((void *)this + 465);
    double v496 = (void *)*((void *)this + 464);
    if (v495 != v494)
    {
      do
      {
        double v497 = *(std::__shared_weak_count **)(v495 - 8);
        if (v497 && !atomic_fetch_add(&v497->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v497->__on_zero_shared)(v497);
          std::__shared_weak_count::__release_weak(v497);
        }
        v495 -= 24;
      }
      while (v495 != v494);
      double v496 = (void *)*((void *)this + 464);
    }
    *((void *)this + 465) = v494;
    operator delete(v496);
  }
  double v498 = (void *)*((void *)this + 461);
  if (v498)
  {
    *((void *)this + 462) = v498;
    operator delete(v498);
  }
  double v499 = (void *)*((void *)this + 458);
  if (v499)
  {
    *((void *)this + 459) = v499;
    operator delete(v499);
  }
  double v500 = (void *)*((void *)this + 455);
  if (v500)
  {
    do
    {
      uint64_t v501 = (void *)*v500;
      operator delete(v500);
      double v500 = v501;
    }
    while (v501);
  }
  double v502 = (void *)*((void *)this + 453);
  *((void *)this + 453) = 0;
  if (v502) {
    operator delete(v502);
  }
  double v503 = (void *)*((void *)this + 450);
  if (v503)
  {
    do
    {
      double v504 = (void *)*v503;
      operator delete(v503);
      double v503 = v504;
    }
    while (v504);
  }
  double v505 = (void *)*((void *)this + 448);
  *((void *)this + 448) = 0;
  if (v505) {
    operator delete(v505);
  }
  double v506 = (void *)*((void *)this + 445);
  if (v506)
  {
    *((void *)this + 446) = v506;
    operator delete(v506);
  }
  uint64_t v507 = *((void *)this + 442);
  if (v507)
  {
    uint64_t v508 = *((void *)this + 443);
    unint64_t v509 = (void *)*((void *)this + 442);
    if (v508 != v507)
    {
      do
      {
        unint64_t v510 = *(std::__shared_weak_count **)(v508 - 8);
        if (v510 && !atomic_fetch_add(&v510->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v510->__on_zero_shared)(v510);
          std::__shared_weak_count::__release_weak(v510);
        }
        v508 -= 24;
      }
      while (v508 != v507);
      unint64_t v509 = (void *)*((void *)this + 442);
    }
    *((void *)this + 443) = v507;
    operator delete(v509);
  }
  v511 = (void *)*((void *)this + 439);
  if (v511)
  {
    *((void *)this + 440) = v511;
    operator delete(v511);
  }
  int v512 = (void *)*((void *)this + 436);
  if (v512)
  {
    *((void *)this + 437) = v512;
    operator delete(v512);
  }
  int v513 = (void *)*((void *)this + 433);
  if (v513)
  {
    do
    {
      unint64_t v514 = (void *)*v513;
      operator delete(v513);
      int v513 = v514;
    }
    while (v514);
  }
  unint64_t v515 = (void *)*((void *)this + 431);
  *((void *)this + 431) = 0;
  if (v515) {
    operator delete(v515);
  }
  v516 = (void *)*((void *)this + 428);
  if (v516)
  {
    do
    {
      uint64_t v517 = (void *)*v516;
      operator delete(v516);
      v516 = v517;
    }
    while (v517);
  }
  v518 = (void *)*((void *)this + 426);
  *((void *)this + 426) = 0;
  if (v518) {
    operator delete(v518);
  }
  v519 = (void *)*((void *)this + 423);
  if (v519)
  {
    *((void *)this + 424) = v519;
    operator delete(v519);
  }
  uint64_t v520 = *((void *)this + 420);
  if (v520)
  {
    uint64_t v521 = *((void *)this + 421);
    v522 = (void *)*((void *)this + 420);
    if (v521 != v520)
    {
      do
      {
        std::string v523 = *(std::__shared_weak_count **)(v521 - 8);
        if (v523 && !atomic_fetch_add(&v523->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v523->__on_zero_shared)(v523);
          std::__shared_weak_count::__release_weak(v523);
        }
        v521 -= 24;
      }
      while (v521 != v520);
      v522 = (void *)*((void *)this + 420);
    }
    *((void *)this + 421) = v520;
    operator delete(v522);
  }
  std::string v524 = (void *)*((void *)this + 417);
  if (v524)
  {
    *((void *)this + 418) = v524;
    operator delete(v524);
  }
  unint64_t v525 = (void *)*((void *)this + 414);
  if (v525)
  {
    *((void *)this + 415) = v525;
    operator delete(v525);
  }
  __int16 v526 = (void *)*((void *)this + 411);
  if (v526)
  {
    do
    {
      v527 = (void *)*v526;
      operator delete(v526);
      __int16 v526 = v527;
    }
    while (v527);
  }
  std::string v528 = (void *)*((void *)this + 409);
  *((void *)this + 409) = 0;
  if (v528) {
    operator delete(v528);
  }
  uint64_t v529 = (void *)*((void *)this + 406);
  if (v529)
  {
    do
    {
      long long v530 = (void *)*v529;
      operator delete(v529);
      uint64_t v529 = v530;
    }
    while (v530);
  }
  long long v531 = (void *)*((void *)this + 404);
  *((void *)this + 404) = 0;
  if (v531) {
    operator delete(v531);
  }
  long long v532 = (void *)*((void *)this + 401);
  if (v532)
  {
    do
    {
      long long v533 = (void *)*v532;
      operator delete(v532);
      long long v532 = v533;
    }
    while (v533);
  }
  long long v534 = (void *)*((void *)this + 399);
  *((void *)this + 399) = 0;
  if (v534) {
    operator delete(v534);
  }
  uint64_t v535 = (void *)*((void *)this + 396);
  if (v535)
  {
    do
    {
      uint64_t v536 = (void *)*v535;
      operator delete(v535);
      uint64_t v535 = v536;
    }
    while (v536);
  }
  std::string v537 = (void *)*((void *)this + 394);
  *((void *)this + 394) = 0;
  if (v537) {
    operator delete(v537);
  }
  uint64_t v538 = (void *)*((void *)this + 391);
  if (v538)
  {
    do
    {
      double v544 = (void *)*v538;
      uint64_t v545 = v538[3];
      v538[3] = 0;
      if (v545) {
        (*(void (**)(uint64_t))(*(void *)v545 + 8))(v545);
      }
      operator delete(v538);
      uint64_t v538 = v544;
    }
    while (v544);
  }
  double v539 = (void *)*((void *)this + 389);
  *((void *)this + 389) = 0;
  if (v539) {
    operator delete(v539);
  }
  double v540 = (void *)*((void *)this + 386);
  if (v540)
  {
    *((void *)this + 387) = v540;
    operator delete(v540);
  }
  uint64_t v541 = *((void *)this + 383);
  if (v541)
  {
    uint64_t v542 = *((void *)this + 384);
    double v543 = (void *)*((void *)this + 383);
    if (v542 != v541)
    {
      do
      {
        uint64_t v546 = *(std::__shared_weak_count **)(v542 - 8);
        if (v546 && !atomic_fetch_add(&v546->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v546->__on_zero_shared)(v546);
          std::__shared_weak_count::__release_weak(v546);
        }
        v542 -= 24;
      }
      while (v542 != v541);
      double v543 = (void *)*((void *)this + 383);
    }
    *((void *)this + 384) = v541;
    operator delete(v543);
  }
  std::string v547 = (void *)*((void *)this + 380);
  if (v547)
  {
    *((void *)this + 381) = v547;
    operator delete(v547);
  }
  uint64_t v548 = (void *)*((void *)this + 377);
  if (v548)
  {
    *((void *)this + 378) = v548;
    operator delete(v548);
  }
  v549 = (void *)*((void *)this + 374);
  if (v549)
  {
    do
    {
      v550 = (void *)*v549;
      operator delete(v549);
      v549 = v550;
    }
    while (v550);
  }
  long long v551 = (void *)*((void *)this + 372);
  *((void *)this + 372) = 0;
  if (v551) {
    operator delete(v551);
  }
  uint64_t v552 = (void *)*((void *)this + 369);
  if (v552)
  {
    do
    {
      long long v553 = (void *)*v552;
      operator delete(v552);
      uint64_t v552 = v553;
    }
    while (v553);
  }
  long long v554 = (void *)*((void *)this + 367);
  *((void *)this + 367) = 0;
  if (v554) {
    operator delete(v554);
  }
  double v555 = (void *)*((void *)this + 364);
  if (v555)
  {
    do
    {
      uint64_t v556 = (void *)*v555;
      operator delete(v555);
      double v555 = v556;
    }
    while (v556);
  }
  uint64_t v557 = (void *)*((void *)this + 362);
  *((void *)this + 362) = 0;
  if (v557) {
    operator delete(v557);
  }
  unint64_t v558 = (void *)*((void *)this + 359);
  if (v558)
  {
    do
    {
      double v559 = (void *)*v558;
      operator delete(v558);
      unint64_t v558 = v559;
    }
    while (v559);
  }
  uint64_t v560 = (void *)*((void *)this + 357);
  *((void *)this + 357) = 0;
  if (v560) {
    operator delete(v560);
  }
  std::string v561 = (void *)*((void *)this + 354);
  if (v561)
  {
    do
    {
      v585 = (void *)*v561;
      uint64_t v586 = v561[3];
      v561[3] = 0;
      if (v586) {
        MEMORY[0x1A6239270](v586, 0x1000C400CE834B2);
      }
      operator delete(v561);
      std::string v561 = v585;
    }
    while (v585);
  }
  long long v562 = (void *)*((void *)this + 352);
  *((void *)this + 352) = 0;
  if (v562) {
    operator delete(v562);
  }
  double v563 = (void *)*((void *)this + 349);
  if (v563)
  {
    *((void *)this + 350) = v563;
    operator delete(v563);
  }
  double v564 = (void *)*((void *)this + 346);
  if (v564)
  {
    *((void *)this + 347) = v564;
    operator delete(v564);
  }
  std::string v565 = (void *)*((void *)this + 343);
  if (v565)
  {
    *((void *)this + 344) = v565;
    operator delete(v565);
  }
  double v566 = (void *)*((void *)this + 340);
  if (v566)
  {
    *((void *)this + 341) = v566;
    operator delete(v566);
  }
  double v567 = (void *)*((void *)this + 337);
  if (v567)
  {
    do
    {
      double v568 = (void *)*v567;
      operator delete(v567);
      double v567 = v568;
    }
    while (v568);
  }
  double v569 = (void *)*((void *)this + 335);
  *((void *)this + 335) = 0;
  if (v569) {
    operator delete(v569);
  }
  id v570 = (void *)*((void *)this + 332);
  if (v570)
  {
    do
    {
      v571 = (void *)*v570;
      operator delete(v570);
      id v570 = v571;
    }
    while (v571);
  }
  id v572 = (void *)*((void *)this + 330);
  *((void *)this + 330) = 0;
  if (v572) {
    operator delete(v572);
  }
  v573 = (void *)*((void *)this + 327);
  if (v573)
  {
    do
    {
      float64x2_t v574 = (void *)*v573;
      operator delete(v573);
      v573 = v574;
    }
    while (v574);
  }
  float64x2_t v575 = (void *)*((void *)this + 325);
  *((void *)this + 325) = 0;
  if (v575) {
    operator delete(v575);
  }
  float64x2_t v576 = (void *)*((void *)this + 322);
  if (v576)
  {
    do
    {
      float64x2_t v577 = (void *)*v576;
      operator delete(v576);
      float64x2_t v576 = v577;
    }
    while (v577);
  }
  float64x2_t v578 = (void *)*((void *)this + 320);
  *((void *)this + 320) = 0;
  if (v578) {
    operator delete(v578);
  }
  float64x2_t v579 = (void *)*((void *)this + 317);
  if (v579)
  {
    do
    {
      v587 = (void *)*v579;
      uint64_t v588 = v579[3];
      v579[3] = 0;
      if (v588) {
        (*(void (**)(uint64_t))(*(void *)v588 + 8))(v588);
      }
      operator delete(v579);
      float64x2_t v579 = v587;
    }
    while (v587);
  }
  float64x2_t v580 = (void *)*((void *)this + 315);
  *((void *)this + 315) = 0;
  if (v580) {
    operator delete(v580);
  }
  v581 = (void *)*((void *)this + 312);
  if (v581)
  {
    *((void *)this + 313) = v581;
    operator delete(v581);
  }
  uint64_t v582 = *((void *)this + 309);
  if (v582)
  {
    uint64_t v583 = *((void *)this + 310);
    v584 = (void *)*((void *)this + 309);
    if (v583 != v582)
    {
      do
      {
        v589 = *(std::__shared_weak_count **)(v583 - 8);
        if (v589 && !atomic_fetch_add(&v589->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v589->__on_zero_shared)(v589);
          std::__shared_weak_count::__release_weak(v589);
        }
        v583 -= 24;
      }
      while (v583 != v582);
      v584 = (void *)*((void *)this + 309);
    }
    *((void *)this + 310) = v582;
    operator delete(v584);
  }
  v590 = (void *)*((void *)this + 306);
  if (v590)
  {
    *((void *)this + 307) = v590;
    operator delete(v590);
  }
  v591 = (void *)*((void *)this + 303);
  if (v591)
  {
    *((void *)this + 304) = v591;
    operator delete(v591);
  }
  v592 = (void *)*((void *)this + 300);
  if (v592)
  {
    do
    {
      v593 = (void *)*v592;
      operator delete(v592);
      v592 = v593;
    }
    while (v593);
  }
  v594 = (void *)*((void *)this + 298);
  *((void *)this + 298) = 0;
  if (v594) {
    operator delete(v594);
  }
  v595 = (void *)*((void *)this + 295);
  if (v595)
  {
    do
    {
      v596 = (void *)*v595;
      operator delete(v595);
      v595 = v596;
    }
    while (v596);
  }
  v597 = (void *)*((void *)this + 293);
  *((void *)this + 293) = 0;
  if (v597) {
    operator delete(v597);
  }
  v598 = (void *)*((void *)this + 290);
  if (v598)
  {
    do
    {
      v599 = (void *)*v598;
      operator delete(v598);
      v598 = v599;
    }
    while (v599);
  }
  v600 = (void *)*((void *)this + 288);
  *((void *)this + 288) = 0;
  if (v600) {
    operator delete(v600);
  }
  v601 = (void *)*((void *)this + 285);
  if (v601)
  {
    do
    {
      v602 = (void *)*v601;
      operator delete(v601);
      v601 = v602;
    }
    while (v602);
  }
  v603 = (void *)*((void *)this + 283);
  *((void *)this + 283) = 0;
  if (v603) {
    operator delete(v603);
  }
  v604 = (void *)*((void *)this + 280);
  if (v604)
  {
    do
    {
      v628 = (void *)*v604;
      uint64_t v629 = v604[3];
      v604[3] = 0;
      if (v629) {
        MEMORY[0x1A6239270](v629, 0x1000C40B9F3BD1DLL);
      }
      operator delete(v604);
      v604 = v628;
    }
    while (v628);
  }
  v605 = (void *)*((void *)this + 278);
  *((void *)this + 278) = 0;
  if (v605) {
    operator delete(v605);
  }
  v606 = (void *)*((void *)this + 275);
  if (v606)
  {
    *((void *)this + 276) = v606;
    operator delete(v606);
  }
  v607 = (void *)*((void *)this + 272);
  if (v607)
  {
    *((void *)this + 273) = v607;
    operator delete(v607);
  }
  v608 = (void *)*((void *)this + 269);
  if (v608)
  {
    *((void *)this + 270) = v608;
    operator delete(v608);
  }
  v609 = (void *)*((void *)this + 266);
  if (v609)
  {
    *((void *)this + 267) = v609;
    operator delete(v609);
  }
  v610 = (void *)*((void *)this + 263);
  if (v610)
  {
    do
    {
      v611 = (void *)*v610;
      operator delete(v610);
      v610 = v611;
    }
    while (v611);
  }
  v612 = (void *)*((void *)this + 261);
  *((void *)this + 261) = 0;
  if (v612) {
    operator delete(v612);
  }
  v613 = (void *)*((void *)this + 258);
  if (v613)
  {
    do
    {
      v614 = (void *)*v613;
      operator delete(v613);
      v613 = v614;
    }
    while (v614);
  }
  v615 = (void *)*((void *)this + 256);
  *((void *)this + 256) = 0;
  if (v615) {
    operator delete(v615);
  }
  v616 = (void *)*((void *)this + 253);
  if (v616)
  {
    do
    {
      v617 = (void *)*v616;
      operator delete(v616);
      v616 = v617;
    }
    while (v617);
  }
  v618 = (void *)*((void *)this + 251);
  *((void *)this + 251) = 0;
  if (v618) {
    operator delete(v618);
  }
  v619 = (void *)*((void *)this + 248);
  if (v619)
  {
    do
    {
      v620 = (void *)*v619;
      operator delete(v619);
      v619 = v620;
    }
    while (v620);
  }
  v621 = (void *)*((void *)this + 246);
  *((void *)this + 246) = 0;
  if (v621) {
    operator delete(v621);
  }
  v622 = (void *)*((void *)this + 243);
  if (v622)
  {
    do
    {
      v630 = (void *)*v622;
      uint64_t v631 = v622[3];
      v622[3] = 0;
      if (v631) {
        (*(void (**)(uint64_t))(*(void *)v631 + 8))(v631);
      }
      operator delete(v622);
      v622 = v630;
    }
    while (v630);
  }
  v623 = (void *)*((void *)this + 241);
  *((void *)this + 241) = 0;
  if (v623) {
    operator delete(v623);
  }
  v624 = (void *)*((void *)this + 238);
  if (v624)
  {
    *((void *)this + 239) = v624;
    operator delete(v624);
  }
  uint64_t v625 = *((void *)this + 235);
  if (v625)
  {
    uint64_t v626 = *((void *)this + 236);
    v627 = (void *)*((void *)this + 235);
    if (v626 != v625)
    {
      do
      {
        v632 = *(std::__shared_weak_count **)(v626 - 8);
        if (v632 && !atomic_fetch_add(&v632->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v632->__on_zero_shared)(v632);
          std::__shared_weak_count::__release_weak(v632);
        }
        v626 -= 24;
      }
      while (v626 != v625);
      v627 = (void *)*((void *)this + 235);
    }
    *((void *)this + 236) = v625;
    operator delete(v627);
  }
  v633 = (void *)*((void *)this + 232);
  if (v633)
  {
    *((void *)this + 233) = v633;
    operator delete(v633);
  }
  v634 = (void *)*((void *)this + 229);
  if (v634)
  {
    *((void *)this + 230) = v634;
    operator delete(v634);
  }
  v635 = (void *)*((void *)this + 226);
  if (v635)
  {
    do
    {
      v636 = (void *)*v635;
      operator delete(v635);
      v635 = v636;
    }
    while (v636);
  }
  v637 = (void *)*((void *)this + 224);
  *((void *)this + 224) = 0;
  if (v637) {
    operator delete(v637);
  }
  v638 = (void *)*((void *)this + 221);
  if (v638)
  {
    do
    {
      v639 = (void *)*v638;
      operator delete(v638);
      v638 = v639;
    }
    while (v639);
  }
  v640 = (void *)*((void *)this + 219);
  *((void *)this + 219) = 0;
  if (v640) {
    operator delete(v640);
  }
  v641 = (void *)*((void *)this + 216);
  if (v641)
  {
    do
    {
      v642 = (void *)*v641;
      operator delete(v641);
      v641 = v642;
    }
    while (v642);
  }
  v643 = (void *)*((void *)this + 214);
  *((void *)this + 214) = 0;
  if (v643) {
    operator delete(v643);
  }
  v644 = (void *)*((void *)this + 211);
  if (v644)
  {
    do
    {
      v645 = (void *)*v644;
      operator delete(v644);
      v644 = v645;
    }
    while (v645);
  }
  v646 = (void *)*((void *)this + 209);
  *((void *)this + 209) = 0;
  if (v646) {
    operator delete(v646);
  }
  v647 = (void *)*((void *)this + 206);
  if (v647)
  {
    do
    {
      v671 = (void *)*v647;
      uint64_t v672 = v647[3];
      v647[3] = 0;
      if (v672) {
        MEMORY[0x1A6239270](v672, 0x1000C40B4868423);
      }
      operator delete(v647);
      v647 = v671;
    }
    while (v671);
  }
  v648 = (void *)*((void *)this + 204);
  *((void *)this + 204) = 0;
  if (v648) {
    operator delete(v648);
  }
  v649 = (void *)*((void *)this + 201);
  if (v649)
  {
    *((void *)this + 202) = v649;
    operator delete(v649);
  }
  v650 = (void *)*((void *)this + 198);
  if (v650)
  {
    *((void *)this + 199) = v650;
    operator delete(v650);
  }
  v651 = (void *)*((void *)this + 195);
  if (v651)
  {
    *((void *)this + 196) = v651;
    operator delete(v651);
  }
  v652 = (void *)*((void *)this + 192);
  if (v652)
  {
    *((void *)this + 193) = v652;
    operator delete(v652);
  }
  v653 = (void *)*((void *)this + 189);
  if (v653)
  {
    do
    {
      v654 = (void *)*v653;
      operator delete(v653);
      v653 = v654;
    }
    while (v654);
  }
  v655 = (void *)*((void *)this + 187);
  *((void *)this + 187) = 0;
  if (v655) {
    operator delete(v655);
  }
  v656 = (void *)*((void *)this + 184);
  if (v656)
  {
    do
    {
      v657 = (void *)*v656;
      operator delete(v656);
      v656 = v657;
    }
    while (v657);
  }
  v658 = (void *)*((void *)this + 182);
  *((void *)this + 182) = 0;
  if (v658) {
    operator delete(v658);
  }
  v659 = (void *)*((void *)this + 179);
  if (v659)
  {
    do
    {
      v660 = (void *)*v659;
      operator delete(v659);
      v659 = v660;
    }
    while (v660);
  }
  v661 = (void *)*((void *)this + 177);
  *((void *)this + 177) = 0;
  if (v661) {
    operator delete(v661);
  }
  v662 = (void *)*((void *)this + 174);
  if (v662)
  {
    do
    {
      v663 = (void *)*v662;
      operator delete(v662);
      v662 = v663;
    }
    while (v663);
  }
  v664 = (void *)*((void *)this + 172);
  *((void *)this + 172) = 0;
  if (v664) {
    operator delete(v664);
  }
  v665 = (void *)*((void *)this + 169);
  if (v665)
  {
    do
    {
      v673 = (void *)*v665;
      uint64_t v674 = v665[3];
      v665[3] = 0;
      if (v674) {
        (*(void (**)(uint64_t))(*(void *)v674 + 8))(v674);
      }
      operator delete(v665);
      v665 = v673;
    }
    while (v673);
  }
  v666 = (void *)*((void *)this + 167);
  *((void *)this + 167) = 0;
  if (v666) {
    operator delete(v666);
  }
  v667 = (void *)*((void *)this + 164);
  if (v667)
  {
    *((void *)this + 165) = v667;
    operator delete(v667);
  }
  uint64_t v668 = *((void *)this + 161);
  if (v668)
  {
    uint64_t v669 = *((void *)this + 162);
    v670 = (void *)*((void *)this + 161);
    if (v669 != v668)
    {
      do
      {
        v675 = *(std::__shared_weak_count **)(v669 - 8);
        if (v675 && !atomic_fetch_add(&v675->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v675->__on_zero_shared)(v675);
          std::__shared_weak_count::__release_weak(v675);
        }
        v669 -= 24;
      }
      while (v669 != v668);
      v670 = (void *)*((void *)this + 161);
    }
    *((void *)this + 162) = v668;
    operator delete(v670);
  }
  v676 = (void *)*((void *)this + 158);
  if (v676)
  {
    *((void *)this + 159) = v676;
    operator delete(v676);
  }
  v677 = (void *)*((void *)this + 155);
  if (v677)
  {
    *((void *)this + 156) = v677;
    operator delete(v677);
  }
  v678 = (void *)*((void *)this + 152);
  if (v678)
  {
    do
    {
      v679 = (void *)*v678;
      operator delete(v678);
      v678 = v679;
    }
    while (v679);
  }
  v680 = (void *)*((void *)this + 150);
  *((void *)this + 150) = 0;
  if (v680) {
    operator delete(v680);
  }
  v681 = (void *)*((void *)this + 147);
  if (v681)
  {
    do
    {
      v682 = (void *)*v681;
      operator delete(v681);
      v681 = v682;
    }
    while (v682);
  }
  v683 = (void *)*((void *)this + 145);
  *((void *)this + 145) = 0;
  if (v683) {
    operator delete(v683);
  }
  v684 = (void *)*((void *)this + 142);
  if (v684)
  {
    do
    {
      v685 = (void *)*v684;
      operator delete(v684);
      v684 = v685;
    }
    while (v685);
  }
  v686 = (void *)*((void *)this + 140);
  *((void *)this + 140) = 0;
  if (v686) {
    operator delete(v686);
  }
  v687 = (void *)*((void *)this + 137);
  if (v687)
  {
    do
    {
      v688 = (void *)*v687;
      operator delete(v687);
      v687 = v688;
    }
    while (v688);
  }
  v689 = (void *)*((void *)this + 135);
  *((void *)this + 135) = 0;
  if (v689) {
    operator delete(v689);
  }
  v690 = (void *)*((void *)this + 132);
  if (v690)
  {
    do
    {
      v718 = (void *)*v690;
      uint64_t v719 = v690[3];
      v690[3] = 0;
      if (v719) {
        MEMORY[0x1A6239270](v719, 0x10A0C4046FC076FLL);
      }
      operator delete(v690);
      v690 = v718;
    }
    while (v718);
  }
  v691 = (void *)*((void *)this + 130);
  *((void *)this + 130) = 0;
  if (v691) {
    operator delete(v691);
  }
  v692 = (void *)*((void *)this + 127);
  if (v692)
  {
    *((void *)this + 128) = v692;
    operator delete(v692);
  }
  v693 = (void *)*((void *)this + 124);
  if (v693)
  {
    *((void *)this + 125) = v693;
    operator delete(v693);
  }
  v694 = (void *)*((void *)this + 121);
  if (v694)
  {
    *((void *)this + 122) = v694;
    operator delete(v694);
  }
  v695 = (void *)*((void *)this + 118);
  if (v695)
  {
    *((void *)this + 119) = v695;
    operator delete(v695);
  }
  v696 = (void *)*((void *)this + 115);
  if (v696)
  {
    do
    {
      v697 = (void *)*v696;
      operator delete(v696);
      v696 = v697;
    }
    while (v697);
  }
  v698 = (void *)*((void *)this + 113);
  *((void *)this + 113) = 0;
  if (v698) {
    operator delete(v698);
  }
  v699 = (void *)*((void *)this + 110);
  if (v699)
  {
    do
    {
      v700 = (void *)*v699;
      operator delete(v699);
      v699 = v700;
    }
    while (v700);
  }
  v701 = (void *)*((void *)this + 108);
  *((void *)this + 108) = 0;
  if (v701) {
    operator delete(v701);
  }
  v702 = (void *)*((void *)this + 105);
  if (v702)
  {
    do
    {
      v720 = (void *)*v702;
      v721 = (void *)v702[5];
      if (v721)
      {
        do
        {
          v722 = (void *)*v721;
          operator delete(v721);
          v721 = v722;
        }
        while (v722);
      }
      v723 = (void *)v702[3];
      v702[3] = 0;
      if (v723) {
        operator delete(v723);
      }
      operator delete(v702);
      v702 = v720;
    }
    while (v720);
  }
  v703 = (void *)*((void *)this + 103);
  *((void *)this + 103) = 0;
  if (v703) {
    operator delete(v703);
  }
  v704 = (void *)*((void *)this + 100);
  if (v704)
  {
    *((void *)this + 101) = v704;
    operator delete(v704);
  }
  v705 = (void *)*((void *)this + 97);
  if (v705)
  {
    *((void *)this + 98) = v705;
    operator delete(v705);
  }
  v706 = (void *)*((void *)this + 94);
  if (v706)
  {
    *((void *)this + 95) = v706;
    operator delete(v706);
  }
  v707 = (void *)*((void *)this + 91);
  if (v707)
  {
    *((void *)this + 92) = v707;
    operator delete(v707);
  }
  v708 = (void *)*((void *)this + 88);
  if (v708)
  {
    do
    {
      v709 = (void *)*v708;
      operator delete(v708);
      v708 = v709;
    }
    while (v709);
  }
  v710 = (void *)*((void *)this + 86);
  *((void *)this + 86) = 0;
  if (v710) {
    operator delete(v710);
  }
  v711 = (void *)*((void *)this + 83);
  if (v711)
  {
    do
    {
      v712 = (void *)*v711;
      operator delete(v711);
      v711 = v712;
    }
    while (v712);
  }
  v713 = (void *)*((void *)this + 81);
  *((void *)this + 81) = 0;
  if (v713) {
    operator delete(v713);
  }
  v714 = (void *)*((void *)this + 78);
  if (v714)
  {
    *((void *)this + 79) = v714;
    operator delete(v714);
  }
  uint64_t v715 = *((void *)this + 75);
  if (v715)
  {
    uint64_t v716 = *((void *)this + 76);
    v717 = (void *)*((void *)this + 75);
    if (v716 != v715)
    {
      do
      {
        v724 = *(std::__shared_weak_count **)(v716 - 8);
        if (v724 && !atomic_fetch_add(&v724->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v724->__on_zero_shared)(v724);
          std::__shared_weak_count::__release_weak(v724);
        }
        v716 -= 16;
      }
      while (v716 != v715);
      v717 = (void *)*((void *)this + 75);
    }
    *((void *)this + 76) = v715;
    operator delete(v717);
  }
  v725 = (void *)*((void *)this + 72);
  if (v725)
  {
    *((void *)this + 73) = v725;
    operator delete(v725);
  }
  v726 = (void *)*((void *)this + 69);
  if (v726)
  {
    *((void *)this + 70) = v726;
    operator delete(v726);
  }
  v727 = (void *)*((void *)this + 66);
  if (v727)
  {
    do
    {
      v728 = (void *)*v727;
      operator delete(v727);
      v727 = v728;
    }
    while (v728);
  }
  v729 = (void *)*((void *)this + 64);
  *((void *)this + 64) = 0;
  if (v729) {
    operator delete(v729);
  }
  v730 = (void *)*((void *)this + 61);
  if (v730)
  {
    do
    {
      v731 = (void *)*v730;
      operator delete(v730);
      v730 = v731;
    }
    while (v731);
  }
  v732 = (void *)*((void *)this + 59);
  *((void *)this + 59) = 0;
  if (v732) {
    operator delete(v732);
  }
  v733 = (void *)*((void *)this + 56);
  if (v733)
  {
    *((void *)this + 57) = v733;
    operator delete(v733);
  }
  v734 = (void *)*((void *)this + 53);
  if (v734)
  {
    *((void *)this + 54) = v734;
    operator delete(v734);
  }
  v735 = (void *)*((void *)this + 50);
  if (v735)
  {
    *((void *)this + 51) = v735;
    operator delete(v735);
  }
  v736 = (void *)*((void *)this + 47);
  if (v736)
  {
    *((void *)this + 48) = v736;
    operator delete(v736);
  }
  v737 = (void *)*((void *)this + 44);
  if (v737)
  {
    do
    {
      v738 = (void *)*v737;
      operator delete(v737);
      v737 = v738;
    }
    while (v738);
  }
  v739 = (void *)*((void *)this + 42);
  *((void *)this + 42) = 0;
  if (v739) {
    operator delete(v739);
  }
  v740 = (void *)*((void *)this + 39);
  if (v740)
  {
    do
    {
      v741 = (void *)*v740;
      operator delete(v740);
      v740 = v741;
    }
    while (v741);
  }
  v742 = (void *)*((void *)this + 37);
  *((void *)this + 37) = 0;
  if (v742) {
    operator delete(v742);
  }
  v784 = 0;
  uint64_t v785 = 0;
  v783 = &v784;
  v743 = (void *)*((void *)this + 36);
  if (v743)
  {
    uint64_t v744 = 0;
    do
    {
      v745 = &v784;
      v746 = &v784;
      if (v784)
      {
        v747 = v784;
        while (1)
        {
          while (1)
          {
            v746 = (uint64_t **)v747;
            unint64_t v748 = v747[4];
            if ((unint64_t)v743 >= v748) {
              break;
            }
            v747 = *v746;
            v745 = v746;
            if (!*v746) {
              goto LABEL_1226;
            }
          }
          if (v748 >= (unint64_t)v743) {
            break;
          }
          v747 = v746[1];
          if (!v747)
          {
            v745 = v746 + 1;
            goto LABEL_1226;
          }
        }
      }
      else
      {
LABEL_1226:
        v749 = (uint64_t *)operator new(0x28uLL);
        v749[4] = (uint64_t)v743;
        uint64_t *v749 = 0;
        v749[1] = 0;
        v749[2] = (uint64_t)v746;
        *v745 = v749;
        if (*v783)
        {
          v783 = (uint64_t **)*v783;
          v749 = *v745;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v784, v749);
        uint64_t v744 = ++v785;
        v743 = (void *)*((void *)this + 36);
      }
      v743 = (void *)*v743;
      *((void *)this + 36) = v743;
    }
    while (v743);
  }
  else
  {
    uint64_t v744 = 0;
  }
  unint64_t v750 = *((void *)this + 34);
  v751 = (char *)*((void *)this + 31);
  v752 = (char *)this + 256;
  BOOL v753 = v744 == *((void *)this + 33) * v750 || v751 == v752;
  if (v753 || v750 == 0)
  {
    if (v751 == v752) {
      goto LABEL_1261;
    }
    goto LABEL_1280;
  }
  uint64_t v755 = 1;
  do
  {
    if (v755)
    {
      unint64_t v756 = 0;
      uint64_t v757 = *((void *)v751 + 4);
      do
      {
        v758 = (void (***)(void))(v757 + 120 * v756);
        v759 = v784;
        if (!v784) {
          goto LABEL_1242;
        }
        v760 = &v784;
        do
        {
          v761 = v759;
          v762 = v760;
          unint64_t v763 = v759[4];
          v764 = (uint64_t **)(v759 + 1);
          if (v763 >= (unint64_t)v758)
          {
            v764 = (uint64_t **)v761;
            v760 = (uint64_t **)v761;
          }
          v759 = *v764;
        }
        while (v759);
        if (v760 == &v784) {
          goto LABEL_1242;
        }
        if (v763 < (unint64_t)v758) {
          v761 = (uint64_t *)v762;
        }
        if ((unint64_t)v758 < v761[4])
        {
LABEL_1242:
          (**v758)(v758);
          unint64_t v750 = *((void *)this + 34);
        }
        ++v756;
        uint64_t v755 = v750;
      }
      while (v756 < v750);
    }
    v765 = (char *)*((void *)v751 + 1);
    if (v765)
    {
      do
      {
        v766 = v765;
        v765 = *(char **)v765;
      }
      while (v765);
    }
    else
    {
      do
      {
        v766 = (char *)*((void *)v751 + 2);
        BOOL v753 = *(void *)v766 == (void)v751;
        v751 = v766;
      }
      while (!v753);
    }
    v751 = v766;
  }
  while (v766 != v752);
  v751 = (char *)*((void *)this + 31);
  if (v751 != v752)
  {
    do
    {
LABEL_1280:
      free(*((void **)v751 + 4));
      v779 = (char *)*((void *)v751 + 1);
      if (v779)
      {
        do
        {
          v780 = v779;
          v779 = *(char **)v779;
        }
        while (v779);
      }
      else
      {
        do
        {
          v780 = (char *)*((void *)v751 + 2);
          BOOL v753 = *(void *)v780 == (void)v751;
          v751 = v780;
        }
        while (!v753);
      }
      v751 = v780;
    }
    while (v780 != v752);
  }
LABEL_1261:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 32));
  *((void *)this + 32) = 0;
  *((void *)this + 33) = 0;
  *((void *)this + 31) = v752;
  *((void *)this + 36) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v784);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 32));
  v767 = (void *)*((void *)this + 28);
  if (v767)
  {
    do
    {
      v781 = (void *)*v767;
      v782 = (void *)v767[3];
      if (v782)
      {
        v767[4] = v782;
        operator delete(v782);
      }
      operator delete(v767);
      v767 = v781;
    }
    while (v781);
  }
  v768 = (void *)*((void *)this + 26);
  *((void *)this + 26) = 0;
  if (v768) {
    operator delete(v768);
  }
  v769 = (void *)*((void *)this + 23);
  if (v769)
  {
    *((void *)this + 24) = v769;
    operator delete(v769);
  }
  v770 = (void *)*((void *)this + 20);
  if (v770)
  {
    do
    {
      v771 = (void *)*v770;
      operator delete(v770);
      v770 = v771;
    }
    while (v771);
  }
  v772 = (void *)*((void *)this + 18);
  *((void *)this + 18) = 0;
  if (v772) {
    operator delete(v772);
  }
  v773 = (void *)*((void *)this + 15);
  if (v773)
  {
    do
    {
      v774 = (void *)*v773;
      operator delete(v773);
      v773 = v774;
    }
    while (v774);
  }
  v775 = (void *)*((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v775) {
    operator delete(v775);
  }
  v776 = (void *)*((void *)this + 10);
  if (v776)
  {
    do
    {
      v777 = (void *)*v776;
      operator delete(v776);
      v776 = v777;
    }
    while (v777);
  }
  v778 = (void *)*((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v778) {
    operator delete(v778);
  }
}

void sub_1A239770C(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v2);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 256));
  _Unwind_Resume(a1);
}

void std::default_delete<md::MapEngineSettings>::operator()[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 72);
  while (v2)
  {
    uint64_t v5 = v2;
    uint64_t v2 = (void *)*v2;
    uint64_t v6 = (void *)v5[6];
    if (v6 == v5 + 3)
    {
      (*(void (**)(void *))(v5[3] + 32))(v5 + 3);
    }
    else if (v6)
    {
      (*(void (**)(void *))(*v6 + 40))(v6);
    }
    operator delete(v5);
  }
  uint64_t v3 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v3) {
    operator delete(v3);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 32));
  BOOL v4 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
  }
  JUMPOUT(0x1A6239270);
}

md::VKMRenderResourcesStore **std::unique_ptr<md::VKMRenderResourcesStore>::~unique_ptr[abi:nn180100](md::VKMRenderResourcesStore **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::VKMRenderResourcesStore::~VKMRenderResourcesStore(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

uint64_t *std::unique_ptr<md::ConfigSettingProvider>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40A25DD1A6);
  }
  return a1;
}

uint64_t ___ZN2md9MapEngineC2Efffb16VKMapViewPurposeRKNSt3__110shared_ptrINS_11TaskContextEEE12VKMapPurposeNS2_10unique_ptrINS_16AnimationManagerENS2_14default_deleteISA_EEEERKN3geo10linear_mapINS_16MapEngineSettingExNS2_8equal_toISG_EENS2_9allocatorINS2_4pairISG_xEEEENS2_6vectorISL_SM_EEEEyP24GEOApplicationAuditToken_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = GEOConfigGetUInteger();
  *(void *)(v1 + 1288) = result;
  return result;
}

uint64_t ___ZN2md9MapEngineC2Efffb16VKMapViewPurposeRKNSt3__110shared_ptrINS_11TaskContextEEE12VKMapPurposeNS2_10unique_ptrINS_16AnimationManagerENS2_14default_deleteISA_EEEERKN3geo10linear_mapINS_16MapEngineSettingExNS2_8equal_toISG_EENS2_9allocatorINS2_4pairISG_xEEEENS2_6vectorISL_SM_EEEEyP24GEOApplicationAuditToken_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = GEOConfigGetUInteger();
  *(void *)(v1 + 1296) = result;
  return result;
}

uint64_t ___ZN2md9MapEngineC2Efffb16VKMapViewPurposeRKNSt3__110shared_ptrINS_11TaskContextEEE12VKMapPurposeNS2_10unique_ptrINS_16AnimationManagerENS2_14default_deleteISA_EEEERKN3geo10linear_mapINS_16MapEngineSettingExNS2_8equal_toISG_EENS2_9allocatorINS2_4pairISG_xEEEENS2_6vectorISL_SM_EEEEyP24GEOApplicationAuditToken_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = GEOConfigGetUInteger();
  *(void *)(v1 + 1304) = result;
  return result;
}

uint64_t ___ZN2md9MapEngineC2Efffb16VKMapViewPurposeRKNSt3__110shared_ptrINS_11TaskContextEEE12VKMapPurposeNS2_10unique_ptrINS_16AnimationManagerENS2_14default_deleteISA_EEEERKN3geo10linear_mapINS_16MapEngineSettingExNS2_8equal_toISG_EENS2_9allocatorINS2_4pairISG_xEEEENS2_6vectorISL_SM_EEEEyP24GEOApplicationAuditToken_block_invoke_4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = GEOConfigGetDouble();
  *(void *)(v1 + 1312) = v3;
  return result;
}

uint64_t ___ZN2md9MapEngineC2Efffb16VKMapViewPurposeRKNSt3__110shared_ptrINS_11TaskContextEEE12VKMapPurposeNS2_10unique_ptrINS_16AnimationManagerENS2_14default_deleteISA_EEEERKN3geo10linear_mapINS_16MapEngineSettingExNS2_8equal_toISG_EENS2_9allocatorINS2_4pairISG_xEEEENS2_6vectorISL_SM_EEEEyP24GEOApplicationAuditToken_block_invoke_5(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = GEOConfigGetBOOL();
  *(unsigned char *)(v1 + 1320) = result;
  return result;
}

void *std::function<void ()(md::LabelManager *,md::NeedsLayoutReason)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(md::LabelManager *,std::shared_ptr<md::LabelMarker> const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(md::Venue const*,md::VenueBuilding const*)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(md::Venue const*)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(VKAnimation *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(long long)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(NSError *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(gdc::SceneStatus)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(int)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t md::Monitorable<md::ConfigValue<GEOConfigKeyInteger,int>>::~Monitorable(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    GEOConfigRemoveBlockListener();
    uint64_t v2 = *(void **)(a1 + 24);
    *(void *)(a1 + 24) = 0;
  }
  atomic_store(0, *(unsigned __int8 **)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 72);
  if (v3 == a1 + 48)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 48) + 32))(a1 + 48);
    BOOL v4 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v4) {
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4)
  {
LABEL_9:
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
LABEL_11:

  return a1;
}

void sub_1A2397F68(_Unwind_Exception *a1)
{
  std::function<void ()(int)>::~function((void *)(v1 + 48));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 32);

  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<md::HomeQueueScheduler>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    std::condition_variable::~condition_variable((std::condition_variable *)(v2 + 240));
    std::mutex::~mutex((std::mutex *)(v2 + 176));

    std::deque<std::function<void ()(void)>>::~deque[abi:nn180100](v2 + 120);
    std::condition_variable::~condition_variable((std::condition_variable *)(v2 + 72));
    std::mutex::~mutex((std::mutex *)(v2 + 8));
    MEMORY[0x1A6239270](v2, 0x10A0C40BCFC4640);
  }
  return a1;
}

uint64_t *std::unique_ptr<md::DaVinciTransitionManager>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(v2 + 200);
    md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v2 + 120);
    MEMORY[0x1A6239270](v2, 0x10A0C4071554381);
  }
  return a1;
}

md::LayoutContext **std::unique_ptr<md::LayoutContext>::~unique_ptr[abi:nn180100](md::LayoutContext **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::LayoutContext::~LayoutContext(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

uint64_t *std::unique_ptr<md::ARContext>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {

    MEMORY[0x1A6239270](v2, 0x1080C4006152ACDLL);
  }
  return a1;
}

uint64_t *std::unique_ptr<gdc::Context>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v6 = (void *)*v3;
        uint64_t v7 = v3[5];
        v3[5] = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        }
        operator delete(v3);
        uint64_t v3 = v6;
      }
      while (v6);
    }
    BOOL v4 = *(void **)v2;
    *(void *)uint64_t v2 = 0;
    if (v4) {
      operator delete(v4);
    }
    MEMORY[0x1A6239270](v2, 0x10A0C408EF24B1CLL);
  }
  return a1;
}

uint64_t *std::unique_ptr<md::MapDataAccess>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 24);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    MEMORY[0x1A6239270](v2, 0x1020C408EAB821DLL);
  }
  return a1;
}

md::World **std::unique_ptr<md::World>::~unique_ptr[abi:nn180100](md::World **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::World::~World(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void *___ZN2md11MonitorableINS_11ConfigValueI19GEOConfigKeyIntegeriEEE16setCallbackQueueEPU28objcproto17OS_dispatch_queue8NSObjectNSt3__18functionIFviEEE_block_invoke(void *result)
{
  uint64_t v1 = (unsigned char *)result[5];
  if (v1)
  {
    uint64_t v2 = result[4];
    if (*v1)
    {
      int v3 = *(_DWORD *)(v2 + 16);
      if (*(void *)v2) {
        BOOL v4 = *(void *)(v2 + 8) == 0;
      }
      else {
        BOOL v4 = 1;
      }
      if (!v4) {
        *(_DWORD *)(v2 + 16) = GEOConfigGetInteger();
      }
      uint64_t result = *(void **)(v2 + 72);
      if (result)
      {
        int v5 = v3;
        return (void *)(*(uint64_t (**)(void *, int *))(*result + 48))(result, &v5);
      }
    }
  }
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_34,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_34>,void ()(BOOL)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(*(void *)(a1 + 8) + 4688);
  id v2 = +[VKDebugSettings sharedSettings];
  [v2 setLayoutContinuously:v1];
}

void sub_1A239836C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_34,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_34>,void ()(BOOL)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5211E8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_34,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_34>,void ()(BOOL)>::~__func()
{
}

uint64_t std::__function::__func<md::MapEngine::updateLogicsFrequency(unsigned long,md::LayoutContext const&,std::optional<unsigned long>)::$_0,std::allocator<md::MapEngine::updateLogicsFrequency(unsigned long,md::LayoutContext const&,std::optional<unsigned long>)::$_0>,void ()(md::LogicBase *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF590700;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MapEngine::updateLogicsFrequency(unsigned long,md::LayoutContext const&,std::optional<unsigned long>)::$_0,std::allocator<md::MapEngine::updateLogicsFrequency(unsigned long,md::LayoutContext const&,std::optional<unsigned long>)::$_0>,void ()(md::LogicBase *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF590700;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::updateLogicsFrequency(unsigned long,md::LayoutContext const&,std::optional<unsigned long>)::$_0,std::allocator<md::MapEngine::updateLogicsFrequency(unsigned long,md::LayoutContext const&,std::optional<unsigned long>)::$_0>,void ()(md::LogicBase *)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_33,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_33>,void ()(BOOL)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(v1 + 1128);
  uint64_t v3 = (void *)*(unsigned __int8 *)(v1 + 4608);
  char v4 = 37;
  md::MapEngineSettings::set(v2, &v4, v3);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_33,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_33>,void ()(BOOL)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5211A0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_33,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_33>,void ()(BOOL)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_32,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_32>,void ()(void)>::operator()(uint64_t a1)
{
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_32,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_32>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521158;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_32,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_32>,void ()(void)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_31,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_31>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579E30;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_31,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_31>,void ()(void)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_30,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_30>,void ()(gdc::SceneStatus)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521110;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_30,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_30>,void ()(gdc::SceneStatus)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_29,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_29>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5210C8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_29,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_29>,void ()(void)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_28,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_28>,void ()(NSError *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521080;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_28,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_28>,void ()(NSError *)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_27,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_27>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF521038;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_27,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_27>,void ()(void)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_26,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_26>,void ()(long long)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF520FF0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_26,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_26>,void ()(long long)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::clearScene(void)::$_0,std::allocator<md::MapEngine::clearScene(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579530;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::clearScene(void)::$_0,std::allocator<md::MapEngine::clearScene(void)::$_0>,void ()(void)>::~__func()
{
}

uint64_t md::MapEngine::createFlyoverRenderer(uint64_t this)
{
  if (!*(void *)(this + 864) && !*(unsigned char *)(this + 1241)) {
    operator new();
  }
  return this;
}

void sub_1A23989FC(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10A1C405D6FF93FLL);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::MapEngine::updateForConfigurationAndMode(double)::$_1,std::allocator<md::MapEngine::updateForConfigurationAndMode(double)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF520E40;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MapEngine::updateForConfigurationAndMode(double)::$_1,std::allocator<md::MapEngine::updateForConfigurationAndMode(double)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF520E40;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::updateForConfigurationAndMode(double)::$_1,std::allocator<md::MapEngine::updateForConfigurationAndMode(double)::$_1>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::MapEngine::updateForConfigurationAndMode(double)::$_0,std::allocator<md::MapEngine::updateForConfigurationAndMode(double)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(v1 + 1216);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)int v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "ApplyConfiguration", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::MapEngine::updateForConfigurationAndMode(double)::$_0,std::allocator<md::MapEngine::updateForConfigurationAndMode(double)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF520DF8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MapEngine::updateForConfigurationAndMode(double)::$_0,std::allocator<md::MapEngine::updateForConfigurationAndMode(double)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF520DF8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::updateForConfigurationAndMode(double)::$_0,std::allocator<md::MapEngine::updateForConfigurationAndMode(double)::$_0>,void ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_pointer<LayoutContextProviderWrapper *,std::shared_ptr<LayoutContextProviderWrapper>::__shared_ptr_default_delete<LayoutContextProviderWrapper,LayoutContextProviderWrapper>,std::allocator<LayoutContextProviderWrapper>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

void std::__shared_ptr_pointer<LayoutContextProviderWrapper *,std::shared_ptr<LayoutContextProviderWrapper>::__shared_ptr_default_delete<LayoutContextProviderWrapper,LayoutContextProviderWrapper>,std::allocator<LayoutContextProviderWrapper>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void LayoutContextProviderWrapper::~LayoutContextProviderWrapper(LayoutContextProviderWrapper *this)
{
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::TypeInfo,std::unique_ptr<md::LogicBase>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::TypeInfo,std::unique_ptr<md::LogicBase>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = v2[5];
      v2[5] = 0;
      if (v3) {
        (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_24,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_24>,void ()(VKMuninAvailability)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579DE8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_24,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_24>,void ()(VKMuninAvailability)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_23,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_23>,void ()(geo::Unit<geo::DegreeUnitDescription,double>)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579DA0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_23,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_23>,void ()(geo::Unit<geo::DegreeUnitDescription,double>)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_22,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_22>,void ()(geo::Mercator2<double>,BOOL)>::operator()(uint64_t a1, double *a2, unsigned __int8 *a3)
{
  double v3 = *a2;
  double v4 = a2[1];
  int v5 = *a3;
  uint64_t v6 = (id *)(*(void *)(a1 + 8) + 848);
  id WeakRetained = objc_loadWeakRetained(v6);
  char v7 = objc_opt_respondsToSelector();

  if (v7)
  {
    long double v8 = exp(v4 * 6.28318531 + -3.14159265);
    double v9 = atan(v8);
    long double v10 = fmod(v3 * 6.28318531, 6.28318531);
    long double v11 = fmod(v10 + 6.28318531, 6.28318531) * 57.2957795 + -180.0;
    id v13 = objc_loadWeakRetained(v6);
    objc_msgSend(v13, "location:isInHikingContextualRegion:", v5 != 0, v9 * 114.591559 + -90.0, (double)v11);
  }
}

void sub_1A2398ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_22,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_22>,void ()(geo::Mercator2<double>,BOOL)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF520FA8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_22,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_22>,void ()(geo::Mercator2<double>,BOOL)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_21,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_21>,void ()(unsigned long long)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = (id *)(*(void *)(a1 + 8) + 848);
  id WeakRetained = objc_loadWeakRetained(v3);
  char v4 = objc_opt_respondsToSelector();

  if (v4)
  {
    id v6 = objc_loadWeakRetained(v3);
    [v6 locationInHikingToolTipRegion:v2];
  }
}

void sub_1A2398FF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_21,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_21>,void ()(unsigned long long)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579D58;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_21,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_21>,void ()(unsigned long long)>::~__func()
{
}

void md::Logic<md::HillshadeLogic,md::HillshadeContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    int v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      int v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

uint64_t md::Logic<md::HillshadeLogic,md::HillshadeContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::HillshadeLogic,md::HillshadeContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0xE719E07499A88BEBLL && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    v8[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::GeometryContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    v8[1] = v7;
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v8, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::GeometryContext>(uint64_t a1, unint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x1AF456233693CD46;
    if (a2 <= 0x1AF456233693CD46) {
      uint64_t v3 = 0x1AF456233693CD46 % a2;
    }
  }
  else
  {
    uint64_t v3 = (a2 - 1) & 0x1AF456233693CD46;
  }
  int v5 = *(void **)(a1 + 8 * v3);
  if (!v5) {
    goto LABEL_25;
  }
  uint64_t v6 = (void *)*v5;
  if (!v6) {
    goto LABEL_25;
  }
  if (v2.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v8 = v6[1];
      if (v8 == 0x1AF456233693CD46)
      {
        if (v6[2] == 0x1AF456233693CD46) {
          goto LABEL_23;
        }
      }
      else if ((v8 & (a2 - 1)) != v3)
      {
        goto LABEL_25;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v6[1];
    if (v7 == 0x1AF456233693CD46) {
      break;
    }
    if (v7 >= a2) {
      v7 %= a2;
    }
    if (v7 != v3) {
      goto LABEL_25;
    }
LABEL_12:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_25;
    }
  }
  if (v6[2] != 0x1AF456233693CD46) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v9 = v6[5];
  if (*(void *)(v9 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v10 = *(void *)(v9 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v10 = 0;
LABEL_26:
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v11 = 0x3070CB6B3C7F21D3;
    if (a2 <= 0x3070CB6B3C7F21D3) {
      uint64_t v11 = 0x3070CB6B3C7F21D3 % a2;
    }
  }
  else
  {
    uint64_t v11 = (a2 - 1) & 0x3070CB6B3C7F21D3;
  }
  uint64_t v12 = *(void **)(a1 + 8 * v11);
  if (!v12) {
    return v10;
  }
  uint64_t v13 = (void *)*v12;
  if (!v13) {
    return v10;
  }
  if (v2.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v15 = v13[1];
      if (v15 == 0x3070CB6B3C7F21D3)
      {
        if (v13[2] == 0x3070CB6B3C7F21D3) {
          goto LABEL_46;
        }
      }
      else if ((v15 & (a2 - 1)) != v11)
      {
        return v10;
      }
      uint64_t v13 = (void *)*v13;
      if (!v13) {
        return v10;
      }
    }
  }
  while (2)
  {
    unint64_t v14 = v13[1];
    if (v14 != 0x3070CB6B3C7F21D3)
    {
      if (v14 >= a2) {
        v14 %= a2;
      }
      if (v14 != v11) {
        return v10;
      }
      goto LABEL_35;
    }
    if (v13[2] != 0x3070CB6B3C7F21D3)
    {
LABEL_35:
      uint64_t v13 = (void *)*v13;
      if (!v13) {
        return v10;
      }
      continue;
    }
    break;
  }
LABEL_46:
  if (*(void *)(v13[5] + 8) == 0x3070CB6B3C7F21D3) {
    return v10;
  }
  return v10;
}

uint64_t md::Logic<md::HillshadeLogic,md::HillshadeContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0xE719E07499A88BEBLL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::GeometryContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 152))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::HillshadeLogic,md::HillshadeContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0xE719E07499A88BEBLL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::GeometryContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 144))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::HillshadeLogic,md::HillshadeContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0xE719E07499A88BEBLL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::GeometryContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 136))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::HillshadeLogic,md::HillshadeContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0xE719E07499A88BEBLL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::GeometryContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 128))(v5, a2, v7, v3);
    }
  }
  return result;
}

void md::Logic<md::HillshadeLogic,md::HillshadeContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::GeometryContext>,gdc::TypeList<>>>::_allocateContext()
{
}

void sub_1A239974C(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

uint64_t gdc::ObjectHolder<md::HillshadeContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::HillshadeContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555618;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0xC400A2AC0F1);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::HillshadeContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555618;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0xC400A2AC0F1);
  }
  return a1;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_20,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_20>,void ()(VKNavigationPuckLocationTracingEvent *)>::operator()(uint64_t a1, id *a2)
{
  id v7 = *a2;
  uint64_t v3 = (id *)(*(void *)(a1 + 8) + 848);
  id WeakRetained = objc_loadWeakRetained(v3);
  char v5 = objc_opt_respondsToSelector();

  if (v5)
  {
    id v6 = objc_loadWeakRetained(v3);
    [v6 puckLocationTracingEvent:v7];
  }
}

void sub_1A23998EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_20,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_20>,void ()(VKNavigationPuckLocationTracingEvent *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579D10;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_20,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_20>,void ()(VKNavigationPuckLocationTracingEvent *)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_19,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_19>,BOOL ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579CC8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_19,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_19>,BOOL ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_18,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_18>,void ()(BOOL)>::operator()(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(*(void *)(a1 + 8) + 1120);
  unint64_t v4 = *(void *)(v3 + 16);
  if ((v4 & (v4 - 1)) != 0)
  {
    unint64_t v6 = 0x20A1ED17D78F322BLL;
    if (v4 <= 0x20A1ED17D78F322BLL) {
      unint64_t v6 = 0x20A1ED17D78F322BLL % v4;
    }
    char v5 = *(void **)(*(void *)(v3 + 8) + 8 * v6);
    do
    {
      do
        char v5 = (void *)*v5;
      while (v5[1] != 0x20A1ED17D78F322BLL);
    }
    while (v5[2] != 0x20A1ED17D78F322BLL);
  }
  else
  {
    char v5 = *(void **)(*(void *)(v3 + 8) + 8 * ((v4 - 1) & 0x20A1ED17D78F322BLL));
    do
    {
      do
        char v5 = (void *)*v5;
      while (v5[1] != 0x20A1ED17D78F322BLL);
    }
    while (v5[2] != 0x20A1ED17D78F322BLL);
  }
  id v7 = *(md::LabelManager **)(v5[5] + 160);
  v9[0] = &unk_1EF56F1C8;
  v9[1] = v7;
  v9[2] = v2;
  uint64_t v10 = v9;
  md::LabelManager::queueCommand(v7, 50, 1, v9);
  uint64_t result = (uint64_t)v10;
  if (v10 == v9) {
    return (*(uint64_t (**)(void *))(v9[0] + 32))(v9);
  }
  if (v10) {
    return (*(uint64_t (**)(void))(*v10 + 40))();
  }
  return result;
}

void sub_1A2399B5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_18,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_18>,void ()(BOOL)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579C80;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_18,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_18>,void ()(BOOL)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_17,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_17>,void ()(void)>::operator()(void *result)
{
  uint64_t v1 = *(void *)(result[1] + 1120);
  unint64_t v2 = *(void *)(v1 + 16);
  if ((v2 & (v2 - 1)) != 0)
  {
    unint64_t v4 = 0x20A1ED17D78F322BLL;
    if (v2 <= 0x20A1ED17D78F322BLL) {
      unint64_t v4 = 0x20A1ED17D78F322BLL % v2;
    }
    uint64_t v3 = *(void **)(*(void *)(v1 + 8) + 8 * v4);
    do
    {
      do
        uint64_t v3 = (void *)*v3;
      while (v3[1] != 0x20A1ED17D78F322BLL);
    }
    while (v3[2] != 0x20A1ED17D78F322BLL);
  }
  else
  {
    uint64_t v3 = *(void **)(*(void *)(v1 + 8) + 8 * ((v2 - 1) & 0x20A1ED17D78F322BLL));
    do
    {
      do
        uint64_t v3 = (void *)*v3;
      while (v3[1] != 0x20A1ED17D78F322BLL);
    }
    while (v3[2] != 0x20A1ED17D78F322BLL);
  }
  uint64_t v5 = *(void *)(v3[5] + 160);
  unsigned __int8 v6 = atomic_load((unsigned __int8 *)(v5 + 3058));
  if (v6)
  {
    uint64_t v7 = *(void *)(v5 + 136);
    if (v7)
    {
      uint64_t result = *(void **)(v7 + 56);
      if (result)
      {
        uint64_t v9 = v5;
        char v8 = 9;
        return (void *)(*(uint64_t (**)(void *, uint64_t *, char *))(*result + 48))(result, &v9, &v8);
      }
    }
  }
  return result;
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_17,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_17>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579C38;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_17,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_17>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_16,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_16>,void ()(VKAnimation *)>::operator()(uint64_t a1, id *a2)
{
  id v3 = *a2;
  unint64_t v4 = *(md::MapEngine **)(a1 + 8);
  id v5 = v3;
  (*(void (**)(void *))(**((void **)v4 + 13) + 24))(*((void **)v4 + 13));
  md::MapEngine::updateRunLoopStatus(v4);
}

void sub_1A2399DD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_16,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_16>,void ()(VKAnimation *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579BF0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_16,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_16>,void ()(VKAnimation *)>::~__func()
{
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_15,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_15>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(*(void *)(a1 + 8) + 1120);
  unint64_t v2 = *(void *)(v1 + 16);
  if ((v2 & (v2 - 1)) != 0)
  {
    unint64_t v4 = 0x20A1ED17D78F322BLL;
    if (v2 <= 0x20A1ED17D78F322BLL) {
      unint64_t v4 = 0x20A1ED17D78F322BLL % v2;
    }
    uint64_t v3 = *(void **)(*(void *)(v1 + 8) + 8 * v4);
    do
    {
      do
        uint64_t v3 = (void *)*v3;
      while (v3[1] != 0x20A1ED17D78F322BLL);
    }
    while (v3[2] != 0x20A1ED17D78F322BLL);
  }
  else
  {
    uint64_t v3 = *(void **)(*(void *)(v1 + 8) + 8 * ((v2 - 1) & 0x20A1ED17D78F322BLL));
    do
    {
      do
        uint64_t v3 = (void *)*v3;
      while (v3[1] != 0x20A1ED17D78F322BLL);
    }
    while (v3[2] != 0x20A1ED17D78F322BLL);
  }
  id v5 = *(md::LabelManager **)(v3[5] + 160);
  v7[0] = &unk_1EF56EF88;
  v7[1] = v5;
  char v8 = v7;
  md::LabelManager::queueCommand(v5, 42, 1, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

void sub_1A2399FDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_15,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_15>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579BA8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_15,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_15>,void ()(void)>::~__func()
{
}

md::LabelManager *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_14,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_14>,void ()(md::Venue const*)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(*(void *)(a1 + 8) + 1120);
  unint64_t v4 = *(void *)(v3 + 16);
  if ((v4 & (v4 - 1)) != 0)
  {
    unint64_t v6 = 0x20A1ED17D78F322BLL;
    if (v4 <= 0x20A1ED17D78F322BLL) {
      unint64_t v6 = 0x20A1ED17D78F322BLL % v4;
    }
    id v5 = *(void **)(*(void *)(v3 + 8) + 8 * v6);
    do
    {
      do
        id v5 = (void *)*v5;
      while (v5[1] != 0x20A1ED17D78F322BLL);
    }
    while (v5[2] != 0x20A1ED17D78F322BLL);
  }
  else
  {
    id v5 = *(void **)(*(void *)(v3 + 8) + 8 * ((v4 - 1) & 0x20A1ED17D78F322BLL));
    do
    {
      do
        id v5 = (void *)*v5;
      while (v5[1] != 0x20A1ED17D78F322BLL);
    }
    while (v5[2] != 0x20A1ED17D78F322BLL);
  }
  uint64_t result = *(md::LabelManager **)(v5[5] + 160);
  if (v2 || *((unsigned char *)result + 3570))
  {
    *((unsigned char *)result + 3570) = v2 != 0;
    v8[0] = &unk_1EF56E9E8;
    v8[1] = result;
    uint64_t v8[2] = v2 != 0;
    uint64_t v9 = (md::LabelManager *)v8;
    md::LabelManager::queueCommand(result, 51, 1, v8);
    uint64_t result = v9;
    if (v9 == (md::LabelManager *)v8)
    {
      return (md::LabelManager *)(*(uint64_t (**)(void *))(v8[0] + 32))(v8);
    }
    else if (v9)
    {
      return (md::LabelManager *)(*(uint64_t (**)(void))(*(void *)v9 + 40))();
    }
  }
  return result;
}

void sub_1A239A200(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_14,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_14>,void ()(md::Venue const*)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579B60;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_14,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_14>,void ()(md::Venue const*)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_13,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_13>,void ()(md::Venue const*,md::VenueBuilding const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a3;
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 8) + 848));
  [WeakRetained nearestVenueDidChange:v3 building:v4];
}

void sub_1A239A2D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_13,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_13>,void ()(md::Venue const*,md::VenueBuilding const*)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579B18;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_13,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_13>,void ()(md::Venue const*,md::VenueBuilding const*)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_12,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_12>,void ()(VKARWalkingElevationRequestFailureInfo *)>::operator()(uint64_t a1, id *a2)
{
  id v7 = *a2;
  uint64_t v3 = (id *)(*(void *)(a1 + 8) + 848);
  id WeakRetained = objc_loadWeakRetained(v3);
  char v5 = objc_opt_respondsToSelector();

  if (v5)
  {
    id v6 = objc_loadWeakRetained(v3);
    [v6 arWalkingElevationRequestFailure:v7];
  }
}

void sub_1A239A3E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_12,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_12>,void ()(VKARWalkingElevationRequestFailureInfo *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579AD0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_12,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_12>,void ()(VKARWalkingElevationRequestFailureInfo *)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_11,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_11>,void ()(VKARWalkingFeatureSet *)>::operator()(uint64_t a1, id *a2)
{
  id v7 = *a2;
  uint64_t v3 = (id *)(*(void *)(a1 + 8) + 848);
  id WeakRetained = objc_loadWeakRetained(v3);
  char v5 = objc_opt_respondsToSelector();

  if (v5)
  {
    id v6 = objc_loadWeakRetained(v3);
    [v6 arWalkingFeatureSetStateDidUpdate:v7];
  }
}

void sub_1A239A4F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_11,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_11>,void ()(VKARWalkingFeatureSet *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579A88;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_11,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_11>,void ()(VKARWalkingFeatureSet *)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_10,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_10>,void ()(VKARWalkingFeatureDidUpdateInfo *)>::operator()(uint64_t a1, id *a2)
{
  id v7 = *a2;
  uint64_t v3 = (id *)(*(void *)(a1 + 8) + 848);
  id WeakRetained = objc_loadWeakRetained(v3);
  char v5 = objc_opt_respondsToSelector();

  if (v5)
  {
    id v6 = objc_loadWeakRetained(v3);
    [v6 activeARWalkingFeatureDidUpdate:v7];
  }
}

void sub_1A239A608(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_10,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_10>,void ()(VKARWalkingFeatureDidUpdateInfo *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579A40;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_10,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_10>,void ()(VKARWalkingFeatureDidUpdateInfo *)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_9,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_9>,void ()(md::MuninJunction const*,md::MuninRoadEdge const*,BOOL)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3, unsigned __int8 *a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *a3;
  int v6 = *a4;
  id v7 = (id *)(*(void *)(a1 + 8) + 848);
  id WeakRetained = objc_loadWeakRetained(v7);
  char v8 = objc_opt_respondsToSelector();

  if (v8)
  {
    id v10 = objc_loadWeakRetained(v7);
    [v10 muninJunctionDidChange:v4 currentRoad:v5 localize:v6 != 0];
  }
}

void sub_1A239A748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_9,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_9>,void ()(md::MuninJunction const*,md::MuninRoadEdge const*,BOOL)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5799F8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_9,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_9>,void ()(md::MuninJunction const*,md::MuninRoadEdge const*,BOOL)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_8,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_8>,void ()(md::LabelManager *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5799B0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_8,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_8>,void ()(md::LabelManager *)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_7,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_7>,void ()(md::LabelManager *,std::shared_ptr<md::LabelMarker> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 8) + 848));
  [WeakRetained labelMarkerDidChangeState:a3];
}

void sub_1A239A87C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_7,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_7>,void ()(md::LabelManager *,std::shared_ptr<md::LabelMarker> const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579968;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_7,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_7>,void ()(md::LabelManager *,std::shared_ptr<md::LabelMarker> const&)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_6,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_6>,void ()(md::LabelManager *,std::shared_ptr<md::LabelMarker> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 8) + 848));
  [WeakRetained selectedLabelMarkerWillDisappear:a3];
}

void sub_1A239A948(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_6,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_6>,void ()(md::LabelManager *,std::shared_ptr<md::LabelMarker> const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579920;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_6,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_6>,void ()(md::LabelManager *,std::shared_ptr<md::LabelMarker> const&)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_5,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_5>,void ()(md::LabelManager *,std::shared_ptr<md::LabelMarker> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 8) + 848));
  [WeakRetained selectedLabelMarkerDidCompleteLayout:a3];
}

void sub_1A239AA14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_5,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_5>,void ()(md::LabelManager *,std::shared_ptr<md::LabelMarker> const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF520F60;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_5,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_5>,void ()(md::LabelManager *,std::shared_ptr<md::LabelMarker> const&)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_4,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_4>,void ()(md::LabelManager const*,md::NeedsLayoutReason)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF520F18;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_4,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_4>,void ()(md::LabelManager const*,md::NeedsLayoutReason)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_3,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_3>,void ()(md::LabelManager *,md::NeedsLayoutReason)>::operator()(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  char v4 = *a3;
  md::MapEngine::setNeedsTick(v3, &v4);
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_3,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_3>,void ()(md::LabelManager *,md::NeedsLayoutReason)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF520ED0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_3,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_3>,void ()(md::LabelManager *,md::NeedsLayoutReason)>::~__func()
{
}

void md::Logic<md::ARApplyWorldTransformUpdatesLogic,md::ARApplyWorldTransformUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

uint64_t md::Logic<md::ARApplyWorldTransformUpdatesLogic,md::ARApplyWorldTransformUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::ARApplyWorldTransformUpdatesLogic,md::ARApplyWorldTransformUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x61AAF6FADEFBCCACLL && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    md::LogicDependencies<gdc::TypeList<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>(v7, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v7, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

void *md::LogicDependencies<gdc::TypeList<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>(void *result, uint64_t a2, unint64_t a3)
{
  if (!a3)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    goto LABEL_94;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    uint64_t v4 = 0x2BD4930A0600742;
    if (a3 <= 0x2BD4930A0600742) {
      uint64_t v4 = 0x2BD4930A0600742 % a3;
    }
  }
  else
  {
    uint64_t v4 = (a3 - 1) & 0x2BD4930A0600742;
  }
  char v8 = *(void **)(a2 + 8 * v4);
  if (!v8) {
    goto LABEL_25;
  }
  char v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_25;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v11 = v9[1];
      if (v11 == 0x2BD4930A0600742)
      {
        if (v9[2] == 0x2BD4930A0600742) {
          goto LABEL_23;
        }
      }
      else if ((v11 & (a3 - 1)) != v4)
      {
        goto LABEL_25;
      }
      char v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v9[1];
    if (v10 == 0x2BD4930A0600742) {
      break;
    }
    if (v10 >= a3) {
      v10 %= a3;
    }
    if (v10 != v4) {
      goto LABEL_25;
    }
LABEL_12:
    char v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_25;
    }
  }
  if (v9[2] != 0x2BD4930A0600742) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v12 = v9[5];
  if (*(void *)(v12 + 8) == 0x2BD4930A0600742)
  {
    uint64_t v6 = *(void *)(v12 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v6 = 0;
LABEL_26:
  if (v3.u32[0] > 1uLL)
  {
    uint64_t v13 = 0x148CB13E59522D82;
    if (a3 <= 0x148CB13E59522D82) {
      uint64_t v13 = 0x148CB13E59522D82 % a3;
    }
  }
  else
  {
    uint64_t v13 = (a3 - 1) & 0x148CB13E59522D82;
  }
  unint64_t v14 = *(void **)(a2 + 8 * v13);
  if (!v14) {
    goto LABEL_48;
  }
  uint64_t v15 = (void *)*v14;
  if (!v15) {
    goto LABEL_48;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v17 = v15[1];
      if (v17 == 0x148CB13E59522D82)
      {
        if (v15[2] == 0x148CB13E59522D82) {
          goto LABEL_46;
        }
      }
      else if ((v17 & (a3 - 1)) != v13)
      {
        goto LABEL_48;
      }
      uint64_t v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_48;
      }
    }
  }
  while (2)
  {
    unint64_t v16 = v15[1];
    if (v16 != 0x148CB13E59522D82)
    {
      if (v16 >= a3) {
        v16 %= a3;
      }
      if (v16 != v13) {
        goto LABEL_48;
      }
      goto LABEL_35;
    }
    if (v15[2] != 0x148CB13E59522D82)
    {
LABEL_35:
      uint64_t v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_48;
      }
      continue;
    }
    break;
  }
LABEL_46:
  uint64_t v18 = v15[5];
  if (*(void *)(v18 + 8) == 0x148CB13E59522D82)
  {
    uint64_t v7 = *(void *)(v18 + 32);
    goto LABEL_49;
  }
LABEL_48:
  uint64_t v7 = 0;
LABEL_49:
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v19 = 0x9C174DEE01931CA6;
    if (a3 <= 0x9C174DEE01931CA6) {
      unint64_t v19 = 0x9C174DEE01931CA6 % a3;
    }
  }
  else
  {
    unint64_t v19 = (a3 - 1) & 0x9C174DEE01931CA6;
  }
  uint64_t v20 = *(void **)(a2 + 8 * v19);
  if (!v20) {
    goto LABEL_71;
  }
  uint64_t v21 = (void *)*v20;
  if (!v21) {
    goto LABEL_71;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v23 = v21[1];
      if (v23 == 0x9C174DEE01931CA6)
      {
        if (v21[2] == 0x9C174DEE01931CA6) {
          goto LABEL_69;
        }
      }
      else if ((v23 & (a3 - 1)) != v19)
      {
        goto LABEL_71;
      }
      uint64_t v21 = (void *)*v21;
      if (!v21) {
        goto LABEL_71;
      }
    }
  }
  while (2)
  {
    unint64_t v22 = v21[1];
    if (v22 != 0x9C174DEE01931CA6)
    {
      if (v22 >= a3) {
        v22 %= a3;
      }
      if (v22 != v19) {
        goto LABEL_71;
      }
      goto LABEL_58;
    }
    if (v21[2] != 0x9C174DEE01931CA6)
    {
LABEL_58:
      uint64_t v21 = (void *)*v21;
      if (!v21) {
        goto LABEL_71;
      }
      continue;
    }
    break;
  }
LABEL_69:
  uint64_t v24 = v21[5];
  if (*(void *)(v24 + 8) == 0x9C174DEE01931CA6)
  {
    uint64_t v5 = *(void *)(v24 + 32);
    goto LABEL_72;
  }
LABEL_71:
  uint64_t v5 = 0;
LABEL_72:
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v25 = 0xF409241CDA31AF08;
    if (a3 <= 0xF409241CDA31AF08) {
      unint64_t v25 = 0xF409241CDA31AF08 % a3;
    }
  }
  else
  {
    unint64_t v25 = (a3 - 1) & 0xF409241CDA31AF08;
  }
  unint64_t v26 = *(void **)(a2 + 8 * v25);
  if (!v26) {
    goto LABEL_94;
  }
  int v27 = (void *)*v26;
  if (!v27) {
    goto LABEL_94;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v29 = v27[1];
      if (v29 == 0xF409241CDA31AF08)
      {
        if (v27[2] == 0xF409241CDA31AF08) {
          goto LABEL_92;
        }
      }
      else if ((v29 & (a3 - 1)) != v25)
      {
        goto LABEL_94;
      }
      int v27 = (void *)*v27;
      if (!v27) {
        goto LABEL_94;
      }
    }
  }
  while (1)
  {
    unint64_t v28 = v27[1];
    if (v28 == 0xF409241CDA31AF08) {
      break;
    }
    if (v28 >= a3) {
      v28 %= a3;
    }
    if (v28 != v25) {
      goto LABEL_94;
    }
LABEL_81:
    int v27 = (void *)*v27;
    if (!v27) {
      goto LABEL_94;
    }
  }
  if (v27[2] != 0xF409241CDA31AF08) {
    goto LABEL_81;
  }
LABEL_92:
  uint64_t v30 = v27[5];
  if (*(void *)(v30 + 8) != 0xF409241CDA31AF08)
  {
LABEL_94:
    uint64_t v31 = 0;
    goto LABEL_95;
  }
  uint64_t v31 = *(void *)(v30 + 32);
LABEL_95:
  void *result = v6;
  result[1] = v7;
  result[2] = v5;
  result[3] = v31;
  return result;
}

uint64_t md::Logic<md::ARApplyWorldTransformUpdatesLogic,md::ARApplyWorldTransformUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x61AAF6FADEFBCCACLL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 152))(v5, a2, v6, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARApplyWorldTransformUpdatesLogic,md::ARApplyWorldTransformUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x61AAF6FADEFBCCACLL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 144))(v5, a2, v6, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARApplyWorldTransformUpdatesLogic,md::ARApplyWorldTransformUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x61AAF6FADEFBCCACLL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 136))(v5, a2, v6, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARApplyWorldTransformUpdatesLogic,md::ARApplyWorldTransformUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x61AAF6FADEFBCCACLL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 128))(v5, a2, v6, v3);
    }
  }
  return result;
}

void md::Logic<md::ARApplyWorldTransformUpdatesLogic,md::ARApplyWorldTransformUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARUpDirectionUpdatesContext,md::ARAnimationContext,md::ARRotateTowardsUserContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::_allocateContext()
{
}

void sub_1A239B444(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

uint64_t gdc::ObjectHolder<md::ARApplyWorldTransformUpdatesContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ARApplyWorldTransformUpdatesContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555E38;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0xC400A2AC0F1);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ARApplyWorldTransformUpdatesContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555E38;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0xC400A2AC0F1);
  }
  return a1;
}

void md::Logic<md::ARUpDirectionUpdatesLogic,md::ARUpDirectionUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARAnimationContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

uint64_t md::Logic<md::ARUpDirectionUpdatesLogic,md::ARUpDirectionUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARAnimationContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::ARUpDirectionUpdatesLogic,md::ARUpDirectionUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARAnimationContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) != 0x2BD4930A0600742 || !*(void *)(a3 + 32))
  {
    a4[23] = 0;
    *a4 = 0;
    return result;
  }
  uint64_t v4 = *(void **)(a2 + 8);
  int8x8_t v5 = (int8x8_t)v4[1];
  if (!*(void *)&v5) {
    goto LABEL_27;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    uint64_t v7 = 0x148CB13E59522D82;
    if (*(void *)&v5 <= 0x148CB13E59522D82uLL) {
      uint64_t v7 = 0x148CB13E59522D82uLL % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v7 = (*(void *)&v5 - 1) & 0x148CB13E59522D82;
  }
  char v8 = *(void **)(*v4 + 8 * v7);
  if (!v8) {
    goto LABEL_27;
  }
  char v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_27;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v10 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v12 = v9[1];
      if (v12 == 0x148CB13E59522D82)
      {
        if (v9[2] == 0x148CB13E59522D82) {
          goto LABEL_25;
        }
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_27;
      }
      char v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_27;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v9[1];
    if (v11 == 0x148CB13E59522D82) {
      break;
    }
    if (v11 >= *(void *)&v5) {
      v11 %= *(void *)&v5;
    }
    if (v11 != v7) {
      goto LABEL_27;
    }
LABEL_14:
    char v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_27;
    }
  }
  if (v9[2] != 0x148CB13E59522D82) {
    goto LABEL_14;
  }
LABEL_25:
  uint64_t v13 = v9[5];
  if (*(void *)(v13 + 8) == 0x148CB13E59522D82)
  {
    uint64_t v14 = *(void *)(v13 + 32);
    goto LABEL_28;
  }
LABEL_27:
  uint64_t v14 = 0;
LABEL_28:
  uint64_t v15 = v14;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 160))(result);
}

uint64_t md::Logic<md::ARUpDirectionUpdatesLogic,md::ARUpDirectionUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARAnimationContext>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x2BD4930A0600742 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x148CB13E59522D82;
    if (*(void *)&v4 <= 0x148CB13E59522D82uLL) {
      uint64_t v6 = 0x148CB13E59522D82uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x148CB13E59522D82;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  char v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x148CB13E59522D82)
      {
        if (v8[2] == 0x148CB13E59522D82) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      char v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x148CB13E59522D82) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    char v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x148CB13E59522D82) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x148CB13E59522D82)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 152))(result);
}

uint64_t md::Logic<md::ARUpDirectionUpdatesLogic,md::ARUpDirectionUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARAnimationContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x2BD4930A0600742 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x148CB13E59522D82;
    if (*(void *)&v4 <= 0x148CB13E59522D82uLL) {
      uint64_t v6 = 0x148CB13E59522D82uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x148CB13E59522D82;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  char v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x148CB13E59522D82)
      {
        if (v8[2] == 0x148CB13E59522D82) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      char v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x148CB13E59522D82) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    char v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x148CB13E59522D82) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x148CB13E59522D82)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 144))(result);
}

uint64_t md::Logic<md::ARUpDirectionUpdatesLogic,md::ARUpDirectionUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARAnimationContext>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x2BD4930A0600742 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x148CB13E59522D82;
    if (*(void *)&v4 <= 0x148CB13E59522D82uLL) {
      uint64_t v6 = 0x148CB13E59522D82uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x148CB13E59522D82;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  char v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x148CB13E59522D82)
      {
        if (v8[2] == 0x148CB13E59522D82) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      char v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x148CB13E59522D82) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    char v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x148CB13E59522D82) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x148CB13E59522D82)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 136))(result);
}

uint64_t md::Logic<md::ARUpDirectionUpdatesLogic,md::ARUpDirectionUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARAnimationContext>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x2BD4930A0600742 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x148CB13E59522D82;
    if (*(void *)&v4 <= 0x148CB13E59522D82uLL) {
      uint64_t v6 = 0x148CB13E59522D82uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x148CB13E59522D82;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  char v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x148CB13E59522D82)
      {
        if (v8[2] == 0x148CB13E59522D82) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      char v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x148CB13E59522D82) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    char v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x148CB13E59522D82) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x148CB13E59522D82)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 128))(result);
}

void md::Logic<md::ARUpDirectionUpdatesLogic,md::ARUpDirectionUpdatesContext,md::LogicDependencies<gdc::TypeList<md::ARAnimationContext>,gdc::TypeList<>>>::_allocateContext()
{
}

void sub_1A239BE74(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

uint64_t gdc::ObjectHolder<md::ARUpDirectionUpdatesContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ARUpDirectionUpdatesContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555B68;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0xC400A2AC0F1);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ARUpDirectionUpdatesContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555B68;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0xC400A2AC0F1);
  }
  return a1;
}

void md::CollectARMapDataLogic::~CollectARMapDataLogic(md::CollectARMapDataLogic *this)
{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_2,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_2>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF520E88;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_2,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_2>,void ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<gdc::Camera>::__on_zero_shared(uint64_t result)
{
  if (*(unsigned char *)(result + 376)) {
    *(unsigned char *)(result + 376) = 0;
  }
  if (*(unsigned char *)(result + 360)) {
    *(unsigned char *)(result + 360) = 0;
  }
  return result;
}

void std::__shared_ptr_emplace<gdc::Camera>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582DD8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gdc::Camera>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582DD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_pointer<md::RunLoopController *,std::shared_ptr<md::RunLoopController>::__shared_ptr_default_delete<md::RunLoopController,md::RunLoopController>,std::allocator<md::RunLoopController>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<md::RunLoopController *,std::shared_ptr<md::RunLoopController>::__shared_ptr_default_delete<md::RunLoopController,md::RunLoopController>,std::allocator<md::RunLoopController>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<md::ConfigSettingProvider *,std::shared_ptr<md::ConfigSettingProvider>::__shared_ptr_default_delete<md::ConfigSettingProvider,md::ConfigSettingProvider>,std::allocator<md::ConfigSettingProvider>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<md::ConfigSettingProvider *,std::shared_ptr<md::ConfigSettingProvider>::__shared_ptr_default_delete<md::ConfigSettingProvider,md::ConfigSettingProvider>,std::allocator<md::ConfigSettingProvider>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<md::RenderLayerProviderWrapper *,std::shared_ptr<md::RenderLayerProviderWrapper>::__shared_ptr_default_delete<md::RenderLayerProviderWrapper,md::RenderLayerProviderWrapper>,std::allocator<md::RenderLayerProviderWrapper>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 112))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::RenderLayerProviderWrapper *,std::shared_ptr<md::RenderLayerProviderWrapper>::__shared_ptr_default_delete<md::RenderLayerProviderWrapper,md::RenderLayerProviderWrapper>,std::allocator<md::RenderLayerProviderWrapper>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void md::RenderLayerProviderWrapper::~RenderLayerProviderWrapper(md::RenderLayerProviderWrapper *this)
{
  *(void *)this = &unk_1EF547CD0;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }

  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  std::__shared_weak_count *v3;

  *(void *)this = &unk_1EF547CD0;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }

  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

double md::RenderLayerProviderWrapper::setQuantizedShadowMatrix(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)(v2 + 4320) = *(void *)a2;
  *(void *)(v2 + 4328) = *(void *)(a2 + 8);
  *(void *)(v2 + 4336) = *(void *)(a2 + 16);
  *(void *)(v2 + 4344) = *(void *)(a2 + 24);
  *(void *)(v2 + 4352) = *(void *)(a2 + 32);
  *(void *)(v2 + 4360) = *(void *)(a2 + 40);
  *(void *)(v2 + 4368) = *(void *)(a2 + 48);
  *(void *)(v2 + 4376) = *(void *)(a2 + 56);
  *(void *)(v2 + 4384) = *(void *)(a2 + 64);
  *(void *)(v2 + 4392) = *(void *)(a2 + 72);
  *(void *)(v2 + 4400) = *(void *)(a2 + 80);
  *(void *)(v2 + 4408) = *(void *)(a2 + 88);
  *(void *)(v2 + 4416) = *(void *)(a2 + 96);
  *(void *)(v2 + 4424) = *(void *)(a2 + 104);
  *(void *)(v2 + 4432) = *(void *)(a2 + 112);
  double result = *(double *)(a2 + 120);
  *(double *)(v2 + 4440) = result;
  return result;
}

__n128 md::RenderLayerProviderWrapper::quantizedShadowMatrix@<Q0>(md::RenderLayerProviderWrapper *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *((void *)this + 1);
  long long v3 = *(_OWORD *)(v2 + 4400);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(v2 + 4384);
  *(_OWORD *)(a2 + 80) = v3;
  long long v4 = *(_OWORD *)(v2 + 4432);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(v2 + 4416);
  *(_OWORD *)(a2 + 112) = v4;
  long long v5 = *(_OWORD *)(v2 + 4336);
  *(_OWORD *)a2 = *(_OWORD *)(v2 + 4320);
  *(_OWORD *)(a2 + 16) = v5;
  __n128 result = *(__n128 *)(v2 + 4352);
  long long v7 = *(_OWORD *)(v2 + 4368);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v7;
  return result;
}

uint64_t md::RenderLayerProviderWrapper::legacyCartographicTiledRenderResources(md::RenderLayerProviderWrapper *this)
{
  return *((void *)this + 1) + 4168;
}

uint64_t md::RenderLayerProviderWrapper::getCommandBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  long long v3 = *(void **)(a1 + 8);
  uint64_t v4 = v3[3];
  if (a2 < (unint64_t)((v3[4] - v4) >> 3))
  {
    uint64_t v5 = *(void *)(v4 + 8 * a2);
    if (v5 && HIDWORD(a2) == HIDWORD(v5))
    {
      uint64_t v10 = v3[7];
      uint64_t v11 = v3[6] + 8 * v5;
      if (v11 != v10) {
        return *(void *)v11;
      }
    }
  }
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  long long v7 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    uint64_t v8 = (uint64_t)(*(void *)(*(void *)(a1 + 8) + 56) - *(void *)(*(void *)(a1 + 8) + 48)) >> 3;
    int v12 = 134218754;
    uint64_t v13 = v8;
    __int16 v14 = 2080;
    uint64_t v15 = "false";
    __int16 v16 = 2080;
    uint64_t v17 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/RenderLayerProvider.hpp";
    __int16 v18 = 1024;
    int v19 = 103;
    _os_log_impl(&dword_1A1780000, v7, OS_LOG_TYPE_ERROR, "Failed to resolve command buffer for handle (%zu): Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)&v12, 0x26u);
  }

  return 0;
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<std::tuple<unsigned long,md::SceneLayer>,std::vector<geo::handle<md::CommandBufferResource>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::tuple<unsigned long,md::SceneLayer>,std::vector<geo::handle<md::CommandBufferResource>>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      long long v3 = (void *)v2[4];
      if (v3)
      {
        v2[5] = v3;
        operator delete(v3);
      }
    }
    operator delete(v2);
  }
  return a1;
}

uint64_t md::data_array_cache<md::ls::ColorData,geo::handle<md::ls::ColorData>,md::MaterialKey,md::ls::ColorData,md::MaterialKeyHasher>::~data_array_cache(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 272);
  if (v2)
  {
    do
    {
      long long v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 256);
  *(void *)(a1 + 256) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 232);
  if (v5)
  {
    do
    {
      uint64_t v6 = (void *)*v5;
      operator delete(v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  long long v7 = *(void **)(a1 + 216);
  *(void *)(a1 + 216) = 0;
  if (v7) {
    operator delete(v7);
  }
  uint64_t v8 = *(void **)(a1 + 192);
  if (v8)
  {
    do
    {
      uint64_t v21 = (void *)*v8;
      uint64_t v22 = v8[3];
      void v8[3] = 0;
      if (v22) {
        MEMORY[0x1A6239270](v22, 0x1000C40A86A77D5);
      }
      operator delete(v8);
      uint64_t v8 = v21;
    }
    while (v21);
  }
  uint64_t v9 = *(void **)(a1 + 176);
  *(void *)(a1 + 176) = 0;
  if (v9) {
    operator delete(v9);
  }
  uint64_t v10 = *(void **)(a1 + 152);
  if (v10)
  {
    *(void *)(a1 + 160) = v10;
    operator delete(v10);
  }
  uint64_t v11 = *(void **)(a1 + 128);
  if (v11)
  {
    *(void *)(a1 + 136) = v11;
    operator delete(v11);
  }
  int v12 = *(void **)(a1 + 104);
  if (v12)
  {
    *(void *)(a1 + 112) = v12;
    operator delete(v12);
  }
  uint64_t v13 = *(void **)(a1 + 80);
  if (v13)
  {
    *(void *)(a1 + 88) = v13;
    operator delete(v13);
  }
  __int16 v14 = *(void **)(a1 + 56);
  if (v14)
  {
    do
    {
      uint64_t v15 = (void *)*v14;
      operator delete(v14);
      __int16 v14 = v15;
    }
    while (v15);
  }
  __int16 v16 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v16) {
    operator delete(v16);
  }
  uint64_t v17 = *(void **)(a1 + 16);
  if (v17)
  {
    do
    {
      __int16 v18 = (void *)*v17;
      operator delete(v17);
      uint64_t v17 = v18;
    }
    while (v18);
  }
  int v19 = *(void **)a1;
  *(void *)a1 = 0;
  if (v19) {
    operator delete(v19);
  }
  return a1;
}

uint64_t md::data_array_cache<md::ls::ZIndex,geo::handle<md::ls::ZIndex>,md::MaterialKey,md::ls::ZIndex,md::MaterialKeyHasher>::~data_array_cache(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 272);
  if (v2)
  {
    do
    {
      long long v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 256);
  *(void *)(a1 + 256) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 232);
  if (v5)
  {
    do
    {
      uint64_t v6 = (void *)*v5;
      operator delete(v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  long long v7 = *(void **)(a1 + 216);
  *(void *)(a1 + 216) = 0;
  if (v7) {
    operator delete(v7);
  }
  uint64_t v8 = *(void **)(a1 + 192);
  if (v8)
  {
    do
    {
      uint64_t v21 = (void *)*v8;
      uint64_t v22 = v8[3];
      void v8[3] = 0;
      if (v22) {
        MEMORY[0x1A6239270](v22, 0x1000C4090D0E795);
      }
      operator delete(v8);
      uint64_t v8 = v21;
    }
    while (v21);
  }
  uint64_t v9 = *(void **)(a1 + 176);
  *(void *)(a1 + 176) = 0;
  if (v9) {
    operator delete(v9);
  }
  uint64_t v10 = *(void **)(a1 + 152);
  if (v10)
  {
    *(void *)(a1 + 160) = v10;
    operator delete(v10);
  }
  uint64_t v11 = *(void **)(a1 + 128);
  if (v11)
  {
    *(void *)(a1 + 136) = v11;
    operator delete(v11);
  }
  int v12 = *(void **)(a1 + 104);
  if (v12)
  {
    *(void *)(a1 + 112) = v12;
    operator delete(v12);
  }
  uint64_t v13 = *(void **)(a1 + 80);
  if (v13)
  {
    *(void *)(a1 + 88) = v13;
    operator delete(v13);
  }
  __int16 v14 = *(void **)(a1 + 56);
  if (v14)
  {
    do
    {
      uint64_t v15 = (void *)*v14;
      operator delete(v14);
      __int16 v14 = v15;
    }
    while (v15);
  }
  __int16 v16 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v16) {
    operator delete(v16);
  }
  uint64_t v17 = *(void **)(a1 + 16);
  if (v17)
  {
    do
    {
      __int16 v18 = (void *)*v17;
      operator delete(v17);
      uint64_t v17 = v18;
    }
    while (v18);
  }
  int v19 = *(void **)a1;
  *(void *)a1 = 0;
  if (v19) {
    operator delete(v19);
  }
  return a1;
}

uint64_t md::data_array_cache<md::ls::MaterialVisibilityOptions,geo::handle<md::ls::MaterialVisibilityOptions>,md::MaterialKey,md::ls::MaterialVisibilityOptions,md::MaterialKeyHasher>::~data_array_cache(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 272);
  if (v2)
  {
    do
    {
      long long v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 256);
  *(void *)(a1 + 256) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 232);
  if (v5)
  {
    do
    {
      uint64_t v6 = (void *)*v5;
      operator delete(v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  long long v7 = *(void **)(a1 + 216);
  *(void *)(a1 + 216) = 0;
  if (v7) {
    operator delete(v7);
  }
  uint64_t v8 = *(void **)(a1 + 192);
  if (v8)
  {
    do
    {
      uint64_t v21 = (void *)*v8;
      uint64_t v22 = v8[3];
      void v8[3] = 0;
      if (v22) {
        MEMORY[0x1A6239270](v22, 0x1000C4033FC2DF1);
      }
      operator delete(v8);
      uint64_t v8 = v21;
    }
    while (v21);
  }
  uint64_t v9 = *(void **)(a1 + 176);
  *(void *)(a1 + 176) = 0;
  if (v9) {
    operator delete(v9);
  }
  uint64_t v10 = *(void **)(a1 + 152);
  if (v10)
  {
    *(void *)(a1 + 160) = v10;
    operator delete(v10);
  }
  uint64_t v11 = *(void **)(a1 + 128);
  if (v11)
  {
    *(void *)(a1 + 136) = v11;
    operator delete(v11);
  }
  int v12 = *(void **)(a1 + 104);
  if (v12)
  {
    *(void *)(a1 + 112) = v12;
    operator delete(v12);
  }
  uint64_t v13 = *(void **)(a1 + 80);
  if (v13)
  {
    *(void *)(a1 + 88) = v13;
    operator delete(v13);
  }
  __int16 v14 = *(void **)(a1 + 56);
  if (v14)
  {
    do
    {
      uint64_t v15 = (void *)*v14;
      operator delete(v14);
      __int16 v14 = v15;
    }
    while (v15);
  }
  __int16 v16 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v16) {
    operator delete(v16);
  }
  uint64_t v17 = *(void **)(a1 + 16);
  if (v17)
  {
    do
    {
      __int16 v18 = (void *)*v17;
      operator delete(v17);
      uint64_t v17 = v18;
    }
    while (v18);
  }
  int v19 = *(void **)a1;
  *(void *)a1 = 0;
  if (v19) {
    operator delete(v19);
  }
  return a1;
}

uint64_t md::data_array_cache<md::MaterialIDStorage,geo::handle<md::MaterialIDStorage>,md::MaterialKey,std::shared_ptr<gms::Material<ggl::Texture2D>>,md::MaterialKeyHasher>::~data_array_cache(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 272);
  if (v2)
  {
    do
    {
      long long v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 256);
  *(void *)(a1 + 256) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 232);
  if (v5)
  {
    do
    {
      uint64_t v6 = (void *)*v5;
      operator delete(v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  long long v7 = *(void **)(a1 + 216);
  *(void *)(a1 + 216) = 0;
  if (v7) {
    operator delete(v7);
  }
  uint64_t v8 = *(void **)(a1 + 192);
  if (v8)
  {
    do
    {
      uint64_t v9 = (void *)*v8;
      uint64_t v10 = v8[3];
      void v8[3] = 0;
      if (v10)
      {
        uint64_t v11 = *(std::__shared_weak_count **)(v10 + 8);
        if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
        MEMORY[0x1A6239270](v10, 0x20C40A4A59CD2);
      }
      operator delete(v8);
      uint64_t v8 = v9;
    }
    while (v9);
  }
  int v12 = *(void **)(a1 + 176);
  *(void *)(a1 + 176) = 0;
  if (v12) {
    operator delete(v12);
  }
  uint64_t v13 = *(void **)(a1 + 152);
  if (v13)
  {
    *(void *)(a1 + 160) = v13;
    operator delete(v13);
  }
  __int16 v14 = *(void **)(a1 + 128);
  if (v14)
  {
    *(void *)(a1 + 136) = v14;
    operator delete(v14);
  }
  uint64_t v15 = *(void **)(a1 + 104);
  if (v15)
  {
    *(void *)(a1 + 112) = v15;
    operator delete(v15);
  }
  __int16 v16 = *(void **)(a1 + 80);
  if (v16)
  {
    *(void *)(a1 + 88) = v16;
    operator delete(v16);
  }
  uint64_t v17 = *(void **)(a1 + 56);
  if (v17)
  {
    do
    {
      __int16 v18 = (void *)*v17;
      operator delete(v17);
      uint64_t v17 = v18;
    }
    while (v18);
  }
  int v19 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v19) {
    operator delete(v19);
  }
  uint64_t v20 = *(void **)(a1 + 16);
  if (v20)
  {
    do
    {
      uint64_t v21 = (void *)*v20;
      operator delete(v20);
      uint64_t v20 = v21;
    }
    while (v21);
  }
  uint64_t v22 = *(void **)a1;
  *(void *)a1 = 0;
  if (v22) {
    operator delete(v22);
  }
  return a1;
}

uint64_t std::__shared_ptr_pointer<md::MaterialResourceStore *,std::shared_ptr<md::MaterialResourceStore>::__shared_ptr_default_delete<md::MaterialResourceStore,md::MaterialResourceStore>,std::allocator<md::MaterialResourceStore>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    md::data_array_cache<md::ls::ColorData,geo::handle<md::ls::ColorData>,md::MaterialKey,md::ls::ColorData,md::MaterialKeyHasher>::~data_array_cache(v1 + 904);
    md::data_array_cache<md::ls::ZIndex,geo::handle<md::ls::ZIndex>,md::MaterialKey,md::ls::ZIndex,md::MaterialKeyHasher>::~data_array_cache(v1 + 608);
    md::data_array_cache<md::ls::MaterialVisibilityOptions,geo::handle<md::ls::MaterialVisibilityOptions>,md::MaterialKey,md::ls::MaterialVisibilityOptions,md::MaterialKeyHasher>::~data_array_cache(v1 + 312);
    md::data_array_cache<md::MaterialIDStorage,geo::handle<md::MaterialIDStorage>,md::MaterialKey,std::shared_ptr<gms::Material<ggl::Texture2D>>,md::MaterialKeyHasher>::~data_array_cache(v1 + 16);
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<md::MaterialResourceStore *,std::shared_ptr<md::MaterialResourceStore>::__shared_ptr_default_delete<md::MaterialResourceStore,md::MaterialResourceStore>,std::allocator<md::MaterialResourceStore>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

md::VKMRenderResourcesStore *std::__shared_ptr_pointer<md::VKMRenderResourcesStore *,std::shared_ptr<md::VKMRenderResourcesStore>::__shared_ptr_default_delete<md::VKMRenderResourcesStore,md::VKMRenderResourcesStore>,std::allocator<md::VKMRenderResourcesStore>>::__on_zero_shared(uint64_t a1)
{
  __n128 result = *(md::VKMRenderResourcesStore **)(a1 + 24);
  if (result)
  {
    md::VKMRenderResourcesStore::~VKMRenderResourcesStore(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<md::VKMRenderResourcesStore *,std::shared_ptr<md::VKMRenderResourcesStore>::__shared_ptr_default_delete<md::VKMRenderResourcesStore,md::VKMRenderResourcesStore>,std::allocator<md::VKMRenderResourcesStore>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::RenderLayerResources>::__on_zero_shared(void *a1)
{
  md::CartographicTiledRenderResources::~CartographicTiledRenderResources((md::CartographicTiledRenderResources *)(a1 + 524));
  md::FlyoverRenderResources::~FlyoverRenderResources((md::FlyoverRenderResources *)(a1 + 365));
  md::DaVinciGroundRenderResources::~DaVinciGroundRenderResources((md::DaVinciGroundRenderResources *)(a1 + 20));
  uint64_t v2 = (void *)a1[17];
  if (v2)
  {
    do
    {
      uint64_t v8 = (void *)*v2;
      uint64_t v9 = (void *)v2[4];
      if (v9)
      {
        v2[5] = v9;
        operator delete(v9);
      }
      operator delete(v2);
      uint64_t v2 = v8;
    }
    while (v8);
  }
  long long v3 = (void *)a1[15];
  a1[15] = 0;
  if (v3) {
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[12];
  if (v4)
  {
    a1[13] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)a1[9];
  if (v5)
  {
    a1[10] = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)a1[6];
  if (v6)
  {
    a1[7] = v6;
    operator delete(v6);
  }
  long long v7 = (void *)a1[3];
  if (v7)
  {
    a1[4] = v7;
    operator delete(v7);
  }
}

void md::CartographicTiledRenderResources::~CartographicTiledRenderResources(md::CartographicTiledRenderResources *this)
{
  uint64_t v2 = (void *)*((void *)this + 16);
  do
  {
    if (v2[1])
    {
      unint64_t v3 = 0;
      uint64_t v4 = v2 + 2;
      uint64_t v5 = v2 + 2;
      uint64_t v6 = (void (***)(void))(v2 + 2);
      do
      {
        long long v7 = (void (**)(void *))*v6;
        v6 += 15;
        (*v7)(v5);
        ++v3;
        v4 += 15;
        uint64_t v5 = v6;
      }
      while (v3 < v2[1]);
    }
    v2[1] = 0;
    uint64_t v2 = (void *)*v2;
  }
  while (v2);
  uint64_t v8 = (void **)*((void *)this + 16);
  *((void *)this + 17) = v8;
  uint64_t v9 = *v8;
  *uint64_t v8 = 0;
  if (v9)
  {
    do
    {
      uint64_t v10 = (void *)*v9;
      free(v9);
      uint64_t v9 = v10;
    }
    while (v10);
    uint64_t v8 = (void **)*((void *)this + 16);
  }
  free(v8);
  uint64_t v11 = *((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v11)
  {
    uint64_t v12 = ggl::FragmentedPool<ggl::PolygonSolidFill::MeshPipelineSetup>::~FragmentedPool(v11);
    MEMORY[0x1A6239270](v12, 0x10A0C40D234DDC7);
  }
  uint64_t v13 = (void *)*((void *)this + 10);
  if (v13)
  {
    *((void *)this + 11) = v13;
    operator delete(v13);
  }
  __int16 v14 = (void *)*((void *)this + 7);
  if (v14)
  {
    *((void *)this + 8) = v14;
    operator delete(v14);
  }
  uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
    __int16 v16 = (std::__shared_weak_count *)*((void *)this + 4);
    if (!v16) {
      goto LABEL_22;
    }
  }
  else
  {
    __int16 v16 = (std::__shared_weak_count *)*((void *)this + 4);
    if (!v16) {
      goto LABEL_22;
    }
  }
  if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
LABEL_22:
  uint64_t v17 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v18 = *(void *)this;
  *(void *)this = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
}

void md::DaVinciGroundRenderResources::~DaVinciGroundRenderResources(md::DaVinciGroundRenderResources *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 344);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 342);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 340);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 338);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  std::__tree<std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>,std::__map_value_compare<gss::StyleAttribute,std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>,std::less<gss::StyleAttribute>,true>,std::allocator<std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>>>::destroy(*((void **)this + 335));
  uint64_t v6 = (void *)*((void *)this + 331);
  while (v6)
  {
    long long v7 = v6;
    uint64_t v6 = (void *)*v6;
    uint64_t v8 = (std::__shared_weak_count *)v7[4];
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    operator delete(v7);
  }
  uint64_t v9 = (void *)*((void *)this + 329);
  *((void *)this + 329) = 0;
  if (v9) {
    operator delete(v9);
  }
  uint64_t v10 = *((void *)this + 325);
  *((void *)this + 325) = 0;
  if (v10) {
    MEMORY[0x1A6239270](v10, 0x1000C4049ECCB0CLL);
  }
  uint64_t v11 = *((void *)this + 324);
  *((void *)this + 324) = 0;
  if (v11) {
    MEMORY[0x1A6239270](v11, 0x1000C4049ECCB0CLL);
  }
  uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 323);
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 321);
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  __int16 v14 = (void *)*((void *)this + 317);
  do
  {
    if (v14[1])
    {
      unint64_t v15 = 0;
      __int16 v16 = v14 + 2;
      uint64_t v17 = v14 + 2;
      uint64_t v18 = (void (***)(void))(v14 + 2);
      do
      {
        int v19 = (void (**)(void *))*v18;
        v18 += 15;
        (*v19)(v17);
        ++v15;
        v16 += 15;
        uint64_t v17 = v18;
      }
      while (v15 < v14[1]);
    }
    v14[1] = 0;
    __int16 v14 = (void *)*v14;
  }
  while (v14);
  uint64_t v20 = (void **)*((void *)this + 317);
  *((void *)this + 318) = v20;
  uint64_t v21 = *v20;
  void *v20 = 0;
  if (v21)
  {
    do
    {
      uint64_t v22 = (void *)*v21;
      free(v21);
      uint64_t v21 = v22;
    }
    while (v22);
    uint64_t v20 = (void **)*((void *)this + 317);
  }
  free(v20);
  uint64_t v23 = (void *)*((void *)this + 314);
  if (v23)
  {
    *((void *)this + 315) = v23;
    operator delete(v23);
  }
  uint64_t v24 = *((void *)this + 310);
  if (v24)
  {
    uint64_t v25 = *((void *)this + 311);
    uint64_t v26 = *((void *)this + 310);
    if (v25 != v24)
    {
      uint64_t v27 = *((void *)this + 311);
      do
      {
        uint64_t v29 = *(void **)(v27 - 24);
        v27 -= 24;
        unint64_t v28 = v29;
        if (v29)
        {
          *(void *)(v25 - 16) = v28;
          operator delete(v28);
        }
        uint64_t v25 = v27;
      }
      while (v27 != v24);
      uint64_t v26 = *((void *)this + 310);
    }
    *((void *)this + 311) = v24;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 313) + 40))(*((void *)this + 313), v26, *((void *)this + 312) - v26);
  }
  uint64_t v30 = (void *)*((void *)this + 307);
  if (v30)
  {
    *((void *)this + 308) = v30;
    operator delete(v30);
  }
  uint64_t v31 = *((void *)this + 303);
  if (v31)
  {
    uint64_t v32 = *((void *)this + 304);
    uint64_t v33 = *((void *)this + 303);
    if (v32 != v31)
    {
      do
      {
        uint64_t v34 = *(void (****)(void, uint64_t))(v32 - 8);
        *(void *)(v32 - 8) = 0;
        if (v34)
        {
          (**v34)(v34, v33);
          {
            operator new();
          }
          (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                           + 40))(mdm::Allocator::instance(void)::alloc, v34, 216);
        }
        v32 -= 16;
      }
      while (v32 != v31);
      uint64_t v33 = *((void *)this + 303);
    }
    *((void *)this + 304) = v31;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 306) + 40))(*((void *)this + 306), v33, *((void *)this + 305) - v33);
  }
  *((void *)this + 276) = &unk_1EF55D4B8;
  uint64_t v35 = *((void *)this + 277);
  if (v35)
  {
    (*(void (**)(uint64_t, void))(*(void *)v35 + 16))(v35, *((void *)this + 279));
    *((void *)this + 279) = 3735927469;
  }
  uint64_t v36 = (std::__shared_weak_count *)*((void *)this + 278);
  if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
  }
  *((void *)this + 249) = &unk_1EF55D4B8;
  uint64_t v37 = *((void *)this + 250);
  if (v37)
  {
    (*(void (**)(uint64_t, void))(*(void *)v37 + 16))(v37, *((void *)this + 252));
    *((void *)this + 252) = 3735927469;
  }
  unint64_t v38 = (std::__shared_weak_count *)*((void *)this + 251);
  if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
    std::__shared_weak_count::__release_weak(v38);
  }
  *((void *)this + 222) = &unk_1EF55D4B8;
  uint64_t v39 = *((void *)this + 223);
  if (v39)
  {
    (*(void (**)(uint64_t, void))(*(void *)v39 + 16))(v39, *((void *)this + 225));
    *((void *)this + 225) = 3735927469;
  }
  uint64_t v40 = (std::__shared_weak_count *)*((void *)this + 224);
  if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
  }
  *((void *)this + 195) = &unk_1EF55D4B8;
  uint64_t v41 = *((void *)this + 196);
  if (v41)
  {
    (*(void (**)(uint64_t, void))(*(void *)v41 + 16))(v41, *((void *)this + 198));
    *((void *)this + 198) = 3735927469;
  }
  unint64_t v42 = (std::__shared_weak_count *)*((void *)this + 197);
  if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
    std::__shared_weak_count::__release_weak(v42);
  }
  uint64_t v43 = (std::__shared_weak_count *)*((void *)this + 194);
  if (v43 && !atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
    std::__shared_weak_count::__release_weak(v43);
  }
  uint64_t v44 = (std::__shared_weak_count *)*((void *)this + 192);
  if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
    std::__shared_weak_count::__release_weak(v44);
  }
  uint64_t v45 = (std::__shared_weak_count *)*((void *)this + 190);
  if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
    std::__shared_weak_count::__release_weak(v45);
  }
  uint64_t v46 = (std::__shared_weak_count *)*((void *)this + 188);
  if (v46 && !atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
    std::__shared_weak_count::__release_weak(v46);
  }
  uint64_t v47 = (std::__shared_weak_count *)*((void *)this + 186);
  if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
    std::__shared_weak_count::__release_weak(v47);
  }
  uint64_t v48 = (std::__shared_weak_count *)*((void *)this + 184);
  if (v48 && !atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
    std::__shared_weak_count::__release_weak(v48);
  }
  uint64_t v49 = *((void *)this + 182);
  *((void *)this + 182) = 0;
  if (v49) {
    (*(void (**)(uint64_t))(*(void *)v49 + 8))(v49);
  }
  uint64_t v50 = *((void *)this + 181);
  *((void *)this + 181) = 0;
  if (v50) {
    (*(void (**)(uint64_t))(*(void *)v50 + 8))(v50);
  }
  uint64_t v51 = *((void *)this + 180);
  *((void *)this + 180) = 0;
  if (v51)
  {
    uint64_t v52 = ggl::FragmentedPool<ggl::DaVinci::PackedLinearDepthPipelineSetup>::~FragmentedPool(v51);
    MEMORY[0x1A6239270](v52, 0x10A0C40D234DDC7);
  }
  uint64_t v53 = *((void *)this + 179);
  *((void *)this + 179) = 0;
  if (v53)
  {
    uint64_t v54 = ggl::FragmentedPool<ggl::DaVinci::LinearDepthPipelineSetup>::~FragmentedPool(v53);
    MEMORY[0x1A6239270](v54, 0x10A0C40D234DDC7);
  }
  uint64_t v55 = *((void *)this + 178);
  *((void *)this + 178) = 0;
  if (v55)
  {
    uint64_t v56 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Tile::Clipping>>::~FragmentedPool(v55);
    MEMORY[0x1A6239270](v56, 0x10A0C40D234DDC7);
  }
  uint64_t v57 = *((void *)this + 177);
  *((void *)this + 177) = 0;
  if (v57)
  {
    uint64_t v58 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>::~FragmentedPool(v57);
    MEMORY[0x1A6239270](v58, 0x10A0C40D234DDC7);
  }
  uint64_t v59 = *((void *)this + 176);
  *((void *)this + 176) = 0;
  if (v59)
  {
    uint64_t v60 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>::~FragmentedPool(v59);
    MEMORY[0x1A6239270](v60, 0x10A0C40D234DDC7);
  }
  uint64_t v61 = *((void *)this + 175);
  *((void *)this + 175) = 0;
  if (v61)
  {
    uint64_t v62 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>::~FragmentedPool(v61);
    MEMORY[0x1A6239270](v62, 0x10A0C40D234DDC7);
  }
  uint64_t v63 = *((void *)this + 174);
  *((void *)this + 174) = 0;
  if (v63)
  {
    uint64_t v64 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>::~FragmentedPool(v63);
    MEMORY[0x1A6239270](v64, 0x10A0C40D234DDC7);
  }
  uint64_t v65 = *((void *)this + 173);
  *((void *)this + 173) = 0;
  if (v65)
  {
    uint64_t v66 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>::~FragmentedPool(v65);
    MEMORY[0x1A6239270](v66, 0x10A0C40D234DDC7);
  }
  uint64_t v67 = *((void *)this + 172);
  *((void *)this + 172) = 0;
  if (v67)
  {
    uint64_t v68 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::RibbonStyle>>::~FragmentedPool(v67);
    MEMORY[0x1A6239270](v68, 0x10A0C40D234DDC7);
  }
  uint64_t v69 = *((void *)this + 171);
  *((void *)this + 171) = 0;
  if (v69)
  {
    uint64_t v70 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>::~FragmentedPool(v69);
    MEMORY[0x1A6239270](v70, 0x10A0C40D234DDC7);
  }
  uint64_t v71 = *((void *)this + 170);
  *((void *)this + 170) = 0;
  if (v71)
  {
    uint64_t v72 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>::~FragmentedPool(v71);
    MEMORY[0x1A6239270](v72, 0x10A0C40D234DDC7);
  }
  uint64_t v73 = *((void *)this + 169);
  *((void *)this + 169) = 0;
  if (v73)
  {
    uint64_t v74 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>::~FragmentedPool(v73);
    MEMORY[0x1A6239270](v74, 0x10A0C40D234DDC7);
  }
  uint64_t v75 = *((void *)this + 168);
  *((void *)this + 168) = 0;
  if (v75)
  {
    uint64_t v76 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>::~FragmentedPool(v75);
    MEMORY[0x1A6239270](v76, 0x10A0C40D234DDC7);
  }
  uint64_t v77 = (std::__shared_weak_count *)*((void *)this + 167);
  if (v77 && !atomic_fetch_add(&v77->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
    std::__shared_weak_count::__release_weak(v77);
  }
  uint64_t v78 = (std::__shared_weak_count *)*((void *)this + 165);
  if (v78 && !atomic_fetch_add(&v78->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
    std::__shared_weak_count::__release_weak(v78);
  }
  uint64_t v79 = (std::__shared_weak_count *)*((void *)this + 163);
  if (v79 && !atomic_fetch_add(&v79->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
    std::__shared_weak_count::__release_weak(v79);
  }
  uint64_t v80 = (std::__shared_weak_count *)*((void *)this + 161);
  if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
    std::__shared_weak_count::__release_weak(v80);
  }
  uint64_t v81 = (std::__shared_weak_count *)*((void *)this + 159);
  if (v81 && !atomic_fetch_add(&v81->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
    std::__shared_weak_count::__release_weak(v81);
  }
  uint64_t v82 = (std::__shared_weak_count *)*((void *)this + 157);
  if (v82 && !atomic_fetch_add(&v82->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
    std::__shared_weak_count::__release_weak(v82);
  }
  uint64_t v83 = *((void *)this + 153);
  *((void *)this + 153) = 0;
  if (v83) {
    (*(void (**)(uint64_t))(*(void *)v83 + 8))(v83);
  }
  uint64_t v84 = (std::__shared_weak_count *)*((void *)this + 152);
  if (v84 && !atomic_fetch_add(&v84->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
    std::__shared_weak_count::__release_weak(v84);
  }
  uint64_t v85 = (void *)*((void *)this + 150);
  *((void *)this + 150) = 0;
  if (v85)
  {
    *uint64_t v85 = 3131955885;
    MEMORY[0x1A6239270]();
  }
  uint64_t v86 = (std::__shared_weak_count *)*((void *)this + 149);
  if (v86 && !atomic_fetch_add(&v86->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
    std::__shared_weak_count::__release_weak(v86);
  }
  unint64_t v87 = (std::__shared_weak_count *)*((void *)this + 147);
  if (v87 && !atomic_fetch_add(&v87->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
    std::__shared_weak_count::__release_weak(v87);
  }
  uint64_t v88 = *((void *)this + 145);
  *((void *)this + 145) = 0;
  if (v88)
  {
    uint64_t v89 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>::~FragmentedPool(v88);
    MEMORY[0x1A6239270](v89, 0x10A0C40D234DDC7);
  }
  uint64_t v90 = *((void *)this + 144);
  *((void *)this + 144) = 0;
  if (v90)
  {
    uint64_t v91 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>>::~FragmentedPool(v90);
    MEMORY[0x1A6239270](v91, 0x10A0C40D234DDC7);
  }
  uint64_t v92 = *((void *)this + 143);
  *((void *)this + 143) = 0;
  if (v92)
  {
    uint64_t v93 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>::~FragmentedPool(v92);
    MEMORY[0x1A6239270](v93, 0x10A0C40D234DDC7);
  }
  uint64_t v94 = *((void *)this + 142);
  *((void *)this + 142) = 0;
  if (v94)
  {
    uint64_t v95 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::Style>>::~FragmentedPool(v94);
    MEMORY[0x1A6239270](v95, 0x10A0C40D234DDC7);
  }
  uint64_t v96 = *((void *)this + 141);
  *((void *)this + 141) = 0;
  if (v96)
  {
    uint64_t v97 = ggl::FragmentedPool<ggl::DaVinci::DecalPipelineSetup>::~FragmentedPool(v96);
    MEMORY[0x1A6239270](v97, 0x10A0C40D234DDC7);
  }
  uint64_t v98 = *((void *)this + 140);
  *((void *)this + 140) = 0;
  if (v98)
  {
    uint64_t v99 = ggl::FragmentedPool<ggl::DaVinci::RibbonPipelineSetup>::~FragmentedPool(v98);
    MEMORY[0x1A6239270](v99, 0x10A0C40D234DDC7);
  }
  uint64_t v100 = *((void *)this + 139);
  *((void *)this + 139) = 0;
  if (v100)
  {
    uint64_t v101 = ggl::FragmentedPool<ggl::DaVinci::GroundShadowMapPipelineSetup>::~FragmentedPool(v100);
    MEMORY[0x1A6239270](v101, 0x10A0C40D234DDC7);
  }
  uint64_t v102 = *((void *)this + 138);
  *((void *)this + 138) = 0;
  if (v102)
  {
    uint64_t v103 = ggl::FragmentedPool<ggl::DaVinci::GroundDepthPipelineSetup>::~FragmentedPool(v102);
    MEMORY[0x1A6239270](v103, 0x10A0C40D234DDC7);
  }
  uint64_t v104 = *((void *)this + 137);
  *((void *)this + 137) = 0;
  if (v104)
  {
    uint64_t v105 = ggl::FragmentedPool<ggl::DaVinci::GroundNonCompressedPipelineSetup>::~FragmentedPool(v104);
    MEMORY[0x1A6239270](v105, 0x10A0C40D234DDC7);
  }
  uint64_t v106 = *((void *)this + 136);
  *((void *)this + 136) = 0;
  if (v106)
  {
    uint64_t v107 = ggl::FragmentedPool<ggl::DaVinci::GroundPipelineSetup>::~FragmentedPool(v106);
    MEMORY[0x1A6239270](v107, 0x10A0C40D234DDC7);
  }
  uint64_t v108 = *((void *)this + 135);
  *((void *)this + 135) = 0;
  if (v108)
  {
    uint64_t v109 = ggl::FragmentedPool<ggl::DaVinci::GroundPipelineSetup>::~FragmentedPool(v108);
    MEMORY[0x1A6239270](v109, 0x10A0C40D234DDC7);
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*((void **)this + 133));
  uint64_t v110 = (std::__shared_weak_count *)*((void *)this + 121);
  if (v110 && !atomic_fetch_add(&v110->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v110->__on_zero_shared)(v110);
    std::__shared_weak_count::__release_weak(v110);
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*((void **)this + 118));
  uint64_t v111 = (std::__shared_weak_count *)*((void *)this + 106);
  if (v111 && !atomic_fetch_add(&v111->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v111->__on_zero_shared)(v111);
    std::__shared_weak_count::__release_weak(v111);
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*((void **)this + 103));
  uint64_t v112 = (std::__shared_weak_count *)*((void *)this + 91);
  if (v112 && !atomic_fetch_add(&v112->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
    std::__shared_weak_count::__release_weak(v112);
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*((void **)this + 88));
  uint64_t v113 = (std::__shared_weak_count *)*((void *)this + 76);
  if (v113 && !atomic_fetch_add(&v113->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
    std::__shared_weak_count::__release_weak(v113);
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*((void **)this + 73));
  uint64_t v114 = (std::__shared_weak_count *)*((void *)this + 61);
  if (v114 && !atomic_fetch_add(&v114->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v114->__on_zero_shared)(v114);
    std::__shared_weak_count::__release_weak(v114);
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*((void **)this + 58));
  uint64_t v115 = (std::__shared_weak_count *)*((void *)this + 46);
  if (v115 && !atomic_fetch_add(&v115->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v115->__on_zero_shared)(v115);
    std::__shared_weak_count::__release_weak(v115);
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*((void **)this + 43));
  float64x2_t v116 = (std::__shared_weak_count *)*((void *)this + 31);
  if (v116 && !atomic_fetch_add(&v116->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v116->__on_zero_shared)(v116);
    std::__shared_weak_count::__release_weak(v116);
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*((void **)this + 28));
  uint64_t v117 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v117 && !atomic_fetch_add(&v117->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
    std::__shared_weak_count::__release_weak(v117);
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*((void **)this + 13));
  uint64_t v118 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v118)
  {
    if (!atomic_fetch_add(&v118->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v118->__on_zero_shared)(v118);
      std::__shared_weak_count::__release_weak(v118);
    }
  }
}

void std::__tree<std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>,std::__map_value_compare<gss::StyleAttribute,std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>,std::less<gss::StyleAttribute>,true>,std::allocator<std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>,std::__map_value_compare<gss::StyleAttribute,std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>,std::less<gss::StyleAttribute>,true>,std::allocator<std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>>>::destroy(*a1);
    std::__tree<std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>,std::__map_value_compare<gss::StyleAttribute,std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>,std::less<gss::StyleAttribute>,true>,std::allocator<std::__value_type<gss::StyleAttribute,std::unique_ptr<ggl::Texture2D>>>>::destroy(a1[1]);
    uint64_t v2 = a1[5];
    a1[5] = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    operator delete(a1);
  }
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::PackedLinearDepthPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::LinearDepthPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Tile::Clipping>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::RibbonStyle>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::Style>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::DecalPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::RibbonPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::GroundDepthPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::GroundNonCompressedPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::GroundPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void std::__shared_ptr_emplace<md::RenderLayerResources>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581088;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::RenderLayerResources>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581088;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::MapEngine::onLayoutOnlyTimerFired(id *this, double a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  md::MapEngine::runUpdatePhase((md::MapEngine *)this, a2, 1);
  md::MapEngine::_postRender(this, a2);
  uint64_t v4 = *((void *)this[1] + 1);
  v8[0] = &unk_1EF5797B8;
  uint64_t v9 = v8;
  geo::TaskQueue::barrierSync(v4, v8);
  if (v9 == v8)
  {
    (*(void (**)(void *))(v8[0] + 32))(v8);
  }
  else if (v9)
  {
    (*(void (**)(void))(*v9 + 40))();
  }
  id WeakRetained = objc_loadWeakRetained(this + 106);
  BOOL v6 = WeakRetained == 0;

  if (!v6)
  {
    id v7 = objc_loadWeakRetained(this + 106);
    [v7 didPresent];
  }
  md::MapEngine::updateRunLoopStatus((md::MapEngine *)this);
}

void sub_1A23A0ED8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__function::__func<md::MapEngine::onLayoutOnlyTimerFired(double)::$_0,std::allocator<md::MapEngine::onLayoutOnlyTimerFired(double)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5797B8;
}

void *std::__function::__func<md::MapEngine::onLayoutOnlyTimerFired(double)::$_0,std::allocator<md::MapEngine::onLayoutOnlyTimerFired(double)::$_0>,void ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF5797B8;
  return result;
}

void std::__function::__func<md::MapEngine::onLayoutOnlyTimerFired(double)::$_0,std::allocator<md::MapEngine::onLayoutOnlyTimerFired(double)::$_0>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::MapEngine::_postRender(double)::$_0::operator() const(void)::{lambda(void)#2},std::allocator<md::MapEngine::_postRender(double)::$_0::operator() const(void)::{lambda(void)#2}>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57EDD8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MapEngine::_postRender(double)::$_0::operator() const(void)::{lambda(void)#2},std::allocator<md::MapEngine::_postRender(double)::$_0::operator() const(void)::{lambda(void)#2}>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57EDD8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::_postRender(double)::$_0::operator() const(void)::{lambda(void)#2},std::allocator<md::MapEngine::_postRender(double)::$_0::operator() const(void)::{lambda(void)#2}>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::MapEngine::_postRender(double)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<md::MapEngine::_postRender(double)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(v1 + 1216);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "RunLogicAfter", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::MapEngine::_postRender(double)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<md::MapEngine::_postRender(double)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57EE20;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MapEngine::_postRender(double)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<md::MapEngine::_postRender(double)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57EE20;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::_postRender(double)::$_0::operator() const(void)::{lambda(void)#1},std::allocator<md::MapEngine::_postRender(double)::$_0::operator() const(void)::{lambda(void)#1}>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::MapEngine::_postRender(double)::$_0,std::allocator<md::MapEngine::_postRender(double)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF579578;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<md::MapEngine::_postRender(double)::$_0,std::allocator<md::MapEngine::_postRender(double)::$_0>,void ()(void)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::runUpdatePhase(double,BOOL)::$_4,std::allocator<md::MapEngine::runUpdatePhase(double,BOOL)::$_4>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579698;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::runUpdatePhase(double,BOOL)::$_4,std::allocator<md::MapEngine::runUpdatePhase(double,BOOL)::$_4>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::MapEngine::runUpdatePhase(double,BOOL)::$_3,std::allocator<md::MapEngine::runUpdatePhase(double,BOOL)::$_3>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579650;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MapEngine::runUpdatePhase(double,BOOL)::$_3,std::allocator<md::MapEngine::runUpdatePhase(double,BOOL)::$_3>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579650;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::runUpdatePhase(double,BOOL)::$_3,std::allocator<md::MapEngine::runUpdatePhase(double,BOOL)::$_3>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::MapEngine::runUpdatePhase(double,BOOL)::$_2,std::allocator<md::MapEngine::runUpdatePhase(double,BOOL)::$_2>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(v1 + 1216);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "RunLogicBefore", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::MapEngine::runUpdatePhase(double,BOOL)::$_2,std::allocator<md::MapEngine::runUpdatePhase(double,BOOL)::$_2>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579608;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MapEngine::runUpdatePhase(double,BOOL)::$_2,std::allocator<md::MapEngine::runUpdatePhase(double,BOOL)::$_2>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579608;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::runUpdatePhase(double,BOOL)::$_2,std::allocator<md::MapEngine::runUpdatePhase(double,BOOL)::$_2>,void ()(void)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::runUpdatePhase(double,BOOL)::$_1,std::allocator<md::MapEngine::runUpdatePhase(double,BOOL)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5795C0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::runUpdatePhase(double,BOOL)::$_1,std::allocator<md::MapEngine::runUpdatePhase(double,BOOL)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<std::__bind<void (md::MapEngine::*)(double),md::MapEngine*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (md::MapEngine::*)(double),md::MapEngine*,std::placeholders::__ph<1> const&>>,void ()(double)>::operator()(void *a1, double *a2)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = (uint64_t (*)(void *, double))a1[1];
  os_signpost_id_t v4 = (void *)(a1[3] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(double))(*v4 + v3))(*a2);
  }
  else {
    return v3(v4, *a2);
  }
}

__n128 std::__function::__func<std::__bind<void (md::MapEngine::*)(double),md::MapEngine*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (md::MapEngine::*)(double),md::MapEngine*,std::placeholders::__ph<1> const&>>,void ()(double)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56B848;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<void (md::MapEngine::*)(double),md::MapEngine*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (md::MapEngine::*)(double),md::MapEngine*,std::placeholders::__ph<1> const&>>,void ()(double)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF56B848;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<std::__bind<void (md::MapEngine::*)(double),md::MapEngine*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (md::MapEngine::*)(double),md::MapEngine*,std::placeholders::__ph<1> const&>>,void ()(double)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::buildFrameRequest(std::optional<unsigned int>,std::function<void ()(void)>)::$_0,std::allocator<md::MapEngine::buildFrameRequest(std::optional<unsigned int>,std::function<void ()(void)>)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF520D68;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::buildFrameRequest(std::optional<unsigned int>,std::function<void ()(void)>)::$_0,std::allocator<md::MapEngine::buildFrameRequest(std::optional<unsigned int>,std::function<void ()(void)>)::$_0>,void ()(void)>::~__func()
{
}

uint64_t md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0::~$_0(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  return a1;
}

uint64_t std::__function::__func<md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0,std::allocator<md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 4536);
  int v3 = *(_DWORD *)(a1 + 16);
  std::mutex::lock((std::mutex *)(v2 + 176));
  if (*(unsigned char *)(v2 + 292) && *(_DWORD *)(v2 + 288) == v3)
  {
    geo::concurrent_queue_base<std::function<void ()(void)>,geo::BasicStoragePolicy<std::function<void ()(void)>>>::close(v2);
    if (*(unsigned char *)(v2 + 292)) {
      *(unsigned char *)(v2 + 292) = 0;
    }
    if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
    }
    os_signpost_id_t v4 = (id)GEOGetVectorKitPerformanceLog_log;
    uint64_t v5 = v4;
    os_signpost_id_t v6 = *(void *)(v2 + 296);
    if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
    {
      *(_WORD *)uint64_t v12 = 0;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v5, OS_SIGNPOST_INTERVAL_END, v6, "HomeQueueReservation", "", v12, 2u);
    }

    std::mutex::unlock((std::mutex *)(v2 + 176));
    std::condition_variable::notify_one((std::condition_variable *)(v2 + 240));
  }
  else
  {
    std::mutex::unlock((std::mutex *)(v2 + 176));
  }
  uint64_t v7 = *(void *)(a1 + 48);
  if (!v7)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    uint64_t v11 = v10;
    std::mutex::unlock((std::mutex *)(v2 + 176));
    _Unwind_Resume(v11);
  }
  uint64_t v8 = *(uint64_t (**)(void))(*(void *)v7 + 48);
  return v8();
}

void std::__function::__func<md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0,std::allocator<md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0>,void ()(void)>::destroy_deallocate(char *__p)
{
  uint64_t v2 = __p + 24;
  int v3 = (char *)*((void *)__p + 6);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  operator delete(__p);
}

uint64_t std::__function::__func<md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0,std::allocator<md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 24;
  uint64_t result = *(void *)(a1 + 48);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t std::__function::__func<md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0,std::allocator<md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0>,void ()(void)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF520D20;
  uint64_t v3 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v3;
  uint64_t v4 = *(void *)(result + 48);
  if (v4)
  {
    if (v4 == result + 24)
    {
      *(void *)(a2 + 48) = a2 + 24;
      uint64_t v5 = *(uint64_t (**)(void))(**(void **)(result + 48) + 24);
      return v5();
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)v4 + 16))(*(void *)(result + 48));
      *(void *)(a2 + 48) = result;
    }
  }
  else
  {
    *(void *)(a2 + 48) = 0;
  }
  return result;
}

void *std::__function::__func<md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0,std::allocator<md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x38uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = &unk_1EF520D20;
  v2[1] = v3;
  *((_DWORD *)v2 + 4) = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4)
  {
    if (v4 == a1 + 24)
    {
      v2[6] = v2 + 3;
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      return v2;
    }
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  }
  v2[6] = v4;
  return v2;
}

void sub_1A23A19E8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0,std::allocator<md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF520D20;
  uint64_t v1 = a1 + 3;
  uint64_t v2 = (void *)a1[6];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0,std::allocator<md::MapEngine::_renderSceneAsync(double,std::function<void ()(void)>,std::function<void ()(void)>)::$_0>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF520D20;
  uint64_t v2 = a1 + 3;
  uint64_t v3 = (void *)a1[6];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  return a1;
}

uint64_t std::__function::__func<md::MapEngine::onRenderTimerFired(double,std::function<void ()(void)>)::$_0,std::allocator<md::MapEngine::onRenderTimerFired(double,std::function<void ()(void)>)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  uint64_t v3 = *(void *)(result + 16);
  *a2 = &unk_1EF5796E0;
  a2[1] = v2;
  a2[2] = v3;
  return result;
}

void *std::__function::__func<md::MapEngine::onRenderTimerFired(double,std::function<void ()(void)>)::$_0,std::allocator<md::MapEngine::onRenderTimerFired(double,std::function<void ()(void)>)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  void *result = &unk_1EF5796E0;
  result[1] = v3;
  result[2] = v4;
  return result;
}

void std::__function::__func<md::MapEngine::onRenderTimerFired(double,std::function<void ()(void)>)::$_0,std::allocator<md::MapEngine::onRenderTimerFired(double,std::function<void ()(void)>)::$_0>,void ()(void)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::onDisplayLinkFired(double)::$_0,std::allocator<md::MapEngine::onDisplayLinkFired(double)::$_0>,void ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF520DB0;
  return result;
}

void std::__function::__func<md::MapEngine::onDisplayLinkFired(double)::$_0,std::allocator<md::MapEngine::onDisplayLinkFired(double)::$_0>,void ()(void)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::MapEngineDisplayLinkCaller,std::allocator<md::MapEngine::MapEngineDisplayLinkCaller>,void ()(double)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF519EE0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngineDisplayLinkCaller,std::allocator<md::MapEngine::MapEngineDisplayLinkCaller>,void ()(double)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::DisplayLink>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DisplayLink>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583350;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DisplayLink>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583350;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_1,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5798D8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_1,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5798D8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_1,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_1>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_0,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(v1 + 1216);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "InitMapEngine", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_0,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579890;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_0,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579890;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_0,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_0>,void ()(void)>::~__func()
{
}

uint64_t gdc::Signal<unsigned long>::~Signal(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  while (v2)
  {
    uint64_t v5 = v2;
    uint64_t v2 = (void *)*v2;
    os_signpost_id_t v6 = (void *)v5[6];
    if (v6 == v5 + 3)
    {
      (*(void (**)(void *))(v5[3] + 32))(v5 + 3);
    }
    else if (v6)
    {
      (*(void (**)(void *))(*v6 + 40))(v6);
    }
    operator delete(v5);
  }
  uint64_t v3 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_pointer<md::MapEngineSignals *,std::shared_ptr<md::MapEngineSignals>::__shared_ptr_default_delete<md::MapEngineSignals,md::MapEngineSignals>,std::allocator<md::MapEngineSignals>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    md::MapEngineSignals::ThreadSafeSignal<unsigned long>::~ThreadSafeSignal(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<md::MapEngineSignals *,std::shared_ptr<md::MapEngineSignals>::__shared_ptr_default_delete<md::MapEngineSignals,md::MapEngineSignals>,std::allocator<md::MapEngineSignals>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<md::NullFaultNotificationService *,std::shared_ptr<md::NullFaultNotificationService>::__shared_ptr_default_delete<md::NullFaultNotificationService,md::NullFaultNotificationService>,std::allocator<md::NullFaultNotificationService>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::NullFaultNotificationService *,std::shared_ptr<md::NullFaultNotificationService>::__shared_ptr_default_delete<md::NullFaultNotificationService,md::NullFaultNotificationService>,std::allocator<md::NullFaultNotificationService>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void md::NullFaultNotificationService::~NullFaultNotificationService(md::NullFaultNotificationService *this)
{
}

uint64_t std::__shared_ptr_pointer<md::DefaultFaultNotificationService *,std::shared_ptr<md::DefaultFaultNotificationService>::__shared_ptr_default_delete<md::DefaultFaultNotificationService,md::DefaultFaultNotificationService>,std::allocator<md::DefaultFaultNotificationService>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::DefaultFaultNotificationService *,std::shared_ptr<md::DefaultFaultNotificationService>::__shared_ptr_default_delete<md::DefaultFaultNotificationService,md::DefaultFaultNotificationService>,std::allocator<md::DefaultFaultNotificationService>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<md::StandardRouteElevationSource *,std::shared_ptr<md::StandardRouteElevationSource>::__shared_ptr_default_delete<md::StandardRouteElevationSource,md::StandardRouteElevationSource>,std::allocator<md::StandardRouteElevationSource>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::StandardRouteElevationSource *,std::shared_ptr<md::StandardRouteElevationSource>::__shared_ptr_default_delete<md::StandardRouteElevationSource,md::StandardRouteElevationSource>,std::allocator<md::StandardRouteElevationSource>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<md::FlyoverRouteElevationSource *,std::shared_ptr<md::FlyoverRouteElevationSource>::__shared_ptr_default_delete<md::FlyoverRouteElevationSource,md::FlyoverRouteElevationSource>,std::allocator<md::FlyoverRouteElevationSource>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::FlyoverRouteElevationSource *,std::shared_ptr<md::FlyoverRouteElevationSource>::__shared_ptr_default_delete<md::FlyoverRouteElevationSource,md::FlyoverRouteElevationSource>,std::allocator<md::FlyoverRouteElevationSource>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

md::FeatureFlagProvider *std::__shared_ptr_pointer<md::FeatureFlagProvider *,std::shared_ptr<md::FeatureFlagProvider>::__shared_ptr_default_delete<md::FeatureFlagProvider,md::FeatureFlagProvider>,std::allocator<md::FeatureFlagProvider>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(md::FeatureFlagProvider **)(a1 + 24);
  if (result)
  {
    md::FeatureFlagProvider::~FeatureFlagProvider(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<md::FeatureFlagProvider *,std::shared_ptr<md::FeatureFlagProvider>::__shared_ptr_default_delete<md::FeatureFlagProvider,md::FeatureFlagProvider>,std::allocator<md::FeatureFlagProvider>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

gdc::ResourceRequestRouter *std::__shared_ptr_pointer<gdc::ResourceRequestRouter *,std::shared_ptr<gdc::ResourceRequestRouter>::__shared_ptr_default_delete<gdc::ResourceRequestRouter,gdc::ResourceRequestRouter>,std::allocator<gdc::ResourceRequestRouter>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(gdc::ResourceRequestRouter **)(a1 + 24);
  if (result)
  {
    gdc::ResourceRequestRouter::~ResourceRequestRouter(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<gdc::ResourceRequestRouter *,std::shared_ptr<gdc::ResourceRequestRouter>::__shared_ptr_default_delete<gdc::ResourceRequestRouter,gdc::ResourceRequestRouter>,std::allocator<gdc::ResourceRequestRouter>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<mre::GGLResourceStore *,std::shared_ptr<mre::GGLResourceStore>::__shared_ptr_default_delete<mre::GGLResourceStore,mre::GGLResourceStore>,std::allocator<mre::GGLResourceStore>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 80))();
  }
  return result;
}

void std::__shared_ptr_pointer<mre::GGLResourceStore *,std::shared_ptr<mre::GGLResourceStore>::__shared_ptr_default_delete<mre::GGLResourceStore,mre::GGLResourceStore>,std::allocator<mre::GGLResourceStore>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<md::MapEngineCompatabilityServiceImpl *,std::shared_ptr<md::MapEngineCompatabilityServiceImpl>::__shared_ptr_default_delete<md::MapEngineCompatabilityServiceImpl,md::MapEngineCompatabilityServiceImpl>,std::allocator<md::MapEngineCompatabilityServiceImpl>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::MapEngineCompatabilityServiceImpl *,std::shared_ptr<md::MapEngineCompatabilityServiceImpl>::__shared_ptr_default_delete<md::MapEngineCompatabilityServiceImpl,md::MapEngineCompatabilityServiceImpl>,std::allocator<md::MapEngineCompatabilityServiceImpl>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<RendererPassListProviderWrapper *,std::shared_ptr<RendererPassListProviderWrapper>::__shared_ptr_default_delete<RendererPassListProviderWrapper,RendererPassListProviderWrapper>,std::allocator<RendererPassListProviderWrapper>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void std::__shared_ptr_pointer<RendererPassListProviderWrapper *,std::shared_ptr<RendererPassListProviderWrapper>::__shared_ptr_default_delete<RendererPassListProviderWrapper,RendererPassListProviderWrapper>,std::allocator<RendererPassListProviderWrapper>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void RendererPassListProviderWrapper::~RendererPassListProviderWrapper(RendererPassListProviderWrapper *this)
{
}

uint64_t std::__shared_ptr_pointer<md::MapEngineCallbackGraphService *,std::shared_ptr<md::MapEngineCallbackGraphService>::__shared_ptr_default_delete<md::MapEngineCallbackGraphService,md::MapEngineCallbackGraphService>,std::allocator<md::MapEngineCallbackGraphService>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::MapEngineCallbackGraphService *,std::shared_ptr<md::MapEngineCallbackGraphService>::__shared_ptr_default_delete<md::MapEngineCallbackGraphService,md::MapEngineCallbackGraphService>,std::allocator<md::MapEngineCallbackGraphService>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<md::MapEngineFrameService *,std::shared_ptr<md::MapEngineFrameService>::__shared_ptr_default_delete<md::MapEngineFrameService,md::MapEngineFrameService>,std::allocator<md::MapEngineFrameService>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::MapEngineFrameService *,std::shared_ptr<md::MapEngineFrameService>::__shared_ptr_default_delete<md::MapEngineFrameService,md::MapEngineFrameService>,std::allocator<md::MapEngineFrameService>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<std::atomic<unsigned long> *,std::shared_ptr<std::atomic<unsigned long>>::__shared_ptr_default_delete<std::atomic<unsigned long>,std::atomic<unsigned long>>,std::allocator<std::atomic<unsigned long>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<std::atomic<unsigned long> *,std::shared_ptr<std::atomic<unsigned long>>::__shared_ptr_default_delete<std::atomic<unsigned long>,std::atomic<unsigned long>>,std::allocator<std::atomic<unsigned long>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gdc::ServiceLocator>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    os_signpost_id_t v4 = *(void **)(a1 + 24);
    if (v3 != v1)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 40;
      }
      while (v3 != v1);
      os_signpost_id_t v4 = *(void **)(a1 + 24);
    }
    *(void *)(a1 + 32) = v1;
    operator delete(v4);
  }
}

void std::__shared_ptr_emplace<gdc::ServiceLocator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582CF8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gdc::ServiceLocator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582CF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<md::MapEngine::AnalyticsInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582B38;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::MapEngine::AnalyticsInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582B38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<gdc::Statistics>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<gdc::Statistics>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582C88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gdc::Statistics>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582C88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void geo::_retain_ptr<VKCameraDelegateMediator * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559B58;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKCameraDelegateMediator * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559B58;

  return a1;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEN3gdc2tf8TaskData6StaticENSB_17StaticWithContextENSB_12StaticModuleENSB_13DynamicModuleENSB_13ModuleFactoryEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSI_1EJS8_SC_SD_SE_SF_SG_EEEEEEDcSK_DpT0_(uint64_t a1, void *a2)
{
  uint64_t result = a2[3];
  if ((void *)result == a2) {
    return (*(uint64_t (**)(void *))(*a2 + 32))(a2);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEN3gdc2tf8TaskData6StaticENSB_17StaticWithContextENSB_12StaticModuleENSB_13DynamicModuleENSB_13ModuleFactoryEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSI_1EJS8_SC_SD_SE_SF_SG_EEEEEEDcSK_DpT0_(uint64_t a1, void *a2)
{
  uint64_t v3 = a2[7];
  a2[7] = 0;
  if (v3)
  {
    geo::Pool<geo::IntrusiveNode<gdc::tf::TaskData>>::disposeElements(v3);
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v3 + 8));
    MEMORY[0x1A6239270](v3, 0x1020C407A7143E5);
  }
  os_signpost_id_t v4 = (void *)a2[4];
  if (v4)
  {
    a2[5] = v4;
    operator delete(v4);
  }
  uint64_t result = a2[3];
  if ((void *)result == a2)
  {
    uint64_t v7 = *(uint64_t (**)(void *))(*a2 + 32);
    return v7(a2);
  }
  else if (result)
  {
    os_signpost_id_t v6 = *(uint64_t (**)(void))(*(void *)result + 40);
    return v6();
  }
  return result;
}

void sub_1A23A2A44(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEN3gdc2tf8TaskData6StaticENSB_17StaticWithContextENSB_12StaticModuleENSB_13DynamicModuleENSB_13ModuleFactoryEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSI_1EJS8_SC_SD_SE_SF_SG_EEEEEEDcSK_DpT0_(uint64_t a1, void *a2)
{
  uint64_t result = a2[3];
  if ((void *)result == a2) {
    return (*(uint64_t (**)(void *))(*a2 + 32))(a2);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void std::__function::__func<md::MeshRendererModule,std::allocator<md::MeshRendererModule>,ecs2::ModuleDescriptor ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF519E08;
}

void *std::__function::__func<md::MeshRendererModule,std::allocator<md::MeshRendererModule>,ecs2::ModuleDescriptor ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF519E08;
  return result;
}

void std::__function::__func<md::MeshRendererModule,std::allocator<md::MeshRendererModule>,ecs2::ModuleDescriptor ()(void)>::~__func()
{
}

void std::__function::__func<md::MapEngineFrameModule,std::allocator<md::MapEngineFrameModule>,ecs2::ModuleDescriptor ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF519E50;
}

void *std::__function::__func<md::MapEngineFrameModule,std::allocator<md::MapEngineFrameModule>,ecs2::ModuleDescriptor ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF519E50;
  return result;
}

void std::__function::__func<md::MapEngineFrameModule,std::allocator<md::MapEngineFrameModule>,ecs2::ModuleDescriptor ()(void)>::~__func()
{
}

void std::__function::__func<md::BuildFrameGraphModule,std::allocator<md::BuildFrameGraphModule>,ecs2::ModuleDescriptor ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF519E98;
}

void *std::__function::__func<md::BuildFrameGraphModule,std::allocator<md::BuildFrameGraphModule>,ecs2::ModuleDescriptor ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF519E98;
  return result;
}

void std::__function::__func<md::BuildFrameGraphModule,std::allocator<md::BuildFrameGraphModule>,ecs2::ModuleDescriptor ()(void)>::~__func()
{
}

void std::__function::__func<md::LegacyLayoutModule,std::allocator<md::LegacyLayoutModule>,ecs2::ModuleDescriptor ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF519DC0;
}

void *std::__function::__func<md::LegacyLayoutModule,std::allocator<md::LegacyLayoutModule>,ecs2::ModuleDescriptor ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF519DC0;
  return result;
}

void std::__function::__func<md::LegacyLayoutModule,std::allocator<md::LegacyLayoutModule>,ecs2::ModuleDescriptor ()(void)>::~__func()
{
}

void std::__function::__func<md::EncodeModule,std::allocator<md::EncodeModule>,ecs2::ModuleDescriptor ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF519D78;
}

void *std::__function::__func<md::EncodeModule,std::allocator<md::EncodeModule>,ecs2::ModuleDescriptor ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF519D78;
  return result;
}

void std::__function::__func<md::EncodeModule,std::allocator<md::EncodeModule>,ecs2::ModuleDescriptor ()(void)>::~__func()
{
}

void geo::_retain_ptr<_MapEngineRenderQueueSource * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559C98;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<_MapEngineRenderQueueSource * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559C98;

  return a1;
}

void *std::function<void ()(geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> const&,VKOverlayLevel)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::MapEngine::~MapEngine()::$_0,std::allocator<md::MapEngine::~MapEngine()::$_0>,void ()(geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> const&,VKOverlayLevel)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = [*(id *)(a2 + 8) customTileProvider];

  if (v3)
  {
    os_signpost_id_t v4 = *(void **)(a2 + 8);
    [v4 setRunLoopController:0];
  }
}

void std::__function::__func<md::MapEngine::~MapEngine()::$_0,std::allocator<md::MapEngine::~MapEngine()::$_0>,void ()(geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> const&,VKOverlayLevel)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF579E78;
}

void *std::__function::__func<md::MapEngine::~MapEngine()::$_0,std::allocator<md::MapEngine::~MapEngine()::$_0>,void ()(geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> const&,VKOverlayLevel)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF579E78;
  return result;
}

void std::__function::__func<md::MapEngine::~MapEngine()::$_0,std::allocator<md::MapEngine::~MapEngine()::$_0>,void ()(geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> const&,VKOverlayLevel)>::~__func()
{
}

void *std::__function::__func<md::MapEngine::_produceRenderQueue(void)::$_1,std::allocator<md::MapEngine::_produceRenderQueue(void)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF579770;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MapEngine::_produceRenderQueue(void)::$_1,std::allocator<md::MapEngine::_produceRenderQueue(void)::$_1>,void ()(void)>::~__func()
{
}

id ___ZZN2md9MapEngine19_produceRenderQueueEvENK3__0clEmdN3ggl28RenderTransactionErrorStatusE_block_invoke(uint64_t a1)
{
  void v7[3] = *MEMORY[0x1E4F143B8];
  v7[0] = MEMORY[0x1E4F1CC38];
  v6[0] = @"AccessRevoked";
  v6[1] = @"MapPurpose";
  uint64_t v1 = a1 + 32;
  uint64_t v2 = [NSNumber numberWithInt:*(unsigned int *)(*(void *)(a1 + 32) + 8)];
  v7[1] = v2;
  v6[2] = @"MapMode";
  uint64_t v3 = [NSNumber numberWithInt:*(unsigned int *)(*(void *)v1 + 4)];
  void v7[2] = v3;
  os_signpost_id_t v4 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v7 forKeys:v6 count:3];

  return v4;
}

void sub_1A23A3070(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

id ___ZZN2md9MapEngine19_produceRenderQueueEvENK3__0clEmdN3ggl28RenderTransactionErrorStatusE_block_invoke_662(uint64_t a1)
{
  void v7[3] = *MEMORY[0x1E4F143B8];
  v7[0] = MEMORY[0x1E4F1CC28];
  v6[0] = @"AccessRevoked";
  v6[1] = @"MapPurpose";
  uint64_t v1 = a1 + 32;
  uint64_t v2 = [NSNumber numberWithInt:*(unsigned int *)(*(void *)(a1 + 32) + 8)];
  v7[1] = v2;
  v6[2] = @"MapMode";
  uint64_t v3 = [NSNumber numberWithInt:*(unsigned int *)(*(void *)v1 + 4)];
  void v7[2] = v3;
  os_signpost_id_t v4 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v7 forKeys:v6 count:3];

  return v4;
}

void sub_1A23A319C(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c56_ZTSNSt3__110shared_ptrIN2md9MapEngine13AnalyticsInfoEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_ea8_32c56_ZTSNSt3__110shared_ptrIN2md9MapEngine13AnalyticsInfoEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<md::MapEngine::_produceRenderQueue(void)::$_0,std::allocator<md::MapEngine::_produceRenderQueue(void)::$_0>,void ()(unsigned long,double,ggl::RenderTransactionErrorStatus)>::destroy(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  os_signpost_id_t v4 = (std::__shared_weak_count *)a1[4];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (v5)
  {
    std::__shared_weak_count::__release_weak(v5);
  }
}

void *std::__function::__func<md::MapEngine::_produceRenderQueue(void)::$_0,std::allocator<md::MapEngine::_produceRenderQueue(void)::$_0>,void ()(unsigned long,double,ggl::RenderTransactionErrorStatus)>::__clone(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = &unk_1EF579728;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = result[4];
  a2[3] = result[3];
  a2[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = result[6];
  a2[5] = result[5];
  a2[6] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = result[8];
  a2[7] = result[7];
  a2[8] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
  }
  a2[9] = result[9];
  return result;
}

void *std::__function::__func<md::MapEngine::_produceRenderQueue(void)::$_0,std::allocator<md::MapEngine::_produceRenderQueue(void)::$_0>,void ()(unsigned long,double,ggl::RenderTransactionErrorStatus)>::__clone(void *a1)
{
  uint64_t result = operator new(0x50uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  void *result = &unk_1EF579728;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a1[4];
  result[3] = a1[3];
  result[4] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = a1[6];
  result[5] = a1[5];
  result[6] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = a1[8];
  result[7] = a1[7];
  result[8] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 16), 1uLL, memory_order_relaxed);
  }
  result[9] = a1[9];
  return result;
}

void std::__function::__func<md::MapEngine::_produceRenderQueue(void)::$_0,std::allocator<md::MapEngine::_produceRenderQueue(void)::$_0>,void ()(unsigned long,double,ggl::RenderTransactionErrorStatus)>::~__func(void *a1)
{
  *a1 = &unk_1EF579728;
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[4];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::MapEngine::_produceRenderQueue(void)::$_0,std::allocator<md::MapEngine::_produceRenderQueue(void)::$_0>,void ()(unsigned long,double,ggl::RenderTransactionErrorStatus)>::~__func(void *a1)
{
  *a1 = &unk_1EF579728;
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[4];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1;
}

uint64_t md::MapEngine::renderSceneInContextSync(md::MapEngine *this, CGContext *a2, double a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  __int16 v16 = a2;
  [*((id *)this + 105) size];
  char v7 = *((unsigned char *)this + 1177);
  if (v7) {
    char v7 = *((unsigned char *)this + 1178) == 0;
  }
  uint64_t result = 0;
  if ((v7 & 1) == 0 && !*((unsigned char *)this + 1176))
  {
    double v9 = v6 * v5;
    if ([*((id *)this + 105) hasRenderTarget])
    {
      if (v9 <= 0.0) {
        return 0;
      }
    }
    else
    {
      uint64_t result = 0;
      if (*((void *)this + 150) != 1 || v9 <= 0.0) {
        return result;
      }
    }
    unsigned __int8 v10 = atomic_load((unsigned __int8 *)this + 1181);
    if (v10) {
      return 0;
    }
    if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
    }
    uint64_t v11 = (id)GEOGetVectorKitPerformanceLog_log;
    if (os_signpost_enabled(v11))
    {
      unsigned int v12 = md::MapEngine::canRenderAsync(this);

      if (v12)
      {
        if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
        }
        uint64_t v13 = (id)GEOGetVectorKitPerformanceLog_log;
        if (os_signpost_enabled(v13))
        {
          *(_WORD *)unint64_t v15 = 0;
          _os_signpost_emit_with_name_impl(&dword_1A1780000, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "ForceSyncRender", "", v15, 2u);
        }
      }
    }
    else
    {
    }
    md::HomeQueueScheduler::waitForSynchronization(*((md::HomeQueueScheduler **)this + 567), "BOOL md::MapEngine::renderSceneInContextSync(CGContext *, double)");
    atomic_store(1u, (unsigned __int8 *)this + 1181);
    md::MapEngine::runUpdatePhase(this, a3, 0);
    uint64_t v14 = *(void *)(*((void *)this + 1) + 16);
    v17[0] = &unk_1EF579800;
    v17[1] = this;
    void v17[2] = &v16;
    uint64_t v18 = v17;
    geo::TaskQueue::barrierSync(v14, v17);
    if (v18 == v17)
    {
      (*(void (**)(void *))(v17[0] + 32))(v17);
    }
    else if (v18)
    {
      (*(void (**)(void))(*v18 + 40))();
    }
    atomic_store(0, (unsigned __int8 *)this + 1181);
    return 1;
  }
  return result;
}

void sub_1A23A3788(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23A3798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::MapEngine::renderSceneInContextSync(CGContext *,double)::$_0,std::allocator<md::MapEngine::renderSceneInContextSync(CGContext *,double)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 8) + 824) drawInContext:**(void **)(a1 + 16) registry:*(void *)(a1 + 8) + 136];
}

__n128 std::__function::__func<md::MapEngine::renderSceneInContextSync(CGContext *,double)::$_0,std::allocator<md::MapEngine::renderSceneInContextSync(CGContext *,double)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF579800;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::MapEngine::renderSceneInContextSync(CGContext *,double)::$_0,std::allocator<md::MapEngine::renderSceneInContextSync(CGContext *,double)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF579800;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::MapEngine::renderSceneInContextSync(CGContext *,double)::$_0,std::allocator<md::MapEngine::renderSceneInContextSync(CGContext *,double)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<md::MapEngine::prune(md::PruneLevel)::$_0,std::allocator<md::MapEngine::prune(md::PruneLevel)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF579848;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::MapEngine::prune(md::PruneLevel)::$_0,std::allocator<md::MapEngine::prune(md::PruneLevel)::$_0>,void ()(void)>::~__func()
{
}

char *md::MapEngine::createDebugNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2;
  uint64_t v4 = (void *)a1;
  uint64_t v342 = *MEMORY[0x1E4F143B8];
  strcpy((char *)a1, "Map Engine");
  *(_WORD *)(a1 + 23) = 10;
  *(_OWORD *)(a1 + 47) = 0u;
  *(_OWORD *)(a1 + 63) = 0u;
  *(_OWORD *)(a1 + 79) = 0u;
  *(unsigned char *)(a1 + 95) = 0;
  uint64_t v5 = *(unsigned __int8 *)(a2 + 1176);
  *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 9;
  strcpy((char *)__p, "Is Hidden");
  int v301 = 0;
  memset(&v300[4], 0, 24);
  v300[0] = v5;
  gdc::DebugTreeNode::addProperty(a1, (uint64_t)__p, (uint64_t)v300);
  uint64_t v6 = *(unsigned __int8 *)(v3 + 1177);
  *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 16;
  strcpy((char *)__p, "Is In Background");
  int v299 = 0;
  memset(&v298[4], 0, 24);
  v298[0] = v6;
  gdc::DebugTreeNode::addProperty((uint64_t)v4, (uint64_t)__p, (uint64_t)v298);
  uint64_t v7 = *(unsigned __int8 *)(v3 + 1178);
  *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 21;
  strcpy((char *)__p, "Renders in Background");
  int v297 = 0;
  memset(&v296[4], 0, 24);
  v296[0] = v7;
  gdc::DebugTreeNode::addProperty((uint64_t)v4, (uint64_t)__p, (uint64_t)v296);
  *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 12;
  strcpy((char *)__p, "Needs Layout");
  unsigned __int8 v8 = atomic_load((unsigned __int8 *)(v3 + 1179));
  int v295 = 0;
  memset(&v294[4], 0, 24);
  v294[0] = v8 & 1;
  gdc::DebugTreeNode::addProperty((uint64_t)v4, (uint64_t)__p, (uint64_t)v294);
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 21;
  strcpy((char *)__p, "Needs Run Loop Update");
  unsigned __int8 v9 = atomic_load((unsigned __int8 *)(v3 + 1180));
  int v293 = 0;
  memset(&v292[4], 0, 24);
  v292[0] = v9 & 1;
  gdc::DebugTreeNode::addProperty((uint64_t)v4, (uint64_t)__p, (uint64_t)v292);
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 13;
  strcpy((char *)__p, "Render Target");
  ChildNode = gdc::DebugTreeNode::createChildNode((uint64_t)v4, (long long *)__p);
  uint64_t v11 = *(void **)(v3 + 840);
  if (v11)
  {
    *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 17;
    strcpy((char *)__p, "Has Render Target");
    unsigned int v12 = [v11 hasRenderTarget];
    int v291 = 0;
    memset(&v290[4], 0, 24);
    v290[0] = v12;
    gdc::DebugTreeNode::addProperty((uint64_t)v4, (uint64_t)__p, (uint64_t)v290);
    uint64_t v13 = *(void **)(v3 + 840);
    *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 13;
    strcpy((char *)__p, "Content Scale");
    [v13 contentScale];
    uint64_t v287 = 0;
    uint64_t v286 = 0;
    uint64_t v288 = 0;
    int v289 = 2;
    uint64_t v285 = v14;
    gdc::DebugTreeNode::addProperty((uint64_t)v4, (uint64_t)__p, (uint64_t)v284);
    unint64_t v15 = *(void **)(v3 + 840);
    *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 12;
    strcpy((char *)__p, "Multi Sample");
    unsigned int v16 = [v15 multiSample];
    int v283 = 0;
    memset(&v282[4], 0, 24);
    v282[0] = v16;
    gdc::DebugTreeNode::addProperty((uint64_t)v4, (uint64_t)__p, (uint64_t)v282);
    uint64_t v17 = *(void **)(v3 + 840);
    *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 16;
    strcpy((char *)__p, "Should Rasterize");
    unsigned int v18 = [v17 shouldRasterize];
    int v281 = 0;
    memset(&v280[4], 0, 24);
    v280[0] = v18;
    gdc::DebugTreeNode::addProperty((uint64_t)v4, (uint64_t)__p, (uint64_t)v280);
    *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 11;
    strcpy((char *)__p, "Size Points");
    uint64_t v19 = gdc::DebugTreeNode::createChildNode((uint64_t)ChildNode, (long long *)__p);
    uint64_t v20 = *(void **)(v3 + 840);
    *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 5;
    strcpy((char *)__p, "Width");
    [v20 size];
    uint64_t v277 = 0;
    uint64_t v276 = 0;
    uint64_t v278 = 0;
    int v279 = 2;
    uint64_t v275 = v21;
    gdc::DebugTreeNode::addProperty((uint64_t)v19, (uint64_t)__p, (uint64_t)v274);
    uint64_t v22 = *(void **)(v3 + 840);
    *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 6;
    strcpy((char *)__p, "Height");
    [v22 size];
    uint64_t v271 = 0;
    uint64_t v270 = 0;
    uint64_t v272 = 0;
    int v273 = 2;
    uint64_t v269 = v23;
    gdc::DebugTreeNode::addProperty((uint64_t)v19, (uint64_t)__p, (uint64_t)v268);
    *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 11;
    strcpy((char *)__p, "Size Pixels");
    uint64_t v24 = gdc::DebugTreeNode::createChildNode((uint64_t)ChildNode, (long long *)__p);
    uint64_t v25 = *(void **)(v3 + 840);
    *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 5;
    strcpy((char *)__p, "Width");
    [v25 sizeInPixels];
    uint64_t v265 = 0;
    uint64_t v264 = 0;
    uint64_t v266 = 0;
    int v267 = 2;
    uint64_t v263 = v26;
    gdc::DebugTreeNode::addProperty((uint64_t)v24, (uint64_t)__p, (uint64_t)v262);
    uint64_t v27 = *(void **)(v3 + 840);
    *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 6;
    strcpy((char *)__p, "Height");
    [v27 sizeInPixels];
    uint64_t v259 = 0;
    uint64_t v258 = 0;
    uint64_t v260 = 0;
    int v261 = 2;
    uint64_t v257 = v28;
    gdc::DebugTreeNode::addProperty((uint64_t)v24, (uint64_t)__p, (uint64_t)v256);
  }
  *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 19;
  strcpy((char *)__p, "Map Engine Settings");
  uint64_t v242 = v4;
  uint64_t v29 = gdc::DebugTreeNode::createChildNode((uint64_t)v4, (long long *)__p);
  uint64_t v30 = *(void *)(v3 + 1128);
  uint64_t v243 = v3;
  if (v30)
  {
    uint64_t v31 = (uint64_t)v29;
    *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 18;
    strcpy((char *)__p, "HasUpdatedSettings");
    BOOL v32 = *(void *)(v30 + 40) != 0;
    int v255 = 0;
    memset(&v254[4], 0, 24);
    v254[0] = v32;
    gdc::DebugTreeNode::addProperty((uint64_t)v29, (uint64_t)__p, (uint64_t)v254);
    for (uint64_t i = &md::MapEngineSettingList; i != md::NeedsLayoutReasonList; ++i)
    {
      uint64_t v34 = *i;
      uint64_t v35 = "<Invalid>";
      if (v34 <= 0x27) {
        uint64_t v35 = off_1E5A92DE8[v34];
      }
      size_t v36 = strlen(v35);
      if (v36 > 0x7FFFFFFFFFFFFFF7) {
        abort();
      }
      std::string::size_type v37 = v36;
      if (v36 >= 0x17)
      {
        uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v36 | 7) != 0x17) {
          uint64_t v39 = v36 | 7;
        }
        uint64_t v40 = v39 + 1;
        unint64_t v38 = (std::string *)operator new(v39 + 1);
        __p[0].__r_.__value_.__l.__size_ = v37;
        __p[0].__r_.__value_.__r.__words[2] = v40 | 0x8000000000000000;
        __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
      }
      else
      {
        *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = v36;
        unint64_t v38 = __p;
        if (!v36) {
          goto LABEL_20;
        }
      }
      memcpy(v38, v35, v37);
LABEL_20:
      v38->__r_.__value_.__s.__data_[v37] = 0;
      uint64_t v3 = v243;
      uint64_t v41 = *(unsigned __int8 ***)(v243 + 1128);
      unint64_t v42 = *v41;
      uint64_t v43 = v41[1];
      if (v42 != v43)
      {
        while (v34 != *v42)
        {
          v42 += 16;
          if (v42 == v43) {
            goto LABEL_26;
          }
        }
      }
      if (v42 == v43) {
LABEL_26:
      }
        uint64_t v44 = 0;
      else {
        uint64_t v44 = *((void *)v42 + 1);
      }
      memset(&v252[4], 0, 24);
      int v253 = 0;
      v252[0] = v44;
      gdc::DebugTreeNode::addProperty(v31, (uint64_t)__p, (uint64_t)v252);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[0].__r_.__value_.__l.__data_);
      }
    }
  }
  uint64_t v45 = *(void *)(v3 + 1184);
  if (!v45) {
    goto LABEL_48;
  }
  uint64_t v46 = (char *)operator new(0x20uLL);
  strcpy(v46, "Map Engine Configuration");
  std::string::__init_copy_ctor_external(__p, v46, 0x18uLL);
  __p[1].__r_.__value_.__s.__data_[0] = 0;
  *(_OWORD *)((char *)&__p[1].__r_.__value_.__r.__words[2] + 7) = 0u;
  *(_OWORD *)((char *)&__p[2].__r_.__value_.__r.__words[1] + 7) = 0u;
  *(_OWORD *)((char *)__p[3].__r_.__value_.__r.__words + 7) = 0u;
  *((unsigned char *)&__p[3].__r_.__value_.__s + 23) = 0;
  operator delete(v46);
  HIBYTE(__len[2]) = 18;
  strcpy((char *)__len, "Configuration Type");
  unint64_t v47 = *(unsigned __int8 *)(v45 + 8);
  uint64_t v48 = "<Invalid>";
  if (v47 <= 4) {
    uint64_t v48 = off_1E5A990C0[v47];
  }
  *((void *)&v337 + 1) = 0;
  long long v338 = 0uLL;
  LODWORD(v339) = 4;
  std::string::__assign_external((std::string *)((char *)&v337 + 8), v48);
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)__len, (uint64_t)&v336);
  if (SHIBYTE(v338) < 0) {
    operator delete(*((void **)&v337 + 1));
  }
  int v49 = *(unsigned __int8 *)(v45 + 9);
  HIBYTE(v328[2]) = 13;
  strcpy((char *)v328, "Renderer Type");
  uint64_t v50 = "Realistic";
  if (v49 != 1) {
    uint64_t v50 = "<Invalid>";
  }
  if (v49) {
    uint64_t v51 = v50;
  }
  else {
    uint64_t v51 = "Cartographic";
  }
  memset(&v334, 0, sizeof(v334));
  int v335 = 4;
  std::string::__assign_external(&v334, v51);
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)v328, (uint64_t)__len);
  if (SHIBYTE(v334.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v334.__r_.__value_.__l.__data_);
  }
  gdc::DebugTreeNode::addChildNode(v4, (long long *)__p);
  std::string::pointer data = __p[3].__r_.__value_.__l.__data_;
  uint64_t v3 = v243;
  if (__p[3].__r_.__value_.__r.__words[0])
  {
    std::string::size_type size = __p[3].__r_.__value_.__l.__size_;
    std::string::pointer v54 = __p[3].__r_.__value_.__l.__data_;
    if (__p[3].__r_.__value_.__l.__size_ != __p[3].__r_.__value_.__r.__words[0])
    {
      do
      {
        size -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(size);
      }
      while ((std::string::pointer)size != data);
      std::string::pointer v54 = __p[3].__r_.__value_.__l.__data_;
    }
    __p[3].__r_.__value_.__l.__size_ = (std::string::size_type)data;
    operator delete(v54);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__p[2]);
  if (SHIBYTE(__p[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p[1].__r_.__value_.__l.__data_);
    if ((SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_48;
    }
LABEL_296:
    operator delete(__p[0].__r_.__value_.__l.__data_);
    goto LABEL_48;
  }
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_296;
  }
LABEL_48:
  uint64_t v55 = *(void *)(v3 + 1192);
  if (!v55) {
    goto LABEL_235;
  }
  strcpy((char *)__p, "Map Engine Mpde");
  *(_WORD *)((char *)&__p[0].__r_.__value_.__r.__words[2] + 7) = 15;
  *(_OWORD *)((char *)&__p[1].__r_.__value_.__r.__words[2] + 7) = 0u;
  *(_OWORD *)((char *)&__p[2].__r_.__value_.__r.__words[1] + 7) = 0u;
  *(_OWORD *)((char *)__p[3].__r_.__value_.__r.__words + 7) = 0u;
  *((unsigned char *)&__p[3].__r_.__value_.__s + 23) = 0;
  unint64_t v56 = *(unsigned __int8 *)(v55 + 48);
  HIBYTE(__len[2]) = 4;
  strcpy((char *)__len, "Type");
  if (v56 > 0x12) {
    uint64_t v57 = "<Invalid>";
  }
  else {
    uint64_t v57 = off_1E5A92CE0[v56];
  }
  *((void *)&v337 + 1) = 0;
  long long v338 = 0uLL;
  LODWORD(v339) = 4;
  std::string::__assign_external((std::string *)((char *)&v337 + 8), v57);
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)__len, (uint64_t)&v336);
  if (SHIBYTE(v338) < 0) {
    operator delete(*((void **)&v337 + 1));
  }
  size_t v58 = *(unsigned __int8 *)(v55 + 49);
  HIBYTE(v328[2]) = 19;
  strcpy((char *)v328, "Animate Transitions");
  int v335 = 0;
  memset(&v334, 0, sizeof(v334));
  __len[0] = v58;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)v328, (uint64_t)__len);
  uint64_t v59 = *(unsigned int *)(v55 + 52);
  v325[23] = 16;
  strcpy(v325, "Default Max Zoom");
  uint64_t v331 = 0;
  uint64_t v330 = 0;
  int v332 = 1;
  uint64_t v329 = 0;
  v328[1] = v59;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)v325, (uint64_t)v328);
  uint64_t v60 = *(uint64_t **)(v55 + 96);
  uint64_t v319 = 0;
  uint64_t v318 = 0;
  v320 = 0;
  uint64_t v238 = v55;
  if (!v60)
  {
    uint64_t v110 = 0;
    uint64_t v99 = 0;
    goto LABEL_153;
  }
  do
  {
    while (1)
    {
      unint64_t v61 = *((unsigned __int16 *)v60 + 8);
      uint64_t v62 = "<Invalid>";
      if (v61 <= 0x51) {
        uint64_t v62 = off_1E5A95780[v61];
      }
      size_t v63 = strlen(v62);
      if (v63 > 0x7FFFFFFFFFFFFFF7) {
        abort();
      }
      size_t v64 = v63;
      if (v63 >= 0x17)
      {
        uint64_t v66 = (v63 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v63 | 7) != 0x17) {
          uint64_t v66 = v63 | 7;
        }
        uint64_t v67 = v66 + 1;
        p_dst = (long long *)operator new(v66 + 1);
        int64_t v313 = v67 | 0x8000000000000000;
        *(void *)&long long __dst = p_dst;
        *((void *)&__dst + 1) = v64;
LABEL_67:
        memmove(p_dst, v62, v64);
        goto LABEL_68;
      }
      HIBYTE(v313) = v63;
      p_dst = &__dst;
      if (v63) {
        goto LABEL_67;
      }
LABEL_68:
      *((unsigned char *)p_dst + v64) = 0;
      memset(&v306, 0, sizeof(v306));
      int v68 = *((unsigned __int8 *)v60 + 18);
      if (!*((unsigned char *)v60 + 18))
      {
        *((unsigned char *)&v306.__r_.__value_.__s + 23) = 8;
        std::string::size_type v69 = 0x6465726975716572;
        goto LABEL_74;
      }
      if (v68 == 1)
      {
        *((unsigned char *)&v306.__r_.__value_.__s + 23) = 8;
        std::string::size_type v69 = 0x6C616E6F6974706FLL;
LABEL_74:
        v306.__r_.__value_.__r.__words[0] = v69;
        goto LABEL_75;
      }
      if (v68 == 2)
      {
        *((unsigned char *)&v306.__r_.__value_.__s + 23) = 7;
        qmemcpy(&v306, "allowed", 7);
      }
LABEL_75:
      unint64_t v70 = *((unsigned __int16 *)v60 + 10);
      uint64_t v71 = "<Invalid>";
      if (v70 <= 8) {
        uint64_t v71 = off_1E5A95718[v70];
      }
      size_t v72 = strlen(v71);
      if (v72 > 0x7FFFFFFFFFFFFFF7) {
        abort();
      }
      std::string::size_type v73 = v72;
      if (v72 >= 0x17)
      {
        uint64_t v75 = (v72 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v72 | 7) != 0x17) {
          uint64_t v75 = v72 | 7;
        }
        uint64_t v76 = v75 + 1;
        uint64_t v74 = operator new(v75 + 1);
        v311.__r_.__value_.__r.__words[2] = v76 | 0x8000000000000000;
        v311.__r_.__value_.__r.__words[0] = (std::string::size_type)v74;
        v311.__r_.__value_.__l.__size_ = v73;
LABEL_84:
        memcpy(v74, v71, v73);
        goto LABEL_85;
      }
      *((unsigned char *)&v311.__r_.__value_.__s + 23) = v72;
      uint64_t v74 = &v311;
      if (v72) {
        goto LABEL_84;
      }
LABEL_85:
      *((unsigned char *)v74 + v73) = 0;
      int v77 = SHIBYTE(v313);
      if (v313 >= 0) {
        size_t v78 = HIBYTE(v313);
      }
      else {
        size_t v78 = *((void *)&__dst + 1);
      }
      unint64_t v79 = v78 + 1;
      if (v78 + 1 > 0x7FFFFFFFFFFFFFF7) {
        abort();
      }
      if (v79 >= 0x17)
      {
        uint64_t v81 = (v79 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v79 | 7) != 0x17) {
          uint64_t v81 = v79 | 7;
        }
        uint64_t v82 = v81 + 1;
        uint64_t v80 = (char *)operator new(v81 + 1);
        v302.__r_.__value_.__r.__words[2] = v82 | 0x8000000000000000;
        v302.__r_.__value_.__r.__words[0] = (std::string::size_type)v80;
        v302.__r_.__value_.__l.__size_ = v78 + 1;
      }
      else
      {
        memset(&v302, 0, sizeof(v302));
        uint64_t v80 = (char *)&v302;
        *((unsigned char *)&v302.__r_.__value_.__s + 23) = v78 + 1;
        if (!v78) {
          goto LABEL_99;
        }
      }
      uint64_t v83 = v77 >= 0 ? &__dst : (long long *)__dst;
      memmove(v80, v83, v78);
LABEL_99:
      *(_WORD *)&v80[v78] = 32;
      if ((v306.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v84 = &v306;
      }
      else {
        uint64_t v84 = (std::string *)v306.__r_.__value_.__r.__words[0];
      }
      if ((v306.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v85 = HIBYTE(v306.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v85 = v306.__r_.__value_.__l.__size_;
      }
      uint64_t v86 = std::string::append(&v302, (const std::string::value_type *)v84, v85);
      std::string::size_type v87 = v86->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v303.__r_.__value_.__l.__data_ = *(_OWORD *)&v86->__r_.__value_.__l.__data_;
      v303.__r_.__value_.__r.__words[2] = v87;
      v86->__r_.__value_.__l.__size_ = 0;
      v86->__r_.__value_.__r.__words[2] = 0;
      v86->__r_.__value_.__r.__words[0] = 0;
      uint64_t v88 = std::string::append(&v303, " ", 1uLL);
      std::string::size_type v89 = v88->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v304.__r_.__value_.__l.__data_ = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
      v304.__r_.__value_.__r.__words[2] = v89;
      v88->__r_.__value_.__l.__size_ = 0;
      v88->__r_.__value_.__r.__words[2] = 0;
      v88->__r_.__value_.__r.__words[0] = 0;
      if ((v311.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v90 = &v311;
      }
      else {
        uint64_t v90 = (std::string *)v311.__r_.__value_.__r.__words[0];
      }
      if ((v311.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v91 = HIBYTE(v311.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v91 = v311.__r_.__value_.__l.__size_;
      }
      uint64_t v92 = std::string::append(&v304, (const std::string::value_type *)v90, v91);
      uint64_t v94 = (void *)v92->__r_.__value_.__r.__words[0];
      size_t v93 = v92->__r_.__value_.__l.__size_;
      v305[0] = v92->__r_.__value_.__r.__words[2];
      *(_DWORD *)((char *)v305 + 3) = *(_DWORD *)((char *)&v92->__r_.__value_.__r.__words[2] + 3);
      int v95 = SHIBYTE(v92->__r_.__value_.__r.__words[2]);
      v92->__r_.__value_.__r.__words[0] = 0;
      v92->__r_.__value_.__l.__size_ = 0;
      v92->__r_.__value_.__r.__words[2] = 0;
      memset(&v326, 0, sizeof(v326));
      int v327 = 4;
      if (v95 < 0)
      {
        std::string::__assign_no_alias<true>(&v326, v94, v93);
      }
      else
      {
        v326.__r_.__value_.__r.__words[0] = (std::string::size_type)v94;
        v326.__r_.__value_.__l.__size_ = v93;
        LODWORD(v326.__r_.__value_.__r.__words[2]) = v305[0];
        *(_DWORD *)((char *)&v326.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v305 + 3);
        *((unsigned char *)&v326.__r_.__value_.__s + 23) = v95;
      }
      uint64_t v96 = v319;
      if (v319 < (void **)v320)
      {
        long long v97 = *(_OWORD *)v325;
        *(_OWORD *)((char *)v319 + 9) = *(_OWORD *)&v325[9];
        *(_OWORD *)uint64_t v96 = v97;
        long long v98 = *(_OWORD *)&v326.__r_.__value_.__l.__data_;
        v96[6] = (void *)v326.__r_.__value_.__r.__words[2];
        *((_OWORD *)v96 + 2) = v98;
        memset(&v326, 0, sizeof(v326));
        *((_DWORD *)v96 + 14) = v327;
        uint64_t v99 = v96 + 8;
        goto LABEL_132;
      }
      uint64_t v100 = (char *)v318;
      uint64_t v101 = ((char *)v319 - (unsigned char *)v318) >> 6;
      unint64_t v102 = v101 + 1;
      if ((unint64_t)(v101 + 1) >> 58) {
        abort();
      }
      uint64_t v103 = v320 - (unsigned char *)v318;
      if ((v320 - (unsigned char *)v318) >> 5 > v102) {
        unint64_t v102 = v103 >> 5;
      }
      if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFC0) {
        unint64_t v104 = 0x3FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v104 = v102;
      }
      if (v104 >> 58) {
LABEL_404:
      }
        std::__throw_bad_array_new_length[abi:nn180100]();
      uint64_t v105 = (char *)operator new(v104 << 6);
      uint64_t v106 = &v105[64 * v101];
      *(_OWORD *)uint64_t v106 = *(_OWORD *)v325;
      *(_OWORD *)(v106 + 9) = *(_OWORD *)&v325[9];
      *(std::string *)(v106 + 32) = v326;
      *(_OWORD *)&v326.__r_.__value_.__l.__data_ = 0uLL;
      *((_DWORD *)v106 + 14) = v327;
      uint64_t v99 = (void **)(v106 + 64);
      v326.__r_.__value_.__r.__words[2] = 0;
      if (v96 == (void **)v100)
      {
        uint64_t v318 = v106;
        uint64_t v319 = (void **)(v106 + 64);
        v320 = &v105[64 * v104];
        if (v96) {
          goto LABEL_131;
        }
      }
      else
      {
        uint64_t v107 = (char *)v96;
        do
        {
          long long v108 = *((_OWORD *)v107 - 4);
          *(_OWORD *)(v106 - 55) = *(_OWORD *)(v107 - 55);
          *((_OWORD *)v106 - 4) = v108;
          long long v109 = *((_OWORD *)v107 - 2);
          *((void *)v106 - 2) = *((void *)v107 - 2);
          *((_OWORD *)v106 - 2) = v109;
          *((void *)v107 - 3) = 0;
          *((void *)v107 - 2) = 0;
          *((void *)v107 - 4) = 0;
          *((_DWORD *)v106 - 2) = *((_DWORD *)v107 - 2);
          v106 -= 64;
          v107 -= 64;
        }
        while (v107 != v100);
        uint64_t v318 = v106;
        uint64_t v319 = v99;
        v320 = &v105[64 * v104];
        do
        {
          if (*((char *)v96 - 9) < 0) {
            operator delete(*(v96 - 4));
          }
          v96 -= 8;
        }
        while (v96 != (void **)v100);
        uint64_t v96 = (void **)v100;
        if (v100) {
LABEL_131:
        }
          operator delete(v96);
      }
LABEL_132:
      uint64_t v319 = v99;
      if ((SHIBYTE(v326.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        break;
      }
      operator delete(v326.__r_.__value_.__l.__data_);
      if (v95 < 0) {
        goto LABEL_141;
      }
LABEL_134:
      if ((SHIBYTE(v304.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_135;
      }
LABEL_142:
      operator delete(v304.__r_.__value_.__l.__data_);
      if (SHIBYTE(v303.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_143;
      }
LABEL_136:
      if ((SHIBYTE(v302.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_137;
      }
LABEL_144:
      operator delete(v302.__r_.__value_.__l.__data_);
      if (SHIBYTE(v311.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_145;
      }
LABEL_138:
      if ((SHIBYTE(v306.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_146;
      }
LABEL_56:
      operator delete(v306.__r_.__value_.__l.__data_);
      if (v77 < 0) {
        goto LABEL_147;
      }
LABEL_57:
      uint64_t v60 = (uint64_t *)*v60;
      if (!v60) {
        goto LABEL_151;
      }
    }
    if ((v95 & 0x80000000) == 0) {
      goto LABEL_134;
    }
LABEL_141:
    operator delete(v94);
    if (SHIBYTE(v304.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_142;
    }
LABEL_135:
    if ((SHIBYTE(v303.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_136;
    }
LABEL_143:
    operator delete(v303.__r_.__value_.__l.__data_);
    if (SHIBYTE(v302.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_144;
    }
LABEL_137:
    if ((SHIBYTE(v311.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_138;
    }
LABEL_145:
    operator delete(v311.__r_.__value_.__l.__data_);
    if (SHIBYTE(v306.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_56;
    }
LABEL_146:
    if ((v77 & 0x80000000) == 0) {
      goto LABEL_57;
    }
LABEL_147:
    operator delete((void *)__dst);
    uint64_t v60 = (uint64_t *)*v60;
  }
  while (v60);
LABEL_151:
  uint64_t v110 = (void **)v318;
LABEL_153:
  v325[23] = 12;
  strcpy(v325, "MapDataTypes");
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)v325, (uint64_t *)&v318);
  while (v99 != v110)
  {
    if (*((char *)v99 - 9) < 0) {
      operator delete(*(v99 - 4));
    }
    v99 -= 8;
  }
  uint64_t v319 = v110;
  uint64_t v111 = *(uint64_t **)(v238 + 200);
  if (v111)
  {
    while (2)
    {
      long long __dst = 0uLL;
      int64_t v313 = 0;
      int v112 = *((unsigned __int8 *)v111 + 40);
      if (v112 == 2)
      {
        HIBYTE(v313) = 7;
        qmemcpy(&__dst, "allowed", 7);
      }
      else if (v112 == 1)
      {
        HIBYTE(v313) = 8;
        *(void *)&long long __dst = 0x6C616E6F6974706FLL;
      }
      else if (!*((unsigned char *)v111 + 40))
      {
        HIBYTE(v313) = 8;
        *(void *)&long long __dst = 0x6465726975716572;
      }
      std::string::size_type v113 = v111[4];
      if (v113 > 0x7FFFFFFFFFFFFFF7) {
        abort();
      }
      uint64_t v114 = (const void *)v111[3];
      if (v113 >= 0x17)
      {
        uint64_t v116 = (v113 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v113 | 7) != 0x17) {
          uint64_t v116 = v113 | 7;
        }
        uint64_t v117 = v116 + 1;
        uint64_t v115 = operator new(v116 + 1);
        v311.__r_.__value_.__r.__words[2] = v117 | 0x8000000000000000;
        v311.__r_.__value_.__r.__words[0] = (std::string::size_type)v115;
        v311.__r_.__value_.__l.__size_ = v113;
      }
      else
      {
        *((unsigned char *)&v311.__r_.__value_.__s + 23) = v111[4];
        uint64_t v115 = &v311;
        if (!v113)
        {
LABEL_176:
          v115[v113] = 0;
          uint64_t v118 = std::string::append(&v311, " ", 1uLL);
          std::string::size_type v119 = v118->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v306.__r_.__value_.__l.__data_ = *(_OWORD *)&v118->__r_.__value_.__l.__data_;
          v306.__r_.__value_.__r.__words[2] = v119;
          v118->__r_.__value_.__l.__size_ = 0;
          v118->__r_.__value_.__r.__words[2] = 0;
          v118->__r_.__value_.__r.__words[0] = 0;
          if (v313 >= 0) {
            uint64_t v120 = (const std::string::value_type *)&__dst;
          }
          else {
            uint64_t v120 = (const std::string::value_type *)__dst;
          }
          if (v313 >= 0) {
            std::string::size_type v121 = HIBYTE(v313);
          }
          else {
            std::string::size_type v121 = *((void *)&__dst + 1);
          }
          uint64_t v122 = std::string::append(&v306, v120, v121);
          uint64_t v124 = (void *)v122->__r_.__value_.__r.__words[0];
          size_t v123 = v122->__r_.__value_.__l.__size_;
          LODWORD(v304.__r_.__value_.__l.__data_) = v122->__r_.__value_.__r.__words[2];
          *(_DWORD *)((char *)v304.__r_.__value_.__r.__words + 3) = *(_DWORD *)((char *)&v122->__r_.__value_.__r.__words[2]
                                                                              + 3);
          int v125 = SHIBYTE(v122->__r_.__value_.__r.__words[2]);
          v122->__r_.__value_.__r.__words[0] = 0;
          v122->__r_.__value_.__l.__size_ = 0;
          v122->__r_.__value_.__r.__words[2] = 0;
          memset(&v326, 0, sizeof(v326));
          int v327 = 4;
          if (v125 < 0)
          {
            std::string::__assign_no_alias<true>(&v326, v124, v123);
          }
          else
          {
            v326.__r_.__value_.__r.__words[0] = (std::string::size_type)v124;
            v326.__r_.__value_.__l.__size_ = v123;
            LODWORD(v326.__r_.__value_.__r.__words[2]) = v304.__r_.__value_.__l.__data_;
            *(_DWORD *)((char *)&v326.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v304.__r_.__value_.__r.__words
                                                                                    + 3);
            *((unsigned char *)&v326.__r_.__value_.__s + 23) = v125;
          }
          uint64_t v126 = v319;
          if (v319 < (void **)v320)
          {
            long long v127 = *(_OWORD *)v325;
            *(_OWORD *)((char *)v319 + 9) = *(_OWORD *)&v325[9];
            *(_OWORD *)uint64_t v126 = v127;
            long long v128 = *(_OWORD *)&v326.__r_.__value_.__l.__data_;
            v126[6] = (void *)v326.__r_.__value_.__r.__words[2];
            *((_OWORD *)v126 + 2) = v128;
            memset(&v326, 0, sizeof(v326));
            *((_DWORD *)v126 + 14) = v327;
            uint64_t v110 = v126 + 8;
            goto LABEL_203;
          }
          uint64_t v129 = (void **)v318;
          uint64_t v130 = ((char *)v319 - (unsigned char *)v318) >> 6;
          unint64_t v131 = v130 + 1;
          if ((unint64_t)(v130 + 1) >> 58) {
            abort();
          }
          uint64_t v132 = v320 - (unsigned char *)v318;
          if ((v320 - (unsigned char *)v318) >> 5 > v131) {
            unint64_t v131 = v132 >> 5;
          }
          if ((unint64_t)v132 >= 0x7FFFFFFFFFFFFFC0) {
            unint64_t v133 = 0x3FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v133 = v131;
          }
          if (v133 >> 58) {
            goto LABEL_404;
          }
          uint64_t v134 = (char *)operator new(v133 << 6);
          uint64_t v135 = &v134[64 * v130];
          *(_OWORD *)uint64_t v135 = *(_OWORD *)v325;
          unint64_t v136 = &v134[64 * v133];
          *(_OWORD *)(v135 + 9) = *(_OWORD *)&v325[9];
          *(std::string *)(v135 + 32) = v326;
          *(_OWORD *)&v326.__r_.__value_.__l.__data_ = 0uLL;
          *((_DWORD *)v135 + 14) = v327;
          uint64_t v110 = (void **)(v135 + 64);
          v326.__r_.__value_.__r.__words[2] = 0;
          if (v126 == v129)
          {
            uint64_t v318 = v135;
            uint64_t v319 = (void **)(v135 + 64);
            v320 = &v134[64 * v133];
            uint64_t v4 = v242;
            if (v126) {
              goto LABEL_202;
            }
          }
          else
          {
            uint64_t v137 = v126;
            uint64_t v4 = v242;
            do
            {
              long long v138 = *((_OWORD *)v137 - 4);
              *(_OWORD *)(v135 - 55) = *(_OWORD *)((char *)v137 - 55);
              *((_OWORD *)v135 - 4) = v138;
              long long v139 = *((_OWORD *)v137 - 2);
              *((void *)v135 - 2) = *(v137 - 2);
              *((_OWORD *)v135 - 2) = v139;
              *(v137 - 3) = 0;
              *(v137 - 2) = 0;
              *(v137 - 4) = 0;
              *((_DWORD *)v135 - 2) = *((_DWORD *)v137 - 2);
              v135 -= 64;
              v137 -= 8;
            }
            while (v137 != v129);
            uint64_t v318 = v135;
            uint64_t v319 = v110;
            v320 = v136;
            do
            {
              if (*((char *)v126 - 9) < 0) {
                operator delete(*(v126 - 4));
              }
              v126 -= 8;
            }
            while (v126 != v129);
            uint64_t v126 = v129;
            if (v129) {
LABEL_202:
            }
              operator delete(v126);
          }
LABEL_203:
          uint64_t v319 = v110;
          if (SHIBYTE(v326.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v326.__r_.__value_.__l.__data_);
            if (v125 < 0) {
              goto LABEL_209;
            }
LABEL_205:
            if ((SHIBYTE(v306.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_206;
            }
LABEL_210:
            operator delete(v306.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v311.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_211;
            }
LABEL_160:
            operator delete(v311.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v313) & 0x80000000) == 0) {
              goto LABEL_161;
            }
          }
          else
          {
            if ((v125 & 0x80000000) == 0) {
              goto LABEL_205;
            }
LABEL_209:
            operator delete(v124);
            if (SHIBYTE(v306.__r_.__value_.__r.__words[2]) < 0) {
              goto LABEL_210;
            }
LABEL_206:
            if (SHIBYTE(v311.__r_.__value_.__r.__words[2]) < 0) {
              goto LABEL_160;
            }
LABEL_211:
            if ((SHIBYTE(v313) & 0x80000000) == 0)
            {
LABEL_161:
              uint64_t v111 = (uint64_t *)*v111;
              if (!v111) {
                goto LABEL_216;
              }
              continue;
            }
          }
          operator delete((void *)__dst);
          uint64_t v111 = (uint64_t *)*v111;
          if (!v111) {
            goto LABEL_216;
          }
          continue;
        }
      }
      break;
    }
    memmove(v115, v114, v113);
    goto LABEL_176;
  }
LABEL_216:
  v325[23] = 6;
  strcpy(v325, "Logics");
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)v325, (uint64_t *)&v318);
  HIBYTE(v313) = 10;
  strcpy((char *)&__dst, "World Type");
  unint64_t v140 = *(unsigned __int8 *)(v238 + 225);
  if (v140 > 6) {
    uint64_t v141 = "<Invalid>";
  }
  else {
    uint64_t v141 = off_1E5A99FA0[v140];
  }
  uint64_t v3 = v243;
  memset(&v326, 0, sizeof(v326));
  int v327 = 4;
  std::string::__assign_external(&v326, v141);
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&__dst, (uint64_t)v325);
  if (SHIBYTE(v326.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v326.__r_.__value_.__l.__data_);
  }
  uint64_t v142 = (void **)v318;
  if (v318)
  {
    while (v110 != v142)
    {
      if (*((char *)v110 - 9) < 0) {
        operator delete(*(v110 - 4));
      }
      v110 -= 8;
    }
    operator delete(v142);
  }
  gdc::DebugTreeNode::addChildNode(v4, (long long *)__p);
  std::string::pointer v143 = __p[3].__r_.__value_.__l.__data_;
  if (__p[3].__r_.__value_.__r.__words[0])
  {
    std::string::size_type v144 = __p[3].__r_.__value_.__l.__size_;
    std::string::pointer v145 = __p[3].__r_.__value_.__l.__data_;
    if (__p[3].__r_.__value_.__l.__size_ != __p[3].__r_.__value_.__r.__words[0])
    {
      do
      {
        v144 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v144);
      }
      while ((std::string::pointer)v144 != v143);
      std::string::pointer v145 = __p[3].__r_.__value_.__l.__data_;
    }
    __p[3].__r_.__value_.__l.__size_ = (std::string::size_type)v143;
    operator delete(v145);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__p[2]);
  if (SHIBYTE(__p[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p[1].__r_.__value_.__l.__data_);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_302;
    }
  }
  else
  {
    if ((SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_235;
    }
LABEL_302:
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
LABEL_235:
  md::World::createDebugNode((uint64_t)__p, *(void **)(v3 + 896), a3);
  gdc::DebugTreeNode::addChildNode(v4, (long long *)__p);
  std::string::pointer v146 = __p[3].__r_.__value_.__l.__data_;
  if (__p[3].__r_.__value_.__r.__words[0])
  {
    std::string::size_type v147 = __p[3].__r_.__value_.__l.__size_;
    std::string::pointer v148 = __p[3].__r_.__value_.__l.__data_;
    if (__p[3].__r_.__value_.__l.__size_ != __p[3].__r_.__value_.__r.__words[0])
    {
      do
      {
        v147 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v147);
      }
      while ((std::string::pointer)v147 != v146);
      std::string::pointer v148 = __p[3].__r_.__value_.__l.__data_;
    }
    __p[3].__r_.__value_.__l.__size_ = (std::string::size_type)v146;
    operator delete(v148);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__p[2]);
  if (SHIBYTE(__p[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p[1].__r_.__value_.__l.__data_);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_269;
    }
  }
  else
  {
    if ((SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_242;
    }
LABEL_269:
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
LABEL_242:
  uint64_t v149 = *(void *)(v3 + 1120);
  strcpy((char *)__p, "Logic Manager");
  *(_WORD *)((char *)&__p[0].__r_.__value_.__r.__words[2] + 7) = 13;
  *(_OWORD *)((char *)&__p[1].__r_.__value_.__r.__words[2] + 7) = 0u;
  *(_OWORD *)((char *)&__p[2].__r_.__value_.__r.__words[1] + 7) = 0u;
  *(_OWORD *)((char *)__p[3].__r_.__value_.__r.__words + 7) = 0u;
  *((unsigned char *)&__p[3].__r_.__value_.__s + 23) = 0;
  *((unsigned char *)&v336.__r_.__value_.__s + 23) = 6;
  strcpy((char *)&v336, "Logics");
  unint64_t v150 = gdc::DebugTreeNode::createChildNode((uint64_t)__p, (long long *)&v336);
  memset(__len, 0, 24);
  *(void *)&long long v337 = 0;
  uint64_t v151 = operator new(0x20uLL);
  int v152 = (void (**)(void))&unk_1EF57D680;
  *uint64_t v151 = &unk_1EF57D680;
  v151[1] = a3;
  v151[2] = __len;
  v151[3] = v150;
  *(void *)&long long v337 = v151;
  int v153 = *(void **)(v149 + 24);
  if (!v153)
  {
LABEL_250:
    v152[5]();
    goto LABEL_251;
  }
  v328[0] = v153[5];
  while (1)
  {
    (*(void (**)(void *, void *))(*v151 + 48))(v151, v328);
    int v153 = (void *)*v153;
    uint64_t v151 = (void *)v337;
    if (!v153) {
      break;
    }
    v328[0] = v153[5];
    if (!(void)v337)
    {
      std::__throw_bad_function_call[abi:nn180100]();
      __break(1u);
    }
  }
  if ((std::string *)v337 == &v336)
  {
    (*(void (**)(std::string *))(v336.__r_.__value_.__r.__words[0] + 32))(&v336);
    size_t v154 = __len[0];
    if (__len[0]) {
      goto LABEL_252;
    }
  }
  else
  {
    if ((void)v337)
    {
      int v152 = *(void (***)(void))v337;
      goto LABEL_250;
    }
LABEL_251:
    size_t v154 = __len[0];
    if (__len[0])
    {
LABEL_252:
      size_t v155 = __len[1];
      unsigned int v156 = (void *)v154;
      if (__len[1] != v154)
      {
        do
        {
          if (*(char *)(v155 - 9) < 0) {
            operator delete(*(void **)(v155 - 32));
          }
          v155 -= 64;
        }
        while (v155 != v154);
        unsigned int v156 = (void *)__len[0];
      }
      __len[1] = v154;
      operator delete(v156);
    }
  }
  gdc::DebugTreeNode::addChildNode(v4, (long long *)__p);
  std::string::pointer v157 = __p[3].__r_.__value_.__l.__data_;
  if (__p[3].__r_.__value_.__r.__words[0])
  {
    std::string::size_type v158 = __p[3].__r_.__value_.__l.__size_;
    std::string::pointer v159 = __p[3].__r_.__value_.__l.__data_;
    if (__p[3].__r_.__value_.__l.__size_ != __p[3].__r_.__value_.__r.__words[0])
    {
      do
      {
        v158 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v158);
      }
      while ((std::string::pointer)v158 != v157);
      std::string::pointer v159 = __p[3].__r_.__value_.__l.__data_;
    }
    __p[3].__r_.__value_.__l.__size_ = (std::string::size_type)v157;
    operator delete(v159);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__p[2]);
  if (SHIBYTE(__p[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p[1].__r_.__value_.__l.__data_);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_271;
    }
LABEL_266:
    uint64_t v160 = *(void *)(v3 + 872);
    if (v160)
    {
LABEL_272:
      (*(void (**)(std::string *__return_ptr))(*(void *)v160 + 48))(__p);
      gdc::DebugTreeNode::addChildNode(v4, (long long *)__p);
      std::string::pointer v161 = __p[3].__r_.__value_.__l.__data_;
      if (__p[3].__r_.__value_.__r.__words[0])
      {
        std::string::size_type v162 = __p[3].__r_.__value_.__l.__size_;
        std::string::pointer v163 = __p[3].__r_.__value_.__l.__data_;
        if (__p[3].__r_.__value_.__l.__size_ != __p[3].__r_.__value_.__r.__words[0])
        {
          do
          {
            v162 -= 80;
            std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v162);
          }
          while ((std::string::pointer)v162 != v161);
          std::string::pointer v163 = __p[3].__r_.__value_.__l.__data_;
        }
        __p[3].__r_.__value_.__l.__size_ = (std::string::size_type)v161;
        operator delete(v163);
      }
      std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__p[2]);
      if (SHIBYTE(__p[1].__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p[1].__r_.__value_.__l.__data_);
        if ((SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_279;
        }
      }
      else if ((SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_279;
      }
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
  }
  else
  {
    if ((SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_266;
    }
LABEL_271:
    operator delete(__p[0].__r_.__value_.__l.__data_);
    uint64_t v160 = *(void *)(v3 + 872);
    if (v160) {
      goto LABEL_272;
    }
  }
LABEL_279:
  uint64_t v164 = *(void *)(v3 + 4512);
  long long v165 = *(void **)v164;
  uint64_t v166 = *(void **)(v164 + 8);
  if (v165 != v166)
  {
    while (*v165 != 0x41D4E9297E100630)
    {
      v165 += 5;
      if (v165 == v166) {
        goto LABEL_307;
      }
    }
  }
  if (v165 != v166)
  {
    uint64_t v167 = v165[3];
    double v168 = (std::__shared_weak_count *)v165[4];
    if (v168
      && (atomic_fetch_add_explicit(&v168->__shared_owners_, 1uLL, memory_order_relaxed),
          !atomic_fetch_add(&v168->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
    {
      ((void (*)(std::__shared_weak_count *))v168->__on_zero_shared)(v168);
      std::__shared_weak_count::__release_weak(v168);
      if (v167)
      {
LABEL_287:
        memset(__p, 0, sizeof(__p));
        uint64_t v169 = (char *)operator new(0x19uLL);
        strcpy(v169, "VKMRenderResourcesStore");
        std::string::__assign_no_alias<true>(__p, v169, 0x17uLL);
        operator delete(v169);
        md::VKMRenderResourceStoreSerializer::serializeWith(__p, v167);
        gdc::DebugTreeNode::addChildNode(v4, (long long *)__p);
        std::string::pointer v170 = __p[3].__r_.__value_.__l.__data_;
        if (__p[3].__r_.__value_.__r.__words[0])
        {
          std::string::size_type v171 = __p[3].__r_.__value_.__l.__size_;
          std::string::pointer v172 = __p[3].__r_.__value_.__l.__data_;
          if (__p[3].__r_.__value_.__l.__size_ != __p[3].__r_.__value_.__r.__words[0])
          {
            do
            {
              v171 -= 80;
              std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v171);
            }
            while ((std::string::pointer)v171 != v170);
            std::string::pointer v172 = __p[3].__r_.__value_.__l.__data_;
          }
          __p[3].__r_.__value_.__l.__size_ = (std::string::size_type)v170;
          operator delete(v172);
        }
        std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__p[2]);
        if (SHIBYTE(__p[1].__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p[1].__r_.__value_.__l.__data_);
          if ((SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_307;
          }
        }
        else if ((SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_307;
        }
        operator delete(__p[0].__r_.__value_.__l.__data_);
      }
    }
    else if (v167)
    {
      goto LABEL_287;
    }
  }
LABEL_307:
  uint64_t v173 = *(void *)(v3 + 4512);
  float v174 = *(void **)v173;
  float v175 = *(void **)(v173 + 8);
  if (v174 != v175)
  {
    while (*v174 != 0x4EDAD23DFB014132)
    {
      v174 += 5;
      if (v174 == v175) {
        goto LABEL_363;
      }
    }
  }
  if (v174 == v175) {
    goto LABEL_363;
  }
  uint64_t v177 = v174[3];
  float v176 = (std::__shared_weak_count *)v174[4];
  if (!v176
    || (atomic_fetch_add_explicit(&v176->__shared_owners_, 1uLL, memory_order_relaxed),
        atomic_fetch_add(&v176->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
  {
    if (v177) {
      goto LABEL_315;
    }
    goto LABEL_363;
  }
  ((void (*)(std::__shared_weak_count *))v176->__on_zero_shared)(v176);
  std::__shared_weak_count::__release_weak(v176);
  if (!v177) {
    goto LABEL_363;
  }
LABEL_315:
  uint64_t v341 = 0;
  long long v340 = 0u;
  long long v339 = 0u;
  long long v338 = 0u;
  long long v337 = 0u;
  strcpy((char *)&v336, "MaterialResourceStore");
  *((unsigned char *)&v336.__r_.__value_.__s + 23) = 21;
  memset(&__p[1], 0, 72);
  strcpy((char *)__p, "_materialPtrItems");
  *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 17;
  HIBYTE(v328[2]) = 8;
  strcpy((char *)v328, "counters");
  size_t v178 = *(unsigned int *)(v177 + 40);
  int v335 = 1;
  memset(&v334, 0, sizeof(v334));
  __len[1] = v178;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)v328, (uint64_t)__len);
  uint64_t v179 = *(unsigned int *)(v177 + 80);
  v325[23] = 16;
  strcpy(v325, "countersRetained");
  uint64_t v331 = 0;
  uint64_t v330 = 0;
  int v332 = 1;
  uint64_t v329 = 0;
  v328[1] = v179;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)v325, (uint64_t)v328);
  uint64_t v181 = *(void *)(v177 + 144);
  uint64_t v180 = *(void *)(v177 + 152);
  HIBYTE(v320) = 5;
  strcpy((char *)&v318, "items");
  int v327 = 1;
  memset(&v326, 0, sizeof(v326));
  *(void *)&v325[8] = ((unint64_t)(v180 - v181) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&v318, (uint64_t)v325);
  double v182 = (void **)*(unsigned int *)(v177 + 216);
  HIBYTE(v313) = 4;
  strcpy((char *)&__dst, "pool");
  uint64_t v323 = 0;
  uint64_t v322 = 0;
  int v324 = 1;
  uint64_t v321 = 0;
  uint64_t v319 = v182;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&__dst, (uint64_t)&v318);
  uint64_t v183 = *(unsigned int *)(v177 + 256);
  *((unsigned char *)&v306.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v306, "keyToHandle");
  uint64_t v316 = 0;
  uint64_t v315 = 0;
  int v317 = 1;
  uint64_t v314 = 0;
  *((void *)&__dst + 1) = v183;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&v306, (uint64_t)&__dst);
  std::string::size_type v184 = *(unsigned int *)(v177 + 296);
  *((unsigned char *)&v311.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v311, "handleToKey");
  uint64_t v309 = 0;
  uint64_t v308 = 0;
  int v310 = 1;
  uint64_t v307 = 0;
  v306.__r_.__value_.__l.__size_ = v184;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&v311, (uint64_t)&v306);
  gdc::DebugTreeNode::addChildNode(&v336, (long long *)__p);
  std::string::pointer v185 = __p[3].__r_.__value_.__l.__data_;
  if (__p[3].__r_.__value_.__r.__words[0])
  {
    std::string::size_type v186 = __p[3].__r_.__value_.__l.__size_;
    std::string::pointer v187 = __p[3].__r_.__value_.__l.__data_;
    if (__p[3].__r_.__value_.__l.__size_ != __p[3].__r_.__value_.__r.__words[0])
    {
      do
      {
        v186 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v186);
      }
      while ((std::string::pointer)v186 != v185);
      std::string::pointer v187 = __p[3].__r_.__value_.__l.__data_;
    }
    __p[3].__r_.__value_.__l.__size_ = (std::string::size_type)v185;
    operator delete(v187);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__p[2]);
  if (SHIBYTE(__p[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p[1].__r_.__value_.__l.__data_);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_356;
    }
  }
  else
  {
    if ((SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_322;
    }
LABEL_356:
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
LABEL_322:
  memset(__p, 0, sizeof(__p));
  float v188 = (char *)operator new(0x20uLL);
  strcpy(v188, "_materialVisibilityOptions");
  std::string::__assign_no_alias<true>(__p, v188, 0x1AuLL);
  operator delete(v188);
  HIBYTE(v328[2]) = 8;
  strcpy((char *)v328, "counters");
  size_t v189 = *(unsigned int *)(v177 + 336);
  int v335 = 1;
  memset(&v334, 0, sizeof(v334));
  __len[1] = v189;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)v328, (uint64_t)__len);
  uint64_t v190 = *(unsigned int *)(v177 + 376);
  v325[23] = 16;
  strcpy(v325, "countersRetained");
  uint64_t v331 = 0;
  uint64_t v330 = 0;
  int v332 = 1;
  uint64_t v329 = 0;
  v328[1] = v190;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)v325, (uint64_t)v328);
  int v191 = *(_DWORD *)(v177 + 448);
  int v192 = *(_DWORD *)(v177 + 440);
  HIBYTE(v320) = 5;
  strcpy((char *)&v318, "items");
  int v327 = 1;
  memset(&v326, 0, sizeof(v326));
  *(void *)&v325[8] = (-1431655765 * (v191 - v192));
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&v318, (uint64_t)v325);
  long long v193 = (void **)*(unsigned int *)(v177 + 512);
  HIBYTE(v313) = 4;
  strcpy((char *)&__dst, "pool");
  uint64_t v323 = 0;
  uint64_t v322 = 0;
  int v324 = 1;
  uint64_t v321 = 0;
  uint64_t v319 = v193;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&__dst, (uint64_t)&v318);
  uint64_t v194 = *(unsigned int *)(v177 + 552);
  *((unsigned char *)&v306.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v306, "keyToHandle");
  uint64_t v316 = 0;
  uint64_t v315 = 0;
  int v317 = 1;
  uint64_t v314 = 0;
  *((void *)&__dst + 1) = v194;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&v306, (uint64_t)&__dst);
  std::string::size_type v195 = *(unsigned int *)(v177 + 592);
  *((unsigned char *)&v311.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v311, "handleToKey");
  uint64_t v309 = 0;
  uint64_t v308 = 0;
  int v310 = 1;
  uint64_t v307 = 0;
  v306.__r_.__value_.__l.__size_ = v195;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&v311, (uint64_t)&v306);
  gdc::DebugTreeNode::addChildNode(&v336, (long long *)__p);
  std::string::pointer v196 = __p[3].__r_.__value_.__l.__data_;
  if (__p[3].__r_.__value_.__r.__words[0])
  {
    std::string::size_type v197 = __p[3].__r_.__value_.__l.__size_;
    std::string::pointer v198 = __p[3].__r_.__value_.__l.__data_;
    if (__p[3].__r_.__value_.__l.__size_ != __p[3].__r_.__value_.__r.__words[0])
    {
      do
      {
        v197 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v197);
      }
      while ((std::string::pointer)v197 != v196);
      std::string::pointer v198 = __p[3].__r_.__value_.__l.__data_;
    }
    __p[3].__r_.__value_.__l.__size_ = (std::string::size_type)v196;
    operator delete(v198);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__p[2]);
  if (SHIBYTE(__p[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p[1].__r_.__value_.__l.__data_);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_358;
    }
  }
  else
  {
    if ((SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_329;
    }
LABEL_358:
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
LABEL_329:
  memset(&__p[1], 0, 72);
  strcpy((char *)__p, "_materialZIndex");
  *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 15;
  HIBYTE(v328[2]) = 8;
  strcpy((char *)v328, "counters");
  size_t v199 = *(unsigned int *)(v177 + 632);
  int v335 = 1;
  memset(&v334, 0, sizeof(v334));
  __len[1] = v199;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)v328, (uint64_t)__len);
  uint64_t v200 = *(unsigned int *)(v177 + 672);
  v325[23] = 16;
  strcpy(v325, "countersRetained");
  uint64_t v331 = 0;
  uint64_t v330 = 0;
  int v332 = 1;
  uint64_t v329 = 0;
  v328[1] = v200;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)v325, (uint64_t)v328);
  uint64_t v201 = *(void *)(v177 + 744);
  uint64_t v202 = *(void *)(v177 + 736);
  HIBYTE(v320) = 5;
  strcpy((char *)&v318, "items");
  int v327 = 1;
  memset(&v326, 0, sizeof(v326));
  *(void *)&v325[8] = ((unint64_t)(v201 - v202) >> 3);
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&v318, (uint64_t)v325);
  uint64_t v203 = (void **)*(unsigned int *)(v177 + 808);
  HIBYTE(v313) = 4;
  strcpy((char *)&__dst, "pool");
  uint64_t v323 = 0;
  uint64_t v322 = 0;
  int v324 = 1;
  uint64_t v321 = 0;
  uint64_t v319 = v203;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&__dst, (uint64_t)&v318);
  uint64_t v204 = *(unsigned int *)(v177 + 848);
  *((unsigned char *)&v306.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v306, "keyToHandle");
  uint64_t v316 = 0;
  uint64_t v315 = 0;
  int v317 = 1;
  uint64_t v314 = 0;
  *((void *)&__dst + 1) = v204;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&v306, (uint64_t)&__dst);
  std::string::size_type v205 = *(unsigned int *)(v177 + 888);
  *((unsigned char *)&v311.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v311, "handleToKey");
  uint64_t v309 = 0;
  uint64_t v308 = 0;
  int v310 = 1;
  uint64_t v307 = 0;
  v306.__r_.__value_.__l.__size_ = v205;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&v311, (uint64_t)&v306);
  gdc::DebugTreeNode::addChildNode(&v336, (long long *)__p);
  std::string::pointer v206 = __p[3].__r_.__value_.__l.__data_;
  if (__p[3].__r_.__value_.__r.__words[0])
  {
    std::string::size_type v207 = __p[3].__r_.__value_.__l.__size_;
    std::string::pointer v208 = __p[3].__r_.__value_.__l.__data_;
    if (__p[3].__r_.__value_.__l.__size_ != __p[3].__r_.__value_.__r.__words[0])
    {
      do
      {
        v207 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v207);
      }
      while ((std::string::pointer)v207 != v206);
      std::string::pointer v208 = __p[3].__r_.__value_.__l.__data_;
    }
    __p[3].__r_.__value_.__l.__size_ = (std::string::size_type)v206;
    operator delete(v208);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__p[2]);
  if (SHIBYTE(__p[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p[1].__r_.__value_.__l.__data_);
    if ((SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_336;
    }
LABEL_360:
    operator delete(__p[0].__r_.__value_.__l.__data_);
    goto LABEL_336;
  }
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_360;
  }
LABEL_336:
  memset(&__p[1], 0, 72);
  strcpy((char *)__p, "_colorData");
  *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 10;
  HIBYTE(v328[2]) = 8;
  strcpy((char *)v328, "counters");
  size_t v209 = *(unsigned int *)(v177 + 928);
  int v335 = 1;
  memset(&v334, 0, sizeof(v334));
  __len[1] = v209;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)v328, (uint64_t)__len);
  uint64_t v210 = *(unsigned int *)(v177 + 968);
  v325[23] = 16;
  strcpy(v325, "countersRetained");
  uint64_t v331 = 0;
  uint64_t v330 = 0;
  int v332 = 1;
  uint64_t v329 = 0;
  v328[1] = v210;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)v325, (uint64_t)v328);
  uint64_t v211 = *(void *)(v177 + 1040);
  uint64_t v212 = *(void *)(v177 + 1032);
  HIBYTE(v320) = 5;
  strcpy((char *)&v318, "items");
  int v327 = 1;
  memset(&v326, 0, sizeof(v326));
  *(void *)&v325[8] = -858993459 * ((unint64_t)(v211 - v212) >> 2);
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&v318, (uint64_t)v325);
  uint64_t v213 = (void **)*(unsigned int *)(v177 + 1104);
  HIBYTE(v313) = 4;
  strcpy((char *)&__dst, "pool");
  uint64_t v323 = 0;
  uint64_t v322 = 0;
  int v324 = 1;
  uint64_t v321 = 0;
  uint64_t v319 = v213;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&__dst, (uint64_t)&v318);
  uint64_t v214 = *(unsigned int *)(v177 + 1144);
  *((unsigned char *)&v306.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v306, "keyToHandle");
  uint64_t v316 = 0;
  uint64_t v315 = 0;
  int v317 = 1;
  uint64_t v314 = 0;
  *((void *)&__dst + 1) = v214;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&v306, (uint64_t)&__dst);
  std::string::size_type v215 = *(unsigned int *)(v177 + 1184);
  *((unsigned char *)&v311.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v311, "handleToKey");
  uint64_t v309 = 0;
  uint64_t v308 = 0;
  int v310 = 1;
  uint64_t v307 = 0;
  v306.__r_.__value_.__l.__size_ = v215;
  gdc::DebugTreeNode::addProperty((uint64_t)__p, (uint64_t)&v311, (uint64_t)&v306);
  gdc::DebugTreeNode::addChildNode(&v336, (long long *)__p);
  std::string::pointer v216 = __p[3].__r_.__value_.__l.__data_;
  if (__p[3].__r_.__value_.__r.__words[0])
  {
    std::string::size_type v217 = __p[3].__r_.__value_.__l.__size_;
    std::string::pointer v218 = __p[3].__r_.__value_.__l.__data_;
    if (__p[3].__r_.__value_.__l.__size_ != __p[3].__r_.__value_.__r.__words[0])
    {
      do
      {
        v217 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v217);
      }
      while ((std::string::pointer)v217 != v216);
      std::string::pointer v218 = __p[3].__r_.__value_.__l.__data_;
    }
    __p[3].__r_.__value_.__l.__size_ = (std::string::size_type)v216;
    operator delete(v218);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&__p[2]);
  if (SHIBYTE(__p[1].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[1].__r_.__value_.__l.__data_);
  }
  uint64_t v3 = v243;
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  gdc::DebugTreeNode::addChildNode(v4, (long long *)&v336);
  uint64_t v219 = v340;
  if ((void)v340)
  {
    uint64_t v220 = *((void *)&v340 + 1);
    long long v221 = (void *)v340;
    if (*((void *)&v340 + 1) != (void)v340)
    {
      do
      {
        v220 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v220);
      }
      while (v220 != v219);
      long long v221 = (void *)v340;
    }
    *((void *)&v340 + 1) = v219;
    operator delete(v221);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&v338 + 1);
  if (SBYTE7(v338) < 0)
  {
    operator delete((void *)v337);
    if ((SHIBYTE(v336.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_363;
    }
  }
  else if ((SHIBYTE(v336.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_363;
  }
  operator delete(v336.__r_.__value_.__l.__data_);
LABEL_363:
  unint64_t v222 = *(void *)(v3 + 4312);
  *((unsigned char *)&__p[0].__r_.__value_.__s + 23) = 19;
  strcpy((char *)__p, "LayoutReasonHistory");
  __n128 result = gdc::DebugTreeNode::createChildNode((uint64_t)v4, (long long *)__p);
  uint64_t v241 = (uint64_t)result;
  if (v222 != *(void *)(v3 + 4320))
  {
    uint64_t v224 = v243 + 1408;
    std::string::size_type v237 = *(void *)(MEMORY[0x1E4FBA418] + 24);
    std::string::size_type v239 = *MEMORY[0x1E4FBA418];
    while (1)
    {
      std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)__p);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"(", 1);
      uint64_t v226 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v226, (uint64_t)",", 1);
      stringForLayoutReasonsMask(&v336, *(void *)(v224 + 24 * v222 + 16));
      if ((v336.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v227 = &v336;
      }
      else {
        uint64_t v227 = (std::string *)v336.__r_.__value_.__r.__words[0];
      }
      if ((v336.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v228 = HIBYTE(v336.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v228 = v336.__r_.__value_.__l.__size_;
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v226, (uint64_t)v227, v228);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v226, (uint64_t)")", 1);
      if (SHIBYTE(v336.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v336.__r_.__value_.__l.__data_);
      }
      std::to_string(&v336, *(void *)(v224 + 24 * v222));
      if ((v250 & 0x10) != 0)
      {
        std::string::size_type v231 = v249;
        v232 = &__p[2];
        if (v249 < __p[2].__r_.__value_.__l.__size_)
        {
          std::string::size_type v249 = __p[2].__r_.__value_.__l.__size_;
          std::string::size_type v231 = __p[2].__r_.__value_.__l.__size_;
          v232 = &__p[2];
        }
      }
      else
      {
        if ((v250 & 8) == 0)
        {
          size_t v229 = 0;
          HIBYTE(__len[2]) = 0;
          uint64_t v230 = __len;
          goto LABEL_389;
        }
        std::string::size_type v231 = __p[1].__r_.__value_.__r.__words[2];
        v232 = &__p[1];
      }
      unint64_t v233 = (const void *)v232->__r_.__value_.__r.__words[0];
      size_t v229 = v231 - v232->__r_.__value_.__r.__words[0];
      if (v229 > 0x7FFFFFFFFFFFFFF7) {
        abort();
      }
      if (v229 >= 0x17) {
        break;
      }
      HIBYTE(__len[2]) = v231 - v232->__r_.__value_.__s.__data_[0];
      uint64_t v230 = __len;
      if (v229) {
        goto LABEL_388;
      }
LABEL_389:
      v230[v229] = 0;
      long long v245 = 0uLL;
      size_t v246 = 0;
      int v247 = 4;
      int v236 = SHIBYTE(__len[2]);
      if (SHIBYTE(__len[2]) < 0)
      {
        std::string::__assign_no_alias<true>(&v245, (void *)__len[0], __len[1]);
      }
      else
      {
        long long v245 = *(_OWORD *)__len;
        size_t v246 = __len[2];
      }
      gdc::DebugTreeNode::addProperty(v241, (uint64_t)&v336, (uint64_t)v244);
      if (SHIBYTE(v246) < 0)
      {
        operator delete((void *)v245);
        if ((v236 & 0x80000000) == 0)
        {
LABEL_394:
          if (SHIBYTE(v336.__r_.__value_.__r.__words[2]) < 0) {
            goto LABEL_399;
          }
          goto LABEL_395;
        }
      }
      else if ((v236 & 0x80000000) == 0)
      {
        goto LABEL_394;
      }
      operator delete((void *)__len[0]);
      if (SHIBYTE(v336.__r_.__value_.__r.__words[2]) < 0) {
LABEL_399:
      }
        operator delete(v336.__r_.__value_.__l.__data_);
LABEL_395:
      __p[0].__r_.__value_.__r.__words[0] = v239;
      *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words + *(void *)(v239 - 24)) = v237;
      __p[0].__r_.__value_.__l.__size_ = MEMORY[0x1E4FBA470] + 16;
      if (SHIBYTE(__p[3].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[3].__r_.__value_.__l.__data_);
      }
      uint64_t v225 = ((v222 + 1) * (unsigned __int128)0xECF56BE69C8FDE3uLL) >> 64;
      unint64_t v222 = v222 + 1 - 121 * ((v225 + ((v222 + 1 - v225) >> 1)) >> 6);
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      __n128 result = (char *)MEMORY[0x1A62391A0](&v251);
      if (v222 == *(void *)(v243 + 4320)) {
        return result;
      }
    }
    uint64_t v234 = (v229 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v229 | 7) != 0x17) {
      uint64_t v234 = v229 | 7;
    }
    uint64_t v235 = v234 + 1;
    uint64_t v230 = operator new(v234 + 1);
    __len[2] = v235 | 0x8000000000000000;
    __len[0] = (size_t)v230;
    __len[1] = v229;
LABEL_388:
    memmove(v230, v233, v229);
    goto LABEL_389;
  }
  return result;
}

void sub_1A23A627C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, gdc::DebugTreeNode *a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  gdc::DebugTreeNode::~DebugTreeNode((gdc::DebugTreeNode *)va);
  gdc::DebugTreeNode::~DebugTreeNode(a8);
  _Unwind_Resume(a1);
}

uint64_t md::MapEngine::mapType(md::MapEngine *this, md::MapEngine *a2)
{
  if (this != a2)
  {
    while (*(unsigned char *)this != 20)
    {
      this = (md::MapEngine *)((char *)this + 16);
      if (this == a2) {
        return 0;
      }
    }
  }
  if (this == a2) {
    return 0;
  }
  else {
    return *((unsigned int *)this + 2);
  }
}

uint64_t md::MapEngineDeleter::operator()(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  uint64_t v2 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v8 = a1;
    _os_log_impl(&dword_1A1780000, v2, OS_LOG_TYPE_INFO, "[MapEngine:%p] destruction requested", buf, 0xCu);
  }

  atomic_store(1u, (unsigned __int8 *)(a1 + 1));
  uint64_t v3 = *(void *)(a1 + 4528);
  int v6 = 1;
  uint64_t result = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v3 + 16))(v3, v5);
  if (v6 != -1) {
    return ((uint64_t (*)(uint8_t *, unsigned char *))off_1EF590668[v6])(buf, v5);
  }
  return result;
}

void sub_1A23A6634(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, int a15, char a16)
{
  if (a14 != -1)
  {
    ((void (*)(char *, uint64_t *))off_1EF590668[a14])(&a16, &a9);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

__CFString *VKStringForAnnotationTrackingBehavior(unsigned __int8 *a1)
{
  if (a1)
  {
    uint64_t v2 = [MEMORY[0x1E4F28E78] stringWithString:@"{\n"];
    [(__CFString *)v2 appendFormat:@"\tshouldZoomToFit: %i\n", *a1];
    [(__CFString *)v2 appendFormat:@"\tidealCenterCoordinateDistance: %.1f\n", *((void *)a1 + 1)];
    [(__CFString *)v2 appendFormat:@"\tshouldPreserveUserSpecifiedZoomLevel: %i\n", a1[16]];
    if (a1[17]) {
      [(__CFString *)v2 appendFormat:@"\tresetAfterTracking: %i\n", 1];
    }
    [(__CFString *)v2 appendString:@"}"];
  }
  else
  {
    uint64_t v2 = @"<nil>";
  }
  return v2;
}

void sub_1A23A674C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::FontOptions::debugString(void *a1, long long *a2, grl::FontManager *a3)
{
  grl::FontManager::fontForKey(a3, a2, &v12, 0.0);
  if (cf)
  {
    id v4 = [(id)cf description];
    uint64_t v5 = (const char *)[v4 UTF8String];
    {
      operator new();
    }
    uint64_t v6 = mdm::Allocator::instance(void)::alloc;
    a1[3] = mdm::Allocator::instance(void)::alloc;
    size_t v7 = strlen(v5);
    if (v7 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    size_t v8 = v7;
    if (v7 >= 0x17)
    {
      uint64_t v9 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17) {
        uint64_t v9 = v7 | 7;
      }
      uint64_t v10 = v9 + 1;
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 16))(v6, v9 + 1, 1);
      a1[1] = v8;
      a1[2] = v10 | 0x8000000000000000;
      *a1 = v11;
      a1 = (void *)v11;
    }
    else
    {
      *((unsigned char *)a1 + 23) = v7;
      if (!v7) {
        goto LABEL_13;
      }
    }
    memmove(a1, v5, v8);
LABEL_13:
    *((unsigned char *)a1 + v8) = 0;

    goto LABEL_14;
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  {
    operator new();
  }
  a1[3] = mdm::Allocator::instance(void)::alloc;
LABEL_14:
  unsigned int v12 = &unk_1EF5592D8;
  if (cf) {
    CFRelease(cf);
  }
}

void sub_1A23A6984(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t getTopDepthPipelineSetupForGroup(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = *(uint64_t **)a3;
  size_t v7 = *(uint64_t **)(a1 + 64);
  v7[1] = 0;
  uint64_t v8 = *v6;
  *size_t v7 = *v6;
  uint64_t v9 = *(void **)(a1 + 160);
  uint64_t v10 = v6[1];
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = (std::__shared_weak_count *)v9[1];
  *uint64_t v9 = v8;
  v9[1] = v10;
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  uint64_t v12 = *(void *)(*(void *)(a1 + 64) + 16);
  unint64_t v13 = *(void *)(v12 + 8);
  if (v13) {
    uint64_t v14 = *(void *)(v12 + 72);
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v22 = *(void *)(*(void *)(a1 + 64) + 16);
  *(void *)uint64_t v14 = *(void *)(a3 + 76);
  unint64_t v15 = (_DWORD *)objc_msgSend(v5, "origin", 0);
  *(_DWORD *)(v14 + 16) = *v15;
  *(_DWORD *)(v14 + 20) = v15[1];
  *(_DWORD *)(v14 + 24) = v15[2];
  [v5 size];
  *(_DWORD *)(v14 + 32) = v16;
  *(_DWORD *)(v14 + 36) = v17;
  *(_DWORD *)(v14 + 40) = v18;
  if (v13)
  {
    if (v21 && *(unsigned char *)(v22 + 17) != 2) {
      (*(void (**)(void))(*(void *)v21 + 64))();
    }
    unint64_t v19 = *(void *)(v22 + 64);
    if (v19 <= v13) {
      unint64_t v19 = v13;
    }
    *(void *)(v22 + 56) = 0;
    *(void *)(v22 + 64) = v19;
  }

  return a1;
}

void sub_1A23A6B6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va);

  _Unwind_Resume(a1);
}

uint64_t getExtrusionDepthPipelineSetupForGroup(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = *(uint64_t **)a3;
  size_t v7 = *(uint64_t **)(a1 + 64);
  v7[1] = 0;
  uint64_t v8 = *v6;
  *size_t v7 = *v6;
  uint64_t v9 = *(void **)(a1 + 160);
  uint64_t v10 = v6[1];
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = (std::__shared_weak_count *)v9[1];
  *uint64_t v9 = v8;
  v9[1] = v10;
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  uint64_t v12 = *(void *)(*(void *)(a1 + 64) + 16);
  unint64_t v13 = *(void *)(v12 + 8);
  if (v13) {
    uint64_t v14 = *(void *)(v12 + 72);
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v22 = *(void *)(*(void *)(a1 + 64) + 16);
  *(void *)uint64_t v14 = *(void *)(a3 + 76);
  unint64_t v15 = (_DWORD *)objc_msgSend(v5, "origin", 0);
  *(_DWORD *)(v14 + 16) = *v15;
  *(_DWORD *)(v14 + 20) = v15[1];
  *(_DWORD *)(v14 + 24) = v15[2];
  [v5 size];
  *(_DWORD *)(v14 + 32) = v16;
  *(_DWORD *)(v14 + 36) = v17;
  *(_DWORD *)(v14 + 40) = v18;
  if (v13)
  {
    if (v21 && *(unsigned char *)(v22 + 17) != 2) {
      (*(void (**)(void))(*(void *)v21 + 64))();
    }
    unint64_t v19 = *(void *)(v22 + 64);
    if (v19 <= v13) {
      unint64_t v19 = v13;
    }
    *(void *)(v22 + 56) = 0;
    *(void *)(v22 + 64) = v19;
  }

  return a1;
}

void sub_1A23A6D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va);

  _Unwind_Resume(a1);
}

uint64_t getPointyRoofDepthPipelineSetupForGroup(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = *(uint64_t **)a3;
  size_t v7 = *(uint64_t **)(a1 + 64);
  v7[1] = 0;
  uint64_t v8 = *v6;
  *size_t v7 = *v6;
  uint64_t v9 = *(void **)(a1 + 160);
  uint64_t v10 = v6[1];
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = (std::__shared_weak_count *)v9[1];
  *uint64_t v9 = v8;
  v9[1] = v10;
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  uint64_t v12 = *(void *)(*(void *)(a1 + 64) + 16);
  unint64_t v13 = *(void *)(v12 + 8);
  if (v13) {
    uint64_t v14 = *(void *)(v12 + 72);
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v22 = *(void *)(*(void *)(a1 + 64) + 16);
  *(void *)uint64_t v14 = *(void *)(a3 + 76);
  unint64_t v15 = (_DWORD *)objc_msgSend(v5, "origin", 0);
  *(_DWORD *)(v14 + 16) = *v15;
  *(_DWORD *)(v14 + 20) = v15[1];
  *(_DWORD *)(v14 + 24) = v15[2];
  [v5 size];
  *(_DWORD *)(v14 + 32) = v16;
  *(_DWORD *)(v14 + 36) = v17;
  *(_DWORD *)(v14 + 40) = v18;
  if (v13)
  {
    if (v21 && *(unsigned char *)(v22 + 17) != 2) {
      (*(void (**)(void))(*(void *)v21 + 64))();
    }
    unint64_t v19 = *(void *)(v22 + 64);
    if (v19 <= v13) {
      unint64_t v19 = v13;
    }
    *(void *)(v22 + 56) = 0;
    *(void *)(v22 + 64) = v19;
  }

  return a1;
}

void sub_1A23A6EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va);

  _Unwind_Resume(a1);
}

uint64_t getExtrusionPipelineSetupForGroup(uint64_t a1, void *a2, uint64_t a3, float a4)
{
  id v7 = a2;
  uint64_t v8 = *(uint64_t **)a3;
  uint64_t v9 = *(void *)(a1 + 64);
  *(void *)(v9 + 24) = 0;
  uint64_t v10 = *v8;
  *(void *)(v9 + 16) = *v8;
  uint64_t v11 = *(void *)(a1 + 160);
  uint64_t v12 = v8[1];
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v13 = *(std::__shared_weak_count **)(v11 + 24);
  *(void *)(v11 + 16) = v10;
  *(void *)(v11 + 24) = v12;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  **(void **)(a1 + 96) = *(void *)(a3 + 32);
  uint64_t v14 = *(void *)(*(void *)(a1 + 64) + 32);
  unint64_t v15 = *(void *)(v14 + 8);
  if (v15) {
    uint64_t v16 = *(void *)(v14 + 72);
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v37 = *(void *)(*(void *)(a1 + 64) + 32);
  *(void *)uint64_t v16 = *(void *)(a3 + 76);
  int v17 = (_DWORD *)objc_msgSend(v7, "origin", 0);
  *(_DWORD *)(v16 + 16) = *v17;
  *(_DWORD *)(v16 + 20) = v17[1];
  *(_DWORD *)(v16 + 24) = v17[2];
  [v7 size];
  *(_DWORD *)(v16 + 32) = v18;
  *(_DWORD *)(v16 + 36) = v19;
  *(_DWORD *)(v16 + 40) = v20;
  if (v15)
  {
    if (v36 && *(unsigned char *)(v37 + 17) != 2) {
      (*(void (**)(void))(*(void *)v36 + 64))();
    }
    unint64_t v21 = *(void *)(v37 + 64);
    if (v21 <= v15) {
      unint64_t v21 = v15;
    }
    *(void *)(v37 + 56) = 0;
    *(void *)(v37 + 64) = v21;
  }
  uint64_t v22 = *(void **)(a1 + 64);
  uint64_t v23 = (void *)v22[6];
  unint64_t v24 = v23[1];
  if (v24) {
    uint64_t v25 = v23[9];
  }
  else {
    uint64_t v25 = 0;
  }
  *(_DWORD *)(v25 + 368) = *(_DWORD *)(a3 + 56);
  *(_DWORD *)(v25 + 372) = *(_DWORD *)(a3 + 60);
  *(_DWORD *)(v25 + 376) = *(_DWORD *)(a3 + 64);
  *(float *)(v25 + 356) = a4;
  if (v25 && v24)
  {
    if (v23[8] > v24) {
      unint64_t v24 = v23[8];
    }
    v23[7] = 0;
    v23[8] = v24;
  }
  uint64_t v26 = *(void **)(*(void *)(a3 + 40) + 8);
  unint64_t v27 = v26[1];
  if ((v27 & (v27 - 1)) != 0)
  {
    unint64_t v29 = 0x41E8D6E445F4145;
    if (v27 <= 0x41E8D6E445F4145) {
      unint64_t v29 = 0x41E8D6E445F4145 % v27;
    }
    uint64_t v28 = *(void **)(*v26 + 8 * v29);
    do
    {
      do
        uint64_t v28 = (void *)*v28;
      while (v28[1] != 0x41E8D6E445F4145);
    }
    while (v28[2] != 0x41E8D6E445F4145);
  }
  else
  {
    uint64_t v28 = *(void **)(*v26 + 8 * ((v27 - 1) & 0x41E8D6E445F4145));
    do
    {
      do
        uint64_t v28 = (void *)*v28;
      while (v28[1] != 0x41E8D6E445F4145);
    }
    while (v28[2] != 0x41E8D6E445F4145);
  }
  uint64_t v30 = *(uint64_t **)(v28[5] + 32);
  v22[11] = 0;
  uint64_t v31 = *v30;
  v22[10] = *v30;
  uint64_t v32 = *(void *)(a1 + 160);
  uint64_t v33 = v30[1];
  if (v33) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v33 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v34 = *(std::__shared_weak_count **)(v32 + 88);
  *(void *)(v32 + 80) = v31;
  *(void *)(v32 + 88) = v33;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }

  return a1;
}

void sub_1A23A7224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va);

  _Unwind_Resume(a1);
}

uint64_t getFoggedExtrusionPipelineSetupForGroup(uint64_t a1, void *a2, uint64_t a3, float a4)
{
  id v7 = a2;
  uint64_t v8 = *(uint64_t **)a3;
  uint64_t v9 = *(void *)(a1 + 64);
  *(void *)(v9 + 24) = 0;
  uint64_t v10 = *v8;
  *(void *)(v9 + 16) = *v8;
  uint64_t v11 = *(void *)(a1 + 160);
  uint64_t v12 = v8[1];
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v13 = *(std::__shared_weak_count **)(v11 + 24);
  *(void *)(v11 + 16) = v10;
  *(void *)(v11 + 24) = v12;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  **(void **)(a1 + 96) = *(void *)(a3 + 32);
  uint64_t v14 = *(void *)(*(void *)(a1 + 64) + 32);
  unint64_t v15 = *(void *)(v14 + 8);
  if (v15) {
    uint64_t v16 = *(void *)(v14 + 72);
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v43 = *(void *)(*(void *)(a1 + 64) + 32);
  *(void *)uint64_t v16 = *(void *)(a3 + 76);
  int v17 = (_DWORD *)objc_msgSend(v7, "origin", 0);
  *(_DWORD *)(v16 + 16) = *v17;
  *(_DWORD *)(v16 + 20) = v17[1];
  *(_DWORD *)(v16 + 24) = v17[2];
  [v7 size];
  *(_DWORD *)(v16 + 32) = v18;
  *(_DWORD *)(v16 + 36) = v19;
  *(_DWORD *)(v16 + 40) = v20;
  if (v15)
  {
    if (v42 && *(unsigned char *)(v43 + 17) != 2) {
      (*(void (**)(void))(*(void *)v42 + 64))();
    }
    unint64_t v21 = *(void *)(v43 + 64);
    if (v21 <= v15) {
      unint64_t v21 = v15;
    }
    *(void *)(v43 + 56) = 0;
    *(void *)(v43 + 64) = v21;
  }
  uint64_t v22 = *(void **)(a1 + 64);
  uint64_t v23 = (void *)v22[6];
  unint64_t v24 = v23[1];
  if (v24) {
    uint64_t v25 = v23[9];
  }
  else {
    uint64_t v25 = 0;
  }
  *(_DWORD *)(v25 + 368) = *(_DWORD *)(a3 + 56);
  *(_DWORD *)(v25 + 372) = *(_DWORD *)(a3 + 60);
  *(_DWORD *)(v25 + 376) = *(_DWORD *)(a3 + 64);
  *(float *)(v25 + 356) = a4;
  if (v25 && v24)
  {
    if (v23[8] > v24) {
      unint64_t v24 = v23[8];
    }
    v23[7] = 0;
    v23[8] = v24;
  }
  uint64_t v26 = *(void **)(*(void *)(a3 + 40) + 8);
  unint64_t v27 = v26[1];
  if ((v27 & (v27 - 1)) != 0)
  {
    unint64_t v29 = 0x41E8D6E445F4145;
    if (v27 <= 0x41E8D6E445F4145) {
      unint64_t v29 = 0x41E8D6E445F4145 % v27;
    }
    uint64_t v28 = *(void **)(*v26 + 8 * v29);
    do
    {
      do
        uint64_t v28 = (void *)*v28;
      while (v28[1] != 0x41E8D6E445F4145);
    }
    while (v28[2] != 0x41E8D6E445F4145);
  }
  else
  {
    uint64_t v28 = *(void **)(*v26 + 8 * ((v27 - 1) & 0x41E8D6E445F4145));
    do
    {
      do
        uint64_t v28 = (void *)*v28;
      while (v28[1] != 0x41E8D6E445F4145);
    }
    while (v28[2] != 0x41E8D6E445F4145);
  }
  uint64_t v30 = *(uint64_t **)(v28[5] + 32);
  v22[11] = 0;
  uint64_t v31 = *v30;
  v22[10] = *v30;
  uint64_t v32 = *(void *)(a1 + 160);
  uint64_t v33 = v30[1];
  if (v33) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v33 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v34 = *(std::__shared_weak_count **)(v32 + 88);
  *(void *)(v32 + 80) = v31;
  *(void *)(v32 + 88) = v33;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  uint64_t v35 = *(uint64_t **)(a3 + 8);
  uint64_t v36 = *(uint64_t **)(a1 + 64);
  v36[1] = 0;
  uint64_t v37 = *v35;
  uint64_t *v36 = *v35;
  unint64_t v38 = *(void **)(a1 + 160);
  uint64_t v39 = v35[1];
  if (v39) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v39 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v40 = (std::__shared_weak_count *)v38[1];
  *unint64_t v38 = v37;
  v38[1] = v39;
  if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
  }

  return a1;
}

void sub_1A23A75D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va);

  _Unwind_Resume(a1);
}

void submitRenderItems(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  uint64_t v89 = *(void *)(a3 + 80);
  uint64_t v8 = 688;
  uint64_t v9 = 656;
  if (!*(unsigned char *)(a3 + 88))
  {
    uint64_t v9 = 640;
    uint64_t v8 = 672;
  }
  uint64_t v10 = *(void *)(a2 + v8);
  *((void *)&v97 + 1) = "";
  *(void *)&long long v98 = v10;
  LODWORD(v99) = 0;
  *(_DWORD *)uint64_t v100 = 1065353216;
  memset(&v100[8], 0, 32);
  *(int64x2_t *)&v100[40] = vdupq_n_s64(1uLL);
  *(void *)&v100[56] = 0;
  uint64_t v83 = *(void *)(a2 + v9);
  *((void *)&v98 + 1) = *(void *)a3;
  *((void *)&v99 + 1) = 0;
  *((void *)&v90 + 1) = "";
  *(void *)&long long v91 = v83;
  *((void *)&v95 + 1) = 0;
  LODWORD(v95) = 0;
  *(_DWORD *)uint64_t v96 = 1065353216;
  memset(&v96[8], 0, 32);
  *(_OWORD *)&v96[40] = *(_OWORD *)&v100[40];
  *(void *)&v96[56] = 0;
  uint64_t v11 = *(void *)(a3 + 8);
  uint64_t v12 = a3;
  if (!v11) {
    uint64_t v11 = *(void *)(a3 + 16);
  }
  *((void *)&v91 + 1) = v11;
  uint64_t v88 = v7;
  uint64_t v13 = objc_msgSend(v7, "fillMeshes", v10);
  uint64_t v14 = *(uint64_t **)v13;
  uint64_t v84 = *(uint64_t **)(v13 + 8);
  if (*(uint64_t **)v13 != v84)
  {
    unsigned __int8 v15 = 0;
    do
    {
      uint64_t v16 = *(unsigned int *)(v12 + 72);
      uint64_t v17 = a4[3];
      if (v17)
      {
        if ((void *)v17 == a4)
        {
          long long v108 = v107;
          (*(void (**)(void *, void *))(*a4 + 24))(a4, v107);
          goto LABEL_12;
        }
        uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 16))(v17);
      }
      long long v108 = (void *)v17;
LABEL_12:
      uint64_t v18 = v15;
      int v19 = (uint64_t *)[v88 commitRangesToFillRenderItemBatcher:a2 + 784 forMeshAtIndex:v15 cullingMask:v16 featureIdPredicate:v107];
      if (v108 == v107)
      {
        (*(void (**)(void *))(v107[0] + 32))(v107);
      }
      else if (v108)
      {
        (*(void (**)(void))(*v108 + 40))();
      }
      uint64_t v20 = *v14;
      unint64_t v21 = *(void **)(a2 + 872);
      uint64_t v22 = v21[1];
      if (v22 == *(void *)(a2 + 880))
      {
        unint64_t v21 = (void *)*v21;
        if (!v21)
        {
          unint64_t v21 = malloc_type_malloc(120 * v22 + 16, 0xB644C221uLL);
          *unint64_t v21 = 0;
          v21[1] = 0;
          **(void **)(a2 + 872) = v21;
        }
        *(void *)(a2 + 872) = v21;
        uint64_t v22 = v21[1];
      }
      uint64_t v23 = &v21[15 * v22];
      v21[1] = v22 + 1;
      _OWORD v23[2] = &off_1EF55A458;
      *(_OWORD *)(v23 + 9) = *(_OWORD *)v100;
      *(_OWORD *)(v23 + 7) = v99;
      *(_OWORD *)(v23 + 5) = v98;
      *(_OWORD *)(v23 + 3) = v97;
      *(_OWORD *)(v23 + 15) = *(_OWORD *)&v100[48];
      *(_OWORD *)(v23 + 13) = *(_OWORD *)&v100[32];
      *(_OWORD *)(v23 + 11) = *(_OWORD *)&v100[16];
      v23[10] = v20;
      uint64_t v24 = *v19;
      v23[13] = *v19;
      v23[14] = (v19[1] - v24) >> 4;
      ggl::CommandBuffer::pushRenderItem(v89, (uint64_t)(v23 + 2));
      uint64_t v25 = *v14;
      uint64_t v26 = *(void **)(a2 + 872);
      uint64_t v27 = v26[1];
      if (v27 == *(void *)(a2 + 880))
      {
        uint64_t v26 = (void *)*v26;
        if (!v26)
        {
          uint64_t v26 = malloc_type_malloc(120 * v27 + 16, 0xB644C221uLL);
          void *v26 = 0;
          v26[1] = 0;
          **(void **)(a2 + 872) = v26;
        }
        *(void *)(a2 + 872) = v26;
        uint64_t v27 = v26[1];
      }
      uint64_t v28 = &v26[15 * v27];
      v26[1] = v27 + 1;
      v28[2] = &off_1EF55A458;
      *(_OWORD *)(v28 + 9) = *(_OWORD *)v96;
      *(_OWORD *)(v28 + 7) = v95;
      *(_OWORD *)(v28 + 5) = v91;
      *(_OWORD *)(v28 + 3) = v90;
      *(_OWORD *)(v28 + 15) = *(_OWORD *)&v96[48];
      *(_OWORD *)(v28 + 13) = *(_OWORD *)&v96[32];
      *(_OWORD *)(v28 + 11) = *(_OWORD *)&v96[16];
      v28[10] = v25;
      uint64_t v29 = *v19;
      v28[13] = *v19;
      v28[14] = (v19[1] - v29) >> 4;
      v28[8] = *(unsigned int *)(v12 + 76) + v18;
      ggl::CommandBuffer::pushRenderItem(v89, (uint64_t)(v28 + 2));
      unsigned __int8 v15 = v18 + 1;
      v14 += 2;
    }
    while (v14 != v84);
  }
  *(void *)&long long v98 = v82;
  *((void *)&v98 + 1) = *(void *)(v12 + 24);
  uint64_t v30 = *(void *)(v12 + 40);
  if (*(void *)(v12 + 32)) {
    uint64_t v30 = *(void *)(v12 + 32);
  }
  *(void *)&long long v92 = v83;
  *((void *)&v92 + 1) = v30;
  uint64_t v31 = (uint64_t **)[v88 extrusionFillMeshVendor];
  uint64_t v32 = *v31;
  if (*(void *)(**(void **)(**v31 + 64) + 48) != *(void *)(**(void **)(**v31 + 64) + 40))
  {
    std::string::size_type v85 = v31[1];
    if (v32 != v85)
    {
      unsigned __int8 v33 = 0;
      do
      {
        uint64_t v34 = *(unsigned int *)(v12 + 72);
        uint64_t v35 = a4[3];
        if (v35)
        {
          if ((void *)v35 == a4)
          {
            uint64_t v106 = v105;
            (*(void (**)(void *, void *))(*a4 + 24))(a4, v105);
            goto LABEL_35;
          }
          uint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)v35 + 16))(v35);
        }
        uint64_t v106 = (void *)v35;
LABEL_35:
        uint64_t v36 = v33;
        uint64_t v37 = (uint64_t *)[v88 commitRangesToExtrusionFillRenderItemBatcher:a2 + 784 forMeshAtIndex:v33 cullingMask:v34 featureIdPredicate:v105];
        if (v106 == v105)
        {
          (*(void (**)(void *))(v105[0] + 32))(v105);
        }
        else if (v106)
        {
          (*(void (**)(void))(*v106 + 40))();
        }
        uint64_t v38 = *v32;
        uint64_t v39 = *(void **)(a2 + 872);
        uint64_t v40 = v39[1];
        if (v40 == *(void *)(a2 + 880))
        {
          uint64_t v39 = (void *)*v39;
          if (!v39)
          {
            uint64_t v39 = malloc_type_malloc(120 * v40 + 16, 0xB644C221uLL);
            void *v39 = 0;
            v39[1] = 0;
            **(void **)(a2 + 872) = v39;
          }
          *(void *)(a2 + 872) = v39;
          uint64_t v40 = v39[1];
        }
        uint64_t v41 = &v39[15 * v40];
        v39[1] = v40 + 1;
        v41[2] = &off_1EF55A458;
        *(_OWORD *)(v41 + 9) = *(_OWORD *)v100;
        *(_OWORD *)(v41 + 7) = v99;
        *(_OWORD *)(v41 + 5) = v98;
        *(_OWORD *)(v41 + 3) = v97;
        *(_OWORD *)(v41 + 15) = *(_OWORD *)&v100[48];
        *(_OWORD *)(v41 + 13) = *(_OWORD *)&v100[32];
        *(_OWORD *)(v41 + 11) = *(_OWORD *)&v100[16];
        _OWORD v41[10] = v38;
        uint64_t v42 = *v37;
        v41[13] = *v37;
        v41[14] = (v37[1] - v42) >> 4;
        ggl::CommandBuffer::pushRenderItem(v89, (uint64_t)(v41 + 2));
        uint64_t v43 = *v32;
        uint64_t v44 = *(void **)(a2 + 872);
        uint64_t v45 = v44[1];
        if (v45 == *(void *)(a2 + 880))
        {
          uint64_t v44 = (void *)*v44;
          if (!v44)
          {
            uint64_t v44 = malloc_type_malloc(120 * v45 + 16, 0xB644C221uLL);
            void *v44 = 0;
            v44[1] = 0;
            **(void **)(a2 + 872) = v44;
          }
          *(void *)(a2 + 872) = v44;
          uint64_t v45 = v44[1];
        }
        uint64_t v46 = &v44[15 * v45];
        v44[1] = v45 + 1;
        v46[2] = &off_1EF55A458;
        *(_OWORD *)(v46 + 9) = *(_OWORD *)v96;
        *(_OWORD *)(v46 + 7) = v95;
        *(_OWORD *)(v46 + 5) = v92;
        *(_OWORD *)(v46 + 3) = v90;
        *(_OWORD *)(v46 + 15) = *(_OWORD *)&v96[48];
        *(_OWORD *)(v46 + 13) = *(_OWORD *)&v96[32];
        *(_OWORD *)(v46 + 11) = *(_OWORD *)&v96[16];
        v46[10] = v43;
        uint64_t v47 = *v37;
        v46[13] = *v37;
        v46[14] = (v37[1] - v47) >> 4;
        v46[8] = v36 + 2 * *(unsigned int *)(v12 + 76);
        ggl::CommandBuffer::pushRenderItem(v89, (uint64_t)(v46 + 2));
        unsigned __int8 v33 = v36 + 1;
        ++v32;
      }
      while (v32 != v85);
    }
  }
  *(void *)&long long v98 = v82;
  *((void *)&v98 + 1) = *(void *)(v12 + 48);
  *(void *)&long long v93 = v83;
  *((void *)&v93 + 1) = *(void *)(v12 + 56);
  uint64_t v48 = (uint64_t **)[v88 pointyRoofFillMeshVendor];
  int v49 = *v48;
  if (*(void *)(**(void **)(**v48 + 64) + 48) != *(void *)(**(void **)(**v48 + 64) + 40))
  {
    uint64_t v86 = v48[1];
    if (v49 != v86)
    {
      unsigned __int8 v50 = 0;
      do
      {
        uint64_t v51 = *(unsigned int *)(v12 + 72);
        uint64_t v52 = a4[3];
        if (v52)
        {
          if ((void *)v52 == a4)
          {
            unint64_t v104 = v103;
            (*(void (**)(void *, void *))(*a4 + 24))(a4, v103);
            goto LABEL_56;
          }
          uint64_t v52 = (*(uint64_t (**)(uint64_t))(*(void *)v52 + 16))(v52);
        }
        unint64_t v104 = (void *)v52;
LABEL_56:
        uint64_t v53 = v50;
        std::string::pointer v54 = (uint64_t *)[v88 commitRangesToPointyRoofFillRenderItemBatcher:a2 + 784 forMeshAtIndex:v50 cullingMask:v51 featureIdPredicate:v103];
        if (v104 == v103)
        {
          (*(void (**)(void *))(v103[0] + 32))(v103);
        }
        else if (v104)
        {
          (*(void (**)(void))(*v104 + 40))();
        }
        uint64_t v55 = *v49;
        unint64_t v56 = *(void **)(a2 + 872);
        uint64_t v57 = v56[1];
        if (v57 == *(void *)(a2 + 880))
        {
          unint64_t v56 = (void *)*v56;
          if (!v56)
          {
            unint64_t v56 = malloc_type_malloc(120 * v57 + 16, 0xB644C221uLL);
            *unint64_t v56 = 0;
            v56[1] = 0;
            **(void **)(a2 + 872) = v56;
          }
          *(void *)(a2 + 872) = v56;
          uint64_t v57 = v56[1];
        }
        size_t v58 = &v56[15 * v57];
        v56[1] = v57 + 1;
        v58[2] = &off_1EF55A458;
        *(_OWORD *)(v58 + 9) = *(_OWORD *)v100;
        *(_OWORD *)(v58 + 7) = v99;
        *(_OWORD *)(v58 + 5) = v98;
        *(_OWORD *)(v58 + 3) = v97;
        *(_OWORD *)(v58 + 15) = *(_OWORD *)&v100[48];
        *(_OWORD *)(v58 + 13) = *(_OWORD *)&v100[32];
        *(_OWORD *)(v58 + 11) = *(_OWORD *)&v100[16];
        v58[10] = v55;
        uint64_t v59 = *v54;
        v58[13] = *v54;
        v58[14] = (v54[1] - v59) >> 4;
        ggl::CommandBuffer::pushRenderItem(v89, (uint64_t)(v58 + 2));
        uint64_t v60 = *v49;
        unint64_t v61 = *(void **)(a2 + 872);
        uint64_t v62 = v61[1];
        if (v62 == *(void *)(a2 + 880))
        {
          unint64_t v61 = (void *)*v61;
          if (!v61)
          {
            unint64_t v61 = malloc_type_malloc(120 * v62 + 16, 0xB644C221uLL);
            void *v61 = 0;
            v61[1] = 0;
            **(void **)(a2 + 872) = v61;
          }
          *(void *)(a2 + 872) = v61;
          uint64_t v62 = v61[1];
        }
        size_t v63 = &v61[15 * v62];
        v61[1] = v62 + 1;
        v63[2] = &off_1EF55A458;
        *(_OWORD *)(v63 + 9) = *(_OWORD *)v96;
        *(_OWORD *)(v63 + 7) = v95;
        *(_OWORD *)(v63 + 5) = v93;
        *(_OWORD *)(v63 + 3) = v90;
        *(_OWORD *)(v63 + 15) = *(_OWORD *)&v96[48];
        *(_OWORD *)(v63 + 13) = *(_OWORD *)&v96[32];
        *(_OWORD *)(v63 + 11) = *(_OWORD *)&v96[16];
        v63[10] = v60;
        uint64_t v64 = *v54;
        v63[13] = *v54;
        v63[14] = (v54[1] - v64) >> 4;
        v63[8] = 3 * *(unsigned int *)(v12 + 76) + v53;
        ggl::CommandBuffer::pushRenderItem(v89, (uint64_t)(v63 + 2));
        unsigned __int8 v50 = v53 + 1;
        ++v49;
      }
      while (v49 != v86);
    }
  }
  if (*(unsigned char *)(a2 + 769))
  {
    *(void *)&long long v98 = *(void *)(a2 + 704);
    *((void *)&v98 + 1) = *(void *)(v12 + 64);
    long long v94 = v98;
    uint64_t v65 = (uint64_t **)[v88 extrusionStrokeMeshVendor];
    uint64_t v66 = *v65;
    if (*(void *)(**(void **)(**v65 + 64) + 48) != *(void *)(**(void **)(**v65 + 64) + 40))
    {
      std::string::size_type v87 = v65[1];
      if (v66 != v87)
      {
        unsigned __int8 v67 = 0;
        do
        {
          uint64_t v68 = *(unsigned int *)(v12 + 72);
          uint64_t v69 = a4[3];
          if (v69)
          {
            if ((void *)v69 == a4)
            {
              unint64_t v102 = v101;
              (*(void (**)(void *, void *))(*a4 + 24))(a4, v101);
              goto LABEL_78;
            }
            uint64_t v69 = (*(uint64_t (**)(uint64_t))(*(void *)v69 + 16))(v69);
          }
          unint64_t v102 = (void *)v69;
LABEL_78:
          uint64_t v70 = v67;
          uint64_t v71 = (uint64_t *)[v88 commitRangesToExtrusionStrokeRenderItemBatcher:a2 + 784 forMeshAtIndex:v67 cullingMask:v68 featureIdPredicate:v101];
          if (v102 == v101)
          {
            (*(void (**)(void *))(v101[0] + 32))(v101);
          }
          else if (v102)
          {
            (*(void (**)(void))(*v102 + 40))();
          }
          uint64_t v72 = *v66;
          std::string::size_type v73 = *(void **)(a2 + 872);
          uint64_t v74 = v73[1];
          if (v74 == *(void *)(a2 + 880))
          {
            std::string::size_type v73 = (void *)*v73;
            if (!v73)
            {
              std::string::size_type v73 = malloc_type_malloc(120 * v74 + 16, 0xB644C221uLL);
              void *v73 = 0;
              v73[1] = 0;
              **(void **)(a2 + 872) = v73;
            }
            *(void *)(a2 + 872) = v73;
            uint64_t v74 = v73[1];
          }
          uint64_t v75 = &v73[15 * v74];
          v73[1] = v74 + 1;
          v75[2] = &off_1EF55A458;
          *(_OWORD *)(v75 + 9) = *(_OWORD *)v100;
          *(_OWORD *)(v75 + 7) = v99;
          *(_OWORD *)(v75 + 5) = v98;
          *(_OWORD *)(v75 + 3) = v97;
          *(_OWORD *)(v75 + 15) = *(_OWORD *)&v100[48];
          *(_OWORD *)(v75 + 13) = *(_OWORD *)&v100[32];
          *(_OWORD *)(v75 + 11) = *(_OWORD *)&v100[16];
          v75[10] = v72;
          uint64_t v76 = *v71;
          v75[13] = *v71;
          v75[14] = (v71[1] - v76) >> 4;
          ggl::CommandBuffer::pushRenderItem(v89, (uint64_t)(v75 + 2));
          uint64_t v77 = *v66;
          size_t v78 = *(void **)(a2 + 872);
          uint64_t v79 = v78[1];
          if (v79 == *(void *)(a2 + 880))
          {
            size_t v78 = (void *)*v78;
            if (!v78)
            {
              size_t v78 = malloc_type_malloc(120 * v79 + 16, 0xB644C221uLL);
              *size_t v78 = 0;
              v78[1] = 0;
              **(void **)(a2 + 872) = v78;
            }
            *(void *)(a2 + 872) = v78;
            uint64_t v79 = v78[1];
          }
          uint64_t v80 = &v78[15 * v79];
          v78[1] = v79 + 1;
          v80[2] = &off_1EF55A458;
          *(_OWORD *)(v80 + 9) = *(_OWORD *)v96;
          *(_OWORD *)(v80 + 7) = v95;
          *(_OWORD *)(v80 + 5) = v94;
          *(_OWORD *)(v80 + 3) = v90;
          *(_OWORD *)(v80 + 15) = *(_OWORD *)&v96[48];
          *(_OWORD *)(v80 + 13) = *(_OWORD *)&v96[32];
          *(_OWORD *)(v80 + 11) = *(_OWORD *)&v96[16];
          v80[10] = v77;
          uint64_t v81 = *v71;
          v80[13] = *v71;
          v80[14] = (v71[1] - v81) >> 4;
          v80[8] = v70 + 4 * *(unsigned int *)(v12 + 76);
          ggl::CommandBuffer::pushRenderItem(v89, (uint64_t)(v80 + 2));
          unsigned __int8 v67 = v70 + 1;
          ++v66;
        }
        while (v66 != v87);
      }
    }
  }
}

void sub_1A23A85B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void md::BuildingRenderLayer::updateFadeParametersWithLayoutContext(md::BuildingRenderLayer *this, const md::LayoutContext *a2)
{
  id v4 = (uint64_t *)*((void *)a2 + 1);
  int8x8_t v5 = (int8x8_t)v4[1];
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] >= 2uLL)
  {
    unint64_t v10 = 0xC97B9E962ADF4AD4;
    if (*(void *)&v5 <= 0xC97B9E962ADF4AD4) {
      unint64_t v10 = 0xC97B9E962ADF4AD4 % *(void *)&v5;
    }
    uint64_t v8 = *v4;
    uint64_t v9 = *(void **)(v8 + 8 * v10);
    do
    {
      do
        uint64_t v9 = (void *)*v9;
      while (v9[1] != 0xC97B9E962ADF4AD4);
    }
    while (v9[2] != 0xC97B9E962ADF4AD4);
    uint64_t v7 = *(void *)&v5 - 1;
  }
  else
  {
    uint64_t v7 = *(void *)&v5 - 1;
    uint64_t v8 = *v4;
    uint64_t v9 = *(void **)(v8 + 8 * ((*(void *)&v5 - 1) & 0xC97B9E962ADF4AD4));
    do
    {
      do
        uint64_t v9 = (void *)*v9;
      while (v9[1] != 0xC97B9E962ADF4AD4);
    }
    while (v9[2] != 0xC97B9E962ADF4AD4);
  }
  uint64_t v11 = *(uint64_t **)(v9[5] + 32);
  uint64_t v12 = *v11;
  uint64_t v13 = v11[1];
  if (v12 != v13)
  {
    while (*(unsigned char *)v12 != 20)
    {
      v12 += 16;
      if (v12 == v13) {
        goto LABEL_18;
      }
    }
  }
  if (v12 == v13) {
LABEL_18:
  }
    uint64_t v14 = 0;
  else {
    uint64_t v14 = *(unsigned int *)(v12 + 8);
  }
  if (v6.u32[0] >= 2uLL)
  {
    unint64_t v16 = 0xE42D19AFCA302E68;
    if (*(void *)&v5 <= 0xE42D19AFCA302E68) {
      unint64_t v16 = 0xE42D19AFCA302E68 % *(void *)&v5;
    }
    unsigned __int8 v15 = *(void **)(v8 + 8 * v16);
    do
    {
      do
        unsigned __int8 v15 = (void *)*v15;
      while (v15[1] != 0xE42D19AFCA302E68);
    }
    while (v15[2] != 0xE42D19AFCA302E68);
  }
  else
  {
    unsigned __int8 v15 = *(void **)(v8 + 8 * (v7 & 0xE42D19AFCA302E68));
    do
    {
      do
        unsigned __int8 v15 = (void *)*v15;
      while (v15[1] != 0xE42D19AFCA302E68);
    }
    while (v15[2] != 0xE42D19AFCA302E68);
  }
  uint64_t v17 = *(void *)(*(void *)(v15[5] + 32) + 16);
  long long v102 = 0uLL;
  uint64_t v103 = 0;
  uint64_t v104 = gss::Allocator::instance(this);
  memset(v107, 0, sizeof(v107));
  char v108 = 1;
  gss::StylesheetManager<gss::ScenePropertyID>::styleQueryForFeatureAttributes((uint64_t *)&v110, v17, (gss::FeatureAttributeSet *)&v102, (gss::QueryOverrides *)v107);
  if ((void)v102)
  {
    *((void *)&v102 + 1) = v102;
    (*(void (**)(uint64_t, void, void))(*(void *)v104 + 40))(v104, v102, v103 - v102);
  }
  long long v18 = v110;
  long long v102 = v110;
  if (*((void *)&v110 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v110 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::ScenePropertyID>::QueryableLocker((uint64_t *)v107, v18, *((uint64_t *)&v18 + 1));
  if (*((void *)&v18 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v18 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**((void **)&v18 + 1) + 16))(*((void *)&v18 + 1));
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v18 + 1));
  }
  int v19 = (uint64_t *)*((void *)this + 47);
  uint64_t v20 = *v19;
  long long v102 = 0uLL;
  unint64_t v21 = *(void *)(v20 + 8);
  *(void *)&long long v22 = 0;
  *((void *)&v22 + 1) = v20;
  long long v101 = v22;
  if (v21) {
    uint64_t v23 = *(void *)(v20 + 72);
  }
  else {
    uint64_t v23 = 0;
  }
  long long v102 = v22;
  uint64_t v103 = 0;
  uint64_t v104 = v21;
  uint64_t v106 = v23;
  __int16 v105 = 1;
  if (!v109)
  {
    *((unsigned char *)v19 + 18) = 0;
    *(_DWORD *)(v23 + 8) = 1065353216;
    *(_DWORD *)uint64_t v23 = 0;
    *(float *)(v23 + 4) = 1.0;
    if (!v21) {
      goto LABEL_123;
    }
    goto LABEL_117;
  }
  uint64_t v24 = *(void *)(*(void *)v107 + 24);
  uint64_t v25 = *(float **)v24;
  if (*(void *)v24
    && (float v26 = *v25, LODWORD(v25) = *v25 == 1.0, *(unsigned char *)(v24 + 10))
    && (v26 != 0.0 ? (BOOL v27 = v26 == 1.0) : (BOOL v27 = 1), !v27)
    || (unsigned int v28 = *(unsigned __int8 *)(v24 + v25 + 11), v26 = 0.0, v28 == 2))
  {
    char v112 = 1;
    char v111 = 1;
    uint64_t v29 = (float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(v24, 0x39u, 0, &v112);
    float v30 = *v29
        + (float)((float)(*(float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(v24, 0x39u, 1u, &v111)- *v29)* v26);
  }
  else
  {
    float v30 = *(float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(*(void *)(*(void *)v107 + 24), 0x39u, v28, 0);
  }
  uint64_t v31 = *(void *)(*(void *)v107 + 24);
  uint64_t v32 = *(float **)v31;
  if (*(void *)v31 && (float v33 = *v32, LODWORD(v32) = *v32 == 1.0, *(unsigned char *)(v31 + 10)) && v33 != 0.0 && v33 != 1.0
    || (v34 = *(unsigned __int8 *)(v31 + v32 + 11), float v33 = 0.0, v34 == 2))
  {
    char v112 = 1;
    char v111 = 1;
    uint64_t v35 = (float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(v31, 0x40u, 0, &v112);
    float v36 = *v35
        + (float)((float)(*(float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(v31, 0x40u, 1u, &v111)- *v35)* v33);
  }
  else
  {
    float v36 = *(float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(*(void *)(*(void *)v107 + 24), 0x40u, v34, 0);
  }
  uint64_t v37 = *(void *)(*(void *)v107 + 24);
  uint64_t v38 = *(float **)v37;
  if (*(void *)v37 && (float v39 = *v38, LODWORD(v38) = *v38 == 1.0, *(unsigned char *)(v37 + 10)) && v39 != 0.0 && v39 != 1.0
    || (v40 = *(unsigned __int8 *)(v37 + v38 + 11), float v39 = 0.0, v40 == 2))
  {
    char v112 = 1;
    char v111 = 1;
    uint64_t v41 = (float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(v37, 0x3Au, 0, &v112);
    float v42 = *v41
        + (float)((float)(*(float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(v37, 0x3Au, 1u, &v111)- *v41)* v39);
  }
  else
  {
    float v42 = *(float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(*(void *)(*(void *)v107 + 24), 0x3Au, v40, 0);
  }
  uint64_t v43 = *(void *)(*(void *)v107 + 24);
  uint64_t v44 = *(float **)v43;
  if (*(void *)v43 && (float v45 = *v44, LODWORD(v44) = *v44 == 1.0, *(unsigned char *)(v43 + 10)) && v45 != 0.0 && v45 != 1.0
    || (v46 = *(unsigned __int8 *)(v43 + v44 + 11), float v45 = 0.0, v46 == 2))
  {
    char v112 = 1;
    char v111 = 1;
    uint64_t v47 = (float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(v43, 0x41u, 0, &v112);
    float v48 = *v47
        + (float)((float)(*(float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(v43, 0x41u, 1u, &v111)- *v47)* v45);
  }
  else
  {
    float v48 = *(float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(*(void *)(*(void *)v107 + 24), 0x41u, v46, 0);
  }
  uint64_t v49 = *(void *)(*(void *)v107 + 24);
  unsigned __int8 v50 = *(float **)v49;
  if (*(void *)v49 && (float v51 = *v50, LODWORD(v50) = *v50 == 1.0, *(unsigned char *)(v49 + 10)) && v51 != 0.0 && v51 != 1.0
    || (v52 = *(unsigned __int8 *)(v49 + v50 + 11), float v51 = 0.0, v52 == 2))
  {
    char v112 = 1;
    char v111 = 1;
    uint64_t v53 = (float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(v49, 0x3Cu, 0, &v112);
    float v54 = *v53
        + (float)((float)(*(float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(v49, 0x3Cu, 1u, &v111)- *v53)* v51);
  }
  else
  {
    float v54 = *(float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(*(void *)(*(void *)v107 + 24), 0x3Cu, v52, 0);
  }
  float v55 = (float)(v36 * 2.0) + -1.0;
  float v56 = -1.0;
  float v57 = (float)(v54 * 2.0) + -1.0;
  if (v14 == 5)
  {
    uint64_t v58 = md::LayoutContext::frameState(a2);
    double v59 = *(double *)(v58 + 64);
    double v60 = *(double *)(v58 + 72);
    long double v61 = tan(*(double *)(v58 + 56) * 0.5 + 0.785398163);
    long double v62 = log(v61);
    size_t v63 = (void *)*((void *)a2 + 1);
    unint64_t v64 = v63[1];
    float v100 = v42;
    double v98 = v62;
    if ((v64 & (v64 - 1)) != 0)
    {
      unint64_t v66 = 0x1AF456233693CD46;
      if (v64 <= 0x1AF456233693CD46) {
        unint64_t v66 = 0x1AF456233693CD46 % v64;
      }
      uint64_t v65 = *(void **)(*v63 + 8 * v66);
      do
      {
        do
          uint64_t v65 = (void *)*v65;
        while (v65[1] != 0x1AF456233693CD46);
      }
      while (v65[2] != 0x1AF456233693CD46);
    }
    else
    {
      uint64_t v65 = *(void **)(*v63 + 8 * ((v64 - 1) & 0x1AF456233693CD46));
      do
      {
        do
          uint64_t v65 = (void *)*v65;
        while (v65[1] != 0x1AF456233693CD46);
      }
      while (v65[2] != 0x1AF456233693CD46);
    }
    float v99 = v48;
    unsigned __int8 v67 = *(double **)(v65[5] + 32);
    double v96 = v67[106];
    double v97 = v67[102];
    double v94 = v67[104];
    double v95 = v67[110];
    double v92 = v67[114];
    double v93 = v67[108];
    double v68 = v67[116];
    double v91 = v67[112];
    uint64_t v69 = *(void *)(*(void *)v107 + 24);
    uint64_t v70 = *(float **)v69;
    if (*(void *)v69
      && (float v71 = *v70, LODWORD(v70) = *v70 == 1.0, *(unsigned char *)(v69 + 10))
      && (v71 != 0.0 ? (BOOL v72 = v71 == 1.0) : (BOOL v72 = 1), !v72)
      || (v73 = *(unsigned __int8 *)(v69 + v70 + 11), float v71 = 0.0, v73 == 2))
    {
      char v112 = 1;
      char v111 = 1;
      uint64_t v74 = (float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(v69, 0x3Bu, 0, &v112);
      double v75 = v59;
      float v76 = *v74
          + (float)((float)(*(float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(v69, 0x3Bu, 1u, &v111)- *v74)* v71);
    }
    else
    {
      double v75 = v59;
      float v76 = *(float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(*(void *)(*(void *)v107 + 24), 0x3Bu, v73, 0);
    }
    float v77 = v30;
    uint64_t v78 = *(void *)(*(void *)v107 + 24);
    uint64_t v79 = *(float **)v78;
    if (*(void *)v78
      && (float v80 = *v79, LODWORD(v79) = *v79 == 1.0, *(unsigned char *)(v78 + 10))
      && (v80 != 0.0 ? (BOOL v81 = v80 == 1.0) : (BOOL v81 = 1), !v81)
      || (v82 = *(unsigned __int8 *)(v78 + v79 + 11), float v80 = 0.0, v82 == 2))
    {
      char v112 = 1;
      char v111 = 1;
      uint64_t v83 = (float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(v78, 0x3Du, 0, &v112);
      float v84 = *v83
          + (float)((float)(*(float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(v78, 0x3Du, 1u, &v111)- *v83)* v80);
    }
    else
    {
      float v84 = *(float *)gss::RenderStyle<gss::ScenePropertyID>::styleValueForKey<float>(*(void *)(*(void *)v107 + 24), 0x3Du, v82, 0);
    }
    float v30 = v77;
    float v85 = (v92 + v97 * (v75 * 0.159154943 + 0.5) + v96 * (v98 * 0.159154943 + 0.5) + v95 * v60)
        / (v68 + v94 * (v75 * 0.159154943 + 0.5) + v93 * (v98 * 0.159154943 + 0.5) + v91 * v60);
    float v55 = fminf(fmaxf(v85 + (float)(v76 * 2.0), v55), (float)(v100 * 2.0) + -1.0);
    float v57 = fminf(fmaxf(v85 + (float)(v84 * 2.0), (float)(v99 * 2.0) + -1.0), v57);
    float v56 = -1.0;
  }
  float v86 = 1.0;
  if (v55 < v57) {
    float v86 = v30;
  }
  float v87 = -2.0;
  if (v55 < v57)
  {
    float v87 = v55;
    float v56 = v57;
  }
  *(unsigned char *)(*((void *)this + 47) + 18) = v86 < 0.999;
  *(float *)(v23 + 8) = v86;
  float v88 = (1.0 - v86) / (float)(v56 - v87);
  *(float *)uint64_t v23 = v88;
  *(float *)(v23 + 4) = v86 - (float)(v87 * v88);
  if (v21)
  {
LABEL_117:
    if ((void)v101 && *(unsigned char *)(*((void *)&v101 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v101 + 64))();
    }
    unint64_t v89 = *(void *)(*((void *)&v101 + 1) + 64);
    if (v89 <= v21) {
      unint64_t v89 = v21;
    }
    *(void *)(*((void *)&v101 + 1) + 56) = 0;
    *(void *)(*((void *)&v101 + 1) + 64) = v89;
  }
LABEL_123:
  gss::QueryableLocker<gss::ScenePropertyID>::~QueryableLocker((uint64_t)v107);
  long long v90 = (std::__shared_weak_count *)*((void *)&v110 + 1);
  if (*((void *)&v110 + 1))
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v110 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
      std::__shared_weak_count::__release_weak(v90);
    }
  }
}

void sub_1A23A90E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a21);
  gss::QueryableLocker<gss::ScenePropertyID>::~QueryableLocker((uint64_t)&a27);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v27 - 152);
  _Unwind_Resume(a1);
}

void md::BuildingRenderLayer::layout3DBuildings(void *a1, uint64_t **a2, uint64_t a3, int8x8_t **a4, int a5, int a6)
{
  uint64_t v192 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = a4[1];
  int8x8_t v12 = v11[1];
  if (!*(void *)&v12) {
    goto LABEL_26;
  }
  uint8x8_t v13 = (uint8x8_t)vcnt_s8(v12);
  v13.i16[0] = vaddlv_u8(v13);
  if (v13.u32[0] > 1uLL)
  {
    uint64_t v14 = 0x401D4CCE847AB1D1;
    if (*(void *)&v12 <= 0x401D4CCE847AB1D1uLL) {
      uint64_t v14 = 0x401D4CCE847AB1D1uLL % *(void *)&v12;
    }
  }
  else
  {
    uint64_t v14 = (*(void *)&v12 - 1) & 0x401D4CCE847AB1D1;
  }
  unsigned __int8 v15 = *(void **)(*(void *)v11 + 8 * v14);
  if (!v15) {
    goto LABEL_26;
  }
  unint64_t v16 = (void *)*v15;
  if (!v16) {
    goto LABEL_26;
  }
  if (v13.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v18 = v16[1];
      if (v18 == 0x401D4CCE847AB1D1)
      {
        if (v16[2] == 0x401D4CCE847AB1D1) {
          goto LABEL_22;
        }
      }
      else if ((v18 & (*(void *)&v12 - 1)) != v14)
      {
        goto LABEL_26;
      }
      unint64_t v16 = (void *)*v16;
      if (!v16) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v17 = v16[1];
    if (v17 == 0x401D4CCE847AB1D1) {
      break;
    }
    if (v17 >= *(void *)&v12) {
      v17 %= *(void *)&v12;
    }
    if (v17 != v14) {
      goto LABEL_26;
    }
LABEL_11:
    unint64_t v16 = (void *)*v16;
    if (!v16) {
      goto LABEL_26;
    }
  }
  if (v16[2] != 0x401D4CCE847AB1D1) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v19 = v16[5];
  if (*(void *)(v19 + 8) == 0x401D4CCE847AB1D1)
  {
    uint64_t v20 = *(void *)(v19 + 32);
    if (v20)
    {
      if (*(unsigned char *)(v20 + 16))
      {
        uint64_t v21 = *(void *)(v20 + 8);
        goto LABEL_27;
      }
    }
  }
LABEL_26:
  uint64_t v21 = 0;
LABEL_27:
  if (a5 != 1 || v21)
  {
    md::LayoutContext::zoomAtCentrePoint(a4[1]);
    float v23 = 1.0;
    if (a6 != 1
      || ((float v24 = fmaxf((float)(v22 * 2.0) + -31.0, 0.0), v24 <= 1.0) ? (v23 = 1.0 - v24) : (v23 = 0.0),
          v23 >= 0.00000011921))
    {
      if (v12)
      {
        uint8x8_t v25 = (uint8x8_t)vcnt_s8(v12);
        v25.i16[0] = vaddlv_u8(v25);
        if (v25.u32[0] > 1uLL)
        {
          uint64_t v26 = 0x7C7EC6C7C111B0D0;
          if (*(void *)&v12 <= 0x7C7EC6C7C111B0D0uLL) {
            uint64_t v26 = 0x7C7EC6C7C111B0D0uLL % *(void *)&v12;
          }
        }
        else
        {
          uint64_t v26 = (*(void *)&v12 - 1) & 0x7C7EC6C7C111B0D0;
        }
        int8x8_t v27 = *v11;
        unsigned int v28 = *(void **)(*(void *)v11 + 8 * v26);
        if (v28)
        {
          uint64_t v29 = (void *)*v28;
          if (*v28)
          {
            uint64_t v30 = *(void *)&v12 - 1;
            if (v25.u32[0] < 2uLL)
            {
              do
              {
                uint64_t v31 = v29[1];
                if (v31 == 0x7C7EC6C7C111B0D0)
                {
                  if (v29[2] == 0x7C7EC6C7C111B0D0) {
                    goto LABEL_55;
                  }
                }
                else if ((v31 & v30) != v26)
                {
                  return;
                }
                uint64_t v29 = (void *)*v29;
              }
              while (v29);
            }
            while (1)
            {
              unint64_t v32 = v29[1];
              if (v32 == 0x7C7EC6C7C111B0D0) {
                break;
              }
              if (v32 >= *(void *)&v12) {
                v32 %= *(void *)&v12;
              }
              if (v32 != v26) {
                return;
              }
LABEL_49:
              uint64_t v29 = (void *)*v29;
              if (!v29) {
                return;
              }
            }
            if (v29[2] != 0x7C7EC6C7C111B0D0) {
              goto LABEL_49;
            }
LABEL_55:
            uint64_t v33 = v29[5];
            if (*(void *)(v33 + 8) == 0x7C7EC6C7C111B0D0)
            {
              uint64_t v34 = *(void *)(v33 + 32);
              if (v34)
              {
                if (v25.u32[0] > 1uLL)
                {
                  uint64_t v35 = 0x41E8D6E445F4145;
                  if (*(void *)&v12 <= 0x41E8D6E445F4145uLL) {
                    uint64_t v35 = 0x41E8D6E445F4145uLL % *(void *)&v12;
                  }
                }
                else
                {
                  uint64_t v35 = v30 & 0x41E8D6E445F4145;
                }
                float v36 = *(void **)(*(void *)&v27 + 8 * v35);
                if (v36)
                {
                  uint64_t v37 = (void *)*v36;
                  if (v37)
                  {
                    if (v25.u32[0] < 2uLL)
                    {
                      while (1)
                      {
                        uint64_t v38 = v37[1];
                        if (v38 == 0x41E8D6E445F4145)
                        {
                          if (v37[2] == 0x41E8D6E445F4145) {
                            goto LABEL_77;
                          }
                        }
                        else if ((v38 & v30) != v35)
                        {
                          return;
                        }
                        uint64_t v37 = (void *)*v37;
                        if (!v37) {
                          return;
                        }
                      }
                    }
                    while (1)
                    {
                      unint64_t v39 = v37[1];
                      if (v39 == 0x41E8D6E445F4145) {
                        break;
                      }
                      if (v39 >= *(void *)&v12) {
                        v39 %= *(void *)&v12;
                      }
                      if (v39 != v35) {
                        return;
                      }
LABEL_71:
                      uint64_t v37 = (void *)*v37;
                      if (!v37) {
                        return;
                      }
                    }
                    if (v37[2] != 0x41E8D6E445F4145) {
                      goto LABEL_71;
                    }
LABEL_77:
                    uint64_t v40 = v37[5];
                    if (*(void *)(v40 + 8) == 0x41E8D6E445F4145 && *(void *)(v40 + 32))
                    {
                      if (v25.u32[0] > 1uLL)
                      {
                        unint64_t v41 = 0xA60DDA5A69582425;
                        if (*(void *)&v12 <= 0xA60DDA5A69582425) {
                          unint64_t v41 = 0xA60DDA5A69582425 % *(void *)&v12;
                        }
                      }
                      else
                      {
                        unint64_t v41 = v30 & 0xA60DDA5A69582425;
                      }
                      float v42 = *(void **)(*(void *)&v27 + 8 * v41);
                      if (v42)
                      {
                        uint64_t v43 = (void *)*v42;
                        if (v43)
                        {
                          uint64_t v148 = v34;
                          if (v25.u32[0] < 2uLL)
                          {
                            while (1)
                            {
                              uint64_t v44 = v43[1];
                              if (v44 == 0xA60DDA5A69582425)
                              {
                                if (v43[2] == 0xA60DDA5A69582425) {
                                  goto LABEL_99;
                                }
                              }
                              else if ((v44 & v30) != v41)
                              {
                                return;
                              }
                              uint64_t v43 = (void *)*v43;
                              if (!v43) {
                                return;
                              }
                            }
                          }
                          while (1)
                          {
                            unint64_t v45 = v43[1];
                            if (v45 == 0xA60DDA5A69582425) {
                              break;
                            }
                            if (v45 >= *(void *)&v12) {
                              v45 %= *(void *)&v12;
                            }
                            if (v45 != v41) {
                              return;
                            }
LABEL_93:
                            uint64_t v43 = (void *)*v43;
                            if (!v43) {
                              return;
                            }
                          }
                          if (v43[2] != 0xA60DDA5A69582425) {
                            goto LABEL_93;
                          }
LABEL_99:
                          uint64_t v46 = v43[5];
                          if (*(void *)(v46 + 8) == 0xA60DDA5A69582425)
                          {
                            std::string::size_type v147 = *(id **)(v46 + 32);
                            if (v147)
                            {
                              uint64_t v143 = a3;
                              if (v25.u32[0] > 1uLL)
                              {
                                uint64_t v47 = 0x1AF456233693CD46;
                                if (*(void *)&v12 <= 0x1AF456233693CD46uLL) {
                                  uint64_t v47 = 0x1AF456233693CD46uLL % *(void *)&v12;
                                }
                              }
                              else
                              {
                                uint64_t v47 = v30 & 0x1AF456233693CD46;
                              }
                              float v48 = *(void **)(*(void *)&v27 + 8 * v47);
                              if (!v48) {
                                goto LABEL_123;
                              }
                              uint64_t v49 = (void *)*v48;
                              if (!v49) {
                                goto LABEL_123;
                              }
                              if (v25.u32[0] < 2uLL)
                              {
                                while (1)
                                {
                                  uint64_t v50 = v49[1];
                                  if (v50 == 0x1AF456233693CD46)
                                  {
                                    if (v49[2] == 0x1AF456233693CD46) {
                                      goto LABEL_121;
                                    }
                                  }
                                  else if ((v50 & v30) != v47)
                                  {
                                    goto LABEL_123;
                                  }
                                  uint64_t v49 = (void *)*v49;
                                  if (!v49) {
                                    goto LABEL_123;
                                  }
                                }
                              }
                              while (1)
                              {
                                unint64_t v51 = v49[1];
                                if (v51 == 0x1AF456233693CD46) {
                                  break;
                                }
                                if (v51 >= *(void *)&v12) {
                                  v51 %= *(void *)&v12;
                                }
                                if (v51 != v47) {
                                  goto LABEL_123;
                                }
LABEL_115:
                                uint64_t v49 = (void *)*v49;
                                if (!v49) {
                                  goto LABEL_123;
                                }
                              }
                              if (v49[2] != 0x1AF456233693CD46) {
                                goto LABEL_115;
                              }
LABEL_121:
                              uint64_t v52 = v49[5];
                              if (*(void *)(v52 + 8) != 0x1AF456233693CD46)
                              {
LABEL_123:
                                uint64_t v141 = 0;
                                goto LABEL_124;
                              }
                              uint64_t v141 = *(void *)(v52 + 32);
LABEL_124:
                              md::BuildingRenderLayer::updateFadeParametersWithLayoutContext((md::BuildingRenderLayer *)a1, (const md::LayoutContext *)a4);
                              uint64_t v53 = a4[1];
                              int8x8_t v54 = v53[1];
                              float v55 = 0.0;
                              if (!*(void *)&v54) {
                                goto LABEL_148;
                              }
                              uint8x8_t v56 = (uint8x8_t)vcnt_s8(v54);
                              v56.i16[0] = vaddlv_u8(v56);
                              if (v56.u32[0] > 1uLL)
                              {
                                uint64_t v57 = 0x4927EB92E562CC46;
                                if (*(void *)&v54 <= 0x4927EB92E562CC46uLL) {
                                  uint64_t v57 = 0x4927EB92E562CC46uLL % *(void *)&v54;
                                }
                              }
                              else
                              {
                                uint64_t v57 = (*(void *)&v54 - 1) & 0x4927EB92E562CC46;
                              }
                              uint64_t v58 = *(void **)(*(void *)v53 + 8 * v57);
                              if (!v58) {
                                goto LABEL_148;
                              }
                              double v59 = (void *)*v58;
                              if (!v59) {
                                goto LABEL_148;
                              }
                              if (v56.u32[0] < 2uLL)
                              {
                                uint64_t v60 = *(void *)&v54 - 1;
                                while (1)
                                {
                                  uint64_t v62 = v59[1];
                                  if (v62 == 0x4927EB92E562CC46)
                                  {
                                    if (v59[2] == 0x4927EB92E562CC46) {
                                      goto LABEL_145;
                                    }
                                  }
                                  else if ((v62 & v60) != v57)
                                  {
                                    goto LABEL_148;
                                  }
                                  double v59 = (void *)*v59;
                                  if (!v59) {
                                    goto LABEL_148;
                                  }
                                }
                              }
                              while (2)
                              {
                                unint64_t v61 = v59[1];
                                if (v61 != 0x4927EB92E562CC46)
                                {
                                  if (v61 >= *(void *)&v54) {
                                    v61 %= *(void *)&v54;
                                  }
                                  if (v61 != v57) {
                                    goto LABEL_148;
                                  }
                                  goto LABEL_134;
                                }
                                if (v59[2] != 0x4927EB92E562CC46)
                                {
LABEL_134:
                                  double v59 = (void *)*v59;
                                  if (!v59) {
                                    goto LABEL_148;
                                  }
                                  continue;
                                }
                                break;
                              }
LABEL_145:
                              uint64_t v63 = v59[5];
                              if (*(void *)(v63 + 8) == 0x4927EB92E562CC46)
                              {
                                uint64_t v140 = *(void *)(v63 + 32);
                                if (v140)
                                {
                                  float v55 = *(float *)(v140 + 280);
                                  goto LABEL_149;
                                }
                              }
LABEL_148:
                              uint64_t v140 = 0;
LABEL_149:
                              uint64_t v142 = a1 + 52;
                              if (a1[55])
                              {
                                unint64_t v64 = (void *)a1[54];
                                if (v64)
                                {
                                  do
                                  {
                                    uint64_t v65 = (void *)*v64;
                                    operator delete(v64);
                                    unint64_t v64 = v65;
                                  }
                                  while (v65);
                                }
                                a1[54] = 0;
                                uint64_t v66 = a1[53];
                                if (v66)
                                {
                                  for (uint64_t i = 0; i != v66; ++i)
                                    *(void *)(*v142 + 8 * i) = 0;
                                }
                                a1[55] = 0;
                              }
                              double v68 = *a2;
                              long long v139 = a2[1];
                              uint64_t v69 = a3;
                              int v70 = a6;
                              if (*a2 != v139)
                              {
                                float v71 = 1.0 - v55;
                                float v72 = fmaxf(*(float *)(v141 + 3080) + *(float *)(v141 + 3076), 1.0);
                                if (a6 == 1) {
                                  float v73 = 1.0;
                                }
                                else {
                                  float v73 = v71;
                                }
                                do
                                {
                                  std::string::size_type v144 = v68;
                                  uint64_t v74 = *v68;
                                  uint64_t v75 = *(void *)(*v68 + 384);
                                  long long v164 = 0u;
                                  long long v165 = 0u;
                                  uint64_t v166 = 0;
                                  uint64_t v167 = a4;
                                  uint64_t v168 = v69;
                                  unint64_t v150 = (void *)v75;
                                  unsigned int v76 = *(unsigned __int8 *)(v75 + 169);
                                  float v175 = (float)v76;
                                  md::featureIdPredicate((uint64_t)v190, a5, v70, v76, v21, v140, (uint64_t)v142);
                                  md::FogInfo::updateFogUniformsWithLayoutContext((uint64_t *)(v74 + 496), (uint64_t)a4, (double *)(v74 + 88));
                                  float v77 = *(std::__shared_weak_count **)(v74 + 504);
                                  uint64_t v162 = *(void *)(v74 + 496);
                                  std::string::pointer v163 = v77;
                                  if (v77) {
                                    atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
                                  }
                                  uint64_t v78 = v74 + 480;
                                  uint64_t v79 = 216;
                                  if (a6 == 1) {
                                    uint64_t v79 = 480;
                                  }
                                  else {
                                    uint64_t v78 = v74 + 216;
                                  }
                                  uint64_t v80 = *(void *)(v74 + v79);
                                  BOOL v81 = *(std::__shared_weak_count **)(v78 + 8);
                                  uint64_t v160 = v80;
                                  std::string::pointer v161 = v81;
                                  if (v81) {
                                    atomic_fetch_add_explicit(&v81->__shared_owners_, 1uLL, memory_order_relaxed);
                                  }
                                  std::string::size_type v158 = 0;
                                  uint64_t v156 = 0;
                                  std::string::pointer v157 = 0;
                                  ggl::ResourceAccessor::accessConstantData((uint64_t)&v180, 0, v80, 0);
                                  ggl::BufferMemory::operator=(&v156, (uint64_t)&v180);
                                  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v180);
                                  long long v82 = v158[1];
                                  v159[0] = *v158;
                                  v159[1] = v82;
                                  long long v83 = v158[3];
                                  void v159[2] = v158[2];
                                  v159[3] = v83;
                                  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v156);
                                  float v176 = v72;
                                  *(void *)&long long v164 = &v160;
                                  int v179 = ggl::CullingGridWithHeight::intersectedCellsForView((uint64_t)(v150 + 93), (float *)v159);
                                  *((void *)&v164 + 1) = &v162;
                                  float v84 = *(float *)(v74 + 404) * v23;
                                  int v171 = *(_DWORD *)(v74 + 400);
                                  float v172 = v84;
                                  float v85 = *(float *)(v74 + 412);
                                  float v173 = v85;
                                  if (a6 == 1)
                                  {
                                    float v86 = *(float *)(v74 + 408);
                                  }
                                  else
                                  {
                                    if (!*(unsigned char *)(a1[47] + 17))
                                    {
                                      float v174 = 0.0;
                                      float v173 = 0.0;
                                      goto LABEL_174;
                                    }
                                    float v86 = *(float *)(v74 + 408) * v85;
                                  }
                                  float v174 = v86;
LABEL_174:
                                  double v87 = *(double *)(v141 + 496);
                                  double v88 = *(double *)(v141 + 504);
                                  double v89 = *(double *)(v141 + 512);
                                  double v90 = 1.0
                                      / (*(double *)(v74 + 632)
                                       + *(double *)(v74 + 536) * v87
                                       + *(double *)(v74 + 568) * v88
                                       + *(double *)(v74 + 600) * v89);
                                  float v91 = v90
                                      * (*(double *)(v74 + 624)
                                       + *(double *)(v74 + 528) * v87
                                       + *(double *)(v74 + 560) * v88
                                       + *(double *)(v74 + 592) * v89);
                                  float32x2_t v169 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(v74 + 608), *(float64x2_t *)(v74 + 512), v87), *(float64x2_t *)(v74 + 544), v88), *(float64x2_t *)(v74 + 576), v89), v90));
                                  float v170 = v91;
                                  float v177 = v73;
                                  int v178 = (v150[110] - v150[109]) >> 4;
                                  double v92 = (void *)v150[90];
                                  std::string::pointer v145 = (void *)v150[91];
                                  if (v92 == v145) {
                                    goto LABEL_292;
                                  }
                                  unsigned int v149 = 0;
                                  while (2)
                                  {
                                    std::string::pointer v146 = v92;
                                    uint64_t v93 = *v92;
                                    uint64_t v152 = v92[1];
                                    if (*v92 == v152) {
                                      goto LABEL_176;
                                    }
                                    do
                                    {
                                      id v94 = *(id *)(v93 + 8);
                                      uint64_t v95 = [v94 styleQueriesForPointyRoofs:0 selected:a5 == 1];
                                      *(void *)&long long v165 = v95;
                                      uint64_t v96 = [v94 styleQueriesForPointyRoofs:1 selected:a5 == 1];
                                      *((void *)&v165 + 1) = v96;
                                      v97.n128_f32[0] = v172;
                                      if (v172 <= 0.00000011921) {
                                        goto LABEL_290;
                                      }
                                      uint64_t v153 = v93;
                                      uint64_t v151 = v94;
                                      double v98 = *(uint64_t **)v95;
                                      float v99 = *(uint64_t **)(v95 + 8);
                                      if (*(uint64_t **)v95 == v99)
                                      {
                                        char v154 = 0;
                                        goto LABEL_223;
                                      }
                                      char v154 = 0;
                                      do
                                      {
                                        uint64_t v101 = *v98;
                                        uint64_t v156 = *v98;
                                        long long v102 = (std::__shared_weak_count *)v98[1];
                                        std::string::pointer v157 = v102;
                                        if (v102)
                                        {
                                          atomic_fetch_add_explicit(&v102->__shared_owners_, 1uLL, memory_order_relaxed);
                                          uint64_t v181 = v102;
                                          atomic_fetch_add_explicit(&v102->__shared_owners_, 1uLL, memory_order_relaxed);
                                        }
                                        else
                                        {
                                          uint64_t v181 = 0;
                                        }
                                        uint64_t v180 = (unsigned __int16 **)v101;
                                        uint64_t v182 = 0;
                                        uint64_t v183 = 0;
                                        unsigned __int8 v184 = 0;
                                        if (v101) {
                                          LODWORD(v101) = (*(uint64_t (**)(uint64_t, uint64_t *, __n128))(*(void *)v101 + 48))(v101, &v182, v97);
                                        }
                                        unsigned __int8 v184 = v101;
                                        if (v102)
                                        {
                                          if (!atomic_fetch_add(&v102->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                          {
                                            ((void (*)(std::__shared_weak_count *, __n128))v102->__on_zero_shared)(v102, v97);
                                            std::__shared_weak_count::__release_weak(v102);
                                          }
                                          LODWORD(v101) = v184;
                                        }
                                        if (v101)
                                        {
                                          uint64_t v103 = v180[3];
                                          if ((int)v176 >= 0x17) {
                                            unsigned int v104 = 23;
                                          }
                                          else {
                                            unsigned int v104 = (int)v176;
                                          }
                                          __int16 v105 = *(float **)v103;
                                          if (*(void *)v103
                                            && (float v106 = *v105, LODWORD(v105) = *v105 == 1.0, *((unsigned char *)v103 + 10))
                                            && (v106 != 0.0 ? (BOOL v107 = v106 == 1.0) : (BOOL v107 = 1), !v107)
                                            || (int v108 = *((unsigned __int8 *)v103 + v105 + 11),
                                                float v106 = 0.0,
                                                v108 == 2))
                                          {
                                            LOBYTE(v156) = 1;
                                            char v185 = 1;
                                            char v109 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v103, 0x5Bu, v104, 0, &v156);
                                            char v110 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v103, 0x5Bu, v104, 1, &v185);
                                            if (v106 < 1.0) {
                                              char v110 = v109;
                                            }
                                            if (v110)
                                            {
LABEL_209:
                                              char v154 = 1;
                                              char v111 = 1;
                                              if (!v184) {
                                                goto LABEL_214;
                                              }
LABEL_213:
                                              (*((void (**)(unsigned __int16 **))*v180 + 7))(v180);
                                              goto LABEL_214;
                                            }
                                          }
                                          else if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v180[3], 0x5Bu, v104, v108, 0))
                                          {
                                            goto LABEL_209;
                                          }
                                        }
                                        char v111 = 0;
                                        if (v184) {
                                          goto LABEL_213;
                                        }
LABEL_214:
                                        char v112 = v183;
                                        if (v183 && !atomic_fetch_add(&v183->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                        {
                                          ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
                                          std::__shared_weak_count::__release_weak(v112);
                                        }
                                        std::string::size_type v113 = v181;
                                        if (v181 && !atomic_fetch_add(&v181->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                        {
                                          ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
                                          std::__shared_weak_count::__release_weak(v113);
                                        }
                                        v98 += 2;
                                        if (v98 == v99) {
                                          char v100 = 1;
                                        }
                                        else {
                                          char v100 = v111;
                                        }
                                      }
                                      while ((v100 & 1) == 0);
                                      if ((v154 & 1) == 0)
                                      {
                                        uint64_t v96 = *((void *)&v165 + 1);
LABEL_223:
                                        uint64_t v114 = *(uint64_t **)v96;
                                        uint64_t v115 = *(uint64_t **)(v96 + 8);
                                        if (*(uint64_t **)v96 == v115)
                                        {
                                          int v116 = 0;
                                          goto LABEL_266;
                                        }
                                        while (2)
                                        {
                                          uint64_t v118 = *v114;
                                          uint64_t v156 = *v114;
                                          std::string::size_type v119 = (std::__shared_weak_count *)v114[1];
                                          std::string::pointer v157 = v119;
                                          if (v119)
                                          {
                                            atomic_fetch_add_explicit(&v119->__shared_owners_, 1uLL, memory_order_relaxed);
                                            uint64_t v181 = v119;
                                            atomic_fetch_add_explicit(&v119->__shared_owners_, 1uLL, memory_order_relaxed);
                                          }
                                          else
                                          {
                                            uint64_t v181 = 0;
                                          }
                                          uint64_t v180 = (unsigned __int16 **)v118;
                                          uint64_t v182 = 0;
                                          uint64_t v183 = 0;
                                          unsigned __int8 v184 = 0;
                                          if (v118) {
                                            LODWORD(v118) = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v118 + 48))(v118, &v182);
                                          }
                                          unsigned __int8 v184 = v118;
                                          if (v119)
                                          {
                                            if (!atomic_fetch_add(&v119->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                            {
                                              ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
                                              std::__shared_weak_count::__release_weak(v119);
                                            }
                                            LODWORD(v118) = v184;
                                          }
                                          if (v118)
                                          {
                                            uint64_t v120 = v180[3];
                                            if ((int)v176 >= 0x17) {
                                              unsigned int v121 = 23;
                                            }
                                            else {
                                              unsigned int v121 = (int)v176;
                                            }
                                            uint64_t v122 = *(float **)v120;
                                            if (*(void *)v120
                                              && (float v123 = *v122, LODWORD(v122) = *v122 == 1.0, *((unsigned char *)v120 + 10))
                                              && (v123 != 0.0 ? (BOOL v124 = v123 == 1.0) : (BOOL v124 = 1), !v124)
                                              || (int v125 = *((unsigned __int8 *)v120 + v122 + 11),
                                                  float v123 = 0.0,
                                                  v125 == 2))
                                            {
                                              LOBYTE(v156) = 1;
                                              char v185 = 1;
                                              char v126 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v120, 0x5Bu, v121, 0, &v156);
                                              char v127 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v120, 0x5Bu, v121, 1, &v185);
                                              if (v123 < 1.0) {
                                                char v127 = v126;
                                              }
                                              if (v127)
                                              {
LABEL_253:
                                                char v154 = 1;
                                                char v128 = 1;
                                                if (!v184) {
                                                  goto LABEL_258;
                                                }
LABEL_257:
                                                (*((void (**)(unsigned __int16 **))*v180 + 7))(v180);
LABEL_258:
                                                uint64_t v129 = v183;
                                                if (v183
                                                  && !atomic_fetch_add(&v183->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v129->__on_zero_shared)(v129);
                                                  std::__shared_weak_count::__release_weak(v129);
                                                }
                                                uint64_t v130 = v181;
                                                if (v181
                                                  && !atomic_fetch_add(&v181->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v130->__on_zero_shared)(v130);
                                                  std::__shared_weak_count::__release_weak(v130);
                                                }
                                                v114 += 2;
                                                if (v114 == v115) {
                                                  char v117 = 1;
                                                }
                                                else {
                                                  char v117 = v128;
                                                }
                                                if (v117)
                                                {
                                                  int v116 = v154 & 1;
                                                  goto LABEL_266;
                                                }
                                                continue;
                                              }
                                            }
                                            else if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(v180[3], 0x5Bu, v121, v125, 0))
                                            {
                                              goto LABEL_253;
                                            }
                                          }
                                          break;
                                        }
                                        char v128 = 0;
                                        if (v184) {
                                          goto LABEL_257;
                                        }
                                        goto LABEL_258;
                                      }
                                      int v116 = 1;
LABEL_266:
                                      int v131 = v116 != 0;
                                      id v94 = v151;
                                      uint64_t v93 = v153;
                                      if (a5 != 1)
                                      {
LABEL_269:
                                        if (!v131) {
                                          goto LABEL_290;
                                        }
                                        uint64_t v132 = v150[109];
                                        if (v149 >= (unint64_t)((v150[110] - v132) >> 4)) {
                                          goto LABEL_290;
                                        }
                                        uint64_t v166 = *(void *)(v132 + 16 * v149);
                                        int v133 = *(unsigned __int8 *)(a1[49] + 772);
                                        id v134 = *v147;
                                        uint64_t v135 = (uint64_t)v191;
                                        if (v133)
                                        {
                                          if (!v191) {
                                            goto LABEL_279;
                                          }
                                          if (v191 == v190)
                                          {
                                            size_t v189 = v188;
                                            (*(void (**)(void *, void *))(v190[0] + 24))(v190, v188);
                                          }
                                          else
                                          {
                                            uint64_t v135 = (*(uint64_t (**)(void))(*v191 + 16))();
LABEL_279:
                                            size_t v189 = (void *)v135;
                                          }
                                          md::BuildingRenderLayer::generateSpecularRenderItemsForGroup((uint64_t)a1, v148, v134, v151, (uint64_t)&v164, v188);
                                          unint64_t v136 = v189;
                                          if (v189 == v188)
                                          {
                                            (*(void (**)(void *))(v188[0] + 32))(v188);
                                            goto LABEL_288;
                                          }
LABEL_285:
                                          uint64_t v93 = v153;
                                          if (v136) {
                                            (*(void (**)(void *))(*v136 + 40))(v136);
                                          }
                                          goto LABEL_289;
                                        }
                                        if (v191)
                                        {
                                          if (v191 != v190)
                                          {
                                            uint64_t v135 = (*(uint64_t (**)(void))(*v191 + 16))();
                                            goto LABEL_278;
                                          }
                                          std::string::pointer v187 = v186;
                                          (*(void (**)(void *, void *))(v190[0] + 24))(v190, v186);
                                        }
                                        else
                                        {
LABEL_278:
                                          std::string::pointer v187 = (void *)v135;
                                        }
                                        md::BuildingRenderLayer::generateDiffuseRenderItemsForGroup((uint64_t)a1, v148, v134, v151, (uint64_t)&v164, v186);
                                        unint64_t v136 = v187;
                                        if (v187 != v186) {
                                          goto LABEL_285;
                                        }
                                        (*(void (**)(void *))(v186[0] + 32))(v186);
LABEL_288:
                                        uint64_t v93 = v153;
LABEL_289:

                                        goto LABEL_290;
                                      }
                                      if (v116)
                                      {
                                        int v131 = [v151 hasFeatureId:v21];
                                        goto LABEL_269;
                                      }
LABEL_290:

                                      v93 += 24;
                                    }
                                    while (v93 != v152);
LABEL_176:
                                    ++v149;
                                    double v92 = v146 + 3;
                                    if (v146 + 3 != v145) {
                                      continue;
                                    }
                                    break;
                                  }
LABEL_292:
                                  uint64_t v137 = v161;
                                  if (v161 && !atomic_fetch_add(&v161->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                  {
                                    ((void (*)(std::__shared_weak_count *))v137->__on_zero_shared)(v137);
                                    std::__shared_weak_count::__release_weak(v137);
                                  }
                                  long long v138 = v163;
                                  if (v163 && !atomic_fetch_add(&v163->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                  {
                                    ((void (*)(std::__shared_weak_count *))v138->__on_zero_shared)(v138);
                                    std::__shared_weak_count::__release_weak(v138);
                                  }
                                  if (v191 == v190)
                                  {
                                    (*(void (**)(void *))(v190[0] + 32))(v190);
                                  }
                                  else if (v191)
                                  {
                                    (*(void (**)(void))(*v191 + 40))();
                                  }
                                  uint64_t v69 = v143;
                                  double v68 = v144 + 1;
                                  int v70 = a6;
                                }
                                while (v144 + 1 != v139);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

void sub_1A23AA478(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t v65 = *(void *)(v63 - 168);
  if (v65 == v63 - 192)
  {
    (*(void (**)(uint64_t))(*(void *)(v63 - 192) + 32))(v63 - 192);
    _Unwind_Resume(exception_object);
  }
  if (v65)
  {
    (*(void (**)(uint64_t))(*(void *)v65 + 40))(v65);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void md::BuildingRenderLayer::generateSpecularRenderItemsForGroup(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  uint64_t v576 = *MEMORY[0x1E4F143B8];
  id v502 = a3;
  id v17 = a4;
  uint64_t v548 = a1;
  uint64_t v18 = ggl::FragmentedPool<ggl::BuildingTopDepth::CompressedMeshPipelineSetup>::pop(*(void *)(*(void *)(a1 + 392)
                                                                                               + 496));
  getTopDepthPipelineSetupForGroup(v18, v17, a5);
  uint64_t v19 = ggl::FragmentedPool<ggl::BuildingFacadeDepth::BuildingPipelineSetup>::pop(*(void *)(*(void *)(a1 + 392)
                                                                                            + 488));
  getExtrusionDepthPipelineSetupForGroup(v19, v17, a5);
  uint64_t v500 = v18;
  uint64_t v20 = ggl::FragmentedPool<ggl::BuildingPointyRoofDepth::BuildingPipelineSetup>::pop(*(void *)(*(void *)(v548 + 392)
                                                                                                + 504));
  uint64_t PointyRoofDepthPipelineSetupForGroup = getPointyRoofDepthPipelineSetupForGroup(v20, v17, a5);
  uint64_t v21 = *(void *)(*(void *)(v548 + 392) + 584);
  uint64_t v22 = *(void *)(v21 + 8);
  uint64_t v503 = v19;
  if (v22 == *(void *)v21)
  {
    uint64_t v26 = *(void *)(v21 + 88);
    if (!v26)
    {
LABEL_637:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_641:
      __break(1u);
      return;
    }
    uint64_t v508 = (ggl::PipelineSetup *)(*(uint64_t (**)(uint64_t))(*(void *)v26 + 48))(v26);
    float v24 = *(ggl::PipelineSetup ***)(v21 + 40);
    unint64_t v27 = *(void *)(v21 + 48);
    if ((unint64_t)v24 < v27)
    {
      if (v24) {
        *float v24 = v508;
      }
      goto LABEL_9;
    }
    uint64_t v37 = *(void *)(v21 + 32);
    uint64_t v38 = ((uint64_t)v24 - v37) >> 3;
    unint64_t v39 = v38 + 1;
    if (!((unint64_t)(v38 + 1) >> 61))
    {
      uint64_t v40 = v27 - v37;
      if (v40 >> 2 > v39) {
        unint64_t v39 = v40 >> 2;
      }
      if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v41 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v41 = v39;
      }
      if (v41)
      {
        uint64_t v42 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v21 + 56) + 16))(*(void *)(v21 + 56), 8 * v41, 8);
        uint64_t v35 = (ggl::PipelineSetup **)(v42 + 8 * v38);
        uint64_t v36 = v42 + 8 * v41;
        if (v42) {
          *uint64_t v35 = v508;
        }
      }
      else
      {
        uint64_t v36 = 0;
        uint64_t v35 = (ggl::PipelineSetup **)(8 * v38);
      }
      unsigned int v28 = v35 + 1;
      uint64_t v52 = *(void *)(v21 + 32);
      uint64_t v43 = *(void *)(v21 + 40);
      if (v43 == v52) {
        goto LABEL_52;
      }
      unint64_t v53 = v43 - v52 - 8;
      if (v53 < 0x38)
      {
        uint64_t v55 = *(void *)(v21 + 40);
      }
      else if ((unint64_t)(v43 - (void)v35) < 0x20)
      {
        uint64_t v55 = *(void *)(v21 + 40);
      }
      else
      {
        uint64_t v54 = (v53 >> 3) + 1;
        uint64_t v55 = v43 - 8 * (v54 & 0x3FFFFFFFFFFFFFFCLL);
        uint8x8_t v56 = v35 - 2;
        uint64_t v57 = (long long *)(v43 - 16);
        uint64_t v58 = v54 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v59 = *v57;
          *((_OWORD *)v56 - 1) = *(v57 - 1);
          *(_OWORD *)uint8x8_t v56 = v59;
          v56 -= 4;
          v57 -= 2;
          v58 -= 4;
        }
        while (v58);
        v35 -= v54 & 0x3FFFFFFFFFFFFFFCLL;
        if (v54 == (v54 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_51;
        }
      }
      do
      {
        unint64_t v61 = *(ggl::PipelineSetup **)(v55 - 8);
        v55 -= 8;
        *--uint64_t v35 = v61;
      }
      while (v55 != v52);
      goto LABEL_51;
    }
LABEL_639:
    abort();
  }
  float v23 = *(ggl::PipelineSetup **)(v22 - 8);
  *(void *)(v21 + 8) = v22 - 8;
  float v24 = *(ggl::PipelineSetup ***)(v21 + 40);
  unint64_t v25 = *(void *)(v21 + 48);
  uint64_t v508 = v23;
  if ((unint64_t)v24 < v25)
  {
    if (v24) {
      *float v24 = v23;
    }
LABEL_9:
    unsigned int v28 = v24 + 1;
    goto LABEL_54;
  }
  uint64_t v29 = *(void *)(v21 + 32);
  uint64_t v30 = ((uint64_t)v24 - v29) >> 3;
  unint64_t v31 = v30 + 1;
  if ((unint64_t)(v30 + 1) >> 61) {
    goto LABEL_639;
  }
  uint64_t v32 = v25 - v29;
  if (v32 >> 2 > v31) {
    unint64_t v31 = v32 >> 2;
  }
  if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v33 = v31;
  }
  if (v33)
  {
    uint64_t v34 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v21 + 56) + 16))(*(void *)(v21 + 56), 8 * v33, 8);
    uint64_t v35 = (ggl::PipelineSetup **)(v34 + 8 * v30);
    uint64_t v36 = v34 + 8 * v33;
    if (v34) {
      *uint64_t v35 = v508;
    }
  }
  else
  {
    uint64_t v36 = 0;
    uint64_t v35 = (ggl::PipelineSetup **)(8 * v30);
  }
  unsigned int v28 = v35 + 1;
  uint64_t v44 = *(void *)(v21 + 32);
  uint64_t v43 = *(void *)(v21 + 40);
  if (v43 == v44) {
    goto LABEL_52;
  }
  unint64_t v45 = v43 - v44 - 8;
  if (v45 < 0x38)
  {
    uint64_t v47 = *(void *)(v21 + 40);
  }
  else if ((unint64_t)(v43 - (void)v35) < 0x20)
  {
    uint64_t v47 = *(void *)(v21 + 40);
  }
  else
  {
    uint64_t v46 = (v45 >> 3) + 1;
    uint64_t v47 = v43 - 8 * (v46 & 0x3FFFFFFFFFFFFFFCLL);
    float v48 = v35 - 2;
    uint64_t v49 = (long long *)(v43 - 16);
    uint64_t v50 = v46 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v51 = *v49;
      *((_OWORD *)v48 - 1) = *(v49 - 1);
      *(_OWORD *)float v48 = v51;
      v48 -= 4;
      v49 -= 2;
      v50 -= 4;
    }
    while (v50);
    v35 -= v46 & 0x3FFFFFFFFFFFFFFCLL;
    if (v46 == (v46 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_51;
    }
  }
  do
  {
    uint64_t v60 = *(ggl::PipelineSetup **)(v47 - 8);
    v47 -= 8;
    *--uint64_t v35 = v60;
  }
  while (v47 != v44);
LABEL_51:
  uint64_t v43 = *(void *)(v21 + 32);
LABEL_52:
  *(void *)(v21 + 32) = v35;
  *(void *)(v21 + 40) = v28;
  uint64_t v62 = *(void *)(v21 + 48);
  *(void *)(v21 + 48) = v36;
  if (v43) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v21 + 56) + 40))(*(void *)(v21 + 56), v43, v62 - v43);
  }
LABEL_54:
  *(void *)(v21 + 40) = v28;
  *(void *)&long long v554 = v508;
  uint64_t v63 = *(void *)(v21 + 120);
  if (!v63) {
    goto LABEL_637;
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v63 + 48))(v63, &v554);
  id v506 = v17;
  unint64_t v64 = *(uint64_t **)a5;
  uint64_t v65 = *((void *)v508 + 8);
  *(void *)(v65 + 24) = 0;
  uint64_t v66 = *v64;
  *(void *)(v65 + 16) = *v64;
  uint64_t v67 = *((void *)v508 + 20);
  uint64_t v68 = v64[1];
  if (v68) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v68 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v69 = *(std::__shared_weak_count **)(v67 + 24);
  *(void *)(v67 + 16) = v66;
  *(void *)(v67 + 24) = v68;
  if (v69 && !atomic_fetch_add(&v69->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
    std::__shared_weak_count::__release_weak(v69);
  }
  int v70 = *(uint64_t **)(a5 + 8);
  float v71 = (uint64_t *)*((void *)v508 + 8);
  v71[1] = 0;
  uint64_t v72 = *v70;
  *float v71 = *v70;
  float v73 = (void *)*((void *)v508 + 20);
  uint64_t v74 = v70[1];
  if (v74) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v74 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v75 = (std::__shared_weak_count *)v73[1];
  void *v73 = v72;
  v73[1] = v74;
  if (v75 && !atomic_fetch_add(&v75->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
    std::__shared_weak_count::__release_weak(v75);
  }
  uint64_t v76 = *(void *)(*((void *)v508 + 8) + 32);
  long long v554 = 0uLL;
  unint64_t v77 = *(void *)(v76 + 8);
  *(void *)&long long v78 = 0;
  *((void *)&v78 + 1) = v76;
  if (v77) {
    uint64_t v79 = *(ggl::PipelineSetup **)(v76 + 72);
  }
  else {
    uint64_t v79 = 0;
  }
  long long v549 = v78;
  long long v554 = v78;
  double v555 = 0;
  uint64_t v556 = v77;
  unint64_t v558 = v79;
  LOWORD(v557) = 1;
  *(void *)uint64_t v79 = *(void *)(a5 + 76);
  uint64_t v80 = (_DWORD *)[v506 origin];
  *((_DWORD *)v79 + 4) = *v80;
  *((_DWORD *)v79 + 5) = v80[1];
  *((_DWORD *)v79 + 6) = v80[2];
  [v506 size];
  *((_DWORD *)v79 + 8) = v81;
  *((_DWORD *)v79 + 9) = v82;
  *((_DWORD *)v79 + 10) = v83;
  if (v77)
  {
    if ((void)v549 && *(unsigned char *)(*((void *)&v549 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v549 + 64))();
    }
    unint64_t v84 = *(void *)(*((void *)&v549 + 1) + 64);
    if (v84 <= v77) {
      unint64_t v84 = v77;
    }
    *(void *)(*((void *)&v549 + 1) + 56) = 0;
    *(void *)(*((void *)&v549 + 1) + 64) = v84;
  }
  float v85 = (void *)*((void *)v508 + 8);
  float v86 = (void *)v85[6];
  unint64_t v87 = v86[1];
  if (v87) {
    double v88 = (_DWORD *)v86[9];
  }
  else {
    double v88 = 0;
  }
  v88[92] = *(_DWORD *)(a5 + 56);
  v88[93] = *(_DWORD *)(a5 + 60);
  v88[94] = *(_DWORD *)(a5 + 64);
  v88[89] = 1065353216;
  if (v88 && v87)
  {
    if (v86[8] > v87) {
      unint64_t v87 = v86[8];
    }
    v86[7] = 0;
    v86[8] = v87;
  }
  double v89 = *(void **)(*(void *)(a5 + 40) + 8);
  unint64_t v90 = v89[1];
  if ((v90 & (v90 - 1)) != 0)
  {
    unint64_t v92 = 0x41E8D6E445F4145;
    if (v90 <= 0x41E8D6E445F4145) {
      unint64_t v92 = 0x41E8D6E445F4145 % v90;
    }
    float v91 = *(void **)(*v89 + 8 * v92);
    do
    {
      do
        float v91 = (void *)*v91;
      while (v91[1] != 0x41E8D6E445F4145);
    }
    while (v91[2] != 0x41E8D6E445F4145);
  }
  else
  {
    float v91 = *(void **)(*v89 + 8 * ((v90 - 1) & 0x41E8D6E445F4145));
    do
    {
      do
        float v91 = (void *)*v91;
      while (v91[1] != 0x41E8D6E445F4145);
    }
    while (v91[2] != 0x41E8D6E445F4145);
  }
  uint64_t v93 = *(uint64_t **)(v91[5] + 32);
  v85[11] = 0;
  uint64_t v94 = *v93;
  v85[10] = *v93;
  uint64_t v95 = *((void *)v508 + 20);
  uint64_t v96 = v93[1];
  if (v96) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v96 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 v97 = *(std::__shared_weak_count **)(v95 + 88);
  *(void *)(v95 + 80) = v94;
  *(void *)(v95 + 88) = v96;
  if (v97 && !atomic_fetch_add(&v97->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
    std::__shared_weak_count::__release_weak(v97);
  }

  uint64_t v98 = *((void *)v508 + 8);
  uint64_t v99 = *(void *)(v98 + 48);
  uint64_t v100 = *(void *)(v98 + 64);
  float v101 = 1.0;
  if (!*(unsigned char *)(a2 + 32)) {
    float v101 = 0.0;
  }
  float v541 = v101;
  uint64_t v102 = *(void *)(v548 + 392);
  if (*(unsigned char *)(a2 + 32))
  {
    uint64_t v103 = *(void *)(v102 + 576);
    uint64_t v104 = *(void *)(v103 + 8);
    if (v104 != *(void *)v103)
    {
      uint64_t v507 = *(ggl::PipelineSetup **)(v104 - 8);
      *(void *)(v103 + 8) = v104 - 8;
      __int16 v105 = *(ggl::PipelineSetup ***)(v103 + 40);
      unint64_t v106 = *(void *)(v103 + 48);
      if ((unint64_t)v105 >= v106)
      {
        uint64_t v107 = *(void *)(v103 + 32);
        uint64_t v108 = ((uint64_t)v105 - v107) >> 3;
        unint64_t v109 = v108 + 1;
        if (!((unint64_t)(v108 + 1) >> 61))
        {
          uint64_t v110 = v106 - v107;
          if (v110 >> 2 > v109) {
            unint64_t v109 = v110 >> 2;
          }
          if ((unint64_t)v110 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v111 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v111 = v109;
          }
          if (v111)
          {
            uint64_t v112 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v103 + 56) + 16))(*(void *)(v103 + 56), 8 * v111, 8);
            std::string::size_type v113 = (ggl::PipelineSetup **)(v112 + 8 * v108);
            uint64_t v114 = v112 + 8 * v111;
            if (v112) {
              *std::string::size_type v113 = v507;
            }
          }
          else
          {
            uint64_t v114 = 0;
            std::string::size_type v113 = (ggl::PipelineSetup **)(8 * v108);
          }
          uint64_t v129 = v113 + 1;
          uint64_t v140 = *(void *)(v103 + 32);
          uint64_t v139 = *(void *)(v103 + 40);
          if (v139 == v140) {
            goto LABEL_195;
          }
          unint64_t v141 = v139 - v140 - 8;
          if (v141 < 0x38)
          {
            uint64_t v143 = *(void *)(v103 + 40);
          }
          else if ((unint64_t)(v139 - (void)v113) < 0x20)
          {
            uint64_t v143 = *(void *)(v103 + 40);
          }
          else
          {
            uint64_t v142 = (v141 >> 3) + 1;
            uint64_t v143 = v139 - 8 * (v142 & 0x3FFFFFFFFFFFFFFCLL);
            std::string::size_type v144 = v113 - 2;
            std::string::pointer v145 = (long long *)(v139 - 16);
            uint64_t v146 = v142 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v147 = *v145;
              *((_OWORD *)v144 - 1) = *(v145 - 1);
              *(_OWORD *)std::string::size_type v144 = v147;
              v144 -= 4;
              v145 -= 2;
              v146 -= 4;
            }
            while (v146);
            v113 -= v142 & 0x3FFFFFFFFFFFFFFCLL;
            if (v142 == (v142 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_194;
            }
          }
          do
          {
            int v171 = *(ggl::PipelineSetup **)(v143 - 8);
            v143 -= 8;
            *--std::string::size_type v113 = v171;
          }
          while (v143 != v140);
LABEL_194:
          uint64_t v139 = *(void *)(v103 + 32);
LABEL_195:
          *(void *)(v103 + 32) = v113;
          *(void *)(v103 + 40) = v129;
          uint64_t v182 = *(void *)(v103 + 48);
          *(void *)(v103 + 48) = v114;
          if (v139) {
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v103 + 56) + 40))(*(void *)(v103 + 56), v139, v182 - v139);
          }
          goto LABEL_197;
        }
        goto LABEL_640;
      }
      goto LABEL_125;
    }
    uint64_t v127 = *(void *)(v103 + 88);
    if (v127)
    {
      uint64_t v507 = (ggl::PipelineSetup *)(*(uint64_t (**)(uint64_t))(*(void *)v127 + 48))(v127);
      __int16 v105 = *(ggl::PipelineSetup ***)(v103 + 40);
      unint64_t v128 = *(void *)(v103 + 48);
      if ((unint64_t)v105 >= v128)
      {
        uint64_t v133 = *(void *)(v103 + 32);
        uint64_t v134 = ((uint64_t)v105 - v133) >> 3;
        unint64_t v135 = v134 + 1;
        if (!((unint64_t)(v134 + 1) >> 61))
        {
          uint64_t v136 = v128 - v133;
          if (v136 >> 2 > v135) {
            unint64_t v135 = v136 >> 2;
          }
          if ((unint64_t)v136 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v137 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v137 = v135;
          }
          if (v137)
          {
            uint64_t v138 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v103 + 56) + 16))(*(void *)(v103 + 56), 8 * v137, 8);
            std::string::size_type v113 = (ggl::PipelineSetup **)(v138 + 8 * v134);
            uint64_t v114 = v138 + 8 * v137;
            if (v138) {
              *std::string::size_type v113 = v507;
            }
          }
          else
          {
            uint64_t v114 = 0;
            std::string::size_type v113 = (ggl::PipelineSetup **)(8 * v134);
          }
          uint64_t v129 = v113 + 1;
          uint64_t v163 = *(void *)(v103 + 32);
          uint64_t v139 = *(void *)(v103 + 40);
          if (v139 == v163) {
            goto LABEL_195;
          }
          unint64_t v164 = v139 - v163 - 8;
          if (v164 < 0x38)
          {
            uint64_t v166 = *(void *)(v103 + 40);
          }
          else if ((unint64_t)(v139 - (void)v113) < 0x20)
          {
            uint64_t v166 = *(void *)(v103 + 40);
          }
          else
          {
            uint64_t v165 = (v164 >> 3) + 1;
            uint64_t v166 = v139 - 8 * (v165 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v167 = v113 - 2;
            uint64_t v168 = (long long *)(v139 - 16);
            uint64_t v169 = v165 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v170 = *v168;
              *((_OWORD *)v167 - 1) = *(v168 - 1);
              *(_OWORD *)uint64_t v167 = v170;
              v167 -= 4;
              v168 -= 2;
              v169 -= 4;
            }
            while (v169);
            v113 -= v165 & 0x3FFFFFFFFFFFFFFCLL;
            if (v165 == (v165 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_194;
            }
          }
          do
          {
            uint64_t v181 = *(ggl::PipelineSetup **)(v166 - 8);
            v166 -= 8;
            *--std::string::size_type v113 = v181;
          }
          while (v166 != v163);
          goto LABEL_194;
        }
LABEL_640:
        abort();
      }
LABEL_125:
      if (v105) {
        float *v105 = v507;
      }
      uint64_t v129 = v105 + 1;
LABEL_197:
      *(void *)(v103 + 40) = v129;
      *(void *)&long long v554 = v507;
      uint64_t v183 = *(void *)(v103 + 120);
      if (v183)
      {
        (*(void (**)(uint64_t, long long *))(*(void *)v183 + 48))(v183, &v554);
        int v184 = **(_DWORD **)(v548 + 392);
        id v185 = v506;
        std::string::size_type v186 = *(uint64_t **)a5;
        uint64_t v187 = *((void *)v507 + 8);
        *(void *)(v187 + 24) = 0;
        uint64_t v188 = *v186;
        *(void *)(v187 + 16) = *v186;
        uint64_t v189 = *((void *)v507 + 20);
        uint64_t v190 = v186[1];
        if (v190) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v190 + 8), 1uLL, memory_order_relaxed);
        }
        int v191 = *(std::__shared_weak_count **)(v189 + 24);
        *(void *)(v189 + 16) = v188;
        *(void *)(v189 + 24) = v190;
        if (v191 && !atomic_fetch_add(&v191->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v191->__on_zero_shared)(v191);
          std::__shared_weak_count::__release_weak(v191);
        }
        uint64_t v192 = *(void *)(*((void *)v507 + 8) + 32);
        long long v554 = 0uLL;
        unint64_t v193 = *(void *)(v192 + 8);
        *(void *)&long long v194 = 0;
        *((void *)&v194 + 1) = v192;
        if (v193) {
          std::string::size_type v195 = *(ggl::PipelineSetup **)(v192 + 72);
        }
        else {
          std::string::size_type v195 = 0;
        }
        long long v550 = v194;
        long long v554 = v194;
        double v555 = 0;
        uint64_t v556 = v193;
        unint64_t v558 = v195;
        LOWORD(v557) = 1;
        *(void *)std::string::size_type v195 = *(void *)(a5 + 76);
        std::string::pointer v196 = (_DWORD *)[v185 origin];
        *((_DWORD *)v195 + 4) = *v196;
        *((_DWORD *)v195 + 5) = v196[1];
        *((_DWORD *)v195 + 6) = v196[2];
        [v185 size];
        *((_DWORD *)v195 + 8) = v197;
        *((_DWORD *)v195 + 9) = v198;
        *((_DWORD *)v195 + 10) = v199;
        if (v193)
        {
          if ((void)v550 && *(unsigned char *)(*((void *)&v550 + 1) + 17) != 2) {
            (*(void (**)(void))(*(void *)v550 + 64))();
          }
          unint64_t v200 = *(void *)(*((void *)&v550 + 1) + 64);
          if (v200 <= v193) {
            unint64_t v200 = v193;
          }
          *(void *)(*((void *)&v550 + 1) + 56) = 0;
          *(void *)(*((void *)&v550 + 1) + 64) = v200;
        }
        uint64_t v201 = (void *)*((void *)v507 + 8);
        uint64_t v202 = (void *)v201[6];
        unint64_t v203 = v202[1];
        if (v203) {
          uint64_t v204 = (_DWORD *)v202[9];
        }
        else {
          uint64_t v204 = 0;
        }
        v204[92] = *(_DWORD *)(a5 + 56);
        v204[93] = *(_DWORD *)(a5 + 60);
        v204[94] = *(_DWORD *)(a5 + 64);
        v204[89] = v184;
        if (v204 && v203)
        {
          if (v202[8] > v203) {
            unint64_t v203 = v202[8];
          }
          v202[7] = 0;
          v202[8] = v203;
        }
        std::string::size_type v205 = *(void **)(*(void *)(a5 + 40) + 8);
        unint64_t v206 = v205[1];
        if ((v206 & (v206 - 1)) != 0)
        {
          unint64_t v208 = 0x41E8D6E445F4145;
          if (v206 <= 0x41E8D6E445F4145) {
            unint64_t v208 = 0x41E8D6E445F4145 % v206;
          }
          std::string::size_type v207 = *(void **)(*v205 + 8 * v208);
          do
          {
            do
              std::string::size_type v207 = (void *)*v207;
            while (v207[1] != 0x41E8D6E445F4145);
          }
          while (v207[2] != 0x41E8D6E445F4145);
        }
        else
        {
          std::string::size_type v207 = *(void **)(*v205 + 8 * ((v206 - 1) & 0x41E8D6E445F4145));
          do
          {
            do
              std::string::size_type v207 = (void *)*v207;
            while (v207[1] != 0x41E8D6E445F4145);
          }
          while (v207[2] != 0x41E8D6E445F4145);
        }
        size_t v209 = *(uint64_t **)(v207[5] + 32);
        v201[11] = 0;
        uint64_t v210 = *v209;
        v201[10] = *v209;
        uint64_t v211 = *((void *)v507 + 20);
        uint64_t v212 = v209[1];
        if (v212) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v212 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v213 = *(std::__shared_weak_count **)(v211 + 88);
        *(void *)(v211 + 80) = v210;
        *(void *)(v211 + 88) = v212;
        if (v213 && !atomic_fetch_add(&v213->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v213->__on_zero_shared)(v213);
          std::__shared_weak_count::__release_weak(v213);
        }
        uint64_t v214 = *(uint64_t **)(a5 + 8);
        std::string::size_type v215 = (uint64_t *)*((void *)v507 + 8);
        v215[1] = 0;
        uint64_t v216 = *v214;
        uint64_t *v215 = *v214;
        std::string::size_type v217 = (void *)*((void *)v507 + 20);
        uint64_t v218 = v214[1];
        if (v218) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v218 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v219 = (std::__shared_weak_count *)v217[1];
        *std::string::size_type v217 = v216;
        v217[1] = v218;
        if (v219 && !atomic_fetch_add(&v219->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v219->__on_zero_shared)(v219);
          std::__shared_weak_count::__release_weak(v219);
        }

        uint64_t v220 = *((void *)v507 + 8);
        long long v221 = *(void **)(v220 + 48);
        v511 = *(void **)(v220 + 64);
        uint64_t v222 = ggl::FragmentedPool<ggl::FoggedDiffuseBuilding::BuildingPipelineSetup>::pop(*(void *)(*(void *)(v548 + 392) + 528));
        uint64_t FoggedExtrusionPipelineSetupForGroup = getFoggedExtrusionPipelineSetupForGroup(v222, v185, a5, **(float **)(v548 + 392));
        double v497 = 0;
        double v498 = (ggl::PipelineSetup *)FoggedExtrusionPipelineSetupForGroup;
        double v504 = 0;
        goto LABEL_288;
      }
    }
LABEL_638:
    std::__throw_bad_function_call[abi:nn180100]();
    goto LABEL_641;
  }
  uint64_t v115 = *(void *)(v102 + 560);
  uint64_t v116 = *(void *)(v115 + 8);
  if (v116 == *(void *)v115)
  {
    uint64_t v130 = *(void *)(v115 + 88);
    if (!v130) {
      goto LABEL_638;
    }
    double v504 = (ggl::PipelineSetup *)(*(uint64_t (**)(uint64_t))(*(void *)v130 + 48))(v130);
    char v117 = *(ggl::PipelineSetup ***)(v115 + 40);
    unint64_t v131 = *(void *)(v115 + 48);
    if ((unint64_t)v117 >= v131)
    {
      uint64_t v148 = *(void *)(v115 + 32);
      uint64_t v149 = ((uint64_t)v117 - v148) >> 3;
      unint64_t v150 = v149 + 1;
      if ((unint64_t)(v149 + 1) >> 61) {
        goto LABEL_640;
      }
      uint64_t v151 = v131 - v148;
      if (v151 >> 2 > v150) {
        unint64_t v150 = v151 >> 2;
      }
      if ((unint64_t)v151 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v152 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v152 = v150;
      }
      if (v152)
      {
        uint64_t v153 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v115 + 56) + 16))(*(void *)(v115 + 56), 8 * v152, 8);
        int v125 = (ggl::PipelineSetup **)(v153 + 8 * v149);
        uint64_t v126 = v153 + 8 * v152;
        if (v153) {
          void *v125 = v504;
        }
      }
      else
      {
        uint64_t v126 = 0;
        int v125 = (ggl::PipelineSetup **)(8 * v149);
      }
      uint64_t v132 = v125 + 1;
      uint64_t v172 = *(void *)(v115 + 32);
      uint64_t v154 = *(void *)(v115 + 40);
      if (v154 == v172) {
        goto LABEL_246;
      }
      unint64_t v173 = v154 - v172 - 8;
      if (v173 < 0x38)
      {
        uint64_t v175 = *(void *)(v115 + 40);
      }
      else if ((unint64_t)(v154 - (void)v125) < 0x20)
      {
        uint64_t v175 = *(void *)(v115 + 40);
      }
      else
      {
        uint64_t v174 = (v173 >> 3) + 1;
        uint64_t v175 = v154 - 8 * (v174 & 0x3FFFFFFFFFFFFFFCLL);
        float v176 = v125 - 2;
        float v177 = (long long *)(v154 - 16);
        uint64_t v178 = v174 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v179 = *v177;
          *((_OWORD *)v176 - 1) = *(v177 - 1);
          *(_OWORD *)float v176 = v179;
          v176 -= 4;
          v177 -= 2;
          v178 -= 4;
        }
        while (v178);
        v125 -= v174 & 0x3FFFFFFFFFFFFFFCLL;
        if (v174 == (v174 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_245;
        }
      }
      do
      {
        uint64_t v224 = *(ggl::PipelineSetup **)(v175 - 8);
        v175 -= 8;
        *--int v125 = v224;
      }
      while (v175 != v172);
      goto LABEL_245;
    }
  }
  else
  {
    double v504 = *(ggl::PipelineSetup **)(v116 - 8);
    *(void *)(v115 + 8) = v116 - 8;
    char v117 = *(ggl::PipelineSetup ***)(v115 + 40);
    unint64_t v118 = *(void *)(v115 + 48);
    if ((unint64_t)v117 >= v118)
    {
      uint64_t v119 = *(void *)(v115 + 32);
      uint64_t v120 = ((uint64_t)v117 - v119) >> 3;
      unint64_t v121 = v120 + 1;
      if ((unint64_t)(v120 + 1) >> 61) {
        goto LABEL_640;
      }
      uint64_t v122 = v118 - v119;
      if (v122 >> 2 > v121) {
        unint64_t v121 = v122 >> 2;
      }
      if ((unint64_t)v122 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v123 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v123 = v121;
      }
      if (v123)
      {
        uint64_t v124 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v115 + 56) + 16))(*(void *)(v115 + 56), 8 * v123, 8);
        int v125 = (ggl::PipelineSetup **)(v124 + 8 * v120);
        uint64_t v126 = v124 + 8 * v123;
        if (v124) {
          void *v125 = v504;
        }
      }
      else
      {
        uint64_t v126 = 0;
        int v125 = (ggl::PipelineSetup **)(8 * v120);
      }
      uint64_t v132 = v125 + 1;
      uint64_t v155 = *(void *)(v115 + 32);
      uint64_t v154 = *(void *)(v115 + 40);
      if (v154 == v155) {
        goto LABEL_246;
      }
      unint64_t v156 = v154 - v155 - 8;
      if (v156 < 0x38)
      {
        uint64_t v158 = *(void *)(v115 + 40);
      }
      else if ((unint64_t)(v154 - (void)v125) < 0x20)
      {
        uint64_t v158 = *(void *)(v115 + 40);
      }
      else
      {
        uint64_t v157 = (v156 >> 3) + 1;
        uint64_t v158 = v154 - 8 * (v157 & 0x3FFFFFFFFFFFFFFCLL);
        std::string::pointer v159 = v125 - 2;
        uint64_t v160 = (long long *)(v154 - 16);
        uint64_t v161 = v157 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v162 = *v160;
          *((_OWORD *)v159 - 1) = *(v160 - 1);
          *(_OWORD *)std::string::pointer v159 = v162;
          v159 -= 4;
          v160 -= 2;
          v161 -= 4;
        }
        while (v161);
        v125 -= v157 & 0x3FFFFFFFFFFFFFFCLL;
        if (v157 == (v157 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_245;
        }
      }
      do
      {
        uint64_t v180 = *(ggl::PipelineSetup **)(v158 - 8);
        v158 -= 8;
        *--int v125 = v180;
      }
      while (v158 != v155);
LABEL_245:
      uint64_t v154 = *(void *)(v115 + 32);
LABEL_246:
      *(void *)(v115 + 32) = v125;
      *(void *)(v115 + 40) = v132;
      uint64_t v225 = *(void *)(v115 + 48);
      *(void *)(v115 + 48) = v126;
      if (v154) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v115 + 56) + 40))(*(void *)(v115 + 56), v154, v225 - v154);
      }
      goto LABEL_248;
    }
  }
  if (v117) {
    *char v117 = v504;
  }
  uint64_t v132 = v117 + 1;
LABEL_248:
  *(void *)(v115 + 40) = v132;
  *(void *)&long long v554 = v504;
  uint64_t v226 = *(void *)(v115 + 120);
  if (!v226) {
    goto LABEL_638;
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v226 + 48))(v226, &v554);
  int v227 = **(_DWORD **)(v548 + 392);
  id v228 = v506;
  size_t v229 = *(uint64_t **)a5;
  uint64_t v230 = *((void *)v504 + 8);
  *(void *)(v230 + 24) = 0;
  uint64_t v231 = *v229;
  *(void *)(v230 + 16) = *v229;
  uint64_t v232 = *((void *)v504 + 20);
  uint64_t v233 = v229[1];
  if (v233) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v233 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v234 = *(std::__shared_weak_count **)(v232 + 24);
  *(void *)(v232 + 16) = v231;
  *(void *)(v232 + 24) = v233;
  if (v234 && !atomic_fetch_add(&v234->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v234->__on_zero_shared)(v234);
    std::__shared_weak_count::__release_weak(v234);
  }
  uint64_t v235 = *(void *)(*((void *)v504 + 8) + 32);
  long long v554 = 0uLL;
  unint64_t v236 = *(void *)(v235 + 8);
  *(void *)&long long v237 = 0;
  *((void *)&v237 + 1) = v235;
  if (v236) {
    uint64_t v238 = *(ggl::PipelineSetup **)(v235 + 72);
  }
  else {
    uint64_t v238 = 0;
  }
  long long v551 = v237;
  long long v554 = v237;
  double v555 = 0;
  uint64_t v556 = v236;
  unint64_t v558 = v238;
  LOWORD(v557) = 1;
  *(void *)uint64_t v238 = *(void *)(a5 + 76);
  std::string::size_type v239 = (_DWORD *)[v228 origin];
  *((_DWORD *)v238 + 4) = *v239;
  *((_DWORD *)v238 + 5) = v239[1];
  *((_DWORD *)v238 + 6) = v239[2];
  [v228 size];
  *((_DWORD *)v238 + 8) = v240;
  *((_DWORD *)v238 + 9) = v241;
  *((_DWORD *)v238 + 10) = v242;
  if (v236)
  {
    if ((void)v551 && *(unsigned char *)(*((void *)&v551 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v551 + 64))();
    }
    unint64_t v243 = *(void *)(*((void *)&v551 + 1) + 64);
    if (v243 <= v236) {
      unint64_t v243 = v236;
    }
    *(void *)(*((void *)&v551 + 1) + 56) = 0;
    *(void *)(*((void *)&v551 + 1) + 64) = v243;
  }
  uint64_t v244 = (void *)*((void *)v504 + 8);
  long long v245 = (void *)v244[6];
  unint64_t v246 = v245[1];
  if (v246) {
    int v247 = (_DWORD *)v245[9];
  }
  else {
    int v247 = 0;
  }
  v247[92] = *(_DWORD *)(a5 + 56);
  v247[93] = *(_DWORD *)(a5 + 60);
  v247[94] = *(_DWORD *)(a5 + 64);
  v247[89] = v227;
  if (v247 && v246)
  {
    if (v245[8] > v246) {
      unint64_t v246 = v245[8];
    }
    v245[7] = 0;
    v245[8] = v246;
  }
  v248 = *(void **)(*(void *)(a5 + 40) + 8);
  unint64_t v249 = v248[1];
  if ((v249 & (v249 - 1)) != 0)
  {
    unint64_t v251 = 0x41E8D6E445F4145;
    if (v249 <= 0x41E8D6E445F4145) {
      unint64_t v251 = 0x41E8D6E445F4145 % v249;
    }
    int v250 = *(void **)(*v248 + 8 * v251);
    do
    {
      do
        int v250 = (void *)*v250;
      while (v250[1] != 0x41E8D6E445F4145);
    }
    while (v250[2] != 0x41E8D6E445F4145);
  }
  else
  {
    int v250 = *(void **)(*v248 + 8 * ((v249 - 1) & 0x41E8D6E445F4145));
    do
    {
      do
        int v250 = (void *)*v250;
      while (v250[1] != 0x41E8D6E445F4145);
    }
    while (v250[2] != 0x41E8D6E445F4145);
  }
  unint64_t v252 = *(uint64_t **)(v250[5] + 32);
  v244[11] = 0;
  uint64_t v253 = *v252;
  v244[10] = *v252;
  uint64_t v254 = *((void *)v504 + 20);
  uint64_t v255 = v252[1];
  if (v255) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v255 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v256 = *(std::__shared_weak_count **)(v254 + 88);
  *(void *)(v254 + 80) = v253;
  *(void *)(v254 + 88) = v255;
  if (v256 && !atomic_fetch_add(&v256->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v256->__on_zero_shared)(v256);
    std::__shared_weak_count::__release_weak(v256);
  }

  uint64_t v257 = *((void *)v504 + 8);
  long long v221 = *(void **)(v257 + 48);
  v511 = *(void **)(v257 + 64);
  uint64_t v258 = ggl::FragmentedPool<ggl::DiffuseBuilding::BuildingPipelineSetup>::pop(*(void *)(*(void *)(v548 + 392)
                                                                                         + 512));
  uint64_t FoggedExtrusionPipelineSetupForGroup = getExtrusionPipelineSetupForGroup(v258, v228, a5, **(float **)(v548 + 392));
  double v497 = (ggl::PipelineSetup *)FoggedExtrusionPipelineSetupForGroup;
  double v498 = 0;
  uint64_t v507 = 0;
LABEL_288:
  uint64_t v259 = *(void *)(FoggedExtrusionPipelineSetupForGroup + 64);
  unint64_t v510 = *(void **)(v259 + 64);
  uint64_t v260 = *(void **)(v259 + 48);
  if (*(unsigned char *)(*(void *)(v548 + 392) + 769))
  {
    uint64_t v261 = [v502 alphaAtlas];
    id v262 = **(id **)(a5 + 40);
    [v262 sizeInPixels];
    double v264 = v263;
    double v6 = v265;

    uint64_t v266 = ggl::FragmentedPool<ggl::PrefilteredLine::PrefilteredLinePipelineSetup>::pop(*(void *)(*(void *)(v548 + 392)
                                                                                                  + 600));
    int v267 = *(uint64_t **)a5;
    float64_t v268 = *(uint64_t **)(v266 + 64);
    v268[1] = 0;
    uint64_t v269 = *v267;
    *float64_t v268 = *v267;
    uint64_t v270 = *(void **)(v266 + 160);
    uint64_t v271 = v267[1];
    if (v271) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v271 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v272 = (std::__shared_weak_count *)v270[1];
    *uint64_t v270 = v269;
    v270[1] = v271;
    if (v272 && !atomic_fetch_add(&v272->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v272->__on_zero_shared)(v272);
      std::__shared_weak_count::__release_weak(v272);
    }
    int v273 = *(uint64_t **)(a5 + 8);
    uint64_t v274 = *(void *)(v266 + 64);
    *(void *)(v274 + 40) = 0;
    uint64_t v275 = *v273;
    *(void *)(v274 + 32) = *v273;
    uint64_t v276 = *(void *)(v266 + 160);
    uint64_t v277 = v273[1];
    if (v277) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v277 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v278 = *(std::__shared_weak_count **)(v276 + 40);
    *(void *)(v276 + 32) = v275;
    *(void *)(v276 + 40) = v277;
    if (v278 && !atomic_fetch_add(&v278->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v278->__on_zero_shared)(v278);
      std::__shared_weak_count::__release_weak(v278);
    }
    **(void **)(v266 + 96) = *(void *)(v261 + 24);
    int v281 = *(void **)(*(void *)(v266 + 64) + 16);
    long long v554 = 0uLL;
    unint64_t v282 = v281[1];
    *(void *)&long long v283 = 0;
    *((void *)&v283 + 1) = v281;
    uint64_t v552 = v281;
    if (v282) {
      uint64_t v284 = v281[9];
    }
    else {
      uint64_t v284 = 0;
    }
    long long v545 = v283;
    long long v554 = v283;
    double v555 = 0;
    uint64_t v556 = v282;
    unint64_t v558 = (ggl::PipelineSetup *)v284;
    LOWORD(v557) = 1;
    float v279 = v264;
    *(float *)(v284 + 288) = v279;
    float v280 = v6;
    *(float *)(v284 + 292) = v280;
    *(_DWORD *)(v284 + 336) = *(_DWORD *)(a5 + 80);
    *(void *)uint64_t v284 = 0;
    *(void *)(v284 + 8) = 0;
    uint64_t v285 = (_DWORD *)[v506 origin];
    uint64_t v496 = v266;
    *(_DWORD *)(v284 + 304) = *v285;
    *(_DWORD *)(v284 + 308) = v285[1];
    *(_DWORD *)(v284 + 312) = v285[2];
    [v506 size];
    *(_DWORD *)(v284 + 320) = v286;
    *(_DWORD *)(v284 + 324) = v287;
    *(_DWORD *)(v284 + 328) = v288;
    *(float *)(v284 + 340) = v541;
    if (v282)
    {
      if ((void)v545 && *(unsigned char *)(*((void *)&v545 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v545 + 64))();
      }
      unint64_t v289 = *(void *)(*((void *)&v545 + 1) + 64);
      if (v289 <= v282) {
        unint64_t v289 = v282;
      }
      *(void *)(*((void *)&v545 + 1) + 56) = 0;
      *(void *)(*((void *)&v545 + 1) + 64) = v289;
    }
  }
  else
  {
    uint64_t v496 = 0;
    uint64_t v552 = 0;
  }
  uint64_t v540 = v99;
  id v495 = v17;
  double v290 = *(uint64_t ***)(a5 + 16);
  int v291 = *v290;
  __asm { FMOV            V0.2S, #1.0 }
  uint64_t v543 = _D0;
  uint64_t v544 = v100;
  uint64_t v546 = v290[1];
  if (*v290 != v546)
  {
    uint64_t v542 = 0;
    unsigned __int8 v296 = 0;
    float v12 = 1.0;
    float32x2_t v505 = (float32x2_t)vdup_n_s32(0x37800080u);
    unint64_t v509 = v221;
    int v297 = v552;
    while (1)
    {
      uint64_t v299 = *v291;
      *(void *)&long long v565 = *v291;
      v300 = (std::__shared_weak_count *)v291[1];
      *((void *)&v565 + 1) = v300;
      if (v300) {
        atomic_fetch_add_explicit(&v300->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)&v554, v299, (uint64_t)v300);
      if (v300 && !atomic_fetch_add(&v300->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v300->__on_zero_shared)(v300);
        std::__shared_weak_count::__release_weak(v300);
        if (!(_BYTE)v557) {
          goto LABEL_362;
        }
      }
      else if (!(_BYTE)v557)
      {
        goto LABEL_362;
      }
      uint64_t v301 = *(void *)(v554 + 24);
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v302 = 23;
      }
      else {
        unsigned int v302 = (int)*(float *)(a5 + 88);
      }
      std::string v303 = *(float **)v301;
      if (*(void *)v301
        && (float v304 = *v303, LODWORD(v303) = *v303 == v12, *(unsigned char *)(v301 + 10))
        && (v304 != 0.0 ? (_ZF = v304 == v12) : (_ZF = 1), !_ZF)
        || (v306 = *(unsigned __int8 *)(v301 + v303 + 11), float v304 = 0.0, v306 == 2))
      {
        LOBYTE(v565) = 1;
        LOBYTE(v570[0]) = 1;
        char v307 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v301, 0x5Bu, v302, 0, &v565);
        char v308 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v301, 0x5Bu, v302, 1, v570);
        if (v304 < v12) {
          char v308 = v307;
        }
      }
      else
      {
        char v308 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(v554 + 24), 0x5Bu, v302, v306, 0);
      }
      int v297 = v552;
      if (!v308)
      {
LABEL_362:
        unint64_t v327 = v221[1];
        if (v327)
        {
          uint64_t v328 = v221[9];
          uint64_t v329 = v296;
          uint64_t v330 = (void *)(v328 + 16 * v296);
          *uint64_t v330 = 0;
          v330[1] = 0;
          *(void *)(v328 + 8 * v296 + 256) = v543;
          if (v328)
          {
            if (v221[8] > v327) {
              unint64_t v327 = v221[8];
            }
            v221[7] = 0;
            v221[8] = v327;
          }
          uint64_t v331 = v543;
        }
        else
        {
          uint64_t v329 = v296;
          int v332 = (void *)(16 * v296);
          *int v332 = 0;
          v332[1] = 0;
          uint64_t v331 = v543;
          *(void *)(8 * v296 + 0x100) = v543;
        }
        unint64_t v333 = v260[1];
        uint64_t v334 = v260[9];
        int v335 = (void *)(v334 + 16 * v329);
        *int v335 = 0;
        v335[1] = 0;
        *(void *)(v334 + 8 * v329 + 256) = v331;
        if (v260[8] > v333) {
          unint64_t v333 = v260[8];
        }
        v260[7] = 0;
        v260[8] = v333;
        if (*(unsigned char *)(*(void *)(v548 + 392) + 769))
        {
          unint64_t v336 = v297[1];
          if (v336)
          {
            uint64_t v337 = v297[9];
            *(_DWORD *)(v337 + 4 * v329 + 256) = 0;
            uint64_t v338 = v337 + 16 * v329;
            *(void *)(v338 + 128) = 0;
            *(void *)(v338 + 136) = 0;
            unint64_t v339 = v297[8];
            if (v339 <= v336) {
              unint64_t v339 = v336;
            }
            v297[7] = 0;
            v297[8] = v339;
          }
          else
          {
            uint64_t v298 = 16 * v329;
            *(void *)(v298 + 128) = 0;
            *(void *)(v298 + 136) = 0;
          }
        }
        uint64_t v542 = 0x100000001;
        goto LABEL_314;
      }
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v309 = 23;
      }
      else {
        unsigned int v309 = (int)*(float *)(a5 + 88);
      }
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v565, *(void *)(v554 + 24), 0xA1u, v309, 2u, 0);
      LOWORD(v9) = WORD1(v565);
      LOWORD(v304) = v565;
      LOWORD(v6) = WORD3(v565);
      LOWORD(v11) = WORD2(v565);
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v310 = 23;
      }
      else {
        unsigned int v310 = (int)*(float *)(a5 + 88);
      }
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v565, *(void *)(v554 + 24), 0xA0u, v310, 2u, 0);
      unsigned int v534 = LODWORD(v6);
      unsigned int v537 = LODWORD(v304);
      LOWORD(v311) = v565;
      unsigned int v528 = v311;
      LOWORD(v311) = WORD1(v565);
      unsigned int v530 = v311;
      LOWORD(v311) = WORD2(v565);
      unsigned int v532 = v311;
      LOWORD(v10) = WORD3(v565);
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v312 = 23;
      }
      else {
        unsigned int v312 = (int)*(float *)(a5 + 88);
      }
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v565, *(void *)(v554 + 24), 0xA3u, v312, 2u, 0);
      LOWORD(v8) = WORD1(v565);
      LOWORD(v6) = v565;
      LOWORD(v304) = WORD3(v565);
      LOWORD(v7) = WORD2(v565);
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v313 = 23;
      }
      else {
        unsigned int v313 = (int)*(float *)(a5 + 88);
      }
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v565, *(void *)(v554 + 24), 3u, v313, 2u, 0);
      unsigned int v516 = (unsigned __int16)v565;
      unsigned int v314 = WORD1(v565);
      LOWORD(v315) = WORD2(v565);
      unsigned int v518 = v315;
      LOWORD(v315) = WORD3(v565);
      unsigned int v520 = v315;
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v316 = 23;
      }
      else {
        unsigned int v316 = (int)*(float *)(a5 + 88);
      }
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v565, *(void *)(v554 + 24), 0x5Du, v316, 2u, 0);
      unsigned int v524 = LODWORD(v9);
      unsigned int v526 = LODWORD(v11);
      v513.i32[0] = (unsigned __int16)v565;
      v513.i32[1] = WORD1(v565);
      LOWORD(v317) = WORD2(v565);
      unsigned int v515 = v317;
      float v318 = *(float *)(a5 + 88);
      unsigned int v319 = (int)v318;
      LOWORD(v318) = WORD3(v565);
      unsigned int v514 = LODWORD(v318);
      uint64_t v320 = *(void *)(v554 + 24);
      if (v319 >= 0x17) {
        unsigned int v321 = 23;
      }
      else {
        unsigned int v321 = v319;
      }
      uint64_t v322 = *(float **)v320;
      unsigned int v522 = LODWORD(v304);
      if (*(void *)v320
        && (float v323 = *v322, LODWORD(v322) = *v322 == v12, *(unsigned char *)(v320 + 10))
        && v323 != 0.0
        && v323 != v12
        || (v324 = *(unsigned __int8 *)(v320 + v322 + 11), float v323 = 0.0, v324 == 2))
      {
        LOBYTE(v565) = 1;
        LOBYTE(v570[0]) = 1;
        float v325 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v320, 0x118u, v321, 0, &v565);
        float v326 = v325
             + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v320, 0x118u, v321, 1u, v570)- v325)* v323);
      }
      else
      {
        float v326 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v320, 0x118u, v321, v324, 0);
      }
      uint64_t v340 = *(void *)(v554 + 24);
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v341 = 23;
      }
      else {
        unsigned int v341 = (int)*(float *)(a5 + 88);
      }
      uint64_t v342 = *(float **)v340;
      unsigned int v512 = v314;
      if (*(void *)v340
        && (float v343 = *v342, LODWORD(v342) = *v342 == v12, *(unsigned char *)(v340 + 10))
        && v343 != 0.0
        && v343 != v12
        || (v344 = *(unsigned __int8 *)(v340 + v342 + 11), float v343 = 0.0, v344 == 2))
      {
        LOBYTE(v565) = 1;
        LOBYTE(v570[0]) = 1;
        char v345 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v340, 0x138u, v341, 0, &v565);
        char v346 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v340, 0x138u, v341, 1, v570);
        if (v343 >= v12) {
          char v345 = v346;
        }
      }
      else
      {
        char v345 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v340, 0x138u, v341, v344, 0);
      }
      uint64_t v347 = *(void *)(v554 + 24);
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v348 = 23;
      }
      else {
        unsigned int v348 = (int)*(float *)(a5 + 88);
      }
      double v349 = *(float **)v347;
      if (*(void *)v347
        && (float v350 = *v349, LODWORD(v349) = *v349 == v12, *(unsigned char *)(v347 + 10))
        && v350 != 0.0
        && v350 != v12
        || (v351 = *(unsigned __int8 *)(v347 + v349 + 11), float v350 = 0.0, v351 == 2))
      {
        LOBYTE(v565) = 1;
        LOBYTE(v570[0]) = 1;
        float v352 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v347, 0x14Au, v348, 0, &v565);
        float v9 = v352
           + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v347, 0x14Au, v348, 1u, v570)- v352)* v350);
      }
      else
      {
        float v9 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v554 + 24), 0x14Au, v348, v351, 0);
      }
      uint64_t v353 = *(void *)(v554 + 24);
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v354 = 23;
      }
      else {
        unsigned int v354 = (int)*(float *)(a5 + 88);
      }
      double v355 = *(float **)v353;
      if (*(void *)v353
        && (float v11 = *v355, LODWORD(v355) = *v355 == v12, *(unsigned char *)(v353 + 10))
        && v11 != 0.0
        && v11 != v12
        || (v356 = *(unsigned __int8 *)(v353 + v355 + 11), float v11 = 0.0, v356 == 2))
      {
        LOBYTE(v565) = 1;
        LOBYTE(v570[0]) = 1;
        float v357 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v353, 0x14Bu, v354, 0, &v565);
        float v358 = v357
             + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v353, 0x14Bu, v354, 1u, v570)- v357)* v11);
      }
      else
      {
        float v358 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v554 + 24), 0x14Bu, v354, v356, 0);
      }
      float v359 = (float)v522 * 0.000015259;
      float v360 = *(float *)(a5 + 76);
      float v361 = *(float *)(a5 + 92);
      float v362 = (float)(v359 + (float)(v360 * (float)((float)((float)v10 * 0.000015259) - v359)))
           * (float)(v361 * *(float *)(a5 + 72));
      BOOL v363 = v362 < 0.9999;
      unint64_t v364 = v221[1];
      float v12 = 1.0;
      if (v364) {
        uint64_t v365 = v221[9];
      }
      else {
        uint64_t v365 = 0;
      }
      float v366 = (float)LODWORD(v6) * 0.000015259;
      float v367 = (float)LODWORD(v8) * 0.000015259;
      float v368 = (float)LODWORD(v7) * 0.000015259;
      float v369 = *(float *)(a5 + 84);
      double v370 = (float *)(v365 + 16 * v296);
      *double v370 = (float)(v366 + (float)(v360 * (float)((float)((float)v528 * 0.000015259) - v366))) * v361;
      v370[1] = (float)(v367 + (float)(v360 * (float)((float)((float)v530 * 0.000015259) - v367))) * v361;
      v370[2] = (float)(v368 + (float)(v360 * (float)((float)((float)v532 * 0.000015259) - v368))) * v361;
      v370[3] = v362;
      if (v326 >= 0.0001) {
        float v371 = v326;
      }
      else {
        float v371 = 1.0;
      }
      if (v326 >= 0.0001) {
        float v372 = 1.0;
      }
      else {
        float v372 = 0.0;
      }
      uint64_t v373 = v365 + 8 * v296;
      *(float *)(v373 + 256) = v371;
      *(float *)(v373 + 260) = v372;
      *(_DWORD *)(v365 + 4 * v296 + 320) = 1065353216;
      if (v365 && v364)
      {
        if (v221[8] > v364) {
          unint64_t v364 = v221[8];
        }
        v221[7] = 0;
        v221[8] = v364;
      }
      float v374 = *(float *)(a5 + 76);
      float v375 = *(float *)(a5 + 92);
      float v376 = (float)(v359 + (float)(v374 * (float)((float)((float)v534 * 0.000015259) - v359)))
           * (float)(v375 * *(float *)(a5 + 72));
      BOOL v377 = v376 < 0.9999;
      unint64_t v378 = v260[1];
      if (v378) {
        uint64_t v379 = v260[9];
      }
      else {
        uint64_t v379 = 0;
      }
      double v380 = (float *)(v379 + 16 * v296);
      *double v380 = (float)(v366 + (float)(v374 * (float)((float)((float)v537 * 0.000015259) - v366))) * v375;
      v380[1] = (float)(v367 + (float)(v374 * (float)((float)((float)v524 * 0.000015259) - v367))) * v375;
      v380[2] = (float)(v368 + (float)(v374 * (float)((float)((float)v526 * 0.000015259) - v368))) * v375;
      v380[3] = v376;
      uint64_t v381 = v379 + 8 * v296;
      *(float *)(v381 + 256) = v371;
      *(float *)(v381 + 260) = v372;
      float v382 = 1.5;
      if (!v345) {
        float v382 = 0.0;
      }
      *(float *)(v379 + 4 * v296 + 320) = v382;
      if (v379 && v378)
      {
        if (v260[8] > v378) {
          unint64_t v378 = v260[8];
        }
        v260[7] = 0;
        v260[8] = v378;
      }
      float v383 = v9 * 40075017.0 / ((double)(unint64_t)(1 << (int)v369) * v358);
      LOBYTE(v542) = v542 | v363;
      BYTE4(v542) |= v377;
      unint64_t v384 = v511[1];
      uint64_t v385 = (float *)(v511[9] + 8 * v296);
      *uint64_t v385 = v383;
      v385[1] = 1.0 - v9;
      if (v511[8] > v384) {
        unint64_t v384 = v511[8];
      }
      v511[7] = 0;
      v511[8] = v384;
      unint64_t v386 = v510[1];
      double v387 = (float *)(v510[9] + 8 * v296);
      *double v387 = v383;
      v387[1] = 1.0 - v9;
      if (v510[8] > v386) {
        unint64_t v386 = v510[8];
      }
      v510[7] = 0;
      v510[8] = v386;
      int v297 = v552;
      if (!*(unsigned char *)(*(void *)(v548 + 392) + 769)) {
        goto LABEL_465;
      }
      float v538 = *(float *)(a5 + 92);
      float v388 = *(float *)(a5 + 72);
      float v535 = *(float *)(a5 + 76);
      uint64_t v389 = *(void *)(v554 + 24);
      unsigned int v390 = (int)*(float *)(a5 + 88) >= 0x17 ? 23 : (int)*(float *)(a5 + 88);
      if ((double v391 = *(float **)v389) != 0
        && (float v392 = *v391, LODWORD(v391) = *v391 == 1.0, *(unsigned char *)(v389 + 10))
        && v392 != 0.0
        && v392 != 1.0
        || (v393 = *(unsigned __int8 *)(v389 + v391 + 11), float v392 = 0.0, v393 == 2))
      {
        LOBYTE(v565) = 1;
        LOBYTE(v570[0]) = 1;
        float v394 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v389, 2u, v390, 0, &v565);
        *(float *)&double v6 = v394
                      + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v389, 2u, v390, 1u, v570)- v394)* v392);
      }
      else
      {
        LODWORD(v6) = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v554 + 24), 2u, v390, v393, 0);
      }
      uint64_t v395 = *(void *)(v554 + 24);
      unsigned int v396 = (int)*(float *)(a5 + 88) >= 0x17 ? 23 : (int)*(float *)(a5 + 88);
      if ((unint64_t v397 = *(float **)v395) != 0
        && (float v7 = *v397, LODWORD(v397) = *v397 == 1.0, *(unsigned char *)(v395 + 10))
        && v7 != 0.0
        && v7 != 1.0
        || (v398 = *(unsigned __int8 *)(v395 + v397 + 11), float v7 = 0.0, v398 == 2))
      {
        LOBYTE(v565) = 1;
        LOBYTE(v570[0]) = 1;
        float v8 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v395, 0x61u, v396, 0, &v565);
        float v399 = v8
             + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v395, 0x61u, v396, 1u, v570)- v8)* v7);
      }
      else
      {
        float v399 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v554 + 24), 0x61u, v396, v398, 0);
      }
      unint64_t v400 = v552[1];
      uint64_t v401 = v400 ? v552[9] : 0;
      float32x2_t v402 = vmul_f32(vcvt_f32_u32(v513), v505);
      *(float *)(v401 + 4 * v296 + 256) = (float)(v399 * 0.5)
                                          + (float)(*(float *)(a5 + 76) * (float)(*(float *)&v6 - v399));
      uint64_t v403 = (float32x2_t *)(v401 + 16 * v296);
      v403[16] = vmul_n_f32(vmla_n_f32(v402, vsub_f32(vmul_f32(vcvt_f32_u32((uint32x2_t)__PAIR64__(v512, v516)), v505), v402), v535), v538);
      v403[17].f32[0] = (float)((float)((float)v515 * 0.000015259)
                              + (float)(v535
                                      * (float)((float)((float)v518 * 0.000015259) - (float)((float)v515 * 0.000015259))))
                      * v538;
      v403[17].f32[1] = (float)((float)((float)v514 * 0.000015259)
                              + (float)(v535
                                      * (float)((float)((float)v520 * 0.000015259) - (float)((float)v514 * 0.000015259))))
                      * (float)(v538 * v388);
      if (v401)
      {
        long long v221 = v509;
        if (v400)
        {
          if (v552[8] > v400) {
            unint64_t v400 = v552[8];
          }
          v552[7] = 0;
          v552[8] = v400;
        }
      }
      else
      {
LABEL_465:
        long long v221 = v509;
      }
LABEL_314:
      ++v296;
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v554);
      v291 += 2;
      if (v291 == v546) {
        goto LABEL_467;
      }
    }
  }
  uint64_t v542 = 0;
LABEL_467:
  long long v553 = (float *)a5;
  uint64_t v404 = *(uint64_t ***)(a5 + 24);
  unint64_t v405 = *v404;
  double v539 = v404[1];
  if (*v404 != v539)
  {
    char v547 = 0;
    unsigned __int8 v406 = 0;
    *(void *)&long long v407 = 0;
    uint64_t v408 = v540;
    *((void *)&v407 + 1) = v540;
    long long v536 = v407;
    *(void *)&long long v407 = 0;
    *((void *)&v407 + 1) = v100;
    long long v533 = v407;
    float v409 = 1.0;
    while (1)
    {
      uint64_t v411 = *v405;
      *(void *)&long long v554 = *v405;
      double v412 = (std::__shared_weak_count *)v405[1];
      *((void *)&v554 + 1) = v412;
      if (v412) {
        atomic_fetch_add_explicit(&v412->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v570, v411, (uint64_t)v412);
      if (v412 && !atomic_fetch_add(&v412->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v412->__on_zero_shared)(v412);
        std::__shared_weak_count::__release_weak(v412);
        int v413 = v571;
        if (!v571)
        {
LABEL_495:
          uint64_t v419 = v553;
          goto LABEL_498;
        }
      }
      else
      {
        int v413 = v571;
        if (!v571) {
          goto LABEL_495;
        }
      }
      uint64_t v414 = *(void *)(v570[0] + 24);
      if ((int)v553[22] >= 0x17) {
        unsigned int v415 = 23;
      }
      else {
        unsigned int v415 = (int)v553[22];
      }
      double v416 = *(float **)v414;
      if (*(void *)v414 && (float v417 = *v416, LODWORD(v416) = *v416 == v409, *(unsigned char *)(v414 + 10)))
      {
        BOOL v418 = v417 == 0.0 || v417 == v409;
        uint64_t v419 = v553;
        if (!v418)
        {
LABEL_491:
          LOBYTE(v554) = 1;
          LOBYTE(v565) = 1;
          char v421 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v414, 0x5Bu, v415, 0, &v554);
          char v422 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v414, 0x5Bu, v415, 1, &v565);
          if (v417 < v409) {
            char v422 = v421;
          }
          goto LABEL_497;
        }
      }
      else
      {
        uint64_t v419 = v553;
      }
      int v420 = *(unsigned __int8 *)(v414 + v416 + 11);
      float v417 = 0.0;
      if (v420 == 2) {
        goto LABEL_491;
      }
      char v422 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(v570[0] + 24), 0x5Bu, v415, v420, 0);
LABEL_497:
      int v413 = v422 != 0;
LABEL_498:
      long long v554 = 0uLL;
      unint64_t v423 = *(void *)(v408 + 8);
      if (v423) {
        double v424 = *(float **)(v408 + 72);
      }
      else {
        double v424 = 0;
      }
      long long v554 = v536;
      double v555 = 0;
      uint64_t v556 = v423;
      unint64_t v558 = (ggl::PipelineSetup *)v424;
      LOWORD(v557) = 1;
      long long v565 = 0uLL;
      uint64_t v425 = v100;
      unint64_t v426 = *(void *)(v100 + 8);
      if (v426) {
        uint64_t v427 = *(void *)(v425 + 72);
      }
      else {
        uint64_t v427 = 0;
      }
      long long v565 = v533;
      uint64_t v566 = 0;
      unint64_t v567 = v426;
      uint64_t v569 = v427;
      __int16 v568 = 1;
      if (v413)
      {
        uint64_t v428 = *(void *)(v570[0] + 24);
        if ((int)v419[22] >= 0x17) {
          unsigned int v429 = 23;
        }
        else {
          unsigned int v429 = (int)v419[22];
        }
        double v430 = *(float **)v428;
        if (*(void *)v428
          && (float v431 = *v430, LODWORD(v430) = *v430 == v409, *(unsigned char *)(v428 + 10))
          && (v431 != 0.0 ? (BOOL v432 = v431 == v409) : (BOOL v432 = 1), !v432)
          || (v433 = *(unsigned __int8 *)(v428 + v430 + 11), float v431 = 0.0, v433 == 2))
        {
          LOBYTE(v572) = 1;
          char v573 = 1;
          LODWORD(v6) = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v428, 0x118u, v429, 0, &v572);
          float v434 = *(float *)&v6
               + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v428, 0x118u, v429, 1u, &v573)- *(float *)&v6)* v431);
        }
        else
        {
          float v434 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v570[0] + 24), 0x118u, v429, v433, 0);
        }
        float v531 = v434;
        if ((int)v419[22] >= 0x17) {
          unsigned int v436 = 23;
        }
        else {
          unsigned int v436 = (int)v419[22];
        }
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>(&v572, *(void *)(v570[0] + 24), 0xA0u, v436, 2u, 0);
        LOWORD(v437) = WORD1(v572);
        LOWORD(v10) = v572;
        unsigned int v529 = v437;
        LOWORD(v7) = HIWORD(v572);
        LOWORD(v8) = WORD2(v572);
        if ((int)v419[22] >= 0x17) {
          unsigned int v438 = 23;
        }
        else {
          unsigned int v438 = (int)v419[22];
        }
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>(&v572, *(void *)(v570[0] + 24), 0xA1u, v438, 2u, 0);
        LOWORD(v431) = WORD1(v572);
        LOWORD(v6) = v572;
        LOWORD(v11) = HIWORD(v572);
        LOWORD(v12) = WORD2(v572);
        if ((int)v419[22] >= 0x17) {
          unsigned int v439 = 23;
        }
        else {
          unsigned int v439 = (int)v419[22];
        }
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>(&v572, *(void *)(v570[0] + 24), 0xA3u, v439, 2u, 0);
        unsigned int v525 = LODWORD(v8);
        unsigned int v527 = LODWORD(v7);
        LOWORD(v440) = v572;
        unsigned int v517 = v440;
        LOWORD(v440) = WORD1(v572);
        unsigned int v521 = v440;
        LOWORD(v440) = WORD2(v572);
        unsigned int v523 = v440;
        float v441 = v419[22];
        unsigned int v442 = (int)v441;
        LOWORD(v441) = HIWORD(v572);
        unsigned int v519 = LODWORD(v441);
        uint64_t v443 = *(void *)(v570[0] + 24);
        if (v442 >= 0x17) {
          unsigned int v444 = 23;
        }
        else {
          unsigned int v444 = v442;
        }
        v445 = *(float **)v443;
        if (*(void *)v443
          && (float v446 = *v445, LODWORD(v445) = *v445 == v409, *(unsigned char *)(v443 + 10))
          && v446 != 0.0
          && v446 != v409
          || (v447 = *(unsigned __int8 *)(v443 + v445 + 11), float v446 = 0.0, v447 == 2))
        {
          LOBYTE(v572) = 1;
          char v573 = 1;
          float v448 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v443, 0x14Au, v444, 0, &v572);
          float v7 = v448
             + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v443, 0x14Au, v444, 1u, &v573)- v448)* v446);
        }
        else
        {
          float v7 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v570[0] + 24), 0x14Au, v444, v447, 0);
        }
        uint64_t v449 = *(void *)(v570[0] + 24);
        if ((int)v553[22] >= 0x17) {
          unsigned int v450 = 23;
        }
        else {
          unsigned int v450 = (int)v553[22];
        }
        double v451 = *(float **)v449;
        if (!*(void *)v449 || (float v8 = *v451, LODWORD(v451) = *v451 == v409, !*(unsigned char *)(v449 + 10)))
        {
          double v452 = v553;
          goto LABEL_549;
        }
        double v452 = v553;
        if (v8 == 0.0 || v8 == v409)
        {
LABEL_549:
          unsigned int v453 = *(unsigned __int8 *)(v449 + v451 + 11);
          float v8 = 0.0;
          if (v453 == 2) {
            goto LABEL_550;
          }
          float v455 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v570[0] + 24), 0x14Bu, v450, v453, 0);
        }
        else
        {
LABEL_550:
          LOBYTE(v572) = 1;
          char v573 = 1;
          float v454 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v449, 0x14Bu, v450, 0, &v572);
          float v455 = v454
               + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v449, 0x14Bu, v450, 1u, &v573)- v454)* v8);
        }
        float v456 = (float)v517 * 0.000015259;
        float v457 = (float)v521 * 0.000015259;
        float v458 = (float)v523 * 0.000015259;
        float v459 = (float)v519 * 0.000015259;
        float v460 = v7 * 40075017.0 / ((double)(unint64_t)(1 << (int)v452[21]) * v455);
        float v409 = 1.0;
        float v461 = v452[19];
        float v462 = v452[23];
        float v463 = v452[18] * v462;
        float v464 = v463 * (float)(v459 + (float)(v461 * (float)((float)((float)v527 * 0.000015259) - v459)));
        float v465 = v463 * (float)(v459 + (float)(v461 * (float)((float)((float)LODWORD(v11) * 0.000015259) - v459)));
        double v466 = &v424[4 * v406];
        *double v466 = (float)(v456 + (float)(v461 * (float)((float)((float)v10 * 0.000015259) - v456))) * v462;
        v466[1] = (float)(v457 + (float)(v461 * (float)((float)((float)v529 * 0.000015259) - v457))) * v462;
        v466[2] = (float)(v458 + (float)(v461 * (float)((float)((float)v525 * 0.000015259) - v458))) * v462;
        v466[3] = v464;
        v466[32] = (float)(v456 + (float)(v461 * (float)((float)((float)LODWORD(v6) * 0.000015259) - v456))) * v462;
        v466[33] = (float)(v457 + (float)(v461 * (float)((float)((float)LODWORD(v431) * 0.000015259) - v457))) * v462;
        v466[34] = (float)(v458 + (float)(v461 * (float)((float)((float)LODWORD(v12) * 0.000015259) - v458))) * v462;
        v466[35] = v465;
        uint64_t v467 = 2 * v406;
        *(int8x8_t *)&v424[v467 + 64] = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v531 < 0.0001), 0x1FuLL)), (int8x8_t)1065353216, (int8x8_t)__PAIR64__(HIDWORD(v543), LODWORD(v531)));
        v424[v406 + 80] = 1.0;
        uint64_t v468 = (float *)(v427 + v467 * 4);
        *uint64_t v468 = v460;
        v468[1] = 1.0 - v7;
        BOOL v469 = v464 < 0.9999;
        if (v465 < 0.9999) {
          BOOL v469 = 1;
        }
        v547 |= v469;
        v424[96] = v541;
        if (!v426) {
          goto LABEL_558;
        }
LABEL_555:
        unint64_t v470 = *(void *)(v544 + 64);
        if (v470 <= v426) {
          unint64_t v470 = v426;
        }
        *(void *)(v544 + 56) = 0;
        *(void *)(v544 + 64) = v470;
        goto LABEL_558;
      }
      unint64_t v435 = &v424[4 * v406];
      *(void *)unint64_t v435 = 0;
      *((void *)v435 + 1) = 0;
      *((void *)v435 + 16) = 0;
      *((void *)v435 + 17) = 0;
      *(void *)&v424[2 * v406 + 64] = 1065353216;
      v424[v406 + 80] = 1.0;
      v424[96] = v541;
      char v547 = 1;
      if (v427 && v426) {
        goto LABEL_555;
      }
LABEL_558:
      uint64_t v408 = v540;
      if (v423)
      {
        unint64_t v410 = *(void *)(v540 + 64);
        if (v410 <= v423) {
          unint64_t v410 = v423;
        }
        *(void *)(v540 + 56) = 0;
        *(void *)(v540 + 64) = v410;
      }
      ++v406;
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v570);
      v405 += 2;
      uint64_t v100 = v544;
      if (v405 == v539) {
        goto LABEL_561;
      }
    }
  }
  char v547 = 0;
LABEL_561:
  if (v542)
  {
    uint64_t v471 = v503;
    unint64_t v472 = v504;
    unint64_t v473 = v507;
    int v475 = v497;
    v474 = v498;
    char v476 = BYTE4(v542);
    char v477 = v547;
    unint64_t v478 = v553;
    if (v504) {
      ggl::Flyover::FlyoverPipelineSetup::setState(v504, *(void *)(*(void *)(v548 + 392) + 376), *(std::__shared_weak_count **)(*(void *)(v548 + 392) + 384));
    }
    if (!v507) {
      goto LABEL_585;
    }
    uint64_t v480 = *(void *)(*(void *)(v548 + 392) + 408);
    uint64_t v479 = *(std::__shared_weak_count **)(*(void *)(v548 + 392) + 416);
    if (!v479) {
      goto LABEL_572;
    }
LABEL_571:
    atomic_fetch_add_explicit(&v479->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_572;
  }
  uint64_t v471 = v503;
  unint64_t v472 = v504;
  unint64_t v473 = v507;
  int v475 = v497;
  v474 = v498;
  char v476 = BYTE4(v542);
  char v477 = v547;
  unint64_t v478 = v553;
  if (v504) {
    ggl::Flyover::FlyoverPipelineSetup::setState(v504, *(void *)(*(void *)(v548 + 392) + 216), *(std::__shared_weak_count **)(*(void *)(v548 + 392) + 224));
  }
  if (!v507) {
    goto LABEL_585;
  }
  uint64_t v480 = *(void *)(*(void *)(v548 + 392) + 248);
  uint64_t v479 = *(std::__shared_weak_count **)(*(void *)(v548 + 392) + 256);
  if (v479) {
    goto LABEL_571;
  }
LABEL_572:
  if (!v480 || **(void **)(v480 + 40) != *((void *)v473 + 1))
  {
    uint64_t v481 = (std::__shared_weak_count *)*((void *)v473 + 3);
    *((void *)v473 + 2) = 0;
    *((void *)v473 + 3) = 0;
    uint64_t v471 = v503;
    if (!v481) {
      goto LABEL_583;
    }
    goto LABEL_582;
  }
  uint64_t v482 = *((void *)v473 + 2);
  if (v482 && v482 != v480) {
    ggl::PipelineSetup::resetData((uint64_t)v473);
  }
  if (v479) {
    atomic_fetch_add_explicit(&v479->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v481 = (std::__shared_weak_count *)*((void *)v473 + 3);
  *((void *)v473 + 2) = v480;
  *((void *)v473 + 3) = v479;
  uint64_t v471 = v503;
  if (v481)
  {
LABEL_582:
    if (atomic_fetch_add(&v481->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_583;
    }
    ((void (*)(std::__shared_weak_count *))v481->__on_zero_shared)(v481);
    std::__shared_weak_count::__release_weak(v481);
    if (v479) {
      goto LABEL_584;
    }
LABEL_585:
    if (v476) {
      goto LABEL_586;
    }
    goto LABEL_593;
  }
LABEL_583:
  if (!v479) {
    goto LABEL_585;
  }
LABEL_584:
  if (atomic_fetch_add(&v479->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_585;
  }
  ((void (*)(std::__shared_weak_count *))v479->__on_zero_shared)(v479);
  std::__shared_weak_count::__release_weak(v479);
  if (v476)
  {
LABEL_586:
    if (v475) {
      ggl::Flyover::FlyoverPipelineSetup::setState(v475, *(void *)(*(void *)(v548 + 392) + 280), *(std::__shared_weak_count **)(*(void *)(v548 + 392) + 288));
    }
    if (v474)
    {
      uint64_t v483 = *(void *)(v548 + 392) + 312;
LABEL_597:
      ggl::Flyover::FlyoverPipelineSetup::setState(v474, *(void *)v483, *(std::__shared_weak_count **)(v483 + 8));
      goto LABEL_598;
    }
    goto LABEL_598;
  }
LABEL_593:
  if (v475) {
    ggl::Flyover::FlyoverPipelineSetup::setState(v475, *(void *)(*(void *)(v548 + 392) + 120), *(std::__shared_weak_count **)(*(void *)(v548 + 392) + 128));
  }
  if (v474)
  {
    uint64_t v483 = *(void *)(v548 + 392) + 152;
    goto LABEL_597;
  }
LABEL_598:
  double v484 = *(void **)(v548 + 392);
  if (v477)
  {
    if (!v508) {
      goto LABEL_621;
    }
    uint64_t v486 = v484[53];
    double v485 = (std::__shared_weak_count *)v484[54];
    if (!v485) {
      goto LABEL_605;
    }
LABEL_604:
    atomic_fetch_add_explicit(&v485->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_605;
  }
  if (!v508) {
    goto LABEL_621;
  }
  uint64_t v486 = v484[33];
  double v485 = (std::__shared_weak_count *)v484[34];
  if (v485) {
    goto LABEL_604;
  }
LABEL_605:
  if (v486 && **(void **)(v486 + 40) == *((void *)v508 + 1))
  {
    uint64_t v488 = *((void *)v508 + 2);
    if (v488 && v488 != v486) {
      ggl::PipelineSetup::resetData((uint64_t)v508);
    }
    if (v485) {
      atomic_fetch_add_explicit(&v485->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    double v487 = (std::__shared_weak_count *)*((void *)v508 + 3);
    *((void *)v508 + 2) = v486;
    *((void *)v508 + 3) = v485;
    uint64_t v471 = v503;
    if (!v487) {
      goto LABEL_617;
    }
    goto LABEL_615;
  }
  double v487 = (std::__shared_weak_count *)*((void *)v508 + 3);
  *((void *)v508 + 2) = 0;
  *((void *)v508 + 3) = 0;
  uint64_t v471 = v503;
  if (v487)
  {
LABEL_615:
    if (!atomic_fetch_add(&v487->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v487->__on_zero_shared)(v487);
      std::__shared_weak_count::__release_weak(v487);
    }
  }
LABEL_617:
  if (v485 && !atomic_fetch_add(&v485->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v485->__on_zero_shared)(v485);
    std::__shared_weak_count::__release_weak(v485);
  }
  double v484 = *(void **)(v548 + 392);
LABEL_621:
  *(void *)&long long v554 = v500;
  *((void *)&v554 + 1) = v472;
  double v555 = v473;
  uint64_t v556 = v471;
  uint64_t v557 = v475;
  unint64_t v558 = v474;
  uint64_t v559 = PointyRoofDepthPipelineSetupForGroup;
  uint64_t v560 = v508;
  uint64_t v561 = v496;
  int32x2_t v562 = vrev64_s32(*(int32x2_t *)(v478 + 24));
  uint64_t v563 = *((void *)v478 + 6);
  BOOL v564 = v478[17] > 0.5;
  uint64_t v489 = a6[3];
  if (v489)
  {
    double v490 = v506;
    if ((void *)v489 == a6)
    {
      float64x2_t v575 = v574;
      (*(void (**)(void *, void *))(*a6 + 24))(a6, v574);
      goto LABEL_627;
    }
    uint64_t v489 = (*(uint64_t (**)(uint64_t))(*(void *)v489 + 16))(v489);
  }
  else
  {
    double v490 = v506;
  }
  float64x2_t v575 = (void *)v489;
LABEL_627:
  submitRenderItems(v490, (uint64_t)v484, (uint64_t)&v554, v574);
  if (v575 == v574)
  {
    (*(void (**)(void *))(v574[0] + 32))(v574);
  }
  else if (v575)
  {
    (*(void (**)(void *))(*v575 + 40))(v575);
  }
  for (uint64_t i = *(void **)(objc_msgSend(v490, "featureIds", v495) + 16); i; uint64_t i = (void *)*i)
  {
    unint64_t v492 = i[2];
    float v493 = v478[21];
    uint64_t v494 = operator new(0x20uLL);
    v494[24] = (int)v493;
    *(void *)uint64_t v494 = 0;
    *((void *)v494 + 1) = ((v492 << 6) + (v492 >> 2) + (int)v493 - 0x61C8864680B583EBLL) ^ v492;
    *((void *)v494 + 2) = v492;
    if ((std::__hash_table<md::FeatureIdZoom,md::FeatureIdZoomHash,std::equal_to<md::FeatureIdZoom>,std::allocator<md::FeatureIdZoom>>::__node_insert_unique((void *)(v548 + 416), (uint64_t)v494) & 1) == 0)operator delete(v494); {
  }
    }
}

void sub_1A23AD788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a55);

  _Unwind_Resume(a1);
}

void md::BuildingRenderLayer::generateDiffuseRenderItemsForGroup(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  uint64_t v540 = *MEMORY[0x1E4F143B8];
  id v471 = a3;
  id v17 = a4;
  uint64_t v511 = a1;
  uint64_t v18 = ggl::FragmentedPool<ggl::BuildingTopDepth::CompressedMeshPipelineSetup>::pop(*(void *)(*(void *)(a1 + 392)
                                                                                               + 496));
  getTopDepthPipelineSetupForGroup(v18, v17, a5);
  uint64_t v19 = ggl::FragmentedPool<ggl::BuildingFacadeDepth::BuildingPipelineSetup>::pop(*(void *)(*(void *)(a1 + 392)
                                                                                            + 488));
  getExtrusionDepthPipelineSetupForGroup(v19, v17, a5);
  uint64_t v469 = v18;
  uint64_t v20 = ggl::FragmentedPool<ggl::BuildingPointyRoofDepth::BuildingPipelineSetup>::pop(*(void *)(*(void *)(v511 + 392)
                                                                                                + 504));
  uint64_t PointyRoofDepthPipelineSetupForGroup = getPointyRoofDepthPipelineSetupForGroup(v20, v17, a5);
  uint64_t v21 = *(void *)(*(void *)(v511 + 392) + 544);
  uint64_t v22 = *(void *)(v21 + 8);
  uint64_t v472 = v19;
  if (v22 == *(void *)v21)
  {
    uint64_t v26 = *(void *)(v21 + 88);
    if (!v26)
    {
LABEL_591:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_595:
      __break(1u);
      return;
    }
    char v477 = (ggl::PipelineSetup *)(*(uint64_t (**)(uint64_t))(*(void *)v26 + 48))(v26);
    float v24 = *(ggl::PipelineSetup ***)(v21 + 40);
    unint64_t v27 = *(void *)(v21 + 48);
    if ((unint64_t)v24 < v27)
    {
      if (v24) {
        *float v24 = v477;
      }
      goto LABEL_9;
    }
    uint64_t v37 = *(void *)(v21 + 32);
    uint64_t v38 = ((uint64_t)v24 - v37) >> 3;
    unint64_t v39 = v38 + 1;
    if (!((unint64_t)(v38 + 1) >> 61))
    {
      uint64_t v40 = v27 - v37;
      if (v40 >> 2 > v39) {
        unint64_t v39 = v40 >> 2;
      }
      if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v41 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v41 = v39;
      }
      if (v41)
      {
        uint64_t v42 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v21 + 56) + 16))(*(void *)(v21 + 56), 8 * v41, 8);
        uint64_t v35 = (ggl::PipelineSetup **)(v42 + 8 * v38);
        uint64_t v36 = v42 + 8 * v41;
        if (v42) {
          *uint64_t v35 = v477;
        }
      }
      else
      {
        uint64_t v36 = 0;
        uint64_t v35 = (ggl::PipelineSetup **)(8 * v38);
      }
      unsigned int v28 = v35 + 1;
      uint64_t v52 = *(void *)(v21 + 32);
      uint64_t v43 = *(void *)(v21 + 40);
      if (v43 == v52) {
        goto LABEL_52;
      }
      unint64_t v53 = v43 - v52 - 8;
      if (v53 < 0x38)
      {
        uint64_t v55 = *(void *)(v21 + 40);
      }
      else if ((unint64_t)(v43 - (void)v35) < 0x20)
      {
        uint64_t v55 = *(void *)(v21 + 40);
      }
      else
      {
        uint64_t v54 = (v53 >> 3) + 1;
        uint64_t v55 = v43 - 8 * (v54 & 0x3FFFFFFFFFFFFFFCLL);
        uint8x8_t v56 = v35 - 2;
        uint64_t v57 = (long long *)(v43 - 16);
        uint64_t v58 = v54 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v59 = *v57;
          *((_OWORD *)v56 - 1) = *(v57 - 1);
          *(_OWORD *)uint8x8_t v56 = v59;
          v56 -= 4;
          v57 -= 2;
          v58 -= 4;
        }
        while (v58);
        v35 -= v54 & 0x3FFFFFFFFFFFFFFCLL;
        if (v54 == (v54 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_51;
        }
      }
      do
      {
        unint64_t v61 = *(ggl::PipelineSetup **)(v55 - 8);
        v55 -= 8;
        *--uint64_t v35 = v61;
      }
      while (v55 != v52);
      goto LABEL_51;
    }
LABEL_593:
    abort();
  }
  float v23 = *(ggl::PipelineSetup **)(v22 - 8);
  *(void *)(v21 + 8) = v22 - 8;
  float v24 = *(ggl::PipelineSetup ***)(v21 + 40);
  unint64_t v25 = *(void *)(v21 + 48);
  char v477 = v23;
  if ((unint64_t)v24 < v25)
  {
    if (v24) {
      *float v24 = v23;
    }
LABEL_9:
    unsigned int v28 = v24 + 1;
    goto LABEL_54;
  }
  uint64_t v29 = *(void *)(v21 + 32);
  uint64_t v30 = ((uint64_t)v24 - v29) >> 3;
  unint64_t v31 = v30 + 1;
  if ((unint64_t)(v30 + 1) >> 61) {
    goto LABEL_593;
  }
  uint64_t v32 = v25 - v29;
  if (v32 >> 2 > v31) {
    unint64_t v31 = v32 >> 2;
  }
  if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v33 = v31;
  }
  if (v33)
  {
    uint64_t v34 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v21 + 56) + 16))(*(void *)(v21 + 56), 8 * v33, 8);
    uint64_t v35 = (ggl::PipelineSetup **)(v34 + 8 * v30);
    uint64_t v36 = v34 + 8 * v33;
    if (v34) {
      *uint64_t v35 = v477;
    }
  }
  else
  {
    uint64_t v36 = 0;
    uint64_t v35 = (ggl::PipelineSetup **)(8 * v30);
  }
  unsigned int v28 = v35 + 1;
  uint64_t v44 = *(void *)(v21 + 32);
  uint64_t v43 = *(void *)(v21 + 40);
  if (v43 == v44) {
    goto LABEL_52;
  }
  unint64_t v45 = v43 - v44 - 8;
  if (v45 < 0x38)
  {
    uint64_t v47 = *(void *)(v21 + 40);
  }
  else if ((unint64_t)(v43 - (void)v35) < 0x20)
  {
    uint64_t v47 = *(void *)(v21 + 40);
  }
  else
  {
    uint64_t v46 = (v45 >> 3) + 1;
    uint64_t v47 = v43 - 8 * (v46 & 0x3FFFFFFFFFFFFFFCLL);
    float v48 = v35 - 2;
    uint64_t v49 = (long long *)(v43 - 16);
    uint64_t v50 = v46 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v51 = *v49;
      *((_OWORD *)v48 - 1) = *(v49 - 1);
      *(_OWORD *)float v48 = v51;
      v48 -= 4;
      v49 -= 2;
      v50 -= 4;
    }
    while (v50);
    v35 -= v46 & 0x3FFFFFFFFFFFFFFCLL;
    if (v46 == (v46 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_51;
    }
  }
  do
  {
    uint64_t v60 = *(ggl::PipelineSetup **)(v47 - 8);
    v47 -= 8;
    *--uint64_t v35 = v60;
  }
  while (v47 != v44);
LABEL_51:
  uint64_t v43 = *(void *)(v21 + 32);
LABEL_52:
  *(void *)(v21 + 32) = v35;
  *(void *)(v21 + 40) = v28;
  uint64_t v62 = *(void *)(v21 + 48);
  *(void *)(v21 + 48) = v36;
  if (v43) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v21 + 56) + 40))(*(void *)(v21 + 56), v43, v62 - v43);
  }
LABEL_54:
  *(void *)(v21 + 40) = v28;
  *(void *)&long long v518 = v477;
  uint64_t v63 = *(void *)(v21 + 120);
  if (!v63) {
    goto LABEL_591;
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v63 + 48))(v63, &v518);
  id v475 = v17;
  unint64_t v64 = *(uint64_t **)a5;
  uint64_t v65 = *((void *)v477 + 8);
  *(void *)(v65 + 24) = 0;
  uint64_t v66 = *v64;
  *(void *)(v65 + 16) = *v64;
  uint64_t v67 = *((void *)v477 + 20);
  uint64_t v68 = v64[1];
  if (v68) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v68 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v69 = *(std::__shared_weak_count **)(v67 + 24);
  *(void *)(v67 + 16) = v66;
  *(void *)(v67 + 24) = v68;
  if (v69 && !atomic_fetch_add(&v69->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
    std::__shared_weak_count::__release_weak(v69);
  }
  int v70 = *(uint64_t **)(a5 + 8);
  float v71 = (uint64_t *)*((void *)v477 + 8);
  v71[1] = 0;
  uint64_t v72 = *v70;
  *float v71 = *v70;
  float v73 = (void *)*((void *)v477 + 20);
  uint64_t v74 = v70[1];
  if (v74) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v74 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v75 = (std::__shared_weak_count *)v73[1];
  void *v73 = v72;
  v73[1] = v74;
  if (v75 && !atomic_fetch_add(&v75->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
    std::__shared_weak_count::__release_weak(v75);
  }
  uint64_t v76 = *(void *)(*((void *)v477 + 8) + 32);
  long long v518 = 0uLL;
  unint64_t v77 = *(void *)(v76 + 8);
  *(void *)&long long v78 = 0;
  *((void *)&v78 + 1) = v76;
  if (v77) {
    uint64_t v79 = *(ggl::PipelineSetup **)(v76 + 72);
  }
  else {
    uint64_t v79 = 0;
  }
  long long v512 = v78;
  long long v518 = v78;
  unsigned int v519 = 0;
  uint64_t v520 = v77;
  unsigned int v522 = v79;
  LOWORD(v521) = 1;
  *(void *)uint64_t v79 = *(void *)(a5 + 76);
  uint64_t v80 = (_DWORD *)[v475 origin];
  *((_DWORD *)v79 + 4) = *v80;
  *((_DWORD *)v79 + 5) = v80[1];
  *((_DWORD *)v79 + 6) = v80[2];
  [v475 size];
  *((_DWORD *)v79 + 8) = v81;
  *((_DWORD *)v79 + 9) = v82;
  *((_DWORD *)v79 + 10) = v83;
  if (v77)
  {
    if ((void)v512 && *(unsigned char *)(*((void *)&v512 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v512 + 64))();
    }
    unint64_t v84 = *(void *)(*((void *)&v512 + 1) + 64);
    if (v84 <= v77) {
      unint64_t v84 = v77;
    }
    *(void *)(*((void *)&v512 + 1) + 56) = 0;
    *(void *)(*((void *)&v512 + 1) + 64) = v84;
  }
  float v85 = (void *)*((void *)v477 + 8);
  float v86 = (void *)v85[6];
  unint64_t v87 = v86[1];
  if (v87) {
    double v88 = (_DWORD *)v86[9];
  }
  else {
    double v88 = 0;
  }
  v88[92] = *(_DWORD *)(a5 + 56);
  v88[93] = *(_DWORD *)(a5 + 60);
  v88[94] = *(_DWORD *)(a5 + 64);
  v88[89] = 1065353216;
  if (v88 && v87)
  {
    if (v86[8] > v87) {
      unint64_t v87 = v86[8];
    }
    v86[7] = 0;
    v86[8] = v87;
  }
  double v89 = *(void **)(*(void *)(a5 + 40) + 8);
  unint64_t v90 = v89[1];
  if ((v90 & (v90 - 1)) != 0)
  {
    unint64_t v92 = 0x41E8D6E445F4145;
    if (v90 <= 0x41E8D6E445F4145) {
      unint64_t v92 = 0x41E8D6E445F4145 % v90;
    }
    float v91 = *(void **)(*v89 + 8 * v92);
    do
    {
      do
        float v91 = (void *)*v91;
      while (v91[1] != 0x41E8D6E445F4145);
    }
    while (v91[2] != 0x41E8D6E445F4145);
  }
  else
  {
    float v91 = *(void **)(*v89 + 8 * ((v90 - 1) & 0x41E8D6E445F4145));
    do
    {
      do
        float v91 = (void *)*v91;
      while (v91[1] != 0x41E8D6E445F4145);
    }
    while (v91[2] != 0x41E8D6E445F4145);
  }
  uint64_t v93 = *(uint64_t **)(v91[5] + 32);
  v85[11] = 0;
  uint64_t v94 = *v93;
  v85[10] = *v93;
  uint64_t v95 = *((void *)v477 + 20);
  uint64_t v96 = v93[1];
  if (v96) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v96 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 v97 = *(std::__shared_weak_count **)(v95 + 88);
  *(void *)(v95 + 80) = v94;
  *(void *)(v95 + 88) = v96;
  if (v97 && !atomic_fetch_add(&v97->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
    std::__shared_weak_count::__release_weak(v97);
  }

  uint64_t v98 = *((void *)v477 + 8);
  uint64_t v99 = *(void *)(v98 + 48);
  uint64_t v100 = *(void *)(v98 + 64);
  float v101 = 1.0;
  if (!*(unsigned char *)(a2 + 32)) {
    float v101 = 0.0;
  }
  float v505 = v101;
  uint64_t v102 = *(void *)(v511 + 392);
  if (*(unsigned char *)(a2 + 32))
  {
    uint64_t v103 = *(void *)(v102 + 536);
    uint64_t v104 = *(void *)(v103 + 8);
    if (v104 != *(void *)v103)
    {
      char v476 = *(ggl::PipelineSetup **)(v104 - 8);
      *(void *)(v103 + 8) = v104 - 8;
      __int16 v105 = *(ggl::PipelineSetup ***)(v103 + 40);
      unint64_t v106 = *(void *)(v103 + 48);
      if ((unint64_t)v105 >= v106)
      {
        uint64_t v107 = *(void *)(v103 + 32);
        uint64_t v108 = ((uint64_t)v105 - v107) >> 3;
        unint64_t v109 = v108 + 1;
        if (!((unint64_t)(v108 + 1) >> 61))
        {
          uint64_t v110 = v106 - v107;
          if (v110 >> 2 > v109) {
            unint64_t v109 = v110 >> 2;
          }
          if ((unint64_t)v110 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v111 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v111 = v109;
          }
          if (v111)
          {
            uint64_t v112 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v103 + 56) + 16))(*(void *)(v103 + 56), 8 * v111, 8);
            std::string::size_type v113 = (ggl::PipelineSetup **)(v112 + 8 * v108);
            uint64_t v114 = v112 + 8 * v111;
            if (v112) {
              *std::string::size_type v113 = v476;
            }
          }
          else
          {
            uint64_t v114 = 0;
            std::string::size_type v113 = (ggl::PipelineSetup **)(8 * v108);
          }
          uint64_t v129 = v113 + 1;
          uint64_t v140 = *(void *)(v103 + 32);
          uint64_t v139 = *(void *)(v103 + 40);
          if (v139 == v140) {
            goto LABEL_195;
          }
          unint64_t v141 = v139 - v140 - 8;
          if (v141 < 0x38)
          {
            uint64_t v143 = *(void *)(v103 + 40);
          }
          else if ((unint64_t)(v139 - (void)v113) < 0x20)
          {
            uint64_t v143 = *(void *)(v103 + 40);
          }
          else
          {
            uint64_t v142 = (v141 >> 3) + 1;
            uint64_t v143 = v139 - 8 * (v142 & 0x3FFFFFFFFFFFFFFCLL);
            std::string::size_type v144 = v113 - 2;
            std::string::pointer v145 = (long long *)(v139 - 16);
            uint64_t v146 = v142 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v147 = *v145;
              *((_OWORD *)v144 - 1) = *(v145 - 1);
              *(_OWORD *)std::string::size_type v144 = v147;
              v144 -= 4;
              v145 -= 2;
              v146 -= 4;
            }
            while (v146);
            v113 -= v142 & 0x3FFFFFFFFFFFFFFCLL;
            if (v142 == (v142 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_194;
            }
          }
          do
          {
            int v171 = *(ggl::PipelineSetup **)(v143 - 8);
            v143 -= 8;
            *--std::string::size_type v113 = v171;
          }
          while (v143 != v140);
LABEL_194:
          uint64_t v139 = *(void *)(v103 + 32);
LABEL_195:
          *(void *)(v103 + 32) = v113;
          *(void *)(v103 + 40) = v129;
          uint64_t v182 = *(void *)(v103 + 48);
          *(void *)(v103 + 48) = v114;
          if (v139) {
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v103 + 56) + 40))(*(void *)(v103 + 56), v139, v182 - v139);
          }
          goto LABEL_197;
        }
        goto LABEL_594;
      }
      goto LABEL_125;
    }
    uint64_t v127 = *(void *)(v103 + 88);
    if (v127)
    {
      char v476 = (ggl::PipelineSetup *)(*(uint64_t (**)(uint64_t))(*(void *)v127 + 48))(v127);
      __int16 v105 = *(ggl::PipelineSetup ***)(v103 + 40);
      unint64_t v128 = *(void *)(v103 + 48);
      if ((unint64_t)v105 >= v128)
      {
        uint64_t v133 = *(void *)(v103 + 32);
        uint64_t v134 = ((uint64_t)v105 - v133) >> 3;
        unint64_t v135 = v134 + 1;
        if (!((unint64_t)(v134 + 1) >> 61))
        {
          uint64_t v136 = v128 - v133;
          if (v136 >> 2 > v135) {
            unint64_t v135 = v136 >> 2;
          }
          if ((unint64_t)v136 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v137 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v137 = v135;
          }
          if (v137)
          {
            uint64_t v138 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v103 + 56) + 16))(*(void *)(v103 + 56), 8 * v137, 8);
            std::string::size_type v113 = (ggl::PipelineSetup **)(v138 + 8 * v134);
            uint64_t v114 = v138 + 8 * v137;
            if (v138) {
              *std::string::size_type v113 = v476;
            }
          }
          else
          {
            uint64_t v114 = 0;
            std::string::size_type v113 = (ggl::PipelineSetup **)(8 * v134);
          }
          uint64_t v129 = v113 + 1;
          uint64_t v163 = *(void *)(v103 + 32);
          uint64_t v139 = *(void *)(v103 + 40);
          if (v139 == v163) {
            goto LABEL_195;
          }
          unint64_t v164 = v139 - v163 - 8;
          if (v164 < 0x38)
          {
            uint64_t v166 = *(void *)(v103 + 40);
          }
          else if ((unint64_t)(v139 - (void)v113) < 0x20)
          {
            uint64_t v166 = *(void *)(v103 + 40);
          }
          else
          {
            uint64_t v165 = (v164 >> 3) + 1;
            uint64_t v166 = v139 - 8 * (v165 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v167 = v113 - 2;
            uint64_t v168 = (long long *)(v139 - 16);
            uint64_t v169 = v165 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v170 = *v168;
              *((_OWORD *)v167 - 1) = *(v168 - 1);
              *(_OWORD *)uint64_t v167 = v170;
              v167 -= 4;
              v168 -= 2;
              v169 -= 4;
            }
            while (v169);
            v113 -= v165 & 0x3FFFFFFFFFFFFFFCLL;
            if (v165 == (v165 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_194;
            }
          }
          do
          {
            uint64_t v181 = *(ggl::PipelineSetup **)(v166 - 8);
            v166 -= 8;
            *--std::string::size_type v113 = v181;
          }
          while (v166 != v163);
          goto LABEL_194;
        }
LABEL_594:
        abort();
      }
LABEL_125:
      if (v105) {
        float *v105 = v476;
      }
      uint64_t v129 = v105 + 1;
LABEL_197:
      *(void *)(v103 + 40) = v129;
      *(void *)&long long v518 = v476;
      uint64_t v183 = *(void *)(v103 + 120);
      if (v183)
      {
        (*(void (**)(uint64_t, long long *))(*(void *)v183 + 48))(v183, &v518);
        LODWORD(v184) = **(_DWORD **)(v511 + 392);
        id v185 = v475;
        std::string::size_type v186 = *(uint64_t **)a5;
        uint64_t v187 = *((void *)v476 + 8);
        *(void *)(v187 + 24) = 0;
        uint64_t v188 = *v186;
        *(void *)(v187 + 16) = *v186;
        uint64_t v189 = *((void *)v476 + 20);
        uint64_t v190 = v186[1];
        if (v190) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v190 + 8), 1uLL, memory_order_relaxed);
        }
        int v191 = *(std::__shared_weak_count **)(v189 + 24);
        *(void *)(v189 + 16) = v188;
        *(void *)(v189 + 24) = v190;
        if (v191 && !atomic_fetch_add(&v191->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v191->__on_zero_shared)(v191);
          std::__shared_weak_count::__release_weak(v191);
        }
        uint64_t v192 = *(void *)(*((void *)v476 + 8) + 32);
        long long v518 = 0uLL;
        unint64_t v193 = *(void *)(v192 + 8);
        *(void *)&long long v194 = 0;
        *((void *)&v194 + 1) = v192;
        if (v193) {
          std::string::size_type v195 = *(ggl::PipelineSetup **)(v192 + 72);
        }
        else {
          std::string::size_type v195 = 0;
        }
        long long v513 = v194;
        long long v518 = v194;
        unsigned int v519 = 0;
        uint64_t v520 = v193;
        unsigned int v522 = v195;
        LOWORD(v521) = 1;
        *(void *)std::string::size_type v195 = *(void *)(a5 + 76);
        std::string::pointer v196 = (_DWORD *)[v185 origin];
        *((_DWORD *)v195 + 4) = *v196;
        *((_DWORD *)v195 + 5) = v196[1];
        *((_DWORD *)v195 + 6) = v196[2];
        [v185 size];
        *((_DWORD *)v195 + 8) = v197;
        *((_DWORD *)v195 + 9) = v198;
        *((_DWORD *)v195 + 10) = v199;
        if (v193)
        {
          if ((void)v513 && *(unsigned char *)(*((void *)&v513 + 1) + 17) != 2) {
            (*(void (**)(void))(*(void *)v513 + 64))();
          }
          unint64_t v200 = *(void *)(*((void *)&v513 + 1) + 64);
          if (v200 <= v193) {
            unint64_t v200 = v193;
          }
          *(void *)(*((void *)&v513 + 1) + 56) = 0;
          *(void *)(*((void *)&v513 + 1) + 64) = v200;
        }
        uint64_t v201 = (void *)*((void *)v476 + 8);
        uint64_t v202 = (void *)v201[6];
        unint64_t v203 = v202[1];
        if (v203) {
          uint64_t v204 = (_DWORD *)v202[9];
        }
        else {
          uint64_t v204 = 0;
        }
        v204[92] = *(_DWORD *)(a5 + 56);
        v204[93] = *(_DWORD *)(a5 + 60);
        v204[94] = *(_DWORD *)(a5 + 64);
        v204[89] = LODWORD(v184);
        if (v204 && v203)
        {
          if (v202[8] > v203) {
            unint64_t v203 = v202[8];
          }
          v202[7] = 0;
          v202[8] = v203;
        }
        std::string::size_type v205 = *(void **)(*(void *)(a5 + 40) + 8);
        unint64_t v206 = v205[1];
        if ((v206 & (v206 - 1)) != 0)
        {
          unint64_t v208 = 0x41E8D6E445F4145;
          if (v206 <= 0x41E8D6E445F4145) {
            unint64_t v208 = 0x41E8D6E445F4145 % v206;
          }
          std::string::size_type v207 = *(void **)(*v205 + 8 * v208);
          do
          {
            do
              std::string::size_type v207 = (void *)*v207;
            while (v207[1] != 0x41E8D6E445F4145);
          }
          while (v207[2] != 0x41E8D6E445F4145);
        }
        else
        {
          std::string::size_type v207 = *(void **)(*v205 + 8 * ((v206 - 1) & 0x41E8D6E445F4145));
          do
          {
            do
              std::string::size_type v207 = (void *)*v207;
            while (v207[1] != 0x41E8D6E445F4145);
          }
          while (v207[2] != 0x41E8D6E445F4145);
        }
        size_t v209 = *(uint64_t **)(v207[5] + 32);
        v201[11] = 0;
        uint64_t v210 = *v209;
        v201[10] = *v209;
        uint64_t v211 = *((void *)v476 + 20);
        uint64_t v212 = v209[1];
        if (v212) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v212 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v213 = *(std::__shared_weak_count **)(v211 + 88);
        *(void *)(v211 + 80) = v210;
        *(void *)(v211 + 88) = v212;
        if (v213 && !atomic_fetch_add(&v213->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v213->__on_zero_shared)(v213);
          std::__shared_weak_count::__release_weak(v213);
        }
        uint64_t v214 = *(uint64_t **)(a5 + 8);
        std::string::size_type v215 = (uint64_t *)*((void *)v476 + 8);
        v215[1] = 0;
        uint64_t v216 = *v214;
        uint64_t *v215 = *v214;
        std::string::size_type v217 = (void *)*((void *)v476 + 20);
        uint64_t v218 = v214[1];
        if (v218) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v218 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v219 = (std::__shared_weak_count *)v217[1];
        *std::string::size_type v217 = v216;
        v217[1] = v218;
        if (v219 && !atomic_fetch_add(&v219->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v219->__on_zero_shared)(v219);
          std::__shared_weak_count::__release_weak(v219);
        }

        uint64_t v220 = *((void *)v476 + 8);
        long long v221 = *(void **)(v220 + 48);
        uint64_t v479 = *(void **)(v220 + 64);
        uint64_t v222 = ggl::FragmentedPool<ggl::FoggedDiffuseBuilding::BuildingPipelineSetup>::pop(*(void *)(*(void *)(v511 + 392) + 528));
        uint64_t FoggedExtrusionPipelineSetupForGroup = getFoggedExtrusionPipelineSetupForGroup(v222, v185, a5, **(float **)(v511 + 392));
        double v466 = 0;
        uint64_t v467 = (ggl::PipelineSetup *)FoggedExtrusionPipelineSetupForGroup;
        unint64_t v473 = 0;
        goto LABEL_288;
      }
    }
LABEL_592:
    std::__throw_bad_function_call[abi:nn180100]();
    goto LABEL_595;
  }
  uint64_t v115 = *(void *)(v102 + 520);
  uint64_t v116 = *(void *)(v115 + 8);
  if (v116 == *(void *)v115)
  {
    uint64_t v130 = *(void *)(v115 + 88);
    if (!v130) {
      goto LABEL_592;
    }
    unint64_t v473 = (ggl::PipelineSetup *)(*(uint64_t (**)(uint64_t))(*(void *)v130 + 48))(v130);
    char v117 = *(ggl::PipelineSetup ***)(v115 + 40);
    unint64_t v131 = *(void *)(v115 + 48);
    if ((unint64_t)v117 >= v131)
    {
      uint64_t v148 = *(void *)(v115 + 32);
      uint64_t v149 = ((uint64_t)v117 - v148) >> 3;
      unint64_t v150 = v149 + 1;
      if ((unint64_t)(v149 + 1) >> 61) {
        goto LABEL_594;
      }
      uint64_t v151 = v131 - v148;
      if (v151 >> 2 > v150) {
        unint64_t v150 = v151 >> 2;
      }
      if ((unint64_t)v151 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v152 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v152 = v150;
      }
      if (v152)
      {
        uint64_t v153 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v115 + 56) + 16))(*(void *)(v115 + 56), 8 * v152, 8);
        int v125 = (ggl::PipelineSetup **)(v153 + 8 * v149);
        uint64_t v126 = v153 + 8 * v152;
        if (v153) {
          void *v125 = v473;
        }
      }
      else
      {
        uint64_t v126 = 0;
        int v125 = (ggl::PipelineSetup **)(8 * v149);
      }
      uint64_t v132 = v125 + 1;
      uint64_t v172 = *(void *)(v115 + 32);
      uint64_t v154 = *(void *)(v115 + 40);
      if (v154 == v172) {
        goto LABEL_246;
      }
      unint64_t v173 = v154 - v172 - 8;
      if (v173 < 0x38)
      {
        uint64_t v175 = *(void *)(v115 + 40);
      }
      else if ((unint64_t)(v154 - (void)v125) < 0x20)
      {
        uint64_t v175 = *(void *)(v115 + 40);
      }
      else
      {
        uint64_t v174 = (v173 >> 3) + 1;
        uint64_t v175 = v154 - 8 * (v174 & 0x3FFFFFFFFFFFFFFCLL);
        float v176 = v125 - 2;
        float v177 = (long long *)(v154 - 16);
        uint64_t v178 = v174 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v179 = *v177;
          *((_OWORD *)v176 - 1) = *(v177 - 1);
          *(_OWORD *)float v176 = v179;
          v176 -= 4;
          v177 -= 2;
          v178 -= 4;
        }
        while (v178);
        v125 -= v174 & 0x3FFFFFFFFFFFFFFCLL;
        if (v174 == (v174 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_245;
        }
      }
      do
      {
        uint64_t v224 = *(ggl::PipelineSetup **)(v175 - 8);
        v175 -= 8;
        *--int v125 = v224;
      }
      while (v175 != v172);
      goto LABEL_245;
    }
  }
  else
  {
    unint64_t v473 = *(ggl::PipelineSetup **)(v116 - 8);
    *(void *)(v115 + 8) = v116 - 8;
    char v117 = *(ggl::PipelineSetup ***)(v115 + 40);
    unint64_t v118 = *(void *)(v115 + 48);
    if ((unint64_t)v117 >= v118)
    {
      uint64_t v119 = *(void *)(v115 + 32);
      uint64_t v120 = ((uint64_t)v117 - v119) >> 3;
      unint64_t v121 = v120 + 1;
      if ((unint64_t)(v120 + 1) >> 61) {
        goto LABEL_594;
      }
      uint64_t v122 = v118 - v119;
      if (v122 >> 2 > v121) {
        unint64_t v121 = v122 >> 2;
      }
      if ((unint64_t)v122 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v123 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v123 = v121;
      }
      if (v123)
      {
        uint64_t v124 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v115 + 56) + 16))(*(void *)(v115 + 56), 8 * v123, 8);
        int v125 = (ggl::PipelineSetup **)(v124 + 8 * v120);
        uint64_t v126 = v124 + 8 * v123;
        if (v124) {
          void *v125 = v473;
        }
      }
      else
      {
        uint64_t v126 = 0;
        int v125 = (ggl::PipelineSetup **)(8 * v120);
      }
      uint64_t v132 = v125 + 1;
      uint64_t v155 = *(void *)(v115 + 32);
      uint64_t v154 = *(void *)(v115 + 40);
      if (v154 == v155) {
        goto LABEL_246;
      }
      unint64_t v156 = v154 - v155 - 8;
      if (v156 < 0x38)
      {
        uint64_t v158 = *(void *)(v115 + 40);
      }
      else if ((unint64_t)(v154 - (void)v125) < 0x20)
      {
        uint64_t v158 = *(void *)(v115 + 40);
      }
      else
      {
        uint64_t v157 = (v156 >> 3) + 1;
        uint64_t v158 = v154 - 8 * (v157 & 0x3FFFFFFFFFFFFFFCLL);
        std::string::pointer v159 = v125 - 2;
        uint64_t v160 = (long long *)(v154 - 16);
        uint64_t v161 = v157 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v162 = *v160;
          *((_OWORD *)v159 - 1) = *(v160 - 1);
          *(_OWORD *)std::string::pointer v159 = v162;
          v159 -= 4;
          v160 -= 2;
          v161 -= 4;
        }
        while (v161);
        v125 -= v157 & 0x3FFFFFFFFFFFFFFCLL;
        if (v157 == (v157 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_245;
        }
      }
      do
      {
        uint64_t v180 = *(ggl::PipelineSetup **)(v158 - 8);
        v158 -= 8;
        *--int v125 = v180;
      }
      while (v158 != v155);
LABEL_245:
      uint64_t v154 = *(void *)(v115 + 32);
LABEL_246:
      *(void *)(v115 + 32) = v125;
      *(void *)(v115 + 40) = v132;
      uint64_t v225 = *(void *)(v115 + 48);
      *(void *)(v115 + 48) = v126;
      if (v154) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v115 + 56) + 40))(*(void *)(v115 + 56), v154, v225 - v154);
      }
      goto LABEL_248;
    }
  }
  if (v117) {
    *char v117 = v473;
  }
  uint64_t v132 = v117 + 1;
LABEL_248:
  *(void *)(v115 + 40) = v132;
  *(void *)&long long v518 = v473;
  uint64_t v226 = *(void *)(v115 + 120);
  if (!v226) {
    goto LABEL_592;
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v226 + 48))(v226, &v518);
  LODWORD(v184) = **(_DWORD **)(v511 + 392);
  id v227 = v475;
  id v228 = *(uint64_t **)a5;
  uint64_t v229 = *((void *)v473 + 8);
  *(void *)(v229 + 24) = 0;
  uint64_t v230 = *v228;
  *(void *)(v229 + 16) = *v228;
  uint64_t v231 = *((void *)v473 + 20);
  uint64_t v232 = v228[1];
  if (v232) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v232 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v233 = *(std::__shared_weak_count **)(v231 + 24);
  *(void *)(v231 + 16) = v230;
  *(void *)(v231 + 24) = v232;
  if (v233 && !atomic_fetch_add(&v233->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v233->__on_zero_shared)(v233);
    std::__shared_weak_count::__release_weak(v233);
  }
  uint64_t v234 = *(void *)(*((void *)v473 + 8) + 32);
  long long v518 = 0uLL;
  unint64_t v235 = *(void *)(v234 + 8);
  *(void *)&long long v236 = 0;
  *((void *)&v236 + 1) = v234;
  if (v235) {
    long long v237 = *(ggl::PipelineSetup **)(v234 + 72);
  }
  else {
    long long v237 = 0;
  }
  long long v514 = v236;
  long long v518 = v236;
  unsigned int v519 = 0;
  uint64_t v520 = v235;
  unsigned int v522 = v237;
  LOWORD(v521) = 1;
  *(void *)long long v237 = *(void *)(a5 + 76);
  uint64_t v238 = (_DWORD *)[v227 origin];
  *((_DWORD *)v237 + 4) = *v238;
  *((_DWORD *)v237 + 5) = v238[1];
  *((_DWORD *)v237 + 6) = v238[2];
  [v227 size];
  *((_DWORD *)v237 + 8) = v239;
  *((_DWORD *)v237 + 9) = v240;
  *((_DWORD *)v237 + 10) = v241;
  if (v235)
  {
    if ((void)v514 && *(unsigned char *)(*((void *)&v514 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v514 + 64))();
    }
    unint64_t v242 = *(void *)(*((void *)&v514 + 1) + 64);
    if (v242 <= v235) {
      unint64_t v242 = v235;
    }
    *(void *)(*((void *)&v514 + 1) + 56) = 0;
    *(void *)(*((void *)&v514 + 1) + 64) = v242;
  }
  unint64_t v243 = (void *)*((void *)v473 + 8);
  uint64_t v244 = (void *)v243[6];
  unint64_t v245 = v244[1];
  if (v245) {
    unint64_t v246 = (_DWORD *)v244[9];
  }
  else {
    unint64_t v246 = 0;
  }
  v246[92] = *(_DWORD *)(a5 + 56);
  v246[93] = *(_DWORD *)(a5 + 60);
  v246[94] = *(_DWORD *)(a5 + 64);
  v246[89] = LODWORD(v184);
  if (v246 && v245)
  {
    if (v244[8] > v245) {
      unint64_t v245 = v244[8];
    }
    v244[7] = 0;
    v244[8] = v245;
  }
  int v247 = *(void **)(*(void *)(a5 + 40) + 8);
  unint64_t v248 = v247[1];
  if ((v248 & (v248 - 1)) != 0)
  {
    unint64_t v250 = 0x41E8D6E445F4145;
    if (v248 <= 0x41E8D6E445F4145) {
      unint64_t v250 = 0x41E8D6E445F4145 % v248;
    }
    unint64_t v249 = *(void **)(*v247 + 8 * v250);
    do
    {
      do
        unint64_t v249 = (void *)*v249;
      while (v249[1] != 0x41E8D6E445F4145);
    }
    while (v249[2] != 0x41E8D6E445F4145);
  }
  else
  {
    unint64_t v249 = *(void **)(*v247 + 8 * ((v248 - 1) & 0x41E8D6E445F4145));
    do
    {
      do
        unint64_t v249 = (void *)*v249;
      while (v249[1] != 0x41E8D6E445F4145);
    }
    while (v249[2] != 0x41E8D6E445F4145);
  }
  unint64_t v251 = *(uint64_t **)(v249[5] + 32);
  v243[11] = 0;
  uint64_t v252 = *v251;
  v243[10] = *v251;
  uint64_t v253 = *((void *)v473 + 20);
  uint64_t v254 = v251[1];
  if (v254) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v254 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v255 = *(std::__shared_weak_count **)(v253 + 88);
  *(void *)(v253 + 80) = v252;
  *(void *)(v253 + 88) = v254;
  if (v255 && !atomic_fetch_add(&v255->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v255->__on_zero_shared)(v255);
    std::__shared_weak_count::__release_weak(v255);
  }

  uint64_t v256 = *((void *)v473 + 8);
  long long v221 = *(void **)(v256 + 48);
  uint64_t v479 = *(void **)(v256 + 64);
  uint64_t v257 = ggl::FragmentedPool<ggl::DiffuseBuilding::BuildingPipelineSetup>::pop(*(void *)(*(void *)(v511 + 392)
                                                                                         + 512));
  uint64_t FoggedExtrusionPipelineSetupForGroup = getExtrusionPipelineSetupForGroup(v257, v227, a5, **(float **)(v511 + 392));
  double v466 = (ggl::PipelineSetup *)FoggedExtrusionPipelineSetupForGroup;
  uint64_t v467 = 0;
  char v476 = 0;
LABEL_288:
  uint64_t v258 = *(void *)(FoggedExtrusionPipelineSetupForGroup + 64);
  unint64_t v478 = *(void **)(v258 + 64);
  uint64_t v259 = *(void **)(v258 + 48);
  if (*(unsigned char *)(*(void *)(v511 + 392) + 769))
  {
    uint64_t v260 = [v471 alphaAtlas];
    id v261 = **(id **)(a5 + 40);
    [v261 sizeInPixels];
    double v184 = v262;
    double v6 = v263;

    uint64_t v264 = ggl::FragmentedPool<ggl::PrefilteredLine::PrefilteredLinePipelineSetup>::pop(*(void *)(*(void *)(v511 + 392)
                                                                                                  + 600));
    double v265 = *(uint64_t **)a5;
    uint64_t v266 = *(uint64_t **)(v264 + 64);
    v266[1] = 0;
    uint64_t v267 = *v265;
    *uint64_t v266 = *v265;
    float64_t v268 = *(void **)(v264 + 160);
    uint64_t v269 = v265[1];
    if (v269) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v269 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v270 = (std::__shared_weak_count *)v268[1];
    *float64_t v268 = v267;
    v268[1] = v269;
    if (v270 && !atomic_fetch_add(&v270->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v270->__on_zero_shared)(v270);
      std::__shared_weak_count::__release_weak(v270);
    }
    uint64_t v271 = *(uint64_t **)(a5 + 8);
    uint64_t v272 = *(void *)(v264 + 64);
    *(void *)(v272 + 40) = 0;
    uint64_t v273 = *v271;
    *(void *)(v272 + 32) = *v271;
    uint64_t v274 = *(void *)(v264 + 160);
    uint64_t v275 = v271[1];
    if (v275) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v275 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v276 = *(std::__shared_weak_count **)(v274 + 40);
    *(void *)(v274 + 32) = v273;
    *(void *)(v274 + 40) = v275;
    if (v276 && !atomic_fetch_add(&v276->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v276->__on_zero_shared)(v276);
      std::__shared_weak_count::__release_weak(v276);
    }
    **(void **)(v264 + 96) = *(void *)(v260 + 24);
    float v279 = *(void **)(*(void *)(v264 + 64) + 16);
    long long v518 = 0uLL;
    unint64_t v280 = v279[1];
    *(void *)&long long v281 = 0;
    *((void *)&v281 + 1) = v279;
    uint64_t v282 = v264;
    if (v280) {
      uint64_t v283 = v279[9];
    }
    else {
      uint64_t v283 = 0;
    }
    long long v515 = v281;
    long long v518 = v281;
    unsigned int v519 = 0;
    uint64_t v520 = v280;
    unsigned int v522 = (ggl::PipelineSetup *)v283;
    LOWORD(v521) = 1;
    float v277 = v184;
    *(float *)(v283 + 288) = v277;
    float v278 = v6;
    *(float *)(v283 + 292) = v278;
    *(_DWORD *)(v283 + 336) = *(_DWORD *)(a5 + 80);
    *(void *)uint64_t v283 = 0;
    *(void *)(v283 + 8) = 0;
    uint64_t v284 = (_DWORD *)[v475 origin];
    *(_DWORD *)(v283 + 304) = *v284;
    *(_DWORD *)(v283 + 308) = v284[1];
    *(_DWORD *)(v283 + 312) = v284[2];
    [v475 size];
    uint64_t v508 = v279;
    *(_DWORD *)(v283 + 320) = v285;
    *(_DWORD *)(v283 + 324) = v286;
    *(_DWORD *)(v283 + 328) = v287;
    *(float *)(v283 + 340) = v505;
    if (v280)
    {
      if ((void)v515 && *(unsigned char *)(*((void *)&v515 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v515 + 64))();
      }
      unint64_t v288 = *(void *)(*((void *)&v515 + 1) + 64);
      if (v288 <= v280) {
        unint64_t v288 = v280;
      }
      *(void *)(*((void *)&v515 + 1) + 56) = 0;
      *(void *)(*((void *)&v515 + 1) + 64) = v288;
    }
  }
  else
  {
    uint64_t v282 = 0;
    uint64_t v508 = 0;
  }
  uint64_t v465 = v282;
  unint64_t v289 = *(uint64_t ***)(a5 + 16);
  double v290 = *v289;
  unsigned int v516 = v289[1];
  uint64_t v510 = v99;
  uint64_t v506 = v100;
  if (*v289 != v516)
  {
    uint64_t v507 = 0;
    unsigned __int8 v291 = 0;
    float v12 = 1.0;
    float32x2_t v474 = (float32x2_t)vdup_n_s32(0x37800080u);
    while (1)
    {
      uint64_t v295 = *v290;
      *(void *)&long long v529 = *v290;
      unsigned __int8 v296 = (std::__shared_weak_count *)v290[1];
      *((void *)&v529 + 1) = v296;
      if (v296) {
        atomic_fetch_add_explicit(&v296->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)&v518, v295, (uint64_t)v296);
      if (v296 && !atomic_fetch_add(&v296->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v296->__on_zero_shared)(v296);
        std::__shared_weak_count::__release_weak(v296);
        if (!(_BYTE)v521) {
          break;
        }
      }
      else if (!(_BYTE)v521)
      {
        break;
      }
      uint64_t v297 = *(void *)(v518 + 24);
      unsigned int v298 = (int)*(float *)(a5 + 88) >= 0x17 ? 23 : (int)*(float *)(a5 + 88);
      if ((uint64_t v299 = *(_DWORD **)v297) != 0
        && (LODWORD(v184) = *v299, LODWORD(v299) = *(float *)v299 == v12, *(unsigned char *)(v297 + 10))
        && (*(float *)&v184 != 0.0 ? (BOOL v300 = *(float *)&v184 == v12) : (BOOL v300 = 1), !v300)
        || (int v301 = *(unsigned __int8 *)(v297 + v299 + 11), LODWORD(v184) = 0, v301 == 2))
      {
        LOBYTE(v529) = 1;
        LOBYTE(v534[0]) = 1;
        char v302 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v297, 0x5Bu, v298, 0, &v529);
        char v303 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v297, 0x5Bu, v298, 1, v534);
        if (*(float *)&v184 < v12) {
          char v303 = v302;
        }
      }
      else
      {
        char v303 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(v518 + 24), 0x5Bu, v298, v301, 0);
      }
      if (!v303) {
        break;
      }
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v304 = 23;
      }
      else {
        unsigned int v304 = (int)*(float *)(a5 + 88);
      }
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v529, *(void *)(v518 + 24), 0xA1u, v304, 2u, 0);
      LOWORD(v8) = WORD1(v529);
      LOWORD(v7) = v529;
      LOWORD(v9) = WORD3(v529);
      LOWORD(v10) = WORD2(v529);
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v305 = 23;
      }
      else {
        unsigned int v305 = (int)*(float *)(a5 + 88);
      }
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v529, *(void *)(v518 + 24), 0xA0u, v305, 2u, 0);
      LOWORD(v184) = WORD1(v529);
      LOWORD(v12) = v529;
      LOWORD(v6) = WORD3(v529);
      LOWORD(v11) = WORD2(v529);
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v306 = 23;
      }
      else {
        unsigned int v306 = (int)*(float *)(a5 + 88);
      }
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v529, *(void *)(v518 + 24), 0xA3u, v306, 2u, 0);
      unsigned int v499 = LODWORD(v12);
      unsigned int v502 = LODWORD(v184);
      LOWORD(v307) = v529;
      unsigned int v491 = v307;
      LOWORD(v307) = WORD1(v529);
      unsigned int v493 = v307;
      LOWORD(v307) = WORD2(v529);
      unsigned int v495 = v307;
      LOWORD(v307) = WORD3(v529);
      unsigned int v497 = v307;
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v308 = 23;
      }
      else {
        unsigned int v308 = (int)*(float *)(a5 + 88);
      }
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v529, *(void *)(v518 + 24), 3u, v308, 2u, 0);
      unsigned int v309 = (unsigned __int16)v529;
      unsigned int v487 = WORD1(v529);
      LOWORD(v184) = WORD3(v529);
      LOWORD(v12) = WORD2(v529);
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v310 = 23;
      }
      else {
        unsigned int v310 = (int)*(float *)(a5 + 88);
      }
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v529, *(void *)(v518 + 24), 0x5Du, v310, 2u, 0);
      unsigned int v483 = LODWORD(v12);
      unsigned int v485 = LODWORD(v184);
      v480.i32[0] = (unsigned __int16)v529;
      v480.i32[1] = WORD1(v529);
      LOWORD(v311) = WORD2(v529);
      unsigned int v482 = v311;
      float v312 = *(float *)(a5 + 88);
      unsigned int v313 = (int)v312;
      LOWORD(v312) = WORD3(v529);
      unsigned int v481 = LODWORD(v312);
      uint64_t v314 = *(void *)(v518 + 24);
      if (v313 >= 0x17) {
        unsigned int v315 = 23;
      }
      else {
        unsigned int v315 = v313;
      }
      unsigned int v316 = *(float **)v314;
      if (*(void *)v314
        && (float v317 = *v316, LODWORD(v316) = *v316 == 1.0, *(unsigned char *)(v314 + 10))
        && v317 != 0.0
        && v317 != 1.0
        || (unsigned int v318 = *(unsigned __int8 *)(v314 + v316 + 11), v317 = 0.0, v318 == 2))
      {
        LOBYTE(v529) = 1;
        LOBYTE(v534[0]) = 1;
        LODWORD(v184) = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v314, 0x14Au, v315, 0, &v529);
        float v319 = *(float *)&v184
             + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v314, 0x14Au, v315, 1u, v534)- *(float *)&v184)* v317);
      }
      else
      {
        float v319 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v518 + 24), 0x14Au, v315, v318, 0);
      }
      uint64_t v329 = *(void *)(v518 + 24);
      if ((int)*(float *)(a5 + 88) >= 0x17) {
        unsigned int v330 = 23;
      }
      else {
        unsigned int v330 = (int)*(float *)(a5 + 88);
      }
      uint64_t v331 = *(float **)v329;
      float v489 = v319;
      if (*(void *)v329
        && (float v332 = *v331, LODWORD(v331) = *v331 == 1.0, *(unsigned char *)(v329 + 10))
        && v332 != 0.0
        && v332 != 1.0
        || (v333 = *(unsigned __int8 *)(v329 + v331 + 11), float v332 = 0.0, v333 == 2))
      {
        LOBYTE(v529) = 1;
        LOBYTE(v534[0]) = 1;
        LODWORD(v184) = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v329, 0x14Bu, v330, 0, &v529);
        float v334 = *(float *)&v184
             + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v329, 0x14Bu, v330, 1u, v534)- *(float *)&v184)* v332);
      }
      else
      {
        float v334 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v329, 0x14Bu, v330, v333, 0);
      }
      float v12 = 1.0;
      float v335 = (float)v491 * 0.000015259;
      float v336 = (float)v493 * 0.000015259;
      float v337 = (float)v495 * 0.000015259;
      float v338 = (float)v497 * 0.000015259;
      float v339 = *(float *)(a5 + 84);
      float v340 = *(float *)(a5 + 76);
      float v341 = *(float *)(a5 + 92);
      float v342 = (float)(v335 + (float)(v340 * (float)((float)((float)v499 * 0.000015259) - v335))) * v341;
      float v343 = (float)(v336 + (float)(v340 * (float)((float)((float)v502 * 0.000015259) - v336))) * v341;
      float v344 = (float)(v337 + (float)(v340 * (float)((float)((float)v11 * 0.000015259) - v337))) * v341;
      float v345 = (float)(v338 + (float)(v340 * (float)((float)((float)LODWORD(v6) * 0.000015259) - v338)))
           * (float)(v341 * *(float *)(a5 + 72));
      BOOL v346 = v345 < 0.9999;
      unint64_t v347 = v221[1];
      if (v347)
      {
        uint64_t v348 = v221[9];
        uint64_t v349 = v291;
        float v350 = (float *)(v348 + 16 * v291);
        *float v350 = v342;
        v350[1] = v343;
        v350[2] = v344;
        v350[3] = v345;
        if (v348)
        {
          if (v221[8] > v347) {
            unint64_t v347 = v221[8];
          }
          v221[7] = 0;
          v221[8] = v347;
        }
      }
      else
      {
        uint64_t v349 = v291;
        unsigned int v351 = (float *)(16 * v291);
        *unsigned int v351 = v342;
        v351[1] = v343;
        v351[2] = v344;
        v351[3] = v345;
      }
      float v352 = *(float *)(a5 + 76);
      float v353 = v338 + (float)(v352 * (float)((float)((float)v9 * 0.000015259) - v338));
      float v354 = *(float *)(a5 + 92);
      float v355 = (float)(v335 + (float)(v352 * (float)((float)((float)LODWORD(v7) * 0.000015259) - v335))) * v354;
      float v356 = (float)(v336 + (float)(v352 * (float)((float)((float)LODWORD(v8) * 0.000015259) - v336))) * v354;
      float v357 = (float)(v337 + (float)(v352 * (float)((float)((float)v10 * 0.000015259) - v337))) * v354;
      float v358 = v353 * (float)(v354 * *(float *)(a5 + 72));
      unint64_t v359 = v259[1];
      if (v359)
      {
        uint64_t v360 = v259[9];
        float v361 = (float *)(v360 + 16 * v349);
        *float v361 = v355;
        v361[1] = v356;
        v361[2] = v357;
        v361[3] = v358;
        if (v360)
        {
          if (v259[8] > v359) {
            unint64_t v359 = v259[8];
          }
          v259[7] = 0;
          v259[8] = v359;
        }
      }
      else
      {
        float v362 = (float *)(16 * v349);
        *float v362 = v355;
        v362[1] = v356;
        v362[2] = v357;
        v362[3] = v358;
      }
      float v363 = v489 * 40075017.0 / ((double)(unint64_t)(1 << (int)v339) * v334);
      LOBYTE(v507) = v507 | v346;
      BYTE4(v507) |= v358 < 0.9999;
      unint64_t v364 = v479[1];
      uint64_t v365 = (float *)(v479[9] + 8 * v349);
      *uint64_t v365 = v363;
      v365[1] = 1.0 - v489;
      if (v479[8] > v364) {
        unint64_t v364 = v479[8];
      }
      v479[7] = 0;
      v479[8] = v364;
      unint64_t v366 = v478[1];
      float v367 = (float *)(v478[9] + 8 * v349);
      *float v367 = v363;
      v367[1] = 1.0 - v489;
      if (v478[8] > v366) {
        unint64_t v366 = v478[8];
      }
      v478[7] = 0;
      v478[8] = v366;
      if (!*(unsigned char *)(*(void *)(v511 + 392) + 769)) {
        goto LABEL_432;
      }
      float v503 = *(float *)(a5 + 92);
      LODWORD(v184) = *(_DWORD *)(a5 + 72);
      float v500 = *(float *)(a5 + 76);
      uint64_t v368 = *(void *)(v518 + 24);
      unsigned int v369 = (int)*(float *)(a5 + 88) >= 0x17 ? 23 : (int)*(float *)(a5 + 88);
      if ((double v370 = *(float **)v368) != 0
        && (float v371 = *v370, LODWORD(v370) = *v370 == 1.0, *(unsigned char *)(v368 + 10))
        && v371 != 0.0
        && v371 != 1.0
        || (v372 = *(unsigned __int8 *)(v368 + v370 + 11), float v371 = 0.0, v372 == 2))
      {
        LOBYTE(v529) = 1;
        LOBYTE(v534[0]) = 1;
        float v373 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v368, 2u, v369, 0, &v529);
        *(float *)&double v6 = v373
                      + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v368, 2u, v369, 1u, v534)- v373)* v371);
      }
      else
      {
        LODWORD(v6) = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v518 + 24), 2u, v369, v372, 0);
      }
      uint64_t v374 = *(void *)(v518 + 24);
      unsigned int v375 = (int)*(float *)(a5 + 88) >= 0x17 ? 23 : (int)*(float *)(a5 + 88);
      if ((float v376 = *(float **)v374) != 0
        && (float v7 = *v376, LODWORD(v376) = *v376 == 1.0, *(unsigned char *)(v374 + 10))
        && v7 != 0.0
        && v7 != 1.0
        || (v377 = *(unsigned __int8 *)(v374 + v376 + 11), float v7 = 0.0, v377 == 2))
      {
        LOBYTE(v529) = 1;
        LOBYTE(v534[0]) = 1;
        float v8 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v374, 0x61u, v375, 0, &v529);
        float v378 = v8
             + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v374, 0x61u, v375, 1u, v534)- v8)* v7);
      }
      else
      {
        float v378 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v518 + 24), 0x61u, v375, v377, 0);
      }
      unint64_t v379 = v508[1];
      uint64_t v380 = v379 ? v508[9] : 0;
      float32x2_t v381 = vmul_f32(vcvt_f32_u32(v480), v474);
      *(float *)(v380 + 4 * v349 + 256) = (float)(v378 * 0.5)
                                        + (float)(*(float *)(a5 + 76) * (float)(*(float *)&v6 - v378));
      float v382 = (float32x2_t *)(v380 + 16 * v349);
      v382[16] = vmul_n_f32(vmla_n_f32(v381, vsub_f32(vmul_f32(vcvt_f32_u32((uint32x2_t)__PAIR64__(v487, v309)), v474), v381), v500), v503);
      v382[17].f32[0] = (float)((float)((float)v482 * 0.000015259)
                              + (float)(v500
                                      * (float)((float)((float)v483 * 0.000015259) - (float)((float)v482 * 0.000015259))))
                      * v503;
      v382[17].f32[1] = (float)((float)((float)v481 * 0.000015259)
                              + (float)(v500
                                      * (float)((float)((float)v485 * 0.000015259) - (float)((float)v481 * 0.000015259))))
                      * (float)(v503 * *(float *)&v184);
      if (v380)
      {
        uint64_t v100 = v506;
        if (v379)
        {
          if (v508[8] > v379) {
            unint64_t v379 = v508[8];
          }
          v508[7] = 0;
          v508[8] = v379;
        }
      }
      else
      {
LABEL_432:
        uint64_t v100 = v506;
      }
LABEL_316:
      ++v291;
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v518);
      v290 += 2;
      if (v290 == v516) {
        goto LABEL_434;
      }
    }
    unint64_t v320 = v221[1];
    if (v320)
    {
      uint64_t v321 = v291;
      uint64_t v322 = (void *)(v221[9] + 16 * v291);
      void *v322 = 0;
      v322[1] = 0;
      if (v221[8] > v320) {
        unint64_t v320 = v221[8];
      }
      v221[7] = 0;
      v221[8] = v320;
      unint64_t v323 = v259[1];
      if (v323) {
        goto LABEL_368;
      }
    }
    else
    {
      uint64_t v321 = v291;
      float v325 = (void *)(16 * v291);
      void *v325 = 0;
      v325[1] = 0;
      unint64_t v323 = v259[1];
      if (v323)
      {
LABEL_368:
        unsigned int v324 = (void *)(v259[9] + 16 * v321);
        void *v324 = 0;
        v324[1] = 0;
        if (v259[8] > v323) {
          unint64_t v323 = v259[8];
        }
        v259[7] = 0;
        v259[8] = v323;
        goto LABEL_373;
      }
    }
    float v326 = (void *)(16 * v321);
    void *v326 = 0;
    v326[1] = 0;
LABEL_373:
    if (*(unsigned char *)(*(void *)(v511 + 392) + 769))
    {
      unint64_t v327 = v508[1];
      if (v327)
      {
        uint64_t v292 = v508[9];
        *(_DWORD *)(v292 + 4 * v321 + 256) = 0;
        uint64_t v293 = v292 + 16 * v321;
        *(void *)(v293 + 128) = 0;
        *(void *)(v293 + 136) = 0;
        unint64_t v294 = v508[8];
        if (v294 <= v327) {
          unint64_t v294 = v327;
        }
        v508[7] = 0;
        v508[8] = v294;
      }
      else
      {
        uint64_t v328 = 16 * v321;
        *(void *)(v328 + 128) = 0;
        *(void *)(v328 + 136) = 0;
      }
    }
    uint64_t v507 = 0x100000001;
    goto LABEL_316;
  }
  uint64_t v507 = 0;
LABEL_434:
  unsigned int v517 = (float *)a5;
  float v383 = *(uint64_t ***)(a5 + 24);
  unint64_t v384 = *v383;
  double v504 = v383[1];
  if (*v383 != v504)
  {
    char v509 = 0;
    unsigned __int8 v385 = 0;
    *(void *)&long long v386 = 0;
    *(void *)&long long v387 = 0;
    *((void *)&v387 + 1) = v100;
    *((void *)&v386 + 1) = v99;
    long long v498 = v387;
    long long v501 = v386;
    float v388 = 1.0;
    while (1)
    {
      uint64_t v390 = *v384;
      *(void *)&long long v518 = *v384;
      double v391 = (std::__shared_weak_count *)v384[1];
      *((void *)&v518 + 1) = v391;
      if (v391) {
        atomic_fetch_add_explicit(&v391->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v534, v390, (uint64_t)v391);
      if (v391 && !atomic_fetch_add(&v391->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v391->__on_zero_shared)(v391);
        std::__shared_weak_count::__release_weak(v391);
        int v392 = v535;
        if (!v535)
        {
LABEL_462:
          unint64_t v397 = v517;
          goto LABEL_465;
        }
      }
      else
      {
        int v392 = v535;
        if (!v535) {
          goto LABEL_462;
        }
      }
      uint64_t v393 = *(void *)(v534[0] + 24);
      if ((int)v517[22] >= 0x17) {
        unsigned int v394 = 23;
      }
      else {
        unsigned int v394 = (int)v517[22];
      }
      uint64_t v395 = *(_DWORD **)v393;
      if (*(void *)v393 && (LODWORD(v184) = *v395, LODWORD(v395) = *(float *)v395 == v388, *(unsigned char *)(v393 + 10)))
      {
        BOOL v396 = *(float *)&v184 == 0.0 || *(float *)&v184 == v388;
        unint64_t v397 = v517;
        if (!v396)
        {
LABEL_458:
          LOBYTE(v518) = 1;
          LOBYTE(v529) = 1;
          char v399 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v393, 0x5Bu, v394, 0, &v518);
          char v400 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v393, 0x5Bu, v394, 1, &v529);
          if (*(float *)&v184 < v388) {
            char v400 = v399;
          }
          goto LABEL_464;
        }
      }
      else
      {
        unint64_t v397 = v517;
      }
      int v398 = *(unsigned __int8 *)(v393 + v395 + 11);
      LODWORD(v184) = 0;
      if (v398 == 2) {
        goto LABEL_458;
      }
      char v400 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(v534[0] + 24), 0x5Bu, v394, v398, 0);
LABEL_464:
      int v392 = v400 != 0;
LABEL_465:
      long long v518 = 0uLL;
      unint64_t v401 = *(void *)(v100 + 8);
      if (v401) {
        float32x2_t v402 = *(ggl::PipelineSetup **)(v100 + 72);
      }
      else {
        float32x2_t v402 = 0;
      }
      long long v518 = v498;
      unsigned int v519 = 0;
      uint64_t v520 = v401;
      unsigned int v522 = v402;
      LOWORD(v521) = 1;
      long long v529 = 0uLL;
      uint64_t v403 = v99;
      unint64_t v404 = *(void *)(v99 + 8);
      if (v404) {
        uint64_t v405 = *(void *)(v403 + 72);
      }
      else {
        uint64_t v405 = 0;
      }
      long long v529 = v501;
      uint64_t v530 = 0;
      unint64_t v531 = v404;
      uint64_t v533 = v405;
      __int16 v532 = 1;
      if (v392)
      {
        if ((int)v397[22] >= 0x17) {
          unsigned int v406 = 23;
        }
        else {
          unsigned int v406 = (int)v397[22];
        }
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>(&v536, *(void *)(v534[0] + 24), 0xA0u, v406, 2u, 0);
        LOWORD(v407) = WORD1(v536);
        LOWORD(v10) = v536;
        unsigned int v496 = v407;
        LOWORD(v8) = HIWORD(v536);
        LOWORD(v7) = WORD2(v536);
        if ((int)v397[22] >= 0x17) {
          unsigned int v408 = 23;
        }
        else {
          unsigned int v408 = (int)v397[22];
        }
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>(&v536, *(void *)(v534[0] + 24), 0xA1u, v408, 2u, 0);
        LOWORD(v184) = WORD1(v536);
        LOWORD(v6) = v536;
        LOWORD(v11) = HIWORD(v536);
        LOWORD(v12) = WORD2(v536);
        if ((int)v397[22] >= 0x17) {
          unsigned int v409 = 23;
        }
        else {
          unsigned int v409 = (int)v397[22];
        }
        gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>(&v536, *(void *)(v534[0] + 24), 0xA3u, v409, 2u, 0);
        LOWORD(v410) = v536;
        unsigned int v484 = v410;
        LOWORD(v410) = WORD1(v536);
        unsigned int v488 = v410;
        LOWORD(v410) = WORD2(v536);
        unsigned int v490 = v410;
        unsigned int v492 = LODWORD(v7);
        float v411 = v397[22];
        unsigned int v412 = (int)v411;
        LOWORD(v411) = HIWORD(v536);
        unsigned int v486 = LODWORD(v411);
        uint64_t v413 = *(void *)(v534[0] + 24);
        if (v412 >= 0x17) {
          unsigned int v414 = 23;
        }
        else {
          unsigned int v414 = v412;
        }
        unsigned int v415 = *(float **)v413;
        unsigned int v494 = LODWORD(v8);
        if (*(void *)v413
          && (float v416 = *v415, LODWORD(v415) = *v415 == v388, *(unsigned char *)(v413 + 10))
          && v416 != 0.0
          && v416 != v388
          || (v417 = *(unsigned __int8 *)(v413 + v415 + 11), float v416 = 0.0, v417 == 2))
        {
          LOBYTE(v536) = 1;
          char v537 = 1;
          float v418 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v413, 0x14Au, v414, 0, &v536);
          float v7 = v418
             + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v413, 0x14Au, v414, 1u, &v537)- v418)* v416);
        }
        else
        {
          float v7 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v413, 0x14Au, v414, v417, 0);
        }
        uint64_t v420 = *(void *)(v534[0] + 24);
        if ((int)v517[22] >= 0x17) {
          unsigned int v421 = 23;
        }
        else {
          unsigned int v421 = (int)v517[22];
        }
        char v422 = *(float **)v420;
        if (!*(void *)v420 || (float v8 = *v422, LODWORD(v422) = *v422 == v388, !*(unsigned char *)(v420 + 10)))
        {
          unint64_t v423 = v517;
          goto LABEL_501;
        }
        unint64_t v423 = v517;
        if (v8 == 0.0 || v8 == v388)
        {
LABEL_501:
          unsigned int v424 = *(unsigned __int8 *)(v420 + v422 + 11);
          float v8 = 0.0;
          if (v424 == 2) {
            goto LABEL_502;
          }
          float v426 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v534[0] + 24), 0x14Bu, v421, v424, 0);
        }
        else
        {
LABEL_502:
          LOBYTE(v536) = 1;
          char v537 = 1;
          float v425 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v420, 0x14Bu, v421, 0, &v536);
          float v426 = v425
               + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v420, 0x14Bu, v421, 1u, &v537)- v425)* v8);
        }
        float v427 = (float)v484 * 0.000015259;
        float v428 = (float)v488 * 0.000015259;
        float v429 = (float)v490 * 0.000015259;
        float v430 = (float)v486 * 0.000015259;
        float v431 = v7 * 40075017.0 / ((double)(unint64_t)(1 << (int)v423[21]) * v426);
        float v388 = 1.0;
        float v432 = v423[19];
        float v433 = v423[23];
        float v434 = v423[18] * v433;
        float v435 = v434 * (float)(v430 + (float)(v432 * (float)((float)((float)v494 * 0.000015259) - v430)));
        float v436 = v434 * (float)(v430 + (float)(v432 * (float)((float)((float)v11 * 0.000015259) - v430)));
        unsigned int v437 = (float *)(v405 + 16 * v385);
        *unsigned int v437 = (float)(v427 + (float)(v432 * (float)((float)((float)v10 * 0.000015259) - v427))) * v433;
        v437[1] = (float)(v428 + (float)(v432 * (float)((float)((float)v496 * 0.000015259) - v428))) * v433;
        v437[2] = (float)(v429 + (float)(v432 * (float)((float)((float)v492 * 0.000015259) - v429))) * v433;
        v437[3] = v435;
        v437[32] = (float)(v427 + (float)(v432 * (float)((float)((float)LODWORD(v6) * 0.000015259) - v427))) * v433;
        v437[33] = (float)(v428 + (float)(v432 * (float)((float)((float)LODWORD(v184) * 0.000015259) - v428))) * v433;
        v437[34] = (float)(v429 + (float)(v432 * (float)((float)((float)LODWORD(v12) * 0.000015259) - v429))) * v433;
        v437[35] = v436;
        unsigned int v438 = (float *)((char *)v402 + 8 * v385);
        *unsigned int v438 = v431;
        v438[1] = 1.0 - v7;
        BOOL v439 = v435 < 0.9999;
        if (v436 < 0.9999) {
          BOOL v439 = 1;
        }
        v509 |= v439;
        goto LABEL_507;
      }
      uint64_t v419 = (void *)(v405 + 16 * v385);
      *uint64_t v419 = 0;
      v419[1] = 0;
      v419[16] = 0;
      v419[17] = 0;
      char v509 = 1;
LABEL_507:
      *(float *)(v405 + 384) = v505;
      if (v404)
      {
        unint64_t v440 = *(void *)(v510 + 64);
        if (v440 <= v404) {
          unint64_t v440 = v404;
        }
        *(void *)(v510 + 56) = 0;
        *(void *)(v510 + 64) = v440;
      }
      uint64_t v100 = v506;
      if (v402 && v401)
      {
        unint64_t v389 = *(void *)(v506 + 64);
        if (v389 <= v401) {
          unint64_t v389 = v401;
        }
        *(void *)(v506 + 56) = 0;
        *(void *)(v506 + 64) = v389;
      }
      ++v385;
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v534);
      v384 += 2;
      uint64_t v99 = v510;
      if (v384 == v504) {
        goto LABEL_515;
      }
    }
  }
  char v509 = 0;
LABEL_515:
  if (v507)
  {
    uint64_t v441 = v472;
    unsigned int v442 = v473;
    uint64_t v443 = v476;
    v445 = v466;
    unsigned int v444 = v467;
    char v446 = BYTE4(v507);
    char v447 = v509;
    float v448 = v517;
    if (v473) {
      ggl::Flyover::FlyoverPipelineSetup::setState(v473, *(void *)(*(void *)(v511 + 392) + 296), *(std::__shared_weak_count **)(*(void *)(v511 + 392) + 304));
    }
    if (!v476) {
      goto LABEL_539;
    }
    uint64_t v450 = *(void *)(*(void *)(v511 + 392) + 328);
    uint64_t v449 = *(std::__shared_weak_count **)(*(void *)(v511 + 392) + 336);
    if (!v449) {
      goto LABEL_526;
    }
LABEL_525:
    atomic_fetch_add_explicit(&v449->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_526;
  }
  uint64_t v441 = v472;
  unsigned int v442 = v473;
  uint64_t v443 = v476;
  v445 = v466;
  unsigned int v444 = v467;
  char v446 = BYTE4(v507);
  char v447 = v509;
  float v448 = v517;
  if (v473) {
    ggl::Flyover::FlyoverPipelineSetup::setState(v473, *(void *)(*(void *)(v511 + 392) + 136), *(std::__shared_weak_count **)(*(void *)(v511 + 392) + 144));
  }
  if (!v476) {
    goto LABEL_539;
  }
  uint64_t v450 = *(void *)(*(void *)(v511 + 392) + 168);
  uint64_t v449 = *(std::__shared_weak_count **)(*(void *)(v511 + 392) + 176);
  if (v449) {
    goto LABEL_525;
  }
LABEL_526:
  if (!v450 || **(void **)(v450 + 40) != *((void *)v443 + 1))
  {
    double v451 = (std::__shared_weak_count *)*((void *)v443 + 3);
    *((void *)v443 + 2) = 0;
    *((void *)v443 + 3) = 0;
    uint64_t v441 = v472;
    if (!v451) {
      goto LABEL_537;
    }
    goto LABEL_536;
  }
  uint64_t v452 = *((void *)v443 + 2);
  if (v452 && v452 != v450) {
    ggl::PipelineSetup::resetData((uint64_t)v443);
  }
  if (v449) {
    atomic_fetch_add_explicit(&v449->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  double v451 = (std::__shared_weak_count *)*((void *)v443 + 3);
  *((void *)v443 + 2) = v450;
  *((void *)v443 + 3) = v449;
  uint64_t v441 = v472;
  if (v451)
  {
LABEL_536:
    if (atomic_fetch_add(&v451->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_537;
    }
    ((void (*)(std::__shared_weak_count *))v451->__on_zero_shared)(v451);
    std::__shared_weak_count::__release_weak(v451);
    if (v449) {
      goto LABEL_538;
    }
LABEL_539:
    if (v446) {
      goto LABEL_540;
    }
    goto LABEL_547;
  }
LABEL_537:
  if (!v449) {
    goto LABEL_539;
  }
LABEL_538:
  if (atomic_fetch_add(&v449->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_539;
  }
  ((void (*)(std::__shared_weak_count *))v449->__on_zero_shared)(v449);
  std::__shared_weak_count::__release_weak(v449);
  if (v446)
  {
LABEL_540:
    if (v445) {
      ggl::Flyover::FlyoverPipelineSetup::setState(v445, *(void *)(*(void *)(v511 + 392) + 280), *(std::__shared_weak_count **)(*(void *)(v511 + 392) + 288));
    }
    if (v444)
    {
      uint64_t v453 = *(void *)(v511 + 392) + 312;
LABEL_551:
      ggl::Flyover::FlyoverPipelineSetup::setState(v444, *(void *)v453, *(std::__shared_weak_count **)(v453 + 8));
      goto LABEL_552;
    }
    goto LABEL_552;
  }
LABEL_547:
  if (v445) {
    ggl::Flyover::FlyoverPipelineSetup::setState(v445, *(void *)(*(void *)(v511 + 392) + 120), *(std::__shared_weak_count **)(*(void *)(v511 + 392) + 128));
  }
  if (v444)
  {
    uint64_t v453 = *(void *)(v511 + 392) + 152;
    goto LABEL_551;
  }
LABEL_552:
  float v454 = *(void **)(v511 + 392);
  if (v447)
  {
    if (!v477) {
      goto LABEL_575;
    }
    uint64_t v456 = v454[43];
    float v455 = (std::__shared_weak_count *)v454[44];
    if (!v455) {
      goto LABEL_559;
    }
LABEL_558:
    atomic_fetch_add_explicit(&v455->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_559;
  }
  if (!v477) {
    goto LABEL_575;
  }
  uint64_t v456 = v454[23];
  float v455 = (std::__shared_weak_count *)v454[24];
  if (v455) {
    goto LABEL_558;
  }
LABEL_559:
  if (v456 && **(void **)(v456 + 40) == *((void *)v477 + 1))
  {
    uint64_t v458 = *((void *)v477 + 2);
    if (v458 && v458 != v456) {
      ggl::PipelineSetup::resetData((uint64_t)v477);
    }
    if (v455) {
      atomic_fetch_add_explicit(&v455->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    float v457 = (std::__shared_weak_count *)*((void *)v477 + 3);
    *((void *)v477 + 2) = v456;
    *((void *)v477 + 3) = v455;
    uint64_t v441 = v472;
    if (!v457) {
      goto LABEL_571;
    }
    goto LABEL_569;
  }
  float v457 = (std::__shared_weak_count *)*((void *)v477 + 3);
  *((void *)v477 + 2) = 0;
  *((void *)v477 + 3) = 0;
  uint64_t v441 = v472;
  if (v457)
  {
LABEL_569:
    if (!atomic_fetch_add(&v457->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v457->__on_zero_shared)(v457);
      std::__shared_weak_count::__release_weak(v457);
    }
  }
LABEL_571:
  if (v455 && !atomic_fetch_add(&v455->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v455->__on_zero_shared)(v455);
    std::__shared_weak_count::__release_weak(v455);
  }
  float v454 = *(void **)(v511 + 392);
LABEL_575:
  *(void *)&long long v518 = v469;
  *((void *)&v518 + 1) = v442;
  unsigned int v519 = v443;
  uint64_t v520 = v441;
  unsigned int v521 = v445;
  unsigned int v522 = v444;
  uint64_t v523 = PointyRoofDepthPipelineSetupForGroup;
  unsigned int v524 = v477;
  uint64_t v525 = v465;
  int32x2_t v526 = vrev64_s32(*(int32x2_t *)(v448 + 24));
  uint64_t v527 = *((void *)v448 + 6);
  BOOL v528 = v448[17] > 0.5;
  uint64_t v459 = a6[3];
  if (v459)
  {
    float v460 = v475;
    if ((void *)v459 == a6)
    {
      double v539 = v538;
      (*(void (**)(void *, void *))(*a6 + 24))(a6, v538);
      goto LABEL_581;
    }
    uint64_t v459 = (*(uint64_t (**)(uint64_t))(*(void *)v459 + 16))(v459);
  }
  else
  {
    float v460 = v475;
  }
  double v539 = (void *)v459;
LABEL_581:
  submitRenderItems(v460, (uint64_t)v454, (uint64_t)&v518, v538);
  if (v539 == v538)
  {
    (*(void (**)(void *))(v538[0] + 32))(v538);
  }
  else if (v539)
  {
    (*(void (**)(void))(*v539 + 40))();
  }
  for (uint64_t i = *(void **)([v460 featureIds] + 16); i; uint64_t i = (void *)*i)
  {
    unint64_t v462 = i[2];
    float v463 = operator new(0x20uLL);
    float v464 = v448[21];
    v463[24] = (int)v464;
    *(void *)float v463 = 0;
    *((void *)v463 + 1) = ((v462 << 6) + (v462 >> 2) + (int)v464 - 0x61C8864680B583EBLL) ^ v462;
    *((void *)v463 + 2) = v462;
    if ((std::__hash_table<md::FeatureIdZoom,md::FeatureIdZoomHash,std::equal_to<md::FeatureIdZoom>,std::allocator<md::FeatureIdZoom>>::__node_insert_unique((void *)(v511 + 416), (uint64_t)v463) & 1) == 0)operator delete(v463); {
  }
    }
}

void sub_1A23B070C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a47);

  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::BuildingTopDepth::CompressedMeshPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    id v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *float v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v17);
      }
      unsigned __int8 v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--float v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    id v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *float v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v7);
      }
      unsigned __int8 v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--float v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *id v4 = v3;
  }
  unsigned __int8 v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::BuildingFacadeDepth::BuildingPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    id v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *float v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v17);
      }
      unsigned __int8 v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--float v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    id v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *float v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v7);
      }
      unsigned __int8 v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--float v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *id v4 = v3;
  }
  unsigned __int8 v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::BuildingPointyRoofDepth::BuildingPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    id v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *float v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v17);
      }
      unsigned __int8 v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--float v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    id v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *float v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v7);
      }
      unsigned __int8 v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--float v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *id v4 = v3;
  }
  unsigned __int8 v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::DiffuseBuilding::BuildingPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    id v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *float v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v17);
      }
      unsigned __int8 v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--float v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    id v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *float v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v7);
      }
      unsigned __int8 v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--float v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *id v4 = v3;
  }
  unsigned __int8 v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::FoggedDiffuseBuilding::BuildingPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    id v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *float v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v17);
      }
      unsigned __int8 v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--float v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    id v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *float v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v7);
      }
      unsigned __int8 v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--float v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *id v4 = v3;
  }
  unsigned __int8 v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::PrefilteredLine::PrefilteredLinePipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    id v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *float v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v17);
      }
      unsigned __int8 v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--float v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    id v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *float v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v7);
      }
      unsigned __int8 v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--float v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *id v4 = v3;
  }
  unsigned __int8 v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void non-virtual thunk to'md::OcclusionPipelineProxy::update(uint64_t a1, int8x8_t *a2, uint64_t *a3)
{
}

void md::OcclusionPipelineProxy::update(uint64_t a1, int8x8_t *a2, uint64_t *a3)
{
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v7 = *(void *)(v6 + 8);
  if (v7 == *(void *)v6)
  {
    uint64_t v18 = *(void *)(v6 + 88);
    if (!v18)
    {
LABEL_55:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_56:
      abort();
    }
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 48))(v18);
    uint64_t v9 = *(uint64_t **)(v6 + 40);
    unint64_t v19 = *(void *)(v6 + 48);
    if ((unint64_t)v9 >= v19)
    {
      uint64_t v21 = *(void *)(v6 + 32);
      uint64_t v22 = ((uint64_t)v9 - v21) >> 3;
      unint64_t v13 = v22 + 1;
      if ((unint64_t)(v22 + 1) >> 61) {
        goto LABEL_56;
      }
      uint64_t v23 = v19 - v21;
      if (v23 >> 2 > v13) {
        unint64_t v13 = v23 >> 2;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v13)
      {
        uint64_t v24 = 8 * v13;
        uint64_t v25 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v6 + 56) + 16))(*(void *)(v6 + 56), 8 * v13, 8);
        uint64_t v17 = (uint64_t *)(v25 + 8 * v22);
        unint64_t v13 = v25 + v24;
        if (v25) {
          uint64_t *v17 = v8;
        }
      }
      else
      {
        uint64_t v17 = (uint64_t *)(8 * v22);
      }
      uint64_t v20 = v17 + 1;
      uint64_t v35 = *(void *)(v6 + 32);
      uint64_t v26 = *(void *)(v6 + 40);
      if (v26 == v35) {
        goto LABEL_48;
      }
      unint64_t v36 = v26 - v35 - 8;
      if (v36 < 0x38)
      {
        uint64_t v38 = *(void *)(v6 + 40);
      }
      else if ((unint64_t)(v26 - (void)v17) < 0x20)
      {
        uint64_t v38 = *(void *)(v6 + 40);
      }
      else
      {
        uint64_t v37 = (v36 >> 3) + 1;
        uint64_t v38 = v26 - 8 * (v37 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v39 = v17 - 2;
        uint64_t v40 = (long long *)(v26 - 16);
        uint64_t v41 = v37 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v42 = *v40;
          *((_OWORD *)v39 - 1) = *(v40 - 1);
          *(_OWORD *)uint64_t v39 = v42;
          v39 -= 4;
          v40 -= 2;
          v41 -= 4;
        }
        while (v41);
        v17 -= v37 & 0x3FFFFFFFFFFFFFFCLL;
        if (v37 == (v37 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v44 = *(void *)(v38 - 8);
        v38 -= 8;
        *--uint64_t v17 = v44;
      }
      while (v38 != v35);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v8 = *(void *)(v7 - 8);
    *(void *)(v6 + 8) = v7 - 8;
    uint64_t v9 = *(uint64_t **)(v6 + 40);
    unint64_t v10 = *(void *)(v6 + 48);
    if ((unint64_t)v9 >= v10)
    {
      uint64_t v11 = *(void *)(v6 + 32);
      uint64_t v12 = ((uint64_t)v9 - v11) >> 3;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
        goto LABEL_56;
      }
      uint64_t v14 = v10 - v11;
      if (v14 >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v13)
      {
        uint64_t v15 = 8 * v13;
        uint64_t v16 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v6 + 56) + 16))(*(void *)(v6 + 56), 8 * v13, 8);
        uint64_t v17 = (uint64_t *)(v16 + 8 * v12);
        unint64_t v13 = v16 + v15;
        if (v16) {
          uint64_t *v17 = v8;
        }
      }
      else
      {
        uint64_t v17 = (uint64_t *)(8 * v12);
      }
      uint64_t v20 = v17 + 1;
      uint64_t v27 = *(void *)(v6 + 32);
      uint64_t v26 = *(void *)(v6 + 40);
      if (v26 == v27) {
        goto LABEL_48;
      }
      unint64_t v28 = v26 - v27 - 8;
      if (v28 < 0x38)
      {
        uint64_t v30 = *(void *)(v6 + 40);
      }
      else if ((unint64_t)(v26 - (void)v17) < 0x20)
      {
        uint64_t v30 = *(void *)(v6 + 40);
      }
      else
      {
        uint64_t v29 = (v28 >> 3) + 1;
        uint64_t v30 = v26 - 8 * (v29 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v31 = v17 - 2;
        uint64_t v32 = (long long *)(v26 - 16);
        uint64_t v33 = v29 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v34 = *v32;
          *((_OWORD *)v31 - 1) = *(v32 - 1);
          *(_OWORD *)unint64_t v31 = v34;
          v31 -= 4;
          v32 -= 2;
          v33 -= 4;
        }
        while (v33);
        v17 -= v29 & 0x3FFFFFFFFFFFFFFCLL;
        if (v29 == (v29 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v43 = *(void *)(v30 - 8);
        v30 -= 8;
        *--uint64_t v17 = v43;
      }
      while (v30 != v27);
LABEL_47:
      uint64_t v26 = *(void *)(v6 + 32);
LABEL_48:
      *(void *)(v6 + 32) = v17;
      *(void *)(v6 + 40) = v20;
      uint64_t v45 = *(void *)(v6 + 48);
      *(void *)(v6 + 48) = v13;
      if (v26) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 56) + 40))(*(void *)(v6 + 56), v26, v45 - v26);
      }
      goto LABEL_50;
    }
  }
  if (v9) {
    *uint64_t v9 = v8;
  }
  uint64_t v20 = v9 + 1;
LABEL_50:
  *(void *)(v6 + 40) = v20;
  *(void *)uint64_t v66 = v8;
  uint64_t v46 = *(void *)(v6 + 120);
  if (!v46) {
    goto LABEL_55;
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v46 + 48))(v46, v66);
  uint64_t v47 = *a3;
  *(void *)uint64_t v66 = v8;
  float v48 = (void *)gdc::Registry::storage<arComponents::PipelineInstanceToUse>(a2);
  gdc::ComponentStorageWrapper<md::ls::RegisterHandle>::emplace(v48, v47, v66);
  uint64_t v49 = *a3;
  *(void *)&v66[12] = 0;
  *(void *)&v66[4] = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  uint64_t v72 = 0;
  uint64_t v71 = 0;
  *(_DWORD *)uint64_t v66 = 1065353216;
  int v67 = 1065353216;
  int v70 = 1065353216;
  int v73 = 1065353216;
  uint64_t v50 = (void *)gdc::Registry::storage<arComponents::ViewConstantDataComponent>(a2);
  gdc::ComponentStorageWrapper<arComponents::ViewConstantDataComponent>::emplace(v50, v49, (long long *)v66);
  uint64_t v51 = *a3;
  *(void *)uint64_t v66 = 0;
  *(void *)&v66[8] = 0;
  uint64_t v52 = (void *)gdc::Registry::storage<arComponents::TransformConstantDataComponent>(a2);
  gdc::ComponentStorageWrapper<arComponents::TransformConstantDataComponent>::emplace(v52, v51, v66);
  unint64_t v53 = *(std::__shared_weak_count **)&v66[8];
  if (*(void *)&v66[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v66[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
  }
  uint64_t v54 = *a3;
  uint64_t v55 = (void *)gdc::Registry::storage<arComponents::NeedsTransformConstantDataUpdate>(a2);
  gdc::ComponentStorageWrapper<md::components::Collapsible>::emplace(v55, v54);
  uint64_t v56 = *a3;
  *(void *)uint64_t v66 = **(void **)(v8 + 64);
  uint64_t v57 = (void *)gdc::Registry::storage<arComponents::CompWrap<ggl::ConstantDataTyped<ggl::Tile::View>>>(a2);
  gdc::ComponentStorageWrapper<md::ls::RegisterHandle>::emplace(v57, v56, v66);
  uint64_t v58 = *a3;
  *(void *)uint64_t v66 = *(void *)(*(void *)(v8 + 64) + 16);
  long long v59 = (void *)gdc::Registry::storage<arComponents::CompWrap<ggl::ConstantDataTyped<ggl::Tile::Transform>>>(a2);
  gdc::ComponentStorageWrapper<md::ls::RegisterHandle>::emplace(v59, v58, v66);
  uint64_t v60 = *a3;
  *(void *)uint64_t v66 = **(void **)(v8 + 32);
  unint64_t v61 = (void *)gdc::Registry::storage<arComponents::CompWrap<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>>>(a2);
  gdc::ComponentStorageWrapper<md::ls::RegisterHandle>::emplace(v61, v60, v66);
  uint64_t v62 = *a3;
  *(void *)uint64_t v66 = a1;
  HasTransformConstant = (void *)gdc::Registry::storage<md::pipelineECS::HasTransformConstantData>(a2);
  gdc::ComponentStorageWrapper<md::ls::RegisterHandle>::emplace(HasTransformConstant, v62, v66);
  uint64_t v64 = *a3;
  *(void *)uint64_t v66 = a1 + 8;
  HasTransformInstanceDeviceData = (void *)gdc::Registry::storage<md::pipelineECS::HasTransformInstanceDeviceDataFeature>(a2);
  gdc::ComponentStorageWrapper<md::ls::RegisterHandle>::emplace(HasTransformInstanceDeviceData, v64, v66);
}

void sub_1A23B21C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void non-virtual thunk to'md::OcclusionPipelineProxy::setTransformInstanceDeviceData(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  id v4 = *(uint64_t **)(a3 + 32);
  unint64_t v5 = *(void **)(*a2 + 32);
  uint64_t v6 = *v4;
  uint64_t v7 = v4[1];
  *unint64_t v5 = v6;
  v5[1] = 0;
  uint64_t v8 = *(void **)(v3 + 128);
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = (std::__shared_weak_count *)v8[1];
  *uint64_t v8 = v6;
  v8[1] = v7;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
}

void md::OcclusionPipelineProxy::setTransformInstanceDeviceData(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  id v4 = *(uint64_t **)(a3 + 32);
  unint64_t v5 = *(void **)(*a2 + 32);
  uint64_t v6 = *v4;
  uint64_t v7 = v4[1];
  *unint64_t v5 = v6;
  v5[1] = 0;
  uint64_t v8 = *(void **)(v3 + 128);
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = (std::__shared_weak_count *)v8[1];
  *uint64_t v8 = v6;
  v8[1] = v7;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
}

void md::OcclusionPipelineProxy::~OcclusionPipelineProxy(md::OcclusionPipelineProxy *this)
{
}

void md::OcclusionPipelineProxy::setTransformConstant(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(*a2 + 64);
  uint64_t v5 = *a3;
  uint64_t v6 = a3[1];
  *(void *)(v4 + 16) = *a3;
  *(void *)(v4 + 24) = 0;
  uint64_t v7 = *(void *)(v3 + 160);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(v7 + 24);
  *(void *)(v7 + 16) = v5;
  *(void *)(v7 + 24) = v6;
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
}

void ggl::Line::BasePipelineState::~BasePipelineState(ggl::Line::BasePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::Line::BasePipelineSetup::textureIsEnabled(ggl::Line::BasePipelineSetup *this)
{
  return 0;
}

BOOL ggl::Line::BasePipelineSetup::constantDataIsEnabled(ggl::Line::BasePipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

void ggl::Line::BasePipelineSetup::~BasePipelineSetup(ggl::Line::BasePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t md::RasterRenderLayer::reserveStencilRange(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 24);
  unsigned int v3 = *v2;
  unsigned int v4 = v2[1];
  BOOL v5 = v3 >= v4;
  if (v3 >= v4) {
    uint64_t v6 = v2 + 4;
  }
  else {
    uint64_t v6 = 0;
  }
  *(void *)(result + 392) = v6;
  if (v5)
  {
    v2[1] = v2[2];
    LOBYTE(v3) = 1;
  }
  *uint64_t v2 = v3 + 1;
  *(unsigned char *)(result + 400) = v3;
  return result;
}

void md::RasterRenderLayer::layout(md::RasterRenderLayer *this, const md::LayoutContext *a2)
{
  uint64_t v2 = a2;
  uint64_t v375 = *MEMORY[0x1E4F143B8];
  v371[0] = &unk_1EF573278;
  v371[1] = a2;
  v369[0] = &unk_1EF5732C0;
  v369[1] = a2;
  double v370 = v369;
  uint64_t v374 = v373;
  unsigned int v372 = v371;
  v373[0] = &unk_1EF5732C0;
  v373[1] = a2;
  std::__function::__func<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()((uint64_t)v371);
  if (v370 == v369)
  {
    (*(void (**)(void *))(v369[0] + 32))(v369);
  }
  else if (v370)
  {
    (*(void (**)(void *))(*v370 + 40))(v370);
  }
  if (v372 == v371)
  {
    (*(void (**)(void *))(v371[0] + 32))(v371);
  }
  else if (v372)
  {
    (*(void (**)(void *))(*v372 + 40))(v372);
  }
  unsigned int v4 = (uint64_t *)*((void *)v2 + 1);
  int8x8_t v5 = (int8x8_t)v4[1];
  if (v5)
  {
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      uint64_t v7 = 0x3070CB6B3C7F21D3;
      if (*(void *)&v5 <= 0x3070CB6B3C7F21D3uLL) {
        uint64_t v7 = 0x3070CB6B3C7F21D3uLL % *(void *)&v5;
      }
    }
    else
    {
      uint64_t v7 = (*(void *)&v5 - 1) & 0x3070CB6B3C7F21D3;
    }
    uint64_t v8 = *v4;
    uint64_t v9 = *(void **)(v8 + 8 * v7);
    if (!v9) {
      goto LABEL_33;
    }
    unint64_t v10 = (void *)*v9;
    if (!v10) {
      goto LABEL_33;
    }
    if (v6.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v12 = v10[1];
        if (v12 == 0x3070CB6B3C7F21D3)
        {
          if (v10[2] == 0x3070CB6B3C7F21D3) {
            goto LABEL_31;
          }
        }
        else if ((v12 & (*(void *)&v5 - 1)) != v7)
        {
          goto LABEL_33;
        }
        unint64_t v10 = (void *)*v10;
        if (!v10) {
          goto LABEL_33;
        }
      }
    }
    while (1)
    {
      unint64_t v11 = v10[1];
      if (v11 == 0x3070CB6B3C7F21D3)
      {
        if (v10[2] == 0x3070CB6B3C7F21D3)
        {
LABEL_31:
          uint64_t v13 = v10[5];
          if (*(void *)(v13 + 8) == 0x3070CB6B3C7F21D3)
          {
            uint64_t v352 = *(void *)(v13 + 32);
LABEL_34:
            if (v6.u32[0] > 1uLL)
            {
              unint64_t v14 = 0xE42D19AFCA302E68;
              if (*(void *)&v5 <= 0xE42D19AFCA302E68) {
                unint64_t v14 = 0xE42D19AFCA302E68 % *(void *)&v5;
              }
            }
            else
            {
              unint64_t v14 = (*(void *)&v5 - 1) & 0xE42D19AFCA302E68;
            }
            uint64_t v15 = *(void **)(v8 + 8 * v14);
            if (!v15) {
              goto LABEL_56;
            }
            uint64_t v16 = (void *)*v15;
            if (!v16) {
              goto LABEL_56;
            }
            if (v6.u32[0] < 2uLL)
            {
              uint64_t v17 = *(void *)&v5 - 1;
              while (1)
              {
                uint64_t v19 = v16[1];
                if (v19 == 0xE42D19AFCA302E68)
                {
                  if (v16[2] == 0xE42D19AFCA302E68) {
                    goto LABEL_54;
                  }
                }
                else if ((v19 & v17) != v14)
                {
                  goto LABEL_56;
                }
                uint64_t v16 = (void *)*v16;
                if (!v16) {
                  goto LABEL_56;
                }
              }
            }
            while (1)
            {
              unint64_t v18 = v16[1];
              if (v18 == 0xE42D19AFCA302E68)
              {
                if (v16[2] == 0xE42D19AFCA302E68)
                {
LABEL_54:
                  uint64_t v20 = (int8x8_t *)v16[5];
                  if (*(void *)&v20[1] == 0xE42D19AFCA302E68)
                  {
                    int8x8_t v5 = v20[4];
                    goto LABEL_57;
                  }
LABEL_56:
                  int8x8_t v5 = 0;
                  goto LABEL_57;
                }
              }
              else
              {
                if (v18 >= *(void *)&v5) {
                  v18 %= *(void *)&v5;
                }
                if (v18 != v14) {
                  goto LABEL_56;
                }
              }
              uint64_t v16 = (void *)*v16;
              if (!v16) {
                goto LABEL_56;
              }
            }
          }
LABEL_33:
          uint64_t v352 = 0;
          goto LABEL_34;
        }
      }
      else
      {
        if (v11 >= *(void *)&v5) {
          v11 %= *(void *)&v5;
        }
        if (v11 != v7) {
          goto LABEL_33;
        }
      }
      unint64_t v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_33;
      }
    }
  }
  uint64_t v352 = 0;
LABEL_57:
  v367[0] = &unk_1EF573308;
  v367[1] = this;
  v367[2] = v5;
  uint64_t v368 = v367;
  uint64_t v21 = *(unsigned char **)(*(void *)&v5 + 48);
  uint64_t v22 = *(unsigned char **)(*(void *)&v5 + 56);
  uint64_t v348 = (uint64_t *)v5;
  if (v21 == v22) {
    goto LABEL_63;
  }
  do
  {
    LOBYTE(__p) = *v21;
    if (!v368)
    {
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_555:
      __break(1u);
      return;
    }
    (*(void (**)(void *, void **))(*v368 + 48))(v368, &__p);
    ++v21;
  }
  while (v21 != v22);
  if (v368 != v367)
  {
    if (v368) {
      (*(void (**)(void))(*v368 + 40))();
    }
    goto LABEL_64;
  }
LABEL_63:
  (*(void (**)(void *))(v367[0] + 32))(v367);
LABEL_64:
  (*(void (**)(void **__return_ptr, md::RasterRenderLayer *, const md::LayoutContext *))(*(void *)this
                                                                                                  + 32))(&__p, this, v2);
  unsigned int v23 = *(unsigned __int16 *)__p;
  float v361 = (std::__shared_weak_count *)__p;
  operator delete(__p);
  uint64_t v24 = *(void **)(*(void *)(*((void *)this + 5) + 24) + 8);
  uint64_t v26 = v24[3];
  uint64_t v25 = v24[4];
  if (v25 == v26) {
    goto LABEL_71;
  }
  uint64_t v27 = 0;
  while (1)
  {
    unint64_t v28 = *(unsigned __int8 **)(v26 + 8 * v27);
    if (*v28 == v23)
    {
      unint64_t v29 = *((void *)v28 + 1);
      uint64_t v30 = v24[15];
      if (v29 < (v24[16] - v30) >> 3) {
        break;
      }
    }
    if (++v27 >= (unint64_t)((v25 - v26) >> 3)) {
      goto LABEL_71;
    }
  }
  uint64_t v31 = *(void *)(v30 + 8 * v29);
  if (!v31) {
LABEL_71:
  }
    uint64_t v32 = 0;
  else {
    uint64_t v32 = *(void **)(*(void *)(v31 + 24) + 8 * (v23 >> 8));
  }
  uint64_t v33 = v32[9];
  if (v32[10] != v33) {
    v32[10] = v33;
  }
  uint64_t v353 = (uint64_t)v32;
  v32[4] = 0;
  long long v34 = (uint64_t **)*((void *)this + 47);
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(v34[3]);
  uint64_t v35 = *v34;
  unint64_t v36 = (uint64_t *)(*v34)[4];
  uint64_t v37 = (uint64_t *)(*v34)[5];
  float v350 = v2;
  if (v36 != v37)
  {
    uint64_t v38 = (void *)v35[1];
    while (1)
    {
      uint64_t v39 = *v36;
      unint64_t v40 = v35[2];
      if ((unint64_t)v38 >= v40) {
        break;
      }
      if (v38) {
        *uint64_t v38 = v39;
      }
      ++v38;
LABEL_77:
      v35[1] = (uint64_t)v38;
      if (++v36 == v37)
      {
        uint64_t v60 = v35[4];
        if (v60 != v35[5]) {
          v35[5] = v60;
        }
        goto LABEL_106;
      }
    }
    uint64_t v41 = ((uint64_t)v38 - *v35) >> 3;
    if ((unint64_t)(v41 + 1) >> 61) {
LABEL_548:
    }
      abort();
    uint64_t v42 = v40 - *v35;
    uint64_t v43 = v42 >> 2;
    if (v42 >> 2 <= (unint64_t)(v41 + 1)) {
      uint64_t v43 = v41 + 1;
    }
    if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v44 = v43;
    }
    if (v44)
    {
      uint64_t v45 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v35[3] + 16))(v35[3], 8 * v44, 8);
      uint64_t v46 = (void *)(v45 + 8 * v41);
      uint64_t v47 = v45 + 8 * v44;
      if (v45) {
        void *v46 = v39;
      }
    }
    else
    {
      uint64_t v47 = 0;
      uint64_t v46 = (void *)(8 * v41);
    }
    uint64_t v49 = *v35;
    uint64_t v48 = v35[1];
    uint64_t v50 = v48 - *v35;
    if (v48 != *v35)
    {
      unint64_t v51 = v50 - 8;
      if ((unint64_t)(v50 - 8) < 0x38)
      {
        uint64_t v52 = v46;
      }
      else
      {
        uint64_t v52 = v46;
        if ((unint64_t)(v48 - (void)v46) >= 0x20)
        {
          uint64_t v53 = (v51 >> 3) + 1;
          uint64_t v54 = v46 - 2;
          uint64_t v55 = (long long *)(v48 - 16);
          uint64_t v56 = v53 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v57 = *v55;
            *(v54 - 1) = *(v55 - 1);
            _OWORD *v54 = v57;
            v54 -= 2;
            v55 -= 2;
            v56 -= 4;
          }
          while (v56);
          uint64_t v52 = &v46[-(v53 & 0x3FFFFFFFFFFFFFFCLL)];
          v48 -= 8 * (v53 & 0x3FFFFFFFFFFFFFFCLL);
          if (v53 == (v53 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_101:
            uint64_t v48 = *v35;
LABEL_102:
            uint64_t v38 = v46 + 1;
            *uint64_t v35 = (uint64_t)v52;
            v35[1] = (uint64_t)(v46 + 1);
            uint64_t v59 = v35[2];
            v35[2] = v47;
            if (v48) {
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v35[3] + 40))(v35[3], v48, v59 - v48);
            }
            goto LABEL_77;
          }
        }
      }
      do
      {
        uint64_t v58 = *(void *)(v48 - 8);
        v48 -= 8;
        *--uint64_t v52 = v58;
      }
      while (v48 != v49);
      goto LABEL_101;
    }
    uint64_t v52 = v46;
    goto LABEL_102;
  }
LABEL_106:
  unint64_t v61 = v34[1];
  uint64_t v62 = (uint64_t *)v61[4];
  uint64_t v63 = (uint64_t *)v61[5];
  if (v62 == v63) {
    goto LABEL_138;
  }
  uint64_t v64 = (void *)v61[1];
  while (2)
  {
    uint64_t v65 = *v62;
    unint64_t v66 = v61[2];
    if ((unint64_t)v64 < v66)
    {
      if (v64) {
        void *v64 = v65;
      }
      ++v64;
      goto LABEL_109;
    }
    uint64_t v67 = ((uint64_t)v64 - *v61) >> 3;
    if ((unint64_t)(v67 + 1) >> 61) {
      goto LABEL_548;
    }
    uint64_t v68 = v66 - *v61;
    uint64_t v69 = v68 >> 2;
    if (v68 >> 2 <= (unint64_t)(v67 + 1)) {
      uint64_t v69 = v67 + 1;
    }
    if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v70 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v70 = v69;
    }
    if (v70)
    {
      uint64_t v71 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v61[3] + 16))(v61[3], 8 * v70, 8);
      uint64_t v72 = (void *)(v71 + 8 * v67);
      uint64_t v73 = v71 + 8 * v70;
      if (v71) {
        void *v72 = v65;
      }
    }
    else
    {
      uint64_t v73 = 0;
      uint64_t v72 = (void *)(8 * v67);
    }
    uint64_t v75 = *v61;
    uint64_t v74 = v61[1];
    uint64_t v76 = v74 - *v61;
    if (v74 == *v61)
    {
      long long v78 = v72;
      goto LABEL_134;
    }
    unint64_t v77 = v76 - 8;
    if ((unint64_t)(v76 - 8) < 0x38)
    {
      long long v78 = v72;
      do
      {
LABEL_132:
        uint64_t v84 = *(void *)(v74 - 8);
        v74 -= 8;
        *--long long v78 = v84;
      }
      while (v74 != v75);
      goto LABEL_133;
    }
    long long v78 = v72;
    if ((unint64_t)(v74 - (void)v72) < 0x20) {
      goto LABEL_132;
    }
    uint64_t v79 = (v77 >> 3) + 1;
    uint64_t v80 = v72 - 2;
    int v81 = (long long *)(v74 - 16);
    uint64_t v82 = v79 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v83 = *v81;
      *(v80 - 1) = *(v81 - 1);
      *uint64_t v80 = v83;
      v80 -= 2;
      v81 -= 2;
      v82 -= 4;
    }
    while (v82);
    long long v78 = &v72[-(v79 & 0x3FFFFFFFFFFFFFFCLL)];
    v74 -= 8 * (v79 & 0x3FFFFFFFFFFFFFFCLL);
    if (v79 != (v79 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_132;
    }
LABEL_133:
    uint64_t v74 = *v61;
LABEL_134:
    uint64_t v64 = v72 + 1;
    uint64_t *v61 = (uint64_t)v78;
    v61[1] = (uint64_t)(v72 + 1);
    uint64_t v85 = v61[2];
    _OWORD v61[2] = v73;
    if (v74) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v61[3] + 40))(v61[3], v74, v85 - v74);
    }
LABEL_109:
    v61[1] = (uint64_t)v64;
    if (++v62 != v63) {
      continue;
    }
    break;
  }
  uint64_t v86 = v61[4];
  if (v86 != v61[5]) {
    v61[5] = v86;
  }
LABEL_138:
  unint64_t v87 = v34[2];
  double v88 = (uint64_t *)v87[4];
  double v89 = (uint64_t *)v87[5];
  if (v88 == v89) {
    goto LABEL_170;
  }
  unint64_t v90 = (void *)v87[1];
  while (2)
  {
    uint64_t v91 = *v88;
    unint64_t v92 = v87[2];
    if ((unint64_t)v90 < v92)
    {
      if (v90) {
        *unint64_t v90 = v91;
      }
      ++v90;
      goto LABEL_141;
    }
    uint64_t v93 = ((uint64_t)v90 - *v87) >> 3;
    if ((unint64_t)(v93 + 1) >> 61) {
      goto LABEL_548;
    }
    uint64_t v94 = v92 - *v87;
    uint64_t v95 = v94 >> 2;
    if (v94 >> 2 <= (unint64_t)(v93 + 1)) {
      uint64_t v95 = v93 + 1;
    }
    if ((unint64_t)v94 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v96 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v96 = v95;
    }
    if (v96)
    {
      uint64_t v97 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v87[3] + 16))(v87[3], 8 * v96, 8);
      uint64_t v98 = (void *)(v97 + 8 * v93);
      uint64_t v99 = v97 + 8 * v96;
      if (v97) {
        *uint64_t v98 = v91;
      }
    }
    else
    {
      uint64_t v99 = 0;
      uint64_t v98 = (void *)(8 * v93);
    }
    uint64_t v101 = *v87;
    uint64_t v100 = v87[1];
    uint64_t v102 = v100 - *v87;
    if (v100 == *v87)
    {
      uint64_t v104 = v98;
      goto LABEL_166;
    }
    unint64_t v103 = v102 - 8;
    if ((unint64_t)(v102 - 8) < 0x38)
    {
      uint64_t v104 = v98;
      do
      {
LABEL_164:
        uint64_t v110 = *(void *)(v100 - 8);
        v100 -= 8;
        *--uint64_t v104 = v110;
      }
      while (v100 != v101);
      goto LABEL_165;
    }
    uint64_t v104 = v98;
    if ((unint64_t)(v100 - (void)v98) < 0x20) {
      goto LABEL_164;
    }
    uint64_t v105 = (v103 >> 3) + 1;
    unint64_t v106 = v98 - 2;
    uint64_t v107 = (long long *)(v100 - 16);
    uint64_t v108 = v105 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v109 = *v107;
      *(v106 - 1) = *(v107 - 1);
      *unint64_t v106 = v109;
      v106 -= 2;
      v107 -= 2;
      v108 -= 4;
    }
    while (v108);
    uint64_t v104 = &v98[-(v105 & 0x3FFFFFFFFFFFFFFCLL)];
    v100 -= 8 * (v105 & 0x3FFFFFFFFFFFFFFCLL);
    if (v105 != (v105 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_164;
    }
LABEL_165:
    uint64_t v100 = *v87;
LABEL_166:
    unint64_t v90 = v98 + 1;
    *unint64_t v87 = (uint64_t)v104;
    v87[1] = (uint64_t)(v98 + 1);
    uint64_t v111 = v87[2];
    v87[2] = v99;
    if (v100) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v87[3] + 40))(v87[3], v100, v111 - v100);
    }
LABEL_141:
    v87[1] = (uint64_t)v90;
    if (++v88 != v89) {
      continue;
    }
    break;
  }
  uint64_t v112 = v87[4];
  uint64_t v2 = v350;
  if (v112 != v87[5]) {
    v87[5] = v112;
  }
LABEL_170:
  if (*((void *)this + 34) == *((void *)this + 35)) {
    goto LABEL_461;
  }
  if (*(void *)(*((void *)this + 46) + 8) || !*v348) {
    goto LABEL_172;
  }
  uint64_t v122 = *(void *)(*v348 + 16);
  unsigned __int8 v123 = atomic_load((unsigned __int8 *)(v122 + 2784));
  if ((v123 & 1) == 0) {
    std::__assoc_sub_state::wait(*(std::__assoc_sub_state **)(v122 + 2808));
  }
  if (!*(unsigned char *)(v122 + 136) || !md::RasterRenderLayer::shouldEnableCLUT(v348)) {
    goto LABEL_172;
  }
  id v124 = *(id *)v2;
  int v125 = (gss::Allocator *)[v124 contentScale];
  uint64_t v126 = (void *)*((void *)v2 + 1);
  int8x8_t v127 = (int8x8_t)v126[1];
  if (!*(void *)&v127) {
    goto LABEL_487;
  }
  uint8x8_t v128 = (uint8x8_t)vcnt_s8(v127);
  v128.i16[0] = vaddlv_u8(v128);
  if (v128.u32[0] > 1uLL)
  {
    unint64_t v129 = 0xA60DDA5A69582425;
    if (*(void *)&v127 <= 0xA60DDA5A69582425) {
      unint64_t v129 = 0xA60DDA5A69582425 % *(void *)&v127;
    }
  }
  else
  {
    unint64_t v129 = (*(void *)&v127 - 1) & 0xA60DDA5A69582425;
  }
  float v317 = *(void **)(*v126 + 8 * v129);
  if (!v317) {
    goto LABEL_487;
  }
  unsigned int v318 = (void *)*v317;
  if (!v318) {
    goto LABEL_487;
  }
  if (v128.u32[0] < 2uLL)
  {
    uint64_t v319 = *(void *)&v127 - 1;
    while (1)
    {
      uint64_t v321 = v318[1];
      if (v321 == 0xA60DDA5A69582425)
      {
        if (v318[2] == 0xA60DDA5A69582425) {
          goto LABEL_485;
        }
      }
      else if ((v321 & v319) != v129)
      {
        goto LABEL_487;
      }
      unsigned int v318 = (void *)*v318;
      if (!v318) {
        goto LABEL_487;
      }
    }
  }
  while (2)
  {
    unint64_t v320 = v318[1];
    if (v320 != 0xA60DDA5A69582425)
    {
      if (v320 >= *(void *)&v127) {
        v320 %= *(void *)&v127;
      }
      if (v320 != v129) {
        goto LABEL_487;
      }
      goto LABEL_474;
    }
    if (v318[2] != 0xA60DDA5A69582425)
    {
LABEL_474:
      unsigned int v318 = (void *)*v318;
      if (!v318) {
        goto LABEL_487;
      }
      continue;
    }
    break;
  }
LABEL_485:
  uint64_t v322 = v318[5];
  if (*(void *)(v322 + 8) == 0xA60DDA5A69582425)
  {
    unint64_t v323 = *(id **)(v322 + 32);
    goto LABEL_488;
  }
LABEL_487:
  unint64_t v323 = 0;
LABEL_488:
  uint64_t v324 = *((void *)this + 46);
  uint64_t v325 = *(void *)(v324 + 96);
  if (!v325)
  {
    uint64_t v326 = gss::Allocator::instance(v125);
    uint64_t v366 = v326;
    unint64_t v327 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v326 + 16))(v326, 8, 4);
    uint64_t v328 = v327;
    v365.__r_.__value_.__r.__words[0] = (std::string::size_type)v327;
    v365.__r_.__value_.__r.__words[2] = (std::string::size_type)(v327 + 1);
    if (v327) {
      void *v327 = 0x900000005;
    }
    v365.__r_.__value_.__l.__size_ = (std::string::size_type)(v327 + 1);
    gss::FeatureAttributeSet::FeatureAttributeSet((gss::FeatureAttributeSet *)&__p, (uint64_t)&v365);
    if (v328) {
      (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v326 + 40))(v326, v328, 8);
    }
    uint64_t v329 = *v348;
    if (*v348)
    {
      *(std::string::size_type *)((char *)v365.__r_.__value_.__r.__words + 7) = 0;
      v365.__r_.__value_.__r.__words[0] = 0;
      v365.__r_.__value_.__s.__data_[15] = 1;
      gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)&v359, v329, (gss::FeatureAttributeSet *)&__p, (gss::QueryOverrides *)&v365);
      long long v330 = *(_OWORD *)&v359.__r_.__value_.__l.__data_;
    }
    else
    {
      long long v330 = 0uLL;
    }
    *(_OWORD *)&v359.__r_.__value_.__l.__data_ = 0uLL;
    uint64_t v331 = *(std::__shared_weak_count **)(v324 + 104);
    *(_OWORD *)(v324 + 96) = v330;
    if (v331 && !atomic_fetch_add(&v331->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v331->__on_zero_shared)(v331);
      std::__shared_weak_count::__release_weak(v331);
    }
    std::string::size_type size = (std::__shared_weak_count *)v359.__r_.__value_.__l.__size_;
    if (v359.__r_.__value_.__l.__size_
      && !atomic_fetch_add((atomic_ullong *volatile)(v359.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
    if (__p)
    {
      float v361 = (std::__shared_weak_count *)__p;
      (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v363 + 40))(v363, __p, v362 - (void)__p);
    }
    uint64_t v325 = *(void *)(v324 + 96);
  }
  unsigned int v333 = *(std::__shared_weak_count **)(v324 + 104);
  v365.__r_.__value_.__r.__words[0] = v325;
  v365.__r_.__value_.__l.__size_ = (std::string::size_type)v333;
  if (v333) {
    atomic_fetch_add_explicit(&v333->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)&__p, v325, (uint64_t)v333);
  if (v333 && !atomic_fetch_add(&v333->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v333->__on_zero_shared)(v333);
    std::__shared_weak_count::__release_weak(v333);
  }
  if (v364)
  {
    *((unsigned char *)&v365.__r_.__value_.__s + 23) = 0;
    v365.__r_.__value_.__s.__data_[0] = 0;
    if (!md::RasterRenderLayer::shouldEnableCLUT(v348)) {
      goto LABEL_517;
    }
    gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<std::string>(&v359, *((void *)__p + 3), 0x88u, 1u, 1);
    if (SHIBYTE(v365.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v365.__r_.__value_.__l.__data_);
    }
    std::string v365 = v359;
    std::string::size_type v334 = HIBYTE(v359.__r_.__value_.__r.__words[2]);
    if ((v359.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v334 = v359.__r_.__value_.__l.__size_;
    }
    if (!v334)
    {
LABEL_517:
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<std::string>(&v359, *((void *)__p + 3), 0x88u, 1u, 2);
      if (SHIBYTE(v365.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v365.__r_.__value_.__l.__data_);
      }
      std::string v365 = v359;
    }
    std::string::size_type v335 = HIBYTE(v365.__r_.__value_.__r.__words[2]);
    char v336 = HIBYTE(v365.__r_.__value_.__r.__words[2]);
    if ((v365.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v335 = v365.__r_.__value_.__l.__size_;
    }
    if (v335)
    {
      float v337 = (std::__shared_weak_count *)operator new(0x58uLL);
      v337->__shared_owners_ = 0;
      v337->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583858;
      v337[1].__shared_weak_owners_ = 0;
      v337[2].__vftable = 0;
      v337[1].__shared_owners_ = 0;
      LODWORD(v337[2].__shared_owners_) = 0;
      v337->__shared_weak_owners_ = 0;
      v337[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55AE58;
      *(_OWORD *)((char *)&v337[2].__shared_owners_ + 4) = xmmword_1A28FC7B0;
      *(std::__shared_weak_count_vtbl **)((char *)&v337[3].__vftable + 4) = (std::__shared_weak_count_vtbl *)0x100000001;
      HIDWORD(v337[3].__shared_owners_) = 0;
      v359.__r_.__value_.__r.__words[0] = (std::string::size_type)&v337[1];
      v359.__r_.__value_.__l.__size_ = (std::string::size_type)v337;
      id v338 = *v323;
      float v339 = v338;
      if (v338)
      {
        [v338 textureManager];
        float v340 = v355;
      }
      else
      {
        float v340 = 0;
        float v355 = 0;
        float v356 = 0;
      }
      v354[0] = (uint64_t)&v337[1];
      v354[1] = (uint64_t)v337;
      atomic_fetch_add_explicit(&v337->__shared_owners_, 1uLL, memory_order_relaxed);
      md::TextureManager::texture(&v357, v340, (uint64_t)&v365, v354, 0, 1.0);
      if (!atomic_fetch_add(&v337->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v337->__on_zero_shared)(v337);
        std::__shared_weak_count::__release_weak(v337);
      }
      float v341 = v356;
      if (v356 && !atomic_fetch_add(&v356->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v341->__on_zero_shared)(v341);
        std::__shared_weak_count::__release_weak(v341);
      }

      uint64_t v342 = v357;
      if (v357)
      {
        uint64_t v343 = *(void *)(v357 + 32);
        uint64_t v342 = *(void *)(v357 + 40);
        if (v342) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v342 + 8), 1uLL, memory_order_relaxed);
        }
      }
      else
      {
        uint64_t v343 = 0;
      }
      uint64_t v344 = *((void *)this + 46);
      float v345 = *(std::__shared_weak_count **)(v344 + 16);
      *(void *)(v344 + 8) = v343;
      *(void *)(v344 + 16) = v342;
      if (v345 && !atomic_fetch_add(&v345->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v345->__on_zero_shared)(v345);
        std::__shared_weak_count::__release_weak(v345);
      }
      BOOL v346 = v358;
      if (v358 && !atomic_fetch_add(&v358->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v346->__on_zero_shared)(v346);
        std::__shared_weak_count::__release_weak(v346);
      }
      unint64_t v347 = (std::__shared_weak_count *)v359.__r_.__value_.__l.__size_;
      if (v359.__r_.__value_.__l.__size_
        && !atomic_fetch_add((atomic_ullong *volatile)(v359.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v347->__on_zero_shared)(v347);
        std::__shared_weak_count::__release_weak(v347);
      }
      char v336 = HIBYTE(v365.__r_.__value_.__r.__words[2]);
    }
    if (v336 < 0) {
      operator delete(v365.__r_.__value_.__l.__data_);
    }
  }
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&__p);

LABEL_172:
  uint64_t v113 = *((void *)this + 46);
  uint64_t v351 = *(void *)(v113 + 8);
  uint64_t v114 = 40;
  if (!v351) {
    uint64_t v114 = 32;
  }
  uint64_t v115 = *(void *)(v113 + v114);
  *(void *)(v353 + 32) = *((void *)this + 49);
  uint64_t v349 = v115;
  *(unsigned char *)(v115 + 55) = *((unsigned char *)this + 400);
  uint64_t v116 = *v348;
  if (!*v348)
  {
    unint64_t v118 = 0;
    std::vector<unsigned int> __p = 0;
    float v361 = 0;
LABEL_193:
    float v121 = 0.0;
    goto LABEL_194;
  }
  char v117 = *(float **)(v116 + 520);
  unint64_t v118 = *(std::__shared_weak_count **)(v116 + 528);
  std::vector<unsigned int> __p = v117;
  float v361 = v118;
  if (v118) {
    atomic_fetch_add_explicit(&v118->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v117) {
    goto LABEL_193;
  }
  int v119 = gss::ClientStyleState<gss::PropertyID>::sourceClientStyleAttribute((uint64_t)v117, 0x10001u);
  if (v119 != 1 || (v119 & 0xFFFF0000) == 0) {
    float v121 = v117[64];
  }
  else {
    float v121 = 1.0 - v117[64];
  }
LABEL_194:
  float v130 = 0.0;
  if (*((void *)this + 48) == 3)
  {
    unint64_t v131 = (void *)*((void *)v2 + 1);
    unint64_t v132 = v131[1];
    if ((v132 & (v132 - 1)) != 0)
    {
      unint64_t v134 = 0x1AF456233693CD46;
      if (v132 <= 0x1AF456233693CD46) {
        unint64_t v134 = 0x1AF456233693CD46 % v132;
      }
      uint64_t v133 = *(void **)(*v131 + 8 * v134);
      do
      {
        do
          uint64_t v133 = (void *)*v133;
        while (v133[1] != 0x1AF456233693CD46);
      }
      while (v133[2] != 0x1AF456233693CD46);
    }
    else
    {
      uint64_t v133 = *(void **)(*v131 + 8 * ((v132 - 1) & 0x1AF456233693CD46));
      do
      {
        do
          uint64_t v133 = (void *)*v133;
        while (v133[1] != 0x1AF456233693CD46);
      }
      while (v133[2] != 0x1AF456233693CD46);
    }
    float v135 = fmaxf(*(float *)(*(void *)(v133[5] + 32) + 3080) + *(float *)(*(void *)(v133[5] + 32) + 3072), 1.0);
    float v136 = 0.8;
    if (v135 > 9.0) {
      float v136 = 0.5;
    }
    if (v135 <= 8.0) {
      float v130 = 1.0;
    }
    else {
      float v130 = v136;
    }
  }
  uint64_t v138 = *((void *)this + 34);
  uint64_t v137 = *((void *)this + 35);
  if (v138 != v137)
  {
    while (1)
    {
      uint64_t v139 = *(void **)v138;
      uint64_t v140 = *(void *)(*(void *)(*(void *)v138 + 384) + 720);
      if (v140) {
        break;
      }
LABEL_214:
      v138 += 8;
      if (v138 == v137)
      {
        unint64_t v118 = v361;
        if (v361) {
          goto LABEL_459;
        }
        goto LABEL_461;
      }
    }
    uint64_t v141 = ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*((void *)this + 47) + 24));
    uint64_t v142 = v141;
    *(void *)(v141 + 24) = v349;
    uint64_t v143 = 16;
    if (*(unsigned __int8 *)(v352 + 320) - 1 < 3) {
      uint64_t v143 = 32;
    }
    *(void *)(v141 + 64) = *(void *)(v352 + v143);
    std::string::size_type v144 = (uint64_t **)*((void *)this + 47);
    if (v351)
    {
      std::string::pointer v145 = v144[1];
      uint64_t v146 = v145[1];
      if (v146 == *v145)
      {
        uint64_t v170 = v145[11];
        if (!v170) {
          goto LABEL_552;
        }
        long long v147 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v170 + 48))(v170);
        uint64_t v148 = (void *)v145[5];
        unint64_t v171 = v145[6];
        if ((unint64_t)v148 >= v171)
        {
          uint64_t v186 = v145[4];
          uint64_t v187 = ((uint64_t)v148 - v186) >> 3;
          unint64_t v188 = v187 + 1;
          if ((unint64_t)(v187 + 1) >> 61) {
LABEL_551:
          }
            abort();
          uint64_t v189 = v171 - v186;
          if (v189 >> 2 > v188) {
            unint64_t v188 = v189 >> 2;
          }
          if ((unint64_t)v189 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v190 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v190 = v188;
          }
          if (v190)
          {
            uint64_t v191 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v145[7] + 16))(v145[7], 8 * v190, 8);
            unint64_t v156 = (void *)(v191 + 8 * v187);
            uint64_t v157 = v191 + 8 * v190;
            if (v191) {
              *unint64_t v156 = v147;
            }
          }
          else
          {
            uint64_t v157 = 0;
            unint64_t v156 = (void *)(8 * v187);
          }
          uint64_t v208 = v145[4];
          uint64_t v192 = v145[5];
          uint64_t v209 = v192 - v208;
          if (v192 != v208)
          {
            unint64_t v210 = v209 - 8;
            if ((unint64_t)(v209 - 8) < 0x38)
            {
              std::string::pointer v196 = v156;
            }
            else
            {
              std::string::pointer v196 = v156;
              if ((unint64_t)(v192 - (void)v156) >= 0x20)
              {
                uint64_t v211 = (v210 >> 3) + 1;
                uint64_t v212 = v156 - 2;
                uint64_t v213 = (long long *)(v192 - 16);
                uint64_t v214 = v211 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v215 = *v213;
                  *(v212 - 1) = *(v213 - 1);
                  *uint64_t v212 = v215;
                  v212 -= 2;
                  v213 -= 2;
                  v214 -= 4;
                }
                while (v214);
                std::string::pointer v196 = &v156[-(v211 & 0x3FFFFFFFFFFFFFFCLL)];
                v192 -= 8 * (v211 & 0x3FFFFFFFFFFFFFFCLL);
                if (v211 == (v211 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_333;
                }
              }
            }
            do
            {
              uint64_t v249 = *(void *)(v192 - 8);
              v192 -= 8;
              *--std::string::pointer v196 = v249;
            }
            while (v192 != v208);
            goto LABEL_333;
          }
LABEL_293:
          std::string::pointer v196 = v156;
          goto LABEL_334;
        }
      }
      else
      {
        long long v147 = *(void **)(v146 - 8);
        v145[1] = v146 - 8;
        uint64_t v148 = (void *)v145[5];
        unint64_t v149 = v145[6];
        if ((unint64_t)v148 >= v149)
        {
          uint64_t v150 = v145[4];
          uint64_t v151 = ((uint64_t)v148 - v150) >> 3;
          unint64_t v152 = v151 + 1;
          if ((unint64_t)(v151 + 1) >> 61) {
            goto LABEL_551;
          }
          uint64_t v153 = v149 - v150;
          if (v153 >> 2 > v152) {
            unint64_t v152 = v153 >> 2;
          }
          if ((unint64_t)v153 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v154 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v154 = v152;
          }
          if (v154)
          {
            uint64_t v155 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v145[7] + 16))(v145[7], 8 * v154, 8);
            unint64_t v156 = (void *)(v155 + 8 * v151);
            uint64_t v157 = v155 + 8 * v154;
            if (v155) {
              *unint64_t v156 = v147;
            }
          }
          else
          {
            uint64_t v157 = 0;
            unint64_t v156 = (void *)(8 * v151);
          }
          uint64_t v193 = v145[4];
          uint64_t v192 = v145[5];
          uint64_t v194 = v192 - v193;
          if (v192 != v193)
          {
            unint64_t v195 = v194 - 8;
            if ((unint64_t)(v194 - 8) < 0x38)
            {
              std::string::pointer v196 = v156;
            }
            else
            {
              std::string::pointer v196 = v156;
              if ((unint64_t)(v192 - (void)v156) >= 0x20)
              {
                uint64_t v197 = (v195 >> 3) + 1;
                int v198 = v156 - 2;
                int v199 = (long long *)(v192 - 16);
                uint64_t v200 = v197 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v201 = *v199;
                  *(v198 - 1) = *(v199 - 1);
                  *int v198 = v201;
                  v198 -= 2;
                  v199 -= 2;
                  v200 -= 4;
                }
                while (v200);
                std::string::pointer v196 = &v156[-(v197 & 0x3FFFFFFFFFFFFFFCLL)];
                v192 -= 8 * (v197 & 0x3FFFFFFFFFFFFFFCLL);
                if (v197 == (v197 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_333;
                }
              }
            }
            do
            {
              uint64_t v228 = *(void *)(v192 - 8);
              v192 -= 8;
              *--std::string::pointer v196 = v228;
            }
            while (v192 != v193);
LABEL_333:
            uint64_t v192 = v145[4];
LABEL_334:
            uint64_t v172 = v156 + 1;
            v145[4] = (uint64_t)v196;
            v145[5] = (uint64_t)(v156 + 1);
            uint64_t v250 = v145[6];
            v145[6] = v157;
            if (v192) {
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v145[7] + 40))(v145[7], v192, v250 - v192);
            }
            goto LABEL_336;
          }
          goto LABEL_293;
        }
      }
      if (v148) {
        *uint64_t v148 = v147;
      }
      uint64_t v172 = v148 + 1;
LABEL_336:
      v145[5] = (uint64_t)v172;
      v365.__r_.__value_.__r.__words[0] = (std::string::size_type)v147;
      uint64_t v251 = v145[15];
      if (!v251) {
        goto LABEL_552;
      }
      (*(void (**)(uint64_t, std::string *))(*(void *)v251 + 48))(v251, &v365);
      uint64_t v252 = *((void *)this + 46);
      uint64_t v254 = *(void *)(v252 + 64);
      uint64_t v253 = *(std::__shared_weak_count **)(v252 + 72);
      if (v253) {
        atomic_fetch_add_explicit(&v253->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v254 && **(void **)(v254 + 40) == v147[1])
      {
        uint64_t v256 = v147[2];
        if (v256 && v256 != v254) {
          ggl::PipelineSetup::resetData((uint64_t)v147);
        }
        if (v253) {
          atomic_fetch_add_explicit(&v253->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v255 = (std::__shared_weak_count *)v147[3];
        v147[2] = v254;
        v147[3] = v253;
        if (!v255) {
          goto LABEL_350;
        }
      }
      else
      {
        uint64_t v255 = (std::__shared_weak_count *)v147[3];
        v147[2] = 0;
        v147[3] = 0;
        if (!v255) {
          goto LABEL_350;
        }
      }
      if (!atomic_fetch_add(&v255->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v255->__on_zero_shared)(v255);
        std::__shared_weak_count::__release_weak(v255);
        if (v253)
        {
LABEL_351:
          if (!atomic_fetch_add(&v253->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v253->__on_zero_shared)(v253);
            std::__shared_weak_count::__release_weak(v253);
          }
        }
LABEL_354:
        *(void *)(v147[12] + 8) = *(void *)(*((void *)this + 46) + 8);
        *(void *)v147[12] = v140;
        uint64_t v257 = (void *)v147[8];
        v257[1] = 0;
        uint64_t v258 = v139[27];
        *uint64_t v257 = v258;
        uint64_t v259 = (void *)v147[20];
        uint64_t v260 = v139[28];
        if (v260) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v260 + 8), 1uLL, memory_order_relaxed);
        }
        id v261 = (std::__shared_weak_count *)v259[1];
        void *v259 = v258;
        v259[1] = v260;
        if (v261 && !atomic_fetch_add(&v261->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v261->__on_zero_shared)(v261);
          std::__shared_weak_count::__release_weak(v261);
        }
        uint64_t v262 = v147[8];
        *(void *)(v262 + 24) = 0;
        uint64_t v263 = v139[29];
        *(void *)(v262 + 16) = v263;
        uint64_t v264 = v147[20];
        uint64_t v265 = v139[30];
        if (v265) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v265 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v266 = *(std::__shared_weak_count **)(v264 + 24);
        *(void *)(v264 + 16) = v263;
        *(void *)(v264 + 24) = v265;
        if (v266 && !atomic_fetch_add(&v266->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v266->__on_zero_shared)(v266);
          std::__shared_weak_count::__release_weak(v266);
        }
        uint64_t v267 = *(void *)(v147[8] + 32);
        unint64_t v268 = *(void *)(v267 + 8);
        **(float **)(v267 + 72) = v121;
        if (*(void *)(v267 + 64) > v268) {
          unint64_t v268 = *(void *)(v267 + 64);
        }
        *(void *)(v267 + 56) = 0;
        *(void *)(v267 + 64) = v268;
LABEL_367:
        *(void *)(v142 + 32) = v147;
        if (v147[9] != v147[8])
        {
          unint64_t v269 = 0;
          do
          {
            (*(void (**)(void *, unint64_t))(*v147 + 16))(v147, v269++);
            long long v147 = *(void **)(v142 + 32);
          }
          while (v269 < (uint64_t)(v147[9] - v147[8]) >> 4);
        }
        if (v147[13] != v147[12])
        {
          unint64_t v270 = 0;
          do
          {
            (*(void (**)(void *, unint64_t))(*v147 + 24))(v147, v270++);
            long long v147 = *(void **)(v142 + 32);
          }
          while (v270 < (uint64_t)(v147[13] - v147[12]) >> 3);
        }
        ggl::CommandBuffer::pushRenderItem(v353, v142);
        goto LABEL_214;
      }
LABEL_350:
      if (v253) {
        goto LABEL_351;
      }
      goto LABEL_354;
    }
    if (v130 > 0.0)
    {
      uint64_t v158 = v144[2];
      uint64_t v159 = v158[1];
      if (v159 == *v158)
      {
        uint64_t v202 = v158[11];
        if (!v202) {
          goto LABEL_552;
        }
        long long v147 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v202 + 48))(v202);
        uint64_t v160 = (void *)v158[5];
        unint64_t v203 = v158[6];
        if ((unint64_t)v160 >= v203)
        {
          uint64_t v216 = v158[4];
          uint64_t v217 = ((uint64_t)v160 - v216) >> 3;
          unint64_t v218 = v217 + 1;
          if ((unint64_t)(v217 + 1) >> 61) {
LABEL_554:
          }
            abort();
          uint64_t v219 = v203 - v216;
          if (v219 >> 2 > v218) {
            unint64_t v218 = v219 >> 2;
          }
          if ((unint64_t)v219 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v220 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v220 = v218;
          }
          if (v220)
          {
            uint64_t v221 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v158[7] + 16))(v158[7], 8 * v220, 8);
            uint64_t v168 = (void *)(v221 + 8 * v217);
            uint64_t v169 = v221 + 8 * v220;
            if (v221) {
              *uint64_t v168 = v147;
            }
          }
          else
          {
            uint64_t v169 = 0;
            uint64_t v168 = (void *)(8 * v217);
          }
          uint64_t v271 = v158[4];
          uint64_t v229 = v158[5];
          uint64_t v272 = v229 - v271;
          if (v229 != v271)
          {
            unint64_t v273 = v272 - 8;
            if ((unint64_t)(v272 - 8) < 0x38)
            {
              uint64_t v233 = v168;
            }
            else
            {
              uint64_t v233 = v168;
              if ((unint64_t)(v229 - (void)v168) >= 0x20)
              {
                uint64_t v274 = (v273 >> 3) + 1;
                uint64_t v275 = v168 - 2;
                uint64_t v276 = (long long *)(v229 - 16);
                uint64_t v277 = v274 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v278 = *v276;
                  *(v275 - 1) = *(v276 - 1);
                  *uint64_t v275 = v278;
                  v275 -= 2;
                  v276 -= 2;
                  v277 -= 4;
                }
                while (v277);
                uint64_t v233 = &v168[-(v274 & 0x3FFFFFFFFFFFFFFCLL)];
                v229 -= 8 * (v274 & 0x3FFFFFFFFFFFFFFCLL);
                if (v274 == (v274 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_400;
                }
              }
            }
            do
            {
              uint64_t v289 = *(void *)(v229 - 8);
              v229 -= 8;
              *--uint64_t v233 = v289;
            }
            while (v229 != v271);
            goto LABEL_400;
          }
LABEL_382:
          uint64_t v233 = v168;
          goto LABEL_401;
        }
      }
      else
      {
        long long v147 = *(void **)(v159 - 8);
        v158[1] = v159 - 8;
        uint64_t v160 = (void *)v158[5];
        unint64_t v161 = v158[6];
        if ((unint64_t)v160 >= v161)
        {
          uint64_t v162 = v158[4];
          uint64_t v163 = ((uint64_t)v160 - v162) >> 3;
          unint64_t v164 = v163 + 1;
          if ((unint64_t)(v163 + 1) >> 61) {
            goto LABEL_554;
          }
          uint64_t v165 = v161 - v162;
          if (v165 >> 2 > v164) {
            unint64_t v164 = v165 >> 2;
          }
          if ((unint64_t)v165 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v166 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v166 = v164;
          }
          if (v166)
          {
            uint64_t v167 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v158[7] + 16))(v158[7], 8 * v166, 8);
            uint64_t v168 = (void *)(v167 + 8 * v163);
            uint64_t v169 = v167 + 8 * v166;
            if (v167) {
              *uint64_t v168 = v147;
            }
          }
          else
          {
            uint64_t v169 = 0;
            uint64_t v168 = (void *)(8 * v163);
          }
          uint64_t v230 = v158[4];
          uint64_t v229 = v158[5];
          uint64_t v231 = v229 - v230;
          if (v229 != v230)
          {
            unint64_t v232 = v231 - 8;
            if ((unint64_t)(v231 - 8) < 0x38)
            {
              uint64_t v233 = v168;
            }
            else
            {
              uint64_t v233 = v168;
              if ((unint64_t)(v229 - (void)v168) >= 0x20)
              {
                uint64_t v234 = (v232 >> 3) + 1;
                unint64_t v235 = v168 - 2;
                long long v236 = (long long *)(v229 - 16);
                uint64_t v237 = v234 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v238 = *v236;
                  *(v235 - 1) = *(v236 - 1);
                  *unint64_t v235 = v238;
                  v235 -= 2;
                  v236 -= 2;
                  v237 -= 4;
                }
                while (v237);
                uint64_t v233 = &v168[-(v234 & 0x3FFFFFFFFFFFFFFCLL)];
                v229 -= 8 * (v234 & 0x3FFFFFFFFFFFFFFCLL);
                if (v234 == (v234 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_400;
                }
              }
            }
            do
            {
              uint64_t v287 = *(void *)(v229 - 8);
              v229 -= 8;
              *--uint64_t v233 = v287;
            }
            while (v229 != v230);
LABEL_400:
            uint64_t v229 = v158[4];
LABEL_401:
            uint64_t v204 = v168 + 1;
            v158[4] = (uint64_t)v233;
            v158[5] = (uint64_t)(v168 + 1);
            uint64_t v290 = v158[6];
            v158[6] = v169;
            if (v229) {
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v158[7] + 40))(v158[7], v229, v290 - v229);
            }
            goto LABEL_403;
          }
          goto LABEL_382;
        }
      }
      if (v160) {
        *uint64_t v160 = v147;
      }
      uint64_t v204 = v160 + 1;
LABEL_403:
      v158[5] = (uint64_t)v204;
      v365.__r_.__value_.__r.__words[0] = (std::string::size_type)v147;
      uint64_t v291 = v158[15];
      if (!v291) {
        goto LABEL_552;
      }
      (*(void (**)(uint64_t, std::string *))(*(void *)v291 + 48))(v291, &v365);
      uint64_t v292 = *((void *)this + 46);
      uint64_t v294 = *(void *)(v292 + 80);
      uint64_t v293 = *(std::__shared_weak_count **)(v292 + 88);
      if (v293) {
        atomic_fetch_add_explicit(&v293->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v294 && **(void **)(v294 + 40) == v147[1])
      {
        uint64_t v296 = v147[2];
        if (v296 && v296 != v294) {
          ggl::PipelineSetup::resetData((uint64_t)v147);
        }
        if (v293) {
          atomic_fetch_add_explicit(&v293->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v295 = (std::__shared_weak_count *)v147[3];
        v147[2] = v294;
        v147[3] = v293;
        if (!v295) {
          goto LABEL_418;
        }
      }
      else
      {
        uint64_t v295 = (std::__shared_weak_count *)v147[3];
        v147[2] = 0;
        v147[3] = 0;
        if (!v295)
        {
LABEL_418:
          if (v293 && !atomic_fetch_add(&v293->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v293->__on_zero_shared)(v293);
            std::__shared_weak_count::__release_weak(v293);
          }
          *(void *)v147[12] = v140;
          uint64_t v297 = (void *)v147[8];
          uint64_t v298 = v297[4];
          unint64_t v299 = *(void *)(v298 + 8);
          **(float **)(v298 + 72) = v130;
          if (*(void *)(v298 + 64) > v299) {
            unint64_t v299 = *(void *)(v298 + 64);
          }
          *(void *)(v298 + 56) = 0;
          *(void *)(v298 + 64) = v299;
LABEL_448:
          v297[1] = 0;
          uint64_t v308 = v139[27];
          *uint64_t v297 = v308;
          unsigned int v309 = (void *)v147[20];
          uint64_t v310 = v139[28];
          if (v310) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v310 + 8), 1uLL, memory_order_relaxed);
          }
          unsigned int v311 = (std::__shared_weak_count *)v309[1];
          void *v309 = v308;
          v309[1] = v310;
          if (v311 && !atomic_fetch_add(&v311->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v311->__on_zero_shared)(v311);
            std::__shared_weak_count::__release_weak(v311);
          }
          uint64_t v312 = v147[8];
          *(void *)(v312 + 24) = 0;
          uint64_t v313 = v139[29];
          *(void *)(v312 + 16) = v313;
          uint64_t v314 = v147[20];
          uint64_t v315 = v139[30];
          if (v315) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v315 + 8), 1uLL, memory_order_relaxed);
          }
          unsigned int v316 = *(std::__shared_weak_count **)(v314 + 24);
          *(void *)(v314 + 16) = v313;
          *(void *)(v314 + 24) = v315;
          if (v316 && !atomic_fetch_add(&v316->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v316->__on_zero_shared)(v316);
            std::__shared_weak_count::__release_weak(v316);
          }
          goto LABEL_367;
        }
      }
      if (!atomic_fetch_add(&v295->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v295->__on_zero_shared)(v295);
        std::__shared_weak_count::__release_weak(v295);
      }
      goto LABEL_418;
    }
    unint64_t v173 = *v144;
    uint64_t v175 = **v144;
    uint64_t v174 = (*v144)[1];
    if (v174 == v175)
    {
      uint64_t v205 = v173[11];
      if (!v205) {
        goto LABEL_552;
      }
      long long v147 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v205 + 48))(v205);
      float v176 = (void *)v173[5];
      unint64_t v206 = v173[6];
      if ((unint64_t)v176 >= v206)
      {
        uint64_t v222 = v173[4];
        uint64_t v223 = ((uint64_t)v176 - v222) >> 3;
        unint64_t v224 = v223 + 1;
        if ((unint64_t)(v223 + 1) >> 61) {
LABEL_553:
        }
          abort();
        uint64_t v225 = v206 - v222;
        if (v225 >> 2 > v224) {
          unint64_t v224 = v225 >> 2;
        }
        if ((unint64_t)v225 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v226 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v226 = v224;
        }
        if (v226)
        {
          uint64_t v227 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v173[7] + 16))(v173[7], 8 * v226, 8);
          double v184 = (void *)(v227 + 8 * v223);
          uint64_t v185 = v227 + 8 * v226;
          if (v227) {
            *double v184 = v147;
          }
        }
        else
        {
          uint64_t v185 = 0;
          double v184 = (void *)(8 * v223);
        }
        uint64_t v279 = v173[4];
        uint64_t v239 = v173[5];
        uint64_t v280 = v239 - v279;
        if (v239 != v279)
        {
          unint64_t v281 = v280 - 8;
          if ((unint64_t)(v280 - 8) < 0x38)
          {
            unint64_t v243 = v184;
          }
          else
          {
            unint64_t v243 = v184;
            if ((unint64_t)(v239 - (void)v184) >= 0x20)
            {
              uint64_t v282 = (v281 >> 3) + 1;
              uint64_t v283 = v184 - 2;
              uint64_t v284 = (long long *)(v239 - 16);
              uint64_t v285 = v282 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v286 = *v284;
                *(v283 - 1) = *(v284 - 1);
                *uint64_t v283 = v286;
                v283 -= 2;
                v284 -= 2;
                v285 -= 4;
              }
              while (v285);
              unint64_t v243 = &v184[-(v282 & 0x3FFFFFFFFFFFFFFCLL)];
              v239 -= 8 * (v282 & 0x3FFFFFFFFFFFFFFCLL);
              if (v282 == (v282 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_426;
              }
            }
          }
          do
          {
            uint64_t v300 = *(void *)(v239 - 8);
            v239 -= 8;
            *--unint64_t v243 = v300;
          }
          while (v239 != v279);
          goto LABEL_426;
        }
LABEL_391:
        unint64_t v243 = v184;
        goto LABEL_427;
      }
    }
    else
    {
      long long v147 = *(void **)(v174 - 8);
      v173[1] = v174 - 8;
      float v176 = (void *)v173[5];
      unint64_t v177 = v173[6];
      if ((unint64_t)v176 >= v177)
      {
        uint64_t v178 = v173[4];
        uint64_t v179 = ((uint64_t)v176 - v178) >> 3;
        unint64_t v180 = v179 + 1;
        if ((unint64_t)(v179 + 1) >> 61) {
          goto LABEL_553;
        }
        uint64_t v181 = v177 - v178;
        if (v181 >> 2 > v180) {
          unint64_t v180 = v181 >> 2;
        }
        if ((unint64_t)v181 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v182 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v182 = v180;
        }
        if (v182)
        {
          uint64_t v183 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v173[7] + 16))(v173[7], 8 * v182, 8);
          double v184 = (void *)(v183 + 8 * v179);
          uint64_t v185 = v183 + 8 * v182;
          if (v183) {
            *double v184 = v147;
          }
        }
        else
        {
          uint64_t v185 = 0;
          double v184 = (void *)(8 * v179);
        }
        uint64_t v240 = v173[4];
        uint64_t v239 = v173[5];
        uint64_t v241 = v239 - v240;
        if (v239 != v240)
        {
          unint64_t v242 = v241 - 8;
          if ((unint64_t)(v241 - 8) < 0x38)
          {
            unint64_t v243 = v184;
          }
          else
          {
            unint64_t v243 = v184;
            if ((unint64_t)(v239 - (void)v184) >= 0x20)
            {
              uint64_t v244 = (v242 >> 3) + 1;
              unint64_t v245 = v184 - 2;
              unint64_t v246 = (long long *)(v239 - 16);
              uint64_t v247 = v244 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v248 = *v246;
                *(v245 - 1) = *(v246 - 1);
                *unint64_t v245 = v248;
                v245 -= 2;
                v246 -= 2;
                v247 -= 4;
              }
              while (v247);
              unint64_t v243 = &v184[-(v244 & 0x3FFFFFFFFFFFFFFCLL)];
              v239 -= 8 * (v244 & 0x3FFFFFFFFFFFFFFCLL);
              if (v244 == (v244 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_426;
              }
            }
          }
          do
          {
            uint64_t v288 = *(void *)(v239 - 8);
            v239 -= 8;
            *--unint64_t v243 = v288;
          }
          while (v239 != v240);
LABEL_426:
          uint64_t v239 = v173[4];
LABEL_427:
          std::string::size_type v207 = v184 + 1;
          v173[4] = (uint64_t)v243;
          v173[5] = (uint64_t)(v184 + 1);
          uint64_t v301 = v173[6];
          v173[6] = v185;
          if (v239) {
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v173[7] + 40))(v173[7], v239, v301 - v239);
          }
          goto LABEL_429;
        }
        goto LABEL_391;
      }
    }
    if (v176) {
      *float v176 = v147;
    }
    std::string::size_type v207 = v176 + 1;
LABEL_429:
    v173[5] = (uint64_t)v207;
    v365.__r_.__value_.__r.__words[0] = (std::string::size_type)v147;
    uint64_t v302 = v173[15];
    if (!v302) {
      goto LABEL_552;
    }
    (*(void (**)(uint64_t, std::string *))(*(void *)v302 + 48))(v302, &v365);
    uint64_t v303 = *((void *)this + 46);
    uint64_t v305 = *(void *)(v303 + 48);
    unsigned int v304 = *(std::__shared_weak_count **)(v303 + 56);
    if (v304) {
      atomic_fetch_add_explicit(&v304->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v305 && **(void **)(v305 + 40) == v147[1])
    {
      uint64_t v307 = v147[2];
      if (v307 && v307 != v305) {
        ggl::PipelineSetup::resetData((uint64_t)v147);
      }
      if (v304) {
        atomic_fetch_add_explicit(&v304->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unsigned int v306 = (std::__shared_weak_count *)v147[3];
      v147[2] = v305;
      v147[3] = v304;
      if (!v306) {
        goto LABEL_444;
      }
    }
    else
    {
      unsigned int v306 = (std::__shared_weak_count *)v147[3];
      v147[2] = 0;
      v147[3] = 0;
      if (!v306)
      {
LABEL_444:
        if (v304 && !atomic_fetch_add(&v304->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v304->__on_zero_shared)(v304);
          std::__shared_weak_count::__release_weak(v304);
        }
        *(void *)v147[12] = v140;
        uint64_t v297 = (void *)v147[8];
        goto LABEL_448;
      }
    }
    if (!atomic_fetch_add(&v306->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v306->__on_zero_shared)(v306);
      std::__shared_weak_count::__release_weak(v306);
    }
    goto LABEL_444;
  }
  if (v118)
  {
LABEL_459:
    if (!atomic_fetch_add(&v118->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v118->__on_zero_shared)(v118);
      std::__shared_weak_count::__release_weak(v118);
    }
  }
LABEL_461:
  if (!v374)
  {
LABEL_552:
    std::__throw_bad_function_call[abi:nn180100]();
    goto LABEL_555;
  }
  (*(void (**)(void *))(*v374 + 48))(v374);
  if (v374 == v373)
  {
    (*(void (**)(void *))(v373[0] + 32))(v373);
  }
  else if (v374)
  {
    (*(void (**)(void))(*v374 + 40))();
  }
}

void sub_1A23B4AEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,char a36)
{
  gss::QueryOverrides::~QueryOverrides((gss::QueryOverrides *)&__p);
  if (a24) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a27 + 40))(a27, a24, a26 - a24);
  }

  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)(v37 - 144));
  _Unwind_Resume(a1);
}

void std::__function::__func<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  unsigned int v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)int8x8_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "RasterLayout", "", v5, 2u);
  }
}

uint64_t md::RasterRenderLayer::shouldEnableCLUT(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1)
  {
    uint64_t v7 = 0;
    uint64_t v32 = 0;
    goto LABEL_56;
  }
  uint64_t v2 = *(void *)(v1 + 520);
  unsigned int v3 = *(std::__shared_weak_count **)(v1 + 528);
  uint64_t v31 = v2;
  uint64_t v32 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v2)
  {
    uint64_t v7 = 0;
    goto LABEL_56;
  }
  uint64_t v4 = *(void *)(*a1 + 520);
  int8x8_t v5 = *(std::__shared_weak_count **)(*a1 + 528);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    float v6 = *(float *)(v4 + 256);
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    float v6 = *(float *)(v4 + 256);
  }
  int v8 = gss::ClientStyleState<gss::PropertyID>::sourceClientStyleAttribute(v31, 0x10001u);
  BOOL v10 = (v8 & 0xFFFF0000) != 0 && v8 == 1;
  unint64_t v11 = (geo::read_write_lock *)pthread_rwlock_rdlock((pthread_rwlock_t *)(v31 + 16));
  if (v11) {
    geo::read_write_lock::logFailure(v11, (uint64_t)"read lock", v12);
  }
  uint64_t v13 = *(unsigned __int16 *)(v31 + 242);
  if (!*(_WORD *)(v31 + 242)) {
    goto LABEL_46;
  }
  uint64_t v14 = *(void *)(v31 + 232);
  if (*(unsigned char *)(v31 + 247))
  {
    if (v13 >= 0x1E)
    {
      uint64_t v20 = *(_DWORD **)(v31 + 232);
      unint64_t v21 = *(unsigned __int16 *)(v31 + 242);
      do
      {
        unint64_t v22 = v21 >> 1;
        unsigned int v23 = &v20[v21 >> 1];
        unsigned int v25 = *v23;
        uint64_t v24 = v23 + 1;
        v21 += ~(v21 >> 1);
        if (v25 < 0x10001) {
          uint64_t v20 = v24;
        }
        else {
          unint64_t v21 = v22;
        }
      }
      while (v21);
      if (v20 == (_DWORD *)(v14 + 4 * v13)
        || *v20 != 65537
        || (unint64_t v19 = ((unint64_t)v20 - v14) >> 2, v13 == (unsigned __int16)v19))
      {
LABEL_46:
        int v27 = 0;
        char v26 = 1;
        goto LABEL_47;
      }
    }
    else
    {
      uint64_t v15 = 0;
      while (1)
      {
        unsigned int v16 = *(_DWORD *)(v14 + 4 * v15);
        if (v16 >= 0x10001) {
          break;
        }
        if (v13 == ++v15) {
          goto LABEL_46;
        }
      }
      if (v16 == 65537) {
        LOWORD(v19) = v15;
      }
      else {
        LOWORD(v19) = *(_WORD *)(v31 + 242);
      }
      if (v13 == (unsigned __int16)v19) {
        goto LABEL_46;
      }
    }
  }
  else
  {
    uint64_t v17 = 4 * v13;
    unint64_t v18 = *(_DWORD **)(v31 + 232);
    while (*v18 != 65537)
    {
      ++v18;
      v17 -= 4;
      if (!v17)
      {
        unint64_t v18 = (_DWORD *)(v14 + 4 * v13);
        break;
      }
    }
    unint64_t v19 = ((unint64_t)v18 - v14) >> 2;
    if (v13 == (unsigned __int16)v19) {
      goto LABEL_46;
    }
  }
  char v26 = 0;
  int v27 = *(unsigned __int8 *)(*(void *)(v31 + 232) + *(unsigned __int16 *)(v31 + 240) + 2 * (unsigned __int16)v19);
LABEL_47:
  unint64_t v28 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(v31 + 16));
  if (v28) {
    geo::read_write_lock::logFailure(v28, (uint64_t)"unlock", v29);
  }
  if ((v26 & 1) != 0 || v6 <= 0.0 || v27 != 1) {
    uint64_t v7 = v6 < 1.0 && v10;
  }
  else {
    uint64_t v7 = 1;
  }
LABEL_56:
  if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
    std::__shared_weak_count::__release_weak(v32);
  }
  return v7;
}

void sub_1A23B50B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::__function::__func<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_2,std::allocator<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_2>,void ()(md::StyleManagerEvent)>::operator()(uint64_t a1, unsigned __int8 *a2)
{
  if ((*a2 | 4) == 4)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if ((md::RasterRenderLayer::shouldEnableCLUT(*(uint64_t **)(a1 + 16)) & 1) == 0)
    {
      uint64_t v3 = *(void *)(v2 + 368);
      uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
      *(void *)(v3 + 8) = 0;
      *(void *)(v3 + 16) = 0;
      if (v4)
      {
        if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
    }
  }
}

__n128 std::__function::__func<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_2,std::allocator<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_2>,void ()(md::StyleManagerEvent)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF573308;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_2,std::allocator<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_2>,void ()(md::StyleManagerEvent)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF573308;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_2,std::allocator<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_2>,void ()(md::StyleManagerEvent)>::~__func()
{
}

void std::__function::__func<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)int8x8_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "RasterLayout", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5732C0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5732C0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF573278;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF573278;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::RasterRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::~__func()
{
}

void md::RasterRenderLayer::~RasterRenderLayer(md::RasterRenderLayer *this)
{
  *(void *)this = &unk_1EF537768;
  uint64_t v2 = (md::RasterRenderResources *)*((void *)this + 47);
  *((void *)this + 47) = 0;
  if (v2)
  {
    md::RasterRenderResources::~RasterRenderResources(v2);
    MEMORY[0x1A6239270]();
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 45);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  md::CartographicTiledRenderLayer<md::MapTileDataRenderable<md::RasterTileData>>::~CartographicTiledRenderLayer((uint64_t)this);
  JUMPOUT(0x1A6239270);
}

{
  md::RasterRenderResources *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF537768;
  uint64_t v2 = (md::RasterRenderResources *)*((void *)this + 47);
  *((void *)this + 47) = 0;
  if (v2)
  {
    md::RasterRenderResources::~RasterRenderResources(v2);
    MEMORY[0x1A6239270]();
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 45);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  md::CartographicTiledRenderLayer<md::MapTileDataRenderable<md::RasterTileData>>::~CartographicTiledRenderLayer((uint64_t)this);
}

void md::RasterRenderResources::~RasterRenderResources(md::RasterRenderResources *this)
{
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::RenderItem>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  uint64_t v4 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v4)
  {
    uint64_t v5 = ggl::FragmentedPool<ggl::TextureWithReverseAlpha::Pos2DUVPipelineSetup>::~FragmentedPool(v4);
    MEMORY[0x1A6239270](v5, 0x10A0C40D234DDC7);
  }
  uint64_t v6 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v6)
  {
    uint64_t v7 = ggl::FragmentedPool<ggl::Clut::Pos2DUVPipelineSetup>::~FragmentedPool(v6);
    MEMORY[0x1A6239270](v7, 0x10A0C40D234DDC7);
  }
  uint64_t v8 = *(void *)this;
  *(void *)this = 0;
  if (v8)
  {
    uint64_t v9 = ggl::FragmentedPool<ggl::Textured::Pos2DUVPipelineSetup>::~FragmentedPool(v8);
    MEMORY[0x1A6239270](v9, 0x10A0C40D234DDC7);
  }
}

uint64_t ggl::FragmentedPool<ggl::TextureWithReverseAlpha::Pos2DUVPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Clut::Pos2DUVPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Textured::Pos2DUVPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_23TextureWithReverseAlpha20Pos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF57BBC8;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_23TextureWithReverseAlpha20Pos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_3,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_3>,ggl::TextureWithReverseAlpha::Pos2DUVPipelineSetup * ()(void)>::operator()()
{
}

void ggl::ConstantDataTyped<ggl::TextureWithReverseAlpha::ReverseAlpha>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::TextureWithReverseAlpha::ReverseAlpha>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::TextureWithReverseAlpha::ReverseAlpha>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::TextureWithReverseAlpha::ReverseAlpha>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586B88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::TextureWithReverseAlpha::ReverseAlpha>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586B88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_3,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_3>,ggl::TextureWithReverseAlpha::Pos2DUVPipelineSetup * ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF5757E0;
  return result;
}

void std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_3,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_3>,ggl::TextureWithReverseAlpha::Pos2DUVPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_4Clut20Pos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF57BEE0;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_4Clut20Pos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_2,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_2>,ggl::Clut::Pos2DUVPipelineSetup * ()(void)>::operator()()
{
}

void ggl::ConstantDataTyped<ggl::Clut::Variation>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::Clut::Variation>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Clut::Variation>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Clut::Variation>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586CA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Clut::Variation>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586CA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_2,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_2>,ggl::Clut::Pos2DUVPipelineSetup * ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF575798;
  return result;
}

void std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_2,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_2>,ggl::Clut::Pos2DUVPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured20Pos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF57C6C0;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured20Pos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_1,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_1>,ggl::Textured::Pos2DUVPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_1,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_1>,ggl::Textured::Pos2DUVPipelineSetup * ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF575750;
  return result;
}

void std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_1,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_1>,ggl::Textured::Pos2DUVPipelineSetup * ()(void)>::~__func()
{
}

void std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_0,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_0>,ggl::RenderItem * ()(void)>::operator()()
{
}

void *std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_0,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_0>,ggl::RenderItem * ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF575708;
  return result;
}

void std::__function::__func<md::RasterRenderResources::RasterRenderResources(void)::$_0,std::allocator<md::RasterRenderResources::RasterRenderResources(void)::$_0>,ggl::RenderItem * ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::TextureWithReverseAlpha::Pos2DUVPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::TextureWithReverseAlpha::Pos2DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588868;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::TextureWithReverseAlpha::Pos2DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588868;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Clut::Pos2DUVPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Clut::Pos2DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588DE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Clut::Pos2DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588DE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Textured::Pos2DUVPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Textured::Pos2DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589B00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Textured::Pos2DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589B00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::RasterSharedRenderResourcesInternal::~RasterSharedRenderResourcesInternal(md::RasterSharedRenderResourcesInternal *this)
{
  md::RasterSharedRenderResourcesInternal::~RasterSharedRenderResourcesInternal(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;

  *(void *)this = &unk_1EF54F138;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 11);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 11);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 7);
    if (!v5) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 7);
    if (!v5) {
      goto LABEL_13;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_13:
  uint64_t v6 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v9)
  {
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

BOOL std::__function::__func<md::RasterRenderLayer::RasterRenderLayer(md::CartographicRenderer &,md::RasterRenderLayerType,std::shared_ptr<md::RasterSharedRenderResources> const&)::$_0,std::allocator<md::RasterRenderLayer::RasterRenderLayer(md::CartographicRenderer &,md::RasterRenderLayerType,std::shared_ptr<md::RasterSharedRenderResources> const&)::$_0>,BOOL ()(md::MapTileDataRenderable<md::RasterTileData> *,md::MapTileDataRenderable<md::RasterTileData> *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)a2 + 384) + 169) > *(unsigned __int8 *)(*(void *)(*(void *)a3 + 384) + 169);
}

void *std::__function::__func<md::RasterRenderLayer::RasterRenderLayer(md::CartographicRenderer &,md::RasterRenderLayerType,std::shared_ptr<md::RasterSharedRenderResources> const&)::$_0,std::allocator<md::RasterRenderLayer::RasterRenderLayer(md::CartographicRenderer &,md::RasterRenderLayerType,std::shared_ptr<md::RasterSharedRenderResources> const&)::$_0>,BOOL ()(md::MapTileDataRenderable<md::RasterTileData> *,md::MapTileDataRenderable<md::RasterTileData> *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF573350;
  return result;
}

void std::__function::__func<md::RasterRenderLayer::RasterRenderLayer(md::CartographicRenderer &,md::RasterRenderLayerType,std::shared_ptr<md::RasterSharedRenderResources> const&)::$_0,std::allocator<md::RasterRenderLayer::RasterRenderLayer(md::CartographicRenderer &,md::RasterRenderLayerType,std::shared_ptr<md::RasterSharedRenderResources> const&)::$_0>,BOOL ()(md::MapTileDataRenderable<md::RasterTileData> *,md::MapTileDataRenderable<md::RasterTileData> *)>::~__func()
{
}

uint64_t karo::graphics::FreezeViewNode::computeView(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 48);
  if (!v3) {
    return v3;
  }
  if (*(unsigned char *)(a1 + 56))
  {
    if (*(unsigned char *)(a1 + 57))
    {
      uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24))(v2);
      karo::graphics::View::copyView(*(void *)(a1 + 48), v4);
      *(unsigned char *)(a1 + 57) = 0;
      return *(void *)(a1 + 48);
    }
    return v3;
  }
  uint64_t v6 = *(uint64_t (**)(void))(*(void *)v2 + 24);
  return v6();
}

void karo::graphics::FreezeViewNode::~FreezeViewNode(void **this)
{
  *this = &unk_1EF567F78;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x1A6239270);
}

{
  *this = &unk_1EF567F78;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

uint64_t md::SceneQueryLogic::debugConsoleString@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, void *a3@<X8>)
{
  uint64_t v117 = *MEMORY[0x1E4F143B8];
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v79);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"\n===== SceneQueryLogic =====\n", 29);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"HasBaseQuery:", 13);
  uint64_t v5 = *(void *)(a1 + 320);
  if (v5) {
    uint64_t v6 = "YES";
  }
  else {
    uint64_t v6 = "NO";
  }
  if (v5) {
    uint64_t v7 = 3;
  }
  else {
    uint64_t v7 = 2;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)v6, v7);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"== RouteLineMasking ==\n", 23);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"Allowed:", 8);
  if (*(unsigned char *)(a1 + 121)) {
    uint64_t v8 = "YES";
  }
  else {
    uint64_t v8 = "NO";
  }
  if (*(unsigned char *)(a1 + 121)) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = 2;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)v8, v9);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)" ", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"Active:", 7);
  if (*(unsigned char *)(a2 + 64)) {
    BOOL v10 = "YES";
  }
  else {
    BOOL v10 = "NO";
  }
  if (*(unsigned char *)(a2 + 64)) {
    uint64_t v11 = 3;
  }
  else {
    uint64_t v11 = 2;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)v10, v11);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)" ", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"HasQuery:", 9);
  uint64_t v12 = *(void *)(a1 + 352);
  if (v12) {
    uint64_t v13 = "YES";
  }
  else {
    uint64_t v13 = "NO";
  }
  if (v12) {
    uint64_t v14 = 3;
  }
  else {
    uint64_t v14 = 2;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)v13, v14);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"== SpatialFlexing ==\n", 21);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"Allowed:", 8);
  if (*(unsigned char *)(a1 + 120)) {
    uint64_t v15 = "YES";
  }
  else {
    uint64_t v15 = "NO";
  }
  if (*(unsigned char *)(a1 + 120)) {
    uint64_t v16 = 3;
  }
  else {
    uint64_t v16 = 2;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)v15, v16);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)" ", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"Active:", 7);
  if (*(unsigned char *)(a2 + 65)) {
    uint64_t v17 = "YES";
  }
  else {
    uint64_t v17 = "NO";
  }
  if (*(unsigned char *)(a2 + 65)) {
    uint64_t v18 = 3;
  }
  else {
    uint64_t v18 = 2;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)v17, v18);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)" ", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"HasQuery:", 9);
  uint64_t v19 = *(void *)(a1 + 336);
  if (v19) {
    uint64_t v20 = "YES";
  }
  else {
    uint64_t v20 = "NO";
  }
  if (v19) {
    uint64_t v21 = 3;
  }
  else {
    uint64_t v21 = 2;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)v20, v21);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"\n", 1);
  if (*(void *)(a1 + 248) != *(void *)(a1 + 256))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"FlexBuckets:\n", 13);
    unint64_t v22 = *(unsigned __int8 **)(a1 + 248);
    for (uint64_t i = *(unsigned __int8 **)(a1 + 256); v22 != i; v22 += 12)
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"  ", 2);
      uint64_t v24 = gss::to_string(*v22);
      size_t v25 = strlen(v24);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)v24, v25);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)":", 1);
      char v26 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v26, (uint64_t)" - ", 3);
      if (*((_DWORD *)v22 + 2) == -1) {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"MAX", 3);
      }
      else {
        std::ostream::operator<<();
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"\n", 1);
    }
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"Registries Processed:", 21);
  int v27 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"Entities Processed:", 19);
  unint64_t v28 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v28, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"Pending:", 8);
  unint64_t v29 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v29, (uint64_t)"\n", 1);
  if (*(void *)(a1 + 472))
  {
    uint64_t v30 = *(void **)(a1 + 456);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"[", 1);
    uint64_t v31 = (char *)v79 + *(void *)(v79[0] - 24);
    if ((v31[32] & 5) != 0)
    {
      long long v114 = 0u;
      long long v115 = 0u;
      long long v112 = 0u;
      long long v113 = 0u;
      long long v110 = 0u;
      long long v111 = 0u;
      long long v108 = 0u;
      long long v109 = 0u;
      uint64_t v116 = -1;
    }
    else
    {
      (*(void (**)(long long *__return_ptr))(**((void **)v31 + 5) + 32))(&v108);
    }
    if (v30 != (void *)(a1 + 464))
    {
      while (1)
      {
        uint64_t v32 = (char *)v79 + *(void *)(v79[0] - 24);
        if ((v32[32] & 5) != 0)
        {
          long long v105 = 0u;
          long long v106 = 0u;
          long long v103 = 0u;
          long long v104 = 0u;
          long long v101 = 0u;
          long long v102 = 0u;
          long long v99 = 0u;
          long long v100 = 0u;
          uint64_t v107 = -1;
        }
        else
        {
          (*(void (**)(long long *__return_ptr))(**((void **)v32 + 5) + 32))(&v99);
        }
        std::ostream::operator<<();
        uint64_t v33 = (char *)v79 + *(void *)(v79[0] - 24);
        if ((v33[32] & 5) != 0)
        {
          long long v96 = 0u;
          long long v97 = 0u;
          long long v94 = 0u;
          long long v95 = 0u;
          long long v92 = 0u;
          long long v93 = 0u;
          long long v90 = 0u;
          long long v91 = 0u;
          uint64_t v98 = -1;
        }
        else
        {
          (*(void (**)(long long *__return_ptr))(**((void **)v33 + 5) + 32))(&v90);
        }
        long long v34 = (void *)v30[1];
        if (v34)
        {
          do
          {
            uint64_t v35 = v34;
            long long v34 = (void *)*v34;
          }
          while (v34);
        }
        else
        {
          do
          {
            uint64_t v35 = (void *)v30[2];
            BOOL v36 = *v35 == (void)v30;
            uint64_t v30 = v35;
          }
          while (!v36);
        }
        if (v35 == (void *)(a1 + 464)) {
          break;
        }
        if (v98 > v107)
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)",", 1);
          if (v98 - v116 >= 41)
          {
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"\n", 1);
            BYTE7(v77) = 2;
            strcpy((char *)__p, "  ");
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)__p, 2);
            if (SBYTE7(v77) < 0) {
              operator delete(__p[0]);
            }
            long long v114 = v96;
            long long v115 = v97;
            uint64_t v116 = v98;
            long long v110 = v92;
            long long v111 = v93;
            long long v112 = v94;
            long long v113 = v95;
            long long v108 = v90;
            long long v109 = v91;
          }
        }
        uint64_t v30 = v35;
      }
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"]", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"\n", 1);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"Modified:", 9);
  uint64_t v37 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v37, (uint64_t)"\n", 1);
  uint64_t v38 = *(void **)(a1 + 152);
  if (v38[48] != v38[49])
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"Modified(Active):\n", 18);
    uint64_t v39 = *(void **)(a1 + 480);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"[", 1);
    unint64_t v40 = (char *)v79 + *(void *)(v79[0] - 24);
    if ((v40[32] & 5) != 0)
    {
      long long v114 = 0u;
      long long v115 = 0u;
      long long v112 = 0u;
      long long v113 = 0u;
      long long v110 = 0u;
      long long v111 = 0u;
      long long v108 = 0u;
      long long v109 = 0u;
      uint64_t v116 = -1;
    }
    else
    {
      (*(void (**)(long long *__return_ptr))(**((void **)v40 + 5) + 32))(&v108);
    }
    if (v39 != (void *)(a1 + 488))
    {
      while (1)
      {
        uint64_t v41 = (char *)v79 + *(void *)(v79[0] - 24);
        if ((v41[32] & 5) != 0)
        {
          long long v105 = 0u;
          long long v106 = 0u;
          long long v103 = 0u;
          long long v104 = 0u;
          long long v101 = 0u;
          long long v102 = 0u;
          long long v99 = 0u;
          long long v100 = 0u;
          uint64_t v107 = -1;
        }
        else
        {
          (*(void (**)(long long *__return_ptr))(**((void **)v41 + 5) + 32))(&v99);
        }
        uint64_t v43 = (void *)v38[48];
        uint64_t v42 = (void *)v38[49];
        if (v43 != v42)
        {
          while (*v43 != v39[5])
          {
            if (++v43 == v42)
            {
              uint64_t v43 = (void *)v38[49];
              break;
            }
          }
        }
        if (v43 != v42) {
          std::ostream::operator<<();
        }
        uint64_t v44 = (char *)v79 + *(void *)(v79[0] - 24);
        if ((v44[32] & 5) != 0)
        {
          long long v96 = 0u;
          long long v97 = 0u;
          long long v94 = 0u;
          long long v95 = 0u;
          long long v92 = 0u;
          long long v93 = 0u;
          long long v90 = 0u;
          long long v91 = 0u;
          uint64_t v98 = -1;
        }
        else
        {
          (*(void (**)(long long *__return_ptr))(**((void **)v44 + 5) + 32))(&v90);
        }
        uint64_t v45 = (void *)v39[1];
        if (v45)
        {
          do
          {
            uint64_t v46 = v45;
            uint64_t v45 = (void *)*v45;
          }
          while (v45);
        }
        else
        {
          do
          {
            uint64_t v46 = (void *)v39[2];
            BOOL v36 = *v46 == (void)v39;
            uint64_t v39 = v46;
          }
          while (!v36);
        }
        if (v46 == (void *)(a1 + 488)) {
          break;
        }
        if (v98 > v107)
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)",", 1);
          if (v98 - v116 >= 41)
          {
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"\n", 1);
            BYTE7(v77) = 2;
            strcpy((char *)__p, "  ");
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)__p, 2);
            if (SBYTE7(v77) < 0) {
              operator delete(__p[0]);
            }
            long long v114 = v96;
            long long v115 = v97;
            uint64_t v116 = v98;
            long long v110 = v92;
            long long v111 = v93;
            long long v112 = v94;
            long long v113 = v95;
            long long v108 = v90;
            long long v109 = v91;
          }
        }
        uint64_t v39 = v46;
      }
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"]", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"\n", 1);
    uint64_t v38 = *(void **)(a1 + 152);
  }
  if (v38[60] != v38[61])
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"Modified(Cached):\n", 18);
    uint64_t v47 = *(void **)(a1 + 480);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"[", 1);
    uint64_t v48 = (char *)v79 + *(void *)(v79[0] - 24);
    if ((v48[32] & 5) != 0)
    {
      long long v114 = 0u;
      long long v115 = 0u;
      long long v112 = 0u;
      long long v113 = 0u;
      long long v110 = 0u;
      long long v111 = 0u;
      long long v108 = 0u;
      long long v109 = 0u;
      uint64_t v116 = -1;
    }
    else
    {
      (*(void (**)(long long *__return_ptr))(**((void **)v48 + 5) + 32))(&v108);
    }
    if (v47 != (void *)(a1 + 488))
    {
      while (1)
      {
        uint64_t v49 = (char *)v79 + *(void *)(v79[0] - 24);
        if ((v49[32] & 5) != 0)
        {
          long long v105 = 0u;
          long long v106 = 0u;
          long long v103 = 0u;
          long long v104 = 0u;
          long long v101 = 0u;
          long long v102 = 0u;
          long long v99 = 0u;
          long long v100 = 0u;
          uint64_t v107 = -1;
        }
        else
        {
          (*(void (**)(long long *__return_ptr))(**((void **)v49 + 5) + 32))(&v99);
        }
        unint64_t v51 = (void *)v38[60];
        uint64_t v50 = (void *)v38[61];
        if (v51 != v50)
        {
          while (*v51 != v47[5])
          {
            if (++v51 == v50)
            {
              unint64_t v51 = (void *)v38[61];
              break;
            }
          }
        }
        if (v51 != v50) {
          std::ostream::operator<<();
        }
        uint64_t v52 = (char *)v79 + *(void *)(v79[0] - 24);
        if ((v52[32] & 5) != 0)
        {
          long long v96 = 0u;
          long long v97 = 0u;
          long long v94 = 0u;
          long long v95 = 0u;
          long long v92 = 0u;
          long long v93 = 0u;
          long long v90 = 0u;
          long long v91 = 0u;
          uint64_t v98 = -1;
        }
        else
        {
          (*(void (**)(long long *__return_ptr))(**((void **)v52 + 5) + 32))(&v90);
        }
        uint64_t v53 = (void *)v47[1];
        if (v53)
        {
          do
          {
            uint64_t v54 = v53;
            uint64_t v53 = (void *)*v53;
          }
          while (v53);
        }
        else
        {
          do
          {
            uint64_t v54 = (void *)v47[2];
            BOOL v36 = *v54 == (void)v47;
            uint64_t v47 = v54;
          }
          while (!v36);
        }
        if (v54 == (void *)(a1 + 488)) {
          break;
        }
        if (v98 > v107)
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)",", 1);
          if (v98 - v116 >= 41)
          {
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"\n", 1);
            BYTE7(v77) = 2;
            strcpy((char *)__p, "  ");
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)__p, 2);
            if (SBYTE7(v77) < 0) {
              operator delete(__p[0]);
            }
            long long v114 = v96;
            long long v115 = v97;
            uint64_t v116 = v98;
            long long v110 = v92;
            long long v111 = v93;
            long long v112 = v94;
            long long v113 = v95;
            long long v108 = v90;
            long long v109 = v91;
          }
        }
        uint64_t v47 = v54;
      }
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"]", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"\n", 1);
  }
  if (*(void *)(a1 + 528))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"CacheHits:\n", 11);
    *(_OWORD *)std::vector<unsigned int> __p = 0u;
    long long v77 = 0u;
    int v78 = 1065353216;
    uint64_t v55 = *(uint64_t **)(a1 + 520);
    if (v55)
    {
      do
      {
        uint64_t v56 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)__p, *((_DWORD *)v55 + 5), (_DWORD *)v55 + 5);
        ++*((_DWORD *)v56 + 5);
        uint64_t v55 = (uint64_t *)*v55;
      }
      while (v55);
      long long v57 = (void *)v77;
    }
    else
    {
      long long v57 = 0;
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"[", 1);
    uint64_t v58 = (char *)v79 + *(void *)(v79[0] - 24);
    if ((v58[32] & 5) != 0)
    {
      long long v114 = 0u;
      long long v115 = 0u;
      long long v112 = 0u;
      long long v113 = 0u;
      long long v110 = 0u;
      long long v111 = 0u;
      long long v108 = 0u;
      long long v109 = 0u;
      uint64_t v116 = -1;
    }
    else
    {
      (*(void (**)(long long *__return_ptr))(**((void **)v58 + 5) + 32))(&v108);
    }
    if (v57)
    {
      while (1)
      {
        uint64_t v59 = (char *)v79 + *(void *)(v79[0] - 24);
        if ((v59[32] & 5) != 0)
        {
          long long v105 = 0u;
          long long v106 = 0u;
          long long v103 = 0u;
          long long v104 = 0u;
          long long v101 = 0u;
          long long v102 = 0u;
          long long v99 = 0u;
          long long v100 = 0u;
          uint64_t v107 = -1;
        }
        else
        {
          (*(void (**)(long long *__return_ptr))(**((void **)v59 + 5) + 32))(&v99);
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"(", 1);
        uint64_t v60 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v60, (uint64_t)",", 1);
        unint64_t v61 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v61, (uint64_t)")", 1);
        uint64_t v62 = (char *)v79 + *(void *)(v79[0] - 24);
        if ((v62[32] & 5) != 0)
        {
          long long v96 = 0u;
          long long v97 = 0u;
          long long v94 = 0u;
          long long v95 = 0u;
          long long v92 = 0u;
          long long v93 = 0u;
          long long v90 = 0u;
          long long v91 = 0u;
          uint64_t v98 = -1;
        }
        else
        {
          (*(void (**)(long long *__return_ptr))(**((void **)v62 + 5) + 32))(&v90);
        }
        long long v57 = (void *)*v57;
        if (!v57) {
          break;
        }
        if (v98 > v107)
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)",", 1);
          if (v98 - v116 >= 41)
          {
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"\n", 1);
            char v89 = 2;
            strcpy((char *)v88, "  ");
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)v88, 2);
            if (v89 < 0) {
              operator delete(v88[0]);
            }
            long long v114 = v96;
            long long v115 = v97;
            uint64_t v116 = v98;
            long long v110 = v92;
            long long v111 = v93;
            long long v112 = v94;
            long long v113 = v95;
            long long v108 = v90;
            long long v109 = v91;
          }
        }
      }
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"]", 1);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"\n", 1);
    uint64_t v63 = (void *)v77;
    if ((void)v77)
    {
      do
      {
        uint64_t v64 = (void *)*v63;
        operator delete(v63);
        uint64_t v63 = v64;
      }
      while (v64);
    }
    uint64_t v65 = __p[0];
    __p[0] = 0;
    if (v65) {
      operator delete(v65);
    }
  }
  if ((v86 & 0x10) != 0)
  {
    unint64_t v68 = v85;
    if (v85 < v82)
    {
      unint64_t v85 = v82;
      unint64_t v68 = v82;
    }
    uint64_t v69 = (const void **)&v81;
  }
  else
  {
    if ((v86 & 8) == 0)
    {
      size_t v66 = 0;
      uint64_t v67 = a3;
      *((unsigned char *)a3 + 23) = 0;
      goto LABEL_177;
    }
    uint64_t v69 = (const void **)v80;
    unint64_t v68 = v80[2];
  }
  uint64_t v67 = a3;
  uint64_t v70 = *v69;
  size_t v66 = v68 - (void)*v69;
  if (v66 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v66 >= 0x17)
  {
    uint64_t v71 = (v66 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v66 | 7) != 0x17) {
      uint64_t v71 = v66 | 7;
    }
    uint64_t v72 = v71 + 1;
    uint64_t v73 = operator new(v71 + 1);
    a3[1] = v66;
    a3[2] = v72 | 0x8000000000000000;
    *a3 = v73;
    uint64_t v67 = v73;
    goto LABEL_176;
  }
  *((unsigned char *)a3 + 23) = v66;
  if (v66) {
LABEL_176:
  }
    memmove(v67, v70, v66);
LABEL_177:
  *((unsigned char *)v67 + v66) = 0;
  v79[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v79 + *(void *)(v79[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v79[1] = MEMORY[0x1E4FBA470] + 16;
  if (v84 < 0) {
    operator delete(v83);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v87);
}

void sub_1A23B8350(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
}

void std::__shared_ptr_emplace<md::RouteLineMaskDesc>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580528;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::RouteLineMaskDesc>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580528;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::SceneQueryLogic::updatePendingRegistries(uint64_t a1, int8x8_t ***a2)
{
  uint64_t v4 = *(void *)(a1 + 152);
  uint64_t v5 = *(void *)(v4 + 408);
  uint64_t v6 = *(void *)(v4 + 416);
  if (v5 != v6)
  {
    uint64_t v7 = *(uint64_t **)(a1 + 464);
    if (v7)
    {
      uint64_t v8 = (uint64_t **)(a1 + 464);
LABEL_4:
      unsigned int v9 = *(unsigned __int16 *)(*(void *)v5 + 40);
      BOOL v10 = (uint64_t *)(a1 + 464);
      uint64_t v11 = v7;
      do
      {
        unsigned int v12 = *(unsigned __int16 *)(v11[4] + 40);
        BOOL v13 = v12 >= v9;
        if (v12 >= v9) {
          uint64_t v14 = (uint64_t **)v11;
        }
        else {
          uint64_t v14 = (uint64_t **)(v11 + 1);
        }
        if (v13) {
          BOOL v10 = v11;
        }
        uint64_t v11 = *v14;
      }
      while (*v14);
      if (v10 != (uint64_t *)v8 && v9 >= *(unsigned __int16 *)(v10[4] + 40))
      {
        uint64_t v15 = (uint64_t *)v10[1];
        uint64_t v16 = v10;
        if (v15)
        {
          do
          {
            uint64_t v17 = v15;
            uint64_t v15 = (uint64_t *)*v15;
          }
          while (v15);
        }
        else
        {
          do
          {
            uint64_t v17 = (uint64_t *)v16[2];
            BOOL v18 = *v17 == (void)v16;
            uint64_t v16 = v17;
          }
          while (!v18);
        }
        if (*(uint64_t **)(a1 + 456) == v10) {
          *(void *)(a1 + 456) = v17;
        }
        --*(void *)(a1 + 472);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v7, v10);
        operator delete(v10);
      }
      while (1)
      {
        v5 += 8;
        if (v5 == v6) {
          break;
        }
        uint64_t v7 = *v8;
        if (*v8) {
          goto LABEL_4;
        }
      }
    }
  }
  uint64_t v19 = *(uint64_t **)(a1 + 456);
  uint64_t v20 = (uint64_t *)(a1 + 464);
  if (v19 != (uint64_t *)(a1 + 464))
  {
    do
    {
      uint64_t v34 = *(void *)(a1 + 152);
      uint64_t v35 = *(unsigned __int16 **)(v34 + 456);
      BOOL v36 = *(unsigned __int16 **)(v34 + 464);
      if (v36 == v35) {
        goto LABEL_53;
      }
      unsigned int v37 = *(unsigned __int16 *)(v19[4] + 40);
      unint64_t v38 = v36 - v35;
      do
      {
        unint64_t v39 = v38 >> 1;
        unint64_t v40 = &v35[v38 >> 1];
        unsigned int v42 = *v40;
        uint64_t v41 = v40 + 1;
        v38 += ~(v38 >> 1);
        if (v42 < v37) {
          uint64_t v35 = v41;
        }
        else {
          unint64_t v38 = v39;
        }
      }
      while (v38);
      if (v35 == v36)
      {
LABEL_53:
        uint64_t v44 = (uint64_t *)v19[1];
        if (v44) {
          goto LABEL_54;
        }
      }
      else
      {
        unsigned int v43 = *v35;
        uint64_t v44 = (uint64_t *)v19[1];
        if (v43 <= v37)
        {
          uint64_t v46 = v19;
          if (v44)
          {
            do
            {
              uint64_t v45 = v44;
              uint64_t v44 = (uint64_t *)*v44;
            }
            while (v44);
          }
          else
          {
            do
            {
              uint64_t v45 = (uint64_t *)v46[2];
              BOOL v18 = *v45 == (void)v46;
              uint64_t v46 = v45;
            }
            while (!v18);
          }
          if (*(uint64_t **)(a1 + 456) == v19) {
            *(void *)(a1 + 456) = v45;
          }
          uint64_t v33 = *(uint64_t **)(a1 + 464);
          --*(void *)(a1 + 472);
          std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v33, v19);
          operator delete(v19);
          goto LABEL_42;
        }
        if (v44)
        {
          do
          {
LABEL_54:
            uint64_t v45 = v44;
            uint64_t v44 = (uint64_t *)*v44;
          }
          while (v44);
          goto LABEL_42;
        }
      }
      do
      {
        uint64_t v45 = (uint64_t *)v19[2];
        BOOL v18 = *v45 == (void)v19;
        uint64_t v19 = v45;
      }
      while (!v18);
LABEL_42:
      uint64_t v19 = v45;
    }
    while (v45 != v20);
  }
  uint64_t v21 = *a2;
  unint64_t v22 = a2[1];
  while (v21 != v22)
  {
    char v26 = *v21;
    uint64_t v27 = gdc::Registry::storage<md::components::SupportsFlexing>(*v21);
    if (*(void *)(v27 + 88) != *(void *)(v27 + 80))
    {
      unint64_t v28 = (uint64_t *)*v20;
      unint64_t v29 = (uint64_t **)(a1 + 464);
      uint64_t v30 = (uint64_t **)(a1 + 464);
      if (*v20)
      {
        unsigned int v31 = v26[5].u16[0];
        while (1)
        {
          while (1)
          {
            uint64_t v30 = (uint64_t **)v28;
            unsigned int v32 = *(unsigned __int16 *)(v28[4] + 40);
            if (v31 >= v32) {
              break;
            }
            unint64_t v28 = *v30;
            unint64_t v29 = v30;
            if (!*v30) {
              goto LABEL_27;
            }
          }
          if (v32 >= v31) {
            break;
          }
          unint64_t v28 = v30[1];
          if (!v28)
          {
            unint64_t v29 = v30 + 1;
            goto LABEL_27;
          }
        }
      }
      else
      {
LABEL_27:
        unsigned int v23 = (uint64_t *)operator new(0x28uLL);
        v23[4] = (uint64_t)v26;
        uint64_t *v23 = 0;
        v23[1] = 0;
        _OWORD v23[2] = (uint64_t)v30;
        *unint64_t v29 = v23;
        uint64_t v24 = **(void **)(a1 + 456);
        if (v24)
        {
          *(void *)(a1 + 456) = v24;
          size_t v25 = *v29;
        }
        else
        {
          size_t v25 = v23;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 464), v25);
        ++*(void *)(a1 + 472);
      }
    }
    ++v21;
  }
}

void std::__hash_table<md::SceneQueryEvent,std::hash<md::SceneQueryEvent>,std::equal_to<md::SceneQueryEvent>,std::allocator<md::SceneQueryEvent>>::__emplace_unique_key_args<md::SceneQueryEvent,md::SceneQueryEvent&>(float *a1, unsigned __int8 a2, char a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unsigned int v9 = *(uint64_t ****)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      BOOL v10 = *v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            unsigned int v12 = v10[1];
            if (v12 == (uint64_t *)a2)
            {
              if (*((unsigned __int8 *)v10 + 16) == a2) {
                return;
              }
            }
            else if (((unint64_t)v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            BOOL v10 = (uint64_t **)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = (unint64_t)v10[1];
          if (v11 == a2)
          {
            if (*((unsigned __int8 *)v10 + 16) == a2) {
              return;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          BOOL v10 = (uint64_t **)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  BOOL v13 = operator new(0x18uLL);
  *BOOL v13 = 0;
  v13[1] = v6;
  *((unsigned char *)v13 + 16) = a3;
  float v14 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v15 = a1[8];
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (prime <= v7)
    {
      if (prime >= v7) {
        goto LABEL_59;
      }
      unint64_t v31 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
      {
        unint64_t v31 = std::__next_prime(v31);
      }
      else
      {
        uint64_t v33 = 1 << -(char)__clz(v31 - 1);
        if (v31 >= 2) {
          unint64_t v31 = v33;
        }
      }
      if (prime <= v31) {
        size_t prime = v31;
      }
      if (prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
LABEL_59:
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v6) {
            unint64_t v3 = v6 % v7;
          }
          else {
            unint64_t v3 = v6;
          }
        }
        else
        {
          unint64_t v3 = (v7 - 1) & v6;
        }
        goto LABEL_72;
      }
      if (!prime)
      {
        unint64_t v40 = *(void **)a1;
        *(void *)a1 = 0;
        if (v40) {
          operator delete(v40);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_59;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v20 = operator new(8 * prime);
    uint64_t v21 = *(void **)a1;
    *(void *)a1 = v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v22++) = 0;
    while (prime != v22);
    uint64_t v24 = (uint64_t *)(a1 + 4);
    unsigned int v23 = (void *)*((void *)a1 + 2);
    if (!v23)
    {
LABEL_58:
      unint64_t v7 = prime;
      goto LABEL_59;
    }
    size_t v25 = v23[1];
    size_t v26 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v27 = v25 & v26;
      *(void *)(*(void *)a1 + 8 * v27) = v24;
      for (uint64_t i = (void *)*v23; *v23; uint64_t i = (void *)*v23)
      {
        size_t v29 = i[1] & v26;
        if (v29 == v27)
        {
          unsigned int v23 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v29))
        {
          void *v23 = *i;
          uint64_t v30 = 8 * v29;
          void *i = **(void **)(*(void *)a1 + v30);
          **(void **)(*(void *)a1 + v30) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v29) = v23;
          unsigned int v23 = i;
          size_t v27 = v29;
        }
      }
      goto LABEL_58;
    }
    if (v25 >= prime) {
      v25 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v25) = v24;
    uint64_t v34 = (void *)*v23;
    if (!*v23) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v36 = v34[1];
      if (v36 >= prime) {
        v36 %= prime;
      }
      if (v36 != v25)
      {
        if (!*(void *)(*(void *)a1 + 8 * v36))
        {
          *(void *)(*(void *)a1 + 8 * v36) = v23;
          goto LABEL_63;
        }
        void *v23 = *v34;
        uint64_t v35 = 8 * v36;
        void *v34 = **(void **)(*(void *)a1 + v35);
        **(void **)(*(void *)a1 + v35) = v34;
        uint64_t v34 = v23;
      }
      size_t v36 = v25;
LABEL_63:
      unsigned int v23 = v34;
      uint64_t v34 = (void *)*v34;
      size_t v25 = v36;
      if (!v34) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  unsigned int v37 = *(void **)a1;
  unint64_t v38 = *(void **)(*(void *)a1 + 8 * v3);
  if (v38)
  {
    *BOOL v13 = *v38;
LABEL_80:
    *unint64_t v38 = v13;
    goto LABEL_81;
  }
  *BOOL v13 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v13;
  v37[v3] = a1 + 4;
  if (*v13)
  {
    unint64_t v39 = *(void *)(*v13 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v39 >= v7) {
        v39 %= v7;
      }
    }
    else
    {
      v39 &= v7 - 1;
    }
    unint64_t v38 = (void *)(*(void *)a1 + 8 * v39);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
}

void sub_1A23B8B74(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_0,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  unint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "RouteDidChangeForSceneQueryLogic", "", v5, 2u);
  }
}

void md::SceneQueryLogic::clearNavigationFlexState(md::SceneQueryLogic *this)
{
  uint64_t v1 = (char *)*((void *)this + 60);
  uint64_t v58 = (char *)this + 488;
  if (v1 == (char *)this + 488)
  {
LABEL_2:
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 61));
    *((void *)this + 61) = 0;
    *((void *)this + 62) = 0;
    *((void *)this + 60) = v58;
    if (*((void *)this + 66))
    {
      uint64_t v2 = (void *)*((void *)this + 65);
      if (v2)
      {
        do
        {
          unint64_t v3 = (void *)*v2;
          operator delete(v2);
          uint64_t v2 = v3;
        }
        while (v3);
      }
      *((void *)this + 65) = 0;
      uint64_t v4 = *((void *)this + 64);
      if (v4)
      {
        for (uint64_t i = 0; i != v4; ++i)
          *(void *)(*((void *)this + 63) + 8 * i) = 0;
      }
      *((void *)this + 66) = 0;
    }
  }
  else
  {
    while (1)
    {
      unint64_t v6 = (int8x8_t *)*((void *)v1 + 5);
      unint64_t v7 = (void *)gdc::Registry::storage<md::components::FlexSelectionInfo>(v6);
      uint8x8_t v8 = v7;
      if (v7[29])
      {
        unsigned int v9 = (void *)v7[28];
        if (v9) {
          break;
        }
      }
LABEL_16:
      v8[8] = v8[7];
      v8[11] = v8[10];
      float v14 = (void *)gdc::Registry::storage<md::components::ClientState>(v6);
      uint64_t v15 = gdc::Registry::storage<md::components::SupportsFlexing>(v6);
      BOOL v16 = (void *)v15;
      uint64_t v17 = v15 + 32;
      uint64_t v18 = v14[7];
      uint64_t v19 = v14[8];
      if (*(void *)(v15 + 64) - *(void *)(v15 + 56) >= (unint64_t)(v19 - v18)) {
        uint64_t v20 = v14 + 4;
      }
      else {
        uint64_t v20 = (void *)(v15 + 32);
      }
      BOOL v21 = v14 + 4 != v20 || v18 == v19;
      if (!v21)
      {
        uint64_t v24 = v14[10];
        do
        {
          unint64_t v25 = *(unsigned int *)(v18 + 4);
          uint64_t v26 = v16[4];
          if (v25 >> 7 < (v16[5] - v26) >> 3)
          {
            uint64_t v27 = *(void *)(v26 + 8 * (v25 >> 7));
            if (v27)
            {
              unint64_t v28 = *(unsigned __int16 *)(v27 + 2 * (v25 & 0x7F));
              uint64_t v30 = v16[7];
              uint64_t v29 = v16[8];
              if (v28 < (v29 - v30) >> 3)
              {
                uint64_t v31 = v30 + 8 * v28;
                if (v31 != v29 && *(_DWORD *)(v31 + 4) == v25)
                {
                  uint64_t v33 = *(void *)v18;
                  if (geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::erase(v24, 0x10059u))
                  {
                    uint64_t v34 = (void *)gdc::Registry::storage<md::components::FlexClientStateChanged>(v6);
                    gdc::ComponentStorageWrapper<md::components::Collapsible>::emplace(v34, v33);
                  }
                }
              }
            }
          }
          v24 += 16;
          v18 += 8;
        }
        while (v18 != v19);
      }
      if ((void *)v17 == v20)
      {
        uint64_t v35 = v16[7];
        uint64_t v36 = v16[8];
        while (v35 != v36)
        {
          unint64_t v37 = *(unsigned int *)(v35 + 4);
          uint64_t v38 = v14[4];
          unint64_t v39 = (v14[5] - v38) >> 3;
          if (v37 >> 7 < v39)
          {
            uint64_t v40 = *(void *)(v38 + 8 * (v37 >> 7));
            if (v40)
            {
              unint64_t v41 = *(unsigned __int16 *)(v40 + 2 * (v37 & 0x7F));
              uint64_t v43 = v14[7];
              uint64_t v42 = v14[8];
              unint64_t v44 = (v42 - v43) >> 3;
              if (v44 > v41)
              {
                uint64_t v45 = v43 + 8 * v41;
                if (v45 != v42 && *(_DWORD *)(v45 + 4) == v37)
                {
                  if ((v47 = *(void *)v35, unint64_t v48 = *(void *)v35 >> 39, v48 < v39)
                    && (uint64_t v49 = *(void *)(v38 + 8 * v48)) != 0
                    && (unint64_t v50 = *(unsigned __int16 *)(v49 + 2 * (HIDWORD(v47) & 0x7F)), v44 > v50)
                    && ((uint64_t v51 = v43 + 8 * v50, v51 != v42) ? (v52 = *(_DWORD *)(v51 + 4) == HIDWORD(v47)) : (v52 = 0), v52))
                  {
                    uint64_t v53 = v14[10] + 16 * v50;
                  }
                  else
                  {
                    uint64_t v53 = v14[11];
                  }
                  if (geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::erase(v53, 0x10059u))
                  {
                    uint64_t v54 = (void *)gdc::Registry::storage<md::components::FlexClientStateChanged>(v6);
                    gdc::ComponentStorageWrapper<md::components::Collapsible>::emplace(v54, v47);
                  }
                }
              }
            }
          }
          v35 += 8;
        }
      }
      uint64_t v22 = (char *)*((void *)v1 + 1);
      if (v22)
      {
        do
        {
          unsigned int v23 = v22;
          uint64_t v22 = *(char **)v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          unsigned int v23 = (char *)*((void *)v1 + 2);
          BOOL v21 = *(void *)v23 == (void)v1;
          uint64_t v1 = v23;
        }
        while (!v21);
      }
      uint64_t v1 = v23;
      if (v23 == v58) {
        goto LABEL_2;
      }
    }
    uint64_t v10 = v7[31];
    uint64_t v11 = v7[7];
    uint64_t v12 = (v7[8] - v11) >> 3;
    while (1)
    {
      v60[0] = v11;
      v60[1] = v12;
      uint64_t v59 = v10;
      uint64_t v13 = v9[6];
      if (!v13) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v13 + 48))(v13, &v59, v60);
      unsigned int v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_16;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    md::SceneQueryLogic::prepareNavigationFlexSegmentsForRoute(v55, v56);
  }
}

void md::SceneQueryLogic::prepareNavigationFlexSegmentsForRoute(md::SceneQueryLogic *this, GEOComposedRoute *a2)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = a2;
  uint64_t v4 = (uint64_t *)((char *)this + 168);
  if (*((void *)this + 24))
  {
    uint64_t v5 = (void *)*((void *)this + 23);
    if (v5)
    {
      do
      {
        uint64_t v54 = (void *)*v5;
        uint64_t v55 = (void *)v5[3];
        if (v55)
        {
          v5[4] = v55;
          operator delete(v55);
        }
        operator delete(v5);
        uint64_t v5 = v54;
      }
      while (v54);
    }
    *((void *)this + 23) = 0;
    uint64_t v6 = *((void *)this + 22);
    if (v6)
    {
      for (uint64_t i = 0; i != v6; ++i)
        *(void *)(*v4 + 8 * i) = 0;
    }
    *((void *)this + 24) = 0;
  }
  if (v3)
  {
    long long v67 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    uint8x8_t v8 = [(GEOComposedRoute *)v3 sections];
    uint64_t v59 = v4;
    uint64_t v57 = [v8 countByEnumeratingWithState:&v67 objects:v72 count:16];
    if (v57)
    {
      uint64_t v56 = *(void *)v68;
      unsigned int v9 = (double *)MEMORY[0x1E4F63F10];
      uint64_t v60 = v3;
      uint64_t v10 = v8;
      do
      {
        for (uint64_t j = 0; j != v57; ++j)
        {
          if (*(void *)v68 != v56) {
            objc_enumerationMutation(v8);
          }
          uint64_t v11 = *(void **)(*((void *)&v67 + 1) + 8 * j);
          uint64_t v71 = v11;
          for (unint64_t k = 1; k < [v11 pointCount]; ++k)
          {
            uint64_t v14 = [v11 points];
            if (v11)
            {
              [v11 bounds];
              double v15 = *(double *)&v64;
              double v16 = *((double *)&v65 + 1);
              double v61 = *((double *)&v64 + 1);
              double v62 = *(double *)&v65;
              uint64_t v17 = v11;
              double v63 = *((double *)&v66 + 1);
              double v18 = *(double *)&v66;
            }
            else
            {
              uint64_t v17 = 0;
              long long v65 = 0u;
              long long v66 = 0u;
              double v62 = 0.0;
              double v63 = 0.0;
              double v18 = 0.0;
              double v16 = 0.0;
              long long v64 = 0u;
              double v61 = 0.0;
              double v15 = 0.0;
            }
            unint64_t v19 = v14 + 12 * k;
            float v21 = *(float *)(v19 - 12);
            float v20 = *(float *)(v19 - 8);
            float v22 = *(float *)(v19 - 4);
            double v23 = *v9;
            double v24 = v9[1];
            uint64_t v25 = [v17 points];
            if (v11)
            {
              uint8x8_t v8 = v10;
              [v11 bounds];
              double v26 = *((double *)&v64 + 1);
              double v27 = *(double *)&v64;
              double v29 = *((double *)&v65 + 1);
              double v28 = *(double *)&v65;
              double v30 = *((double *)&v66 + 1);
              double v31 = *(double *)&v66;
            }
            else
            {
              long long v65 = 0u;
              long long v66 = 0u;
              double v30 = 0.0;
              double v31 = 0.0;
              double v29 = 0.0;
              double v28 = 0.0;
              long long v64 = 0u;
              double v26 = 0.0;
              double v27 = 0.0;
              uint8x8_t v8 = v10;
            }
            double v32 = v61 + v18 * (float)(1.0 - v20);
            double v33 = (v15 + v16 * v21) / v23;
            double v34 = v32 / v24;
            double v35 = (v62 + v63 * v22) * 0.0000000249532021;
            uint64_t v36 = (float *)(v25 + 12 * k);
            double v37 = (v27 + v29 * *v36) / *v9;
            double v38 = (v26 + v31 * (float)(1.0 - v36[1])) / v9[1];
            double v39 = (v28 + v30 * v36[2]) * 0.0000000249532021;
            if (vabdd_f64(v33, v37) >= 0.0000000249532021
              || vabdd_f64(v38, v34) >= 0.0000000249532021
              || vabdd_f64(v35, v39) >= 0.0000000249532021)
            {
              uint64_t v40 = std::__hash_table<std::__hash_value_type<GEOComposedRouteSection *,std::vector<gm::LineSegment<double,3>>>,std::__unordered_map_hasher<std::vector,std::__unordered_map_hasher,md::SceneQueryLogic::pointer_hasher<GEOComposedRouteSection>,std::equal_to<std::vector>,true>,std::__unordered_map_equal<std::vector,std::__unordered_map_hasher,std::__unordered_map_hasher<std::vector,std::__unordered_map_hasher,md::SceneQueryLogic::pointer_hasher<GEOComposedRouteSection>,std::equal_to<std::vector>,true>,std::equal_to,true>,std::allocator<std::allocator><std::__unordered_map_hasher>>::__emplace_unique_key_args<std::vector,std::piecewise_construct_t const&,std::tuple<GEOComposedRouteSection * const&>,GEOComposedRouteSection * const<>>(v59, (unint64_t)v11, &v71);
              unint64_t v41 = v40;
              double v42 = 1.0 - v34;
              unint64_t v44 = (double *)v40[4];
              unint64_t v43 = v40[5];
              if ((unint64_t)v44 < v43)
              {
                double *v44 = v33;
                v44[1] = v42;
                v44[2] = v35;
                v44[3] = v37 - v33;
                v44[4] = v34 - v38;
                v44[5] = v39 - v35;
                uint64_t v13 = v44 + 6;
              }
              else
              {
                uint64_t v45 = (double *)v40[3];
                unint64_t v46 = 0xAAAAAAAAAAAAAAABLL * (((char *)v44 - (char *)v45) >> 4) + 1;
                if (v46 > 0x555555555555555) {
                  abort();
                }
                unint64_t v47 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v43 - (void)v45) >> 4);
                if (2 * v47 > v46) {
                  unint64_t v46 = 2 * v47;
                }
                if (v47 >= 0x2AAAAAAAAAAAAAALL) {
                  unint64_t v48 = 0x555555555555555;
                }
                else {
                  unint64_t v48 = v46;
                }
                if (v48)
                {
                  if (v48 > 0x555555555555555) {
                    std::__throw_bad_array_new_length[abi:nn180100]();
                  }
                  uint64_t v49 = (char *)operator new(48 * v48);
                }
                else
                {
                  uint64_t v49 = 0;
                }
                unint64_t v50 = (double *)&v49[16 * (((char *)v44 - (char *)v45) >> 4)];
                *unint64_t v50 = v33;
                v50[1] = v42;
                v50[2] = v35;
                v50[3] = v37 - v33;
                v50[4] = v34 - v38;
                v50[5] = v39 - v35;
                uint64_t v51 = v50;
                if (v44 != v45)
                {
                  do
                  {
                    long long v52 = *((_OWORD *)v44 - 3);
                    long long v53 = *((_OWORD *)v44 - 1);
                    *((_OWORD *)v51 - 2) = *((_OWORD *)v44 - 2);
                    *((_OWORD *)v51 - 1) = v53;
                    *((_OWORD *)v51 - 3) = v52;
                    v51 -= 6;
                    v44 -= 6;
                  }
                  while (v44 != v45);
                  unint64_t v44 = (double *)v41[3];
                }
                uint64_t v13 = v50 + 6;
                v41[3] = v51;
                v41[4] = v50 + 6;
                v41[5] = &v49[48 * v48];
                if (v44) {
                  operator delete(v44);
                }
              }
              v41[4] = v13;
              uint8x8_t v8 = v10;
            }
            unint64_t v3 = v60;
          }
        }
        uint64_t v57 = [v8 countByEnumeratingWithState:&v67 objects:v72 count:16];
      }
      while (v57);
    }
  }
}

void sub_1A23B941C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_2,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_2>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  unint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "ProcessPendingFeaturesForSceneQueryLogic", "", v5, 2u);
  }
}

void std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_4,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_4>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  unint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "ClearExitingForSceneQueryLogic", "", v5, 2u);
  }
}

void std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_5,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_5>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  unint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "ClearExitingForSceneQueryLogic", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_5,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_5>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5716E8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_5,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_5>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5716E8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_5,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_5>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_4,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_4>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5716A0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_4,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_4>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5716A0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_4,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_4>,void ()(void)>::~__func()
{
}

void *std::__hash_table<std::__hash_value_type<unsigned short,unsigned int>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned int>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short &&>,std::tuple<>>(float *a1, unsigned __int16 a2, _WORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unsigned int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((unsigned __int16 *)v10 + 8) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((unsigned __int16 *)v10 + 8) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v10 = operator new(0x18uLL);
  *uint64_t v10 = 0;
  v10[1] = v6;
  *((_WORD *)v10 + 8) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (prime <= v7)
    {
      if (prime >= v7) {
        goto LABEL_59;
      }
      unint64_t v30 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
      {
        unint64_t v30 = std::__next_prime(v30);
      }
      else
      {
        uint64_t v32 = 1 << -(char)__clz(v30 - 1);
        if (v30 >= 2) {
          unint64_t v30 = v32;
        }
      }
      if (prime <= v30) {
        size_t prime = v30;
      }
      if (prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
LABEL_59:
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v6) {
            unint64_t v3 = v6 % v7;
          }
          else {
            unint64_t v3 = v6;
          }
        }
        else
        {
          unint64_t v3 = (v7 - 1) & v6;
        }
        goto LABEL_72;
      }
      if (!prime)
      {
        uint64_t v40 = *(void **)a1;
        *(void *)a1 = 0;
        if (v40) {
          operator delete(v40);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_59;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v19 = operator new(8 * prime);
    float v20 = *(void **)a1;
    *(void *)a1 = v19;
    if (v20) {
      operator delete(v20);
    }
    uint64_t v21 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v21++) = 0;
    while (prime != v21);
    double v23 = (uint64_t *)(a1 + 4);
    float v22 = (void *)*((void *)a1 + 2);
    if (!v22)
    {
LABEL_58:
      unint64_t v7 = prime;
      goto LABEL_59;
    }
    size_t v24 = v22[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*(void *)a1 + 8 * v26) = v23;
      for (uint64_t i = (void *)*v22; *v22; uint64_t i = (void *)*v22)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          float v22 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v28))
        {
          *float v22 = *i;
          uint64_t v29 = 8 * v28;
          void *i = **(void **)(*(void *)a1 + v29);
          **(void **)(*(void *)a1 + v29) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v28) = v22;
          float v22 = i;
          size_t v26 = v28;
        }
      }
      goto LABEL_58;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v24) = v23;
    double v33 = (void *)*v22;
    if (!*v22) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*(void *)a1 + 8 * v35))
        {
          *(void *)(*(void *)a1 + 8 * v35) = v22;
          goto LABEL_63;
        }
        *float v22 = *v33;
        uint64_t v34 = 8 * v35;
        *double v33 = **(void **)(*(void *)a1 + v34);
        **(void **)(*(void *)a1 + v34) = v33;
        double v33 = v22;
      }
      size_t v35 = v24;
LABEL_63:
      float v22 = v33;
      double v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  uint64_t v36 = *(void **)a1;
  double v37 = *(void **)(*(void *)a1 + 8 * v3);
  if (v37)
  {
    *uint64_t v10 = *v37;
LABEL_80:
    void *v37 = v10;
    goto LABEL_81;
  }
  *uint64_t v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v36[v3] = a1 + 4;
  if (*v10)
  {
    unint64_t v38 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    double v37 = (void *)(*(void *)a1 + 8 * v38);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A23B9C08(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void md::SceneQueryLogic::categorizeEntitiesByFlexZone<>(std::vector<gdc::Registry *> const&)::{lambda(gdc::Entity,md::components::MeshInstance &,md::components::ClientState &)#1}::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = *(uint64_t **)a1;
  ++*(_DWORD *)(*(void *)a1 + 548);
  float64x2_t v7 = vcvtq_f64_f32(*(float32x2_t *)(a3 + 44));
  v91[0] = vcvtq_f64_f32(*(float32x2_t *)(a3 + 36));
  v91[1] = v7;
  uint64_t v8 = **(void **)(a1 + 8) + 304;
  float64x2_t v92 = vcvtq_f64_f32(*(float32x2_t *)(a3 + 52));
  *(int64x2_t *)long long v93 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  *(_OWORD *)&v93[16] = xmmword_1A28FC720;
  float64x2_t v94 = (float64x2_t)vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  v95[0] = &unk_1EF57D5A8;
  v95[1] = v93;
  v95[2] = v8;
  long long v96 = v95;
  double v9 = gm::Box<double,3>::forEachCorner((uint64_t)v91, (uint64_t)v95);
  if (v96 == v95)
  {
    (*(void (**)(void *, double))(v95[0] + 32))(v95, v9);
  }
  else if (v96)
  {
    (*(void (**)(double))(*v96 + 40))(v9);
  }
  uint64_t v10 = *(id ***)(a1 + 16);
  unint64_t v11 = *v10;
  uint64_t v12 = v10[1];
  if (*v10 == v12)
  {
    __int16 v48 = 0;
    float v14 = 3.4028e38;
  }
  else
  {
    uint64_t v13 = -1;
    float v14 = 3.4028e38;
    __asm { FMOV            V0.2D, #0.5 }
    float64x2_t v90 = _Q0;
    do
    {
      id v20 = *v11;
      *(void *)&v91[0] = v20;
      uint64_t v21 = std::__hash_table<std::__hash_value_type<GEOComposedRouteSection *,std::vector<gm::LineSegment<double,3>>>,std::__unordered_map_hasher<std::vector,std::__unordered_map_hasher,md::SceneQueryLogic::pointer_hasher<GEOComposedRouteSection>,std::equal_to<std::vector>,true>,std::__unordered_map_equal<std::vector,std::__unordered_map_hasher,std::__unordered_map_hasher<std::vector,std::__unordered_map_hasher,md::SceneQueryLogic::pointer_hasher<GEOComposedRouteSection>,std::equal_to<std::vector>,true>,std::equal_to,true>,std::allocator<std::allocator><std::__unordered_map_hasher>>::__emplace_unique_key_args<std::vector,std::piecewise_construct_t const&,std::tuple<GEOComposedRouteSection * const&>,GEOComposedRouteSection * const<>>(v6 + 21, (unint64_t)v20, v91);
      uint64_t v22 = v21[3];
      uint64_t v23 = v21[4];
      if (v22 != v23)
      {
        double v24 = *(double *)v93 + (*(double *)&v93[24] - *(double *)v93) * 0.5;
        float64x2_t v25 = vmlaq_f64(*(float64x2_t *)&v93[8], v90, vsubq_f64(v94, *(float64x2_t *)&v93[8]));
        uint64_t v26 = v6[31];
        uint64_t v27 = (v6[32] - v26) / 12;
        uint64_t v28 = v26 + 12 * v27 - 4;
        unint64_t v29 = v13;
        do
        {
          double v30 = *(double *)v22;
          float64x2_t v31 = *(float64x2_t *)(v22 + 8);
          float64x2_t v32 = vsubq_f64(v25, v31);
          uint64_t v33 = *(uint64_t *)(v22 + 24);
          float64x2_t v34 = *(float64x2_t *)(v22 + 32);
          float64x2_t v35 = (float64x2_t)vdupq_lane_s64(v33, 0);
          v35.f64[0] = v24 - *(double *)v22;
          float64x2_t v36 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v34.f64[0], 0);
          v36.f64[0] = v32.f64[0];
          v37.f64[1] = *(float64_t *)(v22 + 40);
          v37.f64[0] = v32.f64[1];
          float64x2_t v38 = vmlaq_laneq_f64(vmlaq_n_f64(vmulq_n_f64(v35, *(double *)&v33), v36, v34.f64[0]), v37, v34, 1);
          double v39 = vdivq_f64(v38, (float64x2_t)vdupq_laneq_s64((int64x2_t)v38, 1)).f64[0];
          if (v39 >= 0.0)
          {
            double v42 = v30 - v24;
            if (v39 <= 1.0)
            {
              double v41 = (v42 + v39 * *(double *)&v33) * (v42 + v39 * *(double *)&v33);
              float64x2_t v40 = vmlaq_n_f64(vsubq_f64(v31, v25), v34, v39);
            }
            else
            {
              double v41 = (*(double *)&v33 + v42) * (*(double *)&v33 + v42);
              float64x2_t v40 = vaddq_f64(v34, vsubq_f64(v31, v25));
            }
          }
          else
          {
            float64x2_t v40 = vsubq_f64(v31, v25);
            double v41 = (v30 - v24) * (v30 - v24);
          }
          float64x2_t v43 = vmulq_f64(v40, v40);
          *(float *)v43.f64 = v43.f64[0] + v41 + v43.f64[1];
          *(float *)v43.f64 = *(float *)v43.f64 * 1.60600699e15;
          float v14 = fminf(v14, *(float *)v43.f64);
          unsigned int v44 = *(float *)v43.f64;
          uint64_t v45 = (unsigned int *)v28;
          uint64_t v13 = v27;
          do
          {
            while (1)
            {
              if (v13-- < 1)
              {
                uint64_t v13 = v29;
                goto LABEL_23;
              }
              if (*(v45 - 1) <= v44) {
                break;
              }
              v45 -= 3;
            }
            BOOL v47 = *v45 >= v44;
            v45 -= 3;
          }
          while (!v47 || v13 >= v29);
          if (!v13)
          {

            uint64_t v13 = 0;
            goto LABEL_27;
          }
LABEL_23:
          v22 += 48;
          unint64_t v29 = v13;
        }
        while (v22 != v23);
      }

      ++v11;
    }
    while (v11 != v12);
    if (v13 == -1) {
      __int16 v48 = 0;
    }
    else {
LABEL_27:
    }
      __int16 v48 = *(unsigned __int8 *)(v6[31] + 12 * v13);
  }
  geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::emplace<gss::StyleAttribute,unsigned short>((uint64_t)v91, a4, 0x10059u, v48);
  if (LOBYTE(v92.f64[1]))
  {
    uint64_t v49 = *(char ***)(a1 + 24);
    uint64_t v51 = v49[1];
    unint64_t v50 = (unint64_t)v49[2];
    if ((unint64_t)v51 >= v50)
    {
      long long v53 = *v49;
      uint64_t v54 = v51 - *v49;
      uint64_t v55 = v54 >> 3;
      unint64_t v56 = (v54 >> 3) + 1;
      if (v56 >> 61) {
        abort();
      }
      uint64_t v57 = v50 - (void)v53;
      if (v57 >> 2 > v56) {
        unint64_t v56 = v57 >> 2;
      }
      if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v58 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v58 = v56;
      }
      if (v58)
      {
        if (v58 >> 61) {
          goto LABEL_75;
        }
        uint64_t v59 = operator new(8 * v58);
      }
      else
      {
        uint64_t v59 = 0;
      }
      uint64_t v60 = &v59[8 * v55];
      double v61 = &v59[8 * v58];
      *(void *)uint64_t v60 = a2;
      long long v52 = v60 + 8;
      if (v51 != v53)
      {
        unint64_t v62 = v51 - v53 - 8;
        if (v62 < 0x58) {
          goto LABEL_80;
        }
        if ((unint64_t)(v51 - v59 - v54) < 0x20) {
          goto LABEL_80;
        }
        uint64_t v63 = (v62 >> 3) + 1;
        long long v64 = &v59[8 * v55 - 16];
        long long v65 = v51 - 16;
        uint64_t v66 = v63 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v67 = *(_OWORD *)v65;
          *(v64 - 1) = *((_OWORD *)v65 - 1);
          _OWORD *v64 = v67;
          v64 -= 2;
          v65 -= 32;
          v66 -= 4;
        }
        while (v66);
        v60 -= 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
        v51 -= 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
        if (v63 != (v63 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_80:
          do
          {
            uint64_t v68 = *((void *)v51 - 1);
            v51 -= 8;
            *((void *)v60 - 1) = v68;
            v60 -= 8;
          }
          while (v51 != v53);
        }
        uint64_t v51 = *v49;
      }
      *uint64_t v49 = v60;
      v49[1] = v52;
      v49[2] = v61;
      if (v51) {
        operator delete(v51);
      }
    }
    else
    {
      *(void *)uint64_t v51 = a2;
      long long v52 = v51 + 8;
    }
    v49[1] = v52;
    uint64_t v69 = *(void *)(a1 + 32);
    uint64_t v71 = *(float **)(v69 + 8);
    unint64_t v70 = *(void *)(v69 + 16);
    if ((unint64_t)v71 < v70)
    {
      *uint64_t v71 = v14;
      uint64_t v72 = v71 + 1;
LABEL_73:
      *(void *)(v69 + 8) = v72;
      return;
    }
    uint64_t v73 = *(float **)v69;
    uint64_t v74 = (uint64_t)v71 - *(void *)v69;
    uint64_t v75 = v74 >> 2;
    unint64_t v76 = (v74 >> 2) + 1;
    if (v76 >> 62) {
      abort();
    }
    uint64_t v77 = v70 - (void)v73;
    if (v77 >> 1 > v76) {
      unint64_t v76 = v77 >> 1;
    }
    if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v78 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v78 = v76;
    }
    if (!v78)
    {
      uint64_t v79 = 0;
LABEL_64:
      uint64_t v80 = (float *)&v79[4 * v75];
      uint64_t v81 = &v79[4 * v78];
      *uint64_t v80 = v14;
      uint64_t v72 = v80 + 1;
      if (v71 != v73)
      {
        unint64_t v82 = (char *)v71 - (char *)v73 - 4;
        if (v82 < 0x2C) {
          goto LABEL_81;
        }
        if ((unint64_t)((char *)v71 - &v79[v74]) < 0x20) {
          goto LABEL_81;
        }
        uint64_t v83 = (v82 >> 2) + 1;
        char v84 = &v79[4 * v75 - 16];
        unint64_t v85 = v71 - 4;
        uint64_t v86 = v83 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v87 = *(_OWORD *)v85;
          *(v84 - 1) = *((_OWORD *)v85 - 1);
          *char v84 = v87;
          v84 -= 2;
          v85 -= 8;
          v86 -= 8;
        }
        while (v86);
        v80 -= v83 & 0x7FFFFFFFFFFFFFF8;
        v71 -= v83 & 0x7FFFFFFFFFFFFFF8;
        if (v83 != (v83 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_81:
          do
          {
            int v88 = *((_DWORD *)v71-- - 1);
            *((_DWORD *)v80-- - 1) = v88;
          }
          while (v71 != v73);
        }
      }
      *(void *)uint64_t v69 = v80;
      *(void *)(v69 + 8) = v72;
      *(void *)(v69 + 16) = v81;
      if (v73) {
        operator delete(v73);
      }
      goto LABEL_73;
    }
    if (!(v78 >> 62))
    {
      uint64_t v79 = operator new(4 * v78);
      goto LABEL_64;
    }
LABEL_75:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
}

void sub_1A23BA224(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<GEOComposedRouteSection *,std::vector<gm::LineSegment<double,3>>>,std::__unordered_map_hasher<std::vector,std::__unordered_map_hasher,md::SceneQueryLogic::pointer_hasher<GEOComposedRouteSection>,std::equal_to<std::vector>,true>,std::__unordered_map_equal<std::vector,std::__unordered_map_hasher,std::__unordered_map_hasher<std::vector,std::__unordered_map_hasher,md::SceneQueryLogic::pointer_hasher<GEOComposedRouteSection>,std::equal_to<std::vector>,true>,std::equal_to,true>,std::allocator<std::allocator><std::__unordered_map_hasher>>::__emplace_unique_key_args<std::vector,std::piecewise_construct_t const&,std::tuple<GEOComposedRouteSection * const&>,GEOComposedRouteSection * const<>>(uint64_t *a1, unint64_t a2, void *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = a1[1];
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    unint64_t v11 = *(void ***)(*a1 + 8 * v3);
    if (v11)
    {
      uint64_t v12 = *v11;
      if (*v11)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v14 = v12[1];
            if (v14 == v8)
            {
              if (v12[2] == a2) {
                return v12;
              }
            }
            else if ((v14 & (v9 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == v8)
          {
            if (v12[2] == a2) {
              return v12;
            }
          }
          else
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
            if (v13 != v3) {
              break;
            }
          }
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_22:
  BOOL v15 = a1 + 2;
  uint64_t v12 = operator new(0x30uLL);
  *uint64_t v12 = 0;
  v12[1] = v8;
  v12[2] = *a3;
  v12[3] = 0;
  v12[4] = 0;
  v12[5] = 0;
  float v16 = (float)(unint64_t)(a1[3] + 1);
  float v17 = *((float *)a1 + 8);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    BOOL v18 = 1;
    if (v9 >= 3) {
      BOOL v18 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v9);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t prime = v20;
    }
    else {
      size_t prime = v19;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v9 = a1[1];
    }
    if (prime <= v9)
    {
      if (prime >= v9) {
        goto LABEL_59;
      }
      unint64_t v32 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v9 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        unint64_t v32 = std::__next_prime(v32);
      }
      else
      {
        uint64_t v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2) {
          unint64_t v32 = v34;
        }
      }
      if (prime <= v32) {
        size_t prime = v32;
      }
      if (prime >= v9)
      {
        unint64_t v9 = a1[1];
LABEL_59:
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v8 >= v9) {
            unint64_t v3 = v8 % v9;
          }
          else {
            unint64_t v3 = v8;
          }
        }
        else
        {
          unint64_t v3 = (v9 - 1) & v8;
        }
        goto LABEL_72;
      }
      if (!prime)
      {
        double v42 = (void *)*a1;
        *a1 = 0;
        if (v42) {
          operator delete(v42);
        }
        unint64_t v9 = 0;
        a1[1] = 0;
        goto LABEL_59;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v22 = operator new(8 * prime);
    uint64_t v23 = (void *)*a1;
    *a1 = (uint64_t)v22;
    if (v23) {
      operator delete(v23);
    }
    uint64_t v24 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v24++) = 0;
    while (prime != v24);
    float64x2_t v25 = (void *)*v15;
    if (!*v15)
    {
LABEL_58:
      unint64_t v9 = prime;
      goto LABEL_59;
    }
    size_t v26 = v25[1];
    size_t v27 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v28 = v26 & v27;
      *(void *)(*a1 + 8 * v28) = v15;
      for (uint64_t i = (void *)*v25; *v25; uint64_t i = (void *)*v25)
      {
        size_t v30 = i[1] & v27;
        if (v30 == v28)
        {
          float64x2_t v25 = i;
        }
        else if (*(void *)(*a1 + 8 * v30))
        {
          *float64x2_t v25 = *i;
          uint64_t v31 = 8 * v30;
          void *i = **(void **)(*a1 + v31);
          **(void **)(*a1 + v31) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v30) = v25;
          float64x2_t v25 = i;
          size_t v28 = v30;
        }
      }
      goto LABEL_58;
    }
    if (v26 >= prime) {
      v26 %= prime;
    }
    *(void *)(*a1 + 8 * v26) = v15;
    float64x2_t v35 = (void *)*v25;
    if (!*v25) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v37 = v35[1];
      if (v37 >= prime) {
        v37 %= prime;
      }
      if (v37 != v26)
      {
        if (!*(void *)(*a1 + 8 * v37))
        {
          *(void *)(*a1 + 8 * v37) = v25;
          goto LABEL_63;
        }
        *float64x2_t v25 = *v35;
        uint64_t v36 = 8 * v37;
        *float64x2_t v35 = **(void **)(*a1 + v36);
        **(void **)(*a1 + v36) = v35;
        float64x2_t v35 = v25;
      }
      size_t v37 = v26;
LABEL_63:
      float64x2_t v25 = v35;
      float64x2_t v35 = (void *)*v35;
      size_t v26 = v37;
      if (!v35) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  uint64_t v38 = *a1;
  double v39 = *(void **)(*a1 + 8 * v3);
  if (v39)
  {
    *uint64_t v12 = *v39;
LABEL_80:
    void *v39 = v12;
    goto LABEL_81;
  }
  *uint64_t v12 = *v15;
  *BOOL v15 = v12;
  *(void *)(v38 + 8 * v3) = v15;
  if (*v12)
  {
    unint64_t v40 = *(void *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v40 >= v9) {
        v40 %= v9;
      }
    }
    else
    {
      v40 &= v9 - 1;
    }
    double v39 = (void *)(*a1 + 8 * v40);
    goto LABEL_80;
  }
LABEL_81:
  ++a1[3];
  return v12;
}

void sub_1A23BA6DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::vector<gdc::Entity>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::emplace<gss::StyleAttribute,unsigned short>(uint64_t result, uint64_t *a2, unsigned int a3, __int16 a4)
{
  uint64_t v5 = result;
  uint64_t v6 = *((unsigned __int16 *)a2 + 5);
  if (!*((unsigned char *)a2 + 14))
  {
    if (!*((_WORD *)a2 + 5)) {
      goto LABEL_29;
    }
    uint8x8_t v10 = (char *)*a2;
    if (*((unsigned char *)a2 + 15))
    {
      if (v6 >= 0x1E)
      {
        BOOL v15 = (char *)*a2;
        unint64_t v16 = *((unsigned __int16 *)a2 + 5);
        do
        {
          unint64_t v17 = v16 >> 1;
          BOOL v18 = &v15[4 * (v16 >> 1)];
          unsigned int v20 = *(_DWORD *)v18;
          unint64_t v19 = v18 + 4;
          v16 += ~(v16 >> 1);
          if (v20 < a3) {
            BOOL v15 = v19;
          }
          else {
            unint64_t v16 = v17;
          }
        }
        while (v16);
        if (v15 == &v10[4 * v6]) {
          goto LABEL_29;
        }
        if (*(_DWORD *)v15 != a3) {
          goto LABEL_29;
        }
        unint64_t v11 = (unint64_t)(v15 - v10) >> 2;
        if (v6 == (unsigned __int16)v11) {
          goto LABEL_29;
        }
      }
      else
      {
        unint64_t v11 = 0;
        while (1)
        {
          unsigned int v12 = *(_DWORD *)&v10[4 * v11];
          if (v12 >= a3) {
            break;
          }
          if (v6 == ++v11) {
            goto LABEL_29;
          }
        }
        if (v12 != a3) {
          LOWORD(v11) = *((_WORD *)a2 + 5);
        }
        if (v6 == (unsigned __int16)v11) {
          goto LABEL_29;
        }
      }
    }
    else
    {
      uint64_t v13 = 4 * v6;
      uint64_t v14 = (char *)*a2;
      while (*(_DWORD *)v14 != a3)
      {
        v14 += 4;
        v13 -= 4;
        if (!v13)
        {
          uint64_t v14 = &v10[4 * v6];
          break;
        }
      }
      unint64_t v11 = (unint64_t)(v14 - v10) >> 2;
      if (v6 == (unsigned __int16)v11)
      {
LABEL_29:
        if (*((_WORD *)a2 + 5))
        {
          uint64_t v21 = (char *)*a2;
          if (*((unsigned char *)a2 + 15))
          {
            if (v6 >= 0x1E)
            {
              size_t v27 = (char *)*a2;
              unint64_t v28 = *((unsigned __int16 *)a2 + 5);
              do
              {
                unint64_t v29 = v28 >> 1;
                size_t v30 = (unsigned int *)&v27[4 * (v28 >> 1)];
                unsigned int v32 = *v30;
                uint64_t v31 = (char *)(v30 + 1);
                v28 += ~(v28 >> 1);
                if (v32 < a3) {
                  size_t v27 = v31;
                }
                else {
                  unint64_t v28 = v29;
                }
              }
              while (v28);
              if (v27 == &v21[4 * v6] || *(_DWORD *)v27 != a3) {
                goto LABEL_54;
              }
              unint64_t v24 = (unint64_t)(v27 - v21) >> 2;
            }
            else
            {
              uint64_t v22 = 0;
              while (1)
              {
                unsigned int v23 = *(_DWORD *)&v21[4 * v22];
                if (v23 >= a3) {
                  break;
                }
                if (v6 == ++v22) {
                  goto LABEL_54;
                }
              }
              if (v23 == a3) {
                LOWORD(v24) = v22;
              }
              else {
                LOWORD(v24) = *((_WORD *)a2 + 5);
              }
            }
          }
          else
          {
            uint64_t v25 = 4 * v6;
            size_t v26 = (char *)*a2;
            while (*(_DWORD *)v26 != a3)
            {
              v26 += 4;
              v25 -= 4;
              if (!v25)
              {
                size_t v26 = &v21[4 * v6];
                break;
              }
            }
            unint64_t v24 = (unint64_t)(v26 - v21) >> 2;
          }
        }
        else
        {
          LOWORD(v24) = 0;
        }
        if (v6 != (unsigned __int16)v24)
        {
LABEL_56:
          LODWORD(v6) = (unsigned __int16)v6 - 1;
          char v7 = 1;
          goto LABEL_57;
        }
LABEL_54:
        __n128 result = geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable((unsigned __int16 *)a2);
        uint64_t v33 = *((unsigned __int16 *)a2 + 5);
        LOWORD(v6) = *((_WORD *)a2 + 5);
        if (result)
        {
          uint64_t v6 = *a2;
          *(_DWORD *)(*a2 + 4 * v33) = a3;
          *(_WORD *)(v6 + *((unsigned __int16 *)a2 + 4) + 2 * v33) = a4;
          LOWORD(v6) = *((_WORD *)a2 + 5) + 1;
          *((_WORD *)a2 + 5) = v6;
          *((unsigned char *)a2 + 15) = 0;
        }
        goto LABEL_56;
      }
    }
    char v7 = 0;
    LODWORD(v6) = (unsigned __int16)v11;
    goto LABEL_57;
  }
  char v7 = 0;
LABEL_57:
  *(void *)uint64_t v5 = a2;
  *(_DWORD *)(v5 + 8) = v6;
  *(unsigned char *)(v5 + 16) = 0;
  *(unsigned char *)(v5 + 32) = 0;
  *(unsigned char *)(v5 + 40) = v7;
  return result;
}

void md::SceneQueryLogic::categorizeEntitiesByFlexZone<md::components::DidResolvePendingMaterial>(std::vector<gdc::Registry *> const&)::{lambda(gdc::Entity,md::components::MeshInstance &,md::components::ClientState &)#1}::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(uint64_t **)a1;
  ++*(_DWORD *)(*(void *)a1 + 548);
  float64x2_t v7 = vcvtq_f64_f32(*(float32x2_t *)(a3 + 44));
  v91[0] = vcvtq_f64_f32(*(float32x2_t *)(a3 + 36));
  v91[1] = v7;
  uint64_t v8 = **(void **)(a1 + 8) + 304;
  float64x2_t v92 = vcvtq_f64_f32(*(float32x2_t *)(a3 + 52));
  *(int64x2_t *)long long v93 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  *(_OWORD *)&v93[16] = xmmword_1A28FC720;
  float64x2_t v94 = (float64x2_t)vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  v95[0] = &unk_1EF57D5A8;
  v95[1] = v93;
  v95[2] = v8;
  long long v96 = v95;
  double v9 = gm::Box<double,3>::forEachCorner((uint64_t)v91, (uint64_t)v95);
  if (v96 == v95)
  {
    (*(void (**)(void *, double))(v95[0] + 32))(v95, v9);
  }
  else if (v96)
  {
    (*(void (**)(double))(*v96 + 40))(v9);
  }
  uint8x8_t v10 = *(id ***)(a1 + 16);
  unint64_t v11 = *v10;
  unsigned int v12 = v10[1];
  if (*v10 == v12)
  {
    __int16 v48 = 0;
    float v14 = 3.4028e38;
  }
  else
  {
    uint64_t v13 = -1;
    float v14 = 3.4028e38;
    __asm { FMOV            V0.2D, #0.5 }
    float64x2_t v90 = _Q0;
    do
    {
      id v20 = *v11;
      *(void *)&v91[0] = v20;
      uint64_t v21 = std::__hash_table<std::__hash_value_type<GEOComposedRouteSection *,std::vector<gm::LineSegment<double,3>>>,std::__unordered_map_hasher<std::vector,std::__unordered_map_hasher,md::SceneQueryLogic::pointer_hasher<GEOComposedRouteSection>,std::equal_to<std::vector>,true>,std::__unordered_map_equal<std::vector,std::__unordered_map_hasher,std::__unordered_map_hasher<std::vector,std::__unordered_map_hasher,md::SceneQueryLogic::pointer_hasher<GEOComposedRouteSection>,std::equal_to<std::vector>,true>,std::equal_to,true>,std::allocator<std::allocator><std::__unordered_map_hasher>>::__emplace_unique_key_args<std::vector,std::piecewise_construct_t const&,std::tuple<GEOComposedRouteSection * const&>,GEOComposedRouteSection * const<>>(v6 + 21, (unint64_t)v20, v91);
      uint64_t v22 = v21[3];
      uint64_t v23 = v21[4];
      if (v22 != v23)
      {
        double v24 = *(double *)v93 + (*(double *)&v93[24] - *(double *)v93) * 0.5;
        float64x2_t v25 = vmlaq_f64(*(float64x2_t *)&v93[8], v90, vsubq_f64(v94, *(float64x2_t *)&v93[8]));
        uint64_t v26 = v6[31];
        uint64_t v27 = (v6[32] - v26) / 12;
        uint64_t v28 = v26 + 12 * v27 - 4;
        unint64_t v29 = v13;
        do
        {
          double v30 = *(double *)v22;
          float64x2_t v31 = *(float64x2_t *)(v22 + 8);
          float64x2_t v32 = vsubq_f64(v25, v31);
          uint64_t v33 = *(uint64_t *)(v22 + 24);
          float64x2_t v34 = *(float64x2_t *)(v22 + 32);
          float64x2_t v35 = (float64x2_t)vdupq_lane_s64(v33, 0);
          v35.f64[0] = v24 - *(double *)v22;
          float64x2_t v36 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v34.f64[0], 0);
          v36.f64[0] = v32.f64[0];
          v37.f64[1] = *(float64_t *)(v22 + 40);
          v37.f64[0] = v32.f64[1];
          float64x2_t v38 = vmlaq_laneq_f64(vmlaq_n_f64(vmulq_n_f64(v35, *(double *)&v33), v36, v34.f64[0]), v37, v34, 1);
          double v39 = vdivq_f64(v38, (float64x2_t)vdupq_laneq_s64((int64x2_t)v38, 1)).f64[0];
          if (v39 >= 0.0)
          {
            double v42 = v30 - v24;
            if (v39 <= 1.0)
            {
              double v41 = (v42 + v39 * *(double *)&v33) * (v42 + v39 * *(double *)&v33);
              float64x2_t v40 = vmlaq_n_f64(vsubq_f64(v31, v25), v34, v39);
            }
            else
            {
              double v41 = (*(double *)&v33 + v42) * (*(double *)&v33 + v42);
              float64x2_t v40 = vaddq_f64(v34, vsubq_f64(v31, v25));
            }
          }
          else
          {
            float64x2_t v40 = vsubq_f64(v31, v25);
            double v41 = (v30 - v24) * (v30 - v24);
          }
          float64x2_t v43 = vmulq_f64(v40, v40);
          *(float *)v43.f64 = v43.f64[0] + v41 + v43.f64[1];
          *(float *)v43.f64 = *(float *)v43.f64 * 1.60600699e15;
          float v14 = fminf(v14, *(float *)v43.f64);
          unsigned int v44 = *(float *)v43.f64;
          uint64_t v45 = (unsigned int *)v28;
          uint64_t v13 = v27;
          do
          {
            while (1)
            {
              if (v13-- < 1)
              {
                uint64_t v13 = v29;
                goto LABEL_23;
              }
              if (*(v45 - 1) <= v44) {
                break;
              }
              v45 -= 3;
            }
            BOOL v47 = *v45 >= v44;
            v45 -= 3;
          }
          while (!v47 || v13 >= v29);
          if (!v13)
          {

            uint64_t v13 = 0;
            goto LABEL_27;
          }
LABEL_23:
          v22 += 48;
          unint64_t v29 = v13;
        }
        while (v22 != v23);
      }

      ++v11;
    }
    while (v11 != v12);
    if (v13 == -1) {
      __int16 v48 = 0;
    }
    else {
LABEL_27:
    }
      __int16 v48 = *(unsigned __int8 *)(v6[31] + 12 * v13);
  }
  geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::emplace<gss::StyleAttribute,unsigned short>((uint64_t)v91, a4, 0x10059u, v48);
  if (LOBYTE(v92.f64[1]))
  {
    uint64_t v49 = *(char ***)(a1 + 24);
    uint64_t v51 = v49[1];
    unint64_t v50 = (unint64_t)v49[2];
    if ((unint64_t)v51 >= v50)
    {
      long long v53 = *v49;
      uint64_t v54 = v51 - *v49;
      uint64_t v55 = v54 >> 3;
      unint64_t v56 = (v54 >> 3) + 1;
      if (v56 >> 61) {
        abort();
      }
      uint64_t v57 = v50 - (void)v53;
      if (v57 >> 2 > v56) {
        unint64_t v56 = v57 >> 2;
      }
      if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v58 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v58 = v56;
      }
      if (v58)
      {
        if (v58 >> 61) {
          goto LABEL_75;
        }
        uint64_t v59 = operator new(8 * v58);
      }
      else
      {
        uint64_t v59 = 0;
      }
      uint64_t v60 = &v59[8 * v55];
      double v61 = &v59[8 * v58];
      *(void *)uint64_t v60 = a2;
      long long v52 = v60 + 8;
      if (v51 != v53)
      {
        unint64_t v62 = v51 - v53 - 8;
        if (v62 < 0x58) {
          goto LABEL_80;
        }
        if ((unint64_t)(v51 - v59 - v54) < 0x20) {
          goto LABEL_80;
        }
        uint64_t v63 = (v62 >> 3) + 1;
        long long v64 = &v59[8 * v55 - 16];
        long long v65 = v51 - 16;
        uint64_t v66 = v63 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v67 = *(_OWORD *)v65;
          *(v64 - 1) = *((_OWORD *)v65 - 1);
          _OWORD *v64 = v67;
          v64 -= 2;
          v65 -= 32;
          v66 -= 4;
        }
        while (v66);
        v60 -= 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
        v51 -= 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
        if (v63 != (v63 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_80:
          do
          {
            uint64_t v68 = *((void *)v51 - 1);
            v51 -= 8;
            *((void *)v60 - 1) = v68;
            v60 -= 8;
          }
          while (v51 != v53);
        }
        uint64_t v51 = *v49;
      }
      *uint64_t v49 = v60;
      v49[1] = v52;
      v49[2] = v61;
      if (v51) {
        operator delete(v51);
      }
    }
    else
    {
      *(void *)uint64_t v51 = a2;
      long long v52 = v51 + 8;
    }
    v49[1] = v52;
    uint64_t v69 = *(void *)(a1 + 32);
    uint64_t v71 = *(float **)(v69 + 8);
    unint64_t v70 = *(void *)(v69 + 16);
    if ((unint64_t)v71 < v70)
    {
      *uint64_t v71 = v14;
      uint64_t v72 = v71 + 1;
LABEL_73:
      *(void *)(v69 + 8) = v72;
      return;
    }
    uint64_t v73 = *(float **)v69;
    uint64_t v74 = (uint64_t)v71 - *(void *)v69;
    uint64_t v75 = v74 >> 2;
    unint64_t v76 = (v74 >> 2) + 1;
    if (v76 >> 62) {
      abort();
    }
    uint64_t v77 = v70 - (void)v73;
    if (v77 >> 1 > v76) {
      unint64_t v76 = v77 >> 1;
    }
    if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v78 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v78 = v76;
    }
    if (!v78)
    {
      uint64_t v79 = 0;
LABEL_64:
      uint64_t v80 = (float *)&v79[4 * v75];
      uint64_t v81 = &v79[4 * v78];
      *uint64_t v80 = v14;
      uint64_t v72 = v80 + 1;
      if (v71 != v73)
      {
        unint64_t v82 = (char *)v71 - (char *)v73 - 4;
        if (v82 < 0x2C) {
          goto LABEL_81;
        }
        if ((unint64_t)((char *)v71 - &v79[v74]) < 0x20) {
          goto LABEL_81;
        }
        uint64_t v83 = (v82 >> 2) + 1;
        char v84 = &v79[4 * v75 - 16];
        unint64_t v85 = v71 - 4;
        uint64_t v86 = v83 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v87 = *(_OWORD *)v85;
          *(v84 - 1) = *((_OWORD *)v85 - 1);
          *char v84 = v87;
          v84 -= 2;
          v85 -= 8;
          v86 -= 8;
        }
        while (v86);
        v80 -= v83 & 0x7FFFFFFFFFFFFFF8;
        v71 -= v83 & 0x7FFFFFFFFFFFFFF8;
        if (v83 != (v83 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_81:
          do
          {
            int v88 = *((_DWORD *)v71-- - 1);
            *((_DWORD *)v80-- - 1) = v88;
          }
          while (v71 != v73);
        }
      }
      *(void *)uint64_t v69 = v80;
      *(void *)(v69 + 8) = v72;
      *(void *)(v69 + 16) = v81;
      if (v73) {
        operator delete(v73);
      }
      goto LABEL_73;
    }
    if (!(v78 >> 62))
    {
      uint64_t v79 = operator new(4 * v78);
      goto LABEL_64;
    }
LABEL_75:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
}

void sub_1A23BAF58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_3,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_3>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  unint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "ProcessPendingFeaturesForSceneQueryLogic", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_3,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_3>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF571658;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_3,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_3>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF571658;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_3,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_3>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_2,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_2>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF571610;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_2,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_2>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF571610;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_2,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_2>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_1,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "RouteDidChangeForSceneQueryLogic", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_1,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5715C8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_1,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5715C8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_1,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_0,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF571580;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_0,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF571580;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_0,std::allocator<md::SceneQueryLogic::handleNavigationFlex(md::LayoutContext const&,md::CameraContext const&,md::NavigationContext const&,md::StyleLogicContext const&,std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const&,BOOL,md::SceneQueryContext &)::$_0>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::SceneQueryLogic::resolveFlexQueries(md::StyleLogicContext const&,md::NavigationContext const&,BOOL,BOOL)::$_0,std::allocator<md::SceneQueryLogic::resolveFlexQueries(md::StyleLogicContext const&,md::NavigationContext const&,BOOL,BOOL)::$_0>,void ()(md::StyleManagerEvent)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF571538;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::SceneQueryLogic::resolveFlexQueries(md::StyleLogicContext const&,md::NavigationContext const&,BOOL,BOOL)::$_0,std::allocator<md::SceneQueryLogic::resolveFlexQueries(md::StyleLogicContext const&,md::NavigationContext const&,BOOL,BOOL)::$_0>,void ()(md::StyleManagerEvent)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF571538;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::SceneQueryLogic::resolveFlexQueries(md::StyleLogicContext const&,md::NavigationContext const&,BOOL,BOOL)::$_0,std::allocator<md::SceneQueryLogic::resolveFlexQueries(md::StyleLogicContext const&,md::NavigationContext const&,BOOL,BOOL)::$_0>,void ()(md::StyleManagerEvent)>::~__func()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md15SceneQueryLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_15RegistryContextENS2_17NavigationContextENS2_17StyleLogicContextENS2_15SettingsContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_17SceneQueryContextEE3__1NS_9allocatorISN_EEFvvEE7__cloneEPNS0_6__baseISQ_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF571778;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md15SceneQueryLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_15RegistryContextENS2_17NavigationContextENS2_17StyleLogicContextENS2_15SettingsContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_17SceneQueryContextEE3__1NS_9allocatorISN_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF571778;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md15SceneQueryLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_15RegistryContextENS2_17NavigationContextENS2_17StyleLogicContextENS2_15SettingsContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_17SceneQueryContextEE3__1NS_9allocatorISN_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md15SceneQueryLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_15RegistryContextENS2_17NavigationContextENS2_17StyleLogicContextENS2_15SettingsContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_17SceneQueryContextEE3__0NS_9allocatorISN_EEFvvEE7__cloneEPNS0_6__baseISQ_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF571730;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md15SceneQueryLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_15RegistryContextENS2_17NavigationContextENS2_17StyleLogicContextENS2_15SettingsContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_17SceneQueryContextEE3__0NS_9allocatorISN_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF571730;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md15SceneQueryLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_15RegistryContextENS2_17NavigationContextENS2_17StyleLogicContextENS2_15SettingsContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_17SceneQueryContextEE3__0NS_9allocatorISN_EEFvvEED0Ev()
{
}

uint64_t md::Logic<md::SceneQueryLogic,md::SceneQueryContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::RegistryContext,md::NavigationContext,md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::SceneQueryLogic,md::SceneQueryContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::RegistryContext,md::NavigationContext,md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0xDFC317497CF9A4BFLL && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    md::LogicDependencies<gdc::TypeList<md::CameraContext,md::RegistryContext,md::NavigationContext,md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::RegistryContext,md::NavigationContext,md::StyleLogicContext,md::SettingsContext>(v7, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v7, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

void md::SceneQueryContext::~SceneQueryContext(md::SceneQueryContext *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (void *)*((void *)this + 5);
    if (!v3) {
      goto LABEL_5;
    }
  }
  else
  {
    uint64_t v3 = (void *)*((void *)this + 5);
    if (!v3) {
      goto LABEL_5;
    }
  }
  do
  {
    uint64_t v4 = (void *)*v3;
    operator delete(v3);
    uint64_t v3 = v4;
  }
  while (v4);
LABEL_5:
  uint64_t v5 = (void *)*((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v5) {
    operator delete(v5);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 1));
}

uint64_t gdc::ObjectHolder<md::SceneQueryContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::SceneQueryContext>::~ManagedObjectHolder(void *a1)
{
  gdc::ManagedObjectHolder<md::SceneQueryContext>::~ManagedObjectHolder(a1);
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::SceneQueryContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5556B8;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 80);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    uint64_t v4 = *(void **)(v2 + 40);
    if (v4)
    {
      do
      {
        uint64_t v5 = (void *)*v4;
        operator delete(v4);
        uint64_t v4 = v5;
      }
      while (v5);
    }
    uint64_t v6 = *(void **)(v2 + 24);
    *(void *)(v2 + 24) = 0;
    if (v6) {
      operator delete(v6);
    }
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v2 + 8));
    MEMORY[0x1A6239270](v2, 0x10A0C4056A13B85);
  }
  return a1;
}

void md::SceneQueryLogic::didBecomeInactive(md::SceneQueryLogic *this)
{
  uint64_t v2 = (void *)*((void *)this + 38);
  if (v2)
  {
    *((void *)this + 38) = 0;
  }
  md::SceneQueryLogic::clearNavigationFlexState(this);
}

void md::SceneQueryLogic::~SceneQueryLogic(md::SceneQueryLogic *this)
{
  md::SceneQueryLogic::~SceneQueryLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  std::__shared_weak_count *v14;
  void *v15;
  void *v16;

  *(void *)this = &unk_1EF5353C0;
  GEOConfigRemoveBlockListener();
  GEOConfigRemoveBlockListener();
  GEOConfigRemoveBlockListener();
  uint64_t v2 = (void *)*((void *)this + 65);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)*((void *)this + 63);
  *((void *)this + 63) = 0;
  if (v4) {
    operator delete(v4);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 61));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 58));
  std::__tree<std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>,std::__map_value_compare<md::FrameGraphPass *,std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>,md::FrameGraphPassLessThan,true>,std::allocator<std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>>>::destroy(*((void **)this + 54));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 51));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 48));
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 45);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 43);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  float64x2_t v7 = (std::__shared_weak_count *)*((void *)this + 41);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  *((void *)this + 37) = &unk_1EF559678;

  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 35));
  uint64_t v8 = (void *)*((void *)this + 31);
  if (v8)
  {
    *((void *)this + 32) = v8;
    operator delete(v8);
  }
  double v9 = (void *)*((void *)this + 28);
  if (v9)
  {
    do
    {
      uint8x8_t v10 = (void *)*v9;
      operator delete(v9);
      double v9 = v10;
    }
    while (v10);
  }
  unint64_t v11 = (void *)*((void *)this + 26);
  *((void *)this + 26) = 0;
  if (v11) {
    operator delete(v11);
  }
  unsigned int v12 = (void *)*((void *)this + 23);
  if (v12)
  {
    do
    {
      BOOL v15 = (void *)*v12;
      unint64_t v16 = (void *)v12[3];
      if (v16)
      {
        v12[4] = v16;
        operator delete(v16);
      }
      operator delete(v12);
      unsigned int v12 = v15;
    }
    while (v15);
  }
  uint64_t v13 = (void *)*((void *)this + 21);
  *((void *)this + 21) = 0;
  if (v13) {
    operator delete(v13);
  }
  float v14 = (std::__shared_weak_count *)*((void *)this + 20);
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }

  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void sub_1A23BBA6C(_Unwind_Exception *a1)
{
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v1 + 504);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 488));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 464));
  std::__tree<std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>,std::__map_value_compare<md::FrameGraphPass *,std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>,md::FrameGraphPassLessThan,true>,std::allocator<std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>>>::destroy(*(void **)(v1 + 432));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 408));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 384));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 352);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 336);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 320);
  *(void *)(v1 + 296) = &unk_1EF559678;

  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 280));
  uint64_t v3 = *(void **)(v1 + 248);
  if (v3)
  {
    *(void *)(v1 + 256) = v3;
    operator delete(v3);
  }
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v1 + 208);
  md::MeshRenderableContext::~MeshRenderableContext((md::MeshRenderableContext *)(v1 + 168));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 152);

  md::Logic<md::DrapingLogic,md::DrapingContext,md::LogicDependencies<gdc::TypeList<md::OverlaysContext,md::CameraContext,md::PendingSceneContext,md::ElevationContext>,gdc::TypeList<>>>::~Logic(v1);
  _Unwind_Resume(a1);
}

void ___ZN2md15SceneQueryLogicC2ERKNSt3__110shared_ptrINS_15RegistryManagerEEEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  *(unsigned char *)(v1 + 120) = GEOConfigGetBOOL();
  if (GEOGetVectorKitSceneQueryLogicLog(void)::onceToken != -1) {
    dispatch_once(&GEOGetVectorKitSceneQueryLogicLog(void)::onceToken, &__block_literal_global_23989);
  }
  uint64_t v2 = GEOGetVectorKitSceneQueryLogicLog(void)::log;
  if (os_log_type_enabled((os_log_t)GEOGetVectorKitSceneQueryLogicLog(void)::log, OS_LOG_TYPE_INFO))
  {
    int v3 = *(unsigned __int8 *)(v1 + 120);
    v4[0] = 67109120;
    v4[1] = v3;
    _os_log_impl(&dword_1A1780000, v2, OS_LOG_TYPE_INFO, "SpatialFlexingAllowed updated to %d", (uint8_t *)v4, 8u);
  }
}

void ___ZN2md15SceneQueryLogicC2ERKNSt3__110shared_ptrINS_15RegistryManagerEEEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_8(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  *(unsigned char *)(v1 + 121) = GEOConfigGetBOOL();
  if (GEOGetVectorKitSceneQueryLogicLog(void)::onceToken != -1) {
    dispatch_once(&GEOGetVectorKitSceneQueryLogicLog(void)::onceToken, &__block_literal_global_23989);
  }
  uint64_t v2 = GEOGetVectorKitSceneQueryLogicLog(void)::log;
  if (os_log_type_enabled((os_log_t)GEOGetVectorKitSceneQueryLogicLog(void)::log, OS_LOG_TYPE_INFO))
  {
    int v3 = *(unsigned __int8 *)(v1 + 121);
    v4[0] = 67109120;
    v4[1] = v3;
    _os_log_impl(&dword_1A1780000, v2, OS_LOG_TYPE_INFO, "RouteLineMaskingAllowed updated to %d", (uint8_t *)v4, 8u);
  }
}

void ___ZN2md15SceneQueryLogicC2ERKNSt3__110shared_ptrINS_15RegistryManagerEEEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_9(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  *(_DWORD *)(v1 + 124) = GEOConfigGetUInteger();
  if (GEOGetVectorKitSceneQueryLogicLog(void)::onceToken != -1) {
    dispatch_once(&GEOGetVectorKitSceneQueryLogicLog(void)::onceToken, &__block_literal_global_23989);
  }
  uint64_t v2 = GEOGetVectorKitSceneQueryLogicLog(void)::log;
  if (os_log_type_enabled((os_log_t)GEOGetVectorKitSceneQueryLogicLog(void)::log, OS_LOG_TYPE_INFO))
  {
    int v3 = *(_DWORD *)(v1 + 124);
    v4[0] = 67109120;
    v4[1] = v3;
    _os_log_impl(&dword_1A1780000, v2, OS_LOG_TYPE_INFO, "MaxEntitiesToFlexPerFrame updated to %d", (uint8_t *)v4, 8u);
  }
}

void md::Logic<md::SceneQueryLogic,md::SceneQueryContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::RegistryContext,md::NavigationContext,md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  int v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    unsigned int v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void geo::_retain_ptr<NSUUID * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559DB8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<NSUUID * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559DB8;

  return a1;
}

void sub_1A23BC718(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  unsigned int v12 = *(void **)v10;
  if (*(void *)v10)
  {
    *(void *)(v10 + 8) = v12;
    operator delete(v12);
  }
  _Unwind_Resume(a1);
}

void sub_1A23BCC64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a39, 8);
  _Block_object_dispose(&a43, 8);
  _Block_object_dispose((const void *)(v43 - 224), 8);
  _Block_object_dispose((const void *)(v43 - 144), 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__13(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__14(uint64_t a1)
{
}

__n128 __Block_byref_object_copy__32(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

__n128 __Block_byref_object_copy__35(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void sub_1A23BCF70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void forEachNodeInSortedPaths(void *a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = (void (**)(void, void, void, void, void, void, void, float))v4;
  if (v3 && v4)
  {
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    obuint64_t j = v3;
    uint64_t v6 = [obj countByEnumeratingWithState:&v29 objects:v33 count:16];
    if (v6)
    {
      uint64_t v26 = *(void *)v30;
      uint64_t v27 = 0;
      do
      {
        for (uint64_t i = 0; i != v6; ++i)
        {
          if (*(void *)v30 != v26) {
            objc_enumerationMutation(obj);
          }
          uint64_t v8 = *(void **)(*((void *)&v29 + 1) + 8 * i);
          if (!v27) {
            goto LABEL_11;
          }
          char v9 = [v27 section];
          int v10 = [v9 transportType];
          unint64_t v11 = [v8 section];
          int v12 = [v11 transportType];

          LODWORD(v13) = (unint64_t)[v27 routeEnd] >> 32;
          if (*(float *)&v13 >= 0.0)
          {
            unsigned int v22 = objc_msgSend(v8, "routeStart", v13);
            BOOL v14 = 1;
            if (v22 <= [v27 routeEnd] && v10 == v12)
            {
              uint64_t v23 = [v27 section];
              if ([v23 transportType] != 1)
              {
                double v24 = [v8 section];
                BOOL v14 = [v24 transportType] == 2;
              }
            }
          }
          else
          {
LABEL_11:
            BOOL v14 = 1;
          }
          uint64_t v15 = [v8 points];
          unsigned int v16 = [v8 pointCount];
          if (v16)
          {
            uint64_t v17 = 0;
            uint64_t v18 = v16;
            do
            {
              uint64_t v28 = *(void *)(*(void *)[v8 polylineCoordinates] + 8 * v17);
              if (v17) {
                BOOL v19 = 0;
              }
              else {
                BOOL v19 = v14;
              }
              [v8 laneHalfWidthAtIndex:v17];
              ((void (**)(void, uint64_t, uint64_t *, uint64_t, void *, BOOL, uint64_t, float))v5)[2](v5, v15, &v28, v17, v8, v19, [v8 gradientTrafficAtIndex:v17], v20);
              ++v17;
              v15 += 12;
            }
            while (v18 != v17);
            if ((int)v18 > 0)
            {
              id v21 = v8;

              uint64_t v27 = v21;
            }
          }
        }
        uint64_t v6 = [obj countByEnumeratingWithState:&v29 objects:v33 count:16];
      }
      while (v6);
    }
    else
    {
      uint64_t v27 = 0;
    }
  }
}

void sub_1A23BD27C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1A23BD500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  geo::fast_shared_ptr<md::RouteLineSection,mdm::MDAllocator>::~fast_shared_ptr(&a9);
  geo::fast_shared_ptr<md::RouteLineSection,mdm::MDAllocator>::~fast_shared_ptr(&a10);

  _Unwind_Resume(a1);
}

void sub_1A23BD978(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23BD9FC()
{
}

uint64_t __Block_byref_object_copy__18_24205(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = 0;
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__19_24206(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 48);
  if (v1)
  {
    if ((*v1)-- == 1)
    {
      uint64_t v3 = result;
      md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v1 + 1));
      id v4 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
      {
        id v4 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
        if (v5) {
          operator new();
        }
      }
      __n128 result = (*(uint64_t (**)(void, void, uint64_t))(**((void **)v4 + 91) + 40))(*((void *)v4 + 91), *(void *)(v3 + 48), 400);
      *(void *)(v3 + 48) = 0;
    }
  }
  return result;
}

void sub_1A23BE034(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  geo::fast_shared_ptr<md::RouteLineSection,mdm::MDAllocator>::~fast_shared_ptr((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1A23BE048(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23BE724(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL29GEOGetVectorKitVKRouteLineLogv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.VectorKit", "VKRouteLine");
  uint64_t v1 = (void *)GEOGetVectorKitVKRouteLineLog(void)::log;
  GEOGetVectorKitVKRouteLineLog(void)::log = (uint64_t)v0;
}

void sub_1A23BE8C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t geo::_retain_ptr<NSUUID * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(void *a1, void **a2)
{
  id v3 = a1;
  id v4 = *a2;
  id v5 = v3;
  id v6 = v4;
  if (v6 == v5) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = [v5 isEqual:v6];
  }

  return v7;
}

void sub_1A23BE954(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23BEBA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23BEFD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

void sub_1A23BF6F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  geo::fast_shared_ptr<md::RouteLineSection,mdm::MDAllocator>::~fast_shared_ptr((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1A23BF714(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23BF724(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<Arrow>::emplace_back<geo::PolylineCoordinate &,geo::PolylineCoordinate &,unsigned int &>(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  char v9 = *(_DWORD **)(a1 + 8);
  unint64_t v8 = *(void *)(a1 + 16);
  if ((unint64_t)v9 >= v8)
  {
    unint64_t v11 = *(_DWORD **)a1;
    uint64_t v12 = 0x2E8BA2E8BA2E8BA3 * (((uint64_t)v9 - *(void *)a1) >> 2);
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) > 0x5D1745D1745D174) {
      abort();
    }
    unint64_t v14 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v8 - (void)v11) >> 2);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x2E8BA2E8BA2E8BALL) {
      unint64_t v15 = 0x5D1745D1745D174;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15 > 0x5D1745D1745D174) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v16 = 44 * v15;
    uint64_t v17 = (char *)operator new(44 * v15);
    uint64_t v18 = &v17[44 * v12];
    *(_DWORD *)uint64_t v18 = a4;
    *(void *)(v18 + 4) = -1;
    *(void *)(v18 + 12) = a2;
    *(void *)(v18 + 20) = a3;
    *(void *)(v18 + 28) = 0xBF80000000000000;
    *(void *)(v18 + 36) = 0xBF80000000000000;
    int v10 = v18 + 44;
    if (v9 == v11)
    {
      id v21 = &v17[44 * v12];
    }
    else
    {
      do
      {
        long long v19 = *(_OWORD *)(v9 - 11);
        long long v20 = *(_OWORD *)(v9 - 7);
        id v21 = v18 - 44;
        *((_OWORD *)v18 - 1) = *((_OWORD *)v9 - 1);
        *(_OWORD *)(v18 - 28) = v20;
        *(_OWORD *)(v18 - 44) = v19;
        v9 -= 11;
        v18 -= 44;
      }
      while (v9 != v11);
    }
    *(void *)a1 = v21;
    *(void *)(a1 + 8) = v10;
    *(void *)(a1 + 16) = &v17[v16];
    if (v11) {
      operator delete(v11);
    }
  }
  else
  {
    *char v9 = a4;
    *(void *)(v9 + 1) = -1;
    *(void *)(v9 + 3) = a2;
    *(void *)(v9 + 5) = a3;
    *(void *)(v9 + 7) = 0xBF80000000000000;
    *(void *)(v9 + 9) = 0xBF80000000000000;
    int v10 = (char *)(v9 + 11);
  }
  *(void *)(a1 + 8) = v10;
}

void sub_1A23C036C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose(&a38, 8);
  _Block_object_dispose(&a45, 8);
  geo::fast_shared_ptr<md::RouteLineSection,mdm::MDAllocator>::~fast_shared_ptr((void *)(v66 + 48));
  _Block_object_dispose(&a52, 8);
  _Block_object_dispose(&a61, 8);

  _Block_object_dispose((const void *)(v68 - 200), 8);
  unint64_t v70 = *(void **)(v68 - 152);
  if (v70)
  {
    *(void *)(v68 - 144) = v70;
    operator delete(v70);
  }

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__24217(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__24218(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void sub_1A23C0658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__15(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  return result;
}

uint64_t __Block_byref_object_copy__21(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = *(void *)(a2 + 48);
  return result;
}

uint64_t __Block_byref_object_copy__24(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(_DWORD *)(result + 56) = *(_DWORD *)(a2 + 56);
  *(void *)(result + 48) = v2;
  return result;
}

void sub_1A23C1984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A23C1B48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1A23C1DF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23C1F58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23C2000(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A23C2064(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A23C20DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  std::mutex::unlock(v10);

  _Unwind_Resume(a1);
}

void sub_1A23C2168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  int v10 = v9;

  a9.super_class = (Class)VKRouteLine;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A23C22A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::ExternalIconLabelPart::populateDebugNode(md::ExternalIconLabelPart *this, gdc::DebugTreeNode *a2)
{
  md::ImageLabelPart::populateDebugNode(this, a2);
  BYTE7(v26[1]) = 21;
  strcpy((char *)v26, "ExternalIconLabelPart");
  ChildNode = gdc::DebugTreeNode::createChildNode((uint64_t)a2, v26);
  float v5 = *((float *)this + 138);
  BYTE7(v26[1]) = 5;
  strcpy((char *)v26, "Alpha");
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v22 = 0;
  int v25 = 2;
  double v21 = v5;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v26, (uint64_t)v20);
  uint64_t v6 = *((unsigned __int8 *)this + 672);
  BYTE7(v26[1]) = 8;
  strcpy((char *)v26, "Is Round");
  int v19 = 0;
  memset(&v18[4], 0, 24);
  v18[0] = v6;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v26, (uint64_t)v18);
  if (*((unsigned char *)this + 672))
  {
    BYTE7(v26[1]) = 6;
    strcpy((char *)v26, "Radius");
    double v7 = *((float *)this + 164);
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    uint64_t v14 = 0;
    int v17 = 2;
    double v13 = v7;
    gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v26, (uint64_t)v12);
    return;
  }
  BYTE7(v26[1]) = 8;
  strcpy((char *)v26, "Half Ext");
  float v8 = *((float *)this + 165);
  double v9 = *((float *)this + 166);
  int v10 = (char *)operator new(0x80uLL);
  v11[1] = (uint64_t)(v10 + 128);
  v11[2] = (uint64_t)(v10 + 128);
  *((double *)v10 + 2) = v8;
  *((void *)v10 + 5) = 0;
  *((void *)v10 + 6) = 0;
  *((void *)v10 + 4) = 0;
  *((_DWORD *)v10 + 14) = 2;
  *((void *)v10 + 12) = 0;
  *((double *)v10 + 10) = v9;
  *((void *)v10 + 13) = 0;
  *((void *)v10 + 14) = 0;
  *((_DWORD *)v10 + 30) = 2;
  v11[0] = (uint64_t)v10;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v26, v11);
  if (v10[119] < 0)
  {
    operator delete(*((void **)v10 + 12));
    if ((v10[55] & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_7:
    operator delete(*((void **)v10 + 4));
    goto LABEL_5;
  }
  if (v10[55] < 0) {
    goto LABEL_7;
  }
LABEL_5:
  operator delete(v10);
}

uint64_t md::ExternalIconLabelPart::debugString@<X0>(md::ExternalIconLabelPart *this@<X0>, unsigned char *a2@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v20);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"ExternalIcon", 12);
  uint64_t v4 = v20[0];
  *(_DWORD *)((char *)&v20[1] + *(void *)(v20[0] - 24)) = *(_DWORD *)((unsigned char *)&v20[1] + *(void *)(v20[0] - 24)) & 0xFFFFFEFB | 4;
  *(void *)((char *)&v20[2] + *(void *)(v4 - 24)) = 2;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"\n  alpha:", 9);
  std::ostream::operator<<();
  if (*((unsigned char *)this + 672))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"\n  radius:", 10);
    std::ostream::operator<<();
  }
  else
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"\n  halfExt:(", 12);
    float v5 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)", ", 2);
    uint64_t v6 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)")", 1);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"\n  ", 3);
  md::ImageLabelPart::debugString(this, __p);
  if ((v19 & 0x80u) == 0) {
    double v7 = __p;
  }
  else {
    double v7 = (void **)__p[0];
  }
  if ((v19 & 0x80u) == 0) {
    uint64_t v8 = v19;
  }
  else {
    uint64_t v8 = (uint64_t)__p[1];
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)v7, v8);
  if ((char)v19 < 0)
  {
    operator delete(__p[0]);
    char v9 = v27;
    if ((v27 & 0x10) == 0) {
      goto LABEL_12;
    }
LABEL_15:
    unint64_t v11 = v26;
    if (v26 < v23)
    {
      unint64_t v26 = v23;
      unint64_t v11 = v23;
    }
    uint64_t v12 = (const void **)&v22;
    goto LABEL_19;
  }
  char v9 = v27;
  if ((v27 & 0x10) != 0) {
    goto LABEL_15;
  }
LABEL_12:
  if ((v9 & 8) == 0)
  {
    size_t v10 = 0;
    a2[23] = 0;
    goto LABEL_27;
  }
  uint64_t v12 = (const void **)v21;
  unint64_t v11 = v21[2];
LABEL_19:
  double v13 = *v12;
  size_t v10 = v11 - (void)*v12;
  if (v10 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v10 >= 0x17)
  {
    uint64_t v14 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v14 = v10 | 7;
    }
    uint64_t v15 = v14 + 1;
    uint64_t v16 = operator new(v14 + 1);
    *((void *)a2 + 1) = v10;
    *((void *)a2 + 2) = v15 | 0x8000000000000000;
    *(void *)a2 = v16;
    a2 = v16;
    goto LABEL_26;
  }
  a2[23] = v10;
  if (v10) {
LABEL_26:
  }
    memmove(a2, v13, v10);
LABEL_27:
  a2[v10] = 0;
  v20[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v20 + *(void *)(v20[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v20[1] = MEMORY[0x1E4FBA470] + 16;
  if (v25 < 0) {
    operator delete(v24);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v28);
}

void sub_1A23C281C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

float md::ExternalIconLabelPart::calloutAnchorRect(md::ExternalIconLabelPart *this)
{
  if (*((unsigned char *)this + 672)) {
    return -*((float *)this + 164);
  }
  else {
    return -*((float *)this + 165);
  }
}

float md::ExternalIconLabelPart::pushToRenderModel(uint64_t a1, float a2)
{
  float result = fmaxf(fminf(*(float *)(a1 + 600) * a2, 1.0), 0.0);
  *(float *)(a1 + 552) = result;
  return result;
}

uint64_t md::ExternalIconLabelPart::layoutForDisplay(_DWORD *a1, double a2, double a3, double a4, uint64_t a5, uint64_t a6, _DWORD *a7)
{
  a1[130] = *a7;
  a1[131] = a7[1];
  a1[86] = *a7;
  LODWORD(a2) = a7[1];
  a1[87] = LODWORD(a2);
  md::CollisionObject::setupShapeData((uint64_t)(a1 + 78), a2, a3, a4);
  return 37;
}

uint64_t md::ExternalIconLabelPart::layoutForStaging(uint64_t a1, double a2, double a3, double a4, uint64_t a5, _DWORD *a6)
{
  if (*(unsigned char *)(a1 + 628))
  {
    uint64_t v6 = (const float *)(a1 + 668);
    float32x2_t v7 = vld1_dup_f32(v6);
    a3 = *(double *)(a1 + 620);
    a2 = COERCE_DOUBLE(vmaxnm_f32(*(float32x2_t *)&a3, v7));
    *(double *)(a1 + 168) = a2;
    *(unsigned char *)(a1 + 271) = *(unsigned char *)(a1 + 631);
    *(unsigned char *)(a1 + 628) = 0;
  }
  *(_DWORD *)(a1 + 280) = *a6;
  *(_DWORD *)(a1 + 284) = a6[1];
  *(_DWORD *)(a1 + 104) = *a6;
  LODWORD(a2) = a6[1];
  *(_DWORD *)(a1 + 108) = LODWORD(a2);
  md::CollisionObject::setupShapeData(a1 + 72, a2, a3, a4);
  return 37;
}

void md::ExternalIconLabelPart::~ExternalIconLabelPart(md::ExternalIconLabelPart *this)
{
  md::ExternalIconLabelPart::~ExternalIconLabelPart(this);
  uint64_t v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  uint64_t v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

{
  std::__shared_weak_count *v2;

  *(void *)this = &unk_1EF53F168;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 81);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF5540C8;
  free(*((void **)this + 59));
  free(*((void **)this + 60));
  free(*((void **)this + 62));
  free(*((void **)this + 29));
  free(*((void **)this + 30));
  free(*((void **)this + 32));
}

uint64_t md::HillshadeRenderLayer::prepare(md::HillshadeRenderLayer *this, md::LayoutContext *a2)
{
  return (*(uint64_t (**)(md::HillshadeRenderLayer *, md::LayoutContext *))(*(void *)this + 104))(this, a2);
}

uint64_t md::HillshadeRenderLayer::reserveStencilRange(uint64_t result, uint64_t a2)
{
  unsigned __int8 v2 = *(unsigned char *)(result + 49) - *(unsigned char *)(result + 48) + 1;
  int v3 = *(unsigned __int8 **)(a2 + 24);
  int v4 = *v3;
  if (v4 + v2 > v3[1])
  {
    uint64_t v5 = *(void *)(result + 368);
    *(unsigned char *)(v5 + 28) = v3[32];
    *(_DWORD *)(v5 + 32) = *((_DWORD *)v3 + 9);
    v3[1] = v3[2];
    int v4 = 1;
  }
  *int v3 = v4 + v2;
  *(_DWORD *)(result + 376) = v4 - *(unsigned __int8 *)(result + 48);
  return result;
}

void md::HillshadeRenderLayer::layout(md::HillshadeRenderLayer *this, const md::LayoutContext *a2)
{
  unsigned __int8 v2 = (uint64_t *)*((void *)a2 + 1);
  int8x8_t v3 = (int8x8_t)v2[1];
  if (v3)
  {
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(v3);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      uint64_t v7 = 0x3070CB6B3C7F21D3;
      if (*(void *)&v3 <= 0x3070CB6B3C7F21D3uLL) {
        uint64_t v7 = 0x3070CB6B3C7F21D3uLL % *(void *)&v3;
      }
    }
    else
    {
      uint64_t v7 = (*(void *)&v3 - 1) & 0x3070CB6B3C7F21D3;
    }
    uint64_t v8 = *v2;
    char v9 = *(void **)(v8 + 8 * v7);
    if (!v9) {
      goto LABEL_24;
    }
    size_t v10 = (void *)*v9;
    if (!v10) {
      goto LABEL_24;
    }
    if (v6.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v12 = v10[1];
        if (v12 == 0x3070CB6B3C7F21D3)
        {
          if (v10[2] == 0x3070CB6B3C7F21D3) {
            goto LABEL_22;
          }
        }
        else if ((v12 & (*(void *)&v3 - 1)) != v7)
        {
          goto LABEL_24;
        }
        size_t v10 = (void *)*v10;
        if (!v10) {
          goto LABEL_24;
        }
      }
    }
    while (1)
    {
      unint64_t v11 = v10[1];
      if (v11 == 0x3070CB6B3C7F21D3) {
        break;
      }
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
      if (v11 != v7) {
        goto LABEL_24;
      }
LABEL_11:
      size_t v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_24;
      }
    }
    if (v10[2] != 0x3070CB6B3C7F21D3) {
      goto LABEL_11;
    }
LABEL_22:
    uint64_t v13 = v10[5];
    if (*(void *)(v13 + 8) == 0x3070CB6B3C7F21D3)
    {
      uint64_t v147 = *(void *)(v13 + 32);
      goto LABEL_25;
    }
LABEL_24:
    uint64_t v147 = 0;
LABEL_25:
    if (v6.u32[0] > 1uLL)
    {
      uint64_t v14 = 0x1AF456233693CD46;
      if (*(void *)&v3 <= 0x1AF456233693CD46uLL) {
        uint64_t v14 = 0x1AF456233693CD46uLL % *(void *)&v3;
      }
    }
    else
    {
      uint64_t v14 = (*(void *)&v3 - 1) & 0x1AF456233693CD46;
    }
    uint64_t v15 = *(void **)(v8 + 8 * v14);
    if (v15)
    {
      uint64_t v16 = (void *)*v15;
      if (v16)
      {
        if (v6.u32[0] < 2uLL)
        {
          uint64_t v17 = *(void *)&v3 - 1;
          while (1)
          {
            uint64_t v19 = v16[1];
            if (v19 == 0x1AF456233693CD46)
            {
              if (v16[2] == 0x1AF456233693CD46) {
                goto LABEL_45;
              }
            }
            else if ((v19 & v17) != v14)
            {
              return;
            }
            uint64_t v16 = (void *)*v16;
            if (!v16) {
              return;
            }
          }
        }
        while (1)
        {
          unint64_t v18 = v16[1];
          if (v18 == 0x1AF456233693CD46) {
            break;
          }
          if (v18 >= *(void *)&v3) {
            v18 %= *(void *)&v3;
          }
          if (v18 != v14) {
            return;
          }
LABEL_34:
          uint64_t v16 = (void *)*v16;
          if (!v16) {
            return;
          }
        }
        if (v16[2] != 0x1AF456233693CD46) {
          goto LABEL_34;
        }
LABEL_45:
        uint64_t v20 = v16[5];
        if (*(void *)(v20 + 8) == 0x1AF456233693CD46)
        {
          uint64_t v144 = *(void *)(v20 + 32);
          if (v144)
          {
            uint64_t v21 = *((void *)this + 44);
            *(void *)(v21 + 112) = 0;
            *(void *)(v21 + 120) = 0;
            uint64_t v22 = *((void *)this + 48);
            ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v22 + 48));
            ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v22 + 56));
            unint64_t v23 = (void *)md::PassList::commandBufferForId(*(void **)(*(void *)(*((void *)this + 5) + 24) + 8), *((unsigned char *)this + 392), *((unsigned char *)this + 393));
            uint64_t v24 = v23[9];
            if (v23[10] != v24) {
              v23[10] = v24;
            }
            v23[4] = *((void *)this + 46);
            int v25 = *((_DWORD *)this + 94);
            LOBYTE(v158) = 0;
            uint64_t v142 = (uint64_t)v23;
            md::CartographicTiledVectorRenderLayer<HillshadeRenderable>::layoutStencilTiles((uint64_t)this, a2, (uint64_t)v23, v25, &v158);
            uint64_t v26 = *((void *)this + 34);
            uint64_t v145 = *((void *)this + 35);
            if (v26 != v145)
            {
              unsigned int v27 = (int)fmaxf(*(float *)(v144 + 3080) + *(float *)(v144 + 3076), 1.0);
              if (v27 >= 0x17) {
                unsigned int v27 = 23;
              }
              unsigned int v143 = v27;
              float32x4_t v141 = (float32x4_t)vdupq_n_s32(0x37800080u);
              do
              {
                uint64_t v28 = *(void **)v26;
                uint64_t v29 = *(void *)(*(void *)v26 + 384);
                uint64_t v30 = *(void *)(v29 + 736);
                long long v31 = *(std::__shared_weak_count **)(v29 + 744);
                if (v31)
                {
                  atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
                  if (!atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
                    std::__shared_weak_count::__release_weak(v31);
                  }
                }
                if (!v30) {
                  goto LABEL_54;
                }
                int v32 = *((unsigned __int8 *)this + 360);
                if (*((unsigned char *)this + 360)) {
                  int v146 = *((_DWORD *)this + 94) + *(unsigned __int8 *)(v29 + 169);
                }
                else {
                  LOBYTE(v146) = 0;
                }
                int v33 = *(unsigned __int8 *)(v144 + 3776);
                uint64_t v34 = (std::__shared_weak_count *)v28[28];
                uint64_t v156 = v28[27];
                uint64_t v157 = v34;
                if (v34) {
                  atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                float64x2_t v35 = (std::__shared_weak_count *)v28[30];
                uint64_t v154 = v28[29];
                uint64_t v155 = v35;
                if (v35) {
                  atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v36 = *(void *)(*((void *)this + 48) + 56);
                uint64_t v37 = *(void *)(v36 + 8);
                if (v37 == *(void *)v36)
                {
                  uint64_t v49 = *(void *)(v36 + 88);
                  if (!v49) {
                    goto LABEL_202;
                  }
                  uint64_t v38 = (*(uint64_t (**)(uint64_t))(*(void *)v49 + 48))(v49);
                  double v39 = *(uint64_t **)(v36 + 40);
                  unint64_t v50 = *(void *)(v36 + 48);
                  if ((unint64_t)v39 >= v50)
                  {
                    uint64_t v52 = *(void *)(v36 + 32);
                    uint64_t v53 = ((uint64_t)v39 - v52) >> 3;
                    unint64_t v54 = v53 + 1;
                    if ((unint64_t)(v53 + 1) >> 61) {
LABEL_203:
                    }
                      abort();
                    uint64_t v55 = v50 - v52;
                    if (v55 >> 2 > v54) {
                      unint64_t v54 = v55 >> 2;
                    }
                    if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8) {
                      uint64_t v56 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      uint64_t v56 = v54;
                    }
                    if (v56)
                    {
                      uint64_t v57 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v36 + 56) + 16))(*(void *)(v36 + 56), 8 * v56, 8);
                      BOOL v47 = (uint64_t *)(v57 + 8 * v53);
                      uint64_t v48 = v57 + 8 * v56;
                      if (v57) {
                        uint64_t *v47 = v38;
                      }
                    }
                    else
                    {
                      uint64_t v48 = 0;
                      BOOL v47 = (uint64_t *)(8 * v53);
                    }
                    uint64_t v68 = *(void *)(v36 + 32);
                    uint64_t v58 = *(void *)(v36 + 40);
                    uint64_t v69 = v58 - v68;
                    if (v58 != v68)
                    {
                      unint64_t v70 = v69 - 8;
                      if ((unint64_t)(v69 - 8) < 0x38)
                      {
                        unint64_t v62 = v47;
                      }
                      else
                      {
                        unint64_t v62 = v47;
                        if ((unint64_t)(v58 - (void)v47) >= 0x20)
                        {
                          uint64_t v71 = (v70 >> 3) + 1;
                          uint64_t v72 = v47 - 2;
                          uint64_t v73 = (long long *)(v58 - 16);
                          uint64_t v74 = v71 & 0x3FFFFFFFFFFFFFFCLL;
                          do
                          {
                            long long v75 = *v73;
                            *((_OWORD *)v72 - 1) = *(v73 - 1);
                            *(_OWORD *)uint64_t v72 = v75;
                            v72 -= 4;
                            v73 -= 2;
                            v74 -= 4;
                          }
                          while (v74);
                          unint64_t v62 = &v47[-(v71 & 0x3FFFFFFFFFFFFFFCLL)];
                          v58 -= 8 * (v71 & 0x3FFFFFFFFFFFFFFCLL);
                          if (v71 == (v71 & 0x3FFFFFFFFFFFFFFCLL))
                          {
LABEL_113:
                            uint64_t v58 = *(void *)(v36 + 32);
LABEL_114:
                            uint64_t v51 = v47 + 1;
                            *(void *)(v36 + 32) = v62;
                            *(void *)(v36 + 40) = v47 + 1;
                            uint64_t v78 = *(void *)(v36 + 48);
                            *(void *)(v36 + 48) = v48;
                            if (v58) {
                              (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v36 + 56) + 40))(*(void *)(v36 + 56), v58, v78 - v58);
                            }
                            goto LABEL_116;
                          }
                        }
                      }
                      do
                      {
                        uint64_t v77 = *(void *)(v58 - 8);
                        v58 -= 8;
                        *--unint64_t v62 = v77;
                      }
                      while (v58 != v68);
                      goto LABEL_113;
                    }
LABEL_107:
                    unint64_t v62 = v47;
                    goto LABEL_114;
                  }
                }
                else
                {
                  uint64_t v38 = *(void *)(v37 - 8);
                  *(void *)(v36 + 8) = v37 - 8;
                  double v39 = *(uint64_t **)(v36 + 40);
                  unint64_t v40 = *(void *)(v36 + 48);
                  if ((unint64_t)v39 >= v40)
                  {
                    uint64_t v41 = *(void *)(v36 + 32);
                    uint64_t v42 = ((uint64_t)v39 - v41) >> 3;
                    unint64_t v43 = v42 + 1;
                    if ((unint64_t)(v42 + 1) >> 61) {
                      goto LABEL_203;
                    }
                    uint64_t v44 = v40 - v41;
                    if (v44 >> 2 > v43) {
                      unint64_t v43 = v44 >> 2;
                    }
                    if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8) {
                      uint64_t v45 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      uint64_t v45 = v43;
                    }
                    if (v45)
                    {
                      uint64_t v46 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v36 + 56) + 16))(*(void *)(v36 + 56), 8 * v45, 8);
                      BOOL v47 = (uint64_t *)(v46 + 8 * v42);
                      uint64_t v48 = v46 + 8 * v45;
                      if (v46) {
                        uint64_t *v47 = v38;
                      }
                    }
                    else
                    {
                      uint64_t v48 = 0;
                      BOOL v47 = (uint64_t *)(8 * v42);
                    }
                    uint64_t v59 = *(void *)(v36 + 32);
                    uint64_t v58 = *(void *)(v36 + 40);
                    uint64_t v60 = v58 - v59;
                    if (v58 != v59)
                    {
                      unint64_t v61 = v60 - 8;
                      if ((unint64_t)(v60 - 8) < 0x38)
                      {
                        unint64_t v62 = v47;
                      }
                      else
                      {
                        unint64_t v62 = v47;
                        if ((unint64_t)(v58 - (void)v47) >= 0x20)
                        {
                          uint64_t v63 = (v61 >> 3) + 1;
                          long long v64 = v47 - 2;
                          long long v65 = (long long *)(v58 - 16);
                          uint64_t v66 = v63 & 0x3FFFFFFFFFFFFFFCLL;
                          do
                          {
                            long long v67 = *v65;
                            *((_OWORD *)v64 - 1) = *(v65 - 1);
                            *(_OWORD *)long long v64 = v67;
                            v64 -= 4;
                            v65 -= 2;
                            v66 -= 4;
                          }
                          while (v66);
                          unint64_t v62 = &v47[-(v63 & 0x3FFFFFFFFFFFFFFCLL)];
                          v58 -= 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
                          if (v63 == (v63 & 0x3FFFFFFFFFFFFFFCLL)) {
                            goto LABEL_113;
                          }
                        }
                      }
                      do
                      {
                        uint64_t v76 = *(void *)(v58 - 8);
                        v58 -= 8;
                        *--unint64_t v62 = v76;
                      }
                      while (v58 != v59);
                      goto LABEL_113;
                    }
                    goto LABEL_107;
                  }
                }
                if (v39) {
                  uint64_t *v39 = v38;
                }
                uint64_t v51 = v39 + 1;
LABEL_116:
                *(void *)(v36 + 40) = v51;
                *(void *)&long long v158 = v38;
                uint64_t v79 = *(void *)(v36 + 120);
                if (!v79)
                {
LABEL_202:
                  std::__throw_bad_function_call[abi:nn180100]();
                  __break(1u);
                  return;
                }
                (*(void (**)(uint64_t, long long *))(*(void *)v79 + 48))(v79, &v158);
                uint64_t v80 = *((void *)this + 48);
                uint64_t v81 = v80 + 32;
                uint64_t v82 = 16;
                if ((v33 - 1) >= 3) {
                  uint64_t v81 = v80 + 16;
                }
                else {
                  uint64_t v82 = 32;
                }
                uint64_t v83 = *(void *)(v80 + v82);
                char v84 = *(std::__shared_weak_count **)(v81 + 8);
                if (v84) {
                  atomic_fetch_add_explicit(&v84->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                if (!v83 || **(void **)(v83 + 40) != *(void *)(v38 + 8))
                {
                  unint64_t v85 = *(std::__shared_weak_count **)(v38 + 24);
                  *(void *)(v38 + 16) = 0;
                  *(void *)(v38 + 24) = 0;
                  if (!v85) {
                    goto LABEL_134;
                  }
LABEL_132:
                  if (!atomic_fetch_add(&v85->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
                    std::__shared_weak_count::__release_weak(v85);
                  }
                  goto LABEL_134;
                }
                uint64_t v86 = *(void *)(v38 + 16);
                if (v86 && v86 != v83) {
                  ggl::PipelineSetup::resetData(v38);
                }
                if (v84) {
                  atomic_fetch_add_explicit(&v84->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                unint64_t v85 = *(std::__shared_weak_count **)(v38 + 24);
                *(void *)(v38 + 16) = v83;
                *(void *)(v38 + 24) = v84;
                if (v85) {
                  goto LABEL_132;
                }
LABEL_134:
                if (v84 && !atomic_fetch_add(&v84->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
                  std::__shared_weak_count::__release_weak(v84);
                }
                uint64_t v87 = *(void *)(v29 + 736);
                int v88 = *(std::__shared_weak_count **)(v29 + 744);
                if (v88)
                {
                  atomic_fetch_add_explicit(&v88->__shared_owners_, 1uLL, memory_order_relaxed);
                  **(void **)(v38 + 96) = v87;
                  if (!atomic_fetch_add(&v88->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
                    std::__shared_weak_count::__release_weak(v88);
                  }
                }
                else
                {
                  **(void **)(v38 + 96) = v87;
                }
                char v89 = *(void **)(v38 + 64);
                uint64_t v90 = v156;
                *char v89 = v156;
                v89[1] = 0;
                long long v91 = *(void **)(v38 + 160);
                float64x2_t v92 = v157;
                if (v157) {
                  atomic_fetch_add_explicit(&v157->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                long long v93 = (std::__shared_weak_count *)v91[1];
                *long long v91 = v90;
                v91[1] = v92;
                if (v93 && !atomic_fetch_add(&v93->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v93->__on_zero_shared)(v93);
                  std::__shared_weak_count::__release_weak(v93);
                }
                uint64_t v94 = *(void *)(v38 + 64);
                uint64_t v95 = v154;
                long long v96 = v155;
                *(void *)(v94 + 16) = v154;
                *(void *)(v94 + 24) = 0;
                uint64_t v97 = *(void *)(v38 + 160);
                if (v96) {
                  atomic_fetch_add_explicit(&v96->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v98 = *(std::__shared_weak_count **)(v97 + 24);
                *(void *)(v97 + 16) = v95;
                *(void *)(v97 + 24) = v96;
                if (v98 && !atomic_fetch_add(&v98->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
                  std::__shared_weak_count::__release_weak(v98);
                }
                uint64_t v99 = ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*((void *)this + 48) + 48));
                uint64_t v100 = v99;
                *(void *)(v99 + 24) = *(void *)(*((void *)this + 48) + 8 * (v32 != 0));
                *(void *)(v99 + 32) = v38;
                uint64_t v101 = 16;
                if (*(unsigned __int8 *)(v147 + 320) - 1 < 3) {
                  uint64_t v101 = 32;
                }
                *(void *)(v99 + 64) = *(void *)(v147 + v101);
                *(void *)(v99 + 16) = "hillshade";
                *(_DWORD *)(v99 + 40) = v146;
                uint64_t v102 = *(void *)(*(void *)(v38 + 64) + 32);
                long long v158 = 0uLL;
                unint64_t v103 = *(void *)(v102 + 8);
                if (v103) {
                  long long v104 = *(float32x4_t **)(v102 + 72);
                }
                else {
                  long long v104 = 0;
                }
                *(void *)&long long v105 = 0;
                *((void *)&v105 + 1) = v102;
                long long v158 = v105;
                unint64_t v159 = 0;
                unint64_t v160 = v103;
                uint64_t v162 = v104;
                __int16 v161 = 1;
                uint64_t v106 = *(void *)(v29 + 720);
                uint64_t v107 = *(std::__shared_weak_count **)(v29 + 728);
                uint64_t v148 = v106;
                unint64_t v149 = v107;
                if (v107)
                {
                  atomic_fetch_add_explicit(&v107->__shared_owners_, 1uLL, memory_order_relaxed);
                  uint64_t v150 = v106;
                  uint64_t v151 = v107;
                  atomic_fetch_add_explicit(&v107->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                else
                {
                  uint64_t v150 = v106;
                  uint64_t v151 = 0;
                }
                gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v152, v106, (uint64_t)v107);
                if (v107 && !atomic_fetch_add(&v107->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v107->__on_zero_shared)(v107);
                  std::__shared_weak_count::__release_weak(v107);
                  long long v108 = v149;
                  if (!v149)
                  {
LABEL_163:
                    int v109 = v153;
                    if (!v153) {
                      goto LABEL_173;
                    }
                    goto LABEL_164;
                  }
                }
                else
                {
                  long long v108 = v149;
                  if (!v149) {
                    goto LABEL_163;
                  }
                }
                if (atomic_fetch_add(&v108->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
                  goto LABEL_163;
                }
                ((void (*)(std::__shared_weak_count *))v108->__on_zero_shared)(v108);
                std::__shared_weak_count::__release_weak(v108);
                int v109 = v153;
                if (!v153)
                {
LABEL_173:
                  uint64_t v116 = v162;
                  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v152);
                  if (!v116) {
                    goto LABEL_195;
                  }
                  goto LABEL_180;
                }
LABEL_164:
                uint64_t v110 = *(void *)(v152[0] + 24);
                long long v111 = *(float **)v110;
                if (*(void *)v110
                  && (float v112 = *v111, LODWORD(v111) = *v111 == 1.0, *(unsigned char *)(v110 + 10))
                  && v112 != 0.0
                  && v112 != 1.0
                  || (v113 = *(unsigned __int8 *)(v110 + v111 + 11), float v112 = 0.0, v113 == 2))
                {
                  LOBYTE(v150) = 1;
                  LOBYTE(v148) = 1;
                  float v114 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v110, 0xC2u, v143, 0, &v150);
                  _S8 = v114
                      + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v110, 0xC2u, v143, 1u, &v148)- v114)* v112);
                }
                else
                {
                  _S8 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v152[0] + 24), 0xC2u, v143, v113, 0);
                }
                gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v150, *(void *)(v152[0] + 24), 0x1B6u, v143, 2u, 0);
                uint16x4_t v117 = (uint16x4_t)v150;
                gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v150, *(void *)(v152[0] + 24), 0x5Cu, v143, 2u, 0);
                uint16x4_t v118 = (uint16x4_t)v150;
                int v119 = +[VKDebugSettings sharedSettings];
                int v120 = [v119 enableDebugSettingForHillShade];

                if (v120)
                {
                  float v121 = +[VKDebugSettings sharedSettings];
                  [v121 hillshadeOpacity];
                  _S8 = v122;

                  unsigned __int8 v123 = +[VKDebugSettings sharedSettings];
                  [v123 hillshadeBlendMode];
                  unsigned int v125 = vcvtms_u32_f32(v124);
                }
                else
                {
                  unsigned int v125 = 11;
                }
                uint64_t v126 = v162;
                __asm { FCVT            H2, S8 }
                v162[2].i16[0] = _H2;
                *uint64_t v126 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v117)), v141);
                v126[1] = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v118)), v141);
                v126[2].i32[1] = v125;
                ggl::CommandBuffer::pushRenderItem(v142, v100);
                gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v152);
LABEL_180:
                unint64_t v133 = v159;
                unint64_t v132 = v160;
                if (v160 != v159)
                {
                  unint64_t v134 = (void *)*((void *)&v158 + 1);
                  int v135 = v161;
                  int v136 = HIBYTE(v161);
                  if ((void)v158 && *(unsigned char *)(*((void *)&v158 + 1) + 17) != 2) {
                    (*(void (**)(void))(*(void *)v158 + 64))();
                  }
                  if (v135 && !v136)
                  {
                    unint64_t v137 = v134[7];
                    unint64_t v138 = v134[8];
                    if (v138 == v137) {
                      unint64_t v137 = v134[10] - v134[9];
                    }
                    if (v133 < v137) {
                      unint64_t v137 = v133;
                    }
                    if (v138 <= v132) {
                      unint64_t v138 = v132;
                    }
                    if (v138 == v137) {
                      unint64_t v138 = v137 + v134[10] - v134[9];
                    }
                    v134[7] = v137;
                    v134[8] = v138;
                  }
                }
LABEL_195:
                uint64_t v139 = v155;
                if (v155 && !atomic_fetch_add(&v155->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v139->__on_zero_shared)(v139);
                  std::__shared_weak_count::__release_weak(v139);
                }
                uint64_t v140 = v157;
                if (v157)
                {
                  if (!atomic_fetch_add(&v157->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v140->__on_zero_shared)(v140);
                    std::__shared_weak_count::__release_weak(v140);
                  }
                }
                if (!v109) {
                  return;
                }
LABEL_54:
                v26 += 8;
              }
              while (v26 != v145);
            }
          }
        }
      }
    }
  }
}

void sub_1A23C3930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,char a29,uint64_t a30,char a31)
{
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&a22);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a31);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a27);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a29);
  _Unwind_Resume(a1);
}

void md::HillshadeRenderLayer::~HillshadeRenderLayer(md::HillshadeRenderLayer *this)
{
  *(void *)this = off_1EF53D710;
  unsigned __int8 v2 = (md::HillshadeRenderResources *)*((void *)this + 48);
  *((void *)this + 48) = 0;
  if (v2)
  {
    md::HillshadeRenderResources::~HillshadeRenderResources(v2);
    MEMORY[0x1A6239270]();
  }
  uint64_t v3 = *((void *)this + 46);
  *((void *)this + 46) = 0;
  if (v3) {
    MEMORY[0x1A6239270](v3, 0x1000C4049ECCB0CLL);
  }
  md::CartographicTiledVectorRenderLayer<HillshadeRenderable>::~CartographicTiledVectorRenderLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  md::HillshadeRenderResources *v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = off_1EF53D710;
  unsigned __int8 v2 = (md::HillshadeRenderResources *)*((void *)this + 48);
  *((void *)this + 48) = 0;
  if (v2)
  {
    md::HillshadeRenderResources::~HillshadeRenderResources(v2);
    MEMORY[0x1A6239270]();
  }
  uint64_t v3 = *((void *)this + 46);
  *((void *)this + 46) = 0;
  if (v3) {
    MEMORY[0x1A6239270](v3, 0x1000C4049ECCB0CLL);
  }
  md::CartographicTiledVectorRenderLayer<HillshadeRenderable>::~CartographicTiledVectorRenderLayer(this);
}

void md::HillshadeRenderResources::~HillshadeRenderResources(md::HillshadeRenderResources *this)
{
  unsigned __int8 v2 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v3)
  {
    uint64_t v4 = ggl::FragmentedPool<ggl::Hillshade::Pos2DUVPipelineSetup>::~FragmentedPool(v3);
    MEMORY[0x1A6239270](v4, 0x10A0C40D234DDC7);
  }
  uint64_t v5 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v5)
  {
    uint64_t v6 = ggl::FragmentedPool<ggl::RenderItem>::~FragmentedPool(v5);
    MEMORY[0x1A6239270](v6, 0x10A0C40D234DDC7);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 3);
    if (!v8) {
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 3);
    if (!v8) {
      goto LABEL_14;
    }
  }
  if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
LABEL_14:
  uint64_t v9 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *(void *)this;
  *(void *)this = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
}

uint64_t ggl::FragmentedPool<ggl::Hillshade::Pos2DUVPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  unsigned __int8 v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_9Hillshade20Pos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  float result = operator new(0x10uLL);
  void *result = &unk_1EF57C870;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_9Hillshade20Pos2DUVPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::HillshadeRenderResources::HillshadeRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::HillshadeRenderResources::HillshadeRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,ggl::Hillshade::Pos2DUVPipelineSetup * ()(void)>::operator()()
{
}

void ggl::ConstantDataTyped<ggl::Hillshade::HillshadeStyle>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::Hillshade::HillshadeStyle>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Hillshade::HillshadeStyle>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Hillshade::HillshadeStyle>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587950;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Hillshade::HillshadeStyle>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587950;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::HillshadeRenderResources::HillshadeRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::HillshadeRenderResources::HillshadeRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,ggl::Hillshade::Pos2DUVPipelineSetup * ()(void)>::__clone()
{
  float result = operator new(0x10uLL);
  void *result = &unk_1EF576C68;
  return result;
}

void std::__function::__func<md::HillshadeRenderResources::HillshadeRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::HillshadeRenderResources::HillshadeRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,ggl::Hillshade::Pos2DUVPipelineSetup * ()(void)>::~__func()
{
}

void std::__function::__func<md::HillshadeRenderResources::HillshadeRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::HillshadeRenderResources::HillshadeRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::RenderItem * ()(void)>::operator()()
{
}

void *std::__function::__func<md::HillshadeRenderResources::HillshadeRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::HillshadeRenderResources::HillshadeRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::RenderItem * ()(void)>::__clone()
{
  float result = operator new(0x10uLL);
  void *result = &unk_1EF576C20;
  return result;
}

void std::__function::__func<md::HillshadeRenderResources::HillshadeRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::HillshadeRenderResources::HillshadeRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::RenderItem * ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::Hillshade::Pos2DUVPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Hillshade::Pos2DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589CF8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Hillshade::Pos2DUVPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589CF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t altitude::SkeletonRequestManager::request(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 80))(a1, a2, a3, a4, a5, a6, 0);
}

void karo::AsyncRequestManagerTemplate<altitude::TileId,karo::AsyncRequestManagerNoArgs>::getRequest(uint64_t a1@<X0>, unsigned int *a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  uint64_t v7 = (uint64_t **)(a1 + 72);
  uint64_t v6 = *(uint64_t **)(a1 + 72);
  if (!v6) {
    goto LABEL_17;
  }
  unsigned int v9 = *a2;
  unsigned int v8 = a2[1];
  uint64_t v10 = (uint64_t **)(a1 + 72);
  unsigned int v12 = a2[2];
  unsigned int v11 = a2[3];
  do
  {
    unsigned int v13 = *((_DWORD *)v6 + 8);
    if (v13 < v9)
    {
LABEL_3:
      ++v6;
      goto LABEL_4;
    }
    if (v13 > v9) {
      goto LABEL_7;
    }
    unsigned int v14 = *((_DWORD *)v6 + 9);
    if (v14 < v8) {
      goto LABEL_3;
    }
    if (v14 > v8) {
      goto LABEL_7;
    }
    unsigned int v15 = *((_DWORD *)v6 + 10);
    if (v15 < v12) {
      goto LABEL_3;
    }
    if (v15 > v12)
    {
LABEL_7:
      uint64_t v10 = (uint64_t **)v6;
    }
    else if (*((_DWORD *)v6 + 11) < v11)
    {
      ++v6;
    }
    else
    {
      uint64_t v10 = (uint64_t **)v6;
    }
LABEL_4:
    uint64_t v6 = (uint64_t *)*v6;
  }
  while (v6);
  if (v10 != v7)
  {
    unsigned int v16 = *((_DWORD *)v10 + 8);
    if (v9 >= v16)
    {
      if (v9 > v16
        || (unsigned int v38 = *((_DWORD *)v10 + 9), v8 >= v38)
        && (v8 > v38 || (unsigned int v39 = *((_DWORD *)v10 + 10), v12 >= v39) && (v12 > v39 || v11 >= *((_DWORD *)v10 + 11))))
      {
        long long v31 = v10[6];
        uint64_t v30 = v10[7];
        if (v30) {
          atomic_fetch_add_explicit(v30 + 1, 1uLL, memory_order_relaxed);
        }
        *a3 = (uint64_t)v31;
        a3[1] = (uint64_t)v30;
        return;
      }
    }
  }
LABEL_17:
  (*(void (**)(uint64_t *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 64))(&v40, a1, a2);
  uint64_t v18 = v40;
  uint64_t v17 = v41;
  *a3 = v40;
  a3[1] = (uint64_t)v17;
  uint64_t v19 = *v7;
  uint64_t v20 = v7;
  if (*v7)
  {
    unsigned int v21 = *a2;
    unsigned int v22 = a2[1];
    unsigned int v23 = a2[2];
    unsigned int v24 = a2[3];
    while (1)
    {
      uint64_t v20 = v19;
      unsigned int v25 = *((_DWORD *)v19 + 8);
      if (v21 < v25) {
        goto LABEL_19;
      }
      if (v21 > v25) {
        goto LABEL_22;
      }
      unsigned int v26 = *((_DWORD *)v20 + 9);
      if (v22 < v26) {
        goto LABEL_19;
      }
      if (v22 > v26) {
        goto LABEL_22;
      }
      unsigned int v27 = *((_DWORD *)v20 + 10);
      if (v23 < v27) {
        goto LABEL_19;
      }
      if (v23 > v27) {
        goto LABEL_22;
      }
      unsigned int v28 = *((_DWORD *)v20 + 11);
      if (v24 < v28)
      {
LABEL_19:
        uint64_t v19 = (uint64_t *)*v20;
        uint64_t v7 = (uint64_t **)v20;
        if (!*v20) {
          break;
        }
      }
      else
      {
        if (v28 >= v24)
        {
          uint64_t v29 = v20;
          goto LABEL_38;
        }
LABEL_22:
        uint64_t v19 = (uint64_t *)v20[1];
        if (!v19)
        {
          uint64_t v7 = (uint64_t **)(v20 + 1);
          break;
        }
      }
    }
  }
  uint64_t v29 = operator new(0x40uLL);
  *((_OWORD *)v29 + 2) = *(_OWORD *)a2;
  *((void *)v29 + 6) = 0;
  *((void *)v29 + 7) = 0;
  *(void *)uint64_t v29 = 0;
  *((void *)v29 + 1) = 0;
  *((void *)v29 + 2) = v20;
  *uint64_t v7 = (uint64_t *)v29;
  uint64_t v32 = **(void **)(a1 + 64);
  int v33 = (uint64_t *)v29;
  if (v32)
  {
    *(void *)(a1 + 64) = v32;
    int v33 = *v7;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 72), v33);
  ++*(void *)(a1 + 80);
LABEL_38:
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v34 = (std::__shared_weak_count *)*((void *)v29 + 7);
  *((void *)v29 + 6) = v18;
  *((void *)v29 + 7) = v17;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  unint64_t v35 = *(void *)(a1 + 48);
  if (v35)
  {
    uint64_t v36 = *a3;
    uint64_t v37 = (std::__shared_weak_count *)a3[1];
    uint64_t v40 = v36;
    uint64_t v41 = v37;
    if (v37)
    {
      atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::JobManager::queueJob(v35, &v40);
      if (!atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
    else
    {
      karo::JobManager::queueJob(v35, &v40);
    }
  }
}

void sub_1A23C48D0(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileId,karo::AsyncRequestManagerNoArgs>::waitOnRequest(uint64_t a1, unsigned int *a2, unsigned int a3)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  uint64_t v6 = *(uint64_t **)(a1 + 72);
  if (!v6)
  {
LABEL_23:
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
    return 0;
  }
  unsigned int v8 = *a2;
  unsigned int v7 = a2[1];
  unsigned int v9 = (uint64_t *)(a1 + 72);
  unsigned int v11 = a2[2];
  unsigned int v10 = a2[3];
  do
  {
    unsigned int v12 = *((_DWORD *)v6 + 8);
    if (v12 < v8)
    {
LABEL_3:
      ++v6;
      goto LABEL_4;
    }
    if (v12 > v8) {
      goto LABEL_11;
    }
    unsigned int v13 = *((_DWORD *)v6 + 9);
    if (v13 < v7) {
      goto LABEL_3;
    }
    if (v13 > v7) {
      goto LABEL_11;
    }
    unsigned int v14 = *((_DWORD *)v6 + 10);
    if (v14 < v11) {
      goto LABEL_3;
    }
    if (v14 <= v11)
    {
      if (*((_DWORD *)v6 + 11) < v10) {
        ++v6;
      }
      else {
        unsigned int v9 = v6;
      }
    }
    else
    {
LABEL_11:
      unsigned int v9 = v6;
    }
LABEL_4:
    uint64_t v6 = (uint64_t *)*v6;
  }
  while (v6);
  if (v9 == (uint64_t *)(a1 + 72)) {
    goto LABEL_23;
  }
  unsigned int v15 = *((_DWORD *)v9 + 8);
  if (v8 < v15) {
    goto LABEL_23;
  }
  if (v8 <= v15)
  {
    unsigned int v16 = *((_DWORD *)v9 + 9);
    if (v7 < v16) {
      goto LABEL_23;
    }
    if (v7 <= v16)
    {
      unsigned int v17 = *((_DWORD *)v9 + 10);
      if (v11 < v17 || v11 <= v17 && v10 < *((_DWORD *)v9 + 11)) {
        goto LABEL_23;
      }
    }
  }
  uint64_t v21 = v9[6];
  uint64_t v20 = (std::__shared_weak_count *)v9[7];
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
  if (v21)
  {
    karo::Job::waitToFinish((karo::Job *)v21, a3);
    pthread_mutex_lock(*(pthread_mutex_t **)(v21 + 152));
    uint64_t v18 = *(_DWORD *)(v21 + 160) & 1;
    pthread_mutex_unlock(*(pthread_mutex_t **)(v21 + 152));
    if (!v20) {
      return v18;
    }
LABEL_31:
    if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  else
  {
    uint64_t v18 = 0;
    if (v20) {
      goto LABEL_31;
    }
  }
  return v18;
}

void sub_1A23C4A9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileId,karo::AsyncRequestManagerNoArgs>::requestT@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, unsigned int a5@<W4>, char a6@<W5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  if (!a3) {
    a3 = *(_DWORD *)(a1 + 88) + 1;
  }
  (*(void (**)(unsigned int **__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 96))(&v22, a1, a2, a7);
  unsigned int v16 = v22;
  unsigned int v17 = atomic_load(v22 + 4);
  if (v17 != a4) {
    (*(void (**)(unsigned int *, uint64_t))(*(void *)v22 + 24))(v22, a4);
  }
  v16[45] = a3;
  v16[46] = a5;
  *((unsigned char *)v16 + 176) = a6;
  uint64_t v18 = v22;
  uint64_t v19 = v23;
  *a8 = off_1EF5677B0;
  a8[1] = v18;
  a8[2] = v19;
  if (v19)
  {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v18 = (unsigned int *)a8[1];
  }
  if (v18) {
    atomic_fetch_add((atomic_uint *volatile)v18 + 32, 1u);
  }
  uint64_t v20 = v23;
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  return pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
}

void sub_1A23C4C34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 40));
  _Unwind_Resume(a1);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileId,karo::AsyncRequestManagerNoArgs>::requestT(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  if (!a4) {
    a4 = *(_DWORD *)(a1 + 88) + 1;
  }
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  if (*a2 != v9)
  {
    do
    {
      uint64_t v10 = v8 + 16;
      (*(void (**)(unsigned int **__return_ptr, uint64_t))(*(void *)a1 + 96))(&v22, a1);
      unsigned int v11 = v22;
      int v12 = *(_DWORD *)(v10 + 4);
      unsigned int v13 = *(_DWORD *)(v10 + 8);
      char v14 = *(unsigned char *)(v10 + 12);
      unsigned int v15 = atomic_load(v22 + 4);
      if (v15 != v12) {
        (*(void (**)(unsigned int *))(*(void *)v22 + 24))(v22);
      }
      v11[45] = a4;
      v11[46] = v13;
      *((unsigned char *)v11 + 176) = v14;
      unsigned int v16 = *(void **)(a3 + 8);
      if ((unint64_t)v16 >= *(void *)(a3 + 16))
      {
        uint64_t v19 = std::vector<karo::AsyncRequestManager::RequestHandle>::__emplace_back_slow_path<std::shared_ptr<karo::AsyncRequestManager::Request> &>((void **)a3, (uint64_t)v22, (uint64_t)v23);
      }
      else
      {
        *unsigned int v16 = off_1EF5677B0;
        unsigned int v17 = v22;
        v16[1] = v22;
        uint64_t v18 = (uint64_t)v23;
        _OWORD v16[2] = v23;
        if (v18)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
          unsigned int v17 = (unsigned int *)v16[1];
        }
        if (v17) {
          atomic_fetch_add((atomic_uint *volatile)v17 + 32, 1u);
        }
        uint64_t v19 = v16 + 3;
        *(void *)(a3 + 8) = v16 + 3;
      }
      *(void *)(a3 + 8) = v19;
      uint64_t v20 = v23;
      if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
      uint64_t v8 = v10 + 16;
    }
    while (v10 + 16 != v9);
  }
  return pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
}

void sub_1A23C4E24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 40));
  _Unwind_Resume(a1);
}

void altitude::SkeletonRequestManager::createRequest()
{
}

void sub_1A23C4F50(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<altitude::SkeletonLoadJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::SkeletonLoadJob>,std::allocator<altitude::SkeletonLoadJob>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::SkeletonLoadJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::SkeletonLoadJob>,std::allocator<altitude::SkeletonLoadJob>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t altitude::SkeletonLoadJob::succeeded(altitude::SkeletonLoadJob *this)
{
  return *((unsigned __int8 *)this + 188);
}

void altitude::SkeletonLoadJob::jobStep(altitude::SkeletonLoadJob *this)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 30);
  if (v2 && *((void *)this + 32)) {
    goto LABEL_7;
  }
  long long v3 = *((_OWORD *)this + 13);
  long long v20 = *((_OWORD *)this + 12);
  long long v21 = v3;
  int v22 = *(_DWORD *)(*((void *)this + 1) + 88);
  if (!v2)
  {
    atomic_load((unsigned int *)this + 4);
    (*(void (**)(void *__return_ptr))(**((void **)this + 34) + 104))(v23);
    uint64_t v4 = v23[0];
    if (v23[0])
    {
      uint64_t v5 = v23[1];
      if (v23[1]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v23[1] + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 31);
      *((void *)this + 30) = v4;
      *((void *)this + 31) = v5;
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
      karo::Job::removeSubJob((pthread_mutex_t **)this, 0);
    }
    else if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v23[2]))
    {
      char v14 = v25;
      v19[0] = v24;
      v19[1] = v25;
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        karo::Job::addBlockingSubJob((uint64_t *)this, v19, 0, 0);
        if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
      else
      {
        karo::Job::addBlockingSubJob((uint64_t *)this, v19, 0, 0);
      }
    }
    else
    {
      if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
      }
      unsigned int v16 = (id)GEOGetVectorKitVKDefaultLog_log;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1A1780000, v16, OS_LOG_TYPE_ERROR, "Failed to load Traffic file", buf, 2u);
      }

      (*(void (**)(altitude::SkeletonLoadJob *))(*(void *)this + 16))(this);
    }
    _OWORD v23[2] = off_1EF5677B0;
    if (v24) {
      atomic_fetch_add((atomic_uint *volatile)(v24 + 128), 0xFFFFFFFF);
    }
    unsigned int v7 = v25;
    if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    uint64_t v8 = (std::__shared_weak_count *)v23[1];
    if (v23[1] && !atomic_fetch_add((atomic_ullong *volatile)(v23[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  if (!*((void *)this + 32))
  {
    atomic_load((unsigned int *)this + 4);
    (*(void (**)(void *__return_ptr))(**((void **)this + 35) + 104))(v23);
    uint64_t v9 = v23[0];
    if (v23[0])
    {
      uint64_t v10 = v23[1];
      if (v23[1]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v23[1] + 8), 1uLL, memory_order_relaxed);
      }
      unsigned int v11 = (std::__shared_weak_count *)*((void *)this + 33);
      *((void *)this + 32) = v9;
      *((void *)this + 33) = v10;
      if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
      karo::Job::removeSubJob((pthread_mutex_t **)this, 1);
    }
    else if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v23[2]))
    {
      unsigned int v15 = v25;
      v18[0] = v24;
      v18[1] = v25;
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        karo::Job::addBlockingSubJob((uint64_t *)this, v18, 1, 0);
        if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
      else
      {
        karo::Job::addBlockingSubJob((uint64_t *)this, v18, 1, 0);
      }
    }
    else
    {
      if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
      }
      unsigned int v17 = (id)GEOGetVectorKitVKDefaultLog_log;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1A1780000, v17, OS_LOG_TYPE_ERROR, "Failed to load DTM file", buf, 2u);
      }

      (*(void (**)(altitude::SkeletonLoadJob *))(*(void *)this + 16))(this);
    }
    _OWORD v23[2] = off_1EF5677B0;
    if (v24) {
      atomic_fetch_add((atomic_uint *volatile)(v24 + 128), 0xFFFFFFFF);
    }
    int v12 = v25;
    if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    unsigned int v13 = (std::__shared_weak_count *)v23[1];
    if (v23[1] && !atomic_fetch_add((atomic_ullong *volatile)(v23[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (*((void *)this + 30) && *((void *)this + 32)) {
LABEL_7:
  }
    operator new();
}

void sub_1A23C5F08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::pair<std::shared_ptr<altitude::GEOTileDataPrivate>,karo::AsyncRequestManager::RequestHandle>::~pair((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1A23C5F1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::pair<std::shared_ptr<altitude::GEOTileDataPrivate>,karo::AsyncRequestManager::RequestHandle>::~pair((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1A23C5F30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  ggl::Loader::~Loader((ggl::Loader *)va2);
  _Unwind_Resume(a1);
}

void sub_1A23C5F90(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 32))(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<altitude::SkeletonLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<altitude::SkeletonLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 8) + 224);
  uint64_t v2 = *(void *)(v1 + 56);
  uint64_t v38 = v1;
  int v3 = *(_DWORD *)(v1 + 32);
  pthread_mutex_lock(*(pthread_mutex_t **)(v2 + 16));
  uint64_t v5 = *(void *)(v2 + 24);
  uint64_t v4 = *(void *)(v2 + 32);
  uint64_t v39 = v2;
  if (v5 == v4) {
    goto LABEL_23;
  }
  while (*(_DWORD *)v5 != v3)
  {
    v5 += 24;
    if (v5 == v4) {
      goto LABEL_23;
    }
  }
  uint64_t v6 = *(std::__shared_weak_count **)(v5 + 16);
  if (!v6)
  {
    uint64_t v8 = 0;
LABEL_10:
    uint64_t v10 = v5 + 24;
    uint64_t v11 = *(void *)(v39 + 32);
    if (v5 + 24 != v11)
    {
      do
      {
        *(_DWORD *)uint64_t v5 = *(_DWORD *)(v5 + 24);
        long long v14 = *(_OWORD *)(v5 + 32);
        *(void *)(v5 + 32) = 0;
        *(void *)(v5 + 40) = 0;
        unsigned int v15 = *(std::__shared_weak_count **)(v5 + 16);
        *(_OWORD *)(v5 + 8) = v14;
        if (v15) {
          std::__shared_weak_count::__release_weak(v15);
        }
        uint64_t v12 = v5 + 24;
        uint64_t v13 = v5 + 48;
        v5 += 24;
      }
      while (v13 != v11);
      uint64_t v10 = *(void *)(v39 + 32);
      uint64_t v5 = v12;
    }
    while (v10 != v5)
    {
      unsigned int v16 = *(std::__shared_weak_count **)(v10 - 8);
      if (v16) {
        std::__shared_weak_count::__release_weak(v16);
      }
      v10 -= 24;
    }
    *(void *)(v39 + 32) = v5;
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
LABEL_23:
    operator new();
  }
  uint64_t v7 = std::__shared_weak_count::lock(v6);
  uint64_t v8 = v7;
  if (!v7 || !*(void *)(v5 + 8)) {
    goto LABEL_10;
  }
  *(void *)&long long v9 = *(void *)(v5 + 8);
  *((void *)&v9 + 1) = v7;
  long long v40 = v9;
  pthread_mutex_unlock(*(pthread_mutex_t **)(v39 + 16));
  uint64_t v17 = v38;
  uint64_t v18 = *(std::__shared_weak_count **)(v38 + 48);
  *(_OWORD *)(v38 + 40) = v40;
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
    uint64_t v17 = v38;
  }
  uint64_t v19 = *(void *)(v17 + 40);
  int v20 = *(_DWORD *)(v17 + 32);
  int v21 = *(_DWORD *)(v19 + 120);
  int v22 = v20 - v21;
  if (v20 == v21)
  {
    unsigned int v23 = 0;
    uint64_t v28 = *(void *)(v19 + 64);
  }
  else
  {
    unsigned int v23 = 0;
    unsigned int v24 = *(_DWORD *)(v17 + 28) - (*(_DWORD *)(v19 + 116) << v22);
    unsigned int v25 = *(_DWORD *)(v17 + 24) - (*(_DWORD *)(v19 + 112) << v22);
    int v26 = ~v21 + v20;
    int v27 = 2 * v26;
    do
    {
      v23 += (v25 >> v26 << v27) + (2 << v27) * (v24 >> v26);
      v25 -= v25 >> v26 << v26;
      v24 -= v24 >> v26 << v26;
      --v26;
      v27 -= 2;
    }
    while (v26 != -1);
    uint64_t v28 = *(void *)(v19 + 64);
    int v29 = 0;
    if (v22)
    {
      int v30 = *(_DWORD *)(v19 + 112);
      unsigned int v31 = *(_DWORD *)(v17 + 28) - (*(_DWORD *)(v19 + 116) << v22);
      unsigned int v32 = *(_DWORD *)(v17 + 24) - (v30 << v22);
      int v33 = ~v21 + v20;
      int v34 = 2 * v33;
      do
      {
        v29 += (v32 >> v33 << v34) + (2 << v34) * (v31 >> v33);
        v32 -= v32 >> v33 << v33;
        v31 -= v31 >> v33 << v33;
        --v33;
        v34 -= 2;
      }
      while (v33 != -1);
    }
  }
  uint64_t v35 = v28 + 72 * v23;
  int v37 = *(unsigned __int8 *)(v35 + 24);
  uint64_t v36 = (unsigned char *)(v35 + 24);
  if (!v37)
  {
    unsigned char *v36 = 1;
    operator new();
  }
}

void sub_1A23C8560(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A23C8574(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p)
{
  MEMORY[0x1A6239270](v33, 0x10A1C40E260AA06);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<altitude::SkeletonLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<altitude::SkeletonLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57D200;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<altitude::SkeletonLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<altitude::SkeletonLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57D200;
  result[1] = v3;
  return result;
}

void std::__function::__func<altitude::SkeletonLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<altitude::SkeletonLoadJob::jobStep(void)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

uint64_t std::__shared_ptr_pointer<altitude::TrafficTilePrivate *,std::shared_ptr<altitude::TrafficTilePrivate>::__shared_ptr_default_delete<altitude::TrafficTilePrivate,altitude::TrafficTilePrivate>,std::allocator<altitude::TrafficTilePrivate>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::TrafficTilePrivate *,std::shared_ptr<altitude::TrafficTilePrivate>::__shared_ptr_default_delete<altitude::TrafficTilePrivate,altitude::TrafficTilePrivate>,std::allocator<altitude::TrafficTilePrivate>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void altitude::SkeletonLoadJob::~SkeletonLoadJob(altitude::SkeletonLoadJob *this)
{
  altitude::SkeletonLoadJob::~SkeletonLoadJob(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF569120;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 37));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 33);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 31);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 31);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 29);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  karo::Job::~Job(this);
}

void karo::AsyncRequestManagerTemplate<altitude::TileId,karo::AsyncRequestManagerNoArgs>::createAndQueueRequest(void *a1@<X0>, uint64_t *a2@<X8>)
{
  (*(void (**)(void *))(*a1 + 64))(a1);
  unint64_t v4 = a1[6];
  if (v4)
  {
    uint64_t v5 = *a2;
    uint64_t v6 = (std::__shared_weak_count *)a2[1];
    v7[0] = v5;
    v7[1] = v6;
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::JobManager::queueJob(v4, v7);
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    else
    {
      karo::JobManager::queueJob(v4, v7);
    }
  }
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileId,karo::AsyncRequestManagerNoArgs>::clearRequest(uint64_t a1, unsigned int *a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = *(uint64_t **)(a1 + 72);
  if (!v4) {
    goto LABEL_36;
  }
  unsigned int v6 = *a2;
  unsigned int v5 = a2[1];
  uint64_t v7 = (uint64_t *)(a1 + 72);
  unsigned int v9 = a2[2];
  unsigned int v8 = a2[3];
  do
  {
    unsigned int v10 = *((_DWORD *)v4 + 8);
    if (v10 < v6)
    {
LABEL_3:
      ++v4;
      goto LABEL_4;
    }
    if (v10 > v6) {
      goto LABEL_11;
    }
    unsigned int v11 = *((_DWORD *)v4 + 9);
    if (v11 < v5) {
      goto LABEL_3;
    }
    if (v11 > v5) {
      goto LABEL_11;
    }
    unsigned int v12 = *((_DWORD *)v4 + 10);
    if (v12 < v9) {
      goto LABEL_3;
    }
    if (v12 <= v9)
    {
      if (*((_DWORD *)v4 + 11) < v8) {
        ++v4;
      }
      else {
        uint64_t v7 = v4;
      }
    }
    else
    {
LABEL_11:
      uint64_t v7 = v4;
    }
LABEL_4:
    unint64_t v4 = (uint64_t *)*v4;
  }
  while (v4);
  if (v7 != (uint64_t *)(a1 + 72))
  {
    unsigned int v13 = *((_DWORD *)v7 + 8);
    if (v6 >= v13)
    {
      if (v6 > v13
        || (unsigned int v16 = *((_DWORD *)v7 + 9), v5 >= v16)
        && (v5 > v16 || (unsigned int v17 = *((_DWORD *)v7 + 10), v9 >= v17) && (v9 > v17 || v8 >= *((_DWORD *)v7 + 11))))
      {
        (*(void (**)(uint64_t))(*(void *)v7[6] + 16))(v7[6]);
        long long v14 = (uint64_t *)v7[1];
        if (v14)
        {
          do
          {
            unsigned int v15 = v14;
            long long v14 = (uint64_t *)*v14;
          }
          while (v14);
        }
        else
        {
          uint64_t v18 = v7;
          do
          {
            unsigned int v15 = (uint64_t *)v18[2];
            BOOL v19 = *v15 == (void)v18;
            uint64_t v18 = v15;
          }
          while (!v19);
        }
        if (*(uint64_t **)(a1 + 64) == v7) {
          *(void *)(a1 + 64) = v15;
        }
        int v20 = *(uint64_t **)(a1 + 72);
        --*(void *)(a1 + 80);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v20, v7);
        int v21 = (std::__shared_weak_count *)v7[7];
        if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
        operator delete(v7);
      }
    }
  }
LABEL_36:
  int v22 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v22);
}

void sub_1A23C8D44(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(*(pthread_mutex_t **)(v1 + 40));
  _Unwind_Resume(a1);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileId,karo::AsyncRequestManagerNoArgs>::removeFromRequests(uint64_t a1, uint64_t a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = *(uint64_t **)(a1 + 64);
  if (v4 != (uint64_t *)(a1 + 72))
  {
    unsigned int v5 = *(uint64_t **)(a1 + 64);
    while (1)
    {
      unsigned int v6 = (uint64_t *)v5[1];
      if (v5[6] == a2) {
        break;
      }
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          unsigned int v6 = (uint64_t *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (uint64_t *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          unsigned int v5 = v7;
        }
        while (!v8);
      }
      unsigned int v5 = v7;
      if (v7 == (uint64_t *)(a1 + 72)) {
        goto LABEL_23;
      }
    }
    if (v6)
    {
      do
      {
        unsigned int v9 = v6;
        unsigned int v6 = (uint64_t *)*v6;
      }
      while (v6);
    }
    else
    {
      unsigned int v10 = v5;
      do
      {
        unsigned int v9 = (uint64_t *)v10[2];
        BOOL v8 = *v9 == (void)v10;
        unsigned int v10 = v9;
      }
      while (!v8);
    }
    if (v4 == v5) {
      *(void *)(a1 + 64) = v9;
    }
    unsigned int v11 = *(uint64_t **)(a1 + 72);
    --*(void *)(a1 + 80);
    std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v11, v5);
    unsigned int v12 = (std::__shared_weak_count *)v5[7];
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    operator delete(v5);
  }
LABEL_23:
  unsigned int v13 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v13);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileId,karo::AsyncRequestManagerNoArgs>::pruneRequests(uint64_t a1, int a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = *(uint64_t **)(a1 + 64);
  if (v4 != (uint64_t *)(a1 + 72))
  {
    do
    {
      unsigned int v5 = (uint64_t *)v4[1];
      unsigned int v6 = v4;
      if (v5)
      {
        do
        {
          uint64_t v7 = v5;
          unsigned int v5 = (uint64_t *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v7 = (uint64_t *)v6[2];
          BOOL v8 = *v7 == (void)v6;
          unsigned int v6 = v7;
        }
        while (!v8);
      }
      uint64_t v9 = v4[6];
      if (atomic_load((unsigned int *)(v9 + 128))) {
        *(_DWORD *)(v9 + 180) = a2;
      }
      pthread_mutex_lock(*(pthread_mutex_t **)(v9 + 152));
      int v11 = *(_DWORD *)(v9 + 160);
      pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 152));
      if ((v11 & 1) != 0 && *(unsigned char *)(v9 + 176) && *(_DWORD *)(v9 + 180) != a2
        || (a2 - *(_DWORD *)(v9 + 180)) > *(_DWORD *)(v9 + 184))
      {
        (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
        unsigned int v12 = (uint64_t *)v4[1];
        unsigned int v13 = v4;
        if (v12)
        {
          do
          {
            long long v14 = v12;
            unsigned int v12 = (uint64_t *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            long long v14 = (uint64_t *)v13[2];
            BOOL v8 = *v14 == (void)v13;
            unsigned int v13 = v14;
          }
          while (!v8);
        }
        if (*(uint64_t **)(a1 + 64) == v4) {
          *(void *)(a1 + 64) = v14;
        }
        unsigned int v15 = *(uint64_t **)(a1 + 72);
        --*(void *)(a1 + 80);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v15, v4);
        unsigned int v16 = (std::__shared_weak_count *)v4[7];
        if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
        operator delete(v4);
      }
      unint64_t v4 = v7;
    }
    while (v7 != (uint64_t *)(a1 + 72));
  }
  *(_DWORD *)(a1 + 88) = a2;
  unsigned int v17 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v17);
}

void sub_1A23C9068(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(*(pthread_mutex_t **)(v1 + 40));
  _Unwind_Resume(a1);
}

void altitude::SkeletonRequestManager::~SkeletonRequestManager(altitude::SkeletonRequestManager *this)
{
  altitude::SkeletonRequestManager::~SkeletonRequestManager(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF56ABC0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF567A90;
  while (*((void *)this + 10))
    (*(void (**)(altitude::SkeletonRequestManager *, uint64_t))(*(void *)this + 48))(this, *((void *)this + 8) + 32);
  std::__tree<std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>,std::__map_value_compare<karo::media::C3mmFileIndex,std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>,std::less<karo::media::C3mmFileIndex>,true>,std::allocator<std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>>>::destroy(*((void **)this + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(this);
}

void sub_1A23C91AC(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>,std::__map_value_compare<karo::media::C3mmFileIndex,std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>,std::less<karo::media::C3mmFileIndex>,true>,std::allocator<std::__value_type<karo::media::C3mmFileIndex,std::shared_ptr<karo::media::C3mmFile>>>>::destroy(*((void **)v1 + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(v1);
  _Unwind_Resume(a1);
}

void altitude::SkeletonRequestManager::disable(pthread_mutex_t **this)
{
  unsigned int v24 = 0;
  uint64_t v25 = 0;
  unsigned int v23 = &v24;
  pthread_mutex_lock(this[5]);
  uint64_t v2 = (altitude::SkeletonRequestManager *)this[8];
  if (v2 != (altitude::SkeletonRequestManager *)(this + 9))
  {
    while (1)
    {
      unint64_t v4 = (unsigned int *)*((void *)v2 + 6);
      uint64_t v3 = (std::__shared_weak_count *)*((void *)v2 + 7);
      if (v3) {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(unsigned int *))(*(void *)v4 + 16))(v4);
      unsigned int v5 = v24;
      unsigned int v6 = &v24;
      uint64_t v7 = &v24;
      if (v24) {
        break;
      }
LABEL_21:
      unsigned int v16 = (char *)operator new(0x30uLL);
      *(_OWORD *)(v16 + 28) = *((_OWORD *)v4 + 13);
      *(void *)unsigned int v16 = 0;
      *((void *)v16 + 1) = 0;
      *((void *)v16 + 2) = v7;
      *unsigned int v6 = (uint64_t *)v16;
      if (*v23)
      {
        unsigned int v23 = (uint64_t **)*v23;
        unsigned int v16 = (char *)*v6;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v24, (uint64_t *)v16);
      ++v25;
      if (v3) {
        goto LABEL_24;
      }
LABEL_25:
      unsigned int v17 = (altitude::SkeletonRequestManager *)*((void *)v2 + 1);
      if (v17) {
        goto LABEL_26;
      }
      do
      {
LABEL_29:
        uint64_t v18 = (altitude::SkeletonRequestManager *)*((void *)v2 + 2);
        BOOL v19 = *(void *)v18 == (void)v2;
        uint64_t v2 = v18;
      }
      while (!v19);
LABEL_3:
      uint64_t v2 = v18;
      if (v18 == (altitude::SkeletonRequestManager *)(this + 9)) {
        goto LABEL_32;
      }
    }
    unsigned int v8 = v4[52];
    unsigned int v9 = v4[53];
    unsigned int v10 = v4[54];
    unsigned int v11 = v4[55];
    while (1)
    {
      uint64_t v7 = (uint64_t **)v5;
      unsigned int v12 = *((_DWORD *)v5 + 7);
      if (v8 < v12) {
        goto LABEL_8;
      }
      if (v8 > v12) {
        goto LABEL_11;
      }
      unsigned int v13 = *((_DWORD *)v7 + 8);
      if (v9 < v13) {
        goto LABEL_8;
      }
      if (v9 > v13) {
        goto LABEL_11;
      }
      unsigned int v14 = *((_DWORD *)v7 + 9);
      if (v10 < v14) {
        goto LABEL_8;
      }
      if (v10 > v14) {
        goto LABEL_11;
      }
      unsigned int v15 = *((_DWORD *)v7 + 10);
      if (v11 < v15)
      {
LABEL_8:
        unsigned int v5 = *v7;
        unsigned int v6 = v7;
        if (!*v7) {
          goto LABEL_21;
        }
      }
      else
      {
        if (v15 >= v11)
        {
          if (!v3) {
            goto LABEL_25;
          }
LABEL_24:
          if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_25;
          }
          ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
          std::__shared_weak_count::__release_weak(v3);
          unsigned int v17 = (altitude::SkeletonRequestManager *)*((void *)v2 + 1);
          if (!v17) {
            goto LABEL_29;
          }
          do
          {
LABEL_26:
            uint64_t v18 = v17;
            unsigned int v17 = *(altitude::SkeletonRequestManager **)v17;
          }
          while (v17);
          goto LABEL_3;
        }
LABEL_11:
        unsigned int v5 = v7[1];
        if (!v5)
        {
          unsigned int v6 = v7 + 1;
          goto LABEL_21;
        }
      }
    }
  }
LABEL_32:
  pthread_mutex_unlock(this[5]);
  int v20 = v23;
  if (v23 != &v24)
  {
    do
    {
      (*(void (**)(pthread_mutex_t **, uint64_t))&(*this)->__opaque[40])(this, (uint64_t)v20 + 28);
      int v21 = v20[1];
      if (v21)
      {
        do
        {
          int v22 = (uint64_t **)v21;
          int v21 = (uint64_t *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          int v22 = (uint64_t **)v20[2];
          BOOL v19 = *v22 == (uint64_t *)v20;
          int v20 = v22;
        }
        while (!v19);
      }
      int v20 = v22;
    }
    while (v22 != &v24);
  }
  *((unsigned char *)this + 92) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v24);
}

void sub_1A23C946C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
}

std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep altitude::SkeletonRequestManager::update(altitude::SkeletonRequestManager *this, int a2)
{
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep result = std::chrono::steady_clock::now().__d_.__rep_;
  double v5 = (double)(result - *((void *)this + 18)) * 0.000000001;
  if (v5 > *((double *)this + 19) + 180.0)
  {
    *((double *)this + 19) = v5;
    *((_DWORD *)this + 40) = a2;
    uint64_t v6 = *((void *)this + 17);
    *(_DWORD *)(v6 + 200) = a2;
    *(_DWORD *)(*(void *)(v6 + 160) + 168) = a2;
    uint64_t v7 = **(void ***)(*((void *)this + 15) + 96);
    return [v7 purgeExpired:180.0];
  }
  return result;
}

void altitude::SkeletonRequestManager::setStyleManager(void *a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v4 = (std::__shared_weak_count *)a1[13];
  a1[12] = a2;
  a1[13] = a3;
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    a2 = a1[12];
    a3 = a1[13];
  }
  uint64_t v5 = a1[17];
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(v5 + 192);
  *(void *)(v5 + 184) = a2;
  *(void *)(v5 + 192) = a3;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  int v7 = *(_DWORD *)(a1[4] + 88);
  uint64_t v8 = a1[17];
  *(_DWORD *)(v8 + 200) = v7;
  *(_DWORD *)(*(void *)(v8 + 160) + 168) = v7;
}

void md::RasterTileResourceDecoder::decode(const gdc::ResourceKey *a1@<X1>, const gdc::RawResourceSourceData *a2@<X2>, uint64_t *a3@<X8>)
{
  if (!*((unsigned char *)a2 + 16)) {
    goto LABEL_13;
  }
  uint64_t v6 = *(void *)a2;
  if (!gdc::DataObject::length(*(id **)a2)) {
    goto LABEL_13;
  }
  uint64_t v7 = gdc::DataObject::length((id *)v6);
  uint64_t v8 = *(void **)(v6 + 16);
  if (v7 == 4)
  {
    [v8 bytes];
    unsigned int v9 = operator new(0xC0uLL);
    v9[1] = 0;
    v9[2] = 0;
    *unsigned int v9 = &unk_1EF580918;
    uint64_t v10 = gdc::Resource::Resource((uint64_t)(v9 + 3), (uint64_t)a1);
    v9[21] = 0;
    v9[22] = 0;
    *((unsigned char *)v9 + 184) = 1;
    *a3 = v10;
    a3[1] = (uint64_t)v9;
    return;
  }
  CFDataRef v11 = v8;
  CGImageSourceRef v12 = CGImageSourceCreateWithData(v11, 0);

  if (!v12) {
    goto LABEL_13;
  }
  if (!CGImageSourceGetCount(v12))
  {
    CFRelease(v12);
    goto LABEL_13;
  }
  ImageAtIndex = CGImageSourceCreateImageAtIndex(v12, 0, 0);
  CFRelease(v12);
  if (!ImageAtIndex)
  {
LABEL_13:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  unint64_t v14 = *((unsigned __int16 *)a1 + 1);
  unint64_t Width = CGImageGetWidth(ImageAtIndex);
  size_t v16 = CGImageGetHeight(ImageAtIndex);
  unsigned int v17 = (std::__shared_weak_count *)operator new(0x60uLL);
  v17->__shared_owners_ = 0;
  v17->__shared_weak_owners_ = 0;
  v17->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583AF8;
  size_t height = v16;
  unint64_t v43 = ggl::TextureData2D::TextureData2D((uint64_t)&v17[1], Width, v16, 1u, 24, 0);
  uint64_t v44 = v17;
  uint64_t v18 = ((uint64_t (*)(void *, void))v17[1].__on_zero_shared)(v43, 0);
  size_t v19 = CGImageGetWidth(ImageAtIndex);
  size_t v20 = CGImageGetHeight(ImageAtIndex);
  char v21 = (v14 > 0x34) | (0x7FFFFFFFFFFEFuLL >> v14);
  v46[0] = 0x1000000005;
  if (v21)
  {
    if (_colorSpace(BOOL)::onceTokenSRGB != -1)
    {
      size_t v40 = v20;
      dispatch_once(&_colorSpace(BOOL)::onceTokenSRGB, &__block_literal_global_24386);
      size_t v20 = v40;
    }
    int v22 = &_colorSpace(BOOL)::colorspaceSRGB;
  }
  else
  {
    if (_colorSpace(BOOL)::onceTokenLinear != -1)
    {
      size_t v41 = v20;
      dispatch_once(&_colorSpace(BOOL)::onceTokenLinear, &__block_literal_global_5_24387);
      size_t v20 = v41;
    }
    int v22 = &_colorSpace(BOOL)::colorspaceLinear;
  }
  v46[1] = *v22;
  int v47 = 4096;
  uint64_t v48 = 0;
  memset(v49, 0, sizeof(v49));
  v45[0] = v18 + 2 * (v20 - 1) * v19;
  v45[1] = v20;
  v45[2] = v19;
  v45[3] = -2 * v19;
  if (!MEMORY[0x1A623A490](v45, v46, 0, ImageAtIndex, 512)) {
    goto LABEL_36;
  }
  unsigned int v23 = (std::__shared_weak_count *)operator new(0x60uLL);
  v23->__shared_owners_ = 0;
  v23->__shared_weak_owners_ = 0;
  v23->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583AF8;
  unint64_t v43 = ggl::TextureData2D::TextureData2D((uint64_t)&v23[1], Width, height, 1u, 27, 0);
  uint64_t v44 = v23;
  if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  unsigned int v24 = (int16x8_t *)(*(uint64_t (**)(void *, void))(*v43 + 16))(v43, 0);
  if (v21)
  {
    size_t v25 = height;
    if (_colorSpace(BOOL)::onceTokenSRGB != -1) {
      dispatch_once(&_colorSpace(BOOL)::onceTokenSRGB, &__block_literal_global_24386);
    }
    int v26 = &_colorSpace(BOOL)::colorspaceSRGB;
  }
  else
  {
    size_t v25 = height;
    if (_colorSpace(BOOL)::onceTokenLinear != -1) {
      dispatch_once(&_colorSpace(BOOL)::onceTokenLinear, &__block_literal_global_5_24387);
    }
    int v26 = &_colorSpace(BOOL)::colorspaceLinear;
  }
  int v27 = CGBitmapContextCreate(v24, Width, v25, 5uLL, 2 * Width, (CGColorSpaceRef)*v26, 0x1006u);
  v50.origin.x = 0.0;
  v50.origin.y = 0.0;
  v50.size.CGFloat width = (double)Width;
  v50.size.size_t height = (double)v25;
  CGFloat MinX = CGRectGetMinX(v50);
  v51.origin.x = 0.0;
  v51.origin.y = 0.0;
  v51.size.CGFloat width = (double)Width;
  v51.size.size_t height = (double)v25;
  CGFloat MaxY = CGRectGetMaxY(v51);
  CGContextTranslateCTM(v27, MinX, MaxY);
  CGContextScaleCTM(v27, 1.0, -1.0);
  CGContextSetBlendMode(v27, kCGBlendModeCopy);
  CGContextSetAlpha(v27, 1.0);
  v52.origin.x = *(CGFloat *)MEMORY[0x1E4F1DAD8];
  v52.origin.y = *(CGFloat *)(MEMORY[0x1E4F1DAD8] + 8);
  v52.size.CGFloat width = (double)Width;
  v52.size.size_t height = (double)v25;
  CGContextDrawImage(v27, v52, ImageAtIndex);
  CGContextRelease(v27);
  unint64_t v30 = v25 * Width;
  if (!(v25 * Width)) {
    goto LABEL_36;
  }
  if (v30 > 0xF)
  {
    unint64_t v31 = v30 & 0xFFFFFFFFFFFFFFF0;
    unsigned int v32 = v24 + 1;
    unint64_t v33 = v30 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      unsigned long long v34 = *(_OWORD *)&vaddq_s16(*v32, *v32) | __PAIR128__(0x1000100010001, 0x1000100010001);
      v32[-1] = (int16x8_t)(*(_OWORD *)&vaddq_s16(v32[-1], v32[-1]) | __PAIR128__(0x1000100010001, 0x1000100010001));
      int16x8_t *v32 = (int16x8_t)v34;
      v32 += 2;
      v33 -= 16;
    }
    while (v33);
    if (v30 == v31) {
      goto LABEL_36;
    }
  }
  else
  {
    unint64_t v31 = 0;
  }
  unint64_t v35 = v30 - v31;
  uint64_t v36 = &v24->i16[v31];
  do
  {
    __int16 *v36 = (2 * *v36) | 1;
    ++v36;
    --v35;
  }
  while (v35);
LABEL_36:
  CGImageRelease(ImageAtIndex);
  if (v43)
  {
    int v37 = operator new(0xC0uLL);
    v37[1] = 0;
    v37[2] = 0;
    void *v37 = &unk_1EF580918;
    uint64_t v38 = gdc::Resource::Resource((uint64_t)(v37 + 3), (uint64_t)a1);
    v37[21] = v43;
    v37[22] = v44;
    if (v44) {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *((unsigned char *)v37 + 184) = 0;
    *(void *)&long long v39 = v38;
    *((void *)&v39 + 1) = v37;
    *(_OWORD *)a3 = v39;
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  if (v44)
  {
    if (!atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }
}

void sub_1A23C9C1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

CGColorSpaceRef ___ZL11_colorSpaceb_block_invoke_2()
{
  CGColorSpaceRef result = CGColorSpaceCreateDeviceRGB();
  _colorSpace(BOOL)::colorspaceLinear = (uint64_t)result;
  return result;
}

CGColorSpaceRef ___ZL11_colorSpaceb_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC88]);
  _colorSpace(BOOL)::colorspaceSRGB = (uint64_t)result;
  return result;
}

void md::RasterTileResourceDecoder::~RasterTileResourceDecoder(md::RasterTileResourceDecoder *this)
{
}

void sub_1A23C9DFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23CA174(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFDictionaryRef ___ZL19_imageSourceOptionsv_block_invoke()
{
  keys[3] = *(void **)MEMORY[0x1E4F143B8];
  os_log_t v0 = (void *)*MEMORY[0x1E4F2FF48];
  keys[0] = *(void **)MEMORY[0x1E4F2FF08];
  keys[1] = v0;
  keys[2] = *(void **)MEMORY[0x1E4F2FF78];
  uint64_t v1 = (void *)*MEMORY[0x1E4F1CFD0];
  values[0] = *(void **)MEMORY[0x1E4F1CFC8];
  values[1] = v1;
  values[2] = @"public.png";
  CFDictionaryRef result = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  _imageSourceOptions(void)::options = (uint64_t)result;
  return result;
}

uint64_t std::__shared_ptr_emplace<ggl::TextureData2D,geo::StdAllocator<ggl::TextureData2D,mdm::Allocator>>::__on_zero_shared_weak(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a1, 104);
}

uint64_t std::__shared_ptr_emplace<ggl::TextureData2D,geo::StdAllocator<ggl::TextureData2D,mdm::Allocator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))();
}

void std::__shared_ptr_emplace<ggl::TextureData2D,geo::StdAllocator<ggl::TextureData2D,mdm::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583AC0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::TextureData2D,geo::StdAllocator<ggl::TextureData2D,mdm::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583AC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A23CA4A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9, uint64_t a10, uint64_t a11, char a12)
{
  a9.super_class = (Class)VKImage;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A23CA5C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23CA670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }

  _Unwind_Resume(a1);
}

void sub_1A23CA750(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::ImageLabelPart::populateDebugNode(md::ImageLabelPart *this, gdc::DebugTreeNode *a2)
{
  char v36 = 14;
  strcpy((char *)&v35, "ImageLabelPart");
  uint64_t v3 = gdc::DebugTreeNode::createChildNode((uint64_t)a2, &v35);
  double v4 = *((float *)this + 138);
  char v36 = 5;
  strcpy((char *)&v35, "Alpha");
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  uint64_t v31 = 0;
  int v34 = 2;
  double v30 = v4;
  gdc::DebugTreeNode::addProperty((uint64_t)v3, (uint64_t)&v35, (uint64_t)v29);
  double v5 = *((float *)this + 149);
  char v36 = 10;
  strcpy((char *)&v35, "Brightness");
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v25 = 0;
  int v28 = 2;
  double v24 = v5;
  gdc::DebugTreeNode::addProperty((uint64_t)v3, (uint64_t)&v35, (uint64_t)v23);
  double v6 = *((float *)this + 151);
  char v36 = 10;
  strcpy((char *)&v35, "Saturation");
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v19 = 0;
  int v22 = 2;
  double v18 = v6;
  gdc::DebugTreeNode::addProperty((uint64_t)v3, (uint64_t)&v35, (uint64_t)v17);
  double v7 = *((float *)this + 155);
  char v36 = 7;
  strcpy((char *)&v35, "Padding");
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  int v16 = 2;
  double v12 = v7;
  gdc::DebugTreeNode::addProperty((uint64_t)v3, (uint64_t)&v35, (uint64_t)v11);
  uint64_t v8 = *((char *)this + 594);
  char v36 = 5;
  strcpy((char *)&v35, "Layer");
  int v10 = 0;
  memset(&v9[4], 0, 24);
  v9[0] = v8;
  gdc::DebugTreeNode::addProperty((uint64_t)v3, (uint64_t)&v35, (uint64_t)v9);
}

uint64_t md::ImageLabelPart::debugString@<X0>(md::ImageLabelPart *this@<X0>, unsigned char *a2@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v14);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)"Icon:", 5);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" layer=", 7);
  std::ostream::operator<<();
  uint64_t v4 = v14[0];
  *(_DWORD *)((char *)&v14[1] + *(void *)(v14[0] - 24)) = *(_DWORD *)((unsigned char *)&v14[1] + *(void *)(v14[0] - 24)) & 0xFFFFFEFB | 4;
  *(void *)((char *)&v14[2] + *(void *)(v4 - 24)) = 1;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" alpha=", 7);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" bright=", 8);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" sat=", 5);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" scale=", 7);
  std::ostream::operator<<();
  uint64_t v5 = v14[0];
  *(_DWORD *)((char *)&v14[1] + *(void *)(v14[0] - 24)) = *(_DWORD *)((unsigned char *)&v14[1] + *(void *)(v14[0] - 24)) & 0xFFFFFEFB | 4;
  *(void *)((char *)&v14[2] + *(void *)(v5 - 24)) = 0;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" pad=", 5);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" opad=", 6);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" ovlp=", 6);
  std::ostream::operator<<();
  if (*((unsigned char *)this + 272))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" ovlpGroups=", 12);
    std::ostream::operator<<();
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)"\n", 1);
  if ((v21 & 0x10) != 0)
  {
    unint64_t v7 = v20;
    if (v20 < v17)
    {
      unint64_t v20 = v17;
      unint64_t v7 = v17;
    }
    uint64_t v8 = (const void **)&v16;
  }
  else
  {
    if ((v21 & 8) == 0)
    {
      size_t v6 = 0;
      a2[23] = 0;
      goto LABEL_18;
    }
    uint64_t v8 = (const void **)v15;
    unint64_t v7 = v15[2];
  }
  unsigned int v9 = *v8;
  size_t v6 = v7 - (void)*v8;
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v6 >= 0x17)
  {
    uint64_t v10 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v10 = v6 | 7;
    }
    uint64_t v11 = v10 + 1;
    double v12 = operator new(v10 + 1);
    *((void *)a2 + 1) = v6;
    *((void *)a2 + 2) = v11 | 0x8000000000000000;
    *(void *)a2 = v12;
    a2 = v12;
    goto LABEL_17;
  }
  a2[23] = v6;
  if (v6) {
LABEL_17:
  }
    memmove(a2, v9, v6);
LABEL_18:
  a2[v6] = 0;
  v14[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v14 + *(void *)(v14[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v14[1] = MEMORY[0x1E4FBA470] + 16;
  if (v19 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v22);
}

void sub_1A23CAD34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL md::ImageLabelPart::isVisuallySimilar(md::ImageLabelPart *this, const md::LabelPart *a2)
{
  if (*((float *)this + 143) != *((float *)a2 + 143)) {
    return 0;
  }
  if (*((float *)this + 144) == *((float *)a2 + 144)) {
    return *((float *)this + 145) == *((float *)a2 + 145);
  }
  return 0;
}

float md::ImageLabelPart::updateForDisplay(md::ImageLabelPart *this)
{
  *((_DWORD *)this + 153) = *((_DWORD *)this + 147);
  uint64_t v1 = *(void *)((char *)this + 572);
  float result = *((float *)this + 145);
  *((float *)this + 151) = result;
  *(void *)((char *)this + 596) = v1;
  *((unsigned char *)this + 617) = *((unsigned char *)this + 593);
  *((unsigned char *)this + 556) = *((unsigned char *)this + 633) + 4 * *((unsigned char *)this + 594);
  return result;
}

uint64_t md::ImageLabelPart::setLabel(md::ImageLabelPart *this, md::Label *a2)
{
  *((void *)this + 2) = a2;
  uint64_t result = (*(uint64_t (**)(md::ImageLabelPart *, char *))(*(void *)this + 24))(this, (char *)a2 + 376);
  *((unsigned char *)this + 630) = *(unsigned char *)(*((void *)this + 2) + 1221);
  return result;
}

double std::__function::__func<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_1,std::allocator<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, float *a5, uint64_t a6, uint64_t a7)
{
  *(float *)&v8[8] = *a5 + (float)(*(float *)(a6 + 8) * *a4);
  *(void *)&v8[12] = *(void *)(a6 + 12);
  *(float *)&v8[20] = *a5 + (float)(*(float *)(a6 + 20) * *a4);
  *(_OWORD *)a7 = *(_OWORD *)v8;
  double result = *(double *)&v8[16];
  *(void *)(a7 + 16) = *(void *)&v8[16];
  return result;
}

void std::__function::__func<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_1,std::allocator<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF51FF58;
}

void *std::__function::__func<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_1,std::allocator<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &)>::__clone()
{
  double result = operator new(0x10uLL);
  void *result = &unk_1EF51FF58;
  return result;
}

void std::__function::__func<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_1,std::allocator<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &)>::~__func()
{
}

void std::__function::__func<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_0,std::allocator<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &)>::operator()(uint64_t a1, int32x4_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t *a6, float32x2_t *a7, float32x4_t *a8)
{
  unint64_t v11 = *a6;
  double v12 = **(void ***)(a1 + 8);
  v23.i64[0] = v11;
  uint64_t v13 = v12[417];
  if (v11 >= (unint64_t)((v12[418] - v13) >> 3)
    || ((v14 = *(void *)(v13 + 8 * v11)) != 0 ? (BOOL v15 = HIDWORD(v11) == HIDWORD(v14)) : (BOOL v15 = 0),
        !v15
     || ((uint64_t v18 = v12[420], v19 = *(void *)(v13 + 8 * v11), v18 + 24 * v14 != v12[421])
       ? (BOOL v20 = v18 == 0)
       : (BOOL v20 = 1),
         v20)))
  {
    uint64_t v16 = 0;
    unint64_t v17 = 0;
  }
  else
  {
    int v21 = std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>> const&>,std::tuple<>>((uint64_t)(v12 + 409), v11, &v23);
    ++v21[3];
    uint64_t v22 = v18 + 24 * v19;
    uint64_t v16 = *(void *)(v22 + 8);
    unint64_t v17 = *(std::__shared_weak_count **)(v22 + 16);
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  md::GeometryLogic::scaleGeocentricBoundsWithNormal(&v23, a7, a4, a4 + 24, v16, a2);
  *a8 = v23;
  a8[1].i64[0] = v24;
  if (v17)
  {
    if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

void sub_1A23CB038(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_0,std::allocator<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51FF10;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_0,std::allocator<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51FF10;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_0,std::allocator<md::ita::PrepareMeshRenderableBounds::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>,ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &)>::~__func()
{
}

void *std::function<void ()(md::ls::MeshRenderableID const&,md::ls::BoundZScale &,md::ls::BoundZAdjust &,md::ls::MeshRenderableTransformConstantDataHandle const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::PrepareBoundsScaleAndAdjust::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::BoundZScale &,md::ls::BoundZAdjust &,md::ls::MeshRenderableTransformConstantDataHandle const&>)::$_0,std::allocator<md::ita::PrepareBoundsScaleAndAdjust::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::BoundZScale &,md::ls::BoundZAdjust &,md::ls::MeshRenderableTransformConstantDataHandle const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::BoundZScale &,md::ls::BoundZAdjust &,md::ls::MeshRenderableTransformConstantDataHandle const&)>::operator()(uint64_t a1, uint64_t a2, float *a3, _DWORD *a4, unint64_t *a5)
{
  uint64_t v8 = **(void **)(a1 + 8);
  unsigned int v19 = (char *)*a5;
  unsigned int v9 = *(_DWORD *)(*(void *)(v8 + 3336) + 8 * v19);
  uint64_t v10 = *(void *)(v8 + 3360);
  unint64_t v11 = std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::Tile::Transform>> const&>,std::tuple<>>(v8 + 3272, (unint64_t)v19, &v19);
  ++v11[3];
  uint64_t v12 = v10 + 24 * v9;
  uint64_t v14 = *(void *)(v12 + 8);
  uint64_t v13 = *(std::__shared_weak_count **)(v12 + 16);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if ((*(unsigned char *)(v14 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    unsigned int v19 = &v17;
    uint64_t v18 = &v19;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v18, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
  }
  uint64_t v15 = *(void *)(v14 + 72);
  int v16 = *(_DWORD *)(v15 + 40);
  *a3 = (float)(**(float **)(a1 + 16) * **(float **)(a1 + 24)) * *(float *)(v15 + 340);
  *a4 = v16;
  if (v13)
  {
    if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

__n128 std::__function::__func<md::ita::PrepareBoundsScaleAndAdjust::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::BoundZScale &,md::ls::BoundZAdjust &,md::ls::MeshRenderableTransformConstantDataHandle const&>)::$_0,std::allocator<md::ita::PrepareBoundsScaleAndAdjust::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::BoundZScale &,md::ls::BoundZAdjust &,md::ls::MeshRenderableTransformConstantDataHandle const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::BoundZScale &,md::ls::BoundZAdjust &,md::ls::MeshRenderableTransformConstantDataHandle const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51FEC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::PrepareBoundsScaleAndAdjust::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::BoundZScale &,md::ls::BoundZAdjust &,md::ls::MeshRenderableTransformConstantDataHandle const&>)::$_0,std::allocator<md::ita::PrepareBoundsScaleAndAdjust::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::BoundZScale &,md::ls::BoundZAdjust &,md::ls::MeshRenderableTransformConstantDataHandle const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::BoundZScale &,md::ls::BoundZAdjust &,md::ls::MeshRenderableTransformConstantDataHandle const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF51FEC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<md::ita::PrepareBoundsScaleAndAdjust::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::BoundZScale &,md::ls::BoundZAdjust &,md::ls::MeshRenderableTransformConstantDataHandle const&>)::$_0,std::allocator<md::ita::PrepareBoundsScaleAndAdjust::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::BoundZScale &,md::ls::BoundZAdjust &,md::ls::MeshRenderableTransformConstantDataHandle const&>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::BoundZScale &,md::ls::BoundZAdjust &,md::ls::MeshRenderableTransformConstantDataHandle const&)>::~__func()
{
}

void sub_1A23CB6FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A23CB7A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A23CB91C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23CBA64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A23CBCBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(double,double,double)>::~function(va);
  _Unwind_Resume(a1);
}

void sub_1A23CBE70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(double,double,double)>::~function(va);
  _Unwind_Resume(a1);
}

void sub_1A23CBF48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A23CC0A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A23CC3A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,uint64_t a21,char a22)
{
  std::unordered_map<std::string,double>::~unordered_map[abi:nn180100]((uint64_t)&a22);
  uint64_t v27 = *(void **)(v25 - 128);
  if (v27) {
    operator delete(v27);
  }

  _Unwind_Resume(a1);
}

void sub_1A23CC994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void gdc::LogicExecutionGraphBuilder::~LogicExecutionGraphBuilder(gdc::LogicExecutionGraphBuilder *this)
{
  uint64_t v2 = (char *)this + 112;
  uint64_t v3 = (char *)*((void *)this + 17);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  std::__tree<std::__value_type<gdc::ContextTypeWrapper,std::vector<std::pair<gdc::LogicExecutionNode,gdc::LogicExecutionGraphRequirement>>>,std::__map_value_compare<gdc::ContextTypeWrapper,std::__value_type<gdc::ContextTypeWrapper,std::vector<std::pair<gdc::LogicExecutionNode,gdc::LogicExecutionGraphRequirement>>>,gdc::ContextTypeWrapperCompare,true>,std::allocator<std::__value_type<gdc::ContextTypeWrapper,std::vector<std::pair<gdc::LogicExecutionNode,gdc::LogicExecutionGraphRequirement>>>>>::destroy(*((void **)this + 12));
  std::__tree<std::__value_type<gdc::ContextTypeWrapper,std::vector<std::pair<gdc::LogicExecutionNode,gdc::LogicExecutionGraphRequirement>>>,std::__map_value_compare<gdc::ContextTypeWrapper,std::__value_type<gdc::ContextTypeWrapper,std::vector<std::pair<gdc::LogicExecutionNode,gdc::LogicExecutionGraphRequirement>>>,gdc::ContextTypeWrapperCompare,true>,std::allocator<std::__value_type<gdc::ContextTypeWrapper,std::vector<std::pair<gdc::LogicExecutionNode,gdc::LogicExecutionGraphRequirement>>>>>::destroy(*((void **)this + 9));
  uint64_t v4 = (void *)*((void *)this + 5);
  if (v4)
  {
    do
    {
      uint64_t v5 = (void *)*v4;
      operator delete(v4);
      uint64_t v4 = v5;
    }
    while (v5);
  }
  size_t v6 = (void *)*((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v6) {
    operator delete(v6);
  }
  std::__tree<std::__value_type<gdc::LogicExecutionNode,geo::linear_set<gdc::LogicExecutionNode,gdc::LogicExecutionNodeCompare,std::allocator<gdc::LogicExecutionNode>,std::vector<gdc::LogicExecutionNode>>>,std::__map_value_compare<gdc::LogicExecutionNode,std::__value_type<gdc::LogicExecutionNode,geo::linear_set<gdc::LogicExecutionNode,gdc::LogicExecutionNodeCompare,std::allocator<gdc::LogicExecutionNode>,std::vector<gdc::LogicExecutionNode>>>,gdc::LogicExecutionNodeCompare,true>,std::allocator<std::__value_type<gdc::LogicExecutionNode,geo::linear_set<gdc::LogicExecutionNode,gdc::LogicExecutionNodeCompare,std::allocator<gdc::LogicExecutionNode>,std::vector<gdc::LogicExecutionNode>>>>>::destroy(*((void **)this + 1));
}

void sub_1A23CD304(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A23CD5B4(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1A23CD794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    std::__shared_weak_count::__release_weak(a11);
  }

  _Unwind_Resume(a1);
}

void sub_1A23CD904(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    std::__shared_weak_count::__release_weak(a11);
  }

  _Unwind_Resume(a1);
}

void sub_1A23CDC2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, char a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  std::mutex::unlock(v14);
  _Unwind_Resume(a1);
}

void sub_1A23CDDB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    std::__shared_weak_count::__release_weak(a11);
  }

  _Unwind_Resume(a1);
}

void sub_1A23CECE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
  _Unwind_Resume(a1);
}

void sub_1A23CED48(_Unwind_Exception *exception_object)
{
}

void sub_1A23CF018(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A23CF610(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23D0340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  std::function<void ()(GEOPDFlyover const*)>::~function(&a35);
  std::function<void ()(GEOPDFlyover const*)>::~function(&a31);
  -[VKClassicGlobeCanvas startFlyoverTourAnimation:animateToStart:labelChanged:stateChange:]::$_1::~$_1((uint64_t)&a13);
  geo::_retain_ptr<void({block_pointer} {__strong})(NSString *),geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(&a21);

  geo::_retain_ptr<void({block_pointer} {__strong})(VKFlyoverTourState),geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(&a24);
  _Unwind_Resume(a1);
}

void *geo::_retain_ptr<void({block_pointer} {__strong})(VKFlyoverTourState),geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::_retain_ptr(void *a1, uint64_t a2)
{
  *a1 = &unk_1EF55A058;
  a1[1] = 0;
  uint64_t v3 = MEMORY[0x1A6239EB0](*(void *)(a2 + 8));
  if (v3)
  {
    uint64_t v4 = (void *)v3;
    uint64_t v5 = (void *)MEMORY[0x1A6239EB0]();
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v6 = MEMORY[0x1A6239EB0](v5);
  unint64_t v7 = (void *)a1[1];
  a1[1] = v6;

  return a1;
}

void *geo::_retain_ptr<void({block_pointer} {__strong})(NSString *),geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::_retain_ptr(void *a1, uint64_t a2)
{
  *a1 = &unk_1EF55A078;
  a1[1] = 0;
  uint64_t v3 = MEMORY[0x1A6239EB0](*(void *)(a2 + 8));
  if (v3)
  {
    uint64_t v4 = (void *)v3;
    uint64_t v5 = (void *)MEMORY[0x1A6239EB0]();
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v6 = MEMORY[0x1A6239EB0](v5);
  unint64_t v7 = (void *)a1[1];
  a1[1] = v6;

  return a1;
}

void *geo::_retain_ptr<void({block_pointer} {__strong})(VKFlyoverTourState),geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF55A058;
  if (a1[1])
  {

    uint64_t v2 = (void *)a1[1];
  }
  else
  {
    uint64_t v2 = 0;
  }

  return a1;
}

void *geo::_retain_ptr<void({block_pointer} {__strong})(NSString *),geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF55A078;
  if (a1[1])
  {

    uint64_t v2 = (void *)a1[1];
  }
  else
  {
    uint64_t v2 = 0;
  }

  return a1;
}

void ___ZZ90__VKClassicGlobeCanvas_startFlyoverTourAnimation_animateToStart_labelChanged_stateChange__ENK3__1clEPK12GEOPDFlyover_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = *(void **)(*(void *)(a1 + 40) + 672);
    uint64_t v4 = *(unsigned __int8 *)(a1 + 96);
    unint64_t v7 = (void (**)(id, uint64_t))MEMORY[0x1A6239EB0](*(void *)(a1 + 80));
    uint64_t v5 = (void *)MEMORY[0x1A6239EB0](*(void *)(a1 + 56));
    [v3 flyoverTourAnimation:v2 animateToStart:v4 labelChanged:v7 stateChange:v5];
  }
  else
  {
    uint64_t v6 = (void *)MEMORY[0x1A6239EB0](*(void *)(a1 + 56));

    if (!v6) {
      return;
    }
    unint64_t v7 = (void (**)(id, uint64_t))MEMORY[0x1A6239EB0](*(void *)(a1 + 56));
    v7[2](v7, 6);
  }
}

void sub_1A23D08C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_48c152_ZTSN3geo11_retain_ptrIU8__strongU13block_pointerFv18VKFlyoverTourStateENS_16_retain_objc_arcENS_17_release_objc_arcENS_10_hash_objcENS_11_equal_objcEEE72c142_ZTSN3geo11_retain_ptrIU8__strongU13block_pointerFvP8NSStringENS_16_retain_objc_arcENS_17_release_objc_arcENS_10_hash_objcENS_11_equal_objcEEE(void *a1)
{
  a1[9] = &unk_1EF55A078;
  if (a1[10])
  {

    uint64_t v2 = (void *)a1[10];
  }
  else
  {
    uint64_t v2 = 0;
  }

  a1[6] = &unk_1EF55A058;
  uint64_t v3 = (void *)a1[7];
  if (v3)
  {

    uint64_t v3 = (void *)a1[7];
  }
}

void *__copy_helper_block_ea8_48c152_ZTSN3geo11_retain_ptrIU8__strongU13block_pointerFv18VKFlyoverTourStateENS_16_retain_objc_arcENS_17_release_objc_arcENS_10_hash_objcENS_11_equal_objcEEE72c142_ZTSN3geo11_retain_ptrIU8__strongU13block_pointerFvP8NSStringENS_16_retain_objc_arcENS_17_release_objc_arcENS_10_hash_objcENS_11_equal_objcEEE(uint64_t a1, uint64_t a2)
{
  geo::_retain_ptr<void({block_pointer} {__strong})(VKFlyoverTourState),geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::_retain_ptr((void *)(a1 + 48), a2 + 48);
  return geo::_retain_ptr<void({block_pointer} {__strong})(NSString *),geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::_retain_ptr((void *)(a1 + 72), a2 + 72);
}

void geo::_retain_ptr<void({block_pointer} {__strong})(NSString *),geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF55A078;
  if (a1[1])
  {

    uint64_t v2 = (void *)a1[1];
  }
  else
  {
    uint64_t v2 = 0;
  }

  JUMPOUT(0x1A6239270);
}

void geo::_retain_ptr<void({block_pointer} {__strong})(VKFlyoverTourState),geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF55A058;
  if (a1[1])
  {

    uint64_t v2 = (void *)a1[1];
  }
  else
  {
    uint64_t v2 = 0;
  }

  JUMPOUT(0x1A6239270);
}

void sub_1A23D104C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23D12B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23D1400(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23D158C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23D1830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A23D2348(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  std::ostringstream::~ostringstream((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void sub_1A23D2494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  uint64_t v10 = v9;

  a9.super_class = (Class)VKClassicGlobeCanvas;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A23D30CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va1, a13);
  va_start(va, a13);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  std::function<void ()(void)>::~function((uint64_t *)va1);
  std::function<void ()(void)>::~function((uint64_t *)va);

  _Unwind_Resume(a1);
}

void sub_1A23D3B50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A23D3C2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1A23D3DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A23D3E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A23D3F40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::mun::MetadataResource::~MetadataResource(md::mun::MetadataResource *this)
{
  md::mun::MetadataResource::~MetadataResource(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  *(void *)this = &unk_1EF550320;
  uint64_t v2 = *((void *)this + 27);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 28);
    uint64_t v4 = (void *)*((void *)this + 27);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(void **)(v3 - 80);
        if (v5 != *(void **)(v3 - 64)) {
          free(v5);
        }
        if (*(unsigned char *)(v3 - 120)) {
          *(unsigned char *)(v3 - 120) = 0;
        }
        if (*(unsigned char *)(v3 - 160)) {
          *(unsigned char *)(v3 - 160) = 0;
        }
        v3 -= 168;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 27);
    }
    *((void *)this + 28) = v2;
    operator delete(v4);
  }
  uint64_t v6 = (void *)*((void *)this + 24);
  if (v6)
  {
    do
    {
      unint64_t v7 = (void *)*v6;
      operator delete(v6);
      uint64_t v6 = v7;
    }
    while (v7);
  }
  uint64_t v8 = (void *)*((void *)this + 22);
  *((void *)this + 22) = 0;
  if (v8) {
    operator delete(v8);
  }
  unsigned int v9 = *((void *)this + 19);
  if (v9)
  {
    uint64_t v10 = *((void *)this + 20);
    unint64_t v11 = (void *)*((void *)this + 19);
    if (v10 != v9)
    {
      do
      {
        uint64_t v12 = v10 - 1864;
        uint64_t v13 = *(void **)(v10 - 1776);
        uint64_t v14 = *(void **)(v10 - 1768);
        if (v13 != v14)
        {
          do
          {
            uint64_t v15 = (void *)v13[31];
            if (v15 != (void *)v13[33]) {
              free(v15);
            }
            v13 += 36;
          }
          while (v13 != v14);
          uint64_t v13 = *(void **)(v10 - 1776);
        }
        if (v13 != *(void **)(v10 - 1760)) {
          free(v13);
        }
        v10 -= 1864;
      }
      while (v12 != v9);
      unint64_t v11 = (void *)*((void *)this + 19);
    }
    *((void *)this + 20) = v9;
    operator delete(v11);
  }
  int v16 = (void *)*((void *)this + 2);
  if (v16 != *((void **)this + 4)) {
    free(v16);
  }
}

uint64_t md::ARVIOLocationProvider::location(md::ARVIOLocationProvider *this)
{
  return (uint64_t)this + 128;
}

void md::ARVIOLocationProvider::update(uint64_t a1, uint64_t a2, void *a3, double *a4, uint64_t *a5)
{
  id v8 = a3;
  [v8 camera];
  float v121 = &unk_1EF559ED8;
  id v122 = (id)objc_claimAutoreleasedReturnValue();

  [v122 transform];
  double v13 = v9;
  double v15 = v14;
  double v17 = v16;
  double v19 = v18;
  float v21 = v20;
  double v22 = v20;
  double v24 = v23;
  double v26 = v25;
  double v28 = v27;
  double v29 = v10;
  double v30 = v22 + v9;
  double v31 = v30 + v10;
  if (v31 <= 0.0)
  {
    if (v9 <= v21 || v9 <= v10)
    {
      BOOL v38 = v21 <= v10;
      double v39 = sqrt(v29 + 1.0 - v30);
      double v40 = 1.0 / (v39 + v39);
      double v41 = (v26 + v17) * v40;
      double v42 = v28 + v24;
      double v43 = v42 * v40;
      double v44 = v39 * 0.5;
      double v45 = (v15 - v19) * v40;
      double v46 = sqrt(v22 + 1.0 - (v29 + v13));
      double v47 = 1.0 / (v46 + v46);
      double v48 = (v19 + v15) * v47;
      double v34 = v46 * 0.5;
      double v49 = v42 * v47;
      double v36 = (v26 - v17) * v47;
      if (v38) {
        double v33 = v41;
      }
      else {
        double v33 = v48;
      }
      if (v38)
      {
        double v34 = v43;
        double v35 = v44;
      }
      else
      {
        double v35 = v49;
      }
      if (v38) {
        double v36 = v45;
      }
    }
    else
    {
      double v50 = sqrt(v13 + 1.0 - (v29 + v22));
      double v51 = v50 + v50;
      double v33 = v50 * 0.5;
      double v52 = v19 + v15;
      double v53 = 1.0 / v51;
      double v34 = v52 * (1.0 / v51);
      double v35 = (v26 + v17) * v53;
      double v36 = (v24 - v28) * v53;
    }
  }
  else
  {
    double v32 = 0.5 / sqrt(v31 + 1.0);
    double v33 = v32 * (v24 - v28);
    double v34 = v32 * (v26 - v17);
    double v35 = v32 * (v15 - v19);
    double v36 = 0.25 / v32;
  }
  double v54 = v12;
  _Q3 = vcvtq_f64_f32(v11);
  double v57 = a4[2];
  double v56 = a4[3];
  _D18 = *a4;
  double v59 = a4[1];
  double v60 = v33 * v56 + *a4 * v36 + v59 * v35 - v57 * v34;
  double v61 = v59 * v36 - (*a4 * v35 - v34 * v56) + v57 * v33;
  double v62 = v35 * v56 + *a4 * v34 - v59 * v33 + v57 * v36;
  double v63 = -(*a4 * v33 + v59 * v34 + v57 * v35 - v36 * v56);
  double v64 = vmuld_lane_f64(v57, _Q3, 1);
  double v65 = vmlad_n_f64(-(*a4 * v54), v57, _Q3.f64[0]);
  __asm { FMLA            D21, D18, V3.D[1] }
  double v71 = -(v64 - v59 * v54) - (v64 - v59 * v54);
  double v72 = v65 + v65;
  double v73 = _D21 + _D21;
  _Q3.f64[0] = _Q3.f64[0] + v71 * v56 + v73 * v59 - v72 * v57;
  double v74 = _Q3.f64[1] + v71 * v57 + v72 * v56 - v73 * *a4;
  double v75 = v54 - v71 * v59 + v72 * *a4 + v73 * v56;
  *(double *)(a1 + 80) = v61;
  *(double *)(a1 + 88) = v62;
  *(double *)(a1 + 96) = v63;
  *(float64_t *)(a1 + 48) = _Q3.f64[0];
  *(double *)(a1 + 56) = v74;
  *(double *)(a1 + 64) = v75;
  *(double *)(a1 + 72) = v60;
  uint64_t v76 = *a5;
  uint64_t v77 = a5[1];
  double v112 = v74;
  double v113 = _Q3.f64[0];
  double v111 = v75;
  if (*a5 == v77)
  {
    float v80 = 0.0;
    float v79 = 0.0;
    float v78 = 0.0;
  }
  else
  {
    float v78 = 0.0;
    float v79 = 0.0;
    float v80 = 0.0;
    do
    {
      if (v76)
      {
        int v87 = *(_DWORD *)(v76 + 16);
        if (v87 == 1) {
          int v88 = (double *)v76;
        }
        else {
          int v88 = 0;
        }
        if (v87)
        {
          if (v88) {
            float v78 = *v88 * 10.0;
          }
        }
        else
        {
          float v81 = *(float *)(v76 + 8) - *(float *)v76;
          float v82 = *(float *)(v76 + 12) - *(float *)(v76 + 4);
          float v83 = 1.0 / sqrtf((float)(v81 * v81) + (float)(v82 * v82));
          float v84 = v83 * v81;
          float v85 = v83 * v82;
          if (fabsf(v85) > 0.85) {
            float v84 = 0.0;
          }
          float v86 = v85 * 0.75;
          if (fabsf(v84) <= 0.85) {
            float v79 = v86;
          }
          else {
            float v79 = 0.0;
          }
          float v80 = v84 * 0.75;
        }
      }
      v76 += 24;
    }
    while (v76 != v77);
  }
  double v89 = *(double *)(a1 + 32) * 0.0174532925;
  double v90 = *(double *)(a1 + 40);
  __double2 v91 = __sincos_stret(*(double *)(a1 + 24) * 0.0174532925);
  double v92 = 6378137.0 / sqrt(1.0 - v91.__sinval * v91.__sinval * 0.00669437999);
  double v93 = (v92 + v90) * v91.__cosval;
  __double2 v94 = __sincos_stret(v89);
  double v95 = v93 * v94.__cosval;
  double v96 = v93 * v94.__sinval;
  v120[0] = v95;
  v120[1] = v96;
  double v97 = (v90 + v92 * 0.99330562) * v91.__sinval;
  v120[2] = v97;
  gdc::CameraFrame<geo::Radians,double>::createLocalEcefBasis(v114.f64, v120);
  double v98 = *(double *)(a1 + 120) + v119 * v79 + v115 * v80;
  double v99 = v117;
  float64x2_t v100 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 104), v118, v79), v114, v80), v116, v78);
  *(float64x2_t *)(a1 + 104) = v100;
  double v101 = v98 + v99 * v78;
  *(double *)(a1 + 120) = v101;
  long double v102 = v95 + v100.f64[0] + v113;
  long double v103 = v96 + v100.f64[1] + v112;
  long double v104 = v97 + v101 + v111;
  double v105 = sqrt(v102 * v102 + v103 * v103);
  double v106 = atan2(v104, v105 * 0.996647189);
  double v107 = atan2(v103, v102);
  __double2 v108 = __sincos_stret(v106);
  double v109 = atan2(v104 + v108.__sinval * v108.__sinval * 42841.3115 * v108.__sinval, v105 + v108.__cosval * v108.__cosval * -42697.6727 * v108.__cosval);
  __double2 v110 = __sincos_stret(v109);
  *(double *)(a1 + 128) = v109 * 57.2957795;
  *(double *)(a1 + 136) = v107 * 57.2957795;
  *(double *)(a1 + 144) = v105 / v110.__cosval - 6378137.0 / sqrt(1.0 - v110.__sinval * v110.__sinval * 0.00669437999);
  float v121 = &unk_1EF559ED8;
}

void sub_1A23D466C(_Unwind_Exception *a1)
{
  *(void *)(v3 - 136) = v2;

  _Unwind_Resume(a1);
}

void md::ARVIOLocationProvider::~ARVIOLocationProvider(md::ARVIOLocationProvider *this)
{
}

void md::Logic<md::LayerDataLogic,md::LayerDataLogicContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    float v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

uint64_t _ZNKSt3__110__function6__funcIZN2md14LayerDataLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__1NS_9allocatorISH_EEFvvEE7__cloneEPNS0_6__baseISK_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570920;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md14LayerDataLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__1NS_9allocatorISH_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF570920;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md14LayerDataLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__1NS_9allocatorISH_EEFvvEED0Ev()
{
}

void _ZNSt3__110__function6__funcIZN2md14LayerDataLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__0NS_9allocatorISH_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  os_signpost_id_t v2 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = GEOGetVectorKitPerformanceLog_log;
    if (os_signpost_enabled((os_log_t)GEOGetVectorKitPerformanceLog_log))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "LayerDataLogic", "", v4, 2u);
    }
  }
}

uint64_t _ZNKSt3__110__function6__funcIZN2md14LayerDataLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__0NS_9allocatorISH_EEFvvEE7__cloneEPNS0_6__baseISK_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5708D8;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md14LayerDataLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__0NS_9allocatorISH_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5708D8;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md14LayerDataLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__0NS_9allocatorISH_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md14LayerDataLogic28runAfterLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__1NS_9allocatorISH_EEFvvEE7__cloneEPNS0_6__baseISK_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5709B0;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md14LayerDataLogic28runAfterLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__1NS_9allocatorISH_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5709B0;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md14LayerDataLogic28runAfterLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__1NS_9allocatorISH_EEFvvEED0Ev()
{
}

void _ZNSt3__110__function6__funcIZN2md14LayerDataLogic28runAfterLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__0NS_9allocatorISH_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  os_signpost_id_t v2 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = GEOGetVectorKitPerformanceLog_log;
    if (os_signpost_enabled((os_log_t)GEOGetVectorKitPerformanceLog_log))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "LayerDataLogicAfterVariableRate", "", v4, 2u);
    }
  }
}

uint64_t _ZNKSt3__110__function6__funcIZN2md14LayerDataLogic28runAfterLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__0NS_9allocatorISH_EEFvvEE7__cloneEPNS0_6__baseISK_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570968;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md14LayerDataLogic28runAfterLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__0NS_9allocatorISH_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF570968;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md14LayerDataLogic28runAfterLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__0NS_9allocatorISH_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md14LayerDataLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__1NS_9allocatorISH_EEFvvEE7__cloneEPNS0_6__baseISK_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570A40;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md14LayerDataLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__1NS_9allocatorISH_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF570A40;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md14LayerDataLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__1NS_9allocatorISH_EEFvvEED0Ev()
{
}

void _ZNSt3__110__function6__funcIZN2md14LayerDataLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__0NS_9allocatorISH_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  os_signpost_id_t v2 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = GEOGetVectorKitPerformanceLog_log;
    if (os_signpost_enabled((os_log_t)GEOGetVectorKitPerformanceLog_log))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "LayerDataLogicVariableRate", "", v4, 2u);
    }
  }
}

uint64_t _ZNKSt3__110__function6__funcIZN2md14LayerDataLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__0NS_9allocatorISH_EEFvvEE7__cloneEPNS0_6__baseISK_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5709F8;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md14LayerDataLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__0NS_9allocatorISH_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5709F8;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md14LayerDataLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_21LayerDataLogicContextEE3__0NS_9allocatorISH_EEFvvEED0Ev()
{
}

uint64_t md::Logic<md::LayerDataLogic,md::LayerDataLogicContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::LayerDataLogic,md::LayerDataLogicContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x7851AF310F49C988 && *(void *)(a3 + 32)) {
    return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)result + 160))(result, a2, v4);
  }
  a4[23] = 0;
  *a4 = 0;
  return result;
}

uint64_t gdc::ObjectHolder<md::LayerDataLogicContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::LayerDataLogicContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555938;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0x20C4093837F09);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::LayerDataLogicContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555938;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x20C4093837F09);
  }
  return a1;
}

void md::LayerDataLogic::~LayerDataLogic(md::LayerDataLogic *this)
{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

uint64_t pwin_jpg::generate_huf_nodes(uint64_t result, uint64_t a2)
{
  unint64_t v2 = 0;
  int v3 = 0;
  LODWORD(v4) = 0;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_DWORD *)a2 = 1;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  do
  {
    unint64_t v5 = v2 + 1;
    if (*(unsigned char *)(result + v2))
    {
      unsigned int v6 = 0;
      uint64_t v4 = (int)v4;
      char v7 = 15 - v2;
      if (-(int)v2 < -3 || v2 == 3) {
        int v8 = -3;
      }
      else {
        int v8 = -(int)v2;
      }
      int v9 = v8 + 3;
      int v10 = 1 << (v8 + 3);
      if (v10 <= 1) {
        uint64_t v11 = 1;
      }
      else {
        uint64_t v11 = v10;
      }
      int v12 = 4 - v2;
      if (4 - (int)v2 < -3 || v2 == 7) {
        int v12 = -3;
      }
      int v13 = v12 + 3;
      int v14 = 1 << (v12 + 3);
      if (v14 <= 1) {
        uint64_t v15 = 1;
      }
      else {
        uint64_t v15 = v14;
      }
      int v16 = 8 - v2;
      if (8 - (int)v2 < -3 || v2 == 11) {
        int v16 = -3;
      }
      int v17 = v16 + 3;
      int v18 = 1 << (v16 + 3);
      if (v18 <= 1) {
        uint64_t v19 = 1;
      }
      else {
        uint64_t v19 = v18;
      }
      int v20 = 12 - v2;
      if (12 - (int)v2 <= -3) {
        int v20 = -3;
      }
      int v77 = v20 + 3;
      LODWORD(v21) = 1 << (v20 + 3);
      if ((int)v21 <= 1) {
        uint64_t v21 = 1;
      }
      else {
        uint64_t v21 = v21;
      }
      uint64_t v76 = v21;
      uint64_t v75 = v21 & 0x7FFFFFFC;
      do
      {
        int v23 = v3;
        int v24 = *(unsigned __int8 *)(result + v4 + 16);
        float v25 = (_DWORD *)(a2 + 12 * *(unsigned __int8 *)(result + v4 + 16) + 73736);
        *float v25 = v5;
        v25[1] = v23;
        v25[2] = v24;
        unsigned int v26 = v23 << v7;
        uint64_t v27 = (unsigned __int16)(v23 << v7) >> 12;
        uint64_t v28 = a2 + 8 + 8 * v27;
        uint64_t v30 = *(void *)(v28 + 16);
        double v29 = (_DWORD **)(v28 + 16);
        if (!v30)
        {
          int v31 = (*(_DWORD *)a2)++;
          uint64_t v32 = a2 + 144 * v31;
          *(_OWORD *)(v32 + 8) = 0uLL;
          double v33 = (_OWORD *)(v32 + 8);
          v33[1] = 0uLL;
          v33[2] = 0uLL;
          v33[3] = 0uLL;
          v33[4] = 0uLL;
          v33[5] = 0uLL;
          v33[6] = 0uLL;
          v33[7] = 0uLL;
          v33[8] = 0uLL;
          if (v9 != 31)
          {
            if (v11 < 4) {
              goto LABEL_36;
            }
            int64x2_t v34 = vdupq_n_s64((unint64_t)v33);
            double v35 = (int64x2_t *)(a2 + 40 + 8 * v27);
            uint64_t v36 = v11 & 0x7FFFFFFC;
            do
            {
              v35[-1] = v34;
              *double v35 = v34;
              v35 += 2;
              v36 -= 4;
            }
            while (v36);
            if ((v11 & 0x7FFFFFFC) == 0)
            {
LABEL_36:
              int v37 = (void *)(a2 + 24 + 8 * v27);
              uint64_t v38 = v11;
              do
              {
                *v37++ = v33;
                --v38;
              }
              while (v38);
            }
          }
        }
        double v22 = *v29;
        if (v2 >= 4)
        {
          uint64_t v39 = (v26 >> 8) & 0xF;
          double v40 = &v22[2 * v39];
          uint64_t v42 = *((void *)v40 + 2);
          double v41 = (_DWORD **)(v40 + 4);
          if (!v42)
          {
            int v43 = (*(_DWORD *)a2)++;
            uint64_t v44 = a2 + 144 * v43;
            *(_OWORD *)(v44 + 8) = 0uLL;
            double v45 = (_OWORD *)(v44 + 8);
            v45[1] = 0uLL;
            v45[2] = 0uLL;
            v45[3] = 0uLL;
            void v45[4] = 0uLL;
            v45[5] = 0uLL;
            v45[6] = 0uLL;
            v45[7] = 0uLL;
            v45[8] = 0uLL;
            if (v13 != 31)
            {
              if (v15 < 4) {
                goto LABEL_45;
              }
              int64x2_t v46 = vdupq_n_s64((unint64_t)v45);
              double v47 = (int64x2_t *)&v22[2 * v39 + 8];
              uint64_t v48 = v15 & 0x7FFFFFFC;
              do
              {
                v47[-1] = v46;
                int64x2_t *v47 = v46;
                v47 += 2;
                v48 -= 4;
              }
              while (v48);
              if ((v15 & 0x7FFFFFFC) == 0)
              {
LABEL_45:
                double v49 = &v22[2 * v39 + 4];
                uint64_t v50 = v15;
                do
                {
                  *v49++ = v45;
                  --v50;
                }
                while (v50);
              }
            }
          }
          double v22 = *v41;
          if (v2 >= 8)
          {
            uint64_t v51 = v26 >> 4;
            double v52 = &v22[2 * v51];
            uint64_t v54 = *((void *)v52 + 2);
            double v53 = (_DWORD **)(v52 + 4);
            if (!v54)
            {
              int v55 = (*(_DWORD *)a2)++;
              uint64_t v56 = a2 + 144 * v55;
              *(_OWORD *)(v56 + 8) = 0uLL;
              double v57 = (_OWORD *)(v56 + 8);
              v57[1] = 0uLL;
              void v57[2] = 0uLL;
              v57[3] = 0uLL;
              v57[4] = 0uLL;
              v57[5] = 0uLL;
              v57[6] = 0uLL;
              v57[7] = 0uLL;
              v57[8] = 0uLL;
              if (v17 != 31)
              {
                if (v19 < 4) {
                  goto LABEL_54;
                }
                int64x2_t v58 = vdupq_n_s64((unint64_t)v57);
                double v59 = (int64x2_t *)&v22[2 * v51 + 8];
                uint64_t v60 = v19 & 0x7FFFFFFC;
                do
                {
                  v59[-1] = v58;
                  int64x2_t *v59 = v58;
                  v59 += 2;
                  v60 -= 4;
                }
                while (v60);
                if ((v19 & 0x7FFFFFFC) == 0)
                {
LABEL_54:
                  double v61 = &v22[2 * v51 + 4];
                  uint64_t v62 = v19;
                  do
                  {
                    *v61++ = v57;
                    --v62;
                  }
                  while (v62);
                }
              }
            }
            double v22 = *v53;
            if (v2 >= 0xC)
            {
              uint64_t v63 = v26 & 0xF;
              double v64 = &v22[2 * v63];
              uint64_t v66 = *((void *)v64 + 2);
              double v65 = (_DWORD **)(v64 + 4);
              if (!v66)
              {
                int v67 = (*(_DWORD *)a2)++;
                uint64_t v68 = a2 + 144 * v67;
                *(_OWORD *)(v68 + 8) = 0uLL;
                uint64_t v69 = (_OWORD *)(v68 + 8);
                v69[1] = 0uLL;
                v69[2] = 0uLL;
                v69[3] = 0uLL;
                v69[4] = 0uLL;
                v69[5] = 0uLL;
                v69[6] = 0uLL;
                v69[7] = 0uLL;
                v69[8] = 0uLL;
                if (v77 != 31)
                {
                  if (v76 < 4) {
                    goto LABEL_63;
                  }
                  int64x2_t v70 = vdupq_n_s64((unint64_t)v69);
                  double v71 = (int64x2_t *)&v22[2 * v63 + 8];
                  uint64_t v72 = v75;
                  do
                  {
                    v71[-1] = v70;
                    *double v71 = v70;
                    v71 += 2;
                    v72 -= 4;
                  }
                  while (v72);
                  if (!v75)
                  {
LABEL_63:
                    double v73 = &v22[2 * v63 + 4];
                    uint64_t v74 = v76;
                    do
                    {
                      *v73++ = v69;
                      --v74;
                    }
                    while (v74);
                  }
                }
              }
              double v22 = *v65;
            }
          }
        }
        int v3 = v23 + 1;
        ++v4;
        *double v22 = v5;
        v22[1] = v23;
        v22[2] = v24;
        ++v6;
      }
      while (v6 < *(unsigned __int8 *)(result + v2));
    }
    v3 *= 2;
    ++v2;
  }
  while (v5 != 16);
  return result;
}

uint64_t pwin_jpg::p_info_mem_jpg(pwin_jpg *this, unsigned __int8 *a2, int *a3, int *a4, int *a5)
{
  if ((a2 + 4) < 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = 0;
  if (*(unsigned __int8 *)this == 255 && *((unsigned __int8 *)this + 1) == 216)
  {
    int v7 = a2 + 5;
    int v8 = 2;
    while (1)
    {
      do
      {
LABEL_6:
        uint64_t v9 = v8;
        uint64_t v10 = v8 + 1;
        if (v10 == v7) {
          return 0xFFFFFFFFLL;
        }
        if (*((unsigned __int8 *)this + v9) != 255)
        {
          printf("Error SECTION_MARKER expected %x\n", *((unsigned __int8 *)this + v9));
          return 0;
        }
        uint64_t v11 = v9 + 2;
        if (v9 + 2 == v7) {
          return 0xFFFFFFFFLL;
        }
        int v12 = *((unsigned __int8 *)this + v10);
        int v8 = v9 + 2;
      }
      while (v12 == 216);
      if (v12 == 192) {
        break;
      }
      int v8 = a2 + 5;
      if (v9 + 3 != v7)
      {
        int v8 = a2 + 5;
        if (v9 + 4 != v7)
        {
          int v13 = *((unsigned __int8 *)this + v9 + 3);
          int v8 = v9 + 4;
          if ((v13 & 0xFFFF00FF | (*((unsigned __int8 *)this + v11) << 8)) >= 3)
          {
            int v14 = (*((unsigned __int8 *)this + v11) << 8) + v13;
            int v8 = v14 + v11;
            int v15 = a2 - v9;
            int v16 = v14 - 2;
            while (v15)
            {
              --v15;
              if (!--v16) {
                goto LABEL_6;
              }
            }
            return 0xFFFFFFFFLL;
          }
        }
      }
    }
    if (v9 == a2 + 2) {
      int v17 = a2 + 5;
    }
    else {
      int v17 = v9 + 4;
    }
    uint64_t v18 = v17 + 1;
    if (v18 == v7) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v19 = v17 + 2;
    if (v17 + 2 == v7 || (int v20 = v17 + 3, v20 == v7))
    {
      int v21 = -1;
      int v20 = a2 + 5;
    }
    else
    {
      int v21 = (*((unsigned __int8 *)this + v18) << 8) | *((unsigned __int8 *)this + v19);
    }
    *a4 = v21;
    uint64_t v22 = v20 + 1;
    int v23 = -1;
    if (v22 != v7 && v20 != a2 + 3) {
      int v23 = *((unsigned __int8 *)this + v22) | (*((unsigned __int8 *)this + v20) << 8);
    }
    *a3 = v23;
    return 1;
  }
  return v6;
}

float md::FlyoverRouteOverlayCache::animationCompletionPercentage(md::FlyoverRouteOverlayCache *this, VKPolylineOverlay *a2)
{
  return 1.0;
}

uint64_t md::FlyoverRouteOverlayCache::persistentOverlays(id *this)
{
  return [this[3] persistentOverlays];
}

uint64_t md::FlyoverRouteOverlayCache::overlaysInView(id *this)
{
  return [this[3] overlays];
}

void md::FlyoverRouteOverlayCache::update(void *a1, void *a2, uint64_t a3)
{
  unint64_t v5 = a2 + 1;
  uint64_t v6 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      id v12 = (id)v6[4];
      int v13 = (void *)a1[3];
      if (a3) {
        char v14 = [v13 hasPersistentOverlay:v12];
      }
      else {
        char v14 = [v13 hasNonPersistentOverlay:v12];
      }
      char v15 = v14;

      if ((v15 & 1) == 0) {
        (*(void (**)(void *, id, uint64_t))(*a1 + 88))(a1, v12, a3);
      }

      int v16 = (void *)v6[1];
      if (v16)
      {
        do
        {
          int v17 = v16;
          int v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          int v17 = (void *)v6[2];
          BOOL v18 = *v17 == (void)v6;
          uint64_t v6 = v17;
        }
        while (!v18);
      }
      uint64_t v6 = v17;
    }
    while (v17 != v5);
  }
  __double2 v94 = 0;
  double v95 = 0;
  unint64_t v96 = 0;
  int v7 = (void *)a1[3];
  double v93 = v5;
  unsigned int v90 = a3;
  double v89 = a1;
  if ((a3 & 1) == 0)
  {
    uint64_t v51 = (void *)[v7 nonPersistentOverlays];
    double v52 = v51 + 1;
    double v53 = (void *)*v51;
    if ((void *)*v51 == v51 + 1) {
      goto LABEL_121;
    }
    uint64_t v11 = 0;
    double v92 = v51 + 1;
    while (1)
    {
      id v54 = (id)v53[4];
      int v55 = v54;
      uint64_t v56 = (void *)*v5;
      if (*v5)
      {
        double v57 = v5;
        do
        {
          unint64_t v58 = v56[4];
          BOOL v59 = v58 >= (unint64_t)v54;
          if (v58 >= (unint64_t)v54) {
            uint64_t v60 = v56;
          }
          else {
            uint64_t v60 = v56 + 1;
          }
          if (v59) {
            double v57 = v56;
          }
          uint64_t v56 = (void *)*v60;
        }
        while (*v60);
        if (v57 != v5 && (unint64_t)v54 >= v57[4]) {
          goto LABEL_104;
        }
      }
      if ((unint64_t)v11 >= v96) {
        break;
      }
      *(void *)uint64_t v11 = v54;
      double v61 = v11 + 8;
LABEL_103:
      double v95 = v61;
      uint64_t v11 = v61;
LABEL_104:

      uint64_t v76 = (void *)v53[1];
      if (v76)
      {
        do
        {
          int v77 = v76;
          uint64_t v76 = (void *)*v76;
        }
        while (v76);
      }
      else
      {
        do
        {
          int v77 = (void *)v53[2];
          BOOL v18 = *v77 == (void)v53;
          double v53 = v77;
        }
        while (!v18);
      }
      double v53 = v77;
      if (v77 == v52) {
        goto LABEL_122;
      }
    }
    int64_t v62 = v11 - v94;
    uint64_t v63 = (v11 - v94) >> 3;
    unint64_t v64 = v63 + 1;
    if ((unint64_t)(v63 + 1) >> 61) {
      abort();
    }
    uint64_t v65 = v96 - (void)v94;
    if ((uint64_t)(v96 - (void)v94) >> 2 > v64) {
      unint64_t v64 = v65 >> 2;
    }
    if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v66 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v66 = v64;
    }
    if (v66)
    {
      if (v66 >> 61) {
LABEL_133:
      }
        std::__throw_bad_array_new_length[abi:nn180100]();
      int v67 = (char *)operator new(8 * v66);
    }
    else
    {
      int v67 = 0;
    }
    uint64_t v68 = &v67[8 * v63];
    uint64_t v69 = &v67[8 * v66];
    *(void *)uint64_t v68 = v55;
    double v61 = v68 + 8;
    int64_t v70 = v11 - v94;
    if (v11 == v94)
    {
      __double2 v94 = &v67[8 * v63];
      unint64_t v96 = (unint64_t)v69;
      goto LABEL_111;
    }
    unint64_t v71 = v70 - 8;
    if ((unint64_t)(v70 - 8) <= 0x137
      || (unint64_t v78 = v71 & 0xFFFFFFFFFFFFFFF8, &v11[-(v71 & 0xFFFFFFFFFFFFFFF8) - 8] > v11 - 8)
      || &v67[v62 - 8 - v78] > &v67[v62 - 8]
      || (unint64_t v79 = v71 >> 3, &v11[-8 * v79 - 8] < v68) && &v67[v62 - v78 - 8] < v11)
    {
      uint64_t v72 = v11;
    }
    else
    {
      unint64_t v80 = v79 + 1;
      uint64_t v72 = &v11[-8 * (v80 & 0x3FFFFFFFFFFFFFFCLL)];
      float v81 = &v67[8 * v63 - 16];
      float v82 = v11 - 32;
      uint64_t v83 = v80 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v85 = *(_OWORD *)v82;
        long long v84 = *((_OWORD *)v82 + 1);
        *(_OWORD *)float v82 = 0uLL;
        *((_OWORD *)v82 + 1) = 0uLL;
        v82 -= 32;
        *((_OWORD *)v81 - 1) = v85;
        *(_OWORD *)float v81 = v84;
        v81 -= 32;
        v83 -= 4;
      }
      while (v83);
      v68 -= 8 * (v80 & 0x3FFFFFFFFFFFFFFCLL);
      if (v80 == (v80 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_98:
        uint64_t v11 = v94;
        uint64_t v74 = v95;
        __double2 v94 = v68;
        unint64_t v96 = (unint64_t)v69;
        if (v95 != v11)
        {
          double v52 = v92;
          unint64_t v5 = v93;
          do
          {
            uint64_t v75 = (void *)*((void *)v74 - 1);
            v74 -= 8;
          }
          while (v74 != v11);
          if (!v11) {
            goto LABEL_103;
          }
LABEL_102:
          operator delete(v11);
          goto LABEL_103;
        }
LABEL_111:
        double v52 = v92;
        unint64_t v5 = v93;
        if (!v11) {
          goto LABEL_103;
        }
        goto LABEL_102;
      }
    }
    do
    {
      uint64_t v73 = *((void *)v72 - 1);
      v72 -= 8;
      *(void *)uint64_t v72 = 0;
      *((void *)v68 - 1) = v73;
      v68 -= 8;
    }
    while (v72 != v94);
    goto LABEL_98;
  }
  int v8 = (void *)[v7 persistentOverlays];
  uint64_t v9 = v8 + 1;
  uint64_t v10 = (void *)*v8;
  if ((void *)*v8 != v8 + 1)
  {
    uint64_t v11 = 0;
    __double2 v91 = v8 + 1;
    while (1)
    {
      id v19 = (id)v10[4];
      int v20 = v19;
      int v21 = (void *)*v5;
      if (*v5)
      {
        uint64_t v22 = v5;
        do
        {
          unint64_t v23 = v21[4];
          BOOL v24 = v23 >= (unint64_t)v19;
          if (v23 >= (unint64_t)v19) {
            float v25 = v21;
          }
          else {
            float v25 = v21 + 1;
          }
          if (v24) {
            uint64_t v22 = v21;
          }
          int v21 = (void *)*v25;
        }
        while (*v25);
        if (v22 != v5 && (unint64_t)v19 >= v22[4]) {
          goto LABEL_51;
        }
      }
      if ((unint64_t)v11 >= v96) {
        break;
      }
      *(void *)uint64_t v11 = v19;
      unsigned int v26 = v11 + 8;
LABEL_50:
      double v95 = v26;
      uint64_t v11 = v26;
LABEL_51:

      double v41 = (void *)v10[1];
      if (v41)
      {
        do
        {
          uint64_t v42 = v41;
          double v41 = (void *)*v41;
        }
        while (v41);
      }
      else
      {
        do
        {
          uint64_t v42 = (void *)v10[2];
          BOOL v18 = *v42 == (void)v10;
          uint64_t v10 = v42;
        }
        while (!v18);
      }
      uint64_t v10 = v42;
      if (v42 == v9) {
        goto LABEL_122;
      }
    }
    int64_t v27 = v11 - v94;
    uint64_t v28 = (v11 - v94) >> 3;
    unint64_t v29 = v28 + 1;
    if ((unint64_t)(v28 + 1) >> 61) {
      abort();
    }
    uint64_t v30 = v96 - (void)v94;
    if ((uint64_t)(v96 - (void)v94) >> 2 > v29) {
      unint64_t v29 = v30 >> 2;
    }
    if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v31 = v29;
    }
    if (v31)
    {
      if (v31 >> 61) {
        goto LABEL_133;
      }
      uint64_t v32 = (char *)operator new(8 * v31);
    }
    else
    {
      uint64_t v32 = 0;
    }
    double v33 = &v32[8 * v28];
    int64x2_t v34 = &v32[8 * v31];
    *(void *)double v33 = v20;
    unsigned int v26 = v33 + 8;
    int64_t v35 = v11 - v94;
    if (v11 == v94)
    {
      __double2 v94 = &v32[8 * v28];
      unint64_t v96 = (unint64_t)v34;
      goto LABEL_58;
    }
    unint64_t v36 = v35 - 8;
    if ((unint64_t)(v35 - 8) <= 0x137
      || (unint64_t v43 = v36 & 0xFFFFFFFFFFFFFFF8, &v11[-(v36 & 0xFFFFFFFFFFFFFFF8) - 8] > v11 - 8)
      || &v32[v27 - 8 - v43] > &v32[v27 - 8]
      || (unint64_t v44 = v36 >> 3, &v11[-8 * v44 - 8] < v33) && &v32[v27 - v43 - 8] < v11)
    {
      int v37 = v11;
    }
    else
    {
      unint64_t v45 = v44 + 1;
      int v37 = &v11[-8 * (v45 & 0x3FFFFFFFFFFFFFFCLL)];
      int64x2_t v46 = &v32[8 * v28 - 16];
      double v47 = v11 - 32;
      uint64_t v48 = v45 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v50 = *(_OWORD *)v47;
        long long v49 = *((_OWORD *)v47 + 1);
        *(_OWORD *)double v47 = 0uLL;
        *((_OWORD *)v47 + 1) = 0uLL;
        v47 -= 32;
        *((_OWORD *)v46 - 1) = v50;
        *(_OWORD *)int64x2_t v46 = v49;
        v46 -= 32;
        v48 -= 4;
      }
      while (v48);
      v33 -= 8 * (v45 & 0x3FFFFFFFFFFFFFFCLL);
      if (v45 == (v45 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_45:
        uint64_t v11 = v94;
        uint64_t v39 = v95;
        __double2 v94 = v33;
        unint64_t v96 = (unint64_t)v34;
        if (v95 != v11)
        {
          uint64_t v9 = v91;
          unint64_t v5 = v93;
          do
          {
            double v40 = (void *)*((void *)v39 - 1);
            v39 -= 8;
          }
          while (v39 != v11);
          if (!v11) {
            goto LABEL_50;
          }
LABEL_49:
          operator delete(v11);
          goto LABEL_50;
        }
LABEL_58:
        uint64_t v9 = v91;
        unint64_t v5 = v93;
        if (!v11) {
          goto LABEL_50;
        }
        goto LABEL_49;
      }
    }
    do
    {
      uint64_t v38 = *((void *)v37 - 1);
      v37 -= 8;
      *(void *)int v37 = 0;
      *((void *)v33 - 1) = v38;
      v33 -= 8;
    }
    while (v37 != v94);
    goto LABEL_45;
  }
LABEL_121:
  uint64_t v11 = 0;
LABEL_122:
  if (v94 == v11)
  {
    if (!v11) {
      return;
    }
  }
  else
  {
    float v86 = (id *)v94;
    do
    {
      id v87 = *v86;
      (*(void (**)(void *, id, void))(*v89 + 96))(v89, v87, v90);

      ++v86;
    }
    while (v86 != (id *)v11);
    if (!v94) {
      return;
    }
    do
    {
      int v88 = (void *)*((void *)v11 - 1);
      v11 -= 8;
    }
    while (v11 != v94);
  }
  operator delete(v94);
}

void sub_1A23D5B40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::vector<VKTransitLineMarker * {__strong}>::~vector[abi:nn180100]((void **)va);
  _Unwind_Resume(a1);
}

uint64_t md::FlyoverRouteOverlayCache::removeOverlay(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    [*(id *)(a1 + 8) stopObserving:v5];
  }
  uint64_t v6 = *(void **)(a1 + 24);
  if (a3) {
    [v6 removePersistentOverlay:v5];
  }
  else {
    [v6 removeNonPersistentOverlay:v5];
  }

  return 1;
}

void sub_1A23D5C20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL md::FlyoverRouteOverlayCache::addOverlay(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  if (v5)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      [*(id *)(a1 + 8) startObserving:v5];
    }
    uint64_t v6 = *(void **)(a1 + 24);
    if (a3) {
      [v6 addPersistentOverlay:v5];
    }
    else {
      [v6 addNonPersistentOverlay:v5];
    }
  }

  return v5 != 0;
}

void sub_1A23D5CC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::FlyoverRouteOverlayCache::isStandard(md::FlyoverRouteOverlayCache *this)
{
  return 0;
}

uint64_t md::FlyoverRouteOverlayCache::routeLineHalfWidthAtZ(id *this, VKPolylineOverlay *a2, float a3)
{
  return objc_msgSend(this[3], "halfWidthForLine:styleZ:", a2);
}

uint64_t md::FlyoverRouteOverlayCache::hasPolylineOverlay(id *this, VKPolylineOverlay *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  int v3 = a2;
  uint64_t v4 = (void *)[this[3] persistentOverlays];
  id v5 = v4 + 1;
  uint64_t v6 = (void *)*v4;
  if ((void *)*v4 == v4 + 1)
  {
LABEL_24:
    uint64_t v17 = 0;
    goto LABEL_27;
  }
  while (1)
  {
    int v7 = (VKPolylineOverlay *)(id)v6[4];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      break;
    }
    if (v7 == v3)
    {
      int v8 = v3;
      goto LABEL_26;
    }
LABEL_18:

    char v14 = (void *)v6[1];
    if (v14)
    {
      do
      {
        char v15 = v14;
        char v14 = (void *)*v14;
      }
      while (v14);
    }
    else
    {
      do
      {
        char v15 = (void *)v6[2];
        BOOL v16 = *v15 == (void)v6;
        uint64_t v6 = v15;
      }
      while (!v16);
    }
    uint64_t v6 = v15;
    if (v15 == v5) {
      goto LABEL_24;
    }
  }
  int v8 = v7;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  uint64_t v9 = [(VKPolylineOverlay *)v8 polylines];
  uint64_t v10 = [v9 countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (!v10)
  {
LABEL_16:

    goto LABEL_18;
  }
  uint64_t v11 = *(void *)v20;
LABEL_5:
  if (*(void *)v20 == v11)
  {
    id v12 = (VKPolylineOverlay **)*((void *)&v19 + 1);
    while (*v12 != v3)
    {
      ++v12;
      if (!--v10) {
        goto LABEL_15;
      }
    }
  }
  else
  {
    uint64_t v13 = 0;
    while (1)
    {
      if (*(void *)v20 != v11) {
        objc_enumerationMutation(v9);
      }
      if (*(VKPolylineOverlay **)(*((void *)&v19 + 1) + 8 * v13) == v3) {
        break;
      }
      if (v10 == ++v13)
      {
LABEL_15:
        uint64_t v10 = [v9 countByEnumeratingWithState:&v19 objects:v23 count:16];
        if (v10) {
          goto LABEL_5;
        }
        goto LABEL_16;
      }
    }
  }

LABEL_26:
  uint64_t v17 = 1;
LABEL_27:

  return v17;
}

void sub_1A23D5EE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id md::FlyoverRouteOverlayCache::polylineForRoute(id *this, GEOComposedRoute *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  int v3 = a2;
  uint64_t v4 = (void *)[this[3] persistentOverlays];
  id v5 = v4 + 1;
  uint64_t v6 = (void *)*v4;
  if ((void *)*v4 == v4 + 1)
  {
LABEL_19:
    id v23 = 0;
    goto LABEL_22;
  }
  while (1)
  {
    id v7 = (id)v6[4];
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();
    id v9 = v7;
    uint64_t v10 = v9;
    if (isKindOfClass)
    {
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      uint64_t v11 = objc_msgSend(v9, "polylines", 0);
      uint64_t v12 = [v11 countByEnumeratingWithState:&v25 objects:v29 count:16];
      if (v12)
      {
        uint64_t v13 = *(void *)v26;
        while (2)
        {
          for (uint64_t i = 0; i != v12; ++i)
          {
            if (*(void *)v26 != v13) {
              objc_enumerationMutation(v11);
            }
            char v15 = *(void **)(*((void *)&v25 + 1) + 8 * i);
            BOOL v16 = [v15 composedRoute];
            BOOL v17 = v16 == v3;

            if (v17)
            {
              id v23 = v15;

              goto LABEL_21;
            }
          }
          uint64_t v12 = [v11 countByEnumeratingWithState:&v25 objects:v29 count:16];
          if (v12) {
            continue;
          }
          break;
        }
      }

      goto LABEL_13;
    }
    BOOL v18 = [v9 composedRoute];
    BOOL v19 = v18 == v3;

    if (v19) {
      break;
    }
LABEL_13:

    long long v20 = (void *)v6[1];
    if (v20)
    {
      do
      {
        long long v21 = v20;
        long long v20 = (void *)*v20;
      }
      while (v20);
    }
    else
    {
      do
      {
        long long v21 = (void *)v6[2];
        BOOL v22 = *v21 == (void)v6;
        uint64_t v6 = v21;
      }
      while (!v22);
    }
    uint64_t v6 = v21;
    if (v21 == v5) {
      goto LABEL_19;
    }
  }
  id v23 = v10;
LABEL_21:

LABEL_22:
  return v23;
}

void sub_1A23D613C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::FlyoverRouteOverlayCache::~FlyoverRouteOverlayCache(md::FlyoverRouteOverlayCache *this)
{
  *(void *)this = off_1EF544FE8;
  *((void *)this + 5) = &unk_1EF559BF8;

  *((void *)this + 2) = &unk_1EF559938;
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = off_1EF544FE8;
  *((void *)this + 5) = &unk_1EF559BF8;

  *((void *)this + 2) = &unk_1EF559938;
}

void geo::_retain_ptr<VKGlobeLineContainer * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559938;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKGlobeLineContainer * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559938;

  return a1;
}

void geo::_retain_ptr<GlobeLineContainerDelegate * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559BF8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<GlobeLineContainerDelegate * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559BF8;

  return a1;
}

void md::FlyoverRouteOverlayCache::onPolylineSkippedInGroup(id *this, VKPolylineGroupOverlay *a2, VKPolylineOverlay *a3)
{
  uint64_t v4 = a3;
  [this[3] clearLineSkip];
  id v5 = this[3];
  uint64_t v6 = v4;
  id v7 = off_1EF559738;
  int v8 = v6;
  [v5 setSkipped:&v7 skipped:1];
  id v7 = off_1EF559738;
}

void sub_1A23D64D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void md::FlyoverRouteOverlayCache::onPolylineSelectedInGroup(id *this, VKPolylineGroupOverlay *a2, VKPolylineOverlay *a3)
{
  uint64_t v4 = a3;
  [this[3] clearLineSelection];
  id v5 = this[3];
  uint64_t v6 = v4;
  id v7 = off_1EF559738;
  int v8 = v6;
  [v5 setSelected:&v7 selected:1];
  id v7 = off_1EF559738;
}

void sub_1A23D65A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

uint64_t md::TransitNode::updateExternalIcon(md::TransitNode *this, md::TransitNodeExternalIcon *a2)
{
  return 0;
}

uint64_t md::TransitNode::initializeExternalIcon()
{
  return 0;
}

uint64_t md::TransitNode::parentID(md::TransitNode *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 1) + 256);
  if (v1) {
    return *(void *)v1;
  }
  else {
    return 0;
  }
}

uint64_t md::TransitNode::debugString@<X0>(md::TransitNode *this@<X0>, int a2@<W1>, unsigned char *a3@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v24);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)"\n <node>", 8);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)" drawAsXfer:", 12);
  uint64_t v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)" nodeIconType:", 14);
  id v7 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)", nodeType:", 11);
  int v8 = (*(uint64_t (**)(md::TransitNode *))(*(void *)this + 56))(this);
  if (v8 == 2)
  {
    uint64_t v9 = 6;
    char v23 = 6;
    LODWORD(__p[0]) = 1752199759;
    __int16 v10 = 28257;
    goto LABEL_7;
  }
  if (v8 == 1)
  {
    uint64_t v9 = 6;
    char v23 = 6;
    LODWORD(__p[0]) = 1701994832;
    __int16 v10 = 29806;
LABEL_7:
    WORD2(__p[0]) = v10;
    BYTE6(__p[0]) = 0;
    goto LABEL_9;
  }
  if (v8)
  {
    uint64_t v9 = 0;
    char v23 = 0;
    LOBYTE(__p[0]) = 0;
  }
  else
  {
    uint64_t v9 = 9;
    char v23 = 9;
    strcpy((char *)__p, "Connected");
  }
LABEL_9:
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)__p, v9);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)", tileZ:", 8);
  std::ostream::operator<<();
  if (v23 < 0) {
    operator delete(__p[0]);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)"\n   isActive:", 13);
  uint64_t v11 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)" isSelected:", 12);
  std::ostream::operator<<();
  if (a2)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)"\n  TransitLineIDs:", 18);
    uint64_t v12 = *((void *)this + 4);
    for (uint64_t i = *((void *)this + 5); v12 != i; v12 += 8)
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)"\n   ", 4);
      std::ostream::operator<<();
    }
  }
  if ((v31 & 0x10) != 0)
  {
    unint64_t v15 = v30;
    if (v30 < v27)
    {
      unint64_t v30 = v27;
      unint64_t v15 = v27;
    }
    BOOL v16 = (const void **)&v26;
  }
  else
  {
    if ((v31 & 8) == 0)
    {
      size_t v14 = 0;
      a3[23] = 0;
      goto LABEL_29;
    }
    BOOL v16 = (const void **)v25;
    unint64_t v15 = v25[2];
  }
  BOOL v17 = *v16;
  size_t v14 = v15 - (void)*v16;
  if (v14 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v14 >= 0x17)
  {
    uint64_t v18 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v18 = v14 | 7;
    }
    uint64_t v19 = v18 + 1;
    long long v20 = operator new(v18 + 1);
    *((void *)a3 + 1) = v14;
    *((void *)a3 + 2) = v19 | 0x8000000000000000;
    *(void *)a3 = v20;
    a3 = v20;
    goto LABEL_28;
  }
  a3[23] = v14;
  if (v14) {
LABEL_28:
  }
    memmove(a3, v17, v14);
LABEL_29:
  a3[v14] = 0;
  v24[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v24 + *(void *)(v24[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v24[1] = MEMORY[0x1E4FBA470] + 16;
  if (v29 < 0) {
    operator delete(v28);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v32);
}

void sub_1A23D69C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

uint64_t md::TransitOrphanNode::transitNodeType(md::TransitOrphanNode *this)
{
  return 2;
}

BOOL md::TransitOrphanNode::initializeExternalIcon(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  int v6 = *(char *)(a1 + 60);
  *(unsigned char *)(a2 + 260) = *(unsigned char *)(a1 + 60);
  *(unsigned char *)(a2 + 70) = v6 != 2;
  *(_DWORD *)(a2 + 244) = *((_DWORD *)a3 + 8);
  uint64_t v7 = md::TransitNodeTextureAtlas::infoForIcon(a4, v6, a3[1], *a3, 0);
  uint64_t v8 = v7;
  if (v7)
  {
    md::TransitNodeExternalIcon::setDotTextureRect((float32x4_t *)a2, (__int8 *)v7, v7 + 8, (float *)(v7 + 24));
    uint64_t v9 = *(void *)(a2 + 104);
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((*(void *)(a2 + 112) - v9) >> 2);
    if (*(void *)(a2 + 112) == v9)
    {
      std::vector<md::TransitNodeExternalIcon::DotInfo>::__append((char **)(a2 + 104), 1 - v10);
      uint64_t v9 = *(void *)(a2 + 104);
    }
    else if (v10 >= 2)
    {
      *(void *)(a2 + 112) = v9 + 20;
    }
    if (*(unsigned char *)(*(void *)(a1 + 8) + 320))
    {
      *(_DWORD *)(v9 + 8) = -1;
    }
    else
    {
      uint64_t v11 = *(void *)(a1 + 32);
      if (v11 == *(void *)(a1 + 40))
      {
        unsigned __int32 v13 = -13224394;
      }
      else
      {
        int16x8_t v12 = (int16x8_t)vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)(*(void *)(*(void *)v11 + 64) + 32), (float32x4_t)vdupq_n_s32(0x437F0000u)));
        *(int16x4_t *)v12.i8 = vmovn_s32((int32x4_t)v12);
        unsigned __int32 v13 = vmovn_s16(v12).u32[0];
      }
      *(_DWORD *)(v9 + 8) = v13;
    }
    if (*(unsigned char *)(a2 + 260) == 2)
    {
      float v14 = (float)(*(_DWORD *)(a2 + 248) + *(_DWORD *)(a2 + 252) / 2);
    }
    else
    {
      uint64_t v15 = *(void *)(a2 + 104);
      uint64_t v16 = *(void *)(a2 + 112);
      if (v15 == v16)
      {
        float v14 = (float)(*(_DWORD *)(a2 + 256) / 2);
        float v20 = 0.0;
      }
      else
      {
        unint64_t v17 = v16 - v15 - 20;
        if (v17 > 0x9F)
        {
          unint64_t v21 = v17 / 0x14 + 1;
          uint64_t v22 = v21 & 7;
          if ((v21 & 7) == 0) {
            uint64_t v22 = 8;
          }
          unint64_t v23 = v21 - v22;
          uint64_t v24 = 20 * v23;
          float32x4_t v25 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
          uint64_t v26 = (__int32 *)(v15 + 92);
          v27.i64[0] = 0x80000000800000;
          v27.i64[1] = 0x80000000800000;
          float32x4_t v28 = v25;
          v29.i64[0] = 0x80000000800000;
          v29.i64[1] = 0x80000000800000;
          do
          {
            unint64_t v30 = v26 + 5;
            int v31 = v26 + 10;
            v32.i32[0] = *(v26 - 20);
            v32.i32[1] = *(v26 - 15);
            double v33 = v26 + 15;
            v32.i32[2] = *(v26 - 10);
            v32.i32[3] = *(v26 - 5);
            __int32 v34 = *v26;
            v26 += 40;
            v35.i32[0] = v34;
            v35.i32[1] = *v30;
            v35.i32[2] = *v31;
            v35.i32[3] = *v33;
            float32x4_t v27 = vmaxnmq_f32(v27, v32);
            float32x4_t v29 = vmaxnmq_f32(v29, v35);
            float32x4_t v25 = vminnmq_f32(v32, v25);
            float32x4_t v28 = vminnmq_f32(v35, v28);
            v23 -= 8;
          }
          while (v23);
          v15 += v24;
          float v18 = vmaxnmvq_f32(vmaxnmq_f32(v27, v29));
          float v19 = vminnmvq_f32(vminnmq_f32(v25, v28));
        }
        else
        {
          float v18 = -3.4028e38;
          float v19 = 3.4028e38;
        }
        do
        {
          float v36 = *(float *)(v15 + 12);
          float v18 = fmaxf(v18, v36);
          float v19 = fminf(v36, v19);
          v15 += 20;
        }
        while (v15 != v16);
        float v20 = (float)(v19 + v18) * 0.5;
        float v14 = (float)(v18 - v20) + (float)(*(_DWORD *)(a2 + 256) / 2);
      }
      *(float32x2_t *)(a2 + 48) = vmul_n_f32(*(float32x2_t *)(a2 + 220), v20);
    }
    *(unsigned char *)(a2 + 64) = 1;
    *(float *)(a2 + 44) = v14;
  }
  return v8 != 0;
}

void std::vector<md::TransitNodeExternalIcon::DotInfo>::__append(char **a1, unint64_t a2)
{
  id v5 = a1[1];
  uint64_t v4 = a1[2];
  if (0xCCCCCCCCCCCCCCCDLL * ((v4 - v5) >> 2) >= a2)
  {
    if (a2)
    {
      size_t v12 = 20 * ((20 * a2 - 20) / 0x14) + 20;
      bzero(a1[1], v12);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    int v6 = *a1;
    unint64_t v7 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 2);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0xCCCCCCCCCCCCCCCLL) {
      abort();
    }
    unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * ((v4 - v6) >> 2);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x666666666666666) {
      unint64_t v10 = 0xCCCCCCCCCCCCCCCLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0xCCCCCCCCCCCCCCCLL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v11 = (char *)operator new(20 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    unsigned __int32 v13 = &v11[20 * v7];
    float v14 = &v11[20 * v10];
    size_t v15 = 20 * ((20 * a2 - 20) / 0x14) + 20;
    bzero(v13, v15);
    uint64_t v16 = &v13[v15];
    if (v5 != v6)
    {
      uint64_t v17 = 0;
      do
      {
        float v18 = &v13[v17];
        *(void *)(v18 - 20) = *(void *)&v5[v17 - 20];
        *((_DWORD *)v18 - 3) = *(_DWORD *)&v5[v17 - 12];
        int v19 = *(_DWORD *)&v5[v17 - 8];
        *(v18 - 4) = v5[v17 - 4];
        *((_DWORD *)v18 - 2) = v19;
        v17 -= 20;
      }
      while (&v5[v17] != v6);
      v13 += v17;
      id v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v16;
    a1[2] = v14;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void md::TransitOrphanNode::~TransitOrphanNode(md::TransitOrphanNode *this)
{
  *(void *)this = &unk_1EF5381C8;
  uint64_t v2 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1060C4067290D6BLL);
  }
  *(void *)this = &unk_1EF531178;
  int v3 = (void *)*((void *)this + 4);
  if (v3)
  {
    *((void *)this + 5) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  void *v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF5381C8;
  uint64_t v2 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1060C4067290D6BLL);
  }
  *(void *)this = &unk_1EF531178;
  int v3 = (void *)*((void *)this + 4);
  if (v3)
  {
    *((void *)this + 5) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t md::TransitConnectedNode::transitNodeType(md::TransitConnectedNode *this)
{
  return 0;
}

void md::TransitConnectedNode::didUpdateTransitLinks(md::TransitConnectedNode *this, int a2)
{
  int v2 = *((_DWORD *)this + 31);
  if ((v2 + 1) > 1) {
    int v3 = v2 + 1;
  }
  else {
    int v3 = 1;
  }
  *((_DWORD *)this + 31) = v3;
  if (a2)
  {
    int v5 = *((_DWORD *)this + 32);
    if ((v5 + 1) > 1) {
      int v6 = v5 + 1;
    }
    else {
      int v6 = 1;
    }
    *((_DWORD *)this + 32) = v6;
    if (*((unsigned char *)this + 60) || (md::TransitConnectedNode::createDots(this), *((unsigned char *)this + 60)))
    {
      unint64_t v7 = (void *)*((void *)this + 12);
      unint64_t v8 = (void *)v7[3];
      if (v8 == v7 + 4)
      {
        unint64_t v9 = 0;
      }
      else
      {
        unint64_t v9 = 0;
        do
        {
          if (v9 <= (uint64_t)(*(void *)(v8[4] + 112) - *(void *)(v8[4] + 104)) >> 3) {
            unint64_t v9 = (uint64_t)(*(void *)(v8[4] + 112) - *(void *)(v8[4] + 104)) >> 3;
          }
          unint64_t v10 = (void *)v8[1];
          if (v10)
          {
            do
            {
              uint64_t v11 = v10;
              unint64_t v10 = (void *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              uint64_t v11 = (void *)v8[2];
              BOOL v12 = *v11 == (void)v8;
              unint64_t v8 = v11;
            }
            while (!v12);
          }
          unint64_t v8 = v11;
        }
        while (v11 != v7 + 4);
      }
      unsigned __int32 v13 = (void *)v7[6];
      float v14 = v7 + 7;
      if (v13 != v14)
      {
        do
        {
          if (v9 <= (uint64_t)(*(void *)(v13[4] + 112) - *(void *)(v13[4] + 104)) >> 3) {
            unint64_t v9 = (uint64_t)(*(void *)(v13[4] + 112) - *(void *)(v13[4] + 104)) >> 3;
          }
          size_t v15 = (void *)v13[1];
          if (v15)
          {
            do
            {
              uint64_t v16 = v15;
              size_t v15 = (void *)*v15;
            }
            while (v15);
          }
          else
          {
            do
            {
              uint64_t v16 = (void *)v13[2];
              BOOL v12 = *v16 == (void)v13;
              unsigned __int32 v13 = v16;
            }
            while (!v12);
          }
          unsigned __int32 v13 = v16;
        }
        while (v16 != v14);
      }
      if (v9 != 2)
      {
LABEL_24:
        if (v9 != 1)
        {
          if (!v9)
          {
            *((unsigned char *)this + 61) = 0;
            return;
          }
          if (v9 > 4) {
            LOBYTE(v9) = 4;
          }
          else {
            LOBYTE(v9) = 3;
          }
        }
      }
    }
    else
    {
      unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 10) - *((void *)this + 9)) >> 3);
      if (v9 != 2) {
        goto LABEL_24;
      }
    }
    *((unsigned char *)this + 61) = v9;
  }
}

void md::TransitConnectedNode::createDots(md::TransitConnectedNode *this)
{
  *((void *)this + 10) = *((void *)this + 9);
  uint64_t v139 = 0;
  uint64_t v140 = 0;
  unint64_t v138 = &v139;
  uint64_t v1 = *((void *)this + 4);
  uint64_t v2 = *((void *)this + 5);
  while (v1 != v2)
  {
    unint64_t v3 = *(void *)(*(void *)(*(void *)v1 + 16) + 40);
    uint64_t v4 = &v139;
    int v5 = &v139;
    if (v139)
    {
      int v6 = v139;
      while (1)
      {
        while (1)
        {
          int v5 = (uint64_t **)v6;
          unint64_t v7 = v6[4];
          if (v3 >= v7) {
            break;
          }
          int v6 = *v5;
          uint64_t v4 = v5;
          if (!*v5) {
            goto LABEL_12;
          }
        }
        if (v7 >= v3) {
          break;
        }
        int v6 = v5[1];
        if (!v6)
        {
          uint64_t v4 = v5 + 1;
          goto LABEL_12;
        }
      }
    }
    else
    {
LABEL_12:
      unint64_t v8 = (uint64_t *)operator new(0x28uLL);
      v8[4] = v3;
      *unint64_t v8 = 0;
      v8[1] = 0;
      uint64_t v8[2] = (uint64_t)v5;
      *uint64_t v4 = v8;
      if (*v138)
      {
        unint64_t v138 = (uint64_t **)*v138;
        unint64_t v8 = *v4;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v139, v8);
      ++v140;
    }
    v1 += 8;
  }
  int v136 = 0;
  uint64_t v137 = 0;
  int v135 = &v136;
  unint64_t v9 = this;
  unint64_t v10 = (void *)*((void *)this + 12);
  uint64_t v11 = (void *)v10[3];
  unint64_t v131 = v10 + 4;
  if (v11 == v10 + 4)
  {
    unint64_t v12 = 0;
    goto LABEL_108;
  }
  unint64_t v12 = 0;
  while (2)
  {
    unsigned __int32 v13 = (void *)v11[4];
    float v14 = (void *)v13[10];
    size_t v15 = (void *)v13[11];
    if (v14 == v15 || !v139) {
      goto LABEL_19;
    }
    while (2)
    {
      if (*v14) {
        int v19 = (unsigned int *)(*v14 + 8);
      }
      else {
        int v19 = 0;
      }
      float v20 = v139;
      if (!v139) {
        goto LABEL_28;
      }
      unint64_t v21 = *(void *)(*(void *)(*(void *)v19 + 16) + 40);
      while (1)
      {
        unint64_t v22 = v20[4];
        if (v21 < v22) {
          goto LABEL_35;
        }
        if (v22 >= v21) {
          break;
        }
        ++v20;
LABEL_35:
        float v20 = (uint64_t *)*v20;
        if (!v20) {
          goto LABEL_28;
        }
      }
      unint64_t v23 = v19[10];
      uint64_t v24 = v13[13];
      if (v23 >= (v13[14] - v24) >> 3) {
        unint64_t v25 = 0;
      }
      else {
        unint64_t v25 = *(void *)(v24 + 8 * v23);
      }
      uint64_t v26 = (int8x8_t *)*((void *)v9 + 12);
      float32x4_t v27 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(&v26[21], v25);
      if (v27)
      {
        unsigned int v28 = *((_DWORD *)v27 + 6);
        if (!v25) {
          goto LABEL_28;
        }
      }
      else
      {
        unsigned int v28 = 0;
        if (!v25) {
          goto LABEL_28;
        }
      }
      for (uint64_t i = v136; i; uint64_t i = (void *)*i)
      {
        unsigned int v39 = *((_DWORD *)i + 7);
        if (v28 >= v39)
        {
          if (v39 >= v28) {
            goto LABEL_28;
          }
          ++i;
        }
      }
      if (!v12) {
        unint64_t v12 = v25;
      }
      unint64_t v30 = (float *)md::TransitJunction::normalForLineSegment(v26, v25);
      if (v30)
      {
        unint64_t v133 = v12;
        float v31 = *v30;
        float v32 = v30[1];
        float v33 = sqrtf((float)(v31 * v31) + (float)(v32 * v32));
        float v34 = 0.0;
        float v35 = 0.0;
        if (v33 > 0.01)
        {
          float v34 = (float)-v31 / v33;
          float v35 = (float)-v32 / v33;
        }
        int v37 = (float *)*((void *)v9 + 10);
        unint64_t v36 = *((void *)v9 + 11);
        if ((unint64_t)v37 >= v36)
        {
          double v40 = (float *)*((void *)v9 + 9);
          unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * (((char *)v37 - (char *)v40) >> 3) + 1;
          if (v41 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          unint64_t v42 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v36 - (void)v40) >> 3);
          if (2 * v42 > v41) {
            unint64_t v41 = 2 * v42;
          }
          if (v42 >= 0x555555555555555) {
            unint64_t v43 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v43 = v41;
          }
          if (v43 > 0xAAAAAAAAAAAAAAALL) {
            goto LABEL_217;
          }
          unint64_t v44 = (char *)operator new(24 * v43);
          unint64_t v45 = (float *)&v44[8 * (((char *)v37 - (char *)v40) >> 3)];
          float *v45 = v34;
          v45[1] = v35;
          v45[2] = 0.0;
          *((void *)v45 + 2) = v25;
          if (v37 == v40)
          {
            double v47 = &v44[8 * (((char *)v37 - (char *)v40) >> 3)];
          }
          else
          {
            int64x2_t v46 = &v44[8 * (((char *)v37 - (char *)v40) >> 3)];
            do
            {
              double v47 = v46 - 24;
              long long v48 = *(_OWORD *)(v37 - 6);
              *((void *)v46 - 1) = *((void *)v37 - 1);
              *(_OWORD *)(v46 - 24) = v48;
              v37 -= 6;
              v46 -= 24;
            }
            while (v37 != v40);
          }
          long long v49 = &v44[24 * v43];
          uint64_t v38 = v45 + 6;
          unint64_t v9 = this;
          *((void *)this + 9) = v47;
          *((void *)this + 10) = v45 + 6;
          *((void *)this + 11) = v49;
          if (v40) {
            operator delete(v40);
          }
        }
        else
        {
          float *v37 = v34;
          v37[1] = v35;
          v37[2] = 0.0;
          uint64_t v38 = v37 + 6;
          *((void *)v37 + 2) = v25;
        }
        long long v50 = &v136;
        unint64_t v12 = v133;
        *((void *)v9 + 10) = v38;
        uint64_t v51 = v136;
        double v52 = &v136;
        if (v136)
        {
          while (1)
          {
            while (1)
            {
              long long v50 = (void **)v51;
              unsigned int v53 = *((_DWORD *)v51 + 7);
              if (v28 >= v53) {
                break;
              }
              uint64_t v51 = *v50;
              double v52 = v50;
              if (!*v50) {
                goto LABEL_78;
              }
            }
            if (v53 >= v28) {
              break;
            }
            uint64_t v51 = v50[1];
            if (!v51)
            {
              double v52 = v50 + 1;
              goto LABEL_78;
            }
          }
        }
        else
        {
LABEL_78:
          id v54 = operator new(0x20uLL);
          *((_DWORD *)v54 + 7) = v28;
          void *v54 = 0;
          v54[1] = 0;
          v54[2] = v50;
          *double v52 = v54;
          if (*v135)
          {
            int v135 = (void *)*v135;
            id v54 = (void *)*v52;
          }
          int v55 = v136;
          BOOL v18 = v54 == v136;
          *((unsigned char *)v54 + 24) = v54 == v136;
          if (!v18)
          {
            do
            {
              uint64_t v56 = v54[2];
              if (*(unsigned char *)(v56 + 24)) {
                break;
              }
              double v57 = *(void **)(v56 + 16);
              uint64_t v58 = *v57;
              if (*v57 == v56)
              {
                uint64_t v61 = v57[1];
                if (!v61 || (int v62 = *(unsigned __int8 *)(v61 + 24), v59 = (unsigned char *)(v61 + 24), v62))
                {
                  if (*(void **)v56 == v54)
                  {
                    uint64_t v63 = (uint64_t *)v54[2];
                  }
                  else
                  {
                    uint64_t v63 = *(uint64_t **)(v56 + 8);
                    uint64_t v64 = *v63;
                    *(void *)(v56 + 8) = *v63;
                    if (v64)
                    {
                      *(void *)(v64 + 16) = v56;
                      double v57 = *(void **)(v56 + 16);
                    }
                    v63[2] = (uint64_t)v57;
                    *(void *)(*(void *)(v56 + 16) + 8 * (**(void **)(v56 + 16) != v56)) = v63;
                    *uint64_t v63 = v56;
                    *(void *)(v56 + 16) = v63;
                    double v57 = (void *)v63[2];
                    uint64_t v56 = *v57;
                  }
                  *((unsigned char *)v63 + 24) = 1;
                  *((unsigned char *)v57 + 24) = 0;
                  uint64_t v67 = *(void *)(v56 + 8);
                  *double v57 = v67;
                  if (v67) {
                    *(void *)(v67 + 16) = v57;
                  }
                  *(void *)(v56 + 16) = v57[2];
                  *(void *)(v57[2] + 8 * (*(void *)v57[2] != (void)v57)) = v56;
                  *(void *)(v56 + 8) = v57;
                  goto LABEL_26;
                }
              }
              else if (!v58 || (v60 = *(unsigned __int8 *)(v58 + 24), BOOL v59 = (unsigned char *)(v58 + 24), v60))
              {
                if (*(void **)v56 == v54)
                {
                  uint64_t v65 = v54[1];
                  *(void *)uint64_t v56 = v65;
                  if (v65)
                  {
                    *(void *)(v65 + 16) = v56;
                    double v57 = *(void **)(v56 + 16);
                  }
                  v54[2] = v57;
                  *(void *)(*(void *)(v56 + 16) + 8 * (**(void **)(v56 + 16) != v56)) = v54;
                  v54[1] = v56;
                  *(void *)(v56 + 16) = v54;
                  double v57 = (void *)v54[2];
                }
                else
                {
                  id v54 = (void *)v54[2];
                }
                *((unsigned char *)v54 + 24) = 1;
                *((unsigned char *)v57 + 24) = 0;
                uint64_t v56 = v57[1];
                unint64_t v66 = *(void **)v56;
                v57[1] = *(void *)v56;
                if (v66) {
                  v66[2] = v57;
                }
                *(void *)(v56 + 16) = v57[2];
                *(void *)(v57[2] + 8 * (*(void *)v57[2] != (void)v57)) = v56;
                *(void *)uint64_t v56 = v57;
LABEL_26:
                void v57[2] = v56;
                break;
              }
              *(unsigned char *)(v56 + 24) = 1;
              id v54 = v57;
              *((unsigned char *)v57 + 24) = v57 == v55;
              unsigned char *v59 = 1;
            }
            while (v57 != v55);
          }
          ++v137;
        }
      }
LABEL_28:
      if (++v14 != v15) {
        continue;
      }
      break;
    }
LABEL_19:
    uint64_t v16 = (void *)v11[1];
    if (v16)
    {
      do
      {
        uint64_t v17 = v16;
        uint64_t v16 = (void *)*v16;
      }
      while (v16);
    }
    else
    {
      do
      {
        uint64_t v17 = (void *)v11[2];
        BOOL v18 = *v17 == (void)v11;
        uint64_t v11 = v17;
      }
      while (!v18);
    }
    uint64_t v11 = v17;
    if (v17 != v131) {
      continue;
    }
    break;
  }
  unint64_t v10 = (void *)*((void *)v9 + 12);
LABEL_108:
  uint64_t v68 = (void *)v10[6];
  unint64_t v132 = v10 + 7;
  if (v68 != v10 + 7)
  {
    while (1)
    {
      uint64_t v72 = (void *)v68[4];
      uint64_t v73 = (void *)v72[10];
      uint64_t v74 = (void *)v72[11];
      if (v73 != v74)
      {
        if (v139) {
          break;
        }
      }
LABEL_115:
      uint64_t v75 = (void *)v68[1];
      if (v75)
      {
        do
        {
          uint64_t v76 = v75;
          uint64_t v75 = (void *)*v75;
        }
        while (v75);
      }
      else
      {
        do
        {
          uint64_t v76 = (void *)v68[2];
          BOOL v18 = *v76 == (void)v68;
          uint64_t v68 = v76;
        }
        while (!v18);
      }
      uint64_t v68 = v76;
      if (v76 == v132) {
        goto LABEL_109;
      }
    }
LABEL_125:
    if (*v73) {
      int v77 = (unsigned int *)(*v73 + 8);
    }
    else {
      int v77 = 0;
    }
    unint64_t v78 = v139;
    if (!v139) {
      goto LABEL_124;
    }
    unint64_t v79 = *(void *)(*(void *)(*(void *)v77 + 16) + 40);
    while (1)
    {
      unint64_t v80 = v78[4];
      if (v79 >= v80)
      {
        if (v80 >= v79)
        {
          unint64_t v81 = v77[10];
          uint64_t v82 = v72[13];
          if (v81 >= (v72[14] - v82) >> 3) {
            unint64_t v83 = 0;
          }
          else {
            unint64_t v83 = *(void *)(v82 + 8 * v81);
          }
          long long v84 = (int8x8_t *)*((void *)v9 + 12);
          long long v85 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(&v84[21], v83);
          if (v85)
          {
            unsigned int v86 = *((_DWORD *)v85 + 6);
            if (!v83) {
              goto LABEL_124;
            }
          }
          else
          {
            unsigned int v86 = 0;
            if (!v83) {
              goto LABEL_124;
            }
          }
          for (uint64_t j = v136; j; uint64_t j = (void *)*j)
          {
            unsigned int v97 = *((_DWORD *)j + 7);
            if (v86 >= v97)
            {
              if (v97 >= v86) {
                goto LABEL_124;
              }
              ++j;
            }
          }
          if (!v12) {
            unint64_t v12 = v83;
          }
          int v88 = (float *)md::TransitJunction::normalForLineSegment(v84, v83);
          if (!v88) {
            goto LABEL_124;
          }
          unint64_t v134 = v12;
          float v89 = *v88;
          float v90 = v88[1];
          float v91 = sqrtf((float)(v89 * v89) + (float)(v90 * v90));
          float v92 = 0.0;
          float v93 = 0.0;
          if (v91 > 0.01)
          {
            float v93 = (float)-v89 / v91;
            float v92 = (float)-v90 / v91;
          }
          double v95 = (float *)*((void *)v9 + 10);
          unint64_t v94 = *((void *)v9 + 11);
          if ((unint64_t)v95 >= v94)
          {
            double v98 = (float *)*((void *)v9 + 9);
            unint64_t v99 = 0xAAAAAAAAAAAAAAABLL * (((char *)v95 - (char *)v98) >> 3) + 1;
            if (v99 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            unint64_t v100 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v94 - (void)v98) >> 3);
            if (2 * v100 > v99) {
              unint64_t v99 = 2 * v100;
            }
            if (v100 >= 0x555555555555555) {
              unint64_t v101 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v101 = v99;
            }
            if (v101 <= 0xAAAAAAAAAAAAAAALL)
            {
              long double v102 = (char *)operator new(24 * v101);
              long double v103 = (float *)&v102[8 * (((char *)v95 - (char *)v98) >> 3)];
              float *v103 = v93;
              v103[1] = v92;
              v103[2] = 0.0;
              *((void *)v103 + 2) = v83;
              if (v95 == v98)
              {
                double v105 = &v102[8 * (((char *)v95 - (char *)v98) >> 3)];
              }
              else
              {
                long double v104 = &v102[8 * (((char *)v95 - (char *)v98) >> 3)];
                do
                {
                  double v105 = v104 - 24;
                  long long v106 = *(_OWORD *)(v95 - 6);
                  *((void *)v104 - 1) = *((void *)v95 - 1);
                  *(_OWORD *)(v104 - 24) = v106;
                  v95 -= 6;
                  v104 -= 24;
                }
                while (v95 != v98);
              }
              double v107 = &v102[24 * v101];
              unint64_t v96 = v103 + 6;
              unint64_t v9 = this;
              *((void *)this + 9) = v105;
              *((void *)this + 10) = v103 + 6;
              *((void *)this + 11) = v107;
              if (v98) {
                operator delete(v98);
              }
              goto LABEL_167;
            }
LABEL_217:
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          *double v95 = v93;
          v95[1] = v92;
          v95[2] = 0.0;
          unint64_t v96 = v95 + 6;
          *((void *)v95 + 2) = v83;
LABEL_167:
          __double2 v108 = &v136;
          unint64_t v12 = v134;
          *((void *)v9 + 10) = v96;
          double v109 = v136;
          __double2 v110 = &v136;
          if (v136)
          {
            while (1)
            {
              while (1)
              {
                __double2 v108 = (void **)v109;
                unsigned int v111 = *((_DWORD *)v109 + 7);
                if (v86 >= v111) {
                  break;
                }
                double v109 = *v108;
                __double2 v110 = v108;
                if (!*v108) {
                  goto LABEL_174;
                }
              }
              if (v111 >= v86) {
                break;
              }
              double v109 = v108[1];
              if (!v109)
              {
                __double2 v110 = v108 + 1;
                goto LABEL_174;
              }
            }
          }
          else
          {
LABEL_174:
            double v112 = operator new(0x20uLL);
            *((_DWORD *)v112 + 7) = v86;
            *double v112 = 0;
            v112[1] = 0;
            v112[2] = v108;
            *__double2 v110 = v112;
            if (*v135)
            {
              int v135 = (void *)*v135;
              double v112 = (void *)*v110;
            }
            double v113 = v136;
            BOOL v18 = v112 == v136;
            *((unsigned char *)v112 + 24) = v112 == v136;
            if (!v18)
            {
              do
              {
                uint64_t v114 = v112[2];
                if (*(unsigned char *)(v114 + 24)) {
                  break;
                }
                double v115 = *(void **)(v114 + 16);
                uint64_t v116 = *v115;
                if (*v115 == v114)
                {
                  uint64_t v119 = v115[1];
                  if (!v119 || (v120 = *(unsigned __int8 *)(v119 + 24), double v117 = (unsigned char *)(v119 + 24), v120))
                  {
                    if (*(void **)v114 == v112)
                    {
                      float v121 = (uint64_t *)v112[2];
                    }
                    else
                    {
                      float v121 = *(uint64_t **)(v114 + 8);
                      uint64_t v122 = *v121;
                      *(void *)(v114 + 8) = *v121;
                      if (v122)
                      {
                        *(void *)(v122 + 16) = v114;
                        double v115 = *(void **)(v114 + 16);
                      }
                      v121[2] = (uint64_t)v115;
                      *(void *)(*(void *)(v114 + 16) + 8 * (**(void **)(v114 + 16) != v114)) = v121;
                      *float v121 = v114;
                      *(void *)(v114 + 16) = v121;
                      double v115 = (void *)v121[2];
                      uint64_t v114 = *v115;
                    }
                    *((unsigned char *)v121 + 24) = 1;
                    *((unsigned char *)v115 + 24) = 0;
                    uint64_t v125 = *(void *)(v114 + 8);
                    *double v115 = v125;
                    if (v125) {
                      *(void *)(v125 + 16) = v115;
                    }
                    *(void *)(v114 + 16) = v115[2];
                    *(void *)(v115[2] + 8 * (*(void *)v115[2] != (void)v115)) = v114;
                    *(void *)(v114 + 8) = v115;
                    goto LABEL_122;
                  }
                }
                else if (!v116 || (v118 = *(unsigned __int8 *)(v116 + 24), double v117 = (unsigned char *)(v116 + 24), v118))
                {
                  if (*(void **)v114 == v112)
                  {
                    uint64_t v123 = v112[1];
                    *(void *)uint64_t v114 = v123;
                    if (v123)
                    {
                      *(void *)(v123 + 16) = v114;
                      double v115 = *(void **)(v114 + 16);
                    }
                    v112[2] = v115;
                    *(void *)(*(void *)(v114 + 16) + 8 * (**(void **)(v114 + 16) != v114)) = v112;
                    v112[1] = v114;
                    *(void *)(v114 + 16) = v112;
                    double v115 = (void *)v112[2];
                  }
                  else
                  {
                    double v112 = (void *)v112[2];
                  }
                  *((unsigned char *)v112 + 24) = 1;
                  *((unsigned char *)v115 + 24) = 0;
                  uint64_t v114 = v115[1];
                  float v124 = *(void **)v114;
                  v115[1] = *(void *)v114;
                  if (v124) {
                    v124[2] = v115;
                  }
                  *(void *)(v114 + 16) = v115[2];
                  *(void *)(v115[2] + 8 * (*(void *)v115[2] != (void)v115)) = v114;
                  *(void *)uint64_t v114 = v115;
LABEL_122:
                  void v115[2] = v114;
                  break;
                }
                *(unsigned char *)(v114 + 24) = 1;
                double v112 = v115;
                *((unsigned char *)v115 + 24) = v115 == v113;
                *double v117 = 1;
              }
              while (v115 != v113);
            }
            ++v137;
          }
LABEL_124:
          if (++v73 == v74) {
            goto LABEL_115;
          }
          goto LABEL_125;
        }
        ++v78;
      }
      unint64_t v78 = (uint64_t *)*v78;
      if (!v78) {
        goto LABEL_124;
      }
    }
  }
LABEL_109:
  uint64_t v69 = (void *)*((void *)v9 + 9);
  int64_t v70 = (void *)*((void *)v9 + 10);
  if (v69 == v70)
  {
    unint64_t v71 = *((void *)v9 + 11);
    if ((unint64_t)v69 >= v71)
    {
      unint64_t v126 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v71 - (void)v69) >> 3);
      uint64_t v127 = 2 * v126;
      if (2 * v126 <= 1) {
        uint64_t v127 = 1;
      }
      if (v126 >= 0x555555555555555) {
        unint64_t v128 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v128 = v127;
      }
      if (v128 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_217;
      }
      unint64_t v129 = operator new(24 * v128);
      *(void *)unint64_t v129 = 0;
      v129[2] = 0;
      *((void *)v129 + 2) = v12;
      int64_t v70 = v129 + 6;
      *((void *)v9 + 9) = v129;
      *((void *)v9 + 10) = v129 + 6;
      *((void *)v9 + 11) = &v129[6 * v128];
      if (v69) {
        operator delete(v69);
      }
    }
    else
    {
      void *v69 = 0;
      *((_DWORD *)v69 + 2) = 0;
      int64_t v70 = v69 + 3;
      v69[2] = v12;
    }
    *((void *)v9 + 10) = v70;
    uint64_t v69 = (void *)*((void *)v9 + 9);
  }
  *((void *)v9 + 14) = 0;
  if (v69 != v70)
  {
    while (!*v69)
    {
      v69 += 3;
      if (v69 == v70) {
        goto LABEL_216;
      }
    }
    *((_DWORD *)v9 + 28) = *(_DWORD *)v69;
    *((_DWORD *)v9 + 29) = *((_DWORD *)v69 + 1);
  }
LABEL_216:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v136);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v139);
}

void sub_1A23D7D70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19)
{
}

BOOL md::TransitConnectedNode::updateExternalIcon(md::TransitConnectedNode *this, md::TransitNodeExternalIcon *a2)
{
  if (*((unsigned char *)this + 64) != 1) {
    return 0;
  }
  int v4 = *((unsigned __int8 *)a2 + 260);
  if (v4 != *((unsigned __int8 *)this + 60)) {
    return 1;
  }
  int v5 = *((_DWORD *)this + 31);
  if (*((_DWORD *)a2 + 59) == v5) {
    return 0;
  }
  *((_DWORD *)a2 + 59) = v5;
  switch(v4)
  {
    case 2:
      if (*((_DWORD *)this + 33) == v5)
      {
        float v18 = *((float *)this + 30);
      }
      else
      {
        *((_DWORD *)this + 33) = v5;
        float v20 = (void *)*((void *)this + 12);
        unint64_t v21 = (void *)v20[3];
        float v18 = 0.0;
        if (v21 != v20 + 4)
        {
          do
          {
            float v31 = (void *)v21[1];
            float v32 = v21;
            if (v31)
            {
              do
              {
                float v33 = v31;
                float v31 = (void *)*v31;
              }
              while (v31);
            }
            else
            {
              do
              {
                float v33 = (void *)v32[2];
                BOOL v34 = *v33 == (void)v32;
                float v32 = v33;
              }
              while (!v34);
            }
            float v18 = fmaxf(v18, *(float *)(v21[4] + 152));
            unint64_t v21 = v33;
          }
          while (v33 != v20 + 4);
        }
        unint64_t v22 = (void *)v20[6];
        unint64_t v23 = v20 + 7;
        if (v22 != v23)
        {
          do
          {
            float v35 = (void *)v22[1];
            unint64_t v36 = v22;
            if (v35)
            {
              do
              {
                int v37 = v35;
                float v35 = (void *)*v35;
              }
              while (v35);
            }
            else
            {
              do
              {
                int v37 = (void *)v36[2];
                BOOL v34 = *v37 == (void)v36;
                unint64_t v36 = v37;
              }
              while (!v34);
            }
            float v18 = fmaxf(v18, *(float *)(v22[4] + 152));
            unint64_t v22 = v37;
          }
          while (v37 != v23);
        }
        *((float *)this + 30) = v18;
      }
      BOOL result = v18 < 2.0;
      float v24 = *((float *)this + 14) * v18;
      *((_DWORD *)a2 + 63) = (int)v24;
      int v25 = (int)v24 / 2;
      int v26 = *((_DWORD *)a2 + 62);
      int v27 = -(v26 + v25);
      float v28 = (float)((int)v24 / -2);
      *((float *)a2 + 32) = (float)v27;
      *((float *)a2 + 34) = v28;
      *((float *)a2 + 36) = v28;
      *((float *)a2 + 38) = (float)v27;
      float v29 = v28 + truncf(v24);
      *((float *)a2 + 40) = v29;
      float v30 = v29 + (float)v26;
      *((float *)a2 + 42) = v30;
      *((float *)a2 + 44) = v30;
      *((float *)a2 + 46) = v29;
      *((unsigned char *)a2 + 64) = 1;
      *((float *)a2 + 11) = (float)(v26 + v25);
      break;
    case 1:
      if (!*((unsigned char *)this + 136)) {
        return 0;
      }
      if (*((_DWORD *)this + 33) == v5)
      {
        float v19 = *((float *)this + 30);
      }
      else
      {
        *((_DWORD *)this + 33) = v5;
        uint64_t v38 = (void *)*((void *)this + 12);
        unsigned int v39 = (void *)v38[3];
        float v19 = 0.0;
        if (v39 != v38 + 4)
        {
          do
          {
            unint64_t v42 = (void *)v39[1];
            unint64_t v43 = v39;
            if (v42)
            {
              do
              {
                unint64_t v44 = v42;
                unint64_t v42 = (void *)*v42;
              }
              while (v42);
            }
            else
            {
              do
              {
                unint64_t v44 = (void *)v43[2];
                BOOL v34 = *v44 == (void)v43;
                unint64_t v43 = v44;
              }
              while (!v34);
            }
            float v19 = fmaxf(v19, *(float *)(v39[4] + 152));
            unsigned int v39 = v44;
          }
          while (v44 != v38 + 4);
        }
        double v40 = (void *)v38[6];
        unint64_t v41 = v38 + 7;
        if (v40 != v41)
        {
          do
          {
            unint64_t v45 = (void *)v40[1];
            int64x2_t v46 = v40;
            if (v45)
            {
              do
              {
                double v47 = v45;
                unint64_t v45 = (void *)*v45;
              }
              while (v45);
            }
            else
            {
              do
              {
                double v47 = (void *)v46[2];
                BOOL v34 = *v47 == (void)v46;
                int64x2_t v46 = v47;
              }
              while (!v34);
            }
            float v19 = fmaxf(v19, *(float *)(v40[4] + 152));
            double v40 = v47;
          }
          while (v47 != v41);
        }
        *((float *)this + 30) = v19;
      }
      return v19 > 4.0;
    case 0:
      if (*((_DWORD *)a2 + 60) == *((_DWORD *)this + 32))
      {
        uint64_t v6 = *((void *)this + 9);
        uint64_t v7 = *((void *)this + 10);
        unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - v6) >> 3);
        unint64_t v9 = (float32x2_t *)*((void *)a2 + 13);
        if (v8 == 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)a2 + 14) - (void)v9) >> 2))
        {
          if (v7 != v6)
          {
            unint64_t v10 = 0;
            uint64_t v11 = *((void *)this + 12);
            unint64_t v12 = (unint64_t *)(v6 + 16);
            do
            {
              unint64_t v15 = *v12;
              float v16 = 0.0;
              if (*v12 && v11 && !*(unsigned char *)(v15 + 55))
              {
                uint64_t v17 = (float *)std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>((void *)(v11 + 168), v15);
                if (v17) {
                  float v16 = v17[7];
                }
              }
              *((float *)v12 - 2) = v16;
              float v14 = *((float *)this + 14) * v16;
              v9[1].f32[1] = v14;
              *unint64_t v9 = vmul_n_f32((float32x2_t)*(v12 - 2), v14);
              unint64_t v9 = (float32x2_t *)((char *)v9 + 20);
              ++v10;
              v12 += 3;
            }
            while (v10 < v8);
          }
          md::TransitNodeExternalIcon::updateRadius((uint64_t)a2);
          return 0;
        }
      }
      return 1;
    default:
      return 0;
  }
  return result;
}

uint64_t md::TransitConnectedNode::initializeExternalIcon(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  if (*(unsigned char *)(*(void *)(a1 + 8) + 320))
  {
    if (*(unsigned char *)(a1 + 136))
    {
      int v8 = *(_DWORD *)(a1 + 124);
      if (*(_DWORD *)(a1 + 132) == v8)
      {
        float v9 = *(float *)(a1 + 120);
      }
      else
      {
        *(_DWORD *)(a1 + 132) = v8;
        uint64_t v11 = *(void **)(a1 + 96);
        unint64_t v12 = (void *)v11[3];
        float v9 = 0.0;
        if (v12 != v11 + 4)
        {
          do
          {
            double v40 = (void *)v12[1];
            unint64_t v41 = v12;
            if (v40)
            {
              do
              {
                unint64_t v42 = v40;
                double v40 = (void *)*v40;
              }
              while (v40);
            }
            else
            {
              do
              {
                unint64_t v42 = (void *)v41[2];
                BOOL v43 = *v42 == (void)v41;
                unint64_t v41 = v42;
              }
              while (!v43);
            }
            float v9 = fmaxf(v9, *(float *)(v12[4] + 152));
            unint64_t v12 = v42;
          }
          while (v42 != v11 + 4);
        }
        unsigned __int32 v13 = (void *)v11[6];
        float v14 = v11 + 7;
        if (v13 != v14)
        {
          do
          {
            unint64_t v44 = (void *)v13[1];
            unint64_t v45 = v13;
            if (v44)
            {
              do
              {
                int64x2_t v46 = v44;
                unint64_t v44 = (void *)*v44;
              }
              while (v44);
            }
            else
            {
              do
              {
                int64x2_t v46 = (void *)v45[2];
                BOOL v43 = *v46 == (void)v45;
                unint64_t v45 = v46;
              }
              while (!v43);
            }
            float v9 = fmaxf(v9, *(float *)(v13[4] + 152));
            unsigned __int32 v13 = v46;
          }
          while (v46 != v14);
        }
        *(float *)(a1 + 120) = v9;
      }
      if (v9 < 3.0) {
        int v10 = 1;
      }
      else {
        int v10 = 2;
      }
    }
    else
    {
      int v10 = 1;
    }
    *(unsigned char *)(a1 + 60) = v10;
  }
  else
  {
    int v10 = *(unsigned __int8 *)(a1 + 60);
  }
  *(unsigned char *)(a2 + 260) = v10;
  *(unsigned char *)(a2 + 70) = v10 != 2;
  *(_DWORD *)(a2 + 240) = *(_DWORD *)(a1 + 128);
  uint64_t result = md::TransitNodeTextureAtlas::infoForIcon(a4, (char)v10, a3[1], *a3, 0);
  if (result)
  {
    float v16 = (void *)(result + 8);
    if (*(unsigned char *)(a1 + 60) == 2)
    {
      int v17 = *(_DWORD *)(result + 32);
      int v18 = *(_DWORD *)(result + 8);
      BOOL v19 = __OFSUB__(v18, v17);
      int v20 = v18 - v17;
      if (v20 < 0 != v19) {
        ++v20;
      }
      int v21 = v20 >> 1;
      __int8 v22 = *(unsigned char *)result;
      char v23 = *(unsigned char *)(result + 4);
      *(unsigned char *)(a2 + 192) = *(unsigned char *)result;
      *(unsigned char *)(a2 + 193) = v23;
      char v24 = v21 + v22;
      *(unsigned char *)(a2 + 194) = v21 + v22;
      *(unsigned char *)(a2 + 195) = v23;
      char v25 = *(unsigned char *)(result + 12) + v23;
      *(unsigned char *)(a2 + 196) = v21 + v22;
      *(unsigned char *)(a2 + 197) = v25;
      char v26 = *(unsigned char *)(result + 12) + v23;
      *(unsigned char *)(a2 + 198) = v22;
      *(unsigned char *)(a2 + 199) = v26;
      char v27 = v21 + v17;
      char v28 = v22 + v27;
      *(unsigned char *)(a2 + 200) = v28;
      *(unsigned char *)(a2 + 201) = v23;
      char v29 = v24 + v27;
      *(unsigned char *)(a2 + 202) = v29;
      *(unsigned char *)(a2 + 203) = v23;
      *(unsigned char *)(a2 + 204) = v29;
      *(unsigned char *)(a2 + 205) = v25;
      *(unsigned char *)(a2 + 206) = v28;
      *(unsigned char *)(a2 + 207) = v26;
      int v30 = *(_DWORD *)(result + 12);
      if (v30 >= 0) {
        int v31 = *(_DWORD *)(result + 12);
      }
      else {
        int v31 = v30 + 1;
      }
      int v32 = v31 >> 1;
      float v33 = (float)-v32;
      float v34 = (float)(v30 - v32);
      *(float *)(a2 + 132) = v33;
      *(float *)(a2 + 140) = v33;
      *(float *)(a2 + 148) = v34;
      *(float *)(a2 + 156) = v34;
      *(float *)(a2 + 164) = v33;
      *(float *)(a2 + 172) = v33;
      *(float *)(a2 + 180) = v34;
      *(float *)(a2 + 188) = v34;
      *(_DWORD *)(a2 + 248) = v21;
      float v35 = *(float *)(a2 + 244);
      if (v35 != 1.0)
      {
        *(_DWORD *)(a2 + 248) = (int)(float)(v35 * (float)v21);
        float v36 = v35 * v33;
        *(float *)(a2 + 132) = v36;
        *(float *)(a2 + 140) = v36;
        float v37 = v35 * v34;
        *(float *)(a2 + 148) = v37;
        *(float *)(a2 + 156) = v37;
        *(float *)(a2 + 164) = v36;
        *(float *)(a2 + 172) = v36;
        *(float *)(a2 + 180) = v37;
        *(float *)(a2 + 188) = v37;
      }
      uint64_t v38 = md::TransitNodeTextureAtlas::infoForIcon(a4, *(char *)(a1 + 60), a3[1], *a3, 1);
      if (v38 && *v16 == *(void *)(v38 + 8))
      {
        *(unsigned char *)(a2 + 262) = 1;
        *(_DWORD *)(a2 + 228) = *(_DWORD *)(v38 + 16);
        *(_DWORD *)(a2 + 232) = *(_DWORD *)(v38 + 20);
        char v39 = *(unsigned char *)(v38 + 4) - *(unsigned char *)(a2 + 193);
        *(unsigned char *)(a2 + 208) = *(unsigned char *)v38 - *(unsigned char *)(a2 + 192);
        *(unsigned char *)(a2 + 209) = v39;
      }
    }
    else
    {
      md::TransitNodeExternalIcon::setDotTextureRect((float32x4_t *)a2, (__int8 *)result, (uint64_t)v16, (float *)(result + 24));
    }
    int v47 = *(unsigned __int8 *)(a1 + 60);
    if (*(unsigned char *)(a1 + 60))
    {
      if (v47 != 1)
      {
        if (v47 != 2) {
          return 1;
        }
        *(_DWORD *)(a2 + 212) = *(_DWORD *)(a1 + 104);
        *(_DWORD *)(a2 + 216) = *(_DWORD *)(a1 + 108);
LABEL_45:
        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, a2);
        return 1;
      }
      uint64_t v53 = *(void *)(a2 + 104);
      unint64_t v54 = 0xCCCCCCCCCCCCCCCDLL * ((*(void *)(a2 + 112) - v53) >> 2);
      if (*(void *)(a2 + 112) == v53)
      {
        std::vector<md::TransitNodeExternalIcon::DotInfo>::__append((char **)(a2 + 104), 1 - v54);
        uint64_t v53 = *(void *)(a2 + 104);
      }
      else if (v54 >= 2)
      {
        *(void *)(a2 + 112) = v53 + 20;
      }
      *(_DWORD *)(v53 + 8) = -1;
      if (*(unsigned char *)(a2 + 260) == 2)
      {
        float v55 = (float)(*(_DWORD *)(a2 + 248) + *(_DWORD *)(a2 + 252) / 2);
      }
      else
      {
        uint64_t v56 = *(void *)(a2 + 104);
        uint64_t v57 = *(void *)(a2 + 112);
        if (v56 == v57)
        {
          float v55 = (float)(*(_DWORD *)(a2 + 256) / 2);
          float v72 = 0.0;
        }
        else
        {
          unint64_t v58 = v57 - v56 - 20;
          if (v58 > 0x9F)
          {
            unint64_t v73 = v58 / 0x14 + 1;
            uint64_t v74 = v73 & 7;
            if ((v73 & 7) == 0) {
              uint64_t v74 = 8;
            }
            unint64_t v75 = v73 - v74;
            uint64_t v76 = 20 * v75;
            float32x4_t v77 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
            unint64_t v78 = (__int32 *)(v56 + 92);
            v79.i64[0] = 0x80000000800000;
            v79.i64[1] = 0x80000000800000;
            float32x4_t v80 = v77;
            v81.i64[0] = 0x80000000800000;
            v81.i64[1] = 0x80000000800000;
            do
            {
              uint64_t v82 = v78 + 5;
              unint64_t v83 = v78 + 10;
              v84.i32[0] = *(v78 - 20);
              v84.i32[1] = *(v78 - 15);
              long long v85 = v78 + 15;
              v84.i32[2] = *(v78 - 10);
              v84.i32[3] = *(v78 - 5);
              __int32 v86 = *v78;
              v78 += 40;
              v87.i32[0] = v86;
              v87.i32[1] = *v82;
              v87.i32[2] = *v83;
              v87.i32[3] = *v85;
              float32x4_t v79 = vmaxnmq_f32(v79, v84);
              float32x4_t v81 = vmaxnmq_f32(v81, v87);
              float32x4_t v77 = vminnmq_f32(v84, v77);
              float32x4_t v80 = vminnmq_f32(v87, v80);
              v75 -= 8;
            }
            while (v75);
            v56 += v76;
            float v59 = vmaxnmvq_f32(vmaxnmq_f32(v79, v81));
            float v60 = vminnmvq_f32(vminnmq_f32(v77, v80));
          }
          else
          {
            float v59 = -3.4028e38;
            float v60 = 3.4028e38;
          }
          do
          {
            float v88 = *(float *)(v56 + 12);
            float v59 = fmaxf(v59, v88);
            float v60 = fminf(v88, v60);
            v56 += 20;
          }
          while (v56 != v57);
          float v72 = (float)(v60 + v59) * 0.5;
          float v55 = (float)(v59 - v72) + (float)(*(_DWORD *)(a2 + 256) / 2);
        }
        *(float32x2_t *)(a2 + 48) = vmul_n_f32(*(float32x2_t *)(a2 + 220), v72);
      }
      uint64_t result = 1;
      *(unsigned char *)(a2 + 64) = 1;
      *(float *)(a2 + 44) = v55;
    }
    else
    {
      uint64_t v48 = *(void *)(a1 + 80) - *(void *)(a1 + 72);
      if (v48)
      {
        unint64_t v49 = v48 / 24;
        uint64_t v51 = (void *)(a2 + 104);
        uint64_t v50 = *(void *)(a2 + 104);
        *(_DWORD *)(a2 + 220) = *(_DWORD *)(a1 + 112);
        *(_DWORD *)(a2 + 224) = *(_DWORD *)(a1 + 116);
        unint64_t v52 = 0xCCCCCCCCCCCCCCCDLL * ((*(void *)(a2 + 112) - v50) >> 2);
        if (v49 <= v52)
        {
          if (v49 < v52) {
            *(void *)(a2 + 112) = v50 + 20 * v49;
          }
        }
        else
        {
          std::vector<md::TransitNodeExternalIcon::DotInfo>::__append((char **)(a2 + 104), v49 - v52);
        }
        uint64_t v61 = 0;
        if (v49 <= 1) {
          uint64_t v62 = 1;
        }
        else {
          uint64_t v62 = v49;
        }
        uint64_t v63 = 16;
        float32x4_t v89 = (float32x4_t)vdupq_n_s32(0x437F0000u);
        do
        {
          uint64_t v64 = *(unsigned __int8 **)(*(void *)(a1 + 72) + v63);
          if (v64)
          {
            uint64_t v65 = *(void *)v64;
            unsigned int v66 = v64[52];
            uint64_t v67 = *(void *)(*(void *)v64 + 64);
            md::TransitLine::updateFeatureQueryForMergeTypeIfNecessary(*(uint64_t **)v64, v66);
            uint64_t v68 = v67 + 184 * v66;
            int v70 = *(unsigned __int8 *)(v68 + 177);
            uint64_t v69 = (unsigned char *)(v68 + 177);
            if (v70)
            {
              md::TransitLine::_resolveStyle(v65, *(_DWORD *)(v65 + 60), *(void *)(v67 + 184 * v66), *(std::__shared_weak_count **)(v67 + 184 * v66 + 8), v67 + 184 * v66 + 16);
              unsigned char *v69 = 0;
            }
            int16x8_t v71 = (int16x8_t)vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)(v67 + 184 * v66 + 32), v89));
            *(int16x4_t *)v71.i8 = vmovn_s32((int32x4_t)v71);
            *(_DWORD *)(*v51 + v61 + 8) = vmovn_s16(v71).u32[0];
            LOBYTE(v64) = *(unsigned char *)(**(void **)(*(void *)(a1 + 72) + v63) + 88);
          }
          else
          {
            *(_DWORD *)(*v51 + v61 + 8) = -13224394;
          }
          *(unsigned char *)(*v51 + v61 + 16) = (_BYTE)v64;
          v61 += 20;
          v63 += 24;
          --v62;
        }
        while (v62);
        goto LABEL_45;
      }
      return 0;
    }
  }
  return result;
}

uint64_t md::TransitConnectedNode::debugString@<X0>(md::TransitConnectedNode *this@<X0>, int a2@<W1>, unsigned char *a3@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v60);
  md::TransitNode::debugString(this, a2, __p);
  if ((v59 & 0x80u) == 0) {
    uint64_t v6 = __p;
  }
  else {
    uint64_t v6 = (void **)__p[0];
  }
  if ((v59 & 0x80u) == 0) {
    uint64_t v7 = v59;
  }
  else {
    uint64_t v7 = (uint64_t)__p[1];
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v60, (uint64_t)v6, v7);
  long long __dst = a3;
  if ((char)v59 < 0) {
    operator delete(__p[0]);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v60, (uint64_t)" dots:", 6);
  std::ostream::operator<<();
  uint64_t v8 = *((void *)this + 12);
  if (v8 && a2)
  {
    float v9 = [MEMORY[0x1E4F28E78] stringWithFormat:@"\n <junction>"];
    int v10 = *(void **)(v8 + 24);
    uint64_t v53 = v8;
    float v55 = (void *)(v8 + 32);
    if (v10 == (void *)(v8 + 32))
    {
      uint64_t v11 = 0;
    }
    else
    {
      uint64_t v11 = 0;
      do
      {
        uint64_t v12 = v10[4];
        int v56 = v11;
        objc_msgSend(v9, "appendFormat:", @"\n   IncomingLink[%i]", v11);
        uint64_t v13 = *(void *)(v12 + 80);
        uint64_t v14 = *(void *)(v12 + 88);
        if (v13 != v14)
        {
          uint64_t v15 = 0;
          do
          {
            float v16 = *(md::TransitLine **)(*(void *)v13 + 8);
            uint64_t v17 = *(void *)(*((void *)v16 + 2) + 40);
            uint64_t v18 = md::TransitLine::debugSystemName(v16);
            uint64_t v19 = *(void *)v13 + 8;
            uint64_t v20 = *(void *)(*(void *)(*(void *)v19 + 16) + 16);
            if (!*(void *)v13) {
              uint64_t v19 = 0;
            }
            unsigned int ShouldDrawToEndPoint = geo::codec::transitLinkGetShouldDrawToEndPoint(**(void **)(v19 + 8), *(unsigned int *)(v19 + 36));
            if (*(void *)v13) {
              uint64_t v22 = *(void *)v13 + 8;
            }
            else {
              uint64_t v22 = 0;
            }
            [v9 appendFormat:@"\n    line[uid:%llu,%i,%s,%s] draw[TO:%i, from:%i]", v17, v15, v18, v20, ShouldDrawToEndPoint, geo::codec::transitLinkGetShouldDrawFromEndPoint(**(void ***)(v22 + 8), *(unsigned int *)(v22 + 36))];
            uint64_t v15 = (v15 + 1);
            v13 += 8;
          }
          while (v13 != v14);
        }
        char v23 = (void *)v10[1];
        if (v23)
        {
          do
          {
            char v24 = v23;
            char v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            char v24 = (void *)v10[2];
            BOOL v25 = *v24 == (void)v10;
            int v10 = v24;
          }
          while (!v25);
        }
        uint64_t v11 = (v56 + 1);
        int v10 = v24;
      }
      while (v24 != v55);
    }
    char v26 = *(void **)(v53 + 48);
    if (v26 != (void *)(v53 + 56))
    {
      uint64_t v27 = v11;
      do
      {
        uint64_t v28 = v26[4];
        int v57 = v27;
        objc_msgSend(v9, "appendFormat:", @"\n   OutgoingLink[%i]", v27);
        uint64_t v29 = *(void *)(v28 + 80);
        uint64_t v30 = *(void *)(v28 + 88);
        if (v29 != v30)
        {
          uint64_t v31 = 0;
          do
          {
            int v32 = *(md::TransitLine **)(*(void *)v29 + 8);
            uint64_t v33 = *(void *)(*((void *)v32 + 2) + 40);
            uint64_t v34 = md::TransitLine::debugSystemName(v32);
            uint64_t v35 = *(void *)v29 + 8;
            uint64_t v36 = *(void *)(*(void *)(*(void *)v35 + 16) + 16);
            if (!*(void *)v29) {
              uint64_t v35 = 0;
            }
            unsigned int v37 = geo::codec::transitLinkGetShouldDrawToEndPoint(**(void **)(v35 + 8), *(unsigned int *)(v35 + 36));
            if (*(void *)v29) {
              uint64_t v38 = *(void *)v29 + 8;
            }
            else {
              uint64_t v38 = 0;
            }
            [v9 appendFormat:@"\n    line[uid:%llu,%i,%s,%s] draw[to:%i, FROM:%i]", v33, v31, v34, v36, v37, geo::codec::transitLinkGetShouldDrawFromEndPoint(**(void ***)(v38 + 8), *(unsigned int *)(v38 + 36))];
            uint64_t v31 = (v31 + 1);
            v29 += 8;
          }
          while (v29 != v30);
        }
        char v39 = (void *)v26[1];
        if (v39)
        {
          do
          {
            double v40 = v39;
            char v39 = (void *)*v39;
          }
          while (v39);
        }
        else
        {
          do
          {
            double v40 = (void *)v26[2];
            BOOL v25 = *v40 == (void)v26;
            char v26 = v40;
          }
          while (!v25);
        }
        uint64_t v27 = (v57 + 1);
        char v26 = v40;
      }
      while (v40 != (void *)(v53 + 56));
    }
    id v41 = v9;
    unint64_t v42 = (const char *)[v41 UTF8String];
    size_t v43 = strlen(v42);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v60, (uint64_t)v42, v43);
  }
  if ((v67 & 0x10) != 0)
  {
    unint64_t v46 = v66;
    unint64_t v44 = __dst;
    if (v66 < v63)
    {
      unint64_t v66 = v63;
      unint64_t v46 = v63;
    }
    int v47 = (const void **)&v62;
  }
  else
  {
    unint64_t v44 = __dst;
    if ((v67 & 8) == 0)
    {
      size_t v45 = 0;
      __dst[23] = 0;
      goto LABEL_62;
    }
    int v47 = (const void **)v61;
    unint64_t v46 = v61[2];
  }
  uint64_t v48 = *v47;
  size_t v45 = v46 - (void)*v47;
  if (v45 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v45 >= 0x17)
  {
    uint64_t v49 = (v45 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v45 | 7) != 0x17) {
      uint64_t v49 = v45 | 7;
    }
    uint64_t v50 = v49 + 1;
    uint64_t v51 = operator new(v49 + 1);
    *((void *)__dst + 1) = v45;
    *((void *)__dst + 2) = v50 | 0x8000000000000000;
    *(void *)long long __dst = v51;
    unint64_t v44 = v51;
    goto LABEL_61;
  }
  v44[23] = v45;
  if (v45) {
LABEL_61:
  }
    memmove(v44, v48, v45);
LABEL_62:
  v44[v45] = 0;
  v60[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v60 + *(void *)(v60[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v60[1] = MEMORY[0x1E4FBA470] + 16;
  if (v65 < 0) {
    operator delete(v64);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v68);
}

void sub_1A23D8D44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26)
{
  std::ostringstream::~ostringstream((uint64_t)&a26);
  _Unwind_Resume(a1);
}

void md::TransitConnectedNode::~TransitConnectedNode(md::TransitConnectedNode *this)
{
  *(void *)this = &unk_1EF53ED98;
  uint64_t v2 = (void *)*((void *)this + 9);
  if (v2)
  {
    *((void *)this + 10) = v2;
    operator delete(v2);
  }
  *(void *)this = &unk_1EF531178;
  unint64_t v3 = (void *)*((void *)this + 4);
  if (v3)
  {
    *((void *)this + 5) = v3;
    operator delete(v3);
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF53ED98;
  uint64_t v2 = (void *)*((void *)this + 9);
  if (v2)
  {
    *((void *)this + 10) = v2;
    operator delete(v2);
  }
  *(void *)this = &unk_1EF531178;
  unint64_t v3 = (void *)*((void *)this + 4);
  if (v3)
  {
    *((void *)this + 5) = v3;
    operator delete(v3);
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t md::TransitNode::TransitNode(uint64_t a1, uint64_t *a2, void *a3, float a4)
{
  *(void *)a1 = &unk_1EF531178;
  *(void *)(a1 + 8) = 0;
  uint64_t v8 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  if (a2)
  {
    *(void *)uint64_t v8 = a2;
    float v9 = (std::__shared_weak_count *)a2[1];
    if (v9 && (float v9 = std::__shared_weak_count::lock(v9)) != 0) {
      uint64_t v10 = *a2;
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t v11 = *(std::__shared_weak_count **)(a1 + 24);
    *(void *)(a1 + 16) = v10;
    *(void *)(a1 + 24) = v9;
    if (v11)
    {
      if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(float *)(a1 + 56) = a4;
  *(_DWORD *)(a1 + 60) = 5;
  *(unsigned char *)(a1 + 64) = 0;
  uint64_t v51 = (void **)(a1 + 32);
  uint64_t v12 = *(geo::codec::VectorTile **)(a1 + 16);
  if (v12)
  {
    uint64_t v50 = v8;
    *(unsigned char *)(a1 + 62) = *(unsigned char *)(geo::codec::VectorTile::key(v12) + 1) & 0x3F;
    unint64_t v13 = *((unsigned __int16 *)a2 + 138);
    uint64_t v14 = *(unsigned char **)(a1 + 32);
    if (v13 <= (uint64_t)(*(void *)(a1 + 48) - (void)v14) >> 3)
    {
LABEL_21:
      for (unsigned int i = 0; i < *(unsigned __int16 *)(*(void *)v8 + 276); ++i)
      {
        unint64_t v29 = *(void *)(geo::codec::VectorTile::transitNodeLineIndices(*(geo::codec::VectorTile **)(a1 + 16))
                        + 8 * (*(_DWORD *)(*(void *)v8 + 288) + i));
        if (v29 < 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(a3[1] - *a3) >> 3))
        {
          uint64_t v30 = *a3 + 104 * v29;
          int v32 = *(uint64_t **)(a1 + 40);
          unint64_t v31 = *(void *)(a1 + 48);
          if ((unint64_t)v32 < v31)
          {
            uint64_t *v32 = v30;
            uint64_t v28 = v32 + 1;
          }
          else
          {
            uint64_t v33 = (uint64_t *)*v51;
            uint64_t v34 = (char *)v32 - (unsigned char *)*v51;
            uint64_t v35 = v34 >> 3;
            unint64_t v36 = (v34 >> 3) + 1;
            if (v36 >> 61) {
              abort();
            }
            unsigned int v37 = a3;
            uint64_t v38 = v31 - (void)v33;
            if (v38 >> 2 > v36) {
              unint64_t v36 = v38 >> 2;
            }
            if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v39 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v39 = v36;
            }
            if (v39)
            {
              if (v39 >> 61) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              double v40 = operator new(8 * v39);
            }
            else
            {
              double v40 = 0;
            }
            id v41 = (uint64_t *)&v40[8 * v35];
            uint64_t *v41 = v30;
            uint64_t v28 = v41 + 1;
            if (v32 == v33)
            {
              uint64_t v33 = v32;
            }
            else
            {
              unint64_t v42 = (char *)(v32 - 1) - (char *)v33;
              if (v42 < 0x58) {
                goto LABEL_56;
              }
              if ((unint64_t)((char *)v32 - &v40[v34]) < 0x20) {
                goto LABEL_56;
              }
              uint64_t v43 = (v42 >> 3) + 1;
              unint64_t v44 = &v40[8 * v35 - 16];
              size_t v45 = v32 - 2;
              uint64_t v46 = v43 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v47 = *(_OWORD *)v45;
                *(v44 - 1) = *((_OWORD *)v45 - 1);
                _OWORD *v44 = v47;
                v44 -= 2;
                v45 -= 4;
                v46 -= 4;
              }
              while (v46);
              v41 -= v43 & 0x3FFFFFFFFFFFFFFCLL;
              v32 -= v43 & 0x3FFFFFFFFFFFFFFCLL;
              if (v43 != (v43 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_56:
                do
                {
                  uint64_t v48 = *--v32;
                  *--id v41 = v48;
                }
                while (v32 != v33);
                uint64_t v33 = (uint64_t *)*v51;
              }
            }
            *(void *)(a1 + 32) = v41;
            *(void *)(a1 + 40) = v28;
            *(void *)(a1 + 48) = &v40[8 * v39];
            if (v33) {
              operator delete(v33);
            }
            a3 = v37;
            uint64_t v8 = v50;
          }
          *(void *)(a1 + 40) = v28;
        }
      }
      return a1;
    }
    uint64_t v15 = *(unsigned char **)(a1 + 40);
    float v16 = (char *)operator new(8 * v13);
    uint64_t v17 = v15 - v14;
    uint64_t v18 = &v16[(v15 - v14) & 0xFFFFFFFFFFFFFFF8];
    uint64_t v19 = v18;
    if (v15 != v14)
    {
      if ((unint64_t)(v17 - 8) < 0x58)
      {
        uint64_t v19 = &v16[(v15 - v14) & 0xFFFFFFFFFFFFFFF8];
        do
        {
LABEL_18:
          uint64_t v26 = *((void *)v15 - 1);
          v15 -= 8;
          *((void *)v19 - 1) = v26;
          v19 -= 8;
        }
        while (v15 != v14);
        goto LABEL_19;
      }
      uint64_t v19 = &v16[(v15 - v14) & 0xFFFFFFFFFFFFFFF8];
      if ((unint64_t)(v15 - &v16[v17 & 0xFFFFFFFFFFFFFFF8]) < 0x20) {
        goto LABEL_18;
      }
      uint64_t v20 = v17 >> 3;
      unint64_t v21 = ((unint64_t)(v17 - 8) >> 3) + 1;
      uint64_t v22 = &v16[8 * v20 - 16];
      char v23 = (long long *)(v15 - 16);
      uint64_t v24 = v21 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v25 = *v23;
        *((_OWORD *)v22 - 1) = *(v23 - 1);
        *(_OWORD *)uint64_t v22 = v25;
        v22 -= 32;
        v23 -= 2;
        v24 -= 4;
      }
      while (v24);
      uint64_t v19 = &v18[-8 * (v21 & 0x3FFFFFFFFFFFFFFCLL)];
      v15 -= 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
      if (v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_18;
      }
    }
LABEL_19:
    *(void *)(a1 + 32) = v19;
    *(void *)(a1 + 40) = v18;
    *(void *)(a1 + 48) = &v16[8 * v13];
    if (v14) {
      operator delete(v14);
    }
    goto LABEL_21;
  }
  return a1;
}

void sub_1A23D9330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, md::components::Material *a9, void **a10)
{
  uint64_t v12 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 40) = v12;
    operator delete(v12);
  }
  md::components::Material::~Material(a9);
  _Unwind_Resume(a1);
}

void md::TransitNode::~TransitNode(md::TransitNode *this)
{
  *(void *)this = &unk_1EF531178;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

uint64_t md::TransitConnectedNode::TransitConnectedNode(uint64_t a1, uint64_t *a2, void *a3, void *a4, float a5)
{
  uint64_t v6 = a1;
  uint64_t v7 = md::TransitNode::TransitNode(a1, a2, a3, a5);
  *(void *)uint64_t v7 = &unk_1EF53ED98;
  *(void *)(v7 + 72) = 0;
  *(void *)(v7 + 80) = 0;
  *(void *)(v7 + 88) = 0;
  *(void *)(v7 + 96) = a4;
  *(_DWORD *)(v7 + 120) = 0;
  *(_DWORD *)(v7 + 132) = 0;
  *(void *)(v7 + 124) = 0x100000001;
  *(unsigned char *)(v7 + 136) = 0;
  if (*(unsigned char *)(*(void *)(v7 + 8) + 320))
  {
    uint64_t v8 = (void *)a4[3];
    float v9 = a4 + 4;
    int v70 = v8;
    uint64_t v71 = v6;
    if (v8 == a4 + 4)
    {
      unint64_t v11 = 0;
      uint64_t v10 = 0;
      unint64_t v13 = (void *)a4[6];
    }
    else
    {
      uint64_t v10 = 0;
      unint64_t v11 = 0;
      uint64_t v12 = a4 + 7;
      do
      {
        uint64_t v14 = (void *)v8[1];
        uint64_t v15 = v14;
        float v16 = v8;
        if (v14)
        {
          do
          {
            uint64_t v17 = v15;
            uint64_t v15 = (void *)*v15;
          }
          while (v15);
        }
        else
        {
          do
          {
            uint64_t v17 = (void *)v16[2];
            BOOL v18 = *v17 == (void)v16;
            float v16 = v17;
          }
          while (!v18);
        }
        if (v17 != v9)
        {
          unint64_t v19 = v8[4];
          do
          {
            uint64_t v20 = v17[4];
            uint64_t v21 = md::TransitJunction::normalForLinkPair(a4, v19, v20);
            if (v21
              && ((uint64_t)(*(void *)(v20 + 88) - *(void *)(v20 + 80)) >> 3)
               + ((uint64_t)(*(void *)(v19 + 88) - *(void *)(v19 + 80)) >> 3) > v11)
            {
              unint64_t v11 = ((uint64_t)(*(void *)(v20 + 88) - *(void *)(v20 + 80)) >> 3)
                  + ((uint64_t)(*(void *)(v19 + 88) - *(void *)(v19 + 80)) >> 3);
              uint64_t v10 = (float *)v21;
            }
            uint64_t v22 = (void *)v17[1];
            if (v22)
            {
              do
              {
                char v23 = v22;
                uint64_t v22 = (void *)*v22;
              }
              while (v22);
            }
            else
            {
              do
              {
                char v23 = (void *)v17[2];
                BOOL v18 = *v23 == (void)v17;
                uint64_t v17 = v23;
              }
              while (!v18);
            }
            uint64_t v17 = v23;
          }
          while (v23 != v9);
        }
        uint64_t v24 = (void *)a4[6];
        float v72 = v24;
        if (v24 != v12)
        {
          unint64_t v25 = v8[4];
          do
          {
            uint64_t v26 = v24[4];
            uint64_t v27 = md::TransitJunction::normalForLinkPair(a4, v25, v26);
            if (v27
              && ((uint64_t)(*(void *)(v26 + 88) - *(void *)(v26 + 80)) >> 3)
               + ((uint64_t)(*(void *)(v25 + 88) - *(void *)(v25 + 80)) >> 3) > v11)
            {
              unint64_t v11 = ((uint64_t)(*(void *)(v26 + 88) - *(void *)(v26 + 80)) >> 3)
                  + ((uint64_t)(*(void *)(v25 + 88) - *(void *)(v25 + 80)) >> 3);
              uint64_t v10 = (float *)v27;
            }
            uint64_t v28 = (void *)v24[1];
            if (v28)
            {
              do
              {
                unint64_t v29 = v28;
                uint64_t v28 = (void *)*v28;
              }
              while (v28);
            }
            else
            {
              do
              {
                unint64_t v29 = (void *)v24[2];
                BOOL v18 = *v29 == (void)v24;
                uint64_t v24 = v29;
              }
              while (!v18);
            }
            uint64_t v24 = v29;
          }
          while (v29 != v12);
        }
        if (v14)
        {
          do
          {
            uint64_t v30 = v14;
            uint64_t v14 = (void *)*v14;
          }
          while (v14);
        }
        else
        {
          do
          {
            uint64_t v30 = (void *)v8[2];
            BOOL v18 = *v30 == (void)v8;
            uint64_t v8 = v30;
          }
          while (!v18);
        }
        uint64_t v8 = v30;
        unint64_t v13 = v72;
      }
      while (v30 != v9);
    }
    unint64_t v31 = a4 + 7;
    unint64_t v73 = v13;
    if (v13 != a4 + 7)
    {
      do
      {
        uint64_t v34 = (void *)v13[1];
        uint64_t v35 = v34;
        unint64_t v36 = v13;
        if (v34)
        {
          do
          {
            unsigned int v37 = v35;
            uint64_t v35 = (void *)*v35;
          }
          while (v35);
        }
        else
        {
          do
          {
            unsigned int v37 = (void *)v36[2];
            BOOL v18 = *v37 == (void)v36;
            unint64_t v36 = v37;
          }
          while (!v18);
        }
        if (v37 != v31)
        {
          unint64_t v38 = v13[4];
          do
          {
            uint64_t v39 = v37[4];
            uint64_t v40 = md::TransitJunction::normalForLinkPair(a4, v38, v39);
            if (v40
              && ((uint64_t)(*(void *)(v39 + 88) - *(void *)(v39 + 80)) >> 3)
               + ((uint64_t)(*(void *)(v38 + 88) - *(void *)(v38 + 80)) >> 3) > v11)
            {
              unint64_t v11 = ((uint64_t)(*(void *)(v39 + 88) - *(void *)(v39 + 80)) >> 3)
                  + ((uint64_t)(*(void *)(v38 + 88) - *(void *)(v38 + 80)) >> 3);
              uint64_t v10 = (float *)v40;
            }
            id v41 = (void *)v37[1];
            if (v41)
            {
              do
              {
                unint64_t v42 = v41;
                id v41 = (void *)*v41;
              }
              while (v41);
            }
            else
            {
              do
              {
                unint64_t v42 = (void *)v37[2];
                BOOL v18 = *v42 == (void)v37;
                unsigned int v37 = v42;
              }
              while (!v18);
            }
            unsigned int v37 = v42;
          }
          while (v42 != v31);
        }
        if (v34)
        {
          do
          {
            uint64_t v43 = v34;
            uint64_t v34 = (void *)*v34;
          }
          while (v34);
        }
        else
        {
          do
          {
            uint64_t v43 = (void *)v13[2];
            BOOL v18 = *v43 == (void)v13;
            unint64_t v13 = v43;
          }
          while (!v18);
        }
        unint64_t v13 = v43;
      }
      while (v43 != v31);
    }
    if (v10)
    {
      int v32 = v70;
      uint64_t v6 = v71;
      *(unsigned char *)(v71 + 136) = 1;
      uint64_t v33 = v73;
    }
    else
    {
      int v32 = v70;
      uint64_t v6 = v71;
      uint64_t v33 = v73;
      uint64_t v10 = 0;
      if (v70 != v9)
      {
        unint64_t v44 = v70;
        do
        {
          size_t v45 = (void *)v44[4];
          uint64_t v46 = v45[8];
          if (*(unsigned char *)(v46 - 3))
          {
            unint64_t v47 = (uint64_t)(v45[11] - v45[10]) >> 3;
            uint64_t v48 = (float *)(v46 - 48);
            if (v47 > v11)
            {
              unint64_t v11 = v47;
              uint64_t v10 = v48;
            }
          }
          uint64_t v49 = (void *)v44[1];
          if (v49)
          {
            do
            {
              uint64_t v50 = v49;
              uint64_t v49 = (void *)*v49;
            }
            while (v49);
          }
          else
          {
            do
            {
              uint64_t v50 = (void *)v44[2];
              BOOL v18 = *v50 == (void)v44;
              unint64_t v44 = v50;
            }
            while (!v18);
          }
          unint64_t v44 = v50;
        }
        while (v50 != v9);
      }
      if (v73 != v31)
      {
        uint64_t v51 = v73;
        do
        {
          unint64_t v52 = (void *)v51[4];
          uint64_t v53 = v52[7];
          if (*(unsigned char *)(v53 + 93))
          {
            unint64_t v54 = (uint64_t)(v52[11] - v52[10]) >> 3;
            float v55 = (float *)(v53 + 8);
            if (v54 > v11)
            {
              unint64_t v11 = v54;
              uint64_t v10 = v55;
            }
          }
          int v56 = (void *)v51[1];
          if (v56)
          {
            do
            {
              int v57 = v56;
              int v56 = (void *)*v56;
            }
            while (v56);
          }
          else
          {
            do
            {
              int v57 = (void *)v51[2];
              BOOL v18 = *v57 == (void)v51;
              uint64_t v51 = v57;
            }
            while (!v18);
          }
          uint64_t v51 = v57;
        }
        while (v57 != v31);
      }
      *(unsigned char *)(v71 + 136) = v10 != 0;
      if (!v10) {
        goto LABEL_96;
      }
    }
    float v58 = *v10;
    float v59 = v10[1];
    float v60 = sqrtf((float)(v58 * v58) + (float)(v59 * v59));
    if (v60 >= 0.01)
    {
      *(float *)(v6 + 104) = v58 / v60;
      *(float *)(v6 + 108) = v59 / v60;
      *(_DWORD *)(v6 + 132) = 1;
      float v62 = 0.0;
      if (v32 != v9)
      {
        do
        {
          uint64_t v64 = (void *)v32[1];
          char v65 = v32;
          if (v64)
          {
            do
            {
              unint64_t v66 = v64;
              uint64_t v64 = (void *)*v64;
            }
            while (v64);
          }
          else
          {
            do
            {
              unint64_t v66 = (void *)v65[2];
              BOOL v18 = *v66 == (void)v65;
              char v65 = v66;
            }
            while (!v18);
          }
          float v62 = fmaxf(v62, *(float *)(v32[4] + 152));
          int v32 = v66;
        }
        while (v66 != v9);
      }
      if (v33 != v31)
      {
        do
        {
          int v67 = (void *)v33[1];
          uint64_t v68 = v33;
          if (v67)
          {
            do
            {
              uint64_t v69 = v67;
              int v67 = (void *)*v67;
            }
            while (v67);
          }
          else
          {
            do
            {
              uint64_t v69 = (void *)v68[2];
              BOOL v18 = *v69 == (void)v68;
              uint64_t v68 = v69;
            }
            while (!v18);
          }
          float v62 = fmaxf(v62, *(float *)(v33[4] + 152));
          uint64_t v33 = v69;
        }
        while (v69 != v31);
      }
      *(float *)(v6 + 120) = v62;
      if (v62 < 3.0) {
        char v61 = 1;
      }
      else {
        char v61 = 2;
      }
      goto LABEL_102;
    }
    *(void *)(v6 + 104) = 1065353216;
    *(unsigned char *)(v6 + 136) = 0;
LABEL_96:
    char v61 = 1;
LABEL_102:
    *(unsigned char *)(v6 + 60) = v61;
    return v6;
  }
  *(unsigned char *)(v6 + 60) = 0;
  md::TransitConnectedNode::createDots((md::TransitConnectedNode *)v6);
  return v6;
}

void sub_1A23D99A0(_Unwind_Exception *a1)
{
  int v4 = *v1;
  if (*v1)
  {
    *((void *)v2 + 10) = v4;
    operator delete(v4);
  }
  md::TransitNode::~TransitNode(v2);
  _Unwind_Resume(a1);
}

uint64_t md::TransitParentNode::transitNodeType(md::TransitParentNode *this)
{
  return 1;
}

uint64_t md::TransitParentNode::parentID(md::TransitParentNode *this)
{
  return 0;
}

void md::TransitParentNode::~TransitParentNode(md::TransitParentNode *this)
{
  *(void *)this = &unk_1EF53ED98;
  uint64_t v2 = (void *)*((void *)this + 9);
  if (v2)
  {
    *((void *)this + 10) = v2;
    operator delete(v2);
  }
  *(void *)this = &unk_1EF531178;
  unint64_t v3 = (void *)*((void *)this + 4);
  if (v3)
  {
    *((void *)this + 5) = v3;
    operator delete(v3);
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF53ED98;
  uint64_t v2 = (void *)*((void *)this + 9);
  if (v2)
  {
    *((void *)this + 10) = v2;
    operator delete(v2);
  }
  *(void *)this = &unk_1EF531178;
  unint64_t v3 = (void *)*((void *)this + 4);
  if (v3)
  {
    *((void *)this + 5) = v3;
    operator delete(v3);
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t altitude::TextureMapLoadJob::jobStep(altitude::TextureMapLoadJob *this)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (CVPixelBufferRef *)*((void *)this + 29);
  unint64_t v3 = (CVPixelBufferRef *)*((void *)this + 30);
  if (v3 == v2)
  {
LABEL_5:
    if (*((unsigned char *)this + 224))
    {
      if (!*((void *)this + 34))
      {
        uint64_t v6 = *(void *)(**((void **)this + 1) + 848);
        int v7 = *(_DWORD *)(*((void *)this + 22) + 8);
        uint64_t v8 = operator new(0x68uLL);
        v8[1] = 0;
        uint64_t v8[2] = 0;
        *uint64_t v8 = &unk_1EF58B038;
        altitude::MipChain::MipChain((uint64_t)(v8 + 3), v6, v7);
      }
    }
    else if (!*((void *)this + 32))
    {
      uint64_t v16 = *((void *)this + 22);
      if (**(_DWORD **)(v16 + 40))
      {
        uint64_t v17 = *(void *)(**((void **)this + 1) + 848);
        int v18 = *(_DWORD *)(v16 + 8);
        unint64_t v34 = 0x8000000080;
        LODWORD(v35) = v18;
        altitude::IOSurfacePool::acquireSurface(&v38, v17, &v34);
      }
      else
      {
        uint64_t v22 = *v2;
        unsigned int Width = CVPixelBufferGetWidth(*v2);
        unsigned int Height = CVPixelBufferGetHeight(v22);
        uint64_t v25 = *(void *)(**((void **)this + 1) + 848);
        int v26 = Width >> 2;
        if (Width >> 2 <= 1) {
          int v26 = 1;
        }
        int v27 = Height >> 2;
        if (Height < 4) {
          int v27 = 1;
        }
        int v28 = *(_DWORD *)(*((void *)this + 22) + 8);
        unint64_t v34 = __PAIR64__(v27, v26);
        LODWORD(v35) = v28;
        altitude::IOSurfacePool::acquireSurface(&v38, v25, &v34);
      }
      long long v29 = v38;
      long long v38 = 0uLL;
      uint64_t v30 = (std::__shared_weak_count *)*((void *)this + 33);
      *((_OWORD *)this + 16) = v29;
      if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
      unint64_t v31 = (std::__shared_weak_count *)*((void *)&v38 + 1);
      if (*((void *)&v38 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v38 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
      uint64_t v32 = *((void *)this + 1);
      uint64_t v33 = operator new(0xF8uLL);
      v33[1] = 0;
      v33[2] = 0;
      *uint64_t v33 = &unk_1EF58ACB8;
      karo::Job::Job((uint64_t)(v33 + 3), v32);
    }
    if (v3 != v2)
    {
      uint64_t v10 = *v2;
      CVPixelBufferLockBaseAddress(*v2, 1uLL);
      CVPixelBufferGetBaseAddress(v10);
      CVPixelBufferGetWidth(v10);
      CVPixelBufferGetHeight(v10);
      if (!*(void *)(*((void *)this + 22) + 16)) {
        operator new();
      }
      operator new();
    }
    if (!*((unsigned char *)this + 224))
    {
      uint64_t v15 = *((void *)this + 32);
      *((void *)this + 32) = 0;
      *((void *)this + 33) = 0;
      IOSurfaceLock(*(IOSurfaceRef *)(v15 + 16), 0, 0);
      IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(v15 + 16));
      IOSurfaceGetWidth(*(IOSurfaceRef *)(v15 + 16));
      IOSurfaceGetHeight(*(IOSurfaceRef *)(v15 + 16));
      operator new();
    }
    uint64_t v11 = *((void *)this + 34);
    uint64_t v12 = *(void *)(v11 + 64);
    if (!v12) {
      goto LABEL_52;
    }
    uint64_t v13 = *(void *)(*((void *)this + 22) + 16);
    uint64_t v14 = *(void *)(v13 + 80);
    v36[0] = &unk_1EF57D290;
    unsigned int v37 = v36;
    *(void *)&long long v38 = v12;
    *((void *)&v38 + 1) = v13;
    char v39 = 0;
    char v41 = 0;
    *(void *)&v42[1] = 0;
    *(void *)&v42[3] = v14;
    unint64_t v44 = v43;
    std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_1,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_1>,void ()(ggl::Texture2DLoadItem const&)>::__clone((uint64_t)v36, v43);
    if (v37 == v36)
    {
      (*(void (**)(void *))(v36[0] + 32))(v36);
    }
    else if (v37)
    {
      (*(void (**)(void))(*v37 + 40))();
    }
    unint64_t v19 = *((void *)this + 37);
    if (v19 >= *((void *)this + 38))
    {
      uint64_t v21 = std::vector<ggl::Texture2DLoadItem>::__push_back_slow_path<ggl::Texture2DLoadItem const&>((void *)this + 36, (uint64_t)&v38);
LABEL_47:
      *((void *)this + 37) = v21;
      if (v44 == v43)
      {
        (*(void (**)(void *))(v43[0] + 32))(v43);
      }
      else if (v44)
      {
        (*(void (**)(void))(*v44 + 40))();
      }
      uint64_t v11 = *((void *)this + 34);
LABEL_52:
      if (*(void *)(v11 + 72)) {
        operator new();
      }
      pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
      *((_DWORD *)this + 40) |= 1u;
      return pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
    }
    *(_OWORD *)unint64_t v19 = v38;
    *(unsigned char *)(v19 + 16) = 0;
    if (v39)
    {
      *(unsigned char *)(v19 + 17) = v40;
      *(unsigned char *)(v19 + 16) = 1;
    }
    *(unsigned char *)(v19 + 20) = 0;
    if (v41)
    {
      *(_DWORD *)(v19 + 24) = v42[0];
      *(unsigned char *)(v19 + 20) = 1;
    }
    *(_OWORD *)(v19 + 28) = *(_OWORD *)&v42[1];
    uint64_t v20 = (uint64_t)v44;
    if (v44)
    {
      if (v44 == v43)
      {
        *(void *)(v19 + 72) = v19 + 48;
        (*(void (**)(void *))(*v44 + 24))(v44);
        goto LABEL_46;
      }
      uint64_t v20 = (*(uint64_t (**)(void))(*v44 + 16))();
    }
    *(void *)(v19 + 72) = v20;
LABEL_46:
    uint64_t v21 = (char *)(v19 + 80);
    *((void *)this + 37) = v19 + 80;
    goto LABEL_47;
  }
  unint64_t v4 = 0;
  unsigned int v5 = 1;
  while (v2[v4])
  {
    unint64_t v4 = v5++;
    if (v3 - v2 <= v4) {
      goto LABEL_5;
    }
  }
  return (*(uint64_t (**)(altitude::TextureMapLoadJob *))(*(void *)this + 16))(this);
}

void sub_1A23DB198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42)
{
  if (*(unsigned char *)(v45 + 20)) {
    *(unsigned char *)(v45 + 20) = 0;
  }
  if (*(unsigned char *)(v45 + 16)) {
    *(unsigned char *)(v45 + 16) = 0;
  }
  *(void *)(v42 + 320) = v45;
  if (a42 == v44)
  {
    (*(void (**)(uint64_t))(a39 + 32))(v44);
  }
  else if (a42)
  {
    (*(void (**)(void))(*(void *)a42 + 40))();
  }
  if (v43)
  {
    if (!atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
      _Unwind_Resume(a1);
    }
  }
  _Unwind_Resume(a1);
}

void altitude::MipChain::MipChain(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)a1 = a3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  uint64_t v15 = 0x10000000100;
  int v16 = a3;
  altitude::IOSurfacePool::acquireSurface(&v17, a2, &v15);
  long long v6 = v17;
  long long v17 = 0uLL;
  int v7 = *(std::__shared_weak_count **)(a1 + 16);
  *(_OWORD *)(a1 + 8) = v6;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)&v17 + 1);
  if (*((void *)&v17 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  uint64_t v15 = 0x8000000080;
  int v16 = a3;
  altitude::IOSurfacePool::acquireSurface(&v17, a2, &v15);
  long long v9 = v17;
  long long v17 = 0uLL;
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 32);
  *(_OWORD *)(a1 + 24) = v9;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v11 = (std::__shared_weak_count *)*((void *)&v17 + 1);
  if (*((void *)&v17 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  uint64_t v15 = 0x4000000040;
  int v16 = a3;
  altitude::IOSurfacePool::acquireSurface(&v17, a2, &v15);
  long long v12 = v17;
  long long v17 = 0uLL;
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 48);
  *(_OWORD *)(a1 + 40) = v12;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  uint64_t v14 = (std::__shared_weak_count *)*((void *)&v17 + 1);
  if (*((void *)&v17 + 1))
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  operator new();
}

void sub_1A23DBBA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

void altitude::IOSurfacePool::acquireSurface(void *a1, uint64_t a2, _DWORD *a3)
{
  long long v6 = (std::mutex *)(a2 + 24);
  std::mutex::lock((std::mutex *)(a2 + 24));
  int v7 = *(void **)a2;
  uint64_t v8 = *(void **)(a2 + 8);
  if (*(void **)a2 != v8)
  {
    while (1)
    {
      uint64_t v9 = v7[1];
      if (v9)
      {
        if (!*(void *)(v9 + 8))
        {
          uint64_t v10 = (_DWORD *)*v7;
          if (*(_DWORD *)*v7 == *a3 && v10[1] == a3[1] && v10[2] == a3[2]) {
            break;
          }
        }
      }
      v7 += 2;
      if (v7 == v8) {
        goto LABEL_10;
      }
    }
    *a1 = v10;
    a1[1] = v9;
    goto LABEL_36;
  }
LABEL_10:
  char v40 = a1;
  uint64_t v42 = v6;
  uint64_t v11 = operator new(0x30uLL);
  v11[1] = 0;
  v11[2] = 0;
  *uint64_t v11 = &unk_1EF58AC48;
  uint64_t v11[3] = *(void *)a3;
  int v13 = a3[1];
  int v12 = a3[2];
  *((_DWORD *)v11 + 8) = v12;
  int v14 = *a3;
  int v49 = v13;
  int valuePtr = v14;
  int v48 = 0;
  if (v12 == 4)
  {
    int v48 = 1111970369;
    int v15 = 4;
  }
  else
  {
    int v15 = 0;
    if (v12 == 14)
    {
      int v48 = 1278555701;
      int v15 = 2;
    }
  }
  int v46 = 1;
  int v47 = v15 * v14;
  int v44 = 1024;
  int v45 = 1;
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFNumberRef v17 = CFNumberCreate(0, kCFNumberIntType, &v49);
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberIntType, &v47);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberIntType, &v48);
  CFNumberRef cf = CFNumberCreate(0, kCFNumberIntType, &v46);
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberIntType, &v45);
  CFNumberRef v21 = CFNumberCreate(0, kCFNumberIntType, &v44);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F2C0], v16);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F0E8], v17);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2EFE0], v18);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2F150], v19);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F2EFE8], v21);
  CFRelease(v16);
  CFRelease(v17);
  CFRelease(v18);
  CFRelease(v19);
  CFRelease(cf);
  CFRelease(v20);
  CFRelease(v21);
  IOSurfaceRef v23 = IOSurfaceCreate(Mutable);
  CFRelease(Mutable);
  v11[5] = v23;
  *(void *)&long long v43 = v11 + 3;
  *((void *)&v43 + 1) = v11;
  uint64_t v25 = *(void **)(a2 + 8);
  unint64_t v24 = *(void *)(a2 + 16);
  if ((unint64_t)v25 >= v24)
  {
    int v27 = *(void **)a2;
    uint64_t v28 = ((uint64_t)v25 - *(void *)a2) >> 4;
    unint64_t v29 = v28 + 1;
    if ((unint64_t)(v28 + 1) >> 60) {
      abort();
    }
    uint64_t v30 = v24 - (void)v27;
    if (v30 >> 3 > v29) {
      unint64_t v29 = v30 >> 3;
    }
    if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v31 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v31 = v29;
    }
    long long v6 = v42;
    int v26 = v40;
    if (v31 >> 60) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v32 = (char *)operator new(16 * v31);
    uint64_t v33 = &v32[16 * v28];
    *(_OWORD *)uint64_t v33 = v43;
    unint64_t v34 = v33 + 16;
    uint64_t v35 = &v32[16 * v31];
    if (v25 == v27)
    {
      *(void *)a2 = v33;
      *(void *)(a2 + 8) = v34;
      *(void *)(a2 + 16) = v35;
    }
    else
    {
      do
      {
        long long v36 = *((_OWORD *)v25 - 1);
        v25 -= 2;
        *((_OWORD *)v33 - 1) = v36;
        v33 -= 16;
        *uint64_t v25 = 0;
        v25[1] = 0;
      }
      while (v25 != v27);
      uint64_t v25 = *(void **)a2;
      unsigned int v37 = *(void **)(a2 + 8);
      *(void *)a2 = v33;
      *(void *)(a2 + 8) = v34;
      for (*(void *)(a2 + 16) = v35; v37 != v25; v37 -= 2)
      {
        long long v38 = (std::__shared_weak_count *)*(v37 - 1);
        if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
      }
    }
    if (v25) {
      operator delete(v25);
    }
    *(void *)(a2 + 8) = v34;
  }
  else
  {
    *uint64_t v25 = v11 + 3;
    v25[1] = v11;
    *(void *)(a2 + 8) = v25 + 2;
    long long v6 = v42;
    int v26 = v40;
  }
  uint64_t v39 = *(void *)(a2 + 8);
  uint64_t v9 = *(void *)(v39 - 8);
  void *v26 = *(void *)(v39 - 16);
  v26[1] = v9;
  if (v9) {
LABEL_36:
  }
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
}

void sub_1A23DC070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::mutex *a12, char a13)
{
}

char *std::vector<ggl::Texture2DLoadItem>::__push_back_slow_path<ggl::Texture2DLoadItem const&>(void *a1, uint64_t a2)
{
  unint64_t v2 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a1[1] - *a1) >> 4);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x333333333333333) {
    abort();
  }
  if (0x999999999999999ALL * ((uint64_t)(a1[2] - *a1) >> 4) > v3) {
    unint64_t v3 = 0x999999999999999ALL * ((uint64_t)(a1[2] - *a1) >> 4);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a1[2] - *a1) >> 4) >= 0x199999999999999) {
    unint64_t v6 = 0x333333333333333;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x333333333333333) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int v7 = operator new(80 * v6);
  }
  else
  {
    int v7 = 0;
  }
  uint64_t v8 = &v7[80 * v2];
  *((void *)&v29 + 1) = &v7[80 * v6];
  *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
  v8[16] = 0;
  if (*(unsigned char *)(a2 + 16))
  {
    v7[80 * v2 + 17] = *(unsigned char *)(a2 + 17);
    v8[16] = 1;
  }
  uint64_t v9 = &v7[80 * v2];
  v9[20] = 0;
  uint64_t v10 = v9 + 20;
  if (*(unsigned char *)(a2 + 20))
  {
    *(_DWORD *)&v7[80 * v2 + 24] = *(_DWORD *)(a2 + 24);
    *uint64_t v10 = 1;
  }
  uint64_t v11 = &v7[80 * v2];
  *(_OWORD *)(v11 + 28) = *(_OWORD *)(a2 + 28);
  uint64_t v12 = *(void *)(a2 + 72);
  if (!v12) {
    goto LABEL_18;
  }
  if (v12 != a2 + 48)
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12);
LABEL_18:
    *(void *)&v7[80 * v2 + 72] = v12;
    int v13 = &v7[80 * v2];
    goto LABEL_20;
  }
  *(void *)&v7[80 * v2 + 72] = v11 + 48;
  (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
  int v13 = &v7[80 * v2];
LABEL_20:
  int v14 = v13 + 80;
  *(void *)&long long v29 = v13 + 80;
  CFNumberRef v16 = (char *)*a1;
  int v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v8;
    a1[1] = v14;
    a1[2] = *((void *)&v29 + 1);
  }
  else
  {
    uint64_t v17 = 0;
    do
    {
      CFNumberRef v18 = &v8[v17];
      CFNumberRef v19 = &v15[v17];
      *((_OWORD *)v18 - 5) = *(_OWORD *)&v15[v17 - 80];
      *(v18 - 64) = 0;
      if (v15[v17 - 64])
      {
        *(v18 - 63) = *(v19 - 63);
        *(v18 - 64) = 1;
      }
      *(v18 - 60) = 0;
      if (*(v19 - 60))
      {
        *(_DWORD *)&v8[v17 - 56] = *(_DWORD *)&v15[v17 - 56];
        *(v18 - 60) = 1;
      }
      CFNumberRef v20 = &v8[v17];
      CFNumberRef v21 = &v15[v17];
      *(_OWORD *)&v8[v17 - 52] = *(_OWORD *)&v15[v17 - 52];
      uint64_t v22 = *(char **)&v15[v17 - 8];
      if (v22)
      {
        if (v21 - 32 == v22)
        {
          *((void *)v20 - 1) = v20 - 32;
          (*(void (**)(void))(**((void **)v21 - 1) + 24))(*((void *)v21 - 1));
        }
        else
        {
          *((void *)v20 - 1) = v22;
          *((void *)v21 - 1) = 0;
        }
      }
      else
      {
        *((void *)v20 - 1) = 0;
      }
      v17 -= 80;
    }
    while (&v15[v17] != v16);
    int v15 = (char *)*a1;
    IOSurfaceRef v23 = (char *)a1[1];
    *a1 = &v8[v17];
    *(_OWORD *)(a1 + 1) = v29;
    int v14 = (char *)v29;
    if (v23 != v15)
    {
      unint64_t v24 = v23 - 32;
      uint64_t v25 = v23 - 32;
      do
      {
        int v27 = (char *)*((void *)v25 + 3);
        if (v25 == v27)
        {
          (*(void (**)(char *))(*(void *)v25 + 32))(v25);
          if (!*(v25 - 28)) {
            goto LABEL_40;
          }
        }
        else
        {
          if (v27) {
            (*(void (**)(char *))(*(void *)v27 + 40))(v27);
          }
          if (!*(v25 - 28)) {
            goto LABEL_40;
          }
        }
        *(v25 - 28) = 0;
LABEL_40:
        if (*(v25 - 32)) {
          *(v25 - 32) = 0;
        }
        int v26 = v25 - 48;
        v25 -= 80;
        v24 -= 80;
      }
      while (v26 != v15);
    }
  }
  if (v15) {
    operator delete(v15);
  }
  return v14;
}

void sub_1A23DC43C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*v3) {
    *unint64_t v3 = 0;
  }
  if (*v2) {
    *unint64_t v2 = 0;
  }
  std::__split_buffer<ggl::Texture2DLoadItem>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::function<void ()(ggl::Texture2DLoadItem const&)>::~function(void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void ggl::Texture2DLoadItem::~Texture2DLoadItem(ggl::Texture2DLoadItem *this)
{
  unint64_t v2 = (char *)this + 48;
  unint64_t v3 = (char *)*((void *)this + 9);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    if (*((unsigned char *)this + 20)) {
LABEL_5:
    }
      *((unsigned char *)this + 20) = 0;
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    if (*((unsigned char *)this + 20)) {
      goto LABEL_5;
    }
  }
  if (*((unsigned char *)this + 16)) {
    *((unsigned char *)this + 16) = 0;
  }
}

uint64_t std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_3,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_3>,void ()(ggl::Texture2DLoadItem const&)>::operator()(uint64_t a1, uint64_t *a2)
{
  IOSurfaceUnlock(*(IOSurfaceRef *)(*(void *)(a1 + 8) + 16), 0, 0);
  uint64_t result = *a2;
  if (*a2)
  {
    unint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v4();
  }
  return result;
}

void std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_3,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_3>,void ()(ggl::Texture2DLoadItem const&)>::destroy_deallocate(void *__p)
{
  unint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_3,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_3>,void ()(ggl::Texture2DLoadItem const&)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_3,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_3>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = &unk_1EF57D320;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_3,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_3>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = &unk_1EF57D320;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_3,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_3>,void ()(ggl::Texture2DLoadItem const&)>::~__func(void *a1)
{
  *a1 = &unk_1EF57D320;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_3,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_3>,void ()(ggl::Texture2DLoadItem const&)>::~__func(void *a1)
{
  *a1 = &unk_1EF57D320;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_2,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_2>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57D2D8;
}

void *std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_2,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_2>,void ()(ggl::Texture2DLoadItem const&)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF57D2D8;
  return result;
}

void std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_2,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_2>,void ()(ggl::Texture2DLoadItem const&)>::~__func()
{
}

void std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_1,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_1>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57D290;
}

void *std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_1,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_1>,void ()(ggl::Texture2DLoadItem const&)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF57D290;
  return result;
}

void std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_1,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_1>,void ()(ggl::Texture2DLoadItem const&)>::~__func()
{
}

uint64_t std::__split_buffer<ggl::Texture2DLoadItem>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 80;
    uint64_t v4 = *(void *)(i - 8);
    if (v4 == i - 32)
    {
      (*(void (**)(uint64_t))(*(void *)(i - 32) + 32))(i - 32);
      if (*(unsigned char *)(i - 60)) {
        goto LABEL_8;
      }
    }
    else
    {
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
      }
      if (*(unsigned char *)(i - 60)) {
LABEL_8:
      }
        *(unsigned char *)(i - 60) = 0;
    }
    if (*(unsigned char *)(i - 64)) {
      *(unsigned char *)(i - 64) = 0;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_0,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_0>,void ()(ggl::Texture2DLoadItem const&)>::operator()(uint64_t a1, uint64_t *a2)
{
  CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 8), 1uLL);
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 8));
  uint64_t result = *a2;
  if (*a2)
  {
    unsigned int v5 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v5();
  }
  return result;
}

uint64_t std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_0,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_0>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1EF57D248;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_0,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_0>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_1EF57D248;
  result[1] = v3;
  return result;
}

void std::__function::__func<altitude::TextureMapLoadJob::processImages(void)::$_0,std::allocator<altitude::TextureMapLoadJob::processImages(void)::$_0>,void ()(ggl::Texture2DLoadItem const&)>::~__func()
{
}

uint64_t altitude::HwScalerThumbJob::jobStep(altitude::HwScalerThumbJob *this)
{
  int v2 = *((_DWORD *)this + 54);
  if (md::HardwareScaler::instance(md::HardwareScalerOperation,md::HardwareScalerFilterType)::onceToken != -1) {
    dispatch_once(&md::HardwareScaler::instance(md::HardwareScalerOperation,md::HardwareScalerFilterType)::onceToken, &__block_literal_global_39586);
  }
  *(void *)&long long v11 = MEMORY[0x1E4F143A8];
  *((void *)&v11 + 1) = 3221225472;
  uint64_t v12 = ___ZN2md14HardwareScaler8instanceENS_23HardwareScalerOperationENS_24HardwareScalerFilterTypeE_block_invoke_3;
  int v13 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v14 = 0x100000001;
  if (md::HardwareScaler::instance(md::HardwareScalerOperation,md::HardwareScalerFilterType)::once != -1) {
    dispatch_once(&md::HardwareScaler::instance(md::HardwareScalerOperation,md::HardwareScalerFilterType)::once, &v11);
  }
  int v3 = md::HardwareScaler::instance(md::HardwareScalerOperation,md::HardwareScalerFilterType)::scaler;
  if (!v2)
  {
    IOSurface = CVPixelBufferGetIOSurface(**((CVPixelBufferRef **)this + 22));
    int v8 = v3;
    goto LABEL_9;
  }
  if (v2 == 1)
  {
    long long v11 = xmmword_1A28FF120;
    uint64_t v4 = CVPixelBufferGetIOSurface(**((CVPixelBufferRef **)this + 22));
    md::HardwareScaler::scaleSync(v3, v4);
    long long v11 = xmmword_1A28FF130;
    unsigned int v5 = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)(*((void *)this + 22) + 8));
    md::HardwareScaler::scaleSync(v3, v5);
    long long v11 = xmmword_1A28FF140;
    unint64_t v6 = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)(*((void *)this + 22) + 16));
    md::HardwareScaler::scaleSync(v3, v6);
    long long v11 = xmmword_1A28FF150;
    IOSurface = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)(*((void *)this + 22) + 24));
    int v8 = v3;
LABEL_9:
    md::HardwareScaler::scaleSync(v8, IOSurface);
  }
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 26);
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
  *((_DWORD *)this + 40) |= 1u;
  return pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
}

void altitude::HwScalerThumbJob::~HwScalerThumbJob(altitude::HwScalerThumbJob *this)
{
  *(void *)this = &unk_1EF569550;
  int v2 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  int v3 = (CVPixelBufferRef *)*((void *)this + 22);
  uint64_t v4 = (CVPixelBufferRef *)*((void *)this + 23);
  if (v3 != v4)
  {
    do
      CVPixelBufferRelease(*v3++);
    while (v3 != v4);
    int v3 = (CVPixelBufferRef *)*((void *)this + 22);
  }
  if (v3)
  {
    *((void *)this + 23) = v3;
    operator delete(v3);
  }
  karo::Job::~Job(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  CVPixelBufferRef *v3;
  CVPixelBufferRef *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF569550;
  int v2 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  int v3 = (CVPixelBufferRef *)*((void *)this + 22);
  uint64_t v4 = (CVPixelBufferRef *)*((void *)this + 23);
  if (v3 != v4)
  {
    do
      CVPixelBufferRelease(*v3++);
    while (v3 != v4);
    int v3 = (CVPixelBufferRef *)*((void *)this + 22);
  }
  if (v3)
  {
    *((void *)this + 23) = v3;
    operator delete(v3);
  }
  karo::Job::~Job(this);
}

void sub_1A23DCEAC(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)(v1 + 176);
  if (v3)
  {
    *(void *)(v1 + 184) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A23DCF9C(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)(v1 + 176);
  if (v3)
  {
    *(void *)(v1 + 184) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_emplace<altitude::HwScalerThumbJob>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<altitude::HwScalerThumbJob>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58ACB8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<altitude::HwScalerThumbJob>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58ACB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<altitude::PooledIOSurface>::__on_zero_shared(uint64_t a1)
{
}

void std::__shared_ptr_emplace<altitude::PooledIOSurface>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AC48;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<altitude::PooledIOSurface>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AC48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__function::__func<altitude::TextureMapLoadJob::mipmapIntoMipChain(void)::$_0,std::allocator<altitude::TextureMapLoadJob::mipmapIntoMipChain(void)::$_0>,BOOL ()(void)>::operator()(uint64_t a1)
{
  altitude::MipChain::transferData(*(altitude::MipChain **)(a1 + 8));
  altitude::createCpuMipLevels(*(void *)(a1 + 8), v2);
  return 1;
}

void altitude::MipChain::transferData(altitude::MipChain *this)
{
  if (*(_DWORD *)this == 14) {
    int v2 = 2;
  }
  else {
    int v2 = 4;
  }
  IOSurfaceLock(*(IOSurfaceRef *)(*((void *)this + 1) + 16), 1u, 0);
  int v3 = *(void **)(*(void *)(*((void *)this + 8) + 24) + 8);
  BaseAddress = IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(*((void *)this + 1) + 16));
  memcpy(v3, BaseAddress, (v2 << 16));
  IOSurfaceUnlock(*(IOSurfaceRef *)(*((void *)this + 1) + 16), 1u, 0);
  IOSurfaceLock(*(IOSurfaceRef *)(*((void *)this + 3) + 16), 1u, 0);
  unsigned int v5 = *(void **)(*(void *)(*((void *)this + 8) + 24) + 16);
  unint64_t v6 = IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(*((void *)this + 3) + 16));
  memcpy(v5, v6, (v2 << 14));
  IOSurfaceUnlock(*(IOSurfaceRef *)(*((void *)this + 3) + 16), 1u, 0);
  IOSurfaceLock(*(IOSurfaceRef *)(*((void *)this + 5) + 16), 1u, 0);
  int v7 = *(void **)(*(void *)(*((void *)this + 8) + 24) + 24);
  int v8 = IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(*((void *)this + 5) + 16));
  memcpy(v7, v8, (v2 << 12));
  IOSurfaceUnlock(*(IOSurfaceRef *)(*((void *)this + 5) + 16), 1u, 0);
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 2);
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 4);
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  long long v11 = (std::__shared_weak_count *)*((void *)this + 6);
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
}

uint64_t altitude::createCpuMipLevels(uint64_t this, altitude::MipChain *a2)
{
  uint64_t v2 = this;
  uint64_t v3 = 3;
  int8x16_t v111 = (int8x16_t)vdupq_n_s32(0x3FC00u);
  int8x16_t v112 = (int8x16_t)vdupq_n_s32(0x3FC0000u);
  int8x16_t v114 = (int8x16_t)vdupq_n_s32(0x1F80u);
  int8x16_t v115 = (int8x16_t)vdupq_n_s32(0x7E0u);
  int8x16_t v113 = (int8x16_t)vdupq_n_s32(0x3E000u);
  do
  {
    unsigned int v5 = 0x200u >> v3;
    if (*(_DWORD *)v2 == 4)
    {
      uint64_t v62 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 64) + 16))(*(void *)(v2 + 64), v3);
      uint64_t v4 = (v3 + 1);
      this = (*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 64) + 16))(*(void *)(v2 + 64), v4);
      if (v3 > 8) {
        goto LABEL_3;
      }
      unsigned int v63 = 0;
      unsigned int v64 = 0;
      uint64_t v65 = 0;
      uint64_t v66 = 0x100u >> v3;
      if (v66 <= 1) {
        uint64_t v67 = 1;
      }
      else {
        uint64_t v67 = v66;
      }
      int v68 = 2 * v5;
      uint64_t v69 = v62 + 8 * v67;
      uint64_t v70 = v69 - 4;
      unsigned int v71 = 2 * (v67 - 1);
      v72.i64[0] = 0xFF000000FF000000;
      v72.i64[1] = 0xFF000000FF000000;
      v73.i64[0] = 0xFF000000FF0000;
      v73.i64[1] = 0xFF000000FF0000;
      v74.i64[0] = 0xFF000000FF00;
      v74.i64[1] = 0xFF000000FF00;
      v75.i64[0] = 0xFF000000FFLL;
      v75.i64[1] = 0xFF000000FFLL;
      v76.i64[0] = 0xFC000000FC000000;
      v76.i64[1] = 0xFC000000FC000000;
      while (1)
      {
        if (v67 >= 0xC)
        {
          uint64_t v77 = 0;
          int v85 = v68 * v65;
          BOOL v86 = __CFADD__(v66 * v65, v67 - 1);
          BOOL v87 = __CFADD__(v85, v71);
          BOOL v88 = __CFADD__(v68 * v65 + v5, v71);
          if (!__CFADD__(v5 + 1 + v68 * v65, v71) && !v88 && (v85 ^ 0xFFFFFFFE) >= v71 && !v86 && !v87)
          {
            uint64_t v77 = 0;
            uint64_t v89 = 4 * (v66 * v65);
            unint64_t v90 = this + v89;
            unint64_t v91 = this + 4 * v67 + v89;
            uint64_t v92 = 4 * (v5 + 1 + v68 * v65);
            unint64_t v93 = v62 + v92;
            unint64_t v94 = v70 + v92;
            uint64_t v95 = 4 * (v68 * v65 + v5);
            unint64_t v96 = v62 + v95;
            uint64_t v97 = 4 * (v68 * v65);
            BOOL v41 = v90 >= v70 + v95;
            unint64_t v98 = v62 + v97;
            unint64_t v99 = v69 + v97;
            BOOL v100 = v41 || v96 >= v91;
            BOOL v101 = !v100;
            BOOL v102 = v90 >= v99 || v98 >= v91;
            BOOL v103 = !v102;
            if ((v93 >= v91 || v90 >= v94) && !v101 && !v103)
            {
              unsigned int v105 = v63;
              unsigned int v106 = v64;
              uint64_t v107 = v67 & 0x1FC;
              do
              {
                __double2 v108 = (const float *)(v62 + 4 * v105);
                float32x4x2_t v117 = vld2q_f32(v108);
                v109.i32[0] = *(_DWORD *)(v62 + 4 * (v5 + v105));
                v109.i32[1] = *(_DWORD *)(v62 + 4 * (v5 + v105 + 2));
                v109.i32[2] = *(_DWORD *)(v62 + 4 * (v5 + v105 + 4));
                v109.i32[3] = *(_DWORD *)(v62 + 4 * (v5 + v105 + 6));
                v110.i32[0] = *(_DWORD *)(v62 + 4 * (v5 + v105 + 1));
                v110.i32[1] = *(_DWORD *)(v62 + 4 * (v5 + v105 + 3));
                v110.i32[2] = *(_DWORD *)(v62 + 4 * (v5 + v105 + 5));
                v110.i32[3] = *(_DWORD *)(v62 + 4 * (v5 + v105 + 7));
                *(uint32x4_t *)(this + 4 * v106) = vshrq_n_u32((uint32x4_t)vorrq_s8(vorrq_s8((int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)vandq_s8((int8x16_t)v117.val[1], v75), (int32x4_t)vandq_s8((int8x16_t)v117.val[0], v75)), (int32x4_t)vandq_s8(v109, v75)), (int32x4_t)vandq_s8(v110, v75)), vandq_s8((int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)vandq_s8((int8x16_t)v117.val[1], v73), (int32x4_t)vandq_s8((int8x16_t)v117.val[0], v73)),
                                                                                        (int32x4_t)vandq_s8(v109, v73)),
                                                                                      (int32x4_t)vandq_s8(v110, v73)),
                                                                         v112)),
                                                                     vorrq_s8(vandq_s8((int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)v117.val[1], (int32x4_t)vandq_s8((int8x16_t)v117.val[0], v72)), (int32x4_t)vandq_s8(v109, v72)), (int32x4_t)vandq_s8(v110, v72)), v76), vandq_s8((int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)vandq_s8((int8x16_t)v117.val[1], v74), (int32x4_t)vandq_s8((int8x16_t)v117.val[0], v74)), (int32x4_t)vandq_s8(v109, v74)), (int32x4_t)vandq_s8(v110, v74)), v111))), 2uLL);
                v106 += 4;
                v105 += 8;
                v107 -= 4;
              }
              while (v107);
              uint64_t v77 = v67 & 0x1FC;
              if (v77 == v67) {
                goto LABEL_60;
              }
            }
          }
        }
        else
        {
          uint64_t v77 = 0;
        }
        uint64_t v78 = v67 - v77;
        unsigned int v79 = v64 + v77;
        unsigned int v80 = v63 + 2 * v77;
        do
        {
          int v81 = *(_DWORD *)(v62 + 4 * v80);
          int v82 = *(_DWORD *)(v62 + 4 * (v80 + 1));
          int v83 = *(_DWORD *)(v62 + 4 * (v5 + v80));
          int v84 = *(_DWORD *)(v62 + 4 * (v5 + v80 + 1));
          *(_DWORD *)(this + 4 * v79++) = ((v82
                                            + v81
                                            + v83
                                            + v84) | ((v82 & 0xFF0000)
                                                                     + (v81 & 0xFF0000)
                                                                     + (v83 & 0xFF0000)
                                                                     + (v84 & 0xFF0000)) & 0x3FC0000 | (v82 + (v81 & 0xFF000000) + (v83 & 0xFF000000) + (v84 & 0xFF000000)) & 0xFC000000 | ((v82 & 0xFF00) + (v81 & 0xFF00) + (v83 & 0xFF00) + (v84 & 0xFF00)) & 0x3FC00) >> 2;
          v80 += 2;
          --v78;
        }
        while (v78);
LABEL_60:
        ++v65;
        v64 += v66;
        v63 += v68;
        if (v65 == v66) {
          goto LABEL_3;
        }
      }
    }
    if (*(_DWORD *)v2 == 14)
    {
      uint64_t v6 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 64) + 16))(*(void *)(v2 + 64), v3);
      uint64_t v4 = (v3 + 1);
      this = (*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 64) + 16))(*(void *)(v2 + 64), v4);
      v7.i64[0] = 0x1F0000001FLL;
      v7.i64[1] = 0x1F0000001FLL;
      v8.i64[0] = 0xF8000000F800;
      v8.i64[1] = 0xF8000000F800;
      unsigned int v9 = 0;
      unsigned int v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = 0x100u >> v3;
      unint64_t v13 = v12 - 1;
      int v14 = 2 * v5;
      uint64_t v15 = v6 + 4 * v12;
      uint64_t v16 = v15 - 2;
      unsigned int v17 = 2 * (v12 - 1);
      while (1)
      {
        if (v3 <= 4)
        {
          uint64_t v18 = 0;
          int v26 = v14 * v11;
          BOOL v27 = __CFADD__(v12 * v11, v13);
          BOOL v28 = __CFADD__(v26, v17);
          BOOL v29 = __CFADD__(v5 + v14 * v11, v17);
          if (!__CFADD__(v5 + 1 + v14 * v11, v17) && !v29 && (v26 ^ 0xFFFFFFFE) >= v17 && !v27 && !v28 && !(v13 >> 31))
          {
            uint64_t v18 = 0;
            uint64_t v30 = 2 * (v12 * v11);
            unint64_t v31 = this + v30;
            unint64_t v32 = this + 2 * v12 + v30;
            uint64_t v33 = 2 * (v5 + 1 + v14 * v11);
            unint64_t v34 = v6 + v33;
            unint64_t v35 = v16 + v33;
            uint64_t v36 = 2 * (v5 + v14 * v11);
            unint64_t v37 = v6 + v36;
            uint64_t v38 = 2 * (v14 * v11);
            BOOL v41 = v31 >= v16 + v36;
            unint64_t v39 = v6 + v38;
            unint64_t v40 = v15 + v38;
            BOOL v41 = v41 || v37 >= v32;
            BOOL v42 = !v41;
            BOOL v43 = v31 >= v40 || v39 >= v32;
            BOOL v44 = !v43;
            if ((v34 >= v32 || v31 >= v35) && !v42 && !v44)
            {
              unsigned int v46 = v9;
              unsigned int v47 = v10;
              uint64_t v48 = v12 & 0x1F8;
              do
              {
                int v49 = (const __int16 *)(v6 + 2 * v46);
                int16x8x2_t v116 = vld2q_s16(v49);
                v50.i16[0] = *(_WORD *)(v6 + 2 * (v5 + v46));
                v50.i16[1] = *(_WORD *)(v6 + 2 * (v5 + v46 + 2));
                v51.i16[0] = *(_WORD *)(v6 + 2 * (v5 + v46 + 8));
                v50.i16[2] = *(_WORD *)(v6 + 2 * (v5 + v46 + 4));
                v51.i16[1] = *(_WORD *)(v6 + 2 * (v5 + v46 + 10));
                v51.i16[2] = *(_WORD *)(v6 + 2 * (v5 + v46 + 12));
                v50.i16[3] = *(_WORD *)(v6 + 2 * (v5 + v46 + 6));
                v51.i16[3] = *(_WORD *)(v6 + 2 * (v5 + v46 + 14));
                int8x16_t v52 = (int8x16_t)vmovl_high_u16((uint16x8_t)v116.val[0]);
                int8x16_t v53 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v116.val[0].i8);
                v54.i16[0] = *(_WORD *)(v6 + 2 * (v5 + v46 + 9));
                int8x16_t v55 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v116.val[1].i8);
                v54.i16[1] = *(_WORD *)(v6 + 2 * (v5 + v46 + 11));
                v54.i16[2] = *(_WORD *)(v6 + 2 * (v5 + v46 + 13));
                int8x16_t v56 = (int8x16_t)vmovl_high_u16((uint16x8_t)v116.val[1]);
                v54.i16[3] = *(_WORD *)(v6 + 2 * (v5 + v46 + 15));
                v57.i16[0] = *(_WORD *)(v6 + 2 * (v5 + v46 + 1));
                int8x16_t v58 = (int8x16_t)vmovl_u16(v50);
                v57.i16[1] = *(_WORD *)(v6 + 2 * (v5 + v46 + 3));
                v57.i16[2] = *(_WORD *)(v6 + 2 * (v5 + v46 + 5));
                int8x16_t v59 = (int8x16_t)vmovl_u16(v51);
                int8x16_t v60 = (int8x16_t)vmovl_u16(v54);
                v57.i16[3] = *(_WORD *)(v6 + 2 * (v5 + v46 + 7));
                int8x16_t v61 = (int8x16_t)vmovl_u16(v57);
                *(int16x8_t *)(this + 2 * v47) = vshrn_high_n_s32(vshrn_n_s32((int32x4_t)vorrq_s8(vorrq_s8(vandq_s8((int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)vandq_s8(v55, v115), (int32x4_t)vandq_s8(v53, v115)), (int32x4_t)vandq_s8(v58, v115)), (int32x4_t)vandq_s8(v61, v115)), v114), (int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)vandq_s8(v55, v7), (int32x4_t)vandq_s8(v53, v7)), (int32x4_t)vandq_s8(v58, v7)), (int32x4_t)vandq_s8(v61, v7))),
                                                                    vandq_s8((int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)vaddw_u16((uint32x4_t)vandq_s8(v53, v8), *(uint16x4_t *)v116.val[1].i8), (int32x4_t)vandq_s8(v58, v8)), (int32x4_t)vandq_s8(v61, v8)), v113)), 2uLL), (int32x4_t)vorrq_s8(vorrq_s8(vandq_s8((int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)vandq_s8(v56, v115), (int32x4_t)vandq_s8(v52, v115)), (int32x4_t)vandq_s8(v59, v115)), (int32x4_t)vandq_s8(v60, v115)),
                                                                      v114),
                                                                    (int8x16_t)vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)vandq_s8(v56, v7), (int32x4_t)vandq_s8(v52, v7)), (int32x4_t)vandq_s8(v59, v7)), (int32x4_t)vandq_s8(v60, v7))), vandq_s8((int8x16_t)vaddq_s32(vaddq_s32((int32x4_t)vaddw_high_u16((uint32x4_t)vandq_s8(v52, v8), (uint16x8_t)v116.val[1]), (int32x4_t)vandq_s8(v59, v8)), (int32x4_t)vandq_s8(v60, v8)), v113)), 2uLL);
                v47 += 8;
                v46 += 16;
                v48 -= 8;
              }
              while (v48);
              uint64_t v18 = v12 & 0x1F8;
              if (v18 == v12) {
                goto LABEL_11;
              }
            }
          }
        }
        else
        {
          uint64_t v18 = 0;
        }
        uint64_t v19 = v12 - v18;
        unsigned int v20 = v10 + v18;
        unsigned int v21 = v9 + 2 * v18;
        do
        {
          __int16 v22 = *(_WORD *)(v6 + 2 * v21);
          int v23 = *(unsigned __int16 *)(v6 + 2 * (v21 + 1));
          __int16 v24 = *(_WORD *)(v6 + 2 * (v5 + v21));
          __int16 v25 = *(_WORD *)(v6 + 2 * (v5 + v21 + 1));
          *(_WORD *)(this + 2 * v20++) = (((v23 & 0x7E0) + (v22 & 0x7E0) + (v24 & 0x7E0) + (v25 & 0x7E0)) & 0x1F80 | ((v23 & 0x1F) + (v22 & 0x1F) + (v24 & 0x1F) + (v25 & 0x1F)) | ((v22 & 0xF800) + v23 + (v24 & 0xF800) + (v25 & 0xF800)) & 0x3E000u) >> 2;
          v21 += 2;
          --v19;
        }
        while (v19);
LABEL_11:
        ++v11;
        v10 += v12;
        v9 += v14;
        if (v11 == v12) {
          goto LABEL_3;
        }
      }
    }
    uint64_t v4 = (v3 + 1);
LABEL_3:
    uint64_t v3 = v4;
  }
  while (v4 != 9);
  return this;
}

void std::__function::__func<altitude::TextureMapLoadJob::mipmapIntoMipChain(void)::$_0,std::allocator<altitude::TextureMapLoadJob::mipmapIntoMipChain(void)::$_0>,BOOL ()(void)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void std::__function::__func<altitude::TextureMapLoadJob::mipmapIntoMipChain(void)::$_0,std::allocator<altitude::TextureMapLoadJob::mipmapIntoMipChain(void)::$_0>,BOOL ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__function::__func<altitude::TextureMapLoadJob::mipmapIntoMipChain(void)::$_0,std::allocator<altitude::TextureMapLoadJob::mipmapIntoMipChain(void)::$_0>,BOOL ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = &unk_1EF57D3B0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *std::__function::__func<altitude::TextureMapLoadJob::mipmapIntoMipChain(void)::$_0,std::allocator<altitude::TextureMapLoadJob::mipmapIntoMipChain(void)::$_0>,BOOL ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = &unk_1EF57D3B0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<altitude::TextureMapLoadJob::mipmapIntoMipChain(void)::$_0,std::allocator<altitude::TextureMapLoadJob::mipmapIntoMipChain(void)::$_0>,BOOL ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF57D3B0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<altitude::TextureMapLoadJob::mipmapIntoMipChain(void)::$_0,std::allocator<altitude::TextureMapLoadJob::mipmapIntoMipChain(void)::$_0>,BOOL ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF57D3B0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<altitude::util::GenericJob>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<altitude::util::GenericJob>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AF90;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<altitude::util::GenericJob>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AF90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t altitude::HwScalerMipLevelsJob::jobStep(altitude::HwScalerMipLevelsJob *this)
{
  altitude::createHWScalerMipLevels((uint64_t)this + 176, *((void *)this + 25), *((_DWORD *)this + 54));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 26);
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
  *((_DWORD *)this + 40) |= 1u;
  uint64_t v3 = (pthread_mutex_t *)*((void *)this + 19);
  return pthread_mutex_unlock(v3);
}

uint64_t altitude::createHWScalerMipLevels(uint64_t a1, uint64_t a2, int a3)
{
  if (md::HardwareScaler::instance(md::HardwareScalerOperation,md::HardwareScalerFilterType)::onceToken != -1) {
    dispatch_once(&md::HardwareScaler::instance(md::HardwareScalerOperation,md::HardwareScalerFilterType)::onceToken, &__block_literal_global_39586);
  }
  blocunint64_t k = MEMORY[0x1E4F143A8];
  uint64_t v16 = 3221225472;
  unsigned int v17 = ___ZN2md14HardwareScaler8instanceENS_23HardwareScalerOperationENS_24HardwareScalerFilterTypeE_block_invoke_2;
  uint64_t v18 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v19 = 0x100000000;
  if (md::HardwareScaler::instance(md::HardwareScalerOperation,md::HardwareScalerFilterType)::once != -1) {
    dispatch_once(&md::HardwareScaler::instance(md::HardwareScalerOperation,md::HardwareScalerFilterType)::once, &block);
  }
  int v6 = md::HardwareScaler::instance(md::HardwareScalerOperation,md::HardwareScalerFilterType)::scaler;
  if (a3)
  {
    if (a3 == 1)
    {
      int8x16_t v7 = *(CVPixelBufferRef **)a1;
      if (*(void *)(a1 + 8) != *(void *)a1)
      {
        int v8 = 0;
        int v9 = 0;
        unint64_t v10 = 0;
        unsigned int v11 = 1;
        do
        {
          LODWORD(block) = v8 & 0xFFFFFF80;
          HIDWORD(block) = v9 & 0x80;
          LODWORD(v16) = (v8 & 0xFFFFFF80) + 128;
          HIDWORD(v16) = HIDWORD(block) + 128;
          IOSurface = CVPixelBufferGetIOSurface(v7[v10]);
          md::HardwareScaler::scaleSync(v6, IOSurface);
          unint64_t v10 = v11;
          int8x16_t v7 = *(CVPixelBufferRef **)a1;
          ++v11;
          v9 += 128;
          v8 += 64;
        }
        while (v10 < (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
      }
    }
  }
  else
  {
    unint64_t v13 = CVPixelBufferGetIOSurface(**(CVPixelBufferRef **)a1);
    md::HardwareScaler::scaleSync(v6, v13);
  }
  md::HardwareScaler::scaleSync(v6, *(IOSurfaceRef *)(*(void *)(a2 + 8) + 16));
  return md::HardwareScaler::scaleSync(v6, *(IOSurfaceRef *)(*(void *)(a2 + 24) + 16));
}

void altitude::HwScalerMipLevelsJob::~HwScalerMipLevelsJob(altitude::HwScalerMipLevelsJob *this)
{
  *(void *)this = &unk_1EF56A430;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (CVPixelBufferRef *)*((void *)this + 22);
  uint64_t v4 = (CVPixelBufferRef *)*((void *)this + 23);
  if (v3 != v4)
  {
    do
      CVPixelBufferRelease(*v3++);
    while (v3 != v4);
    uint64_t v3 = (CVPixelBufferRef *)*((void *)this + 22);
  }
  if (v3)
  {
    *((void *)this + 23) = v3;
    operator delete(v3);
  }
  karo::Job::~Job(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  CVPixelBufferRef *v3;
  CVPixelBufferRef *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF56A430;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (CVPixelBufferRef *)*((void *)this + 22);
  uint64_t v4 = (CVPixelBufferRef *)*((void *)this + 23);
  if (v3 != v4)
  {
    do
      CVPixelBufferRelease(*v3++);
    while (v3 != v4);
    uint64_t v3 = (CVPixelBufferRef *)*((void *)this + 22);
  }
  if (v3)
  {
    *((void *)this + 23) = v3;
    operator delete(v3);
  }
  karo::Job::~Job(this);
}

void sub_1A23DE1DC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 + 176);
  if (v3)
  {
    *(void *)(v1 + 184) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A23DE2CC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 + 176);
  if (v3)
  {
    *(void *)(v1 + 184) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_emplace<altitude::HwScalerMipLevelsJob>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<altitude::HwScalerMipLevelsJob>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AE40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<altitude::HwScalerMipLevelsJob>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AE40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t altitude::MipChain::MipData::mipData(altitude::MipChain::MipData *this, unsigned int a2)
{
  return *(void *)(*((void *)this + 3) + 8 * a2);
}

void altitude::MipChain::MipData::~MipData(altitude::MipChain::MipData *this)
{
  *(void *)this = &unk_1EF56B558;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;

  *(void *)this = &unk_1EF56B558;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<altitude::MipChain>::__on_zero_shared(uint64_t a1)
{
  free(*(void **)(a1 + 80));
  uint64_t v2 = *(void *)(a1 + 88);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 96);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    unsigned int v5 = *(std::__shared_weak_count **)(a1 + 56);
    if (!v5) {
      goto LABEL_11;
    }
  }
  else
  {
    unsigned int v5 = *(std::__shared_weak_count **)(a1 + 56);
    if (!v5) {
      goto LABEL_11;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_11:
  int v6 = *(std::__shared_weak_count **)(a1 + 40);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
}

void std::__shared_ptr_emplace<altitude::MipChain>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B038;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<altitude::MipChain>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B038;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t altitude::TextureMapLoadJob::cancel(altitude::TextureMapLoadJob *this)
{
  uint64_t v2 = *((void *)this + 24);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
  }
  uint64_t v3 = *((void *)this + 26);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
  }
  return karo::Job::cancel(this);
}

void altitude::TextureMapLoadJob::~TextureMapLoadJob(altitude::TextureMapLoadJob *this)
{
  altitude::TextureMapLoadJob::~TextureMapLoadJob(this);
  JUMPOUT(0x1A6239270);
}

{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::mutex *v9;
  std::__shared_weak_count *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  char *v18;
  char *v19;
  void *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;
  void *v27;
  std::__shared_weak_count *v28;
  std::__shared_weak_count *v29;
  std::__shared_weak_count *v30;
  CVPixelBufferRef *v31;
  CVPixelBufferRef *v32;
  uint64_t vars8;

  *(void *)this = &unk_1EF569DC0;
  uint64_t v2 = (void **)((char *)this + 288);
  uint64_t v3 = *((void *)this + 36);
  uint64_t v4 = *((void *)this + 37);
  while (v3 != v4)
  {
    unsigned int v5 = *(void *)(v3 + 72);
    if (v5) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 48))(v5, v3);
    }
    v3 += 80;
  }
  int v6 = *((void *)this + 39);
  int8x16_t v7 = *((void *)this + 40);
  while (v6 != v7)
  {
    int v8 = *(void *)(v6 + 72);
    if (v8) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48))(v8, v6);
    }
    v6 += 80;
  }
  if (*((void *)this + 36) == *((void *)this + 37))
  {
    unint64_t v31 = (CVPixelBufferRef *)*((void *)this + 29);
    unint64_t v32 = (CVPixelBufferRef *)*((void *)this + 30);
    while (v31 != v32)
    {
      if (*v31) {
        CVPixelBufferRelease(*v31);
      }
      ++v31;
    }
  }
  int v9 = (std::mutex *)*((void *)this + 44);
  if (v9)
  {
    md::HardwareVideoDecodingSession::~HardwareVideoDecodingSession(v9);
    MEMORY[0x1A6239270]();
  }
  unint64_t v10 = (std::__shared_weak_count *)*((void *)this + 43);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  unsigned int v11 = (void *)*((void *)this + 39);
  if (!v11) {
    goto LABEL_32;
  }
  uint64_t v12 = (void *)*((void *)this + 40);
  unint64_t v13 = (void *)*((void *)this + 39);
  if (v12 == v11) {
    goto LABEL_31;
  }
  int v14 = v12 - 4;
  uint64_t v15 = v12 - 4;
  do
  {
    unsigned int v17 = (void *)v15[3];
    if (v15 == v17)
    {
      (*(void (**)(void *))(*v15 + 32))(v15);
      if (*((unsigned char *)v15 - 28)) {
        goto LABEL_25;
      }
    }
    else
    {
      if (v17) {
        (*(void (**)(void *))(*v17 + 40))(v17);
      }
      if (*((unsigned char *)v15 - 28)) {
LABEL_25:
      }
        *((unsigned char *)v15 - 28) = 0;
    }
    if (*((unsigned char *)v15 - 32)) {
      *((unsigned char *)v15 - 32) = 0;
    }
    uint64_t v16 = v15 - 6;
    v15 -= 10;
    v14 -= 10;
  }
  while (v16 != v11);
  unint64_t v13 = (void *)*((void *)this + 39);
LABEL_31:
  *((void *)this + 40) = v11;
  operator delete(v13);
LABEL_32:
  uint64_t v18 = (char *)*v2;
  if (!*v2) {
    goto LABEL_47;
  }
  uint64_t v19 = (char *)*((void *)this + 37);
  unsigned int v20 = *v2;
  if (v19 == v18) {
    goto LABEL_46;
  }
  unsigned int v21 = v19 - 32;
  __int16 v22 = v19 - 32;
  while (2)
  {
    __int16 v24 = (char *)*((void *)v22 + 3);
    if (v22 == v24)
    {
      (*(void (**)(char *))(*(void *)v22 + 32))(v22);
      if (*(v22 - 28)) {
        goto LABEL_40;
      }
    }
    else
    {
      if (v24) {
        (*(void (**)(char *))(*(void *)v24 + 40))(v24);
      }
      if (*(v22 - 28)) {
LABEL_40:
      }
        *(v22 - 28) = 0;
    }
    if (*(v22 - 32)) {
      *(v22 - 32) = 0;
    }
    int v23 = v22 - 48;
    v22 -= 80;
    v21 -= 80;
    if (v23 != v18) {
      continue;
    }
    break;
  }
  unsigned int v20 = *v2;
LABEL_46:
  *((void *)this + 37) = v18;
  operator delete(v20);
LABEL_47:
  __int16 v25 = (std::__shared_weak_count *)*((void *)this + 35);
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
  int v26 = (std::__shared_weak_count *)*((void *)this + 33);
  if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  BOOL v27 = (void *)*((void *)this + 29);
  if (v27)
  {
    *((void *)this + 30) = v27;
    operator delete(v27);
  }
  BOOL v28 = (std::__shared_weak_count *)*((void *)this + 27);
  if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
  BOOL v29 = (std::__shared_weak_count *)*((void *)this + 25);
  if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  uint64_t v30 = (std::__shared_weak_count *)*((void *)this + 23);
  if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
  }
  karo::Job::~Job(this);
}

void sub_1A23DEB9C(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 336);
  std::vector<ggl::Texture2DLoadItem>::~vector[abi:nn180100]((void **)(v1 + 312));
  std::vector<ggl::Texture2DLoadItem>::~vector[abi:nn180100](v2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 272);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 256);
  uint64_t v4 = *(void **)(v1 + 232);
  if (v4)
  {
    *(void *)(v1 + 240) = v4;
    operator delete(v4);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 208);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 192);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 176);
  karo::Job::~Job((karo::Job *)v1);
  _Unwind_Resume(a1);
}

void **std::vector<ggl::Texture2DLoadItem>::~vector[abi:nn180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (!*a1) {
    return a1;
  }
  uint64_t v3 = (char *)a1[1];
  uint64_t v4 = *a1;
  if (v3 == v2) {
    goto LABEL_15;
  }
  unsigned int v5 = v3 - 32;
  int v6 = v3 - 32;
  do
  {
    int v8 = (char *)*((void *)v6 + 3);
    if (v6 == v8)
    {
      (*(void (**)(char *))(*(void *)v6 + 32))(v6);
      if (*(v6 - 28)) {
        goto LABEL_9;
      }
    }
    else
    {
      if (v8) {
        (*(void (**)(char *))(*(void *)v8 + 40))(v8);
      }
      if (*(v6 - 28)) {
LABEL_9:
      }
        *(v6 - 28) = 0;
    }
    if (*(v6 - 32)) {
      *(v6 - 32) = 0;
    }
    int8x16_t v7 = v6 - 48;
    v6 -= 80;
    v5 -= 80;
  }
  while (v7 != v2);
  uint64_t v4 = *a1;
LABEL_15:
  a1[1] = v2;
  operator delete(v4);
  return a1;
}

void altitude::TexturePager::onTileComponentDataRelease(altitude::TexturePager *this, altitude::TileComponent **a2, altitude::TileComponent *a3, uint64_t **a4)
{
  if (a2[41] == a3)
  {
    if (*((uint64_t ***)a3 + 15) != a4 && *((uint64_t ***)a3 + 26) != a4)
    {
      if ((uint64_t **)((char *)a3 + 152) != a4) {
        return;
      }
      unsigned int v5 = *a4;
      int v6 = (uint64_t *)*((void *)a3 + 20);
      if (*a4 == v6) {
        return;
      }
      while (1)
      {
        uint64_t v7 = *v5;
        int v8 = (std::__shared_weak_count *)v5[1];
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v7)
        {
          uint64_t v9 = *(void *)(v7 + 40);
          if (v9)
          {
            if (*(_DWORD *)v9 == 1)
            {
              uint64_t v15 = v9 + 8;
              int v14 = *(void **)(v9 + 8);
              if (*(void *)(v15 + 8) - (void)v14 == 64 && *v14 && v14[2] && v14[4] && v14[6])
              {
LABEL_17:
                uint64_t v12 = *((void *)this + 5);
                uint64_t v13 = *((void *)this + 6);
                if (v12 != v13)
                {
                  while (**(void **)v12 != v7)
                  {
                    v12 += 8;
                    if (v12 == v13) {
                      goto LABEL_31;
                    }
                  }
                }
                if (v12 != v13)
                {
                  uint64_t v16 = *(void **)v12;
                  int v17 = *(_DWORD *)(*(void *)v12 + 76);
                  BOOL v18 = __OFSUB__(v17--, 1);
                  *((_DWORD *)v16 + 19) = v17;
                  if ((v17 < 0) ^ v18 | (v17 == 0)) {
                    *uint64_t v16 = 0;
                  }
                }
              }
            }
            else if (!*(_DWORD *)v9)
            {
              uint64_t v11 = v9 + 8;
              unint64_t v10 = *(void **)(v9 + 8);
              if (*(void *)(v11 + 8) - (void)v10 == 16)
              {
                if (*v10) {
                  goto LABEL_17;
                }
              }
            }
          }
        }
LABEL_31:
        if (v8)
        {
          if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
        v5 += 2;
        if (v5 == v6) {
          return;
        }
      }
    }
    uint64_t v19 = a4[6];
    unsigned int v20 = a4[7];
LABEL_36:
    if (v19 == v20) {
      return;
    }
    unsigned int v21 = *(uint64_t **)(*v19 + 256);
    __int16 v22 = *(uint64_t **)(*v19 + 264);
    while (1)
    {
      if (v21 == v22)
      {
        ++v19;
        goto LABEL_36;
      }
      uint64_t v23 = *v21;
      if (*v21)
      {
        uint64_t v24 = *(void *)(v23 + 40);
        if (v24)
        {
          if (*(_DWORD *)v24 == 1)
          {
            uint64_t v30 = v24 + 8;
            BOOL v29 = *(void **)(v24 + 8);
            if (*(void *)(v30 + 8) - (void)v29 != 64 || !*v29 || !v29[2] || !v29[4] || !v29[6]) {
              goto LABEL_38;
            }
          }
          else
          {
            if (*(_DWORD *)v24) {
              goto LABEL_38;
            }
            uint64_t v26 = v24 + 8;
            __int16 v25 = *(void **)(v24 + 8);
            if (*(void *)(v26 + 8) - (void)v25 != 16 || !*v25) {
              goto LABEL_38;
            }
          }
          uint64_t v27 = *((void *)this + 5);
          uint64_t v28 = *((void *)this + 6);
          if (v27 != v28)
          {
            while (**(void **)v27 != v23)
            {
              v27 += 8;
              if (v27 == v28) {
                goto LABEL_38;
              }
            }
          }
          if (v27 != v28)
          {
            unint64_t v31 = *(void **)v27;
            int v32 = *(_DWORD *)(*(void *)v27 + 76);
            BOOL v18 = __OFSUB__(v32--, 1);
            *((_DWORD *)v31 + 19) = v32;
            if ((v32 < 0) ^ v18 | (v32 == 0)) {
              *unint64_t v31 = 0;
            }
          }
        }
      }
LABEL_38:
      ++v21;
    }
  }
}

void altitude::TexturePager::onTileComponentDataLoaded(altitude::TexturePager *this, altitude::TileComponent **a2, altitude::TileComponent *a3, uint64_t *a4)
{
  if (a2[41] == a3)
  {
    if (*((uint64_t **)a3 + 15) == a4)
    {
      uint64_t v9 = a4[6];
      uint64_t v10 = a4[7];
      while (v9 != v10)
      {
        uint64_t v11 = *(altitude::TextureMap ***)(*(void *)v9 + 256);
        uint64_t v12 = *(altitude::TextureMap ***)(*(void *)v9 + 264);
        while (v11 != v12)
        {
          uint64_t v13 = *v11++;
          altitude::TexturePager::registerTextureMap((uint64_t)this, v13);
        }
        v9 += 8;
      }
    }
    else if (*((uint64_t **)a3 + 26) == a4)
    {
      uint64_t v14 = a4[6];
      uint64_t v15 = a4[7];
      while (v14 != v15)
      {
        uint64_t v16 = *(altitude::TextureMap ***)(*(void *)v14 + 256);
        int v17 = *(altitude::TextureMap ***)(*(void *)v14 + 264);
        while (v16 != v17)
        {
          BOOL v18 = *v16++;
          altitude::TexturePager::registerTextureMap((uint64_t)this, v18);
        }
        v14 += 8;
      }
    }
    else if ((uint64_t *)((char *)a3 + 152) == a4)
    {
      uint64_t v5 = *a4;
      uint64_t v6 = *((void *)a3 + 20);
      if (*a4 != v6)
      {
        do
        {
          uint64_t v7 = *(altitude::TextureMap **)v5;
          int v8 = *(std::__shared_weak_count **)(v5 + 8);
          if (v8) {
            atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          altitude::TexturePager::registerTextureMap((uint64_t)this, v7);
          if (v8)
          {
            if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
              std::__shared_weak_count::__release_weak(v8);
            }
          }
          v5 += 16;
        }
        while (v5 != v6);
      }
    }
  }
}

void sub_1A23DF0F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t altitude::TexturePager::registerTextureMap(uint64_t this, altitude::TextureMap *a2)
{
  if (a2)
  {
    uint64_t v2 = *((void *)a2 + 5);
    if (v2)
    {
      if (*(_DWORD *)v2 == 1)
      {
        uint64_t v8 = v2 + 8;
        uint64_t v7 = *(void **)(v2 + 8);
        if (*(void *)(v8 + 8) - (void)v7 != 64 || !*v7 || !v7[2] || !v7[4] || !v7[6]) {
          return this;
        }
      }
      else
      {
        if (*(_DWORD *)v2) {
          return this;
        }
        uint64_t v4 = v2 + 8;
        uint64_t v3 = *(void **)(v2 + 8);
        if (*(void *)(v4 + 8) - (void)v3 != 16 || !*v3) {
          return this;
        }
      }
      if (*((void *)a2 + 3))
      {
        uint64_t v5 = *(void *)(this + 40);
        uint64_t v6 = *(void *)(this + 48);
        if (v5 != v6)
        {
          while (**(altitude::TextureMap ***)v5 != a2)
          {
            v5 += 8;
            if (v5 == v6) {
              goto LABEL_20;
            }
          }
        }
        if (v5 == v6) {
LABEL_20:
        }
          operator new();
        ++*(_DWORD *)(*(void *)v5 + 76);
      }
    }
  }
  return this;
}

void altitude::TexturePager::~TexturePager(altitude::TexturePager *this)
{
  altitude::TexturePager::~TexturePager(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  CVPixelBufferRef *v7;
  CVPixelBufferRef *v8;
  std::__shared_weak_count *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  std::unique_lock<std::mutex> __lk;
  std::mutex v22;
  uint64_t v23;

  uint64_t v23 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1EF568AC0;
  altitude::TileManager::unregisterTileListener(*((void *)this + 2), (uint64_t)this);
  v22.__m_.__sig = 850045863;
  memset(v22.__m_.__opaque, 0, sizeof(v22.__m_.__opaque));
  __lk.__m_ = &v22;
  __lk.__owns_ = 1;
  std::mutex::lock(&v22);
  while (atomic_load((unsigned int *)this + 80))
    std::condition_variable::wait((std::condition_variable *)((char *)this + 328), &__lk);
  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
  std::mutex::~mutex(&v22);
  uint64_t v3 = (void *)*((void *)this + 4);
  *((void *)this + 4) = 0;

  uint64_t v4 = *((void *)this + 5);
  uint64_t v5 = *((void *)this + 6);
  if (v4 != v5)
  {
    while (1)
    {
      uint64_t v6 = *(void **)v4;
      uint64_t v7 = *(CVPixelBufferRef **)(*(void *)v4 + 16);
      uint64_t v8 = *(CVPixelBufferRef **)(*(void *)v4 + 24);
      if (v7 != v8)
      {
        do
        {
          if (*v7) {
            CVPixelBufferRelease(*v7);
          }
          ++v7;
        }
        while (v7 != v8);
        uint64_t v6 = *(void **)v4;
        if (!*(void *)v4) {
          goto LABEL_9;
        }
      }
      uint64_t v9 = (std::__shared_weak_count *)v6[8];
      if (v9)
      {
        if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
          break;
        }
      }
      uint64_t v10 = (void *)v6[2];
      if (v10) {
        goto LABEL_19;
      }
LABEL_8:
      MEMORY[0x1A6239270](v6, 0x10A0C40358E639CLL);
LABEL_9:
      v4 += 8;
      if (v4 == v5) {
        goto LABEL_22;
      }
    }
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    uint64_t v10 = (void *)v6[2];
    if (!v10) {
      goto LABEL_8;
    }
LABEL_19:
    void v6[3] = v10;
    operator delete(v10);
    goto LABEL_8;
  }
LABEL_22:
  uint64_t v11 = *((void *)this + 15);
  uint64_t v12 = *((void *)this + 16);
  if (v11 != v12)
  {
    do
    {
      uint64_t v13 = *(void *)(v11 + 8);
      if (v13) {
        (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
      }
      v11 += 16;
    }
    while (v11 != v12);
    uint64_t v11 = *((void *)this + 15);
  }
  *((void *)this + 16) = v11;
  uint64_t v14 = *((void *)this + 52);
  *((void *)this + 52) = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 51);
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  uint64_t v16 = (std::__shared_weak_count *)*((void *)this + 49);
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 328));
  std::mutex::~mutex((std::mutex *)this + 4);
  int v17 = (void *)*((void *)this + 29);
  if (v17)
  {
    *((void *)this + 30) = v17;
    operator delete(v17);
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 168));
  BOOL v18 = (void *)*((void *)this + 18);
  if (v18)
  {
    *((void *)this + 19) = v18;
    operator delete(v18);
  }
  uint64_t v19 = (void *)*((void *)this + 15);
  if (v19)
  {
    *((void *)this + 16) = v19;
    operator delete(v19);
  }
  std::deque<altitude::TexturePager::PagedTextureData *>::~deque[abi:nn180100]((uint64_t)this + 64);
  unsigned int v20 = (void *)*((void *)this + 5);
  if (v20)
  {
    *((void *)this + 6) = v20;
    operator delete(v20);
  }
}

void sub_1A23DF724(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, std::mutex *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  std::mutex::~mutex((std::mutex *)&a12);
  uint64_t v14 = *(void *)(v12 + 416);
  *(void *)(v12 + 416) = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v12 + 400);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v12 + 384);
  std::condition_variable::~condition_variable((std::condition_variable *)(v12 + 328));
  std::mutex::~mutex((std::mutex *)(v12 + 256));
  uint64_t v15 = *(void **)(v12 + 232);
  if (v15)
  {
    *(void *)(v12 + 240) = v15;
    operator delete(v15);
  }
  std::mutex::~mutex((std::mutex *)(v12 + 168));
  uint64_t v16 = *(void **)(v12 + 144);
  if (v16)
  {
    *(void *)(v12 + 152) = v16;
    operator delete(v16);
  }
  int v17 = *(void **)(v12 + 120);
  if (v17)
  {
    *(void *)(v12 + 128) = v17;
    operator delete(v17);
  }
  std::deque<altitude::TexturePager::PagedTextureData *>::~deque[abi:nn180100](v12 + 64);
  BOOL v18 = *(void **)(v12 + 40);
  if (v18)
  {
    *(void *)(v12 + 48) = v18;
    operator delete(v18);
  }

  _Unwind_Resume(a1);
}

uint64_t std::deque<altitude::TexturePager::PagedTextureData *>::~deque[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 512;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t ___ZN8altitude17TextureMapLoadJob16decodeH264ImagesERKNSt3__110shared_ptrINS_20TextureMapSourceDataEEE_block_invoke(uint64_t a1, __CVBuffer *a2, int a3)
{
  uint64_t v6 = *(void **)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 64);
  pthread_mutex_lock(*(pthread_mutex_t **)(v7 + 152));
  int v8 = *(_DWORD *)(v7 + 160);
  uint64_t result = pthread_mutex_unlock(*(pthread_mutex_t **)(v7 + 152));
  if ((v8 & 2) == 0)
  {
    if ((a3 - 1) >= 4)
    {
      if (!a3)
      {
        CVPixelBufferRetain(a2);
        *(void *)(v6[29] + 8 * *(unsigned int *)(a1 + 40)) = a2;
        uint64_t v11 = *(karo::Job **)(a1 + 64);
        return karo::Job::step(v11);
      }
    }
    else
    {
      karo::Job::step(*(karo::Job **)(a1 + 64));
      uint64_t v10 = *(uint64_t (**)(void *))(*v6 + 16);
      return v10(v6);
    }
  }
  return result;
}

void __destroy_helper_block_ea8_32c109_ZTSKZN8altitude17TextureMapLoadJob16decodeH264ImagesERKNSt3__110shared_ptrINS_20TextureMapSourceDataEEEE3__0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
    if (!v3) {
      return;
    }
  }
  else
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
    if (!v3) {
      return;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t __copy_helper_block_ea8_32c109_ZTSKZN8altitude17TextureMapLoadJob16decodeH264ImagesERKNSt3__110shared_ptrINS_20TextureMapSourceDataEEEE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 40);
  *(void *)(result + 32) = v2;
  uint64_t v3 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a2 + 72);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(result + 72) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t altitude::H264ProxyJob::jobStep(uint64_t this)
{
  if (atomic_fetch_add((atomic_uint *volatile)(this + 188), 1u) + 1 == *(_DWORD *)(this + 184))
  {
    uint64_t v1 = this;
    pthread_mutex_lock(*(pthread_mutex_t **)(this + 152));
    *(_DWORD *)(v1 + 160) |= 1u;
    uint64_t v2 = *(pthread_mutex_t **)(v1 + 152);
    return pthread_mutex_unlock(v2);
  }
  return this;
}

uint64_t altitude::H264ProxyJob::cancel(altitude::H264ProxyJob *this)
{
  uint64_t v2 = (std::mutex *)*((void *)this + 22);
  if (v2)
  {
    std::mutex::lock(*((std::mutex **)this + 22));
    for (uint64_t i = (OpaqueVTDecompressionSession **)&v2[1].__m_.__opaque[8];
          ;
          softLinkVTDecompressionSessionWaitForAsynchronousFrames(i[4]))
    {
      uint64_t i = (OpaqueVTDecompressionSession **)*i;
      if (!i) {
        break;
      }
    }
    std::mutex::unlock(v2);
  }
  karo::Job::cancel(this);
  pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
  *((_DWORD *)this + 40) |= 1u;
  uint64_t v4 = (pthread_mutex_t *)*((void *)this + 19);
  return pthread_mutex_unlock(v4);
}

void sub_1A23DFBC4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void altitude::H264ProxyJob::~H264ProxyJob(altitude::H264ProxyJob *this)
{
  karo::Job::~Job(this);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_emplace<altitude::H264ProxyJob>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<altitude::H264ProxyJob>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AAF8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<altitude::H264ProxyJob>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AAF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::function<void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<altitude::TextureMapLoadJob::decodeFigImages(std::shared_ptr<altitude::TextureMapSourceData> const&)::$_0,std::allocator<altitude::TextureMapLoadJob::decodeFigImages(std::shared_ptr<altitude::TextureMapSourceData> const&)::$_0>,void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::operator()(uint64_t a1, uint64_t a2, int *a3, __CVBuffer **a4)
{
  int v5 = *a3;
  uint64_t v6 = *a4;
  uint64_t v7 = *(void **)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 40);
  pthread_mutex_lock(*(pthread_mutex_t **)(v8 + 152));
  int v9 = *(_DWORD *)(v8 + 160) & 2;
  uint64_t result = pthread_mutex_unlock(*(pthread_mutex_t **)(v8 + 152));
  if (v5 != 1 && v9 == 0)
  {
    if (v5)
    {
      uint64_t v12 = *(karo::Job **)(a1 + 40);
      *((void *)v12 + *(unsigned int *)(a1 + 16) + 23) = 0;
      karo::Job::step(v12);
      uint64_t v13 = *(uint64_t (**)(void *))(*v7 + 16);
      return v13(v7);
    }
    else
    {
      CVPixelBufferRetain(v6);
      uint64_t v14 = 8 * *(unsigned int *)(a1 + 16);
      *(void *)(v7[29] + v14) = v6;
      uint64_t v15 = *(karo::Job **)(a1 + 40);
      *(void *)((char *)v15 + v14 + 184) = 0;
      return karo::Job::step(v15);
    }
  }
  return result;
}

void std::__function::__func<altitude::TextureMapLoadJob::decodeFigImages(std::shared_ptr<altitude::TextureMapSourceData> const&)::$_0,std::allocator<altitude::TextureMapLoadJob::decodeFigImages(std::shared_ptr<altitude::TextureMapSourceData> const&)::$_0>,void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[6];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)__p[4];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)__p[4];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  operator delete(__p);
}

void std::__function::__func<altitude::TextureMapLoadJob::decodeFigImages(std::shared_ptr<altitude::TextureMapSourceData> const&)::$_0,std::allocator<altitude::TextureMapLoadJob::decodeFigImages(std::shared_ptr<altitude::TextureMapSourceData> const&)::$_0>,void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::destroy(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
    if (!v3) {
      return;
    }
  }
  else
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
    if (!v3) {
      return;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t std::__function::__func<altitude::TextureMapLoadJob::decodeFigImages(std::shared_ptr<altitude::TextureMapSourceData> const&)::$_0,std::allocator<altitude::TextureMapLoadJob::decodeFigImages(std::shared_ptr<altitude::TextureMapSourceData> const&)::$_0>,void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF57D368;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(result + 48);
  *(void *)(a2 + 40) = *(void *)(result + 40);
  *(void *)(a2 + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *std::__function::__func<altitude::TextureMapLoadJob::decodeFigImages(std::shared_ptr<altitude::TextureMapSourceData> const&)::$_0,std::allocator<altitude::TextureMapLoadJob::decodeFigImages(std::shared_ptr<altitude::TextureMapSourceData> const&)::$_0>,void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x38uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57D368;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 32);
  result[3] = *(void *)(a1 + 24);
  result[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a1 + 48);
  result[5] = *(void *)(a1 + 40);
  result[6] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<altitude::TextureMapLoadJob::decodeFigImages(std::shared_ptr<altitude::TextureMapSourceData> const&)::$_0,std::allocator<altitude::TextureMapLoadJob::decodeFigImages(std::shared_ptr<altitude::TextureMapSourceData> const&)::$_0>,void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::~__func(void *a1)
{
  *a1 = &unk_1EF57D368;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[4];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[4];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<altitude::TextureMapLoadJob::decodeFigImages(std::shared_ptr<altitude::TextureMapSourceData> const&)::$_0,std::allocator<altitude::TextureMapLoadJob::decodeFigImages(std::shared_ptr<altitude::TextureMapSourceData> const&)::$_0>,void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::~__func(void *a1)
{
  *a1 = &unk_1EF57D368;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[4];
    if (!v3) {
      return a1;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[4];
    if (!v3) {
      return a1;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t altitude::ProxyJob::jobStep(uint64_t this)
{
  if (atomic_fetch_add((atomic_uint *volatile)(this + 216), 1u) + 1 == *(_DWORD *)(this + 176))
  {
    uint64_t v1 = this;
    pthread_mutex_lock(*(pthread_mutex_t **)(this + 152));
    *(_DWORD *)(v1 + 160) |= 1u;
    uint64_t v2 = *(pthread_mutex_t **)(v1 + 152);
    return pthread_mutex_unlock(v2);
  }
  return this;
}

uint64_t altitude::ProxyJob::cancel(pthread_mutex_t **this)
{
  unint64_t v2 = *((unsigned int *)this + 44);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = &this[i];
      uint64_t v6 = v4[23];
      uint64_t v5 = (unint64_t *)(v4 + 23);
      if (v6)
      {
        if (md::HardwareFigDecoder::instance(void)::once != -1) {
          dispatch_once(&md::HardwareFigDecoder::instance(void)::once, &__block_literal_global_25645);
        }
        unint64_t v7 = *v5;
        uint64_t v8 = *(void *)md::HardwareFigDecoder::instance(void)::_singleton;
        std::mutex::lock(*(std::mutex **)md::HardwareFigDecoder::instance(void)::_singleton);
        int8x8_t v9 = *(int8x8_t *)(v8 + 80);
        if (v9)
        {
          uint8x8_t v10 = (uint8x8_t)vcnt_s8(v9);
          v10.i16[0] = vaddlv_u8(v10);
          if (v10.u32[0] > 1uLL)
          {
            unint64_t v11 = v7;
            if (*(void *)&v9 <= v7) {
              unint64_t v11 = v7 % *(void *)&v9;
            }
          }
          else
          {
            unint64_t v11 = (*(void *)&v9 - 1) & v7;
          }
          uint64_t v12 = *(uint64_t ***)(*(void *)(v8 + 72) + 8 * v11);
          if (v12)
          {
            uint64_t v13 = *v12;
            if (*v12)
            {
              if (v10.u32[0] < 2uLL)
              {
                uint64_t v14 = *(void *)&v9 - 1;
                while (1)
                {
                  uint64_t v16 = v13[1];
                  if (v16 == v7)
                  {
                    if (v13[2] == v7) {
                      goto LABEL_29;
                    }
                  }
                  else if ((v16 & v14) != v11)
                  {
                    goto LABEL_3;
                  }
                  uint64_t v13 = (uint64_t *)*v13;
                  if (!v13) {
                    goto LABEL_3;
                  }
                }
              }
              do
              {
                unint64_t v15 = v13[1];
                if (v15 == v7)
                {
                  if (v13[2] == v7)
                  {
LABEL_29:
                    CMPhotoDecompressionContainerCancelAsyncRequest();
                    break;
                  }
                }
                else
                {
                  if (v15 >= *(void *)&v9) {
                    v15 %= *(void *)&v9;
                  }
                  if (v15 != v11) {
                    break;
                  }
                }
                uint64_t v13 = (uint64_t *)*v13;
              }
              while (v13);
            }
          }
        }
LABEL_3:
        std::mutex::unlock((std::mutex *)v8);
        unint64_t v2 = *((unsigned int *)this + 44);
      }
    }
  }
  karo::Job::cancel((karo::Job *)this);
  pthread_mutex_lock(this[19]);
  *((_DWORD *)this + 40) |= 1u;
  int v17 = this[19];
  return pthread_mutex_unlock(v17);
}

void sub_1A23E04E0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void altitude::ProxyJob::~ProxyJob(altitude::ProxyJob *this)
{
  karo::Job::~Job(this);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_emplace<altitude::ProxyJob>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<altitude::ProxyJob>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B070;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<altitude::ProxyJob>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B070;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void altitude::TextureMapLoadJob::TextureMapLoadJob(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  karo::Job::Job(a1, a2);
}

void sub_1A23E0F74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, karo::Job *a16, long long a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  unint64_t v31 = (std::__shared_weak_count *)*((void *)a16 + 43);
  if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  int v32 = (void *)*((void *)a16 + 39);
  if (!v32) {
    goto LABEL_19;
  }
  uint64_t v33 = (void *)*((void *)a16 + 40);
  unint64_t v34 = (void *)*((void *)a16 + 39);
  if (v33 == v32) {
    goto LABEL_18;
  }
  unint64_t v35 = v33 - 4;
  uint64_t v36 = v33 - 4;
  while (1)
  {
    uint64_t v38 = (void *)v36[3];
    if (v36 == v38)
    {
      (*(void (**)(void *))(*v36 + 32))(v36);
      if (!*((unsigned char *)v36 - 28)) {
        goto LABEL_13;
      }
    }
    else
    {
      if (v38) {
        (*(void (**)(void *))(*v38 + 40))(v38);
      }
      if (!*((unsigned char *)v36 - 28)) {
        goto LABEL_13;
      }
    }
    *((unsigned char *)v36 - 28) = 0;
LABEL_13:
    if (*((unsigned char *)v36 - 32)) {
      *((unsigned char *)v36 - 32) = 0;
    }
    unint64_t v37 = v36 - 6;
    v36 -= 10;
    v35 -= 10;
    if (v37 == v32)
    {
      unint64_t v34 = (void *)*((void *)a16 + 39);
LABEL_18:
      *((void *)a16 + 40) = v32;
      operator delete(v34);
LABEL_19:
      unint64_t v39 = (void *)*((void *)a16 + 36);
      if (!v39) {
        goto LABEL_34;
      }
      unint64_t v40 = (void *)*((void *)a16 + 37);
      BOOL v41 = (void *)*((void *)a16 + 36);
      if (v40 == v39) {
        goto LABEL_33;
      }
      BOOL v42 = v40 - 4;
      BOOL v43 = v40 - 4;
      while (2)
      {
        int v45 = (void *)v43[3];
        if (v43 == v45)
        {
          (*(void (**)(void *))(*v43 + 32))(v43);
          if (*((unsigned char *)v43 - 28)) {
            goto LABEL_27;
          }
        }
        else
        {
          if (v45) {
            (*(void (**)(void *))(*v45 + 40))(v45);
          }
          if (*((unsigned char *)v43 - 28)) {
LABEL_27:
          }
            *((unsigned char *)v43 - 28) = 0;
        }
        if (*((unsigned char *)v43 - 32)) {
          *((unsigned char *)v43 - 32) = 0;
        }
        BOOL v44 = v43 - 6;
        v43 -= 10;
        v42 -= 10;
        if (v44 == v39)
        {
          BOOL v41 = (void *)*((void *)a16 + 36);
LABEL_33:
          *((void *)a16 + 37) = v39;
          operator delete(v41);
LABEL_34:
          unsigned int v46 = (std::__shared_weak_count *)*((void *)a16 + 35);
          if (v46 && !atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
            std::__shared_weak_count::__release_weak(v46);
          }
          unsigned int v47 = (std::__shared_weak_count *)*((void *)a16 + 33);
          if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
            std::__shared_weak_count::__release_weak(v47);
          }
          uint64_t v48 = *v29;
          if (*v29)
          {
            *((void *)a16 + 30) = v48;
            operator delete(v48);
          }
          int v49 = (std::__shared_weak_count *)*((void *)a16 + 27);
          if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
            std::__shared_weak_count::__release_weak(v49);
          }
          uint16x4_t v50 = (std::__shared_weak_count *)*((void *)a16 + 25);
          if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
            std::__shared_weak_count::__release_weak(v50);
          }
          uint16x4_t v51 = (std::__shared_weak_count *)*((void *)a16 + 23);
          if (v51)
          {
            if (!atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
              std::__shared_weak_count::__release_weak(v51);
            }
          }
          karo::Job::~Job(a16);
          _Unwind_Resume(a1);
        }
        continue;
      }
    }
  }
}

void altitude::TextureMapLoadJob::uploadTextures(altitude::TextureMapLoadJob *this, ResourceAccessor *a2, char a3)
{
  uint64_t v6 = *((void *)this + 39);
  for (uint64_t i = *((void *)this + 40); v6 != i; v6 += 80)
    (*((void (**)(ResourceAccessor *, uint64_t))a2->var0 + 3))(a2, v6);
  uint64_t v8 = *((void *)this + 36);
  uint64_t v9 = *((void *)this + 37);
  if (a3)
  {
    if (v8 == v9) {
      goto LABEL_12;
    }
    do
    {
      (*((void (**)(ResourceAccessor *, uint64_t))a2->var0 + 3))(a2, v8);
      v8 += 80;
    }
    while (v8 != v9);
  }
  else
  {
    for (; v8 != v9; v8 += 80)
    {
      uint64_t v17 = *(void *)(v8 + 72);
      if (v17) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 48))(v17, v8);
      }
    }
    uint64_t v10 = *(void *)(*((void *)this + 22) + 16);
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
  }
  if ((a3 & 1) == 0) {
    *(void *)(*((void *)this + 22) + 16) = *(void *)(*((void *)this + 22) + 24);
  }
LABEL_12:
  uint64_t v12 = (void *)*((void *)this + 36);
  unint64_t v11 = (void *)*((void *)this + 37);
  if (v11 != v12)
  {
    uint64_t v13 = v11 - 4;
    uint64_t v14 = v11 - 4;
    do
    {
      uint64_t v16 = (void *)v14[3];
      if (v14 == v16)
      {
        (*(void (**)(void *))(*v14 + 32))(v14);
        if (!*((unsigned char *)v14 - 28)) {
          goto LABEL_20;
        }
      }
      else
      {
        if (v16) {
          (*(void (**)(void *))(*v16 + 40))(v16);
        }
        if (!*((unsigned char *)v14 - 28)) {
          goto LABEL_20;
        }
      }
      *((unsigned char *)v14 - 28) = 0;
LABEL_20:
      if (*((unsigned char *)v14 - 32)) {
        *((unsigned char *)v14 - 32) = 0;
      }
      unint64_t v15 = v14 - 6;
      v14 -= 10;
      v13 -= 10;
    }
    while (v15 != v12);
  }
  *((void *)this + 37) = v12;
  uint64_t v19 = (void *)*((void *)this + 39);
  BOOL v18 = (void *)*((void *)this + 40);
  if (v18 != v19)
  {
    unsigned int v20 = v18 - 4;
    unsigned int v21 = v18 - 4;
    do
    {
      uint64_t v23 = (void *)v21[3];
      if (v21 == v23)
      {
        (*(void (**)(void *))(*v21 + 32))(v21);
        if (!*((unsigned char *)v21 - 28)) {
          goto LABEL_35;
        }
      }
      else
      {
        if (v23) {
          (*(void (**)(void *))(*v23 + 40))(v23);
        }
        if (!*((unsigned char *)v21 - 28)) {
          goto LABEL_35;
        }
      }
      *((unsigned char *)v21 - 28) = 0;
LABEL_35:
      if (*((unsigned char *)v21 - 32)) {
        *((unsigned char *)v21 - 32) = 0;
      }
      __int16 v22 = v21 - 6;
      v21 -= 10;
      v20 -= 10;
    }
    while (v22 != v19);
  }
  *((void *)this + 40) = v19;
  *((void *)this + 30) = *((void *)this + 29);
  uint64_t v24 = (std::__shared_weak_count *)*((void *)this + 33);
  *((void *)this + 32) = 0;
  *((void *)this + 33) = 0;
  if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
}

std::mutex *std::__shared_ptr_pointer<md::HardwareVideoDecodingSession *,std::shared_ptr<md::HardwareVideoDecodingSession>::__shared_ptr_default_delete<md::HardwareVideoDecodingSession,md::HardwareVideoDecodingSession>,std::allocator<md::HardwareVideoDecodingSession>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(std::mutex **)(a1 + 24);
  if (result)
  {
    md::HardwareVideoDecodingSession::~HardwareVideoDecodingSession(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<md::HardwareVideoDecodingSession *,std::shared_ptr<md::HardwareVideoDecodingSession>::__shared_ptr_default_delete<md::HardwareVideoDecodingSession,md::HardwareVideoDecodingSession>,std::allocator<md::HardwareVideoDecodingSession>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void ___ZN8altitude12TexturePager25processTextureMipmapQueueEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 24);
  uint64_t v3 = operator new(0x68uLL);
  v3[1] = 0;
  v3[2] = 0;
  *uint64_t v3 = &unk_1EF58B038;
  altitude::MipChain::MipChain((uint64_t)(v3 + 3), v2, *(_DWORD *)(v1 + 44));
}

void sub_1A23E1B00(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c64_ZTSKZN8altitude12TexturePager25processTextureMipmapQueueEvE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[2];
  a1[2] = result;
  return result;
}

void ___ZN8altitude12TexturePager25processTextureDecodeQueueEv_block_invoke(uint64_t a1, __CVBuffer *a2, int a3)
{
  uint64_t v6 = *(void *)(a1 + 32);
  std::mutex::lock((std::mutex *)(v6 + 168));
  if ((a3 - 1) < 4)
  {
    uint64_t v7 = *(void *)(a1 + 40);
    int v8 = *(_DWORD *)(a1 + 64);
    uint64_t v10 = *(char **)(v6 + 152);
    unint64_t v9 = *(void *)(v6 + 160);
    if ((unint64_t)v10 < v9)
    {
      *(void *)uint64_t v10 = v7;
      *((_DWORD *)v10 + 2) = v8;
      unint64_t v11 = v10 + 24;
      *((void *)v10 + 2) = 0;
LABEL_22:
      *(void *)(v6 + 152) = v11;
      goto LABEL_23;
    }
    uint64_t v16 = *(unsigned char **)(v6 + 144);
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v16) >> 3) + 1;
    if (v17 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - (void)v16) >> 3);
    if (2 * v18 > v17) {
      unint64_t v17 = 2 * v18;
    }
    if (v18 >= 0x555555555555555) {
      unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v19 = v17;
    }
    if (!v19)
    {
      unsigned int v20 = 0;
      goto LABEL_17;
    }
    if (v19 <= 0xAAAAAAAAAAAAAAALL)
    {
      unsigned int v20 = (char *)operator new(24 * v19);
LABEL_17:
      unsigned int v21 = &v20[8 * ((v10 - v16) >> 3)];
      *(void *)unsigned int v21 = v7;
      *((_DWORD *)v21 + 2) = v8;
      *((void *)v21 + 2) = 0;
      unint64_t v11 = v21 + 24;
      if (v10 != v16)
      {
        do
        {
          long long v22 = *(_OWORD *)(v10 - 24);
          *((void *)v21 - 1) = *((void *)v10 - 1);
          *(_OWORD *)(v21 - 24) = v22;
          v21 -= 24;
          v10 -= 24;
        }
        while (v10 != v16);
        uint64_t v10 = *(char **)(v6 + 144);
      }
      *(void *)(v6 + 144) = v21;
      *(void *)(v6 + 152) = v11;
      *(void *)(v6 + 160) = &v20[24 * v19];
      if (v10) {
        operator delete(v10);
      }
      goto LABEL_22;
    }
LABEL_45:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  if (a3) {
    goto LABEL_23;
  }
  CVPixelBufferRetain(a2);
  uint64_t v12 = *(void *)(a1 + 40);
  int v13 = *(_DWORD *)(a1 + 64);
  unint64_t v15 = *(char **)(v6 + 152);
  unint64_t v14 = *(void *)(v6 + 160);
  if ((unint64_t)v15 < v14)
  {
    *(void *)unint64_t v15 = v12;
    *((_DWORD *)v15 + 2) = v13;
    *((void *)v15 + 2) = a2;
    *(void *)(v6 + 152) = v15 + 24;
    goto LABEL_23;
  }
  uint64_t v23 = *(unsigned char **)(v6 + 144);
  unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((v15 - v23) >> 3) + 1;
  if (v24 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - (void)v23) >> 3);
  if (2 * v25 > v24) {
    unint64_t v24 = 2 * v25;
  }
  if (v25 >= 0x555555555555555) {
    unint64_t v26 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v26 = v24;
  }
  if (v26)
  {
    if (v26 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_45;
    }
    uint64_t v27 = (char *)operator new(24 * v26);
  }
  else
  {
    uint64_t v27 = 0;
  }
  uint64_t v28 = &v27[8 * ((v15 - v23) >> 3)];
  *(void *)uint64_t v28 = v12;
  *((_DWORD *)v28 + 2) = v13;
  *((void *)v28 + 2) = a2;
  BOOL v29 = v28 + 24;
  if (v15 != v23)
  {
    do
    {
      long long v30 = *(_OWORD *)(v15 - 24);
      *((void *)v28 - 1) = *((void *)v15 - 1);
      *(_OWORD *)(v28 - 24) = v30;
      v28 -= 24;
      v15 -= 24;
    }
    while (v15 != v23);
    unint64_t v15 = *(char **)(v6 + 144);
  }
  *(void *)(v6 + 144) = v28;
  *(void *)(v6 + 152) = v29;
  *(void *)(v6 + 160) = &v27[24 * v26];
  if (v15) {
    operator delete(v15);
  }
  *(void *)(v6 + 152) = v29;
LABEL_23:
  if (atomic_fetch_add((atomic_uint *volatile)(v6 + 320), 0xFFFFFFFF) == 1) {
    std::condition_variable::notify_all((std::condition_variable *)(v6 + 328));
  }
  std::mutex::unlock((std::mutex *)(v6 + 168));
}

void sub_1A23E1DE4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c64_ZTSKZN8altitude12TexturePager25processTextureDecodeQueueEvE3__1(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_ea8_32c64_ZTSKZN8altitude12TexturePager25processTextureDecodeQueueEvE3__1(uint64_t result, uint64_t a2)
{
  *(_OWORD *)(result + 32) = *(_OWORD *)(a2 + 32);
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(result + 64) = *(_DWORD *)(a2 + 64);
  return result;
}

void std::__function::__func<altitude::TexturePager::processTextureDecodeQueue(void)::$_0,std::allocator<altitude::TexturePager::processTextureDecodeQueue(void)::$_0>,void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::operator()(uint64_t a1, uint64_t a2, int *a3, __CVBuffer **a4)
{
  int v5 = *a3;
  uint64_t v6 = *a4;
  uint64_t v7 = *(void *)(a1 + 8);
  std::mutex::lock((std::mutex *)(v7 + 168));
  if (v5)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    int v9 = *(_DWORD *)(a1 + 40);
    unint64_t v11 = *(char **)(v7 + 152);
    unint64_t v10 = *(void *)(v7 + 160);
    if ((unint64_t)v11 < v10)
    {
      *(void *)unint64_t v11 = v8;
      *((_DWORD *)v11 + 2) = v9;
      uint64_t v12 = v11 + 24;
      *((void *)v11 + 2) = 0;
LABEL_30:
      *(void *)(v7 + 152) = v12;
      goto LABEL_38;
    }
    unint64_t v18 = *(unsigned char **)(v7 + 144);
    unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((v11 - v18) >> 3) + 1;
    if (v19 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - (void)v18) >> 3);
    if (2 * v20 > v19) {
      unint64_t v19 = 2 * v20;
    }
    if (v20 >= 0x555555555555555) {
      unint64_t v21 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v21 = v19;
    }
    if (!v21)
    {
      long long v22 = 0;
      goto LABEL_25;
    }
    if (v21 <= 0xAAAAAAAAAAAAAAALL)
    {
      long long v22 = (char *)operator new(24 * v21);
LABEL_25:
      uint64_t v28 = &v22[8 * ((v11 - v18) >> 3)];
      *(void *)uint64_t v28 = v8;
      *((_DWORD *)v28 + 2) = v9;
      *((void *)v28 + 2) = 0;
      uint64_t v12 = v28 + 24;
      if (v11 != v18)
      {
        do
        {
          long long v29 = *(_OWORD *)(v11 - 24);
          *((void *)v28 - 1) = *((void *)v11 - 1);
          *(_OWORD *)(v28 - 24) = v29;
          v28 -= 24;
          v11 -= 24;
        }
        while (v11 != v18);
        unint64_t v11 = *(char **)(v7 + 144);
      }
      *(void *)(v7 + 144) = v28;
      *(void *)(v7 + 152) = v12;
      *(void *)(v7 + 160) = &v22[24 * v21];
      if (v11) {
        operator delete(v11);
      }
      goto LABEL_30;
    }
LABEL_44:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  CVPixelBufferRetain(v6);
  uint64_t v13 = *(void *)(a1 + 16);
  int v14 = *(_DWORD *)(a1 + 40);
  uint64_t v16 = *(void **)(v7 + 152);
  unint64_t v15 = *(void *)(v7 + 160);
  if ((unint64_t)v16 >= v15)
  {
    uint64_t v23 = *(void **)(v7 + 144);
    unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * (v16 - v23) + 1;
    if (v24 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - (void)v23) >> 3);
    if (2 * v25 > v24) {
      unint64_t v24 = 2 * v25;
    }
    if (v25 >= 0x555555555555555) {
      unint64_t v26 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v26 = v24;
    }
    if (v26)
    {
      if (v26 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_44;
      }
      uint64_t v27 = (char *)operator new(24 * v26);
    }
    else
    {
      uint64_t v27 = 0;
    }
    long long v30 = &v27[8 * (v16 - v23)];
    *(void *)long long v30 = v13;
    *((_DWORD *)v30 + 2) = v14;
    *((void *)v30 + 2) = v6;
    unint64_t v17 = v30 + 24;
    if (v16 != v23)
    {
      do
      {
        long long v31 = *(_OWORD *)(v16 - 3);
        *((void *)v30 - 1) = *(v16 - 1);
        *(_OWORD *)(v30 - 24) = v31;
        v30 -= 24;
        v16 -= 3;
      }
      while (v16 != v23);
      uint64_t v16 = *(void **)(v7 + 144);
    }
    *(void *)(v7 + 144) = v30;
    *(void *)(v7 + 152) = v17;
    *(void *)(v7 + 160) = &v27[24 * v26];
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    *uint64_t v16 = v13;
    *((_DWORD *)v16 + 2) = v14;
    unint64_t v17 = v16 + 3;
    _OWORD v16[2] = v6;
  }
  *(void *)(v7 + 152) = v17;
LABEL_38:
  if (atomic_fetch_add((atomic_uint *volatile)(v7 + 320), 0xFFFFFFFF) == 1) {
    std::condition_variable::notify_all((std::condition_variable *)(v7 + 328));
  }
  std::mutex::unlock((std::mutex *)(v7 + 168));
}

void sub_1A23E2154(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<altitude::TexturePager::processTextureDecodeQueue(void)::$_0,std::allocator<altitude::TexturePager::processTextureDecodeQueue(void)::$_0>,void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void std::__function::__func<altitude::TexturePager::processTextureDecodeQueue(void)::$_0,std::allocator<altitude::TexturePager::processTextureDecodeQueue(void)::$_0>,void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__function::__func<altitude::TexturePager::processTextureDecodeQueue(void)::$_0,std::allocator<altitude::TexturePager::processTextureDecodeQueue(void)::$_0>,void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF57D128;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(result + 40);
  return result;
}

char *std::__function::__func<altitude::TexturePager::processTextureDecodeQueue(void)::$_0,std::allocator<altitude::TexturePager::processTextureDecodeQueue(void)::$_0>,void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::__clone(uint64_t a1)
{
  __n128 result = (char *)operator new(0x30uLL);
  *(void *)__n128 result = &unk_1EF57D128;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
  return result;
}

void std::__function::__func<altitude::TexturePager::processTextureDecodeQueue(void)::$_0,std::allocator<altitude::TexturePager::processTextureDecodeQueue(void)::$_0>,void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::~__func(void *a1)
{
  *a1 = &unk_1EF57D128;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<altitude::TexturePager::processTextureDecodeQueue(void)::$_0,std::allocator<altitude::TexturePager::processTextureDecodeQueue(void)::$_0>,void ()(unsigned long,md::HardwareFigDecodeResult,__CVBuffer *)>::~__func(void *a1)
{
  *a1 = &unk_1EF57D128;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void altitude::TexturePager::addPooledTexture(altitude::TexturePager *this, ggl::Texture2D *a2)
{
  int v3 = *((_DWORD *)a2 + 20);
  if (v3 == *((_DWORD *)a2 + 21) && (v3 == 256 || v3 == 512))
  {
    uint64_t v5 = (v3 << 16) | (*((_DWORD *)a2 + 26) << 8) | *((unsigned __int8 *)a2 + 68);
    uint64_t v7 = (char *)*((void *)this + 15);
    uint64_t v6 = (char *)*((void *)this + 16);
    unint64_t v8 = (v6 - v7) >> 4;
    if (v8 < *((unsigned int *)this + 28))
    {
      unint64_t v9 = *((void *)this + 17);
      if ((unint64_t)v6 >= v9)
      {
        uint64_t v10 = v9 - (void)v7;
        if (v10 >> 3 <= v8 + 1) {
          uint64_t v11 = v8 + 1;
        }
        else {
          uint64_t v11 = v10 >> 3;
        }
        BOOL v12 = (unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0;
        unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
        if (!v12) {
          unint64_t v13 = v11;
        }
        if (!(v13 >> 60))
        {
          uint64_t v14 = 16 * v13;
          unint64_t v15 = (char *)operator new(16 * v13);
          uint64_t v16 = &v15[16 * v8];
          unint64_t v17 = &v15[v14];
          *(void *)uint64_t v16 = v5;
          *((void *)v16 + 1) = a2;
          unint64_t v18 = v16 + 16;
          if (v6 != v7)
          {
            do
            {
              *((_OWORD *)v16 - 1) = *((_OWORD *)v6 - 1);
              v16 -= 16;
              v6 -= 16;
            }
            while (v6 != v7);
            uint64_t v6 = v7;
          }
LABEL_42:
          *((void *)this + 15) = v16;
          *((void *)this + 16) = v18;
          *((void *)this + 17) = v17;
          if (v6) {
            operator delete(v6);
          }
          goto LABEL_44;
        }
LABEL_45:
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      goto LABEL_28;
    }
    uint64_t v20 = *((void *)v7 + 1);
    if (v20)
    {
      (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
      uint64_t v7 = (char *)*((void *)this + 15);
      uint64_t v6 = (char *)*((void *)this + 16);
    }
    unint64_t v21 = v7 + 16;
    long long v22 = v7;
    if (v7 + 16 != v6)
    {
      unint64_t v23 = v6 - v7 - 32;
      long long v22 = v7;
      if (v23 < 0x10) {
        goto LABEL_26;
      }
      uint64_t v24 = (v23 >> 4) + 1;
      uint64_t v25 = 16 * (v24 & 0x1FFFFFFFFFFFFFFELL);
      long long v22 = &v7[v25];
      unint64_t v26 = v7 + 24;
      uint64_t v27 = v24 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        int v28 = *((_DWORD *)v26 + 2);
        *((_DWORD *)v26 - 6) = *((_DWORD *)v26 - 2);
        *((_DWORD *)v26 - 2) = v28;
        uint64_t v29 = v26[2];
        *(v26 - 2) = *v26;
        void *v26 = v29;
        v26 += 4;
        v27 -= 2;
      }
      while (v27);
      if (v24 != (v24 & 0x1FFFFFFFFFFFFFFELL))
      {
        unint64_t v21 = (void *)((char *)v21 + v25);
        do
        {
LABEL_26:
          *(_DWORD *)long long v22 = *(_DWORD *)v21;
          *((void *)v22 + 1) = v21[1];
          v22 += 16;
          v21 += 2;
        }
        while (v21 != (void *)v6);
      }
    }
    uint64_t v6 = v22;
    *((void *)this + 16) = v22;
    unint64_t v30 = *((void *)this + 17);
    if ((unint64_t)v22 >= v30)
    {
      long long v31 = (char *)*((void *)this + 15);
      uint64_t v32 = (v22 - v31) >> 4;
      unint64_t v33 = v32 + 1;
      if ((unint64_t)(v32 + 1) >> 60) {
        abort();
      }
      uint64_t v34 = v30 - (void)v31;
      if (v34 >> 3 > v33) {
        unint64_t v33 = v34 >> 3;
      }
      if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v35 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v35 = v33;
      }
      if (v35)
      {
        if (v35 >> 60) {
          goto LABEL_45;
        }
        uint64_t v36 = (char *)operator new(16 * v35);
      }
      else
      {
        uint64_t v36 = 0;
      }
      uint64_t v16 = &v36[16 * v32];
      unint64_t v17 = &v36[16 * v35];
      *(void *)uint64_t v16 = v5;
      *((void *)v16 + 1) = a2;
      unint64_t v18 = v16 + 16;
      if (v6 != v31)
      {
        do
        {
          *((_OWORD *)v16 - 1) = *((_OWORD *)v6 - 1);
          v16 -= 16;
          v6 -= 16;
        }
        while (v6 != v31);
        uint64_t v6 = (char *)*((void *)this + 15);
      }
      goto LABEL_42;
    }
LABEL_28:
    *(void *)uint64_t v6 = v5;
    *((void *)v6 + 1) = a2;
    unint64_t v18 = v6 + 16;
LABEL_44:
    *((void *)this + 16) = v18;
    return;
  }
  unint64_t v19 = *(void (**)(ggl::Texture2D *))(*(void *)a2 + 8);
  v19(a2);
}

uint64_t altitude::TexturePager::getPooledTexture(uint64_t a1, int a2, int a3, unsigned __int8 a4, unsigned __int8 a5)
{
  if (a2 != a3 || a2 != 256 && a2 != 512) {
    operator new();
  }
  uint64_t v7 = *(void *)(a1 + 120);
  uint64_t v6 = *(void *)(a1 + 128);
  if (v7 == v6) {
LABEL_8:
  }
    operator new();
  unint64_t v8 = v6 - v7 - 32;
  uint64_t v9 = *(void *)(a1 + 120);
  while (*(_DWORD *)v9 != ((a2 << 16) | (a4 << 8) | a5))
  {
    v9 += 16;
    v8 -= 16;
    if (v9 == v6) {
      goto LABEL_8;
    }
  }
  uint64_t result = *(void *)(v9 + 8);
  uint64_t v11 = v9 + 16;
  if (v9 + 16 != v6)
  {
    unint64_t v12 = v6 - v9 - 32;
    if (v12 <= 0xF) {
      goto LABEL_16;
    }
    uint64_t v13 = (v9 - v7) >> 4;
    uint64_t v14 = (v12 >> 4) + 1;
    uint64_t v15 = 16 * (v14 & 0x1FFFFFFFFFFFFFFELL);
    v9 += v15;
    uint64_t v16 = ((v8 >> 4) + 1) & 0x1FFFFFFFFFFFFFFELL;
    uint64_t v17 = v7 + 16 * v13 + 24;
    do
    {
      int v18 = *(_DWORD *)(v17 + 8);
      *(_DWORD *)(v17 - 24) = *(_DWORD *)(v17 - 8);
      *(_DWORD *)(v17 - 8) = v18;
      uint64_t v19 = *(void *)(v17 + 16);
      *(void *)(v17 - 16) = *(void *)v17;
      *(void *)uint64_t v17 = v19;
      v17 += 32;
      v16 -= 2;
    }
    while (v16);
    if (v14 != (v14 & 0x1FFFFFFFFFFFFFFELL))
    {
      v11 += v15;
      do
      {
LABEL_16:
        *(_DWORD *)uint64_t v9 = *(_DWORD *)v11;
        *(void *)(v9 + 8) = *(void *)(v11 + 8);
        v9 += 16;
        v11 += 16;
      }
      while (v11 != v6);
    }
  }
  *(void *)(a1 + 128) = v9;
  return result;
}

void std::__function::__func<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_1,std::allocator<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_1>,void ()(ggl::Texture2DLoadItem const&)>::operator()(void *a1)
{
  uint64_t v2 = a1[1];
  std::mutex::lock((std::mutex *)(v2 + 256));
  uint64_t v4 = a1[2];
  uint64_t v3 = a1[3];
  uint64_t v6 = *(void **)(v2 + 240);
  unint64_t v5 = *(void *)(v2 + 248);
  if ((unint64_t)v6 >= v5)
  {
    unint64_t v8 = *(void **)(v2 + 232);
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (v6 - v8) + 1;
    if (v9 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - (void)v8) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v12 = (char *)operator new(24 * v11);
    }
    else
    {
      unint64_t v12 = 0;
    }
    uint64_t v13 = &v12[8 * (v6 - v8)];
    *(void *)uint64_t v13 = v4;
    *((void *)v13 + 1) = v3;
    *((void *)v13 + 2) = 0;
    uint64_t v7 = v13 + 24;
    if (v6 != v8)
    {
      do
      {
        long long v14 = *(_OWORD *)(v6 - 3);
        *((void *)v13 - 1) = *(v6 - 1);
        *(_OWORD *)(v13 - 24) = v14;
        v13 -= 24;
        v6 -= 3;
      }
      while (v6 != v8);
      uint64_t v6 = *(void **)(v2 + 232);
    }
    *(void *)(v2 + 232) = v13;
    *(void *)(v2 + 240) = v7;
    *(void *)(v2 + 248) = &v12[24 * v11];
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    *uint64_t v6 = v4;
    v6[1] = v3;
    uint64_t v7 = v6 + 3;
    v6[2] = 0;
  }
  *(void *)(v2 + 240) = v7;
  std::mutex::unlock((std::mutex *)(v2 + 256));
}

void sub_1A23E2B30(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_1,std::allocator<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_1>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF57D0E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_1,std::allocator<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_1>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF57D0E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_1,std::allocator<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_1>,void ()(ggl::Texture2DLoadItem const&)>::~__func()
{
}

uint64_t std::__split_buffer<ggl::Texture2DLoadItem,geo::StdAllocator<ggl::Texture2DLoadItem,ggl::Allocator> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 80;
    uint64_t v4 = *(void *)(i - 8);
    if (v4 == i - 32)
    {
      (*(void (**)(uint64_t))(*(void *)(i - 32) + 32))(i - 32);
      if (*(unsigned char *)(i - 60)) {
        goto LABEL_8;
      }
    }
    else
    {
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
      }
      if (*(unsigned char *)(i - 60)) {
LABEL_8:
      }
        *(unsigned char *)(i - 60) = 0;
    }
    if (*(unsigned char *)(i - 64)) {
      *(unsigned char *)(i - 64) = 0;
    }
  }
  if (*(void *)a1) {
    (*(void (**)(void, void, void))(***(void ***)(a1 + 32) + 40))(**(void **)(a1 + 32), *(void *)a1, *(void *)(a1 + 24) - *(void *)a1);
  }
  return a1;
}

void std::__function::__func<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_0,std::allocator<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_0>,void ()(ggl::Texture2DLoadItem const&)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 16), 1uLL);
  if (*a2) {
    (*(void (**)(void))(*(void *)*a2 + 8))(*a2);
  }
  std::mutex::lock((std::mutex *)(v4 + 256));
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 16);
  unint64_t v9 = *(void **)(v4 + 240);
  unint64_t v8 = *(void *)(v4 + 248);
  if ((unint64_t)v9 >= v8)
  {
    unint64_t v11 = *(void **)(v4 + 232);
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * (v9 - v11) + 1;
    if (v12 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - (void)v11) >> 3);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x555555555555555) {
      unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      if (v14 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v15 = (char *)operator new(24 * v14);
    }
    else
    {
      uint64_t v15 = 0;
    }
    uint64_t v16 = &v15[8 * (v9 - v11)];
    *(void *)uint64_t v16 = v6;
    *((void *)v16 + 1) = v5;
    *((void *)v16 + 2) = v7;
    unint64_t v10 = v16 + 24;
    if (v9 != v11)
    {
      do
      {
        long long v17 = *(_OWORD *)(v9 - 3);
        *((void *)v16 - 1) = *(v9 - 1);
        *(_OWORD *)(v16 - 24) = v17;
        v16 -= 24;
        v9 -= 3;
      }
      while (v9 != v11);
      unint64_t v9 = *(void **)(v4 + 232);
    }
    *(void *)(v4 + 232) = v16;
    *(void *)(v4 + 240) = v10;
    *(void *)(v4 + 248) = &v15[24 * v14];
    if (v9) {
      operator delete(v9);
    }
  }
  else
  {
    *unint64_t v9 = v6;
    v9[1] = v5;
    unint64_t v10 = v9 + 3;
    v9[2] = v7;
  }
  *(void *)(v4 + 240) = v10;
  std::mutex::unlock((std::mutex *)(v4 + 256));
}

void sub_1A23E2E90(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_0,std::allocator<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_0>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF57D098;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_0,std::allocator<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_0>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1EF57D098;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void std::__function::__func<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_0,std::allocator<altitude::TexturePager::processTextureTransfers(unsigned long,md::PassList &)::$_0>,void ()(ggl::Texture2DLoadItem const&)>::~__func()
{
}

void md::InitialMapEngineMode::willBecomeInactive(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(md::LogicManager **)(a2 + 1120);
  int8x8_t v3 = *(int8x8_t *)((char *)v2 + 16);
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    uint64_t v5 = 0x4AC7AB7561675F6;
    if (*(void *)&v3 <= 0x4AC7AB7561675F6uLL) {
      uint64_t v5 = 0x4AC7AB7561675F6uLL % *(void *)&v3;
    }
  }
  else
  {
    uint64_t v5 = (*(void *)&v3 - 1) & 0x4AC7AB7561675F6;
  }
  uint64_t v6 = *((void *)v2 + 1);
  uint64_t v7 = *(void **)(v6 + 8 * v5);
  if (v7 && (unint64_t v8 = (void *)*v7) != 0)
  {
    if (v4.u32[0] >= 2uLL)
    {
      while (v8[1] != 0x4AC7AB7561675F6 || v8[2] != 0x4AC7AB7561675F6)
        unint64_t v8 = (void *)*v8;
    }
    else
    {
      while (v8[1] != 0x4AC7AB7561675F6 || v8[2] != 0x4AC7AB7561675F6)
        unint64_t v8 = (void *)*v8;
    }
    uint64_t v9 = v8[5] + 136;
  }
  else
  {
    uint64_t v9 = 136;
  }
  *(unsigned char *)uint64_t v9 = 1;
  if (v4.u32[0] >= 2uLL)
  {
    unint64_t v11 = 0x653D1F33EF15EF04;
    if (*(void *)&v3 <= 0x653D1F33EF15EF04uLL) {
      unint64_t v11 = 0x653D1F33EF15EF04uLL % *(void *)&v3;
    }
    unint64_t v10 = *(void **)(v6 + 8 * v11);
    do
    {
      do
        unint64_t v10 = (void *)*v10;
      while (v10[1] != 0x653D1F33EF15EF04);
    }
    while (v10[2] != 0x653D1F33EF15EF04);
  }
  else
  {
    unint64_t v10 = *(void **)(v6 + 8 * ((*(void *)&v3 - 1) & 0x653D1F33EF15EF04));
    do
    {
      do
        unint64_t v10 = (void *)*v10;
      while (v10[1] != 0x653D1F33EF15EF04);
    }
    while (v10[2] != 0x653D1F33EF15EF04);
  }
  *(unsigned char *)(v10[5] + 128) = 0;
  md::LogicManager::toggleVLR(v2, 1);
}

void md::InitialMapEngineMode::didBecomeActive(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(md::LogicManager **)(a2 + 1120);
  int8x8_t v3 = *(int8x8_t *)((char *)v2 + 16);
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    uint64_t v5 = 0x4AC7AB7561675F6;
    if (*(void *)&v3 <= 0x4AC7AB7561675F6uLL) {
      uint64_t v5 = 0x4AC7AB7561675F6uLL % *(void *)&v3;
    }
  }
  else
  {
    uint64_t v5 = (*(void *)&v3 - 1) & 0x4AC7AB7561675F6;
  }
  uint64_t v6 = *((void *)v2 + 1);
  uint64_t v7 = *(void **)(v6 + 8 * v5);
  if (v7 && (unint64_t v8 = (void *)*v7) != 0)
  {
    if (v4.u32[0] >= 2uLL)
    {
      while (v8[1] != 0x4AC7AB7561675F6 || v8[2] != 0x4AC7AB7561675F6)
        unint64_t v8 = (void *)*v8;
    }
    else
    {
      while (v8[1] != 0x4AC7AB7561675F6 || v8[2] != 0x4AC7AB7561675F6)
        unint64_t v8 = (void *)*v8;
    }
    uint64_t v9 = v8[5] + 136;
  }
  else
  {
    uint64_t v9 = 136;
  }
  *(unsigned char *)uint64_t v9 = 0;
  if (v4.u32[0] >= 2uLL)
  {
    unint64_t v11 = 0x653D1F33EF15EF04;
    if (*(void *)&v3 <= 0x653D1F33EF15EF04uLL) {
      unint64_t v11 = 0x653D1F33EF15EF04uLL % *(void *)&v3;
    }
    unint64_t v10 = *(void **)(v6 + 8 * v11);
    do
    {
      do
        unint64_t v10 = (void *)*v10;
      while (v10[1] != 0x653D1F33EF15EF04);
    }
    while (v10[2] != 0x653D1F33EF15EF04);
  }
  else
  {
    unint64_t v10 = *(void **)(v6 + 8 * ((*(void *)&v3 - 1) & 0x653D1F33EF15EF04));
    do
    {
      do
        unint64_t v10 = (void *)*v10;
      while (v10[1] != 0x653D1F33EF15EF04);
    }
    while (v10[2] != 0x653D1F33EF15EF04);
  }
  *(unsigned char *)(v10[5] + 128) = 1;
  md::LogicManager::toggleVLR(v2, 0);
}

void md::InitialMapEngineMode::~InitialMapEngineMode(md::InitialMapEngineMode *this)
{
  *(void *)this = &unk_1EF5463F0;
  if (*((unsigned char *)this + 548)) {
    *((unsigned char *)this + 548) = 0;
  }
  md::MapEngineMode::~MapEngineMode(this);
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF5463F0;
  if (*((unsigned char *)this + 548)) {
    *((unsigned char *)this + 548) = 0;
  }
  md::MapEngineMode::~MapEngineMode(this);
}

md::InitialMapEngineMode *md::InitialMapEngineMode::InitialMapEngineMode(md::InitialMapEngineMode *this, int a2)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = md::CartographicMapEngineMode::CartographicMapEngineMode((uint64_t)this, 0);
  *(void *)uint64_t v4 = &unk_1EF53D820;
  *(void *)(v4 + 536) = 0;
  *(unsigned char *)(v4 + 49) = 0;
  *(_DWORD *)(v4 + 52) = 21;
  uint64_t v5 = (uint64_t *)(v4 + 384);
  LOWORD(v49) = 2560;
  *((void *)&v49 + 1) = 0;
  uint64_t v38 = this;
  geo::range_map<unsigned char,geo::Unit<geo::RadianUnitDescription,double>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,geo::Unit<geo::RadianUnitDescription,double>>>>::insert((uint64_t *)(v4 + 384), (unsigned __int8 *)&v49);
  LOWORD(v49) = 5386;
  *((void *)&v49 + 1) = 0x3FD657184AE74487;
  geo::range_map<unsigned char,geo::Unit<geo::RadianUnitDescription,double>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,geo::Unit<geo::RadianUnitDescription,double>>>>::insert(v5, (unsigned __int8 *)&v49);
  LOWORD(v49) = 2560;
  *((void *)&v49 + 1) = 0;
  geo::range_map<unsigned char,geo::Unit<geo::RadianUnitDescription,double>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,geo::Unit<geo::RadianUnitDescription,double>>>>::insert((uint64_t *)this + 54, (unsigned __int8 *)&v49);
  LOWORD(v49) = 5386;
  *((void *)&v49 + 1) = 0x3FE0C152382D7365;
  geo::range_map<unsigned char,geo::Unit<geo::RadianUnitDescription,double>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,geo::Unit<geo::RadianUnitDescription,double>>>>::insert((uint64_t *)this + 54, (unsigned __int8 *)&v49);
  LOWORD(v49) = 768;
  *((void *)&v49 + 1) = 0;
  geo::range_map<unsigned char,geo::Unit<geo::RadianUnitDescription,double>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,geo::Unit<geo::RadianUnitDescription,double>>>>::insert((uint64_t *)this + 51, (unsigned __int8 *)&v49);
  LOWORD(v49) = 3843;
  *((void *)&v49 + 1) = 0x3FE38C35418A5BF6;
  geo::range_map<unsigned char,geo::Unit<geo::RadianUnitDescription,double>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,geo::Unit<geo::RadianUnitDescription,double>>>>::insert((uint64_t *)this + 51, (unsigned __int8 *)&v49);
  LOWORD(v49) = 4111;
  *((void *)&v49 + 1) = 0x3FF0C152382D7365;
  geo::range_map<unsigned char,geo::Unit<geo::RadianUnitDescription,double>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,geo::Unit<geo::RadianUnitDescription,double>>>>::insert((uint64_t *)this + 51, (unsigned __int8 *)&v49);
  LOWORD(v49) = 4624;
  *((void *)&v49 + 1) = 0x3FF38C35418A5BF6;
  geo::range_map<unsigned char,geo::Unit<geo::RadianUnitDescription,double>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,geo::Unit<geo::RadianUnitDescription,double>>>>::insert((uint64_t *)this + 51, (unsigned __int8 *)&v49);
  LOWORD(v49) = 5650;
  *((void *)&v49 + 1) = 0x3FF4F1A6C638D03FLL;
  geo::range_map<unsigned char,geo::Unit<geo::RadianUnitDescription,double>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,geo::Unit<geo::RadianUnitDescription,double>>>>::insert((uint64_t *)this + 51, (unsigned __int8 *)&v49);
  if (a2)
  {
    uint64_t v6 = +[VKDebugSettings sharedSettings];
    if ([v6 daVinciCameraController])
    {
      uint64_t v7 = +[VKDebugSettings sharedSettings];
      int v8 = [v7 daVinciCameraControllerForceMercatorZoom];

      if (v8) {
        char v9 = 2;
      }
      else {
        char v9 = 1;
      }
      char v10 = 5;
    }
    else
    {

      char v10 = 5;
      char v9 = 2;
    }
  }
  else
  {
    char v9 = 0;
    char v10 = 0;
  }
  *((unsigned char *)this + 224) = v9;
  *((unsigned char *)this + 225) = v10;
  unint64_t v11 = (char *)this + 144;
  LOBYTE(v49) = 0;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0, &v49)+ 17) = 0;
  LOBYTE(v49) = 2;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 2u, &v49)+ 17) = 0;
  LOBYTE(v49) = 51;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0x33u, &v49)+ 17) = 0;
  LOBYTE(v49) = 32;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0x20u, &v49)+ 17) = 0;
  LOBYTE(v49) = 31;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0x1Fu, &v49)+ 17) = 0;
  LOBYTE(v49) = 28;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0x1Cu, &v49)+ 17) = 0;
  if (a2)
  {
    LOBYTE(v49) = 1;
    unint64_t v12 = std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 1u, &v49);
  }
  else
  {
    LOBYTE(v49) = 3;
    unint64_t v12 = std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 3u, &v49);
  }
  *((unsigned char *)v12 + 17) = 0;
  LOBYTE(v49) = 44;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0x2Cu, &v49)+ 17) = 1;
  LOBYTE(v49) = 40;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0x28u, &v49)+ 17) = 1;
  LOBYTE(v49) = 18;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0x12u, &v49)+ 17) = 1;
  *(void *)&long long v43 = 0xEA624BC935BAF297;
  *((void *)&v43 + 1) = "md::mun::MuninLogic]";
  unint64_t v13 = (char *)this + 232;
  uint64_t v44 = 19;
  *(void *)&long long v39 = 0x8EA84A1BD3791AFALL;
  *((void *)&v39 + 1) = "md::mun::MuninContext]";
  *(void *)&long long v40 = 21;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 3;
  long long v52 = xmmword_1E5A97EB0;
  long long v53 = unk_1E5A97EC0;
  *(void *)&long long v54 = 20;
  long long v50 = xmmword_1E5A97E90;
  long long v51 = unk_1E5A97EA0;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v43, &v39, 1, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v43 = 0xEC9B77B4222D22FFLL;
  *((void *)&v43 + 1) = "md::VenueLogic]";
  uint64_t v44 = 14;
  *(void *)&long long v39 = 0x4927EB92E562CC46;
  *((void *)&v39 + 1) = "md::VenueLogicContext]";
  *(void *)&long long v40 = 21;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 3;
  long long v52 = xmmword_1E5A971A8;
  long long v53 = unk_1E5A971B8;
  *(void *)&long long v54 = 16;
  long long v50 = xmmword_1E5A97188;
  long long v51 = unk_1E5A97198;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v43, &v39, 1, (uint64_t)&v49, (uint64_t)&v46);
  unint64_t v46 = 0x79FE0BD9535D5C4DLL;
  unsigned int v47 = "md::AnchorLogic]";
  uint64_t v48 = 15;
  *(void *)&long long v49 = &v50;
  *(void *)&long long v43 = 0x63B6FE00C0848868;
  *((void *)&v43 + 1) = "md::AnchorContext]";
  uint64_t v44 = 17;
  char v45 = 1;
  *((void *)&v49 + 1) = 2;
  long long v50 = xmmword_1E5A97998;
  long long v51 = unk_1E5A979A8;
  long long v52 = xmmword_1E5A979B8;
  *(void *)&long long v39 = &v40;
  *((void *)&v39 + 1) = 1;
  long long v40 = xmmword_1E5A98030;
  *(void *)&long long v41 = 21;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v46, &v43, 0, (uint64_t)&v49, (uint64_t)&v39);
  *(void *)&long long v43 = 0x582FBDD84553E215;
  *((void *)&v43 + 1) = "md::AssetInjectionLogic]";
  uint64_t v44 = 23;
  *(void *)&long long v39 = 0xD77FB76AFC10A710;
  *((void *)&v39 + 1) = "md::AssetInjectionContext]";
  *(void *)&long long v40 = 25;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 1;
  long long v50 = xmmword_1E5A97E00;
  *(void *)&long long v51 = 16;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v43 = 0x85B8F2BE93EDF996;
  *((void *)&v43 + 1) = "md::AssetLogic]";
  uint64_t v44 = 14;
  *(void *)&long long v39 = 0x88B81689974D86F3;
  *((void *)&v39 + 1) = "md::AssetContext]";
  *(void *)&long long v40 = 16;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 1;
  long long v50 = xmmword_1E5A97E18;
  *(void *)&long long v51 = 29;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v43 = 0x8E629317B3523E63;
  *((void *)&v43 + 1) = "md::CameraLogic]";
  uint64_t v44 = 15;
  *(void *)&long long v39 = 0x1AF456233693CD46;
  *((void *)&v39 + 1) = "md::CameraContext]";
  *(void *)&long long v40 = 17;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 1;
  long long v50 = xmmword_1E5A979C8;
  *(void *)&long long v51 = 20;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v43 = 0x3B36D43422893971;
  *((void *)&v43 + 1) = "md::DrapingLogic]";
  uint64_t v44 = 16;
  *(void *)&long long v39 = 0x1B9039CBDAB12E5CLL;
  *((void *)&v39 + 1) = "md::DrapingContext]";
  *(void *)&long long v40 = 18;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 4;
  long long v52 = xmmword_1E5A96E78;
  long long v53 = unk_1E5A96E88;
  long long v54 = xmmword_1E5A96E98;
  long long v55 = *(_OWORD *)&off_1E5A96EA8;
  long long v50 = xmmword_1E5A96E58;
  long long v51 = unk_1E5A96E68;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  unint64_t v46 = 0x17767EADC5B287BLL;
  unsigned int v47 = "md::ElevationLogic]";
  uint64_t v48 = 18;
  *(void *)&long long v49 = &v50;
  *(void *)&long long v43 = 0x8BD499FBD96FBB9ELL;
  *((void *)&v43 + 1) = "md::ElevationContext]";
  uint64_t v44 = 20;
  char v45 = 1;
  *((void *)&v49 + 1) = 2;
  long long v50 = xmmword_1E5A97A70;
  long long v51 = unk_1E5A97A80;
  long long v52 = xmmword_1E5A97A90;
  *(void *)&long long v39 = &v40;
  *((void *)&v39 + 1) = 1;
  long long v40 = xmmword_1E5A97AA0;
  *(void *)&long long v41 = 25;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v46, &v43, 0, (uint64_t)&v49, (uint64_t)&v39);
  *(void *)&long long v39 = 0x701C95861FC50076;
  *((void *)&v39 + 1) = "md::GeometryLogic]";
  *(void *)&long long v40 = 17;
  *(void *)&long long v49 = 0x3070CB6B3C7F21D3;
  *((void *)&v49 + 1) = "md::GeometryContext]";
  *(void *)&long long v50 = 19;
  BYTE8(v50) = 1;
  *(void *)&long long v43 = &v44;
  *((void *)&v43 + 1) = 0;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v39, &v49, 0, (uint64_t)&v43, (uint64_t)&v46);
  unint64_t v46 = 0x4AC7AB7561675F6;
  unsigned int v47 = "md::GridLogic]";
  uint64_t v48 = 13;
  *(void *)&long long v43 = 0x336A901A15BB7353;
  *((void *)&v43 + 1) = "md::GridContext]";
  uint64_t v44 = 15;
  char v45 = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 1;
  long long v50 = xmmword_1E5A97DD0;
  *(void *)&long long v51 = 21;
  *(void *)&long long v39 = &v40;
  *((void *)&v39 + 1) = 1;
  long long v40 = xmmword_1E5A97CE0;
  *(void *)&long long v41 = 24;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v46, &v43, 0, (uint64_t)&v49, (uint64_t)&v39);
  unint64_t v46 = 0x8B855FB229857EA1;
  unsigned int v47 = "md::IdentifiedResourceLogic]";
  uint64_t v48 = 27;
  *(void *)&long long v49 = &v50;
  *(void *)&long long v43 = 0x12B1E486D3040E2CLL;
  *((void *)&v43 + 1) = "md::IdentifiedResourceContext]";
  uint64_t v44 = 29;
  char v45 = 1;
  *((void *)&v49 + 1) = 4;
  long long v52 = xmmword_1E5A97C40;
  long long v53 = unk_1E5A97C50;
  long long v54 = xmmword_1E5A97C60;
  long long v55 = *(_OWORD *)&off_1E5A97C70;
  long long v50 = xmmword_1E5A97C20;
  long long v51 = unk_1E5A97C30;
  *(void *)&long long v39 = &v40;
  *((void *)&v39 + 1) = 1;
  long long v40 = xmmword_1E5A97C80;
  *(void *)&long long v41 = 25;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v46, &v43, 0, (uint64_t)&v49, (uint64_t)&v39);
  unint64_t v46 = 0x20A1ED17D78F322BLL;
  unsigned int v47 = "md::LabelsLogic]";
  uint64_t v48 = 15;
  *(void *)&long long v49 = &v50;
  *(void *)&long long v43 = 0xA588623CD4116DAELL;
  *((void *)&v43 + 1) = "md::LabelsContext]";
  uint64_t v44 = 17;
  char v45 = 1;
  *((void *)&v49 + 1) = 1;
  long long v50 = xmmword_1E5A97DD0;
  *(void *)&long long v51 = 21;
  *(void *)&long long v39 = &v40;
  *((void *)&v39 + 1) = 1;
  long long v40 = xmmword_1E5A97DE8;
  *(void *)&long long v41 = 25;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v46, &v43, 0, (uint64_t)&v49, (uint64_t)&v39);
  *(void *)&long long v39 = 0x90C2E4CBBB63E301;
  *((void *)&v39 + 1) = "md::LayerDataLogic]";
  *(void *)&long long v40 = 18;
  *(void *)&long long v49 = 0x7851AF310F49C988;
  *((void *)&v49 + 1) = "md::LayerDataLogicContext]";
  *(void *)&long long v50 = 25;
  BYTE8(v50) = 1;
  *(void *)&long long v43 = &v44;
  *((void *)&v43 + 1) = 0;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v39, &v49, 0, (uint64_t)&v43, (uint64_t)&v46);
  unint64_t v46 = 0x653D1F33EF15EF04;
  unsigned int v47 = "md::LoadingStatusLogic]";
  uint64_t v48 = 22;
  *(void *)&long long v43 = 0x90B6813830DCB581;
  *((void *)&v43 + 1) = "md::LoadingStatusContext]";
  uint64_t v44 = 24;
  char v45 = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 1;
  long long v50 = xmmword_1E5A97E00;
  *(void *)&long long v51 = 16;
  *(void *)&long long v39 = &v40;
  *((void *)&v39 + 1) = 1;
  long long v40 = xmmword_1E5A97E18;
  *(void *)&long long v41 = 29;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v46, &v43, 0, (uint64_t)&v49, (uint64_t)&v39);
  *(void *)&long long v43 = 0x91E65CD7F1A7A7FALL;
  *((void *)&v43 + 1) = "md::LightingLogic]";
  uint64_t v44 = 17;
  *(void *)&long long v39 = 0x41E8D6E445F4145;
  *((void *)&v39 + 1) = "md::LightingLogicContext]";
  *(void *)&long long v40 = 24;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 4;
  long long v52 = xmmword_1E5A96DA0;
  long long v53 = unk_1E5A96DB0;
  long long v54 = xmmword_1E5A96DC0;
  long long v55 = *(_OWORD *)&off_1E5A96DD0;
  long long v50 = xmmword_1E5A96D80;
  long long v51 = unk_1E5A96D90;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v43 = 0x738A703709805788;
  *((void *)&v43 + 1) = "md::LocalNorthLogic]";
  uint64_t v44 = 19;
  *(void *)&long long v39 = 0xC81F81A7CB7767BBLL;
  *((void *)&v39 + 1) = "md::LocalNorthLogicContext]";
  *(void *)&long long v40 = 26;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 3;
  long long v52 = xmmword_1E5A970B8;
  long long v53 = unk_1E5A970C8;
  *(void *)&long long v54 = 17;
  long long v50 = xmmword_1E5A97098;
  long long v51 = unk_1E5A970A8;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v43 = 0xBDB8C71631E0AA6CLL;
  *((void *)&v43 + 1) = "md::MapZoomLevelStyleLogic]";
  uint64_t v44 = 26;
  *(void *)&long long v39 = 0xF0AA2DB42EB710AFLL;
  *((void *)&v39 + 1) = "md::MapZoomLevelStyleLogicContext]";
  *(void *)&long long v40 = 33;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 2;
  long long v50 = xmmword_1E5A97A40;
  long long v51 = unk_1E5A97A50;
  long long v52 = xmmword_1E5A97A60;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v43 = 0xA1851987210F8D55;
  *((void *)&v43 + 1) = "md::MaterialLogic]";
  uint64_t v44 = 17;
  *(void *)&long long v39 = 0xD2404CDD1F9A6950;
  *((void *)&v39 + 1) = "md::MaterialContext]";
  *(void *)&long long v40 = 19;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 5;
  long long v54 = xmmword_1E5A96E20;
  long long v55 = *(_OWORD *)&off_1E5A96E30;
  long long v56 = xmmword_1E5A96E40;
  *(void *)&long long v57 = 21;
  long long v50 = xmmword_1E5A96DE0;
  long long v51 = unk_1E5A96DF0;
  long long v52 = xmmword_1E5A96E00;
  long long v53 = unk_1E5A96E10;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v43 = 0x88BE5DF80D25DA79;
  *((void *)&v43 + 1) = "md::MeshRenderableLogic]";
  uint64_t v44 = 23;
  *(void *)&long long v39 = 0xF014CCE28176CA44;
  *((void *)&v39 + 1) = "md::MeshRenderableContext]";
  *(void *)&long long v40 = 25;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 9;
  long long v60 = xmmword_1E5A96F88;
  long long v61 = *(_OWORD *)&off_1E5A96F98;
  long long v62 = xmmword_1E5A96FA8;
  uint64_t v63 = 15;
  long long v56 = xmmword_1E5A96F48;
  long long v57 = unk_1E5A96F58;
  long long v58 = xmmword_1E5A96F68;
  long long v59 = unk_1E5A96F78;
  long long v52 = xmmword_1E5A96F08;
  long long v53 = unk_1E5A96F18;
  long long v54 = xmmword_1E5A96F28;
  long long v55 = *(_OWORD *)&off_1E5A96F38;
  long long v50 = xmmword_1E5A96EE8;
  long long v51 = unk_1E5A96EF8;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  unint64_t v46 = 0xBEC1A12372CEEC00;
  unsigned int v47 = "md::NavigationLogic]";
  uint64_t v48 = 19;
  *(void *)&long long v49 = &v50;
  *(void *)&long long v43 = 0x1B8B241A8D896A1DLL;
  *((void *)&v43 + 1) = "md::NavigationContext]";
  uint64_t v44 = 21;
  char v45 = 1;
  *((void *)&v49 + 1) = 3;
  long long v52 = xmmword_1E5A97A00;
  long long v53 = unk_1E5A97A10;
  *(void *)&long long v54 = 17;
  long long v50 = xmmword_1E5A979E0;
  long long v51 = unk_1E5A979F0;
  *(void *)&long long v39 = &v40;
  *((void *)&v39 + 1) = 1;
  long long v40 = xmmword_1E5A97A28;
  *(void *)&long long v41 = 23;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v46, &v43, 0, (uint64_t)&v49, (uint64_t)&v39);
  unint64_t v46 = 0x7173CF8D2BE8FE53;
  unsigned int v47 = "md::RouteLineLogic]";
  uint64_t v48 = 18;
  *(void *)&long long v49 = &v50;
  *(void *)&long long v43 = 0x8E4587A431F9C696;
  *((void *)&v43 + 1) = "md::RouteLineContext]";
  uint64_t v44 = 20;
  char v45 = 1;
  *((void *)&v49 + 1) = 4;
  long long v52 = xmmword_1E5A97AD8;
  long long v53 = unk_1E5A97AE8;
  long long v54 = xmmword_1E5A97AF8;
  long long v55 = *(_OWORD *)&off_1E5A97B08;
  long long v50 = xmmword_1E5A97AB8;
  long long v51 = unk_1E5A97AC8;
  *(void *)&long long v39 = &v40;
  *((void *)&v39 + 1) = 2;
  long long v40 = xmmword_1E5A97B18;
  long long v41 = unk_1E5A97B28;
  long long v42 = xmmword_1E5A97B38;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, &v46, &v43, 0, (uint64_t)&v49, (uint64_t)&v39);
  *(void *)&long long v39 = 0x6139471CB89383CBLL;
  *((void *)&v39 + 1) = "md::NonTiledAssetLogic]";
  *(void *)&long long v40 = 22;
  *(void *)&long long v49 = 0x932EE29454ABDC4ELL;
  *((void *)&v49 + 1) = "md::NonTiledAssetContext]";
  *(void *)&long long v50 = 24;
  BYTE8(v50) = 1;
  *(void *)&long long v43 = &v44;
  *((void *)&v43 + 1) = 0;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v39, &v49, 0, (uint64_t)&v43, (uint64_t)&v46);
  *(void *)&long long v43 = 0x87668FB4D087F775;
  *((void *)&v43 + 1) = "md::OverlaysLogic]";
  uint64_t v44 = 17;
  *(void *)&long long v39 = 0xADE8F13E6C18D970;
  *((void *)&v39 + 1) = "md::OverlaysContext]";
  *(void *)&long long v40 = 19;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 4;
  long long v52 = xmmword_1E5A97E50;
  long long v53 = unk_1E5A97E60;
  long long v54 = xmmword_1E5A97E70;
  long long v55 = *(_OWORD *)&off_1E5A97E80;
  long long v50 = xmmword_1E5A97E30;
  long long v51 = unk_1E5A97E40;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v43 = 0xAF46DE79C836B0D8;
  *((void *)&v43 + 1) = "md::TileSelectionLogic]";
  uint64_t v44 = 22;
  *(void *)&long long v39 = 0x64780CBD71DF7CF5;
  *((void *)&v39 + 1) = "md::TileSelectionContext]";
  *(void *)&long long v40 = 24;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 3;
  long long v52 = xmmword_1E5A97CB8;
  long long v53 = unk_1E5A97CC8;
  *(void *)&long long v54 = 21;
  long long v50 = xmmword_1E5A97C98;
  long long v51 = unk_1E5A97CA8;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  uint64_t v14 = 0xCBF29CE484222325;
  uint64_t v15 = 0x26u;
  do
    uint64_t v14 = 0x100000001B3 * (v14 ^ aStdStringViewG_928[v15++]);
  while (v15 != 368);
  unint64_t v46 = v14;
  unsigned int v47 = "md::TileDependencyLogicImpl<md::TileDependencies<>, md::TileDependencies<md::TileDependency<md::MapDataType::Flyover, md::FlyoverTileDataResolverContext>, md::TileDependency<md::MapDataType::FlyoverMetadata, md::FlyoverTileDataResolverContext>, md::TileDependency<md::MapDataType::FlyoverDsm, md::FlyoverTileDataResolverContext>>>]";
  uint64_t v48 = 330;
  *(void *)&long long v43 = 0x8677AD8BA9352C1DLL;
  *((void *)&v43 + 1) = "md::ResolvedTileSelectionContext]";
  uint64_t v44 = 32;
  char v45 = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 1;
  long long v50 = xmmword_1E5A97CE0;
  *(void *)&long long v51 = 24;
  *(void *)&long long v39 = &v40;
  *((void *)&v39 + 1) = 1;
  long long v40 = xmmword_1E5A97CF8;
  *(void *)&long long v41 = 34;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, &v46, &v43, 0, (uint64_t)&v49, (uint64_t)&v39);
  *(void *)&long long v43 = 0x87BA2765F9E38E05;
  *((void *)&v43 + 1) = "md::PendingSceneLogic]";
  uint64_t v44 = 21;
  *(void *)&long long v39 = 0x9F2276D081C2CB20;
  *((void *)&v39 + 1) = "md::PendingSceneContext]";
  *(void *)&long long v40 = 23;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 5;
  long long v54 = xmmword_1E5A97D50;
  long long v55 = *(_OWORD *)&off_1E5A97D60;
  long long v56 = xmmword_1E5A97D70;
  *(void *)&long long v57 = 25;
  long long v50 = xmmword_1E5A97D10;
  long long v51 = unk_1E5A97D20;
  long long v52 = xmmword_1E5A97D30;
  long long v53 = unk_1E5A97D40;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v43 = 0x1FCDF994595CDE24;
  *((void *)&v43 + 1) = "md::PuckLocationAnimationTracingLogic]";
  uint64_t v44 = 37;
  *(void *)&long long v39 = 0xA81ACD73F9C92AA1;
  *((void *)&v39 + 1) = "md::PuckLocationAnimationTracingContext]";
  *(void *)&long long v40 = 39;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 1;
  long long v50 = xmmword_1E5A98030;
  *(void *)&long long v51 = 21;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v43 = 0x33D44727E59BE9E9;
  *((void *)&v43 + 1) = "md::PuckLogic]";
  uint64_t v44 = 13;
  *(void *)&long long v39 = 0x9AEE7E062376E454;
  *((void *)&v39 + 1) = "md::PuckContext]";
  *(void *)&long long v40 = 15;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 9;
  long long v60 = xmmword_1E5A97BE8;
  long long v61 = *(_OWORD *)&off_1E5A97BF8;
  long long v62 = xmmword_1E5A97C08;
  uint64_t v63 = 24;
  long long v56 = xmmword_1E5A97BA8;
  long long v57 = unk_1E5A97BB8;
  long long v58 = xmmword_1E5A97BC8;
  long long v59 = unk_1E5A97BD8;
  long long v52 = xmmword_1E5A97B68;
  long long v53 = unk_1E5A97B78;
  long long v54 = xmmword_1E5A97B88;
  long long v55 = *(_OWORD *)&off_1E5A97B98;
  long long v50 = xmmword_1E5A97B48;
  long long v51 = unk_1E5A97B58;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v43 = 0xDEBD99099DA2C65BLL;
  *((void *)&v43 + 1) = "md::RegistryLogic]";
  uint64_t v44 = 17;
  *(void *)&long long v39 = 0xFBD83FDA8879FF7ELL;
  *((void *)&v39 + 1) = "md::RegistryContext]";
  *(void *)&long long v40 = 19;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 1;
  long long v50 = xmmword_1E5A97E00;
  *(void *)&long long v51 = 16;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v43 = 0x8B45D3D7944796A2;
  *((void *)&v43 + 1) = "md::PendingRegistryLogic]";
  uint64_t v44 = 24;
  *(void *)&long long v39 = 0xA8300AA8F44B09FFLL;
  *((void *)&v39 + 1) = "md::PendingRegistryContext]";
  *(void *)&long long v40 = 26;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 1;
  long long v50 = xmmword_1E5A97DB8;
  *(void *)&long long v51 = 23;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  unint64_t v46 = 0x2B7C4502BD3C99C6;
  unsigned int v47 = "md::ResolvedSceneLogic]";
  uint64_t v48 = 22;
  *(void *)&long long v49 = &v50;
  *(void *)&long long v43 = 0x99BED48DEFBBD82BLL;
  *((void *)&v43 + 1) = "md::SceneContext]";
  uint64_t v44 = 16;
  char v45 = 1;
  *(void *)&long long v39 = &v40;
  *((void *)&v39 + 1) = 1;
  long long v40 = xmmword_1E5A97DB8;
  *(void *)&long long v41 = 23;
  *((void *)&v49 + 1) = 2;
  long long v50 = xmmword_1E5A97D88;
  long long v51 = unk_1E5A97D98;
  long long v52 = xmmword_1E5A97DA8;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, &v46, &v43, 0, (uint64_t)&v39, (uint64_t)&v49);
  *(void *)&long long v39 = 0x5CBBA028798243FLL;
  *((void *)&v39 + 1) = "md::RouteOverlayLogic]";
  *(void *)&long long v40 = 21;
  *(void *)&long long v49 = 0x13043386C0978CC2;
  *((void *)&v49 + 1) = "md::RouteOverlayContext]";
  *(void *)&long long v50 = 23;
  BYTE8(v50) = 1;
  *(void *)&long long v43 = &v44;
  *((void *)&v43 + 1) = 0;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, (unint64_t *)&v39, &v49, 0, (uint64_t)&v43, (uint64_t)&v46);
  *(void *)&long long v43 = 0x1F3242C85D9F2F62;
  *((void *)&v43 + 1) = "md::SceneQueryLogic]";
  uint64_t v44 = 19;
  *(void *)&long long v39 = 0xDFC317497CF9A4BFLL;
  *((void *)&v39 + 1) = "md::SceneQueryContext]";
  *(void *)&long long v40 = 21;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 5;
  long long v54 = xmmword_1E5A97060;
  long long v55 = *(_OWORD *)&off_1E5A97070;
  long long v56 = xmmword_1E5A97080;
  *(void *)&long long v57 = 19;
  long long v50 = xmmword_1E5A97020;
  long long v51 = unk_1E5A97030;
  long long v52 = xmmword_1E5A97040;
  long long v53 = unk_1E5A97050;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v39 = 0xD2443A61CED86C69;
  *((void *)&v39 + 1) = "md::SettingsLogic]";
  *(void *)&long long v40 = 17;
  *(void *)&long long v49 = 0xC97B9E962ADF4AD4;
  *((void *)&v49 + 1) = "md::SettingsContext]";
  *(void *)&long long v50 = 19;
  BYTE8(v50) = 1;
  *(void *)&long long v43 = &v44;
  *((void *)&v43 + 1) = 0;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, (unint64_t *)&v39, &v49, 0, (uint64_t)&v43, (uint64_t)&v46);
  *(void *)&long long v39 = 0x3F812BA5755E8568;
  *((void *)&v39 + 1) = "md::SharedResourcesLogic]";
  *(void *)&long long v40 = 24;
  *(void *)&long long v49 = 0xA60DDA5A69582425;
  *((void *)&v49 + 1) = "md::SharedResourcesContext]";
  *(void *)&long long v50 = 26;
  BYTE8(v50) = 1;
  *(void *)&long long v43 = &v44;
  *((void *)&v43 + 1) = 0;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, (unint64_t *)&v39, &v49, 0, (uint64_t)&v43, (uint64_t)&v46);
  *(void *)&long long v43 = 0xDAD5CEE0DC5FF509;
  *((void *)&v43 + 1) = "md::SkyLogic]";
  uint64_t v44 = 12;
  *(void *)&long long v39 = 0x7C7EC6C7C111B0D0;
  *((void *)&v39 + 1) = "md::SkyLogicContext]";
  *(void *)&long long v40 = 19;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 2;
  long long v50 = xmmword_1E5A97A40;
  long long v51 = unk_1E5A97A50;
  long long v52 = xmmword_1E5A97A60;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v43 = 0x652FEFC5C602CC21;
  *((void *)&v43 + 1) = "md::StandardLogic]";
  uint64_t v44 = 17;
  *(void *)&long long v39 = 0xFFA06A69D924B0E8;
  *((void *)&v39 + 1) = "md::StandardLogicContext]";
  *(void *)&long long v40 = 24;
  BYTE8(v40) = 1;
  *(void *)&long long v49 = &v50;
  *((void *)&v49 + 1) = 2;
  long long v50 = xmmword_1E5A970E0;
  long long v51 = unk_1E5A970F0;
  long long v52 = xmmword_1E5A97100;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, (unint64_t *)&v43, &v39, 0, (uint64_t)&v49, (uint64_t)&v46);
  *(void *)&long long v39 = 0x2FED70A4459DFCA1;
  *((void *)&v39 + 1) = "md::StyleLogic]";
  *(void *)&long long v40 = 14;
  *(void *)&long long v49 = 0xE42D19AFCA302E68;
  *((void *)&v49 + 1) = "md::StyleLogicContext]";
  *(void *)&long long v50 = 21;
  BYTE8(v50) = 1;
  *(void *)&long long v43 = &v44;
  *((void *)&v43 + 1) = 0;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, (unint64_t *)&v39, &v49, 0, (uint64_t)&v43, (uint64_t)&v46);
  *(void *)&long long v39 = 0x41948F4CADE567A1;
  *((void *)&v39 + 1) = "md::DebugDrawLogic]";
  *(void *)&long long v40 = 18;
  *(void *)&long long v49 = 0x3619066E3FB5F2CLL;
  *((void *)&v49 + 1) = "md::DebugDrawContext]";
  *(void *)&long long v50 = 20;
  BYTE8(v50) = 1;
  *(void *)&long long v43 = &v44;
  *((void *)&v43 + 1) = 0;
  unint64_t v46 = (unint64_t)&v48;
  unsigned int v47 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)v13, (unint64_t *)&v39, &v49, 0, (uint64_t)&v43, (uint64_t)&v46);
  if (a2) {
    __int16 v16 = 1;
  }
  else {
    __int16 v16 = 3;
  }
  if (a2) {
    int v17 = 1;
  }
  else {
    int v17 = 4;
  }
  if (a2)
  {
    uint64_t v19 = (void *)((char *)this + 128);
    uint64_t v18 = *((void *)v38 + 16);
    if (v18)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v20 = (void *)v18;
          unsigned int v21 = *(unsigned __int16 *)(v18 + 26);
          if (v21 < 9) {
            break;
          }
          uint64_t v18 = *v20;
          uint64_t v19 = v20;
          if (!*v20) {
            goto LABEL_28;
          }
        }
        if (v21 == 8) {
          break;
        }
        uint64_t v18 = v20[1];
        if (!v18)
        {
          uint64_t v19 = v20 + 1;
          goto LABEL_28;
        }
      }
    }
    else
    {
      uint64_t v20 = (void *)((char *)v38 + 128);
LABEL_28:
      long long v22 = operator new(0x20uLL);
      v22[13] = 8;
      *(void *)long long v22 = 0;
      *((void *)v22 + 1) = 0;
      *((void *)v22 + 2) = v20;
      *uint64_t v19 = v22;
      uint64_t v23 = **((void **)v38 + 15);
      if (v23)
      {
        *((void *)v38 + 15) = v23;
        long long v22 = (_WORD *)*v19;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v38 + 16), (uint64_t *)v22);
      ++*((void *)v38 + 17);
    }
  }
  LOBYTE(v49) = 30;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)v11, 0x1Eu, &v49)+ 17) = 2;
  LOBYTE(v49) = 41;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)v11, 0x29u, &v49)+ 17) = 2;
  LOBYTE(v49) = 42;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)v11, 0x2Au, &v49)+ 17) = 2;
  LOWORD(v49) = 51;
  WORD1(v49) = v17;
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, 0x33u, &v49)+ 18) = v17 << 16;
  LOWORD(v49) = 27;
  WORD1(v49) = a2;
  WORD2(v49) = 55;
  WORD3(v49) = a2;
  WORD4(v49) = 56;
  WORD5(v49) = a2;
  WORD6(v49) = 62;
  HIWORD(v49) = a2;
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, 0x1Bu, &v49)+ 18) = (a2 << 16) | 1;
  int v24 = WORD3(v49);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, WORD2(v49), (_WORD *)&v49 + 2)+ 18) = (v24 << 16) | 1;
  int v25 = WORD5(v49);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, WORD4(v49), (_WORD *)&v49 + 4)+ 18) = (v25 << 16) | 1;
  int v26 = HIWORD(v49);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, WORD6(v49), (_WORD *)&v49 + 6)+ 18) = (v26 << 16) | 1;
  LOWORD(v49) = 63;
  WORD1(v49) = a2;
  WORD2(v49) = 35;
  if (a2) {
    __int16 v27 = 7;
  }
  else {
    __int16 v27 = 2;
  }
  WORD3(v49) = v16;
  WORD4(v49) = 20;
  WORD5(v49) = a2;
  WORD6(v49) = 24;
  HIWORD(v49) = a2;
  LOWORD(v50) = 69;
  WORD1(v50) = a2;
  WORD2(v50) = 11;
  WORD3(v50) = v27;
  WORD4(v50) = 12;
  WORD5(v50) = v27;
  WORD6(v50) = 71;
  HIWORD(v50) = v27;
  LOWORD(v51) = 72;
  WORD1(v51) = v27;
  WORD2(v51) = 74;
  WORD3(v51) = a2;
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, v49, &v49)+ 18) = (a2 << 16) | 2;
  int v28 = WORD3(v49);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, WORD2(v49), (_WORD *)&v49 + 2)+ 18) = (v28 << 16) | 2;
  int v29 = WORD5(v49);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, WORD4(v49), (_WORD *)&v49 + 4)+ 18) = (v29 << 16) | 2;
  int v30 = HIWORD(v49);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, WORD6(v49), (_WORD *)&v49 + 6)+ 18) = (v30 << 16) | 2;
  int v31 = WORD1(v50);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, v50, &v50)+ 18) = (v31 << 16) | 2;
  int v32 = WORD3(v50);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, WORD2(v50), (_WORD *)&v50 + 2)+ 18) = (v32 << 16) | 2;
  int v33 = WORD5(v50);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, WORD4(v50), (_WORD *)&v50 + 4)+ 18) = (v33 << 16) | 2;
  int v34 = HIWORD(v50);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, WORD6(v50), (_WORD *)&v50 + 6)+ 18) = (v34 << 16) | 2;
  int v35 = WORD1(v51);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, v51, &v51)+ 18) = (v35 << 16) | 2;
  int v36 = WORD3(v51);
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)v38 + 80, WORD2(v51), (_WORD *)&v51 + 2)+ 18) = (v36 << 16) | 2;
  return v38;
}

void sub_1A23E50AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,md::MapEngineMode *a26)
{
  *(void *)a26 = &unk_1EF5463F0;
  if (*((unsigned char *)a26 + 548)) {
    *((unsigned char *)a26 + 548) = 0;
  }
  md::MapEngineMode::~MapEngineMode(a26);
  _Unwind_Resume(a1);
}

uint64_t md::PolygonLayerDataSource::shouldFilterFeature()
{
  return 0;
}

void md::PolygonLayerDataSource::resourceKeyForType(uint64_t a1@<X0>, char a2@<W1>, unsigned __int8 *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  __int16 v8 = *(_WORD *)(a1 + 584);
  if (*(unsigned char *)a5) {
    int v9 = *(_DWORD *)(a5 + 4);
  }
  else {
    int v9 = 2147483646;
  }
  uint64_t v10 = *(void *)(a3 + 4);
  int v18 = v10;
  int v11 = a3[1];
  int v12 = *a3;
  *(unsigned char *)a6 = a2;
  *(_WORD *)(a6 + 2) = v8;
  *(_DWORD *)(a6 + 4) = v9;
  *(void *)(a6 + 8) = a6 + 40;
  *(void *)(a6 + 16) = a6 + 40;
  *(void *)(a6 + 24) = a6 + 40;
  *(void *)(a6 + 32) = 32;
  *(void *)(a6 + 72) = 0;
  int v19 = HIDWORD(v10);
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v18;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v11;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v12;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  unint64_t v13 = *(unsigned __int8 **)(a6 + 16);
  uint64_t v14 = *(unsigned __int8 **)(a6 + 8);
  unint64_t v15 = v13 - v14;
  if (v13 == v14)
  {
    unint64_t v16 = 0;
  }
  else
  {
    unint64_t v16 = 0;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    do
    {
      unsigned int v17 = *v14++;
      v16 ^= (v16 << 6) + (v16 >> 2) - 0x61C8864680B583EBLL + v17;
      --v15;
    }
    while (v15);
  }
  *(void *)(a6 + 72) = v16;
  *(void *)(a6 + 88) = a4;
}

void md::PolygonLayerDataSource::createLayerData(unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  sp_mut = std::__get_sp_mut((const void *)(a1 + 784));
  std::__sp_mut::lock(sp_mut);
  int v9 = *(std::__shared_weak_count **)(a1 + 792);
  uint64_t v45 = *(void *)(a1 + 784);
  unint64_t v46 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  std::__sp_mut::unlock(sp_mut);
  unsigned int v10 = atomic_load((unsigned int *)(a1 + 800));
  if (v45)
  {
    float v37 = *(float *)&v10;
    int v11 = *(int32x2_t **)(a2 + 16);
    __int32 v12 = v11[1].i32[0];
    v43[0] = v11[1].i32[1];
    v43[1] = v12;
    int32x2_t v44 = vrev64_s32(*v11);
    memset(v42, 0, sizeof(v42));
    gdc::LayerDataSource::populateLoadMetadataListFromMap(*a3, a3[1], v42);
    std::vector<unsigned int> __p = 0;
    long long v40 = 0;
    long long v41 = 0;
    unint64_t v13 = (unsigned __int16 *)*a3;
    uint64_t v14 = (unsigned __int16 *)a3[1];
    if ((unsigned __int16 *)*a3 != v14)
    {
      while (*(unsigned __int16 *)(a1 + 584) != *v13)
      {
        v13 += 24;
        if (v13 == v14) {
          goto LABEL_40;
        }
      }
    }
    if (v13 != v14)
    {
      for (uint64_t i = (void *)*((void *)v13 + 3); i; uint64_t i = (void *)*i)
      {
        uint64_t v16 = i[14];
        uint64_t v17 = i[15];
        *(void *)&long long v38 = v16;
        *((void *)&v38 + 1) = v17;
        if (v17)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
          int v19 = v40;
          int v18 = v41;
          if (v40 >= (void *)v41) {
            goto LABEL_17;
          }
          void *v40 = v16;
          v19[1] = v17;
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
          uint64_t v20 = v19 + 2;
        }
        else
        {
          int v19 = v40;
          int v18 = v41;
          if (v40 >= (void *)v41)
          {
LABEL_17:
            unsigned int v21 = __p;
            uint64_t v22 = ((char *)v19 - (unsigned char *)__p) >> 4;
            unint64_t v23 = v22 + 1;
            if ((unint64_t)(v22 + 1) >> 60) {
              abort();
            }
            uint64_t v24 = v18 - (unsigned char *)__p;
            if (v24 >> 3 > v23) {
              unint64_t v23 = v24 >> 3;
            }
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v25 = v23;
            }
            if (v25 >> 60) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            int v26 = (char *)operator new(16 * v25);
            __int16 v27 = &v26[16 * v22];
            uint64_t v28 = *((void *)&v38 + 1);
            *(_OWORD *)__int16 v27 = v38;
            if (v28)
            {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
              int v19 = v40;
            }
            uint64_t v20 = v27 + 16;
            if (v19 == v21)
            {
              std::vector<unsigned int> __p = v27;
              long long v41 = &v26[16 * v25];
            }
            else
            {
              int v29 = v19;
              do
              {
                long long v30 = *((_OWORD *)v29 - 1);
                v29 -= 2;
                *((_OWORD *)v27 - 1) = v30;
                v27 -= 16;
                *int v29 = 0;
                v29[1] = 0;
              }
              while (v29 != v21);
              std::vector<unsigned int> __p = v27;
              long long v40 = v20;
              long long v41 = &v26[16 * v25];
              do
              {
                int v31 = (std::__shared_weak_count *)*(v19 - 1);
                if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
                  std::__shared_weak_count::__release_weak(v31);
                }
                v19 -= 2;
              }
              while (v19 != v21);
            }
            if (v21) {
              operator delete(v21);
            }
            goto LABEL_37;
          }
          void *v40 = v16;
          v19[1] = 0;
          uint64_t v20 = v19 + 2;
        }
LABEL_37:
        long long v40 = v20;
        if (*((void *)&v38 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v38 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          (*(void (**)(void))(**((void **)&v38 + 1) + 16))(*((void *)&v38 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v38 + 1));
        }
      }
    }
LABEL_40:
    md::PolygonLayerDataSource::createPolygonTileData(&v38, a1, a2, (uint64_t)v43, (uint64_t **)&__p, &v45, (uint64_t)v42, v37);
    *(_OWORD *)a4 = v38;
    int v32 = __p;
    if (__p)
    {
      int v33 = v40;
      int v34 = __p;
      if (v40 != __p)
      {
        do
        {
          int v35 = (std::__shared_weak_count *)*(v33 - 1);
          if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
            std::__shared_weak_count::__release_weak(v35);
          }
          v33 -= 2;
        }
        while (v33 != v32);
        int v34 = __p;
      }
      long long v40 = v32;
      operator delete(v34);
    }
    if (v42[0]) {
      operator delete(v42[0]);
    }
  }
  else
  {
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
  }
  int v36 = v46;
  if (v46)
  {
    if (!atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
}

void sub_1A23E567C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void *__p)
{
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)&a14);
  if (__p) {
    operator delete(__p);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v17 - 96);
  _Unwind_Resume(a1);
}

void md::PolygonLayerDataSource::createPolygonTileData(void *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t **a5, uint64_t *a6, uint64_t a7, float a8)
{
  uint64_t v371 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a2 + 24))
  {
    unint64_t v11 = a2;
    uint64_t v297 = a3;
    char v336 = 0;
    float v337 = 0;
    id v338 = 0;
    *(_OWORD *)__n = 0u;
    long long v334 = 0u;
    int v335 = 1065353216;
    v331[0] = 0;
    v331[1] = 0;
    uint64_t v332 = 0;
    v320[0] = 0;
    v320[1] = 0;
    uint64_t v319 = v320;
    long long v321 = xmmword_1A28FE9A0;
    uint64_t v326 = 0;
    uint64_t v323 = 0;
    uint64_t v324 = 0;
    uint64_t v322 = 0;
    int v325 = 0;
    int v327 = 4;
    uint64_t v329 = 0;
    uint64_t v330 = 0;
    uint64_t v328 = 0;
    if (*(_WORD *)(a2 + 32) != 41)
    {
      char v336 = operator new(0x2D0uLL);
      float v337 = (char *)v336;
      id v338 = (char *)v336 + 720;
    }
    uint64_t v295 = a1;
    uint64_t v296 = a7;
    long long v364 = 0u;
    long long v365 = 0u;
    float v366 = 1.0;
    long long v367 = 0uLL;
    __int32 v12 = (char *)operator new(0xC8uLL);
    *((void *)v12 + 1) = 0;
    *((void *)v12 + 2) = 0;
    *(void *)__int32 v12 = &unk_1EF57FCA0;
    *(_OWORD *)(v12 + 40) = 0u;
    *(_OWORD *)(v12 + 136) = 0u;
    *(_OWORD *)(v12 + 152) = 0u;
    *(_OWORD *)(v12 + 56) = 0u;
    *(_OWORD *)(v12 + 72) = 0u;
    *(_OWORD *)(v12 + 88) = 0u;
    *(_OWORD *)(v12 + 104) = 0u;
    *(_OWORD *)(v12 + 120) = 0u;
    *(_OWORD *)(v12 + 168) = 0u;
    *((void *)v12 + 23) = 0;
    *((void *)v12 + 24) = 0;
    *(_OWORD *)(v12 + 24) = 0u;
    *((void *)v12 + 5) = v12 + 48;
    *((void *)v12 + 18) = 0;
    *((void *)v12 + 19) = 0;
    *((void *)v12 + 20) = 0;
    uint64_t v362 = v12 + 24;
    uint64_t v363 = (std::__shared_weak_count *)v12;
    unint64_t v13 = *a5;
    unint64_t v299 = a5[1];
    unint64_t v308 = v11;
    if (*a5 != v299)
    {
      uint64_t v14 = 1;
      while (1)
      {
        uint64_t v16 = *v13;
        unint64_t v15 = (std::__shared_weak_count *)v13[1];
        uint64_t v360 = *v13;
        float v361 = v15;
        if (v15) {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v17 = geo::codec::VectorTile::polygonsCount(*(geo::codec::VectorTile **)(v16 + 144));
        uint64_t v18 = v17;
        if (v17) {
          break;
        }
LABEL_256:
        if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
        v13 += 2;
        if (v13 == v299) {
          goto LABEL_259;
        }
      }
      uint64_t v300 = v13;
      uint64_t v19 = 0;
      uint64_t v302 = v17;
      uint64_t v303 = v16;
      while (1)
      {
        uint64_t v20 = geo::codec::VectorTile::polygons(*(geo::codec::VectorTile **)(v16 + 144));
        uint64_t v21 = v20;
        uint64_t v22 = v20 + (v19 << 7);
        int v23 = *(unsigned __int8 *)(v11 + 752);
        if (v23 == 2)
        {
          if (*(unsigned char *)(v22 + 127) != 1) {
            goto LABEL_12;
          }
        }
        else if (v23 == 1 && *(unsigned char *)(v20 + (v19 << 7) + 127) == 1)
        {
          goto LABEL_12;
        }
        if (((*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)v11 + 152))(v11, v360, v22) & 1) == 0)
        {
          uint64_t v24 = v21 + (v19 << 7);
          int v26 = *(unsigned __int8 *)(v24 + 127);
          unint64_t v25 = (unsigned char *)(v24 + 127);
          BOOL v27 = v26 == 1;
          if (v26 == 1) {
            uint64_t v28 = v14 + 1;
          }
          else {
            uint64_t v28 = v14;
          }
          if (v27) {
            uint64_t v29 = v14;
          }
          else {
            uint64_t v29 = 0;
          }
          uint64_t v315 = v29;
          if (*(_DWORD *)(v22 + 100))
          {
            uint64_t v305 = v25;
            md::createFeatureAttributeSet((gss::Allocator *)&v368, (uint64_t *)(v22 + 24));
            uint64_t v30 = *a6;
            *(id *)((char *)obj + 7) = 0;
            obj[0] = 0;
            HIBYTE(obj[1]) = 1;
            gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes(&v358, v30, (gss::FeatureAttributeSet *)&v368, (gss::QueryOverrides *)obj);
            int v31 = (unsigned int *)v368;
            uint64_t v32 = *((void *)&v368 + 1) - v368;
            for (unint64_t i = (uint64_t)(*((void *)&v368 + 1) - v368) >> 3; v31 != *((unsigned int **)&v368 + 1); v31 += 2)
            {
              unint64_t v34 = ((i << 6) - 0x61C8864680B583EBLL + (i >> 2) + *v31) ^ i;
              unint64_t i = (*((unsigned __int16 *)v31 + 2) - 0x61C8864680B583EBLL + (v34 << 6) + (v34 >> 2)) ^ v34;
            }
            uint64_t v313 = v22;
            uint64_t v309 = v28;
            if (*((void *)&v364 + 1))
            {
              uint8x8_t v35 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v364 + 8));
              v35.i16[0] = vaddlv_u8(v35);
              if (v35.u32[0] > 1uLL)
              {
                unint64_t v36 = i;
                if (i >= *((void *)&v364 + 1)) {
                  unint64_t v36 = i % *((void *)&v364 + 1);
                }
              }
              else
              {
                unint64_t v36 = i & (*((void *)&v364 + 1) - 1);
              }
              float v37 = *(void **)(v364 + 8 * v36);
              if (v37)
              {
                long long v38 = (void *)*v37;
                if (v38)
                {
                  if (v35.u32[0] < 2uLL)
                  {
                    while (1)
                    {
                      uint64_t v44 = v38[1];
                      if (v44 == i)
                      {
                        uint64_t v45 = v38[2];
                        uint64_t v46 = v38[3];
                        if (v46 - v45 == v32)
                        {
                          if (v45 == v46) {
                            goto LABEL_64;
                          }
                          uint64_t v47 = v368;
                          while (*(_DWORD *)v45 == *(_DWORD *)v47
                               && *(unsigned __int16 *)(v45 + 4) == *(unsigned __int16 *)(v47 + 4))
                          {
                            v45 += 8;
                            v47 += 8;
                            if (v45 == v46) {
                              goto LABEL_64;
                            }
                          }
                        }
                      }
                      else if ((v44 & (*((void *)&v364 + 1) - 1)) != v36)
                      {
                        goto LABEL_65;
                      }
                      long long v38 = (void *)*v38;
                      if (!v38) {
                        goto LABEL_65;
                      }
                    }
                  }
                  do
                  {
                    unint64_t v39 = v38[1];
                    if (v39 == i)
                    {
                      uint64_t v40 = v38[2];
                      uint64_t v41 = v38[3];
                      if (v41 - v40 == v32)
                      {
                        if (v40 == v41)
                        {
LABEL_64:
                          long long v49 = (unsigned __int8 **)(v38 + 6);
                          goto LABEL_163;
                        }
                        uint64_t v42 = v368;
                        while (*(_DWORD *)v40 == *(_DWORD *)v42
                             && *(unsigned __int16 *)(v40 + 4) == *(unsigned __int16 *)(v42 + 4))
                        {
                          v40 += 8;
                          v42 += 8;
                          if (v40 == v41) {
                            goto LABEL_64;
                          }
                        }
                      }
                    }
                    else
                    {
                      if (v39 >= *((void *)&v364 + 1)) {
                        v39 %= *((void *)&v364 + 1);
                      }
                      if (v39 != v36) {
                        break;
                      }
                    }
                    long long v38 = (void *)*v38;
                  }
                  while (v38);
                }
              }
            }
LABEL_65:
            uint64_t v50 = v21 + (v19 << 7);
            v350[0] = *(void *)(v50 + 104);
            long long v51 = [VKPolygonGroup alloc];
            LOBYTE(v53) = *(unsigned char *)(a4 + 1);
            int v55 = *(unsigned __int8 *)(v50 + 126);
            long long v54 = (char *)(v50 + 126);
            if (v55) {
              long long v56 = v350;
            }
            else {
              long long v56 = 0;
            }
            float v356 = v362;
            uint64_t v357 = v363;
            if (v363) {
              atomic_fetch_add_explicit(&v363->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            *(float *)&double v53 = (float)LODWORD(v53);
            *(float *)&double v52 = a8;
            uint64_t v57 = -[VKPolygonGroup initWithStyleQuery:tileZoom:fixedAroundCentroid:contentScale:storage:](v51, "initWithStyleQuery:tileZoom:fixedAroundCentroid:contentScale:storage:", &v358, v56, &v356, v53, v52, v295, v296, v297);
            long long v58 = (void *)v57;
            long long v59 = v357;
            if (v357 && !atomic_fetch_add(&v357->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
              std::__shared_weak_count::__release_weak(v59);
              if (v58) {
                goto LABEL_73;
              }
            }
            else if (v57)
            {
LABEL_73:
              id v60 = v58;
              obj[0] = &unk_1EF559598;
              obj[1] = v60;
              long long v61 = v337;
              if (v337 >= v338)
              {
                uint64_t v63 = std::vector<geo::_retain_ptr<VKPolygonGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__push_back_slow_path<geo::_retain_ptr<VKPolygonGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(&v336, (uint64_t)obj);
              }
              else
              {
                *(void *)float v337 = &unk_1EF559598;
                *((void *)v61 + 1) = 0;
                objc_storeStrong((id *)v61 + 1, obj[1]);
                id v62 = obj[1];
                obj[1] = 0;

                uint64_t v63 = v61 + 24;
              }
              float v337 = v63;
              obj[0] = &unk_1EF559598;

              unint64_t v11 = v22;
              if (v315)
              {
                id v64 = v60;
                obj[0] = &unk_1EF559598;
                obj[1] = v64;
                uint64_t v65 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,geo::_retain_ptr<VKPolygonGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,geo::_retain_ptr<VKPolygonGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,geo::_retain_ptr<VKPolygonGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,geo::_retain_ptr<VKPolygonGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)__n, *(void *)(v22 + 40), (void *)(v22 + 40));
                objc_storeStrong(v65 + 4, obj[1]);
                id v66 = obj[1];
                obj[1] = 0;

                obj[0] = &unk_1EF559598;
              }
            }
            uint64_t v67 = *((void *)&v368 + 1) - v368;
            unint64_t v68 = (uint64_t)(*((void *)&v368 + 1) - v368) >> 3;
            id v310 = v58;
            if (*((void *)&v368 + 1) != (void)v368)
            {
              uint64_t v69 = (unsigned int *)v368;
              do
              {
                unint64_t v70 = ((v68 << 6) - 0x61C8864680B583EBLL + (v68 >> 2) + *v69) ^ v68;
                unint64_t v68 = (*((unsigned __int16 *)v69 + 2) - 0x61C8864680B583EBLL + (v70 << 6) + (v70 >> 2)) ^ v70;
                v69 += 2;
              }
              while (v69 != *((unsigned int **)&v368 + 1));
            }
            unint64_t v71 = *((void *)&v364 + 1);
            if (*((void *)&v364 + 1))
            {
              uint8x8_t v72 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v364 + 8));
              v72.i16[0] = vaddlv_u8(v72);
              if (v72.u32[0] > 1uLL)
              {
                unint64_t v11 = v68;
                if (v68 >= *((void *)&v364 + 1)) {
                  unint64_t v11 = v68 % *((void *)&v364 + 1);
                }
              }
              else
              {
                unint64_t v11 = (*((void *)&v364 + 1) - 1) & v68;
              }
              int8x16_t v73 = *(uint64_t ***)(v364 + 8 * v11);
              if (v73)
              {
                int8x16_t v74 = *v73;
                if (*v73)
                {
                  if (v72.u32[0] < 2uLL)
                  {
                    while (1)
                    {
                      uint64_t v80 = v74[1];
                      if (v80 == v68)
                      {
                        uint64_t v81 = v74[2];
                        uint64_t v82 = v74[3];
                        if (v82 - v81 == v67)
                        {
                          if (v81 == v82) {
                            goto LABEL_117;
                          }
                          uint64_t v83 = v368;
                          while (*(_DWORD *)v81 == *(_DWORD *)v83
                               && *(unsigned __int16 *)(v81 + 4) == *(unsigned __int16 *)(v83 + 4))
                          {
                            v81 += 8;
                            v83 += 8;
                            if (v81 == v82) {
                              goto LABEL_117;
                            }
                          }
                        }
                      }
                      else if ((v80 & (*((void *)&v364 + 1) - 1)) != v11)
                      {
                        goto LABEL_118;
                      }
                      int8x16_t v74 = (uint64_t *)*v74;
                      if (!v74) {
                        goto LABEL_118;
                      }
                    }
                  }
                  do
                  {
                    unint64_t v75 = v74[1];
                    if (v75 == v68)
                    {
                      uint64_t v76 = v74[2];
                      uint64_t v77 = v74[3];
                      if (v77 - v76 == v67)
                      {
                        if (v76 == v77)
                        {
LABEL_117:
                          int v85 = v54;
                          goto LABEL_142;
                        }
                        uint64_t v78 = v368;
                        while (*(_DWORD *)v76 == *(_DWORD *)v78
                             && *(unsigned __int16 *)(v76 + 4) == *(unsigned __int16 *)(v78 + 4))
                        {
                          v76 += 8;
                          v78 += 8;
                          if (v76 == v77) {
                            goto LABEL_117;
                          }
                        }
                      }
                    }
                    else
                    {
                      if (v75 >= *((void *)&v364 + 1)) {
                        v75 %= *((void *)&v364 + 1);
                      }
                      if (v75 != v11) {
                        break;
                      }
                    }
                    int8x16_t v74 = (uint64_t *)*v74;
                  }
                  while (v74);
                }
              }
            }
LABEL_118:
            int8x16_t v74 = (uint64_t *)operator new(0x48uLL);
            int v85 = v54;
            *int8x16_t v74 = 0;
            v74[1] = v68;
            v74[2] = 0;
            v74[3] = 0;
            v74[4] = 0;
            v74[5] = gss::Allocator::instance((gss::Allocator *)v74);
            std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::__assign_with_size[abi:nn180100]<std::pair<gss::StyleAttribute,unsigned short>*,std::pair<gss::StyleAttribute,unsigned short>*>(v74 + 2, v368, *((void **)&v368 + 1), (uint64_t)(*((void *)&v368 + 1) - v368) >> 3);
            v74[6] = 0;
            v74[7] = 0;
            v74[8] = 0;
            float v86 = (float)(unint64_t)(*((void *)&v365 + 1) + 1);
            if (!v71 || (float)(v366 * (float)v71) < v86)
            {
              BOOL v87 = (v71 & (v71 - 1)) != 0;
              if (v71 < 3) {
                BOOL v87 = 1;
              }
              unint64_t v88 = v87 | (2 * v71);
              unint64_t v89 = vcvtps_u32_f32(v86 / v366);
              if (v88 <= v89) {
                size_t v90 = v89;
              }
              else {
                size_t v90 = v88;
              }
              unint64_t v71 = *((void *)&v364 + 1);
              if ((v71 & (v71 - 1)) != 0)
              {
                if (v68 >= *((void *)&v364 + 1)) {
                  unint64_t v11 = v68 % *((void *)&v364 + 1);
                }
                else {
                  unint64_t v11 = v68;
                }
              }
              else
              {
                unint64_t v11 = (*((void *)&v364 + 1) - 1) & v68;
              }
            }
            uint64_t v91 = v364;
            uint64_t v92 = *(uint64_t **)(v364 + 8 * v11);
            if (v92)
            {
              *int8x16_t v74 = *v92;
              goto LABEL_140;
            }
            *int8x16_t v74 = v365;
            *(void *)&long long v365 = v74;
            *(void *)(v91 + 8 * v11) = &v365;
            if (*v74)
            {
              unint64_t v93 = *(void *)(*v74 + 8);
              if ((v71 & (v71 - 1)) != 0)
              {
                if (v93 >= v71) {
                  v93 %= v71;
                }
              }
              else
              {
                v93 &= v71 - 1;
              }
              uint64_t v92 = (uint64_t *)(v364 + 8 * v93);
LABEL_140:
              uint64_t *v92 = (uint64_t)v74;
            }
            ++*((void *)&v365 + 1);
LABEL_142:
            unint64_t v94 = v74 + 6;
            char v95 = *v85;
            uint64_t v96 = v350[0];
            id v97 = v310;
            obj[0] = &unk_1EF559598;
            obj[1] = v97;
            id v306 = v97;
            unint64_t v99 = v74[7];
            unint64_t v98 = v74[8];
            if (v99 >= v98)
            {
              unint64_t v102 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v99 - *v94) >> 4);
              unint64_t v103 = v102 + 1;
              if (v102 + 1 > 0x555555555555555) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              unint64_t v104 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v98 - *v94) >> 4);
              if (2 * v104 > v103) {
                unint64_t v103 = 2 * v104;
              }
              if (v104 >= 0x2AAAAAAAAAAAAAALL) {
                unint64_t v105 = 0x555555555555555;
              }
              else {
                unint64_t v105 = v103;
              }
              if (v105)
              {
                if (v105 > 0x555555555555555) {
                  goto LABEL_483;
                }
                unsigned int v106 = (char *)operator new(48 * v105);
              }
              else
              {
                unsigned int v106 = 0;
              }
              uint64_t v107 = &v106[48 * v102];
              *uint64_t v107 = v95;
              *(void *)(v107 + 4) = v96;
              *((void *)v107 + 2) = v315;
              *((void *)v107 + 3) = &unk_1EF559598;
              *((void *)v107 + 4) = 0;
              objc_storeStrong((id *)v107 + 4, v310);
              id v108 = obj[1];
              obj[1] = 0;

              int8x16_t v109 = &v106[48 * v105];
              int8x16_t v110 = (char *)v74[6];
              int8x16_t v111 = (char *)v74[7];
              if (v111 == v110)
              {
                v74[6] = (uint64_t)v107;
                v74[7] = (uint64_t)(v107 + 48);
                v74[8] = (uint64_t)v109;
                uint64_t v101 = (uint64_t)(v107 + 48);
                if (!v111) {
                  goto LABEL_162;
                }
              }
              else
              {
                uint64_t v301 = v109;
                id v311 = v107 + 48;
                uint64_t v112 = 0;
                do
                {
                  long long v113 = *(_OWORD *)&v111[v112 - 48];
                  int8x16_t v114 = *(void **)&v111[v112 - 32];
                  *(void *)&v107[v112 - 16] = 0;
                  int8x16_t v115 = (id *)&v107[v112 - 16];
                  *((_OWORD *)v115 - 2) = v113;
                  *(v115 - 2) = v114;
                  *(v115 - 1) = &unk_1EF559598;
                  int16x8x2_t v116 = (id *)&v111[v112 - 16];
                  objc_storeStrong(v115, *v116);
                  id v117 = *v116;
                  id *v116 = 0;

                  v112 -= 48;
                }
                while (&v111[v112] != v110);
                int v118 = &v107[v112];
                int8x16_t v111 = (char *)v74[6];
                uint64_t v119 = (char *)v74[7];
                uint64_t v101 = (uint64_t)(v107 + 48);
                v74[6] = (uint64_t)v118;
                v74[7] = (uint64_t)v311;
                v74[8] = (uint64_t)v301;
                if (v119 == v111)
                {
                  if (!v111) {
                    goto LABEL_162;
                  }
                }
                else
                {
                  int v120 = v119 - 24;
                  do
                  {
                    *((void *)v119 - 3) = &unk_1EF559598;

                    v119 -= 48;
                    v120 -= 48;
                  }
                  while (v119 != v111);
                  uint64_t v101 = (uint64_t)v311;
                  if (!v111) {
                    goto LABEL_162;
                  }
                }
              }
              operator delete(v111);
            }
            else
            {
              *(unsigned char *)unint64_t v99 = v95;
              *(void *)(v99 + 4) = v96;
              *(void *)(v99 + 16) = v315;
              *(void *)(v99 + 24) = &unk_1EF559598;
              *(void *)(v99 + 32) = 0;
              objc_storeStrong((id *)(v99 + 32), obj[1]);
              id v100 = obj[1];
              obj[1] = 0;

              uint64_t v101 = v99 + 48;
            }
LABEL_162:
            v74[7] = v101;
            obj[0] = &unk_1EF559598;

            long long v49 = (unsigned __int8 **)(v74 + 6);
LABEL_163:
            uint64_t v121 = v21 + (v19 << 7);
            float v123 = *(float *)(v121 + 104);
            float v122 = *(float *)(v121 + 108);
            *(float *)float v355 = v123;
            *(float *)&v355[1] = v122;
            int v126 = *(unsigned __int8 *)(v121 + 126);
            float v124 = (unsigned char *)(v121 + 126);
            int v125 = v126;
            uint64_t v127 = *v49;
            unint64_t v128 = v49[1];
            unsigned int v318 = v49;
            if (*v49 == v128)
            {
              unint64_t v129 = 0;
            }
            else
            {
              unint64_t v129 = 0;
              char v130 = 0;
              do
              {
                while (*((void *)v127 + 2) == v315 && *v127 == v125)
                {
                  if (v125)
                  {
                    float v131 = *((float *)v127 + 1);
                    float v132 = vabds_f32(v131, v123);
                    if (v132 > (float)(fabsf(v131 + v123) * 0.000011921) && v132 > 1.1755e-38) {
                      break;
                    }
                    float v134 = *((float *)v127 + 2);
                    float v135 = vabds_f32(v134, v122);
                    if (v135 > (float)(fabsf(v134 + v122) * 0.000011921) && v135 > 1.1755e-38) {
                      break;
                    }
                  }
                  uint64_t v137 = (VKPolygonGroup *)*((id *)v127 + 4);

                  v127 += 48;
                  char v130 = 1;
                  unint64_t v129 = v137;
                  if (v127 == v128) {
                    goto LABEL_224;
                  }
                }
                v127 += 48;
              }
              while (v127 != v128);
              uint64_t v137 = v129;
              if (v130)
              {
LABEL_224:
                float v176 = v358;
                unint64_t v177 = v359;
                v350[0] = v358;
                v350[1] = v359;
                if (v359)
                {
                  atomic_fetch_add_explicit(&v359->__shared_owners_, 1uLL, memory_order_relaxed);
                  obj[1] = v177;
                  atomic_fetch_add_explicit(&v177->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                else
                {
                  obj[1] = 0;
                }
                obj[0] = v176;
                __p[0] = 0;
                __p[1] = 0;
                LOBYTE(v341) = 0;
                if (v176) {
                  LOBYTE(v176) = (*(uint64_t (**)(uint64_t *, void **))(*v176 + 48))(v176, __p);
                }
                LOBYTE(v341) = (_BYTE)v176;
                if (v177 && !atomic_fetch_add(&v177->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v177->__on_zero_shared)(v177);
                  std::__shared_weak_count::__release_weak(v177);
                  uint64_t v178 = v367;
                  if ((void)v367) {
                    goto LABEL_232;
                  }
                }
                else
                {
                  uint64_t v178 = v367;
                  if ((void)v367)
                  {
LABEL_232:
                    if (*v305 == 1) {
                      uint64_t v179 = v178;
                    }
                    else {
                      uint64_t v179 = 0;
                    }
LABEL_237:
                    -[VKPolygonGroup prepareForPolygon:withRounder:](v137, "prepareForPolygon:withRounder:", v313, v179, v295);
                    if ((_BYTE)v341) {
                      (*(void (**)(id))(*(void *)obj[0] + 56))(obj[0]);
                    }
                    unint64_t v180 = (std::__shared_weak_count *)__p[1];
                    if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v180->__on_zero_shared)(v180);
                      std::__shared_weak_count::__release_weak(v180);
                      uint64_t v181 = (std::__shared_weak_count *)obj[1];
                      if (obj[1]) {
                        goto LABEL_242;
                      }
                    }
                    else
                    {
                      uint64_t v181 = (std::__shared_weak_count *)obj[1];
                      if (obj[1])
                      {
LABEL_242:
                        if (!atomic_fetch_add(&v181->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v181->__on_zero_shared)(v181);
                          std::__shared_weak_count::__release_weak(v181);
                        }
                      }
                    }

                    uint64_t v182 = v359;
                    if (v359 && !atomic_fetch_add(&v359->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v182->__on_zero_shared)(v182);
                      std::__shared_weak_count::__release_weak(v182);
                    }
                    uint64_t v18 = v302;
                    uint64_t v16 = v303;
                    uint64_t v14 = v309;
                    if ((void)v368)
                    {
                      *((void *)&v368 + 1) = v368;
                      (*(void (**)(long long *, void, void))(*(void *)v370 + 40))(v370, v368, v369 - v368);
                    }
                    unint64_t v11 = v308;
                    goto LABEL_12;
                  }
                }
                uint64_t v179 = 0;
                goto LABEL_237;
              }
            }
            unint64_t v138 = [VKPolygonGroup alloc];
            LOBYTE(v140) = *(unsigned char *)(a4 + 1);
            if (*v124) {
              float32x4_t v141 = v355;
            }
            else {
              float32x4_t v141 = 0;
            }
            uint64_t v351 = v362;
            uint64_t v352 = v363;
            if (v363) {
              atomic_fetch_add_explicit(&v363->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            *(float *)&double v140 = (float)LODWORD(v140);
            *(float *)&double v139 = a8;
            uint64_t v142 = -[VKPolygonGroup initWithStyleQuery:tileZoom:fixedAroundCentroid:contentScale:storage:](v138, "initWithStyleQuery:tileZoom:fixedAroundCentroid:contentScale:storage:", &v358, v141, &v351, v140, v139, v295);

            unsigned int v143 = v352;
            if (v352 && !atomic_fetch_add(&v352->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v143->__on_zero_shared)(v143);
              std::__shared_weak_count::__release_weak(v143);
              uint64_t v144 = v318;
              if (v142) {
                goto LABEL_193;
              }
            }
            else
            {
              uint64_t v144 = v318;
              if (v142)
              {
LABEL_193:
                uint64_t v145 = v142;
                obj[0] = &unk_1EF559598;
                obj[1] = v145;
                int v146 = v337;
                if (v337 >= v338)
                {
                  uint64_t v148 = std::vector<geo::_retain_ptr<VKPolygonGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__push_back_slow_path<geo::_retain_ptr<VKPolygonGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(&v336, (uint64_t)obj);
                }
                else
                {
                  *(void *)float v337 = &unk_1EF559598;
                  *((void *)v146 + 1) = 0;
                  objc_storeStrong((id *)v146 + 1, obj[1]);
                  id v147 = obj[1];
                  obj[1] = 0;

                  uint64_t v148 = v146 + 24;
                }
                float v337 = v148;
                obj[0] = &unk_1EF559598;

                uint64_t v144 = v318;
                if (v315)
                {
                  unint64_t v149 = v145;
                  obj[0] = &unk_1EF559598;
                  obj[1] = v149;
                  uint64_t v150 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,geo::_retain_ptr<VKPolygonGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,geo::_retain_ptr<VKPolygonGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,geo::_retain_ptr<VKPolygonGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,geo::_retain_ptr<VKPolygonGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)__n, *(void *)(v313 + 40), (void *)(v313 + 40));
                  objc_storeStrong(v150 + 4, obj[1]);
                  id v151 = obj[1];
                  obj[1] = 0;

                  obj[0] = &unk_1EF559598;
                  uint64_t v144 = v318;
                }
              }
            }
            uint64_t v137 = v142;
            obj[0] = &unk_1EF559598;
            obj[1] = v137;
            unint64_t v153 = v144[1];
            unint64_t v152 = v144[2];
            if (v153 >= v152)
            {
              unint64_t v157 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v153 - *v144) >> 4);
              unint64_t v158 = v157 + 1;
              if (v157 + 1 > 0x555555555555555) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              unint64_t v159 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v152 - *v144) >> 4);
              if (2 * v159 > v158) {
                unint64_t v158 = 2 * v159;
              }
              if (v159 >= 0x2AAAAAAAAAAAAAALL) {
                unint64_t v160 = 0x555555555555555;
              }
              else {
                unint64_t v160 = v158;
              }
              if (v160)
              {
                if (v160 > 0x555555555555555) {
LABEL_483:
                }
                  std::__throw_bad_array_new_length[abi:nn180100]();
                __int16 v161 = (char *)operator new(48 * v160);
              }
              else
              {
                __int16 v161 = 0;
              }
              uint64_t v162 = &v161[48 * v157];
              char *v162 = v125;
              *(_WORD *)(v162 + 1) = v353;
              v162[3] = v354;
              *((float *)v162 + 1) = v123;
              *((float *)v162 + 2) = v122;
              *((void *)v162 + 2) = v315;
              *((void *)v162 + 3) = &unk_1EF559598;
              *((void *)v162 + 4) = 0;
              objc_storeStrong((id *)v162 + 4, v142);
              id v163 = obj[1];
              obj[1] = 0;

              unint64_t v164 = &v161[48 * v160];
              uint64_t v155 = v162 + 48;
              uint64_t v156 = v318;
              uint64_t v166 = (char *)*v318;
              uint64_t v165 = (char *)v318[1];
              if (v165 == (char *)*v318)
              {
                *unsigned int v318 = v162;
                v318[1] = v155;
                v318[2] = v164;
                if (!v165) {
                  goto LABEL_223;
                }
              }
              else
              {
                unsigned int v316 = v164;
                uint64_t v167 = 0;
                do
                {
                  long long v168 = *(_OWORD *)&v165[v167 - 48];
                  uint64_t v169 = *(void **)&v165[v167 - 32];
                  *(void *)&v162[v167 - 16] = 0;
                  uint64_t v170 = (id *)&v162[v167 - 16];
                  *((_OWORD *)v170 - 2) = v168;
                  *(v170 - 2) = v169;
                  *(v170 - 1) = &unk_1EF559598;
                  unint64_t v171 = (id *)&v165[v167 - 16];
                  objc_storeStrong(v170, *v171);
                  id v172 = *v171;
                  *unint64_t v171 = 0;

                  v167 -= 48;
                }
                while (&v165[v167] != v166);
                unint64_t v173 = &v162[v167];
                uint64_t v156 = v318;
                uint64_t v165 = (char *)*v318;
                uint64_t v174 = (char *)v318[1];
                *unsigned int v318 = v173;
                v318[1] = v155;
                v318[2] = v316;
                if (v174 != v165)
                {
                  uint64_t v175 = v174 - 24;
                  do
                  {
                    *((void *)v174 - 3) = &unk_1EF559598;

                    v174 -= 48;
                    v175 -= 48;
                  }
                  while (v174 != v165);
                  uint64_t v156 = v318;
                }
                if (!v165) {
                  goto LABEL_223;
                }
              }
              operator delete(v165);
            }
            else
            {
              *(unsigned char *)unint64_t v153 = v125;
              *(_WORD *)(v153 + 1) = v353;
              *(unsigned char *)(v153 + 3) = v354;
              *(float *)(v153 + 4) = v123;
              *(float *)(v153 + 8) = v122;
              *(void *)(v153 + 16) = v315;
              *(void *)(v153 + 24) = &unk_1EF559598;
              *(void *)(v153 + 32) = 0;
              objc_storeStrong((id *)(v153 + 32), obj[1]);
              id v154 = obj[1];
              obj[1] = 0;

              uint64_t v155 = (char *)(v153 + 48);
              uint64_t v156 = v318;
            }
LABEL_223:
            v156[1] = v155;
            obj[0] = &unk_1EF559598;

            goto LABEL_224;
          }
          uint64_t v14 = v28;
        }
LABEL_12:
        if (++v19 == v18)
        {
          unint64_t v15 = v361;
          unint64_t v13 = v300;
          goto LABEL_256;
        }
      }
    }
LABEL_259:
    id v183 = *(id *)(v11 + 768);
    (*(void (**)(uint64_t **__return_ptr))(*(void *)[v183 gglDevice] + 24))(&v358);

    obj[0] = (id)MEMORY[0x1E4F143A8];
    obj[1] = (id)3321888768;
    __p[0] = ___ZNK2md22PolygonLayerDataSource11buildMeshesERKN3geo8QuadTileERNSt3__16vectorINS1_11_retain_ptrIU8__strongP14VKPolygonGroupNS1_16_retain_objc_arcENS1_17_release_objc_arcENS1_10_hash_objcENS1_11_equal_objcEEENS5_9allocatorISF_EEEERNS5_13unordered_mapIySF_NS5_4hashIyEENS5_8equal_toIyEENSG_INS5_4pairIKySF_EEEEEERNS6_INS5_10shared_ptrINS_21GEOVectorTileResourceEEENSG_ISX_EEEERNS_12TriangulatorIfEERKNSV_IN3gss17StylesheetManagerINS14_10PropertyIDEEEEEf_block_invoke;
    __p[1] = &__block_descriptor_144_ea8_40c47_ZTSNSt3__110shared_ptrIN2md14MeshSetStorageEEE80c310_ZTSNSt3__113unordered_mapIN3gss19FeatureAttributeSetENS_6vectorINS_4pairIN12_GLOBAL__N_110PolygonKeyEN3geo11_retain_ptrIU8__strongP14VKPolygonGroupNS7_16_retain_objc_arcENS7_17_release_objc_arcENS7_10_hash_objcENS7_11_equal_objcEEEEENS_9allocatorISH_EEEENS_4hashIS2_EENS_8equal_toIS2_EENSI_INS4_IKS2_SK_EEEEEE120c45_ZTSNSt3__110shared_ptrIN2md12PolygonRoundEEE_e30_v16__0__ResourceAccessor_____8l;
    unint64_t v341 = v308;
    uint64_t v342 = v362;
    uint64_t v343 = v363;
    if (v363) {
      atomic_fetch_add_explicit(&v363->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v344 = &v336;
    float v345 = a5;
    BOOL v346 = a6;
    long long v348 = v367;
    if (*((void *)&v367 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v367 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v349 = &v319;
    double v370 = 0;
    *(void *)&long long v368 = &unk_1EF56BC58;
    *((void *)&v368 + 1) = MEMORY[0x1A6239EB0](obj);
    double v370 = &v368;
    float v361 = 0;
    uint64_t v360 = 0;
    (*(void (**)(uint64_t *, long long *, uint64_t *))(*v358 + 16))(v358, &v368, &v360);
    double v184 = v361;
    if (v361 && !atomic_fetch_add(&v361->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v184->__on_zero_shared)(v184);
      std::__shared_weak_count::__release_weak(v184);
    }
    if (v370 == &v368)
    {
      (*(void (**)(long long *))(v368 + 32))(&v368);
    }
    else if (v370)
    {
      (*(void (**)(void))(*(void *)v370 + 40))();
    }
    uint64_t v185 = (std::__shared_weak_count *)*((void *)&v348 + 1);
    uint64_t v186 = (void **)v308;
    if (*((void *)&v348 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v348 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v185->__on_zero_shared)(v185);
      std::__shared_weak_count::__release_weak(v185);
    }
    uint64_t v187 = v343;
    if (v343 && !atomic_fetch_add(&v343->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v187->__on_zero_shared)(v187);
      std::__shared_weak_count::__release_weak(v187);
    }
    if (v358)
    {
      uint64_t v188 = (*(uint64_t (**)(uint64_t *))(*v358 + 24))(v358);
      uint64_t v189 = v358;
      float v358 = 0;
      *(void *)&long long v368 = v189;
      (*(void (**)(uint64_t, long long *))(*(void *)v188 + 48))(v188, &v368);
      uint64_t v190 = v368;
      *(void *)&long long v368 = 0;
      if (v190) {
        (*(void (**)(uint64_t))(*(void *)v190 + 8))(v190);
      }
      uint64_t v191 = v358;
      float v358 = 0;
      if (v191) {
        (*(void (**)(uint64_t *))(*v191 + 8))(v191);
      }
    }
    uint64_t v192 = v363;
    if (v363 && !atomic_fetch_add(&v363->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v192->__on_zero_shared)(v192);
      std::__shared_weak_count::__release_weak(v192);
    }
    uint64_t v193 = (std::__shared_weak_count *)*((void *)&v367 + 1);
    if (*((void *)&v367 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v367 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v193->__on_zero_shared)(v193);
      std::__shared_weak_count::__release_weak(v193);
    }
    if (*(unsigned char *)(v308 + 752) == 2) {
      goto LABEL_338;
    }
    uint64_t v194 = *a5;
    uint64_t v312 = a5[1];
    if (*a5 == v312) {
      goto LABEL_338;
    }
    while (2)
    {
      std::string::pointer v196 = (char *)*v194;
      unint64_t v195 = (std::__shared_weak_count *)v194[1];
      uint64_t v362 = (char *)*v194;
      uint64_t v363 = v195;
      if (v195) {
        atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v197 = geo::codec::VectorTile::coastlinesCount(*((geo::codec::VectorTile **)v196 + 18));
      __n128 v198 = 0uLL;
      if (!v197) {
        goto LABEL_331;
      }
      uint64_t v314 = v195;
      float v317 = v194;
      uint64_t v199 = 0;
      *(_OWORD *)obuint64_t j = 0uLL;
      *(_OWORD *)std::vector<unsigned int> __p = 0uLL;
      LODWORD(v341) = 1065353216;
      while (2)
      {
        uint64_t v200 = geo::codec::VectorTile::coastlines(*((geo::codec::VectorTile **)v196 + 18));
        uint64_t v201 = v200 + 104 * v199;
        if ((((uint64_t (*)(void **, char *, uint64_t))(*v186)[19])(v186, v362, v201) & 1) != 0
          || !*(_DWORD *)(v200 + 104 * v199 + 100))
        {
          goto LABEL_297;
        }
        uint64_t v202 = *a6;
        md::createFeatureAttributeSet((gss::Allocator *)&v364, (uint64_t *)(v201 + 24));
        *(void *)((char *)&v368 + 7) = 0;
        *(void *)&long long v368 = 0;
        HIBYTE(v368) = 1;
        gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)&v367, v202, (gss::FeatureAttributeSet *)&v364, (gss::QueryOverrides *)&v368);
        if ((void)v364)
        {
          *((void *)&v364 + 1) = v364;
          (*(void (**)(void, void, void))(**((void **)&v365 + 1) + 40))(*((void *)&v365 + 1), v364, v365 - v364);
        }
        if (!obj[1]) {
          goto LABEL_322;
        }
        unint64_t v203 = 0x9DDFEA08EB382D69 * (((8 * v367) + 8) ^ DWORD1(v367));
        unint64_t v204 = 0x9DDFEA08EB382D69 * (DWORD1(v367) ^ (v203 >> 47) ^ v203);
        unint64_t v205 = 0x9DDFEA08EB382D69 * (v204 ^ (v204 >> 47));
        uint8x8_t v206 = (uint8x8_t)vcnt_s8((int8x8_t)obj[1]);
        v206.i16[0] = vaddlv_u8(v206);
        if (v206.u32[0] > 1uLL)
        {
          unint64_t v207 = v205;
          if ((id)v205 >= obj[1]) {
            unint64_t v207 = v205 % (unint64_t)obj[1];
          }
        }
        else
        {
          unint64_t v207 = v205 & ((unint64_t)obj[1] - 1);
        }
        uint64_t v208 = (void *)*((void *)obj[0] + v207);
        if (!v208 || (uint64_t v209 = (void *)*v208) == 0) {
LABEL_322:
        }
          operator new();
        if (v206.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v211 = v209[1];
            if (v211 == v205)
            {
              if (v209[2] == (void)v367) {
                goto LABEL_323;
              }
            }
            else if ((v211 & ((uint64_t)obj[1] - 1)) != v207)
            {
              goto LABEL_322;
            }
            uint64_t v209 = (void *)*v209;
            if (!v209) {
              goto LABEL_322;
            }
          }
        }
        while (1)
        {
          unint64_t v210 = v209[1];
          if (v210 == v205) {
            break;
          }
          if ((id)v210 >= obj[1]) {
            v210 %= (unint64_t)obj[1];
          }
          if (v210 != v207) {
            goto LABEL_322;
          }
LABEL_312:
          uint64_t v209 = (void *)*v209;
          if (!v209) {
            goto LABEL_322;
          }
        }
        if (v209[2] != (void)v367) {
          goto LABEL_312;
        }
LABEL_323:
        md::CoastlineGroup::addCoastlineFeature(v209[4], v201);
        uint64_t v212 = (std::__shared_weak_count *)*((void *)&v367 + 1);
        if (*((void *)&v367 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v367 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v212->__on_zero_shared)(v212);
          std::__shared_weak_count::__release_weak(v212);
        }
        uint64_t v186 = (void **)v308;
LABEL_297:
        if (++v199 != v197) {
          continue;
        }
        break;
      }
      uint64_t v213 = __p[0];
      if (__p[0])
      {
        do
        {
          long long v215 = v213;
          uint64_t v213 = (void *)*v213;
          uint64_t v216 = (std::__shared_weak_count *)v215[3];
          if (v216 && !atomic_fetch_add(&v216->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v216->__on_zero_shared)(v216);
            std::__shared_weak_count::__release_weak(v216);
          }
          operator delete(v215);
        }
        while (v213);
      }
      id v214 = obj[0];
      obj[0] = 0;
      if (v214) {
        operator delete(v214);
      }
      unint64_t v195 = v314;
      uint64_t v194 = v317;
LABEL_331:
      if (v195 && !atomic_fetch_add(&v195->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, __n128))v195->__on_zero_shared)(v195, v198);
        std::__shared_weak_count::__release_weak(v195);
      }
      v194 += 2;
      if (v194 != v312) {
        continue;
      }
      break;
    }
LABEL_338:
    (*(void (**)(id *__return_ptr))(*v186[3] + 32))(obj);
    int v217 = HIDWORD(obj[0]);
    if (a5[1] == *a5)
    {
      long long v368 = 0uLL;
    }
    else
    {
      uint64_t v218 = **a5;
      uint64_t v220 = *(void *)(v218 + 144);
      uint64_t v219 = *(void *)(v218 + 152);
      *(void *)&long long v368 = v220;
      *((void *)&v368 + 1) = v219;
      if (v219) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v219 + 8), 1uLL, memory_order_relaxed);
      }
    }
    uint64_t v221 = (char *)operator new(0x360uLL);
    *((void *)v221 + 1) = 0;
    *((void *)v221 + 2) = 0;
    *(void *)uint64_t v221 = &unk_1EF57FFE8;
    long long v364 = 0uLL;
    *(void *)&long long v365 = 0;
    uint64_t v222 = *a5;
    uint64_t v223 = (char *)a5[1];
    uint64_t v224 = v223 - (char *)*a5;
    if (v223 == (char *)*a5)
    {
      uint64_t v232 = 0;
      obj[0] = 0;
      obj[1] = 0;
      __p[0] = 0;
    }
    else
    {
      if (v224 < 0) {
        abort();
      }
      uint64_t v225 = (char *)operator new(v223 - (char *)*a5);
      uint64_t v226 = v225;
      size_t v227 = 0;
      *(void *)&long long v364 = v225;
      *(void *)&long long v365 = &v225[16 * (v224 >> 4)];
      do
      {
        uint64_t v228 = &v222[v227 / 8];
        uint64_t v229 = &v225[v227];
        *(void *)uint64_t v229 = v222[v227 / 8];
        uint64_t v230 = v222[v227 / 8 + 1];
        *((void *)v229 + 1) = v230;
        if (v230) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v230 + 8), 1uLL, memory_order_relaxed);
        }
        v227 += 16;
      }
      while (v228 + 2 != (uint64_t *)v223);
      uint64_t v231 = &v225[v227];
      *((void *)&v364 + 1) = &v225[v227];
      obj[0] = 0;
      obj[1] = 0;
      __p[0] = 0;
      uint64_t v232 = v227;
      if (v227)
      {
        if ((v227 & 0x8000000000000000) != 0) {
          abort();
        }
        uint64_t v233 = (char *)operator new(v227);
        uint64_t v224 = (uint64_t)v233;
        uint64_t v234 = 0;
        obj[0] = v233;
        __p[0] = &v233[16 * (v232 >> 4)];
        do
        {
          unint64_t v235 = &v226[v234];
          long long v236 = &v233[v234];
          uint64_t v237 = *(void *)&v226[v234 + 8];
          *(void *)long long v236 = *(void *)&v226[v234];
          *((void *)v236 + 1) = v237;
          if (v237) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v237 + 8), 1uLL, memory_order_relaxed);
          }
          v234 += 16;
        }
        while (v235 + 16 != v231);
        uint64_t v232 = (uint64_t)&v233[v234];
        obj[1] = &v233[v234];
      }
      else
      {
        uint64_t v224 = 0;
      }
    }
    md::BasePolygonTileData::BasePolygonTileData((uint64_t)(v221 + 24), v297, (uint64_t)obj, v217, (uint64_t *)&v368, v296);
    if (v224)
    {
      if (v232 != v224)
      {
        do
        {
          long long v238 = *(std::__shared_weak_count **)(v232 - 8);
          if (v238 && !atomic_fetch_add(&v238->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v238->__on_zero_shared)(v238);
            std::__shared_weak_count::__release_weak(v238);
          }
          v232 -= 16;
        }
        while (v232 != v224);
        uint64_t v232 = (uint64_t)obj[0];
      }
      operator delete((void *)v232);
    }
    *((void *)v221 + 3) = &unk_1EF5351C8;
    *((void *)v221 + 82) = &unk_1EF535210;
    *((void *)v221 + 97) = 0;
    *((void *)v221 + 99) = 0;
    *((void *)v221 + 98) = 0;
    int8x8_t v239 = (int8x8_t)v336;
    uint64_t v240 = v337;
    int64_t v241 = v337 - (unsigned char *)v336;
    if (v337 != v336)
    {
      unint64_t v242 = 0xAAAAAAAAAAAAAAABLL * (v241 >> 3);
      if (v242 >= 0xAAAAAAAAAAAAAABLL) {
        abort();
      }
      unint64_t v243 = operator new(v241);
      *((void *)v221 + 97) = v243;
      *((void *)v221 + 98) = v243;
      *((void *)v221 + 99) = &v243[3 * v242];
      uint64_t v244 = v243;
      do
      {
        *uint64_t v244 = &unk_1EF559598;
        v244[1] = 0;
        id v245 = *(id *)(*(void *)&v239 + 8);
        unint64_t v246 = (void *)v244[1];
        v244[1] = v245;

        *(void *)&v239 += 24;
        v244 += 3;
        v243 += 3;
      }
      while ((char *)v239 != v240);
      *((void *)v221 + 98) = v244;
    }
    *((_OWORD *)v221 + 50) = *(_OWORD *)v331;
    *((void *)v221 + 102) = v332;
    v331[1] = 0;
    uint64_t v332 = 0;
    v331[0] = 0;
    uint64_t v247 = (uint64_t *)(v221 + 824);
    *(_OWORD *)(v221 + 824) = 0u;
    *(_OWORD *)(v221 + 840) = 0u;
    *((_DWORD *)v221 + 214) = v335;
    size_t prime = __n[1];
    if (__n[1] == 1)
    {
      size_t prime = 2;
      goto LABEL_373;
    }
    if ((__n[1] & (__n[1] - 1)) != 0)
    {
      size_t prime = std::__next_prime(__n[1]);
      int8x8_t v239 = *(int8x8_t *)(v221 + 832);
      BOOL v277 = prime >= *(void *)&v239;
      if (prime > *(void *)&v239) {
        goto LABEL_373;
      }
    }
    else
    {
      int8x8_t v239 = 0;
      BOOL v277 = 1;
      if (__n[1]) {
        goto LABEL_373;
      }
    }
    if (!v277)
    {
      unint64_t v292 = vcvtps_u32_f32((float)*((unint64_t *)v221 + 106) / *((float *)v221 + 214));
      if (*(void *)&v239 < 3uLL
        || (uint8x8_t v293 = (uint8x8_t)vcnt_s8(v239), v293.i16[0] = vaddlv_u8(v293), v293.u32[0] > 1uLL))
      {
        unint64_t v292 = std::__next_prime(v292);
      }
      else
      {
        uint64_t v294 = 1 << -(char)__clz(v292 - 1);
        if (v292 >= 2) {
          unint64_t v292 = v294;
        }
      }
      if (prime <= v292) {
        size_t prime = v292;
      }
      if (prime < *(void *)&v239) {
LABEL_373:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)(v221 + 824), prime);
    }
    uint64_t v249 = (int8x8_t *)v334;
    if ((void)v334)
    {
      uint64_t v250 = v221 + 840;
      do
      {
        unint64_t v251 = (unint64_t)v249[2];
        unint64_t v252 = *((void *)v221 + 104);
        if (v252)
        {
          uint8x8_t v253 = (uint8x8_t)vcnt_s8((int8x8_t)v252);
          v253.i16[0] = vaddlv_u8(v253);
          if (v253.u32[0] > 1uLL)
          {
            int8x8_t v239 = v249[2];
            if (v251 >= v252) {
              int8x8_t v239 = (int8x8_t)(v251 % v252);
            }
          }
          else
          {
            int8x8_t v239 = (int8x8_t)((v252 - 1) & v251);
          }
          uint64_t v254 = *(void **)(*v247 + 8 * *(void *)&v239);
          if (v254)
          {
            uint64_t v255 = (void *)*v254;
            if (v255)
            {
              if (v253.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v257 = v255[1];
                  if (v257 == v251)
                  {
                    if (v255[2] == v251) {
                      goto LABEL_433;
                    }
                  }
                  else if ((v257 & (v252 - 1)) != *(void *)&v239)
                  {
                    goto LABEL_396;
                  }
                  uint64_t v255 = (void *)*v255;
                  if (!v255) {
                    goto LABEL_396;
                  }
                }
              }
              do
              {
                unint64_t v256 = v255[1];
                if (v256 == v251)
                {
                  if (v255[2] == v251) {
                    goto LABEL_433;
                  }
                }
                else
                {
                  if (v256 >= v252) {
                    v256 %= v252;
                  }
                  if (v256 != *(void *)&v239) {
                    break;
                  }
                }
                uint64_t v255 = (void *)*v255;
              }
              while (v255);
            }
          }
        }
LABEL_396:
        uint64_t v258 = operator new(0x30uLL);
        *uint64_t v258 = 0;
        v258[1] = v251;
        v258[2] = v249[2];
        v258[3] = &unk_1EF559598;
        v258[4] = 0;
        id v259 = *(id *)&v249[4];
        uint64_t v260 = (void *)v258[4];
        v258[4] = v259;

        float v261 = (float)(unint64_t)(*((void *)v221 + 106) + 1);
        float v262 = *((float *)v221 + 214);
        if ((((float)(v262 * (float)v252) >= v261) & ~(v252 == 0)) == 0)
        {
          BOOL v263 = (v252 & (v252 - 1)) != 0;
          if (v252 < 3) {
            BOOL v263 = 1;
          }
          unint64_t v264 = v263 | (2 * v252);
          unint64_t v265 = vcvtps_u32_f32(v261 / v262);
          if (v264 <= v265) {
            size_t v266 = v265;
          }
          else {
            size_t v266 = v264;
          }
          if (v266 == 1)
          {
            size_t v266 = 2;
          }
          else if ((v266 & (v266 - 1)) != 0)
          {
            size_t v266 = std::__next_prime(v266);
          }
          int8x8_t v267 = *(int8x8_t *)(v221 + 832);
          if (v266 > *(void *)&v267) {
            goto LABEL_407;
          }
          if (v266 < *(void *)&v267)
          {
            unint64_t v268 = vcvtps_u32_f32((float)*((unint64_t *)v221 + 106) / *((float *)v221 + 214));
            if (*(void *)&v267 < 3uLL
              || (uint8x8_t v269 = (uint8x8_t)vcnt_s8(v267), v269.i16[0] = vaddlv_u8(v269), v269.u32[0] > 1uLL))
            {
              unint64_t v268 = std::__next_prime(v268);
            }
            else
            {
              uint64_t v270 = 1 << -(char)__clz(v268 - 1);
              if (v268 >= 2) {
                unint64_t v268 = v270;
              }
            }
            if (v266 <= v268) {
              size_t v266 = v268;
            }
            if (v266 < *(void *)&v267) {
LABEL_407:
            }
              std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)(v221 + 824), v266);
          }
          unint64_t v252 = *((void *)v221 + 104);
          if ((v252 & (v252 - 1)) != 0)
          {
            if (v251 >= v252) {
              int8x8_t v239 = (int8x8_t)(v251 % v252);
            }
            else {
              int8x8_t v239 = (int8x8_t)v251;
            }
          }
          else
          {
            int8x8_t v239 = (int8x8_t)((v252 - 1) & v251);
          }
        }
        uint64_t v271 = *v247;
        uint64_t v272 = *(void **)(*v247 + 8 * *(void *)&v239);
        if (v272)
        {
          *uint64_t v258 = *v272;
        }
        else
        {
          *uint64_t v258 = *v250;
          *uint64_t v250 = v258;
          *(void *)(v271 + 8 * *(void *)&v239) = v250;
          if (!*v258) {
            goto LABEL_432;
          }
          unint64_t v273 = *(void *)(*v258 + 8);
          if ((v252 & (v252 - 1)) != 0)
          {
            if (v273 >= v252) {
              v273 %= v252;
            }
          }
          else
          {
            v273 &= v252 - 1;
          }
          uint64_t v272 = (void *)(*v247 + 8 * v273);
        }
        *uint64_t v272 = v258;
LABEL_432:
        ++*((void *)v221 + 106);
LABEL_433:
        uint64_t v249 = (int8x8_t *)*v249;
      }
      while (v249);
    }
    uint64_t v274 = (char *)v364;
    if ((void)v364)
    {
      uint64_t v275 = (char *)*((void *)&v364 + 1);
      if (*((void *)&v364 + 1) != (void)v364)
      {
        do
        {
          uint64_t v276 = (std::__shared_weak_count *)*((void *)v275 - 1);
          if (v276 && !atomic_fetch_add(&v276->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v276->__on_zero_shared)(v276);
            std::__shared_weak_count::__release_weak(v276);
          }
          v275 -= 16;
        }
        while (v275 != v274);
        uint64_t v274 = (char *)v364;
      }
      operator delete(v274);
    }
    *uint64_t v295 = v221 + 24;
    v295[1] = v221;
    long long v278 = (std::__shared_weak_count *)*((void *)&v368 + 1);
    if (*((void *)&v368 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v368 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v278->__on_zero_shared)(v278);
      std::__shared_weak_count::__release_weak(v278);
    }
    if (v328)
    {
      uint64_t v329 = v328;
      operator delete(v328);
    }
    geo::Pool<geo::Triangulator<float,unsigned short>::Node>::disposeElements((uint64_t)&v319);
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v320[0]);
    uint64_t v279 = v331[0];
    if (v331[0])
    {
      uint64_t v280 = v331[1];
      if (v331[1] != v331[0])
      {
        do
        {
          uint64_t v282 = (md::CoastlineGroup *)*--v280;
          unint64_t v281 = v282;
          *uint64_t v280 = 0;
          if (v282)
          {
            md::CoastlineGroup::~CoastlineGroup(v281);
            MEMORY[0x1A6239270]();
          }
        }
        while (v280 != v279);
        uint64_t v279 = v331[0];
      }
      operator delete(v279);
    }
    uint64_t v283 = (void *)v334;
    if ((void)v334)
    {
      do
      {
        uint64_t v284 = *(void **)v283;
        *((void *)v283 + 3) = &unk_1EF559598;

        operator delete(v283);
        uint64_t v283 = v284;
      }
      while (v284);
    }
    uint64_t v285 = (void *)__n[0];
    __n[0] = 0;
    if (v285) {
      operator delete(v285);
    }
    long long v286 = (char *)v336;
    if (v336)
    {
      uint64_t v287 = v336;
      if (v337 != v336)
      {
        uint64_t v288 = v337 - 24;
        uint64_t v289 = v337 - 24;
        uint64_t v290 = v337 - 24;
        do
        {
          uint64_t v291 = *(void (***)(char *))v290;
          v290 -= 24;
          (*v291)(v289);
          v288 -= 24;
          BOOL v27 = v289 == v286;
          uint64_t v289 = v290;
        }
        while (!v27);
        uint64_t v287 = v336;
      }
      float v337 = v286;
      operator delete(v287);
    }
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
}