void *ecs2::Query<md::ls::RegisterHandle &>::Model<ecs2::RuntimeQuery<md::ls::RegisterHandle &>>::each(uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;
  uint64_t *v5;
  unint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  BOOL v14;
  unint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t *v21;
  uint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  void *result;

  v3 = (void *)gdc::Registry::storage<md::ls::RegisterHandle>(*(int8x8_t **)(*(void *)(a1 + 8) + 8));
  v4 = v3;
  v6 = (unint64_t *)v3[7];
  v5 = (uint64_t *)v3[8];
  v7 = (char *)v5 - (char *)v6;
  if (v5 == (uint64_t *)v6
    || (v8 = *((unsigned int *)v6 + 1), v9 = v3[4], v10 = (v3[5] - v9) >> 3, v8 >> 7 < v10)
    && (v11 = *(void *)(v9 + 8 * (v8 >> 7))) != 0
    && (v12 = *(unsigned __int16 *)(v11 + 2 * (v8 & 0x7F)), v12 < v7 >> 3)
    && ((v13 = (uint64_t *)&v6[v12], v13 != v5) ? (v14 = *((_DWORD *)v13 + 1) == v8) : (v14 = 0), v14))
  {
LABEL_19:
    if (v5 != (uint64_t *)v6)
    {
      v21 = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
      do
      {
        *v21 = *v6;
        v23 = *v6;
        v24 = *v6 >> 39;
        v25 = v4[4];
        if (v24 < (v4[5] - v25) >> 3
          && (v26 = *(void *)(v25 + 8 * v24)) != 0
          && (v27 = *(unsigned __int16 *)(v26 + 2 * (HIDWORD(v23) & 0x7F)),
              v29 = v4[7],
              v28 = v4[8],
              v27 < (v28 - v29) >> 3)
          && ((v30 = HIDWORD(v23), v31 = v29 + 8 * v27, v31 != v28)
            ? (v32 = *(_DWORD *)(v31 + 4) == v30)
            : (v32 = 0),
              v32))
        {
          v33 = v4[11];
          v34 = v4[10] + 8 * v27;
          v35 = *(void *)(a2 + 24);
          if (!v35)
          {
LABEL_44:
            std::__throw_bad_function_call[abi:nn180100]();
            break;
          }
        }
        else
        {
          v33 = v4[11];
          v34 = v33;
          v35 = *(void *)(a2 + 24);
          if (!v35) {
            goto LABEL_44;
          }
        }
        if (v34 == v33) {
          v36 = 0;
        }
        else {
          v36 = v34;
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v35 + 48))(v35, v36);
        v37 = v4[4];
        v38 = v4[7];
        v22 = (uint64_t *)v4[8];
        v39 = (uint64_t *)(v6 + 1);
        while (v39 != v22)
        {
          v40 = *((unsigned int *)v39 + 1);
          v41 = v4[8];
          if (v40 >> 7 < (v4[5] - v37) >> 3)
          {
            v42 = *(void *)(v37 + 8 * (v40 >> 7));
            v41 = v4[8];
            if (v42)
            {
              v43 = *(unsigned __int16 *)(v42 + 2 * (v40 & 0x7F));
              v41 = v4[8];
              if (((uint64_t)v22 - v38) >> 3 > v43)
              {
                v41 = v38 + 8 * v43;
                if (*(_DWORD *)(v41 + 4) != v40) {
                  v41 = v4[8];
                }
              }
            }
          }
          ++v39;
          if ((uint64_t *)v41 != v22)
          {
            v22 = v39 - 1;
            break;
          }
        }
        v6 = (unint64_t *)v22;
      }
      while (v5 != v22);
    }
  }
  else
  {
    v15 = v7 >> 3;
    v16 = (uint64_t *)(v6 + 1);
    while (v16 != v5)
    {
      v17 = *((unsigned int *)v16 + 1);
      v18 = (uint64_t *)v3[8];
      if (v17 >> 7 < v10)
      {
        v19 = *(void *)(v9 + 8 * (v17 >> 7));
        v18 = (uint64_t *)v3[8];
        if (v19)
        {
          v20 = *(unsigned __int16 *)(v19 + 2 * (v17 & 0x7F));
          v18 = (uint64_t *)v3[8];
          if (v15 > v20)
          {
            v18 = (uint64_t *)&v6[v20];
            if (*((_DWORD *)v18 + 1) != v17) {
              v18 = (uint64_t *)v3[8];
            }
          }
        }
      }
      ++v16;
      if (v18 != v5)
      {
        v6 = (unint64_t *)(v16 - 1);
        goto LABEL_19;
      }
    }
  }
  result = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  *result = 0xFFFFFFFF00000000;
  return result;
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::SetupCommonDataTask>,std::allocator<ecs2::ForwardToExecute<md::ita::SetupCommonDataTask>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51A8B8;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::SetupCommonDataTask>,std::allocator<ecs2::ForwardToExecute<md::ita::SetupCommonDataTask>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#2},std::allocator<md::ita::UpdateClippingConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF5290C0;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#2},std::allocator<md::ita::UpdateClippingConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#1},std::allocator<md::ita::UpdateClippingConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF529108;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#1},std::allocator<md::ita::UpdateClippingConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::UpdateClippingConstants>,std::allocator<ecs2::ForwardToExecute<md::ita::UpdateClippingConstants>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51B290;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::UpdateClippingConstants>,std::allocator<ecs2::ForwardToExecute<md::ita::UpdateClippingConstants>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#2},std::allocator<md::ita::UpdateCameraStyleLight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF528B20;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#2},std::allocator<md::ita::UpdateCameraStyleLight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#1},std::allocator<md::ita::UpdateCameraStyleLight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF528B68;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#1},std::allocator<md::ita::UpdateCameraStyleLight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

BOOL ecs2::Query<md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &>::Model<ecs2::RuntimeQuery<md::ls::TileMatrix const&,md::ls::TileStyleCameraConstantDataHandle &>>::empty(uint64_t a1)
{
  v1 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  v2 = (void *)gdc::Registry::storage<md::ls::TileMatrix>(v1);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::TileStyleCameraConstantDataHandle>(v1);
  v4 = v3;
  v5 = v3 + 4;
  if (v3[8] - v3[7] >= v2[8] - v2[7]) {
    uint64_t v6 = (uint64_t)(v2 + 4);
  }
  else {
    uint64_t v6 = (uint64_t)(v3 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v10, v6, v2, v3, *(void *)(v6 + 24));
  if (v4[8] - v4[7] >= v2[8] - v2[7]) {
    uint64_t v7 = (uint64_t)(v2 + 4);
  }
  else {
    uint64_t v7 = (uint64_t)v5;
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v9, v7, v2, v4, *(void *)(v7 + 32));
  return v9[4] == v10[4];
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::UpdateCameraStyleLight>,std::allocator<ecs2::ForwardToExecute<md::ita::UpdateCameraStyleLight>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51AFC0;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::UpdateCameraStyleLight>,std::allocator<ecs2::ForwardToExecute<md::ita::UpdateCameraStyleLight>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#2},std::allocator<md::ita::UpdateTileTransforms &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF528070;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#2},std::allocator<md::ita::UpdateTileTransforms &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#1},std::allocator<md::ita::UpdateTileTransforms &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF5280B8;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#1},std::allocator<md::ita::UpdateTileTransforms &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

BOOL ecs2::Query<md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &>::Model<ecs2::RuntimeQuery<md::ls::TileBounds const&,md::ls::TileMatrix const&,md::ls::TileTransformConstantDataHandle &>>::empty(uint64_t a1)
{
  v1 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v2 = gdc::Registry::storage<md::ls::TileBounds>(v1);
  uint64_t v3 = gdc::Registry::storage<md::ls::TileMatrix>(v1);
  uint64_t v4 = gdc::Registry::storage<md::ls::TileTransformConstantDataHandle>(v1);
  if (*(void *)(v3 + 64) - *(void *)(v3 + 56) >= *(void *)(v2 + 64) - *(void *)(v2 + 56)) {
    uint64_t v5 = v2;
  }
  else {
    uint64_t v5 = v3;
  }
  if (*(void *)(v4 + 64) - *(void *)(v4 + 56) < *(void *)(v5 + 64) - *(void *)(v5 + 56)) {
    uint64_t v5 = v4;
  }
  v11[0] = v5 + 32;
  v11[1] = v2;
  v11[2] = v3;
  v11[3] = v4;
  uint64_t v7 = *(void *)(v5 + 56);
  uint64_t v6 = *(void *)(v5 + 64);
  uint64_t v12 = v7;
  if (v6 != v7
    && !gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v11))
  {
    uint64_t v8 = v7 + 8;
    do
    {
      uint64_t v7 = v8;
      uint64_t v12 = v8;
      if (v8 == v6) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v11);
      uint64_t v8 = v7 + 8;
    }
    while (!isValid);
  }
  return v6 == v7;
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::UpdateTileTransforms>,std::allocator<ecs2::ForwardToExecute<md::ita::UpdateTileTransforms>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51AA68;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::UpdateTileTransforms>,std::allocator<ecs2::ForwardToExecute<md::ita::UpdateTileTransforms>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#2},std::allocator<md::ita::UpdateTileRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF528730;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#2},std::allocator<md::ita::UpdateTileRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#1},std::allocator<md::ita::UpdateTileRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF528778;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#1},std::allocator<md::ita::UpdateTileRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

BOOL ecs2::Query<md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &>::Model<ecs2::RuntimeQuery<md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &>>::empty(uint64_t a1)
{
  v1 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v2 = gdc::Registry::storage<md::ls::TileRenderableDataHandle>(v1);
  uint64_t v3 = gdc::Registry::storage<md::ls::BoundsWidth>(v1);
  uint64_t v4 = gdc::Registry::storage<md::ls::NeedsUpdate<ggl::Tile::View>>(v1);
  uint64_t v5 = gdc::Registry::storage<md::ls::TileViewConstantDataHandle>(v1);
  v8[0] = v2;
  v8[1] = v3;
  v8[2] = v4;
  v8[3] = v5;
  gdc::RegistryQueryView<gdc::All<md::ls::PipelineSetupToApply const,md::ls::RenderState const,md::ls::DataIDSetToUse const,md::ls::RenderItemID const>,gdc::Any<>,gdc::None<>>::begin(v9, v8);
  if (*(void *)(v3 + 64) - *(void *)(v3 + 56) >= *(void *)(v2 + 64) - *(void *)(v2 + 56)) {
    uint64_t v6 = v2;
  }
  else {
    uint64_t v6 = v3;
  }
  if (*(void *)(v4 + 64) - *(void *)(v4 + 56) < *(void *)(v6 + 64) - *(void *)(v6 + 56)) {
    uint64_t v6 = v4;
  }
  if (*(void *)(v5 + 64) - *(void *)(v5 + 56) < *(void *)(v6 + 64) - *(void *)(v6 + 56)) {
    uint64_t v6 = v5;
  }
  return *(void *)(v6 + 64) == v9[6];
}

BOOL gdc::ComponentStorageWrapper<md::ls::NeedsUpdate<ggl::Tile::View>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<md::ls::NeedsUpdate<ggl::Tile::View>>::remove(void *a1, unint64_t a2)
{
  unint64_t v19 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 < (v5 - v4) >> 3)
  {
    uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
    if (v6)
    {
      unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
      uint64_t v9 = a1[7];
      uint64_t v8 = a1[8];
      if (v7 < (v8 - v9) >> 3)
      {
        unint64_t v10 = HIDWORD(a2);
        uint64_t v11 = v9 + 8 * v7;
        if (v11 != v8 && *(_DWORD *)(v11 + 4) == v10)
        {
          uint64_t v13 = a1[10];
          geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
          uint64_t v14 = a1[11];
          *(unsigned char *)(v13 + v7) = *(unsigned char *)(v14 - 1);
          a1[11] = v14 - 1;
          v15 = (void *)a1[28];
          if (v15)
          {
            uint64_t v16 = a1[31];
            while (1)
            {
              v21[0] = &v19;
              v21[1] = 1;
              uint64_t v20 = v16;
              uint64_t v17 = v15[6];
              if (!v17) {
                break;
              }
              (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v17 + 48))(v17, &v20, v21);
              v15 = (void *)*v15;
              if (!v15) {
                return;
              }
            }
            std::__throw_bad_function_call[abi:nn180100]();
            gdc::ComponentStorageWrapper<md::ls::NeedsUpdate<ggl::Tile::View>>::~ComponentStorageWrapper(v18);
          }
        }
      }
    }
  }
}

void gdc::ComponentStorageWrapper<md::ls::NeedsUpdate<ggl::Tile::View>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::UpdateTileRenderables>,std::allocator<ecs2::ForwardToExecute<md::ita::UpdateTileRenderables>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51ADC8;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::UpdateTileRenderables>,std::allocator<ecs2::ForwardToExecute<md::ita::UpdateTileRenderables>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#2},std::allocator<md::ita::PrepareCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF5284F0;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#2},std::allocator<md::ita::PrepareCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#1},std::allocator<md::ita::PrepareCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF528538;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#1},std::allocator<md::ita::PrepareCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareCommandBuffers>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareCommandBuffers>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51ACA8;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareCommandBuffers>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareCommandBuffers>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRenderableData>(md::ita::PrepareRenderableData &&)::{lambda(void)#2},std::allocator<md::ita::PrepareRenderableData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRenderableData>(md::ita::PrepareRenderableData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF528580;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRenderableData>(md::ita::PrepareRenderableData &&)::{lambda(void)#2},std::allocator<md::ita::PrepareRenderableData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRenderableData>(md::ita::PrepareRenderableData &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRenderableData>(md::ita::PrepareRenderableData &&)::{lambda(void)#1},std::allocator<md::ita::PrepareRenderableData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRenderableData>(md::ita::PrepareRenderableData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF5285C8;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRenderableData>(md::ita::PrepareRenderableData &&)::{lambda(void)#1},std::allocator<md::ita::PrepareRenderableData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRenderableData>(md::ita::PrepareRenderableData &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

BOOL ecs2::Query<md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &>::Model<ecs2::RuntimeQuery<md::ls::TileMatrix const&,md::ls::NeedsTileRenderableDataHandleUpdate &,md::ls::TileRenderableDataHandle &>>::empty(uint64_t a1)
{
  v1 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v2 = gdc::Registry::storage<md::ls::TileMatrix>(v1);
  uint64_t v3 = gdc::Registry::storage<md::ls::NeedsTileRenderableDataHandleUpdate>(v1);
  uint64_t v4 = gdc::Registry::storage<md::ls::TileRenderableDataHandle>(v1);
  if (*(void *)(v3 + 64) - *(void *)(v3 + 56) >= *(void *)(v2 + 64) - *(void *)(v2 + 56)) {
    uint64_t v5 = v2;
  }
  else {
    uint64_t v5 = v3;
  }
  if (*(void *)(v4 + 64) - *(void *)(v4 + 56) < *(void *)(v5 + 64) - *(void *)(v5 + 56)) {
    uint64_t v5 = v4;
  }
  v11[0] = v5 + 32;
  v11[1] = v2;
  v11[2] = v3;
  v11[3] = v4;
  uint64_t v7 = *(void *)(v5 + 56);
  uint64_t v6 = *(void *)(v5 + 64);
  uint64_t v12 = v7;
  if (v6 != v7
    && !gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v11))
  {
    uint64_t v8 = v7 + 8;
    do
    {
      uint64_t v7 = v8;
      uint64_t v12 = v8;
      if (v8 == v6) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v11);
      uint64_t v8 = v7 + 8;
    }
    while (!isValid);
  }
  return v6 == v7;
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareRenderableData>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareRenderableData>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51ACF0;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareRenderableData>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareRenderableData>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareRouteLineMaskPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF529540;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareRouteLineMaskPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareRouteLineMaskPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF529588;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareRouteLineMaskPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareRouteLineMaskPass>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareRouteLineMaskPass>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51B4D0;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareRouteLineMaskPass>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareRouteLineMaskPass>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#2},std::allocator<md::ita::PrepareSSAOPasses &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF527530;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#2},std::allocator<md::ita::PrepareSSAOPasses &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#1},std::allocator<md::ita::PrepareSSAOPasses &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF527578;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#1},std::allocator<md::ita::PrepareSSAOPasses &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareSSAOPasses>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareSSAOPasses>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51A4C8;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareSSAOPasses>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareSSAOPasses>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareDepthPrePass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF527BF0;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareDepthPrePass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareDepthPrePass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF527C38;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareDepthPrePass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareDepthPrePass>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareDepthPrePass>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51A828;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareDepthPrePass>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareDepthPrePass>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareShadowPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF5275C0;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareShadowPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareShadowPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  result = operator new(0x10uLL);
  void *result = &unk_1EF527608;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareShadowPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

uint64_t std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareShadowPass>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareShadowPass>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t ***a2)
{
  *(void *)(a1 + 8) = a2;
  uint64_t v3 = **a2;
  if (v3 != (*a2)[1] && *v3 != 0xD369A4D92C8FFE6CLL)
  {
    uint64_t v4 = v3 + 5;
    do
    {
      uint64_t v5 = *v4;
      v4 += 5;
    }
    while (v5 != 0xD369A4D92C8FFE6CLL);
    uint64_t v3 = v4 - 5;
  }
  uint64_t v6 = v3[3];
  uint64_t v7 = (std::__shared_weak_count *)v3[4];
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 8))(v6);
  if (result)
  {
    uint64_t v9 = *(void **)(result + 8);
    uint64_t v10 = v9[3];
    uint64_t v11 = v9[4];
    uint64_t v12 = v11 - v10;
    if (v11 != v10)
    {
      uint64_t v13 = 0;
      unint64_t v14 = v12 >> 3;
      while (1)
      {
        uint64_t v15 = *(void *)(v10 + 8 * v13);
        if (!*(unsigned char *)v15)
        {
          unint64_t v16 = *(void *)(v15 + 8);
          uint64_t v17 = v9[15];
          if (v16 < (v9[16] - v17) >> 3) {
            break;
          }
        }
        if (++v13 >= v14) {
          goto LABEL_48;
        }
      }
      if (*(void *)(v17 + 8 * v16))
      {
        v18 = ***(uint64_t ****)(a1 + 8);
        if (v18 != *(uint64_t **)(**(void **)(a1 + 8) + 8) && *v18 != 0x22D45F5AAD4BF408)
        {
          unint64_t v19 = v18 + 5;
          do
          {
            uint64_t v20 = *v19;
            v19 += 5;
          }
          while (v20 != 0x22D45F5AAD4BF408);
          v18 = v19 - 5;
        }
        v21 = (uint64_t (***)(void))v18[3];
        v22 = (std::__shared_weak_count *)v18[4];
        if (v22)
        {
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }
        uint64_t result = (**v21)(v21);
        v23 = *(void **)(result + 8);
        int8x8_t v24 = (int8x8_t)v23[1];
        if (v24)
        {
          uint8x8_t v25 = (uint8x8_t)vcnt_s8(v24);
          v25.i16[0] = vaddlv_u8(v25);
          if (v25.u32[0] > 1uLL)
          {
            uint64_t v26 = 0x41E8D6E445F4145;
            if (*(void *)&v24 <= 0x41E8D6E445F4145uLL) {
              uint64_t v26 = 0x41E8D6E445F4145uLL % *(void *)&v24;
            }
          }
          else
          {
            uint64_t v26 = (*(void *)&v24 - 1) & 0x41E8D6E445F4145;
          }
          v27 = *(void **)(*v23 + 8 * v26);
          if (v27)
          {
            v28 = (void *)*v27;
            if (v28)
            {
              if (v25.u32[0] < 2uLL)
              {
                uint64_t v29 = *(void *)&v24 - 1;
                while (1)
                {
                  uint64_t v31 = v28[1];
                  if (v31 == 0x41E8D6E445F4145)
                  {
                    if (v28[2] == 0x41E8D6E445F4145) {
                      goto LABEL_45;
                    }
                  }
                  else if ((v31 & v29) != v26)
                  {
                    goto LABEL_48;
                  }
                  v28 = (void *)*v28;
                  if (!v28) {
                    goto LABEL_48;
                  }
                }
              }
              do
              {
                unint64_t v30 = v28[1];
                if (v30 == 0x41E8D6E445F4145)
                {
                  if (v28[2] == 0x41E8D6E445F4145)
                  {
LABEL_45:
                    uint64_t v32 = v28[5];
                    if (*(void *)(v32 + 8) == 0x41E8D6E445F4145)
                    {
                      uint64_t v33 = *(void *)(v32 + 32);
                      if (v33)
                      {
                        if (!*(unsigned char *)(v33 + 228)) {
                          gdc::Registry::create(*(gdc::Registry **)(*(void *)(a1 + 8) + 8));
                        }
                      }
                    }
                    break;
                  }
                }
                else
                {
                  if (v30 >= *(void *)&v24) {
                    v30 %= *(void *)&v24;
                  }
                  if (v30 != v26) {
                    break;
                  }
                }
                v28 = (void *)*v28;
              }
              while (v28);
            }
          }
        }
      }
    }
  }
LABEL_48:
  *(void *)(a1 + 8) = 0;
  return result;
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareShadowPass>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareShadowPass>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51A510;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareShadowPass>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareShadowPass>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareMainPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF527140;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareMainPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareMainPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF527188;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareMainPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareMainPass>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareMainPass>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51A2D0;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareMainPass>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareMainPass>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#2},std::allocator<md::ita::PushLegacyRibbons &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF527650;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#2},std::allocator<md::ita::PushLegacyRibbons &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#1},std::allocator<md::ita::PushLegacyRibbons &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF527698;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#1},std::allocator<md::ita::PushLegacyRibbons &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

BOOL ecs2::Query<md::ls::RequireTypedRenderableForLegacyReasons<md::DaVinciGroundRenderable> const&>::Model<ecs2::RuntimeQuery<md::ls::RequireTypedRenderableForLegacyReasons<md::DaVinciGroundRenderable> const&>>::empty(uint64_t a1)
{
  v1 = (void *)gdc::Registry::storage<md::ls::RequireTypedRenderableForLegacyReasons<md::DaVinciGroundRenderable>>(*(int8x8_t **)(*(void *)(a1 + 8) + 8));
  uint64_t v3 = v1[7];
  uint64_t v2 = v1[8];
  uint64_t v4 = v2 - v3;
  if (v2 != v3)
  {
    if ((v5 = *(unsigned int *)(v3 + 4), uint64_t v6 = v1[4], v7 = (v1[5] - v6) >> 3, v5 >> 7 >= v7)
      || (uint64_t v8 = *(void *)(v6 + 8 * (v5 >> 7))) == 0
      || (unint64_t v9 = *(unsigned __int16 *)(v8 + 2 * (v5 & 0x7F)), v9 >= v4 >> 3)
      || ((uint64_t v10 = v3 + 8 * v9, v10 != v2) ? (v11 = *(_DWORD *)(v10 + 4) == v5) : (v11 = 0), !v11))
    {
      unint64_t v12 = v4 >> 3;
      uint64_t v13 = v3 + 8;
      while (v13 != v2)
      {
        unint64_t v14 = *(unsigned int *)(v13 + 4);
        uint64_t v15 = v1[8];
        if (v14 >> 7 < v7)
        {
          uint64_t v16 = *(void *)(v6 + 8 * (v14 >> 7));
          uint64_t v15 = v1[8];
          if (v16)
          {
            unint64_t v17 = *(unsigned __int16 *)(v16 + 2 * (v14 & 0x7F));
            uint64_t v15 = v1[8];
            if (v12 > v17)
            {
              uint64_t v15 = v3 + 8 * v17;
              if (*(_DWORD *)(v15 + 4) != v14) {
                uint64_t v15 = v1[8];
              }
            }
          }
        }
        v13 += 8;
        if (v15 != v2)
        {
          uint64_t v3 = v13 - 8;
          return v2 == v3;
        }
      }
      uint64_t v3 = v1[8];
    }
  }
  return v2 == v3;
}

void *ecs2::Query<md::ls::RequireTypedRenderableForLegacyReasons<md::DaVinciGroundRenderable> const&>::Model<ecs2::RuntimeQuery<md::ls::RequireTypedRenderableForLegacyReasons<md::DaVinciGroundRenderable> const&>>::each(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RequireTypedRenderableForLegacyReasons<md::DaVinciGroundRenderable>>(*(int8x8_t **)(*(void *)(a1 + 8) + 8));
  uint64_t v4 = v3;
  uint64_t v6 = (unint64_t *)v3[7];
  unint64_t v5 = (uint64_t *)v3[8];
  uint64_t v7 = (char *)v5 - (char *)v6;
  if (v5 == (uint64_t *)v6
    || (unint64_t v8 = *((unsigned int *)v6 + 1), v9 = v3[4], v10 = (v3[5] - v9) >> 3, v8 >> 7 < v10)
    && (uint64_t v11 = *(void *)(v9 + 8 * (v8 >> 7))) != 0
    && (unint64_t v12 = *(unsigned __int16 *)(v11 + 2 * (v8 & 0x7F)), v12 < v7 >> 3)
    && ((uint64_t v13 = (uint64_t *)&v6[v12], v13 != v5) ? (v14 = *((_DWORD *)v13 + 1) == v8) : (v14 = 0), v14))
  {
LABEL_19:
    if (v5 != (uint64_t *)v6)
    {
      v21 = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
      do
      {
        unint64_t *v21 = *v6;
        unint64_t v23 = *v6;
        unint64_t v24 = *v6 >> 39;
        uint64_t v25 = v4[4];
        if (v24 < (v4[5] - v25) >> 3
          && (uint64_t v26 = *(void *)(v25 + 8 * v24)) != 0
          && (unint64_t v27 = *(unsigned __int16 *)(v26 + 2 * (HIDWORD(v23) & 0x7F)),
              uint64_t v29 = v4[7],
              uint64_t v28 = v4[8],
              v27 < (v28 - v29) >> 3)
          && ((unint64_t v30 = HIDWORD(v23), v31 = v29 + 8 * v27, v31 != v28)
            ? (BOOL v32 = *(_DWORD *)(v31 + 4) == v30)
            : (BOOL v32 = 0),
              v32))
        {
          uint64_t v33 = v4[11];
          uint64_t v34 = v4[10] + 8 * v27;
          uint64_t v35 = *(void *)(a2 + 24);
          if (!v35)
          {
LABEL_44:
            std::__throw_bad_function_call[abi:nn180100]();
            break;
          }
        }
        else
        {
          uint64_t v33 = v4[11];
          uint64_t v34 = v33;
          uint64_t v35 = *(void *)(a2 + 24);
          if (!v35) {
            goto LABEL_44;
          }
        }
        if (v34 == v33) {
          uint64_t v36 = 0;
        }
        else {
          uint64_t v36 = v34;
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v35 + 48))(v35, v36);
        uint64_t v37 = v4[4];
        uint64_t v38 = v4[7];
        v22 = (uint64_t *)v4[8];
        v39 = (uint64_t *)(v6 + 1);
        while (v39 != v22)
        {
          unint64_t v40 = *((unsigned int *)v39 + 1);
          uint64_t v41 = v4[8];
          if (v40 >> 7 < (v4[5] - v37) >> 3)
          {
            uint64_t v42 = *(void *)(v37 + 8 * (v40 >> 7));
            uint64_t v41 = v4[8];
            if (v42)
            {
              unint64_t v43 = *(unsigned __int16 *)(v42 + 2 * (v40 & 0x7F));
              uint64_t v41 = v4[8];
              if (((uint64_t)v22 - v38) >> 3 > v43)
              {
                uint64_t v41 = v38 + 8 * v43;
                if (*(_DWORD *)(v41 + 4) != v40) {
                  uint64_t v41 = v4[8];
                }
              }
            }
          }
          ++v39;
          if ((uint64_t *)v41 != v22)
          {
            v22 = v39 - 1;
            break;
          }
        }
        uint64_t v6 = (unint64_t *)v22;
      }
      while (v5 != v22);
    }
  }
  else
  {
    unint64_t v15 = v7 >> 3;
    uint64_t v16 = (uint64_t *)(v6 + 1);
    while (v16 != v5)
    {
      unint64_t v17 = *((unsigned int *)v16 + 1);
      v18 = (uint64_t *)v3[8];
      if (v17 >> 7 < v10)
      {
        uint64_t v19 = *(void *)(v9 + 8 * (v17 >> 7));
        v18 = (uint64_t *)v3[8];
        if (v19)
        {
          unint64_t v20 = *(unsigned __int16 *)(v19 + 2 * (v17 & 0x7F));
          v18 = (uint64_t *)v3[8];
          if (v15 > v20)
          {
            v18 = (uint64_t *)&v6[v20];
            if (*((_DWORD *)v18 + 1) != v17) {
              v18 = (uint64_t *)v3[8];
            }
          }
        }
      }
      ++v16;
      if (v18 != v5)
      {
        uint64_t v6 = (unint64_t *)(v16 - 1);
        goto LABEL_19;
      }
    }
  }
  uint64_t result = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  void *result = 0xFFFFFFFF00000000;
  return result;
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::PushLegacyRibbons>,std::allocator<ecs2::ForwardToExecute<md::ita::PushLegacyRibbons>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51A558;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PushLegacyRibbons>,std::allocator<ecs2::ForwardToExecute<md::ita::PushLegacyRibbons>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#2},std::allocator<md::ita::DeletePendingDeletion &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF5283D0;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#2},std::allocator<md::ita::DeletePendingDeletion &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#1},std::allocator<md::ita::DeletePendingDeletion &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF528418;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#1},std::allocator<md::ita::DeletePendingDeletion &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

BOOL ecs2::Query<md::ls::PendingDeletion const&>::Model<ecs2::RuntimeQuery<md::ls::PendingDeletion const&>>::empty(uint64_t a1)
{
  v1 = (void *)gdc::Registry::storage<md::ls::PendingDeletion>(*(int8x8_t **)(*(void *)(a1 + 8) + 8));
  uint64_t v3 = v1[7];
  uint64_t v2 = v1[8];
  uint64_t v4 = v2 - v3;
  if (v2 != v3)
  {
    if ((v5 = *(unsigned int *)(v3 + 4), uint64_t v6 = v1[4], v7 = (v1[5] - v6) >> 3, v5 >> 7 >= v7)
      || (uint64_t v8 = *(void *)(v6 + 8 * (v5 >> 7))) == 0
      || (unint64_t v9 = *(unsigned __int16 *)(v8 + 2 * (v5 & 0x7F)), v9 >= v4 >> 3)
      || ((uint64_t v10 = v3 + 8 * v9, v10 != v2) ? (v11 = *(_DWORD *)(v10 + 4) == v5) : (v11 = 0), !v11))
    {
      unint64_t v12 = v4 >> 3;
      uint64_t v13 = v3 + 8;
      while (v13 != v2)
      {
        unint64_t v14 = *(unsigned int *)(v13 + 4);
        uint64_t v15 = v1[8];
        if (v14 >> 7 < v7)
        {
          uint64_t v16 = *(void *)(v6 + 8 * (v14 >> 7));
          uint64_t v15 = v1[8];
          if (v16)
          {
            unint64_t v17 = *(unsigned __int16 *)(v16 + 2 * (v14 & 0x7F));
            uint64_t v15 = v1[8];
            if (v12 > v17)
            {
              uint64_t v15 = v3 + 8 * v17;
              if (*(_DWORD *)(v15 + 4) != v14) {
                uint64_t v15 = v1[8];
              }
            }
          }
        }
        v13 += 8;
        if (v15 != v2)
        {
          uint64_t v3 = v13 - 8;
          return v2 == v3;
        }
      }
      uint64_t v3 = v1[8];
    }
  }
  return v2 == v3;
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::DeletePendingDeletion>,std::allocator<ecs2::ForwardToExecute<md::ita::DeletePendingDeletion>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51AC18;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::DeletePendingDeletion>,std::allocator<ecs2::ForwardToExecute<md::ita::DeletePendingDeletion>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#2},std::allocator<md::ita::DisconnectComponents &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF527FE0;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#2},std::allocator<md::ita::DisconnectComponents &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#1},std::allocator<md::ita::DisconnectComponents &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF528028;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#1},std::allocator<md::ita::DisconnectComponents &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

BOOL ecs2::Query<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle &>::Model<ecs2::RuntimeQuery<md::ls::PendingDeletion const&,md::ls::ColorRampDataHandle &>>::empty(uint64_t a1)
{
  v1 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v2 = (void *)gdc::Registry::storage<md::ls::PendingDeletion>(v1);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::ColorRampDataHandle>(v1);
  uint64_t v4 = v3;
  unint64_t v5 = v3 + 4;
  if (v3[8] - v3[7] >= v2[8] - v2[7]) {
    uint64_t v6 = (uint64_t)(v2 + 4);
  }
  else {
    uint64_t v6 = (uint64_t)(v3 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v10, v6, v2, v3, *(void *)(v6 + 24));
  if (v4[8] - v4[7] >= v2[8] - v2[7]) {
    uint64_t v7 = (uint64_t)(v2 + 4);
  }
  else {
    uint64_t v7 = (uint64_t)v5;
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v9, v7, v2, v4, *(void *)(v7 + 32));
  return v9[4] == v10[4];
}

BOOL ecs2::Query<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>::Model<ecs2::RuntimeQuery<md::ls::PendingDeletion const&,md::ls::TexturesToDisconnect &>>::empty(uint64_t a1)
{
  v1 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v2 = (void *)gdc::Registry::storage<md::ls::PendingDeletion>(v1);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::TexturesToDisconnect>(v1);
  uint64_t v4 = v3;
  unint64_t v5 = v3 + 4;
  if (v3[8] - v3[7] >= v2[8] - v2[7]) {
    uint64_t v6 = (uint64_t)(v2 + 4);
  }
  else {
    uint64_t v6 = (uint64_t)(v3 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v10, v6, v2, v3, *(void *)(v6 + 24));
  if (v4[8] - v4[7] >= v2[8] - v2[7]) {
    uint64_t v7 = (uint64_t)(v2 + 4);
  }
  else {
    uint64_t v7 = (uint64_t)v5;
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v9, v7, v2, v4, *(void *)(v7 + 32));
  return v9[4] == v10[4];
}

BOOL ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>::Model<ecs2::RuntimeQuery<md::ls::PendingDeletion const&,md::ls::RenderableAlbedoTexture *,md::ls::TextureHandleForType<Flyover::NightTexture> *,md::ls::TextureHandleForType<Flyover::DiffuseTexture> *,md::ls::UniqueMaterialAlbedoTexture *,md::ls::UniqueMaterialEmissiveTexture *,md::ls::UniqueMaterialDiffuseTexture *>>::empty(uint64_t a1)
{
  gdc::Registry::access<gdc::ecs::Access<gdc::Read<md::ls::PendingDeletion const>,gdc::Write<md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture>>>(v22, *(int8x8_t **)(*(void *)(a1 + 8) + 8));
  v1 = (void *)(v22[0] + 32);
  if (!v22[0]) {
    v1 = 0;
  }
  uint64_t v3 = v1[3];
  uint64_t v2 = v1[4];
  if (v2 != v3)
  {
    unint64_t v4 = *(unsigned int *)(v3 + 4);
    uint64_t v5 = *(void *)(v22[0] + 32);
    unint64_t v6 = (*(void *)(v22[0] + 40) - v5) >> 3;
    if (v4 >> 7 >= v6) {
      goto LABEL_11;
    }
    uint64_t v7 = *(void *)(v5 + 8 * (v4 >> 7));
    if (!v7) {
      goto LABEL_11;
    }
    unint64_t v8 = *(unsigned __int16 *)(v7 + 2 * (v4 & 0x7F));
    uint64_t v10 = *(void *)(v22[0] + 56);
    uint64_t v9 = *(void *)(v22[0] + 64);
    if (v8 >= (v9 - v10) >> 3) {
      goto LABEL_11;
    }
    uint64_t v11 = v10 + 8 * v8;
    if (v11 == v9 || *(_DWORD *)(v11 + 4) != v4)
    {
LABEL_11:
      uint64_t v13 = v3 + 8;
      while (1)
      {
        if (v13 == v2)
        {
          uint64_t v3 = v2;
          return v2 == v3;
        }
        unint64_t v16 = *(unsigned int *)(v13 + 4);
        if (v16 >> 7 >= v6)
        {
          uint64_t v14 = *(void *)(v22[0] + 64);
        }
        else
        {
          uint64_t v17 = *(void *)(v5 + 8 * (v16 >> 7));
          uint64_t v14 = *(void *)(v22[0] + 64);
          if (v17)
          {
            unint64_t v18 = *(unsigned __int16 *)(v17 + 2 * (v16 & 0x7F));
            uint64_t v19 = *(void *)(v22[0] + 56);
            if (v18 < (v14 - v19) >> 3)
            {
              uint64_t v20 = v19 + 8 * v18;
              if (*(_DWORD *)(v20 + 4) == v16) {
                uint64_t v15 = v20;
              }
              else {
                uint64_t v15 = *(void *)(v22[0] + 64);
              }
              goto LABEL_14;
            }
          }
        }
        uint64_t v15 = v14;
LABEL_14:
        v13 += 8;
        if (v15 != v14)
        {
          uint64_t v3 = v13 - 8;
          return v2 == v3;
        }
      }
    }
  }
  return v2 == v3;
}

BOOL ecs2::Query<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>::Model<ecs2::RuntimeQuery<md::ls::PendingDeletion const&,md::ls::PositionScaleInfoConstantDataHandle *,md::ls::StyleRouteLineMaskConstantDataHandle *,md::ls::StyleConstantHandle *,md::ls::LandCoverSettingsConstantDataHandle *,md::ls::StyleGroundOcclusionConstantDataHandle *,md::ls::ColorRampDataHandle *,md::ls::NormalsHandle *,md::ls::UVsHandle *,md::ls::ElevationHandle *,md::ls::InstanceTransformHandle *,md::ls::UniqueStyleEmissiveDataKeyHandle *,md::ls::NeedsClimateTint *>>::empty(uint64_t a1)
{
  v1 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v2 = (void *)gdc::Registry::storage<md::ls::PendingDeletion>(v1);
  gdc::Registry::storageTuple<md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint>(v20, v1);
  uint64_t v4 = v2[7];
  uint64_t v3 = v2[8];
  uint64_t v5 = v3 - v4;
  if (v3 != v4)
  {
    if ((unint64_t v6 = *(unsigned int *)(v4 + 4), v7 = v2[4], v8 = (v2[5] - v7) >> 3, v6 >> 7 >= v8)
      || (uint64_t v9 = *(void *)(v7 + 8 * (v6 >> 7))) == 0
      || (unint64_t v10 = *(unsigned __int16 *)(v9 + 2 * (v6 & 0x7F)), v10 >= v5 >> 3)
      || ((v11 = v4 + 8 * v10, v11 != v3) ? (BOOL v12 = *(_DWORD *)(v11 + 4) == v6) : (BOOL v12 = 0), !v12))
    {
      unint64_t v13 = v5 >> 3;
      uint64_t v14 = v4 + 8;
      while (v14 != v3)
      {
        unint64_t v15 = *(unsigned int *)(v14 + 4);
        uint64_t v16 = v2[8];
        if (v15 >> 7 < v8)
        {
          uint64_t v17 = *(void *)(v7 + 8 * (v15 >> 7));
          uint64_t v16 = v2[8];
          if (v17)
          {
            unint64_t v18 = *(unsigned __int16 *)(v17 + 2 * (v15 & 0x7F));
            uint64_t v16 = v2[8];
            if (v13 > v18)
            {
              uint64_t v16 = v4 + 8 * v18;
              if (*(_DWORD *)(v16 + 4) != v15) {
                uint64_t v16 = v2[8];
              }
            }
          }
        }
        v14 += 8;
        if (v16 != v3)
        {
          uint64_t v4 = v14 - 8;
          return v3 == v4;
        }
      }
      uint64_t v4 = v2[8];
    }
  }
  return v3 == v4;
}

BOOL gdc::ComponentStorageWrapper<md::ls::StyleConstantHandle>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::ls::StyleConstantHandle>::remove(void *a1, unint64_t a2)
{
  unint64_t v18 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  *(void *)(v14 + 8 * v7) = *(void *)(a1[11] - 8);
  a1[11] -= 8;
  unint64_t v15 = (void *)a1[28];
  if (!v15) {
    return 1;
  }
  uint64_t v16 = a1[31];
  while (1)
  {
    v20[0] = &v18;
    v20[1] = 1;
    uint64_t v19 = v16;
    uint64_t v17 = v15[6];
    if (!v17) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v17 + 48))(v17, &v19, v20);
    unint64_t v15 = (void *)*v15;
    if (!v15) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::ls::StyleConstantHandle>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::ls::StyleConstantHandle>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<md::ls::StyleRouteLineMaskConstantDataHandle>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::ls::StyleRouteLineMaskConstantDataHandle>::remove(void *a1, unint64_t a2)
{
  unint64_t v18 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  *(void *)(v14 + 8 * v7) = *(void *)(a1[11] - 8);
  a1[11] -= 8;
  unint64_t v15 = (void *)a1[28];
  if (!v15) {
    return 1;
  }
  uint64_t v16 = a1[31];
  while (1)
  {
    v20[0] = &v18;
    v20[1] = 1;
    uint64_t v19 = v16;
    uint64_t v17 = v15[6];
    if (!v17) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v17 + 48))(v17, &v19, v20);
    unint64_t v15 = (void *)*v15;
    if (!v15) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::ls::StyleRouteLineMaskConstantDataHandle>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::ls::StyleRouteLineMaskConstantDataHandle>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>::Model<ecs2::RuntimeQuery<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>>::empty(uint64_t a1)
{
  v1 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v2 = (void *)gdc::Registry::storage<md::ls::PendingDeletion>(v1);
  gdc::Registry::storage<md::ls::RenderableMaterialData>(v1);
  gdc::Registry::storage<md::ls::RampMaterialData>(v1);
  gdc::Registry::storage<md::ls::ColorDataHandle>(v1);
  gdc::Registry::storage<md::ls::UniqueMaterialVisibilityOptionsHandle>(v1);
  gdc::Registry::storage<md::ls::UniqueMaterialZIndexHandle>(v1);
  gdc::Registry::storage<md::ls::UniqueColorDataHandle>(v1);
  uint64_t v4 = v2[7];
  uint64_t v3 = v2[8];
  uint64_t v5 = v3 - v4;
  if (v3 != v4)
  {
    if ((unint64_t v6 = *(unsigned int *)(v4 + 4), v7 = v2[4], v8 = (v2[5] - v7) >> 3, v6 >> 7 >= v8)
      || (uint64_t v9 = *(void *)(v7 + 8 * (v6 >> 7))) == 0
      || (unint64_t v10 = *(unsigned __int16 *)(v9 + 2 * (v6 & 0x7F)), v10 >= v5 >> 3)
      || ((v11 = v4 + 8 * v10, v11 != v3) ? (BOOL v12 = *(_DWORD *)(v11 + 4) == v6) : (BOOL v12 = 0), !v12))
    {
      unint64_t v13 = v5 >> 3;
      uint64_t v14 = v4 + 8;
      while (v14 != v3)
      {
        unint64_t v15 = *(unsigned int *)(v14 + 4);
        uint64_t v16 = v2[8];
        if (v15 >> 7 < v8)
        {
          uint64_t v17 = *(void *)(v7 + 8 * (v15 >> 7));
          uint64_t v16 = v2[8];
          if (v17)
          {
            unint64_t v18 = *(unsigned __int16 *)(v17 + 2 * (v15 & 0x7F));
            uint64_t v16 = v2[8];
            if (v13 > v18)
            {
              uint64_t v16 = v4 + 8 * v18;
              if (*(_DWORD *)(v16 + 4) != v15) {
                uint64_t v16 = v2[8];
              }
            }
          }
        }
        v14 += 8;
        if (v16 != v3)
        {
          uint64_t v4 = v14 - 8;
          return v3 == v4;
        }
      }
      uint64_t v4 = v2[8];
    }
  }
  return v3 == v4;
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::DisconnectComponents>,std::allocator<ecs2::ForwardToExecute<md::ita::DisconnectComponents>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51AA20;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::DisconnectComponents>,std::allocator<ecs2::ForwardToExecute<md::ita::DisconnectComponents>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#2},std::allocator<md::ita::UpdateResourcesAfterRebuild &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF52A500;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#2},std::allocator<md::ita::UpdateResourcesAfterRebuild &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#1},std::allocator<md::ita::UpdateResourcesAfterRebuild &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF52A548;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#1},std::allocator<md::ita::UpdateResourcesAfterRebuild &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

BOOL ecs2::Query<md::ls::UniqueMaterialData &>::Model<ecs2::RuntimeQuery<md::ls::UniqueMaterialData &>>::empty(uint64_t a1)
{
  v1 = (void *)gdc::Registry::storage<md::ls::UniqueMaterialData>(*(int8x8_t **)(*(void *)(a1 + 8) + 8));
  uint64_t v3 = v1[7];
  uint64_t v2 = v1[8];
  uint64_t v4 = v2 - v3;
  if (v2 != v3)
  {
    if ((v5 = *(unsigned int *)(v3 + 4), uint64_t v6 = v1[4], v7 = (v1[5] - v6) >> 3, v5 >> 7 >= v7)
      || (uint64_t v8 = *(void *)(v6 + 8 * (v5 >> 7))) == 0
      || (unint64_t v9 = *(unsigned __int16 *)(v8 + 2 * (v5 & 0x7F)), v9 >= v4 >> 3)
      || ((uint64_t v10 = v3 + 8 * v9, v10 != v2) ? (v11 = *(_DWORD *)(v10 + 4) == v5) : (v11 = 0), !v11))
    {
      unint64_t v12 = v4 >> 3;
      uint64_t v13 = v3 + 8;
      while (v13 != v2)
      {
        unint64_t v14 = *(unsigned int *)(v13 + 4);
        uint64_t v15 = v1[8];
        if (v14 >> 7 < v7)
        {
          uint64_t v16 = *(void *)(v6 + 8 * (v14 >> 7));
          uint64_t v15 = v1[8];
          if (v16)
          {
            unint64_t v17 = *(unsigned __int16 *)(v16 + 2 * (v14 & 0x7F));
            uint64_t v15 = v1[8];
            if (v12 > v17)
            {
              uint64_t v15 = v3 + 8 * v17;
              if (*(_DWORD *)(v15 + 4) != v14) {
                uint64_t v15 = v1[8];
              }
            }
          }
        }
        v13 += 8;
        if (v15 != v2)
        {
          uint64_t v3 = v13 - 8;
          return v2 == v3;
        }
      }
      uint64_t v3 = v1[8];
    }
  }
  return v2 == v3;
}

BOOL ecs2::Query<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>::Model<ecs2::RuntimeQuery<md::ls::SupportsRebuildingRenderables const&,md::ls::EnteringView const&,md::ls::AssociationTileHandle const&>>::empty(uint64_t a1)
{
  v1 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v2 = gdc::Registry::storage<md::ls::SupportsRebuildingRenderables>(v1);
  uint64_t v3 = gdc::Registry::storage<md::ls::EnteringView>(v1);
  uint64_t v4 = gdc::Registry::storage<md::ls::AssociationTileHandle>(v1);
  if (*(void *)(v3 + 64) - *(void *)(v3 + 56) >= *(void *)(v2 + 64) - *(void *)(v2 + 56)) {
    uint64_t v5 = v2;
  }
  else {
    uint64_t v5 = v3;
  }
  if (*(void *)(v4 + 64) - *(void *)(v4 + 56) < *(void *)(v5 + 64) - *(void *)(v5 + 56)) {
    uint64_t v5 = v4;
  }
  v11[0] = v5 + 32;
  v11[1] = v2;
  v11[2] = v3;
  v11[3] = v4;
  uint64_t v7 = *(void *)(v5 + 56);
  uint64_t v6 = *(void *)(v5 + 64);
  uint64_t v12 = v7;
  if (v6 != v7
    && !gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v11))
  {
    uint64_t v8 = v7 + 8;
    do
    {
      uint64_t v7 = v8;
      uint64_t v12 = v8;
      if (v8 == v6) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v11);
      uint64_t v8 = v7 + 8;
    }
    while (!isValid);
  }
  return v6 == v7;
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::UpdateResourcesAfterRebuild>,std::allocator<ecs2::ForwardToExecute<md::ita::UpdateResourcesAfterRebuild>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51BCB0;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::UpdateResourcesAfterRebuild>,std::allocator<ecs2::ForwardToExecute<md::ita::UpdateResourcesAfterRebuild>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfReadyToProcess &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF5282B0;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfReadyToProcess &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfReadyToProcess &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF5282F8;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfReadyToProcess &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

BOOL ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>::Model<ecs2::RuntimeQuery<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>>::empty(uint64_t a1)
{
  v1 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v2 = gdc::Registry::storage<md::ls::RegisterHandle>(v1);
  uint64_t v3 = gdc::Registry::storage<md::ls::MapDataTypeV>(v1);
  uint64_t v4 = gdc::Registry::storage<md::ls::CheckIfReadyToProcess>(v1);
  uint64_t v5 = gdc::Registry::storage<md::ls::FlyoverOctileKey>(v1);
  uint64_t v6 = gdc::Registry::storage<md::ls::BaseMapTileHandle>(v1);
  uint64_t v7 = gdc::Registry::storage<md::ls::WillEnterView>(v1);
  uint64_t v8 = gdc::Registry::storage<md::ls::RenderablesCount>(v1);
  v11[0] = v2;
  v11[1] = v3;
  v11[2] = v4;
  v11[3] = v5;
  v11[4] = v6;
  void v11[5] = v7;
  v11[6] = v8;
  gdc::RegistryQueryView<gdc::All<md::ls::RegisterHandle const,md::ls::RenderablesCount,md::ls::MapDataTypeV const,md::ls::CheckIfReadyToProcess const>,gdc::Any<md::ls::FlyoverOctileKey const,md::ls::BaseMapTileHandle const,md::ls::WillEnterView const>,gdc::None<>>::begin(v12, v11);
  if (*(void *)(v8 + 64) - *(void *)(v8 + 56) >= *(void *)(v2 + 64) - *(void *)(v2 + 56)) {
    uint64_t v9 = v2;
  }
  else {
    uint64_t v9 = v8;
  }
  if (*(void *)(v3 + 64) - *(void *)(v3 + 56) < *(void *)(v9 + 64) - *(void *)(v9 + 56)) {
    uint64_t v9 = v3;
  }
  if (*(void *)(v4 + 64) - *(void *)(v4 + 56) < *(void *)(v9 + 64) - *(void *)(v9 + 56)) {
    uint64_t v9 = v4;
  }
  return *(void *)(v9 + 64) == v12[6];
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::CheckIfReadyToProcess>,std::allocator<ecs2::ForwardToExecute<md::ita::CheckIfReadyToProcess>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51AB88;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::CheckIfReadyToProcess>,std::allocator<ecs2::ForwardToExecute<md::ita::CheckIfReadyToProcess>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfShouldDeleteUniqueMaterial &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF52BE50;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfShouldDeleteUniqueMaterial &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfShouldDeleteUniqueMaterial &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF52BE98;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfShouldDeleteUniqueMaterial &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::CheckIfShouldDeleteUniqueMaterial>,std::allocator<ecs2::ForwardToExecute<md::ita::CheckIfShouldDeleteUniqueMaterial>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51C958;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::CheckIfShouldDeleteUniqueMaterial>,std::allocator<ecs2::ForwardToExecute<md::ita::CheckIfShouldDeleteUniqueMaterial>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfShouldDeleteRenderable &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF52ACE0;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfShouldDeleteRenderable &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#2}<gdc>> ()(void)>::~__func()
{
}

void *std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfShouldDeleteRenderable &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF52AD28;
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfShouldDeleteRenderable &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#1}<gdc>> ()(void)>::~__func()
{
}

BOOL ecs2::Query<md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&>::Model<ecs2::RuntimeQuery<md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&>>::empty(uint64_t a1)
{
  v1 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v2 = (void *)gdc::Registry::storage<md::ls::MeshRenderableID>(v1);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::AssociationHandle>(v1);
  uint64_t v4 = v3;
  uint64_t v5 = v3 + 4;
  if (v3[8] - v3[7] >= v2[8] - v2[7]) {
    uint64_t v6 = (uint64_t)(v2 + 4);
  }
  else {
    uint64_t v6 = (uint64_t)(v3 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v10, v6, v2, v3, *(void *)(v6 + 24));
  if (v4[8] - v4[7] >= v2[8] - v2[7]) {
    uint64_t v7 = (uint64_t)(v2 + 4);
  }
  else {
    uint64_t v7 = (uint64_t)v5;
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v9, v7, v2, v4, *(void *)(v7 + 32));
  return v9[4] == v10[4];
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::CheckIfShouldDeleteRenderable>,std::allocator<ecs2::ForwardToExecute<md::ita::CheckIfShouldDeleteRenderable>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51C0A0;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::CheckIfShouldDeleteRenderable>,std::allocator<ecs2::ForwardToExecute<md::ita::CheckIfShouldDeleteRenderable>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void *std::__function::__func<ecs2::ForwardToExecute<ToggleFeatureFlagTasks>,std::allocator<ecs2::ForwardToExecute<ToggleFeatureFlagTasks>>,void ()(ecs2::Runtime &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF58F910;
  result[1] = v3;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<ToggleFeatureFlagTasks>,std::allocator<ecs2::ForwardToExecute<ToggleFeatureFlagTasks>>,void ()(ecs2::Runtime &)>::~__func()
{
}

void sub_1A204BA40(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A204BA58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~vector[abi:nn180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_1A204BC2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }

  _Unwind_Resume(a1);
}

void sub_1A204BE78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A204C364(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A204C37C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

void geo::_retain_ptr<VKCameraController * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5597F8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKCameraController * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5597F8;

  return a1;
}

void sub_1A204C898(_Unwind_Exception *a1)
{
  std::function<BOOL ()(std::shared_ptr<gdc::Camera>,geo::Unit<geo::MeterUnitDescription,double> &,geo::Unit<geo::MeterUnitDescription,double> &)>::~function((void *)(v2 - 88));

  _Unwind_Resume(a1);
}

void sub_1A204C928(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VKMapImageCanvas;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A204CCE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  std::mutex::unlock(v13);

  _Unwind_Resume(a1);
}

void sub_1A204D104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id location, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  std::function<void ()(GEOExperimentConfiguration *)>::~function(&a16);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void sub_1A204D1AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A204D34C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void md::OverlayContainer::addOverlay(md::OverlayContainer *this, VKOverlay *a2)
{
  uint64_t v3 = a2;
  std::mutex::lock((std::mutex *)((char *)this + 232));
  md::OverlayContainer::_insertOverlay((uint64_t)this, v3, *((id **)this + 3 * [(VKOverlay *)v3 level] + 21));
  std::mutex::unlock((std::mutex *)((char *)this + 232));
}

void sub_1A204D514(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void md::OverlayContainer::_insertOverlay(uint64_t a1, void *a2, id *a3)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  v96 = v5;
  unint64_t v6 = [v5 level];
  unint64_t v7 = a1 + 24 * v6;
  uint64_t v10 = *(void *)(v7 + 160);
  uint64_t v9 = (id **)(v7 + 160);
  uint64_t v8 = v10;
  uint64_t v12 = (unint64_t *)(v9 + 1);
  uint64_t v11 = (uint64_t)v9[1];
  if (v10 == v11) {
    goto LABEL_12;
  }
  while ((geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(*(void **)(v8 + 8), &v96) & 1) == 0)
  {
    v8 += 24;
    if (v8 == v11)
    {
      uint64_t v8 = v11;
      break;
    }
  }
  uint64_t v13 = v8;
  uint64_t v8 = *v12;
  if (v13 == *v12)
  {
LABEL_12:
    if ((id *)v8 == a3)
    {
      id v38 = v5;
      v97 = (id *)&unk_1EF559F78;
      id obj = v38;
      unint64_t v39 = *v12;
      if (*v12 >= *(void *)(a1 + 24 * v6 + 176))
      {
        uint64_t v41 = std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__push_back_slow_path<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>((void **)v9, (uint64_t)&v97);
      }
      else
      {
        *(void *)unint64_t v39 = &unk_1EF559F78;
        *(void *)(v39 + 8) = 0;
        objc_storeStrong((id *)(v39 + 8), obj);
        id v40 = obj;
        id obj = 0;

        uint64_t v41 = (char *)(v39 + 24);
      }
      *uint64_t v12 = (unint64_t)v41;
      v97 = (id *)&unk_1EF559F78;

      goto LABEL_84;
    }
    id v95 = v5;
    uint64_t v16 = *v9;
    unint64_t v17 = v6;
    uint64_t v18 = (char *)a3 - (char *)*v9;
    uint64_t v19 = v18 / 24;
    uint64_t v20 = &(*v9)[3 * (v18 / 24)];
    unint64_t v21 = *v12;
    unint64_t v94 = v17;
    uint64_t v22 = a1 + 24 * v17;
    unint64_t v25 = *(void *)(v22 + 176);
    unint64_t v24 = (char **)(v22 + 176);
    unint64_t v23 = v25;
    if (*v12 < v25)
    {
      if (v20 == (id *)v21)
      {
        *uint64_t v20 = &unk_1EF559F78;
        v46 = (char *)&v16[3 * v19];
        *((void *)v46 + 1) = 0;
        objc_storeStrong((id *)v46 + 1, v95);
        unint64_t v6 = v94;

        *uint64_t v12 = (unint64_t)(v20 + 3);
      }
      else
      {
        v91 = *v9;
        unint64_t v26 = v21 - 24;
        uint64_t v89 = v18 / 24;
        if (v21 < 0x18)
        {
          unint64_t v32 = *v12;
          unint64_t v6 = v17;
        }
        else
        {
          unint64_t v27 = *v12;
          unint64_t v28 = *v12;
          unint64_t v6 = v17;
          do
          {
            unint64_t v29 = v28;
            *(void *)unint64_t v28 = &unk_1EF559F78;
            *(void *)(v28 + 8) = 0;
            unint64_t v30 = v28 + 8;
            objc_storeStrong((id *)(v28 + 8), *(id *)(v26 + 8));
            uint64_t v31 = *(void **)(v26 + 8);
            *(void *)(v26 + 8) = 0;

            v26 += 24;
            v27 += 24;
            unint64_t v28 = v30 + 16;
          }
          while (v26 < v21);
          unint64_t v32 = v29 + 24;
        }
        *uint64_t v12 = v32;
        if ((id *)v21 != v20 + 3)
        {
          unint64_t v65 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v21 - (void)(v20 + 3)) >> 3);
          v66 = (id *)(v21 - 16);
          uint64_t v67 = (uint64_t)&v91[3 * v89 - 2];
          uint64_t v68 = 24 * v65;
          do
          {
            objc_storeStrong(v66, *(id *)(v67 + v68));
            v69 = *(void **)(v67 + v68);
            *(void *)(v67 + v68) = 0;

            v66 -= 3;
            v68 -= 24;
          }
          while (v68);
        }
        objc_storeStrong(&v91[3 * v89 + 1], v95);
      }
LABEL_83:

      goto LABEL_84;
    }
    unint64_t v42 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v21 - (void)v16) >> 3) + 1;
    if (v42 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    v90 = v24;
    v92 = *v9;
    unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - (void)v16) >> 3);
    if (2 * v43 > v42) {
      unint64_t v42 = 2 * v43;
    }
    if (v43 >= 0x555555555555555) {
      unint64_t v44 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v44 = v42;
    }
    v101 = v24;
    if (v44)
    {
      if (v44 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_115;
      }
      v45 = (id *)operator new(24 * v44);
      uint64_t v19 = v18 / 24;
    }
    else
    {
      v45 = 0;
    }
    v47 = &v45[3 * v19];
    v97 = v45;
    id obj = v47;
    v99 = v47;
    v100 = (char *)&v45[3 * v44];
    if (v19 != v44)
    {
      v93 = (char *)&v45[3 * v44];
LABEL_65:
      unint64_t v6 = v94;
LABEL_66:
      id *v47 = &unk_1EF559F78;
      v47[1] = 0;
      objc_storeStrong(v47 + 1, v95);

      v49 = *v9;
      v50 = v47;
      if (*v9 != v20)
      {
        v51 = v47 - 3;
        v52 = v20;
        v50 = v47;
        do
        {
          *(v50 - 3) = &unk_1EF559F78;
          v50 -= 3;
          v50[1] = 0;
          v54 = *(v52 - 2);
          v53 = v52 - 2;
          objc_storeStrong(v50 + 1, v54);
          v55 = *v53;
          *v53 = 0;

          v52 = v53 - 1;
          v51 -= 3;
        }
        while (v52 != v49);
      }
      v56 = v47 + 3;
      id obj = v50;
      v57 = (id *)*v12;
      if ((id *)*v12 != v20)
      {
        v58 = v47 + 3;
        do
        {
          v59 = v56;
          id *v56 = &unk_1EF559F78;
          v56[1] = 0;
          v60 = v56 + 1;
          objc_storeStrong(v56 + 1, v20[1]);
          id v61 = v20[1];
          v20[1] = 0;

          v20 += 3;
          v58 += 3;
          v56 = v60 + 2;
        }
        while (v20 != v57);
        v56 = v59 + 3;
        v50 = (id *)obj;
        uint64_t v20 = (id *)*v12;
      }
      v62 = *v9;
      *uint64_t v9 = v50;
      *uint64_t v12 = (unint64_t)v56;
      v63 = *v90;
      *v90 = v93;
      v99 = v20;
      v100 = v63;
      v97 = v62;
      id obj = v62;
      if (v20 != v62)
      {
        do
        {
          v64 = (void (**)(uint64_t))*(v20 - 3);
          v99 = v20 - 3;
          (*v64)((uint64_t)(v20 - 3));
          uint64_t v20 = v99;
        }
        while (v99 != v62);
        uint64_t v20 = v97;
      }
      if (v20) {
        operator delete(v20);
      }
      goto LABEL_83;
    }
    if (v18 >= 1)
    {
      v93 = (char *)&v45[3 * v44];
      uint64_t v48 = v19 + 2;
      if (v19 >= -1) {
        uint64_t v48 = v19 + 1;
      }
      v47 -= 3 * (v48 >> 1);
      id obj = v47;
      v99 = v47;
      goto LABEL_65;
    }
    if (v92 == a3) {
      unint64_t v87 = 1;
    }
    else {
      unint64_t v87 = 2 * v19;
    }
    unint64_t v6 = v94;
    if (v87 <= 0xAAAAAAAAAAAAAAALL)
    {
      v88 = (id *)operator new(24 * v87);
      v47 = &v88[3 * (v87 >> 2)];
      v97 = v88;
      id obj = v47;
      v99 = v47;
      v100 = (char *)&v88[3 * v87];
      v93 = v100;
      if (v45) {
        operator delete(v45);
      }
      goto LABEL_66;
    }
LABEL_115:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v14 = v13 + 24;
  if ((id *)v8 == a3)
  {
    if ((id *)v14 != a3)
    {
      while (1)
      {
        uint64_t v35 = v13 + 24;
        std::swap[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(v13, v13 + 24);
        if ((id *)(v13 + 48) == a3) {
          break;
        }
        if (v35 == v14) {
          uint64_t v14 = v13 + 48;
        }
        v13 += 24;
      }
      if (v35 != v14)
      {
        uint64_t v36 = v14;
        while (1)
        {
          std::swap[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(v35, v36);
          v35 += 24;
          v36 += 24;
          BOOL v37 = v35 == v14;
          if ((id *)v36 == a3)
          {
            if (v35 == v14) {
              break;
            }
            uint64_t v36 = v14 + 24;
            while (1)
            {
              std::swap[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(v35, v14);
              v35 += 24;
              BOOL v37 = v35 == v14;
              if ((id *)v36 != a3) {
                break;
              }
              if (v35 == v14) {
                goto LABEL_84;
              }
            }
          }
          if (v37) {
            uint64_t v14 = v36;
          }
        }
      }
    }
  }
  else if ((id *)v14 != a3)
  {
    while (1)
    {
      uint64_t v15 = v13 + 24;
      std::swap[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(v13, v13 + 24);
      if ((id *)(v13 + 48) == a3) {
        break;
      }
      if (v15 == v14) {
        uint64_t v14 = v13 + 48;
      }
      v13 += 24;
    }
    if (v15 != v14)
    {
      uint64_t v33 = v14;
      while (1)
      {
        std::swap[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(v15, v33);
        v15 += 24;
        v33 += 24;
        BOOL v34 = v15 == v14;
        if ((id *)v33 == a3)
        {
          if (v15 == v14) {
            break;
          }
          uint64_t v33 = v14 + 24;
          while (1)
          {
            std::swap[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(v15, v14);
            v15 += 24;
            BOOL v34 = v15 == v14;
            if ((id *)v33 != a3) {
              break;
            }
            if (v15 == v14) {
              goto LABEL_84;
            }
          }
        }
        if (v34) {
          uint64_t v14 = v33;
        }
      }
    }
  }
LABEL_84:
  uint64_t v70 = *(void *)(a1 + 208);
  uint64_t v71 = *(void *)(a1 + 216);
  if (v70 == v71)
  {
    uint64_t v72 = *(void *)(a1 + 208);
  }
  else
  {
    while ((geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(*(void **)(v70 + 8), &v96) & 1) == 0)
    {
      v70 += 24;
      if (v70 == v71)
      {
        uint64_t v70 = v71;
        break;
      }
    }
    uint64_t v72 = v70;
    uint64_t v70 = *(void *)(a1 + 216);
  }
  v73 = v96;
  if (v72 == v70)
  {
    [v96 replaceMapContentInRect];
    if (vabdd_f64(v81, *MEMORY[0x1E4F63F08]) < 0.00000001
      && vabdd_f64(v78, *(double *)(MEMORY[0x1E4F63F08] + 8)) < 0.00000001
      && vabdd_f64(v79, *(double *)(MEMORY[0x1E4F63F08] + 16)) < 0.00000001
      && vabdd_f64(v80, *(double *)(MEMORY[0x1E4F63F08] + 24)) < 0.00000001)
    {
      *(unsigned char *)(a1 + 344) = 1;
      id v82 = v73;
      v97 = (id *)&unk_1EF559F78;
      id obj = v82;
      unint64_t v83 = *(void *)(a1 + 216);
      if (v83 >= *(void *)(a1 + 224))
      {
        v85 = std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__push_back_slow_path<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>((void **)(a1 + 208), (uint64_t)&v97);
      }
      else
      {
        *(void *)unint64_t v83 = &unk_1EF559F78;
        *(void *)(v83 + 8) = 0;
        objc_storeStrong((id *)(v83 + 8), obj);
        id v84 = obj;
        id obj = 0;

        v85 = (char *)(v83 + 24);
      }
      *(void *)(a1 + 216) = v85;
      v97 = (id *)&unk_1EF559F78;
    }
  }
  unsigned int v74 = objc_msgSend(v73, "areResourcesRequired", v89);
  if (v6 <= 1)
  {
    uint64_t v75 = *(void *)(a1 + 16 * v6 + 8 * v74);
    if (v75)
    {
      id v76 = v73;
      v103 = 0;
      v77 = operator new(0x28uLL);
      void *v77 = &unk_1EF572300;
      v77[1] = a1;
      v77[2] = v76;
      v77[3] = v75;
      v77[4] = v6;
      v103 = v77;
      md::OverlayContainer::queueCommand(a1, 0, v102);
      if (v103 == v102)
      {
        (*(void (**)(void *))(v102[0] + 32))(v102);
      }
      else if (v103)
      {
        (*(void (**)(void))(*v103 + 40))();
      }
    }
  }
  if ([v73 areResourcesRequired])
  {
    unsigned int v86 = [v73 identifier];
    std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>(a1 + 296, v86, v86);
  }
  *(unsigned char *)(a1 + 345) = 1;
  ++*(_DWORD *)(a1 + 348);
}

void sub_1A204DF54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  std::__split_buffer<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~__split_buffer((uint64_t)va);

  _Unwind_Resume(a1);
}

uint64_t geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(void *a1, void **a2)
{
  id v3 = a1;
  uint64_t v4 = *a2;
  id v5 = v3;
  id v6 = v4;
  if (v6 == v5) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = [v5 isEqual:v6];
  }

  return v7;
}

void sub_1A204E070(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__push_back_slow_path<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(void **a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = &v7[24 * v2];
  uint64_t v9 = &v7[24 * v6];
  *(void *)uint64_t v8 = &unk_1EF559F78;
  *((void *)v8 + 1) = 0;
  objc_storeStrong((id *)v8 + 1, *(id *)(a2 + 8));
  uint64_t v10 = *(void **)(a2 + 8);
  *(void *)(a2 + 8) = 0;

  uint64_t v11 = v8 + 24;
  uint64_t v13 = (id *)*a1;
  uint64_t v12 = (id *)a1[1];
  if (v12 == *a1)
  {
    *a1 = v8;
    a1[1] = v11;
    a1[2] = v9;
    if (!v12) {
      return v11;
    }
    goto LABEL_19;
  }
  uint64_t v14 = (uint64_t)&v7[24 * v2 - 24];
  do
  {
    *((void *)v8 - 3) = &unk_1EF559F78;
    v8 -= 24;
    *((void *)v8 + 1) = 0;
    objc_storeStrong((id *)v8 + 1, *(v12 - 2));
    uint64_t v15 = *(v12 - 2);
    *(v12 - 2) = 0;

    v14 -= 24;
    v12 -= 3;
  }
  while (v12 != v13);
  uint64_t v12 = (id *)*a1;
  uint64_t v16 = (id *)a1[1];
  *a1 = v8;
  a1[1] = v11;
  a1[2] = v9;
  if (v16 != v12)
  {
    unint64_t v17 = v16 - 3;
    uint64_t v18 = v16 - 3;
    uint64_t v19 = v16 - 3;
    do
    {
      uint64_t v20 = (void (**)(id *))*v19;
      v19 -= 3;
      (*v20)(v18);
      v17 -= 3;
      BOOL v21 = v18 == v12;
      uint64_t v18 = v19;
    }
    while (!v21);
  }
  if (v12) {
LABEL_19:
  }
    operator delete(v12);
  return v11;
}

void std::swap[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (id *)(a1 + 8);
  id obj = *(id *)(a1 + 8);
  id v4 = *v3;
  *unint64_t v3 = 0;

  id v5 = *(void **)(a2 + 8);
  a2 += 8;
  objc_storeStrong(v3, v5);
  id v6 = *(id *)a2;
  *(void *)a2 = 0;

  objc_storeStrong((id *)a2, obj);
}

void md::OverlayContainer::queueCommand(uint64_t a1, char a2, void *a3)
{
  id v6 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  unint64_t v7 = *(void *)(a1 + 120);
  if (*(void *)(a1 + 112) == v7)
  {
    uint64_t v8 = **(void **)(a1 + 352);
    if (v8)
    {
      LOBYTE(v35) = 1;
      md::MapEngine::setNeedsTick(v8, &v35);
      unint64_t v7 = *(void *)(a1 + 120);
    }
    else
    {
      unint64_t v7 = *(void *)(a1 + 112);
    }
  }
  unint64_t v9 = *(void *)(a1 + 128);
  if (v7 < v9)
  {
    *(unsigned char *)unint64_t v7 = a2;
    unint64_t v10 = v7 + 8;
    uint64_t v11 = a3[3];
    if (v11)
    {
      if ((void *)v11 == a3)
      {
        *(void *)(v7 + 32) = v10;
        (*(void (**)(void))(*(void *)a3[3] + 24))(a3[3]);
        goto LABEL_26;
      }
      uint64_t v11 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v11 + 16))(v11, v10);
    }
    *(void *)(v7 + 32) = v11;
LABEL_26:
    uint64_t v22 = (char *)(v7 + 40);
    *(void *)(a1 + 120) = v22;
    goto LABEL_46;
  }
  uint64_t v12 = *(void *)(a1 + 112);
  unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - v12) >> 3);
  if (v13 + 1 > 0x666666666666666) {
    abort();
  }
  unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v9 - v12) >> 3);
  uint64_t v15 = 2 * v14;
  if (2 * v14 <= v13 + 1) {
    uint64_t v15 = v13 + 1;
  }
  if (v14 >= 0x333333333333333) {
    unint64_t v16 = 0x666666666666666;
  }
  else {
    unint64_t v16 = v15;
  }
  uint64_t v38 = a1 + 128;
  if (v16)
  {
    if (v16 > 0x666666666666666) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v17 = operator new(40 * v16);
  }
  else
  {
    unint64_t v17 = 0;
  }
  uint64_t v18 = &v17[5 * v13];
  uint64_t v35 = v17;
  uint64_t v36 = v18;
  *(void *)&long long v37 = v18;
  *((void *)&v37 + 1) = &v17[5 * v16];
  unsigned char *v18 = a2;
  uint64_t v19 = v18 + 8;
  uint64_t v20 = (void *)a3[3];
  if (v20)
  {
    if (v20 == a3)
    {
      v17[5 * v13 + 4] = v19;
      (*(void (**)(void *))(*a3 + 24))(a3);
      uint64_t v18 = v36;
      BOOL v21 = (char *)v37;
      goto LABEL_28;
    }
    v17[5 * v13 + 4] = (*(uint64_t (**)(void *, unsigned char *))(*v20 + 16))(v20, v19);
  }
  else
  {
    v17[5 * v13 + 4] = 0;
  }
  BOOL v21 = (char *)&v17[5 * v13];
LABEL_28:
  uint64_t v22 = v21 + 40;
  *(void *)&long long v37 = v21 + 40;
  unint64_t v24 = *(char **)(a1 + 112);
  unint64_t v23 = *(char **)(a1 + 120);
  if (v23 == v24)
  {
    *(void *)(a1 + 112) = v18;
    *(void *)(a1 + 120) = v22;
    *(void *)(a1 + 128) = *((void *)&v37 + 1);
  }
  else
  {
    uint64_t v25 = 0;
    do
    {
      unint64_t v26 = &v18[v25];
      unint64_t v27 = &v23[v25];
      v18[v25 - 40] = v23[v25 - 40];
      unint64_t v28 = *(char **)&v23[v25 - 8];
      if (v28)
      {
        if (v27 - 32 == v28)
        {
          *((void *)v26 - 1) = v26 - 32;
          (*(void (**)(void))(**((void **)v27 - 1) + 24))(*((void *)v27 - 1));
        }
        else
        {
          *((void *)v26 - 1) = v28;
          *((void *)v27 - 1) = 0;
        }
      }
      else
      {
        *((void *)v26 - 1) = 0;
      }
      v25 -= 40;
    }
    while (&v23[v25] != v24);
    unint64_t v23 = *(char **)(a1 + 112);
    unint64_t v29 = *(char **)(a1 + 120);
    *(void *)(a1 + 112) = &v18[v25];
    unint64_t v30 = (char *)v37;
    *(_OWORD *)(a1 + 120) = v37;
    uint64_t v22 = v30;
    if (v29 != v23)
    {
      uint64_t v31 = v29 - 32;
      unint64_t v32 = v29 - 32;
      do
      {
        BOOL v34 = (char *)*((void *)v32 + 3);
        if (v32 == v34)
        {
          (*(void (**)(char *))(*(void *)v32 + 32))(v32);
        }
        else if (v34)
        {
          (*(void (**)(char *))(*(void *)v34 + 40))(v34);
        }
        uint64_t v33 = v32 - 8;
        v32 -= 40;
        v31 -= 40;
      }
      while (v33 != v23);
    }
  }
  if (v23) {
    operator delete(v23);
  }
LABEL_46:
  *(void *)(a1 + 120) = v22;
  std::mutex::unlock(v6);
}

void sub_1A204E6C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<md::OverlayContainerCommandType,std::function<void ()(void)>>>::~__split_buffer((uint64_t)va);
  std::mutex::unlock(v2);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::pair<md::OverlayContainerCommandType,std::function<void ()(void)>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    while (1)
    {
      *(void *)(a1 + 16) = i - 40;
      uint64_t v4 = *(void *)(i - 8);
      if (v4 != i - 32) {
        break;
      }
      (*(void (**)(uint64_t))(*(void *)(i - 32) + 32))(i - 32);
      uint64_t i = *(void *)(a1 + 16);
      if (i == v3) {
        goto LABEL_8;
      }
    }
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    }
  }
LABEL_8:
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0,std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 8);
  id v3 = *(id *)(a1 + 16);
  if ([v3 canProvideVectorData])
  {
    char v4 = 2;
  }
  else
  {
    id v5 = [v3 rasterTileProvider];

    if (v5)
    {
      char v4 = 3;
    }
    else
    {
      id v6 = [v3 customTileProvider];

      if (v6) {
        char v4 = 4;
      }
      else {
        char v4 = 1;
      }
    }
  }

  id v7 = *(id *)(a1 + 16);
  uint64_t v33 = &unk_1EF559F78;
  id v34 = v7;
  uint64_t v8 = [*(id *)(a1 + 16) rasterTileProvider];
  if (v8)
  {
    char v9 = 0;
  }
  else
  {
    unint64_t v10 = [*(id *)(a1 + 16) customTileProvider];
    char v9 = v10 == 0;
  }
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t v31 = &unk_1EF559F78;
  id obj = v34;
  unint64_t v42 = 0;
  uint64_t v12 = operator new(0x20uLL);
  *(void *)uint64_t v12 = &unk_1EF57E6D0;
  *((void *)v12 + 1) = &unk_1EF559F78;
  *((void *)v12 + 2) = 0;
  objc_storeStrong((id *)v12 + 2, obj);
  id v13 = obj;
  id obj = 0;

  unint64_t v42 = v12;
  v39[0] = &unk_1EF57E688;
  v39[1] = v2;
  id v40 = v39;
  *(_OWORD *)unint64_t v28 = 0u;
  *(_OWORD *)__p = 0u;
  int v30 = 1065353216;
  std::__hash_table<md::OverlayTileDataType,std::hash<md::OverlayTileDataType>,std::equal_to<md::OverlayTileDataType>,std::allocator<md::OverlayTileDataType>>::__emplace_unique_key_args<md::OverlayTileDataType,md::OverlayTileDataType const&>((uint64_t)v28, v4, v4);
  md::OverlayLayerDataSource::conditionalInvalidate(v11, v41, v39, v9, (uint64_t)v28);
  unint64_t v14 = __p[0];
  if (__p[0])
  {
    do
    {
      uint64_t v15 = (void *)*v14;
      operator delete(v14);
      unint64_t v14 = v15;
    }
    while (v15);
  }
  unint64_t v16 = v28[0];
  v28[0] = 0;
  if (v16) {
    operator delete(v16);
  }
  if (v40 == v39)
  {
    (*(void (**)(void *))(v39[0] + 32))(v39);
  }
  else if (v40)
  {
    (*(void (**)(void *))(*v40 + 40))(v40);
  }
  if (v42 == v41)
  {
    (*(void (**)(void *))(v41[0] + 32))(v41);
  }
  else if (v42)
  {
    (*(void (**)(void *))(*v42 + 40))(v42);
  }
  uint64_t v31 = &unk_1EF559F78;

  if (*(void *)(a1 + 32) == 1)
  {
    uint64_t v17 = *(void *)(v2 + 32);
    unint64_t v26 = &unk_1EF559F78;
    id v27 = v34;
    uint64_t v38 = 0;
    uint64_t v18 = operator new(0x20uLL);
    *(void *)uint64_t v18 = &unk_1EF52E058;
    *((void *)v18 + 1) = &unk_1EF559F78;
    *((void *)v18 + 2) = 0;
    objc_storeStrong((id *)v18 + 2, v27);
    id v19 = v27;
    id v27 = 0;

    uint64_t v38 = v18;
    v35[0] = &unk_1EF52E0A0;
    v35[1] = v2;
    uint64_t v36 = v35;
    *(_OWORD *)unint64_t v23 = 0u;
    *(_OWORD *)unint64_t v24 = 0u;
    int v25 = 1065353216;
    std::__hash_table<md::OverlayTileDataType,std::hash<md::OverlayTileDataType>,std::equal_to<md::OverlayTileDataType>,std::allocator<md::OverlayTileDataType>>::__emplace_unique_key_args<md::OverlayTileDataType,md::OverlayTileDataType const&>((uint64_t)v23, v4, v4);
    md::OverlayLayerDataSource::conditionalInvalidate(v17, v37, v35, v9, (uint64_t)v23);
    uint64_t v20 = v24[0];
    if (v24[0])
    {
      do
      {
        BOOL v21 = (void *)*v20;
        operator delete(v20);
        uint64_t v20 = v21;
      }
      while (v21);
    }
    uint64_t v22 = v23[0];
    v23[0] = 0;
    if (v22) {
      operator delete(v22);
    }
    if (v36 == v35)
    {
      (*(void (**)(void *))(v35[0] + 32))(v35);
    }
    else if (v36)
    {
      (*(void (**)(void *))(*v36 + 40))(v36);
    }
    if (v38 == v37)
    {
      (*(void (**)(void *))(v37[0] + 32))(v37);
    }
    else if (v38)
    {
      (*(void (**)(void *))(*v38 + 40))(v38);
    }
    unint64_t v26 = &unk_1EF559F78;
  }
  uint64_t v33 = &unk_1EF559F78;
}

void sub_1A204ECF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  _Unwind_Resume(a1);
}

void std::__hash_table<md::OverlayTileDataType,std::hash<md::OverlayTileDataType>,std::equal_to<md::OverlayTileDataType>,std::allocator<md::OverlayTileDataType>>::__emplace_unique_key_args<md::OverlayTileDataType,md::OverlayTileDataType const&>(uint64_t a1, unsigned __int8 a2, char a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    char v9 = *(uint64_t ****)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == (uint64_t *)a2)
            {
              if (*((unsigned __int8 *)v10 + 16) == a2) {
                return;
              }
            }
            else if (((unint64_t)v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            unint64_t v10 = (uint64_t **)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = (unint64_t)v10[1];
          if (v11 == a2)
          {
            if (*((unsigned __int8 *)v10 + 16) == a2) {
              return;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (uint64_t **)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  id v13 = operator new(0x18uLL);
  *id v13 = 0;
  v13[1] = v6;
  *((unsigned char *)v13 + 16) = a3;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_34;
    }
    if (prime < v7)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (prime <= v20) {
        size_t prime = v20;
      }
      if (prime < v7) {
LABEL_34:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v23 = *(void *)a1;
  unint64_t v24 = *(void **)(*(void *)a1 + 8 * v3);
  if (v24)
  {
    *id v13 = *v24;
LABEL_58:
    *unint64_t v24 = v13;
    goto LABEL_59;
  }
  *id v13 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v13;
  *(void *)(v23 + 8 * v3) = a1 + 16;
  if (*v13)
  {
    unint64_t v25 = *(void *)(*v13 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v25 >= v7) {
        v25 %= v7;
      }
    }
    else
    {
      v25 &= v7 - 1;
    }
    unint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
}

void sub_1A204F244(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#4},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#4}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::operator()(uint64_t a1, const md::OverlayTileData **a2)
{
  return md::OverlayContainer::_isOverlayTileInCurrentScene(*(void *)(*(void *)(a1 + 8) + 336), *a2) ^ 1;
}

uint64_t md::OverlayContainer::_isOverlayTileInCurrentScene(uint64_t this, const md::OverlayTileData *a2)
{
  if (this)
  {
    uint64_t v2 = *(uint64_t **)(this + 120);
    if (v2)
    {
      int v4 = *((unsigned __int16 *)a2 + 12);
      uint64_t v5 = *v2;
      {
        qword_1EB3176C0 = 0;
        qword_1EB3176B8 = 0;
        md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet = (uint64_t)&qword_1EB3176B8;
        __cxa_atexit((void (*)(void *))std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100], &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet, &dword_1A1780000);
      }
      unint64_t v6 = *(unsigned __int16 **)(v5 + 48);
      unint64_t v7 = *(unsigned __int16 **)(v5 + 56);
      uint8x8_t v8 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
      if (v6 != v7)
      {
        char v9 = v6;
        while (*v9 != v4)
        {
          v9 += 16;
          if (v9 == v7) {
            goto LABEL_15;
          }
        }
        if (v9 == v7)
        {
          uint8x8_t v8 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
        }
        else
        {
          while (*v6 != v4)
          {
            v6 += 16;
            if (v6 == v7)
            {
              unint64_t v6 = v7;
              break;
            }
          }
          uint8x8_t v8 = (uint64_t *)(v6 + 4);
        }
      }
LABEL_15:
      uint64_t v12 = (uint64_t *)*v8;
      unint64_t v10 = v8 + 1;
      unint64_t v11 = v12;
      if (v12 != v10)
      {
        do
        {
          float v14 = (const md::OverlayTileData *)v11[4];
          id v13 = (std::__shared_weak_count *)v11[5];
          if (v13
            && (atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed),
                !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
            if (v14 == a2) {
              return 1;
            }
          }
          else if (v14 == a2)
          {
            return 1;
          }
          float v15 = (uint64_t *)v11[1];
          if (v15)
          {
            do
            {
              BOOL v16 = v15;
              float v15 = (uint64_t *)*v15;
            }
            while (v15);
          }
          else
          {
            do
            {
              BOOL v16 = (uint64_t *)v11[2];
              BOOL v17 = *v16 == (void)v11;
              unint64_t v11 = v16;
            }
            while (!v17);
          }
          unint64_t v11 = v16;
        }
        while (v16 != v10);
      }
    }
    return 0;
  }
  return this;
}

uint64_t std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#4},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#4}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF52E0A0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#4},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#4}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF52E0A0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#4},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#4}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func()
{
}

uint64_t std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#3},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#3}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(*(void *)a2 + 169) | 0x200000000;
  v4[0] = *(unsigned int *)(*(void *)a2 + 176) | ((unint64_t)*(unsigned int *)(*(void *)a2 + 172) << 32);
  v4[1] = v2;
  return [*(id *)(a1 + 16) canPossiblyDrawKey:v4];
}

void std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#3},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#3}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::destroy_deallocate(uint64_t a1)
{
  *(void *)(a1 + 8) = &unk_1EF559F78;

  operator delete((void *)a1);
}

void std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#3},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#3}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::destroy(uint64_t a1)
{
  *(void *)(a1 + 8) = &unk_1EF559F78;
}

void std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#3},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#3}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52E058;
  a2[1] = &unk_1EF559F78;
  a2[2] = 0;
  id v3 = *(id *)(a1 + 16);
  int v4 = (void *)a2[2];
  a2[2] = v3;
}

void *std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#3},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#3}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = &unk_1EF52E058;
  v2[1] = &unk_1EF559F78;
  v2[2] = 0;
  id v3 = *(id *)(a1 + 16);
  int v4 = (void *)v2[2];
  v2[2] = v3;

  return v2;
}

void std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#3},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#3}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF52E058;
  *(void *)(a1 + 8) = &unk_1EF559F78;

  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#3},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#3}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF52E058;
  *(void *)(a1 + 8) = &unk_1EF559F78;

  return a1;
}

uint64_t std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::operator()(uint64_t a1, const md::OverlayTileData **a2)
{
  return md::OverlayContainer::_isOverlayTileInCurrentScene(*(void *)(*(void *)(a1 + 8) + 336), *a2) ^ 1;
}

uint64_t std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57E688;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57E688;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func()
{
}

uint64_t std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(*(void *)a2 + 169) | 0x200000000;
  v4[0] = *(unsigned int *)(*(void *)a2 + 176) | ((unint64_t)*(unsigned int *)(*(void *)a2 + 172) << 32);
  v4[1] = v2;
  return [*(id *)(a1 + 16) canPossiblyDrawKey:v4];
}

void std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::destroy_deallocate(uint64_t a1)
{
  *(void *)(a1 + 8) = &unk_1EF559F78;

  operator delete((void *)a1);
}

void std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::destroy(uint64_t a1)
{
  *(void *)(a1 + 8) = &unk_1EF559F78;
}

void std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57E6D0;
  a2[1] = &unk_1EF559F78;
  a2[2] = 0;
  id v3 = *(id *)(a1 + 16);
  int v4 = (void *)a2[2];
  a2[2] = v3;
}

void *std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = &unk_1EF57E6D0;
  v2[1] = &unk_1EF559F78;
  v2[2] = 0;
  id v3 = *(id *)(a1 + 16);
  int v4 = (void *)v2[2];
  v2[2] = v3;

  return v2;
}

void std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF57E6D0;
  *(void *)(a1 + 8) = &unk_1EF559F78;

  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1},std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF57E6D0;
  *(void *)(a1 + 8) = &unk_1EF559F78;

  return a1;
}

void std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0,std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0>,void ()(void)>::destroy_deallocate(id *a1)
{
  operator delete(a1);
}

void std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0,std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
}

__n128 std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0,std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void **)(a1 + 16);
  *(void *)a2 = &unk_1EF572300;
  *(void *)(a2 + 8) = v4;
  *(void *)(a2 + 16) = v5;
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(a2 + 24) = result;
  return result;
}

char *std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0,std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *(void *)uint64_t v2 = &unk_1EF572300;
  *((void *)v2 + 1) = v3;
  *((void *)v2 + 2) = v4;
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  return v2;
}

void std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0,std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0,std::allocator<md::OverlayContainer::_insertOverlay(VKOverlay *,std::__wrap_iter<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  return a1;
}

uint64_t std::__split_buffer<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void (***)(void))(i - 24);
    *(void *)(a1 + 16) = i - 24;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559F78;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559F78;

  return a1;
}

void std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__erase_unique<unsigned int>(void *a1, unsigned int a2)
{
  unint64_t v2 = a1[1];
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v2 <= a2) {
        unint64_t v4 = a2 % v2;
      }
    }
    else
    {
      unint64_t v4 = (v2 - 1) & a2;
    }
    uint64_t v5 = *(uint64_t ***)(*a1 + 8 * v4);
    if (v5)
    {
      unint64_t v6 = *v5;
      if (*v5)
      {
        if (v3.u32[0] < 2uLL)
        {
          unint64_t v7 = v2 - 1;
          while (1)
          {
            uint64_t v9 = v6[1];
            if (v9 == a2)
            {
              if (*((_DWORD *)v6 + 4) == a2) {
                goto LABEL_22;
              }
            }
            else if ((v9 & v7) != v4)
            {
              return;
            }
            unint64_t v6 = (uint64_t *)*v6;
            if (!v6) {
              return;
            }
          }
        }
        do
        {
          unint64_t v8 = v6[1];
          if (v8 == a2)
          {
            if (*((_DWORD *)v6 + 4) == a2)
            {
LABEL_22:
              std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)&__p, a1, v6);
              if (__p) {
                operator delete(__p);
              }
              return;
            }
          }
          else
          {
            if (v8 >= v2) {
              v8 %= v2;
            }
            if (v8 != v4) {
              return;
            }
          }
          unint64_t v6 = (uint64_t *)*v6;
        }
        while (v6);
      }
    }
  }
}

uint64_t std::__function::__func<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0,std::allocator<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  unint64_t v28 = (uint64_t (**)(void **))&unk_1EF57E640;
  int v29 = v3;
  int v30 = (void **)&v28;
  v26[0] = &unk_1EF57E5F8;
  v26[1] = v2;
  id v27 = v26;
  int v5 = *(unsigned __int8 *)(a1 + 32);
  *(_OWORD *)unint64_t v18 = 0u;
  *(_OWORD *)__p = 0u;
  int v20 = 1065353216;
  std::__hash_table<md::OverlayTileDataType,std::hash<md::OverlayTileDataType>,std::equal_to<md::OverlayTileDataType>,std::allocator<md::OverlayTileDataType>>::__emplace_unique_key_args<md::OverlayTileDataType,md::OverlayTileDataType const&>((uint64_t)v18, *(unsigned char *)(a1 + 33), *(unsigned char *)(a1 + 33));
  md::OverlayLayerDataSource::conditionalInvalidate(v4, &v28, v26, v5 != 0, (uint64_t)v18);
  unint64_t v6 = __p[0];
  if (__p[0])
  {
    do
    {
      unint64_t v7 = (void *)*v6;
      operator delete(v6);
      unint64_t v6 = v7;
    }
    while (v7);
  }
  unint64_t v8 = v18[0];
  v18[0] = 0;
  if (v8) {
    operator delete(v8);
  }
  if (v27 == v26)
  {
    (*(void (**)(void *))(v26[0] + 32))(v26);
  }
  else if (v27)
  {
    (*(void (**)(void *))(*v27 + 40))(v27);
  }
  uint64_t result = (uint64_t)v30;
  if (v30 == (void **)&v28)
  {
    uint64_t result = v28[4]((void **)&v28);
  }
  else if (v30)
  {
    uint64_t result = (*((uint64_t (**)(void **))*v30 + 5))(v30);
  }
  if (*(void *)(a1 + 40) == 1)
  {
    uint64_t v10 = *(void *)(v2 + 32);
    uint64_t v23 = (uint64_t (**)(void **))&unk_1EF57E640;
    int v24 = v3;
    unint64_t v25 = (void **)&v23;
    v21[0] = &unk_1EF57E5F8;
    v21[1] = v2;
    uint64_t v22 = v21;
    int v11 = *(unsigned __int8 *)(a1 + 32);
    *(_OWORD *)float v15 = 0u;
    *(_OWORD *)BOOL v16 = 0u;
    int v17 = 1065353216;
    std::__hash_table<md::OverlayTileDataType,std::hash<md::OverlayTileDataType>,std::equal_to<md::OverlayTileDataType>,std::allocator<md::OverlayTileDataType>>::__emplace_unique_key_args<md::OverlayTileDataType,md::OverlayTileDataType const&>((uint64_t)v15, *(unsigned char *)(a1 + 33), *(unsigned char *)(a1 + 33));
    md::OverlayLayerDataSource::conditionalInvalidate(v10, &v23, v21, v11 != 0, (uint64_t)v15);
    uint64_t v12 = v16[0];
    if (v16[0])
    {
      do
      {
        id v13 = (void *)*v12;
        operator delete(v12);
        uint64_t v12 = v13;
      }
      while (v13);
    }
    float v14 = v15[0];
    v15[0] = 0;
    if (v14) {
      operator delete(v14);
    }
    if (v22 == v21)
    {
      (*(void (**)(void *))(v21[0] + 32))(v21);
    }
    else if (v22)
    {
      (*(void (**)(void *))(*v22 + 40))(v22);
    }
    uint64_t result = (uint64_t)v25;
    if (v25 == (void **)&v23)
    {
      return v23[4]((void **)&v23);
    }
    else if (v25)
    {
      return (*((uint64_t (**)(void **))*v25 + 5))(v25);
    }
  }
  return result;
}

void sub_1A205020C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t *a27)
{
  unint64_t v28 = __p;
  if (__p)
  {
    do
    {
      int v29 = (void *)*v28;
      operator delete(v28);
      unint64_t v28 = v29;
    }
    while (v29);
  }
  if (a9) {
    operator delete(a9);
  }
  if (a23 == &a20)
  {
    (*(void (**)(uint64_t *))(a20 + 32))(&a20);
  }
  else if (a23)
  {
    (*(void (**)(uint64_t *))(*a23 + 40))(a23);
  }
  if (a27 == &a24)
  {
    (*(void (**)(uint64_t *))(a24 + 32))(&a24);
    _Unwind_Resume(a1);
  }
  if (a27) {
    (*(void (**)(uint64_t *))(*a27 + 40))(a27);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2},std::allocator<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::operator()(uint64_t a1, const md::OverlayTileData **a2)
{
  return md::OverlayContainer::_isOverlayTileInCurrentScene(*(void *)(*(void *)(a1 + 8) + 336), *a2) ^ 1;
}

uint64_t std::__function::__func<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2},std::allocator<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57E5F8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2},std::allocator<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57E5F8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2},std::allocator<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#2}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func()
{
}

BOOL std::__function::__func<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1},std::allocator<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v2 = *a2 + 752;
  uint64_t v3 = (void *)v2;
  do
  {
    uint64_t v3 = (void *)v3[1];
    if (v3 == (void *)v2) {
      break;
    }
    int v5 = (_DWORD *)v3[16];
    uint64_t v4 = (_DWORD *)v3[17];
    if (v5 != v4)
    {
      while (*v5 != *(_DWORD *)(a1 + 8))
      {
        if (++v5 == v4)
        {
          int v5 = (_DWORD *)v3[17];
          break;
        }
      }
    }
  }
  while (v5 == v4);
  return v3 != (void *)v2;
}

uint64_t std::__function::__func<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1},std::allocator<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(result + 8);
  *(void *)a2 = &unk_1EF57E640;
  *(_DWORD *)(a2 + 8) = v2;
  return result;
}

_DWORD *std::__function::__func<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1},std::allocator<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  int v3 = *(_DWORD *)(a1 + 8);
  *(void *)uint64_t result = &unk_1EF57E640;
  result[2] = v3;
  return result;
}

void std::__function::__func<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1},std::allocator<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0::operator() const(void)::{lambda(std::shared_ptr<md::OverlayTileData> const&)#1}>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func()
{
}

__n128 std::__function::__func<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0,std::allocator<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5722B8;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0,std::allocator<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  int v2 = (char *)operator new(0x30uLL);
  *(void *)int v2 = &unk_1EF5722B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0,std::allocator<md::OverlayContainer::removeOverlay(VKOverlay *)::$_0>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::OverlayContainer::invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0,std::allocator<md::OverlayContainer::invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  int v2 = *(unsigned __int8 *)(a1 + 56);
  if (*(unsigned char *)(a1 + 56)) {
    char v39 = *(unsigned char *)(a1 + 57);
  }
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(unsigned __int8 *)(a1 + 58);
  id v5 = *(id *)(a1 + 16);
  unint64_t v6 = [v5 rasterTileProvider];
  unint64_t v7 = v6;
  unint64_t v8 = (long long *)(a1 + 24);
  if (v6)
  {
    uint64_t v9 = *(void *)(*(void *)(*(void *)(v3 + 40) + 24) + 56);
    uint64_t v10 = *(void *)(v9 + 56);
    uint64_t v11 = *(void *)(v9 + 64);
    if (v10 != v11)
    {
      while (*(_WORD *)v10 != 35)
      {
        v10 += 24;
        if (v10 == v11) {
          goto LABEL_19;
        }
      }
    }
    if (v10 != v11)
    {
      id v13 = *(void **)(v10 + 8);
      uint64_t v12 = *(std::__shared_weak_count **)(v10 + 16);
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v13)
      {
        LODWORD(v45[0]) = [v6 providerID];
        v54[0] = &unk_1EF572390;
        v54[1] = v45;
        v54[2] = v8;
        v55 = v54;
        gdc::ResourceStore::clearResources(v13, (uint64_t)v54);
        if (v55 == v54)
        {
          (*(void (**)(void *))(v54[0] + 32))(v54);
          if (!v12) {
            goto LABEL_19;
          }
LABEL_16:
          if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
            std::__shared_weak_count::__release_weak(v12);
          }
          goto LABEL_19;
        }
        if (v55) {
          (*(void (**)(void *))(*v55 + 40))(v55);
        }
      }
      if (!v12) {
        goto LABEL_19;
      }
      goto LABEL_16;
    }
  }
LABEL_19:
  unint64_t v14 = [v5 level];
  unsigned int v15 = [v5 areResourcesRequired];
  if (v14 > 1) {
    goto LABEL_69;
  }
  uint64_t v16 = *(void *)(v3 + 16 * v14 + 8 * v15);
  if (!v16) {
    goto LABEL_69;
  }
  int v17 = [v5 rasterTileProvider];
  if (v17)
  {
    char v18 = 0;
  }
  else
  {
    id v19 = [v5 customTileProvider];
    char v18 = v19 == 0;
  }
  id v20 = v5;
  if ([v20 canProvideVectorData])
  {
    char v21 = 2;
  }
  else
  {
    uint64_t v22 = [v20 rasterTileProvider];
    BOOL v23 = v22 == 0;

    if (v23)
    {
      int v24 = [v20 customTileProvider];
      BOOL v25 = v24 == 0;

      if (v25) {
        char v21 = 1;
      }
      else {
        char v21 = 4;
      }
    }
    else
    {
      char v21 = 3;
    }
  }

  if (v4)
  {
    char v48 = 0;
    if (v2)
    {
      char v49 = v39;
      char v48 = 1;
    }
    v52[0] = &unk_1EF5723D8;
    v52[1] = v3;
    v53 = v52;
    *(_OWORD *)v45 = 0u;
    *(_OWORD *)__p = 0u;
    int v47 = 1065353216;
    std::__hash_table<md::OverlayTileDataType,std::hash<md::OverlayTileDataType>,std::equal_to<md::OverlayTileDataType>,std::allocator<md::OverlayTileDataType>>::__emplace_unique_key_args<md::OverlayTileDataType,md::OverlayTileDataType const&>((uint64_t)v45, v21, v21);
    md::OverlayLayerDataSource::invalidateRect(v16, v8, &v48, v52, v18, (uint64_t)v45);
    unint64_t v26 = __p[0];
    if (__p[0])
    {
      do
      {
        id v27 = (void *)*v26;
        operator delete(v26);
        unint64_t v26 = v27;
      }
      while (v27);
    }
    unint64_t v28 = v45[0];
    v45[0] = 0;
    if (v28) {
      operator delete(v28);
    }
    if (v53 == v52)
    {
      (*(void (**)(void *))(v52[0] + 32))(v52);
    }
    else if (v53)
    {
      (*(void (**)(void))(*v53 + 40))();
    }
    if ([v20 level] == 1)
    {
      uint64_t v32 = *(void *)(v3 + 32);
      char v43 = 0;
      if (v2)
      {
        char v44 = v39;
        char v43 = 1;
      }
      v50[0] = &unk_1EF572420;
      v50[1] = v3;
      v51 = v50;
      *(_OWORD *)id v40 = 0u;
      *(_OWORD *)uint64_t v41 = 0u;
      int v42 = 1065353216;
      std::__hash_table<md::OverlayTileDataType,std::hash<md::OverlayTileDataType>,std::equal_to<md::OverlayTileDataType>,std::allocator<md::OverlayTileDataType>>::__emplace_unique_key_args<md::OverlayTileDataType,md::OverlayTileDataType const&>((uint64_t)v40, v21, v21);
      md::OverlayLayerDataSource::invalidateRect(v32, v8, &v43, v50, v18, (uint64_t)v40);
      uint64_t v33 = v41[0];
      if (v41[0])
      {
        do
        {
          id v34 = (void *)*v33;
          operator delete(v33);
          uint64_t v33 = v34;
        }
        while (v34);
      }
LABEL_63:
      uint64_t v38 = v40[0];
      v40[0] = 0;
      if (v38) {
        operator delete(v38);
      }
      if (v51 == v50)
      {
        (*(void (**)(void *))(v50[0] + 32))(v50);
      }
      else if (v51)
      {
        (*(void (**)(void))(*v51 + 40))();
      }
    }
  }
  else
  {
    char v48 = 0;
    if (v2)
    {
      char v49 = v39;
      char v48 = 1;
    }
    v52[0] = &unk_1EF51DD98;
    v53 = v52;
    *(_OWORD *)v45 = 0u;
    *(_OWORD *)__p = 0u;
    int v47 = 1065353216;
    std::__hash_table<md::OverlayTileDataType,std::hash<md::OverlayTileDataType>,std::equal_to<md::OverlayTileDataType>,std::allocator<md::OverlayTileDataType>>::__emplace_unique_key_args<md::OverlayTileDataType,md::OverlayTileDataType const&>((uint64_t)v45, v21, v21);
    md::OverlayLayerDataSource::invalidateRect(v16, v8, &v48, v52, v18, (uint64_t)v45);
    int v29 = __p[0];
    if (__p[0])
    {
      do
      {
        int v30 = (void *)*v29;
        operator delete(v29);
        int v29 = v30;
      }
      while (v30);
    }
    uint64_t v31 = v45[0];
    v45[0] = 0;
    if (v31) {
      operator delete(v31);
    }
    if (v53 == v52)
    {
      (*(void (**)(void *))(v52[0] + 32))(v52);
    }
    else if (v53)
    {
      (*(void (**)(void))(*v53 + 40))();
    }
    if ([v20 level] == 1)
    {
      uint64_t v35 = *(void *)(v3 + 32);
      char v43 = 0;
      if (v2)
      {
        char v44 = v39;
        char v43 = 1;
      }
      v50[0] = &unk_1EF51DDE0;
      v51 = v50;
      *(_OWORD *)id v40 = 0u;
      *(_OWORD *)uint64_t v41 = 0u;
      int v42 = 1065353216;
      std::__hash_table<md::OverlayTileDataType,std::hash<md::OverlayTileDataType>,std::equal_to<md::OverlayTileDataType>,std::allocator<md::OverlayTileDataType>>::__emplace_unique_key_args<md::OverlayTileDataType,md::OverlayTileDataType const&>((uint64_t)v40, v21, v21);
      md::OverlayLayerDataSource::invalidateRect(v35, v8, &v43, v50, v18, (uint64_t)v40);
      uint64_t v36 = v41[0];
      if (v41[0])
      {
        do
        {
          long long v37 = (void *)*v36;
          operator delete(v36);
          uint64_t v36 = v37;
        }
        while (v37);
      }
      goto LABEL_63;
    }
  }
LABEL_69:
}

void sub_1A2050C6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  uint64_t v33 = __p;
  if (__p)
  {
    do
    {
      id v34 = (void *)*v33;
      operator delete(v33);
      uint64_t v33 = v34;
    }
    while (v34);
  }
  if (a11) {
    operator delete(a11);
  }
  if (a26 == &a23)
  {
    (*(void (**)(uint64_t *))(a23 + 32))(&a23);
  }
  else if (a26)
  {
    (*(void (**)(void))(*a26 + 40))();
  }

  _Unwind_Resume(a1);
}

void *std::function<BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~function(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_4,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_4>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::operator()()
{
  return 0;
}

void std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_4,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_4>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF51DDE0;
}

void *std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_4,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_4>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF51DDE0;
  return result;
}

void std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_4,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_4>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func()
{
}

uint64_t std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_3,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_3>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::operator()()
{
  return 0;
}

void std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_3,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_3>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF51DD98;
}

void *std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_3,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_3>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF51DD98;
  return result;
}

void std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_3,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_3>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func()
{
}

uint64_t std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_2,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_2>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::operator()(uint64_t a1, const md::OverlayTileData **a2)
{
  return md::OverlayContainer::_isOverlayTileInCurrentScene(*(void *)(*(void *)(a1 + 8) + 336), *a2) ^ 1;
}

uint64_t std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_2,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_2>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572420;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_2,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_2>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF572420;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_2,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_2>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func()
{
}

uint64_t std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_1,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_1>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::operator()(uint64_t a1, const md::OverlayTileData **a2)
{
  return md::OverlayContainer::_isOverlayTileInCurrentScene(*(void *)(*(void *)(a1 + 8) + 336), *a2) ^ 1;
}

uint64_t std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_1,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_1>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5723D8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_1,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_1>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5723D8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_1,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_1>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func()
{
}

uint64_t std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0>,BOOL ()(gdc::ResourceKey const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(int32x2_t **)(a2 + 8);
  if (v2[1].i32[1] != **(_DWORD **)(a1 + 8)) {
    return 0;
  }
  __int32 v4 = v2[1].i32[0];
  unsigned int v5 = v2[2].u32[0];
  v17[0] = -1;
  v17[1] = v4;
  int32x2_t v18 = vrev64_s32(*v2);
  unint64_t v14 = 0;
  unsigned int v15 = 0;
  uint64_t v16 = 0;
  md::TileAdjustmentHelpers::adjustTileForSize(v5, 0x200u, (uint64_t)v17, &v14);
  if (v14 == v15)
  {
LABEL_11:
    uint64_t v12 = 0;
  }
  else
  {
    unint64_t v6 = *(double **)(a1 + 16);
    unint64_t v7 = v14;
    while (1)
    {
      int v8 = 1 << v7[1];
      double v9 = 1.0 / (double)v8;
      double v10 = v9 * (double)*((int *)v7 + 2);
      if (v10 + v9 > *v6 && v10 < v6[2])
      {
        double v11 = v9 * (double)(v8 + ~*((_DWORD *)v7 + 1));
        if (v11 + v9 > v6[1] && v11 < v6[3]) {
          break;
        }
      }
      v7 += 24;
      if (v7 == v15) {
        goto LABEL_11;
      }
    }
    uint64_t v12 = 1;
  }
  if (v14) {
    operator delete(v14);
  }
  return v12;
}

void sub_1A20512CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0>,BOOL ()(gdc::ResourceKey const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF572390;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0>,BOOL ()(gdc::ResourceKey const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF572390;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0,std::allocator<md::OverlayContainer::_invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0>,BOOL ()(gdc::ResourceKey const&)>::~__func()
{
}

void std::__function::__func<md::OverlayContainer::invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0,std::allocator<md::OverlayContainer::invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0>,void ()(void)>::destroy_deallocate(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56)) {
    *(unsigned char *)(a1 + 56) = 0;
  }

  operator delete((void *)a1);
}

void std::__function::__func<md::OverlayContainer::invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0,std::allocator<md::OverlayContainer::invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56)) {
    *(unsigned char *)(a1 + 56) = 0;
  }
}

id std::__function::__func<md::OverlayContainer::invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0,std::allocator<md::OverlayContainer::invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unsigned int v5 = *(void **)(a1 + 16);
  *(void *)a2 = &unk_1EF572348;
  *(void *)(a2 + 8) = v4;
  id result = v5;
  *(void *)(a2 + 16) = result;
  long long v7 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = v7;
  *(unsigned char *)(a2 + 56) = 0;
  if (*(unsigned char *)(a1 + 56))
  {
    *(unsigned char *)(a2 + 57) = *(unsigned char *)(a1 + 57);
    *(unsigned char *)(a2 + 56) = 1;
  }
  *(unsigned char *)(a2 + 58) = *(unsigned char *)(a1 + 58);
  return result;
}

char *std::__function::__func<md::OverlayContainer::invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0,std::allocator<md::OverlayContainer::invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *(void *)uint64_t v2 = &unk_1EF572348;
  *((void *)v2 + 1) = v3;
  *((void *)v2 + 2) = v4;
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  v2[56] = 0;
  if (*(unsigned char *)(a1 + 56))
  {
    v2[57] = *(unsigned char *)(a1 + 57);
    v2[56] = 1;
  }
  v2[58] = *(unsigned char *)(a1 + 58);
  return v2;
}

void std::__function::__func<md::OverlayContainer::invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0,std::allocator<md::OverlayContainer::invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF572348;
  if (*(unsigned char *)(a1 + 56)) {
    *(unsigned char *)(a1 + 56) = 0;
  }

  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::OverlayContainer::invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0,std::allocator<md::OverlayContainer::invalidateRect(VKOverlay *,gm::Box<double,2> const&,geo::optional<unsigned char>,BOOL)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF572348;
  if (*(unsigned char *)(a1 + 56)) {
    *(unsigned char *)(a1 + 56) = 0;
  }

  return a1;
}

void md::OverlayContainer::invalidate(md::OverlayContainer *this, VKOverlay *a2, __int16 a3, int a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v7 = a2;
  double v11 = 0;
  int v8 = operator new(0x20uLL);
  *int v8 = &unk_1EF572198;
  v8[1] = this;
  v8[2] = v7;
  if (a4) {
    __int16 v9 = 256;
  }
  else {
    __int16 v9 = 0;
  }
  *((_WORD *)v8 + 12) = v9 | a3;
  double v11 = v8;
  md::OverlayContainer::queueCommand((uint64_t)this, 3, v10);
  if (v11 == v10)
  {
    (*(void (**)(void *))(v10[0] + 32))(v10);
  }
  else if (v11)
  {
    (*(void (**)(void))(*v11 + 40))();
  }
}

void sub_1A20516D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function((uint64_t *)va);

  _Unwind_Resume(a1);
}

void std::__function::__func<md::OverlayContainer::invalidate(VKOverlay *,BOOL,BOOL)::$_0,std::allocator<md::OverlayContainer::invalidate(VKOverlay *,BOOL,BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 8);
  int v2 = *(unsigned __int8 *)(a1 + 24);
  int v3 = *(unsigned __int8 *)(a1 + 25);
  id v4 = *(id *)(a1 + 16);
  unsigned int v5 = [v4 rasterTileProvider];
  unint64_t v6 = v5;
  if (v5)
  {
    uint64_t v7 = *(void *)(*(void *)(*(void *)(v1 + 40) + 24) + 56);
    uint64_t v8 = *(void *)(v7 + 56);
    uint64_t v9 = *(void *)(v7 + 64);
    if (v8 != v9)
    {
      while (*(_WORD *)v8 != 35)
      {
        v8 += 24;
        if (v8 == v9) {
          goto LABEL_17;
        }
      }
    }
    if (v8 != v9)
    {
      double v10 = *(void **)(v8 + 8);
      double v11 = *(std::__shared_weak_count **)(v8 + 16);
      if (v11) {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v10)
      {
        LODWORD(v44[0]) = [v5 providerID];
        v51[0] = &unk_1EF5721E0;
        v51[1] = v44;
        v52 = v51;
        gdc::ResourceStore::clearResources(v10, (uint64_t)v51);
        if (v52 == v51)
        {
          (*(void (**)(void *))(v51[0] + 32))(v51);
          if (!v11) {
            goto LABEL_17;
          }
          goto LABEL_14;
        }
        if (v52) {
          (*(void (**)(void *))(*v52 + 40))(v52);
        }
      }
      if (!v11) {
        goto LABEL_17;
      }
LABEL_14:
      if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
LABEL_17:
  if ([v4 areResourcesRequired])
  {
    unint64_t v12 = [v4 level];
    if (v12 > 1) {
      goto LABEL_69;
    }
    uint64_t v13 = *(void *)(v1 + 16 * v12 + 8);
    if (!v13) {
      goto LABEL_69;
    }
  }
  else
  {
    unint64_t v14 = [v4 level];
    if (v14 > 1) {
      goto LABEL_69;
    }
    uint64_t v13 = *(void *)(v1 + 16 * v14);
    if (!v13) {
      goto LABEL_69;
    }
  }
  unsigned int v15 = [v4 rasterTileProvider];
  if (v15)
  {
    char v16 = 0;
  }
  else
  {
    int v17 = [v4 customTileProvider];
    char v16 = v17 == 0;
  }
  *(_OWORD *)char v44 = 0u;
  *(_OWORD *)v45 = 0u;
  int v46 = 1065353216;
  if (v3)
  {
    LOWORD(v42[0]) = 258;
    std::__hash_table<md::OverlayTileDataType,std::hash<md::OverlayTileDataType>,std::equal_to<md::OverlayTileDataType>,std::allocator<md::OverlayTileDataType>>::__assign_unique<md::OverlayTileDataType const*>((uint64_t)v44, (unsigned __int8 *)v42, (unsigned __int8 *)v42 + 2);
  }
  else
  {
    id v18 = v4;
    if ([v18 canProvideVectorData])
    {
      char v19 = 2;
    }
    else
    {
      id v20 = [v18 rasterTileProvider];
      BOOL v21 = v20 == 0;

      if (v21)
      {
        uint64_t v22 = [v18 customTileProvider];
        BOOL v23 = v22 == 0;

        if (v23) {
          char v19 = 1;
        }
        else {
          char v19 = 4;
        }
      }
      else
      {
        char v19 = 3;
      }
    }

    LOBYTE(v42[0]) = v19;
    std::__hash_table<md::OverlayTileDataType,std::hash<md::OverlayTileDataType>,std::equal_to<md::OverlayTileDataType>,std::allocator<md::OverlayTileDataType>>::__assign_unique<md::OverlayTileDataType const*>((uint64_t)v44, (unsigned __int8 *)v42, (unsigned __int8 *)v42 + 1);
  }
  if (v2)
  {
    v49[0] = &unk_1EF572228;
    v49[1] = v1;
    v50 = v49;
    std::unordered_set<md::OverlayTileDataType>::unordered_set((uint64_t)v42, (uint64_t)v44);
    md::OverlayLayerDataSource::invalidate(v13, v49, v16, (uint64_t)v42);
    int v24 = __p;
    if (__p)
    {
      do
      {
        BOOL v25 = (void *)*v24;
        operator delete(v24);
        int v24 = v25;
      }
      while (v25);
    }
    unint64_t v26 = v42[0];
    v42[0] = 0;
    if (v26) {
      operator delete(v26);
    }
    if (v50 == v49)
    {
      (*(void (**)(void *))(v49[0] + 32))(v49);
    }
    else if (v50)
    {
      (*(void (**)(void))(*v50 + 40))();
    }
    if ([v4 level] != 1) {
      goto LABEL_65;
    }
    uint64_t v30 = *(void *)(v1 + 32);
    v47[0] = &unk_1EF572270;
    v47[1] = v1;
    char v48 = v47;
    std::unordered_set<md::OverlayTileDataType>::unordered_set((uint64_t)v40, (uint64_t)v44);
    md::OverlayLayerDataSource::invalidate(v30, v47, v16, (uint64_t)v40);
    uint64_t v31 = v41;
    if (v41)
    {
      do
      {
        uint64_t v32 = (void *)*v31;
        operator delete(v31);
        uint64_t v31 = v32;
      }
      while (v32);
    }
  }
  else
  {
    v49[0] = &unk_1EF51DD08;
    v50 = v49;
    std::unordered_set<md::OverlayTileDataType>::unordered_set((uint64_t)v42, (uint64_t)v44);
    md::OverlayLayerDataSource::invalidate(v13, v49, v16, (uint64_t)v42);
    id v27 = __p;
    if (__p)
    {
      do
      {
        unint64_t v28 = (void *)*v27;
        operator delete(v27);
        id v27 = v28;
      }
      while (v28);
    }
    int v29 = v42[0];
    v42[0] = 0;
    if (v29) {
      operator delete(v29);
    }
    if (v50 == v49)
    {
      (*(void (**)(void *))(v49[0] + 32))(v49);
    }
    else if (v50)
    {
      (*(void (**)(void))(*v50 + 40))();
    }
    if ([v4 level] != 1) {
      goto LABEL_65;
    }
    uint64_t v33 = *(void *)(v1 + 32);
    v47[0] = &unk_1EF51DD50;
    char v48 = v47;
    std::unordered_set<md::OverlayTileDataType>::unordered_set((uint64_t)v40, (uint64_t)v44);
    md::OverlayLayerDataSource::invalidate(v33, v47, v16, (uint64_t)v40);
    id v34 = v41;
    if (v41)
    {
      do
      {
        uint64_t v35 = (void *)*v34;
        operator delete(v34);
        id v34 = v35;
      }
      while (v35);
    }
  }
  uint64_t v36 = v40[0];
  v40[0] = 0;
  if (v36) {
    operator delete(v36);
  }
  if (v48 == v47)
  {
    (*(void (**)(void *))(v47[0] + 32))(v47);
    long long v37 = v45[0];
    if (!v45[0]) {
      goto LABEL_67;
    }
    goto LABEL_66;
  }
  if (v48) {
    (*(void (**)(void *))(*v48 + 40))(v48);
  }
LABEL_65:
  long long v37 = v45[0];
  if (!v45[0]) {
    goto LABEL_67;
  }
  do
  {
LABEL_66:
    uint64_t v38 = (void *)*v37;
    operator delete(v37);
    long long v37 = v38;
  }
  while (v38);
LABEL_67:
  char v39 = v44[0];
  v44[0] = 0;
  if (v39) {
    operator delete(v39);
  }
LABEL_69:
}

void sub_1A2051D44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  id v34 = __p;
  if (__p)
  {
    do
    {
      uint64_t v35 = (void *)*v34;
      operator delete(v34);
      id v34 = v35;
    }
    while (v35);
  }
  if (a9) {
    operator delete(a9);
  }
  if (a27 == &a24)
  {
    (*(void (**)(uint64_t *))(a24 + 32))(&a24);
  }
  else if (a27)
  {
    (*(void (**)(void))(*a27 + 40))();
  }
  uint64_t v36 = a21;
  if (a21)
  {
    do
    {
      long long v37 = (void *)*v36;
      operator delete(v36);
      uint64_t v36 = v37;
    }
    while (v37);
  }
  if (a19) {
    operator delete(a19);
  }

  _Unwind_Resume(a1);
}

void std::__hash_table<md::OverlayTileDataType,std::hash<md::OverlayTileDataType>,std::equal_to<md::OverlayTileDataType>,std::allocator<md::OverlayTileDataType>>::__assign_unique<md::OverlayTileDataType const*>(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  id v4 = a2;
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
      *(void *)(*(void *)a1 + 8 * i) = 0;
    uint64_t v8 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    if (v8) {
      BOOL v9 = a2 == a3;
    }
    else {
      BOOL v9 = 1;
    }
    if (!v9)
    {
      while (1)
      {
        unint64_t v11 = *v4;
        *((unsigned char *)v8 + 16) = v11;
        double v10 = (void *)*v8;
        v8[1] = v11;
        unint64_t v12 = *(void *)(a1 + 8);
        if (v12)
        {
          uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
          v13.i16[0] = vaddlv_u8(v13);
          if (v13.u32[0] > 1uLL)
          {
            unint64_t v14 = v11;
            if (v12 <= v11) {
              unint64_t v14 = v11 % v12;
            }
          }
          else
          {
            unint64_t v14 = (v12 - 1) & v11;
          }
          unsigned int v15 = *(uint64_t ****)(*(void *)a1 + 8 * v14);
          if (v15)
          {
            char v16 = *v15;
            if (v16)
            {
              if (v13.u32[0] < 2uLL)
              {
                while (1)
                {
                  id v18 = v16[1];
                  if (v18 == (uint64_t *)v11)
                  {
                    if (*((unsigned __int8 *)v16 + 16) == v11) {
                      goto LABEL_67;
                    }
                  }
                  else if (((unint64_t)v18 & (v12 - 1)) != v14)
                  {
                    goto LABEL_30;
                  }
                  char v16 = (uint64_t **)*v16;
                  if (!v16) {
                    goto LABEL_30;
                  }
                }
              }
              do
              {
                unint64_t v17 = (unint64_t)v16[1];
                if (v17 == v11)
                {
                  if (*((unsigned __int8 *)v16 + 16) == v11) {
                    goto LABEL_67;
                  }
                }
                else
                {
                  if (v17 >= v12) {
                    v17 %= v12;
                  }
                  if (v17 != v14) {
                    break;
                  }
                }
                char v16 = (uint64_t **)*v16;
              }
              while (v16);
            }
          }
        }
LABEL_30:
        float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
        float v20 = *(float *)(a1 + 32);
        if (!v12 || (float)(v20 * (float)v12) < v19)
        {
          BOOL v21 = (v12 & (v12 - 1)) != 0;
          if (v12 < 3) {
            BOOL v21 = 1;
          }
          unint64_t v22 = v21 | (2 * v12);
          unint64_t v23 = vcvtps_u32_f32(v19 / v20);
          if (v22 <= v23) {
            size_t prime = v23;
          }
          else {
            size_t prime = v22;
          }
          if (prime == 1)
          {
            size_t prime = 2;
          }
          else if ((prime & (prime - 1)) != 0)
          {
            size_t prime = std::__next_prime(prime);
            unint64_t v12 = *(void *)(a1 + 8);
          }
          if (prime > v12) {
            goto LABEL_42;
          }
          if (prime < v12)
          {
            unint64_t v25 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
            if (v12 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
            {
              unint64_t v25 = std::__next_prime(v25);
            }
            else
            {
              uint64_t v27 = 1 << -(char)__clz(v25 - 1);
              if (v25 >= 2) {
                unint64_t v25 = v27;
              }
            }
            if (prime <= v25) {
              size_t prime = v25;
            }
            if (prime < v12) {
LABEL_42:
            }
              std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
          }
        }
        int8x8_t v28 = *(int8x8_t *)(a1 + 8);
        unint64_t v29 = v8[1];
        uint8x8_t v30 = (uint8x8_t)vcnt_s8(v28);
        v30.i16[0] = vaddlv_u8(v30);
        if (v30.u32[0] > 1uLL)
        {
          if (v29 >= *(void *)&v28) {
            v29 %= *(void *)&v28;
          }
        }
        else
        {
          v29 &= *(void *)&v28 - 1;
        }
        uint64_t v31 = *(void **)(*(void *)a1 + 8 * v29);
        if (v31)
        {
          *uint64_t v8 = *v31;
        }
        else
        {
          *uint64_t v8 = *(void *)(a1 + 16);
          *(void *)(a1 + 16) = v8;
          *(void *)(*(void *)a1 + 8 * v29) = a1 + 16;
          if (!*v8) {
            goto LABEL_66;
          }
          unint64_t v32 = *(void *)(*v8 + 8);
          if (v30.u32[0] > 1uLL)
          {
            if (v32 >= *(void *)&v28) {
              v32 %= *(void *)&v28;
            }
          }
          else
          {
            v32 &= *(void *)&v28 - 1;
          }
          uint64_t v31 = (void *)(*(void *)a1 + 8 * v32);
        }
        *uint64_t v31 = v8;
LABEL_66:
        ++*(void *)(a1 + 24);
LABEL_67:
        ++v4;
        if (v10)
        {
          uint64_t v8 = v10;
          if (v4 != a3) {
            continue;
          }
        }
        goto LABEL_69;
      }
    }
    double v10 = v8;
LABEL_69:
    if (v10)
    {
      do
      {
        uint64_t v33 = (void *)*v10;
        operator delete(v10);
        double v10 = v33;
      }
      while (v33);
    }
  }
  while (v4 != a3)
  {
    char v34 = *v4++;
    std::__hash_table<md::OverlayTileDataType,std::hash<md::OverlayTileDataType>,std::equal_to<md::OverlayTileDataType>,std::allocator<md::OverlayTileDataType>>::__emplace_unique_key_args<md::OverlayTileDataType,md::OverlayTileDataType const&>(a1, v34, v34);
  }
}

uint64_t std::unordered_set<md::OverlayTileDataType>::unordered_set(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  size_t prime = *(void *)(a2 + 8);
  if (prime == 1)
  {
    size_t prime = 2;
LABEL_17:
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    goto LABEL_18;
  }
  if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(*(void *)(a2 + 8));
    int8x8_t v5 = *(int8x8_t *)(a1 + 8);
    BOOL v6 = prime >= *(void *)&v5;
    if (prime > *(void *)&v5) {
      goto LABEL_17;
    }
  }
  else
  {
    int8x8_t v5 = 0;
    BOOL v6 = 1;
    if (prime) {
      goto LABEL_17;
    }
  }
  if (!v6)
  {
    unint64_t v7 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v5 < 3uLL || (uint8x8_t v8 = (uint8x8_t)vcnt_s8(v5), v8.i16[0] = vaddlv_u8(v8), v8.u32[0] > 1uLL))
    {
      unint64_t v7 = std::__next_prime(v7);
    }
    else
    {
      uint64_t v9 = 1 << -(char)__clz(v7 - 1);
      if (v7 >= 2) {
        unint64_t v7 = v9;
      }
    }
    if (prime <= v7) {
      size_t prime = v7;
    }
    if (prime < *(void *)&v5) {
      goto LABEL_17;
    }
  }
LABEL_18:
  for (uint64_t i = *(uint64_t **)(a2 + 16); i; uint64_t i = (uint64_t *)*i)
    std::__hash_table<md::OverlayTileDataType,std::hash<md::OverlayTileDataType>,std::equal_to<md::OverlayTileDataType>,std::allocator<md::OverlayTileDataType>>::__emplace_unique_key_args<md::OverlayTileDataType,md::OverlayTileDataType const&>(a1, *((unsigned char *)i + 16), *((unsigned char *)i + 16));
  return a1;
}

void sub_1A20523C8(_Unwind_Exception *a1)
{
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_4,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_4>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  int v2 = *(std::__shared_weak_count **)(a2 + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return 0;
}

void std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_4,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_4>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF51DD50;
}

void *std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_4,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_4>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone()
{
  id result = operator new(0x10uLL);
  void *result = &unk_1EF51DD50;
  return result;
}

void std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_4,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_4>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func()
{
}

uint64_t std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_3,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_3>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  int v2 = *(std::__shared_weak_count **)(a2 + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return 0;
}

void std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_3,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_3>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF51DD08;
}

void *std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_3,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_3>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone()
{
  id result = operator new(0x10uLL);
  void *result = &unk_1EF51DD08;
  return result;
}

void std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_3,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_3>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func()
{
}

uint64_t std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_2,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_2>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  int v3 = *(const md::OverlayTileData **)a2;
  id v4 = *(std::__shared_weak_count **)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int isOverlayTileInCurrentScene = md::OverlayContainer::_isOverlayTileInCurrentScene(*(void *)(*(void *)(a1 + 8) + 336), v3);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return isOverlayTileInCurrentScene ^ 1u;
}

void sub_1A2052640(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_2,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_2>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572270;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_2,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_2>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF572270;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_2,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_2>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func()
{
}

uint64_t std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_1,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_1>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(const md::OverlayTileData **)a2;
  id v4 = *(std::__shared_weak_count **)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int isOverlayTileInCurrentScene = md::OverlayContainer::_isOverlayTileInCurrentScene(*(void *)(*(void *)(a1 + 8) + 336), v3);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return isOverlayTileInCurrentScene ^ 1u;
}

void sub_1A20527AC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_1,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_1>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572228;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_1,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_1>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::__clone(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF572228;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_1,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_1>,BOOL ()(std::shared_ptr<md::OverlayTileData> const&)>::~__func()
{
}

BOOL std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_0,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_0>,BOOL ()(gdc::ResourceKey const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(*(void *)(a2 + 8) + 12) == **(_DWORD **)(a1 + 8);
}

uint64_t std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_0,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_0>,BOOL ()(gdc::ResourceKey const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5721E0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_0,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_0>,BOOL ()(gdc::ResourceKey const&)>::__clone(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5721E0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_0,std::allocator<md::OverlayContainer::_invalidate(VKOverlay *,BOOL,BOOL)::$_0>,BOOL ()(gdc::ResourceKey const&)>::~__func()
{
}

void std::__function::__func<md::OverlayContainer::invalidate(VKOverlay *,BOOL,BOOL)::$_0,std::allocator<md::OverlayContainer::invalidate(VKOverlay *,BOOL,BOOL)::$_0>,void ()(void)>::destroy_deallocate(id *a1)
{
  operator delete(a1);
}

void std::__function::__func<md::OverlayContainer::invalidate(VKOverlay *,BOOL,BOOL)::$_0,std::allocator<md::OverlayContainer::invalidate(VKOverlay *,BOOL,BOOL)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
}

id std::__function::__func<md::OverlayContainer::invalidate(VKOverlay *,BOOL,BOOL)::$_0,std::allocator<md::OverlayContainer::invalidate(VKOverlay *,BOOL,BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int8x8_t v5 = *(void **)(a1 + 16);
  *(void *)a2 = &unk_1EF572198;
  *(void *)(a2 + 8) = v4;
  id result = v5;
  *(void *)(a2 + 16) = result;
  *(_WORD *)(a2 + 24) = *(_WORD *)(a1 + 24);
  return result;
}

void *std::__function::__func<md::OverlayContainer::invalidate(VKOverlay *,BOOL,BOOL)::$_0,std::allocator<md::OverlayContainer::invalidate(VKOverlay *,BOOL,BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x20uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  void *v2 = &unk_1EF572198;
  v2[1] = v3;
  v2[2] = v4;
  *((_WORD *)v2 + 12) = *(_WORD *)(a1 + 24);
  return v2;
}

void std::__function::__func<md::OverlayContainer::invalidate(VKOverlay *,BOOL,BOOL)::$_0,std::allocator<md::OverlayContainer::invalidate(VKOverlay *,BOOL,BOOL)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::OverlayContainer::invalidate(VKOverlay *,BOOL,BOOL)::$_0,std::allocator<md::OverlayContainer::invalidate(VKOverlay *,BOOL,BOOL)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  return a1;
}

void md::OverlayContainer::computeTileExclusionAreas(void *a1, void **a2)
{
  uint64_t v4 = a1[20];
  uint64_t v5 = a1[21];
  if (v4 != v5)
  {
    uint64_t v6 = MEMORY[0x1E4F63F08];
    do
    {
      id v8 = *(id *)(v4 + 8);
      [v8 replaceMapContentInRect];
      double v10 = v9;
      double v12 = v11;
      double v14 = v13;
      double v16 = v15;

      if ((GEOMapRectIsNull() & 1) == 0)
      {
        double v17 = *(double *)(v6 + 16);
        double v18 = *(double *)(v6 + 24);
        double v19 = v10 / v17;
        double v20 = 1.0 - (v16 + v12) / v18;
        double v21 = 1.0 - v12 / v18;
        unint64_t v23 = (double *)a2[1];
        unint64_t v22 = (unint64_t)a2[2];
        double v24 = (v14 + v10) / v17;
        if ((unint64_t)v23 < v22)
        {
          double *v23 = v19;
          v23[1] = v20;
          v23[2] = v24;
          v23[3] = v21;
          *((_OWORD *)v23 + 2) = xmmword_1A28FE020;
          unint64_t v7 = (char *)(v23 + 8);
          v23[6] = 0.0;
          v23[7] = 0.0;
        }
        else
        {
          unint64_t v25 = (double *)*a2;
          uint64_t v26 = ((char *)v23 - (unsigned char *)*a2) >> 6;
          unint64_t v27 = v26 + 1;
          if ((unint64_t)(v26 + 1) >> 58) {
LABEL_46:
          }
            abort();
          uint64_t v28 = v22 - (void)v25;
          if (v28 >> 5 > v27) {
            unint64_t v27 = v28 >> 5;
          }
          if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFC0) {
            unint64_t v29 = 0x3FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v29 = v27;
          }
          if (v29)
          {
            if (v29 >> 58) {
LABEL_47:
            }
              std::__throw_bad_array_new_length[abi:nn180100]();
            uint8x8_t v30 = (char *)operator new(v29 << 6);
          }
          else
          {
            uint8x8_t v30 = 0;
          }
          uint64_t v31 = &v30[64 * v26];
          *(double *)uint64_t v31 = v19;
          *((double *)v31 + 1) = v20;
          *((double *)v31 + 2) = v24;
          *((double *)v31 + 3) = v21;
          *((_OWORD *)v31 + 2) = xmmword_1A28FE020;
          *((void *)v31 + 6) = 0;
          *((void *)v31 + 7) = 0;
          unint64_t v32 = v31;
          if (v23 != v25)
          {
            do
            {
              long long v33 = *((_OWORD *)v23 - 4);
              long long v34 = *((_OWORD *)v23 - 3);
              long long v35 = *((_OWORD *)v23 - 1);
              *((_OWORD *)v32 - 2) = *((_OWORD *)v23 - 2);
              *((_OWORD *)v32 - 1) = v35;
              *((_OWORD *)v32 - 4) = v33;
              *((_OWORD *)v32 - 3) = v34;
              v32 -= 64;
              v23 -= 8;
            }
            while (v23 != v25);
            unint64_t v23 = (double *)*a2;
          }
          unint64_t v7 = v31 + 64;
          *a2 = v32;
          a2[1] = v31 + 64;
          a2[2] = &v30[64 * v29];
          if (v23) {
            operator delete(v23);
          }
        }
        a2[1] = v7;
      }
      v4 += 24;
    }
    while (v4 != v5);
  }
  uint64_t v36 = a1[23];
  uint64_t v37 = a1[24];
  if (v36 != v37)
  {
    uint64_t v38 = MEMORY[0x1E4F63F08];
    do
    {
      id v40 = *(id *)(v36 + 8);
      [v40 replaceMapContentInRect];
      double v42 = v41;
      double v44 = v43;
      double v46 = v45;
      double v48 = v47;

      if ((GEOMapRectIsNull() & 1) == 0)
      {
        double v49 = *(double *)(v38 + 16);
        double v50 = *(double *)(v38 + 24);
        double v51 = v42 / v49;
        double v52 = 1.0 - (v48 + v44) / v50;
        double v53 = 1.0 - v44 / v50;
        v55 = (double *)a2[1];
        unint64_t v54 = (unint64_t)a2[2];
        double v56 = (v46 + v42) / v49;
        if ((unint64_t)v55 < v54)
        {
          double *v55 = v51;
          v55[1] = v52;
          v55[2] = v56;
          v55[3] = v53;
          *((_OWORD *)v55 + 2) = xmmword_1A28FE030;
          char v39 = (char *)(v55 + 8);
          v55[6] = 0.0;
          v55[7] = 0.0;
        }
        else
        {
          v57 = (double *)*a2;
          uint64_t v58 = ((char *)v55 - (unsigned char *)*a2) >> 6;
          unint64_t v59 = v58 + 1;
          if ((unint64_t)(v58 + 1) >> 58) {
            goto LABEL_46;
          }
          uint64_t v60 = v54 - (void)v57;
          if (v60 >> 5 > v59) {
            unint64_t v59 = v60 >> 5;
          }
          if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFC0) {
            unint64_t v61 = 0x3FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v61 = v59;
          }
          if (v61)
          {
            if (v61 >> 58) {
              goto LABEL_47;
            }
            v62 = (char *)operator new(v61 << 6);
          }
          else
          {
            v62 = 0;
          }
          v63 = &v62[64 * v58];
          *(double *)v63 = v51;
          *((double *)v63 + 1) = v52;
          *((double *)v63 + 2) = v56;
          *((double *)v63 + 3) = v53;
          *((_OWORD *)v63 + 2) = xmmword_1A28FE030;
          *((void *)v63 + 6) = 0;
          *((void *)v63 + 7) = 0;
          v64 = v63;
          if (v55 != v57)
          {
            do
            {
              long long v65 = *((_OWORD *)v55 - 4);
              long long v66 = *((_OWORD *)v55 - 3);
              long long v67 = *((_OWORD *)v55 - 1);
              *((_OWORD *)v64 - 2) = *((_OWORD *)v55 - 2);
              *((_OWORD *)v64 - 1) = v67;
              *((_OWORD *)v64 - 4) = v65;
              *((_OWORD *)v64 - 3) = v66;
              v64 -= 64;
              v55 -= 8;
            }
            while (v55 != v57);
            v55 = (double *)*a2;
          }
          char v39 = v63 + 64;
          *a2 = v64;
          a2[1] = v63 + 64;
          a2[2] = &v62[64 * v61];
          if (v55) {
            operator delete(v55);
          }
        }
        a2[1] = v39;
      }
      v36 += 24;
    }
    while (v36 != v37);
  }
}

void sub_1A2052DFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::OverlayContainer::visitOverlays(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 232);
  std::mutex::lock((std::mutex *)(a1 + 232));
  unint64_t v22 = 0;
  unint64_t v23 = 0;
  uint64_t v24 = 0;
  std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(&v22, *(void *)(a1 + 160), *(void *)(a1 + 168), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 168) - *(void *)(a1 + 160)) >> 3));
  std::mutex::unlock(v4);
  uint64_t v5 = v22;
  uint64_t v6 = v23;
  if (v22 != v23)
  {
    unint64_t v7 = v22;
    while (1)
    {
      uint64_t v25 = 0;
      uint64_t v8 = *(void *)(a2 + 24);
      if (!v8) {
        goto LABEL_26;
      }
      (*(void (**)(uint64_t, char *, uint64_t *))(*(void *)v8 + 48))(v8, v7, &v25);
      v7 += 24;
      if (v7 == v6)
      {
        if (!v5) {
          goto LABEL_13;
        }
        if (v5 != v6)
        {
          double v9 = v6 - 24;
          double v10 = v9;
          double v11 = v9;
          do
          {
            double v12 = *(void (***)(char *))v11;
            v11 -= 24;
            (*v12)(v10);
            v9 -= 24;
            BOOL v13 = v10 == v5;
            double v10 = v11;
          }
          while (!v13);
          uint64_t v5 = v22;
        }
        goto LABEL_12;
      }
    }
  }
  if (v22) {
LABEL_12:
  }
    operator delete(v5);
LABEL_13:
  std::mutex::lock(v4);
  unint64_t v22 = 0;
  unint64_t v23 = 0;
  uint64_t v24 = 0;
  std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(&v22, *(void *)(a1 + 184), *(void *)(a1 + 192), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 192) - *(void *)(a1 + 184)) >> 3));
  std::mutex::unlock(v4);
  double v14 = v22;
  double v15 = v23;
  if (v22 != v23)
  {
    double v16 = v22;
    while (1)
    {
      uint64_t v25 = 1;
      uint64_t v17 = *(void *)(a2 + 24);
      if (!v17) {
        break;
      }
      (*(void (**)(uint64_t, char *, uint64_t *))(*(void *)v17 + 48))(v17, v16, &v25);
      v16 += 24;
      if (v16 == v15)
      {
        if (!v14) {
          return;
        }
        if (v14 != v15)
        {
          double v18 = v15 - 24;
          double v19 = v15 - 24;
          double v20 = v15 - 24;
          do
          {
            double v21 = *(void (***)(char *))v20;
            v20 -= 24;
            (*v21)(v19);
            v18 -= 24;
            BOOL v13 = v19 == v14;
            double v19 = v20;
          }
          while (!v13);
          double v14 = v22;
        }
        goto LABEL_24;
      }
    }
LABEL_26:
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
    return;
  }
  if (v22) {
LABEL_24:
  }
    operator delete(v14);
}

void sub_1A205304C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A2053064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

void sub_1A2053454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::vector<md::MarkerFeatureHandle,geo::StdAllocator<md::MarkerFeatureHandle,mdm::Allocator>>::~vector[abi:nn180100](&a9);
  _Unwind_Resume(a1);
}

void md::MarkerFeatureHandle::~MarkerFeatureHandle(md::MarkerFeatureHandle *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

uint64_t *std::vector<md::MarkerFeatureHandle,geo::StdAllocator<md::MarkerFeatureHandle,mdm::Allocator>>::~vector[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v5->__on_zero_shared)(v5, v4);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 64;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v4, a1[2] - v4);
  }
  return a1;
}

void sub_1A20536B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (SHIBYTE(a11) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 & 0x7FFFFFFFFFFFFFFFLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A2053834(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

char *md::ARFeatureShadowExternalMeshLabelPart::debugString@<X0>(uint64_t a1@<X8>)
{
  id result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1A28FD660;
  strcpy(result, "ARFeatureShadowExternalMeshLabelPart");
  return result;
}

uint64_t md::ARFeatureShadowExternalMeshLabelPart::modelMatrix(md::ARFeatureShadowExternalMeshLabelPart *this)
{
  return (uint64_t)this + 688;
}

uint64_t md::ARFeatureShadowExternalMeshLabelPart::stagingModelMatrix(md::ARFeatureShadowExternalMeshLabelPart *this)
{
  return (uint64_t)this + 816;
}

uint64_t md::ARFeatureShadowExternalMeshLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t v5 = *(void *)(a1 + 576);
  if (!v5) {
    return 26;
  }
  double v9 = *(long long **)(a1 + 64);
  uint64_t v10 = *((void *)v9 + 6);
  uint64_t v11 = *((void *)v9 + 9);
  v12.f32[0] = *(float *)(a1 + 680) - *(float *)(a1 + 672);
  v12.f32[1] = (float)(*(float *)(a1 + 684) - *(float *)(a1 + 676)) * 0.5;
  float64x2_t v13 = vmulq_f64(*(float64x2_t *)((char *)v9 + 56), vcvtq_f64_f32(v12));
  long long v14 = *v9;
  long long v15 = v9[2];
  *(_OWORD *)(v5 + 48) = v9[1];
  *(_OWORD *)(v5 + 64) = v15;
  *(void *)(v5 + 80) = v10;
  *(_OWORD *)(v5 + 32) = v14;
  *(float64x2_t *)(v5 + 88) = v13;
  *(void *)(v5 + 104) = v11;
  double v16 = *((double *)v9 + 4);
  double v17 = *((double *)v9 + 5);
  v13.f64[0] = v16 + v16;
  *(double *)&long long v14 = (v16 + v16) * v16;
  *(double *)&long long v15 = (v17 + v17) * v17;
  uint64_t v19 = *((void *)v9 + 2);
  double v18 = *((double *)v9 + 3);
  double v20 = (v18 + v18) * v16;
  double v21 = *((double *)v9 + 6);
  uint64_t v22 = *((void *)v9 + 7);
  double v23 = (v17 + v17) * v21;
  double v24 = v17 * (v18 + v18);
  double v25 = 1.0 - (v18 + v18) * v18;
  float64_t v26 = v13.f64[0] * v17;
  v48[0] = 1.0 - (*(double *)&v14 + *(double *)&v15);
  v48[1] = v23 + v20;
  v48[4] = v20 - v23;
  v48[5] = v25 - *(double *)&v15;
  v48[8] = v21 * v13.f64[0] + v24;
  v48[9] = v26 - v21 * (v18 + v18);
  v48[2] = v24 - v21 * v13.f64[0];
  v48[6] = v21 * (v18 + v18) + v26;
  v48[10] = v25 - *(double *)&v14;
  v48[3] = 0.0;
  v48[7] = 0.0;
  v48[11] = 0.0;
  long long v49 = *v9;
  uint64_t v50 = v19;
  uint64_t v51 = 0x3FF0000000000000;
  long long v42 = 0u;
  long long v44 = 0u;
  long long v46 = 0u;
  long long v45 = 0u;
  long long v43 = 0u;
  long long v41 = 0u;
  long long v40 = 0u;
  uint64_t v47 = 0x3FF0000000000000;
  uint64_t v27 = *((void *)v9 + 8);
  uint64_t v28 = *((void *)v9 + 9);
  uint64_t v39 = v22;
  *(void *)&long long v42 = v27;
  *((void *)&v44 + 1) = v28;
  gm::operator*<double,4,4,4>((double *)v38, v48, (double *)&v39);
  long long v30 = v38[1];
  *(_OWORD *)(a1 + 688) = v38[0];
  *(_OWORD *)(a1 + 704) = v30;
  long long v31 = v38[3];
  *(_OWORD *)(a1 + 720) = v38[2];
  *(_OWORD *)(a1 + 736) = v31;
  long long v32 = v38[5];
  *(_OWORD *)(a1 + 752) = v38[4];
  *(_OWORD *)(a1 + 768) = v32;
  long long v33 = v38[7];
  *(_OWORD *)(a1 + 784) = v38[6];
  *(_OWORD *)(a1 + 800) = v33;
  *(_DWORD *)(a1 + 544) = *a5;
  *(_DWORD *)(a1 + 548) = a5[1];
  long long v34 = *(void **)(a1 + 472);
  if (v34)
  {
    free(v34);
    *(void *)(a1 + 472) = 0;
  }
  long long v35 = *(void **)(a1 + 480);
  if (v35)
  {
    free(v35);
    *(void *)(a1 + 480) = 0;
  }
  long long v36 = *(_OWORD *)(a1 + 672);
  *(_OWORD *)(a1 + 312) = v36;
  *(_DWORD *)(a1 + 520) = *a4;
  *(_DWORD *)(a1 + 524) = a4[1];
  *(_DWORD *)(a1 + 344) = *a4;
  LODWORD(v36) = a4[1];
  *(_DWORD *)(a1 + 348) = v36;
  md::CollisionObject::setupShapeData(a1 + 312, *(double *)&v36, *(double *)&v33, v29);
  *(void *)(a1 + 424) = a1 + 688;
  *(_DWORD *)(a1 + 408) = *(_DWORD *)(a1 + 948);
  return 37;
}

float md::ARFeatureShadowExternalMeshLabelPart::updateForDisplay(md::ARFeatureShadowExternalMeshLabelPart *this)
{
  *((_OWORD *)this + 42) = *((_OWORD *)this + 41);
  float result = *((float *)this + 236);
  *((float *)this + 237) = result;
  return result;
}

uint64_t md::ARFeatureShadowExternalMeshLabelPart::layoutForStaging(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result = md::ExternalMeshLabelPart::layoutForStaging((void *)a1);
  if (result == 37)
  {
    if (*(float *)(a1 + 664) >= *(float *)(a1 + 656) && *(float *)(a1 + 668) >= *(float *)(a1 + 660))
    {
      uint64_t v8 = *(double **)(a1 + 56);
      double v9 = v8[4];
      double v10 = v8[5];
      double v11 = v9 + v9;
      double v12 = (v9 + v9) * v9;
      double v13 = (v10 + v10) * v10;
      uint64_t v15 = *((void *)v8 + 2);
      double v14 = v8[3];
      double v16 = (v14 + v14) * v9;
      double v17 = v8[6];
      uint64_t v18 = *((void *)v8 + 7);
      double v19 = (v10 + v10) * v17;
      double v20 = v16 - v19;
      double v21 = v10 * (v14 + v14);
      double v22 = v19 + v16;
      double v23 = v17 * v11;
      v48[0] = 1.0 - (v12 + v13);
      v48[1] = v22;
      double v24 = 1.0 - (v14 + v14) * v14;
      v48[4] = v20;
      v48[5] = v24 - v13;
      double v25 = v17 * v11 + v21;
      double v26 = v11 * v10;
      double v27 = v17 * (v14 + v14);
      v48[8] = v25;
      v48[9] = v26 - v27;
      v48[2] = v21 - v23;
      v48[6] = v27 + v26;
      v48[10] = v24 - v12;
      v48[3] = 0.0;
      v48[7] = 0.0;
      v48[11] = 0.0;
      long long v49 = *(_OWORD *)v8;
      uint64_t v50 = v15;
      uint64_t v51 = 0x3FF0000000000000;
      long long v42 = 0u;
      long long v44 = 0u;
      long long v46 = 0u;
      long long v45 = 0u;
      long long v43 = 0u;
      long long v41 = 0u;
      long long v40 = 0u;
      uint64_t v47 = 0x3FF0000000000000;
      uint64_t v28 = *((void *)v8 + 8);
      uint64_t v29 = *((void *)v8 + 9);
      uint64_t v39 = v18;
      *(void *)&long long v42 = v28;
      *((void *)&v44 + 1) = v29;
      gm::operator*<double,4,4,4>((double *)v38, v48, (double *)&v39);
      long long v31 = v38[1];
      *(_OWORD *)(a1 + 816) = v38[0];
      *(_OWORD *)(a1 + 832) = v31;
      long long v32 = v38[3];
      *(_OWORD *)(a1 + 848) = v38[2];
      *(_OWORD *)(a1 + 864) = v32;
      long long v33 = v38[5];
      *(_OWORD *)(a1 + 880) = v38[4];
      *(_OWORD *)(a1 + 896) = v33;
      long long v34 = v38[7];
      *(_OWORD *)(a1 + 912) = v38[6];
      *(_OWORD *)(a1 + 928) = v34;
      *(_DWORD *)(a1 + 304) = *a4;
      *(_DWORD *)(a1 + 308) = a4[1];
      long long v35 = *(void **)(a1 + 232);
      if (v35)
      {
        free(v35);
        *(void *)(a1 + 232) = 0;
      }
      long long v36 = *(void **)(a1 + 240);
      if (v36)
      {
        free(v36);
        *(void *)(a1 + 240) = 0;
      }
      long long v37 = *(_OWORD *)(a1 + 656);
      *(_OWORD *)(a1 + 72) = v37;
      *(_DWORD *)(a1 + 280) = *a3;
      *(_DWORD *)(a1 + 284) = a3[1];
      *(_DWORD *)(a1 + 104) = *a3;
      LODWORD(v37) = a3[1];
      *(_DWORD *)(a1 + 108) = v37;
      md::CollisionObject::setupShapeData(a1 + 72, *(double *)&v37, *(double *)&v34, v30);
      *(void *)(a1 + 184) = a1 + 816;
      *(_DWORD *)(a1 + 168) = *(_DWORD *)(a1 + 944);
      return 37;
    }
    else
    {
      return 13;
    }
  }
  return result;
}

float md::ARFeatureShadowExternalMeshLabelPart::updateWithStyle(md::ARFeatureShadowExternalMeshLabelPart *this, LabelManager *a2)
{
  float result = *(float *)(**((void **)this + 4) + 172);
  *((float *)this + 236) = result;
  return result;
}

void md::ARFeatureShadowExternalMeshLabelPart::~ARFeatureShadowExternalMeshLabelPart(md::ARFeatureShadowExternalMeshLabelPart *this)
{
  md::ExternalMeshLabelPart::~ExternalMeshLabelPart(this);
  uint64_t v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  uint64_t v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

uint64_t md::ARFeatureShadowExternalMeshLabelPart::ARFeatureShadowExternalMeshLabelPart(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 8) = 1065353216;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a1;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  long long v5 = xmmword_1A28FC750;
  *(_OWORD *)(a1 + 72) = xmmword_1A28FC750;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 88) = 1065353216;
  *(_DWORD *)(a1 + 96) = 1065353216;
  *(_OWORD *)(a1 + 100) = 0u;
  *(_DWORD *)(a1 + 116) = 0;
  *(_OWORD *)(a1 + 120) = xmmword_1A28FC750;
  *(_OWORD *)(a1 + 136) = xmmword_1A28FC750;
  *(_OWORD *)(a1 + 152) = xmmword_1A28FC750;
  *(_OWORD *)(a1 + 168) = xmmword_1A28FCDA0;
  *(unsigned char *)(a1 + 224) = 0;
  *(unsigned char *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 257) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 280) = xmmword_1A28FCE90;
  *(_OWORD *)(a1 + 296) = xmmword_1A28FCEA0;
  *(_OWORD *)(a1 + 312) = xmmword_1A28FC750;
  *(void *)(a1 + 328) = 1065353216;
  *(_DWORD *)(a1 + 336) = 1065353216;
  *(_DWORD *)(a1 + 356) = 0;
  *(_OWORD *)(a1 + 340) = 0u;
  *(_OWORD *)(a1 + 360) = xmmword_1A28FC750;
  *(_OWORD *)(a1 + 376) = xmmword_1A28FC750;
  *(_OWORD *)(a1 + 392) = xmmword_1A28FC750;
  *(_OWORD *)(a1 + 408) = xmmword_1A28FCDA0;
  *(unsigned char *)(a1 + 464) = 0;
  *(unsigned char *)(a1 + 440) = 0;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 497) = 0u;
  *(_OWORD *)(a1 + 520) = xmmword_1A28FCE90;
  *(_DWORD *)(a1 + 536) = 1065353216;
  *(_OWORD *)(a1 + 540) = 0u;
  *(_WORD *)(a1 + 556) = 512;
  *(unsigned char *)(a1 + 562) = 0;
  *(_DWORD *)(a1 + 558) = 0;
  *(_WORD *)(a1 + 563) = -1;
  *(_DWORD *)(a1 + 565) = 0;
  *(void *)a1 = &unk_1EF53F508;
  *(_OWORD *)(a1 + 576) = 0u;
  *(void *)(a1 + 592) = a2;
  *(void *)(a1 + 600) = a3;
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
      long long v5 = xmmword_1A28FC750;
    }
  }
  *(void *)a1 = &unk_1EF54F2B0;
  *(_OWORD *)(a1 + 656) = v5;
  *(_OWORD *)(a1 + 672) = v5;
  *(void *)(a1 + 944) = 0;
  return a1;
}

uint64_t md::UniLineLabelFeature::styleIndexForFeature(uint64_t a1, uint64_t a2)
{
  md::UniLineLabelFeature::mergeAdditionalAttributes(&v6, *(void *)(a1 + 472), *(const FeatureStyleAttributes **)(a2 + 24), *(void *)(a2 + 32));
  uint64_t v3 = md::LineLabelFeature::styleIndexForAttributes(a1, (uint64_t *)&v6);
  uint64_t v4 = v7;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return v3;
}

void sub_1A20540B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unint64_t md::UniLineLabelFeature::debugPopulateStyleAttributes(uint64_t *a1, unint64_t a2)
{
  if ((*(uint64_t (**)(uint64_t *))(*a1 + 64))(a1))
  {
    md::createFeatureAttributeSet((gss::Allocator *)&v5, a1 + 52);
    unint64_t result = std::__hash_table<gss::FeatureAttributeSet,std::hash<gss::FeatureAttributeSet>,std::equal_to<gss::FeatureAttributeSet>,geo::StdAllocator<gss::FeatureAttributeSet,mdm::Allocator>>::__emplace_unique_key_args<gss::FeatureAttributeSet,gss::FeatureAttributeSet>(a2, v5, v6, (uint64_t)&v5);
    if (v5)
    {
      uint64_t v6 = v5;
      return (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(*(void *)v8 + 40))(v8, v5, v7 - (void)v5);
    }
  }
  else
  {
    return md::LabelFeature::debugPopulateStyleAttributes((uint64_t)a1, a2);
  }
  return result;
}

void sub_1A2054198(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a9) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 - a9);
  }
  _Unwind_Resume(exception_object);
}

unint64_t std::__hash_table<gss::FeatureAttributeSet,std::hash<gss::FeatureAttributeSet>,std::equal_to<gss::FeatureAttributeSet>,geo::StdAllocator<gss::FeatureAttributeSet,mdm::Allocator>>::__emplace_unique_key_args<gss::FeatureAttributeSet,gss::FeatureAttributeSet>(unint64_t result, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v6 = result;
  int64_t v7 = (char *)a3 - (char *)a2;
  unint64_t v8 = ((char *)a3 - (char *)a2) >> 3;
  if (a3 != a2)
  {
    double v9 = a2;
    do
    {
      unint64_t v10 = ((v8 << 6) - 0x61C8864680B583EBLL + (v8 >> 2) + *v9) ^ v8;
      unint64_t v8 = (*((unsigned __int16 *)v9 + 2) - 0x61C8864680B583EBLL + (v10 << 6) + (v10 >> 2)) ^ v10;
      v9 += 2;
    }
    while (v9 != a3);
  }
  unint64_t v11 = *(void *)(result + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v8;
      if (v8 >= v11) {
        unint64_t v4 = v8 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v8;
    }
    double v13 = *(void **)(*(void *)result + 8 * v4);
    if (v13)
    {
      double v14 = (void *)*v13;
      if (v14)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v20 = v14[1];
            if (v20 == v8)
            {
              uint64_t v22 = v14[2];
              uint64_t v21 = v14[3];
              if (v21 - v22 == v7)
              {
                if (v22 == v21) {
                  return result;
                }
                for (uint64_t i = a2; *(_DWORD *)v22 == *i && *(unsigned __int16 *)(v22 + 4) == *((unsigned __int16 *)i + 2); i += 2)
                {
                  v22 += 8;
                  if (v22 == v21) {
                    return result;
                  }
                }
              }
            }
            else if ((v20 & (v11 - 1)) != v4)
            {
              goto LABEL_42;
            }
            double v14 = (void *)*v14;
            if (!v14) {
              goto LABEL_42;
            }
          }
        }
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v8)
          {
            uint64_t v17 = v14[2];
            uint64_t v16 = v14[3];
            if (v16 - v17 == v7)
            {
              if (v17 == v16) {
                return result;
              }
              for (j = a2; *(_DWORD *)v17 == *j && *(unsigned __int16 *)(v17 + 4) == *((unsigned __int16 *)j + 2); j += 2)
              {
                v17 += 8;
                if (v17 == v16) {
                  return result;
                }
              }
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v4) {
              break;
            }
          }
          double v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_42:
  long long v36 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(result + 32) + 16))(*(void *)(result + 32), 48, 8);
  *long long v36 = 0;
  v36[1] = v8;
  v36[2] = 0;
  v36[3] = 0;
  v36[4] = 0;
  unint64_t result = gss::Allocator::instance((gss::Allocator *)v36);
  v36[5] = result;
  if (v36 + 2 != (uint64_t *)a4) {
    unint64_t result = std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::__assign_with_size[abi:nn180100]<std::pair<gss::StyleAttribute,unsigned short>*,std::pair<gss::StyleAttribute,unsigned short>*>(v36 + 2, *(void *)a4, *(void **)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3);
  }
  float v25 = (float)(unint64_t)(*(void *)(v6 + 40) + 1);
  float v26 = *(float *)(v6 + 48);
  if (!v11 || (float)(v26 * (float)v11) < v25)
  {
    BOOL v27 = 1;
    if (v11 >= 3) {
      BOOL v27 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v28 = v27 | (2 * v11);
    unint64_t v29 = vcvtps_u32_f32(v25 / v26);
    if (v28 <= v29) {
      size_t v30 = v29;
    }
    else {
      size_t v30 = v28;
    }
    if (v30 == 1)
    {
      size_t v30 = 2;
    }
    else if ((v30 & (v30 - 1)) != 0)
    {
      unint64_t result = std::__next_prime(v30);
      size_t v30 = result;
    }
    int8x8_t v31 = *(int8x8_t *)(v6 + 8);
    if (v30 > *(void *)&v31) {
      goto LABEL_56;
    }
    if (v30 < *(void *)&v31)
    {
      unint64_t result = vcvtps_u32_f32((float)*(unint64_t *)(v6 + 40) / *(float *)(v6 + 48));
      if (*(void *)&v31 < 3uLL || (uint8x8_t v32 = (uint8x8_t)vcnt_s8(v31), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
      {
        unint64_t result = std::__next_prime(result);
      }
      else
      {
        uint64_t v33 = 1 << -(char)__clz(result - 1);
        if (result >= 2) {
          unint64_t result = v33;
        }
      }
      if (v30 <= result) {
        size_t v30 = result;
      }
      if (v30 < *(void *)&v31) {
LABEL_56:
      }
        unint64_t result = std::__hash_table<std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,std::__unordered_map_hasher<VKTrafficFeature * {__strong},std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,md::TrafficFeatureHash,std::equal_to<VKTrafficFeature * {__strong}>,true>,std::__unordered_map_equal<VKTrafficFeature * {__strong},std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,std::equal_to<VKTrafficFeature * {__strong}>,md::TrafficFeatureHash,true>,geo::StdAllocator<std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,mdm::Allocator>>::__do_rehash<true>(v6, v30);
    }
    unint64_t v11 = *(void *)(v6 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v8 >= v11) {
        unint64_t v4 = v8 % v11;
      }
      else {
        unint64_t v4 = v8;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v8;
    }
  }
  long long v34 = *(uint64_t **)(*(void *)v6 + 8 * v4);
  if (v34)
  {
    *long long v36 = *v34;
    *long long v34 = (uint64_t)v36;
  }
  else
  {
    *long long v36 = *(void *)(v6 + 24);
    *(void *)(v6 + 24) = v36;
    *(void *)(*(void *)v6 + 8 * v4) = v6 + 24;
    if (*v36)
    {
      unint64_t v35 = *(void *)(*v36 + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v35 >= v11) {
          v35 %= v11;
        }
      }
      else
      {
        v35 &= v11 - 1;
      }
      *(void *)(*(void *)v6 + 8 * v35) = v36;
    }
  }
  ++*(void *)(v6 + 40);
  return result;
}

void sub_1A20545FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<gss::FeatureAttributeSet,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<gss::FeatureAttributeSet,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<std::__hash_node<gss::FeatureAttributeSet,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<gss::FeatureAttributeSet,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      uint64_t v3 = *(void *)(v2 + 16);
      if (v3)
      {
        *(void *)(v2 + 24) = v3;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 40) + 40))(*(void *)(v2 + 40), v3, *(void *)(v2 + 32) - v3);
      }
    }
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)a1[1] + 40))(*(void *)a1[1], v2, 48);
  }
  return a1;
}

void md::UniLineLabelFeature::debugPopulateAttributeStrings(uint64_t a1, void *a2, uint64_t a3, unsigned int *a4)
{
  id v13 = a2;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1))
  {
    int64_t v7 = NSString;
    unint64_t v8 = (gss::Allocator *)(a1 + 416);
    double v9 = md::HighlightHelper::debugAttributesToString(v8);
    unint64_t v10 = [v7 stringWithFormat:@"{%@}", v9];
    [v13 addObject:v10];

    unint64_t v11 = md::LabelFeature::debugClientAttributesToString((uint64_t *)v8, *(void *)(a3 + 336));
    if (v11)
    {
      uint8x8_t v12 = [NSString stringWithFormat:@"{%@}", v11];
      [v13 addObject:v12];
    }
  }
  else
  {
    md::LineLabelFeature::debugPopulateAttributeStrings(a1, v13, a3, a4);
  }
}

void sub_1A2054828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t md::UniLineLabelFeature::isPickedStateStylable(md::UniLineLabelFeature *this)
{
  return 0;
}

uint64_t md::UniLineLabelFeature::debugString@<X0>(md::LineLabelFeature *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, unsigned int a4@<W3>, unsigned char *a5@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v43);
  unint64_t v10 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    unint64_t v10 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v37) {
      operator new();
    }
  }
  uint64_t v40 = *((void *)v10 + 91);
  HIBYTE(v39) = 4;
  strcpy((char *)v38, "Road");
  md::LineLabelFeature::debugRoadString(__p, a1, a2, a3, a4, (uint64_t)v38);
  if ((v42 & 0x80u) == 0) {
    unint64_t v11 = __p;
  }
  else {
    unint64_t v11 = (void **)__p[0];
  }
  if ((v42 & 0x80u) == 0) {
    uint64_t v12 = v42;
  }
  else {
    uint64_t v12 = (uint64_t)__p[1];
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)v11, v12);
  if ((char)v42 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v39) & 0x80000000) == 0) {
      goto LABEL_10;
    }
LABEL_18:
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v40 + 40))(v40, v38[0], v39 & 0x7FFFFFFFFFFFFFFFLL);
    goto LABEL_10;
  }
  if (SHIBYTE(v39) < 0) {
    goto LABEL_18;
  }
LABEL_10:
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)"Road Attributes:\n", 17);
  if (!(*(uint64_t (**)(md::LineLabelFeature *))(*(void *)a1 + 64))(a1))
  {
    uint64_t v18 = *((void *)a1 + 29);
    uint64_t v17 = (void *)((char *)a1 + 232);
    uint64_t v16 = v18;
    if (v18)
    {
      unsigned int v19 = *a3;
      uint64_t v20 = v17;
      do
      {
        unsigned int v21 = *(_DWORD *)(v16 + 32);
        BOOL v22 = v21 >= v19;
        if (v21 >= v19) {
          double v23 = (uint64_t *)v16;
        }
        else {
          double v23 = (uint64_t *)(v16 + 8);
        }
        if (v22) {
          uint64_t v20 = (void *)v16;
        }
        uint64_t v16 = *v23;
      }
      while (*v23);
      if (v20 != v17 && v19 >= *((_DWORD *)v20 + 8))
      {
        uint64_t v24 = v20[5];
        float v25 = (std::__shared_weak_count *)v20[6];
        v38[0] = v24;
        v38[1] = v25;
        if (v25) {
          atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v24)
        {
          if ((float v26 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t))(*(void *)v24 + 200))(v24),
                unint64_t v28 = v26,
                *(void *)v26)
            && *((_DWORD *)v26 + 10) == *(_DWORD *)(*(void *)v26 + 252)
            && (unint64_t v29 = (uint64_t *)*((void *)v26 + 3)) != 0
            && (*((__int16 *)v26 + 17) & 0x80000000) == 0
            || (md::LabelLineResolvedPosition::moveOntoPathForZoom((md::LabelLineResolvedPosition *)v26, v26[164], v27),
                *(void *)v28)
            && *((_DWORD *)v28 + 10) == *(_DWORD *)(*(void *)v28 + 252)
            && (unint64_t v29 = (uint64_t *)*((void *)v28 + 3)) != 0)
          {
            if ((*((__int16 *)v28 + 17) & 0x80000000) == 0)
            {
              uint64_t v30 = *v29;
              if (v30)
              {
                if (!*(unsigned char *)(v30 + 32))
                {
                  uint64_t v31 = *(void *)(v30 + 16);
                  if (v31)
                  {
                    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)"  RoadClass=", 12);
                    LOBYTE(__p[0]) = *(unsigned char *)(v31 + 151);
                    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)__p, 1);
                    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)"\n", 1);
                  }
                }
              }
            }
          }
        }
        if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
    }
  }
  if ((v50 & 0x10) != 0)
  {
    unint64_t v14 = v49;
    if (v49 < v46)
    {
      unint64_t v49 = v46;
      unint64_t v14 = v46;
    }
    unint64_t v15 = (const void **)&v45;
  }
  else
  {
    if ((v50 & 8) == 0)
    {
      size_t v13 = 0;
      a5[23] = 0;
      goto LABEL_57;
    }
    unint64_t v15 = (const void **)v44;
    unint64_t v14 = v44[2];
  }
  uint8x8_t v32 = *v15;
  size_t v13 = v14 - (void)*v15;
  if (v13 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v13 >= 0x17)
  {
    uint64_t v33 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v33 = v13 | 7;
    }
    uint64_t v34 = v33 + 1;
    unint64_t v35 = operator new(v33 + 1);
    *((void *)a5 + 1) = v13;
    *((void *)a5 + 2) = v34 | 0x8000000000000000;
    *(void *)a5 = v35;
    a5 = v35;
    goto LABEL_56;
  }
  a5[23] = v13;
  if (v13) {
LABEL_56:
  }
    memmove(a5, v32, v13);
LABEL_57:
  a5[v13] = 0;
  v43[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v43 + *(void *)(v43[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v43[1] = MEMORY[0x1E4FBA470] + 16;
  if (v48 < 0) {
    operator delete(v47);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v51);
}

void sub_1A2054D58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
}

uint64_t md::UniLineLabelFeature::featureID(md::UniLineLabelFeature *this)
{
  return *((void *)this + 61);
}

void md::UniLineLabelFeature::populateFeatureInfo(md::UniLineLabelFeature *this, md::LabelFeatureInfo *a2)
{
  unint64_t v4 = (char *)a2 + 16;
  if (!*((void *)a2 + 2))
  {
    std::mutex::lock((std::mutex *)((char *)this + 8));
    uint64_t v5 = *((void *)this + 19);
    if (v5) {
      (*(void (**)(uint64_t, char *))(*(void *)v5 + 16))(v5, v4);
    }
    std::mutex::unlock((std::mutex *)((char *)this + 8));
  }
  *((_DWORD *)a2 + 16) = -1431655765 * ((*((void *)this + 45) - *((void *)this + 44)) >> 4);
  uint64_t v6 = *((void *)this + 57);
  if (v6)
  {
    int64_t v7 = (long long *)(v6 + 240);
    unint64_t v8 = (void **)((char *)a2 + 72);
    if ((md::LabelFeatureInfo *)((char *)a2 + 72) != (md::LabelFeatureInfo *)(v6 + 240))
    {
      size_t v9 = *(unsigned __int8 *)(v6 + 263);
      if (*((char *)a2 + 95) < 0)
      {
        uint64_t v12 = *(long long **)(v6 + 240);
        size_t v11 = *(void *)(v6 + 248);
        if ((v9 & 0x80u) == 0) {
          size_t v13 = v7;
        }
        else {
          size_t v13 = v12;
        }
        if ((v9 & 0x80u) == 0) {
          size_t v14 = v9;
        }
        else {
          size_t v14 = v11;
        }
        std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_no_alias<false>(v8, v13, v14);
      }
      else if ((v9 & 0x80) != 0)
      {
        std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_no_alias<true>((void **)v8, *(void **)(v6 + 240), *(void *)(v6 + 248));
      }
      else
      {
        long long v10 = *v7;
        *((void *)a2 + 11) = *(void *)(v6 + 256);
        *(_OWORD *)unint64_t v8 = v10;
      }
    }
    uint64_t v15 = *((void *)this + 57);
    uint64_t v16 = (long long *)(v15 + 272);
    uint64_t v17 = (void **)((char *)a2 + 104);
    if ((md::LabelFeatureInfo *)((char *)a2 + 104) != (md::LabelFeatureInfo *)(v15 + 272))
    {
      size_t v18 = *(unsigned __int8 *)(v15 + 295);
      if (*((char *)a2 + 127) < 0)
      {
        unsigned int v21 = *(long long **)(v15 + 272);
        size_t v20 = *(void *)(v15 + 280);
        if ((v18 & 0x80u) == 0) {
          BOOL v22 = v16;
        }
        else {
          BOOL v22 = v21;
        }
        if ((v18 & 0x80u) == 0) {
          size_t v23 = v18;
        }
        else {
          size_t v23 = v20;
        }
        std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_no_alias<false>(v17, v22, v23);
      }
      else if ((v18 & 0x80) != 0)
      {
        uint64_t v24 = *(void **)(v15 + 272);
        size_t v25 = *(void *)(v15 + 280);
        std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_no_alias<true>((void **)v17, v24, v25);
      }
      else
      {
        long long v19 = *v16;
        *((void *)a2 + 15) = *(void *)(v15 + 288);
        *(_OWORD *)uint64_t v17 = v19;
      }
    }
  }
}

void sub_1A2054F64(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

char *md::UniLineLabelFeature::updateText(char *result, uint64_t *a2)
{
  uint64_t v2 = result;
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  int v4 = *(unsigned __int8 *)(*a2 + 176);
  if (v4 == 14)
  {
    uint64_t v5 = *((void *)result + 48);
    for (uint64_t i = *((void *)result + 49); ; i -= 64)
    {
      if (i == v5)
      {
        *((void *)v2 + 49) = v5;
        uint64_t v11 = *((void *)v2 + 24);
        uint64_t v47 = (uint64_t (**)(void **))&unk_1EF51E2A8;
        char v48 = v2;
        *((void *)&v49 + 1) = &v47;
        uint64_t v12 = *(void *)(v11 + 128);
        uint64_t v13 = *(void *)(v11 + 136);
        if (v12 == v13) {
          return (char *)v47[4]((void **)&v47);
        }
        while (1)
        {
          uint64_t v14 = *(void *)(v12 + 16);
          uint64_t v15 = *(void *)(v12 + 24);
          if (v14 != v15) {
            break;
          }
LABEL_21:
          v12 += 112;
          if (v12 == v13)
          {
            unint64_t result = (char *)*((void *)&v49 + 1);
            if (*((uint64_t (****)(void **))&v49 + 1) != &v47)
            {
              if (*((void *)&v49 + 1)) {
                return (char *)(*(uint64_t (**)(void))(**((void **)&v49 + 1) + 40))();
              }
              return result;
            }
            return (char *)v47[4]((void **)&v47);
          }
        }
        while (*((void *)&v49 + 1))
        {
          (*(void (**)(void, uint64_t))(**((void **)&v49 + 1) + 48))(*((void *)&v49 + 1), v14);
          v14 += 8;
          if (v14 == v15) {
            goto LABEL_21;
          }
        }
        std::__throw_bad_function_call[abi:nn180100]();
        __break(1u);
LABEL_69:
        abort();
      }
      if (*(char *)(i - 9) < 0)
      {
        (*(void (**)(void, void, uint64_t))(**(void **)(i - 8) + 40))(*(void *)(i - 8), *(void *)(i - 32), *(void *)(i - 16) & 0x7FFFFFFFFFFFFFFFLL);
        if ((*(char *)(i - 41) & 0x80000000) == 0) {
          continue;
        }
      }
      else if ((*(char *)(i - 41) & 0x80000000) == 0)
      {
        continue;
      }
      (*(void (**)(void, void, uint64_t))(**(void **)(i - 40) + 40))(*(void *)(i - 40), *(void *)(i - 64), *(void *)(i - 48) & 0x7FFFFFFFFFFFFFFFLL);
    }
  }
  unint64_t v8 = *(void **)(v3 + 184);
  int64_t v7 = *(void **)(v3 + 192);
  if (v7 != v8 && *((void *)result + 44) == *((void *)result + 45))
  {
    if (v4 == 2)
    {
      char v10 = 1;
    }
    else
    {
      if (v4 != 13 && v4 != 9)
      {
        char v46 = 0;
LABEL_33:
        uint64_t v16 = result + 360;
        uint64_t v17 = result + 376;
        uint64_t v45 = result + 376;
        while (1)
        {
          unsigned int v21 = (unsigned char *)*v8;
          uint64_t v22 = *v8 + 8;
          unint64_t v24 = *((void *)v2 + 45);
          unint64_t v23 = *((void *)v2 + 46);
          if (v24 >= v23)
          {
            uint64_t v26 = *((void *)v2 + 44);
            unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - v26) >> 4);
            unint64_t v28 = v27 + 1;
            if (v27 + 1 > 0x555555555555555) {
              goto LABEL_69;
            }
            unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - v26) >> 4);
            if (2 * v29 > v28) {
              unint64_t v28 = 2 * v29;
            }
            if (v29 >= 0x2AAAAAAAAAAAAAALL) {
              uint64_t v30 = 0x555555555555555;
            }
            else {
              uint64_t v30 = v28;
            }
            int v50 = v17;
            if (v30) {
              uint64_t v31 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*v17 + 16))(*v17, 48 * v30, 8);
            }
            else {
              uint64_t v31 = 0;
            }
            unint64_t result = (char *)(v31 + 48 * v27);
            uint64_t v47 = (uint64_t (**)(void **))v31;
            char v48 = result;
            *(void *)&long long v49 = result;
            *((void *)&v49 + 1) = v31 + 48 * v30;
            if (v31)
            {
              uint64_t v32 = *((void *)v21 + 6);
              *((void *)result + 3) = *((void *)v21 + 4);
              if ((char)v21[31] < 0)
              {
                std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)result, *((void **)v21 + 1), *((void *)v21 + 2));
                unint64_t result = v48;
                uint64_t v34 = (char *)v49;
              }
              else
              {
                long long v33 = *(_OWORD *)v22;
                *((void *)result + 2) = *(void *)(v22 + 16);
                *(_OWORD *)unint64_t result = v33;
                uint64_t v34 = (char *)(v31 + 48 * v27);
              }
              unint64_t v35 = v31 + 48 * v27;
              *(void *)(v35 + 32) = v32;
              *(_DWORD *)(v35 + 40) = 0;
              *(unsigned char *)(v35 + 44) = v46;
            }
            else
            {
              uint64_t v34 = result;
            }
            long long v19 = v34 + 48;
            *(void *)&long long v49 = v34 + 48;
            uint64_t v36 = *((void *)v2 + 44);
            uint64_t v37 = *((void *)v2 + 45);
            uint64_t v17 = v45;
            if (v37 == v36)
            {
              *((void *)v2 + 44) = result;
              *((void *)v2 + 45) = v19;
              uint64_t v43 = *((void *)v2 + 46);
              *((void *)v2 + 46) = *((void *)&v49 + 1);
            }
            else
            {
              uint64_t v38 = 0;
              do
              {
                uint64_t v39 = &result[v38];
                uint64_t v40 = v37 + v38;
                long long v41 = *(_OWORD *)(v37 + v38 - 32);
                *((_OWORD *)v39 - 3) = *(_OWORD *)(v37 + v38 - 48);
                *((_OWORD *)v39 - 2) = v41;
                *(void *)(v40 - 40) = 0;
                *(void *)(v40 - 32) = 0;
                *(void *)(v40 - 48) = 0;
                *((void *)v39 - 2) = *(void *)(v37 + v38 - 16);
                *((_DWORD *)v39 - 2) = *(_DWORD *)(v37 + v38 - 8);
                *(v39 - 4) = *(unsigned char *)(v37 + v38 - 4);
                v38 -= 48;
              }
              while (v37 + v38 != v36);
              uint64_t v37 = *((void *)v2 + 44);
              uint64_t v42 = *((void *)v2 + 45);
              *((void *)v2 + 44) = &result[v38];
              uint64_t v43 = *((void *)v2 + 46);
              long long v44 = (char *)v49;
              *uint64_t v16 = v49;
              long long v19 = v44;
              while (v42 != v37)
              {
                if (*(char *)(v42 - 25) < 0) {
                  unint64_t result = (char *)(*(uint64_t (**)(void, void, uint64_t))(**(void **)(v42 - 24) + 40))(*(void *)(v42 - 24), *(void *)(v42 - 48), *(void *)(v42 - 32) & 0x7FFFFFFFFFFFFFFFLL);
                }
                v42 -= 48;
              }
            }
            if (v37) {
              unint64_t result = (char *)(*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*v50 + 40))(*v50, v37, v43 - v37);
            }
          }
          else
          {
            if (v24)
            {
              uint64_t v25 = *((void *)v21 + 6);
              *(void *)(v24 + 24) = *((void *)v21 + 4);
              if ((char)v21[31] < 0)
              {
                unint64_t result = (char *)std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)v24, *((void **)v21 + 1), *((void *)v21 + 2));
              }
              else
              {
                long long v18 = *(_OWORD *)v22;
                *(void *)(v24 + 16) = *(void *)(v22 + 16);
                *(_OWORD *)unint64_t v24 = v18;
              }
              *(void *)(v24 + 32) = v25;
              *(_DWORD *)(v24 + 40) = 0;
              *(unsigned char *)(v24 + 44) = v46;
            }
            long long v19 = (char *)(v24 + 48);
            *(void *)uint64_t v16 = v24 + 48;
          }
          *(void *)uint64_t v16 = v19;
          size_t v20 = (unsigned char *)*v8;
          v8 += 2;
          *(v19 - 8) = v20[56];
          *(v19 - 7) = v20[57];
          *(v19 - 6) = v20[58];
          *(v19 - 5) = v20[59];
          if (v8 == v7) {
            return result;
          }
        }
      }
      char v10 = 2;
    }
    char v46 = v10;
    goto LABEL_33;
  }
  return result;
}

void sub_1A20554A8(_Unwind_Exception *a1)
{
  void *v2 = v1;
  _Unwind_Resume(a1);
}

void sub_1A20554B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::__split_buffer<md::LabelShieldEntry,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator> &>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A20554C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::function<void ()(std::unique_ptr<md::LabelLineSegment> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::function<void ()(std::unique_ptr<md::LabelLineSegment> const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__split_buffer<md::LabelShieldEntry,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v5 = v2 - 48;
      *(void *)(a1 + 16) = v2 - 48;
      if (*(char *)(v2 - 25) < 0)
      {
        (*(void (**)(void, void, uint64_t))(**(void **)(v2 - 24) + 40))(*(void *)(v2 - 24), *(void *)(v2 - 48), *(void *)(v2 - 32) & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v5 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != v3);
  }
  if (*(void *)a1) {
    (*(void (**)(void, void, void))(***(void ***)(a1 + 32) + 40))(**(void **)(a1 + 32), *(void *)a1, *(void *)(a1 + 24) - *(void *)a1);
  }
  return a1;
}

uint64_t std::__function::__func<md::UniLineLabelFeature::updateText(std::shared_ptr<md::LabelExternalRoadFeature> const&,BOOL)::$_0,std::allocator<md::UniLineLabelFeature::updateText(std::shared_ptr<md::LabelExternalRoadFeature> const&,BOOL)::$_0>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::operator()(uint64_t result, uint64_t *a2)
{
  if (*(unsigned char *)(*a2 + 32) == 1)
  {
    uint64_t v2 = *(uint64_t **)(*a2 + 24);
    if (v2)
    {
      uint64_t v3 = *v2;
      if (*v2)
      {
        if (*(char *)(v3 + 263) < 0)
        {
          if (!*(void *)(v3 + 248)) {
            return result;
          }
        }
        else if (!*(unsigned char *)(v3 + 263))
        {
          return result;
        }
        uint64_t v5 = *(uint64_t **)(result + 8);
        {
          if (result) {
            operator new();
          }
        }
        uint64_t v6 = mdm::Allocator::instance(void)::alloc;
        uint64_t v7 = *a2;
        uint64_t v16 = *(void *)(v3 + 264);
        if (*(char *)(v3 + 263) < 0)
        {
          unint64_t result = (uint64_t)std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)__src, *(void **)(v3 + 240), *(void *)(v3 + 248));
        }
        else
        {
          *(_OWORD *)__src = *(_OWORD *)(v3 + 240);
          uint64_t v15 = *(void *)(v3 + 256);
        }
        uint64_t v19 = 0;
        uint64_t v20 = v6;
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        unint64_t v8 = (void *)HIBYTE(v15);
        int v9 = SHIBYTE(v15);
        char v10 = __src[1];
        if (v15 < 0) {
          unint64_t v8 = __src[1];
        }
        if (!v8)
        {
          unsigned __int8 v13 = -1;
          goto LABEL_23;
        }
        uint64_t v12 = (unsigned __int8 *)v5[48];
        unint64_t v11 = v5[49];
        if (v12 != (unsigned __int8 *)v11)
        {
          unsigned __int8 v13 = 0;
          while (1)
          {
            unint64_t result = md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>::operator==(v12, (unsigned __int8 *)__src);
            if (result) {
              break;
            }
            ++v13;
            v12 += 64;
            if (v12 == (unsigned __int8 *)v11)
            {
              if (v13 <= 0x64u) {
                goto LABEL_27;
              }
              *(unsigned char *)(v7 + 38) = -1;
              if ((v9 & 0x80000000) == 0) {
                return result;
              }
              return (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)v16 + 40))(v16, __src[0], v15 & 0x7FFFFFFFFFFFFFFFLL);
            }
          }
LABEL_23:
          *(unsigned char *)(v7 + 38) = v13;
          if ((v9 & 0x80000000) == 0) {
            return result;
          }
          return (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)v16 + 40))(v16, __src[0], v15 & 0x7FFFFFFFFFFFFFFFLL);
        }
        unsigned __int8 v13 = 0;
LABEL_27:
        if (v11 >= v5[50])
        {
          unint64_t result = std::vector<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,geo::StdAllocator<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,mdm::Allocator>>::__emplace_back_slow_path<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>> const&>(v5 + 48, (long long *)__src);
        }
        else
        {
          if (v11)
          {
            *(void *)(v11 + 24) = v16;
            if (v9 < 0)
            {
              std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)v11, __src[0], (unint64_t)v10);
            }
            else
            {
              *(_OWORD *)unint64_t v11 = *(_OWORD *)__src;
              *(void *)(v11 + 16) = v15;
            }
            *(void *)(v11 + 48) = 0;
            *(void *)(v11 + 56) = v6;
            *(void *)(v11 + 32) = 0;
            *(void *)(v11 + 40) = 0;
          }
          unint64_t result = v11 + 64;
          v5[49] = v11 + 64;
        }
        v5[49] = result;
        *(unsigned char *)(v7 + 38) = v13;
        if (v9 < 0) {
          return (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)v16 + 40))(v16, __src[0], v15 & 0x7FFFFFFFFFFFFFFFLL);
        }
      }
    }
  }
  return result;
}

void sub_1A205585C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  *(void *)(v13 + 392) = v12;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 & 0x7FFFFFFFFFFFFFFFLL);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::UniLineLabelFeature::updateText(std::shared_ptr<md::LabelExternalRoadFeature> const&,BOOL)::$_0,std::allocator<md::UniLineLabelFeature::updateText(std::shared_ptr<md::LabelExternalRoadFeature> const&,BOOL)::$_0>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51E2A8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::UniLineLabelFeature::updateText(std::shared_ptr<md::LabelExternalRoadFeature> const&,BOOL)::$_0,std::allocator<md::UniLineLabelFeature::updateText(std::shared_ptr<md::LabelExternalRoadFeature> const&,BOOL)::$_0>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::__clone(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF51E2A8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::UniLineLabelFeature::updateText(std::shared_ptr<md::LabelExternalRoadFeature> const&,BOOL)::$_0,std::allocator<md::UniLineLabelFeature::updateText(std::shared_ptr<md::LabelExternalRoadFeature> const&,BOOL)::$_0>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::~__func()
{
}

__n128 std::__function::__func<md::UniLineLabelFeature::updateText(void const*,BOOL)::$_0,std::allocator<md::UniLineLabelFeature::updateText(void const*,BOOL)::$_0>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51E260;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::UniLineLabelFeature::updateText(void const*,BOOL)::$_0,std::allocator<md::UniLineLabelFeature::updateText(void const*,BOOL)::$_0>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF51E260;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::UniLineLabelFeature::updateText(void const*,BOOL)::$_0,std::allocator<md::UniLineLabelFeature::updateText(void const*,BOOL)::$_0>,void ()(std::unique_ptr<md::LabelLineSegment> const&)>::~__func()
{
}

uint64_t *std::vector<md::LabelShieldEntry,geo::StdAllocator<md::LabelShieldEntry,mdm::Allocator>>::~vector[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 25) < 0) {
          (*(void (**)(void, void, uint64_t))(**(void **)(v3 - 24) + 40))(*(void *)(v3 - 24), *(void *)(v3 - 48), *(void *)(v3 - 32) & 0x7FFFFFFFFFFFFFFFLL);
        }
        v3 -= 48;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v4, a1[2] - v4);
  }
  return a1;
}

unsigned __int8 *md::UniLineLabelFeature::newAnnotationPart(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned char *a4, void *a5)
{
  uint64_t v10 = *(void *)(a3 + 8);
  uint64_t v11 = *(unsigned int *)(a3 + 48);
  unsigned __int8 v12 = atomic_load((unsigned __int8 *)(a3 + 1240));
  uint64_t v13 = (unsigned __int8 **)(*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t))(*(void *)v10 + 552))(v10, v11, 0, v12 & 1, a2);
  uint64_t v14 = *v13;
  if (!*v13) {
    return v14;
  }
  uint64_t v15 = (uint64_t *)v13;
  uint64_t v16 = (float *)*((void *)v14 + 36);
  if (v16)
  {
    if (vabds_f32(v16[2], *((float *)v14 + 26)) >= 0.01)
    {
      md::LabelStyle::updateStyleGroup<md::LabelTextStyleGroup>(*v13, (uint64_t)v16, 6);
      uint64_t v16 = (float *)*((void *)v14 + 36);
    }
  }
  else
  {
    uint64_t v16 = (float *)md::LabelStyle::prepareStyleGroup<md::LabelTextStyleGroup>((uint64_t)*v13, 6);
    *((void *)v14 + 36) = v16;
  }
  uint64_t v17 = *(void *)v16;
  if (*(float *)(*(void *)v16 + 100) <= 0.0 || !(*(uint64_t (**)(void))(*(void *)*a5 + 120))()) {
    return 0;
  }
  char v51 = *(unsigned char *)(a3 + 404);
  uint64_t v18 = (*(uint64_t (**)(void))(*(void *)*a5 + 120))();
  uint64_t v19 = *v15;
  uint64_t v20 = *(void *)(*v15 + 264);
  if (!v20)
  {
    unsigned int v21 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>(*v15);
    uint64_t v20 = *v21;
    *(void *)(v19 + 264) = *v21;
  }
  if (*(_DWORD *)(v20 + 12)) {
    int v22 = *(_DWORD *)(v20 + 12);
  }
  else {
    int v22 = 4;
  }
  if (!v18)
  {
    LOBYTE(__src[0]) = 0;
    char v60 = 0;
    return 0;
  }
  unsigned int v23 = *(unsigned __int8 *)(v20 + 64);
  unint64_t v61 = 0;
  v62 = 0;
  unint64_t v24 = *(std::__shared_weak_count **)(v18 + 8);
  if (v24)
  {
    v62 = std::__shared_weak_count::lock(v24);
    if (v62) {
      unint64_t v61 = *(geo::codec::VectorTile **)v18;
    }
  }
  md::LabelFeature::tileAnnotationText(__src, &v61, *(_DWORD *)(v18 + 140), *(unsigned __int8 *)(v18 + 150), v22, v23);
  uint64_t v25 = v62;
  if (v62 && !atomic_fetch_add(&v62->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
  if (!v60) {
    return 0;
  }
  int v50 = a4;
  uint64_t v26 = (void *)HIBYTE(v55);
  int v27 = SHIBYTE(v55);
  unint64_t v28 = __src[1];
  if (v55 < 0) {
    uint64_t v26 = __src[1];
  }
  if (!v26)
  {
LABEL_29:
    unsigned __int8 v31 = -1;
    goto LABEL_30;
  }
  uint64_t v30 = (unsigned __int8 *)a1[48];
  unint64_t v29 = a1[49];
  if (v30 != (unsigned __int8 *)v29)
  {
    long long v49 = __src[1];
    unsigned __int8 v31 = 0;
    while ((md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>::operator==(v30, (unsigned __int8 *)__src) & 1) == 0)
    {
      ++v31;
      v30 += 64;
      if (v30 == (unsigned __int8 *)v29)
      {
        unint64_t v28 = v49;
        if (v31 <= 0x64u) {
          goto LABEL_34;
        }
        goto LABEL_29;
      }
    }
LABEL_30:
    if (!v60) {
      goto LABEL_49;
    }
    goto LABEL_45;
  }
  unsigned __int8 v31 = 0;
LABEL_34:
  if (v29 >= a1[50])
  {
    uint64_t v33 = std::vector<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,geo::StdAllocator<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,mdm::Allocator>>::__emplace_back_slow_path<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>> const&>(a1 + 48, (long long *)__src);
  }
  else
  {
    if (v29)
    {
      *(void *)(v29 + 24) = v56;
      if (v27 < 0)
      {
        std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)v29, __src[0], (unint64_t)v28);
      }
      else
      {
        long long v32 = *(_OWORD *)__src;
        *(void *)(v29 + 16) = v55;
        *(_OWORD *)unint64_t v29 = v32;
      }
      uint64_t v34 = (void **)(v29 + 32);
      *(void *)(v29 + 56) = v59;
      if (SHIBYTE(v58) < 0)
      {
        std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external(v34, (void *)v57, *((unint64_t *)&v57 + 1));
      }
      else
      {
        long long v35 = v57;
        *(void *)(v29 + 48) = v58;
        *(_OWORD *)uint64_t v34 = v35;
      }
    }
    uint64_t v33 = v29 + 64;
    a1[49] = v29 + 64;
  }
  a1[49] = v33;
  if (v60)
  {
LABEL_45:
    if (SHIBYTE(v58) < 0) {
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v59 + 40))(v59, v57, v58 & 0x7FFFFFFFFFFFFFFFLL);
    }
    if (SHIBYTE(v55) < 0) {
      (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v56 + 40))(v56, __src[0], v55 & 0x7FFFFFFFFFFFFFFFLL);
    }
  }
LABEL_49:
  if (v31 == 0xFF) {
    return 0;
  }
  unint64_t v36 = (*(uint64_t (**)(uint64_t *))(*a1 + 488))(a1);
  uint64_t v37 = (unsigned __int8 *)a1[20];
  uint64_t v38 = (unsigned __int8 *)a1[21];
  if (v36 > 0x6DB6DB6DB6DB6DB7 * ((v38 - v37) >> 3))
  {
    md::LabelFeature::updateTextVector((md::LabelFeature *)a1);
    uint64_t v37 = (unsigned __int8 *)a1[20];
    uint64_t v38 = (unsigned __int8 *)a1[21];
  }
  md::TextDataStore::textDataForZoom(__src, v37, v38, v31, v17 + 72);
  uint64_t v39 = __src[0];
  if (__src[0])
  {
    uint64_t v40 = (std::__shared_weak_count *)operator new(0xB0uLL);
    v40->__shared_owners_ = 0;
    v40->__shared_weak_owners_ = 0;
    v40->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582A90;
    unint64_t v61 = (geo::codec::VectorTile *)md::LabelText::LabelText((uint64_t)&v40[1], (uint64_t)v39, (uint64_t)__src[1], v51);
    v62 = v40;
    {
      operator new();
    }
    uint64_t v14 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                  + 16))(mdm::Allocator::instance(void)::alloc, 1488, 8);
    int v41 = (*(uint64_t (**)(uint64_t *))(*a1 + 264))(a1);
    uint64_t v42 = *v15;
    if (*v50)
    {
      char v43 = 0;
      char v44 = 0;
      __int16 v45 = 9;
    }
    else
    {
      char v43 = *(unsigned char *)(a3 + 317);
      char v44 = *(unsigned char *)(a3 + 318);
      __int16 v45 = *(_WORD *)(a3 + 320);
    }
    __int16 v53 = v45;
    v52[0] = v43;
    v52[1] = v44;
    v52[2] = 0;
    md::CurvedTextLabelPart::CurvedTextLabelPart((uint64_t)v14, v41, &v61, a2, a3, v42, a5, (uint64_t)v52, 0.0, v50, 1);
    (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)v14 + 176))(v14, 5);
    char v46 = v62;
    if (v62 && !atomic_fetch_add(&v62->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  uint64_t v47 = (std::__shared_weak_count *)__src[1];
  if (__src[1] && !atomic_fetch_add((atomic_ullong *volatile)__src[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
    std::__shared_weak_count::__release_weak(v47);
  }
  if (!v39) {
    return 0;
  }
  return v14;
}

void sub_1A2056128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  if (*(char *)(v9 + 23) < 0) {
    (*(void (**)(void, void, uint64_t))(**(void **)(v9 + 24) + 40))(*(void *)(v9 + 24), *(void *)v9, *(void *)(v9 + 16) & 0x7FFFFFFFFFFFFFFFLL);
  }
  *(void *)(v8 + 392) = v9;
  std::optional<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>>::~optional((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A205618C(mdm::Allocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  uint64_t v11 = mdm::Allocator::instance(a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v11 + 40))(v11, v8, 1488);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v9 - 96);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume((_Unwind_Exception *)a1);
}

void sub_1A20561EC(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 - 96);
  _Unwind_Resume(a1);
}

unsigned __int8 *md::UniLineLabelFeature::newTextAndAnnotationPart(md::LabelFeature *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5, void *a6)
{
  uint64_t v11 = (unsigned __int8 *)md::UniLineLabelFeature::newTextPart(a1, a2, a3, a4, a5, a6);
  unsigned __int8 v12 = md::UniLineLabelFeature::newAnnotationPart((uint64_t *)a1, a2, a3, a5, a6);
  uint64_t v13 = (uint64_t)v12;
  if (v11)
  {
    if (v12)
    {
      {
        operator new();
      }
      uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 16))(mdm::Allocator::instance(void)::alloc, 720, 8);
      md::LineTextWithAuxLabelPart::LineTextWithAuxLabelPart(v14, a6, v11, v13);
      return (unsigned __int8 *)v14;
    }
    else
    {
      return v11;
    }
  }
  return (unsigned __int8 *)v13;
}

void sub_1A2056328(mdm::Allocator *a1)
{
  uint64_t v3 = mdm::Allocator::instance(a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 40))(v3, v1, 720);
  _Unwind_Resume((_Unwind_Exception *)a1);
}

unsigned __int8 *md::UniLineLabelFeature::newTextAndShieldPart(md::LabelFeature *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5, void *a6)
{
  uint64_t v11 = (unsigned __int8 *)md::UniLineLabelFeature::newTextPart(a1, a2, a3, a4, a5, a6);
  uint64_t v12 = md::UniLineLabelFeature::newShieldPart((uint64_t)a1, a2, a3, a4, a6);
  uint64_t v13 = (md::LabelPart *)v12;
  if (v11)
  {
    if (v12)
    {
      (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v12 + 200))(&v18, v12);
      uint64_t v14 = v18;
      uint64_t v15 = v19;
      if (v18)
      {
        uint64_t v19 = v18;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v21 + 40))(v21, v18, v20 - v18);
      }
      if (v14 == v15)
      {
        {
          operator new();
        }
        uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                   + 16))(mdm::Allocator::instance(void)::alloc, 704, 8);
        md::MultipleShieldLabelPart::MultipleShieldLabelPart(v16, a6);
        if (v16) {
          md::CompositeLabelPart::addLabelPart(v16, v13);
        }
      }
      else
      {
        uint64_t v16 = (uint64_t)v13;
      }
      {
        operator new();
      }
      uint64_t v13 = (md::LabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                  + 16))(mdm::Allocator::instance(void)::alloc, 720, 8);
      md::LineTextWithAuxLabelPart::LineTextWithAuxLabelPart((uint64_t)v13, a6, v11, v16);
    }
    else
    {
      return v11;
    }
  }
  return (unsigned __int8 *)v13;
}

void sub_1A20565B8(mdm::Allocator *a1)
{
  uint64_t v3 = mdm::Allocator::instance(a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 40))(v3, v1, 704);
  _Unwind_Resume((_Unwind_Exception *)a1);
}

uint64_t md::UniLineLabelFeature::newArrowPart(uint64_t a1, uint64_t a2, md::LabelStyle *a3, void *a4, char a5)
{
  uint64_t v10 = *((void *)a3 + 33);
  if (v10)
  {
    int v11 = *(char *)(v10 + 95);
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    uint64_t v12 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)a3);
    uint64_t v10 = *v12;
    *((void *)a3 + 33) = *v12;
    int v11 = *(char *)(v10 + 95);
    if ((v11 & 0x80000000) == 0)
    {
LABEL_3:
      if ((_BYTE)v11) {
        goto LABEL_4;
      }
LABEL_8:
      int v13 = *(_DWORD *)(a1 + 196);
      BOOL v15 = v13 == 10 || (v13 - 1) < 4;
      if (v15) {
        uint64_t v16 = "roadArrow_hybrid";
      }
      else {
        uint64_t v16 = "roadArrow_standard";
      }
      {
        unsigned __int8 v31 = v16;
        uint64_t v16 = v31;
        if (v30) {
          operator new();
        }
      }
      uint64_t v36 = mdm::Allocator::instance(void)::alloc;
      if (v15) {
        size_t v17 = 16;
      }
      else {
        size_t v17 = 18;
      }
      HIBYTE(v35) = v17;
      memcpy(&__dst, v16, v17);
      *((unsigned char *)&__dst + v17) = 0;
      md::LabelStyle::namedIcon(&v32, a3, a1, a2, (void **)&__dst, 0);
      if (SHIBYTE(v35) < 0)
      {
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)v36 + 40))(v36, __dst, v35 & 0x7FFFFFFFFFFFFFFFLL);
        if (!v32) {
          goto LABEL_41;
        }
      }
      else if (!v32)
      {
        goto LABEL_41;
      }
      goto LABEL_23;
    }
  }
  if (!*(void *)(v10 + 80)) {
    goto LABEL_8;
  }
LABEL_4:
  md::LabelStyle::namedIcon(&v32, a3, a1, a2, (void **)(v10 + 72), 0);
  if (!v32)
  {
LABEL_41:
    uint64_t v18 = 0;
    unint64_t v28 = v33;
    if (!v33) {
      return v18;
    }
    goto LABEL_42;
  }
LABEL_23:
  {
    operator new();
  }
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 920, 8);
  md::IconLabelPart::IconLabelPart(v18, &v32);
  *(void *)uint64_t v19 = &unk_1EF5334F0;
  *(_OWORD *)(v19 + 768) = 0u;
  *(_OWORD *)(v19 + 784) = xmmword_1A28FD280;
  *(_DWORD *)(v19 + 800) = 1065353216;
  *(void *)(v19 + 804) = 0;
  *(void *)(v19 + 820) = 0;
  *(void *)(v19 + 812) = 0;
  *(_DWORD *)(v19 + 828) = 0;
  *(unsigned char *)(v19 + 832) = 9;
  *(_DWORD *)(v18 + 833) = 0;
  uint64_t v20 = (_OWORD *)(v19 + 840);
  *(void *)(v19 + 848) = 0;
  *(void *)(v19 + 840) = 0;
  *(_OWORD *)(v18 + 856) = xmmword_1A28FD280;
  *(_DWORD *)(v19 + 872) = 1065353216;
  *(void *)(v19 + 876) = 0;
  *(void *)(v19 + 892) = 0;
  *(void *)(v19 + 884) = 0;
  *(_DWORD *)(v19 + 900) = 0;
  *(unsigned char *)(v19 + 904) = 9;
  *(_DWORD *)(v18 + 905) = 0;
  *(_DWORD *)(v19 + 912) = 0;
  *(unsigned char *)(v19 + 916) = a5;
  *(unsigned char *)(v19 + 917) = 0;
  uint64_t v21 = *a4;
  uint64_t v22 = a4[1];
  if (v22)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
    unsigned int v23 = *(std::__shared_weak_count **)(v18 + 776);
    *(void *)(v18 + 768) = v21;
    *(void *)(v18 + 776) = v22;
    if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  else
  {
    *(void *)(v18 + 768) = v21;
    *(void *)(v18 + 776) = 0;
  }
  (*(void (**)(long long *__return_ptr))(*(void *)*a4 + 16))(&__dst);
  long long v24 = __dst;
  long long __dst = 0uLL;
  uint64_t v25 = *(std::__shared_weak_count **)(v18 + 848);
  *uint64_t v20 = v24;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
  uint64_t v26 = (std::__shared_weak_count *)*((void *)&__dst + 1);
  if (*((void *)&__dst + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&__dst + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
    if (*(unsigned char *)(v18 + 916)) {
      goto LABEL_35;
    }
  }
  else if (*(unsigned char *)(v18 + 916))
  {
LABEL_35:
    char v27 = 0;
    *(unsigned char *)(v18 + 664) = 2;
    goto LABEL_38;
  }
  char v27 = 1;
LABEL_38:
  *(unsigned char *)(v18 + 557) = v27;
  *(unsigned char *)(v18 + 656) = v27;
  (*(void (**)(uint64_t, uint64_t))(*(void *)v18 + 176))(v18, 1);
  unint64_t v28 = v33;
  if (!v33) {
    return v18;
  }
LABEL_42:
  if (!atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
  return v18;
}

void sub_1A2056B28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (SHIBYTE(a15) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a16 + 40))(a16, a13, a15 & 0x7FFFFFFFFFFFFFFFLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A2056B6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  int v13 = (std::__shared_weak_count *)*((void *)v11 + 106);
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  uint64_t v14 = (std::__shared_weak_count *)*((void *)v11 + 97);
  if (v14)
  {
    if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  md::IconLabelPart::~IconLabelPart(v11);
  uint64_t v16 = mdm::Allocator::instance(v15);
  (*(void (**)(uint64_t, md::IconLabelPart *, uint64_t))(*(void *)v16 + 40))(v16, v11, 920);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

unsigned __int8 *md::UniLineLabelFeature::newTextAndTravelArrowPart(md::LabelFeature *a1, uint64_t a2, uint64_t a3, md::LabelStyle *a4, unsigned char *a5, void *a6)
{
  uint64_t v10 = (unsigned __int8 *)md::UniLineLabelFeature::newTextPart(a1, a2, a3, (uint64_t)a4, a5, a6);
  uint64_t v11 = md::UniLineLabelFeature::newArrowPart(a2, a3, a4, a6, 0);
  uint64_t v12 = v11;
  if (v10)
  {
    if (v11)
    {
      {
        operator new();
      }
      uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 16))(mdm::Allocator::instance(void)::alloc, 720, 8);
      md::LineTextWithAuxLabelPart::LineTextWithAuxLabelPart(v13, a6, v10, v12);
      return (unsigned __int8 *)v13;
    }
    else
    {
      return v10;
    }
  }
  return (unsigned __int8 *)v12;
}

void sub_1A2056D74(mdm::Allocator *a1)
{
  uint64_t v3 = mdm::Allocator::instance(a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 40))(v3, v1, 720);
  _Unwind_Resume((_Unwind_Exception *)a1);
}

uint64_t std::optional<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>>::~optional(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    if (*(char *)(a1 + 55) < 0)
    {
      (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), *(void *)(a1 + 32), *(void *)(a1 + 48) & 0x7FFFFFFFFFFFFFFFLL);
      if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
        return a1;
      }
    }
    else if ((*(char *)(a1 + 23) & 0x80000000) == 0)
    {
      return a1;
    }
    (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), *(void *)a1, *(void *)(a1 + 16) & 0x7FFFFFFFFFFFFFFFLL);
  }
  return a1;
}

void md::UniLineLabelFeature::~UniLineLabelFeature(md::UniLineLabelFeature *this)
{
  *(void *)this = &unk_1EF53C978;
  *((void *)this + 55) = &unk_1EF53CC30;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 60);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 58);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 58);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::LineLabelFeature::~LineLabelFeature(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF53C978;
  *((void *)this + 55) = &unk_1EF53CC30;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 60);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 58);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 58);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::LineLabelFeature::~LineLabelFeature(this);
}

uint64_t *md::UniLineLabelFeature::UniLineLabelFeature(uint64_t *a1, uint64_t *a2, char a3, uint64_t a4)
{
  uint64_t v7 = md::LineLabelFeature::LineLabelFeature((uint64_t)a1, *(unsigned char *)(*a2 + 176), a3);
  *(void *)uint64_t v7 = &unk_1EF53C978;
  *(void *)(v7 + 440) = &unk_1EF53CC30;
  uint64_t v8 = *a2;
  *(unsigned char *)(v7 + 448) = *(unsigned char *)(*a2 + 176);
  *(_WORD *)(v7 + 449) = 0;
  *(void *)(v7 + 456) = v8;
  uint64_t v9 = a2[1];
  *(void *)(v7 + 464) = v9;
  if (v9)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    uint64_t v8 = a1[57];
  }
  a1[59] = 0;
  a1[60] = 0;
  a1[61] = 0;
  uint64_t v11 = *(void *)(v8 + 32);
  uint64_t v10 = *(void *)(v8 + 40);
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = (std::__shared_weak_count *)a1[53];
  a1[52] = v11;
  a1[53] = v10;
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    uint64_t v11 = a1[52];
  }
  if (!v11)
  {
    _ZNSt3__115allocate_sharedB8nn180100I22FeatureStyleAttributesNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v19);
    long long v16 = v19;
    long long v19 = 0uLL;
    size_t v17 = (std::__shared_weak_count *)a1[53];
    *((_OWORD *)a1 + 26) = v16;
    if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
    uint64_t v18 = (std::__shared_weak_count *)*((void *)&v19 + 1);
    if (*((void *)&v19 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v19 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  md::LabelLineStore::addExternalRoadFeature(a1[24], a2);
  uint64_t v13 = (unsigned __int8 *)a1[24];
  unsigned __int8 v14 = atomic_load(v13 + 80);
  if (v14) {
    md::LabelLineStore::consumeWorkUnits((md::LabelLineStore *)v13);
  }
  (*(void (**)(uint64_t *, uint64_t *, uint64_t))(*a1 + 40))(a1, a2, a4);
  return a1;
}

void sub_1A20572A4(_Unwind_Exception *a1)
{
  uint64_t v3 = (std::__shared_weak_count *)*((void *)v1 + 60);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)v1 + 58);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  md::LineLabelFeature::~LineLabelFeature(v1);
  _Unwind_Resume(a1);
}

uint64_t md::MercatorRouteCollider::computeRayBoundsOfRouteSectionWithinFrustum(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, int *a5, _OWORD *a6)
{
  uint64_t v9 = *(uint64_t ***)(a1 + 8);
  int v11 = *a5;
  int v10 = a5[1];
  id v12 = a3;
  if (![v12 pointCount]) {
    goto LABEL_9;
  }
  uint64_t v13 = *v9;
  unsigned __int8 v14 = v9[1];
  if (*v9 == v14) {
    goto LABEL_9;
  }
  uint64_t v15 = 0;
  do
  {
    uint64_t v17 = *v13;
    v13 += 2;
    uint64_t v16 = v17;
    if (*(id *)(v17 + 8) == v12) {
      uint64_t v15 = v16;
    }
  }
  while (v13 != v14);
  if (v15)
  {
    *a6 = xmmword_1A28FC720;
    v20[0] = md::RouteCollisionObject<md::MercatorPointSource>::segmentIndexForVertexIndex(v15, v11, 0);
    v20[1] = md::RouteCollisionObject<md::MercatorPointSource>::segmentIndexForVertexIndex(v15, v10, 1);
    md::RouteCollisionObject<md::MercatorPointSource>::computeRayBoundsWithinFrustum(a2, a4, *(void *)(v15 + 72), (unsigned __int16 *)v20, (uint64_t)a6);
    uint64_t v18 = 1;
  }
  else
  {
LABEL_9:
    uint64_t v18 = 0;
  }

  return v18;
}

void sub_1A2057438(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::RouteCollisionObject<md::MercatorPointSource>::segmentIndexForVertexIndex(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 48);
  if (*(void *)(a1 + 56) == v3)
  {
LABEL_7:
    int v10 = 0;
    unsigned __int16 v6 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    unsigned __int16 v6 = 0;
    unsigned int v7 = a2 - (a3 == 1);
    while (1)
    {
      id v8 = *(id *)(v3 + 8 * v5);
      if ([v8 startPointIndex] <= v7
        && [v8 endPointIndex] > v7)
      {
        break;
      }

      uint64_t v5 = ++v6;
      uint64_t v3 = *(void *)(a1 + 48);
      if (v6 >= (unint64_t)((*(void *)(a1 + 56) - v3) >> 3)) {
        goto LABEL_7;
      }
    }
    int v9 = v7 - [v8 startPointIndex];

    int v10 = v9 << 16;
  }
  return v10 | v6;
}

void sub_1A2057504(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::RouteCollisionObject<md::MercatorPointSource>::computeRayBoundsWithinFrustum(uint64_t result, uint64_t a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5)
{
  int v9 = (double *)result;
  __asm { FMOV            V0.2D, #0.5 }
  float64x2_t v31 = _Q0;
  while (!*(_DWORD *)a3)
  {
    unsigned int v15 = a4[2];
    unsigned int v16 = *(unsigned __int16 *)(a3 + 72);
    if (v15 < v16 || v15 == v16 && a4[3] < *(unsigned __int16 *)(a3 + 74)) {
      return result;
    }
    unsigned int v17 = *a4;
    unsigned int v18 = *(unsigned __int16 *)(a3 + 76);
    if (v17 > v18 || v17 == v18 && a4[1] > *(unsigned __int16 *)(a3 + 78)) {
      return result;
    }
    memset(&v32[1], 0, 32);
    v32[0] = *(_OWORD *)(a3 + 24);
    *(_OWORD *)((char *)&v32[1] + 8) = *(_OWORD *)(a3 + 40);
    __n128 result = geo::Intersect::encloses<double>(v9, (double *)v32);
    if (!result) {
      return result;
    }
    double v19 = *(double *)(a5 + 8);
    if (v19 >= *(double *)a5)
    {
      float64x2_t v20 = *(float64x2_t *)(a3 + 24);
      float64x2_t v21 = vsubq_f64(*(float64x2_t *)(a3 + 40), v20);
      float64x2_t v22 = *(float64x2_t *)(a2 + 24);
      double v23 = vaddvq_f64(vmulq_f64(v22, vsubq_f64(vmlaq_f64(v20, v31, v21), *(float64x2_t *)a2)))
          - *(double *)(a2 + 40) * *(double *)(a2 + 16);
      v20.f64[0] = vaddvq_f64(vmulq_f64(vabsq_f64(v22), vmaxnmq_f64(v21, (float64x2_t)0))) * 0.5;
      v21.f64[0] = v23 - v20.f64[0];
      double v24 = v20.f64[0] + v23;
      if (*(double *)a5 <= v21.f64[0] && v24 <= v19) {
        return result;
      }
    }
    __n128 result = md::RouteCollisionObject<md::MercatorPointSource>::computeRayBoundsWithinFrustum(v9, a2, *(void *)(a3 + 8), a4, a5);
    a3 = *(void *)(a3 + 16);
  }
  float64x2_t v26 = *(float64x2_t *)(a3 + 24);
  float64x2_t v27 = vsubq_f64(*(float64x2_t *)(a3 + 40), v26);
  float64x2_t v28 = *(float64x2_t *)(a2 + 24);
  double v29 = vaddvq_f64(vmulq_f64(v28, vsubq_f64(vmlaq_f64(v26, v31, v27), *(float64x2_t *)a2)))
      - *(double *)(a2 + 40) * *(double *)(a2 + 16);
  v26.f64[0] = vaddvq_f64(vmulq_f64(vabsq_f64(v28), vmaxnmq_f64(v27, (float64x2_t)0))) * 0.5;
  v27.f64[0] = v29 - v26.f64[0];
  v28.f64[1] = *(float64_t *)(a5 + 8);
  v28.f64[0] = v29 - v26.f64[0];
  v27.f64[1] = v29 + v26.f64[0];
  v30.f64[0] = *(float64_t *)a5;
  v30.f64[1] = v29 + v26.f64[0];
  *(int8x16_t *)a5 = vbslq_s8((int8x16_t)vcgtq_f64(v28, v30), *(int8x16_t *)a5, (int8x16_t)v27);
  return result;
}

void md::MercatorRouteCollider::intersectRouteWithFrustum(uint64_t a1@<X0>, double *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  id v8 = *(uint64_t ***)(a1 + 8);
  id v9 = a3;
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  id v15 = v9;
  if ([v9 pointCount])
  {
    int v10 = *v8;
    int v11 = v8[1];
    if (*v8 != v11)
    {
      uint64_t v12 = 0;
      do
      {
        uint64_t v14 = *v10;
        v10 += 2;
        uint64_t v13 = v14;
        if (*(id *)(v14 + 8) == v15) {
          uint64_t v12 = v13;
        }
      }
      while (v10 != v11);
      if (v12) {
        md::RouteCollisionObject<md::MercatorPointSource>::intersectWithFrustum(v12, a2, a4, (uint64_t)a5);
      }
    }
  }
}

void sub_1A20577BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = *(void **)v10;
  if (*(void *)v10)
  {
    *(void *)(v10 + 8) = v12;
    operator delete(v12);
  }

  _Unwind_Resume(a1);
}

void md::RouteCollisionObject<md::MercatorPointSource>::intersectWithFrustum(uint64_t a1, double *a2, uint64_t a3, uint64_t a4)
{
  v100 = 0;
  v101 = 0;
  uint64_t v102 = 0;
  unsigned int v8 = *(_DWORD *)(a3 + 8);
  unsigned int v9 = *(_DWORD *)a3;
  if (v8 > *(_DWORD *)a3
    || (int v10 = *(_DWORD *)a3, v8 == v9) && (int v10 = *(_DWORD *)(a3 + 8), *(float *)(a3 + 12) > *(float *)(a3 + 4)))
  {
    if (v9 >= [*(id *)(a1 + 8) pointCount] - 1) {
      return;
    }
    int v10 = *(_DWORD *)a3;
  }
  unsigned int v11 = md::RouteCollisionObject<md::MercatorPointSource>::segmentIndexForVertexIndex(a1, v10, 0);
  unsigned int v12 = v11;
  uint64_t v97 = a3;
  if (*(float *)(a3 + 12) <= 0.0) {
    int v13 = *(_DWORD *)(a3 + 8);
  }
  else {
    int v13 = *(_DWORD *)(a3 + 8) + 1;
  }
  unsigned int v14 = (unsigned __int16)v11;
  unsigned int v15 = md::RouteCollisionObject<md::MercatorPointSource>::segmentIndexForVertexIndex(a1, v13, 1);
  if (v14 < (unsigned __int16)v15
    || (int v16 = v12, v14 == (unsigned __int16)v15) && (int v16 = v12, HIWORD(v12) < HIWORD(v15)))
  {
    int v16 = v15;
  }
  v99[0] = md::MercatorPointSource::segmentWorldPoint(*(void *)(a1 + 128), v12, 0);
  v99[1] = v17;
  v99[2] = 0.0;
  md::MercatorPointSource::segmentWorldPoint(*(void *)(a1 + 128), v16, 1);
  BOOL v18 = geo::Intersect::encloses<double>(a2, v99);
  double v19 = *(_DWORD **)(a1 + 72);
  v98[0] = v12;
  v98[1] = v16;
  md::RouteCollisionObject<md::MercatorPointSource>::intersectWithFrustumEdges(a1, a2, v19, (unsigned __int16 *)v98, (uint64_t)&v100);
  float64x2_t v21 = v100;
  float64x2_t v22 = v101;
  unint64_t v23 = ((char *)v101 - (char *)v100) >> 3;
  unint64_t v24 = 126 - 2 * __clz(v23);
  unint64_t v25 = (char *)v101 - (char *)v100;
  if (v101 == v100) {
    uint64_t v26 = 0;
  }
  else {
    uint64_t v26 = v24;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,geo::PolylineCoordinate *,false>(v100, v101, v26, 1, v20);
  uint64_t v27 = v97;
  if (v25 < 9)
  {
    double v29 = v21;
    goto LABEL_29;
  }
  unsigned int v28 = *((_DWORD *)v21 + 2);
  double v29 = v21;
  if (v28 >= *(_DWORD *)v97 && (v28 != *(_DWORD *)v97 || v21[3] >= *(float *)(v97 + 4))) {
    goto LABEL_25;
  }
  uint64_t v30 = (char *)v22 - (char *)(v21 + 4);
  if (v22 != v21 + 4) {
    memmove(v21, v21 + 4, (char *)v22 - (char *)(v21 + 4));
  }
  v22 -= 4;
  v101 = (float *)((char *)v21 + v30);
  if ((unint64_t)v30 >= 9)
  {
    unint64_t v23 = v30 >> 3;
LABEL_25:
    float v31 = v21[2 * v23 - 4];
    unsigned int v32 = *(_DWORD *)(v97 + 8);
    if (LODWORD(v31) > v32 || LODWORD(v31) == v32 && v21[2 * v23 - 3] > *(float *)(v97 + 12))
    {
      v22 -= 4;
      v101 = v22;
      uint64_t v27 = v97;
    }
  }
LABEL_29:
  if (v22 == v29)
  {
    float64x2_t v22 = v29;
  }
  else
  {
    if (*(_DWORD *)v29 < *(_DWORD *)v27 || *(_DWORD *)v29 == *(_DWORD *)v27 && v29[1] < *(float *)(v27 + 4)) {
      *(void *)double v29 = *(void *)v27;
    }
    unsigned int v33 = *((_DWORD *)v22 - 2);
    unsigned int v34 = *(_DWORD *)(v27 + 8);
    if (v33 > v34 || v33 == v34 && *(v22 - 1) > *(float *)(v27 + 12))
    {
      *((void *)v22 - 1) = *(void *)(v27 + 8);
      double v29 = v100;
      float64x2_t v22 = v101;
    }
  }
  unint64_t v35 = ((unint64_t)((((char *)v22 - (char *)v29) >> 3) + 1) >> 1) + v18;
  uint64_t v36 = *(char **)a4;
  v96 = v29;
  if (v35 > (uint64_t)(*(void *)(a4 + 16) - *(void *)a4) >> 4)
  {
    if (v35 >> 60) {
      abort();
    }
    uint64_t v37 = *(unsigned char **)(a4 + 8);
    uint64_t v38 = (char *)operator new(16 * v35);
    uint64_t v39 = &v38[(v37 - v36) & 0xFFFFFFFFFFFFFFF0];
    uint64_t v40 = v39;
    if (v37 != v36)
    {
      int v41 = &v38[(v37 - v36) & 0xFFFFFFFFFFFFFFF0];
      do
      {
        uint64_t v40 = v41 - 16;
        *((_OWORD *)v41 - 1) = *((_OWORD *)v37 - 1);
        v37 -= 16;
        v41 -= 16;
      }
      while (v37 != v36);
    }
    *(void *)a4 = v40;
    *(void *)(a4 + 8) = v39;
    *(void *)(a4 + 16) = &v38[16 * v35];
    double v29 = v96;
    if (v36) {
      operator delete(v36);
    }
  }
  uint64_t v42 = v29;
  if (!v18) {
    goto LABEL_75;
  }
  if (v29 != v22)
  {
    char v44 = *(char **)(a4 + 8);
    unint64_t v43 = *(void *)(a4 + 16);
    if ((unint64_t)v44 >= v43)
    {
      int v50 = *(char **)a4;
      uint64_t v51 = (uint64_t)&v44[-*(void *)a4] >> 4;
      unint64_t v52 = v51 + 1;
      if ((unint64_t)(v51 + 1) >> 60) {
        abort();
      }
      uint64_t v53 = v43 - (void)v50;
      if (v53 >> 3 > v52) {
        unint64_t v52 = v53 >> 3;
      }
      if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v54 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v54 = v52;
      }
      if (v54 >> 60) {
        goto LABEL_123;
      }
      uint64_t v55 = (char *)operator new(16 * v54);
      uint64_t v56 = &v55[16 * v51];
      double v29 = v96;
      uint64_t v57 = *(void *)v96;
      *(void *)uint64_t v56 = *(void *)v27;
      *((void *)v56 + 1) = v57;
      char v46 = v56 + 16;
      if (v44 == v50)
      {
        uint64_t v58 = v56;
      }
      else
      {
        do
        {
          uint64_t v58 = v56 - 16;
          *((_OWORD *)v56 - 1) = *((_OWORD *)v44 - 1);
          v44 -= 16;
          v56 -= 16;
        }
        while (v44 != v50);
      }
      *(void *)a4 = v58;
      *(void *)(a4 + 8) = v46;
      *(void *)(a4 + 16) = &v55[16 * v54];
      if (v50) {
        operator delete(v50);
      }
    }
    else
    {
      uint64_t v45 = *(void *)v29;
      *(void *)char v44 = *(void *)v27;
      *((void *)v44 + 1) = v45;
      char v46 = v44 + 16;
    }
    uint64_t v42 = v29 + 2;
    *(void *)(a4 + 8) = v46;
LABEL_75:
    if (v42 == v22) {
      goto LABEL_112;
    }
    while (1)
    {
      long long v67 = (uint64_t *)(v42 + 2);
      int v69 = *(_DWORD *)v42;
      int v68 = *((_DWORD *)v42 + 1);
      if (v42 + 2 == v22) {
        break;
      }
      uint64_t v71 = *(char **)(a4 + 8);
      unint64_t v70 = *(void *)(a4 + 16);
      if ((unint64_t)v71 < v70)
      {
        uint64_t v65 = *v67;
        *(_DWORD *)uint64_t v71 = v69;
        *((_DWORD *)v71 + 1) = v68;
        *((void *)v71 + 1) = v65;
        long long v66 = v71 + 16;
      }
      else
      {
        uint64_t v72 = *(char **)a4;
        uint64_t v73 = (uint64_t)&v71[-*(void *)a4] >> 4;
        unint64_t v74 = v73 + 1;
        if ((unint64_t)(v73 + 1) >> 60) {
          abort();
        }
        uint64_t v75 = v70 - (void)v72;
        if (v75 >> 3 > v74) {
          unint64_t v74 = v75 >> 3;
        }
        if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v76 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v76 = v74;
        }
        if (v76 >> 60) {
          goto LABEL_123;
        }
        v77 = (char *)operator new(16 * v76);
        uint64_t v78 = *v67;
        double v79 = &v77[16 * v73];
        *(_DWORD *)double v79 = v69;
        *((_DWORD *)v79 + 1) = v68;
        *((void *)v79 + 1) = v78;
        if (v71 == v72)
        {
          double v81 = &v77[16 * v73];
        }
        else
        {
          double v80 = &v77[16 * v73];
          do
          {
            double v81 = v80 - 16;
            *((_OWORD *)v80 - 1) = *((_OWORD *)v71 - 1);
            v71 -= 16;
            v80 -= 16;
          }
          while (v71 != v72);
        }
        long long v66 = v79 + 16;
        *(void *)a4 = v81;
        *(void *)(a4 + 8) = v79 + 16;
        *(void *)(a4 + 16) = &v77[16 * v76];
        if (v72) {
          operator delete(v72);
        }
      }
      v42 += 4;
      *(void *)(a4 + 8) = v66;
      if (v42 == v22) {
        goto LABEL_111;
      }
    }
    unint64_t v83 = *(char **)(a4 + 8);
    unint64_t v82 = *(void *)(a4 + 16);
    if ((unint64_t)v83 < v82)
    {
      uint64_t v84 = *(void *)(v97 + 8);
      *(_DWORD *)unint64_t v83 = v69;
      *((_DWORD *)v83 + 1) = v68;
      *((void *)v83 + 1) = v84;
      v85 = v83 + 16;
      goto LABEL_110;
    }
    unsigned int v86 = *(char **)a4;
    uint64_t v87 = (uint64_t)&v83[-*(void *)a4] >> 4;
    unint64_t v88 = v87 + 1;
    if ((unint64_t)(v87 + 1) >> 60) {
      abort();
    }
    uint64_t v89 = v82 - (void)v86;
    if (v89 >> 3 > v88) {
      unint64_t v88 = v89 >> 3;
    }
    if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v90 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v90 = v88;
    }
    if (!(v90 >> 60))
    {
      v91 = (char *)operator new(16 * v90);
      v92 = &v91[16 * v87];
      uint64_t v93 = *(void *)(v97 + 8);
      *(_DWORD *)v92 = v69;
      *((_DWORD *)v92 + 1) = v68;
      *((void *)v92 + 1) = v93;
      v85 = v92 + 16;
      if (v83 == v86)
      {
        unint64_t v94 = v92;
      }
      else
      {
        do
        {
          unint64_t v94 = v92 - 16;
          *((_OWORD *)v92 - 1) = *((_OWORD *)v83 - 1);
          v83 -= 16;
          v92 -= 16;
        }
        while (v83 != v86);
      }
      *(void *)a4 = v94;
      *(void *)(a4 + 8) = v85;
      *(void *)(a4 + 16) = &v91[16 * v90];
      if (v86) {
        operator delete(v86);
      }
LABEL_110:
      *(void *)(a4 + 8) = v85;
LABEL_111:
      double v29 = v96;
LABEL_112:
      if (!v29) {
        return;
      }
      goto LABEL_113;
    }
LABEL_123:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  char v48 = *(char **)(a4 + 8);
  unint64_t v47 = *(void *)(a4 + 16);
  if ((unint64_t)v48 >= v47)
  {
    uint64_t v59 = *(char **)a4;
    uint64_t v60 = (uint64_t)&v48[-*(void *)a4] >> 4;
    unint64_t v61 = v60 + 1;
    if ((unint64_t)(v60 + 1) >> 60) {
      abort();
    }
    uint64_t v62 = v47 - (void)v59;
    if (v62 >> 3 > v61) {
      unint64_t v61 = v62 >> 3;
    }
    if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v63 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v63 = v61;
    }
    if (v63)
    {
      if (v63 >> 60) {
        goto LABEL_123;
      }
      v64 = (char *)operator new(16 * v63);
    }
    else
    {
      v64 = 0;
    }
    id v95 = &v64[16 * v60];
    *(_OWORD *)id v95 = *(_OWORD *)v27;
    long long v49 = v95 + 16;
    if (v48 != v59)
    {
      do
      {
        *((_OWORD *)v95 - 1) = *((_OWORD *)v48 - 1);
        v95 -= 16;
        v48 -= 16;
      }
      while (v48 != v59);
      char v48 = *(char **)a4;
    }
    *(void *)a4 = v95;
    *(void *)(a4 + 8) = v49;
    *(void *)(a4 + 16) = &v64[16 * v63];
    if (v48) {
      operator delete(v48);
    }
  }
  else
  {
    *(_OWORD *)char v48 = *(_OWORD *)v27;
    long long v49 = v48 + 16;
  }
  *(void *)(a4 + 8) = v49;
  double v29 = v100;
  if (v100)
  {
LABEL_113:
    v101 = v29;
    operator delete(v29);
  }
}

void sub_1A2057EF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (v17) {
    operator delete(v17);
  }
  _Unwind_Resume(exception_object);
}

double md::MercatorPointSource::segmentWorldPoint(uint64_t a1, int a2, int a3)
{
  unsigned __int16 v4 = HIWORD(a2);
  id v5 = *(id *)(a1 + 8 * (unsigned __int16)a2);
  uint64_t v6 = [v5 points];
  if (v5)
  {
    [v5 bounds];
    double v7 = v12;
    double v8 = v13;
  }
  else
  {
    double v8 = 0.0;
    double v7 = 0.0;
  }
  unsigned int v9 = v4;
  if (a3 == 1) {
    unsigned int v9 = v4 + 1;
  }
  double v10 = (v7 + v8 * *(float *)(v6 + 12 * v9)) / *MEMORY[0x1E4F63F10];

  return v10;
}

void sub_1A2058030(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL geo::Intersect::encloses<double>(double *a1, double *a2)
{
  double v2 = *a2;
  double v3 = a2[1];
  double v4 = a2[2];
  if (a1[3] + *a1 * *a2 + a1[1] * v3 + a1[2] * v4 < 0.0) {
    return 0;
  }
  if (a1[7] + a1[4] * v2 + a1[5] * v3 + a1[6] * v4 < 0.0) {
    return 0;
  }
  if (a1[11] + a1[8] * v2 + a1[9] * v3 + a1[10] * v4 < 0.0) {
    return 0;
  }
  if (a1[15] + a1[12] * v2 + a1[13] * v3 + a1[14] * v4 < 0.0) {
    return 0;
  }
  if (a1[19] + a1[16] * v2 + a1[17] * v3 + a1[18] * v4 >= 0.0) {
    return a1[23] + a1[20] * v2 + a1[21] * v3 + a1[22] * v4 >= 0.0;
  }
  return 0;
}

void md::RouteCollisionObject<md::MercatorPointSource>::intersectWithFrustumEdges(uint64_t a1, double *a2, _DWORD *a3, unsigned __int16 *a4, uint64_t a5)
{
  double v7 = a3;
  if (*a3)
  {
LABEL_10:
    unint64_t v14 = v7[14];
    if (!v14) {
      return;
    }
    uint64_t v15 = 0;
    while (1)
    {
      double v17 = (unsigned __int16 *)(*((void *)v7 + 8) + 4 * v15);
      uint64_t v18 = *v17;
      unsigned int v19 = v17[1];
      unsigned int v20 = *a4;
      if (v20 >= v18 && (v20 != v18 || a4[1] > v19)) {
        goto LABEL_15;
      }
      unsigned int v22 = a4[2];
      if (v22 <= v18 && (v22 != v18 || a4[3] < v19)) {
        goto LABEL_15;
      }
      double v24 = md::MercatorPointSource::segmentWorldPoint(*(void *)(a1 + 128), v18 | (v19 << 16), 0);
      double v26 = v25;
      double v27 = md::MercatorPointSource::segmentWorldPoint(*(void *)(a1 + 128), v18 | (v19 << 16), 1);
      *(double *)double v79 = v24;
      *((double *)v79 + 1) = v26;
      *(void *)&v79[1] = 0;
      *((double *)&v79[1] + 1) = v27 - v24;
      *(double *)&v79[2] = v28 - v26;
      *((void *)&v79[2] + 1) = 0;
      double v77 = 0.0;
      double v78 = 0.0;
      if (geo::Intersect::internal::intersection<double,std::array<gm::Plane3<double>,6ul>>(a2, (double *)v79, 2u, &v78, &v77))break; {
LABEL_14:
      }
      unint64_t v14 = v7[14];
LABEL_15:
      if (++v15 >= v14) {
        return;
      }
    }
    int v29 = [*(id *)(*(void *)(a1 + 48) + 8 * v18) startPointIndex] + v19;
    if (v78 <= 0.0)
    {
LABEL_59:
      if (v77 >= 1.0) {
        goto LABEL_14;
      }
      float v54 = v77;
      if (v54 >= 1.0)
      {
        v29 += vcvtms_u32_f32(v54);
        float v54 = v54 - floorf(v54);
      }
      uint64_t v56 = *(float **)(a5 + 8);
      unint64_t v55 = *(void *)(a5 + 16);
      if ((unint64_t)v56 < v55)
      {
        *(_DWORD *)uint64_t v56 = v29;
        v56[1] = v54;
        int v16 = (char *)(v56 + 2);
LABEL_13:
        *(void *)(a5 + 8) = v16;
        goto LABEL_14;
      }
      uint64_t v57 = *(float **)a5;
      uint64_t v58 = (uint64_t)v56 - *(void *)a5;
      uint64_t v59 = v58 >> 3;
      unint64_t v60 = (v58 >> 3) + 1;
      if (v60 >> 61) {
LABEL_85:
      }
        abort();
      uint64_t v61 = v55 - (void)v57;
      if (v61 >> 2 > v60) {
        unint64_t v60 = v61 >> 2;
      }
      if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v60 = 0x1FFFFFFFFFFFFFFFLL;
      }
      unint64_t v76 = v60;
      if (v60)
      {
        uint64_t v74 = (uint64_t)v56 - *(void *)a5;
        if (v60 >> 61) {
LABEL_86:
        }
          std::__throw_bad_array_new_length[abi:nn180100]();
        uint64_t v62 = (char *)operator new(8 * v60);
        uint64_t v58 = v74;
      }
      else
      {
        uint64_t v62 = 0;
      }
      unint64_t v63 = (float *)&v62[8 * v59];
      *(_DWORD *)unint64_t v63 = v29;
      v63[1] = v54;
      if (v56 == v57)
      {
        uint64_t v57 = v56;
        uint64_t v65 = &v62[8 * v59];
      }
      else
      {
        unint64_t v64 = (char *)(v56 - 2) - (char *)v57;
        if (v64 < 0x58)
        {
          uint64_t v65 = &v62[8 * v59];
          goto LABEL_80;
        }
        uint64_t v65 = &v62[8 * v59];
        if ((unint64_t)((char *)v56 - &v62[v58]) < 0x20) {
          goto LABEL_89;
        }
        uint64_t v66 = (v64 >> 3) + 1;
        long long v67 = &v62[8 * v59 - 16];
        int v68 = v56 - 4;
        uint64_t v69 = v66 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v70 = *(_OWORD *)v68;
          *((_OWORD *)v67 - 1) = *((_OWORD *)v68 - 1);
          *(_OWORD *)long long v67 = v70;
          v67 -= 32;
          v68 -= 8;
          v69 -= 4;
        }
        while (v69);
        uint64_t v65 = (char *)&v63[-2 * (v66 & 0x3FFFFFFFFFFFFFFCLL)];
        v56 -= 2 * (v66 & 0x3FFFFFFFFFFFFFFCLL);
        if (v66 != (v66 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_89:
          do
          {
LABEL_80:
            uint64_t v71 = *((void *)v56 - 1);
            v56 -= 2;
            *((void *)v65 - 1) = v71;
            v65 -= 8;
          }
          while (v56 != v57);
          uint64_t v57 = *(float **)a5;
        }
      }
      int v16 = (char *)(v63 + 2);
      *(void *)a5 = v65;
      *(void *)(a5 + 8) = v63 + 2;
      *(void *)(a5 + 16) = &v62[8 * v76];
      if (v57) {
        operator delete(v57);
      }
      goto LABEL_13;
    }
    float v30 = v78;
    int v31 = v29 + vcvtms_u32_f32(v30);
    float v32 = v30 - floorf(v30);
    if (v30 >= 1.0) {
      float v33 = v32;
    }
    else {
      float v33 = v78;
    }
    if (v30 >= 1.0) {
      int v34 = v31;
    }
    else {
      int v34 = v29;
    }
    uint64_t v36 = *(float **)(a5 + 8);
    unint64_t v35 = *(void *)(a5 + 16);
    if ((unint64_t)v36 < v35)
    {
      *(_DWORD *)uint64_t v36 = v34;
      v36[1] = v33;
      uint64_t v37 = (char *)(v36 + 2);
LABEL_58:
      *(void *)(a5 + 8) = v37;
      goto LABEL_59;
    }
    uint64_t v38 = *(float **)a5;
    uint64_t v39 = (uint64_t)v36 - *(void *)a5;
    uint64_t v40 = v39 >> 3;
    unint64_t v41 = (v39 >> 3) + 1;
    if (v41 >> 61) {
      goto LABEL_85;
    }
    uint64_t v42 = v35 - (void)v38;
    if (v42 >> 2 > v41) {
      unint64_t v41 = v42 >> 2;
    }
    if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v41 = 0x1FFFFFFFFFFFFFFFLL;
    }
    unint64_t v75 = v41;
    if (v41)
    {
      uint64_t v72 = (uint64_t)v36 - *(void *)a5;
      int v73 = v34;
      if (v41 >> 61) {
        goto LABEL_86;
      }
      unint64_t v43 = (char *)operator new(8 * v41);
      int v34 = v73;
      uint64_t v39 = v72;
    }
    else
    {
      unint64_t v43 = 0;
    }
    char v44 = (float *)&v43[8 * v40];
    *(_DWORD *)char v44 = v34;
    v44[1] = v33;
    if (v36 == v38)
    {
      uint64_t v38 = v36;
      unint64_t v47 = &v43[8 * v40];
      unint64_t v46 = v75;
      goto LABEL_56;
    }
    unint64_t v45 = (char *)(v36 - 2) - (char *)v38;
    unint64_t v46 = v75;
    if (v45 >= 0x58)
    {
      unint64_t v47 = &v43[8 * v40];
      if ((unint64_t)((char *)v36 - &v43[v39]) >= 0x20)
      {
        uint64_t v48 = (v45 >> 3) + 1;
        long long v49 = &v43[8 * v40 - 16];
        int v50 = v36 - 4;
        uint64_t v51 = v48 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v52 = *(_OWORD *)v50;
          *((_OWORD *)v49 - 1) = *((_OWORD *)v50 - 1);
          *(_OWORD *)long long v49 = v52;
          v49 -= 32;
          v50 -= 8;
          v51 -= 4;
        }
        while (v51);
        unint64_t v47 = (char *)&v44[-2 * (v48 & 0x3FFFFFFFFFFFFFFCLL)];
        v36 -= 2 * (v48 & 0x3FFFFFFFFFFFFFFCLL);
        if (v48 == (v48 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_56;
        }
      }
    }
    else
    {
      unint64_t v47 = &v43[8 * v40];
    }
    do
    {
      uint64_t v53 = *((void *)v36 - 1);
      v36 -= 2;
      *((void *)v47 - 1) = v53;
      v47 -= 8;
    }
    while (v36 != v38);
    uint64_t v38 = *(float **)a5;
LABEL_56:
    uint64_t v37 = (char *)(v44 + 2);
    *(void *)a5 = v47;
    *(void *)(a5 + 8) = v44 + 2;
    *(void *)(a5 + 16) = &v43[8 * v46];
    if (v38) {
      operator delete(v38);
    }
    goto LABEL_58;
  }
  while (1)
  {
    unsigned int v10 = a4[2];
    unsigned int v11 = *((unsigned __int16 *)v7 + 36);
    if (v10 < v11 || v10 == v11 && a4[3] < *((unsigned __int16 *)v7 + 37)) {
      break;
    }
    unsigned int v12 = *a4;
    unsigned int v13 = *((unsigned __int16 *)v7 + 38);
    if (v12 > v13 || v12 == v13 && a4[1] > *((unsigned __int16 *)v7 + 39)) {
      break;
    }
    memset(&v79[1], 0, 32);
    v79[0] = *(_OWORD *)(v7 + 6);
    *(_OWORD *)((char *)&v79[1] + 8) = *(_OWORD *)(v7 + 10);
    if (geo::Intersect::encloses<double>(a2, (double *)v79) != 2) {
      break;
    }
    md::RouteCollisionObject<md::MercatorPointSource>::intersectWithFrustumEdges(a1, a2, *((void *)v7 + 1), a4, a5);
    double v7 = (_DWORD *)*((void *)v7 + 2);
    if (*v7) {
      goto LABEL_10;
    }
  }
}

float std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,geo::PolylineCoordinate *,false>(float *a1, float *a2, uint64_t a3, char a4, float result)
{
float std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,geo::PolylineCoordinate *>(float *a1, unsigned int *a2, float *a3)
{
  unsigned int v3 = *a2;
  if (*a2 < *(_DWORD *)a1 || v3 == *(_DWORD *)a1 && (float result = *((float *)a2 + 1), result < a1[1]))
  {
    if (*(_DWORD *)a3 < v3 || *(_DWORD *)a3 == v3 && (float result = a3[1], result < *((float *)a2 + 1)))
    {
      uint64_t v5 = *(void *)a1;
      *(void *)a1 = *(void *)a3;
LABEL_17:
      *(void *)a3 = v5;
      return result;
    }
    uint64_t v5 = *(void *)a1;
    *(void *)a1 = *(void *)a2;
    *(void *)a2 = v5;
    if (*(_DWORD *)a3 < v5
      || *(_DWORD *)a3 == v5 && (float result = *((float *)&v5 + 1), a3[1] < *((float *)&v5 + 1)))
    {
      *(void *)a2 = *(void *)a3;
      goto LABEL_17;
    }
  }
  else if (*(_DWORD *)a3 < v3 || *(_DWORD *)a3 == v3 && (float result = a3[1], result < *((float *)a2 + 1)))
  {
    uint64_t v6 = *(void *)a2;
    *(void *)a2 = *(void *)a3;
    *(void *)a3 = v6;
    if (*a2 < *(_DWORD *)a1 || *a2 == *(_DWORD *)a1 && (float result = *((float *)a2 + 1), result < a1[1]))
    {
      uint64_t v7 = *(void *)a1;
      *(void *)a1 = *(void *)a2;
      *(void *)a2 = v7;
    }
  }
  return result;
}

float std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,geo::PolylineCoordinate *>(float *a1, unsigned int *a2, float *a3, float *a4, float *a5)
{
  float result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,geo::PolylineCoordinate *>(a1, a2, a3);
  if (*(_DWORD *)a4 < *(_DWORD *)a3 || *(_DWORD *)a4 == *(_DWORD *)a3 && (float result = a4[1], result < a3[1]))
  {
    uint64_t v11 = *(void *)a3;
    *(void *)a3 = *(void *)a4;
    *(void *)a4 = v11;
    if (*(_DWORD *)a3 < *a2 || *(_DWORD *)a3 == *a2 && (float result = a3[1], result < *((float *)a2 + 1)))
    {
      uint64_t v12 = *(void *)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v12;
      if (*a2 < *(_DWORD *)a1 || *a2 == *(_DWORD *)a1 && (float result = *((float *)a2 + 1), result < a1[1]))
      {
        uint64_t v13 = *(void *)a1;
        *(void *)a1 = *(void *)a2;
        *(void *)a2 = v13;
      }
    }
  }
  if (*(_DWORD *)a5 < *(_DWORD *)a4 || *(_DWORD *)a5 == *(_DWORD *)a4 && (float result = a5[1], result < a4[1]))
  {
    uint64_t v14 = *(void *)a4;
    *(void *)a4 = *(void *)a5;
    *(void *)a5 = v14;
    if (*(_DWORD *)a4 < *(_DWORD *)a3 || *(_DWORD *)a4 == *(_DWORD *)a3 && (float result = a4[1], result < a3[1]))
    {
      uint64_t v15 = *(void *)a3;
      *(void *)a3 = *(void *)a4;
      *(void *)a4 = v15;
      if (*(_DWORD *)a3 < *a2 || *(_DWORD *)a3 == *a2 && (float result = a3[1], result < *((float *)a2 + 1)))
      {
        uint64_t v16 = *(void *)a2;
        *(void *)a2 = *(void *)a3;
        *(void *)a3 = v16;
        if (*a2 < *(_DWORD *)a1 || *a2 == *(_DWORD *)a1 && (float result = *((float *)a2 + 1), result < a1[1]))
        {
          uint64_t v17 = *(void *)a1;
          *(void *)a1 = *(void *)a2;
          *(void *)a2 = v17;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,geo::PolylineCoordinate *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(_DWORD *)(a2 - 8);
      if (v6 < *(_DWORD *)a1 || v6 == *(_DWORD *)a1 && *(float *)(a2 - 4) < *(float *)(a1 + 4))
      {
        uint64_t v7 = *(void *)a1;
        *(void *)a1 = *(void *)(a2 - 8);
        *(void *)(a2 - 8) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,geo::PolylineCoordinate *>((float *)a1, (unsigned int *)(a1 + 8), (float *)(a2 - 8));
      return 1;
    case 4:
      uint64_t v17 = (uint64_t *)(a1 + 16);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,geo::PolylineCoordinate *>((float *)a1, (unsigned int *)(a1 + 8), (float *)(a1 + 16));
      unsigned int v18 = *(_DWORD *)(a2 - 8);
      unsigned int v19 = *(_DWORD *)(a1 + 16);
      if (v18 < v19 || v18 == v19 && *(float *)(a2 - 4) < *(float *)(a1 + 20))
      {
        uint64_t v20 = *v17;
        *uint64_t v17 = *(void *)(a2 - 8);
        *(void *)(a2 - 8) = v20;
        unsigned int v21 = *(_DWORD *)(a1 + 8);
        if (*(_DWORD *)v17 < v21 || *(_DWORD *)v17 == v21 && *(float *)(a1 + 20) < *(float *)(a1 + 12))
        {
          uint64_t v23 = *(void *)(a1 + 8);
          uint64_t v22 = *(void *)(a1 + 16);
          *(void *)(a1 + 8) = v22;
          *(void *)(a1 + 16) = v23;
          if (*(_DWORD *)a1 > v22
            || *(_DWORD *)a1 == v22 && *(float *)(a1 + 4) > *((float *)&v22 + 1))
          {
            uint64_t v24 = *(void *)a1;
            *(void *)a1 = v22;
            *(void *)(a1 + 8) = v24;
          }
        }
      }
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,geo::PolylineCoordinate *>((float *)a1, (unsigned int *)(a1 + 8), (float *)(a1 + 16), (float *)(a1 + 24), (float *)(a2 - 8));
      return 1;
    default:
      uint64_t v8 = a1 + 16;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,geo::PolylineCoordinate *>((float *)a1, (unsigned int *)(a1 + 8), (float *)(a1 + 16));
      uint64_t v9 = a1 + 24;
      if (a1 + 24 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    unsigned int v13 = *(_DWORD *)v9;
    if (*(_DWORD *)v9 < *(_DWORD *)v8) {
      break;
    }
    if (v13 == *(_DWORD *)v8)
    {
      float v14 = *(float *)(v9 + 4);
      if (v14 < *(float *)(v8 + 4)) {
        goto LABEL_11;
      }
    }
LABEL_8:
    uint64_t v8 = v9;
    v10 += 8;
    v9 += 8;
    if (v9 == a2) {
      return 1;
    }
  }
  float v14 = *(float *)(v9 + 4);
LABEL_11:
  *(void *)uint64_t v9 = *(void *)v8;
  uint64_t v12 = a1;
  if (v8 != a1)
  {
    uint64_t v15 = v10;
    while (1)
    {
      unsigned int v16 = *(_DWORD *)(a1 + v15 + 8);
      if (v13 >= v16)
      {
        if (v13 != v16)
        {
          uint64_t v12 = v8;
          goto LABEL_7;
        }
        if (*(float *)(a1 + v15 + 12) <= v14) {
          break;
        }
      }
      v8 -= 8;
      *(void *)(a1 + v15 + 16) = *(void *)(a1 + v15 + 8);
      v15 -= 8;
      if (v15 == -16)
      {
        uint64_t v12 = a1;
        goto LABEL_7;
      }
    }
    uint64_t v12 = a1 + v15 + 16;
  }
LABEL_7:
  *(_DWORD *)uint64_t v12 = v13;
  *(float *)(v12 + 4) = v14;
  if (++v11 != 8) {
    goto LABEL_8;
  }
  return v9 + 8 == a2;
}

void md::MercatorRouteCollider::intersectRouteWithFrustum(uint64_t a1@<X0>, double *a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  unsigned int v6 = *(uint64_t ***)(a1 + 8);
  id v7 = a3;
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  uint64_t v8 = *v6;
  uint64_t v9 = v6[1];
  if (*v6 != v9)
  {
    uint64_t v10 = 0;
    do
    {
      uint64_t v12 = *v8;
      v8 += 2;
      uint64_t v11 = v12;
      if (*(id *)(v12 + 8) == v7) {
        uint64_t v10 = v11;
      }
    }
    while (v8 != v9);
    if (v10)
    {
      id v13 = v7;
      uint64_t v14 = 0;
      int v15 = [v7 pointCount] - 1;
      int v16 = 0;
      md::RouteCollisionObject<md::MercatorPointSource>::intersectWithFrustum(v10, a2, (uint64_t)&v14, (uint64_t)a4);
      id v7 = v13;
    }
  }
}

void sub_1A2059600(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = *(void **)v10;
  if (*(void *)v10)
  {
    *(void *)(v10 + 8) = v12;
    operator delete(v12);
  }

  _Unwind_Resume(a1);
}

void md::MercatorRouteCollider::~MercatorRouteCollider(md::MercatorRouteCollider *this)
{
  uint64_t v1 = (void **)*((void *)this + 1);
  *(void *)this = &unk_1EF53FA10;
  *((void *)this + 1) = 0;
  if (v1)
  {
    double v2 = (char *)*v1;
    if (*v1)
    {
      unsigned int v3 = (char *)v1[1];
      uint64_t v4 = *v1;
      if (v3 != v2)
      {
        do
        {
          uint64_t v5 = (std::__shared_weak_count *)*((void *)v3 - 1);
          if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
          v3 -= 16;
        }
        while (v3 != v2);
        uint64_t v4 = *v1;
      }
      v1[1] = v2;
      operator delete(v4);
    }
    MEMORY[0x1A6239270](v1, 0x20C40960023A9);
  }
  JUMPOUT(0x1A6239270);
}

{
  void **v1;
  char *v2;
  char *v3;
  void *v4;
  std::__shared_weak_count *v5;

  uint64_t v1 = (void **)*((void *)this + 1);
  *(void *)this = &unk_1EF53FA10;
  *((void *)this + 1) = 0;
  if (v1)
  {
    double v2 = (char *)*v1;
    if (*v1)
    {
      unsigned int v3 = (char *)v1[1];
      uint64_t v4 = *v1;
      if (v3 != v2)
      {
        do
        {
          uint64_t v5 = (std::__shared_weak_count *)*((void *)v3 - 1);
          if (v5)
          {
            if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
              std::__shared_weak_count::__release_weak(v5);
            }
          }
          v3 -= 16;
        }
        while (v3 != v2);
        uint64_t v4 = *v1;
      }
      v1[1] = v2;
      operator delete(v4);
    }
    MEMORY[0x1A6239270](v1, 0x20C40960023A9);
  }
}

uint64_t md::GeocentricRouteCollider::computeRayBoundsOfRouteSectionWithinFrustum(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, int *a5, _OWORD *a6)
{
  uint64_t v9 = *(uint64_t ***)(a1 + 8);
  int v11 = *a5;
  int v10 = a5[1];
  id v12 = a3;
  if (![v12 pointCount]) {
    goto LABEL_9;
  }
  id v13 = *v9;
  uint64_t v14 = v9[1];
  if (*v9 == v14) {
    goto LABEL_9;
  }
  uint64_t v15 = 0;
  do
  {
    uint64_t v17 = *v13;
    v13 += 2;
    uint64_t v16 = v17;
    if (*(id *)(v17 + 8) == v12) {
      uint64_t v15 = v16;
    }
  }
  while (v13 != v14);
  if (v15)
  {
    *a6 = xmmword_1A28FC720;
    v20[0] = md::RouteCollisionObject<md::GeocentricPointSource>::segmentIndexForVertexIndex(v15, v11, 0);
    v20[1] = md::RouteCollisionObject<md::GeocentricPointSource>::segmentIndexForVertexIndex(v15, v10, 1);
    md::RouteCollisionObject<md::GeocentricPointSource>::computeRayBoundsWithinFrustum(a2, a4, *(void *)(v15 + 72), (unsigned __int16 *)v20, (uint64_t)a6);
    uint64_t v18 = 1;
  }
  else
  {
LABEL_9:
    uint64_t v18 = 0;
  }

  return v18;
}

void sub_1A2059910(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::RouteCollisionObject<md::GeocentricPointSource>::segmentIndexForVertexIndex(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 48);
  if (*(void *)(a1 + 56) == v3)
  {
LABEL_7:
    int v10 = 0;
    unsigned __int16 v6 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    unsigned __int16 v6 = 0;
    unsigned int v7 = a2 - (a3 == 1);
    while (1)
    {
      id v8 = *(id *)(v3 + 8 * v5);
      if ([v8 startPointIndex] <= v7
        && [v8 endPointIndex] > v7)
      {
        break;
      }

      uint64_t v5 = ++v6;
      uint64_t v3 = *(void *)(a1 + 48);
      if (v6 >= (unint64_t)((*(void *)(a1 + 56) - v3) >> 3)) {
        goto LABEL_7;
      }
    }
    int v9 = v7 - [v8 startPointIndex];

    int v10 = v9 << 16;
  }
  return v10 | v6;
}

void sub_1A20599DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::RouteCollisionObject<md::GeocentricPointSource>::computeRayBoundsWithinFrustum(uint64_t result, uint64_t a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5)
{
  int v9 = (double *)result;
  __asm { FMOV            V0.2D, #0.5 }
  float64x2_t v45 = _Q0;
  while (!*(_DWORD *)a3)
  {
    unsigned int v15 = a4[2];
    unsigned int v16 = *(unsigned __int16 *)(a3 + 88);
    if (v15 < v16 || v15 == v16 && a4[3] < *(unsigned __int16 *)(a3 + 90)) {
      return result;
    }
    unsigned int v17 = *a4;
    unsigned int v18 = *(unsigned __int16 *)(a3 + 92);
    if (v17 > v18 || v17 == v18 && a4[1] > *(unsigned __int16 *)(a3 + 94)) {
      return result;
    }
    long long v46 = *(_OWORD *)(a3 + 24);
    uint64_t v47 = *(void *)(a3 + 40);
    long long v48 = *(_OWORD *)(a3 + 48);
    uint64_t v49 = *(void *)(a3 + 64);
    BOOL result = geo::Intersect::encloses<double>(v9, (double *)&v46);
    if (!result) {
      return result;
    }
    double v19 = *(double *)(a5 + 8);
    if (v19 >= *(double *)a5)
    {
      double v20 = *(double *)(a3 + 24);
      double v21 = *(double *)(a3 + 48) - v20;
      double v22 = *(double *)(a2 + 24);
      float64x2_t v23 = *(float64x2_t *)(a3 + 32);
      float64x2_t v24 = vsubq_f64(*(float64x2_t *)(a3 + 56), v23);
      float64x2_t v25 = *(float64x2_t *)(a2 + 32);
      float64x2_t v26 = vmulq_f64(v25, vsubq_f64(vmlaq_f64(v23, v45, v24), *(float64x2_t *)(a2 + 8)));
      float64_t v27 = v26.f64[0] + v22 * (v20 + v21 * 0.5 - *(double *)a2) + v26.f64[1];
      float64x2_t v28 = vmulq_f64(vabsq_f64(v25), vmaxnmq_f64(v24, (float64x2_t)0));
      float64_t v29 = (v28.f64[0] + fabs(v22) * fmax(v21, 0.0) + v28.f64[1]) * 0.5;
      float64_t v30 = v27 - v29;
      double v31 = v29 + v27;
      if (*(double *)a5 <= v30 && v31 <= v19) {
        return result;
      }
    }
    BOOL result = md::RouteCollisionObject<md::GeocentricPointSource>::computeRayBoundsWithinFrustum(v9, a2, *(void *)(a3 + 8), a4, a5);
    a3 = *(void *)(a3 + 16);
  }
  double v33 = *(double *)(a3 + 24);
  double v34 = *(double *)(a3 + 48) - v33;
  double v35 = *(double *)(a2 + 24);
  float64x2_t v36 = *(float64x2_t *)(a3 + 32);
  float64x2_t v37 = vsubq_f64(*(float64x2_t *)(a3 + 56), v36);
  float64x2_t v38 = *(float64x2_t *)(a2 + 32);
  float64x2_t v39 = vmulq_f64(v38, vsubq_f64(vmlaq_f64(v36, v45, v37), *(float64x2_t *)(a2 + 8)));
  float64_t v40 = v39.f64[0] + v35 * (v33 + v34 * 0.5 - *(double *)a2) + v39.f64[1];
  float64x2_t v41 = vmulq_f64(vabsq_f64(v38), vmaxnmq_f64(v37, (float64x2_t)0));
  float64_t v42 = (v41.f64[0] + fabs(v35) * fmax(v34, 0.0) + v41.f64[1]) * 0.5;
  *(double *)v43.i64 = v40 - v42;
  v44.f64[1] = *(float64_t *)(a5 + 8);
  v44.f64[0] = v40 - v42;
  *(double *)&v43.i64[1] = v40 + v42;
  v41.f64[0] = *(float64_t *)a5;
  v41.f64[1] = v40 + v42;
  *(int8x16_t *)a5 = vbslq_s8((int8x16_t)vcgtq_f64(v44, v41), *(int8x16_t *)a5, v43);
  return result;
}

void md::GeocentricRouteCollider::intersectRouteWithFrustum(uint64_t a1@<X0>, double *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  id v8 = *(uint64_t ***)(a1 + 8);
  id v9 = a3;
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  id v15 = v9;
  if ([v9 pointCount])
  {
    int v10 = *v8;
    int v11 = v8[1];
    if (*v8 != v11)
    {
      uint64_t v12 = 0;
      do
      {
        uint64_t v14 = *v10;
        v10 += 2;
        uint64_t v13 = v14;
        if (*(id *)(v14 + 8) == v15) {
          uint64_t v12 = v13;
        }
      }
      while (v10 != v11);
      if (v12) {
        md::RouteCollisionObject<md::GeocentricPointSource>::intersectWithFrustum(v12, a2, a4, (uint64_t)a5);
      }
    }
  }
}

void sub_1A2059CE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = *(void **)v10;
  if (*(void *)v10)
  {
    *(void *)(v10 + 8) = v12;
    operator delete(v12);
  }

  _Unwind_Resume(a1);
}

void md::RouteCollisionObject<md::GeocentricPointSource>::intersectWithFrustum(uint64_t a1, double *a2, uint64_t a3, uint64_t a4)
{
  v101 = 0;
  uint64_t v102 = 0;
  uint64_t v103 = 0;
  unsigned int v8 = *(_DWORD *)(a3 + 8);
  unsigned int v9 = *(_DWORD *)a3;
  if (v8 > *(_DWORD *)a3
    || (int v10 = *(_DWORD *)a3, v8 == v9) && (int v10 = *(_DWORD *)(a3 + 8), *(float *)(a3 + 12) > *(float *)(a3 + 4)))
  {
    if (v9 >= [*(id *)(a1 + 8) pointCount] - 1) {
      return;
    }
    int v10 = *(_DWORD *)a3;
  }
  unsigned int v11 = md::RouteCollisionObject<md::GeocentricPointSource>::segmentIndexForVertexIndex(a1, v10, 0);
  unsigned int v12 = v11;
  uint64_t v98 = a3;
  if (*(float *)(a3 + 12) <= 0.0) {
    int v13 = *(_DWORD *)(a3 + 8);
  }
  else {
    int v13 = *(_DWORD *)(a3 + 8) + 1;
  }
  unsigned int v14 = (unsigned __int16)v11;
  unsigned int v15 = md::RouteCollisionObject<md::GeocentricPointSource>::segmentIndexForVertexIndex(a1, v13, 1);
  if (v14 < (unsigned __int16)v15
    || (int v16 = v12, v14 == (unsigned __int16)v15) && (int v16 = v12, HIWORD(v12) < HIWORD(v15)))
  {
    int v16 = v15;
  }
  v100[0] = md::GeocentricPointSource::segmentWorldPoint(*(void *)(a1 + 128), v12, 0);
  v100[1] = v17;
  v100[2] = v18;
  md::GeocentricPointSource::segmentWorldPoint(*(void *)(a1 + 128), v16, 1);
  BOOL v19 = geo::Intersect::encloses<double>(a2, v100);
  double v20 = *(_DWORD **)(a1 + 72);
  v99[0] = v12;
  v99[1] = v16;
  md::RouteCollisionObject<md::GeocentricPointSource>::intersectWithFrustumEdges(a1, a2, v20, (unsigned __int16 *)v99, (uint64_t)&v101);
  double v22 = v101;
  float64x2_t v23 = v102;
  unint64_t v24 = ((char *)v102 - (char *)v101) >> 3;
  unint64_t v25 = 126 - 2 * __clz(v24);
  unint64_t v26 = (char *)v102 - (char *)v101;
  if (v102 == v101) {
    uint64_t v27 = 0;
  }
  else {
    uint64_t v27 = v25;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,geo::PolylineCoordinate *,false>(v101, v102, v27, 1, v21);
  uint64_t v28 = v98;
  if (v26 < 9)
  {
    float64_t v30 = v22;
    goto LABEL_29;
  }
  unsigned int v29 = *((_DWORD *)v22 + 2);
  float64_t v30 = v22;
  if (v29 >= *(_DWORD *)v98 && (v29 != *(_DWORD *)v98 || v22[3] >= *(float *)(v98 + 4))) {
    goto LABEL_25;
  }
  uint64_t v31 = (char *)v23 - (char *)(v22 + 4);
  if (v23 != v22 + 4) {
    memmove(v22, v22 + 4, (char *)v23 - (char *)(v22 + 4));
  }
  v23 -= 4;
  uint64_t v102 = (float *)((char *)v22 + v31);
  if ((unint64_t)v31 >= 9)
  {
    unint64_t v24 = v31 >> 3;
LABEL_25:
    float v32 = v22[2 * v24 - 4];
    unsigned int v33 = *(_DWORD *)(v98 + 8);
    if (LODWORD(v32) > v33 || LODWORD(v32) == v33 && v22[2 * v24 - 3] > *(float *)(v98 + 12))
    {
      v23 -= 4;
      uint64_t v102 = v23;
      uint64_t v28 = v98;
    }
  }
LABEL_29:
  if (v23 == v30)
  {
    float64x2_t v23 = v30;
  }
  else
  {
    if (*(_DWORD *)v30 < *(_DWORD *)v28 || *(_DWORD *)v30 == *(_DWORD *)v28 && v30[1] < *(float *)(v28 + 4)) {
      *(void *)float64_t v30 = *(void *)v28;
    }
    unsigned int v34 = *((_DWORD *)v23 - 2);
    unsigned int v35 = *(_DWORD *)(v28 + 8);
    if (v34 > v35 || v34 == v35 && *(v23 - 1) > *(float *)(v28 + 12))
    {
      *((void *)v23 - 1) = *(void *)(v28 + 8);
      float64_t v30 = v101;
      float64x2_t v23 = v102;
    }
  }
  unint64_t v36 = ((unint64_t)((((char *)v23 - (char *)v30) >> 3) + 1) >> 1) + v19;
  float64x2_t v37 = *(char **)a4;
  uint64_t v97 = v30;
  if (v36 > (uint64_t)(*(void *)(a4 + 16) - *(void *)a4) >> 4)
  {
    if (v36 >> 60) {
      abort();
    }
    float64x2_t v38 = *(unsigned char **)(a4 + 8);
    float64x2_t v39 = (char *)operator new(16 * v36);
    float64_t v40 = &v39[(v38 - v37) & 0xFFFFFFFFFFFFFFF0];
    float64x2_t v41 = v40;
    if (v38 != v37)
    {
      float64_t v42 = &v39[(v38 - v37) & 0xFFFFFFFFFFFFFFF0];
      do
      {
        float64x2_t v41 = v42 - 16;
        *((_OWORD *)v42 - 1) = *((_OWORD *)v38 - 1);
        v38 -= 16;
        v42 -= 16;
      }
      while (v38 != v37);
    }
    *(void *)a4 = v41;
    *(void *)(a4 + 8) = v40;
    *(void *)(a4 + 16) = &v39[16 * v36];
    float64_t v30 = v97;
    if (v37) {
      operator delete(v37);
    }
  }
  int8x16_t v43 = v30;
  if (!v19) {
    goto LABEL_75;
  }
  if (v30 != v23)
  {
    float64x2_t v45 = *(char **)(a4 + 8);
    unint64_t v44 = *(void *)(a4 + 16);
    if ((unint64_t)v45 >= v44)
    {
      uint64_t v51 = *(char **)a4;
      uint64_t v52 = (uint64_t)&v45[-*(void *)a4] >> 4;
      unint64_t v53 = v52 + 1;
      if ((unint64_t)(v52 + 1) >> 60) {
        abort();
      }
      uint64_t v54 = v44 - (void)v51;
      if (v54 >> 3 > v53) {
        unint64_t v53 = v54 >> 3;
      }
      if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v55 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v55 = v53;
      }
      if (v55 >> 60) {
        goto LABEL_123;
      }
      unint64_t v56 = (char *)operator new(16 * v55);
      unint64_t v57 = &v56[16 * v52];
      float64_t v30 = v97;
      uint64_t v58 = *(void *)v97;
      *(void *)unint64_t v57 = *(void *)v28;
      *((void *)v57 + 1) = v58;
      uint64_t v47 = v57 + 16;
      if (v45 == v51)
      {
        unint64_t v59 = v57;
      }
      else
      {
        do
        {
          unint64_t v59 = v57 - 16;
          *((_OWORD *)v57 - 1) = *((_OWORD *)v45 - 1);
          v45 -= 16;
          v57 -= 16;
        }
        while (v45 != v51);
      }
      *(void *)a4 = v59;
      *(void *)(a4 + 8) = v47;
      *(void *)(a4 + 16) = &v56[16 * v55];
      if (v51) {
        operator delete(v51);
      }
    }
    else
    {
      uint64_t v46 = *(void *)v30;
      *(void *)float64x2_t v45 = *(void *)v28;
      *((void *)v45 + 1) = v46;
      uint64_t v47 = v45 + 16;
    }
    int8x16_t v43 = v30 + 2;
    *(void *)(a4 + 8) = v47;
LABEL_75:
    if (v43 == v23) {
      goto LABEL_112;
    }
    while (1)
    {
      unsigned int v68 = (uint64_t *)(v43 + 2);
      int v70 = *(_DWORD *)v43;
      int v69 = *((_DWORD *)v43 + 1);
      if (v43 + 2 == v23) {
        break;
      }
      uint64_t v72 = *(char **)(a4 + 8);
      unint64_t v71 = *(void *)(a4 + 16);
      if ((unint64_t)v72 < v71)
      {
        uint64_t v66 = *v68;
        *(_DWORD *)uint64_t v72 = v70;
        *((_DWORD *)v72 + 1) = v69;
        *((void *)v72 + 1) = v66;
        unint64_t v67 = v72 + 16;
      }
      else
      {
        unsigned int v73 = *(char **)a4;
        uint64_t v74 = (uint64_t)&v72[-*(void *)a4] >> 4;
        unint64_t v75 = v74 + 1;
        if ((unint64_t)(v74 + 1) >> 60) {
          abort();
        }
        uint64_t v76 = v71 - (void)v73;
        if (v76 >> 3 > v75) {
          unint64_t v75 = v76 >> 3;
        }
        if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v77 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v77 = v75;
        }
        if (v77 >> 60) {
          goto LABEL_123;
        }
        unint64_t v78 = (char *)operator new(16 * v77);
        uint64_t v79 = *v68;
        uint64_t v80 = &v78[16 * v74];
        *(_DWORD *)uint64_t v80 = v70;
        *((_DWORD *)v80 + 1) = v69;
        *((void *)v80 + 1) = v79;
        if (v72 == v73)
        {
          uint64_t v82 = &v78[16 * v74];
        }
        else
        {
          uint64_t v81 = &v78[16 * v74];
          do
          {
            uint64_t v82 = v81 - 16;
            *((_OWORD *)v81 - 1) = *((_OWORD *)v72 - 1);
            v72 -= 16;
            v81 -= 16;
          }
          while (v72 != v73);
        }
        unint64_t v67 = v80 + 16;
        *(void *)a4 = v82;
        *(void *)(a4 + 8) = v80 + 16;
        *(void *)(a4 + 16) = &v78[16 * v77];
        if (v73) {
          operator delete(v73);
        }
      }
      v43 += 4;
      *(void *)(a4 + 8) = v67;
      if (v43 == v23) {
        goto LABEL_111;
      }
    }
    uint64_t v84 = *(char **)(a4 + 8);
    unint64_t v83 = *(void *)(a4 + 16);
    if ((unint64_t)v84 < v83)
    {
      uint64_t v85 = *(void *)(v98 + 8);
      *(_DWORD *)uint64_t v84 = v70;
      *((_DWORD *)v84 + 1) = v69;
      *((void *)v84 + 1) = v85;
      unint64_t v86 = v84 + 16;
      goto LABEL_110;
    }
    uint64_t v87 = *(char **)a4;
    uint64_t v88 = (uint64_t)&v84[-*(void *)a4] >> 4;
    unint64_t v89 = v88 + 1;
    if ((unint64_t)(v88 + 1) >> 60) {
      abort();
    }
    uint64_t v90 = v83 - (void)v87;
    if (v90 >> 3 > v89) {
      unint64_t v89 = v90 >> 3;
    }
    if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v91 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v91 = v89;
    }
    if (!(v91 >> 60))
    {
      unsigned int v92 = (char *)operator new(16 * v91);
      uint64_t v93 = &v92[16 * v88];
      uint64_t v94 = *(void *)(v98 + 8);
      *(_DWORD *)uint64_t v93 = v70;
      *((_DWORD *)v93 + 1) = v69;
      *((void *)v93 + 1) = v94;
      unint64_t v86 = v93 + 16;
      if (v84 == v87)
      {
        BOOL v95 = v93;
      }
      else
      {
        do
        {
          BOOL v95 = v93 - 16;
          *((_OWORD *)v93 - 1) = *((_OWORD *)v84 - 1);
          v84 -= 16;
          v93 -= 16;
        }
        while (v84 != v87);
      }
      *(void *)a4 = v95;
      *(void *)(a4 + 8) = v86;
      *(void *)(a4 + 16) = &v92[16 * v91];
      if (v87) {
        operator delete(v87);
      }
LABEL_110:
      *(void *)(a4 + 8) = v86;
LABEL_111:
      float64_t v30 = v97;
LABEL_112:
      if (!v30) {
        return;
      }
      goto LABEL_113;
    }
LABEL_123:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v49 = *(char **)(a4 + 8);
  unint64_t v48 = *(void *)(a4 + 16);
  if ((unint64_t)v49 >= v48)
  {
    uint64_t v60 = *(char **)a4;
    uint64_t v61 = (uint64_t)&v49[-*(void *)a4] >> 4;
    unint64_t v62 = v61 + 1;
    if ((unint64_t)(v61 + 1) >> 60) {
      abort();
    }
    uint64_t v63 = v48 - (void)v60;
    if (v63 >> 3 > v62) {
      unint64_t v62 = v63 >> 3;
    }
    if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v64 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v64 = v62;
    }
    if (v64)
    {
      if (v64 >> 60) {
        goto LABEL_123;
      }
      int64_t v65 = (char *)operator new(16 * v64);
    }
    else
    {
      int64_t v65 = 0;
    }
    v96 = &v65[16 * v61];
    *(_OWORD *)v96 = *(_OWORD *)v28;
    uint64_t v50 = v96 + 16;
    if (v49 != v60)
    {
      do
      {
        *((_OWORD *)v96 - 1) = *((_OWORD *)v49 - 1);
        v96 -= 16;
        v49 -= 16;
      }
      while (v49 != v60);
      uint64_t v49 = *(char **)a4;
    }
    *(void *)a4 = v96;
    *(void *)(a4 + 8) = v50;
    *(void *)(a4 + 16) = &v65[16 * v64];
    if (v49) {
      operator delete(v49);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v49 = *(_OWORD *)v28;
    uint64_t v50 = v49 + 16;
  }
  *(void *)(a4 + 8) = v50;
  float64_t v30 = v101;
  if (v101)
  {
LABEL_113:
    uint64_t v102 = v30;
    operator delete(v30);
  }
}

void sub_1A205A41C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (v17) {
    operator delete(v17);
  }
  _Unwind_Resume(exception_object);
}

double md::GeocentricPointSource::segmentWorldPoint(uint64_t a1, int a2, int a3)
{
  unsigned __int16 v4 = HIWORD(a2);
  id v5 = *(id *)(a1 + 8 * (unsigned __int16)a2);
  uint64_t v6 = [v5 points];
  if (v5)
  {
    [v5 bounds];
    double v7 = v22;
    double v8 = v21;
    double v10 = v23;
    double v9 = v24;
  }
  else
  {
    double v9 = 0.0;
    double v7 = 0.0;
    double v10 = 0.0;
    double v8 = 0.0;
  }
  unsigned int v11 = v4;
  if (a3 == 1) {
    unsigned int v11 = v4 + 1;
  }
  unsigned int v12 = (float *)(v6 + 12 * v11);
  long double v13 = (v8 + v10 * *v12) * 6.28318531 / *MEMORY[0x1E4F63F10];
  long double v14 = exp(3.14159265 - (v7 + v9 * (float)(1.0 - v12[1])) * 6.28318531 / *(double *)(MEMORY[0x1E4F63F10] + 8));
  double v15 = atan(v14) * 2.0 + -1.57079633;
  long double v16 = fmod(v13, 6.28318531);
  double v17 = fmod(v16 + 6.28318531, 6.28318531) + -3.14159265;
  __double2 v18 = __sincos_stret(v15);
  double v19 = 6378137.0
      / sqrt(v18.__sinval * v18.__sinval * -0.00669437999 + 1.0)
      * v18.__cosval
      * __sincos_stret(v17).__cosval;

  return v19;
}

void sub_1A205A604(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::RouteCollisionObject<md::GeocentricPointSource>::intersectWithFrustumEdges(uint64_t a1, double *a2, _DWORD *a3, unsigned __int16 *a4, uint64_t a5)
{
  double v7 = a3;
  if (*a3)
  {
LABEL_10:
    unint64_t v14 = v7[18];
    if (!v14) {
      return;
    }
    uint64_t v15 = 0;
    while (1)
    {
      double v17 = (unsigned __int16 *)(*((void *)v7 + 10) + 4 * v15);
      uint64_t v18 = *v17;
      unsigned int v19 = v17[1];
      unsigned int v20 = *a4;
      if (v20 >= v18 && (v20 != v18 || a4[1] > v19)) {
        goto LABEL_15;
      }
      unsigned int v22 = a4[2];
      if (v22 <= v18 && (v22 != v18 || a4[3] < v19)) {
        goto LABEL_15;
      }
      double v24 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(a1 + 128), v18 | (v19 << 16), 0);
      double v26 = v25;
      double v28 = v27;
      double v29 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(a1 + 128), v18 | (v19 << 16), 1);
      *(double *)&long long v82 = v24;
      *((double *)&v82 + 1) = v26;
      double v83 = v28;
      *(double *)&long long v84 = v29 - v24;
      *((double *)&v84 + 1) = v30 - v26;
      double v85 = v31 - v28;
      double v80 = 0.0;
      double v81 = 0.0;
      if (geo::Intersect::internal::intersection<double,std::array<gm::Plane3<double>,6ul>>(a2, (double *)&v82, 2u, &v81, &v80))break; {
LABEL_14:
      }
      unint64_t v14 = v7[18];
LABEL_15:
      if (++v15 >= v14) {
        return;
      }
    }
    int v32 = [*(id *)(*(void *)(a1 + 48) + 8 * v18) startPointIndex] + v19;
    if (v81 <= 0.0)
    {
LABEL_59:
      if (v80 >= 1.0) {
        goto LABEL_14;
      }
      float v57 = v80;
      if (v57 >= 1.0)
      {
        v32 += vcvtms_u32_f32(v57);
        float v57 = v57 - floorf(v57);
      }
      unint64_t v59 = *(float **)(a5 + 8);
      unint64_t v58 = *(void *)(a5 + 16);
      if ((unint64_t)v59 < v58)
      {
        *(_DWORD *)unint64_t v59 = v32;
        v59[1] = v57;
        long double v16 = (char *)(v59 + 2);
LABEL_13:
        *(void *)(a5 + 8) = v16;
        goto LABEL_14;
      }
      uint64_t v60 = *(float **)a5;
      uint64_t v61 = (uint64_t)v59 - *(void *)a5;
      uint64_t v62 = v61 >> 3;
      unint64_t v63 = (v61 >> 3) + 1;
      if (v63 >> 61) {
LABEL_85:
      }
        abort();
      uint64_t v64 = v58 - (void)v60;
      if (v64 >> 2 > v63) {
        unint64_t v63 = v64 >> 2;
      }
      if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
      }
      unint64_t v79 = v63;
      if (v63)
      {
        uint64_t v77 = (uint64_t)v59 - *(void *)a5;
        if (v63 >> 61) {
LABEL_86:
        }
          std::__throw_bad_array_new_length[abi:nn180100]();
        int64_t v65 = (char *)operator new(8 * v63);
        uint64_t v61 = v77;
      }
      else
      {
        int64_t v65 = 0;
      }
      uint64_t v66 = (float *)&v65[8 * v62];
      *(_DWORD *)uint64_t v66 = v32;
      v66[1] = v57;
      if (v59 == v60)
      {
        uint64_t v60 = v59;
        unsigned int v68 = &v65[8 * v62];
      }
      else
      {
        unint64_t v67 = (char *)(v59 - 2) - (char *)v60;
        if (v67 < 0x58)
        {
          unsigned int v68 = &v65[8 * v62];
          goto LABEL_80;
        }
        unsigned int v68 = &v65[8 * v62];
        if ((unint64_t)((char *)v59 - &v65[v61]) < 0x20) {
          goto LABEL_89;
        }
        uint64_t v69 = (v67 >> 3) + 1;
        int v70 = &v65[8 * v62 - 16];
        unint64_t v71 = v59 - 4;
        uint64_t v72 = v69 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v73 = *(_OWORD *)v71;
          *((_OWORD *)v70 - 1) = *((_OWORD *)v71 - 1);
          *(_OWORD *)int v70 = v73;
          v70 -= 32;
          v71 -= 8;
          v72 -= 4;
        }
        while (v72);
        unsigned int v68 = (char *)&v66[-2 * (v69 & 0x3FFFFFFFFFFFFFFCLL)];
        v59 -= 2 * (v69 & 0x3FFFFFFFFFFFFFFCLL);
        if (v69 != (v69 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_89:
          do
          {
LABEL_80:
            uint64_t v74 = *((void *)v59 - 1);
            v59 -= 2;
            *((void *)v68 - 1) = v74;
            v68 -= 8;
          }
          while (v59 != v60);
          uint64_t v60 = *(float **)a5;
        }
      }
      long double v16 = (char *)(v66 + 2);
      *(void *)a5 = v68;
      *(void *)(a5 + 8) = v66 + 2;
      *(void *)(a5 + 16) = &v65[8 * v79];
      if (v60) {
        operator delete(v60);
      }
      goto LABEL_13;
    }
    float v33 = v81;
    int v34 = v32 + vcvtms_u32_f32(v33);
    float v35 = v33 - floorf(v33);
    if (v33 >= 1.0) {
      float v36 = v35;
    }
    else {
      float v36 = v81;
    }
    if (v33 >= 1.0) {
      int v37 = v34;
    }
    else {
      int v37 = v32;
    }
    float64x2_t v39 = *(float **)(a5 + 8);
    unint64_t v38 = *(void *)(a5 + 16);
    if ((unint64_t)v39 < v38)
    {
      *(_DWORD *)float64x2_t v39 = v37;
      v39[1] = v36;
      float64_t v40 = (char *)(v39 + 2);
LABEL_58:
      *(void *)(a5 + 8) = v40;
      goto LABEL_59;
    }
    float64x2_t v41 = *(float **)a5;
    uint64_t v42 = (uint64_t)v39 - *(void *)a5;
    uint64_t v43 = v42 >> 3;
    unint64_t v44 = (v42 >> 3) + 1;
    if (v44 >> 61) {
      goto LABEL_85;
    }
    uint64_t v45 = v38 - (void)v41;
    if (v45 >> 2 > v44) {
      unint64_t v44 = v45 >> 2;
    }
    if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
    }
    unint64_t v78 = v44;
    if (v44)
    {
      uint64_t v75 = (uint64_t)v39 - *(void *)a5;
      int v76 = v37;
      if (v44 >> 61) {
        goto LABEL_86;
      }
      uint64_t v46 = (char *)operator new(8 * v44);
      int v37 = v76;
      uint64_t v42 = v75;
    }
    else
    {
      uint64_t v46 = 0;
    }
    uint64_t v47 = (float *)&v46[8 * v43];
    *(_DWORD *)uint64_t v47 = v37;
    v47[1] = v36;
    if (v39 == v41)
    {
      float64x2_t v41 = v39;
      uint64_t v50 = &v46[8 * v43];
      unint64_t v49 = v78;
      goto LABEL_56;
    }
    unint64_t v48 = (char *)(v39 - 2) - (char *)v41;
    unint64_t v49 = v78;
    if (v48 >= 0x58)
    {
      uint64_t v50 = &v46[8 * v43];
      if ((unint64_t)((char *)v39 - &v46[v42]) >= 0x20)
      {
        uint64_t v51 = (v48 >> 3) + 1;
        uint64_t v52 = &v46[8 * v43 - 16];
        unint64_t v53 = v39 - 4;
        uint64_t v54 = v51 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v55 = *(_OWORD *)v53;
          *((_OWORD *)v52 - 1) = *((_OWORD *)v53 - 1);
          *(_OWORD *)uint64_t v52 = v55;
          v52 -= 32;
          v53 -= 8;
          v54 -= 4;
        }
        while (v54);
        uint64_t v50 = (char *)&v47[-2 * (v51 & 0x3FFFFFFFFFFFFFFCLL)];
        v39 -= 2 * (v51 & 0x3FFFFFFFFFFFFFFCLL);
        if (v51 == (v51 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_56;
        }
      }
    }
    else
    {
      uint64_t v50 = &v46[8 * v43];
    }
    do
    {
      uint64_t v56 = *((void *)v39 - 1);
      v39 -= 2;
      *((void *)v50 - 1) = v56;
      v50 -= 8;
    }
    while (v39 != v41);
    float64x2_t v41 = *(float **)a5;
LABEL_56:
    float64_t v40 = (char *)(v47 + 2);
    *(void *)a5 = v50;
    *(void *)(a5 + 8) = v47 + 2;
    *(void *)(a5 + 16) = &v46[8 * v49];
    if (v41) {
      operator delete(v41);
    }
    goto LABEL_58;
  }
  while (1)
  {
    unsigned int v10 = a4[2];
    unsigned int v11 = *((unsigned __int16 *)v7 + 44);
    if (v10 < v11 || v10 == v11 && a4[3] < *((unsigned __int16 *)v7 + 45)) {
      break;
    }
    unsigned int v12 = *a4;
    unsigned int v13 = *((unsigned __int16 *)v7 + 46);
    if (v12 > v13 || v12 == v13 && a4[1] > *((unsigned __int16 *)v7 + 47)) {
      break;
    }
    long long v82 = *(_OWORD *)(v7 + 6);
    double v83 = *((double *)v7 + 5);
    long long v84 = *((_OWORD *)v7 + 3);
    double v85 = *((double *)v7 + 8);
    if (geo::Intersect::encloses<double>(a2, (double *)&v82) != 2) {
      break;
    }
    md::RouteCollisionObject<md::GeocentricPointSource>::intersectWithFrustumEdges(a1, a2, *((void *)v7 + 1), a4, a5);
    double v7 = (_DWORD *)*((void *)v7 + 2);
    if (*v7) {
      goto LABEL_10;
    }
  }
}

void md::GeocentricRouteCollider::intersectRouteWithFrustum(uint64_t a1@<X0>, double *a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  uint64_t v6 = *(uint64_t ***)(a1 + 8);
  id v7 = a3;
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  double v8 = *v6;
  double v9 = v6[1];
  if (*v6 != v9)
  {
    uint64_t v10 = 0;
    do
    {
      uint64_t v12 = *v8;
      v8 += 2;
      uint64_t v11 = v12;
      if (*(id *)(v12 + 8) == v7) {
        uint64_t v10 = v11;
      }
    }
    while (v8 != v9);
    if (v10)
    {
      id v13 = v7;
      uint64_t v14 = 0;
      int v15 = [v7 pointCount] - 1;
      int v16 = 0;
      md::RouteCollisionObject<md::GeocentricPointSource>::intersectWithFrustum(v10, a2, (uint64_t)&v14, (uint64_t)a4);
      id v7 = v13;
    }
  }
}

void sub_1A205ABD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = *(void **)v10;
  if (*(void *)v10)
  {
    *(void *)(v10 + 8) = v12;
    operator delete(v12);
  }

  _Unwind_Resume(a1);
}

void md::GeocentricRouteCollider::~GeocentricRouteCollider(md::GeocentricRouteCollider *this)
{
  uint64_t v1 = (void **)*((void *)this + 1);
  *(void *)this = &unk_1EF542FE0;
  *((void *)this + 1) = 0;
  if (v1)
  {
    double v2 = (char *)*v1;
    if (*v1)
    {
      uint64_t v3 = (char *)v1[1];
      unsigned __int16 v4 = *v1;
      if (v3 != v2)
      {
        do
        {
          id v5 = (std::__shared_weak_count *)*((void *)v3 - 1);
          if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
          v3 -= 16;
        }
        while (v3 != v2);
        unsigned __int16 v4 = *v1;
      }
      v1[1] = v2;
      operator delete(v4);
    }
    MEMORY[0x1A6239270](v1, 0x20C40960023A9);
  }
  JUMPOUT(0x1A6239270);
}

{
  void **v1;
  char *v2;
  char *v3;
  void *v4;
  std::__shared_weak_count *v5;

  uint64_t v1 = (void **)*((void *)this + 1);
  *(void *)this = &unk_1EF542FE0;
  *((void *)this + 1) = 0;
  if (v1)
  {
    double v2 = (char *)*v1;
    if (*v1)
    {
      uint64_t v3 = (char *)v1[1];
      unsigned __int16 v4 = *v1;
      if (v3 != v2)
      {
        do
        {
          id v5 = (std::__shared_weak_count *)*((void *)v3 - 1);
          if (v5)
          {
            if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
              std::__shared_weak_count::__release_weak(v5);
            }
          }
          v3 -= 16;
        }
        while (v3 != v2);
        unsigned __int16 v4 = *v1;
      }
      v1[1] = v2;
      operator delete(v4);
    }
    MEMORY[0x1A6239270](v1, 0x20C40960023A9);
  }
}

md::PointSource *md::PointSource::PointSource(md::PointSource *this, GEOComposedRoute *a2)
{
  uint64_t v3 = a2;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  unsigned __int16 v4 = [(GEOComposedRoute *)v3 sections];
  unint64_t v5 = [v4 count];

  uint64_t v6 = *((void *)this + 1);
  unint64_t v7 = (v6 - *(void *)this) >> 3;
  if (v5 > v7)
  {
    std::vector<GEOComposedRouteSection * {__strong}>::__append(this, v5 - v7);
LABEL_8:
    unint64_t v10 = 0;
    unsigned int v11 = 1;
    do
    {
      uint64_t v12 = [(GEOComposedRoute *)v3 sections];
      uint64_t v13 = [v12 objectAtIndexedSubscript:v10];

      uint64_t v14 = *(void **)(*(void *)this + 8 * v10);
      *(void *)(*(void *)this + 8 * v10) = v13;

      unint64_t v10 = v11++;
    }
    while (v5 > v10);
    goto LABEL_10;
  }
  if (v5 < v7)
  {
    uint64_t v8 = *(void *)this + 8 * v5;
    while (v6 != v8)
    {
      double v9 = *(void **)(v6 - 8);
      v6 -= 8;
    }
    *((void *)this + 1) = v8;
  }
  if (v5) {
    goto LABEL_8;
  }
LABEL_10:

  return this;
}

void sub_1A205AEF8(_Unwind_Exception *a1)
{
  std::vector<VKTransitLineMarker * {__strong}>::~vector[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void std::vector<GEOComposedRouteSection * {__strong}>::__append(void *a1, unint64_t a2)
{
  unint64_t v5 = (char *)a1[1];
  uint64_t v4 = a1[2];
  uint64_t v6 = v5;
  if (a2 <= (v4 - (uint64_t)v5) >> 3)
  {
    if (a2)
    {
      bzero(v5, 8 * a2);
      uint64_t v6 = &v5[8 * a2];
    }
    a1[1] = v6;
  }
  else
  {
    unint64_t v7 = (char *)*a1;
    uint64_t v8 = (uint64_t)&v5[-*a1];
    uint64_t v9 = v8 >> 3;
    unint64_t v10 = (v8 >> 3) + a2;
    if (v10 >> 61) {
      abort();
    }
    uint64_t v11 = v4 - (void)v7;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v13 = (char *)operator new(8 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    size_t v15 = 8 * a2;
    int v16 = &v13[8 * v12];
    bzero(v14, v15);
    double v17 = &v14[v15];
    if (v5 == v7)
    {
      *a1 = v14;
      a1[1] = v17;
      a1[2] = v16;
      if (!v5) {
        return;
      }
      goto LABEL_26;
    }
    unint64_t v18 = v5 - v7 - 8;
    if (v18 <= 0x77 || &v5[-(v18 & 0xFFFFFFFFFFFFFFF8) - 8] < v14 && &v13[v8 - (v18 & 0xFFFFFFFFFFFFFFF8) - 8] < v5) {
      goto LABEL_35;
    }
    uint64_t v19 = (v18 >> 3) + 1;
    uint64_t v6 = &v5[-8 * (v19 & 0x3FFFFFFFFFFFFFFCLL)];
    unsigned int v20 = &v13[8 * v9 - 16];
    double v21 = v5 - 32;
    uint64_t v22 = v19 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v24 = *(_OWORD *)v21;
      long long v23 = *((_OWORD *)v21 + 1);
      *(_OWORD *)double v21 = 0uLL;
      *((_OWORD *)v21 + 1) = 0uLL;
      v21 -= 32;
      *((_OWORD *)v20 - 1) = v24;
      *(_OWORD *)unsigned int v20 = v23;
      v20 -= 32;
      v22 -= 4;
    }
    while (v22);
    v14 -= 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
    if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_35:
      do
      {
        uint64_t v25 = *((void *)v6 - 1);
        v6 -= 8;
        *(void *)uint64_t v6 = 0;
        *((void *)v14 - 1) = v25;
        v14 -= 8;
      }
      while (v6 != v7);
    }
    uint64_t v6 = (char *)*a1;
    double v26 = (char *)a1[1];
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v16;
    while (v26 != v6)
    {
      double v27 = (void *)*((void *)v26 - 1);
      v26 -= 8;
    }
    if (v6)
    {
LABEL_26:
      operator delete(v6);
    }
  }
}

void std::vector<md::PointSource::SegmentIndex>::__append(uint64_t a1, unint64_t a2)
{
  unint64_t v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v6 = v5;
  if (a2 <= (v4 - (uint64_t)v5) >> 2)
  {
    if (a2)
    {
      bzero(v5, 4 * a2);
      uint64_t v6 = &v5[4 * a2];
    }
    *(void *)(a1 + 8) = v6;
  }
  else
  {
    unint64_t v7 = *(char **)a1;
    uint64_t v8 = (uint64_t)&v5[-*(void *)a1];
    uint64_t v9 = v8 >> 2;
    unint64_t v10 = (v8 >> 2) + a2;
    if (v10 >> 62) {
      abort();
    }
    uint64_t v11 = v4 - (void)v7;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 62) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v13 = operator new(4 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[4 * v9];
    size_t v15 = 4 * a2;
    int v16 = &v13[4 * v12];
    bzero(v14, v15);
    double v17 = &v14[v15];
    if (v5 == v7)
    {
      unint64_t v7 = v5;
    }
    else
    {
      unint64_t v18 = v5 - v7 - 4;
      if (v18 < 0x2C) {
        goto LABEL_33;
      }
      if ((unint64_t)(v5 - v13 - v8) < 0x20) {
        goto LABEL_33;
      }
      uint64_t v19 = (v18 >> 2) + 1;
      uint64_t v6 = &v5[-4 * (v19 & 0x7FFFFFFFFFFFFFF8)];
      unsigned int v20 = &v13[4 * v9 - 16];
      double v21 = v5 - 16;
      uint64_t v22 = v19 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v23 = *(_OWORD *)v21;
        *(v20 - 1) = *((_OWORD *)v21 - 1);
        *unsigned int v20 = v23;
        v20 -= 2;
        v21 -= 32;
        v22 -= 8;
      }
      while (v22);
      v14 -= 4 * (v19 & 0x7FFFFFFFFFFFFFF8);
      if (v19 != (v19 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_33:
        do
        {
          int v24 = *((_DWORD *)v6 - 1);
          v6 -= 4;
          *((_DWORD *)v14 - 1) = v24;
          v14 -= 4;
        }
        while (v6 != v7);
        unint64_t v7 = *(char **)a1;
      }
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v17;
    *(void *)(a1 + 16) = v16;
    if (v7)
    {
      operator delete(v7);
    }
  }
}

void md::RouteCollisionObject<md::MercatorPointSource>::buildTopDownAABBTree(uint64_t a1, char **a2, int *a3, int *a4)
{
  uint64_t v8 = (uint64_t **)(a1 + 88);
  while (1)
  {
    uint64_t v9 = *(char **)(a1 + 120);
    if (!v9)
    {
      unint64_t v10 = (char *)malloc_type_malloc(*(void *)(a1 + 112), 0x160B39uLL);
      uint64_t v11 = v10;
      unint64_t v12 = *(uint64_t **)(a1 + 88);
      uint64_t v13 = v8;
      uint64_t v14 = v8;
      if (v12)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v14 = (uint64_t **)v12;
            unint64_t v15 = v12[4];
            if ((unint64_t)v10 >= v15) {
              break;
            }
            unint64_t v12 = *v14;
            uint64_t v13 = v14;
            if (!*v14) {
              goto LABEL_11;
            }
          }
          if (v15 >= (unint64_t)v10) {
            break;
          }
          unint64_t v12 = v14[1];
          if (!v12)
          {
            uint64_t v13 = v14 + 1;
            goto LABEL_11;
          }
        }
      }
      else
      {
LABEL_11:
        int v16 = (uint64_t *)operator new(0x28uLL);
        v16[4] = (uint64_t)v11;
        *int v16 = 0;
        v16[1] = 0;
        v16[2] = (uint64_t)v14;
        *uint64_t v13 = v16;
        uint64_t v17 = **(void **)(a1 + 80);
        if (v17)
        {
          *(void *)(a1 + 80) = v17;
          unint64_t v18 = *v13;
        }
        else
        {
          unint64_t v18 = v16;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 88), v18);
        ++*(void *)(a1 + 96);
      }
      uint64_t v9 = *(char **)(a1 + 120);
      uint64_t v19 = 80 * *(void *)(a1 + 104) - 80;
      if ((v19 & 0x8000000000000000) == 0)
      {
        unsigned int v20 = &v11[v19];
        double v21 = &v11[v19];
        do
        {
          *(void *)double v21 = v9;
          v21 -= 80;
          uint64_t v9 = v20;
          unsigned int v20 = v21;
        }
        while (v21 >= v11);
        uint64_t v9 = v21 + 80;
      }
    }
    *(void *)(a1 + 120) = *(void *)v9;
    *a2 = v9;
    if (a3 == a4)
    {
      double v24 = -1.79769313e308;
      double v25 = 1.79769313e308;
      double v22 = 1.79769313e308;
      double v23 = -1.79769313e308;
    }
    else
    {
      double v22 = 1.79769313e308;
      double v23 = -1.79769313e308;
      double v24 = -1.79769313e308;
      double v25 = 1.79769313e308;
      double v26 = a3;
      do
      {
        double v27 = md::MercatorPointSource::segmentWorldPoint(*(void *)(a1 + 128), *v26, 0);
        double v28 = fmin(v27, v25);
        double v29 = fmax(v24, v27);
        double v31 = fmin(v30, v22);
        double v32 = fmax(v23, v30);
        int v33 = *v26++;
        double v34 = md::MercatorPointSource::segmentWorldPoint(*(void *)(a1 + 128), v33, 1);
        double v25 = fmin(v34, v28);
        double v24 = fmax(v29, v34);
        double v22 = fmin(v35, v31);
        double v23 = fmax(v32, v35);
      }
      while (v26 != a4);
    }
    *((double *)v9 + 3) = v25;
    *((double *)v9 + 4) = v22;
    *((double *)v9 + 5) = v24;
    *((double *)v9 + 6) = v23;
    int v50 = 0;
    LODWORD(v51[0]) = -1;
    if (a3 >= a4)
    {
      uint64_t v46 = 0xFFFFFFFFLL;
    }
    else
    {
      LOWORD(v36) = 0;
      LOWORD(v37) = 0;
      unsigned int v38 = 0xFFFF;
      LOWORD(v39) = -1;
      float64_t v40 = a3;
      do
      {
        unsigned int v42 = *(unsigned __int16 *)v40;
        BOOL v43 = v42 == (unsigned __int16)v39;
        if (v42 > (unsigned __int16)v39 || (unint64_t v44 = v40, v43) && (unint64_t v44 = v40, v38 < *((unsigned __int16 *)v40 + 1))) {
          unint64_t v44 = (int *)v51;
        }
        uint64_t v39 = *v44;
        LODWORD(v51[0]) = v39;
        BOOL v45 = v42 == (unsigned __int16)v37;
        if (v42 < (unsigned __int16)v37
          || (float64x2_t v41 = v40, v45) && (float64x2_t v41 = v40, *((unsigned __int16 *)v40 + 1) < (unsigned __int16)v36))
        {
          float64x2_t v41 = &v50;
        }
        unsigned int v38 = WORD1(v39);
        uint64_t v37 = *v41;
        int v50 = v37;
        ++v40;
        unsigned int v36 = WORD1(v37);
      }
      while (v40 < a4);
      uint64_t v46 = v39 | (v37 << 32);
    }
    uint64_t v47 = a4 - a3;
    *((void *)v9 + 9) = v46;
    if (v47 <= 4) {
      break;
    }
    *(_DWORD *)uint64_t v9 = 0;
    *((_DWORD *)v9 + 14) = v47;
    *((void *)v9 + 8) = 0;
    unint64_t v48 = (v47 + (unint64_t)(v47 < 0)) >> 1;
    unint64_t v49 = &a3[v48];
    v51[0] = a1;
    v51[1] = fmax(v23 - v22, 0.0) > fmax(v24 - v25, 0.0);
    if (v49 != a4) {
      std::__nth_element[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteCollisionObject<md::MercatorPointSource>::partitionSegments(std::__wrap_iter<md::PointSource::SegmentIndex *>,std::__wrap_iter<md::PointSource::SegmentIndex *>,gm::Box<double,2> &)::{lambda(md::PointSource::SegmentIndex const&,md::PointSource::SegmentIndex const&)#1} &,std::__wrap_iter<md::PointSource::SegmentIndex *>>(a3, &a3[v48], a4, (int *)v51);
    }
    md::RouteCollisionObject<md::MercatorPointSource>::buildTopDownAABBTree(a1, v9 + 8, a3, v49);
    a2 = (char **)(v9 + 16);
    a3 = v49;
  }
  *(_DWORD *)uint64_t v9 = 1;
  *((_DWORD *)v9 + 14) = v47;
  *((void *)v9 + 8) = a3;
}

uint64_t geo::Pool<md::RouteCollisionObject<md::MercatorPointSource>::Node>::~Pool(uint64_t a1)
{
  return a1;
}

void sub_1A205B648(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void geo::Pool<md::RouteCollisionObject<md::MercatorPointSource>::Node>::disposeElements(uint64_t a1)
{
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = &v14;
  for (uint64_t i = *(void **)(a1 + 40); i; *(void *)(a1 + 40) = i)
  {
    uint64_t v8 = &v14;
    uint64_t v9 = &v14;
    if (v14)
    {
      unint64_t v10 = v14;
      while (1)
      {
        while (1)
        {
          uint64_t v9 = (uint64_t **)v10;
          unint64_t v11 = v10[4];
          if ((unint64_t)i >= v11) {
            break;
          }
          unint64_t v10 = *v9;
          uint64_t v8 = v9;
          if (!*v9) {
            goto LABEL_20;
          }
        }
        if (v11 >= (unint64_t)i) {
          break;
        }
        unint64_t v10 = v9[1];
        if (!v10)
        {
          uint64_t v8 = v9 + 1;
          goto LABEL_20;
        }
      }
    }
    else
    {
LABEL_20:
      unint64_t v12 = (uint64_t *)operator new(0x28uLL);
      v12[4] = (uint64_t)i;
      *unint64_t v12 = 0;
      v12[1] = 0;
      v12[2] = (uint64_t)v9;
      *uint64_t v8 = v12;
      if (*v13)
      {
        uint64_t v13 = (uint64_t **)*v13;
        unint64_t v12 = *v8;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v14, v12);
      ++v15;
      uint64_t i = *(void **)(a1 + 40);
    }
    uint64_t i = (void *)*i;
  }
  uint64_t v3 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1 != a1 + 8)
  {
    do
    {
      free((void *)v4[4]);
      unint64_t v5 = (void *)v4[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          unint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void *)v4[2];
          BOOL v7 = *v6 == (void)v4;
          uint64_t v4 = v6;
        }
        while (!v7);
      }
      uint64_t v4 = v6;
    }
    while (v6 != v3);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v3;
  *(void *)(a1 + 40) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v14);
}

void sub_1A205B7BC(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v1);
  _Unwind_Resume(a1);
}

void std::__nth_element[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteCollisionObject<md::MercatorPointSource>::partitionSegments(std::__wrap_iter<md::PointSource::SegmentIndex *>,std::__wrap_iter<md::PointSource::SegmentIndex *>,gm::Box<double,2> &)::{lambda(md::PointSource::SegmentIndex const&,md::PointSource::SegmentIndex const&)#1} &,std::__wrap_iter<md::PointSource::SegmentIndex *>>(int *a1, int *a2, int *a3, int *a4)
{
  v291 = a3;
  if (a3 == a2) {
    return;
  }
  do
  {
    unint64_t v6 = v291 - a1;
    if (v6 < 2) {
      return;
    }
    if (v6 == 3)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteCollisionObject<md::MercatorPointSource>::partitionSegments(std::__wrap_iter<md::PointSource::SegmentIndex *>,std::__wrap_iter<md::PointSource::SegmentIndex *>,gm::Box<double,2> &)::{lambda(md::PointSource::SegmentIndex const&,md::PointSource::SegmentIndex const&)#1} &,std::__wrap_iter<md::PointSource::SegmentIndex *>>(a1, a1 + 1, v291 - 1, a4);
      return;
    }
    if (v6 == 2)
    {
      uint64_t v266 = *(void *)a4;
      *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *(v291 - 1), 0);
      *((void *)&v295 + 1) = v267;
      double v268 = *((double *)&v295 + a4[2]);
      double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v266 + 128), *(v291 - 1), 1);
      double v299 = v269;
      double v270 = (*(&v298 + a4[2]) + v268) * 0.5;
      *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v266 + 128), *a1, 0);
      *((void *)&v295 + 1) = v271;
      double v272 = *((double *)&v295 + a4[2]);
      double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v266 + 128), *a1, 1);
      double v299 = v273;
      if (v270 < (*(&v298 + a4[2]) + v272) * 0.5)
      {
        int v274 = *a1;
        *a1 = *(v291 - 1);
        *(v291 - 1) = v274;
      }
      return;
    }
    if ((char *)v291 - (char *)a1 <= 31)
    {
      for (; a1 != v291 - 1; ++a1)
      {
        v275 = v291;
        if (a1 != v291)
        {
          v276 = a1 + 1;
          v275 = a1;
          if (a1 + 1 != v291)
          {
            v275 = a1;
            v277 = a1 + 1;
            do
            {
              uint64_t v278 = *(void *)a4;
              *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *v276, 0);
              *((void *)&v295 + 1) = v279;
              double v280 = *((double *)&v295 + a4[2]);
              int v281 = *v277++;
              double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v278 + 128), v281, 1);
              double v299 = v282;
              double v283 = (*(&v298 + a4[2]) + v280) * 0.5;
              *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v278 + 128), *v275, 0);
              *((void *)&v295 + 1) = v284;
              double v285 = *((double *)&v295 + a4[2]);
              double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v278 + 128), *v275, 1);
              double v299 = v286;
              if (v283 < (*(&v298 + a4[2]) + v285) * 0.5) {
                v275 = v276;
              }
              v276 = v277;
            }
            while (v277 != v291);
          }
        }
        if (a1 != v275)
        {
          int v287 = *a1;
          *a1 = *v275;
          int *v275 = v287;
        }
      }
      return;
    }
    BOOL v7 = &a1[v6 >> 1];
    uint64_t v8 = v291 - 1;
    int v293 = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteCollisionObject<md::MercatorPointSource>::partitionSegments(std::__wrap_iter<md::PointSource::SegmentIndex *>,std::__wrap_iter<md::PointSource::SegmentIndex *>,gm::Box<double,2> &)::{lambda(md::PointSource::SegmentIndex const&,md::PointSource::SegmentIndex const&)#1} &,std::__wrap_iter<md::PointSource::SegmentIndex *>>(a1, v7, v291 - 1, a4);
    uint64_t v9 = *(void *)a4;
    *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *a1, 0);
    *((void *)&v295 + 1) = v10;
    double v11 = *((double *)&v295 + a4[2]);
    double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v9 + 128), *a1, 1);
    double v299 = v12;
    double v13 = (*(&v298 + a4[2]) + v11) * 0.5;
    *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v9 + 128), *v7, 0);
    *((void *)&v295 + 1) = v14;
    double v15 = *((double *)&v295 + a4[2]);
    double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v9 + 128), *v7, 1);
    double v299 = v16;
    if (v13 >= (*(&v298 + a4[2]) + v15) * 0.5)
    {
      uint64_t v17 = v291 - 2;
      do
      {
        if (v17 == a1)
        {
          uint64_t v149 = *(void *)a4;
          *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *a1, 0);
          *((void *)&v295 + 1) = v150;
          double v151 = *((double *)&v295 + a4[2]);
          v140 = a1 + 1;
          double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v149 + 128), *a1, 1);
          double v299 = v152;
          double v153 = (*(&v298 + a4[2]) + v151) * 0.5;
          *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v149 + 128), *v8, 0);
          *((void *)&v295 + 1) = v154;
          double v155 = *((double *)&v295 + a4[2]);
          double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v149 + 128), *v8, 1);
          double v299 = v156;
          if (v153 >= (*(&v298 + a4[2]) + v155) * 0.5)
          {
            if (v140 == v8) {
              return;
            }
            while (1)
            {
              uint64_t v157 = *(void *)a4;
              *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *a1, 0);
              *((void *)&v295 + 1) = v158;
              double v159 = *((double *)&v295 + a4[2]);
              double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v157 + 128), *a1, 1);
              double v299 = v160;
              double v161 = (*(&v298 + a4[2]) + v159) * 0.5;
              *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v157 + 128), *v140, 0);
              *((void *)&v295 + 1) = v162;
              double v163 = *((double *)&v295 + a4[2]);
              double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v157 + 128), *v140, 1);
              double v299 = v164;
              if (v161 < (*(&v298 + a4[2]) + v163) * 0.5) {
                break;
              }
              if (++v140 == v8) {
                return;
              }
            }
            int v174 = *v140;
            *v140++ = *v8;
            *uint64_t v8 = v174;
          }
          if (v140 == v8) {
            return;
          }
          while (1)
          {
            uint64_t v176 = *(void *)a4;
            unint64_t v177 = *a1;
            id v178 = *(id *)(*(void *)(*(void *)a4 + 128) + 8 * (unsigned __int16)*a1);
            uint64_t v179 = [v178 points];
            if (v178)
            {
              [v178 bounds];
              double v180 = *((double *)&v295 + 1);
              double v181 = *(double *)&v295;
              double v183 = *((double *)&v296 + 1);
              double v182 = *(double *)&v297;
            }
            else
            {
              long long v296 = 0u;
              long long v297 = 0u;
              double v182 = 0.0;
              double v180 = 0.0;
              double v183 = 0.0;
              double v181 = 0.0;
              long long v295 = 0u;
            }
            v184 = (float *)(v179 + 12 * (v177 >> 16));
            double v185 = (v181 + v183 * *v184) / *MEMORY[0x1E4F63F10];
            double v186 = 1.0 - (v180 + v182 * (float)(1.0 - v184[1])) / *(double *)(MEMORY[0x1E4F63F10] + 8);

            double v298 = v185;
            double v299 = v186;
            double v187 = *(&v298 + a4[2]);
            unint64_t v188 = *a1;
            id v189 = *(id *)(*(void *)(v176 + 128) + 8 * (unsigned __int16)*a1);
            uint64_t v190 = [v189 points];
            if (v189)
            {
              [v189 bounds];
              double v191 = *((double *)&v295 + 1);
              double v192 = *(double *)&v295;
              double v194 = *((double *)&v296 + 1);
              double v193 = *(double *)&v297;
            }
            else
            {
              long long v296 = 0u;
              long long v297 = 0u;
              double v193 = 0.0;
              double v191 = 0.0;
              double v194 = 0.0;
              double v192 = 0.0;
              long long v295 = 0u;
            }
            uint64_t v195 = v190 + 12 * (v188 >> 16);
            double v196 = (v192 + v194 * *(float *)(v195 + 12)) / *MEMORY[0x1E4F63F10];
            double v197 = 1.0 - (v191 + v193 * (float)(1.0 - *(float *)(v195 + 16))) / *(double *)(MEMORY[0x1E4F63F10] + 8);

            *(double *)&long long v295 = v196;
            *((double *)&v295 + 1) = v197;
            double v198 = *((double *)&v295 + a4[2]);
            unint64_t v199 = *v140;
            id v200 = *(id *)(*(void *)(v176 + 128) + 8 * (unsigned __int16)*v140);
            uint64_t v201 = [v200 points];
            if (v200)
            {
              [v200 bounds];
              double v202 = *((double *)&v295 + 1);
              double v203 = *(double *)&v295;
              double v205 = *((double *)&v296 + 1);
              double v204 = *(double *)&v297;
            }
            else
            {
              long long v296 = 0u;
              long long v297 = 0u;
              double v204 = 0.0;
              double v202 = 0.0;
              double v205 = 0.0;
              double v203 = 0.0;
              long long v295 = 0u;
            }
            v206 = (float *)(v201 + 12 * (v199 >> 16));
            double v207 = (v203 + v205 * *v206) / *MEMORY[0x1E4F63F10];
            double v208 = 1.0 - (v202 + v204 * (float)(1.0 - v206[1])) / *(double *)(MEMORY[0x1E4F63F10] + 8);

            double v298 = v207;
            double v299 = v208;
            double v209 = *(&v298 + a4[2]);
            unint64_t v210 = *v140;
            id v211 = *(id *)(*(void *)(v176 + 128) + 8 * (unsigned __int16)*v140);
            uint64_t v212 = [v211 points];
            if (v211)
            {
              [v211 bounds];
              double v213 = *((double *)&v295 + 1);
              double v214 = *(double *)&v295;
              double v216 = *((double *)&v296 + 1);
              double v215 = *(double *)&v297;
            }
            else
            {
              long long v296 = 0u;
              long long v297 = 0u;
              double v215 = 0.0;
              double v213 = 0.0;
              double v216 = 0.0;
              double v214 = 0.0;
              long long v295 = 0u;
            }
            double v217 = (v198 + v187) * 0.5;
            uint64_t v218 = v212 + 12 * (v210 >> 16);
            double v219 = (v214 + v216 * *(float *)(v218 + 12)) / *MEMORY[0x1E4F63F10];
            double v220 = 1.0 - (v213 + v215 * (float)(1.0 - *(float *)(v218 + 16))) / *(double *)(MEMORY[0x1E4F63F10] + 8);

            *(double *)&long long v295 = v219;
            *((double *)&v295 + 1) = v220;
            if (v217 < (*((double *)&v295 + a4[2]) + v209) * 0.5)
            {
              do
              {
                uint64_t v229 = *(void *)a4;
                unint64_t v230 = *a1;
                id v231 = *(id *)(*(void *)(*(void *)a4 + 128) + 8 * (unsigned __int16)*a1);
                uint64_t v232 = [v231 points];
                if (v231)
                {
                  [v231 bounds];
                  double v233 = *((double *)&v295 + 1);
                  double v234 = *(double *)&v295;
                  double v236 = *((double *)&v296 + 1);
                  double v235 = *(double *)&v297;
                }
                else
                {
                  long long v296 = 0u;
                  long long v297 = 0u;
                  double v235 = 0.0;
                  double v233 = 0.0;
                  double v236 = 0.0;
                  double v234 = 0.0;
                  long long v295 = 0u;
                }
                v237 = (float *)(v232 + 12 * (v230 >> 16));
                double v238 = (v234 + v236 * *v237) / *MEMORY[0x1E4F63F10];
                double v239 = 1.0 - (v233 + v235 * (float)(1.0 - v237[1])) / *(double *)(MEMORY[0x1E4F63F10] + 8);

                double v298 = v238;
                double v299 = v239;
                double v240 = *(&v298 + a4[2]);
                unint64_t v241 = *a1;
                id v242 = *(id *)(*(void *)(v229 + 128) + 8 * (unsigned __int16)*a1);
                uint64_t v243 = [v242 points];
                if (v242)
                {
                  [v242 bounds];
                  double v244 = *((double *)&v295 + 1);
                  double v245 = *(double *)&v295;
                  double v247 = *((double *)&v296 + 1);
                  double v246 = *(double *)&v297;
                }
                else
                {
                  long long v296 = 0u;
                  long long v297 = 0u;
                  double v246 = 0.0;
                  double v244 = 0.0;
                  double v247 = 0.0;
                  double v245 = 0.0;
                  long long v295 = 0u;
                }
                uint64_t v248 = v243 + 12 * (v241 >> 16);
                double v249 = (v245 + v247 * *(float *)(v248 + 12)) / *MEMORY[0x1E4F63F10];
                double v250 = 1.0
                     - (v244 + v246 * (float)(1.0 - *(float *)(v248 + 16))) / *(double *)(MEMORY[0x1E4F63F10] + 8);

                *(double *)&long long v295 = v249;
                *((double *)&v295 + 1) = v250;
                double v251 = *((double *)&v295 + a4[2]);
                unint64_t v252 = *(v8 - 1);
                id v253 = *(id *)(*(void *)(v229 + 128) + 8 * (unsigned __int16)*(v8 - 1));
                uint64_t v254 = [v253 points];
                if (v253)
                {
                  [v253 bounds];
                  double v255 = *((double *)&v295 + 1);
                  double v256 = *(double *)&v295;
                  double v258 = *((double *)&v296 + 1);
                  double v257 = *(double *)&v297;
                }
                else
                {
                  long long v296 = 0u;
                  long long v297 = 0u;
                  double v257 = 0.0;
                  double v255 = 0.0;
                  double v258 = 0.0;
                  double v256 = 0.0;
                  long long v295 = 0u;
                }
                v259 = (float *)(v254 + 12 * (v252 >> 16));
                double v260 = (v256 + v258 * *v259) / *MEMORY[0x1E4F63F10];
                double v261 = 1.0 - (v255 + v257 * (float)(1.0 - v259[1])) / *(double *)(MEMORY[0x1E4F63F10] + 8);

                double v298 = v260;
                double v299 = v261;
                double v262 = *(&v298 + a4[2]);
                unint64_t v263 = *(v8 - 1);
                id v264 = *(id *)(*(void *)(v229 + 128) + 8 * (unsigned __int16)*(v8 - 1));
                uint64_t v265 = [v264 points];
                if (v264)
                {
                  [v264 bounds];
                  double v222 = *((double *)&v295 + 1);
                  double v224 = *(double *)&v295;
                  double v223 = *((double *)&v296 + 1);
                  double v221 = *(double *)&v297;
                }
                else
                {
                  long long v296 = 0u;
                  long long v297 = 0u;
                  double v221 = 0.0;
                  double v222 = 0.0;
                  double v223 = 0.0;
                  double v224 = 0.0;
                  long long v295 = 0u;
                }
                --v8;
                double v225 = (v251 + v240) * 0.5;
                uint64_t v226 = v265 + 12 * (v263 >> 16);
                double v227 = (v224 + v223 * *(float *)(v226 + 12)) / *MEMORY[0x1E4F63F10];
                double v228 = 1.0
                     - (v222 + v221 * (float)(1.0 - *(float *)(v226 + 16))) / *(double *)(MEMORY[0x1E4F63F10] + 8);

                *(double *)&long long v295 = v227;
                *((double *)&v295 + 1) = v228;
              }
              while (v225 < (*((double *)&v295 + a4[2]) + v262) * 0.5);
              if (v140 >= v8)
              {
                if (v140 <= a2) {
                  goto LABEL_108;
                }
                return;
              }
              int v175 = *v140;
              int *v140 = *v8;
              *uint64_t v8 = v175;
            }
            ++v140;
          }
        }
        unint64_t v18 = v17;
        uint64_t v19 = *(void *)a4;
        *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *v17, 0);
        *((void *)&v295 + 1) = v20;
        double v21 = *((double *)&v295 + a4[2]);
        int v22 = *v17--;
        double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v19 + 128), v22, 1);
        double v299 = v23;
        double v24 = (*(&v298 + a4[2]) + v21) * 0.5;
        *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v19 + 128), *v7, 0);
        *((void *)&v295 + 1) = v25;
        double v26 = *((double *)&v295 + a4[2]);
        double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v19 + 128), *v7, 1);
        double v299 = v27;
      }
      while (v24 >= (*(&v298 + a4[2]) + v26) * 0.5);
      int v28 = *a1;
      *a1 = *v18;
      int *v18 = v28;
      ++v293;
      uint64_t v8 = v18;
    }
    double v29 = a1 + 1;
    if (a1 + 1 >= v8)
    {
      uint64_t v126 = 1;
      v127 = v291;
    }
    else
    {
      v288 = a1 + 1;
      uint64_t v30 = 1;
      for (uint64_t i = a1; ; a1 = i)
      {
        double v31 = v7;
        uint64_t v294 = v30;
        for (j = &a1[v30]; ; ++j)
        {
          uint64_t v33 = *(void *)a4;
          unint64_t v34 = *j;
          id v35 = *(id *)(*(void *)(*(void *)a4 + 128) + 8 * (unsigned __int16)*j);
          uint64_t v36 = [v35 points];
          if (v35)
          {
            [v35 bounds];
            double v37 = *((double *)&v295 + 1);
            double v38 = *(double *)&v295;
            double v40 = *((double *)&v296 + 1);
            double v39 = *(double *)&v297;
          }
          else
          {
            long long v296 = 0u;
            long long v297 = 0u;
            double v39 = 0.0;
            double v37 = 0.0;
            double v40 = 0.0;
            double v38 = 0.0;
            long long v295 = 0u;
          }
          float64x2_t v41 = (float *)(v36 + 12 * (v34 >> 16));
          double v42 = (v38 + v40 * *v41) / *MEMORY[0x1E4F63F10];
          double v43 = 1.0 - (v37 + v39 * (float)(1.0 - v41[1])) / *(double *)(MEMORY[0x1E4F63F10] + 8);

          double v298 = v42;
          double v299 = v43;
          double v44 = *(&v298 + a4[2]);
          unint64_t v45 = *j;
          id v46 = *(id *)(*(void *)(v33 + 128) + 8 * (unsigned __int16)*j);
          uint64_t v47 = [v46 points];
          if (v46)
          {
            [v46 bounds];
            double v48 = *((double *)&v295 + 1);
            double v49 = *(double *)&v295;
            double v51 = *((double *)&v296 + 1);
            double v50 = *(double *)&v297;
          }
          else
          {
            long long v296 = 0u;
            long long v297 = 0u;
            double v50 = 0.0;
            double v48 = 0.0;
            double v51 = 0.0;
            double v49 = 0.0;
            long long v295 = 0u;
          }
          uint64_t v52 = v47 + 12 * (v45 >> 16);
          double v53 = (v49 + v51 * *(float *)(v52 + 12)) / *MEMORY[0x1E4F63F10];
          double v54 = 1.0 - (v48 + v50 * (float)(1.0 - *(float *)(v52 + 16))) / *(double *)(MEMORY[0x1E4F63F10] + 8);

          *(double *)&long long v295 = v53;
          *((double *)&v295 + 1) = v54;
          double v55 = *((double *)&v295 + a4[2]);
          unint64_t v56 = *v31;
          id v57 = *(id *)(*(void *)(v33 + 128) + 8 * (unsigned __int16)*v31);
          uint64_t v58 = [v57 points];
          if (v57)
          {
            [v57 bounds];
            double v59 = *((double *)&v295 + 1);
            double v60 = *(double *)&v295;
            double v62 = *((double *)&v296 + 1);
            double v61 = *(double *)&v297;
          }
          else
          {
            long long v296 = 0u;
            long long v297 = 0u;
            double v61 = 0.0;
            double v59 = 0.0;
            double v62 = 0.0;
            double v60 = 0.0;
            long long v295 = 0u;
          }
          unint64_t v63 = (float *)(v58 + 12 * (v56 >> 16));
          double v64 = (v60 + v62 * *v63) / *MEMORY[0x1E4F63F10];
          double v65 = 1.0 - (v59 + v61 * (float)(1.0 - v63[1])) / *(double *)(MEMORY[0x1E4F63F10] + 8);

          double v298 = v64;
          double v299 = v65;
          double v66 = *(&v298 + a4[2]);
          unint64_t v67 = *v31;
          id v68 = *(id *)(*(void *)(v33 + 128) + 8 * (unsigned __int16)*v31);
          uint64_t v69 = [v68 points];
          if (v68)
          {
            [v68 bounds];
            double v70 = *((double *)&v295 + 1);
            double v71 = *(double *)&v295;
            double v73 = *((double *)&v296 + 1);
            double v72 = *(double *)&v297;
          }
          else
          {
            long long v296 = 0u;
            long long v297 = 0u;
            double v72 = 0.0;
            double v70 = 0.0;
            double v73 = 0.0;
            double v71 = 0.0;
            long long v295 = 0u;
          }
          double v74 = (v55 + v44) * 0.5;
          uint64_t v75 = v69 + 12 * (v67 >> 16);
          double v76 = (v71 + v73 * *(float *)(v75 + 12)) / *MEMORY[0x1E4F63F10];
          double v77 = 1.0 - (v70 + v72 * (float)(1.0 - *(float *)(v75 + 16))) / *(double *)(MEMORY[0x1E4F63F10] + 8);

          *(double *)&long long v295 = v76;
          *((double *)&v295 + 1) = v77;
          if (v74 >= (*((double *)&v295 + a4[2]) + v66) * 0.5) {
            break;
          }
          ++v294;
        }
        unint64_t v78 = v8;
        do
        {
          uint64_t v87 = *(void *)a4;
          unsigned int v89 = *--v8;
          unint64_t v88 = v89;
          id v90 = *(id *)(*(void *)(*(void *)a4 + 128) + 8 * (unsigned __int16)v89);
          uint64_t v91 = [v90 points];
          if (v90)
          {
            [v90 bounds];
            double v92 = *((double *)&v295 + 1);
            double v93 = *(double *)&v295;
            double v95 = *((double *)&v296 + 1);
            double v94 = *(double *)&v297;
          }
          else
          {
            long long v296 = 0u;
            long long v297 = 0u;
            double v94 = 0.0;
            double v92 = 0.0;
            double v95 = 0.0;
            double v93 = 0.0;
            long long v295 = 0u;
          }
          v96 = (float *)(v91 + 12 * (v88 >> 16));
          double v97 = (v93 + v95 * *v96) / *MEMORY[0x1E4F63F10];
          double v98 = 1.0 - (v92 + v94 * (float)(1.0 - v96[1])) / *(double *)(MEMORY[0x1E4F63F10] + 8);

          double v298 = v97;
          double v299 = v98;
          double v99 = *(&v298 + a4[2]);
          unint64_t v100 = *(v78 - 1);
          id v101 = *(id *)(*(void *)(v87 + 128) + 8 * (unsigned __int16)v100);
          uint64_t v102 = [v101 points];
          if (v101)
          {
            [v101 bounds];
            double v103 = *((double *)&v295 + 1);
            double v104 = *(double *)&v295;
            double v106 = *((double *)&v296 + 1);
            double v105 = *(double *)&v297;
          }
          else
          {
            long long v296 = 0u;
            long long v297 = 0u;
            double v105 = 0.0;
            double v103 = 0.0;
            double v106 = 0.0;
            double v104 = 0.0;
            long long v295 = 0u;
          }
          uint64_t v107 = v102 + 12 * (v100 >> 16);
          double v108 = (v104 + v106 * *(float *)(v107 + 12)) / *MEMORY[0x1E4F63F10];
          double v109 = 1.0 - (v103 + v105 * (float)(1.0 - *(float *)(v107 + 16))) / *(double *)(MEMORY[0x1E4F63F10] + 8);

          *(double *)&long long v295 = v108;
          *((double *)&v295 + 1) = v109;
          double v110 = *((double *)&v295 + a4[2]);
          unint64_t v111 = *v31;
          id v112 = *(id *)(*(void *)(v87 + 128) + 8 * (unsigned __int16)*v31);
          uint64_t v113 = [v112 points];
          if (v112)
          {
            [v112 bounds];
            double v114 = *((double *)&v295 + 1);
            double v115 = *(double *)&v295;
            double v117 = *((double *)&v296 + 1);
            double v116 = *(double *)&v297;
          }
          else
          {
            long long v296 = 0u;
            long long v297 = 0u;
            double v116 = 0.0;
            double v114 = 0.0;
            double v117 = 0.0;
            double v115 = 0.0;
            long long v295 = 0u;
          }
          v118 = (float *)(v113 + 12 * (v111 >> 16));
          double v119 = (v115 + v117 * *v118) / *MEMORY[0x1E4F63F10];
          double v120 = 1.0 - (v114 + v116 * (float)(1.0 - v118[1])) / *(double *)(MEMORY[0x1E4F63F10] + 8);

          double v298 = v119;
          double v299 = v120;
          double v121 = *(&v298 + a4[2]);
          unint64_t v122 = *v31;
          id v123 = *(id *)(*(void *)(v87 + 128) + 8 * (unsigned __int16)*v31);
          uint64_t v124 = [v123 points];
          if (v123)
          {
            [v123 bounds];
            double v80 = *((double *)&v295 + 1);
            double v82 = *(double *)&v295;
            double v81 = *((double *)&v296 + 1);
            double v79 = *(double *)&v297;
          }
          else
          {
            long long v296 = 0u;
            long long v297 = 0u;
            double v79 = 0.0;
            double v80 = 0.0;
            double v81 = 0.0;
            double v82 = 0.0;
            long long v295 = 0u;
          }
          double v83 = (v110 + v99) * 0.5;
          uint64_t v84 = v124 + 12 * (v122 >> 16);
          double v85 = (v82 + v81 * *(float *)(v84 + 12)) / *MEMORY[0x1E4F63F10];
          double v86 = 1.0 - (v80 + v79 * (float)(1.0 - *(float *)(v84 + 16))) / *(double *)(MEMORY[0x1E4F63F10] + 8);

          *(double *)&long long v295 = v85;
          *((double *)&v295 + 1) = v86;
          unint64_t v78 = v8;
        }
        while (v83 >= (*((double *)&v295 + a4[2]) + v121) * 0.5);
        if (j >= v8) {
          break;
        }
        int v125 = *j;
        int *j = *v8;
        *uint64_t v8 = v125;
        ++v293;
        if (v31 == j) {
          BOOL v7 = v8;
        }
        else {
          BOOL v7 = v31;
        }
        uint64_t v30 = v294 + 1;
      }
      a1 = i;
      v127 = v291;
      BOOL v7 = v31;
      double v29 = v288;
      uint64_t v126 = v294;
    }
    v128 = &a1[v126];
    v292 = v127;
    if (v128 == v7) {
      goto LABEL_52;
    }
    uint64_t v129 = *(void *)a4;
    *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *v7, 0);
    *((void *)&v295 + 1) = v130;
    double v131 = *((double *)&v295 + a4[2]);
    double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v129 + 128), *v7, 1);
    double v299 = v132;
    double v133 = (*(&v298 + a4[2]) + v131) * 0.5;
    *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v129 + 128), *v128, 0);
    *((void *)&v295 + 1) = v134;
    double v135 = *((double *)&v295 + a4[2]);
    double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v129 + 128), *v128, 1);
    double v299 = v136;
    if (v133 >= (*(&v298 + a4[2]) + v135) * 0.5)
    {
LABEL_52:
      int v138 = v293;
    }
    else
    {
      int v137 = *v128;
      int *v128 = *v7;
      *BOOL v7 = v137;
      int v138 = v293 + 1;
    }
    if (v128 == a2) {
      return;
    }
    if (!v138)
    {
      if (v128 <= a2)
      {
        for (unint64_t k = v128 + 1; k != v292; ++k)
        {
          uint64_t v166 = *(void *)a4;
          *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *k, 0);
          *((void *)&v295 + 1) = v167;
          double v168 = *((double *)&v295 + a4[2]);
          double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v166 + 128), *k, 1);
          double v299 = v169;
          double v170 = (*(&v298 + a4[2]) + v168) * 0.5;
          *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v166 + 128), *(k - 1), 0);
          *((void *)&v295 + 1) = v171;
          double v172 = *((double *)&v295 + a4[2]);
          double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v166 + 128), *(k - 1), 1);
          double v299 = v173;
          if (v170 < (*(&v298 + a4[2]) + v172) * 0.5) {
            goto LABEL_55;
          }
        }
        return;
      }
      if (v126 == 1) {
        return;
      }
      while (1)
      {
        uint64_t v141 = *(void *)a4;
        *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *v29, 0);
        *((void *)&v295 + 1) = v142;
        double v143 = *((double *)&v295 + a4[2]);
        double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v141 + 128), *v29, 1);
        double v299 = v144;
        double v145 = (*(&v298 + a4[2]) + v143) * 0.5;
        *(void *)&long long v295 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v141 + 128), *(v29 - 1), 0);
        *((void *)&v295 + 1) = v146;
        double v147 = *((double *)&v295 + a4[2]);
        double v298 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v141 + 128), *(v29 - 1), 1);
        double v299 = v148;
        if (v145 < (*(&v298 + a4[2]) + v147) * 0.5) {
          break;
        }
        if (++v29 == v128) {
          return;
        }
      }
    }
LABEL_55:
    v139 = v292;
    if (v128 > a2) {
      v139 = &a1[v126];
    }
    v291 = v139;
    if (v128 <= a2) {
      v140 = v128 + 1;
    }
    else {
      v140 = a1;
    }
LABEL_108:
    a1 = v140;
  }
  while (v291 != a2);
}

void sub_1A205CB48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteCollisionObject<md::MercatorPointSource>::partitionSegments(std::__wrap_iter<md::PointSource::SegmentIndex *>,std::__wrap_iter<md::PointSource::SegmentIndex *>,gm::Box<double,2> &)::{lambda(md::PointSource::SegmentIndex const&,md::PointSource::SegmentIndex const&)#1} &,std::__wrap_iter<md::PointSource::SegmentIndex *>>(int *a1, int *a2, int *a3, int *a4)
{
  uint64_t v8 = *(void *)a4;
  double v55 = md::MercatorPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *a2, 0);
  uint64_t v56 = v9;
  double v10 = *(&v55 + a4[2]);
  double v53 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v8 + 128), *a2, 1);
  uint64_t v54 = v11;
  double v12 = (*(&v53 + a4[2]) + v10) * 0.5;
  double v55 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v8 + 128), *a1, 0);
  uint64_t v56 = v13;
  double v14 = *(&v55 + a4[2]);
  double v53 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v8 + 128), *a1, 1);
  uint64_t v54 = v15;
  uint64_t v16 = *(void *)a4;
  if (v12 < (*(&v53 + a4[2]) + v14) * 0.5)
  {
    double v55 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v16 + 128), *a3, 0);
    uint64_t v56 = v17;
    double v18 = *(&v55 + a4[2]);
    double v53 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v16 + 128), *a3, 1);
    uint64_t v54 = v19;
    double v20 = (*(&v53 + a4[2]) + v18) * 0.5;
    double v55 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v16 + 128), *a2, 0);
    uint64_t v56 = v21;
    double v22 = *(&v55 + a4[2]);
    double v53 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v16 + 128), *a2, 1);
    uint64_t v54 = v23;
    int v24 = *a1;
    if (v20 < (*(&v53 + a4[2]) + v22) * 0.5)
    {
      *a1 = *a3;
      *a3 = v24;
      return 1;
    }
    *a1 = *a2;
    *a2 = v24;
    uint64_t v43 = *(void *)a4;
    double v55 = md::MercatorPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *a3, 0);
    uint64_t v56 = v44;
    double v45 = *(&v55 + a4[2]);
    uint64_t v25 = 1;
    double v53 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v43 + 128), *a3, 1);
    uint64_t v54 = v46;
    double v47 = (*(&v53 + a4[2]) + v45) * 0.5;
    double v55 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v43 + 128), *a2, 0);
    uint64_t v56 = v48;
    double v49 = *(&v55 + a4[2]);
    double v53 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v43 + 128), *a2, 1);
    uint64_t v54 = v50;
    if (v47 >= (*(&v53 + a4[2]) + v49) * 0.5) {
      return v25;
    }
    int v51 = *a2;
    *a2 = *a3;
    *a3 = v51;
    return 2;
  }
  double v55 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v16 + 128), *a3, 0);
  uint64_t v56 = v26;
  double v27 = *(&v55 + a4[2]);
  double v53 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v16 + 128), *a3, 1);
  uint64_t v54 = v28;
  double v29 = (*(&v53 + a4[2]) + v27) * 0.5;
  double v55 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v16 + 128), *a2, 0);
  uint64_t v56 = v30;
  double v31 = *(&v55 + a4[2]);
  uint64_t v25 = 0;
  double v53 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v16 + 128), *a2, 1);
  uint64_t v54 = v32;
  if (v29 < (*(&v53 + a4[2]) + v31) * 0.5)
  {
    int v33 = *a2;
    *a2 = *a3;
    *a3 = v33;
    uint64_t v34 = *(void *)a4;
    double v55 = md::MercatorPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *a2, 0);
    uint64_t v56 = v35;
    double v36 = *(&v55 + a4[2]);
    uint64_t v25 = 1;
    double v53 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v34 + 128), *a2, 1);
    uint64_t v54 = v37;
    double v38 = (*(&v53 + a4[2]) + v36) * 0.5;
    double v55 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v34 + 128), *a1, 0);
    uint64_t v56 = v39;
    double v40 = *(&v55 + a4[2]);
    double v53 = md::MercatorPointSource::segmentWorldPoint(*(void *)(v34 + 128), *a1, 1);
    uint64_t v54 = v41;
    if (v38 < (*(&v53 + a4[2]) + v40) * 0.5)
    {
      int v42 = *a1;
      *a1 = *a2;
      *a2 = v42;
      return 2;
    }
  }
  return v25;
}

void std::__shared_ptr_emplace<md::RouteCollisionObject<md::MercatorPointSource>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 152);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 160);
    uint64_t v4 = *(void **)(a1 + 152);
    if (v3 != v2)
    {
      do
      {
        unint64_t v5 = *(void **)(v3 - 8);
        v3 -= 8;
      }
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 152);
    }
    *(void *)(a1 + 160) = v2;
    operator delete(v4);
  }
  geo::Pool<md::RouteCollisionObject<md::MercatorPointSource>::Node>::disposeElements(a1 + 104);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 112));
  uint64_t v6 = *(void *)(a1 + 72);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 80);
    uint64_t v8 = *(void **)(a1 + 72);
    if (v7 != v6)
    {
      do
      {
        uint64_t v9 = *(void **)(v7 - 8);
        v7 -= 8;
      }
      while (v7 != v6);
      uint64_t v8 = *(void **)(a1 + 72);
    }
    *(void *)(a1 + 80) = v6;
    operator delete(v8);
  }
  double v10 = *(void **)(a1 + 48);
  if (v10)
  {
    *(void *)(a1 + 56) = v10;
    operator delete(v10);
  }
  *(void *)(a1 + 24) = &unk_1EF559678;
  uint64_t v11 = *(void **)(a1 + 32);
}

void sub_1A205D060(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 112));
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::RouteCollisionObject<md::MercatorPointSource>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5810C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::RouteCollisionObject<md::MercatorPointSource>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5810C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::RouteCollisionObject<md::GeocentricPointSource>::buildTopDownAABBTree(uint64_t a1, char **a2, int *a3, int *a4)
{
  uint64_t v8 = (uint64_t **)(a1 + 88);
  while (1)
  {
    uint64_t v9 = *(char **)(a1 + 120);
    if (!v9)
    {
      double v10 = (char *)malloc_type_malloc(*(void *)(a1 + 112), 0x160B39uLL);
      uint64_t v11 = v10;
      double v12 = *(uint64_t **)(a1 + 88);
      uint64_t v13 = v8;
      double v14 = v8;
      if (v12)
      {
        while (1)
        {
          while (1)
          {
            double v14 = (uint64_t **)v12;
            unint64_t v15 = v12[4];
            if ((unint64_t)v10 >= v15) {
              break;
            }
            double v12 = *v14;
            uint64_t v13 = v14;
            if (!*v14) {
              goto LABEL_11;
            }
          }
          if (v15 >= (unint64_t)v10) {
            break;
          }
          double v12 = v14[1];
          if (!v12)
          {
            uint64_t v13 = v14 + 1;
            goto LABEL_11;
          }
        }
      }
      else
      {
LABEL_11:
        uint64_t v16 = (uint64_t *)operator new(0x28uLL);
        v16[4] = (uint64_t)v11;
        *uint64_t v16 = 0;
        v16[1] = 0;
        v16[2] = (uint64_t)v14;
        *uint64_t v13 = v16;
        uint64_t v17 = **(void **)(a1 + 80);
        if (v17)
        {
          *(void *)(a1 + 80) = v17;
          double v18 = *v13;
        }
        else
        {
          double v18 = v16;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 88), v18);
        ++*(void *)(a1 + 96);
      }
      uint64_t v9 = *(char **)(a1 + 120);
      uint64_t v19 = 96 * *(void *)(a1 + 104) - 96;
      if ((v19 & 0x8000000000000000) == 0)
      {
        double v20 = &v11[v19];
        uint64_t v21 = &v11[v19];
        do
        {
          *(void *)uint64_t v21 = v9;
          v21 -= 96;
          uint64_t v9 = v20;
          double v20 = v21;
        }
        while (v21 >= v11);
        uint64_t v9 = v21 + 96;
      }
    }
    *(void *)(a1 + 120) = *(void *)v9;
    *a2 = v9;
    if (a3 == a4)
    {
      double v23 = 1.79769313e308;
      double v28 = -1.79769313e308;
      double v27 = -1.79769313e308;
      double v22 = -1.79769313e308;
      double v24 = 1.79769313e308;
      double v26 = 1.79769313e308;
    }
    else
    {
      double v22 = -1.79769313e308;
      double v23 = 1.79769313e308;
      double v24 = 1.79769313e308;
      uint64_t v25 = a3;
      double v26 = 1.79769313e308;
      double v27 = -1.79769313e308;
      double v28 = -1.79769313e308;
      do
      {
        double v29 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(a1 + 128), *v25, 0);
        double v30 = fmin(v29, v26);
        double v31 = fmax(v22, v29);
        double v33 = fmin(v32, v24);
        double v34 = fmax(v27, v32);
        double v36 = fmin(v35, v23);
        double v37 = fmax(v28, v35);
        int v38 = *v25++;
        double v39 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(a1 + 128), v38, 1);
        double v26 = fmin(v39, v30);
        double v22 = fmax(v31, v39);
        double v24 = fmin(v40, v33);
        double v27 = fmax(v34, v40);
        double v23 = fmin(v41, v36);
        double v28 = fmax(v37, v41);
      }
      while (v25 != a4);
    }
    *((double *)v9 + 3) = v26;
    *((double *)v9 + 4) = v24;
    *((double *)v9 + 5) = v23;
    *((double *)v9 + 6) = v22;
    *((double *)v9 + 7) = v27;
    *((double *)v9 + 8) = v28;
    int v60 = 0;
    LODWORD(v61[0]) = -1;
    if (a3 >= a4)
    {
      uint64_t v52 = 0xFFFFFFFFLL;
    }
    else
    {
      LOWORD(v42) = 0;
      LOWORD(v43) = 0;
      unsigned int v44 = 0xFFFF;
      LOWORD(v45) = -1;
      uint64_t v46 = a3;
      do
      {
        unsigned int v48 = *(unsigned __int16 *)v46;
        BOOL v49 = v48 == (unsigned __int16)v45;
        if (v48 > (unsigned __int16)v45 || (uint64_t v50 = v46, v49) && (uint64_t v50 = v46, v44 < *((unsigned __int16 *)v46 + 1))) {
          uint64_t v50 = (int *)v61;
        }
        uint64_t v45 = *v50;
        LODWORD(v61[0]) = v45;
        BOOL v51 = v48 == (unsigned __int16)v43;
        if (v48 < (unsigned __int16)v43
          || (double v47 = v46, v51) && (double v47 = v46, *((unsigned __int16 *)v46 + 1) < (unsigned __int16)v42))
        {
          double v47 = &v60;
        }
        unsigned int v44 = WORD1(v45);
        uint64_t v43 = *v47;
        int v60 = v43;
        ++v46;
        unsigned int v42 = WORD1(v43);
      }
      while (v46 < a4);
      uint64_t v52 = v45 | (v43 << 32);
    }
    uint64_t v53 = a4 - a3;
    *((void *)v9 + 11) = v52;
    if (v53 <= 4) {
      break;
    }
    *(_DWORD *)uint64_t v9 = 0;
    *((_DWORD *)v9 + 18) = v53;
    *((void *)v9 + 10) = 0;
    double v54 = fmax(v22 - v26, 0.0);
    double v55 = fmax(v27 - v24, 0.0);
    double v56 = fmax(v28 - v23, 0.0);
    BOOL v57 = v55 > v54;
    if (v55 > v54) {
      double v54 = v55;
    }
    uint64_t v58 = &a3[(v53 + (unint64_t)(v53 < 0)) >> 1];
    if (v56 <= v54) {
      uint64_t v59 = v57;
    }
    else {
      uint64_t v59 = 2;
    }
    v61[0] = a1;
    v61[1] = v59;
    if (v58 != a4) {
      std::__nth_element[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteCollisionObject<md::GeocentricPointSource>::partitionSegments(std::__wrap_iter<md::PointSource::SegmentIndex *>,std::__wrap_iter<md::PointSource::SegmentIndex *>,gm::Box<double,3> &)::{lambda(md::PointSource::SegmentIndex const&,md::PointSource::SegmentIndex const&)#1} &,std::__wrap_iter<md::PointSource::SegmentIndex *>>(a3, v58, a4, (int *)v61);
    }
    md::RouteCollisionObject<md::GeocentricPointSource>::buildTopDownAABBTree(a1, v9 + 8, a3, v58);
    a2 = (char **)(v9 + 16);
    a3 = v58;
  }
  *(_DWORD *)uint64_t v9 = 1;
  *((_DWORD *)v9 + 18) = v53;
  *((void *)v9 + 10) = a3;
}

uint64_t geo::Pool<md::RouteCollisionObject<md::GeocentricPointSource>::Node>::~Pool(uint64_t a1)
{
  return a1;
}

void sub_1A205D49C(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void geo::Pool<md::RouteCollisionObject<md::GeocentricPointSource>::Node>::disposeElements(uint64_t a1)
{
  double v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = &v14;
  for (uint64_t i = *(void **)(a1 + 40); i; *(void *)(a1 + 40) = i)
  {
    uint64_t v8 = &v14;
    uint64_t v9 = &v14;
    if (v14)
    {
      double v10 = v14;
      while (1)
      {
        while (1)
        {
          uint64_t v9 = (uint64_t **)v10;
          unint64_t v11 = v10[4];
          if ((unint64_t)i >= v11) {
            break;
          }
          double v10 = *v9;
          uint64_t v8 = v9;
          if (!*v9) {
            goto LABEL_20;
          }
        }
        if (v11 >= (unint64_t)i) {
          break;
        }
        double v10 = v9[1];
        if (!v10)
        {
          uint64_t v8 = v9 + 1;
          goto LABEL_20;
        }
      }
    }
    else
    {
LABEL_20:
      double v12 = (uint64_t *)operator new(0x28uLL);
      v12[4] = (uint64_t)i;
      *double v12 = 0;
      v12[1] = 0;
      v12[2] = (uint64_t)v9;
      *uint64_t v8 = v12;
      if (*v13)
      {
        uint64_t v13 = (uint64_t **)*v13;
        double v12 = *v8;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v14, v12);
      ++v15;
      uint64_t i = *(void **)(a1 + 40);
    }
    uint64_t i = (void *)*i;
  }
  uint64_t v3 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1 != a1 + 8)
  {
    do
    {
      free((void *)v4[4]);
      unint64_t v5 = (void *)v4[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          unint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void *)v4[2];
          BOOL v7 = *v6 == (void)v4;
          uint64_t v4 = v6;
        }
        while (!v7);
      }
      uint64_t v4 = v6;
    }
    while (v6 != v3);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v3;
  *(void *)(a1 + 40) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v14);
}

void sub_1A205D610(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v1);
  _Unwind_Resume(a1);
}

void std::__nth_element[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteCollisionObject<md::GeocentricPointSource>::partitionSegments(std::__wrap_iter<md::PointSource::SegmentIndex *>,std::__wrap_iter<md::PointSource::SegmentIndex *>,gm::Box<double,3> &)::{lambda(md::PointSource::SegmentIndex const&,md::PointSource::SegmentIndex const&)#1} &,std::__wrap_iter<md::PointSource::SegmentIndex *>>(int *a1, int *a2, int *a3, int *a4)
{
  v428 = a3;
  if (a3 == a2) {
    return;
  }
  float v6 = 1.0;
  do
  {
    unint64_t v7 = v428 - a1;
    if (v7 < 2) {
      return;
    }
    if (v7 == 3)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteCollisionObject<md::GeocentricPointSource>::partitionSegments(std::__wrap_iter<md::PointSource::SegmentIndex *>,std::__wrap_iter<md::PointSource::SegmentIndex *>,gm::Box<double,3> &)::{lambda(md::PointSource::SegmentIndex const&,md::PointSource::SegmentIndex const&)#1} &,std::__wrap_iter<md::PointSource::SegmentIndex *>>(a1, a1 + 1, v428 - 1, a4);
      return;
    }
    if (v7 == 2)
    {
      uint64_t v395 = *(void *)a4;
      *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *(v428 - 1), 0);
      *((void *)&v432 + 1) = v396;
      *(void *)&long long v433 = v397;
      double v398 = *((double *)&v432 + a4[2]);
      double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v395 + 128), *(v428 - 1), 1);
      double v436 = v399;
      double v437 = v400;
      double v401 = (*(&v435 + a4[2]) + v398) * 0.5;
      *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v395 + 128), *a1, 0);
      *((void *)&v432 + 1) = v402;
      *(void *)&long long v433 = v403;
      double v404 = *((double *)&v432 + a4[2]);
      double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v395 + 128), *a1, 1);
      double v436 = v405;
      double v437 = v406;
      if (v401 < (*(&v435 + a4[2]) + v404) * 0.5)
      {
        int v407 = *a1;
        *a1 = *(v428 - 1);
        *(v428 - 1) = v407;
      }
      return;
    }
    if ((char *)v428 - (char *)a1 <= 31)
    {
      for (; a1 != v428 - 1; ++a1)
      {
        v408 = v428;
        if (a1 != v428)
        {
          v409 = a1 + 1;
          v408 = a1;
          if (a1 + 1 != v428)
          {
            v408 = a1;
            v410 = a1 + 1;
            do
            {
              uint64_t v411 = *(void *)a4;
              *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *v409, 0);
              *((void *)&v432 + 1) = v412;
              *(void *)&long long v433 = v413;
              double v414 = *((double *)&v432 + a4[2]);
              int v415 = *v410++;
              double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v411 + 128), v415, 1);
              double v436 = v416;
              double v437 = v417;
              double v418 = (*(&v435 + a4[2]) + v414) * 0.5;
              *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v411 + 128), *v408, 0);
              *((void *)&v432 + 1) = v419;
              *(void *)&long long v433 = v420;
              double v421 = *((double *)&v432 + a4[2]);
              double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v411 + 128), *v408, 1);
              double v436 = v422;
              double v437 = v423;
              if (v418 < (*(&v435 + a4[2]) + v421) * 0.5) {
                v408 = v409;
              }
              v409 = v410;
            }
            while (v410 != v428);
          }
        }
        if (a1 != v408)
        {
          int v424 = *a1;
          *a1 = *v408;
          int *v408 = v424;
        }
      }
      return;
    }
    uint64_t v8 = &a1[v7 >> 1];
    uint64_t v9 = v428 - 1;
    int v430 = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteCollisionObject<md::GeocentricPointSource>::partitionSegments(std::__wrap_iter<md::PointSource::SegmentIndex *>,std::__wrap_iter<md::PointSource::SegmentIndex *>,gm::Box<double,3> &)::{lambda(md::PointSource::SegmentIndex const&,md::PointSource::SegmentIndex const&)#1} &,std::__wrap_iter<md::PointSource::SegmentIndex *>>(a1, v8, v428 - 1, a4);
    uint64_t v10 = *(void *)a4;
    *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *a1, 0);
    *((void *)&v432 + 1) = v11;
    *(void *)&long long v433 = v12;
    double v13 = *((double *)&v432 + a4[2]);
    double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v10 + 128), *a1, 1);
    double v436 = v14;
    double v437 = v15;
    double v16 = (*(&v435 + a4[2]) + v13) * 0.5;
    *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v10 + 128), *v8, 0);
    *((void *)&v432 + 1) = v17;
    *(void *)&long long v433 = v18;
    double v19 = *((double *)&v432 + a4[2]);
    double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v10 + 128), *v8, 1);
    double v436 = v20;
    double v437 = v21;
    if (v16 >= (*(&v435 + a4[2]) + v19) * 0.5)
    {
      double v22 = v428 - 2;
      do
      {
        if (v22 == a1)
        {
          uint64_t v217 = *(void *)a4;
          *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *a1, 0);
          *((void *)&v432 + 1) = v218;
          *(void *)&long long v433 = v219;
          double v220 = *((double *)&v432 + a4[2]);
          double v204 = a1 + 1;
          double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v217 + 128), *a1, 1);
          double v436 = v221;
          double v437 = v222;
          double v223 = (*(&v435 + a4[2]) + v220) * 0.5;
          *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v217 + 128), *v9, 0);
          *((void *)&v432 + 1) = v224;
          *(void *)&long long v433 = v225;
          double v226 = *((double *)&v432 + a4[2]);
          double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v217 + 128), *v9, 1);
          double v436 = v227;
          double v437 = v228;
          if (v223 >= (*(&v435 + a4[2]) + v226) * 0.5)
          {
            if (v204 == v9) {
              return;
            }
            while (1)
            {
              uint64_t v229 = *(void *)a4;
              *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *a1, 0);
              *((void *)&v432 + 1) = v230;
              *(void *)&long long v433 = v231;
              double v232 = *((double *)&v432 + a4[2]);
              double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v229 + 128), *a1, 1);
              double v436 = v233;
              double v437 = v234;
              double v235 = (*(&v435 + a4[2]) + v232) * 0.5;
              *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v229 + 128), *v204, 0);
              *((void *)&v432 + 1) = v236;
              *(void *)&long long v433 = v237;
              double v238 = *((double *)&v432 + a4[2]);
              double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v229 + 128), *v204, 1);
              double v436 = v239;
              double v437 = v240;
              if (v235 < (*(&v435 + a4[2]) + v238) * 0.5) {
                break;
              }
              if (++v204 == v9) {
                return;
              }
            }
            int v254 = *v204;
            *v204++ = *v9;
            *uint64_t v9 = v254;
          }
          if (v204 == v9) {
            return;
          }
          while (1)
          {
            uint64_t v256 = *(void *)a4;
            unint64_t v257 = *a1;
            id v258 = *(id *)(*(void *)(*(void *)a4 + 128) + 8 * (unsigned __int16)*a1);
            uint64_t v259 = [v258 points];
            if (v258)
            {
              [v258 bounds];
              double v260 = *((double *)&v432 + 1);
              double v261 = *(double *)&v432;
              double v263 = *((double *)&v433 + 1);
              double v262 = *(double *)&v434;
            }
            else
            {
              long long v433 = 0u;
              long long v434 = 0u;
              double v262 = 0.0;
              double v260 = 0.0;
              double v263 = 0.0;
              double v261 = 0.0;
              long long v432 = 0u;
            }
            id v264 = (float *)(v259 + 12 * (v257 >> 16));
            long double v265 = (v261 + v263 * *v264) * 6.28318531 / *MEMORY[0x1E4F63F10];
            long double v266 = exp(3.14159265- (v260 + v262 * (float)(1.0 - v264[1])) * 6.28318531 / *(double *)(MEMORY[0x1E4F63F10] + 8));
            double v267 = atan(v266) * 2.0 + -1.57079633;
            long double v268 = fmod(v265, 6.28318531);
            double v269 = fmod(v268 + 6.28318531, 6.28318531) + -3.14159265;
            __double2 v270 = __sincos_stret(v267);
            double v271 = 6378137.0 / sqrt(v270.__sinval * v270.__sinval * -0.00669437999 + 1.0);
            __double2 v272 = __sincos_stret(v269);

            double v435 = v271 * v270.__cosval * v272.__cosval;
            double v436 = v271 * v270.__cosval * v272.__sinval;
            double v437 = v270.__sinval * 0.99330562 * v271;
            double v273 = *(&v435 + a4[2]);
            unint64_t v274 = *a1;
            id v275 = *(id *)(*(void *)(v256 + 128) + 8 * (unsigned __int16)*a1);
            uint64_t v276 = [v275 points];
            if (v275)
            {
              [v275 bounds];
              double v277 = *((double *)&v432 + 1);
              double v278 = *(double *)&v432;
              double v280 = *((double *)&v433 + 1);
              double v279 = *(double *)&v434;
            }
            else
            {
              long long v433 = 0u;
              long long v434 = 0u;
              double v279 = 0.0;
              double v277 = 0.0;
              double v280 = 0.0;
              double v278 = 0.0;
              long long v432 = 0u;
            }
            uint64_t v281 = v276 + 12 * (v274 >> 16);
            long double v282 = (v278 + v280 * *(float *)(v281 + 12)) * 6.28318531 / *MEMORY[0x1E4F63F10];
            long double v283 = exp(3.14159265- (v277 + v279 * (float)(1.0 - *(float *)(v281 + 16)))* 6.28318531/ *(double *)(MEMORY[0x1E4F63F10] + 8));
            double v284 = atan(v283) * 2.0 + -1.57079633;
            long double v285 = fmod(v282, 6.28318531);
            double v286 = fmod(v285 + 6.28318531, 6.28318531) + -3.14159265;
            __double2 v287 = __sincos_stret(v284);
            double v288 = 6378137.0 / sqrt(v287.__sinval * v287.__sinval * -0.00669437999 + 1.0);
            __double2 v289 = __sincos_stret(v286);

            *(double *)&long long v432 = v288 * v287.__cosval * v289.__cosval;
            *((double *)&v432 + 1) = v288 * v287.__cosval * v289.__sinval;
            *(double *)&long long v433 = v287.__sinval * 0.99330562 * v288;
            double v290 = *((double *)&v432 + a4[2]);
            unint64_t v291 = *v204;
            id v292 = *(id *)(*(void *)(v256 + 128) + 8 * (unsigned __int16)*v204);
            uint64_t v293 = [v292 points];
            if (v292)
            {
              [v292 bounds];
              double v294 = *((double *)&v432 + 1);
              double v295 = *(double *)&v432;
              double v297 = *((double *)&v433 + 1);
              double v296 = *(double *)&v434;
            }
            else
            {
              long long v433 = 0u;
              long long v434 = 0u;
              double v296 = 0.0;
              double v294 = 0.0;
              double v297 = 0.0;
              double v295 = 0.0;
              long long v432 = 0u;
            }
            double v298 = (float *)(v293 + 12 * (v291 >> 16));
            long double v299 = (v295 + v297 * *v298) * 6.28318531 / *MEMORY[0x1E4F63F10];
            long double v300 = exp(3.14159265- (v294 + v296 * (float)(1.0 - v298[1])) * 6.28318531 / *(double *)(MEMORY[0x1E4F63F10] + 8));
            double v301 = atan(v300) * 2.0 + -1.57079633;
            long double v302 = fmod(v299, 6.28318531);
            double v303 = fmod(v302 + 6.28318531, 6.28318531) + -3.14159265;
            __double2 v304 = __sincos_stret(v301);
            double v305 = 6378137.0 / sqrt(v304.__sinval * v304.__sinval * -0.00669437999 + 1.0);
            __double2 v306 = __sincos_stret(v303);

            double v435 = v305 * v304.__cosval * v306.__cosval;
            double v436 = v305 * v304.__cosval * v306.__sinval;
            double v437 = v304.__sinval * 0.99330562 * v305;
            double v307 = *(&v435 + a4[2]);
            unint64_t v308 = *v204;
            id v309 = *(id *)(*(void *)(v256 + 128) + 8 * (unsigned __int16)*v204);
            uint64_t v310 = [v309 points];
            if (v309)
            {
              [v309 bounds];
              double v311 = *((double *)&v432 + 1);
              double v312 = *(double *)&v432;
              double v314 = *((double *)&v433 + 1);
              double v313 = *(double *)&v434;
            }
            else
            {
              long long v433 = 0u;
              long long v434 = 0u;
              double v313 = 0.0;
              double v311 = 0.0;
              double v314 = 0.0;
              double v312 = 0.0;
              long long v432 = 0u;
            }
            uint64_t v315 = v310 + 12 * (v308 >> 16);
            long double v316 = (v312 + v314 * *(float *)(v315 + 12)) * 6.28318531 / *MEMORY[0x1E4F63F10];
            long double v317 = exp(3.14159265- (v311 + v313 * (float)(1.0 - *(float *)(v315 + 16)))* 6.28318531/ *(double *)(MEMORY[0x1E4F63F10] + 8));
            double v318 = atan(v317) * 2.0 + -1.57079633;
            long double v319 = fmod(v316, 6.28318531);
            double v320 = fmod(v319 + 6.28318531, 6.28318531) + -3.14159265;
            __double2 v321 = __sincos_stret(v318);
            double v322 = 6378137.0 / sqrt(v321.__sinval * v321.__sinval * -0.00669437999 + 1.0);
            __double2 v323 = __sincos_stret(v320);

            *(double *)&long long v432 = v322 * v321.__cosval * v323.__cosval;
            *((double *)&v432 + 1) = v322 * v321.__cosval * v323.__sinval;
            *(double *)&long long v433 = v321.__sinval * 0.99330562 * v322;
            if ((v290 + v273) * 0.5 < (*((double *)&v432 + a4[2]) + v307) * 0.5)
            {
              do
              {
                uint64_t v339 = *(void *)a4;
                unint64_t v340 = *a1;
                id v341 = *(id *)(*(void *)(*(void *)a4 + 128) + 8 * (unsigned __int16)*a1);
                uint64_t v342 = [v341 points];
                if (v341)
                {
                  [v341 bounds];
                  float v343 = 1.0;
                  double v344 = *((double *)&v432 + 1);
                  double v345 = *(double *)&v432;
                  double v347 = *((double *)&v433 + 1);
                  double v346 = *(double *)&v434;
                }
                else
                {
                  long long v433 = 0u;
                  long long v434 = 0u;
                  double v346 = 0.0;
                  double v344 = 0.0;
                  double v347 = 0.0;
                  double v345 = 0.0;
                  long long v432 = 0u;
                  float v343 = 1.0;
                }
                v348 = (float *)(v342 + 12 * (v340 >> 16));
                long double v349 = (v345 + v347 * *v348) * 6.28318531 / *MEMORY[0x1E4F63F10];
                long double v350 = exp(3.14159265- (v344 + v346 * (float)(v343 - v348[1])) * 6.28318531 / *(double *)(MEMORY[0x1E4F63F10] + 8));
                double v351 = atan(v350) * 2.0 + -1.57079633;
                long double v352 = fmod(v349, 6.28318531);
                double v353 = fmod(v352 + 6.28318531, 6.28318531) + -3.14159265;
                __double2 v354 = __sincos_stret(v351);
                double v355 = 6378137.0 / sqrt(v354.__sinval * v354.__sinval * -0.00669437999 + 1.0);
                __double2 v356 = __sincos_stret(v353);

                double v435 = v355 * v354.__cosval * v356.__cosval;
                double v436 = v355 * v354.__cosval * v356.__sinval;
                double v437 = v354.__sinval * 0.99330562 * v355;
                double v357 = *(&v435 + a4[2]);
                unint64_t v358 = *a1;
                id v359 = *(id *)(*(void *)(v339 + 128) + 8 * (unsigned __int16)*a1);
                uint64_t v360 = [v359 points];
                if (v359)
                {
                  [v359 bounds];
                  double v361 = *((double *)&v432 + 1);
                  double v362 = *(double *)&v432;
                  double v364 = *((double *)&v433 + 1);
                  double v363 = *(double *)&v434;
                }
                else
                {
                  long long v433 = 0u;
                  long long v434 = 0u;
                  double v363 = 0.0;
                  double v361 = 0.0;
                  double v364 = 0.0;
                  double v362 = 0.0;
                  long long v432 = 0u;
                }
                uint64_t v365 = v360 + 12 * (v358 >> 16);
                long double v366 = (v362 + v364 * *(float *)(v365 + 12)) * 6.28318531 / *MEMORY[0x1E4F63F10];
                long double v367 = exp(3.14159265- (v361 + v363 * (float)(v343 - *(float *)(v365 + 16)))* 6.28318531/ *(double *)(MEMORY[0x1E4F63F10] + 8));
                double v368 = atan(v367) * 2.0 + -1.57079633;
                long double v369 = fmod(v366, 6.28318531);
                double v370 = fmod(v369 + 6.28318531, 6.28318531) + -3.14159265;
                __double2 v371 = __sincos_stret(v368);
                double v372 = 6378137.0 / sqrt(v371.__sinval * v371.__sinval * -0.00669437999 + 1.0);
                __double2 v373 = __sincos_stret(v370);

                *(double *)&long long v432 = v372 * v371.__cosval * v373.__cosval;
                *((double *)&v432 + 1) = v372 * v371.__cosval * v373.__sinval;
                *(double *)&long long v433 = v371.__sinval * 0.99330562 * v372;
                double v374 = *((double *)&v432 + a4[2]);
                unint64_t v375 = *(v9 - 1);
                id v376 = *(id *)(*(void *)(v339 + 128) + 8 * (unsigned __int16)*(v9 - 1));
                uint64_t v377 = [v376 points];
                if (v376)
                {
                  [v376 bounds];
                  double v378 = *((double *)&v432 + 1);
                  double v379 = *(double *)&v432;
                  double v381 = *((double *)&v433 + 1);
                  double v380 = *(double *)&v434;
                }
                else
                {
                  long long v433 = 0u;
                  long long v434 = 0u;
                  double v380 = 0.0;
                  double v378 = 0.0;
                  double v381 = 0.0;
                  double v379 = 0.0;
                  long long v432 = 0u;
                }
                v382 = (float *)(v377 + 12 * (v375 >> 16));
                long double v383 = (v379 + v381 * *v382) * 6.28318531 / *MEMORY[0x1E4F63F10];
                long double v384 = exp(3.14159265- (v378 + v380 * (float)(v343 - v382[1])) * 6.28318531 / *(double *)(MEMORY[0x1E4F63F10] + 8));
                double v385 = atan(v384) * 2.0 + -1.57079633;
                long double v386 = fmod(v383, 6.28318531);
                double v387 = fmod(v386 + 6.28318531, 6.28318531) + -3.14159265;
                __double2 v388 = __sincos_stret(v385);
                double v389 = 6378137.0 / sqrt(v388.__sinval * v388.__sinval * -0.00669437999 + 1.0);
                __double2 v390 = __sincos_stret(v387);

                double v435 = v389 * v388.__cosval * v390.__cosval;
                double v436 = v389 * v388.__cosval * v390.__sinval;
                double v437 = v388.__sinval * 0.99330562 * v389;
                double v391 = *(&v435 + a4[2]);
                unint64_t v392 = *(v9 - 1);
                id v393 = *(id *)(*(void *)(v339 + 128) + 8 * (unsigned __int16)*(v9 - 1));
                uint64_t v394 = [v393 points];
                if (v393)
                {
                  [v393 bounds];
                  float v324 = 1.0;
                  double v326 = *((double *)&v432 + 1);
                  double v328 = *(double *)&v432;
                  double v327 = *((double *)&v433 + 1);
                  double v325 = *(double *)&v434;
                }
                else
                {
                  float v324 = 1.0;
                  long long v433 = 0u;
                  long long v434 = 0u;
                  double v325 = 0.0;
                  double v326 = 0.0;
                  double v327 = 0.0;
                  double v328 = 0.0;
                  long long v432 = 0u;
                }
                --v9;
                double v329 = (v374 + v357) * 0.5;
                uint64_t v330 = v394 + 12 * (v392 >> 16);
                long double v331 = (v328 + v327 * *(float *)(v330 + 12)) * 6.28318531 / *MEMORY[0x1E4F63F10];
                long double v332 = exp(3.14159265- (v326 + v325 * (float)(v324 - *(float *)(v330 + 16)))* 6.28318531/ *(double *)(MEMORY[0x1E4F63F10] + 8));
                double v333 = atan(v332) * 2.0 + -1.57079633;
                long double v334 = fmod(v331, 6.28318531);
                double v335 = fmod(v334 + 6.28318531, 6.28318531) + -3.14159265;
                __double2 v336 = __sincos_stret(v333);
                double v337 = 6378137.0 / sqrt(v336.__sinval * v336.__sinval * -0.00669437999 + 1.0);
                __double2 v338 = __sincos_stret(v335);

                *(double *)&long long v432 = v337 * v336.__cosval * v338.__cosval;
                *((double *)&v432 + 1) = v337 * v336.__cosval * v338.__sinval;
                *(double *)&long long v433 = v336.__sinval * 0.99330562 * v337;
              }
              while (v329 < (*((double *)&v432 + a4[2]) + v391) * 0.5);
              if (v204 >= v9)
              {
                float v6 = 1.0;
                if (v204 <= a2) {
                  goto LABEL_109;
                }
                return;
              }
              int v255 = *v204;
              *double v204 = *v9;
              *uint64_t v9 = v255;
            }
            ++v204;
          }
        }
        double v23 = v22;
        uint64_t v24 = *(void *)a4;
        *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *v22, 0);
        *((void *)&v432 + 1) = v25;
        *(void *)&long long v433 = v26;
        double v27 = *((double *)&v432 + a4[2]);
        int v28 = *v22--;
        double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v24 + 128), v28, 1);
        double v436 = v29;
        double v437 = v30;
        double v31 = (*(&v435 + a4[2]) + v27) * 0.5;
        *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v24 + 128), *v8, 0);
        *((void *)&v432 + 1) = v32;
        *(void *)&long long v433 = v33;
        double v34 = *((double *)&v432 + a4[2]);
        double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v24 + 128), *v8, 1);
        double v436 = v35;
        double v437 = v36;
      }
      while (v31 >= (*(&v435 + a4[2]) + v34) * 0.5);
      int v37 = *a1;
      *a1 = *v23;
      int *v23 = v37;
      ++v430;
      uint64_t v9 = v23;
    }
    int v38 = a1 + 1;
    if (a1 + 1 >= v9)
    {
      uint64_t v186 = 1;
      double v187 = v428;
    }
    else
    {
      v425 = a1 + 1;
      uint64_t v39 = 1;
      v427 = a1;
      while (1)
      {
        double v40 = v8;
        uint64_t v431 = v39;
        for (uint64_t i = &a1[v39]; ; ++i)
        {
          uint64_t v42 = *(void *)a4;
          unint64_t v43 = *i;
          id v44 = *(id *)(*(void *)(*(void *)a4 + 128) + 8 * (unsigned __int16)*i);
          uint64_t v45 = [v44 points];
          if (v44)
          {
            [v44 bounds];
            double v46 = *((double *)&v432 + 1);
            double v47 = *(double *)&v432;
            double v49 = *((double *)&v433 + 1);
            double v48 = *(double *)&v434;
          }
          else
          {
            long long v433 = 0u;
            long long v434 = 0u;
            double v48 = 0.0;
            double v46 = 0.0;
            double v49 = 0.0;
            double v47 = 0.0;
            long long v432 = 0u;
          }
          uint64_t v50 = (float *)(v45 + 12 * (v43 >> 16));
          long double v51 = (v47 + v49 * *v50) * 6.28318531 / *MEMORY[0x1E4F63F10];
          long double v52 = exp(3.14159265 - (v46 + v48 * (float)(v6 - v50[1]))
                               * 6.28318531
                               / *(double *)(MEMORY[0x1E4F63F10] + 8));
          double v53 = atan(v52) * 2.0 + -1.57079633;
          long double v54 = fmod(v51, 6.28318531);
          double v55 = fmod(v54 + 6.28318531, 6.28318531) + -3.14159265;
          __double2 v56 = __sincos_stret(v53);
          double v57 = 6378137.0 / sqrt(v56.__sinval * v56.__sinval * -0.00669437999 + 1.0);
          __double2 v58 = __sincos_stret(v55);

          double v435 = v57 * v56.__cosval * v58.__cosval;
          double v436 = v57 * v56.__cosval * v58.__sinval;
          double v437 = v56.__sinval * 0.99330562 * v57;
          double v59 = *(&v435 + a4[2]);
          unint64_t v60 = *i;
          id v61 = *(id *)(*(void *)(v42 + 128) + 8 * (unsigned __int16)*i);
          uint64_t v62 = [v61 points];
          if (v61)
          {
            [v61 bounds];
            double v63 = *((double *)&v432 + 1);
            double v64 = *(double *)&v432;
            double v66 = *((double *)&v433 + 1);
            double v65 = *(double *)&v434;
          }
          else
          {
            long long v433 = 0u;
            long long v434 = 0u;
            double v65 = 0.0;
            double v63 = 0.0;
            double v66 = 0.0;
            double v64 = 0.0;
            long long v432 = 0u;
          }
          uint64_t v67 = v62 + 12 * (v60 >> 16);
          long double v68 = (v64 + v66 * *(float *)(v67 + 12)) * 6.28318531 / *MEMORY[0x1E4F63F10];
          long double v69 = exp(3.14159265- (v63 + v65 * (float)(v6 - *(float *)(v67 + 16))) * 6.28318531 / *(double *)(MEMORY[0x1E4F63F10] + 8));
          double v70 = atan(v69) * 2.0 + -1.57079633;
          long double v71 = fmod(v68, 6.28318531);
          double v72 = fmod(v71 + 6.28318531, 6.28318531) + -3.14159265;
          __double2 v73 = __sincos_stret(v70);
          double v74 = 6378137.0 / sqrt(v73.__sinval * v73.__sinval * -0.00669437999 + 1.0);
          __double2 v75 = __sincos_stret(v72);

          *(double *)&long long v432 = v74 * v73.__cosval * v75.__cosval;
          *((double *)&v432 + 1) = v74 * v73.__cosval * v75.__sinval;
          *(double *)&long long v433 = v73.__sinval * 0.99330562 * v74;
          double v76 = *((double *)&v432 + a4[2]);
          unint64_t v77 = *v40;
          id v78 = *(id *)(*(void *)(v42 + 128) + 8 * (unsigned __int16)*v40);
          uint64_t v79 = [v78 points];
          if (v78)
          {
            [v78 bounds];
            double v80 = *((double *)&v432 + 1);
            double v81 = *(double *)&v432;
            double v83 = *((double *)&v433 + 1);
            double v82 = *(double *)&v434;
          }
          else
          {
            long long v433 = 0u;
            long long v434 = 0u;
            double v82 = 0.0;
            double v80 = 0.0;
            double v83 = 0.0;
            double v81 = 0.0;
            long long v432 = 0u;
          }
          uint64_t v84 = (float *)(v79 + 12 * (v77 >> 16));
          long double v85 = (v81 + v83 * *v84) * 6.28318531 / *MEMORY[0x1E4F63F10];
          long double v86 = exp(3.14159265 - (v80 + v82 * (float)(v6 - v84[1]))
                               * 6.28318531
                               / *(double *)(MEMORY[0x1E4F63F10] + 8));
          double v87 = atan(v86) * 2.0 + -1.57079633;
          long double v88 = fmod(v85, 6.28318531);
          double v89 = fmod(v88 + 6.28318531, 6.28318531) + -3.14159265;
          __double2 v90 = __sincos_stret(v87);
          double v91 = 6378137.0 / sqrt(v90.__sinval * v90.__sinval * -0.00669437999 + 1.0);
          __double2 v92 = __sincos_stret(v89);

          double v435 = v91 * v90.__cosval * v92.__cosval;
          double v436 = v91 * v90.__cosval * v92.__sinval;
          double v437 = v90.__sinval * 0.99330562 * v91;
          double v93 = *(&v435 + a4[2]);
          unint64_t v94 = *v40;
          id v95 = *(id *)(*(void *)(v42 + 128) + 8 * (unsigned __int16)*v40);
          uint64_t v96 = [v95 points];
          if (v95)
          {
            [v95 bounds];
            float v97 = 1.0;
            double v98 = *((double *)&v432 + 1);
            double v99 = *(double *)&v432;
            double v101 = *((double *)&v433 + 1);
            double v100 = *(double *)&v434;
          }
          else
          {
            float v97 = 1.0;
            long long v433 = 0u;
            long long v434 = 0u;
            double v100 = 0.0;
            double v98 = 0.0;
            double v101 = 0.0;
            double v99 = 0.0;
            long long v432 = 0u;
          }
          double v102 = (v76 + v59) * 0.5;
          uint64_t v103 = v96 + 12 * (v94 >> 16);
          long double v104 = (v99 + v101 * *(float *)(v103 + 12)) * 6.28318531 / *MEMORY[0x1E4F63F10];
          long double v105 = exp(3.14159265- (v98 + v100 * (float)(v97 - *(float *)(v103 + 16)))* 6.28318531/ *(double *)(MEMORY[0x1E4F63F10] + 8));
          double v106 = atan(v105) * 2.0 + -1.57079633;
          long double v107 = fmod(v104, 6.28318531);
          double v108 = fmod(v107 + 6.28318531, 6.28318531) + -3.14159265;
          __double2 v109 = __sincos_stret(v106);
          double v110 = 6378137.0 / sqrt(v109.__sinval * v109.__sinval * -0.00669437999 + 1.0);
          __double2 v111 = __sincos_stret(v108);

          *(double *)&long long v432 = v110 * v109.__cosval * v111.__cosval;
          *((double *)&v432 + 1) = v110 * v109.__cosval * v111.__sinval;
          *(double *)&long long v433 = v109.__sinval * 0.99330562 * v110;
          if (v102 >= (*((double *)&v432 + a4[2]) + v93) * 0.5) {
            break;
          }
          ++v431;
          float v6 = 1.0;
        }
        id v112 = v9;
        do
        {
          uint64_t v128 = *(void *)a4;
          unsigned int v130 = *--v9;
          unint64_t v129 = v130;
          id v131 = *(id *)(*(void *)(*(void *)a4 + 128) + 8 * (unsigned __int16)v130);
          uint64_t v132 = [v131 points];
          if (v131)
          {
            [v131 bounds];
            float v133 = 1.0;
            double v134 = *((double *)&v432 + 1);
            double v135 = *(double *)&v432;
            double v137 = *((double *)&v433 + 1);
            double v136 = *(double *)&v434;
          }
          else
          {
            long long v433 = 0u;
            long long v434 = 0u;
            double v136 = 0.0;
            double v134 = 0.0;
            double v137 = 0.0;
            double v135 = 0.0;
            long long v432 = 0u;
            float v133 = 1.0;
          }
          int v138 = (float *)(v132 + 12 * (v129 >> 16));
          long double v139 = (v135 + v137 * *v138) * 6.28318531 / *MEMORY[0x1E4F63F10];
          long double v140 = exp(3.14159265- (v134 + v136 * (float)(v133 - v138[1])) * 6.28318531 / *(double *)(MEMORY[0x1E4F63F10] + 8));
          double v141 = atan(v140) * 2.0 + -1.57079633;
          long double v142 = fmod(v139, 6.28318531);
          double v143 = fmod(v142 + 6.28318531, 6.28318531) + -3.14159265;
          __double2 v144 = __sincos_stret(v141);
          double v145 = 6378137.0 / sqrt(v144.__sinval * v144.__sinval * -0.00669437999 + 1.0);
          __double2 v146 = __sincos_stret(v143);

          double v435 = v145 * v144.__cosval * v146.__cosval;
          double v436 = v145 * v144.__cosval * v146.__sinval;
          double v437 = v144.__sinval * 0.99330562 * v145;
          double v147 = *(&v435 + a4[2]);
          unint64_t v148 = *(v112 - 1);
          id v149 = *(id *)(*(void *)(v128 + 128) + 8 * (unsigned __int16)v148);
          uint64_t v150 = [v149 points];
          if (v149)
          {
            [v149 bounds];
            double v151 = *((double *)&v432 + 1);
            double v152 = *(double *)&v432;
            double v154 = *((double *)&v433 + 1);
            double v153 = *(double *)&v434;
          }
          else
          {
            long long v433 = 0u;
            long long v434 = 0u;
            double v153 = 0.0;
            double v151 = 0.0;
            double v154 = 0.0;
            double v152 = 0.0;
            long long v432 = 0u;
          }
          uint64_t v155 = v150 + 12 * (v148 >> 16);
          long double v156 = (v152 + v154 * *(float *)(v155 + 12)) * 6.28318531 / *MEMORY[0x1E4F63F10];
          long double v157 = exp(3.14159265- (v151 + v153 * (float)(v133 - *(float *)(v155 + 16)))* 6.28318531/ *(double *)(MEMORY[0x1E4F63F10] + 8));
          double v158 = atan(v157) * 2.0 + -1.57079633;
          long double v159 = fmod(v156, 6.28318531);
          double v160 = fmod(v159 + 6.28318531, 6.28318531) + -3.14159265;
          __double2 v161 = __sincos_stret(v158);
          double v162 = 6378137.0 / sqrt(v161.__sinval * v161.__sinval * -0.00669437999 + 1.0);
          __double2 v163 = __sincos_stret(v160);

          *(double *)&long long v432 = v162 * v161.__cosval * v163.__cosval;
          *((double *)&v432 + 1) = v162 * v161.__cosval * v163.__sinval;
          *(double *)&long long v433 = v161.__sinval * 0.99330562 * v162;
          double v164 = *((double *)&v432 + a4[2]);
          unint64_t v165 = *v40;
          id v166 = *(id *)(*(void *)(v128 + 128) + 8 * (unsigned __int16)*v40);
          uint64_t v167 = [v166 points];
          if (v166)
          {
            [v166 bounds];
            double v168 = *((double *)&v432 + 1);
            double v169 = *(double *)&v432;
            double v171 = *((double *)&v433 + 1);
            double v170 = *(double *)&v434;
          }
          else
          {
            long long v433 = 0u;
            long long v434 = 0u;
            double v170 = 0.0;
            double v168 = 0.0;
            double v171 = 0.0;
            double v169 = 0.0;
            long long v432 = 0u;
          }
          double v172 = (float *)(v167 + 12 * (v165 >> 16));
          long double v173 = (v169 + v171 * *v172) * 6.28318531 / *MEMORY[0x1E4F63F10];
          long double v174 = exp(3.14159265- (v168 + v170 * (float)(v133 - v172[1])) * 6.28318531 / *(double *)(MEMORY[0x1E4F63F10] + 8));
          double v175 = atan(v174) * 2.0 + -1.57079633;
          long double v176 = fmod(v173, 6.28318531);
          double v177 = fmod(v176 + 6.28318531, 6.28318531) + -3.14159265;
          __double2 v178 = __sincos_stret(v175);
          double v179 = 6378137.0 / sqrt(v178.__sinval * v178.__sinval * -0.00669437999 + 1.0);
          __double2 v180 = __sincos_stret(v177);

          double v435 = v179 * v178.__cosval * v180.__cosval;
          double v436 = v179 * v178.__cosval * v180.__sinval;
          double v437 = v178.__sinval * 0.99330562 * v179;
          double v181 = *(&v435 + a4[2]);
          unint64_t v182 = *v40;
          id v183 = *(id *)(*(void *)(v128 + 128) + 8 * (unsigned __int16)*v40);
          uint64_t v184 = [v183 points];
          if (v183)
          {
            [v183 bounds];
            float v113 = 1.0;
            double v115 = *((double *)&v432 + 1);
            double v117 = *(double *)&v432;
            double v116 = *((double *)&v433 + 1);
            double v114 = *(double *)&v434;
          }
          else
          {
            float v113 = 1.0;
            long long v433 = 0u;
            long long v434 = 0u;
            double v114 = 0.0;
            double v115 = 0.0;
            double v116 = 0.0;
            double v117 = 0.0;
            long long v432 = 0u;
          }
          double v118 = (v164 + v147) * 0.5;
          uint64_t v119 = v184 + 12 * (v182 >> 16);
          long double v120 = (v117 + v116 * *(float *)(v119 + 12)) * 6.28318531 / *MEMORY[0x1E4F63F10];
          long double v121 = exp(3.14159265- (v115 + v114 * (float)(v113 - *(float *)(v119 + 16)))* 6.28318531/ *(double *)(MEMORY[0x1E4F63F10] + 8));
          double v122 = atan(v121) * 2.0 + -1.57079633;
          long double v123 = fmod(v120, 6.28318531);
          double v124 = fmod(v123 + 6.28318531, 6.28318531) + -3.14159265;
          __double2 v125 = __sincos_stret(v122);
          double v126 = 6378137.0 / sqrt(v125.__sinval * v125.__sinval * -0.00669437999 + 1.0);
          __double2 v127 = __sincos_stret(v124);

          *(double *)&long long v432 = v126 * v125.__cosval * v127.__cosval;
          *((double *)&v432 + 1) = v126 * v125.__cosval * v127.__sinval;
          *(double *)&long long v433 = v125.__sinval * 0.99330562 * v126;
          id v112 = v9;
        }
        while (v118 >= (*((double *)&v432 + a4[2]) + v181) * 0.5);
        if (i >= v9) {
          break;
        }
        int v185 = *i;
        *uint64_t i = *v9;
        *uint64_t v9 = v185;
        ++v430;
        if (v40 == i) {
          uint64_t v8 = v9;
        }
        else {
          uint64_t v8 = v40;
        }
        uint64_t v39 = v431 + 1;
        a1 = v427;
        float v6 = 1.0;
      }
      a1 = v427;
      double v187 = v428;
      float v6 = 1.0;
      uint64_t v8 = v40;
      int v38 = v425;
      uint64_t v186 = v431;
    }
    unint64_t v188 = &a1[v186];
    v429 = v187;
    if (v188 == v8) {
      goto LABEL_53;
    }
    uint64_t v189 = *(void *)a4;
    *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *v8, 0);
    *((void *)&v432 + 1) = v190;
    *(void *)&long long v433 = v191;
    double v192 = *((double *)&v432 + a4[2]);
    double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v189 + 128), *v8, 1);
    double v436 = v193;
    double v437 = v194;
    double v195 = (*(&v435 + a4[2]) + v192) * 0.5;
    *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v189 + 128), *v188, 0);
    *((void *)&v432 + 1) = v196;
    *(void *)&long long v433 = v197;
    double v198 = *((double *)&v432 + a4[2]);
    double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v189 + 128), *v188, 1);
    double v436 = v199;
    double v437 = v200;
    if (v195 >= (*(&v435 + a4[2]) + v198) * 0.5)
    {
LABEL_53:
      int v202 = v430;
    }
    else
    {
      int v201 = *v188;
      *unint64_t v188 = *v8;
      *uint64_t v8 = v201;
      int v202 = v430 + 1;
    }
    if (v188 == a2) {
      return;
    }
    if (!v202)
    {
      if (v188 <= a2)
      {
        for (j = v188 + 1; j != v429; ++j)
        {
          uint64_t v242 = *(void *)a4;
          *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *j, 0);
          *((void *)&v432 + 1) = v243;
          *(void *)&long long v433 = v244;
          double v245 = *((double *)&v432 + a4[2]);
          double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v242 + 128), *j, 1);
          double v436 = v246;
          double v437 = v247;
          double v248 = (*(&v435 + a4[2]) + v245) * 0.5;
          *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v242 + 128), *(j - 1), 0);
          *((void *)&v432 + 1) = v249;
          *(void *)&long long v433 = v250;
          double v251 = *((double *)&v432 + a4[2]);
          double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v242 + 128), *(j - 1), 1);
          double v436 = v252;
          double v437 = v253;
          if (v248 < (*(&v435 + a4[2]) + v251) * 0.5) {
            goto LABEL_56;
          }
        }
        return;
      }
      if (v186 == 1) {
        return;
      }
      while (1)
      {
        uint64_t v205 = *(void *)a4;
        *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *v38, 0);
        *((void *)&v432 + 1) = v206;
        *(void *)&long long v433 = v207;
        double v208 = *((double *)&v432 + a4[2]);
        double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v205 + 128), *v38, 1);
        double v436 = v209;
        double v437 = v210;
        double v211 = (*(&v435 + a4[2]) + v208) * 0.5;
        *(void *)&long long v432 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v205 + 128), *(v38 - 1), 0);
        *((void *)&v432 + 1) = v212;
        *(void *)&long long v433 = v213;
        double v214 = *((double *)&v432 + a4[2]);
        double v435 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v205 + 128), *(v38 - 1), 1);
        double v436 = v215;
        double v437 = v216;
        if (v211 < (*(&v435 + a4[2]) + v214) * 0.5) {
          break;
        }
        if (++v38 == v188) {
          return;
        }
      }
    }
LABEL_56:
    double v203 = v429;
    if (v188 > a2) {
      double v203 = &a1[v186];
    }
    v428 = v203;
    if (v188 <= a2) {
      double v204 = v188 + 1;
    }
    else {
      double v204 = a1;
    }
LABEL_109:
    a1 = v204;
  }
  while (v428 != a2);
}

void sub_1A205F3A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteCollisionObject<md::GeocentricPointSource>::partitionSegments(std::__wrap_iter<md::PointSource::SegmentIndex *>,std::__wrap_iter<md::PointSource::SegmentIndex *>,gm::Box<double,3> &)::{lambda(md::PointSource::SegmentIndex const&,md::PointSource::SegmentIndex const&)#1} &,std::__wrap_iter<md::PointSource::SegmentIndex *>>(int *a1, int *a2, int *a3, int *a4)
{
  uint64_t v8 = *(void *)a4;
  double v76 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *a2, 0);
  uint64_t v77 = v9;
  uint64_t v78 = v10;
  double v11 = *(&v76 + a4[2]);
  double v73 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v8 + 128), *a2, 1);
  uint64_t v74 = v12;
  uint64_t v75 = v13;
  double v14 = (*(&v73 + a4[2]) + v11) * 0.5;
  double v76 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v8 + 128), *a1, 0);
  uint64_t v77 = v15;
  uint64_t v78 = v16;
  double v17 = *(&v76 + a4[2]);
  double v73 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v8 + 128), *a1, 1);
  uint64_t v74 = v18;
  uint64_t v75 = v19;
  uint64_t v20 = *(void *)a4;
  if (v14 < (*(&v73 + a4[2]) + v17) * 0.5)
  {
    double v76 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v20 + 128), *a3, 0);
    uint64_t v77 = v21;
    uint64_t v78 = v22;
    double v23 = *(&v76 + a4[2]);
    double v73 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v20 + 128), *a3, 1);
    uint64_t v74 = v24;
    uint64_t v75 = v25;
    double v26 = (*(&v73 + a4[2]) + v23) * 0.5;
    double v76 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v20 + 128), *a2, 0);
    uint64_t v77 = v27;
    uint64_t v78 = v28;
    double v29 = *(&v76 + a4[2]);
    double v73 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v20 + 128), *a2, 1);
    uint64_t v74 = v30;
    uint64_t v75 = v31;
    int v32 = *a1;
    if (v26 < (*(&v73 + a4[2]) + v29) * 0.5)
    {
      *a1 = *a3;
      *a3 = v32;
      return 1;
    }
    *a1 = *a2;
    *a2 = v32;
    uint64_t v59 = *(void *)a4;
    double v76 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *a3, 0);
    uint64_t v77 = v60;
    uint64_t v78 = v61;
    double v62 = *(&v76 + a4[2]);
    uint64_t v33 = 1;
    double v73 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v59 + 128), *a3, 1);
    uint64_t v74 = v63;
    uint64_t v75 = v64;
    double v65 = (*(&v73 + a4[2]) + v62) * 0.5;
    double v76 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v59 + 128), *a2, 0);
    uint64_t v77 = v66;
    uint64_t v78 = v67;
    double v68 = *(&v76 + a4[2]);
    double v73 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v59 + 128), *a2, 1);
    uint64_t v74 = v69;
    uint64_t v75 = v70;
    if (v65 >= (*(&v73 + a4[2]) + v68) * 0.5) {
      return v33;
    }
    int v71 = *a2;
    *a2 = *a3;
    *a3 = v71;
    return 2;
  }
  double v76 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v20 + 128), *a3, 0);
  uint64_t v77 = v34;
  uint64_t v78 = v35;
  double v36 = *(&v76 + a4[2]);
  double v73 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v20 + 128), *a3, 1);
  uint64_t v74 = v37;
  uint64_t v75 = v38;
  double v39 = (*(&v73 + a4[2]) + v36) * 0.5;
  double v76 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v20 + 128), *a2, 0);
  uint64_t v77 = v40;
  uint64_t v78 = v41;
  double v42 = *(&v76 + a4[2]);
  uint64_t v33 = 0;
  double v73 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v20 + 128), *a2, 1);
  uint64_t v74 = v43;
  uint64_t v75 = v44;
  if (v39 < (*(&v73 + a4[2]) + v42) * 0.5)
  {
    int v45 = *a2;
    *a2 = *a3;
    *a3 = v45;
    uint64_t v46 = *(void *)a4;
    double v76 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(*(void *)a4 + 128), *a2, 0);
    uint64_t v77 = v47;
    uint64_t v78 = v48;
    double v49 = *(&v76 + a4[2]);
    uint64_t v33 = 1;
    double v73 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v46 + 128), *a2, 1);
    uint64_t v74 = v50;
    uint64_t v75 = v51;
    double v52 = (*(&v73 + a4[2]) + v49) * 0.5;
    double v76 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v46 + 128), *a1, 0);
    uint64_t v77 = v53;
    uint64_t v78 = v54;
    double v55 = *(&v76 + a4[2]);
    double v73 = md::GeocentricPointSource::segmentWorldPoint(*(void *)(v46 + 128), *a1, 1);
    uint64_t v74 = v56;
    uint64_t v75 = v57;
    if (v52 < (*(&v73 + a4[2]) + v55) * 0.5)
    {
      int v58 = *a1;
      *a1 = *a2;
      *a2 = v58;
      return 2;
    }
  }
  return v33;
}

void std::__shared_ptr_emplace<md::RouteCollisionObject<md::GeocentricPointSource>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 152);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 160);
    uint64_t v4 = *(void **)(a1 + 152);
    if (v3 != v2)
    {
      do
      {
        unint64_t v5 = *(void **)(v3 - 8);
        v3 -= 8;
      }
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 152);
    }
    *(void *)(a1 + 160) = v2;
    operator delete(v4);
  }
  geo::Pool<md::RouteCollisionObject<md::GeocentricPointSource>::Node>::disposeElements(a1 + 104);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 112));
  uint64_t v6 = *(void *)(a1 + 72);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 80);
    uint64_t v8 = *(void **)(a1 + 72);
    if (v7 != v6)
    {
      do
      {
        uint64_t v9 = *(void **)(v7 - 8);
        v7 -= 8;
      }
      while (v7 != v6);
      uint64_t v8 = *(void **)(a1 + 72);
    }
    *(void *)(a1 + 80) = v6;
    operator delete(v8);
  }
  uint64_t v10 = *(void **)(a1 + 48);
  if (v10)
  {
    *(void *)(a1 + 56) = v10;
    operator delete(v10);
  }
  *(void *)(a1 + 24) = &unk_1EF559678;
  double v11 = *(void **)(a1 + 32);
}

void sub_1A205F908(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 112));
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::RouteCollisionObject<md::GeocentricPointSource>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5810F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::RouteCollisionObject<md::GeocentricPointSource>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5810F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::DaVinciGroundLayerDataSource::~DaVinciGroundLayerDataSource(md::DaVinciGroundLayerDataSource *this)
{
  *(void *)this = &unk_1EF54A080;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 100);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 98);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 98);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  *((void *)this + 94) = &unk_1EF559798;

  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF54A080;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 100);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 98);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 98);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  *((void *)this + 94) = &unk_1EF559798;

  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
}

void *md::MuninLabelLayerData::MuninLabelLayerData(void *a1, uint64_t a2, void *a3, void *a4, uint64_t a5)
{
  uint64_t v8 = *(uint64_t **)(*a3 + 24);
  uint64_t v9 = (std::__shared_weak_count *)v8[1];
  v13[0] = *v8;
  v13[1] = (uint64_t)v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  md::MapTileData::MapTileData((uint64_t)a1, a2, a5, v13, 1);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  *a1 = &unk_1EF53C0D0;
  a1[79] = &unk_1EF53C110;
  a1[90] = *a3;
  uint64_t v10 = a3[1];
  a1[91] = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  a1[92] = *a4;
  uint64_t v11 = a4[1];
  a1[93] = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_1A205FCFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void md::MuninLabelLayerData::~MuninLabelLayerData(md::MuninLabelLayerData *this)
{
  *(void *)this = &unk_1EF53C0D0;
  *((void *)this + 79) = &unk_1EF53C110;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 93);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 91);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 91);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::MapTileData::~MapTileData(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF53C0D0;
  *((void *)this + 79) = &unk_1EF53C110;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 93);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 91);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 91);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::MapTileData::~MapTileData(this);
}

uint64_t std::__shared_ptr_emplace<md::MuninLabelLayerData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::MuninLabelLayerData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580D40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::MuninLabelLayerData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580D40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

id md::ARWalkingCustomSceneMapEngineMode::getSession(md::ARWalkingCustomSceneMapEngineMode *this)
{
  id v1 = +[MDARSession newPositionalTrackingSession];
  return v1;
}

uint64_t md::ARWalkingCustomSceneMapEngineMode::buildScene(void *a1, int a2, void *a3)
{
  id v6 = a3;
  if (a2 == 2)
  {
    uint64_t v7 = (void *)a1[72];
    id v8 = v6;
    uint64_t v9 = +[VKDebugSettings sharedSettings];
    v7[3] = 0;
    v7[4] = 0;
    v7[5] = 0;
    double v105 = 0.0;
    long long v104 = 0x415854A640000000uLL;
    gdc::CameraFrame<geo::Degrees,double>::createLocalEcefFrame((uint64_t)&v111, (uint64_t)&v104);
    long long v104 = v111;
    double v105 = v112;
    int8x16_t v106 = v113;
    float64x2_t v107 = v114;
    id v10 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    double v108 = &unk_1EF559578;
    id v109 = v10;
    __int16 v110 = 1;
    [v9 arDebugSceneFeatureDistance];
    float v12 = v11;
    [v9 arDebugSceneFeatureHeading];
    float v14 = v13;
    double v15 = v12;
    double v16 = -v12;
    if ([v9 arDebugSceneFeatureType])
    {
      int v17 = [v9 arDebugScenePoiType];
      uint64_t v18 = (char *)operator new(0x40uLL);
      *(_OWORD *)uint64_t v18 = xmmword_1A28FE040;
      *(_OWORD *)(v18 + 24) = xmmword_1A28FE050;
      *(_OWORD *)(v18 + 40) = xmmword_1A28FE060;
      *((void *)v18 + 7) = 0x1000000A4;
      double v19 = *(double *)&v106.i64[1];
      double v20 = v107.f64[1];
      double v22 = v105;
      double v21 = *(double *)v106.i64;
      double v23 = *(double *)&v106.i64[1] * v16 + *(double *)&v106.i64[1] * v16;
      double v24 = *(double *)v106.i64 * v15 + *(double *)v106.i64 * v15;
      long double v25 = *(double *)&v104 + v23 * v107.f64[1] - v24 * v107.f64[0];
      double v26 = *((double *)&v104 + 1) + v23 * v107.f64[0];
      *((_DWORD *)v18 + 4) = 6;
      *((_DWORD *)v18 + 5) = v17;
      md::ARDebugCustomSceneBuilder::convertPointToCoordinate(v125.f64, v110, v25, v26 + v24 * v20, v22 - (v15 + v23 * v19) + v24 * v21);
      float64x2_t v27 = v125;
      double v28 = v126;
      id v29 = objc_alloc_init(MEMORY[0x1E4F645A0]);
      [v29 replaceAttributes:v18 count:8];
      uint64_t v30 = -[VKARWalkingArrivalFeature initWithPosition:iconStyleAttributes:]([VKARWalkingArrivalFeature alloc], "initWithPosition:iconStyleAttributes:", v29, *(_OWORD *)&v27, v28);
      [v109 addObject:v30];

      double v31 = *(double *)&v18;
      goto LABEL_4;
    }
    double v120 = 0.0;
    double v121 = 0.0;
    *(double *)&uint64_t v119 = 6378137.0;
    gdc::CameraFrame<geo::Degrees,double>::createLocalEcefBasis(v125.f64, (double *)&v119);
    double v32 = *(double *)&v130;
    double v33 = v131;
    double v103 = v132;
    __double2 v34 = __sincos_stret(v14 * 0.00872664626);
    double v36 = v125.f64[1];
    double v35 = v126;
    double v37 = v125.f64[0];
    uint64_t v38 = [v9 arDebugSceneFeatureText];
    if (v38)
    {
      id v3 = [v9 arDebugSceneFeatureText];
      double v39 = (const char *)[v3 UTF8String];
    }
    else
    {
      double v39 = "";
    }
    size_t v40 = strlen(v39);
    if (v40 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    size_t v41 = v40;
    if (v40 >= 0x17)
    {
      uint64_t v43 = (v40 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v40 | 7) != 0x17) {
        uint64_t v43 = v40 | 7;
      }
      uint64_t v44 = v43 + 1;
      *(double *)&double v42 = COERCE_DOUBLE(operator new(v43 + 1));
      *(void *)&v135.f64[0] = v41;
      *(void *)&v135.f64[1] = v44 | 0x8000000000000000;
      double __dst = *(double *)&v42;
    }
    else
    {
      HIBYTE(v135.f64[1]) = v40;
      *(double *)&double v42 = COERCE_DOUBLE(&__dst);
      if (!v40) {
        goto LABEL_16;
      }
    }
    memmove(v42, v39, v41);
LABEL_16:
    *((unsigned char *)v42 + v41) = 0;
    if (v38) {

    }
    md::ARDebugCustomSceneBuilder::convertPointToCoordinate((double *)&v119, v110, *(double *)&v104+ (*(double *)&v106.i64[1] * v16 + *(double *)&v106.i64[1] * v16) * v107.f64[1]- (*(double *)v106.i64 * v15 + *(double *)v106.i64 * v15) * v107.f64[0], *((double *)&v104 + 1)+ (*(double *)&v106.i64[1] * v16 + *(double *)&v106.i64[1] * v16) * v107.f64[0]+ (*(double *)v106.i64 * v15 + *(double *)v106.i64 * v15) * v107.f64[1], v105- (v15+ (*(double *)&v106.i64[1] * v16 + *(double *)&v106.i64[1] * v16) * *(double *)&v106.i64[1])+ (*(double *)v106.i64 * v15 + *(double *)v106.i64 * v15) * *(double *)v106.i64);
    int8x16_t v99 = v106;
    float64x2_t v100 = v107;
    double v45 = *(double *)&v119;
    double v46 = v120;
    double v102 = v121;
    if (v135.f64[1] >= 0.0) {
      p_dst = &__dst;
    }
    else {
      p_dst = *(double **)&__dst;
    }
    uint64_t v48 = [NSString stringWithUTF8String:p_dst];
    double v49 = [VKARWalkingManeuverFeature alloc];
    double v50 = v34.__sinval / sqrt(v32 * v32 + v33 * v33 + v103 * v103);
    double v51 = v50 * v103;
    double v52 = v50 * v33;
    double v53 = v50 * v103 * v36;
    double v54 = v50 * v32;
    double v55 = -(v53 - v52 * v35) - (v53 - v52 * v35);
    double v56 = -(v52 * v37 - v54 * v36) - (v52 * v37 - v54 * v36);
    double v57 = -(v54 * v35 - v51 * v37) - (v54 * v35 - v51 * v37);
    double v58 = v36 + v55 * v51;
    double v59 = v37 + v55 * v34.__cosval + v56 * v52 - v57 * v51;
    double v60 = v58 + v57 * v34.__cosval;
    double v61 = v35 + v57 * v54;
    double v62 = v60 - v56 * v54;
    double v63 = v61 + v56 * v34.__cosval - v55 * v52;
    double v64 = 1.0 / sqrt(v59 * v59 + v62 * v62 + v63 * v63);
    *(double *)v65.i64 = v64 * v59;
    double v66 = v64 * v62;
    double v67 = v64 * v63;
    *(double *)&v65.i64[1] = v66;
    float64x2_t v68 = (float64x2_t)vextq_s8(v99, v99, 8uLL);
    float64x2_t v69 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v100.f64[0], 0);
    v69.f64[0] = v67;
    float64x2_t v70 = (float64x2_t)vextq_s8(v65, v65, 8uLL);
    *(double *)&v65.i64[1] = v67;
    float64x2_t v71 = vmlsq_f64(vmulq_f64(v70, (float64x2_t)vextq_s8((int8x16_t)v68, (int8x16_t)v100, 8uLL)), (float64x2_t)v65, v68);
    v65.i64[0] = *(void *)&v68.f64[0];
    *(double *)&v65.i64[1] = v66;
    float64x2_t v72 = vaddq_f64(v71, v71);
    float64x2_t v73 = vmulq_f64(v69, (float64x2_t)v65);
    v73.f64[0] = vsubq_f64(v73, (float64x2_t)vdupq_laneq_s64((int64x2_t)v73, 1)).f64[0];
    uint64_t v74 = -[VKARWalkingManeuverFeature initWithDisplayLocation:routeCoordinate:maneuverHeading:displayText:](v49, "initWithDisplayLocation:routeCoordinate:maneuverHeading:displayText:", 0, v48, v45, v46, v102, (double)(acos(vmlad_n_f64(v66, v73.f64[0] + v73.f64[0], v100.f64[0])+ COERCE_DOUBLE(*(void *)&vmulq_f64(v72, v100).f64[1])- COERCE_DOUBLE(*(void *)&vmulq_n_f64(v68, *(double *)&v72).f64[1]))* 57.2957795));
    [v109 addObject:v74];

    if ((SHIBYTE(v135.f64[1]) & 0x80000000) == 0)
    {
LABEL_22:
      uint64_t v75 = (gdc::Registry *)a1[67];
      id v76 = v8;
      if (HIBYTE(v110))
      {
        md::ARDebugCustomSceneBuilder::convertPointToCoordinate(&__dst, v110, *(long double *)&v104, *((long double *)&v104 + 1), v105);
        double v77 = __dst;
        long double v78 = cos(__dst * 0.034906585) * -559.82 + 111132.92;
        long double v79 = v78 + cos(v77 * 0.0698131701) * 1.175;
        long double v80 = v79 + cos(v77 * 0.104719755) * -0.0023;
        double v81 = v77 * 0.00872664626;
        long double v82 = tan(v77 * 0.00872664626 + 0.78103484);
        double v83 = log(v82);
        long double v84 = tan(v81 + 0.789761487);
        double v85 = fabs((log(v84) - v83) * 0.159154943);
        float64x2_t v101 = v135;
        long double v86 = tan(v81 + 0.785398163);
        long double v87 = log(v86);
        v88.f64[0] = v101.f64[0];
        uint64_t v127 = 0;
        uint64_t v128 = 0;
        v88.f64[1] = v87;
        float64x2_t v89 = v88;
        __asm { FMOV            V3.2D, #0.5 }
        double v126 = vmuld_lane_f64(0.0000000249532021, v101, 1);
        uint64_t v129 = 0;
        *(double *)&uint64_t v130 = 1.0;
        double v131 = v85 * 75.0 / v80;
        double v132 = v131;
        uint64_t v133 = 0x3FF0000000000000;
        __asm { FMOV            V0.4S, #1.0 }
        long long v124 = _Q0;
        float64x2_t v125 = vmlaq_f64(_Q3, (float64x2_t)xmmword_1A28FCBE0, v89);
        double v117 = &unk_1EF559EB8;
        uint64_t v118 = 0;
        *(double *)&uint64_t v119 = 0.0;
        double v120 = 0.0;
        double v121 = 0.0;
        double v122 = &unk_1EF559EB8;
        uint64_t v123 = 0;
        long long v116 = xmmword_1A28FCDA0;
        __asm { FMOV            V0.2S, #1.0 }
        uint64_t v115 = _Q0;
        gdc::Registry::create(v75);
      }
      id v96 = v109;
      operator new();
    }
    double v31 = __dst;
LABEL_4:
    operator delete(*(void **)&v31);
    goto LABEL_22;
  }
  uint64_t v97 = a1[77];

  return v97;
}

void sub_1A2060B7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
  _Unwind_Resume(a1);
}

void gdc::CameraFrame<geo::Degrees,double>::createLocalEcefFrame(uint64_t a1, uint64_t a2)
{
  gdc::CameraFrame<geo::Degrees,double>::createLocalEcefBasis(&v22, (double *)a2);
  double v4 = v30 + v26 + v22;
  if (v4 <= 0.0)
  {
    if (v22 <= v26 || v22 <= v30)
    {
      double v11 = sqrt(1.0 - (v26 + v22) + v30);
      double v12 = 1.0 / (v11 + v11);
      double v13 = (v28 + v24) * v12;
      double v14 = (v29 + v27) * v12;
      double v15 = v11 * 0.5;
      double v16 = (v23 - v25) * v12;
      double v17 = sqrt(v26 + 1.0 - (v22 + v30));
      double v18 = 1.0 / (v17 + v17);
      double v7 = v17 * 0.5;
      double v9 = (v28 - v24) * v18;
      if (v26 > v30) {
        double v6 = (v25 + v23) * v18;
      }
      else {
        double v6 = v13;
      }
      if (v26 > v30)
      {
        double v8 = (v29 + v27) * v18;
      }
      else
      {
        double v7 = v14;
        double v8 = v15;
      }
      if (v26 <= v30) {
        double v9 = v16;
      }
    }
    else
    {
      double v19 = sqrt(v22 + 1.0 - (v26 + v30));
      double v20 = v19 + v19;
      double v6 = v19 * 0.5;
      double v21 = 1.0 / v20;
      double v7 = (v25 + v23) * (1.0 / v20);
      double v8 = (v28 + v24) * v21;
      double v9 = (v27 - v29) * v21;
    }
  }
  else
  {
    double v5 = 0.5 / sqrt(v4 + 1.0);
    double v6 = v5 * (v27 - v29);
    double v7 = v5 * (v28 - v24);
    double v8 = v5 * (v23 - v25);
    double v9 = 0.25 / v5;
  }
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(double *)(a1 + 24) = v6;
  *(double *)(a1 + 32) = v7;
  *(double *)(a1 + 40) = v8;
  *(double *)(a1 + 48) = v9;
}

long double gdc::CameraFrame<geo::Degrees,double>::createLocalEcefBasis(double *a1, double *a2)
{
  long double v3 = *a2;
  long double v4 = a2[1];
  long double v5 = a2[2];
  double v29 = v3 * v3 + v4 * v4;
  double v6 = sqrt(v29);
  double v7 = atan2(v5, v6 * 0.996647189);
  double v8 = atan2(v4, v3);
  __double2 v9 = __sincos_stret(v7);
  double v10 = atan2(v5 + v9.__sinval * v9.__sinval * 42841.3115 * v9.__sinval, v6 + v9.__cosval * v9.__cosval * -42697.6727 * v9.__cosval);
  __double2 v11 = __sincos_stret(v10);
  double v12 = v6 / v11.__cosval;
  __double2 v13 = __sincos_stret(v8 + 0.000000174532925);
  double v14 = 1.0 / sqrt(v29 + v5 * v5);
  long double v15 = v14 * v3;
  long double v16 = v14 * v4;
  long double v17 = v14 * v5;
  a1[4] = v16;
  a1[5] = v17;
  long double v18 = -(v3 - v12 * v11.__cosval * v13.__cosval);
  long double v19 = -(v4 - v12 * v11.__cosval * v13.__sinval);
  long double v20 = -(v5 - (-42697.6727 / sqrt(v11.__sinval * v11.__sinval * -0.00669437999 + 1.0) + v12) * v11.__sinval);
  double v21 = 1.0 / sqrt(v20 * v20 + v18 * v18 + v19 * v19);
  long double v22 = v21 * v18;
  long double v23 = v21 * v19;
  long double v24 = v21 * v20;
  long double v25 = -(v24 * v16 - v23 * v17);
  long double v26 = -(v22 * v17 - v24 * v15);
  long double v27 = -(v23 * v15 - v22 * v16);
  a1[6] = v25;
  a1[7] = v26;
  a1[8] = v27;
  *a1 = -(v26 * v17 - v27 * v16);
  a1[1] = -(v27 * v15 - v25 * v17);
  long double result = -(v25 * v16 - v26 * v15);
  a1[2] = result;
  a1[3] = v15;
  return result;
}

void geo::_retain_ptr<NSMutableArray * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559578;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<NSMutableArray * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559578;

  return a1;
}

void md::ARWalkingCustomSceneMapEngineMode::buildLocationProvider(md::ARWalkingCustomSceneMapEngineMode *this, md::MapEngine *a2)
{
}

void md::ARWalkingCustomSceneMapEngineMode::~ARWalkingCustomSceneMapEngineMode(md::ARWalkingCustomSceneMapEngineMode *this)
{
  *(void *)this = &unk_1EF54DAB0;
  uint64_t v2 = *((void *)this + 77);
  *((void *)this + 77) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  md::ARWalkingMapEngineMode::~ARWalkingMapEngineMode(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF54DAB0;
  uint64_t v2 = *((void *)this + 77);
  *((void *)this + 77) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  md::ARWalkingMapEngineMode::~ARWalkingMapEngineMode(this);
}

void md::ARWalkingMapEngineMode::~ARWalkingMapEngineMode(md::ARWalkingMapEngineMode *this)
{
  *(void *)this = &unk_1EF540E58;
  *((void *)this + 73) = &unk_1EF559F58;

  uint64_t v2 = *((void *)this + 72);
  *((void *)this + 72) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  long double v3 = (std::__shared_weak_count *)*((void *)this + 70);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    long double v4 = (std::__shared_weak_count *)*((void *)this + 68);
    if (!v4) {
      goto LABEL_9;
    }
  }
  else
  {
    long double v4 = (std::__shared_weak_count *)*((void *)this + 68);
    if (!v4) {
      goto LABEL_9;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_9:
  md::MapEngineMode::~MapEngineMode(this);
}

void geo::_retain_ptr<ARSession * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559F58;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<ARSession * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559F58;

  return a1;
}

void VKCameraPropertiesForRect(double *a1@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  double v5 = *a1;
  double v6 = a1[1];
  double v8 = a1[2];
  double v7 = a1[3];
  if (v8 == 0.0 || v7 == 0.0)
  {
    GEOCoordinate2DForMapPoint();
    GEOMapPointsPerMeterAtLatitude();
    GEOMapRectInset();
    double v5 = v9;
    double v6 = v10;
    double v8 = v11;
    double v7 = v12;
  }
  double v14 = *(double *)(MEMORY[0x1E4F63F08] + 16);
  double v13 = *(double *)(MEMORY[0x1E4F63F08] + 24);
  size_t v40 = [[VKCamera alloc] initWithRunLoopController:0];
  [(VKCamera *)v40 setAspectRatio:a3];
  double v15 = (v7 + v6) / v13;
  double v16 = ((v8 + v5) / v14 - v5 / v14) * 0.5;
  double v17 = (v15 - v6 / v13) * 0.5;
  double v18 = v16 + v5 / v14;
  double v19 = 1.0 - v15 + v17;
  double v20 = v18 + 1.0 - ceil(v18);
  if (v18 >= 0.0) {
    double v20 = v18;
  }
  double v21 = v18 - floor(v18);
  if (v18 > 1.0) {
    double v22 = v21;
  }
  else {
    double v22 = v20;
  }
  if (v19 <= 1.0)
  {
    long double v23 = v40;
    if (v19 < 0.0) {
      double v19 = v19 + 1.0 - ceil(v19);
    }
  }
  else
  {
    double v19 = v19 - floor(v19);
    long double v23 = v40;
  }
  [(VKCamera *)v23 tanHalfVerticalFOV];
  double v25 = v24;
  [(VKCamera *)v40 tanHalfHorizFOV];
  double v27 = v26;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  long double v28 = exp(v19 * 6.28318531 + -3.14159265);
  long double v38 = atan(v28);
  long double v29 = fmod(v22 * 6.28318531, 6.28318531);
  long double v30 = fmod(v29 + 6.28318531, 6.28318531);
  v31.f64[0] = v38;
  v31.f64[1] = v30;
  float64x2_t v39 = vmlaq_f64((float64x2_t)xmmword_1A28FCC00, (float64x2_t)xmmword_1A28FCBF0, v31);
  *(float64x2_t *)a2 = v39;
  long double v32 = cos(0.034906585 * v39.f64[0]) * -559.82 + 111132.92;
  long double v33 = v32 + cos(0.0698131701 * v39.f64[0]) * 1.175;
  long double v34 = v33 + cos(0.104719755 * v39.f64[0]) * -0.0023;
  long double v35 = tan(0.00872664626 * v39.f64[0] + 0.78103484);
  double v36 = log(v35);
  long double v37 = tan(0.00872664626 * v39.f64[0] + 0.789761487);
  *(long double *)(a2 + 32) = v34 * fmax(v17 / v25, v16 / v27) / fabs((log(v37) - v36) * 0.159154943);
}

void sub_1A20616E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

double GEOMapRectEnclosingCameraProperties(double *a1, float a2)
{
  long double v4 = [[VKCamera alloc] initWithRunLoopController:0];
  [(VKCamera *)v4 setAspectRatio:a2];
  double v5 = a1[3];
  __double2 v6 = __sincos_stret(a1[2] * 0.00872664626);
  __double2 v7 = __sincos_stret(v5 * 0.00872664626);
  double v28 = v7.__sinval * v6.__cosval;
  double v29 = v7.__sinval * v6.__sinval;
  double v30 = v7.__cosval * v6.__sinval;
  double v31 = v7.__cosval * v6.__cosval;
  [(VKCamera *)v4 setOrientation:&v28];
  double v8 = *a1;
  double v9 = a1[1];
  double v10 = *a1 * 0.00872664626;
  long double v11 = tan(v10 + 0.785398163);
  double v12 = v9 * 0.00277777778 + 0.5;
  double v13 = log(v11) * 0.159154943 + 0.5;
  double v14 = a1[3];
  double v15 = a1[4];
  if (v14 < 90.0) {
    double v15 = v15 / cos(v14 * 0.0174532925);
  }
  long double v16 = cos(v8 * 0.034906585) * -559.82 + 111132.92;
  long double v17 = v16 + cos(v8 * 0.0698131701) * 1.175;
  long double v18 = v17 + cos(v8 * 0.104719755) * -0.0023;
  long double v19 = tan(v10 + 0.78103484);
  double v20 = log(v19);
  long double v21 = tan(v10 + 0.789761487);
  long double v22 = fabs((log(v21) - v20) * 0.159154943) * v15 / v18;
  long double v23 = v22 * (v29 + v29);
  long double v24 = v28 * -2.0 * v22;
  v27[0] = v12 - v24 * v30 + v23 * v31;
  v27[1] = v13 + v24 * v31 + v23 * v30;
  v27[2] = v22 + v24 * v28 - v23 * v29;
  [(VKCamera *)v4 setPosition:v27];
  long long v25 = *(_OWORD *)(MEMORY[0x1E4F63F00] + 16);
  v32[0] = *MEMORY[0x1E4F63F00];
  v32[1] = v25;
  VKCameraCalculateEnclosingRegion(v4, 0, (double *)v32, 0.0, 0.0, 0.0, 0.0);

  return *(double *)v32;
}

void sub_1A206193C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double GEOPDCameraPathFrameFromVKCameraFrame@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  double v2 = *(double *)(a1 + 24);
  *(void *)(a2 + 16) = *(void *)(a1 + 16);
  *(float64x2_t *)(a2 + 24) = vmulq_f64(*(float64x2_t *)a1, (float64x2_t)vdupq_n_s64(0x3F91DF46A2529D39uLL));
  double v3 = *(double *)(a1 + 32);
  *(double *)(a2 + 40) = *(double *)(a1 + 40) * 0.0174532925;
  *(double *)(a2 + 48) = v2 * 0.0174532925;
  *(void *)(a2 + 80) = 0;
  double result = v3 * 0.0174532925;
  *(_WORD *)(a2 + 80) = 760;
  *(double *)(a2 + 64) = v3 * 0.0174532925;
  return result;
}

double VKCameraFrameFromGEOPDCameraPathFrame@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(float64x2_t *)a2 = vmulq_f64(*(float64x2_t *)(a1 + 24), (float64x2_t)vdupq_n_s64(0x404CA5DC1A63C1F8uLL));
  double v2 = *(double *)(a1 + 40);
  double v3 = *(double *)(a1 + 48) * 57.2957795;
  *(void *)(a2 + 16) = *(void *)(a1 + 16);
  *(double *)(a2 + 24) = v3;
  double result = *(double *)(a1 + 64) * 57.2957795;
  *(double *)(a2 + 32) = result;
  *(double *)(a2 + 40) = v2 * 57.2957795;
  return result;
}

void VKCameraPropertiesForStoreFrontView(void *a1@<X0>, uint64_t a2@<X8>)
{
  id v3 = a1;
  if (v3)
  {
    id v6 = v3;
    md::mun::cameraFrameFromStorefront((uint64_t)&v7, v3);
    float64x2_t v4 = vmulq_f64(v7, (float64x2_t)vdupq_n_s64(0x404CA5DC1A63C1F8uLL));
    *(void *)(a2 + 32) = v8;
    int8x16_t v5 = (int8x16_t)vmulq_f64(v9, (float64x2_t)xmmword_1A28FE070);
    *(float64x2_t *)a2 = v4;
    *(int8x16_t *)(a2 + 16) = vextq_s8(v5, v5, 8uLL);
    id v3 = v6;
  }
}

void sub_1A2061A98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void md::mun::MuninLabelLayerDataSource::createLayerData(uint64_t *a1@<X2>, void *a2@<X8>)
{
  uint64_t v4 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 != v3)
  {
    while (*(_WORD *)v4 != 24)
    {
      v4 += 48;
      if (v4 == v3) {
        goto LABEL_12;
      }
    }
  }
  if (v4 == v3 || *(void *)(v4 + 32) != 1)
  {
LABEL_12:
    long double v176 = 0;
    goto LABEL_223;
  }
  int8x16_t v5 = a2;
  uint64_t v6 = *(void *)(v4 + 24);
  uint64_t v7 = *(void *)(v6 + 112);
  uint64_t v8 = *(std::__shared_weak_count **)(v6 + 120);
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v175 = v7;
    long double v176 = v8;
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    a2 = v5;
    if (!v175) {
      goto LABEL_223;
    }
  }
  else
  {
    long double v176 = 0;
    if (!v7) {
      goto LABEL_223;
    }
  }
  uint64_t v10 = *a1;
  uint64_t v9 = a1[1];
  if (*a1 != v9)
  {
    while (*(_WORD *)v10 != 22)
    {
      v10 += 48;
      if (v10 == v9) {
        goto LABEL_223;
      }
    }
  }
  if (v10 != v9)
  {
    long double v11 = *(void **)(v10 + 24);
    if (v11)
    {
      unint64_t v12 = 0;
      unint64_t v13 = 0;
      do
      {
        uint64_t v14 = v11[14];
        double v15 = (std::__shared_weak_count *)v11[15];
        if (v14) {
          long double v16 = (void *)(v14 - 8);
        }
        else {
          long double v16 = 0;
        }
        if (v15) {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v17 = v16[27];
        uint64_t v18 = v16[28];
        uint64_t v19 = v16[19];
        uint64_t v20 = v16[20];
        if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
        v12 -= 0x30C30C30C30C30C3 * ((v18 - v17) >> 3);
        v13 += 0x63FB9AEB1FDCD759 * ((v20 - v19) >> 3);
        long double v11 = (void *)*v11;
      }
      while (v11);
      __double2 v180 = 0;
      double v181 = 0;
      unint64_t v182 = 0;
      double v177 = 0;
      __double2 v178 = 0;
      double v179 = 0;
      if (v12)
      {
        if (v12 > 0x186186186186186) {
          abort();
        }
        __double2 v180 = (char *)operator new(168 * v12);
        double v181 = v180;
        unint64_t v182 = &v180[168 * v12];
      }
    }
    else
    {
      unint64_t v13 = 0;
      __double2 v180 = 0;
      double v181 = 0;
      unint64_t v182 = 0;
      double v177 = 0;
      __double2 v178 = 0;
      double v179 = 0;
    }
    std::vector<md::mun::CollectionPoint>::reserve(&v177, v13);
    long double v21 = *(void **)(v10 + 24);
    if (!v21) {
LABEL_221:
    }
      operator new();
    while (1)
    {
      uint64_t v22 = v21[14];
      long double v23 = (std::__shared_weak_count *)v21[15];
      double v172 = v21;
      uint64_t v24 = v22 - 8;
      if (!v22) {
        uint64_t v24 = 0;
      }
      if (v23) {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      double v171 = v23;
      double v26 = *(char **)(v24 + 216);
      long long v25 = *(char **)(v24 + 224);
      uint64_t v173 = v24;
      if (v25 - v26 < 1) {
        goto LABEL_169;
      }
      uint64_t v27 = (v25 - v26) / 168;
      double v28 = v181;
      if ((uint64_t)(0xCF3CF3CF3CF3CF3DLL * ((v182 - v181) >> 3)) < v27)
      {
        unint64_t v29 = 0xCF3CF3CF3CF3CF3DLL * ((v181 - v180) >> 3);
        unint64_t v30 = v29 + v27;
        if (v29 + v27 > 0x186186186186186) {
          abort();
        }
        if (0x9E79E79E79E79E7ALL * ((v182 - v180) >> 3) > v30) {
          unint64_t v30 = 0x9E79E79E79E79E7ALL * ((v182 - v180) >> 3);
        }
        if (0xCF3CF3CF3CF3CF3DLL * ((v182 - v180) >> 3) >= 0xC30C30C30C30C3) {
          unint64_t v31 = 0x186186186186186;
        }
        else {
          unint64_t v31 = v30;
        }
        double v187 = &v182;
        if (v31)
        {
          if (v31 > 0x186186186186186) {
            goto LABEL_227;
          }
          long double v32 = (char *)operator new(168 * v31);
        }
        else
        {
          long double v32 = 0;
        }
        uint64_t v45 = 0;
        double v46 = &v32[168 * v29];
        id v183 = v32;
        uint64_t v184 = v46;
        uint64_t v185 = (uint64_t)v46;
        uint64_t v186 = &v32[168 * v31];
        uint64_t v47 = 168 * v27;
        uint64_t v48 = &v46[168 * v27];
        do
        {
          double v49 = &v46[v45];
          double v50 = &v26[v45];
          *(void *)double v49 = *(void *)&v26[v45];
          v49[8] = 0;
          if (v26[v45 + 8])
          {
            long long v51 = *((_OWORD *)v50 + 2);
            *((_OWORD *)v49 + 1) = *((_OWORD *)v50 + 1);
            *((_OWORD *)v49 + 2) = v51;
            v49[8] = 1;
          }
          v49[48] = 0;
          if (v50[48])
          {
            double v52 = &v46[v45];
            long long v53 = *(_OWORD *)&v26[v45 + 56];
            *(_OWORD *)(v52 + 72) = *(_OWORD *)&v26[v45 + 72];
            *(_OWORD *)(v52 + 56) = v53;
            v49[48] = 1;
          }
          double v54 = &v46[v45];
          uint64_t v55 = (uint64_t)&v46[v45 + 120];
          *((void *)v54 + 11) = v55;
          *((void *)v54 + 12) = v55;
          uint64_t v56 = (uint64_t)&v46[v45 + 88];
          *(void *)(v56 + 16) = v55;
          *(void *)(v56 + 24) = 1;
          geo::small_vector_base<md::mun::OrientedPlane>::append<md::mun::OrientedPlane const*>(v56, *((long long **)v50 + 11), *((long long **)v50 + 12));
          v45 += 168;
        }
        while (v47 != v45);
        double v57 = v184;
        double v58 = v180;
        if (v180 == v28)
        {
          double v61 = v184;
        }
        else
        {
          double v59 = v28;
          double v60 = v28;
          double v61 = v184;
          do
          {
            uint64_t v62 = *((void *)v60 - 21);
            v60 -= 168;
            *((void *)v61 - 21) = v62;
            v61 -= 168;
            v61[8] = 0;
            if (v60[8])
            {
              long long v63 = *(_OWORD *)(v59 - 152);
              *(_OWORD *)(v57 - 136) = *(_OWORD *)(v59 - 136);
              *(_OWORD *)(v57 - 152) = v63;
              *(v57 - 160) = 1;
            }
            *(v57 - 120) = 0;
            if (*(v59 - 120))
            {
              long long v64 = *((_OWORD *)v59 - 6);
              *((_OWORD *)v57 - 7) = *((_OWORD *)v59 - 7);
              *((_OWORD *)v57 - 6) = v64;
              *(v57 - 120) = 1;
            }
            *((void *)v57 - 10) = v57 - 48;
            uint64_t v65 = *((void *)v59 - 10);
            *((void *)v57 - 9) = v57 - 48;
            *((void *)v57 - 8) = v57 - 48;
            *((void *)v57 - 7) = *((void *)v59 - 7);
            if (v65 == *((void *)v59 - 8))
            {
              *((void *)v57 - 9) = &v57[*((void *)v59 - 9) - v65 - 48];
              uint64_t v66 = *((void *)v59 - 9);
              if (v65 != v66)
              {
                uint64_t v67 = 0;
                do
                {
                  float64x2_t v68 = &v57[v67];
                  uint64_t v69 = v65 + v67;
                  long long v70 = *(_OWORD *)(v65 + v67);
                  *((void *)v68 - 4) = *(void *)(v65 + v67 + 16);
                  *((_OWORD *)v68 - 3) = v70;
                  uint64_t v71 = *(void *)(v65 + v67 + 24);
                  *((_DWORD *)v68 - 4) = *(_DWORD *)(v65 + v67 + 32);
                  *((void *)v68 - 3) = v71;
                  *((_DWORD *)v68 - 3) = *(_DWORD *)(v65 + v67 + 36);
                  *((void *)v68 - 1) = *(void *)(v65 + v67 + 40);
                  v67 += 48;
                }
                while (v69 + 48 != v66);
              }
            }
            else
            {
              *((void *)v57 - 10) = v65;
              *((void *)v57 - 9) = *((void *)v59 - 9);
              *((_OWORD *)v59 - 5) = 0u;
              *((_OWORD *)v59 - 4) = 0u;
            }
            double v59 = v60;
            double v57 = v61;
          }
          while (v60 != v58);
        }
        uint64_t v184 = v61;
        float64x2_t v72 = v181;
        if (v181 != v28)
        {
          do
          {
            *(void *)uint64_t v48 = *(void *)v28;
            v48[8] = 0;
            if (v28[8])
            {
              long long v73 = *((_OWORD *)v28 + 2);
              *((_OWORD *)v48 + 1) = *((_OWORD *)v28 + 1);
              *((_OWORD *)v48 + 2) = v73;
              v48[8] = 1;
            }
            v48[48] = 0;
            if (v28[48])
            {
              long long v74 = *(_OWORD *)(v28 + 56);
              *(_OWORD *)(v48 + 72) = *(_OWORD *)(v28 + 72);
              *(_OWORD *)(v48 + 56) = v74;
              v48[48] = 1;
            }
            *((void *)v48 + 11) = v48 + 120;
            uint64_t v75 = *((void *)v28 + 11);
            *((void *)v48 + 12) = v48 + 120;
            *((void *)v48 + 13) = v48 + 120;
            *((void *)v48 + 14) = *((void *)v28 + 14);
            if (v75 == *((void *)v28 + 13))
            {
              *((void *)v48 + 12) = &v48[*((void *)v28 + 12) - v75 + 120];
              uint64_t v76 = *((void *)v28 + 12);
              if (v75 != v76)
              {
                uint64_t v77 = 0;
                do
                {
                  long double v78 = &v48[v77];
                  uint64_t v79 = v75 + v77;
                  long long v80 = *(_OWORD *)(v75 + v77);
                  *((void *)v78 + 17) = *(void *)(v75 + v77 + 16);
                  *(_OWORD *)(v78 + 120) = v80;
                  uint64_t v81 = *(void *)(v75 + v77 + 24);
                  *((_DWORD *)v78 + 38) = *(_DWORD *)(v75 + v77 + 32);
                  *((void *)v78 + 18) = v81;
                  *((_DWORD *)v78 + 39) = *(_DWORD *)(v75 + v77 + 36);
                  *((void *)v78 + 20) = *(void *)(v75 + v77 + 40);
                  v77 += 48;
                }
                while (v79 + 48 != v76);
              }
            }
            else
            {
              *((void *)v48 + 11) = v75;
              *((void *)v48 + 12) = *((void *)v28 + 12);
              *(_OWORD *)(v28 + 88) = 0u;
              *(_OWORD *)(v28 + 104) = 0u;
            }
            v28 += 168;
            v48 += 168;
          }
          while (v28 != v72);
          double v61 = v184;
          double v28 = v181;
        }
        uint64_t v185 = (uint64_t)v48;
        long double v82 = v180;
        __double2 v180 = v61;
        double v181 = v48;
        unint64_t v182 = v186;
        while (v28 != v82)
        {
          double v83 = (void *)*((void *)v28 - 10);
          if (v83 != *((void **)v28 - 8)) {
            free(v83);
          }
          if (*(v28 - 120)) {
            *(v28 - 120) = 0;
          }
          if (*(v28 - 160)) {
            *(v28 - 160) = 0;
          }
          v28 -= 168;
        }
        if (v82) {
          operator delete(v82);
        }
        goto LABEL_169;
      }
      if (v27 > 0)
      {
        if (v26 == v25)
        {
          double v42 = v181;
        }
        else
        {
          uint64_t v33 = 0;
          do
          {
            long double v34 = &v26[v33];
            long double v35 = &v28[v33];
            *(void *)long double v35 = *(void *)&v26[v33];
            v35[8] = 0;
            if (v26[v33 + 8])
            {
              long long v36 = *((_OWORD *)v34 + 2);
              *((_OWORD *)v35 + 1) = *((_OWORD *)v34 + 1);
              *((_OWORD *)v35 + 2) = v36;
              v35[8] = 1;
            }
            v35[48] = 0;
            if (v34[48])
            {
              long double v37 = &v28[v33];
              long long v38 = *(_OWORD *)&v26[v33 + 56];
              *(_OWORD *)(v37 + 72) = *(_OWORD *)&v26[v33 + 72];
              *(_OWORD *)(v37 + 56) = v38;
              v35[48] = 1;
            }
            float64x2_t v39 = &v28[v33];
            uint64_t v40 = (uint64_t)&v28[v33 + 120];
            *((void *)v39 + 11) = v40;
            *((void *)v39 + 12) = v40;
            uint64_t v41 = (uint64_t)&v28[v33 + 88];
            *(void *)(v41 + 16) = v40;
            *(void *)(v41 + 24) = 1;
            geo::small_vector_base<md::mun::OrientedPlane>::append<md::mun::OrientedPlane const*>(v41, *((long long **)v34 + 11), *((long long **)v34 + 12));
            v33 += 168;
          }
          while (v34 + 168 != v25);
          double v42 = &v28[v33];
        }
        double v181 = v42;
        goto LABEL_169;
      }
      uint64_t v43 = &v26[168 * v27];
      uint64_t v44 = v181;
      uint64_t v84 = 168 * v27;
      double v85 = &v181[-168 * v27];
      long double v86 = v181;
      unint64_t v87 = (unint64_t)v85;
      if (v85 < v181)
      {
        do
        {
          *(void *)long double v86 = *(void *)v87;
          v86[8] = 0;
          if (*(unsigned char *)(v87 + 8))
          {
            long long v90 = *(_OWORD *)(v87 + 32);
            *((_OWORD *)v86 + 1) = *(_OWORD *)(v87 + 16);
            *((_OWORD *)v86 + 2) = v90;
            v86[8] = 1;
          }
          v86[48] = 0;
          if (*(unsigned char *)(v87 + 48))
          {
            long long v91 = *(_OWORD *)(v87 + 56);
            *(_OWORD *)(v86 + 72) = *(_OWORD *)(v87 + 72);
            *(_OWORD *)(v86 + 56) = v91;
            v86[48] = 1;
          }
          *((void *)v86 + 11) = v86 + 120;
          uint64_t v92 = *(void *)(v87 + 88);
          *((void *)v86 + 12) = v86 + 120;
          *((void *)v86 + 13) = v86 + 120;
          *((void *)v86 + 14) = *(void *)(v87 + 112);
          if (v92 == *(void *)(v87 + 104))
          {
            *((void *)v86 + 12) = &v86[*(void *)(v87 + 96) - v92 + 120];
            uint64_t v93 = *(void *)(v87 + 96);
            if (v92 != v93)
            {
              uint64_t v94 = 0;
              do
              {
                id v95 = &v86[v94];
                uint64_t v96 = v92 + v94;
                long long v97 = *(_OWORD *)(v92 + v94);
                *((void *)v95 + 17) = *(void *)(v92 + v94 + 16);
                *(_OWORD *)(v95 + 120) = v97;
                uint64_t v98 = *(void *)(v92 + v94 + 24);
                *((_DWORD *)v95 + 38) = *(_DWORD *)(v92 + v94 + 32);
                *((void *)v95 + 18) = v98;
                *((_DWORD *)v95 + 39) = *(_DWORD *)(v92 + v94 + 36);
                *((void *)v95 + 20) = *(void *)(v92 + v94 + 40);
                v94 += 48;
              }
              while (v96 + 48 != v93);
            }
          }
          else
          {
            *((void *)v86 + 11) = v92;
            *((void *)v86 + 12) = *(void *)(v87 + 96);
            *(_OWORD *)(v87 + 88) = 0u;
            *(_OWORD *)(v87 + 104) = 0u;
          }
          v87 += 168;
          v86 += 168;
        }
        while (v87 < (unint64_t)v28);
      }
      double v181 = v86;
      if (v44 != &v28[v84])
      {
        float64x2_t v88 = v85;
        float64x2_t v89 = v44;
        while (1)
        {
          uint64_t v100 = *((void *)v88 - 21);
          v88 -= 168;
          *((void *)v89 - 21) = v100;
          v89 -= 168;
          if (v88[8])
          {
            if (v89[8])
            {
              *((void *)v44 - 19) = *((void *)v85 - 19);
              *((void *)v44 - 18) = *((void *)v85 - 18);
              *((void *)v44 - 17) = *((void *)v85 - 17);
              *((void *)v44 - 16) = *((void *)v85 - 16);
            }
            else
            {
              long long v101 = *(_OWORD *)(v85 - 152);
              *(_OWORD *)(v44 - 136) = *(_OWORD *)(v85 - 136);
              *(_OWORD *)(v44 - 152) = v101;
              *(v44 - 160) = 1;
            }
          }
          else if (v89[8])
          {
            *(v44 - 160) = 0;
          }
          if (!*(v85 - 120)) {
            break;
          }
          if (*(v44 - 120))
          {
            *((void *)v44 - 14) = *((void *)v85 - 14);
            *((void *)v44 - 13) = *((void *)v85 - 13);
            *((void *)v44 - 12) = *((void *)v85 - 12);
            *((void *)v44 - 11) = *((void *)v85 - 11);
            if (v44 != v85) {
              goto LABEL_139;
            }
          }
          else
          {
            long long v112 = *((_OWORD *)v85 - 6);
            *((_OWORD *)v44 - 7) = *((_OWORD *)v85 - 7);
            *((_OWORD *)v44 - 6) = v112;
            *(v44 - 120) = 1;
            if (v44 != v85) {
              goto LABEL_139;
            }
          }
LABEL_125:
          uint64_t v44 = v89;
          double v85 = v88;
          if (v88 == v28) {
            goto LABEL_148;
          }
        }
        if (*(v44 - 120)) {
          *(v44 - 120) = 0;
        }
        if (v44 == v85) {
          goto LABEL_125;
        }
LABEL_139:
        double v102 = (void *)*((void *)v44 - 10);
        if (v102 != *((void **)v44 - 8)) {
          free(v102);
        }
        double v103 = v44 - 48;
        *((void *)v44 - 8) = v44 - 48;
        uint64_t v104 = *((void *)v85 - 10);
        if (v104 == *((void *)v85 - 8))
        {
          *((void *)v44 - 10) = v103;
          uint64_t v105 = *((void *)v85 - 10);
          *((void *)v44 - 9) = &v103[*((void *)v85 - 9) - v105];
          uint64_t v106 = *((void *)v85 - 9);
          if (v105 != v106)
          {
            unint64_t v107 = 0;
            do
            {
              double v108 = &v44[v107];
              uint64_t v109 = v105 + v107;
              long long v110 = *(_OWORD *)(v105 + v107);
              *((void *)v108 - 4) = *(void *)(v105 + v107 + 16);
              *((_OWORD *)v108 - 3) = v110;
              uint64_t v111 = *(void *)(v105 + v107 + 24);
              *((_DWORD *)v108 - 4) = *(_DWORD *)(v105 + v107 + 32);
              *((void *)v108 - 3) = v111;
              *((_DWORD *)v108 - 3) = *(_DWORD *)(v105 + v107 + 36);
              *((void *)v108 - 1) = *(void *)(v105 + v107 + 40);
              v107 += 48;
            }
            while (v109 + 48 != v106);
          }
        }
        else
        {
          int8x16_t v99 = v85 - 80;
          *((void *)v44 - 10) = v104;
          *((void *)v44 - 9) = *((void *)v85 - 9);
          *(_OWORD *)int8x16_t v99 = 0u;
          *((_OWORD *)v99 + 1) = 0u;
        }
        *((void *)v44 - 7) = *((void *)v85 - 7);
        goto LABEL_125;
      }
LABEL_148:
      if (v26 != v43) {
        break;
      }
LABEL_169:
      uint64_t v126 = *(void *)(v173 + 152);
      uint64_t v125 = *(void *)(v173 + 160);
      uint64_t v127 = v125 - v126;
      if (v125 - v126 >= 1)
      {
        uint64_t v128 = v127 / 1864;
        uint64_t v129 = v178;
        if (0x63FB9AEB1FDCD759 * ((v179 - v178) >> 3) >= v127 / 1864)
        {
          if (v128 <= 0)
          {
            uint64_t v174 = v126 + 1864 * v128;
            uint64_t v162 = 1864 * v128;
            __double2 v163 = &v178[-1864 * v128];
            uint64_t v164 = (uint64_t)v178;
            unint64_t v165 = (unint64_t)v163;
            if (v163 < v178)
            {
              do
              {
                uint64_t v166 = std::construct_at[abi:nn180100]<md::mun::CollectionPoint,md::mun::CollectionPoint,md::mun::CollectionPoint*>(v164, v165);
                v165 += 1864;
                uint64_t v164 = v166 + 1864;
              }
              while (v165 < (unint64_t)v129);
            }
            __double2 v178 = (char *)v164;
            if (v129 != &v129[v162])
            {
              uint64_t v167 = 0;
              do
              {
                double v169 = &v129[v167];
                double v170 = &v163[v167];
                *(void *)&v129[v167 - 1864] = *(void *)&v163[v167 - 1864];
                *(_DWORD *)&v129[v167 - 1832] = *(_DWORD *)&v163[v167 - 1832];
                *(_DWORD *)&v129[v167 - 1828] = *(_DWORD *)&v163[v167 - 1828];
                *(_DWORD *)&v129[v167 - 1824] = *(_DWORD *)&v163[v167 - 1824];
                *(_DWORD *)&v129[v167 - 1820] = *(_DWORD *)&v163[v167 - 1820];
                *(void *)&v129[v167 - 1856] = *(void *)&v163[v167 - 1856];
                *(void *)&v129[v167 - 1848] = *(void *)&v163[v167 - 1848];
                *(void *)&v129[v167 - 1840] = *(void *)&v163[v167 - 1840];
                *(_DWORD *)&v129[v167 - 1816] = *(_DWORD *)&v163[v167 - 1816];
                *(void *)&v129[v167 - 1808] = *(void *)&v163[v167 - 1808];
                *(void *)&v129[v167 - 1800] = *(void *)&v163[v167 - 1800];
                *(void *)&v129[v167 - 1792] = *(void *)&v163[v167 - 1792];
                *(void *)&v129[v167 - 1784] = *(void *)&v163[v167 - 1784];
                if (v163 != v129) {
                  geo::small_vector_base<md::mun::PhotoInfo>::move((uint64_t)(v169 - 1776), (uint64_t *)v170 - 222, (uint64_t)(v169 - 1744));
                }
                uint64_t v168 = *((void *)v170 - 2);
                *(void *)(v169 - 11) = *(void *)(v170 - 11);
                *((void *)v169 - 2) = v168;
                v167 -= 1864;
              }
              while (-8 * (-v162 >> 3) != v167);
            }
            std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<md::mun::CollectionPoint const*,md::mun::CollectionPoint const*,md::mun::CollectionPoint*>(v126, v174, (uint64_t)v129);
          }
          else
          {
            uint64_t v134 = *(void *)(v173 + 152);
            if (v134 == v125)
            {
              long double v142 = v178;
            }
            else
            {
              float64x2_t v135 = v178;
              do
              {
                double v136 = v135;
                *(void *)float64x2_t v135 = *(void *)v134;
                long long v137 = *(_OWORD *)(v134 + 8);
                *((void *)v135 + 3) = *(void *)(v134 + 24);
                *(_OWORD *)(v135 + 8) = v137;
                uint64_t v138 = *(void *)(v134 + 32);
                *((_DWORD *)v136 + 10) = *(_DWORD *)(v134 + 40);
                *((void *)v136 + 4) = v138;
                *(void *)(v136 + 44) = *(void *)(v134 + 44);
                long long v139 = *(_OWORD *)(v134 + 56);
                long long v140 = *(_OWORD *)(v134 + 72);
                *((void *)v136 + 11) = v136 + 120;
                *(_OWORD *)(v136 + 56) = v139;
                *(_OWORD *)(v136 + 72) = v140;
                *((void *)v136 + 12) = v136 + 120;
                *((void *)v136 + 13) = v136 + 120;
                *((void *)v136 + 14) = 6;
                geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)(v136 + 88), *(long long **)(v134 + 88), *(long long **)(v134 + 96));
                uint64_t v141 = *(void *)(v134 + 1848);
                *(void *)(v136 + 1853) = *(void *)(v134 + 1853);
                *((void *)v136 + 231) = v141;
                v134 += 1864;
                float64x2_t v135 = v136 + 1864;
              }
              while (v134 != v125);
              long double v142 = v136 + 1864;
            }
            __double2 v178 = v142;
          }
        }
        else
        {
          uint64_t v130 = 0x63FB9AEB1FDCD759 * ((v178 - v177) >> 3);
          unint64_t v131 = v130 + v128;
          if ((unint64_t)(v130 + v128) > 0x2328A701194538) {
            abort();
          }
          if (0xC7F735D63FB9AEB2 * ((v179 - v177) >> 3) > v131) {
            unint64_t v131 = 0xC7F735D63FB9AEB2 * ((v179 - v177) >> 3);
          }
          if ((unint64_t)(0x63FB9AEB1FDCD759 * ((v179 - v177) >> 3)) >= 0x119453808CA29CLL) {
            unint64_t v132 = 0x2328A701194538;
          }
          else {
            unint64_t v132 = v131;
          }
          double v187 = &v179;
          if (v132)
          {
            if (v132 > 0x2328A701194538) {
LABEL_227:
            }
              std::__throw_bad_array_new_length[abi:nn180100]();
            uint64_t v133 = (char *)operator new(1864 * v132);
          }
          else
          {
            uint64_t v133 = 0;
          }
          uint64_t v143 = 0;
          __double2 v144 = &v133[1864 * v130];
          id v183 = v133;
          uint64_t v184 = v144;
          uint64_t v185 = (uint64_t)v144;
          uint64_t v186 = &v133[1864 * v132];
          uint64_t v145 = 1864 * v128;
          uint64_t v146 = (uint64_t)&v144[v145];
          do
          {
            double v147 = &v144[v143];
            *(void *)double v147 = *(void *)(v126 + v143);
            long long v148 = *(_OWORD *)(v126 + v143 + 8);
            *((void *)v147 + 3) = *(void *)(v126 + v143 + 24);
            *(_OWORD *)(v147 + 8) = v148;
            uint64_t v149 = *(void *)(v126 + v143 + 32);
            *((_DWORD *)v147 + 10) = *(_DWORD *)(v126 + v143 + 40);
            *((void *)v147 + 4) = v149;
            *(void *)(v147 + 44) = *(void *)(v126 + v143 + 44);
            long long v150 = *(_OWORD *)(v126 + v143 + 56);
            *(_OWORD *)(v147 + 72) = *(_OWORD *)(v126 + v143 + 72);
            uint64_t v151 = (uint64_t)&v144[v143 + 120];
            *(void *)&v144[v143 + 88] = v151;
            *(_OWORD *)(v147 + 56) = v150;
            *((void *)v147 + 12) = v151;
            *((void *)v147 + 13) = v151;
            *((void *)v147 + 14) = 6;
            geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)&v144[v143 + 88], *(long long **)(v126 + v143 + 88), *(long long **)(v126 + v143 + 96));
            uint64_t v152 = *(void *)(v126 + v143 + 1848);
            *(void *)(v147 + 1853) = *(void *)(v126 + v143 + 1853);
            *((void *)v147 + 231) = v152;
            v143 += 1864;
          }
          while (v145 != v143);
          uint64_t v185 = (uint64_t)&v144[v145];
          double v153 = v184;
          double v154 = v177;
          if (v177 != v129)
          {
            uint64_t v155 = (uint64_t)v129;
            do
            {
              v155 -= 1864;
              double v153 = (char *)std::construct_at[abi:nn180100]<md::mun::CollectionPoint,md::mun::CollectionPoint,md::mun::CollectionPoint*>((uint64_t)(v153 - 1864), v155);
            }
            while ((char *)v155 != v154);
            uint64_t v146 = v185;
          }
          uint64_t v184 = v153;
          long double v156 = v178;
          if (v178 != v129)
          {
            do
            {
              std::construct_at[abi:nn180100]<md::mun::CollectionPoint,md::mun::CollectionPoint,md::mun::CollectionPoint*>(v146, (uint64_t)v129);
              v129 += 1864;
              v146 += 1864;
            }
            while (v129 != v156);
            double v153 = v184;
            uint64_t v129 = v178;
          }
          long double v157 = v177;
          double v177 = v153;
          __double2 v178 = (char *)v146;
          double v179 = v186;
          if (v129 != v157)
          {
            do
            {
              double v158 = v129 - 1864;
              long double v159 = (void *)*((void *)v129 - 222);
              double v160 = (void *)*((void *)v129 - 221);
              if (v159 != v160)
              {
                do
                {
                  __double2 v161 = (void *)v159[31];
                  if (v161 != (void *)v159[33]) {
                    free(v161);
                  }
                  v159 += 36;
                }
                while (v159 != v160);
                long double v159 = (void *)*((void *)v129 - 222);
              }
              if (v159 != *((void **)v129 - 220)) {
                free(v159);
              }
              v129 -= 1864;
            }
            while (v158 != v157);
          }
          if (v157) {
            operator delete(v157);
          }
        }
      }
      if (v171 && !atomic_fetch_add(&v171->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v171->__on_zero_shared)(v171);
        std::__shared_weak_count::__release_weak(v171);
      }
      long double v21 = (void *)*v172;
      if (!*v172) {
        goto LABEL_221;
      }
    }
    uint64_t v113 = 0;
    while (1)
    {
      float64x2_t v114 = &v26[v113];
      uint64_t v115 = &v28[v113];
      *(void *)&v28[v113] = *(void *)&v26[v113];
      if (v26[v113 + 8])
      {
        if (v28[v113 + 8])
        {
          long long v116 = &v28[v113];
          *((void *)v116 + 2) = *(void *)&v26[v113 + 16];
          *((void *)v116 + 3) = *(void *)&v26[v113 + 24];
          *((void *)v116 + 4) = *(void *)&v26[v113 + 32];
          *((void *)v116 + 5) = *(void *)&v26[v113 + 40];
        }
        else
        {
          double v117 = &v28[v113];
          long long v118 = *(_OWORD *)&v26[v113 + 32];
          *((_OWORD *)v117 + 1) = *(_OWORD *)&v26[v113 + 16];
          *((_OWORD *)v117 + 2) = v118;
          v115[8] = 1;
        }
      }
      else if (v28[v113 + 8])
      {
        v115[8] = 0;
      }
      uint64_t v119 = &v28[v113];
      if (!v114[48]) {
        break;
      }
      if (v28[v113 + 48])
      {
        double v120 = &v28[v113];
        *((void *)v120 + 7) = *(void *)&v26[v113 + 56];
        *((void *)v120 + 8) = *(void *)&v26[v113 + 64];
        *((void *)v120 + 9) = *(void *)&v26[v113 + 72];
        *((void *)v120 + 10) = *(void *)&v26[v113 + 80];
        if (v115 != v114) {
          goto LABEL_165;
        }
      }
      else
      {
        uint64_t v123 = &v28[v113];
        long long v124 = *(_OWORD *)&v26[v113 + 56];
        *(_OWORD *)(v123 + 72) = *(_OWORD *)&v26[v113 + 72];
        *(_OWORD *)(v123 + 56) = v124;
        v119[48] = 1;
        if (v115 != v114) {
          goto LABEL_165;
        }
      }
LABEL_151:
      v113 += 168;
      if (v114 + 168 == v43) {
        goto LABEL_169;
      }
    }
    if (v28[v113 + 48]) {
      v119[48] = 0;
    }
    if (v115 == v114) {
      goto LABEL_151;
    }
LABEL_165:
    double v121 = &v28[v113];
    double v122 = (void **)&v28[v113 + 88];
    if (*v122 != *(void **)&v28[v113 + 104]) {
      free(*v122);
    }
    *double v122 = v121 + 120;
    *((void *)v121 + 12) = v121 + 120;
    *((void *)v121 + 13) = v121 + 120;
    *(void *)&v28[v113 + 112] = 1;
    geo::small_vector_base<md::mun::OrientedPlane>::append<md::mun::OrientedPlane const*>((uint64_t)&v28[v113 + 88], *(long long **)&v26[v113 + 88], *(long long **)&v26[v113 + 96]);
    goto LABEL_151;
  }
LABEL_223:
  *a2 = 0;
  a2[1] = 0;
  if (v176)
  {
    if (!atomic_fetch_add(&v176->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v176->__on_zero_shared)(v176);
      std::__shared_weak_count::__release_weak(v176);
    }
  }
}

void sub_1A2063214(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  std::__shared_weak_count::~__shared_weak_count(v21);
  operator delete(v25);
  double v26 = *(void **)(v23 - 128);
  if (v26) {
    operator delete(v26);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v23 - 192);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v23 - 176);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v23 - 152);
  (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a21);
  _Unwind_Resume(a1);
}

void std::vector<md::mun::CollectionPoint>::reserve(char **a1, unint64_t a2)
{
  double v2 = *a1;
  if (0x63FB9AEB1FDCD759 * ((a1[2] - *a1) >> 3) >= a2) {
    return;
  }
  if (a2 >= 0x2328A701194539) {
    abort();
  }
  uint64_t v4 = (uint64_t)a1[1];
  uint64_t v5 = 1864 * a2;
  uint64_t v6 = (char *)operator new(1864 * a2);
  uint64_t v7 = &v6[v5];
  uint64_t v8 = &v6[v4 - (void)v2];
  if ((char *)v4 == v2)
  {
    *a1 = v8;
    a1[1] = v8;
    a1[2] = v7;
    if (!v2) {
      return;
    }
    goto LABEL_8;
  }
  uint64_t v9 = (uint64_t)&v6[v4 - (void)v2];
  do
  {
    v4 -= 1864;
    uint64_t v9 = std::construct_at[abi:nn180100]<md::mun::CollectionPoint,md::mun::CollectionPoint,md::mun::CollectionPoint*>(v9 - 1864, v4);
  }
  while ((char *)v4 != v2);
  double v2 = *a1;
  uint64_t v10 = a1[1];
  *a1 = (char *)v9;
  a1[1] = v8;
  a1[2] = v7;
  if (v10 != v2)
  {
    do
    {
      long double v11 = v10 - 1864;
      unint64_t v12 = (void *)*((void *)v10 - 222);
      unint64_t v13 = (void *)*((void *)v10 - 221);
      if (v12 != v13)
      {
        do
        {
          uint64_t v14 = (void *)v12[31];
          if (v14 != (void *)v12[33]) {
            free(v14);
          }
          v12 += 36;
        }
        while (v12 != v13);
        unint64_t v12 = (void *)*((void *)v10 - 222);
      }
      if (v12 != *((void **)v10 - 220)) {
        free(v12);
      }
      v10 -= 1864;
    }
    while (v11 != v2);
  }
  if (v2)
  {
LABEL_8:
    operator delete(v2);
  }
}

void **std::vector<md::mun::CollectionPoint>::~vector[abi:nn180100](void **a1)
{
  double v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = v3 - 1864;
        uint64_t v6 = (void *)*((void *)v3 - 222);
        uint64_t v7 = (void *)*((void *)v3 - 221);
        if (v6 != v7)
        {
          do
          {
            uint64_t v8 = (void *)v6[31];
            if (v8 != (void *)v6[33]) {
              free(v8);
            }
            v6 += 36;
          }
          while (v6 != v7);
          uint64_t v6 = (void *)*((void *)v3 - 222);
        }
        if (v6 != *((void **)v3 - 220)) {
          free(v6);
        }
        v3 -= 1864;
      }
      while (v5 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void **std::vector<md::mun::StorefrontBundle>::~vector[abi:nn180100](void **a1)
{
  double v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = (void *)*((void *)v3 - 10);
        if (v5 != *((void **)v3 - 8)) {
          free(v5);
        }
        if (*(v3 - 120)) {
          *(v3 - 120) = 0;
        }
        if (*(v3 - 160)) {
          *(v3 - 160) = 0;
        }
        v3 -= 168;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>(uint64_t a1, long long *a2, long long *a3)
{
  uint64_t v4 = a2;
  unint64_t v6 = 0x8E38E38E38E38E39 * (((char *)a3 - (char *)a2) >> 5);
  uint64_t v7 = *(void *)(a1 + 8);
  unint64_t v8 = 0x8E38E38E38E38E39 * ((v7 - *(void *)a1) >> 5);
  if (v6 > *(void *)(a1 + 24) - v8)
  {
    geo::small_vector_base<md::mun::PhotoInfo>::grow((void **)a1, v8 - 0x71C71C71C71C71C7 * (((char *)a3 - (char *)a2) >> 5));
    uint64_t v7 = *(void *)(a1 + 8);
  }
  if (v4 != a3)
  {
    unint64_t v52 = v6;
    while (1)
    {
      long long v10 = *v4;
      *(void *)(v7 + 16) = *((void *)v4 + 2);
      *(_OWORD *)uint64_t v7 = v10;
      uint64_t v11 = *((void *)v4 + 3);
      *(_DWORD *)(v7 + 32) = *((_DWORD *)v4 + 8);
      *(void *)(v7 + 24) = v11;
      *(void *)(v7 + 36) = *(void *)((char *)v4 + 36);
      long long v12 = *(long long *)((char *)v4 + 44);
      long long v13 = *(long long *)((char *)v4 + 60);
      long long v14 = *(long long *)((char *)v4 + 76);
      *(_OWORD *)(v7 + 92) = *(long long *)((char *)v4 + 92);
      *(_OWORD *)(v7 + 76) = v14;
      *(_OWORD *)(v7 + 60) = v13;
      *(_OWORD *)(v7 + 44) = v12;
      long long v15 = *(long long *)((char *)v4 + 108);
      long long v16 = *(long long *)((char *)v4 + 124);
      long long v17 = *(long long *)((char *)v4 + 140);
      *(_OWORD *)(v7 + 156) = *(long long *)((char *)v4 + 156);
      *(_OWORD *)(v7 + 140) = v17;
      *(_OWORD *)(v7 + 124) = v16;
      *(_OWORD *)(v7 + 108) = v15;
      long long v18 = *(long long *)((char *)v4 + 172);
      long long v19 = *(long long *)((char *)v4 + 188);
      long long v20 = *(long long *)((char *)v4 + 204);
      *(_OWORD *)(v7 + 220) = *(long long *)((char *)v4 + 220);
      *(_OWORD *)(v7 + 204) = v20;
      *(_OWORD *)(v7 + 188) = v19;
      *(_OWORD *)(v7 + 172) = v18;
      *(_DWORD *)(v7 + 236) = *((_DWORD *)v4 + 59);
      *(unsigned char *)(v7 + 240) = *((unsigned char *)v4 + 240);
      uint64_t v9 = (char *)(v7 + 280);
      *(void *)(v7 + 248) = v7 + 280;
      *(void *)(v7 + 256) = v7 + 280;
      *(void *)(v7 + 264) = v7 + 280;
      *(void *)(v7 + 272) = 2;
      uint64_t v22 = (char *)*((void *)v4 + 31);
      long double v21 = (char *)*((void *)v4 + 32);
      unint64_t v23 = v21 - v22;
      if ((unint64_t)(v21 - v22) < 3) {
        goto LABEL_28;
      }
      size_t v24 = v23 <= 4 ? 4 : v21 - v22;
      uint64_t v9 = (char *)malloc_type_malloc(v24, 0x100004077774924uLL);
      long long v25 = *(char **)(v7 + 248);
      double v26 = *(char **)(v7 + 256);
      if (v25 != v26) {
        break;
      }
LABEL_27:
      *(void *)(v7 + 248) = v9;
      *(void *)(v7 + 256) = v9;
      *(void *)(v7 + 272) = v24;
LABEL_28:
      if (v22 == v21) {
        goto LABEL_6;
      }
      if (v23 < 8)
      {
        uint64_t v41 = v9;
        goto LABEL_44;
      }
      if ((unint64_t)(v9 - v22) < 0x20)
      {
        uint64_t v41 = v9;
        goto LABEL_44;
      }
      if (v23 >= 0x20)
      {
        unint64_t v40 = v23 & 0xFFFFFFFFFFFFFFE0;
        double v42 = (long long *)(v22 + 16);
        uint64_t v43 = v9 + 16;
        unint64_t v44 = v23 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v45 = *v42;
          *(v43 - 1) = *(v42 - 1);
          *uint64_t v43 = v45;
          v42 += 2;
          v43 += 2;
          v44 -= 32;
        }
        while (v44);
        if (v23 == v40) {
          goto LABEL_5;
        }
        if ((v23 & 0x18) == 0)
        {
          v22 += v40;
          uint64_t v41 = &v9[v40];
          goto LABEL_44;
        }
      }
      else
      {
        unint64_t v40 = 0;
      }
      unint64_t v46 = v23 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v41 = &v9[v23 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v47 = v40 - (v23 & 0xFFFFFFFFFFFFFFF8);
      uint64_t v48 = (uint64_t *)&v22[v40];
      double v49 = &v9[v40];
      do
      {
        uint64_t v50 = *v48++;
        *(void *)double v49 = v50;
        v49 += 8;
        v47 += 8;
      }
      while (v47);
      if (v23 == v46) {
        goto LABEL_5;
      }
      v22 += v46;
      do
      {
LABEL_44:
        char v51 = *v22++;
        *v41++ = v51;
      }
      while (v22 != v21);
LABEL_5:
      uint64_t v9 = *(char **)(v7 + 256);
LABEL_6:
      *(void *)(v7 + 256) = &v9[v23];
      v4 += 18;
      v7 += 288;
      if (v4 == a3)
      {
        uint64_t v7 = *(void *)(a1 + 8);
        unint64_t v6 = v52;
        goto LABEL_47;
      }
    }
    unint64_t v27 = v26 - v25;
    if ((unint64_t)(v26 - v25) < 8)
    {
      double v28 = v9;
    }
    else
    {
      double v28 = v9;
      if ((unint64_t)(v9 - v25) >= 0x20)
      {
        if (v27 < 0x20)
        {
          uint64_t v29 = 0;
LABEL_21:
          unint64_t v34 = v27 & 0xFFFFFFFFFFFFFFF8;
          double v28 = &v9[v27 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v35 = v29 - (v27 & 0xFFFFFFFFFFFFFFF8);
          long long v36 = (uint64_t *)&v25[v29];
          long double v37 = &v9[v29];
          do
          {
            uint64_t v38 = *v36++;
            *(void *)long double v37 = v38;
            v37 += 8;
            v35 += 8;
          }
          while (v35);
          if (v27 == v34) {
            goto LABEL_27;
          }
          v25 += v34;
          goto LABEL_26;
        }
        uint64_t v29 = v27 & 0xFFFFFFFFFFFFFFE0;
        unint64_t v30 = (long long *)(v25 + 16);
        unint64_t v31 = v9 + 16;
        unint64_t v32 = v27 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v33 = *v30;
          *(v31 - 1) = *(v30 - 1);
          *unint64_t v31 = v33;
          v30 += 2;
          v31 += 2;
          v32 -= 32;
        }
        while (v32);
        if (v27 == v29) {
          goto LABEL_27;
        }
        if ((v27 & 0x18) != 0) {
          goto LABEL_21;
        }
        v25 += v29;
        double v28 = &v9[v29];
      }
    }
    do
    {
LABEL_26:
      char v39 = *v25++;
      *v28++ = v39;
    }
    while (v25 != v26);
    goto LABEL_27;
  }
LABEL_47:
  *(void *)(a1 + 8) = v7 + 288 * v6;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<md::mun::CollectionPoint const*,md::mun::CollectionPoint const*,md::mun::CollectionPoint*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      *(void *)a3 = *(void *)v5;
      *(_DWORD *)(a3 + 32) = *(_DWORD *)(v5 + 32);
      *(_DWORD *)(a3 + 36) = *(_DWORD *)(v5 + 36);
      *(_DWORD *)(a3 + 40) = *(_DWORD *)(v5 + 40);
      *(_DWORD *)(a3 + 44) = *(_DWORD *)(v5 + 44);
      *(void *)(a3 + 8) = *(void *)(v5 + 8);
      *(void *)(a3 + 16) = *(void *)(v5 + 16);
      *(void *)(a3 + 24) = *(void *)(v5 + 24);
      *(_DWORD *)(a3 + 48) = *(_DWORD *)(v5 + 48);
      *(void *)(a3 + 56) = *(void *)(v5 + 56);
      *(void *)(a3 + 64) = *(void *)(v5 + 64);
      *(void *)(a3 + 72) = *(void *)(v5 + 72);
      *(void *)(a3 + 80) = *(void *)(v5 + 80);
      if (a3 != v5)
      {
        uint64_t v7 = *(void **)(a3 + 88);
        unint64_t v8 = *(void **)(a3 + 96);
        if (v7 != v8)
        {
          do
          {
            uint64_t v9 = (void *)v7[31];
            if (v9 != (void *)v7[33]) {
              free(v9);
            }
            v7 += 36;
          }
          while (v7 != v8);
          uint64_t v7 = *(void **)(a3 + 88);
        }
        if (v7 != *(void **)(a3 + 104)) {
          free(v7);
        }
        *(void *)(a3 + 88) = a3 + 120;
        *(void *)(a3 + 96) = a3 + 120;
        *(void *)(a3 + 104) = a3 + 120;
        *(void *)(a3 + 112) = 6;
        geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>(a3 + 88, *(long long **)(v5 + 88), *(long long **)(v5 + 96));
      }
      uint64_t v6 = *(void *)(v5 + 1848);
      *(void *)(a3 + 1853) = *(void *)(v5 + 1853);
      *(void *)(a3 + 1848) = v6;
      v5 += 1864;
      a3 += 1864;
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t std::construct_at[abi:nn180100]<md::mun::CollectionPoint,md::mun::CollectionPoint,md::mun::CollectionPoint*>(uint64_t result, uint64_t a2)
{
  *(void *)double result = *(void *)a2;
  long long v2 = *(_OWORD *)(a2 + 8);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(result + 8) = v2;
  uint64_t v3 = *(void *)(a2 + 32);
  *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 40);
  *(void *)(result + 32) = v3;
  *(void *)(result + 44) = *(void *)(a2 + 44);
  long long v4 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(result + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(result + 56) = v4;
  uint64_t v5 = result + 120;
  *(void *)(result + 88) = result + 120;
  uint64_t v6 = *(long long **)(a2 + 88);
  *(void *)(result + 104) = result + 120;
  uint64_t v7 = *(long long **)(a2 + 104);
  *(void *)(result + 112) = *(void *)(a2 + 112);
  *(void *)(result + 96) = result + 120;
  if (v6 == v7)
  {
    *(void *)(result + 96) = v5 + *(void *)(a2 + 96) - (void)v6;
    long long v10 = *(long long **)(a2 + 96);
    if (v6 == v10) {
      goto LABEL_3;
    }
    uint64_t v11 = 0;
    long long v12 = (_OWORD *)(result + 416);
    uint64_t v13 = result + 400;
    while (1)
    {
      long long v15 = *v6;
      *(void *)(v5 + 16) = *((void *)v6 + 2);
      *(_OWORD *)uint64_t v5 = v15;
      uint64_t v16 = *((void *)v6 + 3);
      *(_DWORD *)(v5 + 32) = *((_DWORD *)v6 + 8);
      *(void *)(v5 + 24) = v16;
      *(void *)(v5 + 36) = *(void *)((char *)v6 + 36);
      long long v17 = *(long long *)((char *)v6 + 44);
      long long v18 = *(long long *)((char *)v6 + 60);
      long long v19 = *(long long *)((char *)v6 + 76);
      *(_OWORD *)(v5 + 92) = *(long long *)((char *)v6 + 92);
      *(_OWORD *)(v5 + 76) = v19;
      *(_OWORD *)(v5 + 60) = v18;
      *(_OWORD *)(v5 + 44) = v17;
      long long v20 = *(long long *)((char *)v6 + 108);
      long long v21 = *(long long *)((char *)v6 + 124);
      long long v22 = *(long long *)((char *)v6 + 140);
      *(_OWORD *)(v5 + 156) = *(long long *)((char *)v6 + 156);
      *(_OWORD *)(v5 + 140) = v22;
      *(_OWORD *)(v5 + 124) = v21;
      *(_OWORD *)(v5 + 108) = v20;
      long long v23 = *(long long *)((char *)v6 + 172);
      long long v24 = *(long long *)((char *)v6 + 188);
      long long v25 = *(long long *)((char *)v6 + 204);
      *(_OWORD *)(v5 + 220) = *(long long *)((char *)v6 + 220);
      *(_OWORD *)(v5 + 204) = v25;
      *(_OWORD *)(v5 + 188) = v24;
      *(_OWORD *)(v5 + 172) = v23;
      double v26 = (unsigned char *)(v5 + 280);
      *(void *)(v5 + 248) = v5 + 280;
      unint64_t v27 = (char *)*((void *)v6 + 31);
      *(unsigned char *)(v5 + 240) = *((unsigned char *)v6 + 240);
      *(void *)(v5 + 264) = v5 + 280;
      double v28 = (char *)*((void *)v6 + 33);
      *(void *)(v5 + 272) = *((void *)v6 + 34);
      *(_DWORD *)(v5 + 236) = *((_DWORD *)v6 + 59);
      *(void *)(v5 + 256) = v5 + 280;
      if (v27 == v28)
      {
        *(void *)(v5 + 256) = &v26[*((void *)v6 + 32) - (void)v27];
        uint64_t v29 = (char *)*((void *)v6 + 32);
        if (v27 != v29)
        {
          unint64_t v30 = v29 - v27;
          if ((unint64_t)(v29 - v27) >= 8 && (unint64_t)(result + 400 + 288 * v11 - (void)v27) >= 0x20)
          {
            if (v30 < 0x20)
            {
              unint64_t v31 = 0;
              goto LABEL_18;
            }
            unint64_t v31 = v30 & 0xFFFFFFFFFFFFFFE0;
            unint64_t v32 = (long long *)(v27 + 16);
            long long v33 = v12;
            unint64_t v34 = v30 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v35 = *v32;
              *(v33 - 1) = *(v32 - 1);
              *long long v33 = v35;
              v32 += 2;
              v33 += 2;
              v34 -= 32;
            }
            while (v34);
            if (v30 == v31) {
              goto LABEL_7;
            }
            if ((v30 & 0x18) != 0)
            {
LABEL_18:
              unint64_t v36 = v30 & 0xFFFFFFFFFFFFFFF8;
              v26 += v30 & 0xFFFFFFFFFFFFFFF8;
              unint64_t v37 = v31 - (v30 & 0xFFFFFFFFFFFFFFF8);
              uint64_t v38 = (uint64_t *)&v27[v31];
              char v39 = (void *)(v13 + v31);
              do
              {
                uint64_t v40 = *v38++;
                *v39++ = v40;
                v37 += 8;
              }
              while (v37);
              if (v30 == v36) {
                goto LABEL_7;
              }
              v27 += v36;
            }
            else
            {
              v27 += v31;
              v26 += v31;
            }
          }
          do
          {
            char v41 = *v27++;
            *v26++ = v41;
          }
          while (v27 != v29);
        }
      }
      else
      {
        uint64_t v14 = *((void *)v6 + 32);
        *(void *)(v5 + 248) = v27;
        *(void *)(v5 + 256) = v14;
        *(long long *)((char *)v6 + 248) = 0uLL;
        *(long long *)((char *)v6 + 264) = 0uLL;
      }
LABEL_7:
      v5 += 288;
      v6 += 18;
      ++v11;
      v12 += 18;
      v13 += 288;
      if (v6 == v10) {
        goto LABEL_3;
      }
    }
  }
  uint64_t v8 = *(void *)(a2 + 96);
  *(void *)(result + 88) = v6;
  *(void *)(result + 96) = v8;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
LABEL_3:
  uint64_t v9 = *(void *)(a2 + 1848);
  *(void *)(result + 1853) = *(void *)(a2 + 1853);
  *(void *)(result + 1848) = v9;
  return result;
}

uint64_t std::__split_buffer<md::mun::CollectionPoint>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 1864;
    long long v4 = *(void **)(i - 1768);
    uint64_t v5 = *(void **)(i - 1776);
    if (v5 != v4)
    {
      do
      {
        uint64_t v6 = (void *)v5[31];
        if (v6 != (void *)v5[33]) {
          free(v6);
        }
        v5 += 36;
      }
      while (v5 != v4);
      uint64_t v5 = *(void **)(i - 1776);
    }
    if (v5 != *(void **)(i - 1760)) {
      free(v5);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void geo::small_vector_base<md::mun::PhotoInfo>::move(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v6 = *(void **)a1;
    uint64_t v7 = *(void **)(a1 + 8);
    if (*(void **)a1 != v7)
    {
      do
      {
        uint64_t v8 = (void *)v6[31];
        if (v8 != (void *)v6[33]) {
          free(v8);
        }
        v6 += 36;
      }
      while (v6 != v7);
      uint64_t v6 = *(void **)a1;
    }
    if (v6 != *(void **)(a1 + 16)) {
      free(v6);
    }
    *(void *)(a1 + 16) = a3;
    if (*a2 != a2[2])
    {
      uint64_t v9 = a2[1];
      *(void *)a1 = *a2;
      *(void *)(a1 + 8) = v9;
      *(_OWORD *)a2 = 0u;
      *((_OWORD *)a2 + 1) = 0u;
LABEL_12:
      *(void *)(a1 + 24) = a2[3];
      return;
    }
    *(void *)a1 = a3;
    long long v10 = (long long *)*a2;
    *(void *)(a1 + 8) = a3 + a2[1] - *a2;
    uint64_t v11 = (long long *)a2[1];
    if (v10 == v11) {
      goto LABEL_12;
    }
    uint64_t v12 = 0;
    uint64_t v13 = a3 + 280;
    while (1)
    {
      long long v15 = *v10;
      *(void *)(a3 + 16) = *((void *)v10 + 2);
      *(_OWORD *)a3 = v15;
      uint64_t v16 = *((void *)v10 + 3);
      *(_DWORD *)(a3 + 32) = *((_DWORD *)v10 + 8);
      *(void *)(a3 + 24) = v16;
      *(void *)(a3 + 36) = *(void *)((char *)v10 + 36);
      long long v17 = *(long long *)((char *)v10 + 44);
      long long v18 = *(long long *)((char *)v10 + 60);
      long long v19 = *(long long *)((char *)v10 + 76);
      *(_OWORD *)(a3 + 92) = *(long long *)((char *)v10 + 92);
      *(_OWORD *)(a3 + 76) = v19;
      *(_OWORD *)(a3 + 60) = v18;
      *(_OWORD *)(a3 + 44) = v17;
      long long v20 = *(long long *)((char *)v10 + 108);
      long long v21 = *(long long *)((char *)v10 + 124);
      long long v22 = *(long long *)((char *)v10 + 140);
      *(_OWORD *)(a3 + 156) = *(long long *)((char *)v10 + 156);
      *(_OWORD *)(a3 + 140) = v22;
      *(_OWORD *)(a3 + 124) = v21;
      *(_OWORD *)(a3 + 108) = v20;
      long long v23 = *(long long *)((char *)v10 + 172);
      long long v24 = *(long long *)((char *)v10 + 188);
      long long v25 = *(long long *)((char *)v10 + 204);
      *(_OWORD *)(a3 + 220) = *(long long *)((char *)v10 + 220);
      *(_OWORD *)(a3 + 204) = v25;
      *(_OWORD *)(a3 + 188) = v24;
      *(_OWORD *)(a3 + 172) = v23;
      double v26 = (unsigned char *)(a3 + 280);
      *(void *)(a3 + 248) = a3 + 280;
      unint64_t v27 = (char *)*((void *)v10 + 31);
      *(unsigned char *)(a3 + 240) = *((unsigned char *)v10 + 240);
      *(void *)(a3 + 264) = a3 + 280;
      double v28 = (char *)*((void *)v10 + 33);
      *(void *)(a3 + 272) = *((void *)v10 + 34);
      *(_DWORD *)(a3 + 236) = *((_DWORD *)v10 + 59);
      *(void *)(a3 + 256) = a3 + 280;
      if (v27 == v28)
      {
        *(void *)(a3 + 256) = &v26[*((void *)v10 + 32) - (void)v27];
        uint64_t v29 = (char *)*((void *)v10 + 32);
        if (v27 != v29)
        {
          unint64_t v30 = v29 - v27;
          if ((unint64_t)(v29 - v27) >= 8 && (unint64_t)(v13 + 288 * v12 - (void)v27) >= 0x20)
          {
            if (v30 < 0x20)
            {
              unint64_t v31 = 0;
              goto LABEL_28;
            }
            uint64_t v32 = 0;
            unint64_t v31 = v30 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v33 = *(_OWORD *)&v27[v32 + 16];
              *(_OWORD *)(a3 + v32 + 280) = *(_OWORD *)&v27[v32];
              *(_OWORD *)(a3 + v32 + 296) = v33;
              v32 += 32;
            }
            while (v31 != v32);
            if (v30 == v31) {
              goto LABEL_17;
            }
            if ((v30 & 0x18) != 0)
            {
LABEL_28:
              unint64_t v34 = v30 & 0xFFFFFFFFFFFFFFF8;
              v26 += v30 & 0xFFFFFFFFFFFFFFF8;
              do
              {
                *(void *)(a3 + v31 + 280) = *(void *)&v27[v31];
                v31 += 8;
              }
              while (v34 != v31);
              if (v30 == v34) {
                goto LABEL_17;
              }
              v27 += v34;
            }
            else
            {
              v27 += v31;
              v26 += v31;
            }
          }
          do
          {
            char v35 = *v27++;
            *v26++ = v35;
          }
          while (v27 != v29);
        }
      }
      else
      {
        uint64_t v14 = *((void *)v10 + 32);
        *(void *)(a3 + 248) = v27;
        *(void *)(a3 + 256) = v14;
        *(long long *)((char *)v10 + 248) = 0uLL;
        *(long long *)((char *)v10 + 264) = 0uLL;
      }
LABEL_17:
      a3 += 288;
      v10 += 18;
      ++v12;
      if (v10 == v11) {
        goto LABEL_12;
      }
    }
  }
}

void geo::small_vector_base<md::mun::PhotoInfo>::grow(void **a1, unint64_t a2)
{
  uint64_t v3 = (char *)*a1;
  long long v4 = (char *)a1[1];
  uint64_t v6 = (char *)a1[2];
  unint64_t v5 = (unint64_t)a1[3];
  unint64_t v7 = (1 << -(char)__clz(v5 + 1));
  if (v5 >= 0xFFFFFFFFFFFFFFFELL) {
    unint64_t v8 = 1;
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8 <= a2) {
    unint64_t v9 = a2;
  }
  else {
    unint64_t v9 = v8;
  }
  long long v10 = malloc_type_malloc(288 * v9, 0x1010040C6D9B592uLL);
  uint64_t v11 = v10;
  uint64_t v12 = (char *)*a1;
  uint64_t v13 = (char *)a1[1];
  if (*a1 == v13) {
    goto LABEL_33;
  }
  uint64_t v14 = 0;
  long long v15 = v10;
  do
  {
    long long v17 = *(_OWORD *)v12;
    *((void *)v15 + 2) = *((void *)v12 + 2);
    *(_OWORD *)long long v15 = v17;
    uint64_t v18 = *((void *)v12 + 3);
    *((_DWORD *)v15 + 8) = *((_DWORD *)v12 + 8);
    *((void *)v15 + 3) = v18;
    *(void *)(v15 + 36) = *(void *)(v12 + 36);
    long long v19 = *(_OWORD *)(v12 + 44);
    long long v20 = *(_OWORD *)(v12 + 60);
    long long v21 = *(_OWORD *)(v12 + 76);
    *(_OWORD *)(v15 + 92) = *(_OWORD *)(v12 + 92);
    *(_OWORD *)(v15 + 76) = v21;
    *(_OWORD *)(v15 + 60) = v20;
    *(_OWORD *)(v15 + 44) = v19;
    long long v22 = *(_OWORD *)(v12 + 108);
    long long v23 = *(_OWORD *)(v12 + 124);
    long long v24 = *(_OWORD *)(v12 + 140);
    *(_OWORD *)(v15 + 156) = *(_OWORD *)(v12 + 156);
    *(_OWORD *)(v15 + 140) = v24;
    *(_OWORD *)(v15 + 124) = v23;
    *(_OWORD *)(v15 + 108) = v22;
    long long v25 = *(_OWORD *)(v12 + 172);
    long long v26 = *(_OWORD *)(v12 + 188);
    long long v27 = *(_OWORD *)(v12 + 204);
    *(_OWORD *)(v15 + 220) = *(_OWORD *)(v12 + 220);
    *(_OWORD *)(v15 + 204) = v27;
    *(_OWORD *)(v15 + 188) = v26;
    *(_OWORD *)(v15 + 172) = v25;
    double v28 = v15 + 280;
    *((void *)v15 + 31) = v15 + 280;
    uint64_t v29 = (char *)*((void *)v12 + 31);
    v15[240] = v12[240];
    *((void *)v15 + 33) = v15 + 280;
    unint64_t v30 = (char *)*((void *)v12 + 33);
    *((void *)v15 + 34) = *((void *)v12 + 34);
    *((_DWORD *)v15 + 59) = *((_DWORD *)v12 + 59);
    *((void *)v15 + 32) = v15 + 280;
    if (v29 != v30)
    {
      uint64_t v16 = *((void *)v12 + 32);
      *((void *)v15 + 31) = v29;
      *((void *)v15 + 32) = v16;
      *(_OWORD *)(v12 + 248) = 0uLL;
      *(_OWORD *)(v12 + 264) = 0uLL;
      goto LABEL_10;
    }
    *((void *)v15 + 32) = &v28[*((void *)v12 + 32) - (void)v29];
    unint64_t v31 = (char *)*((void *)v12 + 32);
    if (v29 != v31)
    {
      unint64_t v32 = v31 - v29;
      if ((unint64_t)(v31 - v29) < 8 || (unint64_t)(&v11[288 * v14 + 280] - v29) < 0x20) {
        goto LABEL_26;
      }
      if (v32 >= 0x20)
      {
        uint64_t v34 = 0;
        unint64_t v33 = v32 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v35 = *(_OWORD *)&v29[v34 + 16];
          *(_OWORD *)&v15[v34 + 280] = *(_OWORD *)&v29[v34];
          *(_OWORD *)&v15[v34 + 296] = v35;
          v34 += 32;
        }
        while (v33 != v34);
        if (v32 == v33) {
          goto LABEL_10;
        }
        if ((v32 & 0x18) == 0)
        {
          v29 += v33;
          v28 += v33;
          do
          {
LABEL_26:
            char v37 = *v29++;
            *v28++ = v37;
          }
          while (v29 != v31);
          goto LABEL_10;
        }
      }
      else
      {
        unint64_t v33 = 0;
      }
      unint64_t v36 = v32 & 0xFFFFFFFFFFFFFFF8;
      v28 += v32 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        *(void *)&v15[v33 + 280] = *(void *)&v29[v33];
        v33 += 8;
      }
      while (v36 != v33);
      if (v32 != v36)
      {
        v29 += v36;
        goto LABEL_26;
      }
    }
LABEL_10:
    v15 += 288;
    v12 += 288;
    ++v14;
  }
  while (v12 != v13);
  uint64_t v38 = (char *)*a1;
  char v39 = (char *)a1[1];
  while (v38 != v39)
  {
    uint64_t v40 = (void *)*((void *)v38 + 31);
    if (v40 != *((void **)v38 + 33)) {
      free(v40);
    }
    v38 += 288;
  }
LABEL_33:
  if (v3 != v6) {
    free(*a1);
  }
  *a1 = v11;
  a1[1] = &v11[v4 - v3];
  a1[3] = (void *)v9;
}

void geo::small_vector_base<md::mun::OrientedPlane>::append<md::mun::OrientedPlane const*>(uint64_t a1, long long *a2, long long *a3)
{
  long long v4 = a2;
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * (a3 - a2);
  unint64_t v7 = *(void *)(a1 + 24);
  unint64_t v9 = *(void **)a1;
  unint64_t v8 = *(char **)(a1 + 8);
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v8[-*(void *)a1] >> 4);
  if (v6 > v7 - v10)
  {
    uint64_t v11 = *(void **)(a1 + 16);
    unint64_t v12 = (1 << -(char)__clz(v7 + 1));
    if (v7 >= 0xFFFFFFFFFFFFFFFELL) {
      unint64_t v13 = 1;
    }
    else {
      unint64_t v13 = v12;
    }
    if (v13 <= v10 - 0x5555555555555555 * (a3 - a2)) {
      unint64_t v14 = v10 - 0x5555555555555555 * (a3 - a2);
    }
    else {
      unint64_t v14 = v13;
    }
    long long v15 = (char *)malloc_type_malloc(48 * v14, 0x1000040EED21634uLL);
    uint64_t v16 = v15;
    long long v17 = *(void **)a1;
    uint64_t v18 = *(void **)(a1 + 8);
    if (*(void **)a1 != v18)
    {
      long long v19 = v15;
      do
      {
        long long v20 = *(_OWORD *)v17;
        *((void *)v19 + 2) = v17[2];
        *(_OWORD *)long long v19 = v20;
        uint64_t v21 = v17[3];
        *((_DWORD *)v19 + 8) = *((_DWORD *)v17 + 8);
        *((void *)v19 + 3) = v21;
        *((_DWORD *)v19 + 9) = *((_DWORD *)v17 + 9);
        *((void *)v19 + 5) = v17[5];
        v17 += 6;
        v19 += 48;
      }
      while (v17 != v18);
    }
    if (v9 != v11) {
      free(*(void **)a1);
    }
    unint64_t v8 = &v16[48 * v10];
    *(void *)a1 = v16;
    *(void *)(a1 + 8) = v8;
    *(void *)(a1 + 24) = v14;
  }
  if (v4 != a3)
  {
    do
    {
      long long v22 = *v4;
      *((void *)v8 + 2) = *((void *)v4 + 2);
      *(_OWORD *)unint64_t v8 = v22;
      uint64_t v23 = *((void *)v4 + 3);
      *((_DWORD *)v8 + 8) = *((_DWORD *)v4 + 8);
      *((void *)v8 + 3) = v23;
      *((_DWORD *)v8 + 9) = *((_DWORD *)v4 + 9);
      *((void *)v8 + 5) = *((void *)v4 + 5);
      v4 += 3;
      v8 += 48;
    }
    while (v4 != a3);
    unint64_t v8 = *(char **)(a1 + 8);
  }
  *(void *)(a1 + 8) = &v8[48 * v6];
}

uint64_t std::__split_buffer<md::mun::StorefrontBundle>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 168;
    long long v4 = *(void **)(i - 80);
    if (v4 != *(void **)(i - 64)) {
      free(v4);
    }
    if (*(unsigned char *)(i - 120)) {
      *(unsigned char *)(i - 120) = 0;
    }
    if (*(unsigned char *)(i - 160)) {
      *(unsigned char *)(i - 160) = 0;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void md::mun::MuninLabelLayerDataSource::constructRequests(uint64_t a1, char **a2, char **a3)
{
  if (a2 != a3)
  {
    uint64_t v3 = a2;
    do
    {
      long long v4 = *v3;
      char v97 = **v3;
      gdc::LayerDataKey::LayerDataKey((uint64_t)&v98, (uint64_t)(v4 + 8));
      char v101 = 0;
      if (v4[96])
      {
        int v102 = *((_DWORD *)v4 + 25);
        char v101 = 1;
      }
      uint64_t v103 = *((void *)v4 + 13);
      uint64_t v5 = *((void *)*v3 + 2);
      unsigned int v6 = *(unsigned __int8 *)(v5 + 8);
      int v8 = *(_DWORD *)v5;
      int v7 = *(_DWORD *)(v5 + 4);
      int v9 = *v99;
      int v10 = v99[1];
      int v12 = v99[2];
      int v11 = v99[3];
      uint64_t v73 = *((void *)*v3 + 14);
      v87[0] = 0;
      __int16 v88 = 24;
      int v89 = 2147483646;
      long long v90 = v94;
      long long v91 = v94;
      uint64_t v92 = v94;
      uint64_t v93 = 32;
      unint64_t v95 = 0;
      int v78 = v9;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v90, v94, (char *)&v78, (char *)&v79);
      int v78 = v10;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v90, v91, (char *)&v78, (char *)&v79);
      int v78 = v12;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v90, v91, (char *)&v78, (char *)&v79);
      int v78 = v11;
      geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v90, v91, (char *)&v78, (char *)&v79);
      unint64_t v13 = (unsigned __int8 *)v90;
      unint64_t v14 = v91 - (unsigned char *)v90;
      if (v91 == v90)
      {
        unint64_t v15 = 0;
      }
      else
      {
        unint64_t v15 = 0;
        if (v14 <= 1) {
          unint64_t v14 = 1;
        }
        do
        {
          unsigned int v16 = *v13++;
          v15 ^= (v15 << 6) - 0x61C8864680B583EBLL + (v15 >> 2) + v16;
          --v14;
        }
        while (v14);
      }
      unint64_t v95 = v15;
      uint64_t v96 = v73;
      long long v74 = v3;
      gdc::LayerDataRequest::request(*v3, (uint64_t)v87, 0);
      int v17 = -1;
      int v72 = v7;
      do
      {
        int v18 = *v99;
        int v19 = v99[1];
        int v20 = v99[2];
        int v21 = v99[3];
        uint64_t v22 = *((void *)*v3 + 14);
        LOBYTE(v78) = 0;
        HIWORD(v78) = 22;
        int v79 = 2147483646;
        long long v80 = v84;
        uint64_t v81 = v84;
        long double v82 = v84;
        uint64_t v83 = 32;
        unint64_t v85 = 0;
        int v23 = v19 + v17;
        LODWORD(v75) = v18 - 1;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v80, v84, (char *)&v75, (char *)&v75 + 4);
        LODWORD(v75) = v23;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v80, v81, (char *)&v75, (char *)&v75 + 4);
        LODWORD(v75) = v20;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v80, v81, (char *)&v75, (char *)&v75 + 4);
        LODWORD(v75) = v21;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v80, v81, (char *)&v75, (char *)&v75 + 4);
        long long v24 = (unsigned __int8 *)v80;
        unint64_t v25 = v81 - (unsigned char *)v80;
        if (v81 == v80)
        {
          unint64_t v26 = 0;
        }
        else
        {
          unint64_t v26 = 0;
          if (v25 <= 1) {
            unint64_t v25 = 1;
          }
          do
          {
            unsigned int v27 = *v24++;
            v26 ^= (v26 << 6) - 0x61C8864680B583EBLL + (v26 >> 2) + v27;
            --v25;
          }
          while (v25);
        }
        unint64_t v85 = v26;
        uint64_t v86 = v22;
        gdc::LayerDataRequest::request(*v3, (uint64_t)&v78, 0);
        if (v80 != v82) {
          free(v80);
        }
        int v28 = *v99;
        int v29 = v99[1];
        int v30 = v99[2];
        int v31 = v99[3];
        uint64_t v32 = *((void *)*v3 + 14);
        LOBYTE(v78) = 0;
        HIWORD(v78) = 22;
        int v79 = 2147483646;
        long long v80 = v84;
        uint64_t v81 = v84;
        long double v82 = v84;
        uint64_t v83 = 32;
        unint64_t v85 = 0;
        int v33 = v29 + v17;
        LODWORD(v75) = v28;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v80, v84, (char *)&v75, (char *)&v75 + 4);
        LODWORD(v75) = v33;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v80, v81, (char *)&v75, (char *)&v75 + 4);
        LODWORD(v75) = v30;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v80, v81, (char *)&v75, (char *)&v75 + 4);
        LODWORD(v75) = v31;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v80, v81, (char *)&v75, (char *)&v75 + 4);
        uint64_t v34 = (unsigned __int8 *)v80;
        unint64_t v35 = v81 - (unsigned char *)v80;
        if (v81 == v80)
        {
          unint64_t v36 = 0;
        }
        else
        {
          unint64_t v36 = 0;
          if (v35 <= 1) {
            unint64_t v35 = 1;
          }
          do
          {
            unsigned int v37 = *v34++;
            v36 ^= (v36 << 6) - 0x61C8864680B583EBLL + (v36 >> 2) + v37;
            --v35;
          }
          while (v35);
        }
        unint64_t v85 = v36;
        uint64_t v86 = v32;
        gdc::LayerDataRequest::request(*v3, (uint64_t)&v78, 0);
        if (v80 != v82) {
          free(v80);
        }
        int v38 = *v99;
        int v39 = v99[1];
        int v40 = v99[2];
        int v41 = v99[3];
        uint64_t v42 = *((void *)*v3 + 14);
        LOBYTE(v78) = 0;
        HIWORD(v78) = 22;
        int v79 = 2147483646;
        long long v80 = v84;
        uint64_t v81 = v84;
        long double v82 = v84;
        uint64_t v83 = 32;
        unint64_t v85 = 0;
        int v43 = v39 + v17;
        LODWORD(v75) = v38 + 1;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v80, v84, (char *)&v75, (char *)&v75 + 4);
        LODWORD(v75) = v43;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v80, v81, (char *)&v75, (char *)&v75 + 4);
        LODWORD(v75) = v40;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v80, v81, (char *)&v75, (char *)&v75 + 4);
        LODWORD(v75) = v41;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v80, v81, (char *)&v75, (char *)&v75 + 4);
        unint64_t v44 = (unsigned __int8 *)v80;
        unint64_t v45 = v81 - (unsigned char *)v80;
        if (v81 == v80)
        {
          unint64_t v46 = 0;
          int v47 = v72;
        }
        else
        {
          unint64_t v46 = 0;
          if (v45 <= 1) {
            unint64_t v45 = 1;
          }
          int v47 = v72;
          do
          {
            unsigned int v48 = *v44++;
            v46 ^= (v46 << 6) - 0x61C8864680B583EBLL + (v46 >> 2) + v48;
            --v45;
          }
          while (v45);
        }
        unint64_t v85 = v46;
        uint64_t v86 = v42;
        gdc::LayerDataRequest::request(*v3, (uint64_t)&v78, 0);
        if (v80 != v82) {
          free(v80);
        }
        ++v17;
      }
      while (v17 != 2);
      double v49 = [MEMORY[0x1E4F64918] modernManager];
      uint64_t v50 = [v49 activeTileGroup];

      unint64_t v51 = 0;
      int v52 = v47 >> v6;
      int v53 = v8 >> v6;
      if (!v6)
      {
        int v52 = v47;
        int v53 = v8;
      }
      BOOL v54 = (v53 | v52) == 0;
      uint64_t v71 = v50;
      BOOL v70 = v54;
      while (v51 < [v50 regionalResourcesCount])
      {
        uint64_t v55 = [v50 regionalResourceAtIndex:v51];
        if (v55)
        {
          for (unint64_t i = 0; i < [v55 regionsCount]; ++i)
          {
            uint64_t v75 = 0;
            uint64_t v76 = 0;
            uint64_t v77 = 0;
            [v55 regionAtIndex:i];
            if (HIDWORD(v77) <= v6 && v76 >= v6)
            {
              unsigned int v58 = v47;
              unsigned int v59 = v8;
              if (v6)
              {
                if (v6 >= (v6 - BYTE4(v77))) {
                  char v60 = v6 - BYTE4(v77);
                }
                else {
                  char v60 = v6;
                }
                unsigned int v58 = v47 >> v60;
                unsigned int v59 = v8 >> v60;
              }
              if (v59 >= HIDWORD(v76) && v59 <= v75 && v58 >= v77 && v58 <= HIDWORD(v75)) {
                goto LABEL_72;
              }
            }
          }
        }
        else if ([0 regionsCount])
        {
          uint64_t v75 = 0;
          uint64_t v76 = 0;
          uint64_t v77 = 0;
          if (v6 || !v54)
          {
            for (unint64_t j = 1; j < [0 regionsCount]; ++j)
            {
              uint64_t v75 = 0;
              uint64_t v76 = 0;
              uint64_t v77 = 0;
              if (!v6 && v54) {
                goto LABEL_72;
              }
            }
          }
          else
          {
LABEL_72:
            uint64_t v62 = *(void *)(a1 + 584);
            uint64_t v63 = *((void *)*v3 + 14);
            LOBYTE(v78) = 0;
            HIWORD(v78) = 18;
            int v79 = -1073741827;
            long long v80 = v84;
            uint64_t v81 = v84;
            long double v82 = v84;
            uint64_t v83 = 32;
            unint64_t v85 = 0;
            int v104 = v51;
            geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v80, v84, (char *)&v104, v105);
            int v104 = v62;
            geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v80, v81, (char *)&v104, v105);
            long long v64 = (unsigned __int8 *)v80;
            unint64_t v65 = v81 - (unsigned char *)v80;
            if (v81 == v80)
            {
              unint64_t v66 = 0;
            }
            else
            {
              unint64_t v66 = 0;
              if (v65 <= 1) {
                unint64_t v65 = 1;
              }
              do
              {
                unsigned int v67 = *v64++;
                v66 ^= (v66 << 6) - 0x61C8864680B583EBLL + (v66 >> 2) + v67;
                --v65;
              }
              while (v65);
            }
            unint64_t v85 = v66;
            uint64_t v86 = v63;
            gdc::LayerDataRequest::request(*v3, (uint64_t)&v78, 0);
            int v47 = v72;
            uint64_t v50 = v71;
            if (v80 != v82) {
              free(v80);
            }
            BOOL v54 = v70;
          }
        }

        ++v51;
      }

      if (v90 != v92) {
        free(v90);
      }
      if (v101) {
        char v101 = 0;
      }
      if (v99 != v100) {
        free(v99);
      }
      v3 += 2;
    }
    while (v74 + 2 != a3);
  }
}

void sub_1A2064D78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,void *a42)
{
  if (a40 != a42) {
    free(a40);
  }
  if (*(unsigned char *)(v43 - 112)) {
    *(unsigned char *)(v43 - 112) = 0;
  }
  unint64_t v45 = *(void **)(v43 - 192);
  if (v45 != *(void **)(v43 - 176)) {
    free(v45);
  }
  _Unwind_Resume(a1);
}

void md::mun::MuninLabelLayerDataSource::didDeactivate(md::mun::MuninLabelLayerDataSource *this)
{
  id v1 = (_OWORD *)((char *)this + 648);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 82);
  _OWORD *v1 = 0u;
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void md::mun::MuninLabelLayerDataSource::didActivate(md::mun::MuninLabelLayerDataSource *this)
{
  uint64_t v2 = *((void *)this + 80);
  if (v2)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v2 + 48))(&v7);
    uint64_t v3 = v7;
    long long v4 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    *((void *)this + 81) = v3;
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 82);
    *((void *)this + 82) = v4;
    if (v5)
    {
      std::__shared_weak_count::__release_weak(v5);
      long long v4 = v8;
    }
    if (v4)
    {
      if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    md::mun::MuninLabelLayerDataSource::~MuninLabelLayerDataSource(v6);
  }
}

void md::mun::MuninLabelLayerDataSource::~MuninLabelLayerDataSource(md::mun::MuninLabelLayerDataSource *this)
{
  *(void *)this = &unk_1EF550720;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 82);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (md::mun::MuninLabelLayerDataSource *)*((void *)this + 80);
  if (v3 == (md::mun::MuninLabelLayerDataSource *)((char *)this + 616))
  {
    (*(void (**)(char *))(*((void *)this + 77) + 32))((char *)this + 616);
  }
  else if (v3)
  {
    (*(void (**)(md::mun::MuninLabelLayerDataSource *))(*(void *)v3 + 40))(v3);
  }
  *((void *)this + 74) = &unk_1EF559798;

  gdc::LayerDataSource::~LayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  md::mun::MuninLabelLayerDataSource *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF550720;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 82);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (md::mun::MuninLabelLayerDataSource *)*((void *)this + 80);
  if (v3 == (md::mun::MuninLabelLayerDataSource *)((char *)this + 616))
  {
    (*(void (**)(char *))(*((void *)this + 77) + 32))((char *)this + 616);
  }
  else if (v3)
  {
    (*(void (**)(md::mun::MuninLabelLayerDataSource *))(*(void *)v3 + 40))(v3);
  }
  *((void *)this + 74) = &unk_1EF559798;

  gdc::LayerDataSource::~LayerDataSource(this);
}

double altitude::GlobeView::getNearFar(altitude::GlobeView *this, double *a2, double *a3)
{
  uint64_t v5 = (*(uint64_t (**)(void, void, uint64_t))(**((void **)this + 96) + 24))(*((void *)this + 96), 0, 0xFFFFFFFFLL);
  *a3 = *(double *)(v5 + 944);
  double result = *(double *)(v5 + 952);
  *a2 = result;
  return result;
}

uint64_t altitude::GlobeView::setDefaultFovY(uint64_t result, void *a2)
{
  *(void *)(result + 296) = *a2;
  return result;
}

double altitude::GlobeView::getDefaultFovY@<D0>(altitude::GlobeView *this@<X0>, double *a2@<X8>)
{
  double result = *((double *)this + 37);
  *a2 = result;
  return result;
}

double altitude::GlobeView::getTanHalfFovY(altitude::GlobeView *this)
{
  return *((double *)this + 36);
}

double altitude::GlobeView::getOriginalFovY@<D0>(altitude::GlobeView *this@<X0>, double *a2@<X8>)
{
  double result = *((double *)this + 35);
  *a2 = result;
  return result;
}

void *altitude::GlobeView::setLoadingPaused(altitude::GlobeView *this, int a2)
{
  uint64_t v4 = *((void *)this + 86);
  *(unsigned char *)(v4 + 204) = a2;
  uint64_t v5 = *(void *)(v4 + 120);
  uint64_t v6 = *(void *)(v4 + 128);
  char v7 = a2 ^ 1;
  uint64_t v8 = v6 - v5;
  if (v8)
  {
    unint64_t v9 = v8 >> 3;
    if (v9 <= 1) {
      unint64_t v10 = 1;
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10 < 2 || (v10 ? (BOOL v11 = (v10 - 1) >> 32 == 0) : (BOOL v11 = 0), !v11))
    {
      unint64_t v12 = 0;
      int v13 = 0;
LABEL_11:
      unsigned int v14 = v13 + 1;
      do
      {
        *(unsigned char *)(*(void *)(v5 + 8 * v12) + 80) = v7;
        unint64_t v12 = v14++;
      }
      while (v9 > v12);
      goto LABEL_13;
    }
    unint64_t v12 = v10 & 0xFFFFFFFFFFFFFFFELL;
    int v31 = (uint64_t *)(v5 + 8);
    unint64_t v32 = v10 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      uint64_t v33 = *v31;
      *(unsigned char *)(*(v31 - 1) + 80) = v7;
      *(unsigned char *)(v33 + 80) = v7;
      v31 += 2;
      v32 -= 2;
    }
    while (v32);
    int v13 = v10 & 0xFFFFFFFE;
    if (v10 != v12) {
      goto LABEL_11;
    }
  }
LABEL_13:
  *(unsigned char *)(*((void *)this + 60) + 520) = v7;
  double result = (void *)*((void *)this + 46);
  if (result)
  {
    unsigned int v16 = (void *)result[6];
    int v17 = (void *)result[7];
    if (v16 != v17)
    {
      uint64_t v18 = *(void *)(*((void *)this + 107) + 40);
      do
      {
        uint64_t v22 = *(void *)(v18 + 8);
        uint64_t v23 = *(void *)(v22 + 224);
        uint64_t v24 = *(void *)(v22 + 232);
        uint64_t v25 = v24 - v23;
        if (v24 != v23)
        {
          uint64_t v26 = 0;
          unint64_t v27 = v25 >> 4;
          if (v27 <= 1) {
            uint64_t v28 = 1;
          }
          else {
            uint64_t v28 = v27;
          }
          int v29 = *(void **)(v22 + 224);
          while (*v29 != *v16)
          {
            ++v26;
            v29 += 2;
            if (v28 == v26) {
              goto LABEL_17;
            }
          }
          uint64_t v19 = v23 + 16 * v26;
          uint64_t v20 = v23 + 16 * v27;
          uint64_t v21 = *(void *)(v20 - 16);
          v20 -= 16;
          *(void *)uint64_t v19 = v21;
          *(unsigned char *)(v19 + 8) = *(unsigned char *)(v20 + 8);
          *(void *)(v22 + 232) = v20;
        }
LABEL_17:
        ++v16;
      }
      while (v16 != v17);
    }
    double result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
  }
  *((void *)this + 46) = 0;
  if (a2)
  {
    uint64_t v30 = (*(uint64_t (**)(void, void, uint64_t))(**((void **)this + 8) + 24))(*((void *)this + 8), 0, 0xFFFFFFFFLL);
    altitude::createDebugFrustumElement(*(void *)(*((void *)this + 107) + 136), v30);
  }
  return result;
}

void altitude::createDebugFrustumElement(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2 + 40;
  (*(void (**)(uint64_t))(*(void *)(a2 + 40) + 24))(a2 + 40);
  long double v3 = *(double *)(v2 + 944);
  long double v4 = *(double *)(v2 + 928);
  long double v5 = *(double *)(v2 + 920);
  double v6 = *(double *)(v2 + 912);
  double v7 = *(double *)(v2 + 904);
  float v8 = tan(*(long double *)(v2 + 936));
  *(float *)&long double v3 = tan(v3);
  *(float *)&long double v4 = tan(v4);
  *(float *)&long double v5 = tan(v5);
  unint64_t v9 = (float *)operator new(0x60uLL);
  float v10 = v6;
  float v11 = v10 * v8;
  *unint64_t v9 = v10 * v8;
  v9[1] = v10 * *(float *)&v4;
  float v12 = -v10;
  float v13 = v10 * *(float *)&v3;
  v9[2] = -v10;
  v9[3] = v10 * *(float *)&v3;
  v9[4] = v10 * *(float *)&v4;
  void v9[5] = -v10;
  float v14 = v10 * *(float *)&v5;
  v9[6] = v13;
  uint64_t v9[7] = v14;
  v9[8] = v12;
  v9[9] = v11;
  v9[10] = v14;
  v9[11] = v12;
  float v15 = v7;
  float v16 = v15 * v8;
  float v17 = -v15;
  v9[12] = v15 * v8;
  v9[13] = v15 * *(float *)&v4;
  float v18 = v15 * *(float *)&v3;
  v9[14] = -v15;
  v9[15] = v15 * *(float *)&v3;
  v9[16] = v15 * *(float *)&v4;
  v9[17] = -v15;
  float v19 = v15 * *(float *)&v5;
  v9[18] = v18;
  v9[19] = v19;
  v9[20] = v17;
  v9[21] = v16;
  v9[22] = v19;
  v9[23] = v17;
  uint64_t v20 = operator new(2uLL);
  *uint64_t v20 = 0;
  uint64_t v21 = operator new(4uLL);
  _DWORD *v21 = 0x10000;
  operator delete(v20);
  uint64_t v22 = operator new(8uLL);
  v22[2] = 1;
  *(_DWORD *)uint64_t v22 = *v21;
  operator delete(v21);
  v22[3] = 2;
  uint64_t v23 = (char *)operator new(0x10uLL);
  *((_WORD *)v23 + 4) = 2;
  *(void *)uint64_t v23 = *(void *)v22;
  operator delete(v22);
  *(_DWORD *)(v23 + 10) = 196611;
  *((_WORD *)v23 + 7) = 0;
  uint64_t v24 = (char *)operator new(0x20uLL);
  *(void *)(v24 + 10) = 0x4000000030003;
  *((_WORD *)v24 + 4) = *((_WORD *)v23 + 4);
  *(void *)uint64_t v24 = *(void *)v23;
  operator delete(v23);
  *(void *)(v24 + 18) = 0x6000600050005;
  *(_DWORD *)(v24 + 26) = 458759;
  *((_WORD *)v24 + 15) = 4;
  if (__OFADD__(32, 3)) {
    abort();
  }
  uint64_t v25 = v24 + 32;
  uint64_t v26 = (char *)operator new(0x40uLL);
  unint64_t v27 = v26 + 32;
  unint64_t v28 = (unint64_t)(v26 + 64);
  *((_WORD *)v26 + 16) = 0;
  int v29 = v26 + 34;
  if (v24 + 32 != v24)
  {
    if ((unint64_t)(v24 - v26) < 0x20)
    {
      do
      {
        __int16 v33 = *((_WORD *)v25 - 1);
        v25 -= 2;
        *((_WORD *)v27 - 1) = v33;
        v27 -= 2;
      }
      while (v25 != v24);
    }
    else
    {
      for (uint64_t i = 0; i != -32; i -= 32)
      {
        long long v31 = *(_OWORD *)&v24[i + 16];
        unint64_t v32 = &v26[i + 16];
        *((_OWORD *)v32 - 1) = *(_OWORD *)&v24[i];
        *(_OWORD *)unint64_t v32 = v31;
      }
      unint64_t v27 = v26;
    }
  }
  operator delete(v24);
  if ((unint64_t)v29 >= v28)
  {
    uint64_t v36 = v29 - v27;
    if (v29 - v27 <= -3) {
      abort();
    }
    uint64_t v37 = v36 >> 1;
    if (v28 - (unint64_t)v27 <= (v36 >> 1) + 1) {
      uint64_t v38 = v37 + 1;
    }
    else {
      uint64_t v38 = v28 - (void)v27;
    }
    if (v28 - (unint64_t)v27 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v39 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v39 = v38;
    }
    if (v39)
    {
      if (v39 < 0) {
        goto LABEL_184;
      }
      int v40 = operator new(2 * v39);
    }
    else
    {
      int v40 = 0;
    }
    uint64_t v34 = &v40[2 * v37];
    unint64_t v28 = (unint64_t)&v40[2 * v39];
    *(_WORD *)uint64_t v34 = 4;
    unint64_t v35 = v34 + 2;
    if (v29 == v27) {
      goto LABEL_29;
    }
    unint64_t v41 = v29 - v27 - 2;
    if (v41 < 0x1E) {
      goto LABEL_197;
    }
    if (v29 - v40 - (v36 & 0xFFFFFFFFFFFFFFFELL) < 0x20) {
      goto LABEL_197;
    }
    uint64_t v42 = (v41 >> 1) + 1;
    v29 -= 2 * (v42 & 0xFFFFFFFFFFFFFFF0);
    uint64_t v43 = (long long *)(v26 + 18);
    unint64_t v44 = &v40[2 * v37 - 16];
    unint64_t v45 = v42 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      long long v46 = *v43;
      *(v44 - 1) = *(v43 - 1);
      *unint64_t v44 = v46;
      v43 -= 2;
      v44 -= 2;
      v45 -= 16;
    }
    while (v45);
    v34 -= 2 * (v42 & 0xFFFFFFFFFFFFFFF0);
    if (v42 != (v42 & 0xFFFFFFFFFFFFFFF0))
    {
LABEL_197:
      do
      {
        __int16 v47 = *((_WORD *)v29 - 1);
        v29 -= 2;
        *((_WORD *)v34 - 1) = v47;
        v34 -= 2;
      }
      while (v29 != v27);
    }
    if (v27) {
LABEL_29:
    }
      operator delete(v27);
  }
  else
  {
    *(_WORD *)int v29 = 4;
    uint64_t v34 = v27;
    unint64_t v35 = v26 + 36;
  }
  if ((unint64_t)v35 < v28)
  {
    *(_WORD *)unint64_t v35 = 1;
    unsigned int v48 = v35 + 2;
    if ((unint64_t)(v35 + 2) < v28) {
      goto LABEL_32;
    }
    goto LABEL_60;
  }
  uint64_t v53 = v35 - v34;
  if (v35 - v34 <= -3) {
    abort();
  }
  uint64_t v54 = v53 >> 1;
  if (v28 - (unint64_t)v34 <= (v53 >> 1) + 1) {
    uint64_t v55 = v54 + 1;
  }
  else {
    uint64_t v55 = v28 - (void)v34;
  }
  if (v28 - (unint64_t)v34 >= 0x7FFFFFFFFFFFFFFELL) {
    uint64_t v56 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v56 = v55;
  }
  if (v56)
  {
    if (v56 < 0) {
      goto LABEL_184;
    }
    double v57 = operator new(2 * v56);
  }
  else
  {
    double v57 = 0;
  }
  unsigned int v58 = &v57[2 * v54];
  unint64_t v28 = (unint64_t)&v57[2 * v56];
  *(_WORD *)unsigned int v58 = 1;
  unsigned int v48 = v58 + 2;
  if (v35 == v34)
  {
LABEL_58:
    operator delete(v34);
LABEL_59:
    uint64_t v34 = v58;
    if ((unint64_t)v48 < v28)
    {
LABEL_32:
      *(_WORD *)unsigned int v48 = 5;
      double v49 = v48 + 2;
      if ((unint64_t)(v48 + 2) < v28) {
        goto LABEL_33;
      }
      goto LABEL_83;
    }
LABEL_60:
    uint64_t v67 = v48 - v34;
    if (v48 - v34 <= -3) {
      abort();
    }
    uint64_t v68 = v67 >> 1;
    if (v28 - (unint64_t)v34 <= (v67 >> 1) + 1) {
      uint64_t v69 = v68 + 1;
    }
    else {
      uint64_t v69 = v28 - (void)v34;
    }
    if (v28 - (unint64_t)v34 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v70 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v70 = v69;
    }
    if (v70)
    {
      if (v70 < 0) {
        goto LABEL_184;
      }
      uint64_t v71 = operator new(2 * v70);
    }
    else
    {
      uint64_t v71 = 0;
    }
    int v72 = &v71[2 * v68];
    unint64_t v28 = (unint64_t)&v71[2 * v70];
    *(_WORD *)int v72 = 5;
    double v49 = v72 + 2;
    if (v48 == v34)
    {
LABEL_81:
      operator delete(v34);
LABEL_82:
      uint64_t v34 = v72;
      if ((unint64_t)v49 < v28)
      {
LABEL_33:
        *(_WORD *)double v49 = 2;
        uint64_t v50 = v49 + 2;
        if ((unint64_t)(v49 + 2) < v28) {
          goto LABEL_34;
        }
        goto LABEL_106;
      }
LABEL_83:
      uint64_t v81 = v49 - v34;
      if (v49 - v34 <= -3) {
        abort();
      }
      uint64_t v82 = v81 >> 1;
      if (v28 - (unint64_t)v34 <= (v81 >> 1) + 1) {
        uint64_t v83 = v82 + 1;
      }
      else {
        uint64_t v83 = v28 - (void)v34;
      }
      if (v28 - (unint64_t)v34 >= 0x7FFFFFFFFFFFFFFELL) {
        uint64_t v84 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v84 = v83;
      }
      if (v84)
      {
        if (v84 < 0) {
          goto LABEL_184;
        }
        unint64_t v85 = operator new(2 * v84);
      }
      else
      {
        unint64_t v85 = 0;
      }
      uint64_t v86 = &v85[2 * v82];
      unint64_t v28 = (unint64_t)&v85[2 * v84];
      *(_WORD *)uint64_t v86 = 2;
      uint64_t v50 = v86 + 2;
      if (v49 == v34)
      {
LABEL_104:
        operator delete(v34);
LABEL_105:
        uint64_t v34 = v86;
        if ((unint64_t)v50 < v28)
        {
LABEL_34:
          *(_WORD *)uint64_t v50 = 6;
          unint64_t v51 = v50 + 2;
          if ((unint64_t)(v50 + 2) < v28) {
            goto LABEL_35;
          }
          goto LABEL_129;
        }
LABEL_106:
        uint64_t v95 = v50 - v34;
        if (v50 - v34 <= -3) {
          abort();
        }
        uint64_t v96 = v95 >> 1;
        if (v28 - (unint64_t)v34 <= (v95 >> 1) + 1) {
          uint64_t v97 = v96 + 1;
        }
        else {
          uint64_t v97 = v28 - (void)v34;
        }
        if (v28 - (unint64_t)v34 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v98 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v98 = v97;
        }
        if (v98)
        {
          if (v98 < 0) {
            goto LABEL_184;
          }
          int8x16_t v99 = operator new(2 * v98);
        }
        else
        {
          int8x16_t v99 = 0;
        }
        uint64_t v100 = &v99[2 * v96];
        unint64_t v28 = (unint64_t)&v99[2 * v98];
        *(_WORD *)uint64_t v100 = 6;
        unint64_t v51 = v100 + 2;
        if (v50 == v34)
        {
LABEL_127:
          operator delete(v34);
LABEL_128:
          uint64_t v34 = v100;
          if ((unint64_t)v51 < v28)
          {
LABEL_35:
            *(_WORD *)unint64_t v51 = 3;
            int v52 = v51 + 2;
            if ((unint64_t)(v51 + 2) < v28)
            {
LABEL_36:
              *(_WORD *)int v52 = 7;
LABEL_173:
              double v136 = (char *)operator new(0xF8uLL);
              *((void *)v136 + 1) = 0;
              *((void *)v136 + 2) = 0;
              *(void *)double v136 = &unk_1EF5843F0;
              long long v137 = v136 + 24;
              *((void *)v136 + 3) = &unk_1EF55A1F0;
              *((void *)v136 + 4) = 16;
              *((_DWORD *)v136 + 10) = 6;
              long long v138 = 0uLL;
              *((_OWORD *)v136 + 3) = 0u;
              *((_OWORD *)v136 + 4) = 0u;
              *((_OWORD *)v136 + 5) = 0u;
              *((_OWORD *)v136 + 6) = 0u;
              *((void *)v136 + 14) = 0;
              {
                long long v138 = 0uLL;
                if (v152) {
                  operator new();
                }
              }
              *((void *)v136 + 15) = ggl::Allocator::instance(void)::alloc;
              *((void *)v136 + 16) = 0;
              *((_OWORD *)v136 + 11) = v138;
              *((_OWORD *)v136 + 12) = v138;
              *((void *)v136 + 26) = 0;
              *((void *)v136 + 27) = -1;
              *((_OWORD *)v136 + 9) = xmmword_1A28FCCA0;
              *((_OWORD *)v136 + 10) = v138;
              *((_DWORD *)v136 + 34) = 0;
              *((void *)v136 + 29) = "/DebugFrustumElement/VertexData";
              *((void *)v136 + 30) = &ggl::CommonMesh::bufferPos4Reflection;
              *((void *)v136 + 3) = &unk_1EF55BFC8;
              *((void *)v136 + 28) = &unk_1EF55BFE8;
              unint64_t v139 = 8 * *((void *)v136 + 4);
              uint64_t v140 = *((void *)v136 + 12);
              unint64_t v141 = *((void *)v136 + 13) - v140;
              if (v139 != v141)
              {
                if (v139 <= v141)
                {
                  if (v139 < v141) {
                    *((void *)v136 + 13) = v140 + v139;
                  }
                }
                else
                {
                  std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append((unint64_t)(v136 + 96), v139 - v141);
                }
                long double v142 = (std::__shared_weak_count *)*((void *)v136 + 7);
                *((void *)v136 + 6) = 0;
                *((void *)v136 + 7) = 0;
                if (v142)
                {
                  if (!atomic_fetch_add(&v142->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v142->__on_zero_shared)(v142);
                    std::__shared_weak_count::__release_weak(v142);
                  }
                }
                *((void *)v136 + 18) = 0;
                *((_DWORD *)v136 + 34) = 0;
                uint64_t v143 = *((void *)v136 + 13) - *((void *)v136 + 12);
                *((void *)v136 + 8) = 0;
                *((void *)v136 + 9) = v143;
                *((void *)v136 + 10) = 0;
                *((void *)v136 + 11) = v143;
                long long v137 = v136 + 24;
              }
              uint64_t v153 = *((void *)v137 + 9);
              uint64_t v144 = *((unsigned int *)v9 + 2);
              *(void *)uint64_t v153 = *(void *)v9;
              *(_DWORD *)(v153 + 8) = v144;
              *(_DWORD *)(v153 + 12) = 1065353216;
              uint64_t v145 = *(void *)(v9 + 3);
              *(float *)(v153 + 24) = v9[5];
              *(void *)(v153 + 16) = v145;
              *(_DWORD *)(v153 + 28) = 1065353216;
              uint64_t v146 = *((void *)v9 + 3);
              *(float *)(v153 + 40) = v9[8];
              *(void *)(v153 + 32) = v146;
              *(_DWORD *)(v153 + 44) = 1065353216;
              uint64_t v147 = *(void *)(v9 + 9);
              *(float *)(v153 + 56) = v9[11];
              *(void *)(v153 + 48) = v147;
              *(_DWORD *)(v153 + 60) = 1065353216;
              uint64_t v148 = *((void *)v9 + 6);
              *(float *)(v153 + 72) = v9[14];
              *(void *)(v153 + 64) = v148;
              *(_DWORD *)(v153 + 76) = 1065353216;
              uint64_t v149 = *(void *)(v9 + 15);
              *(float *)(v153 + 88) = v9[17];
              *(void *)(v153 + 80) = v149;
              *(_DWORD *)(v153 + 92) = 1065353216;
              uint64_t v150 = *((void *)v9 + 9);
              *(float *)(v153 + 104) = v9[20];
              *(void *)(v153 + 96) = v150;
              *(_DWORD *)(v153 + 108) = 1065353216;
              uint64_t v151 = *(void *)(v9 + 21);
              *(float *)(v153 + 120) = v9[23];
              *(void *)(v153 + 112) = v151;
              *(_DWORD *)(v153 + 124) = 1065353216;
              operator new();
            }
            goto LABEL_152;
          }
LABEL_129:
          uint64_t v109 = v51 - v34;
          if (v51 - v34 <= -3) {
            abort();
          }
          uint64_t v110 = v109 >> 1;
          if (v28 - (unint64_t)v34 <= (v109 >> 1) + 1) {
            uint64_t v111 = v110 + 1;
          }
          else {
            uint64_t v111 = v28 - (void)v34;
          }
          if (v28 - (unint64_t)v34 >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v112 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v112 = v111;
          }
          if (v112)
          {
            if (v112 < 0) {
              goto LABEL_184;
            }
            uint64_t v113 = operator new(2 * v112);
          }
          else
          {
            uint64_t v113 = 0;
          }
          float64x2_t v114 = &v113[2 * v110];
          unint64_t v28 = (unint64_t)&v113[2 * v112];
          *(_WORD *)float64x2_t v114 = 3;
          int v52 = v114 + 2;
          if (v51 == v34)
          {
LABEL_150:
            operator delete(v34);
LABEL_151:
            uint64_t v34 = v114;
            if ((unint64_t)v52 < v28) {
              goto LABEL_36;
            }
LABEL_152:
            uint64_t v123 = v52 - v34;
            if (v52 - v34 <= -3) {
              abort();
            }
            uint64_t v124 = v123 >> 1;
            if (v28 - (unint64_t)v34 <= (v123 >> 1) + 1) {
              uint64_t v125 = v124 + 1;
            }
            else {
              uint64_t v125 = v28 - (void)v34;
            }
            if (v28 - (unint64_t)v34 >= 0x7FFFFFFFFFFFFFFELL) {
              uint64_t v125 = 0x7FFFFFFFFFFFFFFFLL;
            }
            if (!v125)
            {
              uint64_t v126 = 0;
LABEL_162:
              uint64_t v127 = &v126[2 * v124];
              _WORD *v127 = 7;
              if (v52 == v34) {
                goto LABEL_172;
              }
              unint64_t v128 = v52 - v34 - 2;
              if (v128 >= 0x1E)
              {
                if ((unint64_t)(v52 - &v126[v123 & 0xFFFFFFFFFFFFFFFELL]) >= 0x20)
                {
                  uint64_t v130 = (v128 >> 1) + 1;
                  uint64_t v129 = &v52[-2 * (v130 & 0xFFFFFFFFFFFFFFF0)];
                  unint64_t v131 = &v126[2 * v124 - 16];
                  unint64_t v132 = v52 - 16;
                  unint64_t v133 = v130 & 0xFFFFFFFFFFFFFFF0;
                  do
                  {
                    long long v134 = *(_OWORD *)v132;
                    *(v131 - 1) = *((_OWORD *)v132 - 1);
                    *unint64_t v131 = v134;
                    v131 -= 2;
                    v132 -= 32;
                    v133 -= 16;
                  }
                  while (v133);
                  v127 -= v130 & 0xFFFFFFFFFFFFFFF0;
                  if (v130 == (v130 & 0xFFFFFFFFFFFFFFF0))
                  {
LABEL_171:
                    if (!v34) {
                      goto LABEL_173;
                    }
LABEL_172:
                    operator delete(v34);
                    goto LABEL_173;
                  }
                }
                else
                {
                  uint64_t v129 = v52;
                }
              }
              else
              {
                uint64_t v129 = v52;
              }
              do
              {
                __int16 v135 = *((_WORD *)v129 - 1);
                v129 -= 2;
                *--uint64_t v127 = v135;
              }
              while (v129 != v34);
              goto LABEL_171;
            }
            if ((v125 & 0x8000000000000000) == 0)
            {
              uint64_t v126 = operator new(2 * v125);
              goto LABEL_162;
            }
LABEL_184:
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unint64_t v115 = v51 - v34 - 2;
          if (v115 >= 0x1E)
          {
            if (v51 - v113 - (v109 & 0xFFFFFFFFFFFFFFFELL) >= 0x20)
            {
              uint64_t v117 = (v115 >> 1) + 1;
              long long v116 = &v51[-2 * (v117 & 0xFFFFFFFFFFFFFFF0)];
              long long v118 = &v113[2 * v110 - 16];
              uint64_t v119 = v51 - 16;
              unint64_t v120 = v117 & 0xFFFFFFFFFFFFFFF0;
              do
              {
                long long v121 = *(_OWORD *)v119;
                *(v118 - 1) = *((_OWORD *)v119 - 1);
                _OWORD *v118 = v121;
                v118 -= 2;
                v119 -= 32;
                v120 -= 16;
              }
              while (v120);
              v114 -= 2 * (v117 & 0xFFFFFFFFFFFFFFF0);
              if (v117 == (v117 & 0xFFFFFFFFFFFFFFF0))
              {
LABEL_149:
                if (!v34) {
                  goto LABEL_151;
                }
                goto LABEL_150;
              }
            }
            else
            {
              long long v116 = v51;
            }
          }
          else
          {
            long long v116 = v51;
          }
          do
          {
            __int16 v122 = *((_WORD *)v116 - 1);
            v116 -= 2;
            *((_WORD *)v114 - 1) = v122;
            v114 -= 2;
          }
          while (v116 != v34);
          goto LABEL_149;
        }
        unint64_t v101 = v50 - v34 - 2;
        if (v101 >= 0x1E)
        {
          if (v50 - v99 - (v95 & 0xFFFFFFFFFFFFFFFELL) >= 0x20)
          {
            uint64_t v103 = (v101 >> 1) + 1;
            int v102 = &v50[-2 * (v103 & 0xFFFFFFFFFFFFFFF0)];
            int v104 = &v99[2 * v96 - 16];
            uint64_t v105 = v50 - 16;
            unint64_t v106 = v103 & 0xFFFFFFFFFFFFFFF0;
            do
            {
              long long v107 = *(_OWORD *)v105;
              *(v104 - 1) = *((_OWORD *)v105 - 1);
              *int v104 = v107;
              v104 -= 2;
              v105 -= 32;
              v106 -= 16;
            }
            while (v106);
            v100 -= 2 * (v103 & 0xFFFFFFFFFFFFFFF0);
            if (v103 == (v103 & 0xFFFFFFFFFFFFFFF0))
            {
LABEL_126:
              if (!v34) {
                goto LABEL_128;
              }
              goto LABEL_127;
            }
          }
          else
          {
            int v102 = v50;
          }
        }
        else
        {
          int v102 = v50;
        }
        do
        {
          __int16 v108 = *((_WORD *)v102 - 1);
          v102 -= 2;
          *((_WORD *)v100 - 1) = v108;
          v100 -= 2;
        }
        while (v102 != v34);
        goto LABEL_126;
      }
      unint64_t v87 = v49 - v34 - 2;
      if (v87 >= 0x1E)
      {
        if (v49 - v85 - (v81 & 0xFFFFFFFFFFFFFFFELL) >= 0x20)
        {
          uint64_t v89 = (v87 >> 1) + 1;
          __int16 v88 = &v49[-2 * (v89 & 0xFFFFFFFFFFFFFFF0)];
          long long v90 = &v85[2 * v82 - 16];
          long long v91 = v49 - 16;
          unint64_t v92 = v89 & 0xFFFFFFFFFFFFFFF0;
          do
          {
            long long v93 = *(_OWORD *)v91;
            *(v90 - 1) = *((_OWORD *)v91 - 1);
            *long long v90 = v93;
            v90 -= 2;
            v91 -= 32;
            v92 -= 16;
          }
          while (v92);
          v86 -= 2 * (v89 & 0xFFFFFFFFFFFFFFF0);
          if (v89 == (v89 & 0xFFFFFFFFFFFFFFF0))
          {
LABEL_103:
            if (!v34) {
              goto LABEL_105;
            }
            goto LABEL_104;
          }
        }
        else
        {
          __int16 v88 = v49;
        }
      }
      else
      {
        __int16 v88 = v49;
      }
      do
      {
        __int16 v94 = *((_WORD *)v88 - 1);
        v88 -= 2;
        *((_WORD *)v86 - 1) = v94;
        v86 -= 2;
      }
      while (v88 != v34);
      goto LABEL_103;
    }
    unint64_t v73 = v48 - v34 - 2;
    if (v73 >= 0x1E)
    {
      if (v48 - v71 - (v67 & 0xFFFFFFFFFFFFFFFELL) >= 0x20)
      {
        uint64_t v75 = (v73 >> 1) + 1;
        long long v74 = &v48[-2 * (v75 & 0xFFFFFFFFFFFFFFF0)];
        uint64_t v76 = &v71[2 * v68 - 16];
        uint64_t v77 = v48 - 16;
        unint64_t v78 = v75 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          long long v79 = *(_OWORD *)v77;
          *(v76 - 1) = *((_OWORD *)v77 - 1);
          *uint64_t v76 = v79;
          v76 -= 2;
          v77 -= 32;
          v78 -= 16;
        }
        while (v78);
        v72 -= 2 * (v75 & 0xFFFFFFFFFFFFFFF0);
        if (v75 == (v75 & 0xFFFFFFFFFFFFFFF0))
        {
LABEL_80:
          if (!v34) {
            goto LABEL_82;
          }
          goto LABEL_81;
        }
      }
      else
      {
        long long v74 = v48;
      }
    }
    else
    {
      long long v74 = v48;
    }
    do
    {
      __int16 v80 = *((_WORD *)v74 - 1);
      v74 -= 2;
      *((_WORD *)v72 - 1) = v80;
      v72 -= 2;
    }
    while (v74 != v34);
    goto LABEL_80;
  }
  unint64_t v59 = v35 - v34 - 2;
  if (v59 >= 0x1E)
  {
    if (v35 - v57 - (v53 & 0xFFFFFFFFFFFFFFFELL) >= 0x20)
    {
      uint64_t v61 = (v59 >> 1) + 1;
      char v60 = &v35[-2 * (v61 & 0xFFFFFFFFFFFFFFF0)];
      uint64_t v62 = &v57[2 * v54 - 16];
      uint64_t v63 = v35 - 16;
      unint64_t v64 = v61 & 0xFFFFFFFFFFFFFFF0;
      do
      {
        long long v65 = *(_OWORD *)v63;
        *(v62 - 1) = *((_OWORD *)v63 - 1);
        _OWORD *v62 = v65;
        v62 -= 2;
        v63 -= 32;
        v64 -= 16;
      }
      while (v64);
      v58 -= 2 * (v61 & 0xFFFFFFFFFFFFFFF0);
      if (v61 == (v61 & 0xFFFFFFFFFFFFFFF0))
      {
LABEL_57:
        if (!v34) {
          goto LABEL_59;
        }
        goto LABEL_58;
      }
    }
    else
    {
      char v60 = v35;
    }
  }
  else
  {
    char v60 = v35;
  }
  do
  {
    __int16 v66 = *((_WORD *)v60 - 1);
    v60 -= 2;
    *((_WORD *)v58 - 1) = v66;
    v58 -= 2;
  }
  while (v60 != v34);
  goto LABEL_57;
}

void sub_1A206647C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  operator delete(v32);
  operator delete(v31);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos4>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos4>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5843F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos4>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5843F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t altitude::GlobeView::getLabelDataManager(altitude::GlobeView *this)
{
  if (!*((void *)this + 53)) {
    operator new();
  }
  return *((void *)this + 53);
}

void altitude::GlobeView::~GlobeView(altitude::GlobeView *this)
{
  altitude::GlobeView::~GlobeView(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  karo::JobManager **v3;
  karo::JobManager *v4;
  karo::JobManager *v5;
  karo::JobManager *v6;
  karo::JobManager *v7;
  uint64_t v8;
  char **v9;
  char *v10;
  char *v11;
  char *v12;
  std::__shared_weak_count *v13;
  altitude::TileManager *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  void *v37;
  std::__shared_weak_count *v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  void *v41;
  std::__shared_weak_count *v42;
  std::__shared_weak_count *v43;

  *(void *)this = &unk_1EF56B5D8;
  uint64_t v2 = *((void *)this + 78);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  long double v3 = *(karo::JobManager ***)(*(void *)(*((void *)this + 107) + 136) + 72);
  long double v4 = *v3;
  long double v5 = v3[1];
  *((unsigned char *)*v3 + 64) = 1;
  *((unsigned char *)v3[2] + 64) = 1;
  if (v5) {
    *((unsigned char *)v5 + 64) = 1;
  }
  karo::JobManager::cancelAll(v4);
  karo::JobManager::cancelAll(v3[2]);
  double v6 = v3[1];
  if (!v6)
  {
    *((unsigned char *)*v3 + 64) = 0;
    double v7 = v3[2];
    goto LABEL_9;
  }
  karo::JobManager::cancelAll(v6);
  double v7 = v3[1];
  *((unsigned char *)*v3 + 64) = 0;
  *((unsigned char *)v3[2] + 64) = 0;
  if (v7) {
LABEL_9:
  }
    *((unsigned char *)v7 + 64) = 0;
  *((_OWORD *)this + 48) = 0u;
  float v8 = *((void *)this + 105);
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    *((void *)this + 105) = 0;
  }
  unint64_t v9 = (char **)*((void *)this + 106);
  if (v9)
  {
    std::mutex::~mutex((std::mutex *)(v9 + 3));
    float v10 = *v9;
    if (*v9)
    {
      float v11 = v9[1];
      float v12 = *v9;
      if (v11 != v10)
      {
        do
        {
          float v13 = (std::__shared_weak_count *)*((void *)v11 - 1);
          if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
          v11 -= 16;
        }
        while (v11 != v10);
        float v12 = *v9;
      }
      v9[1] = v10;
      operator delete(v12);
    }
    MEMORY[0x1A6239270](v9, 0x1020C40A0054943);
    *((void *)this + 106) = 0;
  }
  float v14 = (altitude::TileManager *)*((void *)this + 86);
  if (v14) {
    altitude::TileManager::clear(v14);
  }
  float v15 = *((void *)this + 89);
  if (v15)
  {
    std::mutex::~mutex((std::mutex *)(v15 + 32));
    float v16 = *(void *)(v15 + 8);
    if (v16)
    {
      float v17 = *(void *)(v15 + 16);
      float v18 = *(void **)(v15 + 8);
      if (v17 != v16)
      {
        do
        {
          float v19 = *(std::__shared_weak_count **)(v17 - 8);
          if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
            std::__shared_weak_count::__release_weak(v19);
          }
          v17 -= 16;
        }
        while (v17 != v16);
        float v18 = *(void **)(v15 + 8);
      }
      *(void *)(v15 + 16) = v16;
      operator delete(v18);
    }
    MEMORY[0x1A6239270](v15, 0x1060C40A814CE04);
    *((void *)this + 89) = 0;
  }
  uint64_t v20 = *(void *)(*(void *)(*((void *)this + 107) + 136) + 80);
  if (v20)
  {
    (*(void (**)(uint64_t))(*(void *)v20 + 16))(v20);
    uint64_t v21 = *(void *)(*(void *)(*((void *)this + 107) + 136) + 80);
    (*(void (**)(uint64_t))(*(void *)v21 + 64))(v21);
  }
  uint64_t v22 = (std::__shared_weak_count *)*((void *)this + 91);
  *((_OWORD *)this + 45) = 0u;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v23 = *((void *)this + 86);
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  *((void *)this + 86) = 0;
  uint64_t v24 = *(void *)(*(void *)(*((void *)this + 107) + 136) + 80);
  if (v24)
  {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
    *(void *)(*(void *)(*((void *)this + 107) + 136) + 80) = 0;
  }
  uint64_t v25 = *((void *)this + 103);
  if (v25)
  {
    (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
    *((void *)this + 103) = 0;
  }
  uint64_t v26 = *((void *)this + 3);
  if (v26)
  {
    (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
    *((void *)this + 3) = 0;
  }
  unint64_t v27 = *((void *)this + 2);
  if (v27)
  {
    (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
    *((void *)this + 2) = 0;
  }
  std::mutex::lock((std::mutex *)((char *)this + 864));
  unint64_t v28 = atomic_load((unint64_t *)this + 116);
  *((void *)this + 116) = 0;
  if (v28) {
    (*(void (**)(unint64_t))(*(void *)v28 + 8))(v28);
  }
  std::mutex::unlock((std::mutex *)((char *)this + 864));
  std::mutex::lock((std::mutex *)((char *)this + 968));
  int v29 = atomic_load((unint64_t *)this + 129);
  *((void *)this + 129) = 0;
  if (v29) {
    (*(void (**)(unint64_t))(*(void *)v29 + 8))(v29);
  }
  std::mutex::unlock((std::mutex *)((char *)this + 968));
  std::mutex::lock((std::mutex *)((char *)this + 1072));
  uint64_t v30 = atomic_load((unint64_t *)this + 142);
  *((void *)this + 142) = 0;
  if (v30) {
    (*(void (**)(unint64_t))(*(void *)v30 + 8))(v30);
  }
  std::mutex::unlock((std::mutex *)((char *)this + 1072));
  long long v31 = *((void *)this + 53);
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
  }
  unint64_t v32 = *((void *)this + 4);
  *(void *)(v32 + 48) = 0;
  *(void *)(v32 + 56) = 0;
  __int16 v33 = *((void *)this + 46);
  if (v33)
  {
    (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
    *((void *)this + 46) = 0;
  }
  **((unsigned char **)this + 69) = 1;
  altitude::util::DclpUnique<altitude::TextureMap,altitude::util::DclpDefaultDelete<altitude::TextureMap>>::~DclpUnique((uint64_t)this + 1072);
  altitude::util::DclpUnique<altitude::TextureMap,altitude::util::DclpDefaultDelete<altitude::TextureMap>>::~DclpUnique((uint64_t)this + 968);
  altitude::util::DclpUnique<ggl::Texture2D,altitude::util::DclpDefaultDelete<ggl::Texture2D>>::~DclpUnique((uint64_t)this + 864);
  uint64_t v34 = (std::__shared_weak_count *)*((void *)this + 101);
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  unint64_t v35 = (std::__shared_weak_count *)*((void *)this + 91);
  if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
  uint64_t v36 = *((void *)this + 85);
  *((void *)this + 85) = 0;
  if (v36)
  {
    [*(id *)(v36 + 8) clearListener];
    uint64_t v37 = *(void **)(v36 + 8);
    if (v37)
    {
      *(void *)(v36 + 8) = 0;

      uint64_t v37 = *(void **)(v36 + 8);
    }
    *(void *)uint64_t v36 = &unk_1EF559A18;

    MEMORY[0x1A6239270](v36, 0x80C40B49F1EBBLL);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 83));
  uint64_t v38 = (std::__shared_weak_count *)*((void *)this + 77);
  if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
    std::__shared_weak_count::__release_weak(v38);
  }
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 75));
  uint64_t v39 = *((void *)this + 75);
  if (v39) {
    MEMORY[0x1A6239270](v39, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 75) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 73));
  int v40 = (std::__shared_weak_count *)*((void *)this + 70);
  if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
  }
  altitude::AnimationManager::~AnimationManager((altitude::GlobeView *)((char *)this + 192));

  unint64_t v41 = (void *)*((void *)this + 17);
  if (v41)
  {
    *((void *)this + 18) = v41;
    operator delete(v41);
  }
  if (*((char *)this + 135) < 0)
  {
    operator delete(*((void **)this + 14));
    if ((*((char *)this + 111) & 0x80000000) == 0)
    {
LABEL_83:
      uint64_t v42 = (std::__shared_weak_count *)*((void *)this + 10);
      if (!v42) {
        goto LABEL_89;
      }
      goto LABEL_87;
    }
  }
  else if ((*((char *)this + 111) & 0x80000000) == 0)
  {
    goto LABEL_83;
  }
  operator delete(*((void **)this + 11));
  uint64_t v42 = (std::__shared_weak_count *)*((void *)this + 10);
  if (!v42) {
    goto LABEL_89;
  }
LABEL_87:
  if (!atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
    std::__shared_weak_count::__release_weak(v42);
  }
LABEL_89:
  uint64_t v43 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v43)
  {
    if (!atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }
}

void sub_1A2066EC4(_Unwind_Exception *a1)
{
  *(void *)uint64_t v1 = &unk_1EF559A18;

  _Unwind_Resume(a1);
}

void sub_1A2066EF4(_Unwind_Exception *a1)
{
  altitude::util::DclpUnique<altitude::TextureMap,altitude::util::DclpDefaultDelete<altitude::TextureMap>>::~DclpUnique(v1 + 1072);
  altitude::util::DclpUnique<altitude::TextureMap,altitude::util::DclpDefaultDelete<altitude::TextureMap>>::~DclpUnique(v1 + 968);
  altitude::util::DclpUnique<ggl::Texture2D,altitude::util::DclpDefaultDelete<ggl::Texture2D>>::~DclpUnique(v1 + 864);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 800);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 720);
  std::unique_ptr<ReachabilityChangedObserver>::~unique_ptr[abi:nn180100]((uint64_t *)(v1 + 680));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 664));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 608);
  karo::Mutex::~Mutex((pthread_mutex_t **)(v1 + 600));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 584));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 552);
  altitude::AnimationManager::~AnimationManager((altitude::AnimationManager *)(v1 + 192));

  long double v3 = *(void **)(v1 + 136);
  if (v3)
  {
    *(void *)(v1 + 144) = v3;
    operator delete(v3);
    if ((*(char *)(v1 + 135) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v1 + 111) & 0x80000000) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if ((*(char *)(v1 + 135) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(v1 + 112));
  if ((*(char *)(v1 + 111) & 0x80000000) == 0)
  {
LABEL_5:
    std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 72);
    std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 32);
    _Unwind_Resume(a1);
  }
LABEL_4:
  operator delete(*(void **)(v1 + 88));
  goto LABEL_5;
}

void altitude::util::DclpUnique<altitude::TextureMap,altitude::util::DclpDefaultDelete<altitude::TextureMap>>::~DclpUnique(uint64_t a1)
{
  std::mutex::lock((std::mutex *)a1);
  unint64_t v2 = atomic_load((unint64_t *)(a1 + 64));
  *(void *)(a1 + 64) = 0;
  if (v2) {
    (*(void (**)(unint64_t))(*(void *)v2 + 8))(v2);
  }
  std::mutex::unlock((std::mutex *)a1);
  uint64_t v3 = *(void *)(a1 + 96);
  if (v3 == a1 + 72)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 72) + 32))(a1 + 72);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  std::mutex::~mutex((std::mutex *)a1);
}

void sub_1A2067094(_Unwind_Exception *a1)
{
  std::function<altitude::TextureMap * ()(void)>::~function((void *)(v1 + 72));
  std::mutex::~mutex((std::mutex *)v1);
  _Unwind_Resume(a1);
}

void altitude::util::DclpUnique<ggl::Texture2D,altitude::util::DclpDefaultDelete<ggl::Texture2D>>::~DclpUnique(uint64_t a1)
{
  std::mutex::lock((std::mutex *)a1);
  unint64_t v2 = atomic_load((unint64_t *)(a1 + 64));
  *(void *)(a1 + 64) = 0;
  if (v2) {
    (*(void (**)(unint64_t))(*(void *)v2 + 8))(v2);
  }
  std::mutex::unlock((std::mutex *)a1);
  uint64_t v3 = *(void *)(a1 + 96);
  if (v3 == a1 + 72)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 72) + 32))(a1 + 72);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  std::mutex::~mutex((std::mutex *)a1);
}

void sub_1A2067188(_Unwind_Exception *a1)
{
  std::function<ggl::Texture2D * ()(void)>::~function((void *)(v1 + 72));
  std::mutex::~mutex((std::mutex *)v1);
  _Unwind_Resume(a1);
}

void *std::function<ggl::Texture2D * ()(void)>::~function(void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<altitude::TextureMap * ()(void)>::~function(void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void altitude::GlobeView::GlobeView(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = &unk_1EF56B5D8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = *a3;
  uint64_t v4 = a3[1];
  *(void *)(a1 + 80) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 88) = 0uLL;
  *(_DWORD *)(a1 + 164) = 0;
  *(_DWORD *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 104) = 0uLL;
  *(_OWORD *)(a1 + 120) = 0uLL;
  *(_OWORD *)(a1 + 136) = 0uLL;
  *(_OWORD *)(a1 + 145) = 0uLL;
  *(void *)(a1 + 176) = 0;
  *(_WORD *)(a1 + 184) = 257;
  gettimeofday(&v5, 0);
  *(double *)(a1 + 192) = (double)v5.tv_sec + (double)v5.tv_usec * 0.000001;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 200) = 0;
  operator new();
}

void sub_1A20695E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, void **a14, uint64_t a15, altitude::AnimationManager *a16, uint64_t a17, _Unwind_Exception *exception_object, std::condition_variable *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  altitude::util::DclpUnique<altitude::TextureMap,altitude::util::DclpDefaultDelete<altitude::TextureMap>>::~DclpUnique(a11);
  altitude::util::DclpUnique<altitude::TextureMap,altitude::util::DclpDefaultDelete<altitude::TextureMap>>::~DclpUnique(v31 + 968);
  altitude::util::DclpUnique<ggl::Texture2D,altitude::util::DclpDefaultDelete<ggl::Texture2D>>::~DclpUnique(a12);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v31 + 800);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v31 + 720);
  std::unique_ptr<ReachabilityChangedObserver>::~unique_ptr[abi:nn180100](a23);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*a13);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v31 + 608);
  karo::Mutex::~Mutex((pthread_mutex_t **)(v31 + 600));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*a14);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a15);
  altitude::AnimationManager::~AnimationManager(a16);

  uint64_t v34 = *(void **)(v31 + 136);
  if (v34)
  {
    *(void *)(v31 + 144) = v34;
    operator delete(v34);
    if (*(char *)(v31 + 135) < 0)
    {
LABEL_3:
      operator delete(*(void **)(v31 + 112));
      if ((*(char *)(v31 + 111) & 0x80000000) == 0)
      {
LABEL_8:
        std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a10);
        std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v31 + 32);

        _Unwind_Resume(a1);
      }
LABEL_7:
      operator delete(*a9);
      goto LABEL_8;
    }
  }
  else if (*(char *)(v31 + 135) < 0)
  {
    goto LABEL_3;
  }
  if ((*(char *)(v31 + 111) & 0x80000000) == 0) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

void altitude::GlobeView::load(altitude::GlobeView *this)
{
}

void sub_1A2069D30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void altitude::GlobeView::updateNightLightRedrawRequest(altitude::GlobeView *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 107) + 136);
  if (*(unsigned char *)(v1 + 48))
  {
    uint64_t v3 = *(void *)(v1 + 160);
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 48))(v3);
    }
    uint64_t v4 = *((void *)this + 69);
    timeval v5 = (std::__shared_weak_count *)*((void *)this + 70);
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    dispatch_time_t v6 = dispatch_time(0, 60000000000);
    double v7 = **(NSObject ***)(*((void *)this + 107) + 8);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3321888768;
    block[2] = ___ZN8altitude9GlobeView29updateNightLightRedrawRequestEv_block_invoke;
    block[3] = &__block_descriptor_56_ea8_40c27_ZTSNSt3__110shared_ptrIbEE_e5_v8__0l;
    block[4] = this;
    block[5] = v4;
    float v10 = v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    dispatch_after(v6, v7, block);
    float v8 = v10;
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    if (v5)
    {
      if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
}

void altitude::GlobeView::updateLodScale(altitude::GlobeView *this)
{
  uint64_t v2 = *((void *)this + 76);
  if (!v2) {
    goto LABEL_28;
  }
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(*(void *)(v2 + 16) + 2784));
  if ((v3 & 1) == 0) {
    goto LABEL_28;
  }
  uint64_t v4 = *(void *)(*((void *)this + 76) + 16);
  if (!v4) {
    goto LABEL_28;
  }
  unsigned __int8 v5 = atomic_load((unsigned __int8 *)(v4 + 2784));
  if ((v5 & 1) == 0) {
    std::__assoc_sub_state::wait(*(std::__assoc_sub_state **)(v4 + 2808));
  }
  uint64_t v6 = *(void *)(v4 + 120);
  double v7 = *(std::__shared_weak_count **)(v4 + 128);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v6)
  {
    BOOL v8 = *(unsigned __int8 *)(v6 + 15) != 0;
    if (!v7)
    {
LABEL_13:
      if (v8) {
        goto LABEL_14;
      }
LABEL_28:
      uint64_t v16 = *((void *)this + 107);
      if (*(double *)(*(void *)(v16 + 136) + 32) <= 1.0) {
        int v17 = 1061158912;
      }
      else {
        int v17 = 1057384038;
      }
      *(_DWORD *)(*((void *)this + 86) + 200) = v17;
      *(_DWORD *)(*((void *)this + 87) + 216) = v17;
      goto LABEL_32;
    }
  }
  else
  {
    BOOL v8 = 0;
    if (!v7) {
      goto LABEL_13;
    }
  }
  if (atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_13;
  }
  ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
  std::__shared_weak_count::__release_weak(v7);
  if (!v8) {
    goto LABEL_28;
  }
LABEL_14:
  uint64_t v9 = *((void *)this + 76);
  int v10 = 0;
  if (v9)
  {
    unsigned __int8 v11 = atomic_load((unsigned __int8 *)(*(void *)(v9 + 16) + 2784));
    if (v11)
    {
      uint64_t v12 = *(void *)(*((void *)this + 76) + 16);
      if (v12)
      {
        unsigned __int8 v13 = atomic_load((unsigned __int8 *)(v12 + 2784));
        if ((v13 & 1) == 0) {
          std::__assoc_sub_state::wait(*(std::__assoc_sub_state **)(v12 + 2808));
        }
        uint64_t v14 = *(void *)(v12 + 120);
        float v15 = *(std::__shared_weak_count **)(v12 + 128);
        if (v15) {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v14) {
          int v10 = *(_DWORD *)(v14 + 204);
        }
        if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
    }
  }
  *(_DWORD *)(*((void *)this + 86) + 200) = v10;
  *(_DWORD *)(*((void *)this + 87) + 216) = v10;
  uint64_t v16 = *((void *)this + 107);
LABEL_32:
  uint64_t v18 = **(void **)(v16 + 88);
  if (v18)
  {
    char v19 = 7;
    md::MapEngine::setNeedsTick(v18, &v19);
  }
}

void altitude::GlobeView::initializeScene(altitude::GlobeView *this)
{
  uint64_t v1 = *((void *)this + 91);
  if (v1) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v1 + 8), 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_1A206D4B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  uint64_t v17 = v13 + 120;
  uint64_t v18 = *(void *)(v13 + 176);
  if (v18 == v13 + 152)
  {
    (*(void (**)(uint64_t))(*(void *)(v13 + 152) + 32))(v13 + 152);
  }
  else if (v18)
  {
    (*(void (**)(uint64_t))(*(void *)v18 + 40))(v18);
  }
  uint64_t v19 = *(void *)(v13 + 144);
  if (v19 == v17)
  {
    (*(void (**)(uint64_t))(*(void *)v17 + 32))(v13 + 120);
  }
  else if (v19)
  {
    (*(void (**)(uint64_t))(*(void *)v19 + 40))(v19);
  }
  uint64_t v20 = *v15;
  uint64_t *v15 = 0;
  if (v20)
  {
    std::__tree<std::__value_type<unsigned long long,GEOPDFlyover const* {__strong}>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,GEOPDFlyover const* {__strong}>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,GEOPDFlyover const* {__strong}>>>::destroy(*(void **)(v20 + 8));
    MEMORY[0x1A6239270](v20, 0x1020C4062D53EE8);
  }
  *(void *)uint64_t v13 = v14;
  if (*(char *)(v13 + 31) < 0) {
    operator delete(*(void **)(v13 + 8));
  }
  MEMORY[0x1A6239270](v13, 0x10B3C4019913E46);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<altitude::AnchorManager *,std::shared_ptr<altitude::AnchorManager>::__shared_ptr_default_delete<altitude::AnchorManager,altitude::AnchorManager>,std::allocator<altitude::AnchorManager>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 40);
    *(void *)(v1 + 40) = 0;
    if (v2)
    {
      karo::Pool<altitude::Anchor>::disposeElements(v2);
      std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v2 + 8));
      MEMORY[0x1A6239270](v2, 0x1020C40D4280EFALL);
    }
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 24));
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::AnchorManager *,std::shared_ptr<altitude::AnchorManager>::__shared_ptr_default_delete<altitude::AnchorManager,altitude::AnchorManager>,std::allocator<altitude::AnchorManager>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void karo::graphics::CullingNode::addCullingGraph(void *a1, uint64_t a2)
{
  unsigned __int8 v5 = (char *)a1[6];
  unint64_t v4 = a1[7];
  uint64_t v6 = v5;
  if ((unint64_t)v5 >= v4)
  {
    BOOL v8 = (char *)a1[5];
    uint64_t v9 = (v5 - v8) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      abort();
    }
    uint64_t v11 = v4 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v13 = operator new(8 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    float v15 = &v13[8 * v12];
    *uint64_t v14 = a2;
    double v7 = v14 + 1;
    if (v5 == v8)
    {
      BOOL v8 = v5;
    }
    else
    {
      unint64_t v16 = v5 - v8 - 8;
      if (v16 < 0x58) {
        goto LABEL_29;
      }
      if ((unint64_t)(v8 - v13) < 0x20) {
        goto LABEL_29;
      }
      uint64_t v17 = (v16 >> 3) + 1;
      uint64_t v6 = &v5[-8 * (v17 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v18 = &v13[8 * v9 - 16];
      uint64_t v19 = v5 - 16;
      uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v21 = *(_OWORD *)v19;
        *(v18 - 1) = *((_OWORD *)v19 - 1);
        _OWORD *v18 = v21;
        v18 -= 2;
        v19 -= 32;
        v20 -= 4;
      }
      while (v20);
      v14 -= v17 & 0x3FFFFFFFFFFFFFFCLL;
      if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_29:
        do
        {
          uint64_t v22 = *((void *)v6 - 1);
          v6 -= 8;
          *--uint64_t v14 = v22;
        }
        while (v6 != v8);
        BOOL v8 = (char *)a1[5];
      }
    }
    a1[5] = v14;
    a1[6] = v7;
    a1[7] = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *(void *)unsigned __int8 v5 = a2;
    double v7 = v5 + 8;
  }
  a1[6] = v7;
}

void altitude::MapAvailabilityCache::~MapAvailabilityCache(altitude::MapAvailabilityCache *this)
{
  *(void *)this = &unk_1EF56A468;
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 8));
  uint64_t v2 = *((void *)this + 8);
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 8) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 6));
  *(void *)this = &unk_1EF567F78;
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;

  *(void *)this = &unk_1EF56A468;
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 8));
  uint64_t v2 = *((void *)this + 8);
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 8) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 6));
  *(void *)this = &unk_1EF567F78;
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

uint64_t ___ZN8altitude9GlobeView29updateNightLightRedrawRequestEv_block_invoke(uint64_t result)
{
  if (!**(unsigned char **)(result + 40)) {
    return altitude::GlobeView::updateNightLightRedrawRequest(*(altitude::GlobeView **)(result + 32));
  }
  return result;
}

void __destroy_helper_block_ea8_40c27_ZTSNSt3__110shared_ptrIbEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_ea8_40c27_ZTSNSt3__110shared_ptrIbEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__tree<std::string>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::string>::destroy(*(void *)a1);
    std::__tree<std::string>::destroy(*((void *)a1 + 1));
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::destroy(*(void *)a1);
    std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::destroy(*((void *)a1 + 1));
    uint64_t v2 = (void *)*((void *)a1 + 7);
    if (v2)
    {
      *((void *)a1 + 8) = v2;
      operator delete(v2);
    }
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

void karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::~SharedItemManager(uint64_t a1)
{
  *(void *)a1 = &unk_1EF567790;
  std::__tree<std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>,std::__map_value_compare<altitude::MapRequestId,std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>,std::less<altitude::MapRequestId>,true>,std::allocator<std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>>>::destroy(*(void **)(a1 + 80));
  std::mutex::~mutex((std::mutex *)(a1 + 8));
  JUMPOUT(0x1A6239270);
}

void std::__tree<std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>,std::__map_value_compare<altitude::MapRequestId,std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>,std::less<altitude::MapRequestId>,true>,std::allocator<std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>,std::__map_value_compare<altitude::MapRequestId,std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>,std::less<altitude::MapRequestId>,true>,std::allocator<std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>>>::destroy(*a1);
    std::__tree<std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>,std::__map_value_compare<altitude::MapRequestId,std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>,std::less<altitude::MapRequestId>,true>,std::allocator<std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>>>::destroy(a1[1]);
    uint64_t v2 = (std::__shared_weak_count *)a1[13];
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    unsigned __int8 v3 = (void *)a1[8];
    if (v3)
    {
      a1[9] = v3;
      operator delete(v3);
    }
    operator delete(a1);
  }
}

uint64_t karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::~SharedItemManager(uint64_t a1)
{
  *(void *)a1 = &unk_1EF567790;
  std::__tree<std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>,std::__map_value_compare<altitude::MapRequestId,std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>,std::less<altitude::MapRequestId>,true>,std::allocator<std::__value_type<altitude::MapRequestId,std::weak_ptr<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>::Entry>>>>::destroy(*(void **)(a1 + 80));
  std::mutex::~mutex((std::mutex *)(a1 + 8));
  return a1;
}

uint64_t std::__shared_ptr_emplace<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A858;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<karo::SharedItemManager<altitude::Map,altitude::MapRequestId>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A858;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_3,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_3>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 8) + 464);
  uint64_t v2 = *(void *)(v1 + 248);
  uint64_t v3 = *(void *)(v2 + 40);
  if (v3 != *(void *)(v2 + 48))
  {
    uint64_t v4 = *(void *)(v2 + 48);
    do
    {
      if (*(void *)v3)
      {
        uint64_t v5 = *(void *)(*(void *)v3 + 328);
        if (v5) {
          *(unsigned char *)(v5 + 282) = 0;
        }
      }
      v3 += 8;
    }
    while (v3 != v4);
  }
  uint64_t v6 = **(void **)(*(void *)(*(void *)(v1 + 32) + 8) + 88);
  if (v6)
  {
    char v7 = 7;
    md::MapEngine::setNeedsTick(v6, &v7);
  }
}

uint64_t std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_3,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_3>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57D560;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_3,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_3>,void ()(void)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57D560;
  result[1] = v3;
  return result;
}

void std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_3,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_3>,void ()(void)>::~__func()
{
}

void std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_2,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_2>,altitude::TextureMap * ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(*(void *)(a1 + 8) + 856) + 136);
  char v7 = &unk_1EF568050;
  uint64_t v8 = 0;
  int v9 = 29;
  char v10 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  char v16 = 0;
  karo::media::Image::setFormat((uint64_t)&v7, 1);
  uint64_t v2 = (atomic_ullong *)operator new(0x30uLL);
  v2[1] = 0;
  v2[2] = 0;
  atomic_ullong *v2 = (atomic_ullong)&unk_1EF588E18;
  uint64_t v3 = ggl::Data::Data((ggl::Data *)(v2 + 3), 256);
  uint64_t v4 = (_OWORD *)v2[4];
  _OWORD *v4 = xmmword_1A28FE0E0;
  v4[1] = xmmword_1A28FE0E0;
  void v4[2] = xmmword_1A28FE0F0;
  v4[3] = xmmword_1A28FE0F0;
  v4[4] = xmmword_1A28FE0E0;
  v4[5] = xmmword_1A28FE0E0;
  v4[6] = xmmword_1A28FE0F0;
  v4[7] = xmmword_1A28FE0F0;
  v4[8] = xmmword_1A28FE0E0;
  v4[9] = xmmword_1A28FE0E0;
  v4[10] = xmmword_1A28FE0F0;
  v4[11] = xmmword_1A28FE0F0;
  v4[12] = xmmword_1A28FE0E0;
  v4[13] = xmmword_1A28FE0E0;
  v4[14] = xmmword_1A28FE0F0;
  v4[15] = xmmword_1A28FE0F0;
  if (v8)
  {
    uint64_t v5 = *(ggl::Data ***)(v8 + 16);
    atomic_fetch_add_explicit(v2 + 1, 1uLL, memory_order_relaxed);
    uint64_t v6 = (std::__shared_weak_count *)v5[1];
    char *v5 = v3;
    v5[1] = (ggl::Data *)v2;
    if (v6)
    {
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  karo::media::Image::convertToFormat((uint64_t)&v7, *(_DWORD *)(v1 + 44));
  if (*(unsigned char *)(v1 + 40) || *(unsigned char *)(v1 + 41)) {
    karo::media::Image::mipmapAndCompress((uint64_t)&v7, *(_DWORD *)(v1 + 44));
  }
  operator new();
}

void sub_1A206E2B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if (!atomic_fetch_add(v4, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  karo::media::Image::~Image((karo::media::Image *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_2,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_2>,altitude::TextureMap * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57D518;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_2,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_2>,altitude::TextureMap * ()(void)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57D518;
  result[1] = v3;
  return result;
}

void std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_2,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_2>,altitude::TextureMap * ()(void)>::~__func()
{
}

void std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_1,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_1>,altitude::TextureMap * ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(*(void *)(a1 + 8) + 856) + 136);
  int v9 = &unk_1EF568050;
  char v10 = 0;
  unsigned int v11 = 29;
  char v12 = 0;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  char v18 = 0;
  karo::media::Image::setFormat((uint64_t)&v9, 1);
  if (v10) {
    *char v10 = 0x800000008;
  }
  uint64_t v2 = (atomic_ullong *)operator new(0x30uLL);
  v2[1] = 0;
  v2[2] = 0;
  atomic_ullong *v2 = (atomic_ullong)&unk_1EF588E18;
  uint64_t v3 = ggl::Data::Data((ggl::Data *)(v2 + 3), 256);
  uint64_t v4 = (_OWORD *)v2[4];
  *(void *)&long long v5 = 0xFFFFFFFFLL;
  *((void *)&v5 + 1) = 0xFFFFFFFFLL;
  _OWORD *v4 = v5;
  v4[1] = v5;
  *(void *)&long long v6 = 0xFFFFFFFF00000000;
  *((void *)&v6 + 1) = 0xFFFFFFFF00000000;
  void v4[2] = v6;
  v4[3] = v6;
  v4[4] = v5;
  v4[5] = v5;
  v4[6] = v6;
  v4[7] = v6;
  v4[8] = v5;
  v4[9] = v5;
  v4[10] = v6;
  v4[11] = v6;
  v4[12] = v5;
  v4[13] = v5;
  v4[14] = v6;
  v4[15] = v6;
  if (v10)
  {
    char v7 = (ggl::Data **)v10[2];
    atomic_fetch_add_explicit(v2 + 1, 1uLL, memory_order_relaxed);
    uint64_t v8 = (std::__shared_weak_count *)v7[1];
    *char v7 = v3;
    v7[1] = (ggl::Data *)v2;
    if (v8)
    {
      if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  karo::media::Image::convertToFormat((uint64_t)&v9, *(_DWORD *)(v1 + 44));
  if (*(unsigned char *)(v1 + 40) || *(unsigned char *)(v1 + 41)) {
    karo::media::Image::mipmapAndCompress((uint64_t)&v9, v11);
  }
  operator new();
}

void sub_1A206E6A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if (!atomic_fetch_add(v4, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  karo::media::Image::~Image((karo::media::Image *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_1,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_1>,altitude::TextureMap * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57D4D0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_1,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_1>,altitude::TextureMap * ()(void)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57D4D0;
  result[1] = v3;
  return result;
}

void std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_1,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_1>,altitude::TextureMap * ()(void)>::~__func()
{
}

uint64_t std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_0,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_0>,ggl::Texture2D * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57D488;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_0,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_0>,ggl::Texture2D * ()(void)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57D488;
  result[1] = v3;
  return result;
}

void std::__function::__func<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_0,std::allocator<altitude::GlobeView::GlobeView(VKClassicGlobeCanvas *,md::realistic::RealisticRenderer *,std::shared_ptr<gdc::Camera> const&)::$_0>,ggl::Texture2D * ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_pointer<BOOL *,std::shared_ptr<BOOL>::__shared_ptr_default_delete<BOOL,BOOL>,std::allocator<BOOL>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<BOOL *,std::shared_ptr<BOOL>::__shared_ptr_default_delete<BOOL,BOOL>,std::allocator<BOOL>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

_DWORD *altitude::GlobeView::setCoarseLoading(altitude::GlobeView *this)
{
  if (*((unsigned char *)this + 272))
  {
    *((unsigned char *)this + 272) = 0;
    uint64_t v2 = *((void *)this + 58);
    unint64_t v3 = (*(uint64_t (**)(void, void, uint64_t))(**((void **)this + 66) + 24))(*((void *)this + 66), 0, 0xFFFFFFFFLL);
    unint64_t v4 = v3;
    long long v6 = (uint64_t **)(v2 + 96);
    long long v5 = *(char **)(v2 + 96);
    if (v5)
    {
      while (1)
      {
        while (1)
        {
          char v7 = v5;
          unint64_t v8 = *((void *)v5 + 4);
          if (v8 <= v3) {
            break;
          }
          long long v5 = *(char **)v7;
          long long v6 = (uint64_t **)v7;
          if (!*(void *)v7) {
            goto LABEL_9;
          }
        }
        if (v8 >= v3) {
          break;
        }
        long long v5 = (char *)*((void *)v7 + 1);
        if (!v5)
        {
          long long v6 = (uint64_t **)(v7 + 8);
          goto LABEL_9;
        }
      }
    }
    else
    {
      char v7 = (char *)(v2 + 96);
LABEL_9:
      int v9 = v7;
      char v7 = (char *)operator new(0x60uLL);
      *((void *)v7 + 4) = v4;
      *(_OWORD *)(v7 + 40) = 0u;
      *(_OWORD *)(v7 + 56) = 0u;
      *((void *)v7 + 9) = 0;
      *((_OWORD *)v7 + 5) = xmmword_1A28FD0E0;
      *(void *)char v7 = 0;
      *((void *)v7 + 1) = 0;
      *((void *)v7 + 2) = v9;
      *long long v6 = (uint64_t *)v7;
      uint64_t v10 = **(void **)(v2 + 88);
      unsigned int v11 = (uint64_t *)v7;
      if (v10)
      {
        *(void *)(v2 + 88) = v10;
        unsigned int v11 = *v6;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v2 + 96), v11);
      ++*(void *)(v2 + 104);
    }
    *(_OWORD *)(v7 + 40) = 0u;
    *(_OWORD *)(v7 + 56) = 0u;
    *((void *)v7 + 9) = 0;
    *((_OWORD *)v7 + 5) = xmmword_1A28FD0E0;
    *(unsigned char *)(*((void *)this + 58) + 612) = 1;
  }
  *(_DWORD *)(*((void *)this + 98) + 1304) = 0;
  uint64_t result = (_DWORD *)*((void *)this + 65);
  if (result)
  {
    uint64_t result = (_DWORD *)(*(uint64_t (**)(_DWORD *, void, uint64_t))(*(void *)result + 24))(result, 0, 0xFFFFFFFFLL);
    if (result)
    {
      uint64_t result = (_DWORD *)(*(uint64_t (**)(void, void, uint64_t))(**((void **)this + 65) + 24))(*((void *)this + 65), 0, 0xFFFFFFFFLL);
      result[326] = 0;
    }
  }
  return result;
}

void altitude::GlobeView::setPerspective(uint64_t a1, double *a2)
{
  double v4 = *a2;
  *(double *)(a1 + 280) = *a2;
  *(long double *)(a1 + 288) = tan(v4 * 0.5);
  long long v5 = *(double **)(a1 + 72);
  double v7 = v5[46];
  double v6 = v5[47];
  if (v6 >= v7)
  {
    double v13 = *a2;
  }
  else
  {
    double v8 = v6 * v7;
    double v9 = v7 / v6;
    if (v8 <= 0.0) {
      double v10 = 1.0;
    }
    else {
      double v10 = v9;
    }
    long double v11 = tan(*a2 * 0.5);
    long double v12 = atan(v10 * v11);
    double v13 = v12 + v12;
  }
  v5[57] = v13;
  uint64_t v14 = **(void **)(*(void *)(a1 + 856) + 88);
  if (v14)
  {
    char v15 = 7;
    md::MapEngine::setNeedsTick(v14, &v15);
  }
}

double altitude::GlobeView::calculateMinZoomDistance(altitude::GlobeView *this)
{
  uint64_t v2 = [MEMORY[0x1E4F64500] sharedConfiguration];
  unint64_t v3 = [v2 countryCode];
  int v4 = [v3 isEqualToString:@"KR"];

  if (v4)
  {
    uint64_t v5 = *((void *)this + 9);
    double v6 = *(double *)(v5 + 8);
    if (v6 >= 0.593400002 && v6 <= 0.676299989)
    {
      double v7 = *(double *)(v5 + 16);
      if (v7 >= 2.18169999 && v7 <= 2.26889992) {
        return fmax(*((double *)this + 48) * 10000.0, *((double *)this + 49));
      }
    }
  }
  uint64_t v10 = *((void *)this + 98);
  if (*(float *)(v10 + 1388) == 0.0) {
    return fmax(*((double *)this + 49), 625.0);
  }
  unsigned int v11 = *((_DWORD *)this + 42);
  if (v11 <= 0x12) {
    unsigned int v11 = 18;
  }
  if (v11 >= 0x14) {
    LOBYTE(v11) = 20;
  }
  float v12 = 0.4 / (double)(1 << (v11 - 18));
  float v13 = 1.0 / *(double *)(v10 + 376);
  float v14 = (double)(*(_DWORD *)(*((void *)this + 99) + 48) - *(_DWORD *)(*((void *)this + 99) + 40)) * 0.5;
  return fmax(*((double *)this + 49), (float)((float)((float)(*(float *)(*((void *)this + 86) + 200) * v14) * v12) / v13));
}

void sub_1A206EC8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL altitude::GlobeView::getSpherePointIntersection(uint64_t a1, int a2, int a3, double *a4, uint64_t a5, double a6)
{
  double v8 = *a4;
  double v9 = a4[1];
  double v10 = a4[2];
  BOOL result = altitude::GlobeView::getDirFromScreenPosition(a1, &v19, a4, (float)a2, (float)a3);
  if (result)
  {
    double v12 = v19.f64[0] * v19.f64[0] + v19.f64[1] * v19.f64[1] + v20 * v20;
    float64_t v13 = v19.f64[0] * v8 + v19.f64[1] * v9 + v20 * v10;
    double v14 = v13 + v13;
    double v15 = (v9 * v9 - (a6 * a6 - v8 * v8) + v10 * v10) * (-4.0 * v12) + v14 * v14;
    if (v15 >= 0.0 && (double v16 = (sqrt(v15) + v14) * -0.5 / v12, v16 >= 0.0))
    {
      *(double *)&long long v17 = v8 + v16 * v19.f64[0];
      *((double *)&v17 + 1) = v9 + v16 * v19.f64[1];
      double v18 = v10 + v16 * v20;
      *(_OWORD *)a5 = v17;
      *(double *)(a5 + 16) = v18;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL altitude::GlobeView::getDirFromScreenPosition(uint64_t a1, float64x2_t *a2, double *a3, float a4, float a5)
{
  uint64_t v5 = *(void *)(a1 + 792);
  if (v5)
  {
    v11.n128_f64[0] = karo::graphics::Viewport::computeWindowMatrix((karo::graphics::Viewport *)v53, v5);
    {
      *(_OWORD *)&qword_1E958FAB8 = 0u;
      unk_1E958FAD8 = 0u;
      unk_1E958FAF8 = 0u;
      unk_1E958FAE8 = 0u;
      unk_1E958FAC8 = 0u;
      unk_1E958FAA8 = 0u;
      unk_1E958FA98 = 0u;
      altitude::GlobeView::getProjectionMatrix(void)const::m = 0x3FF0000000000000;
      qword_1E958FAB8 = 0x3FF0000000000000;
      qword_1E958FAE0 = 0x3FF0000000000000;
      qword_1E958FB08 = 0x3FF0000000000000;
    }
    uint64_t v12 = (*(uint64_t (**)(void, void, uint64_t, __n128))(**(void **)(a1 + 528) + 24))(*(void *)(a1 + 528), 0, 0xFFFFFFFFLL, v11);
    if (v12) {
      float64_t v13 = (double *)(v12 + 376);
    }
    else {
      float64_t v13 = (double *)&altitude::GlobeView::getProjectionMatrix(void)const::m;
    }
    gm::operator*<double,4,4,4>(v54, v53, v13);
    double v14 = a3[4];
    double v15 = a3[5];
    double v16 = a3[6];
    double v18 = a3[2];
    double v17 = a3[3];
    double v19 = a3[1];
    double v20 = -(*a3 * v15 - v18 * v17);
    double v21 = -(v19 * v17 - *a3 * v14);
    double v22 = -(v18 * v14 - v19 * v15) - (v18 * v14 - v19 * v15);
    double v23 = v20 + v20;
    double v24 = v21 + v21;
    double v25 = -(v24 * v17 - (-(v19 - v22 * v15) - v23 * v16));
    double v26 = -(*a3 + v22 * v16 + v23 * v15 - v24 * v14);
    double v27 = v18 + v22 * v14 + v24 * v16;
    double v28 = v14 * -2.0;
    double v29 = -(v14 * (v14 * -2.0));
    double v30 = -(v15 * (v15 * -2.0));
    double v31 = 1.0 - (v29 - v15 * (v15 * -2.0));
    double v32 = -(v14 * (v17 * -2.0));
    double v33 = v15 * -2.0 * v16;
    double v34 = v32 - v33;
    double v35 = -(v15 * (v17 * -2.0));
    double v36 = v16 * v28;
    double v37 = v33 + v32;
    double v38 = v16 * v28 - v15 * (v17 * -2.0);
    double v39 = -(v15 * v28);
    double v40 = v17 * -2.0 * v17 + 1.0;
    double v41 = v16 * (v17 * -2.0);
    v52[0] = v31;
    v52[1] = v37;
    v52[4] = v34;
    v52[5] = v40 - v30;
    v52[8] = v38;
    v52[9] = v39 - v41;
    v52[2] = v35 - v36;
    v52[6] = v41 + v39;
    v52[10] = v40 - v29;
    unsigned char v52[3] = 0.0;
    v52[7] = 0.0;
    v52[11] = 0.0;
    v52[12] = v26;
    v52[13] = v25;
    v52[14] = -(v27 - v23 * v17);
    v52[15] = 1.0;
    gm::operator*<double,4,4,4>(v55, v54, v52);
    gm::Matrix<double,4,4>::inverted<int,void>(v56.f64, v55);
    double v42 = v66 + v57 * a4 + v60 * a5;
    double v43 = v67 + v58 * a4 + v61 * a5;
    double v44 = 1.0 / v43;
    double v45 = 1.0 / v43 * v42;
    double v46 = 1.0 / (v43 + v64);
    double v47 = -(v45 - v46 * (v42 + v63));
    float64x2_t v48 = vmlaq_n_f64(vmlaq_n_f64(v65, v56, a4), v59, a5);
    float64x2_t v49 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v48, v44)), vaddq_f64(v48, v62), v46);
    double v50 = 1.0 / sqrt(vaddvq_f64(vmulq_f64(v49, v49)) + v47 * v47);
    *a2 = vmulq_n_f64(v49, v50);
    a2[1].f64[0] = v50 * v47;
  }
  return v5 != 0;
}

BOOL altitude::GlobeView::getSpherePointIntersection(uint64_t a1, int a2, int a3, char a4, double *a5, double *a6, double *a7, int a8)
{
  gdc::CameraFrame<geo::Radians,double>::toRigidTransformGeocentric(v92, a6);
  double v16 = v92[0];
  double v17 = v92[1];
  double v18 = v92[2];
  BOOL result = altitude::GlobeView::getDirFromScreenPosition(a1, &v93, v92, (float)a2, (float)a3);
  if (result)
  {
    double v20 = v93.f64[0];
    double v90 = v16;
    double v91 = v18;
    double v88 = v17;
    if (a4)
    {
      double v21 = 1.0 / sqrt(v17 * v17 + v16 * v16 + v18 * v18);
      double v22 = v21 * v16;
      double v23 = v21 * v17;
      double v24 = v21 * v18;
      double v25 = 1.0 / sqrt(v22 * v22 + v23 * v23 + v24 * v24);
      double v26 = v25 * v22;
      double v27 = v25 * v23;
      double v28 = v25 * v24;
      double v30 = v93.f64[1];
      double v29 = v94;
      double v31 = v26 * v93.f64[0] + 0.1 + v27 * v93.f64[1] + v28 * v94;
      if (v31 > 0.0)
      {
        double v32 = v31 * 0.8;
        double v20 = v93.f64[0] - v32 * v26;
        double v30 = v93.f64[1] - v32 * v27;
        double v29 = v94 - v32 * v28;
      }
      double v85 = v18 * v18;
      double v86 = v17 * v17;
      double v89 = v16 * v16;
      double v33 = 1.0 / sqrt(v20 * v20 + v30 * v30 + v29 * v29);
      double v20 = v33 * v20;
      double v34 = v33 * v30;
      v93.f64[0] = v20;
      v93.f64[1] = v33 * v30;
      double v35 = v33 * v29;
    }
    else
    {
      double v34 = v93.f64[1];
      double v35 = v94;
      double v89 = v16 * v16;
      double v85 = v18 * v18;
      double v86 = v17 * v17;
    }
    double v36 = v20;
    double v37 = a5[1];
    double v38 = a5[2];
    __double2 v39 = __sincos_stret(*a5);
    double v40 = 6378137.0 / sqrt(v39.__sinval * v39.__sinval * -0.00669437999 + 1.0);
    __double2 v41 = __sincos_stret(v37);
    double v42 = v35 * v35 + v36 * v36 + v34 * v34;
    _D15 = v88;
    double v44 = v35 * v91 + v36 * v16 + v34 * v88;
    double v45 = v44 + v44;
    double v46 = (v89
         - ((v40 + v38) * v39.__cosval * v41.__cosval * ((v40 + v38) * v39.__cosval * v41.__cosval)
          + (v40 + v38) * v39.__cosval * v41.__sinval * ((v40 + v38) * v39.__cosval * v41.__sinval)
          + (v38 + v40 * 0.99330562) * v39.__sinval * ((v38 + v40 * 0.99330562) * v39.__sinval))
         + v86
         + v85)
        * 4.0;
    double v47 = -(v46 * v42 - v45 * v45);
    if (v47 >= 0.0 && (double v48 = (sqrt(v47) + v45) * -0.5 / v42, v48 >= 0.0))
    {
      double v82 = v48 * v36;
      double v83 = v48 * v34;
      double v84 = v48 * v35;
    }
    else
    {
      _V16.D[1] = v93.f64[1];
      float64x2_t v50 = vnegq_f64(v93);
      _D1 = v50.f64[1];
      __asm { FMLS            D5, D1, V16.D[1] }
      double v57 = _D5 + v35 * v35;
      __asm { FMLS            D5, D15, V16.D[1] }
      double v59 = _D5 - v35 * v91 + _D5 - v35 * v91;
      double v60 = -(v46 * v57 - v59 * v59);
      if (v60 < 0.0
        || (double v61 = sqrt(v60), v62 = (v61 + v59) * -0.5 / v57, v62 < 0.0) && (v62 = (v61 - v59) * 0.5 / v57, v62 < 0.0))
      {
        double v63 = v93.f64[1];
        double v87 = v93.f64[0];
        double v64 = sqrt((a6[3] + cos(3.14159265 - a6[4]) * -12756274.0) * a6[3] + 4.06806316e13);
        double v65 = sqrt((v64 + 6378137.0) * (v64 + -6378137.0));
        long double v66 = v90 + v87 * v65;
        long double v67 = v88 + v63 * v65;
        long double v68 = v91 + v35 * v65;
        double v69 = sqrt(v66 * v66 + v67 * v67);
        double v70 = atan2(v68, v69 * 0.996647189);
        double v71 = atan2(v67, v66);
        __double2 v72 = __sincos_stret(v70);
        double v73 = atan2(v68 + v72.__sinval * v72.__sinval * 42841.3115 * v72.__sinval, v69 + v72.__cosval * v72.__cosval * -42697.6727 * v72.__cosval);
        __double2 v74 = __sincos_stret(v73);
        double v75 = 6378137.0 / sqrt(v74.__sinval * v74.__sinval * -0.00669437999 + 1.0);
        if (a8) {
          double v76 = v38;
        }
        else {
          double v76 = 0.0;
        }
        double v77 = (v75 + v76) * v74.__cosval;
        __double2 v78 = __sincos_stret(v71);
        BOOL result = 0;
        double v79 = v77 * v78.__cosval;
        double v80 = v77 * v78.__sinval;
        double v81 = (v76 + v75 * 0.99330562) * v74.__sinval;
        goto LABEL_19;
      }
      double v82 = v62 * v50.f64[0];
      double v83 = v62 * v50.f64[1];
      double v84 = v62 * -v35;
    }
    double v81 = v84 + v91;
    double v80 = v83 + v88;
    double v79 = v82 + v16;
    BOOL result = 1;
LABEL_19:
    *a7 = v79;
    a7[1] = v80;
    a7[2] = v81;
  }
  return result;
}

BOOL altitude::GlobeView::getCoordAtScreenPosition(uint64_t a1, int *a2, double *a3, uint64_t a4, int a5)
{
  uint64_t v9 = *(void *)(a1 + 72);
  double v10 = (double *)(v9 + 8);
  if (!a3)
  {
    gdc::CameraFrame<geo::Radians,double>::toRigidTransformGeocentric(v38.f64, (double *)(v9 + 8));
    float64x2_t v36 = v38;
    double v37 = v39;
    if (!altitude::GlobeView::getDirFromScreenPosition(a1, &v40, v38.f64, (float)*a2, (float)a2[1])) {
      return 0;
    }
    if (a5)
    {
      double v12 = 1.0 / sqrt(v36.f64[0] * v36.f64[0] + v36.f64[1] * v36.f64[1] + v37 * v37);
      double v13 = v12 * v36.f64[1];
      double v14 = v12 * v37;
      double v15 = 1.0 / sqrt(v12 * v36.f64[0] * (v12 * v36.f64[0]) + v13 * v13 + v14 * v14);
      double v16 = v15 * (v12 * v36.f64[0]);
      double v17 = v15 * v13;
      double v18 = v15 * v14;
      double v19 = v40.f64[1];
      double v20 = v40.f64[0];
      double v21 = v41;
      double v22 = v16 * v40.f64[0] + 0.1 + v17 * v40.f64[1] + v18 * v41;
      if (v22 > 0.0)
      {
        double v23 = v22 * 0.8;
        double v20 = v40.f64[0] - v23 * v16;
        double v19 = v40.f64[1] - v23 * v17;
        double v21 = v41 - v23 * v18;
      }
      double v24 = 1.0 / sqrt(v20 * v20 + v19 * v19 + v21 * v21);
      v40.f64[0] = v24 * v20;
      v40.f64[1] = v24 * v19;
      double v41 = v24 * v21;
    }
    if (altitude::Intersector::intersectRayWithVisibleSet(*(void *)(a1 + 456), &v36, &v40, (uint64_t)&v42))
    {
      long long v34 = v42;
      long double v35 = v43;
    }
    else
    {
      BOOL SpherePointIntersection = altitude::GlobeView::getSpherePointIntersection(a1, *a2, a2[1], a5, v10, v10, (double *)&v34, 0);
      BOOL result = 0;
      if (!SpherePointIntersection) {
        return result;
      }
    }
    goto LABEL_13;
  }
  BOOL result = altitude::GlobeView::getSpherePointIntersection(a1, *a2, a2[1], a5, a3, (double *)(v9 + 8), (double *)&v34, 1);
  if (result)
  {
LABEL_13:
    long long v26 = v34;
    double v27 = v35;
    double v28 = sqrt(*(double *)&v34 * *(double *)&v34 + *((double *)&v34 + 1) * *((double *)&v34 + 1));
    double v29 = atan2(v35, v28 * 0.996647189);
    long double v30 = atan2(*((long double *)&v26 + 1), *(long double *)&v26);
    __double2 v31 = __sincos_stret(v29);
    double v32 = atan2(v27 + v31.__sinval * v31.__sinval * 42841.3115 * v31.__sinval, v28 + v31.__cosval * v31.__cosval * -42697.6727 * v31.__cosval);
    __double2 v33 = __sincos_stret(v32);
    *(double *)a4 = v32;
    *(long double *)(a4 + 8) = v30;
    *(double *)(a4 + 16) = v28 / v33.__cosval + -6378137.0 / sqrt(v33.__sinval * v33.__sinval * -0.00669437999 + 1.0);
    return 1;
  }
  return result;
}

BOOL altitude::GlobeView::getLatLongAtViewPosition(uint64_t a1, int *a2, long long *a3)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 600));
  double v6 = (uint64_t **)(a1 + 584);
  uint64_t v7 = *(void *)(a1 + 584);
  if (v7)
  {
    int v9 = *a2;
    int v8 = a2[1];
    uint64_t v10 = a1 + 584;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      if (v11 < v9)
      {
        v7 += 8;
      }
      else if (v9 >= v11)
      {
        if (*(_DWORD *)(v7 + 36) < v8) {
          v7 += 8;
        }
        else {
          uint64_t v10 = v7;
        }
      }
      else
      {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *(void *)v7;
    }
    while (v7);
    if ((uint64_t **)v10 != v6)
    {
      int v12 = *(_DWORD *)(v10 + 32);
      if (v9 >= v12 && (v12 < v9 || v8 >= *(_DWORD *)(v10 + 36)))
      {
        long long v44 = *(_OWORD *)(v10 + 48);
        *((void *)a3 + 2) = *(void *)(v10 + 64);
        *a3 = v44;
        BOOL v15 = *(unsigned __int8 *)(v10 + 40) != 0;
LABEL_34:
        pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 600));
        return v15;
      }
    }
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 600));
  gdc::CameraFrame<geo::Radians,double>::toRigidTransformGeocentric(v49.f64, (double *)(*(void *)(a1 + 72) + 8));
  if (altitude::GlobeView::getDirFromScreenPosition(a1, &v47, (float)*a2, (float)a2[1]))
  {
    uint64_t v13 = altitude::Intersector::intersectRayWithVisibleSet(*(void *)(a1 + 456), &v49, &v47, (uint64_t)v51);
    BOOL v15 = v13 != 0;
    if (v13)
    {
      long double v16 = *(double *)v51;
      long double v17 = *(double *)&v51[1];
      double v18 = v52;
      double v19 = sqrt(v16 * v16 + v17 * v17);
      double v20 = atan2(v52, v19 * 0.996647189);
      long double v21 = atan2(v17, v16);
      __double2 v22 = __sincos_stret(v20);
      double v23 = atan2(v18 + v22.__sinval * v22.__sinval * 42841.3115 * v22.__sinval, v19 + v22.__cosval * v22.__cosval * -42697.6727 * v22.__cosval);
      __double2 v24 = __sincos_stret(v23);
      double v25 = v19 / v24.__cosval + -6378137.0 / sqrt(v24.__sinval * v24.__sinval * -0.00669437999 + 1.0);
    }
    else
    {
      double v26 = sqrt((*(double *)(*(void *)(a1 + 72) + 32)+ cos(3.14159265 - *(double *)(*(void *)(a1 + 72) + 40)) * -12756274.0)* *(double *)(v14 + 32)+ 4.06806316e13);
      double v27 = sqrt((v26 + 6378137.0) * (v26 + -6378137.0));
      long double v28 = v49.f64[0] + v47.f64[0] * v27;
      long double v29 = v49.f64[1] + v47.f64[1] * v27;
      long double v30 = v50 + v48 * v27;
      double v31 = sqrt(v28 * v28 + v29 * v29);
      double v32 = atan2(v30, v31 * 0.996647189);
      long double v21 = atan2(v29, v28);
      __double2 v33 = __sincos_stret(v32);
      double v23 = atan2(v30 + v33.__sinval * v33.__sinval * 42841.3115 * v33.__sinval, v31 + v33.__cosval * v33.__cosval * -42697.6727 * v33.__cosval);
      double v25 = 0.0;
    }
    *(double *)a3 = v23;
    *((long double *)a3 + 1) = v21;
    *((double *)a3 + 2) = v25;
    pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 600));
    long long v46 = *a3;
    uint64_t v34 = *((void *)a3 + 2);
    uint64_t v35 = a1 + 584;
    uint64_t v36 = *(void *)(a1 + 584);
    if (v36)
    {
      int v37 = *a2;
      int v38 = a2[1];
      while (1)
      {
        uint64_t v35 = v36;
        int v39 = *(_DWORD *)(v36 + 32);
        if (v37 < v39) {
          goto LABEL_22;
        }
        if (v39 < v37) {
          goto LABEL_27;
        }
        int v40 = *(_DWORD *)(v35 + 36);
        if (v38 < v40)
        {
LABEL_22:
          uint64_t v36 = *(void *)v35;
          double v6 = (uint64_t **)v35;
          if (!*(void *)v35) {
            break;
          }
        }
        else
        {
          if (v40 >= v38)
          {
            double v41 = (void *)v35;
            goto LABEL_32;
          }
LABEL_27:
          uint64_t v36 = *(void *)(v35 + 8);
          if (!v36)
          {
            double v6 = (uint64_t **)(v35 + 8);
            break;
          }
        }
      }
    }
    double v41 = operator new(0x48uLL);
    v41[4] = *(void *)a2;
    *((unsigned char *)v41 + 40) = 0;
    v41[7] = 0;
    v41[8] = 0;
    v41[6] = 0;
    *double v41 = 0;
    v41[1] = 0;
    v41[2] = v35;
    *double v6 = v41;
    uint64_t v42 = **(void **)(a1 + 576);
    double v43 = v41;
    if (v42)
    {
      *(void *)(a1 + 576) = v42;
      double v43 = *v6;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 584), v43);
    ++*(void *)(a1 + 592);
LABEL_32:
    *((unsigned char *)v41 + 40) = v15;
    *((_OWORD *)v41 + 3) = v46;
    v41[8] = v34;
    goto LABEL_34;
  }
  return 0;
}

void sub_1A206FAF8(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(*(pthread_mutex_t **)(v1 + 600));
  _Unwind_Resume(a1);
}

uint64_t altitude::GlobeView::getDirFromScreenPosition(uint64_t a1, float64x2_t *a2, float a3, float a4)
{
  uint64_t v4 = *(void *)(a1 + 792);
  if (!v4) {
    return 0;
  }
  uint64_t result = *(void *)(a1 + 768);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)result + 24))(result, 0, 0xFFFFFFFFLL);
    if (result)
    {
      uint64_t v9 = result;
      karo::graphics::Viewport::computeWindowMatrix((karo::graphics::Viewport *)v19, v4);
      gm::operator*<double,4,4,4>(v20, v19, (double *)(v9 + 120));
      gm::Matrix<double,4,4>::inverted<int,void>(v21.f64, v20);
      double v10 = v31 + v22 * a3 + v25 * a4;
      double v11 = v32 + v23 * a3 + v26 * a4;
      double v12 = 1.0 / v11;
      double v13 = 1.0 / v11 * v10;
      double v14 = 1.0 / (v11 + v29);
      double v15 = -(v13 - v14 * (v10 + v28));
      float64x2_t v16 = vmlaq_n_f64(vmlaq_n_f64(v30, v21, a3), v24, a4);
      float64x2_t v17 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v16, v12)), vaddq_f64(v16, v27), v14);
      double v18 = 1.0 / sqrt(vaddvq_f64(vmulq_f64(v17, v17)) + v15 * v15);
      *a2 = vmulq_n_f64(v17, v18);
      a2[1].f64[0] = v18 * v15;
      return 1;
    }
  }
  return result;
}

uint64_t altitude::GlobeView::getViewPositionAtLatLongHeight(void *a1, double *a2, _DWORD *a3)
{
  uint64_t result = a1[66];
  if (result)
  {
    uint64_t v7 = (_DWORD *)a1[99];
    int v8 = (double *)(*(uint64_t (**)(uint64_t, void, void))(*(void *)result + 24))(result, 0, 0);
    double v36 = v8[15];
    double v37 = v8[16];
    double v38 = v8[18];
    double v33 = v8[19];
    double v34 = v8[20];
    double v35 = v8[22];
    double v30 = v8[23];
    double v31 = v8[24];
    double v32 = v8[26];
    double v28 = v8[27];
    double v29 = v8[28];
    double v27 = v8[30];
    gdc::CameraFrame<geo::Radians,double>::toRigidTransformGeocentric(v39, (double *)(a1[9] + 8));
    double v9 = v39[0];
    double v10 = v39[1];
    double v11 = v39[2];
    double v12 = a2[1];
    double v13 = a2[2];
    __double2 v14 = __sincos_stret(*a2);
    double v15 = 6378137.0 / sqrt(v14.__sinval * v14.__sinval * -0.00669437999 + 1.0);
    double v16 = (v15 + v13) * v14.__cosval;
    __double2 v17 = __sincos_stret(v12);
    double v18 = v16 * v17.__cosval;
    double v19 = v16 * v17.__sinval;
    double v20 = (v13 + v15 * 0.99330562) * v14.__sinval;
    double v21 = (v16 * v17.__sinval * v10 + v20 * v11 + v16 * v17.__cosval * v9) / sqrt(v9 * v9 + v10 * v10 + v11 * v11);
    uint64_t result = v21 >= 0.0;
    if (v21 >= 0.0)
    {
      double v22 = v28 + v18 * v36 + v19 * v33 + v20 * v30;
      double v23 = v29 + v18 * v37 + v19 * v34 + v20 * v31;
      double v24 = 1.0 / (v27 + v18 * v38 + v19 * v35 + v20 * v32);
      double v25 = (v22 * 0.5 * v24 + 0.5) * (double)(v7[12] - v7[10]);
      double v26 = (0.5 - v23 * 0.5 * v24) * (double)(v7[13] - v7[11]);
      *a3 = (int)v25;
      a3[1] = (int)v26;
    }
  }
  return result;
}

uint64_t *altitude::GlobeView::createAnchor(uint64_t a1, double *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(uint64_t ***)(v4 + 40);
  double v6 = v5[4];
  if (v6)
  {
    uint64_t v7 = (uint64_t *)*v6;
  }
  else
  {
    int v8 = (char *)malloc_type_malloc(*((unsigned int *)v5 + 7), 0xF0B72BE0uLL);
    double v9 = v8;
    double v11 = v5 + 1;
    double v10 = v5[1];
    if (v10)
    {
      while (1)
      {
        while (1)
        {
          double v12 = (uint64_t **)v10;
          unint64_t v13 = v10[4];
          if ((unint64_t)v8 >= v13) {
            break;
          }
          double v10 = *v12;
          double v11 = v12;
          if (!*v12) {
            goto LABEL_10;
          }
        }
        if (v13 >= (unint64_t)v8) {
          break;
        }
        double v10 = v12[1];
        if (!v10)
        {
          double v11 = v12 + 1;
          goto LABEL_10;
        }
      }
    }
    else
    {
      double v12 = v5 + 1;
LABEL_10:
      __double2 v14 = (uint64_t *)operator new(0x28uLL);
      v14[4] = (uint64_t)v9;
      *__double2 v14 = 0;
      v14[1] = 0;
      v14[2] = (uint64_t)v12;
      *double v11 = v14;
      double v15 = (uint64_t *)**v5;
      if (v15)
      {
        double *v5 = v15;
        double v16 = *v11;
      }
      else
      {
        double v16 = v14;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v5[1], v16);
      v5[2] = (uint64_t *)((char *)v5[2] + 1);
    }
    __double2 v17 = &v9[104 * *((_DWORD *)v5 + 6) - 104];
    double v18 = (char *)v5[4];
    do
    {
      uint64_t v7 = (uint64_t *)v18;
      double v18 = v17;
      *(void *)__double2 v17 = v7;
      v17 -= 104;
    }
    while (v17 >= v9);
    double v6 = (uint64_t *)(v17 + 104);
  }
  v5[4] = v7;
  *(_DWORD *)double v6 = 0;
  *(_OWORD *)(v6 + 1) = 0u;
  *(_OWORD *)(v6 + 3) = 0u;
  *(_OWORD *)(v6 + 5) = 0u;
  v6[7] = 0;
  *((_WORD *)v6 + 32) = 255;
  *((_DWORD *)v6 + 17) = 0;
  *((_DWORD *)v6 + 18) = 0;
  v6[11] = v4;
  *((unsigned char *)v6 + 96) = 1;
  double v19 = *a2;
  double v20 = a2[1];
  if (v20 != 0.0 || v19 != 0.0)
  {
    *((double *)v6 + 1) = v19;
    *((double *)v6 + 2) = v20;
    v6[3] = 0;
    *((unsigned char *)v6 + 65) = 0;
    __double2 v22 = __sincos_stret(v19);
    double v23 = 6378137.0 / sqrt(v22.__sinval * v22.__sinval * -0.00669437999 + 1.0);
    __double2 v24 = __sincos_stret(v20);
    *((double *)v6 + 4) = v23 * v22.__cosval * v24.__cosval;
    *((double *)v6 + 5) = v23 * v22.__cosval * v24.__sinval;
    *((double *)v6 + 6) = v22.__sinval * 0.99330562 * v23;
  }
  uint64_t v25 = *(void *)(a1 + 32);
  double v27 = (uint64_t **)(v25 + 24);
  double v26 = *(uint64_t **)(v25 + 24);
  if (v26)
  {
    while (1)
    {
      while (1)
      {
        double v28 = (uint64_t **)v26;
        unint64_t v29 = v26[4];
        if (v29 <= (unint64_t)v6) {
          break;
        }
        double v26 = *v28;
        double v27 = v28;
        if (!*v28) {
          goto LABEL_29;
        }
      }
      if (v29 >= (unint64_t)v6) {
        break;
      }
      double v26 = v28[1];
      if (!v26)
      {
        double v27 = v28 + 1;
        goto LABEL_29;
      }
    }
  }
  else
  {
    double v28 = (uint64_t **)(v25 + 24);
LABEL_29:
    double v30 = (uint64_t *)operator new(0x28uLL);
    v30[4] = (uint64_t)v6;
    *double v30 = 0;
    v30[1] = 0;
    v30[2] = (uint64_t)v28;
    char *v27 = v30;
    uint64_t v31 = **(void **)(v25 + 16);
    if (v31)
    {
      *(void *)(v25 + 16) = v31;
      double v32 = *v27;
    }
    else
    {
      double v32 = v30;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v25 + 24), v32);
    ++*(void *)(v25 + 32);
  }
  *(unsigned char *)(v25 + 64) = 1;
  LODWORD(v33) = *(_DWORD *)v25 - 1;
  if (*(_DWORD *)v25) {
    uint64_t v33 = v33;
  }
  else {
    uint64_t v33 = 0;
  }
  *(void *)(v25 + 8) = v33;
  return v6;
}

void std::__tree<std::__value_type<unsigned int,std::map<unsigned int,std::set<altitude::SimpleTileKey>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,std::set<altitude::SimpleTileKey>>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,std::set<altitude::SimpleTileKey>>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::map<unsigned int,std::set<altitude::SimpleTileKey>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,std::set<altitude::SimpleTileKey>>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,std::set<altitude::SimpleTileKey>>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,std::map<unsigned int,std::set<altitude::SimpleTileKey>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::map<unsigned int,std::set<altitude::SimpleTileKey>>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::map<unsigned int,std::set<altitude::SimpleTileKey>>>>>::destroy(a1[1]);
    std::__tree<std::__value_type<unsigned int,std::set<altitude::SimpleTileKey>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<altitude::SimpleTileKey>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<altitude::SimpleTileKey>>>>::destroy((void *)a1[6]);
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<unsigned int,std::set<altitude::SimpleTileKey>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<altitude::SimpleTileKey>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<altitude::SimpleTileKey>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::set<altitude::SimpleTileKey>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<altitude::SimpleTileKey>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<altitude::SimpleTileKey>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,std::set<altitude::SimpleTileKey>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<altitude::SimpleTileKey>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<altitude::SimpleTileKey>>>>::destroy(a1[1]);
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy((void *)a1[6]);
    operator delete(a1);
  }
}

uint64_t altitude::GlobeView::getVisibleArea(uint64_t a1, long double **a2)
{
  if (*(unsigned char *)(a1 + 160))
  {
    v179.f64[0] = 0.0;
    uint64_t v4 = *(void *)(a1 + 712);
    long long v181 = *(_OWORD *)(*(void *)(a1 + 72) + 8);
    if (altitude::IntersectorHeight::heightAtLatLon(v4, (double *)&v181, v179.f64, 0xEu) == 2)
    {
      uint64_t v5 = **(void **)(*(void *)(a1 + 856) + 88);
      if (v5)
      {
        LOBYTE(v181) = 7;
        md::MapEngine::setNeedsTick(v5, &v181);
      }
    }
    else
    {
      *(unsigned char *)(a1 + 160) = 0;
      *(double *)(*(void *)(a1 + 72) + 24) = v179.f64[0] + *(double *)(*(void *)(a1 + 72) + 24);
    }
  }
  a2[1] = *a2;
  uint64_t v168 = a1;
  double v6 = *(_DWORD **)(a1 + 792);
  unsigned int v8 = v6[10];
  int v7 = v6[11];
  int v10 = v6[12];
  uint64_t v9 = v6[13];
  double v11 = operator new(8uLL);
  uint64_t v177 = v9;
  unint64_t v12 = v8 | ((unint64_t)v9 << 32);
  *double v11 = v12;
  unint64_t v13 = operator new(0x10uLL);
  uint64_t v14 = (v7 + 1);
  int v15 = v177 + ~v7;
  uint64_t v16 = (v14 + 3 * v15 / 4);
  *unint64_t v13 = v12;
  v13[1] = v8 | ((unint64_t)v16 << 32);
  operator delete(v11);
  __double2 v17 = operator new(0x20uLL);
  double v18 = v17;
  if (v15 >= 0) {
    int v19 = v15;
  }
  else {
    int v19 = v15 + 1;
  }
  uint64_t v20 = (v14 + (v19 >> 1));
  *((void *)v17 + 2) = v8 | ((unint64_t)v20 << 32);
  *__double2 v17 = *(_OWORD *)v13;
  operator delete(v13);
  uint64_t v21 = (v14 + v15 / 4);
  v18[3] = v8 | ((unint64_t)v21 << 32);
  __double2 v22 = operator new(0x40uLL);
  v22[4] = v8 | ((unint64_t)v14 << 32);
  long long v23 = *((_OWORD *)v18 + 1);
  *(_OWORD *)__double2 v22 = *(_OWORD *)v18;
  *((_OWORD *)v22 + 1) = v23;
  operator delete(v18);
  int v24 = v10 + ~v8;
  int v25 = v24 + 3;
  int v26 = v10 - v8;
  if (v24 >= 0) {
    int v25 = v10 + ~v8;
  }
  uint64_t v172 = v8 + (v25 >> 2);
  if (v24 >= 0) {
    int v26 = v10 + ~v8;
  }
  uint64_t v173 = v8 + (v26 >> 1);
  v22[5] = v172 | ((unint64_t)v14 << 32);
  v22[6] = v173 | ((unint64_t)v14 << 32);
  uint64_t v175 = v8 + 3 * v24 / 4;
  uint64_t v22[7] = v175 | ((unint64_t)v14 << 32);
  double v27 = (uint64_t *)operator new(0x80uLL);
  int v28 = v10;
  uint64_t v29 = v177 << 32;
  uint64_t v30 = v16 << 32;
  uint64_t v31 = (v28 - 1);
  v27[8] = (v14 << 32) | v31;
  long long v32 = *((_OWORD *)v22 + 3);
  *((_OWORD *)v27 + 2) = *((_OWORD *)v22 + 2);
  *((_OWORD *)v27 + 3) = v32;
  long long v33 = *((_OWORD *)v22 + 1);
  *(_OWORD *)double v27 = *(_OWORD *)v22;
  *((_OWORD *)v27 + 1) = v33;
  operator delete(v22);
  v27[9] = (v21 << 32) | v31;
  v27[10] = (v20 << 32) | v31;
  unint64_t v34 = (unint64_t)(v27 + 16);
  v27[11] = v30 | v31;
  double v35 = v27 + 12;
  if (v27 + 12 < v27 + 16)
  {
    *double v35 = v29 | v31;
    unint64_t v36 = (unint64_t)(v177 - 1) << 32;
    double v37 = (unint64_t *)(v27 + 13);
    double v38 = (unint64_t *)v27;
    goto LABEL_24;
  }
  int v39 = (unint64_t *)operator new(0x100uLL);
  double v38 = v39 + 12;
  unint64_t v34 = (unint64_t)(v39 + 32);
  v39[12] = v29 | v31;
  double v37 = v39 + 13;
  if (v35 == v27)
  {
    int v40 = v177;
  }
  else
  {
    int v40 = v177;
    if ((unint64_t)((char *)v27 - (char *)v39) < 0x20)
    {
      do
      {
        unint64_t v45 = *--v35;
        *--double v38 = v45;
      }
      while (v35 != v27);
    }
    else
    {
      uint64_t v41 = 0;
      uint64_t v42 = (char *)(v27 + 8);
      do
      {
        long long v43 = *(_OWORD *)&v42[v41 * 8 + 16];
        long long v44 = &v39[v41 + 10];
        *((_OWORD *)v44 - 1) = *(_OWORD *)&v42[v41 * 8];
        *(_OWORD *)long long v44 = v43;
        v41 -= 4;
      }
      while (v41 != -12);
      double v38 = v39;
    }
  }
  long long v46 = v39;
  operator delete(v27);
  unint64_t v36 = (unint64_t)(v40 - 1) << 32;
  if ((unint64_t)v37 < v34)
  {
LABEL_24:
    *double v37 = v36 | v175;
    float64x2_t v47 = v37 + 1;
    if ((unint64_t)(v37 + 1) < v34) {
      goto LABEL_25;
    }
LABEL_47:
    uint64_t v63 = v47 - v38;
    unint64_t v64 = v63 + 1;
    if ((unint64_t)(v63 + 1) >> 61) {
      goto LABEL_149;
    }
    if ((uint64_t)(v34 - (void)v38) >> 2 > v64) {
      unint64_t v64 = (uint64_t)(v34 - (void)v38) >> 2;
    }
    if (v34 - (unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v65 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v65 = v64;
    }
    if (v65)
    {
      if (v65 >> 61) {
        goto LABEL_146;
      }
      long double v66 = operator new(8 * v65);
    }
    else
    {
      long double v66 = 0;
    }
    long double v67 = (unint64_t *)&v66[8 * v63];
    unint64_t v34 = (unint64_t)&v66[8 * v65];
    *long double v67 = v36 | v173;
    double v48 = v67 + 1;
    if (v47 == v38)
    {
LABEL_67:
      operator delete(v38);
LABEL_68:
      double v38 = v67;
      if ((unint64_t)v48 < v34) {
        goto LABEL_26;
      }
LABEL_69:
      uint64_t v76 = v48 - v38;
      unint64_t v77 = v76 + 1;
      if (!((unint64_t)(v76 + 1) >> 61))
      {
        if ((uint64_t)(v34 - (void)v38) >> 2 > v77) {
          unint64_t v77 = (uint64_t)(v34 - (void)v38) >> 2;
        }
        if (v34 - (unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v77 = 0x1FFFFFFFFFFFFFFFLL;
        }
        if (!v77)
        {
          __double2 v78 = 0;
LABEL_78:
          double v79 = (unint64_t *)&v78[8 * v76];
          *double v79 = v36 | v172;
          float64x2_t v49 = v79 + 1;
          if (v48 == v38)
          {
            uint64_t v50 = v168;
LABEL_86:
            operator delete(v38);
LABEL_87:
            double v38 = v79;
            goto LABEL_88;
          }
          unint64_t v80 = (char *)v48 - (char *)v38 - 8;
          if (v80 >= 0x58 && (unint64_t)((char *)v38 - v78) >= 0x20)
          {
            uint64_t v160 = (v80 >> 3) + 1;
            double v81 = &v48[-(v160 & 0x3FFFFFFFFFFFFFFCLL)];
            __double2 v161 = &v78[8 * v76 - 16];
            uint64_t v162 = v48 - 2;
            uint64_t v163 = v160 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v164 = *(_OWORD *)v162;
              *(v161 - 1) = *((_OWORD *)v162 - 1);
              *__double2 v161 = v164;
              v161 -= 2;
              v162 -= 4;
              v163 -= 4;
            }
            while (v163);
            v79 -= v160 & 0x3FFFFFFFFFFFFFFCLL;
            uint64_t v50 = v168;
            if (v160 == (v160 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_83:
              if (!v38) {
                goto LABEL_87;
              }
              goto LABEL_86;
            }
          }
          else
          {
            double v81 = v48;
            uint64_t v50 = v168;
          }
          do
          {
            unint64_t v82 = *--v81;
            *--double v79 = v82;
          }
          while (v81 != v38);
          goto LABEL_83;
        }
        if (!(v77 >> 61))
        {
          __double2 v78 = operator new(8 * v77);
          goto LABEL_78;
        }
LABEL_146:
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
LABEL_149:
      abort();
    }
    unint64_t v68 = (char *)v47 - (char *)v38 - 8;
    if (v68 >= 0x58)
    {
      if ((unint64_t)((char *)v38 - v66) >= 0x20)
      {
        uint64_t v70 = (v68 >> 3) + 1;
        double v69 = &v47[-(v70 & 0x3FFFFFFFFFFFFFFCLL)];
        double v71 = &v66[8 * v63 - 16];
        __double2 v72 = v47 - 2;
        uint64_t v73 = v70 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v74 = *(_OWORD *)v72;
          *(v71 - 1) = *((_OWORD *)v72 - 1);
          *double v71 = v74;
          v71 -= 2;
          v72 -= 4;
          v73 -= 4;
        }
        while (v73);
        v67 -= v70 & 0x3FFFFFFFFFFFFFFCLL;
        if (v70 == (v70 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_66:
          if (!v38) {
            goto LABEL_68;
          }
          goto LABEL_67;
        }
      }
      else
      {
        double v69 = v47;
      }
    }
    else
    {
      double v69 = v47;
    }
    do
    {
      unint64_t v75 = *--v69;
      *--long double v67 = v75;
    }
    while (v69 != v38);
    goto LABEL_66;
  }
  uint64_t v51 = v37 - v38;
  unint64_t v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61) {
    goto LABEL_149;
  }
  if ((uint64_t)(v34 - (void)v38) >> 2 > v52) {
    unint64_t v52 = (uint64_t)(v34 - (void)v38) >> 2;
  }
  if (v34 - (unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v53 = v52;
  }
  if (v53)
  {
    if (v53 >> 61) {
      goto LABEL_146;
    }
    uint64_t v54 = operator new(8 * v53);
  }
  else
  {
    uint64_t v54 = 0;
  }
  uint64_t v55 = (unint64_t *)&v54[8 * v51];
  unint64_t v34 = (unint64_t)&v54[8 * v53];
  unint64_t *v55 = v36 | v175;
  float64x2_t v47 = v55 + 1;
  if (v37 == v38) {
    goto LABEL_45;
  }
  unint64_t v56 = (char *)v37 - (char *)v38 - 8;
  if (v56 < 0x58) {
    goto LABEL_152;
  }
  if ((unint64_t)((char *)v38 - v54) < 0x20) {
    goto LABEL_152;
  }
  uint64_t v57 = (v56 >> 3) + 1;
  v37 -= v57 & 0x3FFFFFFFFFFFFFFCLL;
  double v58 = (long long *)(v46 + 11);
  double v59 = &v54[8 * v51 - 16];
  uint64_t v60 = v57 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v61 = *v58;
    *(v59 - 1) = *(v58 - 1);
    _OWORD *v59 = v61;
    v58 -= 2;
    v59 -= 2;
    v60 -= 4;
  }
  while (v60);
  v55 -= v57 & 0x3FFFFFFFFFFFFFFCLL;
  if (v57 != (v57 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_152:
    do
    {
      unint64_t v62 = *--v37;
      *--uint64_t v55 = v62;
    }
    while (v37 != v38);
  }
  if (v38) {
LABEL_45:
  }
    operator delete(v38);
  double v38 = v55;
  if ((unint64_t)v47 >= v34) {
    goto LABEL_47;
  }
LABEL_25:
  unint64_t *v47 = v36 | v173;
  double v48 = v47 + 1;
  if ((unint64_t)(v47 + 1) >= v34) {
    goto LABEL_69;
  }
LABEL_26:
  *double v48 = v36 | v172;
  float64x2_t v49 = v48 + 1;
  uint64_t v50 = v168;
LABEL_88:
  double v83 = *(double **)(v50 + 72);
  gdc::CameraFrame<geo::Radians,double>::toRigidTransformGeocentric((double *)&v181, v83 + 1);
  double v84 = v83[4];
  double v85 = cos(3.14159265 - v83[5]);
  if (v49 == v38)
  {
    uint64_t v158 = 1;
    goto LABEL_140;
  }
  uint64_t v86 = 0;
  unsigned int v87 = 0;
  double v88 = sqrt((v84 + v85 * -12756274.0) * v84 + 4.06806316e13);
  double v89 = sqrt((v88 + 6378137.0) * (v88 + -6378137.0));
  double v91 = *((double *)&v181 + 1);
  double v90 = *(double *)&v181;
  unint64_t v92 = v49 - v38;
  double v178 = v182;
  double v93 = sqrt(*((double *)&v181 + 1) * *((double *)&v181 + 1) + *(double *)&v181 * *(double *)&v181 + v178 * v178)
      - (v88
       + -6378137.0);
  double v174 = (*(double *)&v181 * *(double *)&v181 - v93 * v93 + *((double *)&v181 + 1) * *((double *)&v181 + 1)
                                                          + v178 * v178)
       * 4.0;
  double v176 = v89 + v89;
  double v171 = v89;
  double v169 = *((double *)&v181 + 1);
  double v170 = *(double *)&v181;
  do
  {
    if ((altitude::GlobeView::getDirFromScreenPosition(v50, &v179, (float)SLODWORD(v38[v86]), (float)SHIDWORD(v38[v86])) & 1) == 0)
    {
      uint64_t v158 = 0;
      goto LABEL_140;
    }
    float64x2_t v95 = v179;
    double v96 = v180;
    double v97 = v179.f64[0] * v179.f64[0] + v179.f64[1] * v179.f64[1] + v96 * v96;
    float64_t v98 = v179.f64[0] * v90 + v179.f64[1] * v91 + v180 * v178;
    double v99 = v98 + v98;
    double v100 = -(v174 * v97 - v99 * v99);
    long double v101 = 0.0;
    if (v100 >= 0.0)
    {
      double v104 = (sqrt(v100) + v99) * -0.5 / v97;
      long double v102 = 0.0;
      double v103 = v176;
      if (v104 >= 0.0)
      {
        double v166 = v104 * v179.f64[1];
        double v167 = v104 * v179.f64[0];
        double v165 = v104 * v180;
        long double v105 = v104 * v179.f64[0] + v90;
        long double v106 = v104 * v179.f64[1] + v91;
        long double v107 = v104 * v180 + v178;
        double v108 = sqrt(v105 * v105 + v106 * v106);
        long double v109 = atan2(v107, v108 * 0.996647189);
        long double v101 = atan2(v106, v105);
        double v110 = v109;
        double v90 = v170;
        __double2 v111 = __sincos_stret(v110);
        long double v112 = v107 + v111.__sinval * v111.__sinval * 42841.3115 * v111.__sinval;
        double v89 = v171;
        long double v113 = v108 + v111.__cosval * v111.__cosval * -42697.6727 * v111.__cosval;
        double v91 = v169;
        long double v102 = atan2(v112, v113);
        double v103 = sqrt(v167 * v167 + v166 * v166 + v165 * v165);
      }
    }
    else
    {
      long double v102 = 0.0;
      double v103 = v176;
    }
    if (v103 >= v89)
    {
      long double v116 = v90 + v89 * v95.f64[0];
      long double v117 = v91 + v89 * v95.f64[1];
      long double v118 = v178 + v89 * v96;
      double v119 = sqrt(v116 * v116 + v117 * v117);
      double v120 = atan2(v118, v119 * 0.996647189);
      long double v121 = atan2(v117, v116);
      __double2 v122 = __sincos_stret(v120);
      double v123 = atan2(v118 + v122.__sinval * v122.__sinval * 42841.3115 * v122.__sinval, v119 + v122.__cosval * v122.__cosval * -42697.6727 * v122.__cosval);
      double v124 = v123;
      unint64_t v126 = (unint64_t)a2[1];
      unint64_t v125 = (unint64_t)a2[2];
      if (v126 < v125)
      {
        *(double *)unint64_t v126 = v123;
        *(long double *)(v126 + 8) = v121;
        double v94 = (long double *)(v126 + 16);
        double v90 = v170;
        double v89 = v171;
        double v91 = v169;
        goto LABEL_91;
      }
      uint64_t v127 = *a2;
      uint64_t v128 = v126 - (void)*a2;
      unint64_t v129 = (v128 >> 4) + 1;
      if (v129 >> 60) {
        abort();
      }
      uint64_t v130 = v125 - (void)v127;
      if (v130 >> 3 > v129) {
        unint64_t v129 = v130 >> 3;
      }
      if ((unint64_t)v130 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v131 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v131 = v129;
      }
      double v90 = v170;
      double v89 = v171;
      double v91 = v169;
      if (v131 >> 60) {
        goto LABEL_146;
      }
      unint64_t v132 = (char *)operator new(16 * v131);
      unint64_t v133 = (long double *)&v132[16 * (v128 >> 4)];
      *unint64_t v133 = v124;
      v133[1] = v121;
      unint64_t v134 = v126 - (void)v127;
      if ((long double *)v126 == v127) {
        goto LABEL_121;
      }
      unint64_t v135 = v134 - 16;
      uint64_t v50 = v168;
      if (v134 - 16 >= 0xB0)
      {
        unint64_t v142 = v135 >> 4;
        if ((unint64_t)&v132[v128 - (v135 & 0xFFFFFFFFFFFFFFF0) - 16] >= v126
          || (double v136 = (long double *)&v132[16 * (v128 >> 4)], v126 - 16 * v142 - 16 >= (unint64_t)v133))
        {
          unint64_t v143 = v142 + 1;
          uint64_t v144 = (const double *)(v126 - 32);
          uint64_t v145 = v133 - 4;
          uint64_t v146 = v143 & 0x1FFFFFFFFFFFFFFCLL;
          do
          {
            float64x2x2_t v183 = vld2q_f64(v144);
            uint64_t v147 = v144 - 4;
            float64x2x2_t v185 = vld2q_f64(v147);
            vst2q_f64(v145, v183);
            uint64_t v148 = v145 - 4;
            vst2q_f64(v148, v185);
            v145 -= 8;
            v144 -= 8;
            v146 -= 4;
          }
          while (v146);
          double v136 = &v133[-2 * (v143 & 0x1FFFFFFFFFFFFFFCLL)];
          v126 -= 16 * (v143 & 0x1FFFFFFFFFFFFFFCLL);
          if (v143 == (v143 & 0x1FFFFFFFFFFFFFFCLL)) {
            goto LABEL_135;
          }
        }
      }
      else
      {
        double v136 = (long double *)&v132[16 * (v128 >> 4)];
      }
      do
      {
        uint64_t v149 = *(void *)(v126 - 16);
        v126 -= 16;
        *((void *)v136 - 2) = v149;
        v136 -= 2;
        v136[1] = *(long double *)(v126 + 8);
      }
      while ((long double *)v126 != v127);
    }
    else
    {
      unint64_t v115 = a2[1];
      unint64_t v114 = (unint64_t)a2[2];
      if ((unint64_t)v115 < v114)
      {
        *unint64_t v115 = v102;
        v115[1] = v101;
        double v94 = v115 + 2;
        goto LABEL_91;
      }
      uint64_t v127 = *a2;
      uint64_t v137 = (char *)v115 - (char *)*a2;
      unint64_t v138 = (v137 >> 4) + 1;
      if (v138 >> 60) {
        abort();
      }
      uint64_t v139 = v114 - (void)v127;
      if (v139 >> 3 > v138) {
        unint64_t v138 = v139 >> 3;
      }
      if ((unint64_t)v139 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v131 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v131 = v138;
      }
      if (v131 >> 60) {
        goto LABEL_146;
      }
      unint64_t v132 = (char *)operator new(16 * v131);
      unint64_t v133 = (long double *)&v132[16 * (v137 >> 4)];
      *unint64_t v133 = v102;
      v133[1] = v101;
      int64_t v140 = (char *)v115 - (char *)v127;
      if (v115 == v127)
      {
LABEL_121:
        double v136 = v133;
        uint64_t v50 = v168;
        goto LABEL_135;
      }
      unint64_t v141 = v140 - 16;
      uint64_t v50 = v168;
      if ((unint64_t)(v140 - 16) >= 0xB0)
      {
        unint64_t v150 = v141 >> 4;
        if (&v132[v137 - (v141 & 0xFFFFFFFFFFFFFFF0) - 16] >= (char *)v115
          || (double v136 = (long double *)&v132[16 * (v137 >> 4)], &v115[-2 * v150 - 2] >= v133))
        {
          unint64_t v151 = v150 + 1;
          int v152 = v115 - 4;
          uint64_t v153 = v133 - 4;
          uint64_t v154 = v151 & 0x1FFFFFFFFFFFFFFCLL;
          do
          {
            float64x2x2_t v184 = vld2q_f64(v152);
            uint64_t v155 = v152 - 4;
            float64x2x2_t v186 = vld2q_f64(v155);
            vst2q_f64(v153, v184);
            long double v156 = v153 - 4;
            vst2q_f64(v156, v186);
            v153 -= 8;
            v152 -= 8;
            v154 -= 4;
          }
          while (v154);
          double v136 = &v133[-2 * (v151 & 0x1FFFFFFFFFFFFFFCLL)];
          v115 -= 2 * (v151 & 0x1FFFFFFFFFFFFFFCLL);
          if (v151 == (v151 & 0x1FFFFFFFFFFFFFFCLL)) {
            goto LABEL_135;
          }
        }
      }
      else
      {
        double v136 = (long double *)&v132[16 * (v137 >> 4)];
      }
      do
      {
        uint64_t v157 = *((void *)v115 - 2);
        v115 -= 2;
        *((void *)v136 - 2) = v157;
        v136 -= 2;
        v136[1] = v115[1];
      }
      while (v115 != v127);
    }
LABEL_135:
    double v94 = v133 + 2;
    *a2 = v136;
    a2[1] = v133 + 2;
    a2[2] = (long double *)&v132[16 * v131];
    if (v127) {
      operator delete(v127);
    }
LABEL_91:
    a2[1] = v94;
    uint64_t v86 = ++v87;
  }
  while (v92 > v87);
  uint64_t v158 = 1;
  if (v38) {
LABEL_140:
  }
    operator delete(v38);
  return v158;
}

void sub_1A2070E5C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void altitude::GlobeView::updateCameraFrame(altitude::GlobeView *this)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  *((unsigned char *)this + 416) = 0;
  if (*((void *)this + 29) != *((void *)this + 30))
  {
    uint64_t v2 = *((void *)this + 27);
    unint64_t v3 = *(double **)v2;
    if (*(void *)v2)
    {
      if (v3[2] <= 0.0)
      {
        gettimeofday((timeval *)&v70, 0);
        double v4 = (double)v70.n128_i64[0] + (double)v70.n128_i32[2] * 0.000001 - *v3;
      }
      else
      {
        double v4 = v3[1] * 0.000001;
      }
    }
    else
    {
      double v4 = 0.0;
    }
    double v5 = *(double *)(v2 + 24);
    if (v5 == 1.0)
    {
      double v7 = *(double *)(v2 + 8);
      double v6 = *(double *)(v2 + 16);
    }
    else
    {
      double v6 = *(double *)(v2 + 16) + (v4 - *(double *)(v2 + 8)) * v5;
      *(double *)(v2 + 8) = v4;
      *(double *)(v2 + 16) = v6;
      *(void *)(v2 + 24) = 0x3FF0000000000000;
      double v7 = v4;
    }
    double v8 = v4 - v7 + v6;
    double v9 = *((double *)this + 28);
    *((double *)this + 28) = v8;
    int v10 = (double *)*((void *)this + 29);
    if (v10 != *((double **)this + 30))
    {
      double v11 = v8 - v9;
      do
      {
        while (1)
        {
          double v12 = v10[1];
          if (v12 < 0.0)
          {
            v10[1] = v8;
            double v12 = v8;
          }
          (***(void (****)(double, double))v10)(v8 - v12, v11);
          if ((*(unsigned int (**)(void))(**(void **)v10 + 8))()) {
            break;
          }
          v10 += 5;
          if (v10 == *((double **)this + 30)) {
            goto LABEL_30;
          }
        }
        if (*(void *)v10) {
          (*(void (**)(void))(**(void **)v10 + 24))(*(void *)v10);
        }
        unint64_t v13 = v10 + 5;
        uint64_t v14 = (double *)*((void *)this + 30);
        if (v10 + 5 == v14)
        {
          uint64_t v16 = v10;
        }
        else
        {
          int v15 = v10;
          do
          {
            *(_OWORD *)int v15 = *(_OWORD *)(v15 + 5);
            double v18 = (void **)(v15 + 2);
            if (*((char *)v15 + 39) < 0) {
              operator delete(*v18);
            }
            *(_OWORD *)double v18 = *(_OWORD *)(v15 + 7);
            v15[4] = v15[9];
            *((unsigned char *)v15 + 79) = 0;
            *((unsigned char *)v15 + 56) = 0;
            uint64_t v16 = v15 + 5;
            __double2 v17 = v15 + 10;
            v15 += 5;
          }
          while (v17 != v14);
          unint64_t v13 = (double *)*((void *)this + 30);
        }
        while (v13 != v16)
        {
          if (*((char *)v13 - 1) < 0) {
            operator delete(*((void **)v13 - 3));
          }
          v13 -= 5;
        }
        *((void *)this + 30) = v16;
      }
      while (v10 != v16);
    }
  }
LABEL_30:
  int v19 = (double *)*((void *)this + 9);
  if (v19[5] != *((double *)this + 42)
    || v19[6] != *((double *)this + 43)
    || v19[7] != *((double *)this + 44)
    || v19[4] != *((double *)this + 41)
    || v19[1] != *((double *)this + 38)
    || v19[2] != *((double *)this + 39)
    || v19[3] != *((double *)this + 40))
  {
    *((unsigned char *)this + 416) = 1;
    uint64_t v20 = **(void **)(*((void *)this + 107) + 88);
    if (v20)
    {
      v70.n128_u8[0] = 7;
      md::MapEngine::setNeedsTick(v20, &v70);
    }
  }
  if (*((unsigned char *)this + 632))
  {
    uint64_t v66 = *((void *)this + 58);
    uint64_t v21 = *(void *)(v66 + 224);
    pthread_mutex_lock(*(pthread_mutex_t **)(v21 + 112));
    uint64_t v22 = *(void *)(v21 + 16);
    uint64_t v23 = *(void *)(v21 + 24);
    int64_t v24 = v23 - v22;
    if (v23 == v22)
    {
      unint64_t v62 = *(pthread_mutex_t **)(v21 + 112);
      pthread_mutex_unlock(v62);
    }
    else
    {
      if (0xEEEEEEEEEEEEEEEFLL * (v24 >> 4) >= 0x111111111111112) {
        abort();
      }
      int v25 = (char *)operator new(v24);
      uint64_t v26 = 0;
      do
      {
        altitude::TriggerManager::Trigger::Trigger((altitude::TriggerManager::Trigger *)&v25[v26], (const altitude::TriggerManager::Trigger *)(v22 + v26));
        v26 += 240;
      }
      while (v22 + v26 != v23);
      uint64_t v27 = 240 * (v26 / 240);
      pthread_mutex_unlock(*(pthread_mutex_t **)(v21 + 112));
      if (v27)
      {
        uint64_t v63 = 240 * (v26 / 240);
        unint64_t v65 = &v25[v27];
        unint64_t v64 = v25;
        do
        {
          uint64_t DebugRenderUtil = altitude::Context::getDebugRenderUtil(*(altitude::Context **)(v66 + 32));
          uint64_t v29 = DebugRenderUtil;
          uint64_t v31 = (uint64_t **)(DebugRenderUtil + 32);
          uint64_t v30 = *(uint64_t **)(DebugRenderUtil + 32);
          if (!v30)
          {
            double v38 = (uint64_t **)(DebugRenderUtil + 32);
            goto LABEL_64;
          }
          uint64_t v32 = DebugRenderUtil + 32;
          uint64_t v33 = *(void *)(DebugRenderUtil + 32);
          do
          {
            int v34 = *(_DWORD *)(v33 + 32);
            BOOL v35 = v34 < 0;
            if (v34 >= 0) {
              unint64_t v36 = (uint64_t *)v33;
            }
            else {
              unint64_t v36 = (uint64_t *)(v33 + 8);
            }
            if (!v35) {
              uint64_t v32 = v33;
            }
            uint64_t v33 = *v36;
          }
          while (*v36);
          if ((uint64_t **)v32 == v31 || *(int *)(v32 + 32) > 0)
          {
            do
            {
              while (1)
              {
                double v38 = (uint64_t **)v30;
                int v39 = *((_DWORD *)v30 + 8);
                if (v39 < 1) {
                  break;
                }
                uint64_t v30 = *v38;
                uint64_t v31 = v38;
                if (!*v38) {
                  goto LABEL_64;
                }
              }
              if ((v39 & 0x80000000) == 0) {
                goto LABEL_67;
              }
              uint64_t v30 = v38[1];
            }
            while (v30);
            uint64_t v31 = v38 + 1;
LABEL_64:
            int v40 = operator new(0x30uLL);
            v40[8] = 0;
            *((void *)v40 + 5) = 0;
            *(void *)int v40 = 0;
            *((void *)v40 + 1) = 0;
            *((void *)v40 + 2) = v38;
            *uint64_t v31 = (uint64_t *)v40;
            uint64_t v41 = **(void **)(v29 + 24);
            uint64_t v42 = (uint64_t *)v40;
            if (v41)
            {
              *(void *)(v29 + 24) = v41;
              uint64_t v42 = *v31;
            }
            std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v29 + 32), v42);
            ++*(void *)(v29 + 40);
LABEL_67:
            operator new();
          }
          uint64_t v37 = v32 + 40;
          long long v43 = *(void **)v37;
          double v44 = *((double *)v25 + 8);
          uint64_t v45 = *(void *)(*(void *)v37 + 16);
          uint64_t v46 = *(void *)(*(void *)v37 + 24);
          if (v45 == v46)
          {
            (*(void (**)(__n128 *__return_ptr, void *))(*v43 + 32))(&v70, v43);
            __n128 v47 = v70;
          }
          else
          {
            __n128 v47 = *(__n128 *)(v46 - 16);
            uint64_t v48 = *(void *)(v46 - 8);
            if (v48)
            {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v48 + 8), 1uLL, memory_order_relaxed);
              uint64_t v46 = v43[3];
              float64x2_t v49 = *(std::__shared_weak_count **)(v46 - 8);
              if (v49)
              {
                if (!atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  __n128 v67 = v47;
                  ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
                  std::__shared_weak_count::__release_weak(v49);
                  __n128 v47 = v67;
                }
              }
            }
            void v43[3] = v46 - 16;
          }
          uint64_t v50 = (__n128 *)v43[6];
          uint64_t v51 = (std::__shared_weak_count *)v47.n128_u64[1];
          if ((unint64_t)v50 >= v43[7])
          {
            unint64_t v68 = v47.n128_u64[0];
            unint64_t v52 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)(v43 + 5), v47);
            v47.n128_u64[0] = v68;
          }
          else
          {
            __n128 *v50 = v47;
            if (v47.n128_u64[1]) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v47.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
            }
            unint64_t v52 = v50 + 1;
          }
          float v53 = v44;
          v43[6] = v52;
          uint64_t v54 = *(void *)(v47.n128_u64[0] + 8);
          uint64_t v75 = 0;
          long long v72 = 0u;
          uint64_t v73 = 0;
          long long v71 = 0u;
          memset(&v70.n128_i8[8], 0, 32);
          v70.n128_u64[0] = 0x3FF0000000000000;
          *(void *)&long long v71 = 0x3FF0000000000000;
          uint64_t v74 = 0x3FF0000000000000;
          uint64_t v78 = 0x3FF0000000000000;
          long long v76 = *(_OWORD *)(v25 + 40);
          uint64_t v77 = *((void *)v25 + 7);
          uint64_t v55 = *(void **)(*(void *)(v54 + 64) + 16);
          unint64_t v56 = v55[1];
          uint64_t v57 = v55[9];
          *(_OWORD *)uint64_t v57 = xmmword_1A28FE130;
          *(float *)(v57 + 32) = v53;
          *(float *)(v57 + 36) = v53;
          *(float *)(v57 + 40) = v53;
          gm::operator*<double,4,4,4>(v69[0].f64, (double *)(v43[1] + 192), v70.n128_f64);
          float32x4_t v58 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v69[2]), v69[3]);
          *(float32x4_t *)(v57 + 48) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v69[0]), v69[1]);
          *(float32x4_t *)(v57 + 64) = v58;
          float32x4_t v59 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v69[6]), v69[7]);
          *(float32x4_t *)(v57 + 80) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v69[4]), v69[5]);
          *(float32x4_t *)(v57 + 96) = v59;
          unint64_t v60 = v55[8];
          if (v60 <= v56) {
            unint64_t v60 = v56;
          }
          v55[7] = 0;
          v55[8] = v60;
          if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
            std::__shared_weak_count::__release_weak(v51);
          }
          v25 += 240;
        }
        while (v25 != v65);
        uint64_t v61 = v63;
        int v25 = v64;
        if (v64 != v65)
        {
          do
          {
            (**(void (***)(void))&v64[v61 - 240])();
            v61 -= 240;
          }
          while (v61);
        }
      }
      operator delete(v25);
    }
  }
}

void altitude::GlobeView::update(altitude::GlobeView *this)
{
  MainTileLoaderStatistics = altitude::GlobeView::getMainTileLoaderStatistics(*((altitude::GlobeView **)this + 58), *((void *)this + 66));
  double v4 = MainTileLoaderStatistics;
  if (!*(unsigned char *)(*(void *)(*((void *)this + 107) + 136) + 69)
    || (unsigned int v5 = *((_DWORD *)MainTileLoaderStatistics + 1), v5 >= 2)
    && (LODWORD(v3) = *((_DWORD *)MainTileLoaderStatistics + 3), (double)v3 / (double)v5 >= 1.0))
  {
    double v6 = (altitude::QuickSurfaceManager *)*((void *)this + 88);
    altitude::QuickSurfaceManager::clear(v6);
    *((unsigned char *)v6 + 64) = 0;
  }
  uint64_t v7 = *((void *)this + 58);
  if (v7)
  {
    if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 40))(v7))
    {
      unsigned int v8 = *((_DWORD *)v4 + 1);
      if (v8) {
        unsigned __int8 v9 = *((_DWORD *)v4 + 5) < v8;
      }
      else {
        unsigned __int8 v9 = 1;
      }
    }
    else
    {
      unsigned __int8 v9 = 0;
    }
    atomic_store(v9, (unsigned __int8 *)this + 832);
  }
  else
  {
    atomic_store(0, (unsigned __int8 *)this + 832);
  }
  pthread_mutex_lock(*((pthread_mutex_t **)this + 75));
  if (*((unsigned char *)this + 416) || *((void *)this + 74) >= 0x21uLL)
  {
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 73));
    *((void *)this + 72) = (char *)this + 584;
    *((void *)this + 74) = 0;
    *((void *)this + 73) = 0;
  }
  pthread_mutex_unlock(*((pthread_mutex_t **)this + 75));
  uint64_t v10 = *((void *)this + 53);
  if (v10 && *(unsigned char *)(v10 + 88))
  {
    uint64_t v11 = *(void *)(v10 + 16);
    double v12 = *(altitude::GlobeCleanupLoader **)(v11 + 448);
    if (v12)
    {
      unsigned int v13 = *(_DWORD *)(*((void *)v12 + 4) + 88) + 1;
      altitude::GlobeCleanupLoader::pruneLabelDataComponents(v12, v13, v13);
      uint64_t v11 = *(void *)(v10 + 16);
    }
    uint64_t v14 = *(void ***)(*(void *)(*(void *)(*(void *)(*(void *)(*(void *)(v11 + 856) + 136) + 8) + 40)
                                  + 40)
                      + 56);
    if (v14)
    {
      (*(void (**)(void *))(*v14[13] + 120))(v14[13]);
      (*(void (**)(void *))(*v14[14] + 120))(v14[14]);
      (*(void (**)(void *))(*v14[15] + 120))(v14[15]);
      (*(void (**)(void *))(*v14[16] + 120))(v14[16]);
    }
    *(unsigned char *)(v10 + 88) = 0;
  }
  int v15 = (unsigned int *)*((void *)this + 4);
  if (v15)
  {
    *((unsigned char *)v15 + 65) = 0;
    uint64_t v16 = *((void *)v15 + 4);
    if (!v16)
    {
      *((unsigned char *)v15 + 64) = 0;
      goto LABEL_56;
    }
    __double2 v17 = (unsigned int *)*((void *)v15 + 2);
    uint64_t v18 = *v15;
    unint64_t v19 = v16 - 1;
    if (v19 <= v18)
    {
      unsigned int *v15 = 0;
    }
    else if (v18)
    {
      do
      {
        uint64_t v21 = (unsigned int *)*((void *)v17 + 1);
        if (v21)
        {
          do
          {
            uint64_t v22 = v21;
            uint64_t v21 = *(unsigned int **)v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            uint64_t v22 = (unsigned int *)*((void *)v17 + 2);
            BOOL v23 = *(void *)v22 == (void)v17;
            __double2 v17 = v22;
          }
          while (!v23);
        }
        __double2 v17 = v22;
      }
      while (v18-- > 1);
      goto LABEL_38;
    }
    uint64_t v22 = v17;
LABEL_38:
    if (v19 >= *((void *)v15 + 1)) {
      unint64_t v19 = *((void *)v15 + 1);
    }
    *((void *)v15 + 1) = v19;
    if (v22 != v15 + 6)
    {
      int v24 = 10;
      unsigned int v25 = 100;
      do
      {
        if (altitude::Anchor::update(*((altitude::Anchor **)v22 + 4)))
        {
          --v24;
          *((unsigned char *)v15 + 65) = 1;
        }
        if (*(unsigned char *)(*((void *)v22 + 4) + 96))
        {
          *((unsigned char *)v15 + 64) = 1;
          uint64_t v26 = *v15;
          *((void *)v15 + 1) = v26;
        }
        else
        {
          uint64_t v26 = *v15;
          if (*((void *)v15 + 1) == v26) {
            *((unsigned char *)v15 + 64) = 0;
          }
        }
        unsigned int *v15 = v26 + 1;
        uint64_t v27 = (unsigned int *)*((void *)v22 + 1);
        if (v27)
        {
          do
          {
            int v28 = v27;
            uint64_t v27 = *(unsigned int **)v27;
          }
          while (v27);
        }
        else
        {
          do
          {
            int v28 = (unsigned int *)*((void *)v22 + 2);
            BOOL v23 = *(void *)v28 == (void)v22;
            uint64_t v22 = v28;
          }
          while (!v23);
        }
        if (v24 < 1) {
          break;
        }
        if (v25 < 2) {
          break;
        }
        --v25;
        uint64_t v22 = v28;
      }
      while (v28 != v15 + 6);
    }
  }
LABEL_56:
  uint64_t v29 = *((void *)this + 78);
  if (!v29) {
    goto LABEL_152;
  }
  uint64_t v30 = *(void *)(v29 + 80);
  if (!v30 || *(_DWORD *)(v29 + 116) != 1) {
    goto LABEL_152;
  }
  uint64_t v31 = *(void **)(v29 + 184);
  uint64_t v32 = *(void *)(*(void *)(v30 + 8) + 120) + 32 * *(unsigned int *)(v30 + 24);
  if (*(char *)(v32 + 31) < 0) {
    uint64_t v33 = *(void *)(v32 + 16);
  }
  else {
    uint64_t v33 = *(unsigned __int8 *)(v32 + 31);
  }
  double v34 = fmin(*(double *)(*(void *)(v29 + 32) + 96), 0.0666666667);
  double v35 = *(double *)(v31[9] + 32);
  uint64_t v36 = v31[58];
  unint64_t v37 = v31[64];
  int v39 = (uint64_t **)(v36 + 96);
  double v38 = *(char **)(v36 + 96);
  if (v38)
  {
    while (1)
    {
      while (1)
      {
        int v40 = v38;
        unint64_t v41 = *((void *)v38 + 4);
        if (v41 <= v37) {
          break;
        }
        double v38 = *(char **)v40;
        int v39 = (uint64_t **)v40;
        if (!*(void *)v40) {
          goto LABEL_69;
        }
      }
      if (v41 >= v37) {
        break;
      }
      double v38 = (char *)*((void *)v40 + 1);
      if (!v38)
      {
        int v39 = (uint64_t **)(v40 + 8);
        goto LABEL_69;
      }
    }
  }
  else
  {
    int v40 = (char *)(v36 + 96);
LABEL_69:
    uint64_t v42 = v40;
    int v40 = (char *)operator new(0x60uLL);
    *((void *)v40 + 4) = v37;
    *(_OWORD *)(v40 + 40) = 0u;
    *(_OWORD *)(v40 + 56) = 0u;
    *((void *)v40 + 9) = 0;
    *((_OWORD *)v40 + 5) = xmmword_1A28FD0E0;
    *(void *)int v40 = 0;
    *((void *)v40 + 1) = 0;
    *((void *)v40 + 2) = v42;
    unint64_t *v39 = (uint64_t *)v40;
    uint64_t v43 = **(void **)(v36 + 88);
    double v44 = (uint64_t *)v40;
    if (v43)
    {
      *(void *)(v36 + 88) = v43;
      double v44 = *v39;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v36 + 96), v44);
    ++*(void *)(v36 + 104);
  }
  float v45 = v34;
  float v46 = fminf(fmaxf(*(float *)(v29 + 92), *(float *)(v29 + 88)), *(float *)(v29 + 88) + 30.0);
  *(float *)(v29 + 92) = v46;
  unsigned int v47 = *((_DWORD *)v40 + 11);
  if (!v47 || (float)((float)*((unsigned int *)v40 + 15) / (float)v47) > 0.6)
  {
    float v48 = v46 + v45 * 3.0;
    *(float *)(v29 + 92) = v48;
  }
  float64x2_t v49 = altitude::GlobeView::getMainTileLoaderStatistics(*(altitude::GlobeView **)(*(void *)(v29 + 184) + 464), *(void *)(*(void *)(v29 + 184) + 528));
  double v51 = *(double *)(v29 + 104);
  unsigned int v52 = *((_DWORD *)v49 + 1);
  if (v52)
  {
    float v53 = *(float *)(v29 + 112);
    if (fabsf(v53 + -1.0) <= 0.001)
    {
      LODWORD(v50) = *((_DWORD *)v49 + 2);
      double v55 = (double)v50 / (double)v52;
      float v56 = v55;
      LODWORD(v55) = *((_DWORD *)v49 + 4);
      *(float *)&double v55 = 1.0 - (double)*(unint64_t *)&v55 / (double)v52;
      float v57 = fminf(cbrtf(*(float *)&v55), v56);
      if (v35 < 5000000.0)
      {
        float v58 = 1.0;
        float v59 = fminf(fmaxf((float)(*(float *)(v29 + 92) - *(float *)(v29 + 88)) * 0.04, 0.0), 1.0);
        if (v33) {
          float v58 = v59;
        }
        float v57 = fminf(fmaxf(v58 * v59, 0.2), v57);
      }
      float v60 = v57 - v51;
      double v54 = v51 + (float)((float)(v45 * 0.1) * v60);
    }
    else
    {
      double v54 = v53;
    }
  }
  else
  {
    double v54 = 0.0;
  }
  *(double *)(v29 + 104) = v54;
  unint64_t v61 = (unint64_t)(100.0 - v54 * 100.0);
  if (ggl::Performance::Counters::instance(void)::onceToken[0] != -1) {
    dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_53878);
  }
  atomic_store(v61, (unint64_t *)(*(void *)(ggl::Performance::Counters::instance(void)::counters + 32) + 168));
  double v62 = *(double *)(v29 + 104);
  if (v62 < 0.800000012 && v51 > 0.800000012)
  {
    char v63 = 1;
LABEL_92:
    *(unsigned char *)(v29 + 252) = v63;
    goto LABEL_93;
  }
  if (v62 > 0.800000012 && v51 < 0.800000012)
  {
    char v63 = 0;
    goto LABEL_92;
  }
LABEL_93:
  float v64 = v62 * v45;
  float v65 = fmaxf(*(float *)(v29 + 88) + v64, 0.0);
  *(float *)(v29 + 88) = v65;
  uint64_t v66 = *(void *)(v29 + 80);
  double v67 = v65;
  *(double *)(v66 + 32) = v67;
  uint64_t v68 = *(void *)(v66 + 8);
  if (!v68) {
    goto LABEL_121;
  }
  uint64_t v69 = *(unsigned int *)(v66 + 16);
  unint64_t v70 = *(unsigned int *)(v66 + 24);
  double v71 = v67 / *(double *)(v68 + 144);
  uint64_t v72 = *(void *)(v68 + 120);
  if (v71 >= *(float *)(v72 + 32 * v70 + 4))
  {
    unint64_t v76 = ((*(void *)(v68 + 128) - v72) >> 5) - 1;
    if (v76 > v70)
    {
      uint64_t v73 = *(unsigned int *)(v66 + 24);
      unsigned int v77 = *(_DWORD *)(v66 + 24);
      while (v71 >= *(float *)(v72 + 32 * v73 + 4))
      {
        uint64_t v73 = ++v77;
        if (v76 <= v77) {
          goto LABEL_109;
        }
      }
      LODWORD(v73) = v77;
      goto LABEL_109;
    }
  }
  else if (v70)
  {
    LODWORD(v73) = *(_DWORD *)(v66 + 24);
    if (v71 < *(float *)(v72 + 32 * v70))
    {
      uint64_t v74 = (float *)(v72 + 32 * v70);
      int v75 = *(_DWORD *)(v66 + 24);
      while (v71 < *v74)
      {
        v74 -= 8;
        if (!--v75)
        {
          LODWORD(v73) = 0;
          goto LABEL_109;
        }
      }
      LODWORD(v73) = v75;
    }
    goto LABEL_109;
  }
  LODWORD(v73) = *(_DWORD *)(v66 + 24);
LABEL_109:
  *(_DWORD *)(v66 + 24) = v73;
  uint64_t v78 = *(void *)(v68 + 72);
  if (v71 >= *(double *)(v78 + 8 * v69))
  {
    unsigned int v80 = v69;
    do
    {
      LODWORD(v79) = v80;
      if (((*(void *)(v68 + 80) - v78) >> 3) - 1 <= (unint64_t)v80) {
        break;
      }
      ++v80;
    }
    while (v71 > *(double *)(v78 + 8 * v80));
  }
  else if (v69)
  {
    uint64_t v79 = v69;
    do
    {
      if (v71 >= *(double *)(v78 + 8 * v79)) {
        break;
      }
      --v79;
    }
    while (v79);
  }
  else
  {
    LODWORD(v79) = 0;
  }
  *(_DWORD *)(v66 + 16) = v79;
  *(unsigned char *)(v66 + 42) = v70 != v73;
  *(unsigned char *)(v66 + 40) = (v79 - v69) > 1;
LABEL_121:
  uint64_t v81 = *(void *)(v29 + 176);
  if (v81 && *(unsigned char *)(v66 + 42))
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v81 + 48))(v81, *(void *)(v68 + 120) + 32 * *(unsigned int *)(v66 + 24) + 8);
    uint64_t v66 = *(void *)(v29 + 80);
    uint64_t v68 = *(void *)(v66 + 8);
  }
  if (v68)
  {
    *(double *)v82.i64 = altitude::AnimationData::interpolateFrames((altitude::AnimationData *)&v203, *(double *)(v66 + 32), v68, *(_DWORD *)(v66 + 16));
  }
  else
  {
    int64x2_t v82 = vdupq_n_s64(0xC00921FB54442D18);
    int64x2_t v203 = v82;
    float64x2_t v204 = 0u;
    long long v205 = 0u;
    double v206 = 0.0;
  }
  v82.i32[0] = *(_DWORD *)(v29 + 248);
  if (*(float *)v82.i32 > 0.0)
  {
    *(float *)v82.i32 = 1.0 - *(float *)v82.i32;
    (*((void (**)(double))VKAnimationCurveEaseOut + 2))(*(double *)v82.i64);
    double v83 = *(double *)(v29 + 192);
    double v198 = v84;
    long double v85 = fmod(3.14159265 - v83 + *(double *)v203.i64, 6.28318531);
    long double v86 = fmod(v85 + 6.28318531, 6.28318531);
    long double v87 = fmod(v83 + 3.14159265 + (v86 + -3.14159265) * v198, 6.28318531);
    long double v88 = fmod(v87 + 6.28318531, 6.28318531) + -3.14159265;
    double v89 = *(double *)(v29 + 200);
    long double v90 = fmod(3.14159265 - v89 + *(double *)&v203.i64[1], 6.28318531);
    long double v91 = fmod(v90 + 6.28318531, 6.28318531);
    long double v92 = fmod(v89 + 3.14159265 + (v91 + -3.14159265) * v198, 6.28318531);
    long double v93 = fmod(v92 + 6.28318531, 6.28318531) + -3.14159265;
    double v94 = *(double *)(v29 + 232);
    long double v95 = fmod(3.14159265 - v94 + *((double *)&v205 + 1), 6.28318531);
    long double v96 = fmod(v95 + 6.28318531, 6.28318531);
    long double v97 = fmod(v94 + 3.14159265 + (v96 + -3.14159265) * v198, 6.28318531);
    long double v98 = fmod(v97 + 6.28318531, 6.28318531);
    double v99 = *(double *)(v29 + 224) + (*(double *)&v205 - *(double *)(v29 + 224)) * v198;
    double v100 = *(double *)(v29 + 240) + (v206 - *(double *)(v29 + 240)) * v198;
    *(long double *)v203.i64 = v88;
    *(long double *)&v203.i64[1] = v93;
    float64x2_t v204 = vmlaq_n_f64(*(float64x2_t *)(v29 + 208), vsubq_f64(v204, *(float64x2_t *)(v29 + 208)), v198);
    *(double *)&long long v205 = v99;
    *((double *)&v205 + 1) = v98 + -3.14159265;
    double v206 = v100;
    *(float *)(v29 + 248) = *(float *)(v29 + 248) + (float)(v45 * -0.66667);
  }
  uint64_t v101 = *(void *)(v29 + 184);
  uint64_t v102 = *(void *)(v101 + 72);
  *(int64x2_t *)(v102 + 8) = v203;
  *(float64x2_t *)(v102 + 24) = v204;
  *(_OWORD *)(v102 + 40) = v205;
  *(double *)(v102 + 56) = v206;
  ++*(_DWORD *)(v101 + 376);
  if (v35 >= 5000000.0)
  {
    float v103 = *(float *)(v29 + 88);
    *(float *)(v29 + 92) = v103;
  }
  else
  {
    float v103 = *(float *)(v29 + 92);
  }
  uint64_t v104 = *(void *)(v29 + 80);
  uint64_t v105 = *(void *)(v104 + 8);
  if (v105)
  {
    double v106 = v103;
    double v107 = v106 / *(double *)(v105 + 144);
    uint64_t v108 = *(unsigned int *)(v104 + 20);
    uint64_t v109 = *(void *)(v105 + 72);
    if (v107 >= *(double *)(v109 + 8 * v108))
    {
      do
      {
        unsigned int v110 = v108;
        if (((*(void *)(v105 + 80) - v109) >> 3) - 1 <= (unint64_t)v108) {
          break;
        }
        LODWORD(v108) = v108 + 1;
      }
      while (v107 > *(double *)(v109 + 8 * v108));
    }
    else if (v108)
    {
      while (v107 < *(double *)(v109 + 8 * v108))
      {
        if (!--v108) {
          goto LABEL_137;
        }
      }
      unsigned int v110 = v108;
    }
    else
    {
LABEL_137:
      unsigned int v110 = 0;
    }
    *(_DWORD *)(v104 + 20) = v110;
    altitude::AnimationData::interpolateFrames((altitude::AnimationData *)&v199, v106, v105, v110);
    uint64_t v112 = *((void *)&v200 + 1);
    uint64_t v114 = *((void *)&v201 + 1);
    uint64_t v113 = v201;
    uint64_t v115 = *(void *)(*(void *)(v29 + 80) + 8);
    uint64_t v111 = *(void *)(v29 + 184);
    if (v115)
    {
      double v116 = *(double *)(v115 + 144);
      goto LABEL_146;
    }
  }
  else
  {
    int64x2_t v199 = vdupq_n_s64(0xC00921FB54442D18);
    long long v200 = 0u;
    long long v201 = 0u;
    uint64_t v202 = 0;
    uint64_t v111 = *(void *)(v29 + 184);
    uint64_t v112 = 0;
    uint64_t v113 = 0;
    uint64_t v114 = 0;
  }
  double v116 = 0.0;
LABEL_146:
  *(double *)(v111 + 264) = v116 - *(float *)(v29 + 88);
  *(std::chrono::steady_clock::time_point *)(v111 + 256) = std::chrono::steady_clock::now();
  long double v117 = *(int64x2_t **)(v111 + 504);
  if (v117)
  {
    v117[4].i64[0] = v200;
    v117[3] = v199;
    v117[4].i64[1] = v112;
    v117[5].i64[0] = v113;
    v117[5].i64[1] = v114;
    if (*(void *)(v111 + 504)) {
      *(void *)(*(void *)(v111 + 512) + 1296) = 0xF424000000002;
    }
  }
  double v118 = *(float *)(v29 + 88);
  uint64_t v119 = *(void *)(*(void *)(v29 + 80) + 8);
  if (!v119)
  {
    if (v118 < 0.0) {
      goto LABEL_152;
    }
    goto LABEL_151;
  }
  if (*(double *)(v119 + 144) <= v118) {
LABEL_151:
  }
    altitude::FlyoverTour::stopTour((_DWORD *)v29);
LABEL_152:
  if ((double)(std::chrono::steady_clock::now().__d_.__rep_ - *((void *)this + 32)) * 0.000000001 >= *((double *)this + 33))
  {
    uint64_t v120 = *((void *)this + 64);
    if (v120)
    {
      if (*(_DWORD *)(v120 + 1296))
      {
        *(_DWORD *)(v120 + 1296) = 0;
        *(_DWORD *)(*((void *)this + 98) + 1296) = 2;
      }
    }
  }
  uint64_t v121 = *((void *)this + 65);
  if (v121)
  {
    uint64_t v122 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v121 + 24))(v121, 0, 0xFFFFFFFFLL);
    uint64_t v123 = *((void *)this + 98);
    karo::graphics::View::copyView(v122, v123);
    *(unsigned char *)(v122 + 1291) = *(unsigned char *)(v123 + 1291);
    *(_DWORD *)(v122 + 1320) = *(_DWORD *)(v123 + 1320);
    *(void *)(v122 + 1328) = *(void *)(v123 + 1328);
    *(void *)(v122 + 1336) = *(void *)(v123 + 1336);
    *(_DWORD *)(v122 + 1344) = *(_DWORD *)(v123 + 1344);
    long long v124 = *(_OWORD *)(v123 + 1352);
    long long v125 = *(_OWORD *)(v123 + 1368);
    *(void *)(v122 + 1384) = *(void *)(v123 + 1384);
    *(_OWORD *)(v122 + 1352) = v124;
    *(_OWORD *)(v122 + 1368) = v125;
    *(_DWORD *)(v122 + 1392) = *(_DWORD *)(v123 + 1392);
    *(void *)(v122 + 1400) = *(void *)(v123 + 1400);
    *(void *)(v122 + 1408) = *(void *)(v123 + 1408);
    *(void *)(v122 + 1416) = *(void *)(v123 + 1416);
    *(void *)(v122 + 1424) = *(void *)(v123 + 1424);
    *(void *)(v122 + 1432) = *(void *)(v123 + 1432);
    *(void *)(v122 + 1440) = *(void *)(v123 + 1440);
    *(void *)(v122 + 1448) = *(void *)(v123 + 1448);
    *(void *)(v122 + 1456) = *(void *)(v123 + 1456);
  }
  if (*((unsigned char *)this + 544))
  {
    uint64_t v126 = (*(uint64_t (**)(void))(**((void **)this + 57) + 56))(*((void *)this + 57));
    uint64_t v128 = *(const void **)v126;
    uint64_t v127 = *(void *)(v126 + 8);
    int64_t v129 = v127 - *(void *)v126;
    if (v127 == *(void *)v126)
    {
      unint64_t v131 = 0;
      uint64_t v130 = 0;
    }
    else
    {
      if (v129 < 0) {
        abort();
      }
      uint64_t v130 = (char *)operator new(v127 - *(void *)v126);
      unint64_t v131 = &v130[8 * (v129 >> 3)];
      memcpy(v130, v128, v129);
    }
    unint64_t v132 = 0;
    int v133 = 0;
    v203.i64[1] = 0;
    v204.f64[0] = 0.0;
    v203.i64[0] = (uint64_t)&v203.i64[1];
    __p = v130;
    while (1)
    {
      unint64_t v134 = (uint64_t **)&v203.i64[1];
      unint64_t v135 = (uint64_t **)&v203.i64[1];
      if (v132)
      {
        do
        {
          while (1)
          {
            unint64_t v135 = (uint64_t **)v132;
            int v136 = *((_DWORD *)v132 + 8);
            if (v136 <= v133) {
              break;
            }
            unint64_t v132 = *v135;
            unint64_t v134 = v135;
            if (!*v135) {
              goto LABEL_172;
            }
          }
          if (v136 >= v133)
          {
            unint64_t v138 = v135;
            goto LABEL_175;
          }
          unint64_t v132 = v135[1];
        }
        while (v132);
        unint64_t v134 = v135 + 1;
      }
LABEL_172:
      unint64_t v138 = operator new(0x40uLL);
      v138[8] = v133;
      *((void *)v138 + 6) = 0;
      *((void *)v138 + 7) = 0;
      *((void *)v138 + 5) = 0;
      *(void *)unint64_t v138 = 0;
      *((void *)v138 + 1) = 0;
      *((void *)v138 + 2) = v135;
      *unint64_t v134 = (uint64_t *)v138;
      uint64_t v137 = (uint64_t *)v138;
      if (*(void *)v203.i64[0])
      {
        v203.i64[0] = *(void *)v203.i64[0];
        uint64_t v137 = *v134;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v203.i64[1], v137);
      ++*(void *)&v204.f64[0];
LABEL_175:
      ++v133;
      *((void *)v138 + 5) = 0;
      *((void *)v138 + 6) = 0;
      *((void *)v138 + 7) = 0;
      if (v133 == 24) {
        break;
      }
      unint64_t v132 = (uint64_t *)v203.i64[1];
    }
    for (; v130 != v131; v130 += 8)
    {
      uint64_t v139 = *(void *)v130;
      int v140 = *(_DWORD *)(*(void *)v130 + 392);
      unint64_t v141 = (uint64_t *)v203.i64[1];
      unint64_t v142 = (uint64_t **)&v203.i64[1];
      unint64_t v143 = (uint64_t **)&v203.i64[1];
      if (v203.i64[1])
      {
        do
        {
          while (1)
          {
            unint64_t v143 = (uint64_t **)v141;
            int v144 = *((_DWORD *)v141 + 8);
            if (v144 <= v140) {
              break;
            }
            unint64_t v141 = *v143;
            unint64_t v142 = v143;
            if (!*v143) {
              goto LABEL_188;
            }
          }
          if (v144 >= v140)
          {
            uint64_t v146 = v143;
            goto LABEL_191;
          }
          unint64_t v141 = v143[1];
        }
        while (v141);
        unint64_t v142 = v143 + 1;
      }
LABEL_188:
      uint64_t v146 = operator new(0x40uLL);
      v146[8] = v140;
      *((void *)v146 + 6) = 0;
      *((void *)v146 + 7) = 0;
      *((void *)v146 + 5) = 0;
      *(void *)uint64_t v146 = 0;
      *((void *)v146 + 1) = 0;
      *((void *)v146 + 2) = v143;
      *unint64_t v142 = (uint64_t *)v146;
      uint64_t v145 = (uint64_t *)v146;
      if (*(void *)v203.i64[0])
      {
        v203.i64[0] = *(void *)v203.i64[0];
        uint64_t v145 = *v142;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v203.i64[1], v145);
      ++*(void *)&v204.f64[0];
LABEL_191:
      ++v146[10];
      uint64_t v147 = *(void **)(v139 + 328);
      if (v147)
      {
        uint64_t v148 = v147[15];
        uint64_t v149 = (std::__shared_weak_count *)v147[16];
        v199.i64[0] = v148;
        v199.i64[1] = (uint64_t)v149;
        if (v149) {
          atomic_fetch_add_explicit(&v149->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v148)
        {
          unint64_t v150 = (uint64_t **)&v203.i64[1];
          unint64_t v151 = *(uint64_t **)(v148 + 48);
          int v152 = *(uint64_t **)(v148 + 56);
          int v153 = *(_DWORD *)(v139 + 392);
          uint64_t v154 = (uint64_t **)&v203.i64[1];
          uint64_t v155 = (uint64_t *)v203.i64[1];
          if (v203.i64[1])
          {
            do
            {
              while (1)
              {
                unint64_t v150 = (uint64_t **)v155;
                int v156 = *((_DWORD *)v155 + 8);
                if (v156 <= v153) {
                  break;
                }
                uint64_t v155 = *v150;
                uint64_t v154 = v150;
                if (!*v150) {
                  goto LABEL_203;
                }
              }
              if (v156 >= v153)
              {
                uint64_t v158 = v152;
                long double v159 = v151;
                uint64_t v160 = v150;
                goto LABEL_206;
              }
              uint64_t v155 = v150[1];
            }
            while (v155);
            uint64_t v154 = v150 + 1;
          }
LABEL_203:
          uint64_t v160 = operator new(0x40uLL);
          v160[8] = v153;
          *((void *)v160 + 6) = 0;
          *((void *)v160 + 7) = 0;
          *((void *)v160 + 5) = 0;
          *(void *)uint64_t v160 = 0;
          *((void *)v160 + 1) = 0;
          *((void *)v160 + 2) = v150;
          *uint64_t v154 = (uint64_t *)v160;
          uint64_t v157 = (uint64_t *)v160;
          if (*(void *)v203.i64[0])
          {
            v203.i64[0] = *(void *)v203.i64[0];
            uint64_t v157 = *v154;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v203.i64[1], v157);
          ++*(void *)&v204.f64[0];
          long double v159 = *(uint64_t **)(v199.i64[0] + 48);
          uint64_t v158 = *(uint64_t **)(v199.i64[0] + 56);
LABEL_206:
          v160[11] += (unint64_t)((char *)v152 - (char *)v151) >> 3;
          if (v159 == v158)
          {
            unint64_t v161 = 0;
          }
          else
          {
            unint64_t v161 = 0;
            do
            {
              uint64_t v167 = *v159;
              uint64_t v168 = *(void *)(*v159 + 256);
              uint64_t v169 = *(void *)(*v159 + 264);
              while (v168 != v169)
              {
                uint64_t v170 = *(void *)(*(void *)v168 + 16);
                if (v170) {
                  v161 += ggl::pixelFormatPixelsSize(*(_DWORD *)(v170 + 68), *(unsigned int *)(v170 + 80), *(unsigned int *)(v170 + 84));
                }
                v168 += 8;
              }
              uint64_t v162 = *(void *)(v167 + 216);
              uint64_t v163 = **(void ***)(v162 + 64);
              unint64_t v164 = v163[6] - v163[5];
              double v165 = *(void **)(v162 + 96);
              unint64_t v166 = v165[6] - v165[5];
              unint64_t v161 = v161 + v164 - v166 % v165[1] - v164 % v163[1] + v166;
              ++v159;
            }
            while (v159 != v158);
          }
          int v171 = *(_DWORD *)(v139 + 392);
          uint64_t v172 = (uint64_t *)v203.i64[1];
          uint64_t v173 = (uint64_t **)&v203.i64[1];
          double v174 = (uint64_t **)&v203.i64[1];
          if (v203.i64[1])
          {
            uint64_t v175 = (uint64_t *)v203.i64[1];
            do
            {
              while (1)
              {
                uint64_t v173 = (uint64_t **)v175;
                int v176 = *((_DWORD *)v175 + 8);
                if (v176 <= v171) {
                  break;
                }
                uint64_t v175 = *v173;
                double v174 = v173;
                if (!*v173) {
                  goto LABEL_223;
                }
              }
              if (v176 >= v171)
              {
                double v178 = v173;
                goto LABEL_226;
              }
              uint64_t v175 = v173[1];
            }
            while (v175);
            double v174 = v173 + 1;
          }
LABEL_223:
          double v178 = operator new(0x40uLL);
          v178[8] = v171;
          *((void *)v178 + 6) = 0;
          *((void *)v178 + 7) = 0;
          *((void *)v178 + 5) = 0;
          *(void *)double v178 = 0;
          *((void *)v178 + 1) = 0;
          *((void *)v178 + 2) = v173;
          *double v174 = (uint64_t *)v178;
          uint64_t v177 = (uint64_t *)v178;
          if (*(void *)v203.i64[0])
          {
            v203.i64[0] = *(void *)v203.i64[0];
            uint64_t v177 = *v174;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v203.i64[1], v177);
          uint64_t v172 = (uint64_t *)v203.i64[1];
          ++*(void *)&v204.f64[0];
          int v171 = *(_DWORD *)(v139 + 392);
LABEL_226:
          *((void *)v178 + 7) += v161;
          uint64_t v179 = v147[19];
          uint64_t v180 = v147[20];
          long long v181 = (uint64_t **)&v203.i64[1];
          double v182 = (uint64_t **)&v203.i64[1];
          if (v172)
          {
            do
            {
              while (1)
              {
                double v182 = (uint64_t **)v172;
                int v183 = *((_DWORD *)v172 + 8);
                if (v183 <= v171) {
                  break;
                }
                uint64_t v172 = *v182;
                long long v181 = v182;
                if (!*v182) {
                  goto LABEL_234;
                }
              }
              if (v183 >= v171)
              {
                float64x2x2_t v185 = v182;
                goto LABEL_237;
              }
              uint64_t v172 = v182[1];
            }
            while (v172);
            long long v181 = v182 + 1;
          }
LABEL_234:
          float64x2x2_t v185 = operator new(0x40uLL);
          v185[8] = v171;
          *((void *)v185 + 6) = 0;
          *((void *)v185 + 7) = 0;
          *((void *)v185 + 5) = 0;
          *(void *)float64x2x2_t v185 = 0;
          *((void *)v185 + 1) = 0;
          *((void *)v185 + 2) = v182;
          *long long v181 = (uint64_t *)v185;
          float64x2x2_t v184 = (uint64_t *)v185;
          if (*(void *)v203.i64[0])
          {
            v203.i64[0] = *(void *)v203.i64[0];
            float64x2x2_t v184 = *v181;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v203.i64[1], v184);
          ++*(void *)&v204.f64[0];
LABEL_237:
          int v186 = v185[12];
          if (v179 != v180) {
            ++v186;
          }
          v185[12] = v186;
          uint64_t v149 = (std::__shared_weak_count *)v199.i64[1];
        }
        if (v149 && !atomic_fetch_add(&v149->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v149->__on_zero_shared)(v149);
          std::__shared_weak_count::__release_weak(v149);
        }
      }
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"Tiles: ", 7);
    double v187 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v187, (uint64_t)"\n", 1);
    unint64_t v188 = (int *)v203.i64[0];
    if ((unint64_t *)v203.i64[0] != &v203.u64[1])
    {
      do
      {
        if (v188[10] >= 1)
        {
          uint64_t v189 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v189, (uint64_t)":\t", 2);
          uint64_t v190 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v190, (uint64_t)" (", 2);
          uint64_t v191 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v191, (uint64_t)"%, ", 3);
          double v192 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v192, (uint64_t)" re, ", 5);
          double v193 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v193, (uint64_t)" hires, ", 8);
          double v194 = (void *)std::ostream::operator<<();
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v194, (uint64_t)" kB)\n", 5);
        }
        double v195 = (unint64_t *)*((void *)v188 + 1);
        if (v195)
        {
          do
          {
            uint64_t v196 = v195;
            double v195 = (unint64_t *)*v195;
          }
          while (v195);
        }
        else
        {
          do
          {
            uint64_t v196 = (unint64_t *)*((void *)v188 + 2);
            BOOL v23 = *v196 == (void)v188;
            unint64_t v188 = (int *)v196;
          }
          while (!v23);
        }
        unint64_t v188 = (int *)v196;
      }
      while (v196 != &v203.u64[1]);
    }
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy((void *)v203.i64[1]);
    if (__p) {
      operator delete(__p);
    }
  }
}

void sub_1A2073360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

char *altitude::GlobeView::getMainTileLoaderStatistics(altitude::GlobeView *this, uint64_t a2)
{
  unint64_t v3 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 24))(a2, 0, 0xFFFFFFFFLL);
  unint64_t v4 = v3;
  double v6 = (uint64_t **)((char *)this + 96);
  unsigned int v5 = (char *)*((void *)this + 12);
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = v5;
        unint64_t v8 = *((void *)v5 + 4);
        if (v8 <= v3) {
          break;
        }
        unsigned int v5 = *(char **)v7;
        double v6 = (uint64_t **)v7;
        if (!*(void *)v7) {
          goto LABEL_8;
        }
      }
      if (v8 >= v3) {
        break;
      }
      unsigned int v5 = (char *)*((void *)v7 + 1);
      if (!v5)
      {
        double v6 = (uint64_t **)(v7 + 8);
        goto LABEL_8;
      }
    }
  }
  else
  {
    uint64_t v7 = (char *)this + 96;
LABEL_8:
    unsigned __int8 v9 = v7;
    uint64_t v7 = (char *)operator new(0x60uLL);
    *((void *)v7 + 4) = v4;
    *(_OWORD *)(v7 + 40) = 0u;
    *(_OWORD *)(v7 + 56) = 0u;
    *((void *)v7 + 9) = 0;
    *((_OWORD *)v7 + 5) = xmmword_1A28FD0E0;
    *(void *)uint64_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v9;
    *double v6 = (uint64_t *)v7;
    uint64_t v10 = **((void **)this + 11);
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *((void *)this + 11) = v10;
      uint64_t v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 12), v11);
    ++*((void *)this + 13);
  }
  return v7 + 40;
}

void altitude::GlobeView::reload(altitude::GlobeView *this)
{
  uint64_t v2 = (altitude::GlobeCleanupLoader *)*((void *)this + 56);
  if (v2) {
    altitude::GlobeCleanupLoader::pruneNodesAndGeometry(v2);
  }
  unint64_t v3 = (altitude::ObjectTreeLoader *)*((void *)this + 87);
  if (v3) {
    altitude::ObjectTreeLoader::pruneModels(v3);
  }
  uint64_t v4 = *((void *)this + 105);
  if (v4) {
    *(unsigned char *)(v4 + 376) = 1;
  }
  if (md::HardwareFigDecoder::instance(void)::once != -1) {
    dispatch_once(&md::HardwareFigDecoder::instance(void)::once, &__block_literal_global_25645);
  }
  md::HardwareFigDecoder::discardCaches(*(std::mutex **)md::HardwareFigDecoder::instance(void)::_singleton);
  unsigned int v5 = *(karo::JobManager ***)(*((void *)this + 107) + 152);
  double v6 = *v5;
  uint64_t v7 = v5[1];
  *((unsigned char *)*v5 + 64) = 1;
  *((unsigned char *)v5[2] + 64) = 1;
  if (v7) {
    *((unsigned char *)v7 + 64) = 1;
  }
  karo::JobManager::cancelAll(v6);
  karo::JobManager::cancelAll(v5[2]);
  unint64_t v8 = v5[1];
  if (v8)
  {
    karo::JobManager::cancelAll(v8);
    unsigned __int8 v9 = v5[1];
    *((unsigned char *)*v5 + 64) = 0;
    *((unsigned char *)v5[2] + 64) = 0;
    if (!v9)
    {
LABEL_16:
      altitude::TileManager::clear(*((altitude::TileManager **)this + 86));
      uint64_t v10 = (void *)*((void *)this + 45);
      uint64_t v11 = (void *)v10[13];
      v10 += 13;
      std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v11);
      *(v10 - 1) = v10;
      *uint64_t v10 = 0;
      v10[1] = 0;
      uint64_t v12 = *((void *)this + 46);
      if (v12)
      {
        (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
        *((void *)this + 46) = 0;
      }
      *((unsigned char *)this + 417) = 1;
      altitude::GlobeView::load(this);
    }
  }
  else
  {
    *((unsigned char *)*v5 + 64) = 0;
    unsigned __int8 v9 = v5[2];
  }
  *((unsigned char *)v9 + 64) = 0;
  goto LABEL_16;
}

BOOL altitude::GlobeView::needsUpdate(altitude::GlobeView *this)
{
  BOOL result = 1;
  if (*((void *)this + 29) == *((void *)this + 30))
  {
    unint64_t v3 = (double *)*((void *)this + 9);
    if (v3[5] == *((double *)this + 42)
      && v3[6] == *((double *)this + 43)
      && v3[7] == *((double *)this + 44)
      && v3[4] == *((double *)this + 41)
      && v3[1] == *((double *)this + 38)
      && v3[2] == *((double *)this + 39)
      && v3[3] == *((double *)this + 40)
      && (altitude::TileManager::needsUpdate(*((altitude::TileManager **)this + 86)) & 1) == 0
      && *(_DWORD *)(*((void *)this + 86) + 196) == *((_DWORD *)this + 41))
    {
      uint64_t v4 = *((void *)this + 60);
      if (!v4 || !*(unsigned char *)(v4 + 522) || !*(unsigned char *)(v4 + 520))
      {
        uint64_t v5 = *((void *)this + 4);
        if (!v5 || !*(unsigned char *)(v5 + 65))
        {
          uint64_t v6 = *((void *)this + 105);
          if (!v6 || !*(void *)(v6 + 104))
          {
            uint64_t v7 = *((void *)this + 78);
            if ((!v7 || *(_DWORD *)(v7 + 116) != 1) && (!v5 || !*(unsigned char *)(v5 + 64)))
            {
              uint64_t v8 = *((void *)this + 53);
              if (!v8 || !*(unsigned char *)(v8 + 88)) {
                return 0;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void altitude::GlobeView::disableLabelData(altitude::GlobeView *this)
{
  *((unsigned char *)this + 433) = 0;
  uint64_t v1 = *(void **)(*(void *)(*((void *)this + 107) + 40) + 40);
  uint64_t v2 = v1[12];
  if (v2) {
    atomic_store(0, (unsigned __int8 *)(v2 + 224));
  }
  uint64_t v3 = v1[10];
  if (v3) {
    atomic_store(0, (unsigned __int8 *)(v3 + 224));
  }
  uint64_t v4 = v1[11];
  if (v4) {
    atomic_store(0, (unsigned __int8 *)(v4 + 224));
  }
  uint64_t v5 = *(void *)(*(void *)(*(void *)(*((void *)this + 107) + 40) + 40) + 56);
  if (v5)
  {
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    unint64_t v19 = &v20;
    pthread_mutex_lock(*(pthread_mutex_t **)(v5 + 40));
    uint64_t v6 = *(void **)(v5 + 64);
    if (v6 != (void *)(v5 + 72))
    {
      do
      {
        uint64_t v8 = v6[8];
        uint64_t v7 = (std::__shared_weak_count *)v6[9];
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
        unsigned __int8 v9 = std::__tree<altitude::TileKey>::__find_equal<altitude::TileKey>((uint64_t)&v19, &v22, (unsigned int *)(v8 + 192));
        if (*v9)
        {
          if (!v7) {
            goto LABEL_20;
          }
        }
        else
        {
          uint64_t v10 = v9;
          uint64_t v11 = (char *)operator new(0x40uLL);
          *(_OWORD *)(v11 + 28) = *(_OWORD *)(v8 + 192);
          *(_OWORD *)(v11 + 44) = *(_OWORD *)(v8 + 208);
          uint64_t v12 = v22;
          *(void *)uint64_t v11 = 0;
          *((void *)v11 + 1) = 0;
          *((void *)v11 + 2) = v12;
          *uint64_t v10 = (uint64_t)v11;
          if (*v19)
          {
            unint64_t v19 = (uint64_t **)*v19;
            uint64_t v11 = (char *)*v10;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v20, (uint64_t *)v11);
          ++v21;
          if (!v7)
          {
LABEL_20:
            unsigned int v13 = (void *)v6[1];
            if (!v13) {
              goto LABEL_24;
            }
            goto LABEL_21;
          }
        }
        if (atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
          goto LABEL_20;
        }
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
        unsigned int v13 = (void *)v6[1];
        if (!v13)
        {
          do
          {
LABEL_24:
            uint64_t v14 = (void *)v6[2];
            BOOL v15 = *v14 == (void)v6;
            uint64_t v6 = v14;
          }
          while (!v15);
          goto LABEL_10;
        }
        do
        {
LABEL_21:
          uint64_t v14 = v13;
          unsigned int v13 = (void *)*v13;
        }
        while (v13);
LABEL_10:
        uint64_t v6 = v14;
      }
      while (v14 != (void *)(v5 + 72));
    }
    pthread_mutex_unlock(*(pthread_mutex_t **)(v5 + 40));
    uint64_t v16 = v19;
    if (v19 != &v20)
    {
      do
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 48))(v5, (uint64_t)v16 + 28);
        __double2 v17 = v16[1];
        if (v17)
        {
          do
          {
            uint64_t v18 = (uint64_t **)v17;
            __double2 v17 = (uint64_t *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            uint64_t v18 = (uint64_t **)v16[2];
            BOOL v15 = *v18 == (uint64_t *)v16;
            uint64_t v16 = v18;
          }
          while (!v15);
        }
        uint64_t v16 = v18;
      }
      while (v18 != &v20);
    }
    *(unsigned char *)(v5 + 136) = 0;
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v20);
  }
}

void sub_1A2073A04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

uint64_t altitude::GlobeView::isFlyoverTileAtTarget(altitude::GlobeView *this)
{
  long double v95 = 0;
  long double v96 = 0;
  uint64_t v97 = 0;
  uint64_t v2 = *((void *)this + 57);
  if (v2)
  {
    uint64_t v3 = (char **)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 56))(v2);
    std::vector<gdc::Entity>::__assign_with_size[abi:nn180100]<gdc::Entity*,gdc::Entity*>(&v95, *v3, v3[1], (v3[1] - *v3) >> 3);
    uint64_t v4 = v95;
    uint64_t v5 = v96;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v4 = 0;
  }
  uint64_t v6 = (double *)*((void *)this + 9);
  double v7 = v6[1];
  double v8 = v6[2];
  long double v9 = tan(v7 * 0.5 + 0.785398163);
  double v10 = log(v9);
  if (v4 == v5)
  {
LABEL_23:
    uint64_t v33 = *((void *)this + 3);
    if (v33)
    {
      gdc::CameraFrame<geo::Radians,double>::toRigidTransformGeocentric((double *)&v57, v6 + 1);
      long long v92 = v57;
      uint64_t v93 = v58;
      uint64_t v94 = 0x4059000000000000;
      long long v58 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      *(void *)&long long v57 = 0;
      *((void *)&v57 + 1) = &unk_1EF568F68;
      uint64_t v62 = 0;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v69 = 0u;
      int v72 = 0;
      uint64_t v70 = 0;
      uint64_t v71 = 0xFFFFFFFFLL;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v76 = 0u;
      long long v77 = 0u;
      uint64_t v73 = &unk_1EF568F68;
      uint64_t v78 = 0;
      long long v79 = 0u;
      long long v80 = 0u;
      long long v81 = 0u;
      long long v82 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      long long v85 = 0u;
      uint64_t v86 = 0;
      uint64_t v87 = 0xFFFFFFFFLL;
      int v88 = 0;
      uint64_t v91 = 0;
      __p = 0;
      long double v90 = 0;
      altitude::TriggerManager::cullTriggers(v33, (altitude::TriggerManager::Trigger **)&v57, &v92, 0xDu);
      if ((void)v57) {
        *((unsigned char *)this + 417) = 1;
      }
      double v34 = (char *)__p;
      if (__p)
      {
        double v35 = __p;
        if (v90 != __p)
        {
          uint64_t v36 = v90 - 240;
          unint64_t v37 = v90 - 240;
          double v38 = (void (***)(char *))(v90 - 240);
          do
          {
            int v39 = *v38;
            v38 -= 30;
            (*v39)(v37);
            v36 -= 240;
            BOOL v17 = v37 == v34;
            unint64_t v37 = (char *)v38;
          }
          while (!v17);
          double v35 = __p;
        }
        long double v90 = v34;
        operator delete(v35);
      }
      altitude::TriggerManager::Trigger::~Trigger((altitude::TriggerManager::Trigger *)&v73);
      altitude::TriggerManager::Trigger::~Trigger((altitude::TriggerManager::Trigger *)((char *)&v57 + 8));
    }
    int v40 = v95;
    if (!v95) {
      return *((unsigned __int8 *)this + 417);
    }
LABEL_35:
    operator delete(v40);
    return *((unsigned __int8 *)this + 417);
  }
  signed int v11 = 0x1FFFFFF - vcvtmd_s64_f64(v10 * 5340353.72 + 16777216.0);
  int v12 = vcvtmd_s64_f64(v8 * 5340353.72 + 16777216.0);
  unsigned int v13 = v4;
  while (1)
  {
    uint64_t v14 = *v13;
    if (*(unsigned char *)(*(void *)(*v13 + 288) + 164))
    {
      unsigned int v15 = *(_DWORD *)(v14 + 392);
      char v16 = v15 >= 0x1F ? 31 : *(_DWORD *)(v14 + 392);
      BOOL v17 = v11 >> (25 - v15) == ~(-1 << v16) - *(_DWORD *)(v14 + 396) && v12 >> (25 - v15) == *(_DWORD *)(v14 + 400);
      if (v17) {
        break;
      }
    }
    if (++v13 == v5) {
      goto LABEL_23;
    }
  }
  uint64_t v18 = *(void *)(v14 + 328);
  *((_DWORD *)this + 42) = 0;
  if (*(void *)(v14 + 312) == *(void *)(v14 + 304)) {
    unsigned int v19 = v15;
  }
  else {
    unsigned int v19 = v15 + 1;
  }
  if (!*(unsigned char *)(v18 + 296))
  {
    *((unsigned char *)this + 417) = 1;
    goto LABEL_72;
  }
  uint64_t v20 = (_DWORD *)(v14 + 392);
  double v21 = v6[3];
  __double2 v22 = __sincos_stret(v7);
  double v23 = 6378137.0 / sqrt(1.0 - v22.__sinval * v22.__sinval * 0.00669437999);
  double v24 = (v23 + v21) * v22.__cosval;
  __double2 v25 = __sincos_stret(v8);
  double v56 = v21 + v23 * 0.99330562;
  double v26 = *((double *)this + 39);
  double v27 = *((double *)this + 40);
  __double2 v28 = __sincos_stret(*((double *)this + 38));
  double v29 = 6378137.0 / sqrt(1.0 - v28.__sinval * v28.__sinval * 0.00669437999);
  __double2 v30 = __sincos_stret(v26);
  double v31 = -((v27 + v29 * 0.99330562) * v28.__sinval - v56 * v22.__sinval);
  double v32 = *((double *)this + 41);
  if (sqrt(-((v29 + v27) * v28.__cosval * v30.__cosval - v24 * v25.__cosval)* -((v29 + v27) * v28.__cosval * v30.__cosval - v24 * v25.__cosval)+ -((v29 + v27) * v28.__cosval * v30.__sinval - v24 * v25.__sinval)* -((v29 + v27) * v28.__cosval * v30.__sinval - v24 * v25.__sinval)+ v31 * v31) <= v32 * 5.0)
  {
    uint64_t v42 = *((void *)this + 66);
    if (!v42
      || (uint64_t v43 = (_DWORD *)*((void *)this + 99),
          (uint64_t v44 = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v42 + 24))(v42, 0, 0)) == 0)
      || (LOBYTE(v92) = 0,
          LODWORD(v57) = -1082130432,
          altitude::Tile::computeTileViewRelation(v44, v43, v14, *(_DWORD *)(*((void *)this + 86) + 208), &v92, (float *)&v57, *(_DWORD *)(*(void *)(*((void *)this + 107) + 136) + 88), 0, *(float *)(*((void *)this + 86) + 200)), *(float *)&v57 <= 0.5))
    {
LABEL_42:
      uint64_t v45 = *((void *)this + 3);
      if (v45)
      {
        gdc::CameraFrame<geo::Radians,double>::toRigidTransformGeocentric((double *)&v57, (double *)(*((void *)this + 9) + 8));
        long long v92 = v57;
        uint64_t v93 = v58;
        uint64_t v94 = 0x4059000000000000;
        long long v58 = 0u;
        long long v59 = 0u;
        long long v60 = 0u;
        long long v61 = 0u;
        *(void *)&long long v57 = 0;
        *((void *)&v57 + 1) = &unk_1EF568F68;
        uint64_t v62 = 0;
        long long v63 = 0u;
        long long v64 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v68 = 0u;
        long long v69 = 0u;
        int v72 = 0;
        uint64_t v70 = 0;
        uint64_t v71 = 0xFFFFFFFFLL;
        long long v74 = 0u;
        long long v75 = 0u;
        long long v76 = 0u;
        long long v77 = 0u;
        uint64_t v73 = &unk_1EF568F68;
        uint64_t v78 = 0;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v83 = 0u;
        long long v84 = 0u;
        long long v85 = 0u;
        uint64_t v86 = 0;
        uint64_t v87 = 0xFFFFFFFFLL;
        int v88 = 0;
        uint64_t v91 = 0;
        __p = 0;
        long double v90 = 0;
        altitude::TriggerManager::cullTriggers(v45, (altitude::TriggerManager::Trigger **)&v57, &v92, 0xDu);
        uint64_t v46 = v57;
        if ((void)v57)
        {
          if ((unint64_t)v57 < 3)
          {
            if (v62 && *v20 < *(_DWORD *)(v62 + 8)) {
              char v48 = 1;
            }
            else {
              char v48 = *(unsigned char *)(v18 + 296) ^ 1;
            }
            if ((void)v57 != 1)
            {
              if (v78 && *v20 < *(_DWORD *)(v78 + 8)) {
                char v48 = 1;
              }
              else {
                char v48 = *(unsigned char *)(v18 + 296) ^ 1;
              }
            }
          }
          else
          {
            unsigned int v47 = (char *)__p + 72;
            do
            {
              if (*(void *)v47 && *v20 < *(_DWORD *)(*(void *)v47 + 8)) {
                char v48 = 1;
              }
              else {
                char v48 = *(unsigned char *)(v18 + 296) ^ 1;
              }
              v47 += 240;
              --v46;
            }
            while (v46);
          }
          *((unsigned char *)this + 417) = v48;
        }
        float64x2_t v49 = (char *)__p;
        if (__p)
        {
          unint64_t v50 = __p;
          if (v90 != __p)
          {
            double v51 = v90 - 240;
            unsigned int v52 = v90 - 240;
            float v53 = (void (***)(char *))(v90 - 240);
            do
            {
              double v54 = *v53;
              v53 -= 30;
              (*v54)(v52);
              v51 -= 240;
              BOOL v17 = v52 == v49;
              unsigned int v52 = (char *)v53;
            }
            while (!v17);
            unint64_t v50 = __p;
          }
          long double v90 = v49;
          operator delete(v50);
        }
        altitude::TriggerManager::Trigger::~Trigger((altitude::TriggerManager::Trigger *)&v73);
        altitude::TriggerManager::Trigger::~Trigger((altitude::TriggerManager::Trigger *)((char *)&v57 + 8));
      }
      goto LABEL_69;
    }
    uint64_t v6 = (double *)*((void *)this + 9);
    double v32 = *((double *)this + 41);
  }
  if (v6[4] / v32 <= 0.5) {
    goto LABEL_42;
  }
  *((unsigned char *)this + 417) = 0;
LABEL_69:
  if (*(void *)(v14 + 312) != *(void *)(v14 + 304) && *v20 >= 0xEu)
  {
    long long v57 = 7uLL;
    long long v58 = *(_OWORD *)v20;
    unsigned int v19 = altitude::HeightRequestManager::maxHeightMeshLevelForTileKey(*(void *)(*(void *)(*((void *)this + 71) + 144) + 32), (unsigned int *)&v57);
  }
LABEL_72:
  unsigned int v55 = *((_DWORD *)this + 42);
  if (v19 > v55) {
    unsigned int v55 = v19;
  }
  *((_DWORD *)this + 42) = v55;
  int v40 = v95;
  if (v95) {
    goto LABEL_35;
  }
  return *((unsigned __int8 *)this + 417);
}

void sub_1A2074180(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void altitude::GlobeView::setStyleManager(altitude::GlobeView *this, uint64_t a2, uint64_t a3)
{
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)this + 76) = a2;
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 77);
  *((void *)this + 77) = a3;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = *(void **)(*(void *)(*(void *)(*((void *)this + 107) + 40) + 16) + 240);
  if (v5)
  {
    uint64_t v6 = *((void *)this + 76);
    uint64_t v7 = *((void *)this + 77);
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    double v8 = (std::__shared_weak_count *)v5[15];
    v5[14] = v6;
    v5[15] = v7;
    if (v8)
    {
      if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
      uint64_t v7 = v5[15];
    }
    uint64_t v9 = v5[13];
    uint64_t v10 = v5[14];
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    signed int v11 = *(std::__shared_weak_count **)(v9 + 176);
    *(void *)(v9 + 168) = v10;
    *(void *)(v9 + 176) = v7;
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  int v12 = *(void **)(*(void *)(*(void *)(*((void *)this + 107) + 40) + 24) + 152);
  if (v12) {
    altitude::SkeletonRequestManager::setStyleManager(v12, *((void *)this + 76), *((void *)this + 77));
  }
  altitude::GlobeView::updateLodScale(this);
  unsigned int v13 = (altitude::GlobeCleanupLoader *)*((void *)this + 56);
  if (v13)
  {
    unsigned int v14 = *(_DWORD *)(*((void *)v13 + 4) + 88) + 1;
    altitude::GlobeCleanupLoader::pruneTrafficComponents(v13, v14, v14);
    unsigned int v15 = (altitude::GlobeCleanupLoader *)*((void *)this + 56);
    unsigned int v16 = *(_DWORD *)(*((void *)v15 + 4) + 88) + 1;
    altitude::GlobeCleanupLoader::pruneRoadComponents(v15, v16, v16);
  }
}

uint64_t altitude::GlobeView::setTileSetGridFractionChangedCallback(uint64_t a1, void *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (void *)a2[3];
  if (!v3)
  {
    double v8 = 0;
    uint64_t v5 = (void *)(a1 + 952);
    uint64_t v10 = 0;
    goto LABEL_10;
  }
  if (v3 != a2)
  {
    uint64_t v4 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    double v8 = v4;
    uint64_t v5 = (void *)(a1 + 952);
    if (v4) {
      goto LABEL_4;
    }
LABEL_8:
    uint64_t v10 = 0;
    goto LABEL_10;
  }
  double v8 = v7;
  (*(void (**)(void *, void *))(*a2 + 24))(a2, v7);
  uint64_t v4 = v8;
  uint64_t v5 = (void *)(a1 + 952);
  if (!v8) {
    goto LABEL_8;
  }
LABEL_4:
  if (v4 == v7)
  {
    uint64_t v10 = v9;
    (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
  }
  else
  {
    uint64_t v10 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
  }
LABEL_10:
  std::__function::__value_func<void ()(double,double,double)>::swap[abi:nn180100](v9, v5);
  if (v10 == v9)
  {
    (*(void (**)(void *))(v9[0] + 32))(v9);
  }
  else if (v10)
  {
    (*(void (**)(void))(*v10 + 40))();
  }
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

void *std::function<void ()(double,double,double)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t altitude::GlobeView::setTileSetLoadedFractionChangedCallback(uint64_t a1, void *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (void *)a2[3];
  if (!v3)
  {
    double v8 = 0;
    uint64_t v5 = (void *)(a1 + 984);
    uint64_t v10 = 0;
    goto LABEL_10;
  }
  if (v3 != a2)
  {
    uint64_t v4 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    double v8 = v4;
    uint64_t v5 = (void *)(a1 + 984);
    if (v4) {
      goto LABEL_4;
    }
LABEL_8:
    uint64_t v10 = 0;
    goto LABEL_10;
  }
  double v8 = v7;
  (*(void (**)(void *, void *))(*a2 + 24))(a2, v7);
  uint64_t v4 = v8;
  uint64_t v5 = (void *)(a1 + 984);
  if (!v8) {
    goto LABEL_8;
  }
LABEL_4:
  if (v4 == v7)
  {
    uint64_t v10 = v9;
    (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
  }
  else
  {
    uint64_t v10 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
  }
LABEL_10:
  std::__function::__value_func<void ()(double,double,double)>::swap[abi:nn180100](v9, v5);
  if (v10 == v9)
  {
    (*(void (**)(void *))(v9[0] + 32))(v9);
  }
  else if (v10)
  {
    (*(void (**)(void))(*v10 + 40))();
  }
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t ___ZN2md3mun20MuninRenderResourcesC2EPKNS_6DeviceE_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 32);
  unint64_t v2 = v1[6] - v1[5];
  unint64_t v3 = v1[1];
  uint64_t v4 = v1[9];
  __asm { FMOV            V0.4S, #-1.0 }
  *(void *)uint64_t v4 = _Q0;
  *(void *)(v4 + 16) = 0x3F80000000000000;
  *(void *)(v4 + 32) = 0xBF8000003F800000;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(v4 + 48) = _Q0;
  __asm { FMOV            V0.4S, #1.0 }
  *(void *)(v4 + 64) = _Q0;
  *(_DWORD *)(v4 + 8) = 1065353216;
  *(_DWORD *)(v4 + 40) = 1065353216;
  *(_DWORD *)(v4 + 72) = 1065353216;
  *(void *)(v4 + 80) = 1065353216;
  *(_DWORD *)(v4 + 104) = 1065353216;
  *(void *)(v4 + 96) = 0x3F800000BF800000;
  *(void *)(v4 + 112) = 0;
  unint64_t v11 = v2 - v2 % v3;
  if (v11)
  {
    if (v1[8] > v11) {
      unint64_t v11 = v1[8];
    }
    v1[7] = 0;
    v1[8] = v11;
  }
  int v12 = *(void **)(result + 48);
  unint64_t v13 = v12[6] - v12[5];
  unint64_t v14 = v13 % v12[1];
  uint64_t v15 = v12[9];
  *(void *)uint64_t v15 = 0x2000200010000;
  *(_DWORD *)(v15 + 8) = 3;
  unint64_t v16 = v13 - v14;
  if (v16)
  {
    if (v12[8] > v16) {
      unint64_t v16 = v12[8];
    }
    uint64_t v12[7] = 0;
    v12[8] = v16;
  }
  return result;
}

uint64_t ggl::FragmentedPool<ggl::VSView::StretchAlphaPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::VSView::PipelineSetup>::~FragmentedPool(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void ggl::ConstantDataTyped<ggl::VSTextured::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::VSTextured::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::VSTextured::Style>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::VSTextured::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585998;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::VSTextured::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585998;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_6VSView13PipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57C240;
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_6VSView13PipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF57C240;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_6VSView13PipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_1,std::allocator<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_1>,ggl::VSView::PipelineSetup * ()(void)>::operator()()
{
}

void sub_1A2075268(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0xE1C40C3CBA79CLL);
  _Unwind_Resume(a1);
}

void ggl::ConstantDataTyped<ggl::VSView::View>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::VSView::View>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::VSView::View>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::VSView::View>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587288;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::VSView::View>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587288;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__function::__func<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_1,std::allocator<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_1>,ggl::VSView::PipelineSetup * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF578BA0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_1,std::allocator<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_1>,ggl::VSView::PipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF578BA0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_1,std::allocator<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_1>,ggl::VSView::PipelineSetup * ()(void)>::~__func()
{
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_6VSView25StretchAlphaPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57C288;
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_6VSView25StretchAlphaPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF57C288;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_6VSView25StretchAlphaPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_0,std::allocator<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_0>,ggl::VSView::StretchAlphaPipelineSetup * ()(void)>::operator()()
{
}

void sub_1A2075844(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0xE1C40C3CBA79CLL);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_0,std::allocator<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_0>,ggl::VSView::StretchAlphaPipelineSetup * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF578B58;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_0,std::allocator<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_0>,ggl::VSView::StretchAlphaPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF578B58;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_0,std::allocator<md::mun::MuninRenderResources::MuninRenderResources(md::Device const*)::$_0>,ggl::VSView::StretchAlphaPipelineSetup * ()(void)>::~__func()
{
}

void ggl::ConstantDataTyped<ggl::VSView::Shared>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::VSView::Shared>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::VSView::Shared>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::VSView::Shared>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5872C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::VSView::Shared>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5872C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_pointer<ggl::VSCommon::Mesh *,std::shared_ptr<ggl::VSCommon::Mesh>::__shared_ptr_default_delete<ggl::VSCommon::Mesh,ggl::VSCommon::Mesh>,std::allocator<ggl::VSCommon::Mesh>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ggl::VSCommon::Mesh *,std::shared_ptr<ggl::VSCommon::Mesh>::__shared_ptr_default_delete<ggl::VSCommon::Mesh,ggl::VSCommon::Mesh>,std::allocator<ggl::VSCommon::Mesh>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void __destroy_helper_block_ea8_32c72_ZTSNSt3__110shared_ptrIN3ggl15VertexDataTypedINS1_8VSCommon6VertexEEEEE48c51_ZTSNSt3__110shared_ptrIN3ggl14IndexDataTypedItEEEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v3) {
      return;
    }
  }
  else
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v3) {
      return;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *__copy_helper_block_ea8_32c72_ZTSNSt3__110shared_ptrIN3ggl15VertexDataTypedINS1_8VSCommon6VertexEEEEE48c51_ZTSNSt3__110shared_ptrIN3ggl14IndexDataTypedItEEEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::__shared_ptr_emplace<ggl::VSTextured::CompositingPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VSTextured::CompositingPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583270;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VSTextured::CompositingPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583270;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::VSView::StretchAlphaPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VSView::StretchAlphaPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5893C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VSView::StretchAlphaPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5893C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Clear::ClearMesh>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Clear::ClearMesh>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588FD8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Clear::ClearMesh>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588FD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__function::__func<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_1>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t result, void *a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *a2;
  uint64_t v4 = **(void **)(result + 8);
  unint64_t v5 = 4 * *(void *)(v4 + 8);
  if (v5)
  {
    if (v3 && *(unsigned char *)(v4 + 17) != 2)
    {
      uint64_t result = (*(uint64_t (**)(void, uint64_t, void, uint64_t, uint64_t, void))(*(void *)v3 + 56))(*a2, v4, 0, 4 * *(void *)(v4 + 8), 1, 0);
      uint64_t v6 = (_OWORD *)result;
    }
    else
    {
      uint64_t v6 = *(_OWORD **)(v4 + 72);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  *uint64_t v6 = xmmword_1A28FCD00;
  v6[1] = xmmword_1A28FCD10;
  uint64_t v7 = **(void **)(v2 + 16);
  unint64_t v8 = 6 * *(void *)(v7 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v7 + 17) == 2)
    {
      uint64_t v9 = *(void *)(v7 + 72);
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, void))(*(void *)v3 + 56))(v3, v7, 0, 6 * *(void *)(v7 + 8), 1, 0);
      uint64_t v9 = result;
    }
    *(void *)uint64_t v9 = 0x2000200010000;
    *(_DWORD *)(v9 + 8) = 3;
    if (*(unsigned char *)(v7 + 17) != 2) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 64))(v3);
    }
  }
  else
  {
    uint64_t v10 = *(void *)(v7 + 72);
    *(void *)uint64_t v10 = 0x2000200010000;
    *(_DWORD *)(v10 + 8) = 3;
  }
  unint64_t v11 = *(void *)(v7 + 64);
  if (v11 <= v8) {
    unint64_t v11 = v8;
  }
  *(void *)(v7 + 56) = 0;
  *(void *)(v7 + 64) = v11;
  if (v5)
  {
    if (v3 && *(unsigned char *)(v4 + 17) != 2) {
      uint64_t result = (*(uint64_t (**)(uint64_t, _OWORD *, uint64_t, void, unint64_t, uint64_t, void))(*(void *)v3 + 64))(v3, v6, v4, 0, v5, 1, 0);
    }
    unint64_t v12 = *(void *)(v4 + 64);
    if (v12 <= v5) {
      unint64_t v12 = v5;
    }
    *(void *)(v4 + 56) = 0;
    *(void *)(v4 + 64) = v12;
  }
  return result;
}

__n128 std::__function::__func<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_1>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF578B10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_1>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF578B10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_1>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::Clear::ClearData>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::Clear::ClearData>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::Clear::ClearData>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Clear::ClearData>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Clear::ClearData>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584E38;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Clear::ClearData>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584E38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__function::__func<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t result, void *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(*(void *)(result + 8) + 112);
  unint64_t v4 = *(void *)(v3 + 8);
  if (*a2)
  {
    if (*(unsigned char *)(v3 + 17) == 2)
    {
      uint64_t v5 = *(void *)(v3 + 72);
    }
    else
    {
      __n128 result = (*(uint64_t (**)(void, uint64_t, void, void, uint64_t, void))(*(void *)v2 + 56))(*a2, v3, 0, *(void *)(v3 + 8), 1, 0);
      uint64_t v5 = result;
    }
    *(_OWORD *)uint64_t v5 = xmmword_1A28FE140;
    *(_DWORD *)(v5 + 16) = 1065353216;
    if (*(unsigned char *)(v3 + 17) != 2) {
      __n128 result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 64))(v2);
    }
  }
  else
  {
    uint64_t v6 = *(void *)(v3 + 72);
    *(_OWORD *)uint64_t v6 = xmmword_1A28FE140;
    *(_DWORD *)(v6 + 16) = 1065353216;
  }
  unint64_t v7 = *(void *)(v3 + 64);
  if (v7 <= v4) {
    unint64_t v7 = v4;
  }
  *(void *)(v3 + 56) = 0;
  *(void *)(v3 + 64) = v7;
  return result;
}

uint64_t std::__function::__func<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF578AC8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF578AC8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::mun::MuninRenderResources::updatePipelineStates(ggl::RenderTargetFormat const&,ggl::RenderTargetFormat const&)::$_0>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

void ggl::ConstantDataTyped<ggl::Clear::ClearConstants>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::Clear::ClearConstants>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Clear::ClearConstants>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Clear::ClearConstants>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586E60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Clear::ClearConstants>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586E60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Clear::ClearPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Clear::ClearPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588FA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Clear::ClearPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588FA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::VSTextured::PassthroughPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VSTextured::PassthroughPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5832A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VSTextured::PassthroughPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5832A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::VSView::PipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VSView::PipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589390;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VSView::PipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589390;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *md::MaskedIconLabelPart::populateMeshDescriptor(md::MaskedIconLabelPart *this, md::IconMeshDescriptor *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  *((unsigned char *)a2 + 3) = 1;
  v3[0] = &unk_1EF574988;
  v3[1] = this;
  unint64_t v4 = v3;
  std::__function::__value_func<void ()(md::LabelRenderDescriptor const&,md::IconMeshData &)>::swap[abi:nn180100](v3, (void *)a2 + 1);
  __n128 result = v4;
  if (v4 == v3) {
    return (void *)(*(uint64_t (**)(void *))(v3[0] + 32))(v3);
  }
  if (v4) {
    return (void *)(*(uint64_t (**)(void))(*v4 + 40))();
  }
  return result;
}

__n128 std::__function::__func<md::MaskedIconLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0,std::allocator<md::MaskedIconLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0>,void ()(md::LabelRenderDescriptor const&,md::IconMeshData &)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(__n128 **)(a1 + 8);
  if (v4[35].n128_u8[5]) {
    *(void *)(a3 + 64) = (*(uint64_t (**)(void))(v4->n128_u64[0] + 144))(*(void *)(a1 + 8));
  }
  float v5 = v4[38].n128_f32[0] * v4[37].n128_f32[1];
  *(_DWORD *)(a3 + 48) = v4[34].n128_u32[2];
  *(float *)(a3 + 52) = v5;
  *(_DWORD *)(a3 + 56) = v4[37].n128_u32[3];
  *(_DWORD *)a3 = v4[43].n128_u32[2];
  *(_DWORD *)(a3 + 4) = v4[43].n128_u32[3];
  *(_DWORD *)(a3 + 8) = v4[44].n128_u32[0];
  *(_DWORD *)(a3 + 12) = v4[44].n128_u32[1];
  *(_DWORD *)(a3 + 16) = v4[44].n128_u32[2];
  *(_DWORD *)(a3 + 20) = v4[44].n128_u32[3];
  *(_DWORD *)(a3 + 24) = v4[45].n128_u32[0];
  *(_DWORD *)(a3 + 28) = v4[45].n128_u32[1];
  uint64_t v6 = (_DWORD *)(*(uint64_t (**)(__n128 *))(v4->n128_u64[0] + 928))(v4);
  *(_DWORD *)(a3 + 32) = *v6;
  *(_DWORD *)(a3 + 36) = v6[1];
  *(_DWORD *)(a3 + 40) = v6[2];
  *(_DWORD *)(a3 + 44) = v6[3];
  __n128 result = v4[48];
  *(__n128 *)(a3 + 116) = result;
  *(_DWORD *)(a3 + 112) = 0;
  return result;
}

uint64_t std::__function::__func<md::MaskedIconLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0,std::allocator<md::MaskedIconLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0>,void ()(md::LabelRenderDescriptor const&,md::IconMeshData &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF574988;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MaskedIconLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0,std::allocator<md::MaskedIconLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0>,void ()(md::LabelRenderDescriptor const&,md::IconMeshData &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF574988;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MaskedIconLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0,std::allocator<md::MaskedIconLabelPart::populateMeshDescriptor(md::IconMeshDescriptor &)::$_0>,void ()(md::LabelRenderDescriptor const&,md::IconMeshData &)>::~__func()
{
}

uint64_t md::MaskedIconLabelPart::styleLayer(md::MaskedIconLabelPart *this, const md::LabelStyle *a2)
{
  return *(char *)(*((void *)this + 2) + 753);
}

uint64_t md::MaskedIconLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t *a4, float32x2_t *a5, double a6, double a7, double a8)
{
  *(_DWORD *)(a1 + 780) = 1086918619;
  LODWORD(a6) = *(_DWORD *)(a1 + 772);
  *(_DWORD *)(a1 + 776) = LODWORD(a6);
  if (!a3) {
    goto LABEL_19;
  }
  unint64_t v8 = *(char **)(a3 + 24);
  uint64_t v9 = *(char **)(a3 + 32);
  if (0x8E38E38E38E38E39 * ((v9 - v8) >> 4) <= *(unsigned __int8 *)(a1 + 563))
  {
    if (v8 == v9 || *(unsigned char *)(a3 + 89) == 0) {
      goto LABEL_19;
    }
  }
  else
  {
    v8 += 144 * *(unsigned __int8 *)(a1 + 563);
  }
  if (v8)
  {
    uint64_t v11 = *(void *)v8;
    uint64_t v12 = *((void *)v8 + 1);
    if (v11 != v12)
    {
      uint64_t v13 = v11;
      while (*(unsigned char *)(v13 + 16) != 3)
      {
        v13 += 24;
        if (v13 == v12) {
          goto LABEL_19;
        }
      }
      do
      {
        if (*(unsigned char *)(v11 + 16) == 3)
        {
          LODWORD(a8) = *(_DWORD *)(**(void **)v11 + 32 * *(unsigned int *)(*(void *)v11 + 32) + 8);
          a7 = 6.28318531;
          a6 = (float)(*(float *)(v11 + 8) + (float)(*(float *)&a8 * (float)(*(float *)(v11 + 12) - *(float *)(v11 + 8))))
             * 6.28318531;
          *(float *)&a6 = a6;
          goto LABEL_18;
        }
        v11 += 24;
      }
      while (v11 != v12);
      LODWORD(a6) = 1086918619;
LABEL_18:
      *(_DWORD *)(a1 + 780) = LODWORD(a6);
    }
  }
LABEL_19:
  md::IconLabelPart::layoutForDisplay(a1, a2, a3, a4, a5, a6, a7, a8);
  return 37;
}

float md::MaskedIconLabelPart::prepareForDisplay(md::MaskedIconLabelPart *this, md::LabelManager *a2)
{
  float v3 = *((float *)this + 153);
  if (v3 != *((float *)this + 188)
    || *((float *)this + 80) < *((float *)this + 78)
    || *((float *)this + 81) < *((float *)this + 79))
  {
    *((float *)this + 188) = v3;
    (*(void (**)(md::MaskedIconLabelPart *, uint64_t, char *, char *))(*(void *)this + 912))(this, 1, (char *)this + 640, (char *)this + 312);
  }
  if (*((unsigned char *)this + 565)) {
    operator new();
  }
  float v4 = (*(float (**)(md::MaskedIconLabelPart *))(*(void *)this + 920))(this);
  float v8 = *((float *)this + 153);
  BOOL v9 = v8 == 1.0;
  float v10 = v4 * v8;
  float v11 = v5 * v8;
  float v12 = v6 * v8;
  float v13 = v7 * v8;
  if (!v9)
  {
    float v4 = v10;
    float v5 = v11;
    float v6 = v12;
    float v7 = v13;
  }
  float v14 = fminf(v7 - v5, v6 - v4);
  *((float *)this + 193) = v14;
  float result = (float)(v14 * 0.5) + -1.0;
  *((float *)this + 192) = result;
  return result;
}

void md::MaskedIconLabelPart::~MaskedIconLabelPart(md::MaskedIconLabelPart *this)
{
  md::IconLabelPart::~IconLabelPart(this);
  uint64_t v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  uint64_t v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

void *md::GraphTraversalPath::GraphTraversalPath(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  float v5 = *(const void **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  int64_t v6 = v4 - *(void *)a2;
  if (v4 != *(void *)a2)
  {
    if (v6 < 0) {
      abort();
    }
    float v7 = (char *)operator new(v4 - *(void *)a2);
    *a1 = v7;
    a1[1] = v7;
    float v8 = &v7[8 * (v6 >> 3)];
    a1[2] = v8;
    memcpy(v7, v5, v6);
    a1[1] = v8;
  }
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  float v10 = *(unsigned char **)(a2 + 24);
  BOOL v9 = *(unsigned char **)(a2 + 32);
  int64_t v11 = v9 - v10;
  if (v9 != v10)
  {
    if (v11 < 0) {
      abort();
    }
    float v12 = (char *)operator new(v9 - v10);
    a1[3] = v12;
    a1[4] = v12;
    float v13 = &v12[8 * (v11 >> 3)];
    a1[5] = v13;
    memcpy(v12, v10, v11);
    a1[4] = v13;
  }
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  uint64_t v15 = *(unsigned char **)(a2 + 48);
  float v14 = *(unsigned char **)(a2 + 56);
  size_t v16 = v14 - v15;
  if (v14 != v15)
  {
    if ((v16 & 0x8000000000000000) != 0) {
      abort();
    }
    BOOL v17 = (char *)operator new(v14 - v15);
    a1[6] = v17;
    a1[7] = v17;
    uint64_t v18 = &v17[v16];
    a1[8] = &v17[v16];
    memcpy(v17, v15, v16);
    a1[7] = v18;
  }
  return a1;
}

void sub_1A20771C4(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
    float v5 = *(void **)v1;
    if (!*(void *)v1) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    float v5 = *(void **)v1;
    if (!*(void *)v1) {
      goto LABEL_3;
    }
  }
  *(void *)(v1 + 8) = v5;
  operator delete(v5);
  _Unwind_Resume(exception_object);
}

void md::GraphTraversalPath::visit(md::GraphTraversalPath *this, const MuninJunction *a2)
{
  float v5 = (void *)*((void *)this + 1);
  unint64_t v4 = *((void *)this + 2);
  int64_t v6 = v5;
  if ((unint64_t)v5 >= v4)
  {
    float v8 = *(unsigned char **)this;
    uint64_t v9 = (uint64_t)v5 - *(void *)this;
    uint64_t v10 = v9 >> 3;
    unint64_t v11 = (v9 >> 3) + 1;
    if (v11 >> 61) {
      goto LABEL_55;
    }
    uint64_t v12 = v4 - (void)v8;
    if (v12 >> 2 > v11) {
      unint64_t v11 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13)
    {
      if (v13 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      float v14 = operator new(8 * v13);
    }
    else
    {
      float v14 = 0;
    }
    uint64_t v15 = &v14[8 * v10];
    size_t v16 = &v14[8 * v13];
    void *v15 = a2;
    float v7 = v15 + 1;
    if (v5 == (void *)v8)
    {
      float v8 = v5;
    }
    else
    {
      unint64_t v17 = (char *)v5 - v8 - 8;
      if (v17 < 0x58) {
        goto LABEL_59;
      }
      if ((unint64_t)((char *)v5 - v14 - v9) < 0x20) {
        goto LABEL_59;
      }
      uint64_t v18 = (v17 >> 3) + 1;
      int64_t v6 = &v5[-(v18 & 0x3FFFFFFFFFFFFFFCLL)];
      unsigned int v19 = &v14[8 * v10 - 16];
      uint64_t v20 = (long long *)(v5 - 2);
      uint64_t v21 = v18 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v22 = *v20;
        *(v19 - 1) = *(v20 - 1);
        *unsigned int v19 = v22;
        v19 -= 2;
        v20 -= 2;
        v21 -= 4;
      }
      while (v21);
      v15 -= v18 & 0x3FFFFFFFFFFFFFFCLL;
      if (v18 != (v18 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_59:
        do
        {
          uint64_t v23 = *--v6;
          *--uint64_t v15 = v23;
        }
        while (v6 != (void *)v8);
        float v8 = *(unsigned char **)this;
      }
    }
    *(void *)this = v15;
    *((void *)this + 1) = v7;
    *((void *)this + 2) = v16;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    void *v5 = a2;
    float v7 = v5 + 1;
  }
  *((void *)this + 1) = v7;
  __double2 v25 = (unsigned char *)*((void *)this + 7);
  unint64_t v24 = *((void *)this + 8);
  if ((unint64_t)v25 < v24)
  {
    *__double2 v25 = 0;
    uint64_t v26 = (uint64_t)(v25 + 1);
    goto LABEL_54;
  }
  double v27 = (unsigned char *)*((void *)this + 6);
  unint64_t v28 = v25 - v27;
  uint64_t v29 = v25 - v27 + 1;
  if (v29 < 0) {
LABEL_55:
  }
    abort();
  unint64_t v30 = v24 - (void)v27;
  if (2 * v30 > v29) {
    uint64_t v29 = 2 * v30;
  }
  if (v30 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v31 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v31 = v29;
  }
  if (v31) {
    double v32 = (char *)operator new(v31);
  }
  else {
    double v32 = 0;
  }
  uint64_t v33 = &v32[v28];
  double v34 = &v32[v31];
  v32[v28] = 0;
  uint64_t v26 = (uint64_t)&v32[v28 + 1];
  if (v25 == v27) {
    goto LABEL_52;
  }
  if (v28 < 8 || (unint64_t)(v27 - v32) < 0x20) {
    goto LABEL_49;
  }
  if (v28 >= 0x20)
  {
    unint64_t v35 = v28 & 0xFFFFFFFFFFFFFFE0;
    uint64_t v36 = (long long *)(v25 - 16);
    unint64_t v37 = &v32[v25 - 16 - v27];
    unint64_t v38 = v28 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      long long v39 = *v36;
      *((_OWORD *)v37 - 1) = *(v36 - 1);
      *(_OWORD *)unint64_t v37 = v39;
      v37 -= 32;
      v36 -= 2;
      v38 -= 32;
    }
    while (v38);
    if (v28 == v35) {
      goto LABEL_51;
    }
    if ((v28 & 0x18) == 0)
    {
      v33 -= v35;
      v25 -= v35;
      goto LABEL_49;
    }
  }
  else
  {
    unint64_t v35 = 0;
  }
  unint64_t v40 = v35 - (v28 & 0xFFFFFFFFFFFFFFF8);
  unint64_t v41 = &v25[-v35 - 8];
  int64_t v42 = v41 - v27;
  do
  {
    uint64_t v43 = *(void *)v41;
    v41 -= 8;
    *(void *)&v32[v42] = v43;
    v42 -= 8;
    v40 += 8;
  }
  while (v40);
  if (v28 == (v28 & 0xFFFFFFFFFFFFFFF8)) {
    goto LABEL_51;
  }
  v33 -= v28 & 0xFFFFFFFFFFFFFFF8;
  v25 -= v28 & 0xFFFFFFFFFFFFFFF8;
LABEL_49:
  uint64_t v44 = v33 - 1;
  do
  {
    char v45 = *--v25;
    *v44-- = v45;
  }
  while (v25 != v27);
LABEL_51:
  uint64_t v33 = v32;
LABEL_52:
  *((void *)this + 6) = v33;
  *((void *)this + 7) = v26;
  *((void *)this + 8) = v34;
  if (v27) {
    operator delete(v27);
  }
LABEL_54:
  *((void *)this + 7) = v26;
}

void md::GraphTraversalPath::visit(md::GraphTraversalPath *this, const MuninRoadEdge *a2)
{
  float v5 = (char *)*((void *)this + 4);
  unint64_t v4 = *((void *)this + 5);
  int64_t v6 = v5;
  if ((unint64_t)v5 >= v4)
  {
    float v8 = (char *)*((void *)this + 3);
    uint64_t v9 = (v5 - v8) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      goto LABEL_55;
    }
    uint64_t v11 = v4 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v13 = operator new(8 * v12);
    }
    else
    {
      unint64_t v13 = 0;
    }
    float v14 = &v13[8 * v9];
    uint64_t v15 = &v13[8 * v12];
    *float v14 = a2;
    float v7 = v14 + 1;
    if (v5 == v8)
    {
      float v8 = v5;
    }
    else
    {
      unint64_t v16 = v5 - v8 - 8;
      if (v16 < 0x58) {
        goto LABEL_59;
      }
      if ((unint64_t)(v8 - v13) < 0x20) {
        goto LABEL_59;
      }
      uint64_t v17 = (v16 >> 3) + 1;
      int64_t v6 = &v5[-8 * (v17 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v18 = &v13[8 * v9 - 16];
      unsigned int v19 = v5 - 16;
      uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v21 = *(_OWORD *)v19;
        *(v18 - 1) = *((_OWORD *)v19 - 1);
        _OWORD *v18 = v21;
        v18 -= 2;
        v19 -= 32;
        v20 -= 4;
      }
      while (v20);
      v14 -= v17 & 0x3FFFFFFFFFFFFFFCLL;
      if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_59:
        do
        {
          uint64_t v22 = *((void *)v6 - 1);
          v6 -= 8;
          *--float v14 = v22;
        }
        while (v6 != v8);
        float v8 = (char *)*((void *)this + 3);
      }
    }
    *((void *)this + 3) = v14;
    *((void *)this + 4) = v7;
    *((void *)this + 5) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *(void *)float v5 = a2;
    float v7 = v5 + 8;
  }
  *((void *)this + 4) = v7;
  unint64_t v24 = (unsigned char *)*((void *)this + 7);
  unint64_t v23 = *((void *)this + 8);
  if ((unint64_t)v24 < v23)
  {
    *unint64_t v24 = 1;
    uint64_t v25 = (uint64_t)(v24 + 1);
    goto LABEL_54;
  }
  uint64_t v26 = (unsigned char *)*((void *)this + 6);
  unint64_t v27 = v24 - v26;
  uint64_t v28 = v24 - v26 + 1;
  if (v28 < 0) {
LABEL_55:
  }
    abort();
  unint64_t v29 = v23 - (void)v26;
  if (2 * v29 > v28) {
    uint64_t v28 = 2 * v29;
  }
  if (v29 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v30 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v30 = v28;
  }
  if (v30) {
    size_t v31 = (char *)operator new(v30);
  }
  else {
    size_t v31 = 0;
  }
  double v32 = &v31[v27];
  uint64_t v33 = &v31[v30];
  v31[v27] = 1;
  uint64_t v25 = (uint64_t)&v31[v27 + 1];
  if (v24 == v26) {
    goto LABEL_52;
  }
  if (v27 < 8 || (unint64_t)(v26 - v31) < 0x20) {
    goto LABEL_49;
  }
  if (v27 >= 0x20)
  {
    unint64_t v34 = v27 & 0xFFFFFFFFFFFFFFE0;
    unint64_t v35 = (long long *)(v24 - 16);
    uint64_t v36 = &v31[v24 - 16 - v26];
    unint64_t v37 = v27 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      long long v38 = *v35;
      *((_OWORD *)v36 - 1) = *(v35 - 1);
      *(_OWORD *)uint64_t v36 = v38;
      v36 -= 32;
      v35 -= 2;
      v37 -= 32;
    }
    while (v37);
    if (v27 == v34) {
      goto LABEL_51;
    }
    if ((v27 & 0x18) == 0)
    {
      v32 -= v34;
      v24 -= v34;
      goto LABEL_49;
    }
  }
  else
  {
    unint64_t v34 = 0;
  }
  unint64_t v39 = v34 - (v27 & 0xFFFFFFFFFFFFFFF8);
  unint64_t v40 = &v24[-v34 - 8];
  int64_t v41 = v40 - v26;
  do
  {
    uint64_t v42 = *(void *)v40;
    v40 -= 8;
    *(void *)&v31[v41] = v42;
    v41 -= 8;
    v39 += 8;
  }
  while (v39);
  if (v27 == (v27 & 0xFFFFFFFFFFFFFFF8)) {
    goto LABEL_51;
  }
  v32 -= v27 & 0xFFFFFFFFFFFFFFF8;
  v24 -= v27 & 0xFFFFFFFFFFFFFFF8;
LABEL_49:
  uint64_t v43 = v32 - 1;
  do
  {
    char v44 = *--v24;
    *v43-- = v44;
  }
  while (v24 != v26);
LABEL_51:
  double v32 = v31;
LABEL_52:
  *((void *)this + 6) = v32;
  *((void *)this + 7) = v25;
  *((void *)this + 8) = v33;
  if (v26) {
    operator delete(v26);
  }
LABEL_54:
  *((void *)this + 7) = v25;
}

uint64_t **std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3)
{
  int64_t v6 = a1 + 1;
  float v5 = a1[1];
  if (v5)
  {
    int v7 = *((char *)a2 + 23);
    if (v7 >= 0) {
      float v8 = a2;
    }
    else {
      float v8 = *a2;
    }
    if (v7 >= 0) {
      size_t v9 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v9 = (size_t)a2[1];
    }
    while (1)
    {
      unint64_t v10 = (uint64_t **)v5;
      unint64_t v13 = (const void *)v5[4];
      uint64_t v11 = v5 + 4;
      unint64_t v12 = v13;
      int v14 = *((char *)v11 + 23);
      if (v14 >= 0) {
        uint64_t v15 = v11;
      }
      else {
        uint64_t v15 = v12;
      }
      if (v14 >= 0) {
        size_t v16 = *((unsigned __int8 *)v11 + 23);
      }
      else {
        size_t v16 = v11[1];
      }
      if (v16 >= v9) {
        size_t v17 = v9;
      }
      else {
        size_t v17 = v16;
      }
      int v18 = memcmp(v8, v15, v17);
      if (v18)
      {
        if (v18 < 0) {
          goto LABEL_8;
        }
LABEL_22:
        int v19 = memcmp(v15, v8, v17);
        if (v19)
        {
          if ((v19 & 0x80000000) == 0) {
            return v10;
          }
        }
        else if (v16 >= v9)
        {
          return v10;
        }
        float v5 = v10[1];
        if (!v5)
        {
          int64_t v6 = v10 + 1;
          goto LABEL_29;
        }
      }
      else
      {
        if (v9 >= v16) {
          goto LABEL_22;
        }
LABEL_8:
        float v5 = *v10;
        int64_t v6 = v10;
        if (!*v10) {
          goto LABEL_29;
        }
      }
    }
  }
  unint64_t v10 = a1 + 1;
LABEL_29:
  uint64_t v20 = operator new(0x50uLL);
  long long v21 = (std::string *)(v20 + 4);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v21, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v21->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v20[6] = *(void *)(a3 + 16);
  }
  v20[7] = 0;
  v20[8] = 0;
  v20[9] = 0;
  *uint64_t v20 = 0;
  v20[1] = 0;
  _DWORD v20[2] = v10;
  *int64_t v6 = v20;
  uint64_t v22 = (uint64_t *)**a1;
  unint64_t v23 = v20;
  if (v22)
  {
    *a1 = v22;
    unint64_t v23 = *v6;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v23);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return (uint64_t **)v20;
}

void md::FlyoverDsmLayerDataSource::resourceKeyForType(uint64_t a1@<X0>, char a2@<W1>, unsigned __int8 *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  if (*(unsigned char *)a5) {
    int v10 = *(_DWORD *)(a5 + 4);
  }
  else {
    int v10 = 2147483646;
  }
  md::FlyoverMetaData::tileCacheLookup((md::FlyoverMetaData *)&v20, *(const QuadTile **)(a1 + 752), a3, 0, 0);
  uint64_t v11 = *(void *)(a3 + 4);
  int v19 = v11;
  int v12 = a3[1];
  int v13 = *a3;
  *(unsigned char *)a6 = a2;
  *(_WORD *)(a6 + 2) = 50;
  *(_DWORD *)(a6 + 4) = v10;
  *(void *)(a6 + 8) = a6 + 40;
  *(void *)(a6 + 16) = a6 + 40;
  *(void *)(a6 + 24) = a6 + 40;
  *(void *)(a6 + 32) = 32;
  *(void *)(a6 + 72) = 0;
  int v20 = HIDWORD(v11);
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v20, v21);
  int v20 = v19;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v20, v21);
  int v20 = v12;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v20, v21);
  int v20 = v13;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v20, v21);
  int v20 = 0;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v20, v21);
  int v20 = 0;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v20, v21);
  int v14 = *(unsigned __int8 **)(a6 + 16);
  uint64_t v15 = *(unsigned __int8 **)(a6 + 8);
  unint64_t v16 = v14 - v15;
  if (v14 == v15)
  {
    unint64_t v17 = 0;
  }
  else
  {
    unint64_t v17 = 0;
    if (v16 <= 1) {
      unint64_t v16 = 1;
    }
    do
    {
      unsigned int v18 = *v15++;
      v17 ^= (v17 << 6) + (v17 >> 2) - 0x61C8864680B583EBLL + v18;
      --v16;
    }
    while (v16);
  }
  *(void *)(a6 + 72) = v17;
  *(void *)(a6 + 88) = a4;
}

uint64_t md::FlyoverDsmLayerDataSource::updateRequest()
{
  return 1;
}

void md::FlyoverDsmLayerDataSource::createLayerData(uint64_t a1@<X1>, uint64_t *a2@<X2>, _OWORD *a3@<X8>)
{
  memset(v38, 0, sizeof(v38));
  gdc::LayerDataSource::populateLoadMetadataListFromMap(*a2, a2[1], v38);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    while (*(_WORD *)v6 != 50)
    {
      v6 += 48;
      if (v6 == v7) {
        goto LABEL_10;
      }
    }
  }
  if (v6 == v7 || *(void *)(v6 + 32) != 1)
  {
LABEL_10:
    uint64_t v9 = 0;
    goto LABEL_11;
  }
  uint64_t v8 = *(void *)(v6 + 24);
  uint64_t v9 = *(void *)(v8 + 112);
  int v10 = *(std::__shared_weak_count **)(v8 + 120);
  if (!v10)
  {
LABEL_11:
    uint64_t v36 = v9;
    unint64_t v37 = 0;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v36 = v9;
  unint64_t v37 = v10;
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
LABEL_12:
  uint64_t v11 = *a2;
  uint64_t v12 = a2[1];
  if (*a2 != v12)
  {
    while (*(_WORD *)v11 != 20)
    {
      v11 += 48;
      if (v11 == v12) {
        goto LABEL_22;
      }
    }
  }
  if (v11 == v12 || *(void *)(v11 + 32) != 1)
  {
LABEL_22:
    uint64_t v14 = 0;
    goto LABEL_23;
  }
  uint64_t v13 = *(void *)(v11 + 24);
  uint64_t v14 = *(void *)(v13 + 112);
  uint64_t v15 = *(std::__shared_weak_count **)(v13 + 120);
  if (!v15)
  {
LABEL_23:
    unint64_t v35 = 0;
    goto LABEL_24;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v34 = v14;
  unint64_t v35 = v15;
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  uint64_t v14 = v34;
LABEL_24:
  uint64_t v30 = 0;
  size_t v31 = 0;
  if (v14 && (unint64_t v16 = *(void **)(v14 + 144)) != 0 && *v16 != v16[1])
  {
    if (v35) {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v32 = v14;
    uint64_t v33 = v35;
    if (v37)
    {
      atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v30 = v36;
      size_t v31 = v37;
    }
    else
    {
      uint64_t v30 = v36;
      size_t v31 = 0;
    }
  }
  else
  {
    if (v37) {
      atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v32 = v36;
    uint64_t v33 = v37;
  }
  unint64_t v17 = (char *)operator new(0x308uLL);
  *((void *)v17 + 1) = 0;
  *((void *)v17 + 2) = 0;
  *(void *)unint64_t v17 = &unk_1EF580790;
  v39[0] = 0;
  v39[1] = 0;
  md::MapTileData::MapTileData((uint64_t)(v17 + 24), a1, (uint64_t)v38, v39, 1);
  *((void *)v17 + 3) = &unk_1EF536C68;
  *((void *)v17 + 82) = &unk_1EF536CD0;
  *((void *)v17 + 3) = &unk_1EF538F50;
  *((void *)v17 + 82) = &unk_1EF538FB8;
  *(_OWORD *)(v17 + 744) = 0u;
  *(_OWORD *)(v17 + 760) = 0u;
  if (v32)
  {
    unsigned int v18 = v17 + 744;
    long long v19 = *(_OWORD *)(v32 + 144);
    uint64_t v20 = *(void *)(v32 + 152);
    if (v20)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
      long long v21 = (std::__shared_weak_count *)*((void *)v17 + 94);
      _OWORD *v18 = v19;
      if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    else
    {
      _OWORD *v18 = v19;
    }
  }
  *(void *)&long long v22 = v17 + 24;
  *((void *)&v22 + 1) = v17;
  if (v30)
  {
    uint64_t v23 = *(void *)(v30 + 144);
    unint64_t v24 = *(std::__shared_weak_count **)(v30 + 152);
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *((void *)v17 + 95) = v23;
    uint64_t v25 = (std::__shared_weak_count *)*((void *)v17 + 96);
    *((void *)v17 + 96) = v24;
    if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      long long v28 = v22;
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
      long long v22 = v28;
    }
    if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      long long v29 = v22;
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
      long long v22 = v29;
    }
  }
  *a3 = v22;
  if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
  if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
    uint64_t v26 = v37;
    if (!v37) {
      goto LABEL_59;
    }
  }
  else
  {
    uint64_t v26 = v37;
    if (!v37) {
      goto LABEL_59;
    }
  }
  if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
    unint64_t v27 = v38[0];
    if (!v38[0]) {
      return;
    }
    goto LABEL_60;
  }
LABEL_59:
  unint64_t v27 = v38[0];
  if (!v38[0]) {
    return;
  }
LABEL_60:
  operator delete(v27);
}

void sub_1A2078084(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va3, a4);
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v13 = va_arg(va3, void);
  uint64_t v15 = va_arg(va3, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va3);
  uint64_t v6 = *(void **)(v4 - 72);
  if (v6) {
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<md::FlyoverDsmTileData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::FlyoverDsmTileData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580790;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::FlyoverDsmTileData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580790;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::FlyoverDsmLayerDataSource::constructRequests(uint64_t a1, void **a2, void **a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a3;
    for (uint64_t i = a2; i != v4; i += 2)
    {
      uint64_t v7 = (int32x2_t *)(*i)[2];
      __int32 v8 = v7[1].i32[0];
      unsigned __int8 v70 = v7[1].i32[1];
      unsigned __int8 v71 = v8;
      int32x2_t v72 = vrev64_s32(*v7);
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 24) + 16))(&v67);
      if ((_BYTE)v67)
      {
        md::FlyoverMetaData::tileCacheLookup((md::FlyoverMetaData *)v56, *(const QuadTile **)(a1 + 752), v68, 0, 1);
        int v9 = v64;
        if (!v64 || (int v3 = BYTE4(v61), BYTE4(v61) == 1))
        {
          (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 24) + 24))(&v50);
          if ((_BYTE)v50)
          {
            if (HIDWORD(v50) <= v68[1] && v51[0] >= v68[1])
            {
              uint64_t v10 = *i;
              int v47 = v3;
              if (*((unsigned char *)*i + 96)) {
                int v11 = *((_DWORD *)v10 + 25);
              }
              else {
                int v11 = 2147483646;
              }
              char v23 = *v10;
              uint64_t v44 = *((void *)v10 + 14);
              md::FlyoverMetaData::tileCacheLookup((md::FlyoverMetaData *)&v73, *(const QuadTile **)(a1 + 752), v68, 0, 0);
              __int32 v42 = v69;
              __int32 v24 = v68[1];
              __int32 v25 = v68[0];
              v56[0] = v23;
              __int16 v57 = 20;
              int v58 = v11;
              long long v59 = v63;
              long long v60 = v63;
              long long v61 = v63;
              uint64_t v62 = 32;
              unint64_t v65 = 0;
              if (v76) {
                uint64_t v26 = v75;
              }
              else {
                uint64_t v26 = 0;
              }
              if ((v26 & 0xFF00000000) != 0) {
                __int32 v27 = v26;
              }
              else {
                __int32 v27 = 0;
              }
              __int32 v73 = HIDWORD(v69);
              geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v63, (char *)&v73, v74);
              __int32 v73 = v42;
              geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
              __int32 v73 = v24;
              geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
              __int32 v73 = v25;
              geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
              __int32 v73 = 0;
              geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
              __int32 v73 = v27;
              geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
              long long v28 = (unsigned __int8 *)v59;
              unint64_t v29 = v60 - (unsigned char *)v59;
              if (v60 == v59)
              {
                unint64_t v30 = 0;
                uint64_t v4 = a3;
                int v3 = v47;
              }
              else
              {
                unint64_t v30 = 0;
                if (v29 <= 1) {
                  unint64_t v29 = 1;
                }
                uint64_t v4 = a3;
                int v3 = v47;
                do
                {
                  unsigned int v31 = *v28++;
                  v30 ^= (v30 << 6) - 0x61C8864680B583EBLL + (v30 >> 2) + v31;
                  --v29;
                }
                while (v29);
              }
              unint64_t v65 = v30;
              uint64_t v66 = v44;
              gdc::LayerDataRequest::request(*i, (uint64_t)v56, v9 == 0);
              if (v59 != v61) {
                free(v59);
              }
            }
          }
        }
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 24) + 24))(&v54);
        __int16 v52 = *(_WORD *)v68;
        uint64_t v53 = v69;
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 24) + 16))(&v50);
        if (!(_BYTE)v50 || !(_BYTE)v54 || HIDWORD(v54) > BYTE1(v51[0]) || v55 < BYTE1(v51[0])) {
          continue;
        }
        uint64_t v32 = (char *)*i;
        int v49 = v3;
        int v33 = *((unsigned char *)*i + 96) ? *((_DWORD *)v32 + 25) : 2147483646;
        char v34 = *v32;
        uint64_t v35 = *((void *)v32 + 14);
        md::FlyoverMetaData::tileCacheLookup((md::FlyoverMetaData *)&v73, *(const QuadTile **)(a1 + 752), (unsigned __int8 *)v51, 0, 0);
        __int32 v45 = v51[1];
        __int32 v36 = BYTE1(v51[0]);
        __int32 v37 = LOBYTE(v51[0]);
        v56[0] = v34;
        __int16 v57 = 50;
        int v58 = v33;
        long long v59 = v63;
        long long v60 = v63;
        long long v61 = v63;
        uint64_t v62 = 32;
        unint64_t v65 = 0;
        __int32 v73 = v51[2];
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v63, (char *)&v73, v74);
        __int32 v73 = v45;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
        __int32 v73 = v36;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
        __int32 v73 = v37;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
        __int32 v73 = 0;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
        __int32 v73 = 0;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
        long long v38 = (unsigned __int8 *)v59;
        unint64_t v39 = v60 - (unsigned char *)v59;
        if (v60 == v59)
        {
          unint64_t v40 = 0;
          uint64_t v4 = a3;
          int v3 = v49;
        }
        else
        {
          unint64_t v40 = 0;
          if (v39 <= 1) {
            unint64_t v39 = 1;
          }
          uint64_t v4 = a3;
          int v3 = v49;
          do
          {
            unsigned int v41 = *v38++;
            v40 ^= (v40 << 6) - 0x61C8864680B583EBLL + (v40 >> 2) + v41;
            --v39;
          }
          while (v39);
        }
        unint64_t v65 = v40;
        uint64_t v66 = v35;
        gdc::LayerDataRequest::request(*i, (uint64_t)v56, 0);
        long long v22 = v59;
        if (v59 == v61) {
          continue;
        }
      }
      else
      {
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 24) + 24))(&v50);
        if (!(_BYTE)v50 || HIDWORD(v50) > v71 || v51[0] < v71) {
          continue;
        }
        uint64_t v12 = (char *)*i;
        int v48 = v3;
        int v13 = *((unsigned char *)*i + 96) ? *((_DWORD *)v12 + 25) : 2147483646;
        char v14 = *v12;
        uint64_t v15 = *((void *)v12 + 14);
        md::FlyoverMetaData::tileCacheLookup((md::FlyoverMetaData *)&v73, *(const QuadTile **)(a1 + 752), &v70, 0, 0);
        __int32 v43 = v72.i32[0];
        __int32 v16 = v71;
        __int32 v17 = v70;
        v56[0] = v14;
        __int16 v57 = 50;
        int v58 = v13;
        long long v59 = v63;
        long long v60 = v63;
        long long v61 = v63;
        uint64_t v62 = 32;
        unint64_t v65 = 0;
        __int32 v73 = v72.i32[1];
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v63, (char *)&v73, v74);
        __int32 v73 = v43;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
        __int32 v73 = v16;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
        __int32 v73 = v17;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
        __int32 v73 = 0;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
        __int32 v73 = 0;
        geo::small_vector_base<unsigned char>::insert<unsigned char *>(&v59, v60, (char *)&v73, v74);
        unsigned int v18 = (unsigned __int8 *)v59;
        unint64_t v19 = v60 - (unsigned char *)v59;
        if (v60 == v59)
        {
          unint64_t v20 = 0;
          uint64_t v4 = a3;
          int v3 = v48;
        }
        else
        {
          unint64_t v20 = 0;
          if (v19 <= 1) {
            unint64_t v19 = 1;
          }
          uint64_t v4 = a3;
          int v3 = v48;
          do
          {
            unsigned int v21 = *v18++;
            v20 ^= (v20 << 6) - 0x61C8864680B583EBLL + (v20 >> 2) + v21;
            --v19;
          }
          while (v19);
        }
        unint64_t v65 = v20;
        uint64_t v66 = v15;
        gdc::LayerDataRequest::request(*i, (uint64_t)v56, 0);
        long long v22 = v59;
        if (v59 == v61) {
          continue;
        }
      }
      free(v22);
    }
  }
}

void md::FlyoverDsmLayerDataSource::didProcessNewLayerData(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 768);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 128);
    if (v3)
    {
      uint64_t v4 = *(void **)(v3 + 24);
      if (v4)
      {
        uint64_t v5 = *a2;
        uint64_t v6 = a2[1];
        if (*a2 != v6)
        {
          do
          {
            uint64_t v7 = *(int **)(v5 + 24);
            int v8 = v7[1];
            int v9 = *v7;
            LODWORD(v7) = 1 << *((unsigned char *)v7 + 8);
            double v10 = 1.0 / (double)(int)v7;
            double v11 = v10 * (double)v9;
            double v12 = v10 * (double)((int)v7 + ~v8);
            double v13 = v11 + v10;
            double v14 = v12 + v10;
            md::MercatorTerrainHeightCache::invalidateRect(v4, &v11);
            v5 += 120;
          }
          while (v5 != v6);
        }
      }
    }
  }
}

void md::FlyoverDsmLayerDataSource::~FlyoverDsmLayerDataSource(md::FlyoverDsmLayerDataSource *this)
{
  *(void *)this = &unk_1EF546638;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 95);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF546638;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 95);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
}

void md::mun::MuninLayer::render(md::mun::MuninLayer *this, const md::LayoutContext *a2)
{
  uint64_t v2 = (void *)*((void *)a2 + 1);
  int8x8_t v3 = (int8x8_t)v2[1];
  if (v3)
  {
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(v3);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      unint64_t v7 = 0xC83717EF586624DCLL;
      if (*(void *)&v3 <= 0xC83717EF586624DCLL) {
        unint64_t v7 = 0xC83717EF586624DCLL % *(void *)&v3;
      }
    }
    else
    {
      unint64_t v7 = (*(void *)&v3 - 1) & 0xC83717EF586624DCLL;
    }
    int v8 = *(void **)(*v2 + 8 * v7);
    if (v8)
    {
      int v9 = (void *)*v8;
      if (v9)
      {
        if (v6.u32[0] < 2uLL)
        {
          uint64_t v10 = *(void *)&v3 - 1;
          while (1)
          {
            uint64_t v12 = v9[1];
            if (v12 == 0xC83717EF586624DCLL)
            {
              if (v9[2] == 0xC83717EF586624DCLL) {
                goto LABEL_22;
              }
            }
            else if ((v12 & v10) != v7)
            {
              return;
            }
            int v9 = (void *)*v9;
            if (!v9) {
              return;
            }
          }
        }
        do
        {
          unint64_t v11 = v9[1];
          if (v11 == 0xC83717EF586624DCLL)
          {
            if (v9[2] == 0xC83717EF586624DCLL)
            {
LABEL_22:
              uint64_t v13 = v9[5];
              if (*(void *)(v13 + 8) == 0xC83717EF586624DCLL)
              {
                uint64_t v14 = *(void *)(v13 + 32);
                if (v14)
                {
                  md::RenderItemPool::reset((uint64_t *)(*((void *)this + 8) + 192));
                  ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(*((void *)this + 8) + 232));
                  ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(*((void *)this + 8) + 256));
                  uint64_t v15 = *(void *)(*((void *)this + 8) + 168);
                  uint64_t v30 = 0;
                  v29[0] = 0;
                  v29[1] = 0;
                  uint64_t v16 = *(void *)(v15 + 8);
                  uint64_t v31 = 0;
                  uint64_t v32 = v15;
                  uint64_t v33 = 0;
                  uint64_t v34 = v16;
                  __int16 v35 = 1;
                  if (v16) {
                    uint64_t v17 = *(void *)(v15 + 72);
                  }
                  else {
                    uint64_t v17 = 0;
                  }
                  uint64_t v36 = v17;
                  ggl::BufferMemory::operator=(v29, (uint64_t)&v31);
                  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v31);
                  id v18 = *(id *)a2;
                  [v18 sizeInPixels];
                  *(float *)&double v19 = v19;
                  *(_DWORD *)uint64_t v30 = LODWORD(v19);

                  id v20 = *(id *)a2;
                  [v20 sizeInPixels];
                  float v22 = v21;
                  *(float *)(v30 + 4) = v22;

                  *(void *)(v30 + 8) = 0x4228000040800000;
                  uint64_t v23 = *(void *)(*((void *)this + 8) + 112);
                  long long v28 = 0;
                  v27[0] = 0;
                  v27[1] = 0;
                  uint64_t v24 = *(void *)(v23 + 8);
                  uint64_t v31 = 0;
                  uint64_t v32 = v23;
                  uint64_t v33 = 0;
                  uint64_t v34 = v24;
                  __int16 v35 = 1;
                  if (v24) {
                    uint64_t v25 = *(void *)(v23 + 72);
                  }
                  else {
                    uint64_t v25 = 0;
                  }
                  uint64_t v36 = v25;
                  ggl::BufferMemory::operator=(v27, (uint64_t)&v31);
                  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v31);
                  _OWORD *v28 = xmmword_1A28FE140;
                  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)v27);
                  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)v29);
                  uint64_t v26 = *(void *)(v14 + 200) - *(void *)(v14 + 192);
                  if (v26)
                  {
                    if (v26 == 8) {
                      md::mun::MuninLayer::renderPanorama(this, a2);
                    }
                    else {
                      md::mun::MuninLayer::renderTransition(this, a2);
                    }
                  }
                  else
                  {
                    md::mun::MuninLayer::renderNothing(this, *((int8x8_t **)a2 + 1));
                  }
                }
              }
              return;
            }
          }
          else
          {
            if (v11 >= *(void *)&v3) {
              v11 %= *(void *)&v3;
            }
            if (v11 != v7) {
              return;
            }
          }
          int v9 = (void *)*v9;
        }
        while (v9);
      }
    }
  }
}

void sub_1A2078D50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va);
  _Unwind_Resume(a1);
}

void *md::mun::MuninLayer::renderNothing(void *this, int8x8_t *a2)
{
  int8x8_t v2 = a2[1];
  if (v2)
  {
    int8x8_t v3 = this;
    uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
    {
      unint64_t v5 = 0xC83717EF586624DCLL;
      if (*(void *)&v2 <= 0xC83717EF586624DCLL) {
        unint64_t v5 = 0xC83717EF586624DCLL % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v5 = (*(void *)&v2 - 1) & 0xC83717EF586624DCLL;
    }
    uint8x8_t v6 = *(void **)(*(void *)a2 + 8 * v5);
    if (v6)
    {
      unint64_t v7 = (void *)*v6;
      if (v7)
      {
        if (v4.u32[0] < 2uLL)
        {
          uint64_t v8 = *(void *)&v2 - 1;
          while (1)
          {
            uint64_t v10 = v7[1];
            if (v10 == 0xC83717EF586624DCLL)
            {
              if (v7[2] == 0xC83717EF586624DCLL) {
                goto LABEL_22;
              }
            }
            else if ((v10 & v8) != v5)
            {
              return this;
            }
            unint64_t v7 = (void *)*v7;
            if (!v7) {
              return this;
            }
          }
        }
        while (1)
        {
          unint64_t v9 = v7[1];
          if (v9 == 0xC83717EF586624DCLL) {
            break;
          }
          if (v9 >= *(void *)&v2) {
            v9 %= *(void *)&v2;
          }
          if (v9 != v5) {
            return this;
          }
LABEL_11:
          unint64_t v7 = (void *)*v7;
          if (!v7) {
            return this;
          }
        }
        if (v7[2] != 0xC83717EF586624DCLL) {
          goto LABEL_11;
        }
LABEL_22:
        uint64_t v11 = v7[5];
        if (*(void *)(v11 + 8) == 0xC83717EF586624DCLL)
        {
          if (*(void *)(v11 + 32))
          {
            uint64_t v12 = *(void **)(*(void *)(this[5] + 24) + 8);
            uint64_t v13 = v12[3];
            uint64_t v14 = v12[4];
            uint64_t v15 = v14 - v13;
            if (v14 == v13) {
              goto LABEL_31;
            }
            uint64_t v16 = 0;
            unint64_t v17 = v15 >> 3;
            while (1)
            {
              uint64_t v18 = *(void *)(v13 + 8 * v16);
              if (!*(unsigned char *)v18)
              {
                unint64_t v19 = *(void *)(v18 + 8);
                uint64_t v20 = v12[15];
                if (v19 < (v12[16] - v20) >> 3) {
                  break;
                }
              }
              if (++v16 >= v17) {
                goto LABEL_31;
              }
            }
            uint64_t v21 = *(void *)(v20 + 8 * v19);
            if (!v21) {
LABEL_31:
            }
              float v22 = 0;
            else {
              float v22 = **(void ***)(v21 + 24);
            }
            uint64_t v23 = v22[9];
            if (v22[10] != v23) {
              v22[10] = v23;
            }
            uint64_t v25 = (void *)v22[29];
            uint64_t v24 = (void *)v22[30];
            if (v24 != v25)
            {
              uint64_t v26 = v24 - 4;
              __int32 v27 = v24 - 4;
              do
              {
                this = (void *)v27[3];
                if (v27 == this)
                {
                  this = (void *)(*(uint64_t (**)(void *))(*v27 + 32))(v27);
                }
                else if (this)
                {
                  this = (void *)(*(uint64_t (**)(void *))(*this + 40))(this);
                }
                long long v28 = v27 - 4;
                v27 -= 8;
                v26 -= 8;
              }
              while (v28 != v25);
            }
            v22[30] = v25;
            uint64_t v30 = (void *)v22[25];
            unint64_t v29 = (void *)v22[26];
            if (v29 != v30)
            {
              uint64_t v31 = v29 - 4;
              uint64_t v32 = v29 - 4;
              do
              {
                this = (void *)v32[3];
                if (v32 == this)
                {
                  this = (void *)(*(uint64_t (**)(void *))(*v32 + 32))(v32);
                  if (!*((unsigned char *)v32 - 28)) {
                    goto LABEL_49;
                  }
                }
                else
                {
                  if (this) {
                    this = (void *)(*(uint64_t (**)(void *))(*this + 40))(this);
                  }
                  if (!*((unsigned char *)v32 - 28)) {
                    goto LABEL_49;
                  }
                }
                *((unsigned char *)v32 - 28) = 0;
LABEL_49:
                if (*((unsigned char *)v32 - 32)) {
                  *((unsigned char *)v32 - 32) = 0;
                }
                uint64_t v33 = v32 - 6;
                v32 -= 10;
                v31 -= 10;
              }
              while (v33 != v30);
            }
            v22[26] = v30;
            v22[4] = *(void *)(v3[8] + 104);
          }
        }
      }
    }
  }
  return this;
}

void md::mun::MuninLayer::renderPanorama(md::mun::MuninLayer *this, const md::LayoutContext *a2)
{
  int8x8_t v2 = (void *)*((void *)a2 + 1);
  int8x8_t v3 = (int8x8_t)v2[1];
  if (!*(void *)&v3) {
    return;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v6 = 0xC83717EF586624DCLL;
    if (*(void *)&v3 <= 0xC83717EF586624DCLL) {
      unint64_t v6 = 0xC83717EF586624DCLL % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v6 = (*(void *)&v3 - 1) & 0xC83717EF586624DCLL;
  }
  unint64_t v7 = *(void **)(*v2 + 8 * v6);
  if (!v7) {
    return;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    return;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v3 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0xC83717EF586624DCLL)
      {
        if (v8[2] == 0xC83717EF586624DCLL) {
          goto LABEL_22;
        }
      }
      else if ((v11 & v9) != v6)
      {
        return;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        return;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0xC83717EF586624DCLL) {
      break;
    }
    if (v10 >= *(void *)&v3) {
      v10 %= *(void *)&v3;
    }
    if (v10 != v6) {
      return;
    }
LABEL_11:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      return;
    }
  }
  if (v8[2] != 0xC83717EF586624DCLL) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) != 0xC83717EF586624DCLL) {
    return;
  }
  uint64_t v13 = *(void **)(v12 + 32);
  if (!v13) {
    return;
  }
  uint64_t v14 = (void *)md::PassList::commandBufferForId(*(void **)(*(void *)(*((void *)this + 5) + 24) + 8), 0, 0);
  uint64_t v15 = v14;
  uint64_t v16 = v14[9];
  if (v14[10] != v16) {
    v14[10] = v16;
  }
  ggl::CommandBuffer::clearBufferLoadItems(v14);
  ggl::CommandBuffer::clearTextureLoadItems(v15);
  v15[4] = *(void *)(*((void *)this + 8) + 104);
  unint64_t v17 = (unint64_t *)v13[24];
  if ((unint64_t *)v13[25] == v17) {
    return;
  }
  uint64_t v18 = (void *)*((void *)a2 + 1);
  int8x8_t v19 = (int8x8_t)v18[1];
  if (!*(void *)&v19) {
    goto LABEL_50;
  }
  uint8x8_t v20 = (uint8x8_t)vcnt_s8(v19);
  v20.i16[0] = vaddlv_u8(v20);
  if (v20.u32[0] > 1uLL)
  {
    uint64_t v21 = 0x1AF456233693CD46;
    if (*(void *)&v19 <= 0x1AF456233693CD46uLL) {
      uint64_t v21 = 0x1AF456233693CD46uLL % *(void *)&v19;
    }
  }
  else
  {
    uint64_t v21 = (*(void *)&v19 - 1) & 0x1AF456233693CD46;
  }
  float v22 = *(void **)(*v18 + 8 * v21);
  if (!v22) {
    goto LABEL_50;
  }
  uint64_t v23 = (void *)*v22;
  if (!v23) {
    goto LABEL_50;
  }
  if (v20.u32[0] < 2uLL)
  {
    uint64_t v24 = *(void *)&v19 - 1;
    while (1)
    {
      uint64_t v26 = v23[1];
      if (v26 == 0x1AF456233693CD46)
      {
        if (v23[2] == 0x1AF456233693CD46) {
          goto LABEL_48;
        }
      }
      else if ((v26 & v24) != v21)
      {
        goto LABEL_50;
      }
      uint64_t v23 = (void *)*v23;
      if (!v23) {
        goto LABEL_50;
      }
    }
  }
  while (2)
  {
    unint64_t v25 = v23[1];
    if (v25 != 0x1AF456233693CD46)
    {
      if (v25 >= *(void *)&v19) {
        v25 %= *(void *)&v19;
      }
      if (v25 != v21) {
        goto LABEL_50;
      }
      goto LABEL_37;
    }
    if (v23[2] != 0x1AF456233693CD46)
    {
LABEL_37:
      uint64_t v23 = (void *)*v23;
      if (!v23) {
        goto LABEL_50;
      }
      continue;
    }
    break;
  }
LABEL_48:
  uint64_t v27 = v23[5];
  if (*(void *)(v27 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v28 = *(void *)(v27 + 32);
    goto LABEL_51;
  }
LABEL_50:
  uint64_t v28 = 0;
LABEL_51:
  unint64_t v29 = *v17;
  unint64_t v30 = v13[20];
  if ((v30 & (v30 - 1)) != 0)
  {
    unint64_t v32 = v29;
    if (v29 >= v30) {
      unint64_t v32 = v29 % v30;
    }
    uint64_t v31 = *(void **)(v13[19] + 8 * v32);
    do
    {
      do
        uint64_t v31 = (void *)*v31;
      while (v29 != v31[1]);
    }
    while (v31[2] != v29);
  }
  else
  {
    uint64_t v31 = *(void **)(v13[19] + 8 * ((v30 - 1) & v29));
    do
    {
      do
        uint64_t v31 = (void *)*v31;
      while (v29 != v31[1]);
    }
    while (v31[2] != v29);
  }
  uint64_t v34 = v31[3];
  uint64_t v33 = v31[4];
  if (v33 != v34)
  {
    unint64_t v35 = 0;
    uint64_t v217 = (float64x2_t *)(v28 + 808);
    double v211 = v31;
    while (1)
    {
      uint64_t v220 = v34 + 16 * v35;
      uint64_t v36 = *(void *)(*(void *)v220 + 176);
      if (*(void *)(*(void *)v220 + 184) != v36) {
        break;
      }
LABEL_64:
      if (++v35 >= (v33 - v34) >> 4) {
        return;
      }
    }
    unint64_t v37 = 0;
    uint64_t v38 = 6;
    if (v35 > 6) {
      uint64_t v38 = v35;
    }
    unint64_t v218 = v38;
    unint64_t v212 = v35;
    while (2)
    {
      uint64_t v40 = *(void *)(*((void *)this + 8) + 256);
      uint64_t v41 = *(void *)(v40 + 8);
      if (v41 != *(void *)v40)
      {
        uint64_t v42 = *(void *)(v41 - 8);
        *(void *)(v40 + 8) = v41 - 8;
        __int32 v43 = *(uint64_t **)(v40 + 40);
        unint64_t v44 = *(void *)(v40 + 48);
        if ((unint64_t)v43 >= v44)
        {
          uint64_t v45 = *(void *)(v40 + 32);
          uint64_t v46 = ((uint64_t)v43 - v45) >> 3;
          unint64_t v47 = v46 + 1;
          if ((unint64_t)(v46 + 1) >> 61) {
            goto LABEL_187;
          }
          uint64_t v48 = v44 - v45;
          if (v48 >> 2 > v47) {
            unint64_t v47 = v48 >> 2;
          }
          if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v47 = 0x1FFFFFFFFFFFFFFFLL;
          }
          if (v47)
          {
            unint64_t v49 = v35;
            uint64_t v50 = v36;
            uint64_t v51 = v42;
            uint64_t v52 = 8 * v47;
            uint64_t v53 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v40 + 56) + 16))(*(void *)(v40 + 56), 8 * v47, 8);
            uint64_t v54 = (uint64_t *)(v53 + 8 * v46);
            unint64_t v47 = v53 + v52;
            uint64_t v42 = v51;
            if (v53) {
              uint64_t *v54 = v51;
            }
            uint64_t v36 = v50;
            unint64_t v35 = v49;
          }
          else
          {
            uint64_t v54 = (uint64_t *)(8 * v46);
          }
          uint64_t v68 = *(void *)(v40 + 32);
          uint64_t v67 = *(void *)(v40 + 40);
          uint64_t v69 = v67 - v68;
          if (v67 != v68)
          {
            unint64_t v70 = v69 - 8;
            if ((unint64_t)(v69 - 8) < 0x38)
            {
              unsigned __int8 v71 = v54;
            }
            else
            {
              unsigned __int8 v71 = v54;
              if ((unint64_t)(v67 - (void)v54) >= 0x20)
              {
                uint64_t v72 = (v70 >> 3) + 1;
                __int32 v73 = v54 - 2;
                long long v74 = (long long *)(v67 - 16);
                uint64_t v75 = v72 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v76 = *v74;
                  *((_OWORD *)v73 - 1) = *(v74 - 1);
                  *(_OWORD *)__int32 v73 = v76;
                  v73 -= 4;
                  v74 -= 2;
                  v75 -= 4;
                }
                while (v75);
                unsigned __int8 v71 = &v54[-(v72 & 0x3FFFFFFFFFFFFFFCLL)];
                v67 -= 8 * (v72 & 0x3FFFFFFFFFFFFFFCLL);
                if (v72 == (v72 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_118;
                }
              }
            }
            do
            {
              uint64_t v77 = *(void *)(v67 - 8);
              v67 -= 8;
              *--unsigned __int8 v71 = v77;
            }
            while (v67 != v68);
            goto LABEL_118;
          }
LABEL_115:
          unsigned __int8 v71 = v54;
LABEL_119:
          int v58 = v54 + 1;
          *(void *)(v40 + 32) = v71;
          *(void *)(v40 + 40) = v54 + 1;
          uint64_t v87 = *(void *)(v40 + 48);
          *(void *)(v40 + 48) = v47;
          if (v67) {
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v40 + 56) + 40))(*(void *)(v40 + 56), v67, v87 - v67);
          }
LABEL_121:
          *(void *)(v40 + 40) = v58;
          double v223 = (void (**)(ggl::RenderItem *__hidden))v42;
          uint64_t v88 = *(void *)(v40 + 120);
          if (!v88)
          {
LABEL_186:
            std::__throw_bad_function_call[abi:nn180100]();
LABEL_187:
            abort();
          }
          (*(void (**)(uint64_t, void (***)(ggl::RenderItem *__hidden)))(*(void *)v88 + 48))(v88, &v223);
          unint64_t v221 = v37;
          **(void **)(v42 + 96) = *(void *)(v36 + 88 * v37 + 16);
          double v89 = (void *)*((void *)this + 8);
          uint64_t v90 = v89[23];
          uint64_t v91 = *(void *)(*(void *)v220 + 176) + 88 * v37;
          uint64_t v92 = *(void *)v91;
          long long v93 = *(_OWORD *)(v91 + 32);
          double v223 = &off_1EF55A458;
          long long v94 = *(_OWORD *)(v90 + 40);
          long long v95 = *(_OWORD *)(v90 + 24);
          long long v224 = *(_OWORD *)(v90 + 8);
          long long v225 = v95;
          long long v226 = v94;
          long long v96 = *(_OWORD *)(v90 + 72);
          long long v97 = *(_OWORD *)(v90 + 104);
          long long v98 = *(_OWORD *)(v90 + 56);
          long long v229 = *(_OWORD *)(v90 + 88);
          long long v230 = v97;
          long long v227 = v98;
          long long v228 = v96;
          double v99 = (void *)v89[25];
          uint64_t v100 = v99[1];
          uint64_t v219 = v42;
          if (v100 == v89[26])
          {
            double v99 = (void *)*v99;
            if (!v99)
            {
              long long v215 = v93;
              double v99 = malloc_type_malloc(120 * v100 + 16, 0xB644C221uLL);
              long long v93 = v215;
              void *v99 = 0;
              v99[1] = 0;
              *(void *)v89[25] = v99;
            }
            v89[25] = v99;
            uint64_t v100 = v99[1];
          }
          uint64_t v101 = &v99[15 * v100];
          uint64_t v102 = v101 + 2;
          v99[1] = v100 + 1;
          v101[2] = &off_1EF55A458;
          long long v104 = v229;
          long long v103 = v230;
          long long v105 = v228;
          *(_OWORD *)(v101 + 9) = v227;
          *(_OWORD *)(v101 + 11) = v105;
          *(_OWORD *)(v101 + 13) = v104;
          long long v106 = v224;
          long long v107 = v225;
          *(_OWORD *)(v101 + 7) = v226;
          *(_OWORD *)(v101 + 5) = v107;
          *(_OWORD *)(v101 + 3) = v106;
          *(_OWORD *)(v101 + 15) = v103;
          v101[10] = v92;
          *(_OWORD *)(v101 + 11) = v93;
          v101[13] = 0;
          v101[14] = 1;
          uint64_t v108 = *((void *)this + 8);
          unsigned int v110 = *(char **)(v108 + 144);
          uint64_t v109 = *(char **)(v108 + 152);
          unint64_t v111 = (v109 - v110) >> 3;
          if (v111 <= v35)
          {
            unint64_t v112 = v218 - v111;
            if (v218 > v111)
            {
              uint64_t v113 = *(void *)(v108 + 160);
              if (v112 <= (v113 - (uint64_t)v109) >> 3)
              {
                bzero(*(void **)(v108 + 152), 8 * v112);
                *(void *)(v108 + 152) = &v109[8 * v112];
              }
              else
              {
                if (v218 >> 61) {
                  goto LABEL_187;
                }
                double v216 = v101 + 2;
                uint64_t v114 = v113 - (void)v110;
                uint64_t v115 = v114 >> 2;
                if (v114 >> 2 <= v218) {
                  uint64_t v115 = v218;
                }
                BOOL v116 = (unint64_t)v114 >= 0x7FFFFFFFFFFFFFF8;
                unint64_t v117 = 0x1FFFFFFFFFFFFFFFLL;
                if (!v116) {
                  unint64_t v117 = v115;
                }
                if (v117 >> 61) {
                  std::__throw_bad_array_new_length[abi:nn180100]();
                }
                uint64_t v118 = v36;
                uint64_t v119 = v15;
                uint64_t v120 = 8 * v117;
                uint64_t v121 = (char *)operator new(8 * v117);
                uint64_t v122 = &v121[8 * v111];
                uint64_t v213 = v121;
                double v214 = &v121[v120];
                bzero(v122, 8 * v112);
                uint64_t v123 = &v122[8 * v112];
                if (v109 == v110)
                {
                  *(void *)(v108 + 144) = v122;
                  *(void *)(v108 + 152) = v123;
                  uint64_t v102 = v216;
                  *(void *)(v108 + 160) = v214;
                  uint64_t v15 = v119;
                  uint64_t v36 = v118;
                  unint64_t v35 = v212;
                }
                else
                {
                  unint64_t v124 = v109 - v110 - 8;
                  uint64_t v15 = v119;
                  if (v124 <= 0x77)
                  {
                    unint64_t v125 = v212;
                    uint64_t v36 = v118;
                    goto LABEL_145;
                  }
                  unint64_t v125 = v212;
                  uint64_t v36 = v118;
                  if (&v109[-(v124 & 0xFFFFFFFFFFFFFFF8) - 8] < v122
                    && &v213[v109 - v110 - (v124 & 0xFFFFFFFFFFFFFFF8) - 8] < v109)
                  {
                    goto LABEL_191;
                  }
                  uint64_t v126 = (v124 >> 3) + 1;
                  uint64_t v127 = &v213[8 * v111 - 16];
                  uint64_t v128 = v109 - 32;
                  uint64_t v129 = v126 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    long long v131 = *(_OWORD *)v128;
                    long long v130 = *((_OWORD *)v128 + 1);
                    *(_OWORD *)uint64_t v128 = 0uLL;
                    *((_OWORD *)v128 + 1) = 0uLL;
                    v128 -= 32;
                    *((_OWORD *)v127 - 1) = v131;
                    *(_OWORD *)uint64_t v127 = v130;
                    v127 -= 32;
                    v129 -= 4;
                  }
                  while (v129);
                  v122 -= 8 * (v126 & 0x3FFFFFFFFFFFFFFCLL);
                  v109 -= 8 * (v126 & 0x3FFFFFFFFFFFFFFCLL);
                  if (v126 != (v126 & 0x3FFFFFFFFFFFFFFCLL))
                  {
LABEL_191:
                    do
                    {
LABEL_145:
                      uint64_t v132 = *((void *)v109 - 1);
                      v109 -= 8;
                      *(void *)uint64_t v109 = 0;
                      *((void *)v122 - 1) = v132;
                      v122 -= 8;
                    }
                    while (v109 != v110);
                  }
                  uint64_t v109 = *(char **)(v108 + 144);
                  int v133 = *(char **)(v108 + 152);
                  *(void *)(v108 + 144) = v122;
                  *(void *)(v108 + 152) = v123;
                  *(void *)(v108 + 160) = v214;
                  unint64_t v35 = v125;
                  if (v133 == v109)
                  {
                    uint64_t v102 = v216;
                  }
                  else
                  {
                    uint64_t v102 = v216;
                    do
                    {
                      uint64_t v135 = *((void *)v133 - 1);
                      v133 -= 8;
                      uint64_t v134 = v135;
                      *(void *)int v133 = 0;
                      if (v135) {
                        (*(void (**)(uint64_t))(*(void *)v134 + 8))(v134);
                      }
                    }
                    while (v133 != v109);
                  }
                }
                if (v109) {
                  operator delete(v109);
                }
              }
              unsigned int v110 = *(char **)(v108 + 144);
            }
          }
          if (!*(void *)&v110[8 * v35]) {
            operator new();
          }
          void v102[3] = *(void *)(*(void *)(v108 + 144) + 8 * v35);
          v102[4] = v219;
          unint64_t v136 = v221;
          uint64_t v137 = v36 + 88 * v221;
          float v138 = *(float *)(v137 + 72);
          float v139 = *(float *)(v137 + 76);
          float v140 = *(float *)(v137 + 80);
          float v141 = *(float *)(v137 + 84);
          float v142 = v139 + v139;
          float v143 = (float)(v139 + v139) * v139;
          float v144 = (float)(v140 + v140) * v140;
          float v145 = 1.0 - (float)(v143 + v144);
          float v146 = v138 + v138;
          float v147 = (float)(v138 + v138) * v139;
          float v148 = (float)(v140 + v140) * v141;
          float v149 = v147 - v148;
          float v150 = v140 * (float)(v138 + v138);
          float v151 = v141 * v142;
          float v152 = (float)(v141 * v142) + v150;
          float v153 = v148 + v147;
          float v154 = 1.0 - (float)((float)(v138 + v138) * v138);
          float v155 = v154 - v144;
          float v156 = v142 * v140;
          float v157 = v141 * v146;
          float v158 = v156 - v157;
          float v159 = v150 - v151;
          float v160 = v157 + v156;
          float v161 = v154 - v143;
          double v162 = v145;
          double v163 = v153;
          double v164 = v159;
          double v165 = v149;
          double v166 = v155;
          double v167 = v160;
          double v168 = v152;
          double v169 = v158;
          double v170 = v161;
          double v172 = *(double *)(v137 + 48);
          double v171 = *(double *)(v137 + 56);
          double v173 = *(double *)(v137 + 64);
          float64x2_t v174 = v217[1];
          float64x2_t v175 = v217[2];
          float64x2_t v176 = v217[3];
          float64x2_t v177 = vmlaq_n_f64(vmulq_n_f64(*v217, v162), v175, v163);
          float64x2_t v178 = vmlaq_n_f64(vmulq_n_f64(*v217, v165), v175, v166);
          float64x2_t v179 = vmlaq_n_f64(vmulq_n_f64(*v217, v168), v175, v169);
          float64x2_t v180 = vmlaq_n_f64(vmlaq_n_f64(v217[6], *v217, v172), v175, v171);
          float64x2_t v181 = v217[4];
          float64x2_t v182 = v217[5];
          float64x2_t v183 = vmlaq_n_f64(v177, v181, v164);
          float32x2_t v184 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v174, v162), v176, v163), v182, v164));
          float32x2_t v185 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v174, v168), v176, v169), v182, v170));
          float32x2_t v186 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v217[7], v174, v172), v176, v171), v182, v173));
          double v187 = **(void ***)(v219 + 64);
          unint64_t v188 = v187[1];
          uint64_t v189 = (float32x2_t *)v187[9];
          *uint64_t v189 = vcvt_f32_f64(v183);
          v189[1] = v184;
          v189[2] = vcvt_f32_f64(vmlaq_n_f64(v178, v181, v167));
          v189[3] = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v174, v165), v176, v166), v182, v167));
          v189[4] = vcvt_f32_f64(vmlaq_n_f64(v179, v181, v170));
          v189[5] = v185;
          v189[6] = vcvt_f32_f64(vmlaq_n_f64(v180, v181, v173));
          v189[7] = v186;
          if (v187[8] > v188) {
            unint64_t v188 = v187[8];
          }
          v187[7] = 0;
          v187[8] = v188;
          uint64_t v190 = (void *)v15[10];
          unint64_t v191 = v15[11];
          if ((unint64_t)v190 < v191)
          {
            if (v190) {
              *uint64_t v190 = v102;
            }
            unint64_t v39 = v190 + 1;
            goto LABEL_70;
          }
          uint64_t v192 = v15[9];
          uint64_t v193 = ((uint64_t)v190 - v192) >> 3;
          unint64_t v194 = v193 + 1;
          if ((unint64_t)(v193 + 1) >> 61) {
            goto LABEL_187;
          }
          uint64_t v195 = v191 - v192;
          if (v195 >> 2 > v194) {
            unint64_t v194 = v195 >> 2;
          }
          if ((unint64_t)v195 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v194 = 0x1FFFFFFFFFFFFFFFLL;
          }
          if (v194)
          {
            uint64_t v196 = 8 * v194;
            uint64_t v197 = (*(uint64_t (**)(void, unint64_t, uint64_t))(*(void *)v15[12] + 16))(v15[12], 8 * v194, 8);
            double v198 = (void *)(v197 + 8 * v193);
            unint64_t v194 = v197 + v196;
            if (v197) {
              *double v198 = v102;
            }
            unint64_t v136 = v221;
          }
          else
          {
            double v198 = (void *)(8 * v193);
          }
          uint64_t v200 = v15[9];
          uint64_t v199 = v15[10];
          uint64_t v201 = v199 - v200;
          if (v199 != v200)
          {
            unint64_t v202 = v201 - 8;
            if ((unint64_t)(v201 - 8) < 0x38)
            {
              int64x2_t v203 = v198;
            }
            else
            {
              int64x2_t v203 = v198;
              if ((unint64_t)(v199 - (void)v198) >= 0x20)
              {
                uint64_t v204 = (v202 >> 3) + 1;
                long long v205 = v198 - 2;
                double v206 = (long long *)(v199 - 16);
                uint64_t v207 = v204 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v208 = *v206;
                  *(v205 - 1) = *(v206 - 1);
                  *long long v205 = v208;
                  v205 -= 2;
                  v206 -= 2;
                  v207 -= 4;
                }
                while (v207);
                int64x2_t v203 = &v198[-(v204 & 0x3FFFFFFFFFFFFFFCLL)];
                v199 -= 8 * (v204 & 0x3FFFFFFFFFFFFFFCLL);
                if (v204 == (v204 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_182:
                  uint64_t v199 = v15[9];
LABEL_183:
                  unint64_t v39 = v198 + 1;
                  v15[9] = v203;
                  v15[10] = v198 + 1;
                  uint64_t v210 = v15[11];
                  v15[11] = v194;
                  if (v199) {
                    (*(void (**)(void, uint64_t, uint64_t))(*(void *)v15[12] + 40))(v15[12], v199, v210 - v199);
                  }
LABEL_70:
                  v15[10] = v39;
                  unint64_t v37 = v136 + 1;
                  uint64_t v36 = *(void *)(*(void *)v220 + 176);
                  if (v37 >= 0x2E8BA2E8BA2E8BA3 * ((*(void *)(*(void *)v220 + 184) - v36) >> 3))
                  {
                    uint64_t v34 = v211[3];
                    uint64_t v33 = v211[4];
                    goto LABEL_64;
                  }
                  continue;
                }
              }
            }
            do
            {
              uint64_t v209 = *(void *)(v199 - 8);
              v199 -= 8;
              *--int64x2_t v203 = v209;
            }
            while (v199 != v200);
            goto LABEL_182;
          }
          int64x2_t v203 = v198;
          goto LABEL_183;
        }
LABEL_83:
        if (v43) {
          *__int32 v43 = v42;
        }
        int v58 = v43 + 1;
        goto LABEL_121;
      }
      break;
    }
    uint64_t v55 = *(void *)(v40 + 88);
    if (!v55) {
      goto LABEL_186;
    }
    uint64_t v56 = (*(uint64_t (**)(uint64_t))(*(void *)v55 + 48))(v55);
    uint64_t v42 = v56;
    __int32 v43 = *(uint64_t **)(v40 + 40);
    unint64_t v57 = *(void *)(v40 + 48);
    if ((unint64_t)v43 < v57) {
      goto LABEL_83;
    }
    uint64_t v59 = *(void *)(v40 + 32);
    uint64_t v60 = ((uint64_t)v43 - v59) >> 3;
    unint64_t v47 = v60 + 1;
    if ((unint64_t)(v60 + 1) >> 61) {
      goto LABEL_187;
    }
    uint64_t v61 = v57 - v59;
    if (v61 >> 2 > v47) {
      unint64_t v47 = v61 >> 2;
    }
    if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v47 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v47)
    {
      unint64_t v62 = v35;
      uint64_t v63 = v36;
      uint64_t v64 = v56;
      uint64_t v65 = 8 * v47;
      uint64_t v66 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v40 + 56) + 16))(*(void *)(v40 + 56), 8 * v47, 8);
      uint64_t v54 = (uint64_t *)(v66 + 8 * v60);
      unint64_t v47 = v66 + v65;
      uint64_t v42 = v64;
      if (v66) {
        uint64_t *v54 = v64;
      }
      uint64_t v36 = v63;
      unint64_t v35 = v62;
    }
    else
    {
      uint64_t v54 = (uint64_t *)(8 * v60);
    }
    uint64_t v78 = *(void *)(v40 + 32);
    uint64_t v67 = *(void *)(v40 + 40);
    uint64_t v79 = v67 - v78;
    if (v67 == v78) {
      goto LABEL_115;
    }
    unint64_t v80 = v79 - 8;
    if ((unint64_t)(v79 - 8) < 0x38)
    {
      unsigned __int8 v71 = v54;
    }
    else
    {
      unsigned __int8 v71 = v54;
      if ((unint64_t)(v67 - (void)v54) >= 0x20)
      {
        uint64_t v81 = (v80 >> 3) + 1;
        long long v82 = v54 - 2;
        long long v83 = (long long *)(v67 - 16);
        uint64_t v84 = v81 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v85 = *v83;
          *((_OWORD *)v82 - 1) = *(v83 - 1);
          *(_OWORD *)long long v82 = v85;
          v82 -= 4;
          v83 -= 2;
          v84 -= 4;
        }
        while (v84);
        unsigned __int8 v71 = &v54[-(v81 & 0x3FFFFFFFFFFFFFFCLL)];
        v67 -= 8 * (v81 & 0x3FFFFFFFFFFFFFFCLL);
        if (v81 == (v81 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_118;
        }
      }
    }
    do
    {
      uint64_t v86 = *(void *)(v67 - 8);
      v67 -= 8;
      *--unsigned __int8 v71 = v86;
    }
    while (v67 != v78);
LABEL_118:
    uint64_t v67 = *(void *)(v40 + 32);
    goto LABEL_119;
  }
}

void md::mun::MuninLayer::renderTransition(md::mun::MuninLayer *this, const md::LayoutContext *a2)
{
  int8x8_t v2 = this;
  int8x8_t v3 = (void *)*((void *)a2 + 1);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_24;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v6 = 0xC83717EF586624DCLL % *(void *)&v4;
    if (*(void *)&v4 > 0xC83717EF586624DCLL) {
      unint64_t v6 = 0xC83717EF586624DCLL;
    }
  }
  else
  {
    unint64_t v6 = (*(void *)&v4 - 1) & 0xC83717EF586624DCLL;
  }
  unint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_24;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_24;
  }
  if (v5.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v10 = v8[1];
      if (v10 == 0xC83717EF586624DCLL)
      {
        if (v8[2] == 0xC83717EF586624DCLL) {
          goto LABEL_22;
        }
      }
      else if ((v10 & (*(void *)&v4 - 1)) != v6)
      {
        goto LABEL_24;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_24;
      }
    }
  }
  while (1)
  {
    unint64_t v9 = v8[1];
    if (v9 == 0xC83717EF586624DCLL) {
      break;
    }
    if (v9 >= *(void *)&v4) {
      v9 %= *(void *)&v4;
    }
    if (v9 != v6) {
      goto LABEL_24;
    }
LABEL_11:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_24;
    }
  }
  if (v8[2] != 0xC83717EF586624DCLL) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v11 = v8[5];
  if (*(void *)(v11 + 8) == 0xC83717EF586624DCLL)
  {
    uint64_t v12 = *(void *)(v11 + 32);
    goto LABEL_25;
  }
LABEL_24:
  uint64_t v12 = 0;
LABEL_25:
  uint64_t v13 = 0;
  uint64_t v14 = *(void **)(*((void *)this + 5) + 24);
  uint64_t v15 = (void *)v14[1];
  while (1)
  {
    uint64_t v16 = *(void *)(v15[3] + 8 * v13);
    if (!*(unsigned char *)v16)
    {
      unint64_t v17 = *(void *)(v16 + 8);
      uint64_t v18 = v15[15];
      if (v17 < (v15[16] - v18) >> 3) {
        break;
      }
    }
    ++v13;
  }
  uint64_t v19 = **(void **)(*(void *)(v18 + 8 * v17) + 24);
  *(void *)(v19 + 32) = *(void *)(*((void *)this + 8) + 104);
  if (!*(void *)&v4) {
    goto LABEL_52;
  }
  uint8x8_t v20 = (uint8x8_t)vcnt_s8(v4);
  v20.i16[0] = vaddlv_u8(v20);
  if (v20.u32[0] > 1uLL)
  {
    uint64_t v21 = 0x1AF456233693CD46;
    if (*(void *)&v4 <= 0x1AF456233693CD46uLL) {
      uint64_t v21 = 0x1AF456233693CD46uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v21 = (*(void *)&v4 - 1) & 0x1AF456233693CD46;
  }
  float v22 = *(void **)(*v3 + 8 * v21);
  if (!v22) {
    goto LABEL_52;
  }
  uint64_t v23 = (void *)*v22;
  if (!v23) {
    goto LABEL_52;
  }
  if (v20.u32[0] < 2uLL)
  {
    uint64_t v24 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v26 = v23[1];
      if (v26 == 0x1AF456233693CD46)
      {
        if (v23[2] == 0x1AF456233693CD46) {
          goto LABEL_50;
        }
      }
      else if ((v26 & v24) != v21)
      {
        goto LABEL_52;
      }
      uint64_t v23 = (void *)*v23;
      if (!v23) {
        goto LABEL_52;
      }
    }
  }
  while (2)
  {
    unint64_t v25 = v23[1];
    if (v25 != 0x1AF456233693CD46)
    {
      if (v25 >= *(void *)&v4) {
        v25 %= *(void *)&v4;
      }
      if (v25 != v21) {
        goto LABEL_52;
      }
      goto LABEL_39;
    }
    if (v23[2] != 0x1AF456233693CD46)
    {
LABEL_39:
      uint64_t v23 = (void *)*v23;
      if (!v23) {
        goto LABEL_52;
      }
      continue;
    }
    break;
  }
LABEL_50:
  uint64_t v27 = v23[5];
  if (*(void *)(v27 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v28 = *(void *)(v27 + 32);
    goto LABEL_53;
  }
LABEL_52:
  uint64_t v28 = 0;
LABEL_53:
  uint64_t v29 = *((void *)this + 8);
  unint64_t v30 = *(void **)(v29 + 264);
  unint64_t v31 = v30[1];
  if (v31) {
    uint64_t v32 = v30[9];
  }
  else {
    uint64_t v32 = 0;
  }
  uint64_t v34 = *(void *)(v12 + 192);
  uint64_t v33 = *(void *)(v12 + 200);
  uint64_t v35 = v33 - v34;
  if (v33 == v34)
  {
    *(_DWORD *)(v32 + 8) = 0;
    *(void *)uint64_t v32 = 1065353216;
    *(void *)(v32 + 12) = 0x100000001;
    *(_DWORD *)(v32 + 20) = 1;
    if (v32) {
      goto LABEL_104;
    }
  }
  else
  {
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = v35 >> 3;
    if (v40)
    {
      do
      {
        uint64_t v41 = *(void *)(v34 + 8 * v38);
        if (v41 == *(void *)(v12 + 80)) {
          uint64_t v39 = v38;
        }
        if (v41 == *(void *)(v12 + 96)) {
          uint64_t v37 = v38;
        }
        if (v41 == *(void *)(v12 + 112)) {
          uint64_t v36 = v38;
        }
        ++v38;
      }
      while (v40 != v38);
    }
    uint64_t v42 = *(void *)(v14[5] + 8 * v39);
    if (v42)
    {
      unint64_t v43 = *(void *)(v42 + 32);
      uint64_t v44 = *(void *)(v14[1] + 96);
      if (v43 >= (*(void *)(v14[1] + 104) - v44) >> 3) {
        uint64_t v42 = 0;
      }
      else {
        uint64_t v42 = *(void *)(*(void *)(v44 + 8 * v43) + 16);
      }
    }
    **(void **)(*(void *)(v29 + 296) + 96) = v42;
    uint64_t v45 = *(void *)(v14[11] + 24 * v39 + 16);
    if (v45)
    {
      unint64_t v46 = *(void *)(v45 + 32);
      uint64_t v47 = *(void *)(v14[1] + 96);
      if (v46 >= (*(void *)(v14[1] + 104) - v47) >> 3) {
        uint64_t v45 = 0;
      }
      else {
        uint64_t v45 = *(void *)(*(void *)(v47 + 8 * v46) + 16);
      }
    }
    *(void *)(*(void *)(*(void *)(*((void *)this + 8) + 296) + 96) + 8) = v45;
    uint64_t v48 = *(void *)(v14[5] + 8 * v36);
    if (v48)
    {
      unint64_t v49 = *(void *)(v48 + 32);
      uint64_t v50 = *(void *)(v14[1] + 96);
      if (v49 >= (*(void *)(v14[1] + 104) - v50) >> 3) {
        uint64_t v48 = 0;
      }
      else {
        uint64_t v48 = *(void *)(*(void *)(v50 + 8 * v49) + 16);
      }
    }
    *(void *)(*(void *)(*(void *)(*((void *)this + 8) + 296) + 96) + 16) = v48;
    uint64_t v51 = *(void *)(v14[11] + 24 * v36 + 16);
    if (v51)
    {
      unint64_t v52 = *(void *)(v51 + 32);
      uint64_t v53 = *(void *)(v14[1] + 96);
      if (v52 >= (*(void *)(v14[1] + 104) - v53) >> 3) {
        uint64_t v51 = 0;
      }
      else {
        uint64_t v51 = *(void *)(*(void *)(v53 + 8 * v52) + 16);
      }
    }
    *(void *)(*(void *)(*(void *)(*((void *)this + 8) + 296) + 96) + 24) = v51;
    uint64_t v54 = *(void *)(v14[5] + 8 * v37);
    if (v54)
    {
      unint64_t v55 = *(void *)(v54 + 32);
      uint64_t v56 = *(void *)(v14[1] + 96);
      if (v55 >= (*(void *)(v14[1] + 104) - v56) >> 3) {
        uint64_t v54 = 0;
      }
      else {
        uint64_t v54 = *(void *)(*(void *)(v56 + 8 * v55) + 16);
      }
    }
    *(void *)(*(void *)(*(void *)(*((void *)this + 8) + 296) + 96) + 32) = v54;
    uint64_t v57 = *(void *)(v14[11] + 24 * v37 + 16);
    if (v57)
    {
      unint64_t v58 = *(void *)(v57 + 32);
      uint64_t v59 = *(void *)(v14[1] + 96);
      if (v58 >= (*(void *)(v14[1] + 104) - v59) >> 3) {
        uint64_t v57 = 0;
      }
      else {
        uint64_t v57 = *(void *)(*(void *)(v59 + 8 * v58) + 16);
      }
    }
    *(void *)(*(void *)(*(void *)(*((void *)this + 8) + 296) + 96) + 40) = v57;
    float v60 = *(float *)(v12 + 120);
    if (v60 < 0.5) {
      uint64_t v37 = v39;
    }
    uint64_t v61 = *(void *)(v14[8] + 8 * v37);
    if (v61)
    {
      unint64_t v62 = *(void *)(v61 + 32);
      uint64_t v63 = *(void *)(v14[1] + 96);
      if (v62 >= (*(void *)(v14[1] + 104) - v63) >> 3) {
        uint64_t v61 = 0;
      }
      else {
        uint64_t v61 = *(void *)(*(void *)(v63 + 8 * v62) + 16);
      }
    }
    *(void *)(*(void *)(*(void *)(*((void *)this + 8) + 296) + 96) + 48) = v61;
    *(float *)uint64_t v32 = v60;
    *(void *)(v32 + 4) = *(void *)(v12 + 124);
    unint64_t v64 = *(void *)(v12 + 72);
    unint64_t v65 = *(void *)(v12 + 104);
    unint64_t v66 = v65 - v64;
    if (v64 > v65) {
      unint64_t v66 = v64 - v65;
    }
    *(_DWORD *)(v32 + 12) = v66 < 0xEA61;
    unint64_t v67 = *(void *)(v12 + 88);
    unint64_t v68 = v67 - v64;
    BOOL v69 = v64 > v67;
    unint64_t v70 = v64 - v67;
    if (!v69) {
      unint64_t v70 = v68;
    }
    *(_DWORD *)(v32 + 16) = v70 < 0xEA61;
    unint64_t v71 = v67 - v65;
    BOOL v69 = v65 > v67;
    unint64_t v72 = v65 - v67;
    if (v69) {
      unint64_t v71 = v72;
    }
    *(_DWORD *)(v32 + 20) = v71 < 0xEA61;
    if (v32)
    {
LABEL_104:
      if (v31)
      {
        if (v30[8] > v31) {
          unint64_t v31 = v30[8];
        }
        v30[7] = 0;
        v30[8] = v31;
      }
    }
  }
  __int32 v73 = (void *)v14[1];
  uint64_t v74 = v73[3];
  uint64_t v75 = v73[4];
  uint64_t v76 = v75 - v74;
  if (v75 == v74) {
    goto LABEL_115;
  }
  uint64_t v77 = 0;
  unint64_t v78 = v76 >> 3;
  while (1)
  {
    uint64_t v79 = *(void *)(v74 + 8 * v77);
    if (*(unsigned char *)v79 == 3)
    {
      unint64_t v80 = *(void *)(v79 + 8);
      uint64_t v81 = v73[15];
      if (v80 < (v73[16] - v81) >> 3) {
        break;
      }
    }
    if (++v77 >= v78) {
      goto LABEL_115;
    }
  }
  uint64_t v82 = *(void *)(v81 + 8 * v80);
  if (!v82) {
LABEL_115:
  }
    uint64_t v83 = 0;
  else {
    uint64_t v83 = **(void **)(v82 + 24);
  }
  ggl::CommandBuffer::pushRenderItem(v83, *(void *)(*((void *)v2 + 8) + 304));
  uint64_t v84 = v14[14];
  if (v84)
  {
    unint64_t v85 = *(void *)(v84 + 32);
    uint64_t v86 = *(void *)(v14[1] + 96);
    if (v85 >= (*(void *)(v14[1] + 104) - v86) >> 3) {
      uint64_t v84 = 0;
    }
    else {
      uint64_t v84 = *(void *)(*(void *)(v86 + 8 * v85) + 16);
    }
  }
  **(void **)(*(void *)(*((void *)v2 + 8) + 336) + 96) = v84;
  uint64_t v87 = v14[15];
  if (v87)
  {
    unint64_t v88 = *(void *)(v87 + 32);
    uint64_t v89 = *(void *)(v14[1] + 96);
    if (v88 >= (*(void *)(v14[1] + 104) - v89) >> 3) {
      uint64_t v87 = 0;
    }
    else {
      uint64_t v87 = *(void *)(*(void *)(v89 + 8 * v88) + 16);
    }
  }
  *(void *)(*(void *)(*(void *)(*((void *)v2 + 8) + 336) + 96) + 8) = v87;
  if (*(void *)(v12 + 200) != *(void *)(v12 + 192)) {
    ggl::CommandBuffer::pushRenderItem(v19, *(void *)(*((void *)v2 + 8) + 344));
  }
  unint64_t v90 = 0;
  double v305 = v2;
  __double2 v306 = (float64x2_t *)(v28 + 808);
  uint64_t v299 = v12;
  long double v300 = v14;
LABEL_128:
  if (v90 < v14[4])
  {
    unint64_t v301 = v90;
    int8x8_t v91 = *(int8x8_t *)(v12 + 160);
    if (!*(void *)&v91) {
      goto LABEL_149;
    }
    unint64_t v92 = *(void *)(*(void *)(v12 + 192) + 8 * v301);
    uint8x8_t v93 = (uint8x8_t)vcnt_s8(v91);
    v93.i16[0] = vaddlv_u8(v93);
    if (v93.u32[0] > 1uLL)
    {
      unint64_t v94 = *(void *)(*(void *)(v12 + 192) + 8 * v301);
      if (v92 >= *(void *)&v91) {
        unint64_t v94 = v92 % *(void *)&v91;
      }
    }
    else
    {
      unint64_t v94 = (*(void *)&v91 - 1) & v92;
    }
    long long v95 = *(void **)(*(void *)(v12 + 152) + 8 * v94);
    if (v95)
    {
      long long v96 = (void *)*v95;
      if (*v95)
      {
        if (v93.u32[0] < 2uLL)
        {
          uint64_t v97 = *(void *)&v91 - 1;
          while (1)
          {
            uint64_t v99 = v96[1];
            if (v92 == v99)
            {
              if (v96[2] == v92) {
                goto LABEL_150;
              }
            }
            else if ((v99 & v97) != v94)
            {
              goto LABEL_149;
            }
            long long v96 = (void *)*v96;
            if (!v96) {
              goto LABEL_150;
            }
          }
        }
        do
        {
          unint64_t v98 = v96[1];
          if (v92 == v98)
          {
            if (v96[2] == v92) {
              break;
            }
          }
          else
          {
            if (v98 >= *(void *)&v91) {
              v98 %= *(void *)&v91;
            }
            if (v98 != v94) {
              goto LABEL_149;
            }
          }
          long long v96 = (void *)*v96;
        }
        while (v96);
      }
    }
    else
    {
LABEL_149:
      long long v96 = 0;
    }
LABEL_150:
    uint64_t v100 = *((void *)v2 + 9);
    long double v302 = v96;
    if (v301 >= (*((void *)v2 + 10) - v100) >> 3)
    {
      uint64_t v101 = (void *)*((void *)a2 + 1);
      unint64_t v102 = v101[1];
      if ((v102 & (v102 - 1)) != 0)
      {
        unint64_t v104 = 0xA60DDA5A69582425;
        if (v102 <= 0xA60DDA5A69582425) {
          unint64_t v104 = 0xA60DDA5A69582425 % v102;
        }
        long long v103 = *(void **)(*v101 + 8 * v104);
        do
        {
          do
            long long v103 = (void *)*v103;
          while (v103[1] != 0xA60DDA5A69582425);
        }
        while (v103[2] != 0xA60DDA5A69582425);
      }
      else
      {
        long long v103 = *(void **)(*v101 + 8 * ((v102 - 1) & 0xA60DDA5A69582425));
        do
        {
          do
            long long v103 = (void *)*v103;
          while (v103[1] != 0xA60DDA5A69582425);
        }
        while (v103[2] != 0xA60DDA5A69582425);
      }
      id v105 = **(id **)(v103[5] + 32);
      uint64_t v106 = *(void *)(*(void *)([v105 device] + 24) + 56);
      if (v106) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v106 + 8), 1uLL, memory_order_relaxed);
      }

      operator new();
    }
    uint64_t v107 = 0;
    uint64_t v108 = v14;
    uint64_t v109 = *(uint64_t ***)(v100 + 8 * v301);
    v109[1] = *v109;
    unsigned int v110 = (void *)v108[1];
    while (1)
    {
      unint64_t v111 = *(unsigned __int8 **)(v110[3] + 8 * v107);
      if (*v111 == ((16 * v301) | 1))
      {
        unint64_t v112 = *((void *)v111 + 1);
        uint64_t v113 = v110[15];
        if (v112 < (v110[16] - v113) >> 3) {
          break;
        }
      }
      ++v107;
    }
    uint64_t v114 = **(void **)(*(void *)(v113 + 8 * v112) + 24);
    *(void *)(v114 + 32) = *(void *)(*((void *)v2 + 8) + 104);
    uint64_t v116 = v96[3];
    uint64_t v115 = v96[4];
    if (v115 != v116)
    {
      uint64_t v117 = 0;
      while (1)
      {
        uint64_t v307 = v116 + 16 * v117;
        uint64_t v118 = *(void *)(*(void *)v307 + 176);
        if (*(void *)(*(void *)v307 + 184) != v118) {
          break;
        }
LABEL_171:
        if (++v117 >= (unint64_t)((v115 - v116) >> 4)) {
          goto LABEL_275;
        }
      }
      uint64_t v303 = v117;
      unint64_t v119 = 0;
      while (2)
      {
        uint64_t v121 = *(void *)(*((void *)v2 + 8) + 232);
        uint64_t v122 = *(void *)(v121 + 8);
        if (v122 != *(void *)v121)
        {
          uint64_t v123 = *(void *)(v122 - 8);
          *(void *)(v121 + 8) = v122 - 8;
          unint64_t v124 = *(uint64_t **)(v121 + 40);
          unint64_t v125 = *(void *)(v121 + 48);
          if ((unint64_t)v124 >= v125)
          {
            uint64_t v126 = *(void *)(v121 + 32);
            uint64_t v127 = ((uint64_t)v124 - v126) >> 3;
            unint64_t v128 = v127 + 1;
            if ((unint64_t)(v127 + 1) >> 61) {
              goto LABEL_321;
            }
            uint64_t v129 = v125 - v126;
            if (v129 >> 2 > v128) {
              unint64_t v128 = v129 >> 2;
            }
            if ((unint64_t)v129 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v128 = 0x1FFFFFFFFFFFFFFFLL;
            }
            if (v128)
            {
              uint64_t v130 = 8 * v128;
              uint64_t v131 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v121 + 56) + 16))(*(void *)(v121 + 56), 8 * v128, 8);
              uint64_t v132 = (uint64_t *)(v131 + 8 * v127);
              unint64_t v128 = v131 + v130;
              if (v131) {
                *uint64_t v132 = v123;
              }
            }
            else
            {
              uint64_t v132 = (uint64_t *)(8 * v127);
            }
            uint64_t v142 = *(void *)(v121 + 32);
            uint64_t v141 = *(void *)(v121 + 40);
            uint64_t v143 = v141 - v142;
            if (v141 != v142)
            {
              unint64_t v144 = v143 - 8;
              if ((unint64_t)(v143 - 8) < 0x38)
              {
                float v145 = v132;
              }
              else
              {
                float v145 = v132;
                if ((unint64_t)(v141 - (void)v132) >= 0x20)
                {
                  uint64_t v146 = (v144 >> 3) + 1;
                  float v147 = v132 - 2;
                  float v148 = (long long *)(v141 - 16);
                  uint64_t v149 = v146 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    long long v150 = *v148;
                    *((_OWORD *)v147 - 1) = *(v148 - 1);
                    *(_OWORD *)float v147 = v150;
                    v147 -= 4;
                    v148 -= 2;
                    v149 -= 4;
                  }
                  while (v149);
                  float v145 = &v132[-(v146 & 0x3FFFFFFFFFFFFFFCLL)];
                  v141 -= 8 * (v146 & 0x3FFFFFFFFFFFFFFCLL);
                  if (v146 == (v146 & 0x3FFFFFFFFFFFFFFCLL)) {
                    goto LABEL_221;
                  }
                }
              }
              do
              {
                uint64_t v159 = *(void *)(v141 - 8);
                v141 -= 8;
                *--float v145 = v159;
              }
              while (v141 != v142);
              goto LABEL_221;
            }
LABEL_215:
            float v145 = v132;
LABEL_222:
            uint64_t v135 = v132 + 1;
            *(void *)(v121 + 32) = v145;
            *(void *)(v121 + 40) = v132 + 1;
            uint64_t v161 = *(void *)(v121 + 48);
            *(void *)(v121 + 48) = v128;
            if (v141) {
              (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v121 + 56) + 40))(*(void *)(v121 + 56), v141, v161 - v141);
            }
LABEL_224:
            *(void *)(v121 + 40) = v135;
            unint64_t v308 = (void (**)(ggl::RenderItem *__hidden))v123;
            uint64_t v162 = *(void *)(v121 + 120);
            if (!v162)
            {
LABEL_322:
              std::__throw_bad_function_call[abi:nn180100]();
LABEL_323:
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            (*(void (**)(uint64_t, void (***)(ggl::RenderItem *__hidden)))(*(void *)v162 + 48))(v162, &v308);
            **(void **)(v123 + 96) = *(void *)(v118 + 88 * v119 + 16);
            double v163 = (void *)*((void *)v2 + 8);
            uint64_t v164 = v163[23];
            uint64_t v165 = *(void *)(*(void *)v307 + 176) + 88 * v119;
            uint64_t v166 = *(void *)v165;
            long long v167 = *(_OWORD *)(v165 + 32);
            unint64_t v308 = &off_1EF55A458;
            long long v168 = *(_OWORD *)(v164 + 40);
            long long v169 = *(_OWORD *)(v164 + 24);
            long long v309 = *(_OWORD *)(v164 + 8);
            long long v310 = v169;
            long long v311 = v168;
            long long v170 = *(_OWORD *)(v164 + 72);
            long long v171 = *(_OWORD *)(v164 + 104);
            long long v172 = *(_OWORD *)(v164 + 56);
            long long v314 = *(_OWORD *)(v164 + 88);
            long long v315 = v171;
            long long v312 = v172;
            long long v313 = v170;
            double v173 = (void *)v163[25];
            uint64_t v174 = v173[1];
            if (v174 == v163[26])
            {
              double v173 = (void *)*v173;
              if (!v173)
              {
                long long v304 = v167;
                double v173 = malloc_type_malloc(120 * v174 + 16, 0xB644C221uLL);
                long long v167 = v304;
                *double v173 = 0;
                v173[1] = 0;
                *(void *)v163[25] = v173;
              }
              v163[25] = v173;
              uint64_t v174 = v173[1];
            }
            float64x2_t v175 = &v173[15 * v174];
            float64x2_t v176 = v175 + 2;
            v173[1] = v174 + 1;
            v175[2] = &off_1EF55A458;
            long long v178 = v314;
            long long v177 = v315;
            long long v179 = v313;
            *(_OWORD *)(v175 + 9) = v312;
            *(_OWORD *)(v175 + 11) = v179;
            *(_OWORD *)(v175 + 13) = v178;
            long long v180 = v309;
            long long v181 = v310;
            *(_OWORD *)(v175 + 7) = v311;
            *(_OWORD *)(v175 + 5) = v181;
            *(_OWORD *)(v175 + 3) = v180;
            *(_OWORD *)(v175 + 15) = v177;
            v175[10] = v166;
            *(_OWORD *)(v175 + 11) = v167;
            v175[13] = 0;
            v175[14] = 1;
            v175[5] = *(void *)(*((void *)v2 + 8) + 136);
            v175[6] = v123;
            uint64_t v182 = v118 + 88 * v119;
            LODWORD(v177) = *(_DWORD *)(v182 + 72);
            LODWORD(v180) = *(_DWORD *)(v182 + 76);
            LODWORD(v181) = *(_DWORD *)(v182 + 80);
            float v183 = *(float *)(v182 + 84);
            float v184 = *(float *)&v180 + *(float *)&v180;
            float v185 = (float)(*(float *)&v180 + *(float *)&v180) * *(float *)&v180;
            float v186 = (float)(*(float *)&v181 + *(float *)&v181) * *(float *)&v181;
            float v187 = 1.0 - (float)(v185 + v186);
            float v188 = *(float *)&v177 + *(float *)&v177;
            *(float *)&long long v180 = (float)(*(float *)&v177 + *(float *)&v177) * *(float *)&v180;
            float v189 = (float)(*(float *)&v181 + *(float *)&v181) * v183;
            float v190 = *(float *)&v180 - v189;
            float v191 = *(float *)&v181 * (float)(*(float *)&v177 + *(float *)&v177);
            float v192 = v183 * v184;
            float v193 = (float)(v183 * v184) + v191;
            *(float *)&long long v180 = v189 + *(float *)&v180;
            *(float *)&long long v177 = 1.0 - (float)((float)(*(float *)&v177 + *(float *)&v177) * *(float *)&v177);
            float v194 = *(float *)&v177 - v186;
            *(float *)&long long v181 = v184 * *(float *)&v181;
            float v195 = v183 * v188;
            float v196 = *(float *)&v181 - v195;
            float v197 = v191 - v192;
            float v198 = v195 + *(float *)&v181;
            float v199 = *(float *)&v177 - v185;
            *(double *)&long long v177 = v187;
            *(double *)&long long v180 = *(float *)&v180;
            *(double *)&long long v181 = v197;
            double v200 = v190;
            double v201 = v194;
            double v202 = v198;
            double v203 = v193;
            double v204 = v196;
            double v205 = v199;
            double v207 = *(double *)(v182 + 48);
            double v206 = *(double *)(v182 + 56);
            double v208 = *(double *)(v182 + 64);
            float64x2_t v209 = v306[1];
            float64x2_t v210 = v306[2];
            float64x2_t v211 = v306[3];
            float64x2_t v212 = vmlaq_n_f64(vmulq_n_f64(*v306, *(double *)&v177), v210, *(double *)&v180);
            float64x2_t v213 = vmlaq_n_f64(vmulq_n_f64(*v306, v200), v210, v201);
            float64x2_t v214 = vmlaq_n_f64(vmulq_n_f64(*v306, v203), v210, v204);
            float64x2_t v215 = vmlaq_n_f64(vmlaq_n_f64(v306[6], *v306, v207), v210, v206);
            float64x2_t v216 = v306[4];
            float64x2_t v217 = v306[5];
            float64x2_t v218 = vmlaq_n_f64(v212, v216, *(double *)&v181);
            *(float32x2_t *)&long long v177 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v209, *(double *)&v177), v211, *(double *)&v180), v217, *(double *)&v181));
            *(float32x2_t *)&long long v181 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v209, v203), v211, v204), v217, v205));
            float32x2_t v219 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v306[7], v209, v207), v211, v206), v217, v208));
            uint64_t v220 = **(void ***)(v123 + 64);
            unint64_t v221 = v220[1];
            double v222 = (float32x2_t *)v220[9];
            *double v222 = vcvt_f32_f64(v218);
            v222[1] = (float32x2_t)v177;
            v222[2] = vcvt_f32_f64(vmlaq_n_f64(v213, v216, v202));
            v222[3] = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v209, v200), v211, v201), v217, v202));
            v222[4] = vcvt_f32_f64(vmlaq_n_f64(v214, v216, v205));
            v222[5] = (float32x2_t)v181;
            v222[6] = vcvt_f32_f64(vmlaq_n_f64(v215, v216, v208));
            v222[7] = v219;
            if (v220[8] > v221) {
              unint64_t v221 = v220[8];
            }
            v220[7] = 0;
            v220[8] = v221;
            long long v224 = v109[1];
            unint64_t v223 = (unint64_t)v109[2];
            if ((unint64_t)v224 >= v223)
            {
              long long v226 = *v109;
              uint64_t v227 = ((char *)v224 - (char *)*v109) >> 4;
              unint64_t v228 = v227 + 1;
              if ((unint64_t)(v227 + 1) >> 60) {
                goto LABEL_321;
              }
              uint64_t v229 = v223 - (void)v226;
              if (v229 >> 3 > v228) {
                unint64_t v228 = v229 >> 3;
              }
              if ((unint64_t)v229 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v230 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v230 = v228;
              }
              if (v230)
              {
                if (v230 >> 60) {
                  goto LABEL_323;
                }
                uint64_t v231 = (char *)operator new(16 * v230);
              }
              else
              {
                uint64_t v231 = 0;
              }
              double v232 = (uint64_t *)&v231[16 * v227];
              *double v232 = v123;
              v232[1] = (uint64_t)v176;
              double v233 = v232;
              if (v224 == v226)
              {
                int8x8_t v2 = v305;
              }
              else
              {
                int8x8_t v2 = v305;
                do
                {
                  *((_OWORD *)v233 - 1) = *((_OWORD *)v224 - 1);
                  v233 -= 2;
                  v224 -= 2;
                }
                while (v224 != v226);
                long long v224 = *v109;
              }
              long long v225 = v232 + 2;
              *uint64_t v109 = v233;
              v109[1] = v232 + 2;
              v109[2] = (uint64_t *)&v231[16 * v230];
              if (v224) {
                operator delete(v224);
              }
            }
            else
            {
              *long long v224 = v123;
              v224[1] = (uint64_t)v176;
              long long v225 = v224 + 2;
            }
            v109[1] = v225;
            uint64_t v234 = *(v225 - 1);
            double v235 = *(void **)(v114 + 80);
            unint64_t v236 = *(void *)(v114 + 88);
            if ((unint64_t)v235 < v236)
            {
              if (v235) {
                *double v235 = v234;
              }
              uint64_t v120 = v235 + 1;
              goto LABEL_175;
            }
            uint64_t v237 = *(void *)(v114 + 72);
            uint64_t v238 = ((uint64_t)v235 - v237) >> 3;
            unint64_t v239 = v238 + 1;
            if ((unint64_t)(v238 + 1) >> 61) {
LABEL_321:
            }
              abort();
            uint64_t v240 = v236 - v237;
            if (v240 >> 2 > v239) {
              unint64_t v239 = v240 >> 2;
            }
            if ((unint64_t)v240 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v239 = 0x1FFFFFFFFFFFFFFFLL;
            }
            if (v239)
            {
              uint64_t v241 = 8 * v239;
              uint64_t v242 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v114 + 96) + 16))(*(void *)(v114 + 96), 8 * v239, 8);
              uint64_t v243 = (void *)(v242 + 8 * v238);
              unint64_t v239 = v242 + v241;
              if (v242) {
                *uint64_t v243 = v234;
              }
            }
            else
            {
              uint64_t v243 = (void *)(8 * v238);
            }
            uint64_t v245 = *(void *)(v114 + 72);
            uint64_t v244 = *(void *)(v114 + 80);
            uint64_t v246 = v244 - v245;
            if (v244 != v245)
            {
              unint64_t v247 = v246 - 8;
              if ((unint64_t)(v246 - 8) < 0x38)
              {
                double v248 = v243;
              }
              else
              {
                double v248 = v243;
                if ((unint64_t)(v244 - (void)v243) >= 0x20)
                {
                  uint64_t v249 = (v247 >> 3) + 1;
                  uint64_t v250 = v243 - 2;
                  double v251 = (long long *)(v244 - 16);
                  uint64_t v252 = v249 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    long long v253 = *v251;
                    *(v250 - 1) = *(v251 - 1);
                    *uint64_t v250 = v253;
                    v250 -= 2;
                    v251 -= 2;
                    v252 -= 4;
                  }
                  while (v252);
                  double v248 = &v243[-(v249 & 0x3FFFFFFFFFFFFFFCLL)];
                  v244 -= 8 * (v249 & 0x3FFFFFFFFFFFFFFCLL);
                  if (v249 == (v249 & 0x3FFFFFFFFFFFFFFCLL))
                  {
LABEL_272:
                    uint64_t v244 = *(void *)(v114 + 72);
LABEL_273:
                    uint64_t v120 = v243 + 1;
                    *(void *)(v114 + 72) = v248;
                    *(void *)(v114 + 80) = v243 + 1;
                    uint64_t v255 = *(void *)(v114 + 88);
                    *(void *)(v114 + 88) = v239;
                    if (v244) {
                      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v114 + 96) + 40))(*(void *)(v114 + 96), v244, v255 - v244);
                    }
LABEL_175:
                    *(void *)(v114 + 80) = v120;
                    ++v119;
                    uint64_t v118 = *(void *)(*(void *)v307 + 176);
                    if (v119 >= 0x2E8BA2E8BA2E8BA3 * ((*(void *)(*(void *)v307 + 184) - v118) >> 3))
                    {
                      uint64_t v117 = v303;
                      uint64_t v116 = v302[3];
                      uint64_t v115 = v302[4];
                      goto LABEL_171;
                    }
                    continue;
                  }
                }
              }
              do
              {
                uint64_t v254 = *(void *)(v244 - 8);
                v244 -= 8;
                *--double v248 = v254;
              }
              while (v244 != v245);
              goto LABEL_272;
            }
            double v248 = v243;
            goto LABEL_273;
          }
LABEL_188:
          if (v124) {
            *unint64_t v124 = v123;
          }
          uint64_t v135 = v124 + 1;
          goto LABEL_224;
        }
        break;
      }
      uint64_t v133 = *(void *)(v121 + 88);
      if (!v133) {
        goto LABEL_322;
      }
      uint64_t v123 = (*(uint64_t (**)(uint64_t))(*(void *)v133 + 48))(v133);
      unint64_t v124 = *(uint64_t **)(v121 + 40);
      unint64_t v134 = *(void *)(v121 + 48);
      if ((unint64_t)v124 < v134) {
        goto LABEL_188;
      }
      uint64_t v136 = *(void *)(v121 + 32);
      uint64_t v137 = ((uint64_t)v124 - v136) >> 3;
      unint64_t v128 = v137 + 1;
      if ((unint64_t)(v137 + 1) >> 61) {
        goto LABEL_321;
      }
      uint64_t v138 = v134 - v136;
      if (v138 >> 2 > v128) {
        unint64_t v128 = v138 >> 2;
      }
      if ((unint64_t)v138 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v128 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v128)
      {
        uint64_t v139 = 8 * v128;
        uint64_t v140 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v121 + 56) + 16))(*(void *)(v121 + 56), 8 * v128, 8);
        uint64_t v132 = (uint64_t *)(v140 + 8 * v137);
        unint64_t v128 = v140 + v139;
        if (v140) {
          *uint64_t v132 = v123;
        }
      }
      else
      {
        uint64_t v132 = (uint64_t *)(8 * v137);
      }
      uint64_t v151 = *(void *)(v121 + 32);
      uint64_t v141 = *(void *)(v121 + 40);
      uint64_t v152 = v141 - v151;
      if (v141 == v151) {
        goto LABEL_215;
      }
      unint64_t v153 = v152 - 8;
      if ((unint64_t)(v152 - 8) < 0x38)
      {
        float v145 = v132;
      }
      else
      {
        float v145 = v132;
        if ((unint64_t)(v141 - (void)v132) >= 0x20)
        {
          uint64_t v154 = (v153 >> 3) + 1;
          float v155 = v132 - 2;
          float v156 = (long long *)(v141 - 16);
          uint64_t v157 = v154 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v158 = *v156;
            *((_OWORD *)v155 - 1) = *(v156 - 1);
            *(_OWORD *)float v155 = v158;
            v155 -= 4;
            v156 -= 2;
            v157 -= 4;
          }
          while (v157);
          float v145 = &v132[-(v154 & 0x3FFFFFFFFFFFFFFCLL)];
          v141 -= 8 * (v154 & 0x3FFFFFFFFFFFFFFCLL);
          if (v154 == (v154 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_221;
          }
        }
      }
      do
      {
        uint64_t v160 = *(void *)(v141 - 8);
        v141 -= 8;
        *--float v145 = v160;
      }
      while (v141 != v151);
LABEL_221:
      uint64_t v141 = *(void *)(v121 + 32);
      goto LABEL_222;
    }
LABEL_275:
    uint64_t v256 = *(void *)(v300[5] + 8 * v301);
    if (v256)
    {
      unint64_t v257 = *(void *)(v256 + 32);
      uint64_t v258 = *(void *)(v300[1] + 96);
      if (v257 >= (*(void *)(v300[1] + 104) - v258) >> 3) {
        uint64_t v256 = 0;
      }
      else {
        uint64_t v256 = *(void *)(*(void *)(v258 + 8 * v257) + 16);
      }
    }
    uint64_t v259 = 0;
    double v260 = v109 + 3;
    uint64_t v14 = v300;
    while (1)
    {
      **(void **)(*(void *)(v260[v259] + 8) + 96) = v256;
      uint64_t v261 = 3 * v301 + v259;
      double v262 = (void *)v300[1];
      uint64_t v263 = v262[3];
      uint64_t v264 = v262[4];
      uint64_t v265 = v264 - v263;
      if (v264 == v263) {
        goto LABEL_289;
      }
      uint64_t v266 = 0;
      unint64_t v267 = v265 >> 3;
      while (1)
      {
        long double v268 = *(unsigned __int8 **)(v263 + 8 * v266);
        if (*v268 == ((16 * v261) | 2))
        {
          unint64_t v269 = *((void *)v268 + 1);
          uint64_t v270 = v262[15];
          if (v269 < (v262[16] - v270) >> 3) {
            break;
          }
        }
        if (++v266 >= v267) {
          goto LABEL_289;
        }
      }
      uint64_t v271 = *(void *)(v270 + 8 * v269);
      if (!v271) {
LABEL_289:
      }
        uint64_t v272 = 0;
      else {
        uint64_t v272 = **(void **)(v271 + 24);
      }
      uint64_t v273 = *(void *)v260[v259];
      unint64_t v274 = *(void **)(v272 + 80);
      unint64_t v275 = *(void *)(v272 + 88);
      if ((unint64_t)v274 < v275)
      {
        if (v274) {
          *unint64_t v274 = v273;
        }
        uint64_t v276 = v274 + 1;
        goto LABEL_316;
      }
      uint64_t v277 = *(void *)(v272 + 72);
      uint64_t v278 = ((uint64_t)v274 - v277) >> 3;
      unint64_t v279 = v278 + 1;
      if ((unint64_t)(v278 + 1) >> 61) {
        goto LABEL_321;
      }
      uint64_t v280 = v275 - v277;
      if (v280 >> 2 > v279) {
        unint64_t v279 = v280 >> 2;
      }
      if ((unint64_t)v280 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v279 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v279)
      {
        uint64_t v281 = 8 * v279;
        uint64_t v282 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v272 + 96) + 16))(*(void *)(v272 + 96), 8 * v279, 8);
        long double v283 = (void *)(v282 + 8 * v278);
        unint64_t v279 = v282 + v281;
        if (v282) {
          *long double v283 = v273;
        }
      }
      else
      {
        long double v283 = (void *)(8 * v278);
      }
      int8x8_t v2 = v305;
      uint64_t v285 = *(void *)(v272 + 72);
      uint64_t v284 = *(void *)(v272 + 80);
      uint64_t v286 = v284 - v285;
      if (v284 == v285)
      {
        double v288 = v283;
        goto LABEL_314;
      }
      unint64_t v287 = v286 - 8;
      if ((unint64_t)(v286 - 8) < 0x38)
      {
        double v288 = v283;
      }
      else
      {
        double v288 = v283;
        if ((unint64_t)(v284 - (void)v283) >= 0x20)
        {
          uint64_t v289 = (v287 >> 3) + 1;
          double v290 = v283 - 2;
          unint64_t v291 = (long long *)(v284 - 16);
          uint64_t v292 = v289 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v293 = *v291;
            *(v290 - 1) = *(v291 - 1);
            *double v290 = v293;
            v290 -= 2;
            v291 -= 2;
            v292 -= 4;
          }
          while (v292);
          double v288 = &v283[-(v289 & 0x3FFFFFFFFFFFFFFCLL)];
          v284 -= 8 * (v289 & 0x3FFFFFFFFFFFFFFCLL);
          if (v289 == (v289 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_313;
          }
        }
      }
      do
      {
        uint64_t v294 = *(void *)(v284 - 8);
        v284 -= 8;
        *--double v288 = v294;
      }
      while (v284 != v285);
LABEL_313:
      uint64_t v284 = *(void *)(v272 + 72);
LABEL_314:
      uint64_t v276 = v283 + 1;
      *(void *)(v272 + 72) = v288;
      *(void *)(v272 + 80) = v283 + 1;
      uint64_t v295 = *(void *)(v272 + 88);
      *(void *)(v272 + 88) = v279;
      if (v284) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v272 + 96) + 40))(*(void *)(v272 + 96), v284, v295 - v284);
      }
LABEL_316:
      *(void *)(v272 + 80) = v276;
      uint64_t v256 = *(void *)(v300[11] + 8 * v261);
      if (!v256) {
        goto LABEL_281;
      }
      unint64_t v296 = *(void *)(v256 + 32);
      uint64_t v297 = *(void *)(v300[1] + 96);
      if (v296 < (*(void *)(v300[1] + 104) - v297) >> 3)
      {
        uint64_t v256 = *(void *)(*(void *)(v297 + 8 * v296) + 16);
LABEL_281:
        if (++v259 == 3) {
          goto LABEL_127;
        }
        continue;
      }
      uint64_t v256 = 0;
      if (++v259 == 3)
      {
LABEL_127:
        unint64_t v90 = v301 + 1;
        uint64_t v12 = v299;
        goto LABEL_128;
      }
    }
  }
}

void sub_1A207C9CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

uint64_t std::__shared_ptr_emplace<ggl::Blur::YPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Blur::YPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588D70;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Blur::YPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588D70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Blur::XPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Blur::XPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588D38;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Blur::XPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588D38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Blur::Downsample4XPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Blur::Downsample4XPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588DA8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Blur::Downsample4XPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588DA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t **std::array<std::unique_ptr<ggl::Drawable>,3ul>::~array(uint64_t **a1)
{
  int8x8_t v2 = a1[2];
  a1[2] = 0;
  if (v2)
  {
    int8x8_t v3 = (std::__shared_weak_count *)v2[3];
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    uint64_t v4 = v2[1];
    v2[1] = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = *v2;
    uint64_t *v2 = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    MEMORY[0x1A6239270](v2, 0x20C40DC1BFBCFLL);
  }
  unint64_t v6 = a1[1];
  a1[1] = 0;
  if (v6)
  {
    unint64_t v7 = (std::__shared_weak_count *)v6[3];
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    uint64_t v8 = v6[1];
    v6[1] = 0;
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
    uint64_t v9 = *v6;
    *unint64_t v6 = 0;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
    MEMORY[0x1A6239270](v6, 0x20C40DC1BFBCFLL);
  }
  uint64_t v10 = *a1;
  *a1 = 0;
  if (v10)
  {
    uint64_t v11 = (std::__shared_weak_count *)v10[3];
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    uint64_t v12 = v10[1];
    v10[1] = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
    uint64_t v13 = *v10;
    *uint64_t v10 = 0;
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    }
    MEMORY[0x1A6239270](v10, 0x20C40DC1BFBCFLL);
  }
  return a1;
}

void md::mun::MuninLayer::prepare(md::mun::MuninLayer *this, md::LayoutContext *a2)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(md::LayoutContext::frameState(a2) + 117)) {
    return;
  }
  uint64_t v4 = *(void *)(*((void *)this + 5) + 24);
  uint64_t v5 = (void *)*((void *)a2 + 1);
  int8x8_t v6 = (int8x8_t)v5[1];
  if (!*(void *)&v6) {
    goto LABEL_25;
  }
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v8 = 0xC83717EF586624DCLL;
    if (*(void *)&v6 <= 0xC83717EF586624DCLL) {
      unint64_t v8 = 0xC83717EF586624DCLL % *(void *)&v6;
    }
  }
  else
  {
    unint64_t v8 = (*(void *)&v6 - 1) & 0xC83717EF586624DCLL;
  }
  uint64_t v9 = *(void **)(*v5 + 8 * v8);
  if (!v9) {
    goto LABEL_25;
  }
  uint64_t v10 = (void *)*v9;
  if (!v10) {
    goto LABEL_25;
  }
  if (v7.u32[0] < 2uLL)
  {
    uint64_t v11 = *(void *)&v6 - 1;
    while (1)
    {
      uint64_t v13 = v10[1];
      if (v13 == 0xC83717EF586624DCLL)
      {
        if (v10[2] == 0xC83717EF586624DCLL) {
          goto LABEL_23;
        }
      }
      else if ((v13 & v11) != v8)
      {
        goto LABEL_25;
      }
      uint64_t v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v12 = v10[1];
    if (v12 == 0xC83717EF586624DCLL) {
      break;
    }
    if (v12 >= *(void *)&v6) {
      v12 %= *(void *)&v6;
    }
    if (v12 != v8) {
      goto LABEL_25;
    }
LABEL_12:
    uint64_t v10 = (void *)*v10;
    if (!v10) {
      goto LABEL_25;
    }
  }
  if (v10[2] != 0xC83717EF586624DCLL) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v14 = v10[5];
  if (*(void *)(v14 + 8) != 0xC83717EF586624DCLL)
  {
LABEL_25:
    uint64_t v15 = 0;
    goto LABEL_26;
  }
  uint64_t v15 = *(void *)(v14 + 32);
LABEL_26:
  uint64_t v16 = *(void **)(v15 + 24);
  unint64_t v17 = v16 + 1;
  if (v16[4])
  {
    uint64_t v18 = (unsigned char *)v16[3];
    if (v18)
    {
      do
      {
        if (v18[112]) {
          v18[112] = 0;
        }
        unint64_t v52 = *(unsigned char **)v18;
        uint64_t v53 = (void *)*((void *)v18 + 4);
        if (v53 != *((void **)v18 + 6)) {
          free(v53);
        }
        operator delete(v18);
        uint64_t v18 = v52;
      }
      while (v52);
    }
    v16[3] = 0;
    uint64_t v19 = v16[2];
    if (v19)
    {
      for (uint64_t i = 0; i != v19; ++i)
        *(void *)(*v17 + 8 * i) = 0;
    }
    v16[4] = 0;
  }
  for (unint64_t j = *(void **)(v15 + 168); j; unint64_t j = (void *)*j)
  {
    float v22 = (uint64_t *)j[3];
    uint64_t v23 = (uint64_t *)j[4];
    while (v22 != v23)
    {
      uint64_t v24 = *v22;
      v22 += 2;
      std::__hash_table<gdc::LayerDataRequestKey,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,std::allocator<gdc::LayerDataRequestKey>>::__emplace_unique_key_args<gdc::LayerDataRequestKey,gdc::LayerDataRequestKey const&>((uint64_t)v17, (unsigned __int8 *)(v24 + 16), v24 + 16);
    }
  }
  uint64_t v25 = *((void *)this + 8);
  id v76 = *(id *)a2;
  uint64_t v26 = [v76 format];
  uint64_t v27 = (long long *)v26;
  long long v28 = *(_OWORD *)(v4 + 192);
  long long v78 = *(_OWORD *)(v4 + 176);
  long long v79 = v28;
  uint64_t v29 = *(void **)(*(void *)(v25 + 64) + 24);
  unint64_t v30 = (std::__shared_weak_count *)v29[1];
  uint64_t v77 = v30;
  if (v30)
  {
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v29 = *(void **)(*(void *)(v25 + 64) + 24);
  }
  uint64_t v32 = v29[6];
  unint64_t v31 = (std::__shared_weak_count *)v29[7];
  if (v31) {
    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v33 = *(void *)(v25 + 16);
  if (v33 != *(void *)(v26 + 16)
    || *(_DWORD *)(v25 + 24) != *(_DWORD *)(v26 + 24)
    || *(_DWORD *)(v25 + 28) != *(_DWORD *)(v26 + 28))
  {
    goto LABEL_50;
  }
  if (v33)
  {
    if (*(_DWORD *)v25 != *(_DWORD *)v26) {
      goto LABEL_50;
    }
    unint64_t v34 = 0;
    do
    {
      if (v33 - 1 == v34) {
        goto LABEL_88;
      }
      int v35 = *(_DWORD *)(v25 + 4 + 4 * v34);
      int v36 = *(_DWORD *)(v26 + 4 + 4 * v34++);
    }
    while (v35 == v36);
    if (v34 < v33)
    {
LABEL_50:
      long long v37 = *(_OWORD *)(v26 + 16);
      *(_OWORD *)uint64_t v25 = *(_OWORD *)v26;
      *(_OWORD *)(v25 + 16) = v37;
      uint64_t v38 = *(void *)(v32 + 80);
      uint64_t v40 = *(void *)(v38 + 8);
      uint64_t v39 = *(std::__shared_weak_count **)(v38 + 16);
      if (v39) {
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *(void *)&long long v84 = 0;
      uint64_t v41 = (char *)operator new(0x198uLL);
      *((void *)v41 + 1) = 0;
      *((void *)v41 + 2) = 0;
      *(void *)uint64_t v41 = &unk_1EF589390;
      long long v42 = v27[1];
      long long v80 = *v27;
      *(_OWORD *)uint64_t v81 = v42;
      {
        if (v72)
        {
          {
            if (v72)
            {
              {
                {
                  ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r = (uint64_t)&ggl::VSCommon::vertexReflection;
                }
                ggl::MeshTyped<ggl::VSCommon::Vertex>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
                *(void *)algn_1E957EFF0 = 1;
              }
              ggl::VSView::PipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::VSCommon::Vertex>::typedReflection(void)::r;
              *(void *)algn_1E957DE48 = &ggl::VSView::pipelineDataPipelineDeviceStructs(void)::ref;
              qword_1E957DE50 = 0;
              {
                ggl::VSView::pipelineDataPipelineConstantStructs(void)::ref = (uint64_t)ggl::VSView::View::reflection(void)::reflection;
                unk_1E957DEB0 = ggl::VSView::Shared::reflection(void)::reflection;
              }
              qword_1E957DE58 = (uint64_t)&ggl::VSView::pipelineDataPipelineConstantStructs(void)::ref;
              unk_1E957DE60 = xmmword_1A28FCEB0;
            }
          }
          ggl::VSView::PipelineState::typedReflection(void)::ref = (uint64_t)&ggl::VSView::PipelineSetup::typedReflection(void)::ref;
          ggl::ViewShader::typedReflection(v72);
          qword_1E957EEE0 = (uint64_t)&ggl::ViewShader::typedReflection(void)::ref;
          {
            ggl::VSView::pipelineStatePipelineAttributeStructBinding(void)::attr = 0;
            unk_1E957DF20 = 0;
            qword_1E957DF28 = (uint64_t)"";
            dword_1E957DF30 = 0;
            qword_1E957DF38 = (uint64_t)&ggl::VSView::pipelineStatePipelineAttributeBinding_0(void)::attr;
            unk_1E957DF40 = 2;
          }
          qword_1E957EEE8 = (uint64_t)&ggl::VSView::pipelineStatePipelineAttributeStructBinding(void)::attr;
          unk_1E957EEF0 = 1;
          qword_1E957EEF8 = 0;
          unk_1E957EF00 = 1;
          qword_1E957EF08 = (uint64_t)&ggl::VSView::pipelineStatePipelineDeviceStructBinding(void)::ref;
          unk_1E957EF10 = 0;
          {
            ggl::VSView::pipelineStatePipelineConstantStructBinding(void)::ref = 0;
            unk_1E957DEC0 = 0;
            qword_1E957DEC8 = (uint64_t)"view";
            dword_1E957DED0 = 3;
            qword_1E957DED8 = (uint64_t)&ggl::VSView::pipelineStatePipelineConstantViewBinding(void)::reflection;
            unk_1E957DEE0 = vdupq_n_s64(1uLL);
            qword_1E957DEF0 = 1;
            unk_1E957DEF8 = "sharedConstants";
            dword_1E957DF00 = 3;
            qword_1E957DF08 = (uint64_t)&ggl::VSView::pipelineStatePipelineConstantSharedConstantsBinding(void)::reflection;
            unk_1E957DF10 = 2;
          }
          qword_1E957EF18 = (uint64_t)&ggl::VSView::pipelineStatePipelineConstantStructBinding(void)::ref;
          unk_1E957EF20 = 2;
        }
      }
      if (v39) {
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *((void *)v41 + 4) = 0;
      *((void *)v41 + 5) = 0;
      *((_DWORD *)v41 + 14) = 0;
      *((void *)v41 + 6) = 0;
      *((void *)v41 + 3) = &unk_1EF55B208;
      *((void *)v41 + 8) = &ggl::VSView::PipelineState::typedReflection(void)::ref;
      *((void *)v41 + 9) = v40;
      *((void *)v41 + 10) = v39;
      if (v39) {
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v41[136] = 0;
      *(_OWORD *)(v41 + 140) = xmmword_1A28FC970;
      *(void *)(v41 + 156) = 0;
      *(void *)(v41 + 172) = 0;
      *(void *)(v41 + 164) = 0;
      v41[184] = 0;
      *(_OWORD *)(v41 + 188) = xmmword_1A28FC970;
      *(void *)(v41 + 204) = 0;
      *(void *)(v41 + 220) = 0;
      *(void *)(v41 + 212) = 0;
      v41[232] = 0;
      *(_OWORD *)(v41 + 236) = xmmword_1A28FC970;
      *(void *)(v41 + 252) = 0;
      *(void *)(v41 + 268) = 0;
      *(void *)(v41 + 260) = 0;
      long long v43 = *(_OWORD *)v81;
      *(_OWORD *)(v41 + 280) = v80;
      *(_OWORD *)(v41 + 296) = v43;
      v41[312] = 0;
      *((void *)v41 + 48) = 0;
      *((_OWORD *)v41 + 22) = 0u;
      *((_OWORD *)v41 + 23) = 0u;
      *((_OWORD *)v41 + 20) = 0u;
      *((_OWORD *)v41 + 21) = 0u;
      *((void *)v41 + 49) = 0x100000001;
      v41[400] = 0;
      v41[88] = 0;
      *(_WORD *)(v41 + 89) = v82;
      v41[91] = v83;
      *(_OWORD *)(v41 + 92) = xmmword_1A28FC970;
      *(void *)(v41 + 108) = v84;
      *((_DWORD *)v41 + 29) = 0;
      *((void *)v41 + 15) = 0;
      *((_DWORD *)v41 + 32) = 0;
      v41[132] = 15;
      if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
      *((void *)v41 + 3) = &unk_1EF560D48;
      uint64_t v44 = *(std::__shared_weak_count **)(v25 + 248);
      *(void *)(v25 + 240) = v41 + 24;
      *(void *)(v25 + 248) = v41;
      if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
        std::__shared_weak_count::__release_weak(v44);
      }
      if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
      uint64_t v45 = *(void *)(v32 + 80);
      uint64_t v46 = *(void *)(v45 + 152);
      uint64_t v47 = *(std::__shared_weak_count **)(v45 + 160);
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *(void *)&long long v84 = 0;
      uint64_t v48 = (char *)operator new(0x198uLL);
      *((void *)v48 + 1) = 0;
      *((void *)v48 + 2) = 0;
      *(void *)uint64_t v48 = &unk_1EF5832A8;
      long long v49 = v27[1];
      long long v80 = *v27;
      *(_OWORD *)uint64_t v81 = v49;
      {
        if (v73)
        {
          {
            if (v73)
            {
              {
                {
                  ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r = (uint64_t)&ggl::VSCommon::vertexReflection;
                }
                ggl::MeshTyped<ggl::VSCommon::Vertex>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
                *(void *)algn_1E957EFF0 = 1;
              }
              ggl::VSTextured::PassthroughPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::VSCommon::Vertex>::typedReflection(void)::r;
              unk_1E957EE20 = &ggl::VSTextured::pipelineDataPassthroughPipelineDeviceStructs(void)::ref;
              qword_1E957EE28 = 0;
              unk_1E957EE30 = &ggl::VSTextured::pipelineDataPassthroughPipelineConstantStructs(void)::ref;
              xmmword_1E957EE38 = xmmword_1A28FE150;
            }
          }
          ggl::VSTextured::PassthroughPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::VSTextured::PassthroughPipelineSetup::typedReflection(void)::ref;
          ggl::VSPassthroughShader::typedReflection(v73);
          qword_1E957EE58 = (uint64_t)&ggl::VSPassthroughShader::typedReflection(void)::ref;
          {
            ggl::VSTextured::pipelineStatePassthroughPipelineAttributeStructBinding(void)::attr = 0;
            *(void *)algn_1E957EEA8 = 0;
            qword_1E957EEB0 = (uint64_t)"";
            dword_1E957EEB8 = 0;
            qword_1E957EEC0 = (uint64_t)&ggl::VSTextured::pipelineStatePassthroughPipelineAttributeBinding_0(void)::attr;
            unk_1E957EEC8 = 2;
          }
          qword_1E957EE60 = (uint64_t)&ggl::VSTextured::pipelineStatePassthroughPipelineAttributeStructBinding(void)::attr;
          *(void *)algn_1E957EE68 = 1;
          qword_1E957EE70 = 0;
          unk_1E957EE78 = 2;
          qword_1E957EE80 = (uint64_t)&ggl::VSTextured::pipelineStatePassthroughPipelineDeviceStructBinding(void)::ref;
          unk_1E957EE88 = 0;
          qword_1E957EE90 = (uint64_t)&ggl::VSTextured::pipelineStatePassthroughPipelineConstantStructBinding(void)::ref;
          unk_1E957EE98 = 0;
        }
      }
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *((void *)v48 + 4) = 0;
      *((void *)v48 + 5) = 0;
      *((_DWORD *)v48 + 14) = 0;
      *((void *)v48 + 6) = 0;
      *((void *)v48 + 3) = &unk_1EF55B208;
      *((void *)v48 + 8) = &ggl::VSTextured::PassthroughPipelineState::typedReflection(void)::ref;
      *((void *)v48 + 9) = v46;
      *((void *)v48 + 10) = v47;
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v48[136] = 0;
      *(_OWORD *)(v48 + 140) = xmmword_1A28FC970;
      *(void *)(v48 + 156) = 0;
      *(void *)(v48 + 172) = 0;
      *(void *)(v48 + 164) = 0;
      v48[184] = 0;
      *(_OWORD *)(v48 + 188) = xmmword_1A28FC970;
      *(void *)(v48 + 204) = 0;
      *(void *)(v48 + 220) = 0;
      *(void *)(v48 + 212) = 0;
      v48[232] = 0;
      *(_OWORD *)(v48 + 236) = xmmword_1A28FC970;
      *(void *)(v48 + 252) = 0;
      *(void *)(v48 + 268) = 0;
      *(void *)(v48 + 260) = 0;
      long long v50 = *(_OWORD *)v81;
      *(_OWORD *)(v48 + 280) = v80;
      *(_OWORD *)(v48 + 296) = v50;
      v48[312] = 0;
      *((void *)v48 + 48) = 0;
      *((_OWORD *)v48 + 22) = 0u;
      *((_OWORD *)v48 + 23) = 0u;
      *((_OWORD *)v48 + 20) = 0u;
      *((_OWORD *)v48 + 21) = 0u;
      *((void *)v48 + 49) = 0x100000001;
      v48[400] = 0;
      v48[88] = 0;
      *(_WORD *)(v48 + 89) = v82;
      v48[91] = v83;
      *(_OWORD *)(v48 + 92) = xmmword_1A28FC970;
      *(void *)(v48 + 108) = v84;
      *((_DWORD *)v48 + 29) = 0;
      *((void *)v48 + 15) = 0;
      *((_DWORD *)v48 + 32) = 0;
      v48[132] = 15;
      if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
      *((void *)v48 + 3) = &unk_1EF55A4F8;
      uint64_t v51 = *(std::__shared_weak_count **)(v25 + 328);
      *(void *)(v25 + 320) = v48 + 24;
      *(void *)(v25 + 328) = v48;
      if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
        std::__shared_weak_count::__release_weak(v51);
      }
      if (v47)
      {
        if (!atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
          std::__shared_weak_count::__release_weak(v47);
        }
      }
      operator new();
    }
  }
LABEL_88:
  uint64_t v54 = (_DWORD *)(v25 + 32);
  unint64_t v55 = *(void *)(v25 + 48);
  if (*(_OWORD *)(v25 + 48) != v79) {
    goto LABEL_95;
  }
  if (v55)
  {
    if (*v54 != v78) {
      goto LABEL_95;
    }
    unint64_t v56 = 0;
    do
    {
      if (v55 - 1 == v56) {
        goto LABEL_128;
      }
      int v57 = *(_DWORD *)(v25 + 36 + 4 * v56);
      int v58 = *((_DWORD *)&v78 + ++v56);
    }
    while (v57 == v58);
    if (v56 < v55)
    {
LABEL_95:
      long long v59 = v79;
      *(_OWORD *)uint64_t v54 = v78;
      *(_OWORD *)(v25 + 48) = v59;
      uint64_t v60 = *(void *)(v32 + 80);
      uint64_t v61 = *(void *)(v60 + 32);
      unint64_t v62 = *(std::__shared_weak_count **)(v60 + 40);
      if (v62) {
        atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *(void *)&long long v84 = 0;
      uint64_t v63 = (char *)operator new(0x198uLL);
      *((void *)v63 + 1) = 0;
      *((void *)v63 + 2) = 0;
      *(void *)uint64_t v63 = &unk_1EF5893C8;
      long long v80 = v78;
      *(_OWORD *)uint64_t v81 = v79;
      {
        if (v74)
        {
          {
            if (v74)
            {
              {
                {
                  ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r = (uint64_t)&ggl::VSCommon::vertexReflection;
                }
                ggl::MeshTyped<ggl::VSCommon::Vertex>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
                *(void *)algn_1E957EFF0 = 1;
              }
              ggl::VSView::StretchAlphaPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::VSCommon::Vertex>::typedReflection(void)::r;
              *(void *)algn_1E957DE78 = &ggl::VSView::pipelineDataStretchAlphaPipelineDeviceStructs(void)::ref;
              qword_1E957DE80 = 0;
              {
                ggl::VSView::pipelineDataStretchAlphaPipelineConstantStructs(void)::ref = (uint64_t)ggl::VSView::View::reflection(void)::reflection;
                *(void *)algn_1E957DF58 = ggl::VSView::Shared::reflection(void)::reflection;
              }
              qword_1E957DE88 = (uint64_t)&ggl::VSView::pipelineDataStretchAlphaPipelineConstantStructs(void)::ref;
              unk_1E957DE90 = xmmword_1A28FCEB0;
            }
          }
          ggl::VSView::StretchAlphaPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::VSView::StretchAlphaPipelineSetup::typedReflection(void)::ref;
          ggl::ViewStretchAlphaShader::typedReflection(v74);
          qword_1E957EF30 = (uint64_t)&ggl::ViewStretchAlphaShader::typedReflection(void)::ref;
          {
            ggl::VSView::pipelineStateStretchAlphaPipelineAttributeStructBinding(void)::attr = 0;
            *(void *)algn_1E957DFC8 = 0;
            qword_1E957DFD0 = (uint64_t)"";
            dword_1E957DFD8 = 0;
            qword_1E957DFE0 = (uint64_t)&ggl::VSView::pipelineStateStretchAlphaPipelineAttributeBinding_0(void)::attr;
            unk_1E957DFE8 = 2;
          }
          qword_1E957EF38 = (uint64_t)&ggl::VSView::pipelineStateStretchAlphaPipelineAttributeStructBinding(void)::attr;
          unk_1E957EF40 = 1;
          qword_1E957EF48 = 0;
          unk_1E957EF50 = 1;
          qword_1E957EF58 = (uint64_t)&ggl::VSView::pipelineStateStretchAlphaPipelineDeviceStructBinding(void)::ref;
          unk_1E957EF60 = 0;
          {
            ggl::VSView::pipelineStateStretchAlphaPipelineConstantStructBinding(void)::ref = 0;
            *(void *)algn_1E957DF68 = 0;
            qword_1E957DF70 = (uint64_t)"view";
            dword_1E957DF78 = 3;
            qword_1E957DF80 = (uint64_t)&ggl::VSView::pipelineStateStretchAlphaPipelineConstantViewBinding(void)::reflection;
            unk_1E957DF88 = vdupq_n_s64(1uLL);
            qword_1E957DF98 = 1;
            unk_1E957DFA0 = "sharedConstants";
            dword_1E957DFA8 = 3;
            qword_1E957DFB0 = (uint64_t)&ggl::VSView::pipelineStateStretchAlphaPipelineConstantSharedConstantsBinding(void)::reflection;
            unk_1E957DFB8 = 2;
          }
          qword_1E957EF68 = (uint64_t)&ggl::VSView::pipelineStateStretchAlphaPipelineConstantStructBinding(void)::ref;
          unk_1E957EF70 = 2;
        }
      }
      if (v62) {
        atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *((void *)v63 + 4) = 0;
      *((void *)v63 + 5) = 0;
      *((_DWORD *)v63 + 14) = 0;
      *((void *)v63 + 6) = 0;
      *((void *)v63 + 3) = &unk_1EF55B208;
      *((void *)v63 + 8) = &ggl::VSView::StretchAlphaPipelineState::typedReflection(void)::ref;
      *((void *)v63 + 9) = v61;
      *((void *)v63 + 10) = v62;
      if (v62) {
        atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v63[136] = 0;
      *(_OWORD *)(v63 + 140) = xmmword_1A28FC970;
      *(void *)(v63 + 156) = 0;
      *(void *)(v63 + 172) = 0;
      *(void *)(v63 + 164) = 0;
      v63[184] = 0;
      *(_OWORD *)(v63 + 188) = xmmword_1A28FC970;
      *(void *)(v63 + 204) = 0;
      *(void *)(v63 + 220) = 0;
      *(void *)(v63 + 212) = 0;
      v63[232] = 0;
      *(_OWORD *)(v63 + 236) = xmmword_1A28FC970;
      *(void *)(v63 + 252) = 0;
      *(void *)(v63 + 268) = 0;
      *(void *)(v63 + 260) = 0;
      long long v64 = *(_OWORD *)v81;
      *(_OWORD *)(v63 + 280) = v80;
      *(_OWORD *)(v63 + 296) = v64;
      v63[312] = 0;
      *((void *)v63 + 48) = 0;
      *((_OWORD *)v63 + 22) = 0u;
      *((_OWORD *)v63 + 23) = 0u;
      *((_OWORD *)v63 + 20) = 0u;
      *((_OWORD *)v63 + 21) = 0u;
      *((void *)v63 + 49) = 0x100000001;
      v63[400] = 0;
      v63[88] = 1;
      *(_WORD *)(v63 + 89) = v82;
      v63[91] = v83;
      *(_OWORD *)(v63 + 92) = xmmword_1A28FC970;
      *(void *)(v63 + 108) = v84;
      *((_DWORD *)v63 + 29) = 0;
      *((void *)v63 + 15) = 0;
      *((_DWORD *)v63 + 32) = 0;
      v63[132] = 15;
      if (v62 && !atomic_fetch_add(&v62->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
        std::__shared_weak_count::__release_weak(v62);
      }
      *((void *)v63 + 3) = &unk_1EF560D98;
      unint64_t v65 = *(std::__shared_weak_count **)(v25 + 224);
      *(void *)(v25 + 216) = v63 + 24;
      *(void *)(v25 + 224) = v63;
      if (v65 && !atomic_fetch_add(&v65->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
        std::__shared_weak_count::__release_weak(v65);
      }
      if (v62 && !atomic_fetch_add(&v62->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
        std::__shared_weak_count::__release_weak(v62);
      }
      uint64_t v66 = *(void *)(v32 + 80);
      uint64_t v68 = *(void *)(v66 + 128);
      unint64_t v67 = *(std::__shared_weak_count **)(v66 + 136);
      if (v67) {
        atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *(void *)&long long v84 = 0;
      BOOL v69 = (char *)operator new(0x198uLL);
      *((void *)v69 + 1) = 0;
      *((void *)v69 + 2) = 0;
      *(void *)BOOL v69 = &unk_1EF583270;
      long long v80 = v78;
      *(_OWORD *)uint64_t v81 = v79;
      {
        if (v75)
        {
          {
            if (v75)
            {
              {
                {
                  ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r = (uint64_t)&ggl::VSCommon::vertexReflection;
                }
                ggl::MeshTyped<ggl::VSCommon::Vertex>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
                *(void *)algn_1E957EFF0 = 1;
              }
              ggl::VSTextured::CompositingPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::VSCommon::Vertex>::typedReflection(void)::r;
              unk_1E957DC60 = &ggl::VSTextured::pipelineDataCompositingPipelineDeviceStructs(void)::ref;
              qword_1E957DC68 = 0;
              {
                ggl::VSTextured::pipelineDataCompositingPipelineConstantStructs(void)::ref = (uint64_t)ggl::VSTextured::Style::reflection(void)::reflection;
              }
              qword_1E957DC70 = (uint64_t)&ggl::VSTextured::pipelineDataCompositingPipelineConstantStructs(void)::ref;
              unk_1E957DC78 = xmmword_1A28FE160;
            }
          }
          ggl::VSTextured::CompositingPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::VSTextured::CompositingPipelineSetup::typedReflection(void)::ref;
          ggl::VSCompositingShader::typedReflection(v75);
          qword_1E957EDC8 = (uint64_t)&ggl::VSCompositingShader::typedReflection(void)::ref;
          {
            ggl::VSTextured::pipelineStateCompositingPipelineAttributeStructBinding(void)::attr = 0;
            *(void *)algn_1E957DCD8 = 0;
            qword_1E957DCE0 = (uint64_t)"";
            dword_1E957DCE8 = 0;
            qword_1E957DCF0 = (uint64_t)&ggl::VSTextured::pipelineStateCompositingPipelineAttributeBinding_0(void)::attr;
            unk_1E957DCF8 = 2;
          }
          qword_1E957EDD0 = (uint64_t)&ggl::VSTextured::pipelineStateCompositingPipelineAttributeStructBinding(void)::attr;
          *(void *)algn_1E957EDD8 = 1;
          qword_1E957EDE0 = 0;
          unk_1E957EDE8 = 7;
          qword_1E957EDF0 = (uint64_t)&ggl::VSTextured::pipelineStateCompositingPipelineDeviceStructBinding(void)::ref;
          unk_1E957EDF8 = 0;
          {
            ggl::VSTextured::pipelineStateCompositingPipelineConstantStructBinding(void)::ref = 0;
            *(void *)algn_1E957DCA8 = 0;
            qword_1E957DCB0 = (uint64_t)"style";
            dword_1E957DCB8 = 3;
            qword_1E957DCC0 = (uint64_t)&ggl::VSTextured::pipelineStateCompositingPipelineConstantStyleBinding(void)::reflection;
            unk_1E957DCC8 = 6;
          }
          qword_1E957EE00 = (uint64_t)&ggl::VSTextured::pipelineStateCompositingPipelineConstantStructBinding(void)::ref;
          unk_1E957EE08 = 1;
        }
      }
      if (v67) {
        atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *((void *)v69 + 4) = 0;
      *((void *)v69 + 5) = 0;
      *((_DWORD *)v69 + 14) = 0;
      *((void *)v69 + 6) = 0;
      *((void *)v69 + 3) = &unk_1EF55B208;
      *((void *)v69 + 8) = &ggl::VSTextured::CompositingPipelineState::typedReflection(void)::ref;
      *((void *)v69 + 9) = v68;
      *((void *)v69 + 10) = v67;
      if (v67) {
        atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v69[136] = 0;
      *(_OWORD *)(v69 + 140) = xmmword_1A28FC970;
      *(void *)(v69 + 156) = 0;
      *(void *)(v69 + 172) = 0;
      *(void *)(v69 + 164) = 0;
      v69[184] = 0;
      *(_OWORD *)(v69 + 188) = xmmword_1A28FC970;
      *(void *)(v69 + 204) = 0;
      *(void *)(v69 + 220) = 0;
      *(void *)(v69 + 212) = 0;
      v69[232] = 0;
      *(_OWORD *)(v69 + 236) = xmmword_1A28FC970;
      *(void *)(v69 + 252) = 0;
      *(void *)(v69 + 268) = 0;
      *(void *)(v69 + 260) = 0;
      long long v70 = *(_OWORD *)v81;
      *(_OWORD *)(v69 + 280) = v80;
      *(_OWORD *)(v69 + 296) = v70;
      v69[312] = 0;
      *((void *)v69 + 48) = 0;
      *((_OWORD *)v69 + 22) = 0u;
      *((_OWORD *)v69 + 23) = 0u;
      *((_OWORD *)v69 + 20) = 0u;
      *((_OWORD *)v69 + 21) = 0u;
      *((void *)v69 + 49) = 0x100000001;
      v69[400] = 0;
      v69[88] = 0;
      *(_WORD *)(v69 + 89) = v82;
      v69[91] = v83;
      *(_OWORD *)(v69 + 92) = xmmword_1A28FC970;
      *(void *)(v69 + 108) = v84;
      *((_DWORD *)v69 + 29) = 0;
      *((void *)v69 + 15) = 0;
      *((_DWORD *)v69 + 32) = 0;
      v69[132] = 15;
      if (v67 && !atomic_fetch_add(&v67->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
        std::__shared_weak_count::__release_weak(v67);
      }
      *((void *)v69 + 3) = &unk_1EF55A4A8;
      unint64_t v71 = *(std::__shared_weak_count **)(v25 + 288);
      *(void *)(v25 + 280) = v69 + 24;
      *(void *)(v25 + 288) = v69;
      if (v71 && !atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
        std::__shared_weak_count::__release_weak(v71);
      }
      if (v67 && !atomic_fetch_add(&v67->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
        std::__shared_weak_count::__release_weak(v67);
      }
      operator new();
    }
  }
LABEL_128:
  if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  if (v77 && !atomic_fetch_add(&v77->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
    std::__shared_weak_count::__release_weak(v77);
  }
}

void sub_1A207F508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, std::__shared_weak_count *a10)
{
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  if (a10)
  {
    if (!atomic_fetch_add(&a10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }

  _Unwind_Resume(a1);
}

void md::mun::MuninLayer::~MuninLayer(md::mun::MuninLayer *this)
{
  md::mun::MuninLayer::~MuninLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  md::mun::MuninRenderResources *v8;
  void *v9;

  *(void *)this = &unk_1EF550198;
  int8x8_t v2 = (void *)*((void *)this + 9);
  if (v2)
  {
    int8x8_t v3 = (void *)*((void *)this + 10);
    uint64_t v4 = (void *)*((void *)this + 9);
    if (v3 != v2)
    {
      do
      {
        int8x8_t v6 = *--v3;
        uint64_t v5 = v6;
        *int8x8_t v3 = 0;
        if (v6)
        {
          std::array<std::unique_ptr<ggl::Drawable>,3ul>::~array((uint64_t **)(v5 + 24));
          uint8x8_t v7 = *(void **)v5;
          if (*(void *)v5)
          {
            *(void *)(v5 + 8) = v7;
            operator delete(v7);
          }
          MEMORY[0x1A6239270](v5, 0x20C40A759441BLL);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 9);
    }
    *((void *)this + 10) = v2;
    operator delete(v4);
  }
  unint64_t v8 = (md::mun::MuninRenderResources *)*((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v8)
  {
    md::mun::MuninRenderResources::~MuninRenderResources(v8);
    MEMORY[0x1A6239270]();
  }

  *(void *)this = &unk_1EF530C60;
  uint64_t v9 = (void *)*((void *)this + 1);
  if (v9)
  {
    *((void *)this + 2) = v9;
    operator delete(v9);
  }
}

void md::mun::MuninRenderResources::~MuninRenderResources(md::mun::MuninRenderResources *this)
{
  uint64_t v2 = *((void *)this + 43);
  *((void *)this + 43) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 42);
  *((void *)this + 42) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 41);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = *((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 38);
  *((void *)this + 38) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *((void *)this + 37);
  *((void *)this + 37) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  unint64_t v8 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 34);
    if (!v9) {
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 34);
    if (!v9) {
      goto LABEL_20;
    }
  }
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
LABEL_20:
  uint64_t v10 = *((void *)this + 32);
  *((void *)this + 32) = 0;
  if (v10)
  {
    uint64_t v11 = ggl::FragmentedPool<ggl::VSView::PipelineSetup>::~FragmentedPool(v10);
    MEMORY[0x1A6239270](v11, 0x10A0C40D234DDC7);
  }
  unint64_t v12 = (std::__shared_weak_count *)*((void *)this + 31);
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  uint64_t v13 = *((void *)this + 29);
  *((void *)this + 29) = 0;
  if (v13)
  {
    uint64_t v14 = ggl::FragmentedPool<ggl::VSView::StretchAlphaPipelineSetup>::~FragmentedPool(v13);
    MEMORY[0x1A6239270](v14, 0x10A0C40D234DDC7);
  }
  uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 28);
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  uint64_t v16 = (void *)*((void *)this + 24);
  do
  {
    if (v16[1])
    {
      unint64_t v17 = 0;
      uint64_t v18 = v16 + 2;
      uint64_t v19 = v16 + 2;
      uint8x8_t v20 = (void (***)(void))(v16 + 2);
      do
      {
        uint64_t v21 = (void (**)(void *))*v20;
        v20 += 15;
        (*v21)(v19);
        ++v17;
        v18 += 15;
        uint64_t v19 = v20;
      }
      while (v17 < v16[1]);
    }
    v16[1] = 0;
    uint64_t v16 = (void *)*v16;
  }
  while (v16);
  float v22 = (void **)*((void *)this + 24);
  *((void *)this + 25) = v22;
  uint64_t v23 = *v22;
  uint64_t *v22 = 0;
  if (v23)
  {
    do
    {
      uint64_t v24 = (void *)*v23;
      free(v23);
      uint64_t v23 = v24;
    }
    while (v24);
    float v22 = (void **)*((void *)this + 24);
  }
  free(v22);
  uint64_t v25 = *((void *)this + 23);
  *((void *)this + 23) = 0;
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
  }
  uint64_t v26 = (std::__shared_weak_count *)*((void *)this + 22);
  if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
    uint64_t v27 = (void *)*((void *)this + 18);
    if (!v27) {
      goto LABEL_51;
    }
  }
  else
  {
    uint64_t v27 = (void *)*((void *)this + 18);
    if (!v27) {
      goto LABEL_51;
    }
  }
  long long v28 = (void *)*((void *)this + 19);
  uint64_t v29 = v27;
  if (v28 != v27)
  {
    do
    {
      uint64_t v31 = *--v28;
      uint64_t v30 = v31;
      void *v28 = 0;
      if (v31) {
        (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
      }
    }
    while (v28 != v27);
    uint64_t v29 = (void *)*((void *)this + 18);
  }
  *((void *)this + 19) = v27;
  operator delete(v29);
LABEL_51:
  uint64_t v32 = *((void *)this + 17);
  *((void *)this + 17) = 0;
  if (v32) {
    (*(void (**)(uint64_t))(*(void *)v32 + 8))(v32);
  }
  uint64_t v33 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v33) {
    (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
  }
  unint64_t v34 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  uint64_t v35 = *((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v35) {
    MEMORY[0x1A6239270](v35, 0x1000C4049ECCB0CLL);
  }
  int v36 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
  }
  uint64_t v37 = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v37) {
    (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
  }
  uint64_t v38 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v38) {
    (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
  }
}

void altitude::ProtocolLoader::getProtocol(altitude::ProtocolLoader *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v2 = (void *)*((void *)this + 12);
  uint64_t v3 = (char *)this + 104;
  if (v2 != (void *)((char *)this + 104))
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = (long long *)(v2 + 4);
      if ((unint64_t)v5 >= a2[2])
      {
        uint64_t v5 = std::vector<std::string>::__push_back_slow_path<std::string const&>((uint64_t)a2, (uint64_t)v6);
      }
      else
      {
        if (*((char *)v2 + 55) < 0)
        {
          std::string::__init_copy_ctor_external(v5, (const std::string::value_type *)v2[4], v2[5]);
        }
        else
        {
          long long v7 = *v6;
          v5->__r_.__value_.__r.__words[2] = v2[6];
          *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v7;
        }
        ++v5;
      }
      a2[1] = v5;
      unint64_t v8 = (char *)v2[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          unint64_t v8 = *(char **)v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (char *)v2[2];
          BOOL v10 = *(void *)v9 == (void)v2;
          uint64_t v2 = v9;
        }
        while (!v10);
      }
      uint64_t v2 = v9;
    }
    while (v9 != v3);
  }
}

uint64_t altitude::ProtocolLoader::waitOnFile(uint64_t a1, char **a2)
{
  uint64_t result = altitude::ProtocolLoader::getLoaderForFile(a1, a2);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 128);
    return v3();
  }
  return result;
}

uint64_t altitude::ProtocolLoader::getLoaderForFile(uint64_t a1, char **a2)
{
  LODWORD(v3) = 4;
  HIBYTE(v37) = 4;
  strcpy((char *)__p, "file");
  char v4 = *((unsigned char *)a2 + 23);
  if (v4 >= 0) {
    uint64_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v5 = (uint64_t)a2[1];
  }
  if (v4 >= 0) {
    uint64_t v6 = (char *)a2;
  }
  else {
    uint64_t v6 = *a2;
  }
  if (v5 < 3) {
    goto LABEL_16;
  }
  long long v7 = &v6[v5];
  uint64_t v8 = v5;
  uint64_t v9 = v6;
  while (1)
  {
    BOOL v10 = (char *)memchr(v9, 58, v8 - 2);
    if (!v10)
    {
LABEL_15:
      LODWORD(v3) = 4;
      goto LABEL_16;
    }
    if (*(_WORD *)v10 == 12090 && v10[2] == 47) {
      break;
    }
    uint64_t v9 = v10 + 1;
    uint64_t v8 = v7 - (unsigned char *)v9;
    if (v7 - (unsigned char *)v9 < 3) {
      goto LABEL_15;
    }
  }
  LODWORD(v3) = 4;
  if (v10 == v7 || v10 - v6 == -1) {
    goto LABEL_16;
  }
  if (v5 >= (unint64_t)(v10 - v6)) {
    size_t v29 = v10 - v6;
  }
  else {
    size_t v29 = v5;
  }
  if (v29 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v29 >= 0x17)
  {
    uint64_t v32 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v29 | 7) != 0x17) {
      uint64_t v32 = v29 | 7;
    }
    uint64_t v33 = v32 + 1;
    p_dst = (long long *)operator new(v32 + 1);
    *((void *)&__dst + 1) = v29;
    unint64_t v35 = v33 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
  }
  else
  {
    HIBYTE(v35) = v29;
    p_dst = &__dst;
    if (!v29) {
      goto LABEL_70;
    }
  }
  memmove(p_dst, v6, v29);
LABEL_70:
  *((unsigned char *)p_dst + v29) = 0;
  if (SHIBYTE(v37) < 0) {
    operator delete(__p[0]);
  }
  unint64_t v37 = v35;
  *(_OWORD *)__p = __dst;
  unint64_t v3 = HIBYTE(v35);
LABEL_16:
  uint64_t v14 = *(uint64_t **)(a1 + 104);
  unint64_t v12 = (uint64_t *)(a1 + 104);
  uint64_t v13 = v14;
  if (!v14) {
    goto LABEL_63;
  }
  if ((v3 & 0x80u) == 0) {
    uint64_t v15 = __p;
  }
  else {
    uint64_t v15 = (void **)__p[0];
  }
  if ((v3 & 0x80u) == 0) {
    size_t v16 = v3;
  }
  else {
    size_t v16 = (size_t)__p[1];
  }
  unint64_t v17 = v12;
  do
  {
    while (1)
    {
      int v18 = *((char *)v13 + 55);
      uint64_t v19 = v18 >= 0 ? v13 + 4 : (uint64_t *)v13[4];
      size_t v20 = v18 >= 0 ? *((unsigned __int8 *)v13 + 55) : v13[5];
      size_t v21 = v16 >= v20 ? v20 : v16;
      int v22 = memcmp(v19, v15, v21);
      if (v22) {
        break;
      }
      if (v20 >= v16) {
        goto LABEL_38;
      }
LABEL_24:
      uint64_t v13 = (uint64_t *)v13[1];
      if (!v13) {
        goto LABEL_39;
      }
    }
    if (v22 < 0) {
      goto LABEL_24;
    }
LABEL_38:
    unint64_t v17 = v13;
    uint64_t v13 = (uint64_t *)*v13;
  }
  while (v13);
LABEL_39:
  if (v17 == v12) {
    goto LABEL_63;
  }
  int v23 = *((char *)v17 + 55);
  if (v23 >= 0) {
    uint64_t v24 = v17 + 4;
  }
  else {
    uint64_t v24 = (const void *)v17[4];
  }
  if (v23 >= 0) {
    size_t v25 = *((unsigned __int8 *)v17 + 55);
  }
  else {
    size_t v25 = v17[5];
  }
  if (v25 >= v16) {
    size_t v26 = v16;
  }
  else {
    size_t v26 = v25;
  }
  int v27 = memcmp(v15, v24, v26);
  if (v27)
  {
    if ((v27 & 0x80000000) == 0) {
      goto LABEL_51;
    }
LABEL_63:
    uint64_t v28 = 0;
    if ((v3 & 0x80) != 0) {
      goto LABEL_64;
    }
  }
  else
  {
    if (v16 < v25) {
      goto LABEL_63;
    }
LABEL_51:
    uint64_t v28 = v17[7];
    if ((v3 & 0x80) != 0) {
LABEL_64:
    }
      operator delete(__p[0]);
  }
  return v28;
}

uint64_t altitude::ProtocolLoader::requestStore@<X0>(uint64_t a1@<X0>, char **a2@<X1>, void *a3@<X8>)
{
  uint64_t result = altitude::ProtocolLoader::getLoaderForFile(a1, a2);
  if (result)
  {
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)result + 112);
    return v5();
  }
  else
  {
    a3[1] = 0;
    a3[2] = 0;
    *a3 = off_1EF5677B0;
  }
  return result;
}

uint64_t altitude::ProtocolLoader::requestFile@<X0>(uint64_t a1@<X0>, char **a2@<X1>, void *a3@<X8>)
{
  uint64_t result = altitude::ProtocolLoader::getLoaderForFile(a1, a2);
  if (result)
  {
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)result + 104);
    return v5();
  }
  else
  {
    a3[1] = 0;
    a3[2] = 0;
    *a3 = off_1EF5676C0;
    a3[3] = 0;
    a3[4] = 0;
  }
  return result;
}

void altitude::ProtocolLoader::createRequest(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t altitude::ProtocolLoader::clearRequest(uint64_t a1, char **a2)
{
  uint64_t result = altitude::ProtocolLoader::getLoaderForFile(a1, a2);
  if (result)
  {
    unint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 48);
    return v3();
  }
  return result;
}

void altitude::ProtocolLoader::~ProtocolLoader(altitude::ProtocolLoader *this)
{
  *(void *)this = &unk_1EF568E78;
  uint64_t v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    *((void *)this + 16) = v2;
    operator delete(v2);
  }
  std::__tree<std::string>::destroy(*((char **)this + 13));
  *(void *)this = &unk_1EF567DD8;
  while (*((void *)this + 10))
    (*(void (**)(altitude::ProtocolLoader *, uint64_t))(*(void *)this + 48))(this, *((void *)this + 8) + 32);
  std::__tree<std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<karo::AsyncFileRequestId,std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<karo::AsyncFileRequestId>,true>,std::allocator<std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((char **)this + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF568E78;
  uint64_t v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    *((void *)this + 16) = v2;
    operator delete(v2);
  }
  std::__tree<std::string>::destroy(*((char **)this + 13));
  *(void *)this = &unk_1EF567DD8;
  while (*((void *)this + 10))
    (*(void (**)(altitude::ProtocolLoader *, uint64_t))(*(void *)this + 48))(this, *((void *)this + 8) + 32);
  std::__tree<std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<karo::AsyncFileRequestId,std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<karo::AsyncFileRequestId>,true>,std::allocator<std::__value_type<karo::AsyncFileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((char **)this + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(this);
}

void altitude::ProtocolLoader::addLoader(void *a1, uint64_t a2)
{
  unint64_t v3 = a1;
  uint64_t v5 = (char *)a1[16];
  unint64_t v4 = a1[17];
  uint64_t v6 = v5;
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v8 = (char *)a1[15];
    uint64_t v9 = (v5 - v8) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      abort();
    }
    uint64_t v11 = v4 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v13 = operator new(8 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    uint64_t v15 = &v13[8 * v12];
    *uint64_t v14 = a2;
    long long v7 = v14 + 1;
    if (v5 == v8)
    {
      uint64_t v8 = v5;
    }
    else
    {
      unint64_t v16 = v5 - v8 - 8;
      if (v16 < 0x58) {
        goto LABEL_108;
      }
      if ((unint64_t)(v8 - v13) < 0x20) {
        goto LABEL_108;
      }
      uint64_t v17 = (v16 >> 3) + 1;
      uint64_t v6 = &v5[-8 * (v17 & 0x3FFFFFFFFFFFFFFCLL)];
      int v18 = &v13[8 * v9 - 16];
      uint64_t v19 = v5 - 16;
      uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v21 = *(_OWORD *)v19;
        *(v18 - 1) = *((_OWORD *)v19 - 1);
        _OWORD *v18 = v21;
        v18 -= 2;
        v19 -= 32;
        v20 -= 4;
      }
      while (v20);
      v14 -= v17 & 0x3FFFFFFFFFFFFFFCLL;
      if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_108:
        do
        {
          uint64_t v22 = *((void *)v6 - 1);
          v6 -= 8;
          *--uint64_t v14 = v22;
        }
        while (v6 != v8);
        uint64_t v8 = (char *)v3[15];
      }
    }
    v3[15] = v14;
    v3[16] = v7;
    v3[17] = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *(void *)uint64_t v5 = a2;
    long long v7 = v5 + 8;
  }
  int v23 = (char *)v3[13];
  v3[16] = v7;
  std::__tree<std::string>::destroy(v23);
  v3[12] = v3 + 13;
  v3[13] = 0;
  v3[14] = 0;
  uint64_t v24 = v3[15];
  long long v70 = v3 + 13;
  if (v3[16] != v24)
  {
    unint64_t v25 = 0;
    int v26 = 0;
    uint64_t v68 = v3;
    while (1)
    {
      int v67 = v26;
      (*(void (**)(void **__return_ptr))(**(void **)(v24 + 8 * v25) + 136))(&__p);
      uint64_t v28 = (void **)__p;
      int v27 = v73;
      if (v73 != __p) {
        break;
      }
      uint64_t v28 = v73;
LABEL_97:
      if (v28)
      {
        if (v27 != v28)
        {
          do
          {
            if (*((char *)v27 - 1) < 0) {
              operator delete(*(v27 - 3));
            }
            v27 -= 3;
          }
          while (v27 != v28);
          int v27 = (void **)__p;
        }
        __int32 v73 = v28;
        operator delete(v27);
      }
      unint64_t v25 = (v67 + 1);
      uint64_t v24 = v3[15];
      int v26 = v67 + 1;
      if (v25 >= (v3[16] - v24) >> 3) {
        return;
      }
    }
    uint64_t v29 = 0;
    unsigned int v30 = 0;
    unint64_t v69 = v25;
    while (1)
    {
      uint64_t v31 = (char *)&v28[3 * v29];
      int v32 = v31[23];
      if (v32 >= 0) {
        size_t v33 = v31[23];
      }
      else {
        size_t v33 = *((void *)v31 + 1);
      }
      if (v33)
      {
        uint64_t v71 = *(void *)(v3[15] + 8 * v25);
        unint64_t v34 = (void *)v3[13];
        unint64_t v35 = v70;
        int v36 = (uint64_t **)v70;
        if (v34)
        {
          if (v32 >= 0) {
            unint64_t v37 = v31;
          }
          else {
            unint64_t v37 = *(const std::string::value_type **)v31;
          }
          while (1)
          {
            unint64_t v35 = v34;
            uint64_t v40 = (const void *)v34[4];
            uint64_t v38 = v34 + 4;
            uint64_t v39 = v40;
            int v41 = *((char *)v38 + 23);
            if (v41 >= 0) {
              long long v42 = v38;
            }
            else {
              long long v42 = v39;
            }
            if (v41 >= 0) {
              size_t v43 = *((unsigned __int8 *)v38 + 23);
            }
            else {
              size_t v43 = v38[1];
            }
            if (v43 >= v33) {
              size_t v44 = v33;
            }
            else {
              size_t v44 = v43;
            }
            int v45 = memcmp(v37, v42, v44);
            if (v45)
            {
              if (v45 < 0) {
                goto LABEL_44;
              }
LABEL_58:
              int v46 = memcmp(v42, v37, v44);
              if (v46)
              {
                if ((v46 & 0x80000000) == 0) {
                  goto LABEL_84;
                }
              }
              else if (v43 >= v33)
              {
LABEL_84:
                uint64_t v47 = v35;
                unint64_t v3 = v68;
                unint64_t v25 = v69;
                uint64_t v50 = v71;
                goto LABEL_34;
              }
              unint64_t v34 = (void *)v35[1];
              if (!v34)
              {
                int v36 = (uint64_t **)(v35 + 1);
                break;
              }
            }
            else
            {
              if (v33 >= v43) {
                goto LABEL_58;
              }
LABEL_44:
              unint64_t v34 = (void *)*v35;
              int v36 = (uint64_t **)v35;
              if (!*v35) {
                break;
              }
            }
          }
        }
        uint64_t v47 = operator new(0x40uLL);
        uint64_t v48 = (std::string *)(v47 + 4);
        if (v31[23] < 0)
        {
          std::string::__init_copy_ctor_external(v48, *(const std::string::value_type **)v31, *((void *)v31 + 1));
        }
        else
        {
          long long v49 = *(_OWORD *)v31;
          v47[6] = *((void *)v31 + 2);
          *(_OWORD *)&v48->__r_.__value_.__l.__data_ = v49;
        }
        unint64_t v3 = v68;
        unint64_t v25 = v69;
        uint64_t v50 = v71;
        v47[7] = 0;
        void *v47 = 0;
        v47[1] = 0;
        v47[2] = v35;
        *int v36 = v47;
        uint64_t v51 = *(void *)v68[12];
        unint64_t v52 = v47;
        if (v51)
        {
          v68[12] = v51;
          unint64_t v52 = *v36;
        }
        uint64_t v53 = (uint64_t *)*v70;
        BOOL v54 = v52 == (uint64_t *)*v70;
        *((unsigned char *)v52 + 24) = v54;
        if (!v54)
        {
          do
          {
            uint64_t v55 = v52[2];
            if (*(unsigned char *)(v55 + 24)) {
              break;
            }
            unint64_t v56 = *(uint64_t **)(v55 + 16);
            uint64_t v57 = *v56;
            if (*v56 == v55)
            {
              uint64_t v60 = v56[1];
              if (!v60 || (int v61 = *(unsigned __int8 *)(v60 + 24), v58 = (unsigned char *)(v60 + 24), v61))
              {
                if (*(uint64_t **)v55 == v52)
                {
                  unint64_t v62 = (uint64_t *)v52[2];
                }
                else
                {
                  unint64_t v62 = *(uint64_t **)(v55 + 8);
                  uint64_t v63 = *v62;
                  *(void *)(v55 + 8) = *v62;
                  if (v63)
                  {
                    *(void *)(v63 + 16) = v55;
                    unint64_t v56 = *(uint64_t **)(v55 + 16);
                  }
                  v62[2] = (uint64_t)v56;
                  *(void *)(*(void *)(v55 + 16) + 8 * (**(void **)(v55 + 16) != v55)) = v62;
                  uint64_t *v62 = v55;
                  *(void *)(v55 + 16) = v62;
                  unint64_t v56 = (uint64_t *)v62[2];
                  uint64_t v55 = *v56;
                }
                *((unsigned char *)v62 + 24) = 1;
                *((unsigned char *)v56 + 24) = 0;
                uint64_t v66 = *(void *)(v55 + 8);
                uint64_t *v56 = v66;
                if (v66) {
                  *(void *)(v66 + 16) = v56;
                }
                *(void *)(v55 + 16) = v56[2];
                *(void *)(v56[2] + 8 * (*(void *)v56[2] != (void)v56)) = v55;
                *(void *)(v55 + 8) = v56;
                goto LABEL_32;
              }
            }
            else if (!v57 || (v59 = *(unsigned __int8 *)(v57 + 24), int v58 = (unsigned char *)(v57 + 24), v59))
            {
              if (*(uint64_t **)v55 == v52)
              {
                uint64_t v64 = v52[1];
                *(void *)uint64_t v55 = v64;
                if (v64)
                {
                  *(void *)(v64 + 16) = v55;
                  unint64_t v56 = *(uint64_t **)(v55 + 16);
                }
                v52[2] = (uint64_t)v56;
                *(void *)(*(void *)(v55 + 16) + 8 * (**(void **)(v55 + 16) != v55)) = v52;
                v52[1] = v55;
                *(void *)(v55 + 16) = v52;
                unint64_t v56 = (uint64_t *)v52[2];
              }
              else
              {
                unint64_t v52 = (uint64_t *)v52[2];
              }
              *((unsigned char *)v52 + 24) = 1;
              *((unsigned char *)v56 + 24) = 0;
              uint64_t v55 = v56[1];
              unint64_t v65 = *(uint64_t **)v55;
              v56[1] = *(void *)v55;
              if (v65) {
                v65[2] = (uint64_t)v56;
              }
              *(void *)(v55 + 16) = v56[2];
              *(void *)(v56[2] + 8 * (*(void *)v56[2] != (void)v56)) = v55;
              *(void *)uint64_t v55 = v56;
LABEL_32:
              unsigned char v56[2] = v55;
              break;
            }
            *(unsigned char *)(v55 + 24) = 1;
            unint64_t v52 = v56;
            *((unsigned char *)v56 + 24) = v56 == v53;
            unsigned char *v58 = 1;
          }
          while (v56 != v53);
        }
        ++v68[14];
        uint64_t v28 = (void **)__p;
        int v27 = v73;
LABEL_34:
        v47[7] = v50;
      }
      uint64_t v29 = ++v30;
      if (0xAAAAAAAAAAAAAAABLL * (v27 - v28) <= v30) {
        goto LABEL_97;
      }
    }
  }
}

void altitude::Route::append(altitude::Route *this, float a2)
{
}

float altitude::Route::widthForZoom(altitude::Route *this, float a2)
{
  unint64_t v4 = (md::realistic::RouteRenderLayer *)*((void *)this + 4);
  md::realistic::RouteRenderLayer::loadStylesheet(v4);
  uint64_t v5 = (md::realistic::RouteRenderLayer *)*((void *)this + 4);
  md::realistic::RouteRenderLayer::loadStylesheet(v5);
  uint64_t v6 = *((void *)v4 + 29);
  long long v7 = (std::__shared_weak_count *)*((void *)v4 + 30);
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v55 = v7;
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    uint64_t v55 = 0;
  }
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  uint64_t v54 = v6;
  char v58 = 0;
  if (v6) {
    LOBYTE(v6) = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v6 + 48))(v6, &v56);
  }
  char v58 = v6;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    uint64_t v8 = *((void *)v5 + 31);
    uint64_t v9 = (std::__shared_weak_count *)*((void *)v5 + 32);
    if (v9) {
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v8 = *((void *)v5 + 31);
    uint64_t v9 = (std::__shared_weak_count *)*((void *)v5 + 32);
    if (v9)
    {
LABEL_9:
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v50 = v9;
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      goto LABEL_12;
    }
  }
  uint64_t v50 = 0;
LABEL_12:
  uint64_t v51 = 0;
  unint64_t v52 = 0;
  uint64_t v49 = v8;
  unsigned __int8 v53 = 0;
  if (v8) {
    LODWORD(v8) = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v8 + 48))(v8, &v51);
  }
  unsigned __int8 v53 = v8;
  if (v9)
  {
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    LODWORD(v8) = v53;
  }
  if (!v58)
  {
    float v18 = 0.0;
    if (!v8) {
      goto LABEL_71;
    }
    goto LABEL_70;
  }
  if (v8)
  {
    if (*(unsigned char *)(*((void *)this + 5) + 64)) {
      unint64_t v10 = &v54;
    }
    else {
      unint64_t v10 = &v49;
    }
    uint64_t v11 = *(void *)(*v10 + 24);
    unint64_t v12 = *(float **)v11;
    if (*(void *)v11
      && (float v13 = *v12, LODWORD(v12) = *v12 == 1.0, *(unsigned char *)(v11 + 10))
      && (v13 != 0.0 ? (BOOL v14 = v13 == 1.0) : (BOOL v14 = 1), !v14)
      || (v15 = *(unsigned __int8 *)(v11 + v12 + 11), float v13 = 0.0, v15 == 2))
    {
      char v60 = 1;
      char v59 = 1;
      unint64_t v16 = (float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v11, 0xF3u, 0, &v60);
      float v17 = *v16
          + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v11, 0xF3u, 1u, &v59)
                          - *v16)
                  * v13);
    }
    else
    {
      float v17 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(*(void *)(*v10 + 24), 0xF3u, v15, 0);
    }
    float v19 = a2 - v17;
    uint64_t v20 = *(void *)(*v10 + 24);
    long long v21 = *(float **)v20;
    if (*(void *)v20
      && (float v22 = *v21, LODWORD(v21) = *v21 == 1.0, *(unsigned char *)(v20 + 10))
      && (v22 != 0.0 ? (BOOL v23 = v22 == 1.0) : (BOOL v23 = 1), !v23)
      || (unsigned int v24 = *(unsigned __int8 *)(v20 + v21 + 11), v22 = 0.0, v24 == 2))
    {
      char v60 = 1;
      char v59 = 1;
      unint64_t v25 = (float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v20, 0xF4u, 0, &v60);
      float v26 = *v25
          + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v20, 0xF4u, 1u, &v59)
                          - *v25)
                  * v22);
    }
    else
    {
      float v26 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(*(void *)(*v10 + 24), 0xF4u, v24, 0);
    }
    float v27 = v26 * v19;
    uint64_t v28 = *(void *)(*v10 + 24);
    uint64_t v29 = *(float **)v28;
    if (*(void *)v28
      && (float v30 = *v29, LODWORD(v29) = *v29 == 1.0, *(unsigned char *)(v28 + 10))
      && (v30 != 0.0 ? (BOOL v31 = v30 == 1.0) : (BOOL v31 = 1), !v31)
      || (v32 = *(unsigned __int8 *)(v28 + v29 + 11), float v30 = 0.0, v32 == 2))
    {
      char v60 = 1;
      char v59 = 1;
      size_t v33 = (float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v28, 0xF5u, 0, &v60);
      float v34 = *v33
          + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v28, 0xF5u, 1u, &v59)
                          - *v33)
                  * v30);
    }
    else
    {
      float v34 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(*(void *)(*v10 + 24), 0xF5u, v32, 0);
    }
    float v35 = fminf(fmaxf(v27, 0.0), v34) + 1.0;
    uint64_t v36 = *(void *)(*v10 + 24);
    if ((int)a2 >= 0x17) {
      unsigned int v37 = 23;
    }
    else {
      unsigned int v37 = (int)a2;
    }
    uint64_t v38 = *(float **)v36;
    if (*(void *)v36
      && (float v39 = *v38, LODWORD(v38) = *v38 == 1.0, *(unsigned char *)(v36 + 10))
      && (v39 != 0.0 ? (BOOL v40 = v39 == 1.0) : (BOOL v40 = 1), !v40)
      || (unsigned int v41 = *(unsigned __int8 *)(v36 + v38 + 11), v39 = 0.0, v41 == 2))
    {
      char v60 = 1;
      char v59 = 1;
      float v42 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v36, 0x5Eu, v37, 0, &v60);
      float v43 = v42
          + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v36, 0x5Eu, v37, 1u, &v59)- v42)* v39);
    }
    else
    {
      float v43 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(*v10 + 24), 0x5Eu, v37, v41, 0);
    }
    float v18 = v43 * v35;
    if (v53) {
LABEL_70:
    }
      (*(void (**)(uint64_t))(*(void *)v49 + 56))(v49);
  }
  else
  {
    float v18 = 0.0;
  }
LABEL_71:
  size_t v44 = v52;
  if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
    std::__shared_weak_count::__release_weak(v44);
    int v45 = v50;
    if (!v50) {
      goto LABEL_77;
    }
  }
  else
  {
    int v45 = v50;
    if (!v50) {
      goto LABEL_77;
    }
  }
  if (!atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
    std::__shared_weak_count::__release_weak(v45);
  }
LABEL_77:
  if (v58) {
    (*(void (**)(uint64_t))(*(void *)v54 + 56))(v54);
  }
  int v46 = v57;
  if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
    std::__shared_weak_count::__release_weak(v46);
    uint64_t v47 = v55;
    if (!v55) {
      return v18;
    }
  }
  else
  {
    uint64_t v47 = v55;
    if (!v55) {
      return v18;
    }
  }
  if (!atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
    std::__shared_weak_count::__release_weak(v47);
  }
  return v18;
}

void altitude::Route::cull(md::realistic::RouteRenderLayer **this, altitude::View *a2, karo::graphics::Viewport *a3, ResourceAccessor *a4)
{
  uint64_t v6 = (altitude::Route *)this;
  long long v7 = this[4];
  md::realistic::RouteRenderLayer::loadStylesheet(v7);
  uint64_t v8 = (md::realistic::RouteRenderLayer *)*((void *)v6 + 4);
  md::realistic::RouteRenderLayer::loadStylesheet(v8);
  uint64_t v9 = (void *)*((void *)v7 + 29);
  unint64_t v10 = (std::__shared_weak_count *)*((void *)v7 + 30);
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    __p[1] = v10;
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    __p[1] = 0;
  }
  float64x2_t v489 = 0uLL;
  __p[0] = v9;
  LOBYTE(v490.f64[0]) = 0;
  if (v9) {
    LOBYTE(v9) = (*(uint64_t (**)(void *, float64x2_t *))(*(void *)v9 + 48))(v9, &v489);
  }
  LOBYTE(v490.f64[0]) = (_BYTE)v9;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    unint64_t v11 = *((void *)v8 + 31);
    unint64_t v12 = (std::__shared_weak_count *)*((void *)v8 + 32);
    if (v12) {
      goto LABEL_9;
    }
  }
  else
  {
    unint64_t v11 = *((void *)v8 + 31);
    unint64_t v12 = (std::__shared_weak_count *)*((void *)v8 + 32);
    if (v12)
    {
LABEL_9:
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      v473.n128_u64[1] = (unint64_t)v12;
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      goto LABEL_12;
    }
  }
  v473.n128_u64[1] = 0;
LABEL_12:
  double v474 = 0.0;
  v475 = 0;
  v473.n128_u64[0] = v11;
  LOBYTE(v476) = 0;
  if (v11)
  {
    int v13 = (*(uint64_t (**)(unint64_t, double *))(*(void *)v11 + 48))(v11, &v474);
    LOBYTE(v476) = v13;
    if (!v12) {
      goto LABEL_19;
    }
  }
  else
  {
    int v13 = 0;
    LOBYTE(v476) = 0;
    if (!v12) {
      goto LABEL_19;
    }
  }
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  int v13 = LOBYTE(v476);
LABEL_19:
  int v14 = LOBYTE(v490.f64[0]);
  if (v13) {
    (*(void (**)(unint64_t))(*(void *)v473.n128_u64[0] + 56))(v473.n128_u64[0]);
  }
  unsigned int v15 = v475;
  if (v475 && !atomic_fetch_add(&v475->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (v473.n128_u64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v473.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(unint64_t))(*(void *)v473.n128_u64[1] + 16))(v473.n128_u64[1]);
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v473.n128_u64[1]);
  }
  if (LOBYTE(v490.f64[0])) {
    (*(void (**)(void *))(*(void *)__p[0] + 56))(__p[0]);
  }
  float64_t v16 = v489.f64[1];
  if (*(void *)&v489.f64[1]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v489.f64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(float64_t))(**(void **)&v16 + 16))(COERCE_FLOAT64_T(*(void *)&v16));
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v16);
    float v17 = (std::__shared_weak_count *)__p[1];
    if (!__p[1])
    {
LABEL_33:
      if (!v14) {
        return;
      }
      goto LABEL_34;
    }
  }
  else
  {
    float v17 = (std::__shared_weak_count *)__p[1];
    if (!__p[1]) {
      goto LABEL_33;
    }
  }
  if (atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_33;
  }
  ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
  std::__shared_weak_count::__release_weak(v17);
  if (!v14) {
    return;
  }
LABEL_34:
  if (!v13) {
    return;
  }
  uint64_t v18 = *((void *)v6 + 5);
  if (v18)
  {
    uint64_t v19 = *(void *)(v18 + 72);
    if (v19)
    {
      *((void *)v6 + 6) = v19;
      if ((*(unsigned int (**)(uint64_t))(*(void *)v19 + 24))(v19))
      {
        unsigned int v20 = (*(uint64_t (**)(void))(**((void **)v6 + 6) + 16))(*((void *)v6 + 6));
        (*(void (**)(void **__return_ptr))(**((void **)v6 + 6) + 32))(__p);
        uint64_t v21 = v20;
        float v22 = 0.0;
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v6 + 11) - *((void *)v6 + 10)) >> 3) - 1 > v20)
        {
          uint64_t v23 = *((void *)v6 + 5);
          if (objc_msgSend(*(id *)(v23 + 40), "pointCount", 0.0)) {
            unsigned int v24 = *(void **)(v23 + 40);
          }
          else {
            unsigned int v24 = 0;
          }
          if (v21 < [v24 pointCount])
          {
            uint64_t v25 = v21;
          }
          else
          {
            unsigned int v24 = 0;
            uint64_t v25 = 0;
          }
          [v24 pointAt:v25];
          double v28 = v27 * 0.0174532925;
          __double2 v29 = __sincos_stret(v26 * 0.0174532925);
          double v30 = 6378137.0 / sqrt(1.0 - v29.__sinval * v29.__sinval * 0.00669437999);
          __double2 v31 = __sincos_stret(v28);
          double v468 = v30 * v29.__cosval * v31.__cosval;
          double v463 = v30 * v29.__cosval * v31.__sinval;
          unsigned int v32 = [v24 pointCount];
          BOOL v33 = v25 + 1 >= (unint64_t)v32;
          if (v25 + 1 >= (unint64_t)v32) {
            float v34 = 0;
          }
          else {
            float v34 = v24;
          }
          if (v33) {
            uint64_t v35 = 0;
          }
          else {
            uint64_t v35 = (v25 + 1);
          }
          [v34 pointAt:v35];
          double v38 = v37 * 0.0174532925;
          __double2 v39 = __sincos_stret(v36 * 0.0174532925);
          double v40 = 6378137.0 / sqrt(1.0 - v39.__sinval * v39.__sinval * 0.00669437999);
          __double2 v41 = __sincos_stret(v38);
          double v452 = v39.__sinval * 0.99330562;
          float v42 = __p[1];
          __double2 v43 = __sincos_stret(*(double *)__p);
          double v44 = 6378137.0 / sqrt(1.0 - v43.__sinval * v43.__sinval * 0.00669437999);
          __double2 v45 = __sincos_stret(*(double *)&v42);
          double v46 = -(v468 - v40 * v39.__cosval * v41.__cosval);
          double v47 = -(v463 - v40 * v39.__cosval * v41.__sinval);
          uint64_t v48 = *((void *)v6 + 7);
          double v49 = *(double *)(v48 + 48 * v21 + 16);
          double v459 = v29.__sinval * 0.99330562 * v30;
          float v22 = (v46 * -(v468 - v44 * v43.__cosval * v45.__cosval)
               + v47 * -(v463 - v44 * v43.__cosval * v45.__sinval)
               + -(v459 - v452 * v40) * -(v459 - v43.__sinval * 0.99330562 * v44))
              * (*(double *)(v48 + 48 * (v21 + 1) + 16) - v49)
              / (v46 * v46 + v47 * v47 + -(v459 - v452 * v40) * -(v459 - v452 * v40))
              + v49;
        }
        *((float *)v6 + 1) = v22;
      }
    }
  }
  float v50 = altitude::Route::widthForZoom(v6, *((float *)a2 + 338));
  if (v50 == 0.0) {
    float v50 = *((float *)v6 + 6);
  }
  *((float *)v6 + 6) = v50;
  long long v51 = *(_OWORD *)((char *)v6 + 152);
  uint64_t v53 = *((void *)v6 + 21);
  unint64_t v52 = (double **)*((void *)v6 + 22);
  *((_OWORD *)v6 + 11) = v51;
  uint64_t v54 = *((void *)v6 + 24);
  *((void *)v6 + 24) = v53;
  *((void *)v6 + 20) = v52;
  *((void *)v6 + 21) = v54;
  *((void *)v6 + 19) = v52;
  uint64_t v55 = (void *)*((void *)v6 + 13);
  double v437 = (void *)*((void *)v6 + 14);
  double v435 = a4;
  if (v55 == v437)
  {
    uint64_t v268 = 0;
    uint64_t v266 = *((void *)&v51 + 1);
    uint64_t v267 = v51;
    uint64_t v265 = v52;
    goto LABEL_215;
  }
  double v56 = 2.0;
  float v57 = 1.0;
  long long v433 = a3;
  long long v434 = v6;
  do
  {
    v440 = v55;
    uint64_t v61 = *v55;
    *(_WORD *)(v61 + 73) = 1;
    float64_t v62 = *(float *)(v61 + 120);
    *(_OWORD *)__p = *(_OWORD *)(v61 + 96);
    v489.f64[0] = *(float64_t *)(v61 + 112);
    v489.f64[1] = v62;
    uint64_t v63 = (double *)(*(uint64_t (**)(void))(*((void *)a2 + 5) + 24))();
    if (karo::graphics::View::relates((uint64_t)a2, (uint64_t)__p))
    {
      *(unsigned char *)(v61 + 73) = 0;
      double v64 = v63[1];
      double v65 = v63[2];
      double v66 = (*v63 - *(double *)(v61 + 96)) * (*v63 - *(double *)(v61 + 96))
          + (v64 - *(double *)(v61 + 104)) * (v64 - *(double *)(v61 + 104))
          + (v65 - *(double *)(v61 + 112)) * (v65 - *(double *)(v61 + 112));
      float v67 = *(float *)(v61 + 120);
      if (v66 < (float)(v67 * v67) * 4.0)
      {
        uint64_t v68 = *(void *)(v61 + 80);
        if (v68)
        {
          unint64_t v69 = 0;
          uint64_t v70 = *(void *)(v61 + 40);
          unint64_t v71 = v68 - 1;
          do
          {
            unint64_t v72 = (double *)(**(void **)(v61 + 24) + 24 * ((v69 / v71) + v70));
            double v66 = fmin((*v63 - *v72) * (*v63 - *v72) + (v64 - v72[1]) * (v64 - v72[1]) + (v65 - v72[2]) * (v65 - v72[2]), v66);
            v69 += *(void *)(v61 + 48) + ~v70;
            --v68;
          }
          while (v68);
        }
      }
      double v436 = (void *)(v61 + 96);
      int v73 = *((_DWORD *)a3 + 12);
      int v74 = *((_DWORD *)a3 + 13);
      int v76 = *((_DWORD *)a3 + 10);
      int v75 = *((_DWORD *)a3 + 11);
      float v77 = *((float *)a2 + 346);
      double v78 = v67;
      double v79 = *(double *)(v61 + 64) * v67;
      unint64_t v80 = *(void *)(v61 + 48) - *(void *)(v61 + 40);
      do
      {
        LODWORD(v81) = v80;
        if (v80 < 3) {
          break;
        }
        double v82 = v79 / (v77 * (v78 + v78) * (double)v80);
        v80 >>= 1;
      }
      while (v82 < v56);
      uint64_t v81 = (int)v81 <= 2 ? 2 : v81;
      uint64_t v438 = *(void *)(v61 + 80);
      unint64_t v439 = v81;
      *(void *)(v61 + 80) = v81;
      unsigned int v83 = *((_DWORD *)a2 + 339);
      int v84 = v83 <= 0xD ? v83 > 0xB : 2;
      int v85 = *(_DWORD *)(v61 + 76);
      *(_DWORD *)(v61 + 76) = v84;
      if (*(unsigned char *)(v61 + 72) || v438 != v439 || v84 != v85)
      {
        LOBYTE(v86) = 0;
        *(unsigned char *)(v61 + 72) = 0;
        unint64_t v87 = v439;
        if (sqrt(v66) < 1000000.0)
        {
          unint64_t v88 = 0;
          int v86 = 0;
          float v89 = (float)((float)(v77 * 0.5) * (float)v73) / *((float *)a2 + 336);
          float v456 = v89 * v89;
          int v446 = v73 - v76;
          int v444 = v74 - v75;
          double v441 = (double)(v74 - v75);
          double v442 = (double)(v73 - v76);
          unint64_t v87 = v439;
          uint64_t v453 = v61;
          while (1)
          {
            uint64_t v97 = *(void *)(v61 + 40);
            uint64_t v98 = *(void *)(v61 + 48) + ~v97;
            unint64_t v99 = v87 - 1;
            if (v88) {
              uint64_t v100 = v98 * (v88 - 1) / v99 + v97;
            }
            else {
              LODWORD(v100) = 0;
            }
            int v464 = v86;
            unint64_t v101 = (v98 * v88 / v99) + v97;
            unint64_t v102 = v101;
            if (v88 != v99) {
              unint64_t v102 = ((v98 + v98 * v88) / v99) + v97;
            }
            uint64_t v103 = *(void *)(*(void *)(v61 + 16) + 40);
            if ([*(id *)(v103 + 40) pointCount]) {
              unint64_t v104 = *(void **)(v103 + 40);
            }
            else {
              unint64_t v104 = 0;
            }
            if (v101 < [v104 pointCount])
            {
              unint64_t v105 = v101;
            }
            else
            {
              unint64_t v104 = 0;
              unint64_t v105 = 0;
            }
            uint64_t v106 = *(void *)(*(void *)(v61 + 16) + 40);
            if ([*(id *)(v106 + 40) pointCount]) {
              uint64_t v107 = *(void **)(v106 + 40);
            }
            else {
              uint64_t v107 = 0;
            }
            unsigned int v108 = [v107 pointCount];
            if (v102 >= v108) {
              uint64_t v107 = 0;
            }
            unint64_t v469 = v102;
            if (v102 >= v108) {
              unint64_t v102 = 0;
            }
            [v104 pointAt:v105];
            double v110 = v109 * 0.0174532925;
            double v112 = v111 * 0.0174532925;
            [v107 pointAt:v102];
            float v115 = -(v110 - v113 * 0.0174532925);
            float v116 = -(v112 - v114 * 0.0174532925);
            float v117 = *((double *)a2 + 166) - v110;
            float v118 = *((double *)a2 + 167) - v112;
            float v119 = (float)(v115 * v115) + (float)(v116 * v116);
            float v120 = 0.0;
            if (v119 >= 1.0e-10)
            {
              float v121 = (float)((float)(v115 * v117) + (float)(v118 * v116)) / v119;
              if (v121 >= 0.0)
              {
                float v120 = v121;
                if (v121 > v57) {
                  float v120 = 1.0;
                }
              }
            }
            if ((float)((float)((float)-(float)(v117 - (float)(v120 * v115))
                               * (float)-(float)(v117 - (float)(v120 * v115)))
                       + (float)((float)-(float)(v118 - (float)(v120 * v116))
                               * (float)-(float)(v118 - (float)(v120 * v116)))) >= v456)
            {
              uint64_t v122 = *(uint64_t **)(v61 + 32);
              uint64_t v123 = (double *)(**(void **)(v61 + 24) + 24 * v101);
              double v124 = v123[1];
              double v125 = v123[2];
              double v126 = *((double *)a2 + 28)
                   + *((double *)a2 + 16) * *v123
                   + *((double *)a2 + 20) * v124
                   + *((double *)a2 + 24) * v125;
              double v127 = 0.5
                   / (*((double *)a2 + 30)
                    + *((double *)a2 + 18) * *v123
                    + *((double *)a2 + 22) * v124
                    + *((double *)a2 + 26) * v125);
              int v128 = (int)((v127
                          * (*((double *)a2 + 27)
                           + *v123 * *((double *)a2 + 15)
                           + v124 * *((double *)a2 + 19)
                           + v125 * *((double *)a2 + 23))
                          + 0.5)
                         * v442);
              int v129 = (int)((0.5 - v127 * v126) * v441);
              BOOL v132 = v128 <= 0 || v446 <= v128 || v129 <= 0 || v444 <= v129;
              char v133 = !v132;
              uint64_t v134 = *v122;
              *(unsigned char *)(*v122 + 48 * v101 + 32) = v133;
              if (v132
                && !*(unsigned char *)(v134 + 48 * v100 + 32)
                && !*(unsigned char *)(v134 + 48 * v469 + 32))
              {
                *(unsigned char *)(v61 + 72) = 1;
                int v86 = v464;
                goto LABEL_88;
              }
            }
            else
            {
              *(unsigned char *)(**(void **)(v61 + 32) + 48 * v101 + 32) = 1;
            }
            unsigned int v460 = v100;
            uint64_t v135 = *(void *)(v61 + 16);
            uint64_t v136 = *(int *)(v61 + 76);
            uint64_t v137 = *(void *)(v135 + 80);
            uint64_t v138 = *(void *)(v135 + 56);
            uint64_t v139 = *(void *)(v135 + 40);
            if ([*(id *)(v139 + 40) pointCount]) {
              uint64_t v140 = *(void **)(v139 + 40);
            }
            else {
              uint64_t v140 = 0;
            }
            uint64_t v141 = (int *)(v138 + 48 * v101);
            if (v101 < [v140 pointCount])
            {
              unint64_t v142 = v101;
            }
            else
            {
              uint64_t v140 = 0;
              unint64_t v142 = 0;
            }
            [v140 pointAt:v142];
            double v144 = v143;
            [v140 pointAt:v142];
            double v498 = 0.0;
            if (*v141 < (int)v136)
            {
              char v146 = 0;
              char v147 = 0;
              double v148 = v144 * 0.0174532925;
              double v149 = v145 * 0.0174532925;
              v448 = (double *)(v138 + 48 * v101 + 24);
              v450 = (double *)(v137 + 24 * v101);
              uint64_t v150 = v136;
              uint64_t v61 = v453;
              while (1)
              {
                uint64_t v151 = *(void *)(*(void *)(*(void *)(*(void *)(v135 + 32) + 40) + 128) + 712);
                v473.n128_f64[0] = v148;
                v473.n128_f64[1] = v149;
                int v152 = altitude::IntersectorHeight::heightAtLatLon(v151, v473.n128_f64, &v498, heightLevels[v150]);
                if (v152 == 1)
                {
                  char v147 = 1;
                }
                else
                {
                  if (!v152)
                  {
                    double v90 = *(double *)(v135 + 8) + v498;
                    double *v448 = v90;
                    __double2 v91 = __sincos_stret(v148);
                    double v92 = 6378137.0 / sqrt(v91.__sinval * v91.__sinval * -0.00669437999 + 1.0);
                    double v93 = (v90 + v92) * v91.__cosval;
                    __double2 v94 = __sincos_stret(v149);
                    double v95 = v90 + v92 * 0.99330562;
                    float v57 = 1.0;
                    double *v450 = v93 * v94.__cosval;
                    v450[1] = v93 * v94.__sinval;
                    v450[2] = v95 * v91.__sinval;
                    *uint64_t v141 = v150;
                    if ((v136 == v150) | v147 & 1) {
                      char v96 = v146;
                    }
                    else {
                      char v96 = 1;
                    }
                    *(unsigned char *)(v453 + 72) |= v96;
                    int v86 = 1;
                    goto LABEL_88;
                  }
                  char v146 = 1;
                }
                if (--v150 <= *v141) {
                  goto LABEL_143;
                }
              }
            }
            char v146 = 0;
            uint64_t v61 = v453;
LABEL_143:
            *(unsigned char *)(v61 + 72) |= v146;
            int v86 = v464 & 1;
            if (v88) {
              break;
            }
LABEL_88:
            ++v88;
            unint64_t v87 = *(void *)(v61 + 80);
            if (v88 >= v87) {
              goto LABEL_162;
            }
          }
          uint64_t v153 = *(void *)(v61 + 16);
          uint64_t v154 = *(void *)(v153 + 80) + 24 * v101;
          long double v155 = *(double *)v154;
          long double v156 = *(double *)(v154 + 8);
          double v157 = *(double *)(v154 + 16);
          uint64_t v158 = *(void *)(v153 + 56);
          uint64_t v159 = (double *)(v158 + 48 * v460);
          int v160 = *(_DWORD *)v159;
          double v161 = v159[3];
          int v162 = *(_DWORD *)(v158 + 48 * v101);
          if (v101 == v469)
          {
            if (v160 <= v162) {
              goto LABEL_88;
            }
          }
          else
          {
            uint64_t v163 = v158 + 48 * v469;
            double v164 = *(double *)(v163 + 24);
            if (*(_DWORD *)v163 > v162 && v160 > v162)
            {
              double v171 = sqrt(v155 * v155 + v156 * v156);
              double v172 = atan2(*(long double *)(v154 + 16), v171 * 0.996647189);
              double v173 = atan2(v156, v155);
              __double2 v174 = __sincos_stret(v172);
              long double v175 = v171 + v174.__cosval * v174.__cosval * -42697.6727 * v174.__cosval;
              double v56 = 2.0;
              double v176 = atan2(v157 + v174.__sinval * v174.__sinval * 42841.3115 * v174.__sinval, v175);
              __double2 v178 = __sincos_stret(v176);
              double cosval = v178.__cosval;
              double sinval = v178.__sinval;
              double v180 = 6378137.0 / sqrt(sinval * sinval * -0.00669437999 + 1.0);
              double v161 = (v164 + v161) * 0.5;
LABEL_156:
              double v181 = (v180 + v161) * cosval;
              goto LABEL_157;
            }
            if (v160 <= v162)
            {
              if (*(_DWORD *)v163 <= v162) {
                goto LABEL_88;
              }
              double v183 = sqrt(v155 * v155 + v156 * v156);
              double v184 = atan2(*(long double *)(v154 + 16), v183 * 0.996647189);
              double v173 = atan2(v156, v155);
              __double2 v185 = __sincos_stret(v184);
              double v186 = atan2(v157 + v185.__sinval * v185.__sinval * 42841.3115 * v185.__sinval, v183 + v185.__cosval * v185.__cosval * -42697.6727 * v185.__cosval);
              __double2 v187 = __sincos_stret(v186);
              double sinval = v187.__sinval;
              double v180 = 6378137.0 / sqrt(v187.__sinval * v187.__sinval * -0.00669437999 + 1.0);
              double v181 = (v180 + v164) * v187.__cosval;
              double v161 = v164;
LABEL_157:
              __double2 v182 = __sincos_stret(v173);
              *(double *)uint64_t v154 = v181 * v182.__cosval;
              *(double *)(v154 + 8) = v181 * v182.__sinval;
              *(double *)(v154 + 16) = (v161 + v180 * 0.99330562) * sinval;
              float v57 = 1.0;
              goto LABEL_88;
            }
          }
          double v166 = sqrt(v155 * v155 + v156 * v156);
          double v167 = atan2(*(long double *)(v154 + 16), v166 * 0.996647189);
          double v173 = atan2(v156, v155);
          __double2 v168 = __sincos_stret(v167);
          double v169 = atan2(v157 + v168.__sinval * v168.__sinval * 42841.3115 * v168.__sinval, v166 + v168.__cosval * v168.__cosval * -42697.6727 * v168.__cosval);
          __double2 v170 = __sincos_stret(v169);
          double cosval = v170.__cosval;
          double sinval = v170.__sinval;
          double v180 = 6378137.0 / sqrt(sinval * sinval * -0.00669437999 + 1.0);
          goto LABEL_156;
        }
LABEL_162:
        uint64_t v6 = v434;
        a4 = v435;
        a3 = v433;
        if ((v86 & 1) != 0 || v438 != v439)
        {
          *(unsigned char *)(v61 + 74) = 1;
          v436[1] = 0;
          v436[2] = 0;
          *double v436 = 0;
          uint64_t v191 = *(void *)(v61 + 40);
          uint64_t v192 = *(void *)(v61 + 48);
          double v193 = 0.0;
          double v194 = 0.0;
          double v195 = 0.0;
          unint64_t v196 = v192 - v191;
          if (v192 != v191)
          {
            float v197 = (double *)(**(void **)(v61 + 24) + 24 * v191 + 16);
            uint64_t v198 = v192 - v191;
            do
            {
              double v195 = *(v197 - 2) + v195;
              *(double *)(v61 + 96) = v195;
              double v194 = *(v197 - 1) + v194;
              *(double *)(v61 + 104) = v194;
              double v199 = *v197;
              v197 += 3;
              double v193 = v199 + v193;
              *(double *)(v61 + 112) = v193;
              --v198;
            }
            while (v198);
          }
          double v200 = 1.0 / (double)v196;
          double v201 = v195 * v200;
          double v202 = v194 * v200;
          double v203 = v193 * v200;
          *(double *)(v61 + 96) = v201;
          *(double *)(v61 + 104) = v202;
          *(double *)(v61 + 112) = v203;
          float v204 = 0.0;
          if (v192 == v191) {
            goto LABEL_199;
          }
          uint64_t v205 = **(void **)(v61 + 24);
          if (v196 > 7)
          {
            unint64_t v206 = v196 & 0xFFFFFFFFFFFFFFF8;
            float64x2_t v221 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v201, 0);
            float64x2_t v222 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v202, 0);
            float64x2_t v223 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v203, 0);
            long long v224 = (const double *)(v205 + 24 * v191);
            float32x4_t v225 = 0uLL;
            unint64_t v226 = v196 & 0xFFFFFFFFFFFFFFF8;
            float32x4_t v227 = 0uLL;
            do
            {
              unint64_t v228 = v224;
              float64x2x3_t v501 = vld3q_f64(v228);
              v228 += 6;
              uint64_t v229 = v224 + 12;
              float64x2x3_t v502 = vld3q_f64(v229);
              unint64_t v230 = v224 + 18;
              float64x2x3_t v503 = vld3q_f64(v230);
              float64x2x3_t v504 = vld3q_f64(v228);
              float64x2_t v231 = vsubq_f64(v501.val[0], v221);
              float64x2_t v232 = vsubq_f64(v504.val[0], v221);
              float64x2_t v233 = vsubq_f64(v502.val[0], v221);
              float64x2_t v234 = vsubq_f64(v503.val[0], v221);
              float64x2_t v235 = vsubq_f64(v501.val[1], v222);
              float64x2_t v236 = vsubq_f64(v503.val[1], v222);
              float64x2_t v237 = vsubq_f64(v502.val[1], v222);
              float64x2_t v238 = vsubq_f64(v504.val[1], v222);
              v501.val[0] = vsubq_f64(v501.val[2], v223);
              v501.val[1] = vsubq_f64(v504.val[2], v223);
              v501.val[2] = vsubq_f64(v502.val[2], v223);
              v502.val[0] = vsubq_f64(v503.val[2], v223);
              float32x4_t v225 = vmaxnmq_f32(v225, vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(v231, v231), v235, v235), v501.val[0], v501.val[0])), vmlaq_f64(vmlaq_f64(vmulq_f64(v232, v232), v238, v238), v501.val[1], v501.val[1])));
              float32x4_t v227 = vmaxnmq_f32(v227, vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(v233, v233), v237, v237), v501.val[2], v501.val[2])), vmlaq_f64(vmlaq_f64(vmulq_f64(v234, v234), v236, v236), v502.val[0], v502.val[0])));
              v224 += 24;
              v226 -= 8;
            }
            while (v226);
            float v204 = vmaxnmvq_f32(vmaxnmq_f32(v225, v227));
            float v57 = 1.0;
            if (v196 == v206) {
              goto LABEL_199;
            }
          }
          else
          {
            unint64_t v206 = 0;
          }
          uint64_t v239 = v206 + v191;
          uint64_t v240 = v239 - v192;
          uint64_t v241 = (double *)(v205 + 24 * v239 + 16);
          do
          {
            double v242 = *(v241 - 2) - v201;
            double v243 = *(v241 - 1) - v202;
            double v244 = *v241;
            v241 += 3;
            *(float *)&double v242 = v242 * v242 + v243 * v243 + (v244 - v203) * (v244 - v203);
            float v204 = fmaxf(v204, *(float *)&v242);
            BOOL v33 = __CFADD__(v240++, 1);
          }
          while (!v33);
LABEL_199:
          *(float *)(v61 + 120) = sqrtf(v204);
          if (v87 < 2)
          {
            LODWORD(v58) = v191;
            unsigned int v59 = v191;
          }
          else
          {
            uint64_t v245 = v192 + ~v191;
            unint64_t v246 = v87 - 1;
            uint64_t v247 = **(void **)(v61 + 24);
            unint64_t v248 = 1;
            unsigned int v59 = v191;
            unsigned int v249 = v191;
            do
            {
              uint64_t v58 = v248 * v245 / v246 + v191;
              if (v59 < v58)
              {
                uint64_t v250 = v247 + 24 * v249;
                double v251 = *(double *)v250;
                uint64_t v252 = v247 + 24 * v58;
                double v253 = *(double *)v252 - *(double *)v250;
                float64x2_t v254 = *(float64x2_t *)(v250 + 8);
                float64x2_t v255 = vsubq_f64(*(float64x2_t *)(v252 + 8), v254);
                float64x2_t v256 = vmulq_f64(v255, v255);
                *(float *)v256.f64 = v256.f64[0] + v253 * v253 + v256.f64[1];
                uint64_t v257 = v59;
                double v258 = 1.0 / *(float *)v256.f64;
                uint64_t v259 = (float *)(**(void **)(v61 + 32) + 48 * v59 + 44);
                double v260 = (_OWORD *)(v247 + 8 + 24 * v59);
                float v261 = 0.0;
                do
                {
                  double v262 = *((double *)v260 - 1) - v251;
                  float64x2_t v263 = *(float64x2_t *)v260;
                  double v260 = (_OWORD *)((char *)v260 + 24);
                  float64x2_t v264 = vmulq_f64(vsubq_f64(v263, v254), v255);
                  *(float *)&double v262 = (v264.f64[0] + v262 * v253 + v264.f64[1]) * v258;
                  float v261 = fmaxf(fminf(fmaxf(v261, *(float *)&v262), v57), 0.0);
                  *((_DWORD *)v259 - 2) = v249;
                  *((_DWORD *)v259 - 1) = v58;
                  float *v259 = v261;
                  v259 += 12;
                  ++v257;
                }
                while (v191 + (v245 * (unint64_t)v248 / v246) != v257);
                unsigned int v59 = v257;
              }
              unint64_t v248 = (v248 + 1);
              unsigned int v249 = v58;
            }
            while (v87 > v248);
          }
          uint64_t v60 = **(void **)(v61 + 32) + 48 * v59;
          *(int32x2_t *)(v60 + 36) = vdup_n_s32(v58);
          *(_DWORD *)(v60 + 44) = 0;
        }
      }
    }
    if (!*(unsigned char *)(v61 + 73))
    {
      float v189 = (char *)*((void *)v6 + 20);
      unint64_t v188 = *((void *)v6 + 21);
      if ((unint64_t)v189 >= v188)
      {
        double v207 = (char *)*((void *)v6 + 19);
        uint64_t v208 = (v189 - v207) >> 3;
        unint64_t v209 = v208 + 1;
        if ((unint64_t)(v208 + 1) >> 61) {
LABEL_383:
        }
          abort();
        uint64_t v210 = v188 - (void)v207;
        if (v210 >> 2 > v209) {
          unint64_t v209 = v210 >> 2;
        }
        if ((unint64_t)v210 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v211 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v211 = v209;
        }
        if (v211)
        {
          if (v211 >> 61) {
LABEL_384:
          }
            std::__throw_bad_array_new_length[abi:nn180100]();
          float64x2_t v212 = operator new(8 * v211);
        }
        else
        {
          float64x2_t v212 = 0;
        }
        float64x2_t v213 = &v212[8 * v208];
        *float64x2_t v213 = v61;
        float v190 = v213 + 1;
        if (v189 == v207)
        {
          double v207 = v189;
        }
        else
        {
          unint64_t v214 = v189 - 8 - v207;
          if (v214 < 0x58) {
            goto LABEL_387;
          }
          if ((unint64_t)(v207 - v212) < 0x20) {
            goto LABEL_387;
          }
          uint64_t v215 = (v214 >> 3) + 1;
          float64x2_t v216 = &v212[8 * v208 - 16];
          float64x2_t v217 = v189 - 16;
          uint64_t v218 = v215 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v219 = *(_OWORD *)v217;
            *(v216 - 1) = *((_OWORD *)v217 - 1);
            *float64x2_t v216 = v219;
            v216 -= 2;
            v217 -= 32;
            v218 -= 4;
          }
          while (v218);
          v213 -= v215 & 0x3FFFFFFFFFFFFFFCLL;
          v189 -= 8 * (v215 & 0x3FFFFFFFFFFFFFFCLL);
          if (v215 != (v215 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_387:
            do
            {
              uint64_t v220 = *((void *)v189 - 1);
              v189 -= 8;
              *--float64x2_t v213 = v220;
            }
            while (v189 != v207);
            double v207 = (char *)*((void *)v6 + 19);
          }
        }
        *((void *)v6 + 19) = v213;
        *((void *)v6 + 20) = v190;
        *((void *)v6 + 21) = &v212[8 * v211];
        if (v207) {
          operator delete(v207);
        }
      }
      else
      {
        *(void *)float v189 = v61;
        float v190 = v189 + 8;
      }
      *((void *)v6 + 20) = v190;
    }
    uint64_t v55 = v440 + 1;
  }
  while (v440 + 1 != v437);
  uint64_t v265 = (double **)*((void *)v6 + 19);
  unint64_t v52 = (double **)*((void *)v6 + 20);
  uint64_t v267 = *((void *)v6 + 22);
  uint64_t v266 = *((void *)v6 + 23);
  if (v265 == v52)
  {
    uint64_t v268 = 0;
    unint64_t v52 = (double **)*((void *)v6 + 19);
LABEL_215:
    if (v268 != (v266 - v267) >> 3) {
      goto LABEL_216;
    }
    goto LABEL_220;
  }
  uint64_t v268 = 0;
  unint64_t v269 = (void *)*((void *)v6 + 19);
  while ((v266 - v267) >> 3 != v268 && *v269 == *(void *)(v267 + 8 * v268) && !*(unsigned char *)(*v269 + 74))
  {
    ++v268;
    if (++v269 == v52)
    {
      uint64_t v268 = v268;
      goto LABEL_215;
    }
  }
LABEL_216:
  *((void *)v6 + 16) = 0;
  *((void *)v6 + 17) = 0;
  *((void *)v6 + 18) = 0;
  if (v265 != v52)
  {
    unint64_t v270 = 0;
    double v271 = 0.0;
    double v272 = 0.0;
    double v273 = 0.0;
    do
    {
      unint64_t v274 = *v265++;
      double v273 = v273 + v274[12];
      *((double *)v6 + 16) = v273;
      double v272 = v272 + v274[13];
      *((double *)v6 + 17) = v272;
      double v271 = v271 + v274[14];
      *((double *)v6 + 18) = v271;
      ++v270;
    }
    while (v265 != v52);
    double v275 = 1.0 / (double)v270;
    *((double *)v6 + 16) = v273 * v275;
    *((double *)v6 + 17) = v272 * v275;
    *((double *)v6 + 18) = v271 * v275;
  }
LABEL_220:
  uint64_t v276 = (float **)*((void *)v6 + 26);
  uint64_t v277 = *v276;
  uint64_t v278 = *((void *)*v276 + 19);
  uint64_t v279 = *((void *)*v276 + 20);
  if (v278 == v279)
  {
    if ((uint64_t)(*((void *)v277 + 23) - *((void *)v277 + 22)) >> 3) {
      goto LABEL_230;
    }
  }
  else
  {
    uint64_t v280 = 0;
    uint64_t v281 = *((void *)v277 + 22);
    uint64_t v282 = (*((void *)v277 + 23) - v281) >> 3;
    do
    {
      if (v282 == v280 || *(void *)v278 != *(void *)(v281 + 8 * v280) || *(unsigned char *)(*(void *)v278 + 74)) {
        goto LABEL_230;
      }
      ++v280;
      v278 += 8;
    }
    while (v278 != v279);
    if (v282 != v280) {
LABEL_230:
    }
      altitude::RouteDrawRegion::update(*((altitude::RouteDrawRegion **)v6 + 26), a4);
  }
  if (!v276[8]) {
    goto LABEL_230;
  }
  long double v283 = (md::realistic::RouteRenderLayer *)v276[1];
  md::realistic::RouteRenderLayer::loadStylesheet(v283);
  uint64_t v284 = (md::realistic::RouteRenderLayer *)v276[1];
  md::realistic::RouteRenderLayer::loadStylesheet(v284);
  uint64_t v285 = (void *)*((void *)v283 + 29);
  uint64_t v286 = (std::__shared_weak_count *)*((void *)v283 + 30);
  __p[0] = v285;
  __p[1] = v286;
  if (v286) {
    atomic_fetch_add_explicit(&v286->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)&v498, (uint64_t)v285, (uint64_t)v286);
  if (v286 && !atomic_fetch_add(&v286->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v286->__on_zero_shared)(v286);
    std::__shared_weak_count::__release_weak(v286);
  }
  unint64_t v287 = (void *)*((void *)v284 + 31);
  double v288 = (std::__shared_weak_count *)*((void *)v284 + 32);
  __p[0] = v287;
  __p[1] = v288;
  if (v288) {
    atomic_fetch_add_explicit(&v288->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker(&v496, (uint64_t)v287, (uint64_t)v288);
  if (v288 && !atomic_fetch_add(&v288->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v288->__on_zero_shared)(v288);
    std::__shared_weak_count::__release_weak(v288);
  }
  if (v499 && v497)
  {
    if (*(unsigned char *)(*((void *)*v276 + 5) + 64)) {
      uint64_t v289 = &v498;
    }
    else {
      uint64_t v289 = (double *)&v496;
    }
    float v290 = *((float *)a2 + 338);
    unint64_t v291 = v276[9];
    unint64_t v292 = *(void *)(*((void *)v291 + 8) + 16);
    double v293 = *((double *)a2 + 10);
    double v294 = *((double *)a2 + 11);
    double v295 = *((double *)a2 + 12);
    double v297 = *((double *)a2 + 8);
    double v296 = *((double *)a2 + 9);
    double v299 = *((double *)a2 + 6);
    double v298 = *((double *)a2 + 7);
    double v300 = -(v297 * v293 - v298 * v294) - (v297 * v293 - v298 * v294);
    double v301 = -(v299 * v294 - v297 * v296) - (v299 * v294 - v297 * v296);
    double v302 = -(v298 * v296 - v299 * v293) - (v298 * v296 - v299 * v293);
    double v303 = -(v302 * v296 - (-(v298 - v300 * v294) - v301 * v295));
    double v304 = -(v299 + v300 * v295 + v301 * v294 - v302 * v293);
    double v305 = -(v297 + v300 * v293 + v302 * v295 - v301 * v296);
    double v306 = v293 * -2.0;
    double v307 = -(v293 * (v293 * -2.0));
    double v308 = 1.0 - (v307 - v294 * (v294 * -2.0));
    double v309 = v296 * -2.0;
    double v310 = -(v293 * (v296 * -2.0));
    double v311 = v294 * -2.0 * v295;
    double v312 = v310 - v311;
    double v313 = -(v294 * (v296 * -2.0));
    double v314 = v295 * v306;
    double v315 = v295 * v306 - v294 * (v296 * -2.0);
    double v316 = v311 + v310;
    double v317 = v296 * -2.0 * v296 + 1.0;
    double v318 = v317 - -(v294 * (v294 * -2.0));
    double v319 = -(v294 * v306);
    double v320 = v295 * v309;
    v473.n128_f64[0] = v308;
    v473.n128_f64[1] = v316;
    double v476 = v312;
    double v477 = v318;
    double v480 = v315;
    double v481 = v319 - v320;
    double v474 = v313 - v314;
    double v478 = v320 + v319;
    double v482 = v317 - v307;
    v475 = 0;
    uint64_t v479 = 0;
    uint64_t v483 = 0;
    double v484 = v304;
    double v485 = v303;
    double v486 = v305;
    uint64_t v487 = 0x3FF0000000000000;
    gm::operator*<double,4,4,4>((double *)__p, v473.n128_f64, (double *)v276[8] + 15);
    __n128 v473 = 0uLL;
    __double2 v321 = *(std::__shared_weak_count **)(v292 + 8);
    v322.n128_u64[0] = 0;
    v322.n128_u64[1] = v292;
    if (v321) {
      double v323 = *(double *)(v292 + 72);
    }
    else {
      double v323 = 0.0;
    }
    __n128 v470 = v322;
    __n128 v473 = v322;
    double v474 = 0.0;
    v475 = v321;
    double v477 = v323;
    LOWORD(v476) = 1;
    float32x4_t v465 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)__p), v489);
    **(_OWORD **)&double v323 = v465;
    float32x4_t v461 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v490), v491);
    *(float32x4_t *)(*(void *)&v323 + 16) = v461;
    float32x4_t v457 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v492), v493);
    *(float32x4_t *)(*(void *)&v323 + 32) = v457;
    float32x4_t v454 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v494), v495);
    *(float32x4_t *)(*(void *)&v323 + 48) = v454;
    *(float *)(*(void *)&v323 + 64) = *((float *)a2 + 345) * (*v276)[6];
    if ((int)v290 >= 0x17) {
      unsigned int v324 = 23;
    }
    else {
      unsigned int v324 = (int)v290;
    }
    gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v500, *(void *)(*(void *)v289 + 24), 0x5Cu, v324, 2u, 0);
    uint16x4_t v325 = v500;
    gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v500, *(void *)(*(void *)v289 + 24), 0xF0u, v324, 2u, 0);
    float32x4_t v326 = (float32x4_t)vdupq_n_s32(0x37800080u);
    float32x4_t v327 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v325)), v326);
    float32x4_t v328 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v500)), v326);
    double v329 = *(void **)(*((void *)v291 + 8) + 32);
    unint64_t v330 = v329[1];
    if (v330) {
      uint64_t v331 = v329[9];
    }
    else {
      uint64_t v331 = 0;
    }
    *(float32x4_t *)uint64_t v331 = v327;
    *(float32x4_t *)(v331 + 16) = v328;
    long double v332 = *v276;
    *(float *)(v331 + 32) = (*v276)[1];
    if (*((unsigned char *)v276 + 104))
    {
      uint64_t v333 = **((void **)v276[8] + 1);
      *(void *)(v333 + 64) = (2 * *(int *)v332) | 1;
      *(unsigned char *)(v333 + 264) = 0;
      __n128 v334 = v470;
      if (v330) {
        goto LABEL_257;
      }
    }
    else
    {
      *(void *)(v331 + 36) = 0x3F66666600000001;
      uint64_t v403 = *((void *)v276[10] + 8);
      double v404 = *(void **)(v403 + 16);
      unint64_t v405 = v404[1];
      double v406 = (float32x4_t *)v404[9];
      *double v406 = v465;
      v406[1] = v461;
      v406[2] = v457;
      v406[3] = v454;
      v406[4].f32[0] = *((float *)a2 + 345) * v332[6];
      int v407 = *(void **)(v403 + 32);
      unint64_t v408 = v407[1];
      v409 = (float32x4_t *)v407[9];
      float32x4_t *v409 = v327;
      v409[1] = v328;
      v409[2].f32[0] = v332[1];
      v409[2].i32[1] = 0;
      v409[2].i32[2] = 1063675494;
      if (v407[8] > v408) {
        unint64_t v408 = v407[8];
      }
      v407[7] = 0;
      v407[8] = v408;
      unint64_t v410 = v404[8];
      if (v410 <= v405) {
        unint64_t v410 = v405;
      }
      v404[7] = 0;
      v404[8] = v410;
      uint64_t v411 = **((void **)v276[8] + 1);
      uint64_t v412 = *(int *)v332;
      *(void *)(v411 + 64) = v412;
      unint64_t v413 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v276[1] + 38) - *((void *)v276[1] + 37)) >> 3);
      int v414 = *((unsigned __int8 *)a2 + 1288) + 2 * (v413 - v412);
      *(_DWORD *)(v411 + 56) = v414 + 1;
      *(void *)(v411 + 192) = v413 + v412;
      *(_DWORD *)(v411 + 184) = v414;
      __n128 v334 = v470;
      if (v330)
      {
LABEL_257:
        if (v329[8] > v330) {
          unint64_t v330 = v329[8];
        }
        v329[7] = 0;
        v329[8] = v330;
      }
    }
    if (v321)
    {
      unint64_t v335 = v334.n128_u64[1];
      if (v334.n128_u64[0] && *(unsigned char *)(v334.n128_u64[1] + 17) != 2) {
        (*(void (**)(__n128))(*(void *)v334.n128_u64[0] + 64))(v334);
      }
      __double2 v336 = *(std::__shared_weak_count **)(v335 + 64);
      if (v336 <= v321) {
        __double2 v336 = v321;
      }
      *(void *)(v335 + 56) = 0;
      *(void *)(v335 + 64) = v336;
    }
  }
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v496);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v498);
  altitude::ManeuverDrawRegion::cull(*((altitude::ManeuverDrawRegion **)v6 + 25), a2, (karo::graphics::Viewport *)a4, v337);
  if (*((unsigned char *)v6 + 28))
  {
    __double2 v338 = (double **)*((void *)v6 + 27);
    uint64_t v339 = *v338;
    uint64_t v340 = *((void *)*v338 + 19);
    uint64_t v341 = *((void *)*v338 + 20);
    if (v340 == v341)
    {
      if ((uint64_t)(*((void *)v339 + 23) - *((void *)v339 + 22)) >> 3) {
        goto LABEL_278;
      }
    }
    else
    {
      uint64_t v342 = 0;
      uint64_t v343 = *((void *)v339 + 22);
      uint64_t v344 = (*((void *)v339 + 23) - v343) >> 3;
      do
      {
        if (v344 == v342 || *(void *)v340 != *(void *)(v343 + 8 * v342) || *(unsigned char *)(*(void *)v340 + 74)) {
          goto LABEL_278;
        }
        ++v342;
        v340 += 8;
      }
      while (v340 != v341);
      if (v344 != v342)
      {
LABEL_278:
        v338[3] = v338[2];
        double v346 = (int *)v338[5];
        v338[5] = 0;
        if (v346)
        {
          (*(void (**)(int *))(*(void *)v346 + 8))(v346);
          uint64_t v339 = *v338;
        }
        __p[0] = 0;
        __p[1] = 0;
        v489.f64[0] = 0.0;
        uint64_t v347 = *((void *)v339 + 5);
        if (![*(id *)(v347 + 32) trafficColorsCount]) {
          goto LABEL_374;
        }
        v348 = *(void **)(v347 + 32);
        uint64_t v349 = [v348 trafficColorOffsets];
        uint64_t v350 = [*(id *)(v347 + 32) trafficColors];
        if (!v348) {
          goto LABEL_374;
        }
        v351.i64[0] = (uint64_t)v348;
        v351.i64[1] = v350;
        int8x16_t v471 = v351;
        unint64_t v352 = [v348 trafficColorsCount];
        double v355 = (uint64_t *)*((void *)v339 + 19);
        if (v355 == *((uint64_t **)v339 + 20)) {
          goto LABEL_374;
        }
        uint64_t v356 = 0;
        v353.i64[0] = v352;
        v354.i64[0] = 1;
        int8x16_t v357 = (int8x16_t)vdupq_lane_s64(vcgtq_u64(v353, v354).i64[0], 0);
        uint64_t v358 = v352 > 1;
        if (v352 <= 1) {
          uint64_t v359 = 0;
        }
        else {
          uint64_t v359 = v349;
        }
        uint64_t v462 = v359;
        int8x16_t v360 = vandq_s8(v471, v357);
        int8x16_t v361 = v471;
LABEL_287:
        v466 = (void *)v360.i64[0];
        uint64_t v472 = v356;
        int8x16_t v455 = v360;
LABEL_289:
        uint64_t v356 = v358;
        if (!v361.i64[0] && !v472) {
          goto LABEL_364;
        }
        if (*(_DWORD *)(v361.i64[1] + 4 * v472) > 2u) {
          goto LABEL_350;
        }
        if (v466 || v358) {
          unsigned int v363 = *(_DWORD *)(v462 + 4 * v358);
        }
        else {
          unsigned int v363 = -1;
        }
        uint64_t v364 = *v355;
        uint64_t v365 = *((void *)v339 + 7);
        double v366 = (double)*(unsigned int *)(v349 + 4 * v472);
        if (*(double *)(v365 + 48 * (*(_DWORD *)(*v355 + 48) - 1) + 8) < v366)
        {
          long double v367 = v355 + 1;
          do
          {
            if (v367 == *((uint64_t **)v339 + 20)) {
              goto LABEL_364;
            }
            uint64_t v368 = *v367++;
            uint64_t v364 = v368;
          }
          while (*(double *)(v365 + 48 * (*(_DWORD *)(v368 + 48) - 1) + 8) < v366);
          double v355 = v367 - 1;
        }
        double v369 = *(double *)(v365 + 48 * *(unsigned int *)(v364 + 40) + 8);
        double v370 = (double)v363;
        if (v369 >= (double)v363) {
          goto LABEL_350;
        }
        int v449 = *(_DWORD *)(v349 + 4 * v472);
        unsigned int v451 = v363;
        int v371 = 0;
        unint64_t v445 = 0xAAAAAAAAAAAAAAABLL * (v338[3] - v338[2]);
        uint64_t v447 = v361.i64[1];
        uint64_t v458 = v358;
        while (1)
        {
          double v372 = v369;
          if (v369 >= v366)
          {
            uint64_t v373 = *((void *)v339 + 10)
                 + 24
                 * (((*(void *)(v364 + 48) + ~*(void *)(v364 + 40))
                                 * v371
                                 / (unint64_t)(*(void *)(v364 + 80) - 1))
                  + *(void *)(v364 + 40));
            unint64_t v375 = (int *)v338[3];
            double v374 = (int *)v338[4];
            if (v375 >= v374)
            {
              double v378 = (int *)v338[2];
              unint64_t v379 = 0xAAAAAAAAAAAAAAABLL * (((char *)v375 - (char *)v378) >> 3) + 1;
              if (v379 > 0xAAAAAAAAAAAAAAALL) {
                goto LABEL_383;
              }
              unint64_t v380 = 0xAAAAAAAAAAAAAAABLL * (((char *)v374 - (char *)v378) >> 3);
              if (2 * v380 > v379) {
                unint64_t v379 = 2 * v380;
              }
              if (v380 >= 0x555555555555555) {
                unint64_t v381 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v381 = v379;
              }
              if (v381)
              {
                if (v381 > 0xAAAAAAAAAAAAAAALL) {
                  goto LABEL_384;
                }
                v382 = (char *)operator new(24 * v381);
              }
              else
              {
                v382 = 0;
              }
              long long v383 = *(_OWORD *)v373;
              long double v384 = &v382[8 * (((char *)v375 - (char *)v378) >> 3)];
              *((void *)v384 + 2) = *(void *)(v373 + 16);
              *(_OWORD *)long double v384 = v383;
              double v385 = (int *)v384;
              if (v375 == v378)
              {
                uint64_t v356 = v458;
              }
              else
              {
                uint64_t v356 = v458;
                do
                {
                  long long v386 = *(_OWORD *)(v375 - 6);
                  *((void *)v385 - 1) = *((void *)v375 - 1);
                  *(_OWORD *)(v385 - 6) = v386;
                  v385 -= 6;
                  v375 -= 6;
                }
                while (v375 != v378);
                unint64_t v375 = (int *)v338[2];
              }
              uint64_t v377 = (int *)(v384 + 24);
              v338[2] = (double *)v385;
              v338[3] = (double *)(v384 + 24);
              v338[4] = (double *)&v382[24 * v381];
              if (v375) {
                operator delete(v375);
              }
            }
            else
            {
              long long v376 = *(_OWORD *)v373;
              *((void *)v375 + 2) = *(void *)(v373 + 16);
              *(_OWORD *)unint64_t v375 = v376;
              uint64_t v377 = v375 + 6;
            }
            v338[3] = (double *)v377;
          }
          ++v371;
          uint64_t v387 = *(void *)(v364 + 80);
          if (v387 == v371)
          {
            if (++v355 == *((uint64_t **)v339 + 20))
            {
              if (v371)
              {
                char v392 = 1;
                goto LABEL_335;
              }
LABEL_364:
              int v415 = (char *)__p[0];
              for (uint64_t i = (char *)__p[1]; v415 != i; v415 += 8)
              {
                uint64_t v417 = *(void *)(*(void *)v415 + 248);
                uint64_t v418 = *(void *)(*(void *)v415 + 256);
                while (v417 != v418)
                {
                  uint64_t v419 = *(uint64_t **)(*(void *)v417 + 176);
                  uint64_t v420 = *(uint64_t **)(*(void *)v417 + 184);
                  if (v419 != v420)
                  {
                    double v421 = (int *)v338[2];
                    do
                    {
                      uint64_t v422 = *v419++;
                      *(void *)(v422 + 56) = &v421[6 * *(void *)(v422 + 56)];
                    }
                    while (v419 != v420);
                  }
                  v417 += 8;
                }
              }
LABEL_374:
              operator new();
            }
            int v371 = 0;
            uint64_t v364 = *v355;
            uint64_t v387 = *(void *)(*v355 + 80);
          }
          uint64_t v388 = *(void *)(v364 + 40);
          uint64_t v389 = *(void *)(v364 + 48) + ~v388;
          unint64_t v390 = v387 - 1;
          double v369 = *(double *)(*((void *)v339 + 7) + 48 * ((v389 * v371 / v390) + v388) + 8);
          if (v372 < v366 && v369 >= v366) {
            altitude::RouteTrafficDrawRegion::point(v338, v389 * v371 / v390 + v388, v389 * (v371 - 1) / v390 + v388, v366);
          }
          if (v369 >= v370)
          {
            if (!v371)
            {
              int8x16_t v360 = v455;
              goto LABEL_350;
            }
            uint64_t v391 = *(void *)(v364 + 40);
            altitude::RouteTrafficDrawRegion::point(v338, (*(void *)(v364 + 48) + ~v391) * v371 / (unint64_t)(*(void *)(v364 + 80) - 1) + v391, (*(void *)(v364 + 48) + ~v391) * (v371 - 1) / (unint64_t)(*(void *)(v364 + 80) - 1) + v391, v370);
            char v392 = 0;
LABEL_335:
            char v443 = v392;
            uint64_t v394 = (int *)v338[2];
            id v393 = (int *)v338[3];
            uint64_t v395 = *(unsigned int *)(v447 + 4 * v472);
            {
              operator new();
            }
            uint64_t v396 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                        + 16))(mdm::Allocator::instance(void)::alloc, 136, 8);
            *(_OWORD *)uint64_t v396 = 0u;
            *(_OWORD *)(v396 + 16) = 0u;
            *(_OWORD *)(v396 + 32) = 0u;
            *(_OWORD *)(v396 + 48) = 0u;
            *(_OWORD *)(v396 + 64) = 0u;
            *(_OWORD *)(v396 + 80) = 0u;
            *(_DWORD *)(v396 + 88) = -1;
            *(void *)(v396 + 96) = 0x7FEFFFFFFFFFFFFFLL;
            *(_OWORD *)(v396 + 120) = 0u;
            *(_OWORD *)(v396 + 104) = 0u;
            *(void *)(v396 + 48) = 0xAAAAAAAAAAAAAAABLL * (((char *)v393 - (char *)v394) >> 3) - v445;
            *(void *)(v396 + 56) = v445;
            *(float *)(v396 + 132) = (float)(v451 - v449);
            uint64_t v397 = (char *)__p[1];
            double v398 = (char *)__p[0];
            *(_DWORD *)(v396 + 80) = 6;
            if (v398 == v397) {
LABEL_339:
            }
              operator new();
            while (*(void *)(*(void *)v398 + 280) != v395)
            {
              v398 += 8;
              if (v398 == v397) {
                goto LABEL_339;
              }
            }
            uint64_t v399 = **(void **)(*(void *)v398 + 248);
            v473.n128_u64[0] = v396;
            double v400 = *(uint64_t **)(v399 + 184);
            if ((unint64_t)v400 >= *(void *)(v399 + 192))
            {
              uint64_t v402 = std::vector<std::unique_ptr<md::FlyoverTraffic,mdm::TypeDeleter<md::FlyoverTraffic>>,geo::StdAllocator<std::unique_ptr<md::FlyoverTraffic,mdm::TypeDeleter<md::FlyoverTraffic>>,mdm::Allocator>>::__push_back_slow_path<std::unique_ptr<md::FlyoverTraffic,mdm::TypeDeleter<md::FlyoverTraffic>>>(v399 + 176, (uint64_t *)&v473);
              uint64_t v396 = v473.n128_u64[0];
              int8x16_t v360 = v455;
              char v401 = v443;
            }
            else
            {
              char v401 = v443;
              if (v400)
              {
                *double v400 = v396;
                uint64_t v396 = 0;
              }
              int8x16_t v360 = v455;
              uint64_t v402 = v400 + 1;
            }
            *(void *)(v399 + 184) = v402;
            v473.n128_u64[0] = 0;
            if (v396)
            {
              {
                operator new();
              }
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v396, 136);
              int8x16_t v360 = v455;
            }
            if (v401) {
              goto LABEL_364;
            }
LABEL_350:
            if (v466 || (v358 = 0, v361 = v360, v472 = v356, uint64_t v349 = v462, v356))
            {
              uint64_t v358 = v356 + 1;
              unint64_t v362 = [v466 trafficColorsCount];
              int8x16_t v360 = v455;
              int8x16_t v361 = v455;
              uint64_t v472 = v356;
              uint64_t v349 = v462;
              if (v356 + 1 >= v362)
              {
                uint64_t v358 = 0;
                int8x16_t v361 = v455;
                uint64_t v349 = v462;
                int8x16_t v360 = 0uLL;
                uint64_t v462 = 0;
                goto LABEL_287;
              }
            }
            goto LABEL_289;
          }
        }
      }
    }
    double v345 = (int *)v338[5];
    if (!v345) {
      goto LABEL_278;
    }
    __p[0] = (void *)1;
    HIDWORD(__p[0]) = *((_DWORD *)v339 + 6);
    md::FlyoverTrafficLayer::willBeDrawn(*((uint64_t **)v345 + 1), *((uint64_t **)v345 + 2), (uint64_t)a2, (uint64_t)__p);
    double v423 = (int *)v338[5];
    int v424 = (char *)*((void *)v423 + 1);
    v425 = (char *)*((void *)v423 + 2);
    if (v424 != v425)
    {
      uint64_t v426 = 2 * *(int *)*v338;
      unint64_t v427 = v425 - v424 - 8;
      if (v427 < 8)
      {
        do
        {
LABEL_381:
          uint64_t v432 = *(void *)v424;
          v424 += 8;
          *(void *)(v432 + 64) = v426;
        }
        while (v424 != v425);
      }
      else
      {
        uint64_t v428 = (v427 >> 3) + 1;
        v429 = (uint64_t *)(v424 + 8);
        uint64_t v430 = v428 & 0x3FFFFFFFFFFFFFFELL;
        do
        {
          uint64_t v431 = *v429;
          *(void *)(*(v429 - 1) + 64) = v426;
          *(void *)(v431 + 64) = v426;
          v429 += 2;
          v430 -= 2;
        }
        while (v430);
        if (v428 != (v428 & 0x3FFFFFFFFFFFFFFELL))
        {
          v424 += 8 * (v428 & 0x3FFFFFFFFFFFFFFELL);
          goto LABEL_381;
        }
      }
    }
  }
}

void sub_1A20840F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a37);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&a70);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker(v70 - 224);
  _Unwind_Resume(a1);
}

void sub_1A208412C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
}

void sub_1A2084140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,std::__shared_weak_count *a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (v72 && !atomic_fetch_add(&v72->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
    std::__shared_weak_count::__release_weak(v72);
  }
  int v75 = *(std::__shared_weak_count **)(v73 - 160);
  if (v75 && !atomic_fetch_add(&v75->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
    std::__shared_weak_count::__release_weak(v75);
  }
  if (a71 && !atomic_fetch_add(&a71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a71->__on_zero_shared)(a71);
    std::__shared_weak_count::__release_weak(a71);
  }
  int v76 = *(std::__shared_weak_count **)(v73 - 216);
  if (v76 && !atomic_fetch_add(&v76->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
    std::__shared_weak_count::__release_weak(v76);
  }
  if (a38 && !atomic_fetch_add(&a38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a38->__on_zero_shared)(a38);
    std::__shared_weak_count::__release_weak(a38);
  }
  if (v71)
  {
    if (!atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
      std::__shared_weak_count::__release_weak(v71);
    }
  }
  _Unwind_Resume(a1);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::FlyoverMorph::Vertex>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::FlyoverMorph::Vertex>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::FlyoverMorph::Vertex>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void non-virtual thunk to'ggl::FlyoverMorph::MorphMesh::~MorphMesh(ggl::FlyoverMorph::MorphMesh *this)
{
  ggl::Mesh::~Mesh((ggl::FlyoverMorph::MorphMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::FlyoverMorph::MorphMesh *)((char *)this - 16));
}

void ggl::FlyoverMorph::MorphMesh::~MorphMesh(ggl::FlyoverMorph::MorphMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::FlyoverMorph::Vertex>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::FlyoverMorph::Vertex>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::FlyoverMorph::MorphPipelineState::~MorphPipelineState(ggl::FlyoverMorph::MorphPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::FlyoverMorph::MorphPipelineState::MorphPipelineState(uint64_t a1, void *a2, uint64_t a3, _OWORD *a4)
{
  {
    unint64_t v10 = a4;
    unint64_t v12 = a2;
    uint64_t v13 = a3;
    a2 = v12;
    a3 = v13;
    a4 = v10;
    if (v11)
    {
      {
        if (v11)
        {
          {
            {
              ggl::MeshTyped<ggl::FlyoverMorph::Vertex>::attributesReflection(void)::r = (uint64_t)&ggl::FlyoverMorph::vertexReflection;
            }
            ggl::MeshTyped<ggl::FlyoverMorph::Vertex>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::FlyoverMorph::Vertex>::attributesReflection(void)::r;
            unk_1E957D578 = 1;
          }
          ggl::FlyoverMorph::MorphPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::FlyoverMorph::Vertex>::typedReflection(void)::r;
          *(void *)algn_1E957D218 = &ggl::FlyoverMorph::pipelineDataMorphPipelineDeviceStructs(void)::ref;
          qword_1E957D220 = 0;
          {
            ggl::FlyoverMorph::pipelineDataMorphPipelineConstantStructs(void)::ref = (uint64_t)ggl::FlyoverCommon::Shared::reflection(void)::reflection;
            unk_1E957D250 = ggl::FlyoverCommon::Transform::reflection(void)::reflection;
            qword_1E957D258 = (uint64_t)ggl::FlyoverCommon::Clip::reflection(void)::reflection;
            unk_1E957D260 = ggl::FlyoverCommon::Material::reflection(void)::reflection;
            qword_1E957D268 = (uint64_t)ggl::FlyoverCommon::Texcoords::reflection(void)::reflection;
            unk_1E957D270 = ggl::FlyoverMorph::Morph::reflection(void)::reflection;
          }
          qword_1E957D228 = (uint64_t)&ggl::FlyoverMorph::pipelineDataMorphPipelineConstantStructs(void)::ref;
          unk_1E957D230 = xmmword_1A28FE170;
        }
      }
      ggl::FlyoverMorph::MorphPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::FlyoverMorph::MorphPipelineSetup::typedReflection(void)::ref;
      ggl::FlyoverMorphShader::typedReflection(v11);
      qword_1E958FB20 = (uint64_t)&ggl::FlyoverMorphShader::typedReflection(void)::ref;
      {
        ggl::FlyoverMorph::pipelineStateMorphPipelineAttributeStructBinding(void)::attr = 0;
        unk_1E958FB80 = 0;
        qword_1E958FB88 = (uint64_t)"";
        dword_1E958FB90 = 0;
        qword_1E958FB98 = (uint64_t)&ggl::FlyoverMorph::pipelineStateMorphPipelineAttributeBinding_0(void)::attr;
        unk_1E958FBA0 = 4;
      }
      qword_1E958FB28 = (uint64_t)&ggl::FlyoverMorph::pipelineStateMorphPipelineAttributeStructBinding(void)::attr;
      unk_1E958FB30 = 1;
      qword_1E958FB38 = 0;
      unk_1E958FB40 = 3;
      qword_1E958FB48 = (uint64_t)&ggl::FlyoverMorph::pipelineStateMorphPipelineDeviceStructBinding(void)::ref;
      unk_1E958FB50 = 0;
      {
        ggl::FlyoverMorph::pipelineStateMorphPipelineConstantStructBinding(void)::ref = 0;
        unk_1E958FBC0 = 0;
        qword_1E958FBC8 = (uint64_t)"sharedConstants";
        dword_1E958FBD0 = 3;
        qword_1E958FBD8 = (uint64_t)&ggl::FlyoverMorph::pipelineStateMorphPipelineConstantSharedConstantsBinding(void)::reflection;
        unk_1E958FBE0 = xmmword_1A28FC940;
        qword_1E958FBF0 = 1;
        unk_1E958FBF8 = "transform";
        dword_1E958FC00 = 3;
        qword_1E958FC08 = (uint64_t)&ggl::FlyoverMorph::pipelineStateMorphPipelineConstantTransformBinding(void)::reflection;
        *(int64x2_t *)algn_1E958FC10 = vdupq_n_s64(2uLL);
        qword_1E958FC20 = 2;
        unk_1E958FC28 = "clip";
        dword_1E958FC30 = 3;
        qword_1E958FC38 = (uint64_t)&ggl::FlyoverMorph::pipelineStateMorphPipelineConstantClipBinding(void)::reflection;
        unk_1E958FC40 = xmmword_1A28FC950;
        qword_1E958FC50 = 3;
        unk_1E958FC58 = "material";
        dword_1E958FC60 = 3;
        qword_1E958FC68 = (uint64_t)&ggl::FlyoverMorph::pipelineStateMorphPipelineConstantMaterialBinding(void)::reflection;
        *(_OWORD *)algn_1E958FC70 = xmmword_1A28FC960;
        qword_1E958FC80 = 4;
        unk_1E958FC88 = "texcoords";
        dword_1E958FC90 = 3;
        qword_1E958FC98 = (uint64_t)&ggl::FlyoverMorph::pipelineStateMorphPipelineConstantTexcoordsBinding(void)::reflection;
        unk_1E958FCA0 = xmmword_1A28FE180;
        qword_1E958FCB0 = 5;
        unk_1E958FCB8 = "morph";
        dword_1E958FCC0 = 3;
        qword_1E958FCC8 = (uint64_t)&ggl::FlyoverMorph::pipelineStateMorphPipelineConstantMorphBinding(void)::reflection;
        unk_1E958FCD0 = 3;
      }
      qword_1E958FB58 = (uint64_t)&ggl::FlyoverMorph::pipelineStateMorphPipelineConstantStructBinding(void)::ref;
      unk_1E958FB60 = 6;
      a4 = v10;
      a2 = v12;
      a3 = v13;
    }
  }
  uint64_t v5 = *a2;
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)float64_t v16 = *(_OWORD *)a3;
  *(_OWORD *)&v16[12] = *(_OWORD *)(a3 + 12);
  long long v7 = *(_OWORD *)(a3 + 28);
  char v8 = *(unsigned char *)(a3 + 44);
  long long v14 = *a4;
  long long v15 = a4[1];
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = &unk_1EF55B208;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 40) = &ggl::FlyoverMorph::MorphPipelineState::typedReflection(void)::ref;
  *(void *)(a1 + 48) = v5;
  *(void *)(a1 + 56) = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 116) = xmmword_1A28FC970;
  *(void *)(a1 + 132) = 0;
  *(void *)(a1 + 148) = 0;
  *(void *)(a1 + 140) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 164) = xmmword_1A28FC970;
  *(void *)(a1 + 180) = 0;
  *(void *)(a1 + 196) = 0;
  *(void *)(a1 + 188) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 212) = xmmword_1A28FC970;
  *(void *)(a1 + 228) = 0;
  *(void *)(a1 + 244) = 0;
  *(void *)(a1 + 236) = 0;
  *(_OWORD *)(a1 + 256) = v14;
  *(_OWORD *)(a1 + 272) = v15;
  *(unsigned char *)(a1 + 288) = 0;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0x100000001;
  *(unsigned char *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)v16;
  *(_OWORD *)(a1 + 76) = *(_OWORD *)&v16[12];
  *(_OWORD *)(a1 + 92) = v7;
  *(unsigned char *)(a1 + 108) = v8;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  *(void *)a1 = &unk_1EF55ABB8;
  return a1;
}

BOOL ggl::FlyoverMorph::MorphPipelineSetup::textureIsEnabled(ggl::FlyoverMorph::MorphPipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

BOOL ggl::FlyoverMorph::MorphPipelineSetup::constantDataIsEnabled(ggl::FlyoverMorph::MorphPipelineSetup *this, unint64_t a2)
{
  return a2 < 6;
}

void ggl::FlyoverMorph::MorphPipelineSetup::~MorphPipelineSetup(ggl::FlyoverMorph::MorphPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__tree<std::__value_type<geo::_retain_ptr<NSString * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>>>,std::__map_value_compare<geo::_retain_ptr<NSString * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::__value_type<geo::_retain_ptr<NSString * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>>>,NSStringMapComparison,true>,geo::StdAllocator<std::__value_type<geo::_retain_ptr<NSString * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>>>,mdm::Allocator>>::destroy(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<geo::_retain_ptr<NSString * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>>>,std::__map_value_compare<geo::_retain_ptr<NSString * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::__value_type<geo::_retain_ptr<NSString * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>>>,NSStringMapComparison,true>,geo::StdAllocator<std::__value_type<geo::_retain_ptr<NSString * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>>>,mdm::Allocator>>::destroy(result, *(void *)a2);
    std::__tree<std::__value_type<geo::_retain_ptr<NSString * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>>>,std::__map_value_compare<geo::_retain_ptr<NSString * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::__value_type<geo::_retain_ptr<NSString * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>>>,NSStringMapComparison,true>,geo::StdAllocator<std::__value_type<geo::_retain_ptr<NSString * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>>>,mdm::Allocator>>::destroy(v3, *(void *)(a2 + 8));
    unint64_t v4 = *(std::__shared_weak_count **)(a2 + 64);
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    *(void *)(a2 + 32) = &unk_1EF559F18;

    uint64_t v5 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v5();
  }
  return result;
}

void sub_1A20852F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  unint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VKInternalIconManager;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void grl::IconRequestOptions::~IconRequestOptions(grl::IconRequestOptions *this)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 3);
    uint64_t v4 = *((void *)this + 2);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0) {
          operator delete(*(void **)(v3 - 24));
        }
        v3 -= 24;
      }
      while (v3 != v2);
      uint64_t v4 = *((void *)this + 2);
    }
    *((void *)this + 3) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 5) + 40))(*((void *)this + 5), v4, *((void *)this + 4) - v4);
  }
}

void sub_1A20859CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  grl::IconModifiers::~IconModifiers((grl::IconModifiers *)&a28);
  if (a16 < 0) {
    operator delete(__p);
  }
  grl::IconRequestOptions::~IconRequestOptions((grl::IconRequestOptions *)&a20);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a26);

  _Unwind_Resume(a1);
}

void sub_1A2085D84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  grl::IconModifiers::~IconModifiers((grl::IconModifiers *)va2);
  grl::IconRequestOptions::~IconRequestOptions((grl::IconRequestOptions *)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);

  _Unwind_Resume(a1);
}

void sub_1A20864A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  grl::IconModifiers::~IconModifiers((grl::IconModifiers *)&a28);
  grl::IconRequestOptions::~IconRequestOptions((grl::IconRequestOptions *)&a20);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a26);

  _Unwind_Resume(a1);
}

uint64_t gss::ClientStyleState<gss::PropertyID>::~ClientStyleState(uint64_t a1)
{
  uint64_t v1 = a1;
  if (!*(unsigned char *)(a1 + 246) && *(void *)(a1 + 232))
  {
    uint64_t v2 = gss::Allocator::instance((gss::Allocator *)a1);
    a1 = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v2 + 40))(v2, *(void *)(v1 + 232), *(unsigned __int16 *)(v1 + 244));
    *(void *)(v1 + 232) = 0;
  }
  if (!*(unsigned char *)(v1 + 230) && *(void *)(v1 + 216))
  {
    uint64_t v3 = gss::Allocator::instance((gss::Allocator *)a1);
    (*(void (**)(uint64_t, void, void))(*(void *)v3 + 40))(v3, *(void *)(v1 + 216), *(unsigned __int16 *)(v1 + 228));
    *(void *)(v1 + 216) = 0;
  }
  uint64_t v4 = (geo::read_write_lock *)pthread_rwlock_destroy((pthread_rwlock_t *)(v1 + 16));
  if (v4) {
    geo::read_write_lock::logFailure(v4, (uint64_t)"destruction", v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(v1 + 8);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  return v1;
}

uint64_t *std::unique_ptr<gss::ClientStyleState<gss::PropertyID>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = gss::ClientStyleState<gss::PropertyID>::~ClientStyleState(v2);
    MEMORY[0x1A6239270](v3, 0x1030C406D3438E8);
  }
  return a1;
}

uint64_t std::__shared_ptr_pointer<gss::ClientStyleState<gss::PropertyID> *,std::shared_ptr<gss::ClientStyleState<gss::PropertyID>>::__shared_ptr_default_delete<gss::ClientStyleState<gss::PropertyID>,gss::ClientStyleState<gss::PropertyID>>,std::allocator<gss::ClientStyleState<gss::PropertyID>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    gss::ClientStyleState<gss::PropertyID>::~ClientStyleState(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<gss::ClientStyleState<gss::PropertyID> *,std::shared_ptr<gss::ClientStyleState<gss::PropertyID>>::__shared_ptr_default_delete<gss::ClientStyleState<gss::PropertyID>,gss::ClientStyleState<gss::PropertyID>>,std::allocator<gss::ClientStyleState<gss::PropertyID>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t *std::unique_ptr<gss::StylesheetManager<gss::PropertyID>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = gss::StylesheetManager<gss::PropertyID>::~StylesheetManager(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40DB985E3BLL);
  }
  return a1;
}

void std::__shared_ptr_pointer<gss::StylesheetManager<gss::PropertyID> *,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>>::__shared_ptr_default_delete<gss::StylesheetManager<gss::PropertyID>,gss::StylesheetManager<gss::PropertyID>>,std::allocator<gss::StylesheetManager<gss::PropertyID>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t *std::vector<std::weak_ptr<gss::FeatureQueryImpl<gss::PropertyID>>,geo::StdAllocator<std::weak_ptr<gss::FeatureQueryImpl<gss::PropertyID>>,gss::Allocator>>::~vector[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5) {
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v4, a1[2] - v4);
  }
  return a1;
}

uint64_t std::unordered_map<gss::StyleKey,std::weak_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::hash<gss::StyleKey>,std::equal_to<gss::StyleKey>,geo::StdAllocator<std::pair<gss::StyleKey const,std::weak_ptr<gss::StylesheetQuery<gss::PropertyID>>>,gss::Allocator>>::~unordered_map[abi:nn180100](uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<gss::StyleKey,std::weak_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::__unordered_map_hasher<gss::StyleKey,std::__hash_value_type<gss::StyleKey,std::weak_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::hash<gss::StyleKey>,std::equal_to<gss::StyleKey>,true>,std::__unordered_map_equal<gss::StyleKey,std::__hash_value_type<gss::StyleKey,std::weak_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::equal_to<gss::StyleKey>,std::hash<gss::StyleKey>,true>,geo::StdAllocator<std::__hash_value_type<gss::StyleKey,std::weak_ptr<gss::StylesheetQuery<gss::PropertyID>>>,gss::Allocator>>::__deallocate_node(a1, *(uint64_t **)(a1 + 24));
  uint64_t v2 = *(void *)a1;
  *(void *)a1 = 0;
  if (v2) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 16) + 40))(*(void *)(a1 + 16), v2, 8 * *(void *)(a1 + 8));
  }
  return a1;
}

uint64_t gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::~function(uint64_t a1)
{
  uint64_t v2 = a1 + 32;
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  return a1;
}

void gss::DecodingContext::~DecodingContext(gss::DecodingContext *this)
{
}

void gss::StylFile::~StylFile(gss::StylFile *this)
{
}

gss::Allocator *gss::StyleMatchingTree<gss::CartoStyle<gss::PropertyID>>::~StyleMatchingTree(gss::Allocator *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = (void *)*((void *)a1 + 5);
  if (v2)
  {
    uint64_t v3 = (void *)*((void *)a1 + 6);
    uint64_t v4 = (gss::Allocator *)*((void *)a1 + 5);
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = (void *)*--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6)
        {
          uint64_t v7 = gss::Allocator::instance(v4);
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)v7 + 40))(v7, *v5, 4 * v5[2]);
          uint64_t v4 = (gss::Allocator *)MEMORY[0x1A6239270](v5, 0x1020C4024DAA5DELL);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (gss::Allocator *)*((void *)v1 + 5);
    }
    *((void *)v1 + 6) = v2;
    operator delete(v4);
  }
  char v8 = (gss::Allocator **)((char *)v1 + 24);
  if (!*((unsigned char *)v1 + 36))
  {
    a1 = *v8;
    if (*v8)
    {
      uint64_t v9 = geo::intern_vector<gss::MatchingGraphEndChain,geo::StdAllocator<gss::MatchingGraphEndChain,gss::Allocator>>::runDestructors(a1, (gss::Allocator *)((char *)a1 + 16 * *((unsigned __int16 *)v1 + 16)));
      uint64_t v10 = gss::Allocator::instance(v9);
      a1 = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v10 + 40))(v10, *((void *)v1 + 3), 16 * *((unsigned __int16 *)v1 + 17));
    }
  }
  *(void *)((char *)v1 + 29) = 0;
  *char v8 = 0;
  uint64_t v11 = (void *)((char *)v1 + 8);
  if (!*((unsigned char *)v1 + 20) && *v11)
  {
    if (*((_WORD *)v1 + 8))
    {
      uint64_t v12 = 24 * *((unsigned __int16 *)v1 + 8);
      uint64_t v13 = (unsigned char *)(*v11 + 20);
      do
      {
        uint64_t v14 = v13 - 12;
        if (!*v13 && *v14)
        {
          uint64_t v15 = gss::Allocator::instance(a1);
          a1 = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v15 + 40))(v15, *(void *)(v13 - 12), 4 * *((unsigned __int16 *)v13 - 1));
        }
        *(void *)(v13 - 7) = 0;
        *uint64_t v14 = 0;
        v13 += 24;
        v12 -= 24;
      }
      while (v12);
    }
    uint64_t v16 = gss::Allocator::instance(a1);
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v16 + 40))(v16, *((void *)v1 + 1), 24 * *((unsigned __int16 *)v1 + 9));
  }
  *(void *)((char *)v1 + 13) = 0;
  *uint64_t v11 = 0;
  return v1;
}

gss::Allocator *std::unique_ptr<geo::intern_allocator<gss::StyleMatchingTreeNode<gss::CartoStyle<gss::PropertyID>>::SubTreeNode,geo::StdAllocator<gss::StyleMatchingTreeNode<gss::CartoStyle<gss::PropertyID>>::SubTreeNode,gss::Allocator>>::PageInfo,std::default_delete<geo::intern_allocator<gss::StyleMatchingTreeNode<gss::CartoStyle<gss::PropertyID>>::SubTreeNode,geo::StdAllocator<gss::StyleMatchingTreeNode<gss::CartoStyle<gss::PropertyID>>::SubTreeNode,gss::Allocator>>::PageInfo>>::~unique_ptr[abi:nn180100](gss::Allocator *a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    uint64_t v3 = gss::Allocator::instance(a1);
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v3 + 40))(v3, *v2, 4 * v2[2]);
    MEMORY[0x1A6239270](v2, 0x1020C4024DAA5DELL);
  }
  return a1;
}

gss::Allocator *geo::intern_vector<gss::MatchingGraphEndChain,geo::StdAllocator<gss::MatchingGraphEndChain,gss::Allocator>>::runDestructors(gss::Allocator *result, gss::Allocator *a2)
{
  if (result != a2)
  {
    uint64_t v3 = result;
    do
    {
      if (!*((unsigned char *)v3 + 12) && *(void *)v3)
      {
        if (*((_WORD *)v3 + 4))
        {
          uint64_t v5 = 24 * *((unsigned __int16 *)v3 + 4);
          uint64_t v6 = (unsigned char *)(*(void *)v3 + 20);
          do
          {
            uint64_t v7 = v6 - 12;
            if (!*v6)
            {
              if (*v7)
              {
                uint64_t v8 = gss::Allocator::instance(result);
                uint64_t result = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v8 + 40))(v8, *(void *)(v6 - 12), 4 * *((unsigned __int16 *)v6 - 1));
              }
            }
            *(void *)(v6 - 7) = 0;
            *uint64_t v7 = 0;
            v6 += 24;
            v5 -= 24;
          }
          while (v5);
        }
        uint64_t v4 = gss::Allocator::instance(result);
        uint64_t result = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v4 + 40))(v4, *(void *)v3, 24 * *((unsigned __int16 *)v3 + 5));
      }
      *(void *)((char *)v3 + 5) = 0;
      *(void *)uint64_t v3 = 0;
      uint64_t v3 = (gss::Allocator *)((char *)v3 + 16);
    }
    while (v3 != a2);
  }
  return result;
}

gss::Allocator *std::unique_ptr<geo::intern_allocator<unsigned int,geo::StdAllocator<unsigned int,gss::Allocator>>::PageInfo,std::default_delete<geo::intern_allocator<unsigned int,geo::StdAllocator<unsigned int,gss::Allocator>>::PageInfo>>::~unique_ptr[abi:nn180100](gss::Allocator *a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    uint64_t v3 = gss::Allocator::instance(a1);
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v3 + 40))(v3, *v2, 4 * v2[2]);
    MEMORY[0x1A6239270](v2, 0x1010C40113C0ABBLL);
  }
  return a1;
}

uint64_t geo::intern_vector<std::shared_ptr<gss::ConditionalStyle<gss::PropertyID>>,geo::StdAllocator<std::shared_ptr<gss::ConditionalStyle<gss::PropertyID>>,gss::Allocator>>::moveContent(uint64_t result, _OWORD *a2)
{
  uint64_t v2 = result;
  __int16 v3 = *(_WORD *)(result + 8);
  if (v3)
  {
    uint64_t v4 = *(void *)result;
    int v5 = *(unsigned __int16 *)(result + 8);
    do
    {
      *a2++ = *(_OWORD *)v4;
      *(void *)uint64_t v4 = 0;
      *(void *)(v4 + 8) = 0;
      v4 += 16;
      --v5;
    }
    while ((_WORD)v5);
  }
  if (!*(unsigned char *)(result + 12) && *(void *)result)
  {
    if (*(_WORD *)(result + 8))
    {
      uint64_t v6 = 16 * *(unsigned __int16 *)(result + 8);
      uint64_t v7 = (std::__shared_weak_count **)(*(void *)result + 8);
      do
      {
        uint64_t v8 = *v7;
        if (*v7 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
        v7 += 2;
        v6 -= 16;
      }
      while (v6);
    }
    uint64_t v9 = gss::Allocator::instance((gss::Allocator *)result);
    uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v9 + 40))(v9, *(void *)v2, 16 * *(unsigned __int16 *)(v2 + 10));
  }
  *(void *)(v2 + 5) = 0;
  *(void *)uint64_t v2 = 0;
  *(_WORD *)(v2 + 8) = v3;
  return result;
}

void *geo::intern_vector<std::shared_ptr<gss::ConditionalStyle<gss::PropertyID>>,geo::StdAllocator<std::shared_ptr<gss::ConditionalStyle<gss::PropertyID>>,gss::Allocator>>::~intern_vector(void *a1)
{
  if (!*((unsigned char *)a1 + 12) && *a1)
  {
    if (*((_WORD *)a1 + 4))
    {
      uint64_t v2 = 16 * *((unsigned __int16 *)a1 + 4);
      __int16 v3 = (std::__shared_weak_count **)(*a1 + 8);
      do
      {
        uint64_t v4 = *v3;
        if (*v3 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
        v3 += 2;
        v2 -= 16;
      }
      while (v2);
    }
    uint64_t v5 = gss::Allocator::instance((gss::Allocator *)a1);
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v5 + 40))(v5, *a1, 16 * *((unsigned __int16 *)a1 + 5));
  }
  *(void *)((char *)a1 + 5) = 0;
  *a1 = 0;
  return a1;
}

uint64_t gss::CartoStyle<gss::PropertyID>::~CartoStyle(uint64_t a1)
{
  *(void *)a1 = &unk_1EF567328;
  uint64_t v2 = *(gss::Allocator **)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (v2) {
    uint64_t v2 = (gss::Allocator *)MEMORY[0x1A6239250](v2, 0x1000C8077774924);
  }
  __int16 v3 = *(std::__shared_weak_count **)(a1 + 96);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 80);
    if (!v4) {
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 80);
    if (!v4) {
      goto LABEL_9;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_9:
  uint64_t v5 = (void *)(a1 + 56);
  if (!*(unsigned char *)(a1 + 68) && *v5)
  {
    if (*(_WORD *)(a1 + 64))
    {
      uint64_t v6 = 16 * *(unsigned __int16 *)(a1 + 64);
      uint64_t v7 = (std::__shared_weak_count **)(*v5 + 8);
      do
      {
        uint64_t v8 = *v7;
        if (*v7 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
        v7 += 2;
        v6 -= 16;
      }
      while (v6);
    }
    uint64_t v9 = gss::Allocator::instance(v2);
    uint64_t v2 = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v9 + 40))(v9, *(void *)(a1 + 56), 16 * *(unsigned __int16 *)(a1 + 66));
  }
  *(void *)(a1 + 61) = 0;
  void *v5 = 0;
  uint64_t v10 = (void *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 52) && *v10)
  {
    if (*(_WORD *)(a1 + 48))
    {
      uint64_t v11 = 24 * *(unsigned __int16 *)(a1 + 48);
      uint64_t v12 = (std::__shared_weak_count **)(*v10 + 16);
      do
      {
        uint64_t v13 = *v12;
        if (*v12 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
        v12 += 3;
        v11 -= 24;
      }
      while (v11);
    }
    uint64_t v14 = gss::Allocator::instance(v2);
    uint64_t v2 = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v14 + 40))(v14, *(void *)(a1 + 40), 24 * *(unsigned __int16 *)(a1 + 50));
  }
  *(void *)(a1 + 45) = 0;
  *uint64_t v10 = 0;
  uint64_t v15 = (void *)(a1 + 24);
  if (!*(unsigned char *)(a1 + 36) && *v15)
  {
    uint64_t v16 = gss::Allocator::instance(v2);
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v16 + 40))(v16, *(void *)(a1 + 24), 4 * *(unsigned __int16 *)(a1 + 34));
  }
  *(void *)(a1 + 29) = 0;
  void *v15 = 0;
  float v17 = *(std::__shared_weak_count **)(a1 + 16);
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  return a1;
}

uint64_t gss::ConditionalStyle<gss::PropertyID>::to_string@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)v42);
  if (*(void *)(*(void *)(a1 + 144) + 104)) {
    __int16 v3 = *(const char **)(*(void *)(a1 + 144) + 104);
  }
  else {
    __int16 v3 = "";
  }
  size_t v4 = strlen(v3);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)v3, v4);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)"-condStyle-", 11);
  uint64_t v5 = (void *)std::ostream::operator<<();
  LOBYTE(__b.__locale_) = 45;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)&__b, 1);
  uint64_t v6 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)"-{", 2);
  if (*(_WORD *)(a1 + 136))
  {
    uint64_t v7 = *(void *)(a1 + 128);
    uint64_t v40 = v7 + 24 * *(unsigned __int16 *)(a1 + 136);
    while (1)
    {
      LOBYTE(__b.__locale_) = 64;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)&__b, 1);
      uint64_t v8 = (void *)std::ostream::operator<<();
      LOBYTE(__b.__locale_) = 61;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)&__b, 1);
      uint64_t v41 = v7;
      uint64_t v9 = *(unsigned __int16 *)(v7 + 16);
      if (v9)
      {
        uint64_t v10 = *(void *)(v41 + 8);
        std::ostream::operator<<();
        if (v9 != 1) {
          break;
        }
      }
LABEL_40:
      LOBYTE(__b.__locale_) = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)&__b, 1);
      uint64_t v7 = v41 + 24;
      if (v41 + 24 == v40) {
        goto LABEL_41;
      }
    }
    uint64_t v11 = v10 + 4;
    uint64_t v12 = 4 * v9 - 4;
    while (1)
    {
      char v52 = 44;
      MEMORY[0x1A6238CF0](v53, v43);
      if (v53[0])
      {
        uint64_t v13 = (const std::ios_base *)((char *)v43 + *(void *)(v43[0] - 24));
        rdbuf = v13->__rdbuf_;
        std::ios_base::fmtflags fmtflags = v13->__fmtflags_;
        int v16 = v13[1].__fmtflags_;
        if (v16 == -1)
        {
          std::ios_base::getloc(v13);
          float v17 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
          int v16 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 32);
          std::locale::~locale(&__b);
          v13[1].__fmtflags_ = v16;
        }
        if ((fmtflags & 0xB0) == 0x20) {
          uint64_t v18 = v53;
        }
        else {
          uint64_t v18 = &v52;
        }
        if (!rdbuf) {
          goto LABEL_38;
        }
        uint64_t width = v13->__width_;
        BOOL v20 = width <= 1;
        uint64_t v21 = width - 1;
        size_t v22 = v20 ? 0 : v21;
        if (v18 - &v52 >= 1
          && (*(uint64_t (**)(void *, char *, int64_t))(*(void *)rdbuf + 96))(rdbuf, &v52, v18 - &v52) != v18 - &v52)
        {
          goto LABEL_38;
        }
        if ((uint64_t)v22 >= 1)
        {
          if (v22 > 0x7FFFFFFFFFFFFFF7) {
            abort();
          }
          if (v22 >= 0x17)
          {
            uint64_t v24 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v22 | 7) != 0x17) {
              uint64_t v24 = v22 | 7;
            }
            uint64_t v25 = v24 + 1;
            p_b = (std::locale::__imp *)operator new(v24 + 1);
            size_t v55 = v22;
            int64_t v56 = v25 | 0x8000000000000000;
            __b.__locale_ = p_b;
          }
          else
          {
            HIBYTE(v56) = v22;
            p_b = (std::locale::__imp *)&__b;
          }
          memset(p_b, v16, v22);
          *((unsigned char *)p_b + v22) = 0;
          if (v56 >= 0) {
            locale = &__b;
          }
          else {
            locale = __b.__locale_;
          }
          uint64_t v27 = (*(uint64_t (**)(void *, void *, size_t))(*(void *)rdbuf + 96))(rdbuf, locale, v22);
          uint64_t v28 = v27;
          if (SHIBYTE(v56) < 0)
          {
            operator delete(__b.__locale_);
            if (v28 != v22) {
              goto LABEL_38;
            }
          }
          else if (v27 != v22)
          {
            goto LABEL_38;
          }
        }
        if (v53 - v18 >= 1
          && (*(uint64_t (**)(void *, char *, int64_t))(*(void *)rdbuf + 96))(rdbuf, v18, v53 - v18) != v53 - v18)
        {
LABEL_38:
          std::ios_base::clear((std::ios_base *)((char *)v43 + *(void *)(v43[0] - 24)), *(_DWORD *)((char *)&v44[1] + *(void *)(v43[0] - 24)) | 5);
          goto LABEL_39;
        }
        v13->__width_ = 0;
      }
LABEL_39:
      MEMORY[0x1A6238D00](v53);
      std::ostream::operator<<();
      v11 += 4;
      v12 -= 4;
      if (!v12) {
        goto LABEL_40;
      }
    }
  }
LABEL_41:
  LOBYTE(__b.__locale_) = 125;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)&__b, 1);
  if ((v50 & 0x10) != 0)
  {
    unint64_t v31 = v49;
    if (v49 < v46)
    {
      unint64_t v49 = v46;
      unint64_t v31 = v46;
    }
    unsigned int v32 = (const void **)&v45;
  }
  else
  {
    if ((v50 & 8) == 0)
    {
      size_t v29 = 0;
      double v30 = a2;
      *((unsigned char *)a2 + 23) = 0;
      goto LABEL_56;
    }
    unsigned int v32 = (const void **)v44;
    unint64_t v31 = v44[2];
  }
  double v30 = a2;
  BOOL v33 = *v32;
  size_t v29 = v31 - (void)*v32;
  if (v29 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  if (v29 >= 0x17)
  {
    uint64_t v34 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v29 | 7) != 0x17) {
      uint64_t v34 = v29 | 7;
    }
    uint64_t v35 = v34 + 1;
    double v36 = operator new(v34 + 1);
    a2[1] = v29;
    a2[2] = v35 | 0x8000000000000000;
    *a2 = v36;
    double v30 = v36;
    goto LABEL_55;
  }
  *((unsigned char *)a2 + 23) = v29;
  if (v29) {
LABEL_55:
  }
    memmove(v30, v33, v29);
LABEL_56:
  *((unsigned char *)v30 + v29) = 0;
  v42[0] = *MEMORY[0x1E4FBA408];
  uint64_t v37 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v42 + *(void *)(v42[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v43[0] = v37;
  v43[1] = MEMORY[0x1E4FBA470] + 16;
  if (v48 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A62391A0](&v51);
}

void sub_1A2087884(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void gss::ConditionalStyle<gss::PropertyID>::~ConditionalStyle(uint64_t a1)
{
  uint64_t v1 = a1;
  *(void *)a1 = &unk_1EF567428;
  uint64_t v2 = (void *)(a1 + 128);
  if (!*(unsigned char *)(a1 + 140) && *v2)
  {
    if (*(_WORD *)(a1 + 136))
    {
      uint64_t v3 = 24 * *(unsigned __int16 *)(a1 + 136);
      size_t v4 = (unsigned char *)(*v2 + 20);
      do
      {
        uint64_t v5 = v4 - 12;
        if (!*v4 && *v5)
        {
          uint64_t v6 = gss::Allocator::instance((gss::Allocator *)a1);
          a1 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v6 + 40))(v6, *(void *)(v4 - 12), 4 * *((unsigned __int16 *)v4 - 1));
        }
        *(void *)(v4 - 7) = 0;
        void *v5 = 0;
        v4 += 24;
        v3 -= 24;
      }
      while (v3);
    }
    uint64_t v7 = gss::Allocator::instance((gss::Allocator *)a1);
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v7 + 40))(v7, *(void *)(v1 + 128), 24 * *(unsigned __int16 *)(v1 + 138));
  }
  *(void *)((char *)v2 + 5) = 0;
  void *v2 = 0;
  gss::CartoStyle<gss::PropertyID>::~CartoStyle(v1);
  JUMPOUT(0x1A6239270);
}

uint64_t gss::ConditionalStyle<gss::PropertyID>::~ConditionalStyle(uint64_t a1)
{
  uint64_t v1 = a1;
  *(void *)a1 = &unk_1EF567428;
  uint64_t v2 = (void *)(a1 + 128);
  if (!*(unsigned char *)(a1 + 140) && *v2)
  {
    if (*(_WORD *)(a1 + 136))
    {
      uint64_t v3 = 24 * *(unsigned __int16 *)(a1 + 136);
      size_t v4 = (unsigned char *)(*v2 + 20);
      do
      {
        uint64_t v5 = v4 - 12;
        if (!*v4 && *v5)
        {
          uint64_t v6 = gss::Allocator::instance((gss::Allocator *)a1);
          a1 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v6 + 40))(v6, *(void *)(v4 - 12), 4 * *((unsigned __int16 *)v4 - 1));
        }
        *(void *)(v4 - 7) = 0;
        void *v5 = 0;
        v4 += 24;
        v3 -= 24;
      }
      while (v3);
    }
    uint64_t v7 = gss::Allocator::instance((gss::Allocator *)a1);
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v7 + 40))(v7, *(void *)(v1 + 128), 24 * *(unsigned __int16 *)(v1 + 138));
  }
  *(void *)((char *)v2 + 5) = 0;
  void *v2 = 0;
  return gss::CartoStyle<gss::PropertyID>::~CartoStyle(v1);
}

void gss::CartoStyle<gss::PropertyID>::to_string(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(void *)(a1 + 104)) {
    uint64_t v3 = *(const char **)(a1 + 104);
  }
  else {
    uint64_t v3 = "";
  }
  size_t v4 = strlen(v3);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  std::string::size_type v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    p_dst = (std::string *)operator new(v7 + 1);
    __dst.__r_.__value_.__l.__size_ = v5;
    __dst.__r_.__value_.__r.__words[2] = v8 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_11;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v4;
  p_dst = &__dst;
  if (v4) {
LABEL_11:
  }
    memmove(p_dst, v3, v5);
  p_dst->__r_.__value_.__s.__data_[v5] = 0;
  uint64_t v9 = std::string::insert(&__dst, 0, "[", 1uLL);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v13.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v13.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  uint64_t v11 = std::string::append(&v13, "]", 1uLL);
  *a2 = *v11;
  v11->__r_.__value_.__r.__words[0] = 0;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  if ((SHIBYTE(v13.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_16:
    operator delete(__dst.__r_.__value_.__l.__data_);
    return;
  }
  operator delete(v13.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_16;
  }
}

void sub_1A2087CA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void gss::CartoStyle<gss::PropertyID>::~CartoStyle(uint64_t a1)
{
  gss::CartoStyle<gss::PropertyID>::~CartoStyle(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_emplace<gss::ConditionalStyle<gss::PropertyID>,geo::StdAllocator<gss::ConditionalStyle<gss::PropertyID>,gss::Allocator>>::__on_zero_shared_weak(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a1, 192);
}

uint64_t std::__shared_ptr_emplace<gss::ConditionalStyle<gss::PropertyID>,geo::StdAllocator<gss::ConditionalStyle<gss::PropertyID>,gss::Allocator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))();
}

void std::__shared_ptr_emplace<gss::ConditionalStyle<gss::PropertyID>,geo::StdAllocator<gss::ConditionalStyle<gss::PropertyID>,gss::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A628;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gss::ConditionalStyle<gss::PropertyID>,geo::StdAllocator<gss::ConditionalStyle<gss::PropertyID>,gss::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A628;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::default_delete<geo::intern_allocator<gss::StyleCondition,geo::StdAllocator<gss::StyleCondition,gss::Allocator>>::PageInfo>::operator()[abi:nn180100](void *a1)
{
  uint64_t v1 = a1;
  if (a1[1])
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = *v1;
      uint64_t v5 = *v1 + v2;
      uint64_t v6 = (void *)(v5 + 8);
      if (!*(unsigned char *)(v5 + 20) && *v6)
      {
        uint64_t v7 = gss::Allocator::instance((gss::Allocator *)a1);
        a1 = (void *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v7 + 40))(v7, *v6, 4 * *(unsigned __int16 *)(v4 + v2 + 18));
      }
      *(void *)((char *)v6 + 5) = 0;
      *uint64_t v6 = 0;
      ++v3;
      v2 += 24;
    }
    while (v3 < v1[1]);
  }
  uint64_t v8 = gss::Allocator::instance((gss::Allocator *)a1);
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v8 + 40))(v8, *v1, 24 * v1[2]);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_emplace<gss::CartoStyle<gss::PropertyID>,geo::StdAllocator<gss::CartoStyle<gss::PropertyID>,gss::Allocator>>::__on_zero_shared_weak(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a1, 160);
}

uint64_t std::__shared_ptr_emplace<gss::CartoStyle<gss::PropertyID>,geo::StdAllocator<gss::CartoStyle<gss::PropertyID>,gss::Allocator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))();
}

void std::__shared_ptr_emplace<gss::CartoStyle<gss::PropertyID>,geo::StdAllocator<gss::CartoStyle<gss::PropertyID>,gss::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A468;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gss::CartoStyle<gss::PropertyID>,geo::StdAllocator<gss::CartoStyle<gss::PropertyID>,gss::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A468;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::function<BOOL ()(geo::ibitstream &,gss::StylePropertySet<gss::PropertyID> &,unsigned long long,gss::StylePropertyIndex,gss::DecodingContext const&,std::ostringstream &)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<gss::StylePropertySet<gss::PropertyID>,geo::StdAllocator<gss::StylePropertySet<gss::PropertyID>,gss::Allocator>>::__on_zero_shared_weak(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a1, 112);
}

uint64_t std::__shared_ptr_emplace<gss::StylePropertySet<gss::PropertyID>,geo::StdAllocator<gss::StylePropertySet<gss::PropertyID>,gss::Allocator>>::__on_zero_shared(uint64_t a1)
{
  return gss::StylePropertySet<gss::PropertyID>::~StylePropertySet(a1 + 32);
}

void std::__shared_ptr_emplace<gss::StylePropertySet<gss::PropertyID>,geo::StdAllocator<gss::StylePropertySet<gss::PropertyID>,gss::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A708;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gss::StylePropertySet<gss::PropertyID>,geo::StdAllocator<gss::StylePropertySet<gss::PropertyID>,gss::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A708;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<gss::GlobalProperties>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A6D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gss::GlobalProperties>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A6D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

__n128 std::__function::__func<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#2},std::allocator<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#2}>,void ()(BOOL)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF57EEF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#2},std::allocator<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#2}>,void ()(BOOL)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF57EEF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#2},std::allocator<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#2}>,void ()(BOOL)>::~__func()
{
}

uint64_t std::__function::__func<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#1},std::allocator<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#1}>,void ()(BOOL)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57EF40;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#1},std::allocator<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#1}>,void ()(BOOL)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF57EF40;
  result[1] = v3;
  return result;
}

void std::__function::__func<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#1},std::allocator<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#1}>,void ()(BOOL)>::~__func()
{
}

uint64_t std::__function::__func<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1},std::allocator<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}>,void ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 40;
  uint64_t result = *(void *)(a1 + 64);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t std::__function::__func<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1},std::allocator<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF57CD38;
  long long v3 = *(_OWORD *)(result + 8);
  *(_OWORD *)(a2 + 17) = *(_OWORD *)(result + 17);
  *(_OWORD *)(a2 + 8) = v3;
  uint64_t v4 = *(void *)(result + 64);
  if (v4)
  {
    if (v4 == result + 40)
    {
      *(void *)(a2 + 64) = a2 + 40;
      uint64_t v5 = *(uint64_t (**)(void))(**(void **)(result + 64) + 24);
      return v5();
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)v4 + 16))(*(void *)(result + 64));
      *(void *)(a2 + 64) = result;
    }
  }
  else
  {
    *(void *)(a2 + 64) = 0;
  }
  return result;
}

void std::__function::__func<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1},std::allocator<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF57CD38;
  uint64_t v1 = a1 + 5;
  uint64_t v2 = (void *)a1[8];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1},std::allocator<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}>,void ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF57CD38;
  uint64_t v2 = a1 + 5;
  long long v3 = (void *)a1[8];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  return a1;
}

void std::__function::__func<std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> gss::StyleManagerExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &)::{lambda(BOOL)#1},std::allocator<std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> gss::StyleManagerExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &)::{lambda(BOOL)#1}>,void ()(BOOL)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57CE58;
}

void *std::__function::__func<std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> gss::StyleManagerExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &)::{lambda(BOOL)#1},std::allocator<std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> gss::StyleManagerExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &)::{lambda(BOOL)#1}>,void ()(BOOL)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF57CE58;
  return result;
}

void std::__function::__func<std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> gss::StyleManagerExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &)::{lambda(BOOL)#1},std::allocator<std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> gss::StyleManagerExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &)::{lambda(BOOL)#1}>,void ()(BOOL)>::~__func()
{
}

uint64_t *std::unique_ptr<std::vector<std::function<void ()(BOOL)>,geo::StdAllocator<std::function<void ()(BOOL)>,gss::Allocator>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    long long v3 = *(void **)v2;
    if (*(void *)v2)
    {
      uint64_t v4 = *(void **)(v2 + 8);
      uint64_t v5 = *(void **)v2;
      if (v4 != v3)
      {
        uint64_t v6 = v4 - 4;
        uint64_t v7 = v4 - 4;
        do
        {
          uint64_t v9 = (void *)v7[3];
          if (v7 == v9)
          {
            (*(void (**)(void *))(*v7 + 32))(v7);
          }
          else if (v9)
          {
            (*(void (**)(void *, void *))(*v9 + 40))(v9, v5);
          }
          v6 -= 4;
          BOOL v8 = v7 == v3;
          v7 -= 4;
        }
        while (!v8);
        uint64_t v5 = *(void **)v2;
      }
      *(void *)(v2 + 8) = v3;
      (*(void (**)(void, void *, void))(**(void **)(v2 + 24) + 40))(*(void *)(v2 + 24), v5, *(void *)(v2 + 16) - (void)v5);
    }
    MEMORY[0x1A6239270](v2, 0x20C40DC1BFBCFLL);
  }
  return a1;
}

gss::Allocator *std::unordered_map<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>,std::hash<gss::StyleSheetResultCacheKey>,std::equal_to<gss::StyleSheetResultCacheKey>,geo::StdAllocator<std::pair<gss::StyleSheetResultCacheKey const,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,gss::Allocator>>::~unordered_map[abi:nn180100](gss::Allocator *a1)
{
  std::__hash_table<std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,std::__unordered_map_hasher<gss::StyleSheetResultCacheKey,std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,std::hash<gss::StyleSheetResultCacheKey>,std::equal_to<gss::StyleSheetResultCacheKey>,true>,std::__unordered_map_equal<gss::StyleSheetResultCacheKey,std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,std::equal_to<gss::StyleSheetResultCacheKey>,std::hash<gss::StyleSheetResultCacheKey>,true>,geo::StdAllocator<std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,gss::Allocator>>::__deallocate_node(a1, *((void **)a1 + 3));
  uint64_t v2 = *(void *)a1;
  *(void *)a1 = 0;
  if (v2) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 2) + 40))(*((void *)a1 + 2), v2, 8 * *((void *)a1 + 1));
  }
  return a1;
}

uint64_t gss::InternAllocators<gss::PropertyID>::~InternAllocators(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 216);
  if (v2)
  {
    long long v3 = *(void **)(a1 + 224);
    uint64_t v4 = *(void **)(a1 + 216);
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = (void *)*--v3;
        uint64_t v5 = v6;
        *long long v3 = 0;
        if (v6) {
          std::default_delete<geo::intern_allocator<gss::StyleCondition,geo::StdAllocator<gss::StyleCondition,gss::Allocator>>::PageInfo>::operator()[abi:nn180100](v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 216);
    }
    *(void *)(a1 + 224) = v2;
    operator delete(v4);
  }
  uint64_t v7 = *(void **)(a1 + 184);
  if (v7)
  {
    BOOL v8 = *(void **)(a1 + 192);
    uint64_t v9 = *(gss::Allocator **)(a1 + 184);
    if (v8 != v7)
    {
      do
      {
        uint64_t v11 = (void *)*--v8;
        long long v10 = v11;
        *BOOL v8 = 0;
        if (v11)
        {
          uint64_t v12 = gss::Allocator::instance(v9);
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)v12 + 40))(v12, *v10, 4 * v10[2]);
          uint64_t v9 = (gss::Allocator *)MEMORY[0x1A6239270](v10, 0x1010C40113C0ABBLL);
        }
      }
      while (v8 != v7);
      uint64_t v9 = *(gss::Allocator **)(a1 + 184);
    }
    *(void *)(a1 + 192) = v7;
    operator delete(v9);
  }
  uint64_t v13 = *(void *)(a1 + 152);
  if (v13)
  {
    uint64_t v14 = *(void *)(a1 + 160);
    uint64_t v15 = *(void **)(a1 + 152);
    if (v14 != v13)
    {
      do
      {
        int v16 = *(std::__shared_weak_count **)(v14 - 8);
        if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
        v14 -= 16;
      }
      while (v14 != v13);
      uint64_t v15 = *(void **)(a1 + 152);
    }
    *(void *)(a1 + 160) = v13;
    operator delete(v15);
  }
  uint64_t v17 = *(void *)(a1 + 120);
  if (v17)
  {
    uint64_t v18 = *(void *)(a1 + 128);
    uint64_t v19 = *(void **)(a1 + 120);
    if (v18 != v17)
    {
      do
      {
        BOOL v20 = *(std::__shared_weak_count **)(v18 - 8);
        if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
        v18 -= 16;
      }
      while (v18 != v17);
      uint64_t v19 = *(void **)(a1 + 120);
    }
    *(void *)(a1 + 128) = v17;
    operator delete(v19);
  }
  size_t v22 = (void **)(a1 + 80);
  std::vector<std::unique_ptr<unsigned char,std::function<void ()(unsigned char *)>>>::__destroy_vector::operator()[abi:nn180100](&v22);
  size_t v22 = (void **)(a1 + 40);
  std::vector<std::unique_ptr<unsigned char,std::function<void ()(unsigned char *)>>>::__destroy_vector::operator()[abi:nn180100](&v22);
  size_t v22 = (void **)a1;
  std::vector<std::unique_ptr<unsigned char,std::function<void ()(unsigned char *)>>>::__destroy_vector::operator()[abi:nn180100](&v22);
  return a1;
}

gss::Allocator **std::unique_ptr<gss::StyleMatchingTree<gss::CartoStyle<gss::PropertyID>>>::~unique_ptr[abi:nn180100](gss::Allocator **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    long long v3 = gss::StyleMatchingTree<gss::CartoStyle<gss::PropertyID>>::~StyleMatchingTree(v2);
    MEMORY[0x1A6239270](v3, 0x1020C40FE16DC66);
  }
  return a1;
}

void std::vector<std::unique_ptr<unsigned char,std::function<void ()(unsigned char *)>>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 4;
      uint64_t v7 = v1[1];
      while (1)
      {
        uint64_t v9 = *(v7 - 5);
        v7 -= 5;
        uint64_t v8 = v9;
        *uint64_t v7 = 0;
        if (v9)
        {
          uint64_t v14 = v8;
          uint64_t v10 = *(v4 - 1);
          if (!v10)
          {
            std::__throw_bad_function_call[abi:nn180100]();
            std::__hash_table<std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,std::__unordered_map_hasher<gss::StyleSheetResultCacheKey,std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,std::hash<gss::StyleSheetResultCacheKey>,std::equal_to<gss::StyleSheetResultCacheKey>,true>,std::__unordered_map_equal<gss::StyleSheetResultCacheKey,std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,std::equal_to<gss::StyleSheetResultCacheKey>,std::hash<gss::StyleSheetResultCacheKey>,true>,geo::StdAllocator<std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,gss::Allocator>>::__deallocate_node(v12, v13);
            return;
          }
          (*(void (**)(uint64_t, uint64_t *))(*(void *)v10 + 48))(v10, &v14);
        }
        uint64_t v11 = (void *)*(v4 - 1);
        if (v4 - 4 == v11)
        {
          (*(void (**)(void *))(*(v4 - 4) + 32))(v4 - 4);
        }
        else if (v11)
        {
          (*(void (**)(void *))(*v11 + 40))(v11);
        }
        v6 -= 5;
        uint64_t v4 = v7;
        if (v7 == v2)
        {
          uint64_t v5 = **a1;
          break;
        }
      }
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

gss::Allocator *std::__hash_table<std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,std::__unordered_map_hasher<gss::StyleSheetResultCacheKey,std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,std::hash<gss::StyleSheetResultCacheKey>,std::equal_to<gss::StyleSheetResultCacheKey>,true>,std::__unordered_map_equal<gss::StyleSheetResultCacheKey,std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,std::equal_to<gss::StyleSheetResultCacheKey>,std::hash<gss::StyleSheetResultCacheKey>,true>,geo::StdAllocator<std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,gss::Allocator>>::__deallocate_node(gss::Allocator *result, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    long long v3 = result;
    do
    {
      uint64_t v4 = v2;
      uint64_t v2 = (void *)*v2;
      uint64_t v5 = (std::__shared_weak_count *)v4[5];
      if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
      if (!*((unsigned char *)v4 + 30))
      {
        if (v4[2])
        {
          uint64_t v6 = gss::Allocator::instance(result);
          (*(void (**)(uint64_t, void, void))(*(void *)v6 + 40))(v6, v4[2], *((unsigned __int16 *)v4 + 14));
          void v4[2] = 0;
        }
      }
      uint64_t result = (gss::Allocator *)(*(uint64_t (**)(void, void *, uint64_t))(**((void **)v3 + 4) + 40))(*((void *)v3 + 4), v4, 48);
    }
    while (v2);
  }
  return result;
}

void std::__shared_ptr_emplace<gss::StyleSheet<gss::PropertyID>>::__on_zero_shared(uint64_t a1)
{
  if (*(char *)(a1 + 3023) < 0) {
    operator delete(*(void **)(a1 + 3000));
  }
  uint64_t v2 = *(void *)(a1 + 2984);
  *(void *)(a1 + 2984) = 0;
  if (v2)
  {
    long long v3 = *(void **)v2;
    if (*(void *)v2)
    {
      uint64_t v4 = *(void **)(v2 + 8);
      uint64_t v5 = *(void **)v2;
      if (v4 != v3)
      {
        uint64_t v6 = v4 - 4;
        uint64_t v7 = v4 - 4;
        do
        {
          uint64_t v9 = (void *)v7[3];
          if (v7 == v9)
          {
            (*(void (**)(void *))(*v7 + 32))(v7);
          }
          else if (v9)
          {
            (*(void (**)(void *, void *))(*v9 + 40))(v9, v5);
          }
          v6 -= 4;
          BOOL v8 = v7 == v3;
          v7 -= 4;
        }
        while (!v8);
        uint64_t v5 = *(void **)v2;
      }
      *(void *)(v2 + 8) = v3;
      (*(void (**)(void, void *, void))(**(void **)(v2 + 24) + 40))(*(void *)(v2 + 24), v5, *(void *)(v2 + 16) - (void)v5);
    }
    MEMORY[0x1A6239270](v2, 0x20C40DC1BFBCFLL);
  }
  uint64_t v10 = *(void *)(a1 + 2976);
  *(void *)(a1 + 2976) = 0;
  if (v10)
  {
    uint64_t v11 = *(void **)v10;
    if (*(void *)v10)
    {
      uint64_t v12 = *(void **)(v10 + 8);
      uint64_t v13 = *(void **)v10;
      if (v12 != v11)
      {
        uint64_t v14 = v12 - 4;
        uint64_t v15 = v12 - 4;
        do
        {
          int v16 = (void *)v15[3];
          if (v15 == v16)
          {
            (*(void (**)(void *))(*v15 + 32))(v15);
          }
          else if (v16)
          {
            (*(void (**)(void *, void *))(*v16 + 40))(v16, v13);
          }
          v14 -= 4;
          BOOL v8 = v15 == v11;
          v15 -= 4;
        }
        while (!v8);
        uint64_t v13 = *(void **)v10;
      }
      *(void *)(v10 + 8) = v11;
      (*(void (**)(void, void *, void))(**(void **)(v10 + 24) + 40))(*(void *)(v10 + 24), v13, *(void *)(v10 + 16) - (void)v13);
    }
    MEMORY[0x1A6239270](v10, 0x20C40DC1BFBCFLL);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 2912));
  std::mutex::~mutex((std::mutex *)(a1 + 2848));
  std::future<void>::~future((std::future<void> *)(a1 + 2840));
  std::future<void>::~future((std::future<void> *)(a1 + 2832));
  MEMORY[0x1A62390B0](a1 + 2824);
  MEMORY[0x1A62390B0](a1 + 2816);
  std::__hash_table<std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,std::__unordered_map_hasher<gss::StyleSheetResultCacheKey,std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,std::hash<gss::StyleSheetResultCacheKey>,std::equal_to<gss::StyleSheetResultCacheKey>,true>,std::__unordered_map_equal<gss::StyleSheetResultCacheKey,std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,std::equal_to<gss::StyleSheetResultCacheKey>,std::hash<gss::StyleSheetResultCacheKey>,true>,geo::StdAllocator<std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,gss::Allocator>>::__deallocate_node((gss::Allocator *)(a1 + 2752), *(void **)(a1 + 2776));
  uint64_t v17 = *(void *)(a1 + 2752);
  *(void *)(a1 + 2752) = 0;
  if (v17) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 2768) + 40))(*(void *)(a1 + 2768), v17, 8 * *(void *)(a1 + 2760));
  }
  uint64_t v18 = (geo::read_write_lock *)pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 2552));
  if (v18) {
    geo::read_write_lock::logFailure(v18, (uint64_t)"destruction", v19);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 2488));
  std::mutex::~mutex((std::mutex *)(a1 + 2424));
  std::mutex::~mutex((std::mutex *)(a1 + 2360));
  std::mutex::~mutex((std::mutex *)(a1 + 2296));
  std::mutex::~mutex((std::mutex *)(a1 + 2232));
  std::mutex::~mutex((std::mutex *)(a1 + 2168));
  std::mutex::~mutex((std::mutex *)(a1 + 2104));
  std::mutex::~mutex((std::mutex *)(a1 + 2040));
  std::mutex::~mutex((std::mutex *)(a1 + 1976));
  std::mutex::~mutex((std::mutex *)(a1 + 1912));
  std::mutex::~mutex((std::mutex *)(a1 + 1848));
  std::mutex::~mutex((std::mutex *)(a1 + 1784));
  std::mutex::~mutex((std::mutex *)(a1 + 1720));
  std::mutex::~mutex((std::mutex *)(a1 + 1656));
  std::mutex::~mutex((std::mutex *)(a1 + 1592));
  std::mutex::~mutex((std::mutex *)(a1 + 1528));
  std::mutex::~mutex((std::mutex *)(a1 + 1464));
  std::mutex::~mutex((std::mutex *)(a1 + 1400));
  std::mutex::~mutex((std::mutex *)(a1 + 1336));
  std::mutex::~mutex((std::mutex *)(a1 + 1272));
  std::mutex::~mutex((std::mutex *)(a1 + 1208));
  std::mutex::~mutex((std::mutex *)(a1 + 1144));
  std::mutex::~mutex((std::mutex *)(a1 + 1080));
  std::mutex::~mutex((std::mutex *)(a1 + 1016));
  std::mutex::~mutex((std::mutex *)(a1 + 952));
  std::mutex::~mutex((std::mutex *)(a1 + 888));
  std::mutex::~mutex((std::mutex *)(a1 + 824));
  std::mutex::~mutex((std::mutex *)(a1 + 760));
  std::mutex::~mutex((std::mutex *)(a1 + 696));
  std::mutex::~mutex((std::mutex *)(a1 + 632));
  std::mutex::~mutex((std::mutex *)(a1 + 568));
  std::mutex::~mutex((std::mutex *)(a1 + 504));
  gss::InternAllocators<gss::PropertyID>::~InternAllocators(a1 + 256);
  std::mutex::~mutex((std::mutex *)(a1 + 192));
  BOOL v20 = *(gss::Allocator **)(a1 + 184);
  *(void *)(a1 + 184) = 0;
  if (v20)
  {
    uint64_t v21 = gss::StyleMatchingTree<gss::CartoStyle<gss::PropertyID>>::~StyleMatchingTree(v20);
    BOOL v20 = (gss::Allocator *)MEMORY[0x1A6239270](v21, 0x1020C40FE16DC66);
  }
  size_t v22 = (void *)(a1 + 168);
  if (!*(unsigned char *)(a1 + 180) && *v22)
  {
    if (*(_WORD *)(a1 + 176))
    {
      uint64_t v23 = 16 * *(unsigned __int16 *)(a1 + 176);
      uint64_t v24 = (std::__shared_weak_count **)(*v22 + 8);
      do
      {
        uint64_t v25 = *v24;
        if (*v24 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
        v24 += 2;
        v23 -= 16;
      }
      while (v23);
    }
    uint64_t v26 = gss::Allocator::instance(v20);
    BOOL v20 = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v26 + 40))(v26, *(void *)(a1 + 168), 16 * *(unsigned __int16 *)(a1 + 178));
  }
  *(void *)(a1 + 173) = 0;
  void *v22 = 0;
  uint64_t v27 = *(std::__shared_weak_count **)(a1 + 152);
  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
    uint64_t v28 = *(std::__shared_weak_count **)(a1 + 136);
    if (!v28) {
      goto LABEL_48;
    }
  }
  else
  {
    uint64_t v28 = *(std::__shared_weak_count **)(a1 + 136);
    if (!v28) {
      goto LABEL_48;
    }
  }
  if (!atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
LABEL_48:
  size_t v29 = *(std::__shared_weak_count **)(a1 + 120);
  if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  double v30 = (void *)(a1 + 88);
  if (!*(unsigned char *)(a1 + 100) && *v30)
  {
    if (*(_WORD *)(a1 + 96))
    {
      uint64_t v31 = 16 * *(unsigned __int16 *)(a1 + 96);
      unsigned int v32 = (std::__shared_weak_count **)(*v30 + 8);
      do
      {
        BOOL v33 = *v32;
        if (*v32 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
        v32 += 2;
        v31 -= 16;
      }
      while (v31);
    }
    uint64_t v34 = gss::Allocator::instance(v20);
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v34 + 40))(v34, *(void *)(a1 + 88), 16 * *(unsigned __int16 *)(a1 + 98));
  }
  *(void *)(a1 + 93) = 0;
  *double v30 = 0;
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v35 = *(std::__shared_weak_count **)(a1 + 48);
  if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
    double v36 = *(std::__shared_weak_count **)(a1 + 32);
    if (!v36) {
      return;
    }
  }
  else
  {
    double v36 = *(std::__shared_weak_count **)(a1 + 32);
    if (!v36) {
      return;
    }
  }
  std::__shared_weak_count::__release_weak(v36);
}

void std::__shared_ptr_emplace<gss::StyleSheet<gss::PropertyID>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A510;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gss::StyleSheet<gss::PropertyID>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A510;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::pair<md::StylesheetKey,std::shared_ptr<gss::StyleSheet<gss::PropertyID>>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
      return a1;
    }
    goto LABEL_4;
  }
  if (*(char *)(a1 + 23) < 0) {
LABEL_4:
  }
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::__split_buffer<std::pair<md::StylesheetKey,std::shared_ptr<gss::StyleSheet<gss::PropertyID>>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 48;
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    if (*(char *)(i - 25) < 0) {
      operator delete(*(void **)(i - 48));
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t md::StyleSheetExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &,VKResourceManager *,BOOL)::{lambda(BOOL)#1}::~VKResourceManager(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  *(void *)a1 = &unk_1EF559D98;

  return a1;
}

void std::__function::__func<std::shared_ptr<gss::StyleSheet<gss::PropertyID>> md::StyleSheetExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &,VKResourceManager *,BOOL)::{lambda(BOOL)#1},std::allocator<std::shared_ptr<gss::StyleSheet<gss::PropertyID>> md::StyleSheetExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &,VKResourceManager *,BOOL)::{lambda(BOOL)#1}>,void ()(BOOL)>::destroy(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  *(void *)(a1 + 8) = &unk_1EF559D98;
  uint64_t v2 = *(void **)(a1 + 16);
}

std::string *std::__function::__func<std::shared_ptr<gss::StyleSheet<gss::PropertyID>> md::StyleSheetExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &,VKResourceManager *,BOOL)::{lambda(BOOL)#1},std::allocator<std::shared_ptr<gss::StyleSheet<gss::PropertyID>> md::StyleSheetExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &,VKResourceManager *,BOOL)::{lambda(BOOL)#1}>,void ()(BOOL)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF574E50;
  return std::__compressed_pair_elem<std::shared_ptr<gss::StyleSheet<gss::PropertyID>> md::StyleSheetExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &,VKResourceManager *,BOOL)::{lambda(BOOL)#1},0,false>::__compressed_pair_elem[abi:nn180100]<std::shared_ptr<gss::StyleSheet<gss::PropertyID>> md::StyleSheetExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &,VKResourceManager *,BOOL)::{lambda(BOOL)#1} const&,0ul>((std::string *)(a2 + 8), a1 + 8);
}

void std::__function::__func<std::shared_ptr<gss::StyleSheet<gss::PropertyID>> md::StyleSheetExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &,VKResourceManager *,BOOL)::{lambda(BOOL)#1},std::allocator<std::shared_ptr<gss::StyleSheet<gss::PropertyID>> md::StyleSheetExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &,VKResourceManager *,BOOL)::{lambda(BOOL)#1}>,void ()(BOOL)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF574E50;

  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  *(void *)(a1 + 8) = &unk_1EF559D98;

  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<std::shared_ptr<gss::StyleSheet<gss::PropertyID>> md::StyleSheetExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &,VKResourceManager *,BOOL)::{lambda(BOOL)#1},std::allocator<std::shared_ptr<gss::StyleSheet<gss::PropertyID>> md::StyleSheetExtension::initWithName<gss::PropertyID>(std::string const&,float,gss::TargetDisplay,md::StylesheetVendor &,VKResourceManager *,BOOL)::{lambda(BOOL)#1}>,void ()(BOOL)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF574E50;

  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  *(void *)(a1 + 8) = &unk_1EF559D98;

  return a1;
}

void geo::_retain_ptr<NSData * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559D98;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<NSData * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559D98;

  return a1;
}

void sub_1A2089C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  grl::IconModifiers::~IconModifiers((grl::IconModifiers *)&a30);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a22);
  grl::IconRequestOptions::~IconRequestOptions((grl::IconRequestOptions *)&a24);

  _Unwind_Resume(a1);
}

void sub_1A2089DA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<grl::FontManager  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<grl::FontManager  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t altitude::GEODataCacheNode::getCacheKeyForKey@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  *(_OWORD *)a3 = *a2;
  *(_OWORD *)(a3 + 16) = v5;
  uint64_t result = altitude::GeoResourceManager::getTileIdWithDataForTileId(*(void *)(*(void *)(a1 + 160) + 32), a2 + 1, v4);
  *(void *)(a3 + 16) = result;
  *(void *)(a3 + 24) = v7;
  return result;
}

void altitude::GEODataCacheNode::fetchData(uint64_t a1@<X1>, void *a2@<X8>)
{
  long long v4 = *(void **)a1;
  long long v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (((*(uint64_t (**)(void *))(*v4 + 40))(v4) & 1) == 0)
  {
    *a2 = 0;
    a2[1] = 0;
    if (!v3) {
      return;
    }
    goto LABEL_9;
  }
  uint64_t v5 = v4[35];
  *a2 = v4[34];
  a2[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  if (v3)
  {
LABEL_9:
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_1A208A06C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t altitude::GenericCacheNode<altitude::TileKey,altitude::GEOTileDataPrivate>::hasValidKey()
{
  return 1;
}

uint64_t altitude::GenericCacheNode<altitude::TileKey,altitude::GEOTileDataPrivate>::clear(uint64_t a1)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 136));
  if (*(void *)(a1 + 120))
  {
    uint64_t v2 = *(void **)(a1 + 112);
    if (v2)
    {
      do
      {
        uint64_t v7 = (void *)*v2;
        BOOL v8 = (std::__shared_weak_count *)v2[7];
        if (v8) {
          std::__shared_weak_count::__release_weak(v8);
        }
        operator delete(v2);
        uint64_t v2 = v7;
      }
      while (v7);
    }
    *(void *)(a1 + 112) = 0;
    uint64_t v3 = *(void *)(a1 + 104);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*(void *)(a1 + 96) + 8 * i) = 0;
    }
    *(void *)(a1 + 120) = 0;
  }
  uint64_t v5 = *(pthread_mutex_t **)(a1 + 136);
  return pthread_mutex_unlock(v5);
}

BOOL altitude::GEODataCacheNode::hasDataAvailable(uint64_t a1, long long *a2)
{
  return altitude::GeoResourceManager::getTileIdWithDataForTileId(*(void *)(*(void *)(a1 + 160) + 32), a2 + 1, *(unsigned int *)a2) != 0;
}

void altitude::GenericCacheNode<altitude::TileKey,altitude::GEOTileDataPrivate>::requestCached(uint64_t a1@<X0>, _OWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1) & 1) == 0)
  {
    *a5 = 0;
    a5[1] = 0;
    a5[3] = 0;
    a5[4] = 0;
    a5[2] = off_1EF5677B0;
    return;
  }
  (*(void (**)(void **__return_ptr, uint64_t, _OWORD *))(*(void *)a1 + 144))(__p, a1, a2);
  long long v10 = a2[1];
  v62[0] = *a2;
  v62[1] = v10;
  long long v63 = *(_OWORD *)__p;
  long long v64 = v61;
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 136));
  int8x8_t v11 = *(int8x8_t *)(a1 + 104);
  if (!*(void *)&v11) {
    goto LABEL_40;
  }
  unint64_t v12 = ((unint64_t)v64 << 58) | ((unint64_t)(DWORD1(v64) & 0x1FFFFFFF) << 29) | DWORD2(v64) & 0x1FFFFFFF;
  uint8x8_t v13 = (uint8x8_t)vcnt_s8(v11);
  v13.i16[0] = vaddlv_u8(v13);
  if (v13.u32[0] > 1uLL)
  {
    unint64_t v14 = ((unint64_t)v64 << 58) | ((unint64_t)(DWORD1(v64) & 0x1FFFFFFF) << 29) | DWORD2(v64) & 0x1FFFFFFF;
    if (v12 >= *(void *)&v11) {
      unint64_t v14 = v12 % *(void *)&v11;
    }
  }
  else
  {
    unint64_t v14 = v12 & (*(void *)&v11 - 1);
  }
  uint64_t v15 = *(uint64_t ***)(*(void *)(a1 + 96) + 8 * v14);
  if (!v15) {
    goto LABEL_40;
  }
  int v16 = *v15;
  if (!*v15) {
    goto LABEL_40;
  }
  if (v13.u32[0] < 2uLL)
  {
    uint64_t v17 = *(void *)&v11 - 1;
    while (1)
    {
      uint64_t v19 = v16[1];
      if (v19 == v12)
      {
        if (*((_DWORD *)v16 + 8) == v64
          && *(uint64_t *)((char *)v16 + 36) == *(void *)((char *)&v64 + 4)
          && HIDWORD(v64) == *((_DWORD *)v16 + 11)
          && *((_DWORD *)v16 + 4) == v63
          && *(uint64_t *)((char *)v16 + 20) == *(void *)((char *)&v63 + 4))
        {
          goto LABEL_31;
        }
      }
      else if ((v19 & v17) != v14)
      {
        goto LABEL_40;
      }
      int v16 = (uint64_t *)*v16;
      if (!v16) {
        goto LABEL_40;
      }
    }
  }
  while (1)
  {
    unint64_t v18 = v16[1];
    if (v18 == v12) {
      break;
    }
    if (v18 >= *(void *)&v11) {
      v18 %= *(void *)&v11;
    }
    if (v18 != v14) {
      goto LABEL_40;
    }
LABEL_13:
    int v16 = (uint64_t *)*v16;
    if (!v16) {
      goto LABEL_40;
    }
  }
  if (*((_DWORD *)v16 + 8) != v64
    || *(uint64_t *)((char *)v16 + 36) != *(void *)((char *)&v64 + 4)
    || HIDWORD(v64) != *((_DWORD *)v16 + 11)
    || *((_DWORD *)v16 + 4) != v63
    || *(uint64_t *)((char *)v16 + 20) != *(void *)((char *)&v63 + 4))
  {
    goto LABEL_13;
  }
LABEL_31:
  if (((*(uint64_t (**)(uint64_t, long long *, uint64_t *))(*(void *)a1 + 128))(a1, &v63, v16 + 2) & 1) == 0)
  {
    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)__p, (void *)(a1 + 96), v16);
    uint64_t v23 = __p[0];
    if (__p[0])
    {
      if ((_BYTE)v61)
      {
        uint64_t v24 = (std::__shared_weak_count *)*((void *)__p[0] + 7);
        if (v24) {
          std::__shared_weak_count::__release_weak(v24);
        }
      }
      operator delete(v23);
    }
    goto LABEL_40;
  }
  BOOL v20 = (std::__shared_weak_count *)v16[7];
  if (!v20)
  {
LABEL_40:
    uint64_t v58 = 0;
    unsigned int v59 = 0;
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 136));
    goto LABEL_41;
  }
  uint64_t v21 = v16[6];
  atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  uint64_t v58 = 0;
  size_t v22 = std::__shared_weak_count::lock(v20);
  unsigned int v59 = v22;
  if (v22) {
    uint64_t v58 = v21;
  }
  else {
    uint64_t v21 = 0;
  }
  std::__shared_weak_count::__release_weak(v20);
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 136));
  if (v21)
  {
    __p[1] = 0;
    *(void *)&long long v61 = 0;
    __p[0] = off_1EF5677B0;
    *a5 = v21;
    a5[1] = v22;
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    a5[3] = 0;
    a5[4] = 0;
    a5[2] = off_1EF5677B0;
    if (!v22) {
      return;
    }
LABEL_90:
    if (!atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
    return;
  }
LABEL_41:
  (*(void (**)(void (***__return_ptr)(karo::AsyncRequestManager::RequestHandle *__hidden), uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 80))(&v55, a1, v62, a3, a4, 300, 1, 0);
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v55) == 4)
  {
    char v52 = 0;
    uint64_t v53 = 0;
    uint64_t v54 = 0;
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, _OWORD *, void **))(*(void *)a1 + 136))(&v50, a1, &v56, v62, &v52);
    pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 136));
    uint64_t v25 = std::__hash_table<std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>,std::__unordered_map_hasher<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>,std::hash<altitude::TileKey>,std::equal_to<altitude::TileKey>,true>,std::__unordered_map_equal<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>,std::equal_to<altitude::TileKey>,std::hash<altitude::TileKey>,true>,std::allocator<std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>>>::__emplace_unique_key_args<altitude::TileKey,std::piecewise_construct_t const&,std::tuple<altitude::TileKey const&>,std::tuple<>>((uint64_t *)(a1 + 96), (int *)&v63, &v63);
    uint64_t v27 = v50;
    uint64_t v26 = v51;
    if (v51) {
      atomic_fetch_add_explicit(&v51->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v28 = (std::__shared_weak_count *)v25[7];
    v25[6] = v27;
    v25[7] = v26;
    if (v28) {
      std::__shared_weak_count::__release_weak(v28);
    }
    size_t v29 = (int *)v52;
    if (v52 != v53)
    {
      do
      {
        double v30 = std::__hash_table<std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>,std::__unordered_map_hasher<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>,std::hash<altitude::TileKey>,std::equal_to<altitude::TileKey>,true>,std::__unordered_map_equal<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>,std::equal_to<altitude::TileKey>,std::hash<altitude::TileKey>,true>,std::allocator<std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>>>::__emplace_unique_key_args<altitude::TileKey,std::piecewise_construct_t const&,std::tuple<altitude::TileKey const&>,std::tuple<>>((uint64_t *)(a1 + 96), v29, v29);
        uint64_t v32 = v50;
        uint64_t v31 = v51;
        if (v51) {
          atomic_fetch_add_explicit(&v51->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        BOOL v33 = (std::__shared_weak_count *)v30[7];
        v30[6] = v32;
        v30[7] = v31;
        if (v33) {
          std::__shared_weak_count::__release_weak(v33);
        }
        v29 += 8;
      }
      while (v29 != v53);
    }
    unsigned int v36 = *(_DWORD *)(a1 + 144) + 1;
    *(_DWORD *)(a1 + 144) = v36;
    if (v36 > 0x14)
    {
      *(_DWORD *)(a1 + 144) = 0;
      for (uint64_t i = *(void **)(a1 + 112); i; uint64_t i = (void *)*i)
      {
        while (1)
        {
          double v38 = (std::__shared_weak_count *)i[7];
          if (!v38) {
            goto LABEL_69;
          }
          __double2 v39 = std::__shared_weak_count::lock(v38);
          if (!v39) {
            goto LABEL_69;
          }
          uint64_t v40 = v39;
          uint64_t v41 = i[6];
          if (atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            break;
          }
          ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
          std::__shared_weak_count::__release_weak(v40);
          if (v41) {
            goto LABEL_66;
          }
LABEL_69:
          float v42 = (void *)*i;
          std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)__p, (void *)(a1 + 96), i);
          __double2 v43 = __p[0];
          if (__p[0])
          {
            if ((_BYTE)v61)
            {
              double v44 = (std::__shared_weak_count *)*((void *)__p[0] + 7);
              if (v44) {
                std::__shared_weak_count::__release_weak(v44);
              }
            }
            operator delete(v43);
          }
          uint64_t i = v42;
          if (!v42) {
            goto LABEL_73;
          }
        }
        if (!v41) {
          goto LABEL_69;
        }
LABEL_66:
        ;
      }
    }
LABEL_73:
    uint64_t v45 = v51;
    *a5 = v50;
    a5[1] = v45;
    if (v45) {
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v46 = v56;
    double v47 = v57;
    a5[2] = off_1EF5677B0;
    a5[3] = v46;
    a5[4] = v47;
    if (v47)
    {
      atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v46 = a5[3];
    }
    if (v46) {
      atomic_fetch_add((atomic_uint *volatile)(v46 + 128), 1u);
    }
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 136));
    char v48 = v51;
    if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
    if (v52)
    {
      uint64_t v53 = v52;
      operator delete(v52);
    }
  }
  else
  {
    *a5 = 0;
    a5[1] = 0;
    uint64_t v34 = v56;
    uint64_t v35 = v57;
    a5[2] = off_1EF5677B0;
    a5[3] = v34;
    a5[4] = v35;
    if (v35)
    {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v34 = a5[3];
    }
    if (v34) {
      atomic_fetch_add((atomic_uint *volatile)(v34 + 128), 1u);
    }
  }
  size_t v55 = off_1EF5677B0;
  if (v56) {
    atomic_fetch_add((atomic_uint *volatile)(v56 + 128), 0xFFFFFFFF);
  }
  unint64_t v49 = v57;
  if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
    std::__shared_weak_count::__release_weak(v49);
  }
  size_t v22 = v59;
  if (v59) {
    goto LABEL_90;
  }
}

void sub_1A208A8E0(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(*(pthread_mutex_t **)(v1 + 136));
  _Unwind_Resume(a1);
}

void sub_1A208A8F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char a17)
{
  pthread_mutex_unlock(*(pthread_mutex_t **)(v17 + 136));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  if (__p)
  {
    a12 = (uint64_t)__p;
    operator delete(__p);
  }
  karo::AsyncRequestManager::RequestHandle::~RequestHandle((karo::AsyncRequestManager::RequestHandle *)&a14);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>,std::__unordered_map_hasher<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>,std::hash<altitude::TileKey>,std::equal_to<altitude::TileKey>,true>,std::__unordered_map_equal<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>,std::equal_to<altitude::TileKey>,std::hash<altitude::TileKey>,true>,std::allocator<std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>>>::__emplace_unique_key_args<altitude::TileKey,std::piecewise_construct_t const&,std::tuple<altitude::TileKey const&>,std::tuple<>>(uint64_t *a1, int *a2, _OWORD *a3)
{
  uint64_t v6 = a2[4];
  unsigned int v7 = a2[5];
  int v8 = a2[6];
  unint64_t v9 = (v6 << 58) | ((unint64_t)(v7 & 0x1FFFFFFF) << 29) | v8 & 0x1FFFFFFF;
  unint64_t v10 = a1[1];
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = (v6 << 58) | ((unint64_t)(v7 & 0x1FFFFFFF) << 29) | v8 & 0x1FFFFFFF;
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
    }
    else
    {
      unint64_t v3 = v9 & (v10 - 1);
    }
    unint64_t v12 = *(void ***)(*a1 + 8 * v3);
    if (v12)
    {
      uint8x8_t v13 = *v12;
      if (*v12)
      {
        int v14 = a2[7];
        int v15 = *a2;
        int v16 = a2[1];
        int v17 = a2[2];
        if (v11.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v19 = v13[1];
            if (v19 == v9)
            {
              if (v13[4] == __PAIR64__(v7, v6)
                && *((_DWORD *)v13 + 10) == v8
                && v14 == *((_DWORD *)v13 + 11)
                && *((_DWORD *)v13 + 4) == v15
                && *((_DWORD *)v13 + 5) == v16
                && *((_DWORD *)v13 + 6) == v17)
              {
                return v13;
              }
            }
            else if ((v19 & (v10 - 1)) != v3)
            {
              goto LABEL_33;
            }
            uint8x8_t v13 = (void *)*v13;
            if (!v13) {
              goto LABEL_33;
            }
          }
        }
        do
        {
          unint64_t v18 = v13[1];
          if (v18 == v9)
          {
            if (v13[4] == __PAIR64__(v7, v6)
              && *((_DWORD *)v13 + 10) == v8
              && v14 == *((_DWORD *)v13 + 11)
              && *((_DWORD *)v13 + 4) == v15
              && *((_DWORD *)v13 + 5) == v16
              && *((_DWORD *)v13 + 6) == v17)
            {
              return v13;
            }
          }
          else
          {
            if (v18 >= v10) {
              v18 %= v10;
            }
            if (v18 != v3) {
              break;
            }
          }
          uint8x8_t v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_33:
  BOOL v20 = a1 + 2;
  uint8x8_t v13 = operator new(0x40uLL);
  *uint8x8_t v13 = 0;
  v13[1] = v9;
  long long v21 = a3[1];
  *((_OWORD *)v13 + 1) = *a3;
  *((_OWORD *)v13 + 2) = v21;
  v13[6] = 0;
  v13[7] = 0;
  float v22 = (float)(unint64_t)(a1[3] + 1);
  float v23 = *((float *)a1 + 8);
  if (!v10 || (float)(v23 * (float)v10) < v22)
  {
    BOOL v24 = 1;
    if (v10 >= 3) {
      BOOL v24 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v25 = v24 | (2 * v10);
    unint64_t v26 = vcvtps_u32_f32(v22 / v23);
    if (v25 <= v26) {
      size_t prime = v26;
    }
    else {
      size_t prime = v25;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v10 = a1[1];
    }
    if (prime <= v10)
    {
      if (prime >= v10) {
        goto LABEL_70;
      }
      unint64_t v38 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v10 < 3 || (uint8x8_t v39 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v39.i16[0] = vaddlv_u8(v39), v39.u32[0] > 1uLL))
      {
        unint64_t v38 = std::__next_prime(v38);
      }
      else
      {
        uint64_t v40 = 1 << -(char)__clz(v38 - 1);
        if (v38 >= 2) {
          unint64_t v38 = v40;
        }
      }
      if (prime <= v38) {
        size_t prime = v38;
      }
      if (prime >= v10)
      {
        unint64_t v10 = a1[1];
LABEL_70:
        if ((v10 & (v10 - 1)) != 0)
        {
          if (v9 >= v10) {
            unint64_t v3 = v9 % v10;
          }
          else {
            unint64_t v3 = v9;
          }
        }
        else
        {
          unint64_t v3 = (v10 - 1) & v9;
        }
        goto LABEL_83;
      }
      if (!prime)
      {
        char v48 = (void *)*a1;
        *a1 = 0;
        if (v48) {
          operator delete(v48);
        }
        unint64_t v10 = 0;
        a1[1] = 0;
        goto LABEL_70;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v28 = operator new(8 * prime);
    size_t v29 = (void *)*a1;
    *a1 = (uint64_t)v28;
    if (v29) {
      operator delete(v29);
    }
    uint64_t v30 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v30++) = 0;
    while (prime != v30);
    uint64_t v31 = (void *)*v20;
    if (!*v20)
    {
LABEL_69:
      unint64_t v10 = prime;
      goto LABEL_70;
    }
    size_t v32 = v31[1];
    size_t v33 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v34 = v32 & v33;
      *(void *)(*a1 + 8 * v34) = v20;
      for (uint64_t i = (void *)*v31; *v31; uint64_t i = (void *)*v31)
      {
        size_t v36 = i[1] & v33;
        if (v36 == v34)
        {
          uint64_t v31 = i;
        }
        else if (*(void *)(*a1 + 8 * v36))
        {
          *uint64_t v31 = *i;
          uint64_t v37 = 8 * v36;
          *uint64_t i = **(void **)(*a1 + v37);
          **(void **)(*a1 + v37) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v36) = v31;
          uint64_t v31 = i;
          size_t v34 = v36;
        }
      }
      goto LABEL_69;
    }
    if (v32 >= prime) {
      v32 %= prime;
    }
    *(void *)(*a1 + 8 * v32) = v20;
    uint64_t v41 = (void *)*v31;
    if (!*v31) {
      goto LABEL_69;
    }
    while (1)
    {
      size_t v43 = v41[1];
      if (v43 >= prime) {
        v43 %= prime;
      }
      if (v43 != v32)
      {
        if (!*(void *)(*a1 + 8 * v43))
        {
          *(void *)(*a1 + 8 * v43) = v31;
          goto LABEL_74;
        }
        *uint64_t v31 = *v41;
        uint64_t v42 = 8 * v43;
        *uint64_t v41 = **(void **)(*a1 + v42);
        **(void **)(*a1 + v42) = v41;
        uint64_t v41 = v31;
      }
      size_t v43 = v32;
LABEL_74:
      uint64_t v31 = v41;
      uint64_t v41 = (void *)*v41;
      size_t v32 = v43;
      if (!v41) {
        goto LABEL_69;
      }
    }
  }
LABEL_83:
  uint64_t v44 = *a1;
  uint64_t v45 = *(void **)(*a1 + 8 * v3);
  if (v45)
  {
    *uint8x8_t v13 = *v45;
LABEL_91:
    void *v45 = v13;
    goto LABEL_92;
  }
  *uint8x8_t v13 = *v20;
  *BOOL v20 = v13;
  *(void *)(v44 + 8 * v3) = v20;
  if (*v13)
  {
    unint64_t v46 = *(void *)(*v13 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v46 >= v10) {
        v46 %= v10;
      }
    }
    else
    {
      v46 &= v10 - 1;
    }
    uint64_t v45 = (void *)(*a1 + 8 * v46);
    goto LABEL_91;
  }
LABEL_92:
  ++a1[3];
  return v13;
}

void sub_1A208AE60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<altitude::TileKey,std::weak_ptr<altitude::GEOTileDataPrivate>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      unint64_t v3 = (std::__shared_weak_count *)v2[7];
      if (v3) {
        std::__shared_weak_count::__release_weak(v3);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::TileKey>,karo::AsyncRequestManagerNoArgs>::getRequest(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t **a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  int v8 = (void **)(a1 + 8);
  unint64_t v9 = (uint64_t **)std::__tree<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::TileKey>,std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::TileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::find<altitude::KeyPair<altitude::TileKey>>((uint64_t)(a1 + 8), (_DWORD *)a2);
  unint64_t v10 = v9;
  if (a1 + 9 != v9)
  {
    unint64_t v12 = v9[12];
    uint8x8_t v11 = v9[13];
    if (v11) {
      atomic_fetch_add_explicit(v11 + 1, 1uLL, memory_order_relaxed);
    }
    *a4 = v12;
    a4[1] = v11;
    return;
  }
  (*(void (**)(uint64_t **__return_ptr, void *, uint64_t, uint64_t))(*a1 + 64))(&v45, a1, a2, a3);
  int v14 = v45;
  uint8x8_t v13 = v46;
  *a4 = v45;
  a4[1] = (uint64_t *)v13;
  int v15 = *v10;
  if (!*v10)
  {
    BOOL v24 = (char *)v10;
    float v23 = v10;
LABEL_48:
    size_t v36 = operator new(0x70uLL);
    long long v37 = *(_OWORD *)(a2 + 16);
    *((_OWORD *)v36 + 2) = *(_OWORD *)a2;
    *((_OWORD *)v36 + 3) = v37;
    long long v38 = *(_OWORD *)(a2 + 48);
    *((_OWORD *)v36 + 4) = *(_OWORD *)(a2 + 32);
    *((_OWORD *)v36 + 5) = v38;
    *((void *)v36 + 12) = 0;
    *((void *)v36 + 13) = 0;
    *(void *)size_t v36 = 0;
    *((void *)v36 + 1) = 0;
    *((void *)v36 + 2) = v24;
    void *v23 = (uint64_t *)v36;
    uint8x8_t v39 = (void *)**v8;
    uint64_t v40 = (uint64_t *)v36;
    if (v39)
    {
      *int v8 = v39;
      uint64_t v40 = *v23;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*v10, v40);
    ++a1[10];
    if (v13) {
      goto LABEL_51;
    }
    goto LABEL_52;
  }
  unsigned int v16 = *(_DWORD *)(a2 + 48);
  unsigned int v17 = *(_DWORD *)(a2 + 52);
  unsigned int v18 = *(_DWORD *)(a2 + 56);
  unsigned int v19 = *(_DWORD *)(a2 + 60);
  unsigned int v20 = *(_DWORD *)(a2 + 32);
  unsigned int v21 = *(_DWORD *)(a2 + 36);
  unsigned int v22 = *(_DWORD *)(a2 + 40);
  while (1)
  {
    while (1)
    {
      BOOL v24 = (char *)v15;
      unsigned int v25 = *((_DWORD *)v15 + 20);
      if (v16 != v25 || v17 != *((_DWORD *)v24 + 21) || v18 != *((_DWORD *)v24 + 22) || *((_DWORD *)v24 + 23) != v19) {
        break;
      }
      unsigned int v26 = *((_DWORD *)v24 + 16);
      BOOL v27 = v20 >= v26;
      if (v20 == v26 && (v28 = *((_DWORD *)v24 + 17), BOOL v27 = v21 >= v28, v21 == v28))
      {
        if (v22 >= *((_DWORD *)v24 + 18)) {
          goto LABEL_31;
        }
      }
      else if (v27)
      {
        goto LABEL_31;
      }
LABEL_8:
      int v15 = *(uint64_t **)v24;
      float v23 = (uint64_t **)v24;
      if (!*(void *)v24) {
        goto LABEL_48;
      }
    }
    if (v16 < v25) {
      goto LABEL_8;
    }
    if (v16 <= v25)
    {
      unsigned int v29 = *((_DWORD *)v24 + 21);
      if (v17 < v29) {
        goto LABEL_8;
      }
      if (v17 <= v29)
      {
        unsigned int v30 = *((_DWORD *)v24 + 22);
        if (v18 < v30 || v18 <= v30 && v19 < *((_DWORD *)v24 + 23)) {
          goto LABEL_8;
        }
      }
    }
    if (v16 == v25 && *((_DWORD *)v24 + 21) == v17 && *((_DWORD *)v24 + 22) == v18) {
      break;
    }
LABEL_38:
    if (v25 >= v16)
    {
      if (v25 > v16) {
        goto LABEL_60;
      }
      unsigned int v34 = *((_DWORD *)v24 + 21);
      if (v34 >= v17)
      {
        if (v34 > v17) {
          goto LABEL_60;
        }
        unsigned int v35 = *((_DWORD *)v24 + 22);
        if (v35 >= v18 && (v35 > v18 || *((_DWORD *)v24 + 23) >= v19)) {
          goto LABEL_60;
        }
      }
    }
LABEL_45:
    float v23 = (uint64_t **)(v24 + 8);
    int v15 = (uint64_t *)*((void *)v24 + 1);
    if (!v15) {
      goto LABEL_48;
    }
  }
LABEL_31:
  if (v19 != *((_DWORD *)v24 + 23)) {
    goto LABEL_38;
  }
  unsigned int v31 = *((_DWORD *)v24 + 16);
  BOOL v32 = v31 >= v20;
  if (v31 == v20)
  {
    unsigned int v33 = *((_DWORD *)v24 + 17);
    BOOL v32 = v33 >= v21;
    if (v33 == v21) {
      BOOL v32 = *((_DWORD *)v24 + 18) >= v22;
    }
  }
  if (!v32) {
    goto LABEL_45;
  }
LABEL_60:
  size_t v36 = v24;
  if (!v13) {
    goto LABEL_52;
  }
LABEL_51:
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_52:
  uint64_t v41 = (std::__shared_weak_count *)*((void *)v36 + 13);
  *((void *)v36 + 12) = v14;
  *((void *)v36 + 13) = v13;
  if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
    std::__shared_weak_count::__release_weak(v41);
  }
  unint64_t v42 = a1[6];
  if (v42)
  {
    size_t v43 = *a4;
    uint64_t v44 = (std::__shared_weak_count *)a4[1];
    uint64_t v45 = v43;
    unint64_t v46 = v44;
    if (v44)
    {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::JobManager::queueJob(v42, &v45);
      if (!atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
        std::__shared_weak_count::__release_weak(v44);
      }
    }
    else
    {
      karo::JobManager::queueJob(v42, &v45);
    }
  }
}

void sub_1A208B228(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

_DWORD *std::__tree<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::TileKey>,std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::TileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::find<altitude::KeyPair<altitude::TileKey>>(uint64_t a1, _DWORD *a2)
{
  long long v4 = *(uint64_t **)(a1 + 8);
  uint64_t v2 = (_DWORD *)(a1 + 8);
  unint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  unsigned int v6 = a2[12];
  unsigned int v5 = a2[13];
  unsigned int v8 = a2[14];
  unsigned int v7 = a2[15];
  unsigned int v10 = a2[8];
  unsigned int v9 = a2[9];
  uint8x8_t v11 = v2;
  unsigned int v12 = a2[10];
  do
  {
    while (1)
    {
      unsigned int v13 = *((_DWORD *)v3 + 20);
      if (v13 == v6 && *((_DWORD *)v3 + 21) == v5 && *((_DWORD *)v3 + 22) == v8 && v7 == *((_DWORD *)v3 + 23)) {
        break;
      }
      if (v13 < v6) {
        goto LABEL_3;
      }
      if (v13 > v6) {
        goto LABEL_21;
      }
      unsigned int v17 = *((_DWORD *)v3 + 21);
      if (v17 < v5) {
        goto LABEL_3;
      }
      if (v17 > v5) {
        goto LABEL_21;
      }
      unsigned int v18 = *((_DWORD *)v3 + 22);
      if (v18 < v8) {
        goto LABEL_3;
      }
      if (v18 > v8) {
        goto LABEL_21;
      }
      BOOL v15 = *((_DWORD *)v3 + 23) >= v7;
LABEL_19:
      if (v15) {
        goto LABEL_21;
      }
LABEL_3:
      unint64_t v3 = (uint64_t *)v3[1];
      if (!v3) {
        goto LABEL_22;
      }
    }
    unsigned int v14 = *((_DWORD *)v3 + 16);
    BOOL v15 = v14 >= v10;
    if (v14 != v10) {
      goto LABEL_19;
    }
    unsigned int v16 = *((_DWORD *)v3 + 17);
    BOOL v15 = v16 >= v9;
    if (v16 != v9) {
      goto LABEL_19;
    }
    if (*((_DWORD *)v3 + 18) < v12) {
      goto LABEL_3;
    }
LABEL_21:
    uint8x8_t v11 = v3;
    unint64_t v3 = (uint64_t *)*v3;
  }
  while (v3);
LABEL_22:
  if (v11 == v2) {
    return v2;
  }
  unsigned int v19 = v11[20];
  if (v6 != v19 || v5 != v11[21] || v8 != v11[22] || v11[23] != v7)
  {
    if (v6 < v19) {
      return v2;
    }
    if (v6 > v19) {
      return v11;
    }
    unsigned int v23 = v11[21];
    if (v5 < v23) {
      return v2;
    }
    if (v5 > v23) {
      return v11;
    }
    unsigned int v24 = v11[22];
    if (v8 < v24) {
      return v2;
    }
    if (v8 > v24) {
      return v11;
    }
    BOOL v21 = v7 >= v11[23];
    goto LABEL_38;
  }
  unsigned int v20 = v11[16];
  BOOL v21 = v10 >= v20;
  if (v10 != v20 || (v22 = v11[17], BOOL v21 = v9 >= v22, v9 != v22))
  {
LABEL_38:
    if (!v21) {
      return v2;
    }
    return v11;
  }
  if (v12 >= v11[18]) {
    return v11;
  }
  return v2;
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::TileKey>,karo::AsyncRequestManagerNoArgs>::waitOnRequest(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unsigned int v6 = std::__tree<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::TileKey>,std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::TileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::find<altitude::KeyPair<altitude::TileKey>>(a1 + 64, a2);
  if ((_DWORD *)(a1 + 72) == v6)
  {
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
    return 0;
  }
  else
  {
    uint64_t v8 = *((void *)v6 + 12);
    unsigned int v7 = (std::__shared_weak_count *)*((void *)v6 + 13);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
    if (v8)
    {
      karo::Job::waitToFinish((karo::Job *)v8, a3);
      pthread_mutex_lock(*(pthread_mutex_t **)(v8 + 152));
      uint64_t v9 = *(_DWORD *)(v8 + 160) & 1;
      pthread_mutex_unlock(*(pthread_mutex_t **)(v8 + 152));
      if (!v7) {
        return v9;
      }
    }
    else
    {
      uint64_t v9 = 0;
      if (!v7) {
        return v9;
      }
    }
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return v9;
}

void sub_1A208B4B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::TileKey>,karo::AsyncRequestManagerNoArgs>::requestT@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, unsigned int a5@<W4>, char a6@<W5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  if (!a3) {
    a3 = *(_DWORD *)(a1 + 88) + 1;
  }
  (*(void (**)(unsigned int **__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 96))(&v22, a1, a2, a7);
  unsigned int v16 = v22;
  unsigned int v17 = atomic_load(v22 + 4);
  if (v17 != a4) {
    (*(void (**)(unsigned int *, uint64_t))(*(void *)v22 + 24))(v22, a4);
  }
  v16[45] = a3;
  v16[46] = a5;
  *((unsigned char *)v16 + 176) = a6;
  unsigned int v18 = v22;
  unsigned int v19 = v23;
  *a8 = off_1EF5677B0;
  a8[1] = v18;
  a8[2] = v19;
  if (v19)
  {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    unsigned int v18 = (unsigned int *)a8[1];
  }
  if (v18) {
    atomic_fetch_add((atomic_uint *volatile)v18 + 32, 1u);
  }
  unsigned int v20 = v23;
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  return pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
}

void sub_1A208B648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 40));
  _Unwind_Resume(a1);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::TileKey>,karo::AsyncRequestManagerNoArgs>::requestT(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  if (!a4) {
    a4 = *(_DWORD *)(a1 + 88) + 1;
  }
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  if (*a2 != v9)
  {
    do
    {
      uint64_t v10 = v8 + 64;
      (*(void (**)(unsigned int **__return_ptr, uint64_t))(*(void *)a1 + 96))(&v22, a1);
      uint8x8_t v11 = v22;
      int v12 = *(_DWORD *)(v10 + 4);
      unsigned int v13 = *(_DWORD *)(v10 + 8);
      char v14 = *(unsigned char *)(v10 + 12);
      unsigned int v15 = atomic_load(v22 + 4);
      if (v15 != v12) {
        (*(void (**)(unsigned int *))(*(void *)v22 + 24))(v22);
      }
      v11[45] = a4;
      v11[46] = v13;
      *((unsigned char *)v11 + 176) = v14;
      unsigned int v16 = *(void **)(a3 + 8);
      if ((unint64_t)v16 >= *(void *)(a3 + 16))
      {
        unsigned int v19 = std::vector<karo::AsyncRequestManager::RequestHandle>::__emplace_back_slow_path<std::shared_ptr<karo::AsyncRequestManager::Request> &>((void **)a3, (uint64_t)v22, (uint64_t)v23);
      }
      else
      {
        *unsigned int v16 = off_1EF5677B0;
        unsigned int v17 = v22;
        v16[1] = v22;
        uint64_t v18 = (uint64_t)v23;
        v16[2] = v23;
        if (v18)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
          unsigned int v17 = (unsigned int *)v16[1];
        }
        if (v17) {
          atomic_fetch_add((atomic_uint *volatile)v17 + 32, 1u);
        }
        unsigned int v19 = v16 + 3;
        *(void *)(a3 + 8) = v16 + 3;
      }
      *(void *)(a3 + 8) = v19;
      unsigned int v20 = v23;
      if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
      uint64_t v8 = v10 + 16;
    }
    while (v10 + 16 != v9);
  }
  return pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
}

void sub_1A208B838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 40));
  _Unwind_Resume(a1);
}

void altitude::GEODataCacheNode::createRequest()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1A208BAE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  karo::Mutex::~Mutex(v21);
  karo::Job::~Job(v20);
  operator delete(v22);
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  MEMORY[0x1A6239270](v20, 0x10B3C407B33DE98);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<altitude::GEODataCacheNodeJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::GEODataCacheNodeJob>,std::allocator<altitude::GEODataCacheNodeJob>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::GEODataCacheNodeJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::GEODataCacheNodeJob>,std::allocator<altitude::GEODataCacheNodeJob>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void altitude::GenericCacheNodeJob::~GenericCacheNodeJob(altitude::GenericCacheNodeJob *this)
{
  *(void *)this = &unk_1EF56A2A8;
  if (*((char *)this + 223) < 0) {
    operator delete(*((void **)this + 25));
  }
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 24));
  uint64_t v2 = *((void *)this + 24);
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 24) = 0;
  karo::Job::~Job(this);
}

uint64_t altitude::GEODataCacheNodeJob::succeeded(altitude::GEODataCacheNodeJob *this)
{
  return *((unsigned __int8 *)this + 225);
}

void altitude::GEODataCacheNodeJob::jobStep(altitude::GEODataCacheNodeJob *this)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  atomic_load((unsigned int *)this + 4);
  (*(void (**)(void *__return_ptr))(**((void **)this + 29) + 104))(&v10);
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v10) == 4)
  {
    uint64_t v2 = v13;
    pthread_mutex_lock(v13[19]);
    int v3 = *((_DWORD *)v2 + 40);
    pthread_mutex_unlock(v2[19]);
    if (v3) {
      long long v4 = (void *)(*(uint64_t (**)(pthread_mutex_t **))&(*v13)->__opaque[48])(v13);
    }
    else {
      long long v4 = 0;
    }
    id v6 = v4;
    operator new();
  }
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v10))
  {
    unsigned int v5 = v12;
    v9[0] = v11;
    v9[1] = v12;
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::Job::addBlockingSubJob((uint64_t *)this, v9, 1, 0);
      if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    else
    {
      karo::Job::addBlockingSubJob((uint64_t *)this, v9, 1, 0);
    }
  }
  else
  {
    (*(void (**)(altitude::GEODataCacheNodeJob *))(*(void *)this + 16))(this);
  }
  uint64_t v10 = off_1EF5676C0;
  unsigned int v7 = v14;
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v10 = off_1EF5677B0;
  if (v11) {
    atomic_fetch_add((atomic_uint *volatile)(v11 + 128), 0xFFFFFFFF);
  }
  uint64_t v8 = v12;
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
}

void sub_1A208C2D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  karo::AsyncFileLoader::FileObject::~FileObject((karo::AsyncFileLoader::FileObject *)va);
  _Unwind_Resume(a1);
}

void *std::function<std::shared_ptr<md::LabelTile> ()(void *,altitude::LabelData::TileType)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__shared_ptr_pointer<altitude::GEOTileDataPrivate *,std::shared_ptr<altitude::GEOTileDataPrivate>::__shared_ptr_default_delete<altitude::GEOTileDataPrivate,altitude::GEOTileDataPrivate>,std::allocator<altitude::GEOTileDataPrivate>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::GEOTileDataPrivate *,std::shared_ptr<altitude::GEOTileDataPrivate>::__shared_ptr_default_delete<altitude::GEOTileDataPrivate,altitude::GEOTileDataPrivate>,std::allocator<altitude::GEOTileDataPrivate>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void altitude::GEODataCacheNodeJob::~GEODataCacheNodeJob(altitude::GEODataCacheNodeJob *this)
{
  altitude::GEODataCacheNodeJob::~GEODataCacheNodeJob(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF56A268;
  uint64_t v2 = (void *)*((void *)this + 36);
  if (v2)
  {
    *((void *)this + 37) = v2;
    operator delete(v2);
  }
  int v3 = (std::__shared_weak_count *)*((void *)this + 35);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  *(void *)this = &unk_1EF56A2A8;
  if (*((char *)this + 223) < 0) {
    operator delete(*((void **)this + 25));
  }
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 24));
  long long v4 = *((void *)this + 24);
  if (v4) {
    MEMORY[0x1A6239270](v4, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 24) = 0;
  karo::Job::~Job(this);
}

void karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::TileKey>,karo::AsyncRequestManagerNoArgs>::createAndQueueRequest(void *a1@<X0>, uint64_t *a2@<X8>)
{
  (*(void (**)(void *))(*a1 + 64))(a1);
  unint64_t v4 = a1[6];
  if (v4)
  {
    uint64_t v5 = *a2;
    id v6 = (std::__shared_weak_count *)a2[1];
    v7[0] = v5;
    v7[1] = v6;
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::JobManager::queueJob(v4, v7);
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    else
    {
      karo::JobManager::queueJob(v4, v7);
    }
  }
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::TileKey>,karo::AsyncRequestManagerNoArgs>::clearRequest(uint64_t a1, _DWORD *a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = (uint64_t **)(a1 + 64);
  uint64_t v5 = (uint64_t *)std::__tree<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::TileKey>,std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::TileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::find<altitude::KeyPair<altitude::TileKey>>(a1 + 64, a2);
  if ((uint64_t *)(a1 + 72) != v5)
  {
    id v6 = v5;
    (*(void (**)(uint64_t))(*(void *)v5[12] + 16))(v5[12]);
    unsigned int v7 = (uint64_t *)v6[1];
    if (v7)
    {
      do
      {
        uint64_t v8 = v7;
        unsigned int v7 = (uint64_t *)*v7;
      }
      while (v7);
    }
    else
    {
      uint64_t v9 = v6;
      do
      {
        uint64_t v8 = (uint64_t *)v9[2];
        BOOL v10 = *v8 == (void)v9;
        uint64_t v9 = v8;
      }
      while (!v10);
    }
    if (*v4 == v6) {
      void *v4 = v8;
    }
    uint64_t v11 = *(uint64_t **)(a1 + 72);
    --*(void *)(a1 + 80);
    std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v11, v6);
    int v12 = (std::__shared_weak_count *)v6[13];
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    operator delete(v6);
  }
  unsigned int v13 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v13);
}

void sub_1A208C76C(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(*(pthread_mutex_t **)(v1 + 40));
  _Unwind_Resume(a1);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::TileKey>,karo::AsyncRequestManagerNoArgs>::removeFromRequests(uint64_t a1, uint64_t a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = *(uint64_t **)(a1 + 64);
  if (v4 != (uint64_t *)(a1 + 72))
  {
    uint64_t v5 = *(uint64_t **)(a1 + 64);
    while (1)
    {
      id v6 = (uint64_t *)v5[1];
      if (v5[12] == a2) {
        break;
      }
      if (v6)
      {
        do
        {
          unsigned int v7 = v6;
          id v6 = (uint64_t *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          unsigned int v7 = (uint64_t *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v8);
      }
      uint64_t v5 = v7;
      if (v7 == (uint64_t *)(a1 + 72)) {
        goto LABEL_23;
      }
    }
    if (v6)
    {
      do
      {
        uint64_t v9 = v6;
        id v6 = (uint64_t *)*v6;
      }
      while (v6);
    }
    else
    {
      BOOL v10 = v5;
      do
      {
        uint64_t v9 = (uint64_t *)v10[2];
        BOOL v8 = *v9 == (void)v10;
        BOOL v10 = v9;
      }
      while (!v8);
    }
    if (v4 == v5) {
      *(void *)(a1 + 64) = v9;
    }
    uint64_t v11 = *(uint64_t **)(a1 + 72);
    --*(void *)(a1 + 80);
    std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v11, v5);
    int v12 = (std::__shared_weak_count *)v5[13];
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    operator delete(v5);
  }
LABEL_23:
  unsigned int v13 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v13);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::KeyPair<altitude::TileKey>,karo::AsyncRequestManagerNoArgs>::pruneRequests(uint64_t a1, int a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = *(uint64_t **)(a1 + 64);
  if (v4 != (uint64_t *)(a1 + 72))
  {
    do
    {
      uint64_t v5 = (uint64_t *)v4[1];
      id v6 = v4;
      if (v5)
      {
        do
        {
          unsigned int v7 = v5;
          uint64_t v5 = (uint64_t *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          unsigned int v7 = (uint64_t *)v6[2];
          BOOL v8 = *v7 == (void)v6;
          id v6 = v7;
        }
        while (!v8);
      }
      uint64_t v9 = v4[12];
      if (atomic_load((unsigned int *)(v9 + 128))) {
        *(_DWORD *)(v9 + 180) = a2;
      }
      pthread_mutex_lock(*(pthread_mutex_t **)(v9 + 152));
      int v11 = *(_DWORD *)(v9 + 160);
      pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 152));
      if ((v11 & 1) != 0 && *(unsigned char *)(v9 + 176) && *(_DWORD *)(v9 + 180) != a2
        || (a2 - *(_DWORD *)(v9 + 180)) > *(_DWORD *)(v9 + 184))
      {
        (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
        int v12 = (uint64_t *)v4[1];
        unsigned int v13 = v4;
        if (v12)
        {
          do
          {
            char v14 = v12;
            int v12 = (uint64_t *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            char v14 = (uint64_t *)v13[2];
            BOOL v8 = *v14 == (void)v13;
            unsigned int v13 = v14;
          }
          while (!v8);
        }
        if (*(uint64_t **)(a1 + 64) == v4) {
          *(void *)(a1 + 64) = v14;
        }
        uint64_t v15 = *(uint64_t **)(a1 + 72);
        --*(void *)(a1 + 80);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v15, v4);
        unsigned int v16 = (std::__shared_weak_count *)v4[13];
        if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
        operator delete(v4);
      }
      unint64_t v4 = v7;
    }
    while (v7 != (uint64_t *)(a1 + 72));
  }
  *(_DWORD *)(a1 + 88) = a2;
  unsigned int v17 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v17);
}

void sub_1A208CA90(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(*(pthread_mutex_t **)(v1 + 40));
  _Unwind_Resume(a1);
}

void altitude::GEODataCacheNode::~GEODataCacheNode(altitude::GEODataCacheNode *this)
{
  *(void *)this = &unk_1EF569160;
  uint64_t v2 = (char *)this + 192;
  int v3 = (char *)*((void *)this + 27);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    unint64_t v4 = (void *)*((void *)this + 21);
    if (v4)
    {
LABEL_5:
      *((void *)this + 22) = v4;
      operator delete(v4);
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    unint64_t v4 = (void *)*((void *)this + 21);
    if (v4) {
      goto LABEL_5;
    }
  }
  altitude::GenericCacheNode<altitude::TileKey,altitude::GEOTileDataPrivate>::~GenericCacheNode(this);
  JUMPOUT(0x1A6239270);
}

{
  char *v2;
  char *v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF569160;
  uint64_t v2 = (char *)this + 192;
  int v3 = (char *)*((void *)this + 27);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    unint64_t v4 = (void *)*((void *)this + 21);
    if (v4)
    {
LABEL_5:
      *((void *)this + 22) = v4;
      operator delete(v4);
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    unint64_t v4 = (void *)*((void *)this + 21);
    if (v4) {
      goto LABEL_5;
    }
  }
  altitude::GenericCacheNode<altitude::TileKey,altitude::GEOTileDataPrivate>::~GenericCacheNode(this);
}

void altitude::GenericCacheNode<altitude::TileKey,altitude::GEOTileDataPrivate>::~GenericCacheNode(karo::AsyncRequestManager *a1)
{
  *(void *)a1 = &unk_1EF569400;
  pthread_mutex_destroy(*((pthread_mutex_t **)a1 + 17));
  uint64_t v2 = *((void *)a1 + 17);
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40FA0F61DDLL);
  }
  *((void *)a1 + 17) = 0;
  int v3 = (void *)*((void *)a1 + 14);
  if (v3)
  {
    do
    {
      uint64_t v5 = (void *)*v3;
      id v6 = (std::__shared_weak_count *)v3[7];
      if (v6) {
        std::__shared_weak_count::__release_weak(v6);
      }
      operator delete(v3);
      int v3 = v5;
    }
    while (v5);
  }
  unint64_t v4 = (void *)*((void *)a1 + 12);
  *((void *)a1 + 12) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)a1 = &unk_1EF567B80;
  while (*((void *)a1 + 10))
    (*(void (**)(karo::AsyncRequestManager *, uint64_t))(*(void *)a1 + 48))(a1, *((void *)a1 + 8) + 32);
  std::__tree<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::TileKey>,std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::TileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)a1 + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(a1);
}

void sub_1A208CCA0(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::TileKey>,std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::TileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)v1 + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(v1);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::TileKey>,std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::TileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::TileKey>,std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::TileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*a1);
    std::__tree<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::TileKey>,std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::TileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(a1[1]);
    uint64_t v2 = (std::__shared_weak_count *)a1[13];
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete(a1);
  }
}

__n128 altitude::GenericCacheNode<altitude::TileKey,altitude::GEOTileDataPrivate>::getCacheKeyForKey@<Q0>(uint64_t a1@<X1>, _OWORD *a2@<X8>)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v3;
  return result;
}

void altitude::GEODataCacheNode::GEODataCacheNode(void *a1, long long *a2, uint64_t a3)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  karo::AsyncRequestManager::AsyncRequestManager(a1, a2, a3);
}

void sub_1A208CFA4(_Unwind_Exception *a1)
{
  altitude::GenericCacheNode<altitude::TileKey,altitude::GEOTileDataPrivate>::~GenericCacheNode(v1);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<std::shared_ptr<md::LabelTile> ()(void *,altitude::LabelData::TileType)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        void v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        void v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        void v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      void v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::GroundShadowMapPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  unint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  unint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void *std::function<void ()(ggl::DaVinci::GroundShadowMapPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::DaVinci::GroundShadowMapPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo> *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo> * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::DaVinci::GroundShadowMapPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::DaVinci::GroundShadowMapPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t md::DaVinciPipelineStateManager<ggl::DaVinci::GroundShadowMapPipelineState,std::shared_ptr<ggl::DaVinciGroundShadowMapShader>,ggl::ColorBufferOperation>::~DaVinciPipelineStateManager(uint64_t a1)
{
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*(void **)(a1 + 104));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17ConstantDataTypedINS2_4Tile17PositionScaleInfoEEEEC1ENS_8functionIFPS7_vEEENS9_IFvSA_EEEmmEd1_UlSA_E_NS_9allocatorISF_EESD_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF57B310;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_17ConstantDataTypedINS2_4Tile17PositionScaleInfoEEEEC1ENS_8functionIFPS7_vEEENS9_IFvSA_EEEmmEd1_UlSA_E_NS_9allocatorISF_EESD_ED0Ev()
{
}

void ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::DaVinci::GroundShadowMapPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DaVinci::GroundShadowMapPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5896D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DaVinci::GroundShadowMapPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5896D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t karo::media::JpegLoaderFig::loadFromChunk(_DWORD *a1, pwin_jpg *this, unsigned __int8 *a3, uint64_t a4, int *a5)
{
  if (*a1 != 6)
  {
    *(void *)unsigned int v13 = 0;
    pwin_jpg::p_info_mem_jpg(this, a3, &v13[1], v13, a5);
    if (md::HardwareFigDecoder::instance(void)::once != -1) {
      dispatch_once(&md::HardwareFigDecoder::instance(void)::once, &__block_literal_global_25645);
    }
    uint64_t v7 = *(void *)md::HardwareFigDecoder::instance(void)::_singleton;
    CFTypeRef cf = 0;
    *(void *)seed = 0;
    if (md::HardwareFigDecoderInternal::createContainer(v7, (uint64_t)this, (uint64_t)a3, &cf, seed))
    {
      md::HardwareFigDecoderInternal::getOrCreateSession(v7);
      uint64_t v15 = 0;
      int ImageForIndex = CMPhotoDecompressionContainerCreateImageForIndex();
      CFRelease(cf);
      if (ImageForIndex)
      {
        if (GEOGetVectorKitResourceLoadingLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitResourceLoadingLog_onceToken, &__block_literal_global_25);
        }
        uint64_t v9 = (id)GEOGetVectorKitResourceLoadingLog_log;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1A1780000, v9, OS_LOG_TYPE_ERROR, "Failed to decode raster resource - failed to decode image", buf, 2u);
        }
      }
      else if (v15)
      {
        operator new();
      }
    }
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    BOOL v10 = (id)GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(cf) = 0;
      _os_log_impl(&dword_1A1780000, v10, OS_LOG_TYPE_ERROR, "Failed to decode JPEG image with hardware decoder.", (uint8_t *)&cf, 2u);
    }
  }
  return 0;
}

void sub_1A208E05C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__shared_ptr_emplace<altitude::IOSurfaceData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<altitude::IOSurfaceData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AB68;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<altitude::IOSurfaceData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58AB68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_pointer<altitude::IOSurfaceHandle *,std::shared_ptr<altitude::IOSurfaceHandle>::__shared_ptr_default_delete<altitude::IOSurfaceHandle,altitude::IOSurfaceHandle>,std::allocator<altitude::IOSurfaceHandle>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(CFTypeRef **)(result + 24);
  if (v1)
  {
    if (*v1) {
      CFRelease(*v1);
    }
    CFTypeRef *v1 = 0;
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::IOSurfaceHandle *,std::shared_ptr<altitude::IOSurfaceHandle>::__shared_ptr_default_delete<altitude::IOSurfaceHandle,altitude::IOSurfaceHandle>,std::allocator<altitude::IOSurfaceHandle>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::allocator_traits<std::allocator<gdc::DebugTreeNode>>::destroy[abi:nn180100]<gdc::DebugTreeNode,void,void>(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 80);
    unint64_t v4 = *(void **)(a1 + 72);
    if (v3 != v2)
    {
      do
      {
        v3 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v3);
      }
      while (v3 != v2);
      unint64_t v4 = *(void **)(a1 + 72);
    }
    *(void *)(a1 + 80) = v2;
    operator delete(v4);
  }
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 56);
    uint64_t v7 = *(void **)(a1 + 48);
    if (v6 != v5)
    {
      do
      {
        v6 -= 96;
        std::allocator_traits<std::allocator<gdc::DebugTreeNode>>::destroy[abi:nn180100]<gdc::DebugTreeNode,void,void>(v6);
      }
      while (v6 != v5);
      uint64_t v7 = *(void **)(a1 + 48);
    }
    *(void *)(a1 + 56) = v5;
    operator delete(v7);
  }
  if (*(char *)(a1 + 47) < 0)
  {
    operator delete(*(void **)(a1 + 24));
    if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
      return;
    }
  }
  else if ((*(char *)(a1 + 23) & 0x80000000) == 0)
  {
    return;
  }
  uint64_t v8 = *(void **)a1;
  operator delete(v8);
}

void sub_1A208E58C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A208E738(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A208E9E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t gdc::DebugTreeNode::operator=(uint64_t a1, long long *a2)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  uint64_t v5 = (void **)(a1 + 24);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*v5);
  }
  long long v6 = *(long long *)((char *)a2 + 24);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *(_OWORD *)uint64_t v5 = v6;
  *((unsigned char *)a2 + 47) = 0;
  *((unsigned char *)a2 + 24) = 0;
  uint64_t v7 = (void **)(a1 + 48);
  uint64_t v8 = *(void *)(a1 + 48);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 56);
    BOOL v10 = *(void **)(a1 + 48);
    if (v9 != v8)
    {
      do
      {
        v9 -= 96;
        std::allocator_traits<std::allocator<gdc::DebugTreeNode>>::destroy[abi:nn180100]<gdc::DebugTreeNode,void,void>(v9);
      }
      while (v9 != v8);
      BOOL v10 = *v7;
    }
    *(void *)(a1 + 56) = v8;
    operator delete(v10);
    *uint64_t v7 = 0;
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
  }
  *(_OWORD *)(a1 + 48) = a2[3];
  *(void *)(a1 + 64) = *((void *)a2 + 8);
  *((void *)a2 + 6) = 0;
  *((void *)a2 + 7) = 0;
  *((void *)a2 + 8) = 0;
  int v11 = (void **)(a1 + 72);
  uint64_t v12 = *(void *)(a1 + 72);
  if (v12)
  {
    uint64_t v13 = *(void *)(a1 + 80);
    char v14 = *(void **)(a1 + 72);
    if (v13 != v12)
    {
      do
      {
        v13 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v13);
      }
      while (v13 != v12);
      char v14 = *v11;
    }
    *(void *)(a1 + 80) = v12;
    operator delete(v14);
    *int v11 = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
  }
  *(_OWORD *)(a1 + 72) = *(long long *)((char *)a2 + 72);
  *(void *)(a1 + 88) = *((void *)a2 + 11);
  *((void *)a2 + 9) = 0;
  *((void *)a2 + 10) = 0;
  *((void *)a2 + 11) = 0;
  return a1;
}

uint64_t geo::optional<gdc::DebugTreeNode>::~optional(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 80);
    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 88);
      long long v4 = *(void **)(a1 + 80);
      if (v3 != v2)
      {
        do
        {
          v3 -= 80;
          std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v3);
        }
        while (v3 != v2);
        long long v4 = *(void **)(a1 + 80);
      }
      *(void *)(a1 + 88) = v2;
      operator delete(v4);
    }
    uint64_t v5 = *(void *)(a1 + 56);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 64);
      uint64_t v7 = *(void **)(a1 + 56);
      if (v6 != v5)
      {
        do
        {
          v6 -= 96;
          std::allocator_traits<std::allocator<gdc::DebugTreeNode>>::destroy[abi:nn180100]<gdc::DebugTreeNode,void,void>(v6);
        }
        while (v6 != v5);
        uint64_t v7 = *(void **)(a1 + 56);
      }
      *(void *)(a1 + 64) = v5;
      operator delete(v7);
    }
    if (*(char *)(a1 + 55) < 0)
    {
      operator delete(*(void **)(a1 + 32));
      if ((*(char *)(a1 + 31) & 0x80000000) == 0) {
        goto LABEL_14;
      }
    }
    else if ((*(char *)(a1 + 31) & 0x80000000) == 0)
    {
LABEL_14:
      *(unsigned char *)a1 = 0;
      return a1;
    }
    operator delete(*(void **)(a1 + 8));
    goto LABEL_14;
  }
  return a1;
}

void sub_1A208ED3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A208F624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, uint64_t a12, void *a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void *__p)
{
  char v69 = a68;
  gdc::DebugTreeNode::~DebugTreeNode((gdc::DebugTreeNode *)&a51);
  if (v69 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t geo::optional<gdc::DebugTreeProperty>::~optional(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 64);
    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 72);
      long long v4 = *(void **)(a1 + 64);
      if (v3 != v2)
      {
        do
        {
          if (*(char *)(v3 - 1) < 0) {
            operator delete(*(void **)(v3 - 24));
          }
          v3 -= 24;
        }
        while (v3 != v2);
        long long v4 = *(void **)(a1 + 64);
      }
      *(void *)(a1 + 72) = v2;
      operator delete(v4);
    }
    uint64_t v5 = *(void *)(a1 + 40);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 48);
      uint64_t v7 = *(void **)(a1 + 40);
      if (v6 != v5)
      {
        do
        {
          if (*(char *)(v6 - 9) < 0) {
            operator delete(*(void **)(v6 - 32));
          }
          v6 -= 64;
        }
        while (v6 != v5);
        uint64_t v7 = *(void **)(a1 + 40);
      }
      *(void *)(a1 + 48) = v5;
      operator delete(v7);
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_1A208F9F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A20900BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *__p,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  gdc::DebugTreeProperty::~DebugTreeProperty((gdc::DebugTreeProperty *)&a41);
  if (a57 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void gdc::DebugTreeProperty::~DebugTreeProperty(gdc::DebugTreeProperty *this)
{
  uint64_t v2 = *((void *)this + 7);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 8);
    long long v4 = (void *)*((void *)this + 7);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0) {
          operator delete(*(void **)(v3 - 24));
        }
        v3 -= 24;
      }
      while (v3 != v2);
      long long v4 = (void *)*((void *)this + 7);
    }
    *((void *)this + 8) = v2;
    operator delete(v4);
  }
  uint64_t v5 = *((void *)this + 4);
  if (v5)
  {
    uint64_t v6 = *((void *)this + 5);
    uint64_t v7 = (void *)*((void *)this + 4);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 9) < 0) {
          operator delete(*(void **)(v6 - 32));
        }
        v6 -= 64;
      }
      while (v6 != v5);
      uint64_t v7 = (void *)*((void *)this + 4);
    }
    *((void *)this + 5) = v5;
    operator delete(v7);
  }
  if (*((char *)this + 23) < 0) {
    operator delete(*(void **)this);
  }
}

void sub_1A2090440(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A20907BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2090A78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A2090D34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void sub_1A2091054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, unsigned __int8 a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19, uint64_t a20,char a21)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy((void ***)&a10, a9);
  _Unwind_Resume(a1);
}

void gdc::tag_invoke(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = (void *)(a1 + 8);
  *(unsigned char *)a1 = 1;
  long long v4 = operator new(0x18uLL);
  v4[1] = 0;
  void v4[2] = 0;
  void *v4 = v4 + 1;
  *uint64_t v3 = v4;
  uint64_t v5 = a2[7] - a2[6];
  if (v5)
  {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * (v5 >> 5);
    if (v6 >> 61) {
      abort();
    }
    size_t v7 = 0x5555555555555558 * (v5 >> 5);
    uint64_t v8 = (int64x2_t *)operator new(v7);
    bzero(v8, 8 * v6);
    uint64_t v9 = &v8->i64[v6];
    if (8 * v6 - 8 >= 0x18)
    {
      unint64_t v120 = ((v7 - 8) >> 3) + 1;
      uint64_t v10 = v120 & 0x3FFFFFFFFFFFFFFCLL;
      int64x2_t v121 = (int64x2_t)xmmword_1A28FC760;
      uint64_t v122 = v8 + 1;
      int64x2_t v123 = vdupq_n_s64(2uLL);
      int64x2_t v124 = vdupq_n_s64(4uLL);
      uint64_t v125 = v120 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v122[-1] = v121;
        *uint64_t v122 = vaddq_s64(v121, v123);
        int64x2_t v121 = vaddq_s64(v121, v124);
        v122 += 2;
        v125 -= 4;
      }
      while (v125);
      if (v120 == v10) {
        goto LABEL_149;
      }
      int v11 = &v8->i64[v120 & 0x3FFFFFFFFFFFFFFCLL];
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = (uint64_t *)v8;
    }
    do
      *v11++ = v10++;
    while (v11 != v9);
LABEL_149:
    *(void *)float64x2_t v213 = a2;
    std::__introsort<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *,false>((uint64_t)v8, &v8->i64[v7 / 8], (uint64_t)v213, 126 - 2 * __clz(v6), 1);
    unint64_t v188 = (int64x2_t *)((char *)v8 + v7);
    __p = v8;
    float v189 = a2;
    while (1)
    {
      unint64_t v126 = ((char *)v9 - (char *)v8) >> 3;
      uint64_t v127 = a2[6];
      uint64_t v128 = v127 + 96 * v8->i64[0];
      if (*(unsigned char *)(v128 + 23)) {
        int v129 = (const char *)(v127 + 96 * v8->i64[0]);
      }
      else {
        int v129 = "";
      }
      if ((*(unsigned char *)(v128 + 23) & 0x80) == 0)
      {
        size_t v130 = strlen(v129);
        uint64_t v131 = v8;
        while (1)
        {
          unint64_t v132 = v126 >> 1;
          char v133 = &v131->i64[v126 >> 1];
          uint64_t v134 = v127 + 96 * *v133;
          if (*(char *)(v134 + 23) < 0)
          {
            if (*(void *)(v134 + 8)) {
              uint64_t v135 = *(const char **)v134;
            }
            else {
              uint64_t v135 = "";
            }
          }
          else if (*(unsigned char *)(v134 + 23))
          {
            uint64_t v135 = (const char *)(v127 + 96 * *v133);
          }
          else
          {
            uint64_t v135 = "";
          }
          size_t v136 = strlen(v135);
          size_t v137 = v136;
          if (v136 >= v130) {
            size_t v138 = v130;
          }
          else {
            size_t v138 = v136;
          }
          int v139 = memcmp(v129, v135, v138);
          if (v139)
          {
            if (v139 < 0) {
              goto LABEL_157;
            }
          }
          else if (v130 < v137)
          {
            goto LABEL_157;
          }
          uint64_t v131 = (int64x2_t *)(v133 + 1);
          unint64_t v132 = v126 + ~v132;
LABEL_157:
          unint64_t v126 = v132;
          if (!v132) {
            goto LABEL_203;
          }
        }
      }
      if (*(void *)(v128 + 8))
      {
        uint64_t v140 = *(const char **)v128;
        size_t v141 = strlen(*(const char **)v128);
        uint64_t v131 = v8;
        while (1)
        {
          unint64_t v142 = v126 >> 1;
          double v143 = &v131->i64[v126 >> 1];
          uint64_t v144 = v127 + 96 * *v143;
          if (*(char *)(v144 + 23) < 0)
          {
            if (*(void *)(v144 + 8)) {
              double v145 = *(const char **)v144;
            }
            else {
              double v145 = "";
            }
          }
          else if (*(unsigned char *)(v144 + 23))
          {
            double v145 = (const char *)(v127 + 96 * *v143);
          }
          else
          {
            double v145 = "";
          }
          size_t v146 = strlen(v145);
          size_t v147 = v146;
          if (v146 >= v141) {
            size_t v148 = v141;
          }
          else {
            size_t v148 = v146;
          }
          int v149 = memcmp(v140, v145, v148);
          if (v149)
          {
            if (v149 < 0) {
              goto LABEL_176;
            }
          }
          else if (v141 < v147)
          {
            goto LABEL_176;
          }
          uint64_t v131 = (int64x2_t *)(v143 + 1);
          unint64_t v142 = v126 + ~v142;
LABEL_176:
          unint64_t v126 = v142;
          if (!v142) {
            goto LABEL_203;
          }
        }
      }
      uint64_t v131 = v8;
      do
      {
        int v152 = &v131->i64[v126 >> 1];
        uint64_t v150 = (const char *)(v127 + 96 * *v152);
        if (v150[23] < 0)
        {
          if (*((void *)v150 + 1)) {
            uint64_t v150 = *(const char **)v150;
          }
          else {
            uint64_t v150 = "";
          }
        }
        else if (!v150[23])
        {
          uint64_t v150 = "";
        }
        uint64_t v151 = (int64x2_t *)(v152 + 1);
        if (*v150)
        {
          v126 >>= 1;
        }
        else
        {
          uint64_t v131 = v151;
          v126 += ~(v126 >> 1);
        }
      }
      while (v126);
LABEL_203:
      v215.__r_.__value_.__s.__data_[0] = 0;
      v215.__r_.__value_.__l.__size_ = 0;
      uint64_t v153 = (long long *)(v127 + 96 * v8->i64[0]);
      if (*((char *)v153 + 23) < 0)
      {
        std::string::size_type v155 = *((void *)v153 + 1);
        a2 = v189;
        if (v155)
        {
          std::string::__init_copy_ctor_external((std::string *)v213, *(const std::string::value_type **)v153, v155);
          goto LABEL_209;
        }
      }
      else
      {
        a2 = v189;
        if (*((unsigned char *)v153 + 23))
        {
          long long v154 = *v153;
          *(void *)&v213[16] = *((void *)v153 + 2);
          *(_OWORD *)float64x2_t v213 = v154;
          goto LABEL_209;
        }
      }
      v213[23] = 8;
      strcpy(v213, "<NO KEY>");
LABEL_209:
      if ((char *)v131 - (char *)v8 >= 9)
      {
        float64x2_t v212 = 0;
        char v211 = 2;
        long double v156 = (void **)operator new(0x18uLL);
        *long double v156 = 0;
        v156[1] = 0;
        v156[2] = 0;
        v215.__r_.__value_.__s.__data_[0] = 2;
        char v211 = 0;
        v215.__r_.__value_.__l.__size_ = (std::string::size_type)v156;
        float64x2_t v212 = 0;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v212, 0);
        while (1)
        {
          gdc::tag_invoke(&v192, v153);
          double v157 = (char *)v156[1];
          uint64_t v158 = (char *)v156[2];
          if (v157 < v158)
          {
            *double v157 = v192.__r_.__value_.__s.__data_[0];
            *((void *)v157 + 1) = v192.__r_.__value_.__l.__size_;
            v192.__r_.__value_.__s.__data_[0] = 0;
            v192.__r_.__value_.__l.__size_ = 0;
            uint64_t v159 = v157 + 16;
            goto LABEL_227;
          }
          uint64_t v160 = (v157 - (unsigned char *)*v156) >> 4;
          unint64_t v161 = v160 + 1;
          if ((unint64_t)(v160 + 1) >> 60) {
            abort();
          }
          uint64_t v162 = v158 - (unsigned char *)*v156;
          if (v162 >> 3 > v161) {
            unint64_t v161 = v162 >> 3;
          }
          if ((unint64_t)v162 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v163 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v163 = v161;
          }
          if (v163 >> 60) {
LABEL_255:
          }
            std::__throw_bad_array_new_length[abi:nn180100]();
          double v164 = (char *)operator new(16 * v163);
          uint64_t v165 = &v164[16 * v160];
          double v166 = &v164[16 * v163];
          *uint64_t v165 = v192.__r_.__value_.__s.__data_[0];
          *((void *)v165 + 1) = v192.__r_.__value_.__l.__size_;
          v192.__r_.__value_.__s.__data_[0] = 0;
          v192.__r_.__value_.__l.__size_ = 0;
          uint64_t v159 = v165 + 16;
          double v167 = (char *)*v156;
          __double2 v168 = (void ***)v156[1];
          if (v168 != *v156) {
            break;
          }
          *long double v156 = v165;
          v156[1] = v159;
          v156[2] = v166;
          if (v168) {
            goto LABEL_226;
          }
LABEL_227:
          v156[1] = v159;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy((void ***)&v192.__r_.__value_.__l.__size_, v192.__r_.__value_.__s.__data_[0]);
          uint64_t v8 = (int64x2_t *)((char *)v8 + 8);
          if (v8 != v131)
          {
            uint64_t v173 = a2[6];
            uint64_t v153 = (long long *)(v173 + 96 * v8->i64[0]);
            if (v173) {
              continue;
            }
          }
          goto LABEL_233;
        }
        do
        {
          char v169 = *((unsigned char *)v168 - 16);
          v168 -= 2;
          *(v165 - 16) = v169;
          v165 -= 16;
          *((void *)v165 + 1) = v168[1];
          *(unsigned char *)__double2 v168 = 0;
          v168[1] = 0;
        }
        while (v168 != (void ***)v167);
        __double2 v168 = (void ***)*v156;
        __double2 v170 = (void ***)v156[1];
        *long double v156 = v165;
        v156[1] = v159;
        v156[2] = v166;
        if (v170 != v168)
        {
          double v171 = v170 - 1;
          do
          {
            double v172 = v171 - 1;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v171, *((unsigned __int8 *)v171 - 8));
            v171 -= 2;
          }
          while (v172 != v168);
        }
        if (!v168) {
          goto LABEL_227;
        }
LABEL_226:
        operator delete(v168);
        goto LABEL_227;
      }
      gdc::tag_invoke(v209, v153);
      v215.__r_.__value_.__s.__data_[0] = v209[0];
      v209[0] = 0;
      v215.__r_.__value_.__l.__size_ = (std::string::size_type)v210;
      uint64_t v210 = 0;
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v210, 0);
LABEL_233:
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json((uint64_t)v207, (unsigned __int8 *)&v215);
      __double2 v174 = nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::operator[]((unsigned __int8 *)a1, (uint64_t)v213);
      int v175 = *v174;
      *__double2 v174 = v207[0];
      v207[0] = v175;
      double v176 = (void **)*((void *)v174 + 1);
      *((void *)v174 + 1) = v208;
      uint64_t v208 = v176;
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v208, v175);
      if ((v213[23] & 0x80000000) != 0) {
        operator delete(*(void **)v213);
      }
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy((void ***)&v215.__r_.__value_.__l.__size_, v215.__r_.__value_.__s.__data_[0]);
      uint64_t v8 = v131;
      uint64_t v9 = (uint64_t *)v188;
      if (v131 == v188) {
        goto LABEL_6;
      }
    }
  }
  *(void *)float64x2_t v213 = a2;
  std::__introsort<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *,false>(0, 0, (uint64_t)v213, 0, 1);
  __p = 0;
LABEL_6:
  uint64_t v12 = a2[9];
  for (uint64_t i = a2[10]; v12 != i; v12 += 80)
  {
    unsigned int v19 = *(uint64_t **)(v12 + 32);
    unsigned int v20 = *(uint64_t **)(v12 + 40);
    if (v19 == v20)
    {
      char v205 = 0;
      uint64_t v206 = 0;
      unint64_t v102 = nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::operator[]((unsigned __int8 *)a1, v12);
      int v16 = *v102;
      *unint64_t v102 = 0;
      char v205 = v16;
      uint64_t v103 = *((void *)v102 + 1);
      *((void *)v102 + 1) = 0;
      uint64_t v206 = v103;
      uint64_t v18 = (void ***)&v206;
LABEL_9:
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v18, v16);
    }
    else if ((unint64_t)((char *)v20 - (char *)v19) <= 0x40)
    {
      switch(*((_DWORD *)v19 + 14))
      {
        case 0:
          uint64_t v104 = *v19;
          char v201 = 5;
          uint64_t v202 = v104;
          unint64_t v105 = nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::operator[]((unsigned __int8 *)a1, v12);
          int v16 = *v105;
          *unint64_t v105 = 5;
          char v201 = v16;
          uint64_t v106 = *((void *)v105 + 1);
          *((void *)v105 + 1) = v104;
          uint64_t v202 = v106;
          uint64_t v18 = (void ***)&v202;
          goto LABEL_9;
        case 1:
          uint64_t v113 = v19[1];
          char v199 = 6;
          uint64_t v200 = v113;
          double v114 = nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::operator[]((unsigned __int8 *)a1, v12);
          int v16 = *v114;
          *double v114 = 6;
          char v199 = v16;
          uint64_t v115 = *((void *)v114 + 1);
          *((void *)v114 + 1) = v113;
          uint64_t v200 = v115;
          uint64_t v18 = (void ***)&v200;
          goto LABEL_9;
        case 2:
          uint64_t v110 = v19[2];
          char v197 = 7;
          uint64_t v198 = v110;
          double v111 = nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::operator[]((unsigned __int8 *)a1, v12);
          int v16 = *v111;
          *double v111 = 7;
          char v197 = v16;
          uint64_t v112 = *((void *)v111 + 1);
          *((void *)v111 + 1) = v110;
          uint64_t v198 = v112;
          uint64_t v18 = (void ***)&v198;
          goto LABEL_9;
        case 3:
          uint64_t v14 = *((unsigned __int8 *)v19 + 24);
          char v195 = 4;
          uint64_t v196 = v14;
          uint64_t v15 = nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::operator[]((unsigned __int8 *)a1, v12);
          int v16 = *v15;
          char *v15 = 4;
          char v195 = v16;
          uint64_t v17 = *((void *)v15 + 1);
          *((void *)v15 + 1) = v14;
          uint64_t v196 = v17;
          uint64_t v18 = (void ***)&v196;
          goto LABEL_9;
        case 4:
          if (*((char *)v19 + 55) < 0)
          {
            std::string::__init_copy_ctor_external((std::string *)v213, (const std::string::value_type *)v19[4], v19[5]);
          }
          else
          {
            *(_OWORD *)float64x2_t v213 = *((_OWORD *)v19 + 2);
            *(void *)&v213[16] = v19[6];
          }
          float v204 = 0;
          char v203 = 3;
          float v116 = (void **)operator new(0x18uLL);
          *(_OWORD *)float v116 = *(_OWORD *)v213;
          v116[2] = *(void **)&v213[16];
          memset(v213, 0, 24);
          float v204 = v116;
          float v117 = nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::operator[]((unsigned __int8 *)a1, v12);
          int v118 = *v117;
          *float v117 = 3;
          char v203 = v118;
          float v119 = (void **)*((void *)v117 + 1);
          *((void *)v117 + 1) = v116;
          float v204 = v119;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v204, v118);
          if ((v213[23] & 0x80000000) != 0) {
            operator delete(*(void **)v213);
          }
          break;
        default:
          continue;
      }
    }
    else
    {
      unsigned __int8 v193 = 2;
      BOOL v21 = (void **)operator new(0x18uLL);
      gss::Allocator *v21 = 0;
      v21[1] = 0;
      void v21[2] = 0;
      double v194 = v21;
      unsigned int v22 = *(uint64_t **)(v12 + 32);
      unsigned int v23 = *(uint64_t **)(v12 + 40);
      if (v22 == v23)
      {
        char v24 = 2;
      }
      else
      {
        while (2)
        {
          switch(*((_DWORD *)v22 + 14))
          {
            case 0:
              uint64_t v26 = *v22;
              uint64_t v27 = v193;
              if (v193)
              {
                if (v193 != 2)
                {
                  exception = __cxa_allocate_exception(0x20uLL);
                  if (v27 > 9) {
                    double v184 = "number";
                  }
                  else {
                    double v184 = off_1E5A8F0B8[v27];
                  }
                  std::string::basic_string[abi:nn180100]<0>(&v215, v184);
                  std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>((std::string *)v213, "cannot use emplace_back() with ", &v215);
                  nlohmann::detail::type_error::create((uint64_t)exception, 311, (uint64_t)v213);
                }
                unsigned int v28 = v194;
              }
              else
              {
                unsigned __int8 v193 = 2;
                unsigned int v28 = (void **)operator new(0x18uLL);
                void *v28 = 0;
                v28[1] = 0;
                v28[2] = 0;
                double v194 = v28;
              }
              size_t v36 = (char *)v28[1];
              uint64_t v50 = (char *)v28[2];
              if (v36 < v50)
              {
                char v51 = 5;
                goto LABEL_58;
              }
              long long v63 = (char *)*v28;
              uint64_t v64 = (v36 - (unsigned char *)*v28) >> 4;
              unint64_t v65 = v64 + 1;
              if ((unint64_t)(v64 + 1) >> 60) {
                abort();
              }
              uint64_t v66 = v50 - v63;
              if (v66 >> 3 > v65) {
                unint64_t v65 = v66 >> 3;
              }
              if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v67 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v67 = v65;
              }
              if (v67 >> 60) {
                goto LABEL_255;
              }
              uint64_t v68 = (char *)operator new(16 * v67);
              size_t v43 = &v68[16 * v64];
              uint64_t v44 = &v68[16 * v67];
              *size_t v43 = 5;
              *((void *)v43 + 1) = v26;
              unsigned int v25 = v43 + 16;
              if (v36 == v63) {
                goto LABEL_100;
              }
              do
              {
                char v69 = *(v36 - 16);
                v36 -= 16;
                *(v43 - 16) = v69;
                v43 -= 16;
                *((void *)v43 + 1) = *((void *)v36 + 1);
                *size_t v36 = 0;
                *((void *)v36 + 1) = 0;
              }
              while (v36 != v63);
              size_t v36 = (char *)*v28;
              uint64_t v70 = (char *)v28[1];
              void *v28 = v43;
              v28[1] = v25;
              v28[2] = v44;
              if (v70 != v36)
              {
                unint64_t v71 = (void ***)(v70 - 8);
                do
                {
                  unint64_t v72 = v71 - 1;
                  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v71, *((unsigned __int8 *)v71 - 8));
                  v71 -= 2;
                }
                while (v72 != (void ***)v36);
              }
              goto LABEL_98;
            case 1:
              uint64_t v26 = v22[1];
              uint64_t v34 = v193;
              if (v193)
              {
                if (v193 != 2)
                {
                  double v181 = __cxa_allocate_exception(0x20uLL);
                  if (v34 > 9) {
                    __double2 v182 = "number";
                  }
                  else {
                    __double2 v182 = off_1E5A8F0B8[v34];
                  }
                  std::string::basic_string[abi:nn180100]<0>(&v215, v182);
                  std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>((std::string *)v213, "cannot use emplace_back() with ", &v215);
                  nlohmann::detail::type_error::create((uint64_t)v181, 311, (uint64_t)v213);
                }
                unsigned int v28 = v194;
              }
              else
              {
                unsigned __int8 v193 = 2;
                unsigned int v28 = (void **)operator new(0x18uLL);
                void *v28 = 0;
                v28[1] = 0;
                v28[2] = 0;
                double v194 = v28;
              }
              size_t v36 = (char *)v28[1];
              char v52 = (char *)v28[2];
              if (v36 < v52)
              {
                char v51 = 6;
LABEL_58:
                *size_t v36 = v51;
                goto LABEL_59;
              }
              uint64_t v73 = (char *)*v28;
              uint64_t v74 = (v36 - (unsigned char *)*v28) >> 4;
              unint64_t v75 = v74 + 1;
              if ((unint64_t)(v74 + 1) >> 60) {
                abort();
              }
              uint64_t v76 = v52 - v73;
              if (v76 >> 3 > v75) {
                unint64_t v75 = v76 >> 3;
              }
              if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v77 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v77 = v75;
              }
              if (v77 >> 60) {
                goto LABEL_255;
              }
              double v78 = (char *)operator new(16 * v77);
              size_t v43 = &v78[16 * v74];
              uint64_t v44 = &v78[16 * v77];
              *size_t v43 = 6;
              *((void *)v43 + 1) = v26;
              unsigned int v25 = v43 + 16;
              if (v36 != v73)
              {
                do
                {
                  char v79 = *(v36 - 16);
                  v36 -= 16;
                  *(v43 - 16) = v79;
                  v43 -= 16;
                  *((void *)v43 + 1) = *((void *)v36 + 1);
                  *size_t v36 = 0;
                  *((void *)v36 + 1) = 0;
                }
                while (v36 != v73);
                size_t v36 = (char *)*v28;
                unint64_t v80 = (char *)v28[1];
                void *v28 = v43;
                v28[1] = v25;
                v28[2] = v44;
                if (v80 != v36)
                {
                  uint64_t v81 = (void ***)(v80 - 8);
                  do
                  {
                    double v82 = v81 - 1;
                    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v81, *((unsigned __int8 *)v81 - 8));
                    v81 -= 2;
                  }
                  while (v82 != (void ***)v36);
                }
                goto LABEL_98;
              }
              goto LABEL_100;
            case 2:
              uint64_t v31 = v22[2];
              uint64_t v32 = v193;
              if (v193)
              {
                if (v193 != 2)
                {
                  __double2 v185 = __cxa_allocate_exception(0x20uLL);
                  if (v32 > 9) {
                    double v186 = "number";
                  }
                  else {
                    double v186 = off_1E5A8F0B8[v32];
                  }
                  std::string::basic_string[abi:nn180100]<0>(&v215, v186);
                  std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>((std::string *)v213, "cannot use emplace_back() with ", &v215);
                  nlohmann::detail::type_error::create((uint64_t)v185, 311, (uint64_t)v213);
                }
                unsigned int v28 = v194;
              }
              else
              {
                unsigned __int8 v193 = 2;
                unsigned int v28 = (void **)operator new(0x18uLL);
                void *v28 = 0;
                v28[1] = 0;
                v28[2] = 0;
                double v194 = v28;
              }
              size_t v36 = (char *)v28[1];
              unsigned int v35 = (char *)v28[2];
              if (v36 < v35)
              {
                *size_t v36 = 7;
                *((void *)v36 + 1) = v31;
                unsigned int v25 = v36 + 16;
                goto LABEL_16;
              }
              long long v37 = (char *)*v28;
              uint64_t v38 = (v36 - (unsigned char *)*v28) >> 4;
              unint64_t v39 = v38 + 1;
              if ((unint64_t)(v38 + 1) >> 60) {
                abort();
              }
              uint64_t v40 = v35 - v37;
              if (v40 >> 3 > v39) {
                unint64_t v39 = v40 >> 3;
              }
              if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v41 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v41 = v39;
              }
              if (v41 >> 60) {
                goto LABEL_255;
              }
              unint64_t v42 = (char *)operator new(16 * v41);
              size_t v43 = &v42[16 * v38];
              uint64_t v44 = &v42[16 * v41];
              *size_t v43 = 7;
              *((void *)v43 + 1) = v31;
              unsigned int v25 = v43 + 16;
              if (v36 == v37) {
                goto LABEL_100;
              }
              do
              {
                char v45 = *(v36 - 16);
                v36 -= 16;
                *(v43 - 16) = v45;
                v43 -= 16;
                *((void *)v43 + 1) = *((void *)v36 + 1);
                *size_t v36 = 0;
                *((void *)v36 + 1) = 0;
              }
              while (v36 != v37);
              size_t v36 = (char *)*v28;
              unint64_t v46 = (char *)v28[1];
              void *v28 = v43;
              v28[1] = v25;
              v28[2] = v44;
              if (v46 != v36)
              {
                double v47 = (void ***)(v46 - 8);
                do
                {
                  char v48 = v47 - 1;
                  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v47, *((unsigned __int8 *)v47 - 8));
                  v47 -= 2;
                }
                while (v48 != (void ***)v36);
              }
              goto LABEL_98;
            case 3:
              uint64_t v26 = *((unsigned __int8 *)v22 + 24);
              uint64_t v33 = v193;
              if (v193)
              {
                if (v193 != 2)
                {
                  long long v179 = __cxa_allocate_exception(0x20uLL);
                  if (v33 > 9) {
                    double v180 = "number";
                  }
                  else {
                    double v180 = off_1E5A8F0B8[v33];
                  }
                  std::string::basic_string[abi:nn180100]<0>(&v215, v180);
                  std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>((std::string *)v213, "cannot use emplace_back() with ", &v215);
                  nlohmann::detail::type_error::create((uint64_t)v179, 311, (uint64_t)v213);
                }
                unsigned int v28 = v194;
              }
              else
              {
                unsigned __int8 v193 = 2;
                unsigned int v28 = (void **)operator new(0x18uLL);
                void *v28 = 0;
                v28[1] = 0;
                v28[2] = 0;
                double v194 = v28;
              }
              size_t v36 = (char *)v28[1];
              unint64_t v49 = (char *)v28[2];
              if (v36 >= v49)
              {
                uint64_t v53 = (char *)*v28;
                uint64_t v54 = (v36 - (unsigned char *)*v28) >> 4;
                unint64_t v55 = v54 + 1;
                if ((unint64_t)(v54 + 1) >> 60) {
                  abort();
                }
                uint64_t v56 = v49 - v53;
                if (v56 >> 3 > v55) {
                  unint64_t v55 = v56 >> 3;
                }
                if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v57 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v57 = v55;
                }
                if (v57 >> 60) {
                  goto LABEL_255;
                }
                uint64_t v58 = (char *)operator new(16 * v57);
                size_t v43 = &v58[16 * v54];
                uint64_t v44 = &v58[16 * v57];
                *size_t v43 = 4;
                *((void *)v43 + 1) = v26;
                unsigned int v25 = v43 + 16;
                if (v36 == v53)
                {
LABEL_100:
                  void *v28 = v43;
                  v28[1] = v25;
                  v28[2] = v44;
                  if (!v36) {
                    goto LABEL_16;
                  }
LABEL_101:
                  operator delete(v36);
                  goto LABEL_16;
                }
                do
                {
                  char v59 = *(v36 - 16);
                  v36 -= 16;
                  *(v43 - 16) = v59;
                  v43 -= 16;
                  *((void *)v43 + 1) = *((void *)v36 + 1);
                  *size_t v36 = 0;
                  *((void *)v36 + 1) = 0;
                }
                while (v36 != v53);
                size_t v36 = (char *)*v28;
                uint64_t v60 = (char *)v28[1];
                void *v28 = v43;
                v28[1] = v25;
                v28[2] = v44;
                if (v60 != v36)
                {
                  long long v61 = (void ***)(v60 - 8);
                  do
                  {
                    float64_t v62 = v61 - 1;
                    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v61, *((unsigned __int8 *)v61 - 8));
                    v61 -= 2;
                  }
                  while (v62 != (void ***)v36);
                }
LABEL_98:
                if (v36) {
                  goto LABEL_101;
                }
              }
              else
              {
                *size_t v36 = 4;
LABEL_59:
                *((void *)v36 + 1) = v26;
                unsigned int v25 = v36 + 16;
              }
LABEL_16:
              v28[1] = v25;
LABEL_17:
              v22 += 8;
              if (v22 != v23) {
                continue;
              }
              BOOL v21 = v194;
              char v24 = v193;
              break;
            case 4:
              if (*((char *)v22 + 55) < 0)
              {
                std::string::__init_copy_ctor_external(&v192, (const std::string::value_type *)v22[4], v22[5]);
                uint64_t v29 = v193;
                if (!v193)
                {
LABEL_23:
                  unsigned __int8 v193 = 2;
                  unsigned int v30 = (void **)operator new(0x18uLL);
                  *unsigned int v30 = 0;
                  v30[1] = 0;
                  v30[2] = 0;
                  double v194 = v30;
                  goto LABEL_105;
                }
              }
              else
              {
                std::string v192 = *(std::string *)(v22 + 4);
                uint64_t v29 = v193;
                if (!v193) {
                  goto LABEL_23;
                }
              }
              if (v29 != 2)
              {
                long long v177 = __cxa_allocate_exception(0x20uLL);
                if (v29 > 9) {
                  __double2 v178 = "number";
                }
                else {
                  __double2 v178 = off_1E5A8F0B8[v29];
                }
                std::string::basic_string[abi:nn180100]<0>(&v215, v178);
                std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>((std::string *)v213, "cannot use emplace_back() with ", &v215);
                nlohmann::detail::type_error::create((uint64_t)v177, 311, (uint64_t)v213);
              }
              unsigned int v30 = v194;
LABEL_105:
              unsigned int v83 = (char *)v30[2];
              int v84 = (char *)v30[1];
              if (v84 < v83)
              {
                *((void *)v84 + 1) = 0;
                *int v84 = 3;
                int v85 = (std::string *)operator new(0x18uLL);
                std::string *v85 = v192;
                memset(&v192, 0, sizeof(v192));
                *((void *)v84 + 1) = v85;
                int v86 = v84 + 16;
                v30[1] = v84 + 16;
                goto LABEL_124;
              }
              uint64_t v87 = (v84 - (unsigned char *)*v30) >> 4;
              if ((unint64_t)(v87 + 1) >> 60) {
                abort();
              }
              uint64_t v88 = v83 - (unsigned char *)*v30;
              uint64_t v89 = v88 >> 3;
              if (v88 >> 3 <= (unint64_t)(v87 + 1)) {
                uint64_t v89 = v87 + 1;
              }
              if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v90 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v90 = v89;
              }
              unint64_t v214 = v30 + 2;
              if (v90)
              {
                if (v90 >> 60) {
                  goto LABEL_255;
                }
                __double2 v91 = (char *)operator new(16 * v90);
              }
              else
              {
                __double2 v91 = 0;
              }
              double v92 = &v91[16 * v87];
              *(void *)float64x2_t v213 = v91;
              *(void *)&v213[8] = v92;
              double v93 = &v91[16 * v90];
              *(void *)&v213[16] = v92;
              *(void *)&v213[24] = v93;
              *((void *)v92 + 1) = 0;
              char *v92 = 3;
              __double2 v94 = (std::string *)operator new(0x18uLL);
              *__double2 v94 = v192;
              memset(&v192, 0, sizeof(v192));
              *((void *)v92 + 1) = v94;
              int v86 = v92 + 16;
              *(void *)&v213[16] = v92 + 16;
              double v95 = (void ***)*v30;
              char v96 = (void ***)v30[1];
              if (v96 == *v30)
              {
                *unsigned int v30 = v92;
                v30[1] = v86;
                v30[2] = v93;
                if (v96) {
                  goto LABEL_123;
                }
              }
              else
              {
                do
                {
                  char v97 = *((unsigned char *)v96 - 16);
                  v96 -= 2;
                  *(v92 - 16) = v97;
                  v92 -= 16;
                  *((void *)v92 + 1) = v96[1];
                  *(unsigned char *)char v96 = 0;
                  v96[1] = 0;
                }
                while (v96 != v95);
                char v96 = (void ***)*v30;
                uint64_t v98 = (void ***)v30[1];
                long long v99 = *(_OWORD *)&v213[16];
                *unsigned int v30 = v92;
                *(_OWORD *)(v30 + 1) = v99;
                int v86 = (void *)v99;
                if (v98 != v96)
                {
                  uint64_t v100 = v98 - 1;
                  do
                  {
                    unint64_t v101 = v100 - 1;
                    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v100, *((unsigned __int8 *)v100 - 8));
                    v100 -= 2;
                  }
                  while (v101 != v96);
                }
                if (v96) {
LABEL_123:
                }
                  operator delete(v96);
              }
LABEL_124:
              v30[1] = v86;
              if (SHIBYTE(v192.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v192.__r_.__value_.__l.__data_);
              }
              goto LABEL_17;
            default:
              goto LABEL_17;
          }
          break;
        }
      }
      uint64_t v191 = v21;
      unsigned __int8 v193 = 0;
      double v194 = 0;
      uint64_t v107 = nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::operator[]((unsigned __int8 *)a1, v12);
      int v108 = *v107;
      *uint64_t v107 = v24;
      double v109 = (void **)*((void *)v107 + 1);
      *((void *)v107 + 1) = v21;
      uint64_t v191 = v109;
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v191, v108);
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v194, 0);
    }
  }
  if (__p) {
    operator delete(__p);
  }
}

void sub_1A2092400(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void ***a10, uint64_t a11, void *__p, void ***a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, unsigned __int8 *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (__p) {
    operator delete(__p);
  }
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(a10, *a20);
  _Unwind_Resume(a1);
}

void nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(void ***a1, int a2)
{
  int v84 = 0;
  int v85 = 0;
  int v86 = 0;
  int v2 = a2 - 1;
  if (a2 == 1)
  {
    unsigned int v22 = *a1;
    unint64_t v23 = (unint64_t)(*a1)[2];
    if (v23)
    {
      if (v23 >> 60) {
        goto LABEL_150;
      }
      uint64_t v8 = (char *)operator new(16 * v23);
      int v84 = v8;
      int v85 = v8;
      int v86 = &v8[16 * v23];
    }
    else
    {
      uint64_t v8 = 0;
    }
    uint64_t v26 = *v22;
    char v24 = v22 + 1;
    unsigned int v25 = v26;
    if (v26 == v24)
    {
LABEL_61:
      unint64_t v3 = (unint64_t)v8;
      goto LABEL_62;
    }
    unint64_t v3 = (unint64_t)v8;
    while (v3 < (unint64_t)v86)
    {
      *(unsigned char *)unint64_t v3 = *((unsigned char *)v25 + 56);
      *(void *)(v3 + 8) = v25[8];
      *((unsigned char *)v25 + 56) = 0;
      v25[8] = 0;
      v3 += 16;
LABEL_53:
      int v85 = (char *)v3;
      uint64_t v38 = (void *)v25[1];
      if (v38)
      {
        do
        {
          unint64_t v39 = v38;
          uint64_t v38 = (void *)*v38;
        }
        while (v38);
      }
      else
      {
        do
        {
          unint64_t v39 = (void *)v25[2];
          BOOL v40 = *v39 == (void)v25;
          unsigned int v25 = v39;
        }
        while (!v40);
      }
      unsigned int v25 = v39;
      if (v39 == v24) {
        goto LABEL_62;
      }
    }
    uint64_t v27 = (uint64_t)(v3 - (void)v8) >> 4;
    unint64_t v28 = v27 + 1;
    if ((unint64_t)(v27 + 1) >> 60) {
      abort();
    }
    uint64_t v29 = v86 - v8;
    if ((v86 - v8) >> 3 > v28) {
      unint64_t v28 = v29 >> 3;
    }
    if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v30 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v30 = v28;
    }
    if (v30 >> 60) {
LABEL_145:
    }
      std::__throw_bad_array_new_length[abi:nn180100]();
    uint64_t v31 = (char *)operator new(16 * v30);
    uint64_t v32 = &v31[16 * v27];
    *uint64_t v32 = *((unsigned char *)v25 + 56);
    *((void *)v32 + 1) = v25[8];
    uint64_t v33 = &v31[16 * v30];
    *((unsigned char *)v25 + 56) = 0;
    v25[8] = 0;
    if ((char *)v3 == v8)
    {
      int v84 = v32;
      int v86 = &v31[16 * v30];
      uint64_t v34 = v32;
      unint64_t v3 = (unint64_t)(v32 + 16);
      if (!v8) {
        goto LABEL_52;
      }
    }
    else
    {
      uint64_t v34 = v32;
      do
      {
        char v35 = *(unsigned char *)(v3 - 16);
        v3 -= 16;
        *(v34 - 16) = v35;
        v34 -= 16;
        *((void *)v34 + 1) = *(void *)(v3 + 8);
        *(unsigned char *)unint64_t v3 = 0;
        *(void *)(v3 + 8) = 0;
      }
      while ((char *)v3 != v8);
      uint64_t v8 = v84;
      int v84 = v34;
      int v86 = v33;
      if (v85 != v8)
      {
        size_t v36 = v85 - 8;
        do
        {
          long long v37 = v36 - 8;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v36, *(v36 - 8));
          v36 -= 16;
        }
        while (v37 != v8);
      }
      unint64_t v3 = (unint64_t)(v32 + 16);
      if (!v8) {
        goto LABEL_52;
      }
    }
    operator delete(v8);
LABEL_52:
    uint64_t v8 = v34;
    goto LABEL_53;
  }
  unint64_t v3 = 0;
  if (a2 == 2)
  {
    long long v4 = *a1;
    unint64_t v6 = **a1;
    uint64_t v5 = (*a1)[1];
    unint64_t v3 = v5 - v6;
    if (v5 != v6)
    {
      if ((v3 & 0x8000000000000000) == 0)
      {
        size_t v7 = (char *)operator new(v5 - v6);
        uint64_t v8 = v7;
        int v84 = v7;
        int v85 = v7;
        int v86 = &v7[16 * ((uint64_t)v3 >> 4)];
        uint64_t v9 = (char *)*v4;
        uint64_t v10 = (char *)v4[1];
        if (v9 != v10)
        {
          unint64_t v3 = (unint64_t)v7;
          while (v3 < (unint64_t)v86)
          {
            *(unsigned char *)unint64_t v3 = *v9;
            *(void *)(v3 + 8) = *((void *)v9 + 1);
            *uint64_t v9 = 0;
            *((void *)v9 + 1) = 0;
            v3 += 16;
LABEL_8:
            int v85 = (char *)v3;
            v9 += 16;
            if (v9 == v10) {
              goto LABEL_62;
            }
          }
          uint64_t v11 = (uint64_t)(v3 - (void)v8) >> 4;
          unint64_t v12 = v11 + 1;
          if ((unint64_t)(v11 + 1) >> 60) {
            abort();
          }
          uint64_t v13 = v86 - v8;
          if ((v86 - v8) >> 3 > v12) {
            unint64_t v12 = v13 >> 3;
          }
          if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v14 = v12;
          }
          if (v14 >> 60) {
            goto LABEL_145;
          }
          uint64_t v15 = (char *)operator new(16 * v14);
          int v16 = &v15[16 * v11];
          *int v16 = *v9;
          *((void *)v16 + 1) = *((void *)v9 + 1);
          uint64_t v17 = &v15[16 * v14];
          *uint64_t v9 = 0;
          *((void *)v9 + 1) = 0;
          if ((char *)v3 == v8)
          {
            int v84 = v16;
            int v86 = &v15[16 * v14];
            uint64_t v18 = v16;
            unint64_t v3 = (unint64_t)(v16 + 16);
            if (!v8) {
              goto LABEL_25;
            }
          }
          else
          {
            uint64_t v18 = v16;
            do
            {
              char v19 = *(unsigned char *)(v3 - 16);
              v3 -= 16;
              *(v18 - 16) = v19;
              v18 -= 16;
              *((void *)v18 + 1) = *(void *)(v3 + 8);
              *(unsigned char *)unint64_t v3 = 0;
              *(void *)(v3 + 8) = 0;
            }
            while ((char *)v3 != v8);
            uint64_t v8 = v84;
            int v84 = v18;
            int v86 = v17;
            if (v85 != v8)
            {
              unsigned int v20 = v85 - 8;
              do
              {
                BOOL v21 = v20 - 8;
                nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v20, *(v20 - 8));
                v20 -= 16;
              }
              while (v21 != v8);
            }
            unint64_t v3 = (unint64_t)(v16 + 16);
            if (!v8) {
              goto LABEL_25;
            }
          }
          operator delete(v8);
LABEL_25:
          uint64_t v8 = v18;
          goto LABEL_8;
        }
        goto LABEL_61;
      }
LABEL_150:
      abort();
    }
  }
LABEL_62:
  if (v84 != (char *)v3)
  {
    while (1)
    {
      unsigned __int8 v82 = *(unsigned char *)(v3 - 16);
      unsigned int v83 = *(void **)(v3 - 8);
      *(unsigned char *)(v3 - 16) = 0;
      *(void *)(v3 - 8) = 0;
      unint64_t v3 = (unint64_t)(v85 - 16);
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v85 - 8, *(v85 - 16));
      int v85 = (char *)v3;
      if (v82 == 1) {
        break;
      }
      if (v82 != 2) {
        goto LABEL_65;
      }
      unint64_t v41 = (void *)*v83;
      size_t v43 = v83 + 1;
      unint64_t v42 = (void *)v83[1];
      if ((void *)*v83 == v42) {
        goto LABEL_64;
      }
      do
      {
        if (v3 < (unint64_t)v86)
        {
          *(unsigned char *)unint64_t v3 = *(unsigned char *)v41;
          *(void *)(v3 + 8) = v41[1];
          *(unsigned char *)unint64_t v41 = 0;
          v41[1] = 0;
          v3 += 16;
          goto LABEL_71;
        }
        uint64_t v44 = v84;
        uint64_t v45 = (uint64_t)(v3 - (void)v84) >> 4;
        unint64_t v46 = v45 + 1;
        if ((unint64_t)(v45 + 1) >> 60) {
          abort();
        }
        uint64_t v47 = v86 - v84;
        if ((v86 - v84) >> 3 > v46) {
          unint64_t v46 = v47 >> 3;
        }
        if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v48 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v48 = v46;
        }
        if (v48 >> 60) {
          goto LABEL_145;
        }
        unint64_t v49 = (char *)operator new(16 * v48);
        uint64_t v50 = &v49[16 * v45];
        char *v50 = *(unsigned char *)v41;
        *((void *)v50 + 1) = v41[1];
        *(unsigned char *)unint64_t v41 = 0;
        v41[1] = 0;
        unint64_t v51 = (unint64_t)(v50 + 16);
        if ((char *)v3 == v44)
        {
          int v84 = v50;
          int v86 = &v49[16 * v48];
        }
        else
        {
          do
          {
            char v52 = *(unsigned char *)(v3 - 16);
            v3 -= 16;
            *(v50 - 16) = v52;
            v50 -= 16;
            *((void *)v50 + 1) = *(void *)(v3 + 8);
            *(unsigned char *)unint64_t v3 = 0;
            *(void *)(v3 + 8) = 0;
          }
          while ((char *)v3 != v44);
          unint64_t v3 = (unint64_t)v84;
          int v84 = v50;
          int v86 = &v49[16 * v48];
          if (v85 != (char *)v3)
          {
            uint64_t v53 = v85 - 8;
            do
            {
              uint64_t v54 = v53 - 8;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v53, *(v53 - 8));
              v53 -= 16;
            }
            while (v54 != (char *)v3);
          }
          if (!v3) {
            goto LABEL_89;
          }
        }
        operator delete((void *)v3);
LABEL_89:
        unint64_t v3 = v51;
LABEL_71:
        int v85 = (char *)v3;
        v41 += 2;
      }
      while (v41 != v42);
      unint64_t v41 = (void *)*v83;
      size_t v43 = v83 + 1;
      uint64_t v71 = v83[1];
      if (v71 == *v83)
      {
        *size_t v43 = v71;
      }
      else
      {
        uint64_t v72 = v71 - 8;
        do
        {
          uint64_t v73 = (void *)(v72 - 8);
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v72, *(unsigned __int8 *)(v72 - 8));
          v72 -= 16;
        }
        while (v73 != v41);
LABEL_64:
        *size_t v43 = v41;
      }
LABEL_65:
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v83, v82);
      if (v84 == (char *)v3) {
        goto LABEL_125;
      }
    }
    unint64_t v55 = v83;
    uint64_t v56 = v83 + 1;
    unint64_t v57 = (void *)*v83;
    if ((void *)*v83 == v83 + 1) {
      goto LABEL_123;
    }
    while (v3 < (unint64_t)v86)
    {
      *(unsigned char *)unint64_t v3 = *((unsigned char *)v57 + 56);
      *(void *)(v3 + 8) = v57[8];
      *((unsigned char *)v57 + 56) = 0;
      v57[8] = 0;
      v3 += 16;
LABEL_112:
      int v85 = (char *)v3;
      char v69 = (void *)v57[1];
      if (v69)
      {
        do
        {
          uint64_t v70 = v69;
          char v69 = (void *)*v69;
        }
        while (v69);
      }
      else
      {
        do
        {
          uint64_t v70 = (void *)v57[2];
          BOOL v40 = *v70 == (void)v57;
          unint64_t v57 = v70;
        }
        while (!v40);
      }
      unint64_t v57 = v70;
      if (v70 == v56)
      {
        unint64_t v55 = v83;
LABEL_123:
        std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::destroy((char *)v55[1]);
        void *v55 = v55 + 1;
        v55[2] = 0;
        v55[1] = 0;
        goto LABEL_65;
      }
    }
    uint64_t v58 = v84;
    uint64_t v59 = (uint64_t)(v3 - (void)v84) >> 4;
    unint64_t v60 = v59 + 1;
    if ((unint64_t)(v59 + 1) >> 60) {
      abort();
    }
    uint64_t v61 = v86 - v84;
    if ((v86 - v84) >> 3 > v60) {
      unint64_t v60 = v61 >> 3;
    }
    if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v62 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v62 = v60;
    }
    if (v62 >> 60) {
      goto LABEL_145;
    }
    long long v63 = (char *)operator new(16 * v62);
    uint64_t v64 = &v63[16 * v59];
    char *v64 = *((unsigned char *)v57 + 56);
    *((void *)v64 + 1) = v57[8];
    *((unsigned char *)v57 + 56) = 0;
    v57[8] = 0;
    unint64_t v65 = (unint64_t)(v64 + 16);
    if ((char *)v3 == v58)
    {
      int v84 = v64;
      int v86 = &v63[16 * v62];
    }
    else
    {
      do
      {
        char v66 = *(unsigned char *)(v3 - 16);
        v3 -= 16;
        *(v64 - 16) = v66;
        v64 -= 16;
        *((void *)v64 + 1) = *(void *)(v3 + 8);
        *(unsigned char *)unint64_t v3 = 0;
        *(void *)(v3 + 8) = 0;
      }
      while ((char *)v3 != v58);
      unint64_t v3 = (unint64_t)v84;
      int v84 = v64;
      int v86 = &v63[16 * v62];
      if (v85 != (char *)v3)
      {
        unint64_t v67 = v85 - 8;
        do
        {
          uint64_t v68 = v67 - 8;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v67, *(v67 - 8));
          v67 -= 16;
        }
        while (v68 != (char *)v3);
      }
      if (!v3) {
        goto LABEL_111;
      }
    }
    operator delete((void *)v3);
LABEL_111:
    unint64_t v3 = v65;
    goto LABEL_112;
  }
LABEL_125:
  switch(v2)
  {
    case 0:
      uint64_t v74 = a1;
      std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::destroy((char *)(*a1)[1]);
      goto LABEL_138;
    case 1:
      uint64_t v74 = a1;
      unint64_t v75 = *a1;
      unint64_t v77 = **a1;
      if (!v77) {
        goto LABEL_139;
      }
      double v78 = v75[1];
      uint64_t v76 = **a1;
      if (v78 != v77)
      {
        uint64_t v79 = (uint64_t)v78 - 8;
        do
        {
          unint64_t v80 = (void *)(v79 - 8);
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v79, *(unsigned __int8 *)(v79 - 8));
          v79 -= 16;
        }
        while (v80 != v77);
        uint64_t v76 = *v75;
      }
      v75[1] = v77;
      break;
    case 2:
      uint64_t v74 = a1;
      unint64_t v75 = *a1;
      if ((*((char *)*a1 + 23) & 0x80000000) == 0) {
        goto LABEL_139;
      }
      uint64_t v76 = *v75;
      break;
    case 7:
      uint64_t v74 = a1;
      unint64_t v75 = *a1;
      uint64_t v76 = **a1;
      if (!v76) {
        goto LABEL_139;
      }
      v75[1] = v76;
      break;
    default:
      goto LABEL_140;
  }
  operator delete(v76);
LABEL_138:
  unint64_t v75 = *v74;
LABEL_139:
  operator delete(v75);
LABEL_140:
  if (v3)
  {
    operator delete((void *)v3);
  }
}

void sub_1A2092F04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~vector[abi:nn180100]((void ****)va);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::destroy(*(void *)a1);
    std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::destroy(*((void *)a1 + 1));
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(a1 + 64, a1[56]);
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

void ****std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~vector[abi:nn180100](void ****a1)
{
  int v2 = *a1;
  if (*a1)
  {
    unint64_t v3 = a1[1];
    long long v4 = *a1;
    if (v3 != v2)
    {
      uint64_t v5 = v3 - 1;
      do
      {
        unint64_t v6 = v5 - 1;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v5, *((unsigned __int8 *)v5 - 8));
        v5 -= 2;
      }
      while (v6 != v2);
      long long v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = (char *)result;
  switch(*(unsigned char *)a2)
  {
    case 0:
      unint64_t v6 = *(void (**)(void))(**(void **)result + 8);
      goto LABEL_234;
    case 1:
      unint64_t v6 = *(void (**)(void))(**(void **)result + 8);
      if (!*(void *)(*(void *)(a2 + 8) + 16)) {
        goto LABEL_234;
      }
      v6();
      unint64_t v7 = a3 + 4;
      uint64_t v8 = v5 + 608;
      if (v5[631] < 0)
      {
        unint64_t v9 = *((void *)v5 + 77);
        if (v9 >= v7) {
          goto LABEL_6;
        }
      }
      else
      {
        unint64_t v9 = v5[631];
        if (v7 <= v9) {
          goto LABEL_6;
        }
      }
      std::string::resize((std::string *)(v5 + 608), 2 * v9, 32);
LABEL_6:
      uint64_t v10 = *(void **)(a2 + 8);
      uint64_t v11 = (void *)*v10;
      if (v10[2] == 1)
      {
        unint64_t v12 = (void *)*v10;
      }
      else
      {
        unint64_t v46 = 0;
        do
        {
          uint64_t v47 = v5 + 608;
          if (v5[631] < 0) {
            uint64_t v47 = *(char **)v8;
          }
          (*(void (**)(void, char *, void))(**(void **)v5 + 8))(*(void *)v5, v47, a3 + 4);
          (***(void (****)(void))v5)();
          nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump_escaped((uint64_t)v5, v11 + 4);
          (*(void (**)(void, const char *, uint64_t))(**(void **)v5 + 8))(*(void *)v5, "\": ", 3);
          nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump(v5, v11 + 7, a3 + 4);
          (*(void (**)(void, const char *, uint64_t))(**(void **)v5 + 8))(*(void *)v5, ",\n", 2);
          unint64_t v48 = (void *)v11[1];
          if (v48)
          {
            do
            {
              unint64_t v12 = v48;
              unint64_t v48 = (void *)*v48;
            }
            while (v48);
          }
          else
          {
            do
            {
              unint64_t v12 = (void *)v11[2];
              BOOL v49 = *v12 == (void)v11;
              uint64_t v11 = v12;
            }
            while (!v49);
          }
          ++v46;
          uint64_t v11 = v12;
        }
        while (v46 < *(void *)(*(void *)(a2 + 8) + 16) - 1);
      }
      uint64_t v13 = v5 + 608;
      if (v5[631] < 0) {
        uint64_t v13 = *(char **)v8;
      }
      (*(void (**)(void, char *, void))(**(void **)v5 + 8))(*(void *)v5, v13, a3 + 4);
      (***(void (****)(void))v5)();
      nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump_escaped((uint64_t)v5, v12 + 4);
      (*(void (**)(void, const char *, uint64_t))(**(void **)v5 + 8))(*(void *)v5, "\": ", 3);
      nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump(v5, v12 + 7, a3 + 4);
      (***(void (****)(void))v5)();
      goto LABEL_121;
    case 2:
      unint64_t v6 = *(void (**)(void))(**(void **)result + 8);
      if (**(void **)(a2 + 8) == *(void *)(*(void *)(a2 + 8) + 8)) {
        goto LABEL_234;
      }
      v6();
      unint64_t v14 = a3 + 4;
      uint64_t v8 = v5 + 608;
      if (v5[631] < 0)
      {
        unint64_t v15 = *((void *)v5 + 77);
        if (v15 >= v14) {
          goto LABEL_14;
        }
      }
      else
      {
        unint64_t v15 = v5[631];
        if (v14 <= v15) {
          goto LABEL_14;
        }
      }
      std::string::resize((std::string *)(v5 + 608), 2 * v15, 32);
LABEL_14:
      int v16 = *(uint64_t **)(a2 + 8);
      uint64_t v17 = *v16;
      if (*v16 != v16[1] - 16)
      {
        do
        {
          (*(void (**)(void))(**(void **)v5 + 8))();
          nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump(v5, v17, a3 + 4);
          (*(void (**)(void, const char *, uint64_t))(**(void **)v5 + 8))(*(void *)v5, ",\n", 2);
          v17 += 16;
        }
        while (v17 != *(void *)(*(void *)(a2 + 8) + 8) - 16);
      }
      unint64_t v30 = v5 + 608;
      if (v5[631] < 0) {
        unint64_t v30 = *(char **)v8;
      }
      (*(void (**)(void, char *, void))(**(void **)v5 + 8))(*(void *)v5, v30, a3 + 4);
      nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump(v5, *(void *)(*(void *)(a2 + 8) + 8) - 16, a3 + 4);
      (***(void (****)(void))v5)();
      uint64_t v31 = *(void (****)(void))v5;
      if (v5[631] < 0) {
        uint64_t v8 = *(char **)v8;
      }
      goto LABEL_123;
    case 3:
      (***(void (****)(void))result)();
      nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump_escaped((uint64_t)v5, *(uint64_t **)(a2 + 8));
      unint64_t v6 = ***(void (****)(void))v5;
      goto LABEL_124;
    case 4:
      unint64_t v6 = *(void (**)(void))(**(void **)result + 8);
      goto LABEL_234;
    case 5:
      unint64_t v18 = *(void *)(a2 + 8);
      if (!v18) {
        goto LABEL_38;
      }
      char v19 = (unsigned char *)(result + 16);
      if ((v18 & 0x8000000000000000) != 0)
      {
        *char v19 = 45;
        unint64_t v18 = -(uint64_t)v18;
        unsigned int v20 = 1;
        if (v18 < 0xA) {
          goto LABEL_157;
        }
        unint64_t v52 = v18;
        while (1)
        {
          if (v52 <= 0x63)
          {
            ++v20;
            goto LABEL_157;
          }
          if (v52 <= 0x3E7)
          {
            v20 += 2;
            goto LABEL_157;
          }
          if (v52 >> 4 <= 0x270) {
            break;
          }
          v20 += 4;
          BOOL v128 = v52 >= 0x186A0;
          v52 /= 0x2710uLL;
          if (!v128) {
            goto LABEL_157;
          }
        }
        v20 += 3;
      }
      else
      {
        if (v18 < 0xA) {
          goto LABEL_30;
        }
        unsigned int v20 = 1;
        unint64_t v21 = *(void *)(a2 + 8);
        while (v21 > 0x63)
        {
          if (v21 <= 0x3E7)
          {
            v20 += 2;
            goto LABEL_158;
          }
          if (v21 >> 4 <= 0x270)
          {
            v20 += 3;
            goto LABEL_158;
          }
          v20 += 4;
          BOOL v128 = v21 >= 0x186A0;
          v21 /= 0x2710uLL;
          if (!v128) {
            goto LABEL_158;
          }
        }
      }
LABEL_157:
      ++v20;
LABEL_158:
      uint64_t v22 = (uint64_t)&v19[v20];
      if (v18 < 0x64)
      {
        unint64_t v108 = v18;
      }
      else
      {
        do
        {
          unint64_t v108 = v18 / 0x64;
          *(_WORD *)(v22 - 2) = nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump_integer<unsigned long long,0>(unsigned long long)::digits_to_99[v18 % 0x64];
          v22 -= 2;
          unint64_t v110 = v18 >> 4;
          v18 /= 0x64uLL;
        }
        while (v110 > 0x270);
      }
      if (v108 >= 0xA) {
        goto LABEL_163;
      }
      goto LABEL_148;
    case 6:
      unint64_t v18 = *(void *)(a2 + 8);
      if (v18)
      {
        if (v18 >= 0xA)
        {
          unsigned int v50 = 1;
          unint64_t v51 = *(void *)(a2 + 8);
          while (1)
          {
            if (v51 <= 0x63)
            {
              ++v50;
              goto LABEL_143;
            }
            if (v51 <= 0x3E7)
            {
              v50 += 2;
              goto LABEL_143;
            }
            if (v51 >> 4 <= 0x270) {
              break;
            }
            v50 += 4;
            BOOL v128 = v51 >= 0x186A0;
            v51 /= 0x2710uLL;
            if (!v128) {
              goto LABEL_143;
            }
          }
          v50 += 3;
LABEL_143:
          uint64_t v22 = result + 16 + v50;
          if (v18 < 0x64)
          {
            unint64_t v108 = *(void *)(a2 + 8);
          }
          else
          {
            do
            {
              unint64_t v108 = v18 / 0x64;
              *(_WORD *)(v22 - 2) = nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump_integer<unsigned long long,0>(unsigned long long)::digits_to_99[v18 % 0x64];
              v22 -= 2;
              unint64_t v109 = v18 >> 4;
              v18 /= 0x64uLL;
            }
            while (v109 > 0x270);
          }
          if (v108 >= 0xA)
          {
LABEL_163:
            *(_WORD *)(v22 - 2) = nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump_integer<unsigned long long,0>(unsigned long long)::digits_to_99[v108];
            goto LABEL_164;
          }
LABEL_148:
          LOBYTE(v18) = v108;
        }
        else
        {
LABEL_30:
          uint64_t v22 = result + 17;
        }
        *(unsigned char *)(v22 - 1) = v18 + 48;
LABEL_164:
        double v111 = *(void (****)(void))result;
        goto LABEL_233;
      }
LABEL_38:
      uint64_t v29 = ***(uint64_t (****)(void))result;
      return v29();
    case 7:
      double v23 = *(double *)(a2 + 8);
      if ((*(void *)&v23 & 0x8000000000000000) != 0)
      {
        double v23 = -v23;
        uint64_t v24 = result + 17;
        *(unsigned char *)(result + 16) = 45;
        if (v23 == 0.0) {
          goto LABEL_33;
        }
      }
      else
      {
        uint64_t v24 = result + 16;
        if (v23 == 0.0)
        {
LABEL_33:
          *(_WORD *)uint64_t v24 = 11824;
          *(unsigned char *)(v24 + 2) = 48;
          goto LABEL_232;
        }
      }
      uint64_t v32 = *(void *)&v23 & 0xFFFFFFFFFFFFFLL;
      uint64_t v33 = *(void *)&v23 >> 52;
      if (*(void *)&v23 >> 52)
      {
        uint64_t v34 = 2 * (v32 | 0x10000000000000);
        uint64_t v35 = (2 * (*(void *)&v23 & 0xFFFFFFFFFFFFFLL | 0x10000000000000)) | 1;
        int v36 = v33 - 1076;
        if (*(void *)&v23 >> 53 && !v32)
        {
          char v55 = v33 - 53;
          uint64_t v56 = 0x3FFFFFFFFFFFFFLL;
          uint64_t v32 = 0x10000000000000;
          goto LABEL_129;
        }
        v32 |= 0x10000000000000uLL;
      }
      else
      {
        uint64_t v34 = 2 * v32;
        uint64_t v35 = (2 * (*(void *)&v23 & 0xFFFFFFFFFFFFFLL)) | 1;
        int v36 = -1075;
      }
      uint64_t v56 = v34 - 1;
      char v55 = v36;
      do
      {
LABEL_129:
        int v63 = v36;
        unint64_t v64 = v35;
        v35 *= 2;
        --v36;
      }
      while ((v35 & 0x8000000000000000) == 0);
      do
      {
        unint64_t v65 = v32;
        v32 *= 2;
      }
      while ((v32 & 0x8000000000000000) == 0);
      unint64_t v66 = v56 << (v55 - v36);
      int v67 = -60 - v63;
      int v68 = 78913 * (-60 - v63) / 0x40000;
      if (v67 <= 0) {
        int v69 = v68;
      }
      else {
        int v69 = v68 + 1;
      }
      uint64_t v70 = (char *)&nlohmann::detail::dtoa_impl::get_cached_power_for_binary_exponent(int)::kCachedPowers
          + 16 * ((int)((v69 + 307 + (((v69 + 307) >> 28) & 7)) << 16) >> 19);
      uint64_t v71 = v70 + 8;
      unsigned int v72 = v32 & 0xFFFFFFFE;
      unint64_t v73 = v65 >> 31;
      uint64_t v74 = *(void *)v70;
      uint64_t v75 = HIDWORD(*(void *)v70);
      unint64_t v76 = v74 * v72;
      unint64_t v77 = HIDWORD(*(void *)v70) * (unint64_t)v72;
      unint64_t v78 = HIDWORD(v77);
      unint64_t v79 = (v74 * v73) >> 32;
      unint64_t v80 = ((v77 & 0xFFFFFFFE)
           + HIDWORD(v76)
           + *(void *)v70 * v73
           + 0x80000000) >> 32;
      unint64_t v81 = v79 + v75 * v73 + HIDWORD(v77) + v80;
      unint64_t v82 = HIDWORD(v66);
      unint64_t v83 = HIDWORD(*(void *)v70) * (unint64_t)v66;
      unint64_t v84 = v74 * HIDWORD(v66);
      unint64_t v85 = HIDWORD(v83);
      unint64_t v86 = HIDWORD(v84);
      unint64_t v87 = (((v74 * (unint64_t)v66) >> 32) + v83 + v84 + 0x80000000) >> 32;
      int v88 = v36 + *((_DWORD *)v70 + 2);
      char v89 = -64 - v88;
      unsigned int v90 = v35 & 0xFFFFFFFE;
      unint64_t v91 = v64 >> 31;
      unint64_t v92 = v74 * (unint64_t)v90;
      unint64_t v93 = v75 * (unint64_t)v90;
      unint64_t v94 = v74 * (v64 >> 31);
      unint64_t v95 = HIDWORD(v93);
      unint64_t v96 = HIDWORD(v94);
      unint64_t v97 = ((v93 & 0xFFFFFFFE) + HIDWORD(v92) + v94 + 0x80000000) >> 32;
      unint64_t v98 = v75 * v91 + HIDWORD(v93) + HIDWORD(v94) + v97 - 1;
      int v99 = -*((_DWORD *)v71 + 1);
      unint64_t v100 = ~(HIDWORD(v84) + v75 * (unint64_t)v82 + v85 + v87) + v98;
      unint64_t v101 = v98 - v81;
      int v102 = -v88;
      unint64_t v103 = 1 << -(char)v88;
      unint64_t v104 = v98 >> v102;
      unint64_t v105 = (v103 - 1) & v98;
      if (v104 <= 0x3B9AC9FF)
      {
        if (v104 <= 0x5F5E0FF)
        {
          if (v104 <= 0x98967F)
          {
            if (v104 <= 0xF423F)
            {
              unsigned int v154 = v104 >> 5;
              unsigned int v112 = v104 >> 4;
              if (v104 <= 9) {
                int v113 = 1;
              }
              else {
                int v113 = 10;
              }
              if (v104 <= 9) {
                int v114 = 1;
              }
              else {
                int v114 = 2;
              }
              if (v104 > 0x63)
              {
                int v113 = 100;
                int v114 = 3;
              }
              if (v104 > 0x3E7)
              {
                int v113 = 1000;
                int v114 = 4;
              }
              BOOL v115 = v112 > 0x270;
              if (v112 <= 0x270) {
                int v116 = v113;
              }
              else {
                int v116 = 10000;
              }
              if (v115) {
                unsigned int v107 = 5;
              }
              else {
                unsigned int v107 = v114;
              }
              if (v154 > 0xC34) {
                unsigned int v106 = 100000;
              }
              else {
                unsigned int v106 = v116;
              }
              if (v154 > 0xC34) {
                unsigned int v107 = 6;
              }
            }
            else
            {
              unsigned int v106 = 1000000;
              unsigned int v107 = 7;
            }
          }
          else
          {
            unsigned int v106 = 10000000;
            unsigned int v107 = 8;
          }
        }
        else
        {
          unsigned int v106 = 100000000;
          unsigned int v107 = 9;
        }
      }
      else
      {
        unsigned int v106 = 1000000000;
        unsigned int v107 = 10;
      }
      uint64_t v117 = 0;
      uint64_t v118 = v107;
      unint64_t v119 = ~v81 + v95 + v96 + v75 * v91 + v97;
      uint64_t v120 = v95 - (v85 + v86) - v87 + v96 + v97 + v75 * (v91 - v82) - 2;
      uint64_t v121 = v105 - v95 - v96 - v97 + v78 + v79 + v80 + v75 * (v73 - v91) + 1;
      while (1)
      {
        uint64_t v122 = v117;
        if (v117 == v118) {
          break;
        }
        unsigned int v123 = v104 / v106;
        unint64_t v104 = v104 % v106;
        unsigned int v124 = v123 + 48;
        uint64_t v117 = v122 + 1;
        *(unsigned char *)(v24 + v122) = v124;
        --v107;
        unint64_t v125 = v104 << v89;
        unint64_t v126 = (v104 << v89) + v105;
        if (v100 < v126)
        {
          v106 /= 0xAu;
        }
        else
        {
          v99 += v107;
          unint64_t v127 = (unint64_t)v106 << v89;
          BOOL v128 = v126 < v101 && v100 - v126 >= v127;
          if (!v128) {
            goto LABEL_211;
          }
          uint64_t v129 = 0;
          unint64_t v130 = v105 + v125 + v127;
          unint64_t v131 = v120 - v130;
          unint64_t v132 = v121 + v125 + v127;
          do
          {
            if (v130 >= v101 && v119 - v126 + v129 <= v132) {
              break;
            }
            *(unsigned char *)(v24 + v122) = --v124;
            if (v130 >= v101) {
              break;
            }
            unint64_t v133 = v131 + v129;
            v129 -= v127;
            v130 += v127;
            v132 += v127;
          }
          while (v133 >= v127);
        }
        if (v100 >= v126) {
          goto LABEL_211;
        }
      }
      uint64_t v134 = 0;
      do
      {
        unint64_t v135 = v101;
        unint64_t v136 = (10 * v105) >> v89;
        unint64_t v105 = (10 * v105) & (v103 - 1);
        int v137 = v136 + 48;
        *(unsigned char *)(v24 + v117 + v134) = v137;
        v100 *= 10;
        v101 *= 10;
        ++v134;
      }
      while (v100 < v105);
      v117 += v134;
      v99 -= v134;
      if (v105 < v101 && v100 - v105 >= v103)
      {
        uint64_t v138 = -(uint64_t)v105;
        unint64_t v139 = v100 - v103;
        unint64_t v140 = v103 + v105;
        uint64_t v141 = -10 * v135;
        do
        {
          if (v140 >= v101 && v101 + v138 <= v141 + v140) {
            break;
          }
          *(unsigned char *)(v24 + v117 - 1) = --v137;
          if (v140 >= v101) {
            break;
          }
          unint64_t v142 = v139 + v138;
          v138 -= v103;
          v140 += v103;
        }
        while (v142 >= v103);
      }
LABEL_211:
      uint64_t v143 = v99 + (uint64_t)(int)v117;
      if ((v99 & 0x80000000) == 0 && (int)v143 <= 15)
      {
        memset((void *)(v24 + (int)v117), 48, v99);
        *(_WORD *)(v24 + v143) = 12334;
        goto LABEL_232;
      }
      if ((v143 - 16) >= 0xFFFFFFF1)
      {
        uint64_t v145 = v143;
        size_t v146 = (unsigned char *)(v24 + v143);
        memmove(v146 + 1, v146, (int)v117 - v145);
        *size_t v146 = 46;
        goto LABEL_232;
      }
      if (v143 == 0 || v143 >= 0xFFFFFFFD)
      {
        size_t v144 = -(int)v143;
        memmove((void *)(v24 + v144 + 2), (const void *)v24, (int)v117);
        *(_WORD *)uint64_t v24 = 11824;
        memset((void *)(v24 + 2), 48, v144);
        goto LABEL_232;
      }
      if (v117 == 1)
      {
        uint64_t v147 = 1;
      }
      else
      {
        uint64_t v148 = (int)v117;
        memmove((void *)(v24 + 2), (const void *)(v24 + 1), (int)v117 - 1);
        *(unsigned char *)(v24 + 1) = 46;
        uint64_t v147 = v148 + 1;
      }
      int v149 = (unsigned char *)(v24 + v147);
      *int v149 = 101;
      unsigned int v150 = v143 - 1;
      if ((int)v143 >= 1) {
        char v151 = 43;
      }
      else {
        char v151 = 45;
      }
      if ((int)v143 - 1 < 0) {
        unsigned int v150 = 1 - v143;
      }
      v149[1] = v151;
      if (v150 <= 9)
      {
        v149[2] = 48;
        char v152 = v150 + 48;
LABEL_230:
        v149[3] = v152;
        goto LABEL_232;
      }
      if (v150 <= 0x63)
      {
        v149[2] = v150 / 0xAu + 48;
        char v152 = (v150 % 0xAu) | 0x30;
        goto LABEL_230;
      }
      v149[2] = v150 / 0x64 + 48;
      unsigned __int8 v153 = v150 % 0x64;
      v149[3] = (v153 / 0xAu) | 0x30;
      v149[4] = (v153 % 0xAu) | 0x30;
LABEL_232:
      double v111 = *(void (****)(void))v5;
LABEL_233:
      unint64_t v6 = (*v111)[1];
LABEL_234:
      return ((uint64_t (*)(void))v6)();
    case 8:
      (*(void (**)(void))(**(void **)result + 8))();
      unint64_t v25 = a3 + 4;
      uint64_t v8 = v5 + 608;
      if (v5[631] < 0)
      {
        unint64_t v26 = *((void *)v5 + 77);
        if (v26 >= v25)
        {
          uint64_t v27 = *(void (****)(void))v5;
LABEL_53:
          unint64_t v28 = *(char **)v8;
          goto LABEL_54;
        }
      }
      else
      {
        unint64_t v26 = v5[631];
        if (v25 <= v26)
        {
          uint64_t v27 = *(void (****)(void))v5;
          unint64_t v28 = v5 + 608;
          goto LABEL_54;
        }
      }
      std::string::resize((std::string *)(v5 + 608), 2 * v26, 32);
      uint64_t v27 = *(void (****)(void))v5;
      unint64_t v28 = v5 + 608;
      if (v5[631] < 0) {
        goto LABEL_53;
      }
LABEL_54:
      ((void (*)(void (***)(void), char *, void))(*v27)[1])(v27, v28, a3 + 4);
      (*(void (**)(void, const char *, uint64_t))(**(void **)v5 + 8))(*(void *)v5, "\"bytes\": [", 10);
      long long v37 = *(unsigned __int8 ***)(a2 + 8);
      unint64_t v39 = *v37;
      uint64_t v38 = v37[1];
      if (v39 == v38) {
        goto LABEL_106;
      }
      if (v39 != v38 - 1)
      {
        while (1)
        {
          unsigned __int8 v40 = *v39;
          if (*v39) {
            break;
          }
          (***(void (****)(void, uint64_t))v5)(*(void *)v5, 48);
LABEL_58:
          (*(void (**)(void, const char *, uint64_t))(**(void **)v5 + 8))(*(void *)v5, ", ", 2);
          if (++v39 == (unsigned __int8 *)(*(void *)(*(void *)(a2 + 8) + 8) - 1)) {
            goto LABEL_67;
          }
        }
        if (*v39 >= 0xAu)
        {
          if (*v39 < 0x64u)
          {
            unint64_t v42 = (char *)&nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump_integer<unsigned long long,0>(unsigned long long)::digits_to_99[*v39];
            v5[17] = v42[1];
            char v43 = *v42;
            uint64_t v41 = 2;
LABEL_66:
            v5[16] = v43;
            (*(void (**)(void, char *, uint64_t))(**(void **)v5 + 8))(*(void *)v5, v5 + 16, v41);
            goto LABEL_58;
          }
          *(_WORD *)(v5 + 17) = nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump_integer<unsigned long long,0>(unsigned long long)::digits_to_99[*v39 % 0x64u];
          v40 /= 0x64u;
          uint64_t v41 = 3;
        }
        else
        {
          uint64_t v41 = 1;
        }
        char v43 = v40 | 0x30;
        goto LABEL_66;
      }
LABEL_67:
      unsigned __int8 v44 = *v39;
      if (!*v39)
      {
        (***(void (****)(void, uint64_t))v5)(*(void *)v5, 48);
        goto LABEL_106;
      }
      if (*v39 >= 0xAu)
      {
        if (*v39 < 0x64u)
        {
          uint64_t v53 = (char *)&nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump_integer<unsigned long long,0>(unsigned long long)::digits_to_99[*v39];
          v5[17] = v53[1];
          char v54 = *v53;
          uint64_t v45 = 2;
          goto LABEL_105;
        }
        *(_WORD *)(v5 + 17) = nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump_integer<unsigned long long,0>(unsigned long long)::digits_to_99[*v39 % 0x64u];
        uint64_t v45 = 3;
        v44 /= 0x64u;
      }
      else
      {
        uint64_t v45 = 1;
      }
      char v54 = v44 | 0x30;
LABEL_105:
      v5[16] = v54;
      (*(void (**)(void, char *, uint64_t))(**(void **)v5 + 8))(*(void *)v5, v5 + 16, v45);
LABEL_106:
      (*(void (**)(void, const char *, uint64_t))(**(void **)v5 + 8))(*(void *)v5, "],\n", 3);
      unint64_t v57 = v5 + 608;
      if (v5[631] < 0) {
        unint64_t v57 = *(char **)v8;
      }
      (*(void (**)(void, char *, void))(**(void **)v5 + 8))(*(void *)v5, v57, a3 + 4);
      (*(void (**)(void, const char *, uint64_t))(**(void **)v5 + 8))(*(void *)v5, "\"subtype\": ", 11);
      uint64_t v58 = *(void *)(a2 + 8);
      if (!*(unsigned char *)(v58 + 25))
      {
        unint64_t v60 = *(void (**)(void))(**(void **)v5 + 8);
        goto LABEL_119;
      }
      unsigned __int8 v59 = *(unsigned char *)(v58 + 24);
      if (!v59)
      {
        (***(void (****)(void, uint64_t))v5)(*(void *)v5, 48);
        goto LABEL_120;
      }
      if (v59 < 0xAu) {
        goto LABEL_117;
      }
      if (v59 >= 0x64u)
      {
        *(_WORD *)(v5 + 17) = nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump_integer<unsigned long long,0>(unsigned long long)::digits_to_99[v59 % 0x64u];
        v59 /= 0x64u;
LABEL_117:
        char v62 = v59 | 0x30;
      }
      else
      {
        uint64_t v61 = (char *)&nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump_integer<unsigned long long,0>(unsigned long long)::digits_to_99[v59];
        v5[17] = v61[1];
        char v62 = *v61;
      }
      v5[16] = v62;
      unint64_t v60 = *(void (**)(void))(**(void **)v5 + 8);
LABEL_119:
      v60();
LABEL_120:
      (***(void (****)(void, uint64_t))v5)(*(void *)v5, 10);
LABEL_121:
      uint64_t v31 = *(void (****)(void))v5;
      if (v5[631] < 0) {
        uint64_t v8 = *(char **)v8;
      }
LABEL_123:
      ((void (*)(void (***)(void), char *, void))(*v31)[1])(v31, v8, a3);
      unint64_t v6 = ***(void (****)(void))v5;
LABEL_124:
      return ((uint64_t (*)(void))v6)();
    case 9:
      unint64_t v6 = *(void (**)(void))(**(void **)result + 8);
      goto LABEL_234;
    default:
      return result;
  }
}

uint64_t nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~serializer(uint64_t a1)
{
  if (*(char *)(a1 + 631) < 0)
  {
    operator delete(*(void **)(a1 + 608));
    int v2 = *(std::__shared_weak_count **)(a1 + 8);
    if (!v2) {
      return a1;
    }
  }
  else
  {
    int v2 = *(std::__shared_weak_count **)(a1 + 8);
    if (!v2) {
      return a1;
    }
  }
  if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::dump_escaped(uint64_t result, uint64_t *a2)
{
  LOBYTE(v2) = *((char *)a2 + 23) < 0;
  uint64_t v3 = *((unsigned __int8 *)a2 + 23);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = a2[1];
  }
  if (v3)
  {
    uint64_t v5 = (_DWORD *)result;
    unint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    unsigned int v10 = 0;
    unsigned int v11 = 0;
    uint64_t v12 = result + 90;
    do
    {
      if (v2) {
        unint64_t v15 = (uint64_t *)*a2;
      }
      else {
        unint64_t v15 = a2;
      }
      uint64_t v16 = *((unsigned __int8 *)v15 + v6);
      if (v10) {
        unsigned int v11 = v16 & 0x3F | (v11 << 6);
      }
      else {
        unsigned int v11 = (0xFFu >> nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::decode(unsigned char &,unsigned int &,unsigned char)::utf8d[v16]) & v16;
      }
      unsigned int v10 = nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::decode(unsigned char &,unsigned int &,unsigned char)::utf8d[16 * v10 + 256 + nlohmann::detail::serializer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::decode(unsigned char &,unsigned int &,unsigned char)::utf8d[v16]];
      if (v10 == 1)
      {
        int v18 = v5[158];
        if ((v18 - 1) >= 2)
        {
          if (!v18)
          {
            char v36 = 3;
            *(_DWORD *)__str = 0;
            snprintf(__str, 3uLL, "%.2X", v16);
            exception = __cxa_allocate_exception(0x20uLL);
            std::to_string(&v29, v6);
            std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&v30, "invalid UTF-8 byte at index ", &v29);
            std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&v31, &v30, ": 0x");
            if (v36 >= 0) {
              double v23 = __str;
            }
            else {
              double v23 = *(char **)__str;
            }
            if (v36 >= 0) {
              std::string::size_type v24 = v36;
            }
            else {
              std::string::size_type v24 = v35;
            }
            unint64_t v25 = std::string::append(&v31, v23, v24);
            std::string::size_type v26 = v25->__r_.__value_.__r.__words[2];
            long long v32 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
            std::string::size_type v33 = v26;
            v25->__r_.__value_.__l.__size_ = 0;
            v25->__r_.__value_.__r.__words[2] = 0;
            v25->__r_.__value_.__r.__words[0] = 0;
            nlohmann::detail::type_error::create((uint64_t)exception, 316, (uint64_t)&v32);
          }
          unsigned int v10 = 1;
        }
        else
        {
          v6 -= v7 != 0;
          if (v18 == 1)
          {
            uint64_t v19 = v12 + v8;
            uint64_t v9 = v8 + 3;
            *(_WORD *)uint64_t v19 = -16401;
            *(unsigned char *)(v19 + 2) = -67;
            if ((unint64_t)(v8 - 497) > 0xC)
            {
LABEL_37:
              unsigned int v10 = 0;
              uint64_t v7 = 0;
              uint64_t v8 = v9;
            }
            else
            {
LABEL_22:
              __n128 result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)v5 + 8))(*(void *)v5, v12, v9);
              unsigned int v10 = 0;
              uint64_t v9 = 0;
              uint64_t v8 = 0;
              uint64_t v7 = 0;
            }
          }
          else
          {
            unsigned int v10 = 0;
            uint64_t v7 = 0;
            uint64_t v9 = v8;
          }
        }
      }
      else
      {
        if (!v10)
        {
          switch(v11)
          {
            case 8u:
              __int16 v17 = 25180;
              goto LABEL_35;
            case 9u:
              __int16 v17 = 29788;
              goto LABEL_35;
            case 0xAu:
              __int16 v17 = 28252;
              goto LABEL_35;
            case 0xBu:
            case 0xEu:
            case 0xFu:
            case 0x10u:
            case 0x11u:
            case 0x12u:
            case 0x13u:
            case 0x14u:
            case 0x15u:
            case 0x16u:
            case 0x17u:
            case 0x18u:
            case 0x19u:
            case 0x1Au:
            case 0x1Bu:
            case 0x1Cu:
            case 0x1Du:
            case 0x1Eu:
            case 0x1Fu:
            case 0x20u:
            case 0x21u:
              goto LABEL_28;
            case 0xCu:
              __int16 v17 = 26204;
              goto LABEL_35;
            case 0xDu:
              __int16 v17 = 29276;
              goto LABEL_35;
            case 0x22u:
              __int16 v17 = 8796;
              goto LABEL_35;
            default:
              if (v11 == 92)
              {
                __int16 v17 = 23644;
LABEL_35:
                *(_WORD *)(v12 + v9) = v17;
                v9 += 2;
              }
              else
              {
LABEL_28:
                if (v11 > 0x1F)
                {
                  *(unsigned char *)(v12 + v9++) = v16;
                }
                else
                {
                  __n128 result = snprintf((char *)(v12 + v9), 7uLL, "\\u%04x", v11);
                  v9 += 6;
                }
              }
              if ((unint64_t)(v9 - 500) > 0xC) {
                goto LABEL_37;
              }
              goto LABEL_22;
          }
        }
        *(unsigned char *)(v12 + v9++) = v16;
        ++v7;
      }
      ++v6;
      int v13 = *((char *)a2 + 23);
      unsigned int v2 = v13 >> 31;
      unint64_t v14 = a2[1];
      if (v13 >= 0) {
        unint64_t v14 = *((unsigned __int8 *)a2 + 23);
      }
    }
    while (v6 < v14);
    if (!v10)
    {
      if (!v9) {
        return result;
      }
      unsigned int v20 = *(uint64_t (**)(void))(**(void **)v5 + 8);
      goto LABEL_42;
    }
    int v21 = v5[158];
    switch(v21)
    {
      case 1:
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)v5 + 8))(*(void *)v5, v12, v8);
        unsigned int v20 = *(uint64_t (**)(void))(**(void **)v5 + 8);
        break;
      case 2:
        unsigned int v20 = *(uint64_t (**)(void))(**(void **)v5 + 8);
        break;
      case 0:
        char v36 = 3;
        *(_DWORD *)__str = 0;
        uint64_t v27 = (uint64_t *)*a2;
        if (v13 >= 0) {
          uint64_t v27 = a2;
        }
        snprintf(__str, 3uLL, "%.2X", *((unsigned __int8 *)v27 + v14 - 1));
        unint64_t v28 = __cxa_allocate_exception(0x20uLL);
        std::operator+<char>();
        nlohmann::detail::type_error::create((uint64_t)v28, 316, (uint64_t)&v32);
      default:
        return result;
    }
LABEL_42:
    return v20();
  }
  return result;
}

void sub_1A2094C48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a33 < 0)
  {
    operator delete(__p);
    if ((v40 & 1) == 0) {
      goto LABEL_7;
    }
  }
  else if (!v40)
  {
LABEL_7:
    if (a39 < 0) {
      operator delete(a34);
    }
    _Unwind_Resume(exception_object);
  }
  __cxa_free_exception(v39);
  goto LABEL_7;
}

__n128 std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(std::string *a1, char *__s, std::string *a3)
{
  size_t v6 = strlen(__s);
  uint64_t v7 = (__n128 *)std::string::insert(a3, 0, __s, v6);
  __n128 result = *v7;
  *a1 = *(std::string *)v7->n128_u8;
  v7->n128_u64[0] = 0;
  v7->n128_u64[1] = 0;
  v7[1].n128_u64[0] = 0;
  return result;
}

__n128 std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(std::string *a1, std::string *a2, char *__s)
{
  size_t v6 = strlen(__s);
  uint64_t v7 = (__n128 *)std::string::append(a2, __s, v6);
  __n128 result = *v7;
  *a1 = *(std::string *)v7->n128_u8;
  v7->n128_u64[0] = 0;
  v7->n128_u64[1] = 0;
  v7[1].n128_u64[0] = 0;
  return result;
}

void nlohmann::detail::type_error::create(uint64_t a1, int a2, uint64_t a3)
{
  v24.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
  *(_OWORD *)&v24.__r_.__value_.__r.__words[1] = xmmword_1A28FCF30;
  strcpy(v24.__r_.__value_.__l.__data_, "[json.exception.type_error");
  size_t v6 = std::string::append(&v24, ".", 1uLL);
  std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v23, a2);
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v8 = &v23;
  }
  else {
    uint64_t v8 = (std::string *)v23.__r_.__value_.__r.__words[0];
  }
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v23.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v23.__r_.__value_.__l.__size_;
  }
  unsigned int v10 = std::string::append(&v25, (const std::string::value_type *)v8, size);
  std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v26.__r_.__value_.__l.__data_ = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v26.__r_.__value_.__r.__words[2] = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  uint64_t v12 = std::string::append(&v26, "] ", 2uLL);
  std::string::size_type v13 = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  __p.__r_.__value_.__r.__words[2] = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v26.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_9:
      if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_10;
      }
LABEL_27:
      operator delete(v25.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_11;
      }
      goto LABEL_28;
    }
  }
  else if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_9;
  }
  operator delete(v23.__r_.__value_.__l.__data_);
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_27;
  }
LABEL_10:
  if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_11;
  }
LABEL_28:
  operator delete(v24.__r_.__value_.__l.__data_);
LABEL_11:
  int v14 = *(char *)(a3 + 23);
  if (v14 >= 0) {
    unint64_t v15 = (const std::string::value_type *)a3;
  }
  else {
    unint64_t v15 = *(const std::string::value_type **)a3;
  }
  if (v14 >= 0) {
    std::string::size_type v16 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v16 = *(void *)(a3 + 8);
  }
  __int16 v17 = std::string::append(&__p, v15, v16);
  std::string::size_type v18 = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)int v21 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  uint64_t v22 = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v22 >= 0) {
    uint64_t v19 = v21;
  }
  else {
    uint64_t v19 = (void **)v21[0];
  }
  *(void *)a1 = &unk_1EF56B688;
  *(_DWORD *)(a1 + 8) = a2;
  MEMORY[0x1A6238AF0](a1 + 16, v19);
  *(void *)a1 = &unk_1EF56B630;
  if (SHIBYTE(v22) < 0) {
    operator delete(v21[0]);
  }
}

void sub_1A2095060(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  std::exception::~exception(v28);
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void nlohmann::detail::type_error::~type_error(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1EF56B688;
  MEMORY[0x1A6238B00](&this[2]);
  std::exception::~exception(this);
}

{
  uint64_t vars8;

  this->__vftable = (std::exception_vtbl *)&unk_1EF56B688;
  MEMORY[0x1A6238B00](&this[2]);
  std::exception::~exception(this);
  JUMPOUT(0x1A6239270);
}

const char *nlohmann::detail::exception::what(const std::runtime_error *this)
{
  return std::runtime_error::what(this + 1);
}

void nlohmann::detail::exception::~exception(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1EF56B688;
  MEMORY[0x1A6238B00](&this[2]);
  std::exception::~exception(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t vars8;

  this->__vftable = (std::exception_vtbl *)&unk_1EF56B688;
  MEMORY[0x1A6238B00](&this[2]);
  std::exception::~exception(this);
}

void nlohmann::detail::output_string_adapter<char,std::string>::~output_string_adapter()
{
}

std::string *nlohmann::detail::output_string_adapter<char,std::string>::write_characters(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3)
{
  return std::string::append(*(std::string **)(a1 + 8), a2, a3);
}

void nlohmann::detail::output_string_adapter<char,std::string>::write_character(uint64_t a1, std::string::value_type a2)
{
}

uint64_t std::__shared_ptr_emplace<nlohmann::detail::output_string_adapter<char,std::string>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 16))();
}

void std::__shared_ptr_emplace<nlohmann::detail::output_string_adapter<char,std::string>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B0A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<nlohmann::detail::output_string_adapter<char,std::string>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B0A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *,false>(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v8 = a3;
  double v294 = (uint64_t *)result;
LABEL_2:
  uint64_t v9 = a2 - 1;
  uint64_t i = v294;
  while (1)
  {
    std::string::size_type v11 = i;
    uint64_t v12 = (char *)a2 - (char *)i;
    unint64_t v13 = a2 - i;
    double v294 = v11;
    if (v6 || !v5)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t v142 = *v9;
          uint64_t v143 = *v11;
          uint64_t v144 = *(void *)(*(void *)v8 + 48);
          uint64_t v145 = v144 + 96 * *v9;
          uint64_t v146 = v144 + 96 * *v294;
          if (*(char *)(v145 + 23) < 0)
          {
            if (*(void *)(v145 + 8)) {
              uint64_t v147 = *(const char **)v145;
            }
            else {
              uint64_t v147 = "";
            }
          }
          else if (*(unsigned char *)(v145 + 23))
          {
            uint64_t v147 = (const char *)v145;
          }
          else
          {
            uint64_t v147 = "";
          }
          size_t v279 = strlen(v147);
          if (*(char *)(v146 + 23) < 0)
          {
            if (*(void *)(v146 + 8)) {
              uint64_t v280 = *(const char **)v146;
            }
            else {
              uint64_t v280 = "";
            }
          }
          else if (*(unsigned char *)(v146 + 23))
          {
            uint64_t v280 = (const char *)v146;
          }
          else
          {
            uint64_t v280 = "";
          }
          size_t v281 = strlen(v280);
          size_t v282 = v281;
          if (v281 >= v279) {
            size_t v283 = v279;
          }
          else {
            size_t v283 = v281;
          }
          __n128 result = memcmp(v147, v280, v283);
          if (result)
          {
            if ((result & 0x80000000) == 0) {
              return result;
            }
          }
          else if (v279 >= v282)
          {
            return result;
          }
          *double v294 = v142;
          *(a2 - 1) = v143;
          break;
        case 3uLL:
          uint64_t v148 = *(void *)(*(void *)v8 + 48);
          return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(v11, v11 + 1, v9, v148);
        case 4uLL:
          return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(v11, v11 + 1, v11 + 2, v9, v8);
        case 5uLL:
          return std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *,0>(v11, v11 + 1, v11 + 2, v11 + 3, v9, v8);
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 191) {
      break;
    }
    if (!a4)
    {
      if (v11 == a2) {
        return result;
      }
      unint64_t v287 = v12;
      int64_t v153 = (v13 - 2) >> 1;
      uint64_t v297 = v13;
      int64_t v303 = v153;
      while (1)
      {
        int64_t v155 = v153;
        if (v303 < v153) {
          goto LABEL_308;
        }
        uint64_t v156 = *(void *)a3;
        uint64_t v157 = (2 * v155) | 1;
        uint64_t v158 = &v294[v157];
        if (2 * v155 + 2 >= (uint64_t)v13)
        {
          uint64_t v162 = *(void *)(v156 + 48);
          goto LABEL_333;
        }
        uint64_t v159 = *(void *)(v156 + 48);
        uint64_t v160 = v159 + 96 * *v158;
        if (*(char *)(v160 + 23) < 0) {
          unint64_t v161 = *(void *)(v160 + 8) ? *(const char **)v160 : "";
        }
        else {
          unint64_t v161 = *(unsigned char *)(v160 + 23) ? (const char *)(v159 + 96 * *v158) : "";
        }
        uint64_t v310 = v159;
        unint64_t v163 = (char *)(v159 + 96 * v158[1]);
        size_t v164 = strlen(v161);
        if (v163[23] < 0)
        {
          unint64_t v163 = *((void *)v163 + 1) ? *(char **)v163 : "";
        }
        else if (!v163[23])
        {
          unint64_t v163 = "";
        }
        size_t v165 = strlen(v163);
        size_t v166 = v165;
        size_t v167 = v165 >= v164 ? v164 : v165;
        int v168 = memcmp(v161, v163, v167);
        if (!v168) {
          break;
        }
        if (v168 < 0) {
          goto LABEL_331;
        }
LABEL_332:
        uint64_t v162 = v310;
LABEL_333:
        uint64_t v169 = *v158;
        uint64_t v293 = v294[v155];
        uint64_t v170 = v162 + 96 * *v158;
        if (*(char *)(v170 + 23) < 0)
        {
          if (*(void *)(v170 + 8)) {
            double v171 = *(const char **)v170;
          }
          else {
            double v171 = "";
          }
        }
        else if (*(unsigned char *)(v170 + 23))
        {
          double v171 = (const char *)(v162 + 96 * v169);
        }
        else
        {
          double v171 = "";
        }
        uint64_t v311 = v162;
        uint64_t v172 = v162 + 96 * v293;
        size_t v173 = strlen(v171);
        if (*(char *)(v172 + 23) < 0)
        {
          if (*(void *)(v172 + 8)) {
            __double2 v174 = *(const char **)v172;
          }
          else {
            __double2 v174 = "";
          }
        }
        else if (*(unsigned char *)(v172 + 23))
        {
          __double2 v174 = (const char *)v172;
        }
        else
        {
          __double2 v174 = "";
        }
        size_t v175 = strlen(v174);
        size_t v176 = v175;
        if (v175 >= v173) {
          size_t v177 = v173;
        }
        else {
          size_t v177 = v175;
        }
        __n128 result = memcmp(v171, v174, v177);
        if (result)
        {
          if ((result & 0x80000000) == 0) {
            goto LABEL_356;
          }
        }
        else if (v173 >= v176)
        {
LABEL_356:
          int64_t v289 = v155;
          v294[v155] = v169;
          if (v303 < v157)
          {
            unsigned int v154 = v158;
LABEL_307:
            *unsigned int v154 = v293;
            int64_t v155 = v289;
            unint64_t v13 = v297;
            goto LABEL_308;
          }
          while (2)
          {
            __double2 v178 = v158;
            uint64_t v179 = v172;
            uint64_t v180 = (2 * v157) | 1;
            double v181 = &v294[v180];
            uint64_t v157 = 2 * v157 + 2;
            if (v157 < v297)
            {
              uint64_t v182 = v311 + 96 * *v181;
              if (*(char *)(v182 + 23) < 0)
              {
                if (*(void *)(v182 + 8)) {
                  double v183 = *(const char **)v182;
                }
                else {
                  double v183 = "";
                }
              }
              else if (*(unsigned char *)(v182 + 23))
              {
                double v183 = (const char *)(v311 + 96 * *v181);
              }
              else
              {
                double v183 = "";
              }
              unsigned int v154 = v181 + 1;
              double v184 = (const char *)(v311 + 96 * v181[1]);
              size_t v185 = strlen(v183);
              if (v184[23] < 0)
              {
                if (*((void *)v184 + 1)) {
                  double v184 = *(const char **)v184;
                }
                else {
                  double v184 = "";
                }
              }
              else if (!v184[23])
              {
                double v184 = "";
              }
              size_t v186 = strlen(v184);
              size_t v187 = v186;
              if (v186 >= v185) {
                size_t v188 = v185;
              }
              else {
                size_t v188 = v186;
              }
              int v189 = memcmp(v183, v184, v188);
              if (v189)
              {
                if ((v189 & 0x80000000) == 0) {
                  break;
                }
LABEL_381:
                uint64_t v190 = *v154;
                uint64_t v191 = v311 + 96 * *v154;
                if (*(char *)(v191 + 23) < 0)
                {
                  uint64_t v172 = v179;
                  if (*(void *)(v191 + 8)) {
                    std::string v192 = *(const char **)v191;
                  }
                  else {
                    std::string v192 = "";
                  }
                }
                else
                {
                  if (*(unsigned char *)(v191 + 23)) {
                    std::string v192 = (const char *)(v311 + 96 * *v154);
                  }
                  else {
                    std::string v192 = "";
                  }
                  uint64_t v172 = v179;
                }
                size_t v193 = strlen(v192);
                if (*(char *)(v172 + 23) < 0)
                {
                  if (*(void *)(v172 + 8)) {
                    double v194 = *(const char **)v172;
                  }
                  else {
                    double v194 = "";
                  }
                }
                else if (*(unsigned char *)(v172 + 23))
                {
                  double v194 = (const char *)v172;
                }
                else
                {
                  double v194 = "";
                }
                size_t v195 = strlen(v194);
                size_t v196 = v195;
                if (v195 >= v193) {
                  size_t v197 = v193;
                }
                else {
                  size_t v197 = v195;
                }
                __n128 result = memcmp(v192, v194, v197);
                if (result)
                {
                  if ((result & 0x80000000) != 0)
                  {
LABEL_306:
                    unsigned int v154 = v178;
                    goto LABEL_307;
                  }
                }
                else if (v193 < v196)
                {
                  goto LABEL_306;
                }
                *__double2 v178 = v190;
                uint64_t v158 = v154;
                if (v303 < v157) {
                  goto LABEL_307;
                }
                continue;
              }
              if (v185 < v187) {
                goto LABEL_381;
              }
            }
            break;
          }
          unsigned int v154 = &v294[v180];
          uint64_t v157 = v180;
          goto LABEL_381;
        }
LABEL_308:
        int64_t v153 = v155 - 1;
        if (!v155)
        {
          uint64_t v218 = v287 >> 3;
          long long v219 = (uint64_t *)a3;
          while (1)
          {
            uint64_t v220 = 0;
            float64x2_t v221 = v294;
            uint64_t v299 = *v294;
            uint64_t v305 = *v219;
            int64_t v222 = (unint64_t)(v218 - 2) >> 1;
            uint64_t v312 = v218;
            do
            {
              float64x2_t v223 = v221;
              long long v224 = &v221[v220 + 1];
              uint64_t v225 = (2 * v220) | 1;
              uint64_t v220 = 2 * v220 + 2;
              if (v220 >= v218)
              {
LABEL_457:
                float64x2_t v221 = v224;
                uint64_t v220 = v225;
                goto LABEL_458;
              }
              uint64_t v226 = *(void *)(v305 + 48);
              uint64_t v227 = v226 + 96 * *v224;
              if (*(char *)(v227 + 23) < 0)
              {
                if (*(void *)(v227 + 8)) {
                  unint64_t v228 = *(const char **)v227;
                }
                else {
                  unint64_t v228 = "";
                }
              }
              else if (*(unsigned char *)(v227 + 23))
              {
                unint64_t v228 = (const char *)(v226 + 96 * *v224);
              }
              else
              {
                unint64_t v228 = "";
              }
              float64x2_t v221 = v224 + 1;
              uint64_t v229 = (const char *)(v226 + 96 * v224[1]);
              size_t v230 = strlen(v228);
              if (v229[23] < 0)
              {
                if (*((void *)v229 + 1)) {
                  uint64_t v229 = *(const char **)v229;
                }
                else {
                  uint64_t v229 = "";
                }
              }
              else if (!v229[23])
              {
                uint64_t v229 = "";
              }
              size_t v231 = strlen(v229);
              size_t v232 = v231;
              if (v231 >= v230) {
                size_t v233 = v230;
              }
              else {
                size_t v233 = v231;
              }
              __n128 result = memcmp(v228, v229, v233);
              if (result)
              {
                uint64_t v218 = v312;
                if ((result & 0x80000000) == 0) {
                  goto LABEL_457;
                }
              }
              else
              {
                uint64_t v218 = v312;
                if (v230 >= v232) {
                  goto LABEL_457;
                }
              }
LABEL_458:
              *float64x2_t v223 = *v221;
            }
            while (v220 <= v222);
            float64x2_t v234 = a2 - 1;
            BOOL v6 = v221 == --a2;
            if (v6)
            {
              *float64x2_t v221 = v299;
            }
            else
            {
              *float64x2_t v221 = *v234;
              *float64x2_t v234 = v299;
              uint64_t v235 = (char *)v221 - (char *)v294 + 8;
              if (v235 >= 9)
              {
                unint64_t v236 = ((unint64_t)v235 >> 3) - 2;
                unint64_t v237 = v236 >> 1;
                float64x2_t v238 = &v294[v236 >> 1];
                uint64_t v239 = *v238;
                uint64_t v306 = *(void *)(*(void *)a3 + 48);
                uint64_t v240 = v306 + 96 * *v238;
                if (*(char *)(v240 + 23) < 0)
                {
                  if (*(void *)(v240 + 8)) {
                    uint64_t v241 = *(const char **)v240;
                  }
                  else {
                    uint64_t v241 = "";
                  }
                }
                else if (*(unsigned char *)(v240 + 23))
                {
                  uint64_t v241 = (const char *)(v306 + 96 * v239);
                }
                else
                {
                  uint64_t v241 = "";
                }
                uint64_t v300 = *v221;
                uint64_t v242 = v306 + 96 * *v221;
                size_t v243 = strlen(v241);
                if (*(char *)(v242 + 23) < 0)
                {
                  if (*(void *)(v242 + 8)) {
                    double v244 = *(const char **)v242;
                  }
                  else {
                    double v244 = "";
                  }
                }
                else if (*(unsigned char *)(v242 + 23))
                {
                  double v244 = (const char *)(v306 + 96 * *v221);
                }
                else
                {
                  double v244 = "";
                }
                size_t v245 = strlen(v244);
                size_t v246 = v245;
                if (v245 >= v243) {
                  size_t v247 = v243;
                }
                else {
                  size_t v247 = v245;
                }
                __n128 result = memcmp(v241, v244, v247);
                if (result)
                {
                  if ((result & 0x80000000) != 0)
                  {
LABEL_505:
                    *float64x2_t v221 = v239;
                    if (v236 >= 2)
                    {
                      while (1)
                      {
                        unint64_t v248 = v237 - 1;
                        unint64_t v237 = (v237 - 1) >> 1;
                        unsigned int v249 = &v294[v237];
                        uint64_t v250 = *v249;
                        uint64_t v251 = v306 + 96 * *v249;
                        if (*(char *)(v251 + 23) < 0)
                        {
                          if (*(void *)(v251 + 8)) {
                            uint64_t v252 = *(const char **)v251;
                          }
                          else {
                            uint64_t v252 = "";
                          }
                        }
                        else if (*(unsigned char *)(v251 + 23))
                        {
                          uint64_t v252 = (const char *)(v306 + 96 * *v249);
                        }
                        else
                        {
                          uint64_t v252 = "";
                        }
                        size_t v253 = strlen(v252);
                        if (*(char *)(v242 + 23) < 0)
                        {
                          if (*(void *)(v242 + 8)) {
                            float64x2_t v254 = *(const char **)v242;
                          }
                          else {
                            float64x2_t v254 = "";
                          }
                        }
                        else if (*(unsigned char *)(v242 + 23))
                        {
                          float64x2_t v254 = (const char *)v242;
                        }
                        else
                        {
                          float64x2_t v254 = "";
                        }
                        size_t v255 = strlen(v254);
                        size_t v256 = v255;
                        if (v255 >= v253) {
                          size_t v257 = v253;
                        }
                        else {
                          size_t v257 = v255;
                        }
                        __n128 result = memcmp(v252, v254, v257);
                        if (result)
                        {
                          if ((result & 0x80000000) == 0) {
                            break;
                          }
                        }
                        else if (v253 >= v256)
                        {
                          break;
                        }
                        *float64x2_t v238 = v250;
                        float64x2_t v238 = &v294[v237];
                        if (v248 <= 1) {
                          goto LABEL_529;
                        }
                      }
                    }
                    unsigned int v249 = v238;
LABEL_529:
                    *unsigned int v249 = v300;
                  }
                }
                else if (v243 < v246)
                {
                  goto LABEL_505;
                }
              }
            }
            uint64_t v218 = v312 - 1;
            long long v219 = (uint64_t *)a3;
            if (v312 <= 2) {
              return result;
            }
          }
        }
      }
      if (v164 >= v166) {
        goto LABEL_332;
      }
LABEL_331:
      ++v158;
      uint64_t v157 = 2 * v155 + 2;
      goto LABEL_332;
    }
    unint64_t v14 = v13 >> 1;
    unint64_t v15 = &v11[v13 >> 1];
    uint64_t v16 = *(void *)(*(void *)v8 + 48);
    if ((unint64_t)v12 < 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(v15, v11, v9, v16);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(v11, v15, v9, v16);
      uint64_t v17 = v14;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(v11 + 1, &v11[v17 - 1], a2 - 2, *(void *)(*(void *)a3 + 48));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(v11 + 2, &v11[v17 + 1], a2 - 3, *(void *)(*(void *)a3 + 48));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(&v11[v17 - 1], v15, &v11[v17 + 1], *(void *)(*(void *)a3 + 48));
      uint64_t v18 = *v11;
      *std::string::size_type v11 = v11[v17];
      v11[v17] = v18;
      uint64_t v8 = a3;
    }
    uint64_t v19 = *(void *)v8;
    uint64_t v20 = *v11;
    uint64_t v285 = *v11;
    uint64_t v286 = a4 - 1;
    if (a5)
    {
      uint64_t v21 = *(void *)(v19 + 48);
      int v22 = *(unsigned __int8 *)(v21 + 96 * v20 + 23);
LABEL_31:
      uint64_t v302 = v21 + 96 * v20;
      if (v22) {
        std::string v31 = (const char *)(v21 + 96 * v20);
      }
      else {
        std::string v31 = "";
      }
      do
      {
        while (1)
        {
          uint64_t v32 = v11[1];
          ++v11;
          uint64_t v33 = v21 + 96 * v32;
          uint64_t v307 = v32;
          if (*(char *)(v33 + 23) < 0)
          {
            if (*(void *)(v33 + 8)) {
              uint64_t v34 = *(const char **)v33;
            }
            else {
              uint64_t v34 = "";
            }
          }
          else if (*(unsigned char *)(v33 + 23))
          {
            uint64_t v34 = (const char *)v33;
          }
          else
          {
            uint64_t v34 = "";
          }
          size_t v35 = strlen(v34);
          char v36 = v31;
          if ((v22 & 0x80) != 0)
          {
            if (*(void *)(v302 + 8)) {
              char v36 = *(const char **)v302;
            }
            else {
              char v36 = "";
            }
          }
          size_t v37 = strlen(v36);
          size_t v38 = v37;
          size_t v39 = v37 >= v35 ? v35 : v37;
          int v40 = memcmp(v34, v36, v39);
          if (v40) {
            break;
          }
          if (v35 >= v38) {
            goto LABEL_51;
          }
        }
      }
      while (v40 < 0);
LABEL_51:
      uint64_t v41 = v9;
      double v295 = v11 - 1;
      char v42 = v22;
      unint64_t v292 = v11;
      if (v11 - 1 != v294)
      {
        while (1)
        {
          uint64_t v46 = v21 + 96 * *v41;
          uint64_t v47 = v41;
          if (*(char *)(v46 + 23) < 0)
          {
            if (*(void *)(v46 + 8)) {
              unint64_t v48 = *(const char **)v46;
            }
            else {
              unint64_t v48 = "";
            }
          }
          else if (*(unsigned char *)(v46 + 23))
          {
            unint64_t v48 = (const char *)(v21 + 96 * *v41);
          }
          else
          {
            unint64_t v48 = "";
          }
          size_t v49 = strlen(v48);
          unsigned int v50 = v31;
          if ((v22 & 0x80) != 0)
          {
            if (*(void *)(v302 + 8)) {
              unsigned int v50 = *(const char **)v302;
            }
            else {
              unsigned int v50 = "";
            }
          }
          size_t v51 = strlen(v50);
          size_t v52 = v51;
          if (v51 >= v49) {
            size_t v53 = v49;
          }
          else {
            size_t v53 = v51;
          }
          int v54 = memcmp(v48, v50, v53);
          if (v54)
          {
            if (v54 < 0)
            {
LABEL_72:
              double v288 = v47;
              uint64_t v44 = v21;
              goto LABEL_73;
            }
          }
          else if (v49 < v52)
          {
            goto LABEL_72;
          }
          uint64_t v41 = v47 - 1;
          LOBYTE(v22) = v42;
        }
      }
      char v43 = v11;
      uint64_t v44 = v21;
      double v288 = a2;
      BOOL v5 = v43 >= a2;
      uint64_t v45 = v302;
      if (v5) {
        goto LABEL_74;
      }
      while (1)
      {
        uint64_t v77 = v21 + 96 * *v9;
        if (*(char *)(v77 + 23) < 0)
        {
          if (*(void *)(v77 + 8)) {
            unint64_t v78 = *(const char **)v77;
          }
          else {
            unint64_t v78 = "";
          }
        }
        else if (*(unsigned char *)(v77 + 23))
        {
          unint64_t v78 = (const char *)(v21 + 96 * *v9);
        }
        else
        {
          unint64_t v78 = "";
        }
        size_t v79 = strlen(v78);
        unint64_t v80 = v31;
        if ((v22 & 0x80) != 0)
        {
          if (*(void *)(v302 + 8)) {
            unint64_t v80 = *(const char **)v302;
          }
          else {
            unint64_t v80 = "";
          }
        }
        size_t v81 = strlen(v80);
        size_t v82 = v81;
        size_t v83 = v81 >= v79 ? v79 : v81;
        int v84 = memcmp(v78, v80, v83);
        if (!v84) {
          break;
        }
        if (v292 >= v9) {
          goto LABEL_150;
        }
        uint64_t v45 = v302;
        if (v84 < 0)
        {
LABEL_138:
          double v288 = v9;
          goto LABEL_74;
        }
LABEL_117:
        --v9;
        LOBYTE(v22) = v42;
      }
      if (v292 < v9)
      {
        uint64_t v45 = v302;
        if (v79 < v82) {
          goto LABEL_138;
        }
        goto LABEL_117;
      }
LABEL_150:
      double v288 = v9;
LABEL_73:
      uint64_t v45 = v302;
LABEL_74:
      if (v292 < v288)
      {
        char v55 = v288;
        uint64_t v56 = *v288;
        unint64_t v57 = v292;
        do
        {
          *v57++ = v56;
          uint64_t *v55 = v307;
          int v58 = *(char *)(v45 + 23);
          if (*(unsigned char *)(v45 + 23)) {
            unsigned __int8 v59 = (const char *)v45;
          }
          else {
            unsigned __int8 v59 = "";
          }
          while (1)
          {
            uint64_t v307 = *v57;
            uint64_t v60 = v44 + 96 * *v57;
            if (*(char *)(v60 + 23) < 0)
            {
              if (*(void *)(v60 + 8)) {
                uint64_t v61 = *(const char **)v60;
              }
              else {
                uint64_t v61 = "";
              }
            }
            else if (*(unsigned char *)(v60 + 23))
            {
              uint64_t v61 = (const char *)(v44 + 96 * v307);
            }
            else
            {
              uint64_t v61 = "";
            }
            size_t v62 = strlen(v61);
            int v63 = v59;
            if (v58 < 0)
            {
              if (*(void *)(v302 + 8)) {
                int v63 = *(const char **)v302;
              }
              else {
                int v63 = "";
              }
            }
            size_t v64 = strlen(v63);
            size_t v65 = v64;
            size_t v66 = v64 >= v62 ? v62 : v64;
            int v67 = memcmp(v61, v63, v66);
            if (v67) {
              break;
            }
            if (v62 >= v65) {
              goto LABEL_98;
            }
LABEL_81:
            ++v57;
          }
          if (v67 < 0) {
            goto LABEL_81;
          }
LABEL_98:
          double v295 = v57 - 1;
          do
          {
            while (1)
            {
              uint64_t v68 = *--v55;
              uint64_t v56 = v68;
              uint64_t v69 = v44 + 96 * v68;
              if (*(char *)(v69 + 23) < 0)
              {
                if (*(void *)(v69 + 8)) {
                  uint64_t v70 = *(const char **)v69;
                }
                else {
                  uint64_t v70 = "";
                }
              }
              else if (*(unsigned char *)(v69 + 23))
              {
                uint64_t v70 = (const char *)v69;
              }
              else
              {
                uint64_t v70 = "";
              }
              size_t v71 = strlen(v70);
              unsigned int v72 = v59;
              if (v58 < 0)
              {
                if (*(void *)(v302 + 8)) {
                  unsigned int v72 = *(const char **)v302;
                }
                else {
                  unsigned int v72 = "";
                }
              }
              size_t v73 = strlen(v72);
              size_t v74 = v73;
              size_t v75 = v73 >= v71 ? v71 : v73;
              int v76 = memcmp(v70, v72, v75);
              if (v76) {
                break;
              }
              if (v71 < v74) {
                goto LABEL_76;
              }
            }
          }
          while ((v76 & 0x80000000) == 0);
LABEL_76:
          uint64_t v45 = v302;
        }
        while (v57 < v55);
      }
      if (v295 != v294) {
        *double v294 = *v295;
      }
      a4 = v286;
      *double v295 = v285;
      uint64_t v8 = a3;
      uint64_t v9 = a2 - 1;
      if (v292 < v288)
      {
LABEL_144:
        __n128 result = std::__introsort<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *,false>(v294, v295, a3, v286, a5 & 1);
        a5 = 0;
        uint64_t i = v295 + 1;
      }
      else
      {
        BOOL v85 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(v294, v295, a3);
        uint64_t i = v295 + 1;
        __n128 result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(v295 + 1, a2, a3);
        if (result)
        {
          a2 = v295;
          if (v85) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v85) {
          goto LABEL_144;
        }
      }
    }
    else
    {
      uint64_t v21 = *(void *)(v19 + 48);
      uint64_t v23 = v21 + 96 * *(v11 - 1);
      if (*(char *)(v23 + 23) < 0)
      {
        if (*(void *)(v23 + 8)) {
          std::string v24 = *(const char **)v23;
        }
        else {
          std::string v24 = "";
        }
      }
      else if (*(unsigned char *)(v23 + 23))
      {
        std::string v24 = (const char *)(v21 + 96 * *(v11 - 1));
      }
      else
      {
        std::string v24 = "";
      }
      std::string v25 = (const char *)(v21 + 96 * v20);
      size_t v26 = strlen(v24);
      int v22 = *((unsigned __int8 *)v25 + 23);
      double v301 = v25;
      if ((v22 & 0x80) != 0)
      {
        if (*((void *)v25 + 1)) {
          std::string v25 = *(const char **)v25;
        }
        else {
          std::string v25 = "";
        }
      }
      else if (!v25[23])
      {
        std::string v25 = "";
      }
      size_t v27 = strlen(v25);
      size_t v28 = v27;
      if (v27 >= v26) {
        size_t v29 = v26;
      }
      else {
        size_t v29 = v27;
      }
      int v30 = memcmp(v24, v25, v29);
      if (v30)
      {
        if (v30 < 0) {
          goto LABEL_31;
        }
      }
      else if (v26 < v28)
      {
        goto LABEL_31;
      }
      int v296 = v22;
      if ((v22 & 0x80) != 0)
      {
        if (*((void *)v301 + 1)) {
          unint64_t v86 = *(const char **)v301;
        }
        else {
          unint64_t v86 = "";
        }
      }
      else if (v22)
      {
        unint64_t v86 = (const char *)(v21 + 96 * v20);
      }
      else
      {
        unint64_t v86 = "";
      }
      uint64_t v87 = *v9;
      uint64_t v88 = v21 + 96 * *v9;
      size_t v89 = strlen(v86);
      if (*(char *)(v88 + 23) < 0)
      {
        if (*(void *)(v88 + 8)) {
          unsigned int v90 = *(const char **)v88;
        }
        else {
          unsigned int v90 = "";
        }
      }
      else if (*(unsigned char *)(v88 + 23))
      {
        unsigned int v90 = (const char *)(v21 + 96 * *v9);
      }
      else
      {
        unsigned int v90 = "";
      }
      size_t v91 = strlen(v90);
      size_t v92 = v91;
      if (v91 >= v89) {
        size_t v93 = v89;
      }
      else {
        size_t v93 = v91;
      }
      __n128 result = memcmp(v86, v90, v93);
      uint64_t v308 = v21;
      if (result)
      {
        int v94 = v296;
        unint64_t v95 = v301;
        if ((result & 0x80000000) != 0) {
          goto LABEL_190;
        }
      }
      else
      {
        int v94 = v296;
        unint64_t v95 = v301;
        if (v89 < v92)
        {
LABEL_190:
          if (v94) {
            unint64_t v104 = v95;
          }
          else {
            unint64_t v104 = "";
          }
          for (uint64_t i = v11 + 1; ; ++i)
          {
            unint64_t v105 = v104;
            if ((v296 & 0x80) != 0)
            {
              if (*((void *)v301 + 1)) {
                unint64_t v105 = *(const char **)v301;
              }
              else {
                unint64_t v105 = "";
              }
            }
            uint64_t v106 = v21 + 96 * *i;
            size_t v107 = strlen(v105);
            if (*(char *)(v106 + 23) < 0)
            {
              if (*(void *)(v106 + 8)) {
                unint64_t v108 = *(const char **)v106;
              }
              else {
                unint64_t v108 = "";
              }
            }
            else if (*(unsigned char *)(v106 + 23))
            {
              unint64_t v108 = (const char *)v106;
            }
            else
            {
              unint64_t v108 = "";
            }
            uint64_t v21 = v308;
            size_t v109 = strlen(v108);
            size_t v110 = v109;
            if (v109 >= v107) {
              size_t v111 = v107;
            }
            else {
              size_t v111 = v109;
            }
            __n128 result = memcmp(v105, v108, v111);
            if (result)
            {
              if ((result & 0x80000000) != 0)
              {
LABEL_212:
                unint64_t v95 = v301;
                goto LABEL_213;
              }
            }
            else if (v107 < v110)
            {
              goto LABEL_212;
            }
          }
        }
      }
      uint64_t i = v11 + 1;
      if (v11 + 1 < a2)
      {
        if (v94) {
          unint64_t v96 = v95;
        }
        else {
          unint64_t v96 = "";
        }
        do
        {
          unint64_t v97 = v96;
          if ((v296 & 0x80) != 0)
          {
            if (*((void *)v301 + 1)) {
              unint64_t v97 = *(const char **)v301;
            }
            else {
              unint64_t v97 = "";
            }
          }
          uint64_t v98 = v21 + 96 * *i;
          size_t v99 = strlen(v97);
          if (*(char *)(v98 + 23) < 0)
          {
            if (*(void *)(v98 + 8)) {
              unint64_t v100 = *(const char **)v98;
            }
            else {
              unint64_t v100 = "";
            }
          }
          else if (*(unsigned char *)(v98 + 23))
          {
            unint64_t v100 = (const char *)v98;
          }
          else
          {
            unint64_t v100 = "";
          }
          size_t v101 = strlen(v100);
          size_t v102 = v101;
          if (v101 >= v99) {
            size_t v103 = v99;
          }
          else {
            size_t v103 = v101;
          }
          __n128 result = memcmp(v97, v100, v103);
          uint64_t v21 = v308;
          if (result)
          {
            unint64_t v95 = v301;
            if ((result & 0x80000000) != 0) {
              break;
            }
          }
          else
          {
            unint64_t v95 = v301;
            if (v99 < v102) {
              break;
            }
          }
          ++i;
        }
        while (i < a2);
      }
LABEL_213:
      unint64_t j = a2;
      if (i >= a2) {
        goto LABEL_237;
      }
      if (v296) {
        int v113 = v95;
      }
      else {
        int v113 = "";
      }
      for (unint64_t j = v9; ; --j)
      {
        BOOL v115 = v113;
        if ((v296 & 0x80) != 0)
        {
          if (*((void *)v301 + 1)) {
            BOOL v115 = *(const char **)v301;
          }
          else {
            BOOL v115 = "";
          }
        }
        int v116 = (const char *)(v21 + 96 * v87);
        size_t v117 = strlen(v115);
        if (v116[23] < 0) {
          uint64_t v118 = *((void *)v116 + 1) ? *(const char **)v116 : "";
        }
        else {
          uint64_t v118 = v116[23] ? v116 : "";
        }
        uint64_t v21 = v308;
        size_t v119 = strlen(v118);
        size_t v120 = v119;
        size_t v121 = v119 >= v117 ? v117 : v119;
        __n128 result = memcmp(v115, v118, v121);
        if (result) {
          break;
        }
        if (v117 >= v120) {
          goto LABEL_236;
        }
LABEL_219:
        uint64_t v114 = *(j - 1);
        uint64_t v87 = v114;
      }
      if ((result & 0x80000000) != 0) {
        goto LABEL_219;
      }
LABEL_236:
      unint64_t v95 = v301;
LABEL_237:
      if (i < j)
      {
        uint64_t v122 = *i;
        uint64_t v123 = *j;
        do
        {
          *i++ = v123;
          uint64_t *j = v122;
          int v124 = v95[23];
          if (v95[23]) {
            unint64_t v125 = v95;
          }
          else {
            unint64_t v125 = "";
          }
          while (1)
          {
            uint64_t v122 = *i;
            unint64_t v126 = v125;
            if (v124 < 0)
            {
              if (*((void *)v301 + 1)) {
                unint64_t v126 = *(const char **)v301;
              }
              else {
                unint64_t v126 = "";
              }
            }
            uint64_t v127 = v308 + 96 * v122;
            size_t v128 = strlen(v126);
            if (*(char *)(v127 + 23) < 0) {
              uint64_t v129 = *(void *)(v127 + 8) ? *(const char **)v127 : "";
            }
            else {
              uint64_t v129 = *(unsigned char *)(v127 + 23) ? (const char *)(v308 + 96 * v122) : "";
            }
            size_t v130 = strlen(v129);
            size_t v131 = v130;
            size_t v132 = v130 >= v128 ? v128 : v130;
            int v133 = memcmp(v126, v129, v132);
            if (v133) {
              break;
            }
            if (v128 < v131) {
              goto LABEL_263;
            }
LABEL_244:
            ++i;
          }
          if ((v133 & 0x80000000) == 0) {
            goto LABEL_244;
          }
          do
          {
            while (1)
            {
LABEL_263:
              uint64_t v134 = *--j;
              uint64_t v123 = v134;
              unint64_t v135 = v125;
              if (v124 < 0)
              {
                if (*((void *)v301 + 1)) {
                  unint64_t v135 = *(const char **)v301;
                }
                else {
                  unint64_t v135 = "";
                }
              }
              unint64_t v136 = (char *)(v308 + 96 * v123);
              size_t v137 = strlen(v135);
              if (v136[23] < 0)
              {
                unint64_t v136 = *((void *)v136 + 1) ? *(char **)v136 : "";
              }
              else if (!v136[23])
              {
                unint64_t v136 = "";
              }
              size_t v138 = strlen(v136);
              size_t v139 = v138;
              size_t v140 = v138 >= v137 ? v137 : v138;
              __n128 result = memcmp(v135, v136, v140);
              if (result) {
                break;
              }
              if (v137 >= v139) {
                goto LABEL_239;
              }
            }
          }
          while ((result & 0x80000000) != 0);
LABEL_239:
          unint64_t v95 = v301;
        }
        while (i < j);
      }
      uint64_t v141 = i - 1;
      BOOL v5 = i - 1 >= v294;
      BOOL v6 = i - 1 == v294;
      if (i - 1 != v294) {
        *double v294 = *v141;
      }
      a5 = 0;
      a4 = v286;
      *uint64_t v141 = v285;
      uint64_t v8 = a3;
      uint64_t v9 = a2 - 1;
    }
  }
  uint64_t v149 = *(void *)v8;
  if (a5)
  {
    if (v11 == a2) {
      return result;
    }
    unsigned int v150 = v11 + 1;
    if (v11 + 1 == a2) {
      return result;
    }
    uint64_t v151 = 0;
    uint64_t v309 = *(void *)(v149 + 48);
    char v152 = v11;
LABEL_407:
    uint64_t v199 = v309 + 96 * v152[1];
    uint64_t v298 = v152[1];
    double v304 = v150;
    if (*(char *)(v199 + 23) < 0)
    {
      if (*(void *)(v199 + 8)) {
        uint64_t v200 = *(const char **)v199;
      }
      else {
        uint64_t v200 = "";
      }
    }
    else if (*(unsigned char *)(v199 + 23))
    {
      uint64_t v200 = (const char *)(v309 + 96 * v152[1]);
    }
    else
    {
      uint64_t v200 = "";
    }
    uint64_t v201 = *v152;
    uint64_t v202 = v309 + 96 * *v152;
    size_t v203 = strlen(v200);
    if (*(char *)(v202 + 23) < 0)
    {
      if (*(void *)(v202 + 8)) {
        float v204 = *(const char **)v202;
      }
      else {
        float v204 = "";
      }
    }
    else if (*(unsigned char *)(v202 + 23))
    {
      float v204 = (const char *)(v309 + 96 * *v152);
    }
    else
    {
      float v204 = "";
    }
    char v205 = v294;
    size_t v206 = strlen(v204);
    size_t v207 = v206;
    if (v206 >= v203) {
      size_t v208 = v203;
    }
    else {
      size_t v208 = v206;
    }
    __n128 result = memcmp(v200, v204, v208);
    if (result)
    {
      if ((result & 0x80000000) == 0) {
        goto LABEL_406;
      }
    }
    else if (v203 >= v207)
    {
      goto LABEL_406;
    }
    v152[1] = v201;
    uint64_t v198 = v294;
    if (v152 == v294) {
      goto LABEL_405;
    }
    uint64_t v209 = v151;
    while (1)
    {
      if (*(char *)(v199 + 23) < 0)
      {
        if (*(void *)(v199 + 8)) {
          uint64_t v210 = *(const char **)v199;
        }
        else {
          uint64_t v210 = "";
        }
      }
      else if (*(unsigned char *)(v199 + 23))
      {
        uint64_t v210 = (const char *)v199;
      }
      else
      {
        uint64_t v210 = "";
      }
      char v211 = (uint64_t *)((char *)v205 + v209);
      uint64_t v212 = *(uint64_t *)((char *)v205 + v209 - 8);
      float64x2_t v213 = (const char *)(v309 + 96 * v212);
      size_t v214 = strlen(v210);
      if (v213[23] < 0)
      {
        if (*((void *)v213 + 1)) {
          float64x2_t v213 = *(const char **)v213;
        }
        else {
          float64x2_t v213 = "";
        }
      }
      else if (!v213[23])
      {
        float64x2_t v213 = "";
      }
      size_t v215 = strlen(v213);
      size_t v216 = v215;
      if (v215 >= v214) {
        size_t v217 = v214;
      }
      else {
        size_t v217 = v215;
      }
      __n128 result = memcmp(v210, v213, v217);
      if (result)
      {
        if ((result & 0x80000000) == 0)
        {
          uint64_t v198 = (uint64_t *)((char *)v294 + v209);
          goto LABEL_405;
        }
      }
      else if (v214 >= v216)
      {
        uint64_t v198 = v152;
LABEL_405:
        *uint64_t v198 = v298;
LABEL_406:
        char v152 = v304;
        unsigned int v150 = v304 + 1;
        v151 += 8;
        if (v304 + 1 == a2) {
          return result;
        }
        goto LABEL_407;
      }
      --v152;
      *char v211 = v212;
      v209 -= 8;
      char v205 = v294;
      if (!v209)
      {
        uint64_t v198 = v294;
        goto LABEL_405;
      }
    }
  }
  if (v11 != a2)
  {
    double v258 = v11 + 1;
    if (v11 + 1 != a2)
    {
      uint64_t v259 = *(void *)(v149 + 48);
      do
      {
        double v260 = v294;
        double v294 = v258;
        uint64_t v261 = v260[1];
        double v262 = (const char *)(v259 + 96 * v261);
        if (v262[23] < 0)
        {
          if (*((void *)v262 + 1)) {
            float64x2_t v263 = *(const char **)v262;
          }
          else {
            float64x2_t v263 = "";
          }
        }
        else if (v262[23])
        {
          float64x2_t v263 = (const char *)(v259 + 96 * v261);
        }
        else
        {
          float64x2_t v263 = "";
        }
        uint64_t v264 = *v260;
        uint64_t v265 = (const char *)(v259 + 96 * *v260);
        size_t v266 = strlen(v263);
        if (v265[23] < 0)
        {
          if (*((void *)v265 + 1)) {
            uint64_t v265 = *(const char **)v265;
          }
          else {
            uint64_t v265 = "";
          }
        }
        else if (!v265[23])
        {
          uint64_t v265 = "";
        }
        size_t v267 = strlen(v265);
        size_t v268 = v267;
        if (v267 >= v266) {
          size_t v269 = v266;
        }
        else {
          size_t v269 = v267;
        }
        __n128 result = memcmp(v263, v265, v269);
        if (result)
        {
          if ((result & 0x80000000) != 0) {
            goto LABEL_556;
          }
        }
        else if (v266 < v268)
        {
LABEL_556:
          uint64_t v313 = v261;
          do
          {
            while (1)
            {
              unint64_t v270 = v260;
              uint64_t v271 = v264;
              uint64_t v272 = *--v260;
              uint64_t v264 = v272;
              v260[2] = v271;
              if (v262[23] < 0) {
                double v273 = *((void *)v262 + 1) ? *(const char **)v262 : "";
              }
              else {
                double v273 = v262[23] ? v262 : "";
              }
              unint64_t v274 = (char *)(v259 + 96 * v264);
              size_t v275 = strlen(v273);
              if (v274[23] < 0)
              {
                unint64_t v274 = *((void *)v274 + 1) ? *(char **)v274 : "";
              }
              else if (!v274[23])
              {
                unint64_t v274 = "";
              }
              size_t v276 = strlen(v274);
              size_t v277 = v276;
              size_t v278 = v276 >= v275 ? v275 : v276;
              __n128 result = memcmp(v273, v274, v278);
              if (result) {
                break;
              }
              if (v275 >= v277) {
                goto LABEL_533;
              }
            }
          }
          while ((result & 0x80000000) != 0);
LABEL_533:
          *unint64_t v270 = v313;
        }
        double v258 = v294 + 1;
      }
      while (v294 + 1 != a2);
    }
  }
  return result;
}

uint64_t nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1;
  int v3 = *a2;
  *(unsigned char *)a1 = v3;
  *(void *)(a1 + 8) = 0;
  switch(v3)
  {
    case 1:
      unint64_t v14 = (void *)*((void *)a2 + 1);
      long long v4 = (void **)operator new(0x18uLL);
      v4[1] = 0;
      void v4[2] = 0;
      void *v4 = v4 + 1;
      unint64_t v15 = (void *)*v14;
      char v55 = v14 + 1;
      if ((void *)*v14 == v14 + 1) {
        goto LABEL_11;
      }
      break;
    case 2:
      uint64_t v47 = (uint64_t *)*((void *)a2 + 1);
      long long v4 = (void **)operator new(0x18uLL);
      v4[1] = 0;
      void v4[2] = 0;
      void *v4 = 0;
      uint64_t v48 = *v47;
      uint64_t v49 = v47[1];
      uint64_t v50 = v49 - v48;
      if (v49 != v48)
      {
        if (v50 < 0) {
          abort();
        }
        size_t v51 = (char *)operator new(v49 - v48);
        uint64_t v52 = 0;
        void *v4 = v51;
        v4[1] = v51;
        void v4[2] = &v51[16 * (v50 >> 4)];
        do
        {
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json(&v51[v52], v48 + v52);
          v52 += 16;
        }
        while (v48 + v52 != v49);
        v4[1] = &v51[v52];
      }
      goto LABEL_80;
    case 3:
      BOOL v5 = (long long *)*((void *)a2 + 1);
      BOOL v6 = (std::string *)operator new(0x18uLL);
      long long v4 = (void **)v6;
      if (*((char *)v5 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)v5, *((void *)v5 + 1));
      }
      else
      {
        long long v7 = *v5;
        v6->__r_.__value_.__r.__words[2] = *((void *)v5 + 2);
        *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
      }
      goto LABEL_80;
    case 4:
      long long v4 = (void **)a2[8];
      goto LABEL_80;
    case 5:
    case 6:
    case 7:
      long long v4 = (void **)*((void *)a2 + 1);
      goto LABEL_80;
    case 8:
      uint64_t v8 = *((void *)a2 + 1);
      long long v4 = (void **)operator new(0x20uLL);
      v4[1] = 0;
      void v4[2] = 0;
      void *v4 = 0;
      unsigned int v10 = *(const void **)v8;
      uint64_t v9 = *(void *)(v8 + 8);
      size_t v11 = v9 - *(void *)v8;
      if (v9 != *(void *)v8)
      {
        if ((v11 & 0x8000000000000000) != 0) {
          abort();
        }
        uint64_t v12 = (char *)operator new(v9 - *(void *)v8);
        void *v4 = v12;
        unint64_t v13 = &v12[v11];
        void v4[2] = &v12[v11];
        memcpy(v12, v10, v11);
        v4[1] = v13;
      }
      *((_WORD *)v4 + 12) = *(_WORD *)(v8 + 24);
LABEL_80:
      *(void *)(v2 + 8) = v4;
      return v2;
    default:
      return v2;
  }
  while (1)
  {
    uint64_t v16 = v4[1];
    uint64_t v17 = (char *)(v4 + 1);
    if (*v4 != v4 + 1)
    {
      uint64_t v18 = (char *)v4[1];
      uint64_t v19 = (char *)(v4 + 1);
      if (v16)
      {
        do
        {
          uint64_t v17 = v18;
          uint64_t v18 = (char *)*((void *)v18 + 1);
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v17 = (char *)*((void *)v19 + 2);
          BOOL v20 = *(void *)v17 == (void)v19;
          uint64_t v19 = v17;
        }
        while (v20);
      }
      int v21 = v17[55];
      if (v21 >= 0) {
        int v22 = v17 + 32;
      }
      else {
        int v22 = (const void *)*((void *)v17 + 4);
      }
      if (v21 >= 0) {
        size_t v23 = v17[55];
      }
      else {
        size_t v23 = *((void *)v17 + 5);
      }
      int v24 = *((char *)v15 + 55);
      if (v24 >= 0) {
        std::string v25 = v15 + 4;
      }
      else {
        std::string v25 = (const void *)v15[4];
      }
      if (v24 >= 0) {
        size_t v26 = *((unsigned __int8 *)v15 + 55);
      }
      else {
        size_t v26 = v15[5];
      }
      if (v26 >= v23) {
        size_t v27 = v23;
      }
      else {
        size_t v27 = v26;
      }
      int v28 = memcmp(v22, v25, v27);
      if (v28)
      {
        if ((v28 & 0x80000000) == 0) {
          goto LABEL_35;
        }
      }
      else if (v23 >= v26)
      {
LABEL_35:
        size_t v29 = v4 + 1;
        int v30 = v4 + 1;
        if (v16)
        {
          std::string v31 = v16;
          while (1)
          {
            int v30 = (uint64_t **)v31;
            uint64_t v34 = (const void *)v31[4];
            uint64_t v32 = v31 + 4;
            uint64_t v33 = v34;
            int v35 = *((char *)v32 + 23);
            if (v35 >= 0) {
              char v36 = v32;
            }
            else {
              char v36 = v33;
            }
            if (v35 >= 0) {
              size_t v37 = *((unsigned __int8 *)v32 + 23);
            }
            else {
              size_t v37 = v32[1];
            }
            if (v37 >= v26) {
              size_t v38 = v26;
            }
            else {
              size_t v38 = v37;
            }
            int v39 = memcmp(v25, v36, v38);
            if (v39)
            {
              if (v39 < 0) {
                goto LABEL_37;
              }
LABEL_51:
              int v40 = memcmp(v36, v25, v38);
              if (v40)
              {
                if ((v40 & 0x80000000) == 0) {
                  goto LABEL_60;
                }
              }
              else if (v37 >= v26)
              {
                goto LABEL_60;
              }
              size_t v29 = v30 + 1;
              std::string v31 = v30[1];
              if (!v31) {
                goto LABEL_63;
              }
            }
            else
            {
              if (v26 >= v37) {
                goto LABEL_51;
              }
LABEL_37:
              std::string v31 = *v30;
              size_t v29 = v30;
              if (!*v30) {
                goto LABEL_63;
              }
            }
          }
        }
        goto LABEL_63;
      }
    }
    size_t v29 = v4 + 1;
    int v30 = v4 + 1;
    if (v16)
    {
      size_t v29 = (uint64_t **)(v17 + 8);
      if (*((void *)v17 + 1))
      {
LABEL_60:
        uint64_t v41 = (void *)v15[1];
        if (!v41) {
          goto LABEL_71;
        }
        goto LABEL_69;
      }
      int v30 = (uint64_t **)v17;
    }
LABEL_63:
    char v42 = (char *)operator new(0x48uLL);
    char v43 = (uint64_t *)v42;
    if (*((char *)v15 + 55) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)(v42 + 32), (const std::string::value_type *)v15[4], v15[5]);
    }
    else
    {
      long long v44 = *((_OWORD *)v15 + 2);
      *((void *)v42 + 6) = v15[6];
      *((_OWORD *)v42 + 2) = v44;
    }
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json(v43 + 7, v15 + 7);
    *char v43 = 0;
    v43[1] = 0;
    v43[2] = (uint64_t)v30;
    *size_t v29 = v43;
    uint64_t v45 = (void *)**v4;
    if (v45)
    {
      void *v4 = v45;
      char v43 = *v29;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v4[1], v43);
    void v4[2] = (void *)((char *)v4[2] + 1);
    uint64_t v41 = (void *)v15[1];
    if (!v41)
    {
      do
      {
LABEL_71:
        uint64_t v46 = (void *)v15[2];
        BOOL v20 = *v46 == (void)v15;
        unint64_t v15 = v46;
      }
      while (!v20);
      goto LABEL_12;
    }
    do
    {
LABEL_69:
      uint64_t v46 = v41;
      uint64_t v41 = (void *)*v41;
    }
    while (v41);
LABEL_12:
    unint64_t v15 = v46;
    if (v46 == v55)
    {
LABEL_11:
      uint64_t v2 = a1;
      goto LABEL_80;
    }
  }
}

void sub_1A20970A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  operator delete(v12);
  _Unwind_Resume(a1);
}

char *nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::operator[](unsigned __int8 *a1, uint64_t a2)
{
  if (*a1)
  {
    if (*a1 != 1)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      unint64_t v27 = *a1;
      if (v27 > 9) {
        int v28 = "number";
      }
      else {
        int v28 = off_1E5A8F0B8[v27];
      }
      std::string::basic_string[abi:nn180100]<0>(&v29, v28);
      std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&v30, "cannot use operator[] with a string argument with ", &v29);
      nlohmann::detail::type_error::create((uint64_t)exception, 305, (uint64_t)&v30);
    }
    long long v4 = (char *)*((void *)a1 + 1);
    BOOL v5 = (uint64_t **)(v4 + 8);
    long long v7 = (uint64_t *)*((void *)v4 + 1);
    int v6 = *(char *)(a2 + 23);
    if (!v7) {
      goto LABEL_31;
    }
    if (v6 >= 0) {
      uint64_t v8 = (const std::string::value_type *)a2;
    }
    else {
      uint64_t v8 = *(const std::string::value_type **)a2;
    }
    if (v6 >= 0) {
      size_t v9 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      size_t v9 = *(void *)(a2 + 8);
    }
    while (1)
    {
      unsigned int v10 = (uint64_t **)v7;
      unint64_t v13 = (const void *)v7[4];
      size_t v11 = v7 + 4;
      uint64_t v12 = v13;
      int v14 = *((char *)v11 + 23);
      if (v14 >= 0) {
        unint64_t v15 = v11;
      }
      else {
        unint64_t v15 = v12;
      }
      if (v14 >= 0) {
        size_t v16 = *((unsigned __int8 *)v11 + 23);
      }
      else {
        size_t v16 = v11[1];
      }
      if (v16 >= v9) {
        size_t v17 = v9;
      }
      else {
        size_t v17 = v16;
      }
      int v18 = memcmp(v8, v15, v17);
      if (v18)
      {
        if (v18 < 0) {
          goto LABEL_11;
        }
LABEL_25:
        int v19 = memcmp(v15, v8, v17);
        if (v19)
        {
          if ((v19 & 0x80000000) == 0) {
            goto LABEL_39;
          }
        }
        else if (v16 >= v9)
        {
LABEL_39:
          int v21 = (char *)v10;
          return v21 + 56;
        }
        long long v7 = v10[1];
        if (!v7)
        {
          BOOL v20 = v10 + 1;
          goto LABEL_32;
        }
      }
      else
      {
        if (v9 >= v16) {
          goto LABEL_25;
        }
LABEL_11:
        long long v7 = *v10;
        if (!*v10)
        {
          BOOL v20 = v10;
          goto LABEL_32;
        }
      }
    }
  }
  *a1 = 1;
  long long v4 = (char *)operator new(0x18uLL);
  *((void *)v4 + 1) = 0;
  BOOL v5 = (uint64_t **)(v4 + 8);
  *((void *)v4 + 2) = 0;
  *(void *)long long v4 = v4 + 8;
  *((void *)a1 + 1) = v4;
  LOBYTE(v6) = *(unsigned char *)(a2 + 23);
LABEL_31:
  BOOL v20 = v5;
  unsigned int v10 = v5;
LABEL_32:
  int v21 = (char *)operator new(0x48uLL);
  int v22 = (std::string *)(v21 + 32);
  if ((v6 & 0x80) != 0)
  {
    std::string::__init_copy_ctor_external(v22, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v22->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    *((void *)v21 + 6) = *(void *)(a2 + 16);
  }
  v21[56] = 0;
  *((void *)v21 + 8) = 0;
  *(void *)int v21 = 0;
  *((void *)v21 + 1) = 0;
  *((void *)v21 + 2) = v10;
  *BOOL v20 = (uint64_t *)v21;
  uint64_t v23 = **(void **)v4;
  int v24 = (uint64_t *)v21;
  if (v23)
  {
    *(void *)long long v4 = v23;
    int v24 = *v20;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*v5, v24);
  ++*((void *)v4 + 2);
  return v21 + 56;
}

void sub_1A2097380(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1A2097394(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0)
  {
    operator delete(a9);
    if (v21)
    {
LABEL_8:
      __cxa_free_exception(v20);
      _Unwind_Resume(a1);
    }
  }
  else if (v21)
  {
    goto LABEL_8;
  }
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    int v5 = *(unsigned __int8 *)(i - 16);
    uint64_t v4 = i - 16;
    *(void *)(a1 + 16) = v4;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy((void ***)(v4 + 8), v5);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t *std::unique_ptr<std::__tree_node<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy((void ***)(v2 + 64), *(unsigned __int8 *)(v2 + 56));
      if (*(char *)(v2 + 55) < 0) {
        operator delete(*(void **)(v2 + 32));
      }
    }
    operator delete((void *)v2);
  }
  return a1;
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(uint64_t *a1, void *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6 = *a1;
  uint64_t v7 = a4 + 96 * *a2;
  uint64_t v8 = a4 + 96 * *a1;
  int v9 = *(unsigned __int8 *)(v7 + 23);
  unsigned int v10 = "";
  uint64_t v52 = *a2;
  if (*(char *)(v7 + 23) < 0)
  {
    if (*(void *)(v7 + 8)) {
      size_t v11 = *(const char **)v7;
    }
    else {
      size_t v11 = "";
    }
  }
  else if (*(unsigned char *)(v7 + 23))
  {
    size_t v11 = (const char *)(a4 + 96 * *a2);
  }
  else
  {
    size_t v11 = "";
  }
  size_t v12 = strlen(v11);
  if (*(char *)(v8 + 23) < 0)
  {
    if (*(void *)(v8 + 8)) {
      unsigned int v10 = *(const char **)v8;
    }
  }
  else if (*(unsigned char *)(v8 + 23))
  {
    unsigned int v10 = (const char *)v8;
  }
  size_t v13 = strlen(v10);
  size_t v14 = v13;
  if (v13 >= v12) {
    size_t v15 = v12;
  }
  else {
    size_t v15 = v13;
  }
  int v16 = memcmp(v11, v10, v15);
  if (v16)
  {
    if ((v16 & 0x80000000) == 0) {
      goto LABEL_19;
    }
LABEL_24:
    size_t v51 = a2;
    uint64_t v21 = *a3;
    uint64_t v22 = a4 + 96 * *a3;
    uint64_t v23 = "";
    if (*(char *)(v22 + 23) < 0)
    {
      if (*(void *)(v22 + 8)) {
        int v24 = *(const char **)v22;
      }
      else {
        int v24 = "";
      }
    }
    else if (*(unsigned char *)(v22 + 23))
    {
      int v24 = (const char *)(a4 + 96 * *a3);
    }
    else
    {
      int v24 = "";
    }
    size_t v35 = strlen(v24);
    if ((v9 & 0x80) != 0)
    {
      if (*(void *)(v7 + 8)) {
        uint64_t v23 = *(const char **)v7;
      }
    }
    else if (v9)
    {
      uint64_t v23 = (const char *)v7;
    }
    size_t v36 = strlen(v23);
    size_t v37 = v36;
    if (v36 >= v35) {
      size_t v38 = v35;
    }
    else {
      size_t v38 = v36;
    }
    uint64_t result = memcmp(v24, v23, v38);
    if (result)
    {
      if ((result & 0x80000000) == 0)
      {
LABEL_64:
        *a1 = v52;
        void *v51 = v6;
        uint64_t v39 = *a3;
        uint64_t v40 = a4 + 96 * *a3;
        if (*(char *)(v40 + 23) < 0)
        {
          uint64_t v41 = "";
          if (*(void *)(v40 + 8)) {
            char v42 = *(const char **)v40;
          }
          else {
            char v42 = "";
          }
        }
        else
        {
          uint64_t v41 = "";
          if (*(unsigned char *)(v40 + 23)) {
            char v42 = (const char *)(a4 + 96 * *a3);
          }
          else {
            char v42 = "";
          }
        }
        size_t v44 = strlen(v42);
        if (*(char *)(v8 + 23) < 0)
        {
          if (*(void *)(v8 + 8)) {
            uint64_t v41 = *(const char **)v8;
          }
        }
        else if (*(unsigned char *)(v8 + 23))
        {
          uint64_t v41 = (const char *)v8;
        }
        size_t v45 = strlen(v41);
        size_t v46 = v45;
        if (v45 >= v44) {
          size_t v47 = v44;
        }
        else {
          size_t v47 = v45;
        }
        uint64_t result = memcmp(v42, v41, v47);
        if (result)
        {
          if ((result & 0x80000000) == 0) {
            return result;
          }
        }
        else if (v44 >= v46)
        {
          return result;
        }
        void *v51 = v39;
LABEL_94:
        *a3 = v6;
        return result;
      }
    }
    else if (v35 >= v37)
    {
      goto LABEL_64;
    }
    *a1 = v21;
    goto LABEL_94;
  }
  if (v12 < v14) {
    goto LABEL_24;
  }
LABEL_19:
  uint64_t v17 = *a3;
  uint64_t v18 = a4 + 96 * *a3;
  int v19 = "";
  if (*(char *)(v18 + 23) < 0)
  {
    if (*(void *)(v18 + 8)) {
      BOOL v20 = *(const char **)v18;
    }
    else {
      BOOL v20 = "";
    }
  }
  else if (*(unsigned char *)(v18 + 23))
  {
    BOOL v20 = (const char *)(a4 + 96 * *a3);
  }
  else
  {
    BOOL v20 = "";
  }
  size_t v25 = strlen(v20);
  if ((v9 & 0x80) != 0)
  {
    if (*(void *)(v7 + 8)) {
      int v19 = *(const char **)v7;
    }
  }
  else if (v9)
  {
    int v19 = (const char *)v7;
  }
  size_t v26 = strlen(v19);
  size_t v27 = v26;
  if (v26 >= v25) {
    size_t v28 = v25;
  }
  else {
    size_t v28 = v26;
  }
  uint64_t result = memcmp(v20, v19, v28);
  if (result)
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v25 >= v27)
  {
    return result;
  }
  *a2 = v17;
  *a3 = v52;
  uint64_t v30 = *a2;
  uint64_t v31 = *a1;
  uint64_t v32 = a4 + 96 * *a2;
  uint64_t v33 = (const char *)(a4 + 96 * *a1);
  if (*(char *)(v32 + 23) < 0)
  {
    if (*(void *)(v32 + 8)) {
      uint64_t v34 = *(const char **)v32;
    }
    else {
      uint64_t v34 = "";
    }
  }
  else if (*(unsigned char *)(v32 + 23))
  {
    uint64_t v34 = (const char *)(a4 + 96 * *a2);
  }
  else
  {
    uint64_t v34 = "";
  }
  size_t v43 = strlen(v34);
  if (v33[23] < 0)
  {
    if (*((void *)v33 + 1)) {
      uint64_t v33 = *(const char **)v33;
    }
    else {
      uint64_t v33 = "";
    }
  }
  else if (!v33[23])
  {
    uint64_t v33 = "";
  }
  size_t v48 = strlen(v33);
  size_t v49 = v48;
  if (v48 >= v43) {
    size_t v50 = v43;
  }
  else {
    size_t v50 = v48;
  }
  uint64_t result = memcmp(v34, v33, v50);
  if (result)
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v43 >= v49)
  {
    return result;
  }
  *a1 = v30;
  *a2 = v31;
  return result;
}

uint64_t std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(a1, a2, a3, *(void *)(*(void *)a5 + 48));
  uint64_t v8 = *a4;
  uint64_t v9 = *a3;
  uint64_t v10 = *(void *)(*(void *)a5 + 48);
  uint64_t v11 = v10 + 96 * *a4;
  size_t v12 = (const char *)(v10 + 96 * *a3);
  if (*(char *)(v11 + 23) < 0)
  {
    if (*(void *)(v11 + 8)) {
      size_t v13 = *(const char **)v11;
    }
    else {
      size_t v13 = "";
    }
  }
  else if (*(unsigned char *)(v11 + 23))
  {
    size_t v13 = (const char *)(v10 + 96 * *a4);
  }
  else
  {
    size_t v13 = "";
  }
  size_t v14 = strlen(v13);
  if (v12[23] < 0)
  {
    if (*((void *)v12 + 1)) {
      size_t v12 = *(const char **)v12;
    }
    else {
      size_t v12 = "";
    }
  }
  else if (!v12[23])
  {
    size_t v12 = "";
  }
  size_t v15 = strlen(v12);
  size_t v16 = v15;
  if (v15 >= v14) {
    size_t v17 = v14;
  }
  else {
    size_t v17 = v15;
  }
  uint64_t result = memcmp(v13, v12, v17);
  if (result)
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v14 >= v16)
  {
    return result;
  }
  *a3 = v8;
  *a4 = v9;
  uint64_t v19 = *a3;
  uint64_t v20 = *a2;
  uint64_t v21 = v10 + 96 * *a3;
  uint64_t v22 = (const char *)(v10 + 96 * *a2);
  if (*(char *)(v21 + 23) < 0)
  {
    if (*(void *)(v21 + 8)) {
      uint64_t v23 = *(const char **)v21;
    }
    else {
      uint64_t v23 = "";
    }
  }
  else if (*(unsigned char *)(v21 + 23))
  {
    uint64_t v23 = (const char *)(v10 + 96 * *a3);
  }
  else
  {
    uint64_t v23 = "";
  }
  size_t v24 = strlen(v23);
  if (v22[23] < 0)
  {
    if (*((void *)v22 + 1)) {
      uint64_t v22 = *(const char **)v22;
    }
    else {
      uint64_t v22 = "";
    }
  }
  else if (!v22[23])
  {
    uint64_t v22 = "";
  }
  size_t v25 = strlen(v22);
  size_t v26 = v25;
  if (v25 >= v24) {
    size_t v27 = v24;
  }
  else {
    size_t v27 = v25;
  }
  uint64_t result = memcmp(v23, v22, v27);
  if (result)
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v24 >= v26)
  {
    return result;
  }
  *a2 = v19;
  *a3 = v20;
  uint64_t v28 = *a2;
  uint64_t v29 = *a1;
  uint64_t v30 = v10 + 96 * *a2;
  uint64_t v31 = (const char *)(v10 + 96 * *a1);
  if (*(char *)(v30 + 23) < 0)
  {
    if (*(void *)(v30 + 8)) {
      uint64_t v32 = *(const char **)v30;
    }
    else {
      uint64_t v32 = "";
    }
  }
  else if (*(unsigned char *)(v30 + 23))
  {
    uint64_t v32 = (const char *)(v10 + 96 * *a2);
  }
  else
  {
    uint64_t v32 = "";
  }
  size_t v33 = strlen(v32);
  if (v31[23] < 0)
  {
    if (*((void *)v31 + 1)) {
      uint64_t v31 = *(const char **)v31;
    }
    else {
      uint64_t v31 = "";
    }
  }
  else if (!v31[23])
  {
    uint64_t v31 = "";
  }
  size_t v34 = strlen(v31);
  size_t v35 = v34;
  if (v34 >= v33) {
    size_t v36 = v33;
  }
  else {
    size_t v36 = v34;
  }
  uint64_t result = memcmp(v32, v31, v36);
  if (result)
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v33 >= v35)
  {
    return result;
  }
  *a1 = v28;
  *a2 = v29;
  return result;
}

uint64_t std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(a1, a2, a3, a4, a6);
  uint64_t v9 = *a5;
  uint64_t v10 = *a4;
  uint64_t v11 = *(void *)(*(void *)a6 + 48);
  uint64_t v12 = v11 + 96 * *a5;
  size_t v13 = (const char *)(v11 + 96 * *a4);
  if (*(char *)(v12 + 23) < 0)
  {
    if (*(void *)(v12 + 8)) {
      size_t v14 = *(const char **)v12;
    }
    else {
      size_t v14 = "";
    }
  }
  else if (*(unsigned char *)(v12 + 23))
  {
    size_t v14 = (const char *)(v11 + 96 * *a5);
  }
  else
  {
    size_t v14 = "";
  }
  size_t v15 = strlen(v14);
  if (v13[23] < 0)
  {
    if (*((void *)v13 + 1)) {
      size_t v13 = *(const char **)v13;
    }
    else {
      size_t v13 = "";
    }
  }
  else if (!v13[23])
  {
    size_t v13 = "";
  }
  size_t v16 = strlen(v13);
  size_t v17 = v16;
  if (v16 >= v15) {
    size_t v18 = v15;
  }
  else {
    size_t v18 = v16;
  }
  uint64_t result = memcmp(v14, v13, v18);
  if (result)
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v15 >= v17)
  {
    return result;
  }
  *a4 = v9;
  *a5 = v10;
  uint64_t v20 = *a4;
  uint64_t v21 = *a3;
  uint64_t v22 = v11 + 96 * *a4;
  uint64_t v23 = (const char *)(v11 + 96 * *a3);
  if (*(char *)(v22 + 23) < 0)
  {
    if (*(void *)(v22 + 8)) {
      size_t v24 = *(const char **)v22;
    }
    else {
      size_t v24 = "";
    }
  }
  else if (*(unsigned char *)(v22 + 23))
  {
    size_t v24 = (const char *)(v11 + 96 * *a4);
  }
  else
  {
    size_t v24 = "";
  }
  size_t v25 = strlen(v24);
  if (v23[23] < 0)
  {
    if (*((void *)v23 + 1)) {
      uint64_t v23 = *(const char **)v23;
    }
    else {
      uint64_t v23 = "";
    }
  }
  else if (!v23[23])
  {
    uint64_t v23 = "";
  }
  size_t v26 = strlen(v23);
  size_t v27 = v26;
  if (v26 >= v25) {
    size_t v28 = v25;
  }
  else {
    size_t v28 = v26;
  }
  uint64_t result = memcmp(v24, v23, v28);
  if (result)
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v25 >= v27)
  {
    return result;
  }
  *a3 = v20;
  *a4 = v21;
  uint64_t v29 = *a3;
  uint64_t v30 = *a2;
  uint64_t v31 = v11 + 96 * *a3;
  uint64_t v32 = (const char *)(v11 + 96 * *a2);
  if (*(char *)(v31 + 23) < 0)
  {
    if (*(void *)(v31 + 8)) {
      size_t v33 = *(const char **)v31;
    }
    else {
      size_t v33 = "";
    }
  }
  else if (*(unsigned char *)(v31 + 23))
  {
    size_t v33 = (const char *)(v11 + 96 * *a3);
  }
  else
  {
    size_t v33 = "";
  }
  size_t v34 = strlen(v33);
  if (v32[23] < 0)
  {
    if (*((void *)v32 + 1)) {
      uint64_t v32 = *(const char **)v32;
    }
    else {
      uint64_t v32 = "";
    }
  }
  else if (!v32[23])
  {
    uint64_t v32 = "";
  }
  size_t v35 = strlen(v32);
  size_t v36 = v35;
  if (v35 >= v34) {
    size_t v37 = v34;
  }
  else {
    size_t v37 = v35;
  }
  uint64_t result = memcmp(v33, v32, v37);
  if (result)
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v34 >= v36)
  {
    return result;
  }
  *a2 = v29;
  *a3 = v30;
  uint64_t v38 = *a2;
  uint64_t v39 = *a1;
  uint64_t v40 = v11 + 96 * *a2;
  uint64_t v41 = (const char *)(v11 + 96 * *a1);
  if (*(char *)(v40 + 23) < 0)
  {
    if (*(void *)(v40 + 8)) {
      char v42 = *(const char **)v40;
    }
    else {
      char v42 = "";
    }
  }
  else if (*(unsigned char *)(v40 + 23))
  {
    char v42 = (const char *)(v11 + 96 * *a2);
  }
  else
  {
    char v42 = "";
  }
  size_t v43 = strlen(v42);
  if (v41[23] < 0)
  {
    if (*((void *)v41 + 1)) {
      uint64_t v41 = *(const char **)v41;
    }
    else {
      uint64_t v41 = "";
    }
  }
  else if (!v41[23])
  {
    uint64_t v41 = "";
  }
  size_t v44 = strlen(v41);
  size_t v45 = v44;
  if (v44 >= v43) {
    size_t v46 = v43;
  }
  else {
    size_t v46 = v44;
  }
  uint64_t result = memcmp(v42, v41, v46);
  if (result)
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v43 >= v45)
  {
    return result;
  }
  *a1 = v38;
  *a2 = v39;
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = a2 - a1;
  BOOL result = 1;
  switch(v5)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v7 = *(a2 - 1);
      uint64_t v8 = *a1;
      uint64_t v9 = *(void *)(*(void *)a3 + 48);
      uint64_t v10 = v9 + 96 * v7;
      uint64_t v11 = (const char *)(v9 + 96 * *a1);
      if (*(char *)(v10 + 23) < 0)
      {
        if (*(void *)(v10 + 8)) {
          uint64_t v12 = *(const char **)v10;
        }
        else {
          uint64_t v12 = "";
        }
      }
      else if (*(unsigned char *)(v10 + 23))
      {
        uint64_t v12 = (const char *)(v9 + 96 * v7);
      }
      else
      {
        uint64_t v12 = "";
      }
      size_t v35 = strlen(v12);
      if (v11[23] < 0)
      {
        if (*((void *)v11 + 1)) {
          uint64_t v11 = *(const char **)v11;
        }
        else {
          uint64_t v11 = "";
        }
      }
      else if (!v11[23])
      {
        uint64_t v11 = "";
      }
      size_t v36 = strlen(v11);
      size_t v37 = v36;
      if (v36 >= v35) {
        size_t v38 = v35;
      }
      else {
        size_t v38 = v36;
      }
      int v39 = memcmp(v12, v11, v38);
      if (v39)
      {
        if ((v39 & 0x80000000) == 0) {
          return 1;
        }
        goto LABEL_77;
      }
      if (v35 < v37)
      {
LABEL_77:
        *a1 = v7;
        *(v4 - 1) = v8;
        return 1;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(a1, a1 + 1, a2 - 1, *(void *)(*(void *)a3 + 48));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      size_t v13 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,gdc::tag_invoke(debugTree::dumpJson_t,gdc::DebugTreeNode const&)::$_0 &,unsigned long *>(a1, a1 + 1, a1 + 2, *(void *)(*(void *)a3 + 48));
      size_t v14 = a1 + 3;
      if (a1 + 3 == v4) {
        return 1;
      }
      uint64_t v43 = 0;
      int v41 = 0;
      uint64_t v45 = *(void *)(*(void *)a3 + 48);
      uint64_t v40 = v4;
      while (2)
      {
        uint64_t v42 = *v14;
        uint64_t v16 = v45 + 96 * *v14;
        if (*(char *)(v16 + 23) < 0)
        {
          if (*(void *)(v16 + 8)) {
            size_t v17 = *(const char **)v16;
          }
          else {
            size_t v17 = "";
          }
        }
        else if (*(unsigned char *)(v16 + 23))
        {
          size_t v17 = (const char *)(v45 + 96 * *v14);
        }
        else
        {
          size_t v17 = "";
        }
        uint64_t v18 = *v13;
        uint64_t v19 = v45 + 96 * *v13;
        size_t v20 = strlen(v17);
        if (*(char *)(v19 + 23) < 0)
        {
          if (*(void *)(v19 + 8)) {
            uint64_t v21 = *(const char **)v19;
          }
          else {
            uint64_t v21 = "";
          }
        }
        else if (*(unsigned char *)(v19 + 23))
        {
          uint64_t v21 = (const char *)(v45 + 96 * *v13);
        }
        else
        {
          uint64_t v21 = "";
        }
        size_t v22 = strlen(v21);
        size_t v23 = v22;
        if (v22 >= v20) {
          size_t v24 = v20;
        }
        else {
          size_t v24 = v22;
        }
        int v25 = memcmp(v17, v21, v24);
        if (v25)
        {
          if ((v25 & 0x80000000) == 0) {
            goto LABEL_11;
          }
        }
        else if (v20 >= v23)
        {
          goto LABEL_11;
        }
        *size_t v14 = v18;
        size_t v15 = a1;
        if (v13 == a1) {
          goto LABEL_10;
        }
        uint64_t v26 = v43;
        while (2)
        {
          if (*(char *)(v16 + 23) < 0)
          {
            if (*(void *)(v16 + 8)) {
              size_t v27 = *(const char **)v16;
            }
            else {
              size_t v27 = "";
            }
          }
          else if (*(unsigned char *)(v16 + 23))
          {
            size_t v27 = (const char *)v16;
          }
          else
          {
            size_t v27 = "";
          }
          uint64_t v28 = *(uint64_t *)((char *)a1 + v26 + 8);
          uint64_t v29 = (const char *)(v45 + 96 * v28);
          size_t v30 = strlen(v27);
          if (v29[23] < 0)
          {
            if (*((void *)v29 + 1)) {
              uint64_t v29 = *(const char **)v29;
            }
            else {
              uint64_t v29 = "";
            }
          }
          else if (!v29[23])
          {
            uint64_t v29 = "";
          }
          size_t v31 = strlen(v29);
          size_t v32 = v31;
          if (v31 >= v30) {
            size_t v33 = v30;
          }
          else {
            size_t v33 = v31;
          }
          int v34 = memcmp(v27, v29, v33);
          if (v34)
          {
            if ((v34 & 0x80000000) == 0)
            {
              size_t v15 = v13;
              goto LABEL_9;
            }
            goto LABEL_36;
          }
          if (v30 < v32)
          {
LABEL_36:
            --v13;
            *(uint64_t *)((char *)a1 + v26 + 16) = v28;
            v26 -= 8;
            if (v26 == -16)
            {
              size_t v15 = a1;
              goto LABEL_9;
            }
            continue;
          }
          break;
        }
        size_t v15 = (uint64_t *)((char *)a1 + v26 + 16);
LABEL_9:
        uint64_t v4 = v40;
LABEL_10:
        uint64_t *v15 = v42;
        if (++v41 == 8) {
          return v14 + 1 == v4;
        }
LABEL_11:
        size_t v13 = v14;
        v43 += 8;
        if (++v14 != v4) {
          continue;
        }
        return 1;
      }
  }
}

size_t *gdc::DebugTreeNode::operator=(size_t *a1, size_t *a2)
{
  if (a1 == a2) {
    return a1;
  }
  uint64_t v3 = a2;
  if (*((char *)a1 + 23) < 0)
  {
    if (*((char *)a2 + 23) >= 0)
    {
      size_t v5 = *((unsigned __int8 *)a2 + 23);
    }
    else
    {
      a2 = (size_t *)*a2;
      size_t v5 = v3[1];
    }
    std::string::__assign_no_alias<false>((void **)a1, a2, v5);
  }
  else if ((*((unsigned char *)a2 + 23) & 0x80) != 0)
  {
    std::string::__assign_no_alias<true>(a1, (void *)*a2, a2[1]);
  }
  else
  {
    long long v4 = *(_OWORD *)a2;
    a1[2] = a2[2];
    *(_OWORD *)a1 = v4;
  }
  uint64_t v6 = (void **)(a1 + 3);
  char v7 = *((unsigned char *)v3 + 47);
  if (*((char *)a1 + 47) < 0)
  {
    if (v7 >= 0) {
      uint64_t v9 = v3 + 3;
    }
    else {
      uint64_t v9 = (void *)v3[3];
    }
    if (v7 >= 0) {
      size_t v10 = *((unsigned __int8 *)v3 + 47);
    }
    else {
      size_t v10 = v3[4];
    }
    std::string::__assign_no_alias<false>(v6, v9, v10);
  }
  else if ((*((unsigned char *)v3 + 47) & 0x80) != 0)
  {
    std::string::__assign_no_alias<true>(v6, (void *)v3[3], v3[4]);
  }
  else
  {
    long long v8 = *(_OWORD *)(v3 + 3);
    a1[5] = v3[5];
    *(_OWORD *)uint64_t v6 = v8;
  }
  uint64_t v12 = (void **)(a1 + 6);
  uint64_t v11 = (char *)a1[6];
  size_t v13 = v3[6];
  size_t v14 = v3[7];
  unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - v13) >> 5);
  uint64_t v16 = a1[8];
  if (0xAAAAAAAAAAAAAAABLL * ((v16 - (uint64_t)v11) >> 5) < v15)
  {
    if (v11)
    {
      uint64_t v17 = a1[7];
      uint64_t v18 = (void *)a1[6];
      if ((char *)v17 != v11)
      {
        do
        {
          v17 -= 96;
          std::allocator_traits<std::allocator<gdc::DebugTreeNode>>::destroy[abi:nn180100]<gdc::DebugTreeNode,void,void>(v17);
        }
        while ((char *)v17 != v11);
        uint64_t v18 = *v12;
      }
      a1[7] = (size_t)v11;
      operator delete(v18);
      uint64_t v16 = 0;
      *uint64_t v12 = 0;
      a1[7] = 0;
      a1[8] = 0;
    }
    if (v15 > 0x2AAAAAAAAAAAAAALL) {
      goto LABEL_82;
    }
    unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * (v16 >> 5);
    uint64_t v20 = 2 * v19;
    if (2 * v19 <= v15) {
      uint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - v13) >> 5);
    }
    unint64_t v21 = v19 >= 0x155555555555555 ? 0x2AAAAAAAAAAAAAALL : v20;
    if (v21 > 0x2AAAAAAAAAAAAAALL) {
      goto LABEL_82;
    }
    uint64_t v22 = 96 * v21;
    uint64_t v11 = (char *)operator new(96 * v21);
    a1[6] = (size_t)v11;
    a1[7] = (size_t)v11;
    a1[8] = (size_t)&v11[v22];
    if (v13 != v14)
    {
      uint64_t v23 = 0;
      do
      {
        gdc::DebugTreeNode::DebugTreeNode((std::string *)&v11[v23], (const gdc::DebugTreeNode *)(v13 + v23));
        v23 += 96;
      }
      while (v13 + v23 != v14);
      v11 += v23;
    }
    goto LABEL_53;
  }
  uint64_t v24 = a1[7];
  if (0xAAAAAAAAAAAAAAABLL * ((v24 - (uint64_t)v11) >> 5) >= v15)
  {
    if (v13 != v14)
    {
      do
      {
        gdc::DebugTreeNode::operator=(v11, v13);
        v13 += 96;
        v11 += 96;
      }
      while (v13 != v14);
      uint64_t v24 = a1[7];
    }
    while ((char *)v24 != v11)
    {
      v24 -= 96;
      std::allocator_traits<std::allocator<gdc::DebugTreeNode>>::destroy[abi:nn180100]<gdc::DebugTreeNode,void,void>(v24);
    }
LABEL_53:
    a1[7] = (size_t)v11;
    goto LABEL_54;
  }
  size_t v25 = v13 + 32 * ((v24 - (uint64_t)v11) >> 5);
  if ((char *)v24 != v11)
  {
    uint64_t v26 = 32 * ((v24 - (uint64_t)v11) >> 5);
    do
    {
      gdc::DebugTreeNode::operator=(v11, v13);
      v13 += 96;
      v11 += 96;
      v26 -= 96;
    }
    while (v26);
    uint64_t v11 = (char *)a1[7];
  }
  size_t v27 = v11;
  if (v25 != v14)
  {
    uint64_t v28 = 0;
    do
    {
      gdc::DebugTreeNode::DebugTreeNode((std::string *)&v11[v28], (const gdc::DebugTreeNode *)(v25 + v28));
      v28 += 96;
    }
    while (v25 + v28 != v14);
    size_t v27 = &v11[v28];
  }
  a1[7] = (size_t)v27;
LABEL_54:
  size_t v30 = (void **)(a1 + 9);
  size_t v29 = a1[9];
  size_t v32 = (void **)v3[9];
  size_t v31 = (void **)v3[10];
  unint64_t v33 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v31 - (char *)v32) >> 4);
  uint64_t v34 = a1[11];
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v34 - v29) >> 4) < v33)
  {
    if (v29)
    {
      uint64_t v35 = a1[10];
      size_t v36 = (void *)a1[9];
      if (v35 != v29)
      {
        do
        {
          v35 -= 80;
          std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v35);
        }
        while (v35 != v29);
        size_t v36 = *v30;
      }
      a1[10] = v29;
      operator delete(v36);
      uint64_t v34 = 0;
      *size_t v30 = 0;
      a1[10] = 0;
      a1[11] = 0;
    }
    if (v33 <= 0x333333333333333)
    {
      unint64_t v37 = 0xCCCCCCCCCCCCCCCDLL * (v34 >> 4);
      uint64_t v38 = 2 * v37;
      if (2 * v37 <= v33) {
        uint64_t v38 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v31 - (char *)v32) >> 4);
      }
      unint64_t v39 = v37 >= 0x199999999999999 ? 0x333333333333333 : v38;
      if (v39 <= 0x333333333333333)
      {
        uint64_t v40 = 80 * v39;
        int v41 = (char *)operator new(80 * v39);
        a1[9] = (size_t)v41;
        a1[10] = (size_t)v41;
        a1[11] = (size_t)&v41[v40];
        if (v32 != v31)
        {
          uint64_t v42 = 0;
          do
          {
            gdc::DebugTreeProperty::DebugTreeProperty((std::string *)&v41[v42 * 8], (const gdc::DebugTreeProperty *)&v32[v42]);
            v42 += 10;
          }
          while (&v32[v42] != v31);
          v41 += v42 * 8;
        }
        a1[10] = (size_t)v41;
        return a1;
      }
    }
LABEL_82:
    abort();
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a1[10] - v29) >> 4) >= v33)
  {
    uint64_t v46 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<gdc::DebugTreeProperty *,gdc::DebugTreeProperty *,gdc::DebugTreeProperty *>(v32, v31, a1[9]);
    for (uint64_t i = a1[10]; i != v46; std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(i))
      i -= 80;
    a1[10] = v46;
  }
  else
  {
    uint64_t v43 = &v32[2 * ((uint64_t)(a1[10] - v29) >> 4)];
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<gdc::DebugTreeProperty *,gdc::DebugTreeProperty *,gdc::DebugTreeProperty *>(v32, v43, a1[9]);
    size_t v44 = a1[10];
    if (v43 != v31)
    {
      uint64_t v45 = 0;
      do
      {
        gdc::DebugTreeProperty::DebugTreeProperty((std::string *)(v44 + v45 * 8), (const gdc::DebugTreeProperty *)&v43[v45]);
        v45 += 10;
      }
      while (&v43[v45] != v31);
      v44 += v45 * 8;
    }
    a1[10] = v44;
  }
  return a1;
}

void sub_1A2098780(_Unwind_Exception *a1)
{
  *(void *)(v1 + 80) = v2;
  _Unwind_Resume(a1);
}

void sub_1A2098788(_Unwind_Exception *a1)
{
  *(void *)(v1 + 56) = v2;
  _Unwind_Resume(a1);
}

void sub_1A2098790(_Unwind_Exception *a1)
{
  *(void *)(v1 + 80) = v2;
  _Unwind_Resume(a1);
}

void sub_1A2098798(_Unwind_Exception *a1)
{
  *(void *)(v1 + 56) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<gdc::DebugTreeProperty *,gdc::DebugTreeProperty *,gdc::DebugTreeProperty *>(void **a1, void **a2, uint64_t a3)
{
  if (a1 != a2)
  {
    long long v4 = a2;
    for (uint64_t i = a1; i != v4; i += 10)
    {
      if ((void **)a3 != i)
      {
        char v7 = *((unsigned char *)i + 23);
        if (*(char *)(a3 + 23) < 0)
        {
          if (v7 >= 0) {
            uint64_t v9 = i;
          }
          else {
            uint64_t v9 = *i;
          }
          if (v7 >= 0) {
            size_t v10 = *((unsigned __int8 *)i + 23);
          }
          else {
            size_t v10 = (size_t)i[1];
          }
          std::string::__assign_no_alias<false>((void **)a3, v9, v10);
        }
        else if ((*((unsigned char *)i + 23) & 0x80) != 0)
        {
          std::string::__assign_no_alias<true>((void *)a3, *i, (size_t)i[1]);
        }
        else
        {
          long long v8 = *(_OWORD *)i;
          *(void *)(a3 + 16) = i[2];
          *(_OWORD *)a3 = v8;
        }
        uint64_t v11 = (void **)(a3 + 32);
        uint64_t v12 = *(char **)(a3 + 32);
        *(_DWORD *)(a3 + 24) = *((_DWORD *)i + 6);
        size_t v14 = (char *)i[4];
        size_t v13 = (long long *)i[5];
        unint64_t v15 = ((char *)v13 - v14) >> 6;
        uint64_t v16 = *(void *)(a3 + 48);
        if (v15 <= (v16 - (uint64_t)v12) >> 6)
        {
          unint64_t v19 = *(char **)(a3 + 40);
          unint64_t v20 = (v19 - v12) >> 6;
          if (v20 >= v15)
          {
            if (v14 != (char *)v13)
            {
              uint64_t v32 = 0;
              do
              {
                uint64_t v35 = &v14[v32];
                size_t v36 = &v12[v32];
                long long v37 = *(_OWORD *)&v14[v32];
                *(_OWORD *)(v36 + 9) = *(_OWORD *)&v14[v32 + 9];
                *(_OWORD *)size_t v36 = v37;
                if (v12 != v14)
                {
                  uint64_t v38 = (void **)(v36 + 32);
                  unint64_t v39 = (void **)(v35 + 32);
                  char v40 = v35[55];
                  if (v36[55] < 0)
                  {
                    if (v40 >= 0) {
                      unint64_t v33 = v35 + 32;
                    }
                    else {
                      unint64_t v33 = *v39;
                    }
                    if (v40 >= 0) {
                      size_t v34 = v35[55];
                    }
                    else {
                      size_t v34 = *(void *)&v14[v32 + 40];
                    }
                    std::string::__assign_no_alias<false>(v38, v33, v34);
                  }
                  else if (v35[55] < 0)
                  {
                    std::string::__assign_no_alias<true>(v38, *v39, *(void *)&v14[v32 + 40]);
                  }
                  else
                  {
                    long long v41 = *(_OWORD *)v39;
                    *((void *)v36 + 6) = *((void *)v35 + 6);
                    *(_OWORD *)uint64_t v38 = v41;
                  }
                }
                *((_DWORD *)v36 + 14) = *((_DWORD *)v35 + 14);
                v32 += 64;
              }
              while (v35 + 64 != (char *)v13);
              v12 += v32;
              unint64_t v19 = *(char **)(a3 + 40);
            }
            while (v19 != v12)
            {
              if (*(v19 - 9) < 0) {
                operator delete(*((void **)v19 - 4));
              }
              v19 -= 64;
            }
            *(void *)(a3 + 40) = v12;
          }
          else
          {
            unint64_t v21 = (long long *)&v14[64 * v20];
            if (v19 != v12)
            {
              uint64_t v22 = 0;
              do
              {
                size_t v25 = &v14[v22];
                uint64_t v26 = &v12[v22];
                long long v27 = *(_OWORD *)&v14[v22];
                *(_OWORD *)(v26 + 9) = *(_OWORD *)&v14[v22 + 9];
                *(_OWORD *)uint64_t v26 = v27;
                if (v12 != v14)
                {
                  uint64_t v28 = (void **)(v26 + 32);
                  size_t v29 = (void **)(v25 + 32);
                  char v30 = v25[55];
                  if (v26[55] < 0)
                  {
                    if (v30 >= 0) {
                      uint64_t v23 = v25 + 32;
                    }
                    else {
                      uint64_t v23 = *v29;
                    }
                    if (v30 >= 0) {
                      size_t v24 = v25[55];
                    }
                    else {
                      size_t v24 = *(void *)&v14[v22 + 40];
                    }
                    std::string::__assign_no_alias<false>(v28, v23, v24);
                  }
                  else if (v25[55] < 0)
                  {
                    std::string::__assign_no_alias<true>(v28, *v29, *(void *)&v14[v22 + 40]);
                  }
                  else
                  {
                    long long v31 = *(_OWORD *)v29;
                    *((void *)v26 + 6) = *((void *)v25 + 6);
                    *(_OWORD *)uint64_t v28 = v31;
                  }
                }
                *((_DWORD *)v26 + 14) = *((_DWORD *)v25 + 14);
                v22 += 64;
              }
              while (v25 + 64 != (char *)v21);
              uint64_t v12 = *(char **)(a3 + 40);
              long long v4 = a2;
            }
            size_t v53 = v12;
            if (v21 != v13)
            {
              uint64_t v54 = (uint64_t)&v14[64 * v20 + 32];
              char v55 = (std::string *)(v12 + 32);
              do
              {
                int v58 = v55;
                long long v59 = *(_OWORD *)(v54 - 32);
                *(_OWORD *)((char *)&v55[-1].__r_.__value_.__l.__data_ + 1) = *(_OWORD *)(v54 - 23);
                *(_OWORD *)&v55[-2].__r_.__value_.__r.__words[2] = v59;
                if (*(char *)(v54 + 23) < 0)
                {
                  std::string::__init_copy_ctor_external(v55, *(const std::string::value_type **)v54, *(void *)(v54 + 8));
                }
                else
                {
                  long long v56 = *(_OWORD *)v54;
                  v55->__r_.__value_.__r.__words[2] = *(void *)(v54 + 16);
                  *(_OWORD *)&v55->__r_.__value_.__l.__data_ = v56;
                }
                uint64_t v57 = v54 - 32;
                LODWORD(v58[1].__r_.__value_.__l.__data_) = *(_DWORD *)(v54 + 24);
                v54 += 64;
                char v55 = (std::string *)((char *)v58 + 64);
              }
              while ((long long *)(v57 + 64) != v13);
              size_t v53 = &v58[1].__r_.__value_.__s.__data_[8];
            }
            *(void *)(a3 + 40) = v53;
          }
        }
        else
        {
          if (v12)
          {
            uint64_t v17 = *(char **)(a3 + 40);
            uint64_t v18 = v12;
            if (v17 != v12)
            {
              do
              {
                if (*(v17 - 9) < 0) {
                  operator delete(*((void **)v17 - 4));
                }
                v17 -= 64;
              }
              while (v17 != v12);
              uint64_t v18 = *v11;
            }
            *(void *)(a3 + 40) = v12;
            operator delete(v18);
            uint64_t v16 = 0;
            *uint64_t v11 = 0;
            *(void *)(a3 + 40) = 0;
            *(void *)(a3 + 48) = 0;
          }
          if ((char *)v13 - v14 < 0) {
            goto LABEL_155;
          }
          uint64_t v42 = v16 >> 5;
          if (v16 >> 5 <= v15) {
            uint64_t v42 = ((char *)v13 - v14) >> 6;
          }
          BOOL v43 = (unint64_t)v16 >= 0x7FFFFFFFFFFFFFC0;
          unint64_t v44 = 0x3FFFFFFFFFFFFFFLL;
          if (!v43) {
            unint64_t v44 = v42;
          }
          if (v44 >> 58) {
LABEL_155:
          }
            abort();
          unint64_t v45 = v44 << 6;
          uint64_t v46 = (char *)operator new(v44 << 6);
          size_t v47 = v46;
          *(void *)(a3 + 32) = v46;
          *(void *)(a3 + 40) = v46;
          *(void *)(a3 + 48) = &v46[v45];
          if (v14 != (char *)v13)
          {
            size_t v48 = (long long *)(v14 + 32);
            size_t v49 = v46 + 32;
            do
            {
              long long v52 = *(v48 - 2);
              *(_OWORD *)(v49 - 23) = *(long long *)((char *)v48 - 23);
              *((_OWORD *)v49 - 2) = v52;
              if (*((char *)v48 + 23) < 0)
              {
                std::string::__init_copy_ctor_external((std::string *)v49, *(const std::string::value_type **)v48, *((void *)v48 + 1));
              }
              else
              {
                long long v50 = *v48;
                *((void *)v49 + 2) = *((void *)v48 + 2);
                *(_OWORD *)size_t v49 = v50;
              }
              size_t v51 = v48 - 2;
              *((_DWORD *)v49 + 6) = *((_DWORD *)v48 + 6);
              v48 += 4;
              v49 += 64;
            }
            while (v51 + 4 != v13);
            size_t v47 = v49 - 32;
          }
          *(void *)(a3 + 40) = v47;
        }
        uint64_t v61 = (void **)(a3 + 56);
        uint64_t v60 = *(void *)(a3 + 56);
        int v63 = (std::string::value_type **)i[7];
        size_t v62 = (std::string::value_type **)i[8];
        unint64_t v64 = 0xAAAAAAAAAAAAAAABLL * (v62 - v63);
        uint64_t v65 = *(void *)(a3 + 72);
        if (0xAAAAAAAAAAAAAAABLL * ((v65 - v60) >> 3) >= v64)
        {
          uint64_t v68 = *(void *)(a3 + 64);
          unint64_t v69 = 0xAAAAAAAAAAAAAAABLL * ((v68 - v60) >> 3);
          if (v69 >= v64)
          {
            if (v63 != v62)
            {
              do
              {
                if (v63 != (std::string::value_type **)v60)
                {
                  char v78 = *((unsigned char *)v63 + 23);
                  if (*(char *)(v60 + 23) < 0)
                  {
                    if (v78 >= 0) {
                      int v76 = (std::string::value_type *)v63;
                    }
                    else {
                      int v76 = *v63;
                    }
                    if (v78 >= 0) {
                      size_t v77 = *((unsigned __int8 *)v63 + 23);
                    }
                    else {
                      size_t v77 = (size_t)v63[1];
                    }
                    std::string::__assign_no_alias<false>((void **)v60, v76, v77);
                  }
                  else if ((*((unsigned char *)v63 + 23) & 0x80) != 0)
                  {
                    std::string::__assign_no_alias<true>((void *)v60, *v63, (size_t)v63[1]);
                  }
                  else
                  {
                    long long v79 = *(_OWORD *)v63;
                    *(void *)(v60 + 16) = v63[2];
                    *(_OWORD *)uint64_t v60 = v79;
                  }
                }
                v63 += 3;
                v60 += 24;
              }
              while (v63 != v62);
              uint64_t v68 = *(void *)(a3 + 64);
            }
            while (v68 != v60)
            {
              if (*(char *)(v68 - 1) < 0) {
                operator delete(*(void **)(v68 - 24));
              }
              v68 -= 24;
            }
            *(void *)(a3 + 64) = v60;
          }
          else
          {
            if (v68 != v60)
            {
              uint64_t v70 = 8 * ((v68 - v60) >> 3);
              size_t v71 = (void **)i[7];
              do
              {
                if (v71 != (void **)v60)
                {
                  char v74 = *((unsigned char *)v71 + 23);
                  if (*(char *)(v60 + 23) < 0)
                  {
                    if (v74 >= 0) {
                      unsigned int v72 = v71;
                    }
                    else {
                      unsigned int v72 = *v71;
                    }
                    if (v74 >= 0) {
                      size_t v73 = *((unsigned __int8 *)v71 + 23);
                    }
                    else {
                      size_t v73 = (size_t)v71[1];
                    }
                    std::string::__assign_no_alias<false>((void **)v60, v72, v73);
                  }
                  else if ((*((unsigned char *)v71 + 23) & 0x80) != 0)
                  {
                    std::string::__assign_no_alias<true>((void *)v60, *v71, (size_t)v71[1]);
                  }
                  else
                  {
                    long long v75 = *(_OWORD *)v71;
                    *(void *)(v60 + 16) = v71[2];
                    *(_OWORD *)uint64_t v60 = v75;
                  }
                }
                v71 += 3;
                v60 += 24;
                v70 -= 24;
              }
              while (v70);
              uint64_t v60 = *(void *)(a3 + 64);
              long long v4 = a2;
            }
            unint64_t v86 = &v63[3 * v69];
            uint64_t v87 = (std::string *)v60;
            if (v86 != v62)
            {
              uint64_t v87 = (std::string *)v60;
              do
              {
                if (*((char *)v86 + 23) < 0)
                {
                  std::string::__init_copy_ctor_external(v87, *v86, (std::string::size_type)v86[1]);
                }
                else
                {
                  long long v88 = *(_OWORD *)v86;
                  v87->__r_.__value_.__r.__words[2] = (std::string::size_type)v86[2];
                  *(_OWORD *)&v87->__r_.__value_.__l.__data_ = v88;
                }
                v86 += 3;
                ++v87;
              }
              while (v86 != v62);
            }
            *(void *)(a3 + 64) = v87;
          }
        }
        else
        {
          if (v60)
          {
            uint64_t v66 = *(void *)(a3 + 64);
            int v67 = *(void **)(a3 + 56);
            if (v66 != v60)
            {
              do
              {
                if (*(char *)(v66 - 1) < 0) {
                  operator delete(*(void **)(v66 - 24));
                }
                v66 -= 24;
              }
              while (v66 != v60);
              int v67 = *v61;
            }
            *(void *)(a3 + 64) = v60;
            operator delete(v67);
            uint64_t v65 = 0;
            *uint64_t v61 = 0;
            *(void *)(a3 + 64) = 0;
            *(void *)(a3 + 72) = 0;
          }
          if (v64 > 0xAAAAAAAAAAAAAAALL) {
            goto LABEL_155;
          }
          unint64_t v80 = 0xAAAAAAAAAAAAAAABLL * (v65 >> 3);
          uint64_t v81 = 2 * v80;
          if (2 * v80 <= v64) {
            uint64_t v81 = 0xAAAAAAAAAAAAAAABLL * (v62 - v63);
          }
          unint64_t v82 = v80 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v81;
          if (v82 > 0xAAAAAAAAAAAAAAALL) {
            goto LABEL_155;
          }
          uint64_t v83 = v82;
          int v84 = (std::string *)operator new(24 * v82);
          *(void *)(a3 + 56) = v84;
          *(void *)(a3 + 64) = v84;
          *(void *)(a3 + 72) = &v84[v83];
          if (v63 == v62)
          {
            uint64_t v6 = v84;
          }
          else
          {
            uint64_t v6 = v84;
            do
            {
              if (*((char *)v63 + 23) < 0)
              {
                std::string::__init_copy_ctor_external(v6, *v63, (std::string::size_type)v63[1]);
              }
              else
              {
                long long v85 = *(_OWORD *)v63;
                v6->__r_.__value_.__r.__words[2] = (std::string::size_type)v63[2];
                *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v85;
              }
              v63 += 3;
              ++v6;
            }
            while (v63 != v62);
          }
          *(void *)(a3 + 64) = v6;
        }
      }
      a3 += 80;
    }
  }
  return a3;
}

void sub_1A2098EF0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 64) = v2;
  _Unwind_Resume(a1);
}

void sub_1A2098EF8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) = v2;
  _Unwind_Resume(a1);
}

void sub_1A2098F00(_Unwind_Exception *a1)
{
  *(void *)(v1 + 64) = v2;
  _Unwind_Resume(a1);
}

void sub_1A2098F08(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) = v2;
  _Unwind_Resume(a1);
}

std::string *gdc::DebugTreeProperty::DebugTreeProperty(std::string *this, const gdc::DebugTreeProperty *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *(_OWORD *)a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  int v5 = *((_DWORD *)a2 + 6);
  this[1].__r_.__value_.__l.__size_ = 0;
  LODWORD(this[1].__r_.__value_.__l.__data_) = v5;
  this[1].__r_.__value_.__r.__words[2] = 0;
  this[2].__r_.__value_.__r.__words[0] = 0;
  uint64_t v6 = *((void *)a2 + 4);
  uint64_t v7 = *((void *)a2 + 5);
  uint64_t v8 = v7 - v6;
  if (v7 != v6)
  {
    if (v8 < 0) {
      abort();
    }
    uint64_t v9 = (char *)operator new(v7 - v6);
    uint64_t v10 = 0;
    this[1].__r_.__value_.__l.__size_ = (std::string::size_type)v9;
    this[1].__r_.__value_.__r.__words[2] = (std::string::size_type)v9;
    this[2].__r_.__value_.__r.__words[0] = (std::string::size_type)&v9[64 * (v8 >> 6)];
    do
    {
      uint64_t v12 = v6 + v10;
      size_t v13 = &v9[v10];
      long long v14 = *(_OWORD *)(v6 + v10);
      *(_OWORD *)(v13 + 9) = *(_OWORD *)(v6 + v10 + 9);
      *(_OWORD *)size_t v13 = v14;
      unint64_t v15 = (std::string *)&v9[v10 + 32];
      uint64_t v16 = (const std::string::value_type **)(v6 + v10 + 32);
      if (*(char *)(v6 + v10 + 55) < 0)
      {
        std::string::__init_copy_ctor_external(v15, *v16, *(void *)(v12 + 40));
      }
      else
      {
        long long v11 = *(_OWORD *)v16;
        *(void *)&v9[v10 + 48] = *(void *)(v6 + v10 + 48);
        *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v11;
      }
      *((_DWORD *)v13 + 14) = *(_DWORD *)(v12 + 56);
      v10 += 64;
    }
    while (v12 + 64 != v7);
    this[1].__r_.__value_.__r.__words[2] = (std::string::size_type)&v9[v10];
  }
  this[2].__r_.__value_.__l.__size_ = 0;
  this[2].__r_.__value_.__r.__words[2] = 0;
  this[3].__r_.__value_.__r.__words[0] = 0;
  uint64_t v17 = *((void *)a2 + 7);
  uint64_t v18 = *((void *)a2 + 8);
  int64_t v19 = v18 - v17;
  if (v18 != v17)
  {
    unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * (v19 >> 3);
    if (v20 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    unint64_t v21 = (char *)operator new(v19);
    uint64_t v22 = 0;
    this[2].__r_.__value_.__l.__size_ = (std::string::size_type)v21;
    this[2].__r_.__value_.__r.__words[2] = (std::string::size_type)v21;
    this[3].__r_.__value_.__r.__words[0] = (std::string::size_type)&v21[24 * v20];
    do
    {
      size_t v24 = (long long *)(v17 + v22);
      size_t v25 = (std::string *)&v21[v22];
      if (*(char *)(v17 + v22 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v25, *(const std::string::value_type **)v24, *((void *)v24 + 1));
      }
      else
      {
        long long v23 = *v24;
        v25->__r_.__value_.__r.__words[2] = *((void *)v24 + 2);
        *(_OWORD *)&v25->__r_.__value_.__l.__data_ = v23;
      }
      v22 += 24;
    }
    while (v17 + v22 != v18);
    this[2].__r_.__value_.__r.__words[2] = (std::string::size_type)&v21[v22];
  }
  return this;
}

void sub_1A20990DC(_Unwind_Exception *a1)
{
  std::vector<gdc::DebugTreeValue>::~vector[abi:nn180100](v2);
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(a1);
}

std::string *gdc::DebugTreeNode::DebugTreeNode(std::string *this, const gdc::DebugTreeNode *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *(_OWORD *)a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(this + 1, *((const std::string::value_type **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(_OWORD *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((void *)a2 + 5);
    *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = v5;
  }
  this[2].__r_.__value_.__r.__words[0] = 0;
  this[2].__r_.__value_.__l.__size_ = 0;
  this[2].__r_.__value_.__r.__words[2] = 0;
  uint64_t v6 = *((void *)a2 + 6);
  uint64_t v7 = *((void *)a2 + 7);
  int64_t v8 = v7 - v6;
  if (v7 != v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 5);
    if (v9 >= 0x2AAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v10 = (char *)operator new(v8);
    uint64_t v11 = 0;
    this[2].__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
    this[2].__r_.__value_.__l.__size_ = (std::string::size_type)v10;
    this[2].__r_.__value_.__r.__words[2] = (std::string::size_type)&v10[96 * v9];
    do
    {
      gdc::DebugTreeNode::DebugTreeNode((gdc::DebugTreeNode *)&v10[v11], (const gdc::DebugTreeNode *)(v6 + v11));
      v11 += 96;
    }
    while (v6 + v11 != v7);
    this[2].__r_.__value_.__l.__size_ = (std::string::size_type)&v10[v11];
  }
  this[3].__r_.__value_.__r.__words[0] = 0;
  this[3].__r_.__value_.__l.__size_ = 0;
  this[3].__r_.__value_.__r.__words[2] = 0;
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v12 = *((void *)a2 + 10);
  int64_t v14 = v12 - v13;
  if (v12 != v13)
  {
    unint64_t v15 = 0xCCCCCCCCCCCCCCCDLL * (v14 >> 4);
    if (v15 >= 0x333333333333334) {
      abort();
    }
    uint64_t v16 = (char *)operator new(v14);
    uint64_t v17 = 0;
    this[3].__r_.__value_.__r.__words[0] = (std::string::size_type)v16;
    this[3].__r_.__value_.__l.__size_ = (std::string::size_type)v16;
    this[3].__r_.__value_.__r.__words[2] = (std::string::size_type)&v16[80 * v15];
    do
    {
      gdc::DebugTreeProperty::DebugTreeProperty((std::string *)&v16[v17], (const gdc::DebugTreeProperty *)(v13 + v17));
      v17 += 80;
    }
    while (v13 + v17 != v12);
    this[3].__r_.__value_.__l.__size_ = (std::string::size_type)&v16[v17];
  }
  return this;
}

void sub_1A20992C4(_Unwind_Exception *exception_object)
{
  if ((*(char *)(v1 + 23) & 0x80000000) == 0) {
    _Unwind_Resume(exception_object);
  }
  operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void sub_1A2099480(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2099534(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A20997A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ggl::BuildingPointyRoofDepth::BuildingPipelineState::~BuildingPipelineState(ggl::BuildingPointyRoofDepth::BuildingPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  long long v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  long long v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::BuildingPointyRoofDepth::BuildingPipelineSetup::textureIsEnabled(ggl::BuildingPointyRoofDepth::BuildingPipelineSetup *this)
{
  return 0;
}

BOOL ggl::BuildingPointyRoofDepth::BuildingPipelineSetup::constantDataIsEnabled(ggl::BuildingPointyRoofDepth::BuildingPipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

void ggl::BuildingPointyRoofDepth::BuildingPipelineSetup::~BuildingPipelineSetup(ggl::BuildingPointyRoofDepth::BuildingPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::ConstantDataTyped<ggl::Tile::Clipping>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::Tile::Clipping>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Tile::Clipping>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Tile::Clipping>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586DF0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Tile::Clipping>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586DF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::NavLabelPart::layoutForDisplayWithNavContext(uint64_t a1, uint64_t a2, _DWORD *a3, float *a4, int8x16_t a5, int8x16_t a6, float32x4_t a7)
{
  uint64_t v7 = *(void *)(a1 + 640);
  if (v7)
  {
    *(unsigned char *)(a1 + 658) = *(unsigned char *)(a1 + 556);
    uint64_t v12 = (int8x16_t *)(a1 + 312);
    if (*(float *)(a1 + 320) < *(float *)(a1 + 312)
      || (a6.i32[0] = *(_DWORD *)(a1 + 316), *(float *)(a1 + 324) < *(float *)a6.i32))
    {
      unsigned __int8 v13 = atomic_load((unsigned __int8 *)(v7 + 144));
      if (v13) {
        long long v14 = *(_OWORD *)(v7 + 64);
      }
      else {
        long long v14 = xmmword_1A28FC750;
      }
      int8x16_t v39 = (int8x16_t)v14;
      md::CollisionObject::resetWithRects((void **)(a1 + 312), 1u);
      uint64_t v15 = *(void *)(a1 + 472);
      uint64_t v16 = *(unsigned int *)(a1 + 488);
      *(_DWORD *)(a1 + 488) = v16 + 1;
      *(int8x16_t *)(v15 + 16 * v16) = v39;
      v17.i64[0] = v39.i64[0];
      v17.i64[1] = v12->i64[1];
      a7.i64[0] = v12->i64[0];
      a7.i64[1] = v39.i64[1];
      a6 = (int8x16_t)vcgtq_f32(a7, v17);
      a5 = vbslq_s8(a6, v39, *v12);
      *uint64_t v12 = a5;
    }
    *(_DWORD *)(a1 + 520) = *a3;
    *(_DWORD *)(a1 + 524) = a3[1];
    *(_DWORD *)(a1 + 344) = *a3;
    a5.i32[0] = a3[1];
    *(_DWORD *)(a1 + 348) = a5.i32[0];
    md::CollisionObject::setupShapeData((uint64_t)v12, *(double *)a5.i64, *(double *)a6.i64, *(double *)a7.i64);
    unsigned __int8 v18 = atomic_load((unsigned __int8 *)(*(void *)(a1 + 640) + 143));
    if ((v18 & 1) == 0)
    {
      if (!*(unsigned char *)(a1 + 565)) {
        return;
      }
LABEL_23:
      int v41 = 0;
      uint64_t v40 = 0;
      char v42 = 1;
      uint64_t v29 = *(void *)(a2 + 24);
      uint64_t v30 = *(void *)(a1 + 32);
      double v31 = *(float *)(v30 + 72);
      double v32 = *(float *)(v30 + 68);
      generateRotationMatrixMeshPositioningMode((double *)&v66, (uint64_t)&v40, v29, (double *)(v30 + 32), *(unsigned __int8 *)(a1 + 766), 1, *(unsigned __int8 *)(a1 + 808));
      double v33 = v32 * v31 * *(double *)(v29 + 320);
      long long v54 = v66;
      long long v57 = v68;
      long long v60 = v70;
      uint64_t v55 = v67;
      uint64_t v58 = v69;
      uint64_t v61 = v71;
      uint64_t v56 = 0;
      uint64_t v59 = 0;
      uint64_t v62 = 0;
      long long v63 = *(_OWORD *)(v30 + 32);
      uint64_t v64 = *(void *)(v30 + 48);
      uint64_t v65 = 0x3FF0000000000000;
      long long v47 = 0u;
      uint64_t v49 = 0;
      long long v52 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v46 = 0u;
      long long v45 = 0u;
      uint64_t v53 = 0x3FF0000000000000;
      double v44 = v33;
      *(double *)&long long v47 = v33;
      double v50 = v33;
      gm::operator*<double,4,4,4>((double *)v43, (double *)&v54, &v44);
      size_t v34 = *(_OWORD **)(a1 + 816);
      long long v35 = v43[1];
      *size_t v34 = v43[0];
      v34[1] = v35;
      long long v36 = v43[3];
      v34[2] = v43[2];
      v34[3] = v36;
      long long v37 = v43[5];
      v34[4] = v43[4];
      v34[5] = v37;
      long long v38 = v43[7];
      v34[6] = v43[6];
      v34[7] = v38;
      return;
    }
    uint64_t v19 = *(void *)(a1 + 640);
    unsigned __int8 v20 = atomic_load((unsigned __int8 *)(v19 + 144));
    if (v20)
    {
      float v23 = *(float *)(v19 + 48);
      float v21 = *(float *)(v19 + 52);
      float v22 = *(float *)(v19 + 56);
      float v24 = *(float *)(v19 + 60);
    }
    else
    {
      float v21 = 3.4028e38;
      float v22 = -3.4028e38;
      float v23 = 3.4028e38;
      float v24 = -3.4028e38;
    }
    int v25 = *(unsigned __int8 *)(a1 + 565);
    BOOL v26 = v22 < v23;
    if (v24 < v21) {
      BOOL v26 = 1;
    }
    if (*(unsigned char *)(a1 + 565))
    {
      if (v26) {
        goto LABEL_22;
      }
      float v27 = *a4;
      float v28 = a4[1];
      float v23 = *a4 + v23;
    }
    else
    {
      if (v26) {
        goto LABEL_22;
      }
      float v27 = *(float *)(a1 + 520);
      float v23 = v27 + v23;
      float v28 = *(float *)(a1 + 524);
    }
    float v21 = v28 + v21;
    float v22 = v27 + v22;
    float v24 = v28 + v24;
LABEL_22:
    *(float *)(a1 + 696) = v23;
    *(float *)(a1 + 700) = v21;
    *(float *)(a1 + 704) = v22;
    *(float *)(a1 + 708) = v21;
    *(float *)(a1 + 712) = v22;
    *(float *)(a1 + 716) = v24;
    *(float *)(a1 + 720) = v23;
    *(float *)(a1 + 724) = v24;
    if (!v25) {
      return;
    }
    goto LABEL_23;
  }
}

uint64_t md::NavLabelPart::updateNavForDisplay(uint64_t this)
{
  int v1 = *(unsigned __int8 *)(this + 768);
  if (*(unsigned __int8 *)(this + 808) != v1)
  {
    uint64_t v2 = this;
    *(unsigned char *)(this + 808) = v1;
    *(unsigned char *)(this + 565) = v1 != 0;
    if (v1) {
      operator new();
    }
    this = *(void *)(this + 816);
    *(void *)(v2 + 816) = 0;
    if (this) {
      this = MEMORY[0x1A6239270](this, 0x1000C40AE2C30F4);
    }
    *(unsigned char *)(v2 + 665) = 1;
  }
  return this;
}

void md::NavLabelPart::layoutForStagingWithNavContext(md::CollisionObject *this, uint64_t a2, _DWORD *a3, __n128 a4, int8x16_t a5, float32x4_t a6)
{
  uint64_t v6 = *((void *)this + 80);
  if (v6)
  {
    uint64_t v10 = (char *)this + 72;
    if (*((float *)this + 20) < *((float *)this + 18)
      || (a5.i32[0] = *((_DWORD *)this + 19), *((float *)this + 21) < *(float *)a5.i32))
    {
      unsigned __int8 v11 = atomic_load((unsigned __int8 *)(v6 + 144));
      if (v11) {
        long long v12 = *(_OWORD *)(v6 + 64);
      }
      else {
        long long v12 = xmmword_1A28FC750;
      }
      int8x16_t v26 = (int8x16_t)v12;
      md::CollisionObject::resetWithRects((void **)this + 9, 1u);
      uint64_t v13 = *((void *)this + 29);
      uint64_t v14 = *((unsigned int *)this + 62);
      *((_DWORD *)this + 62) = v14 + 1;
      *(int8x16_t *)(v13 + 16 * v14) = v26;
      v15.i64[0] = v26.i64[0];
      v15.i64[1] = *((void *)this + 10);
      a6.i64[0] = *((void *)this + 9);
      a6.i64[1] = v26.i64[1];
      a5 = (int8x16_t)vcgtq_f32(a6, v15);
      a4 = (__n128)vbslq_s8(a5, v26, *(int8x16_t *)((char *)this + 72));
      *(__n128 *)((char *)this + 72) = a4;
    }
    *((_DWORD *)this + 70) = *a3;
    *((_DWORD *)this + 71) = a3[1];
    *((_DWORD *)this + 26) = *a3;
    a4.n128_u32[0] = a3[1];
    *((_DWORD *)this + 27) = a4.n128_u32[0];
    md::CollisionObject::setupShapeData((uint64_t)v10, a4.n128_f64[0], *(double *)a5.i64, *(double *)a6.i64);
    if (*((unsigned char *)this + 565))
    {
      int v28 = 0;
      uint64_t v27 = 0;
      char v29 = 1;
      uint64_t v16 = *(void *)(a2 + 24);
      uint64_t v17 = *((void *)this + 4);
      double v18 = *(float *)(v17 + 24);
      double v19 = *(float *)(v17 + 20);
      generateRotationMatrixMeshPositioningMode((double *)&v53, (uint64_t)&v27, v16, (double *)this + 98, *((unsigned __int8 *)this + 766), 1, *((unsigned __int8 *)this + 768));
      double v20 = v19 * v18 * *(double *)(v16 + 320);
      long long v41 = v53;
      long long v44 = v55;
      long long v47 = v57;
      uint64_t v42 = v54;
      uint64_t v45 = v56;
      uint64_t v48 = v58;
      uint64_t v43 = 0;
      uint64_t v46 = 0;
      uint64_t v49 = 0;
      long long v50 = *((_OWORD *)this + 49);
      uint64_t v51 = *((void *)this + 100);
      uint64_t v52 = 0x3FF0000000000000;
      long long v34 = 0u;
      uint64_t v36 = 0;
      long long v39 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      long long v32 = 0u;
      uint64_t v40 = 0x3FF0000000000000;
      double v31 = v20;
      *(double *)&long long v34 = v20;
      double v37 = v20;
      gm::operator*<double,4,4,4>((double *)v30, (double *)&v41, &v31);
      float v21 = (_OWORD *)*((void *)this + 97);
      long long v22 = v30[1];
      _OWORD *v21 = v30[0];
      v21[1] = v22;
      long long v23 = v30[3];
      void v21[2] = v30[2];
      void v21[3] = v23;
      long long v24 = v30[5];
      v21[4] = v30[4];
      v21[5] = v24;
      long long v25 = v30[7];
      v21[6] = v30[6];
      v21[7] = v25;
    }
  }
}

uint64_t md::NavLabelPart::updateWithNavLabelStyle(uint64_t result, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a2 + 8);
  if (v2 != *(unsigned __int8 *)(result + 768))
  {
    uint64_t v3 = result;
    *(unsigned char *)(result + 768) = v2;
    *(unsigned char *)(result + 565) = v2 != 0;
    if (v2) {
      operator new();
    }
    BOOL result = *(void *)(result + 776);
    *(void *)(v3 + 776) = 0;
    if (result)
    {
      JUMPOUT(0x1A6239270);
    }
  }
  return result;
}

void md::NavLabelPart::~NavLabelPart(md::NavLabelPart *this)
{
  *(void *)this = &unk_1EF531878;
  uint64_t v2 = *((void *)this + 102);
  *((void *)this + 102) = 0;
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40AE2C30F4);
  }
  uint64_t v3 = *((void *)this + 97);
  *((void *)this + 97) = 0;
  if (v3) {
    MEMORY[0x1A6239270](v3, 0x1000C40AE2C30F4);
  }
  md::IconLabelPart::~IconLabelPart(this);
  long long v4 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    long long v4 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v6) {
      operator new();
    }
  }
  long long v5 = *(void (**)(void))(**((void **)v4 + 91) + 40);
  v5();
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF531878;
  uint64_t v2 = *((void *)this + 102);
  *((void *)this + 102) = 0;
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40AE2C30F4);
  }
  uint64_t v3 = *((void *)this + 97);
  *((void *)this + 97) = 0;
  if (v3) {
    MEMORY[0x1A6239270](v3, 0x1000C40AE2C30F4);
  }
  md::IconLabelPart::~IconLabelPart(this);
}

void md::DaVinciGroundMetaData::flagsForPoint(char *a1, const QuadTile *a2, double *a3)
{
  unsigned int v5 = vcvtmd_s64_f64(a3[1] * 33554432.0);
  unsigned int v6 = vcvtmd_s64_f64(*a3 * 33554432.0);
  __int16 v18 = 6655;
  unsigned int v19 = 0x1FFFFFF - v5;
  unsigned int v20 = v6;
  md::DaVinciGroundMetaData::queryMetaTileFromTile((md::DaVinciGroundMetaData *)&v16, a2);
  if (v16)
  {
    char v7 = 1;
    int v8 = 1 << *(unsigned char *)(v16 + 169);
    double v9 = 1.0 / (double)v8;
    float32_t v10 = (*a3 - v9 * (double)*(int *)(v16 + 176)) * (double)v8;
    float v11 = -(a3[1] - v9 * (double)(v8 + ~*(_DWORD *)(v16 + 172))) * (double)v8;
    v12.f32[0] = v11 + 1.0;
    v12.f32[1] = v10;
    int32x2_t v13 = vmin_s32(vmax_s32(vcvt_s32_f32(vrndm_f32(vmul_n_f32(v12, (float)*(unsigned __int16 *)(v16 + 800)))), 0), vdup_n_s32(*(unsigned __int16 *)(v16 + 800) - 1));
    unint64_t v14 = *(unsigned __int16 *)(v16 + 800) * (unint64_t)v13.u16[0] + v13.u16[2];
    a1[1] = (((1 << v14) & *(void *)(*(void *)(v16 + 728) + ((v14 >> 3) & 0x3FFFFFF8))) != 0) | (2 * (((1 << v14) & *(void *)(*(void *)(v16 + 752) + ((v14 >> 3) & 0x3FFFFFF8))) != 0));
  }
  else
  {
    char v7 = 0;
  }
  *a1 = v7;
  float32x4_t v15 = v17;
  if (v17)
  {
    if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void md::Logic<md::ARLabelsLogic,md::ARLabelsContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    unsigned int v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      unsigned int v5 = __p;
    }
    float32x2_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void md::ARLabelsLogic::runBeforeLayout(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  unsigned int v5 = (void *)gdc::Registry::storage<arComponents::Configuration>(*(int8x8_t **)(a1 + 120));
  uint64_t v6 = v5[7];
  uint64_t v7 = v5[8];
  if (v6 != v7)
  {
    int v8 = (unsigned __int8 *)(v5[10] + 1);
    do
    {
      int v9 = *v8;
      v8 += 2;
      if (v9)
      {
        *a4 = 1;
      }
      else
      {
        float32_t v10 = +[VKDebugSettings sharedSettings];
        *a4 = [v10 arShowAllLabels];
      }
      v6 += 8;
    }
    while (v6 != v7);
  }
}

void sub_1A209A7E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<arComponents::Configuration>(int8x8_t *a1)
{
  unint64_t v10 = 0xAD7BA5E63AF64920;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xAD7BA5E63AF64920;
    if (*(void *)&v1 <= 0xAD7BA5E63AF64920) {
      unint64_t v3 = 0xAD7BA5E63AF64920 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xAD7BA5E63AF64920;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (unsigned int v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xAD7BA5E63AF64920)
      {
        if (v5[2] == 0xAD7BA5E63AF64920) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      unsigned int v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xAD7BA5E63AF64920) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    unsigned int v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xAD7BA5E63AF64920) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A209AA2C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL gdc::ComponentStorageWrapper<arComponents::Configuration>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::Configuration>::remove(void *a1, unint64_t a2)
{
  unint64_t v18 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  *(_WORD *)(v14 + 2 * v7) = *(_WORD *)(a1[11] - 2);
  a1[11] -= 2;
  float32x4_t v15 = (void *)a1[28];
  if (!v15) {
    return 1;
  }
  uint64_t v16 = a1[31];
  while (1)
  {
    v20[0] = &v18;
    v20[1] = 1;
    uint64_t v19 = v16;
    uint64_t v17 = v15[6];
    if (!v17) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v17 + 48))(v17, &v19, v20);
    float32x4_t v15 = (void *)*v15;
    if (!v15) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::Configuration>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::Configuration>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::Logic<md::ARLabelsLogic,md::ARLabelsContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::ARLabelsLogic,md::ARLabelsContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::allocateContext()
{
  return 0;
}

uint64_t md::Logic<md::ARLabelsLogic,md::ARLabelsContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x8741E659406FCBBLL && *(void *)(a3 + 32)) {
    return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)result + 160))(result, a2, v4);
  }
  a4[23] = 0;
  *a4 = 0;
  return result;
}

uint64_t md::Logic<md::ARLabelsLogic,md::ARLabelsContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x8741E659406FCBBLL)
  {
    if (*(void *)(a3 + 32)) {
      return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)result + 152))(result, a2, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARLabelsLogic,md::ARLabelsContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x8741E659406FCBBLL)
  {
    if (*(void *)(a3 + 32)) {
      return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)result + 144))(result, a2, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARLabelsLogic,md::ARLabelsContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x8741E659406FCBBLL)
  {
    if (*(void *)(a3 + 32)) {
      return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)result + 136))(result, a2, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARLabelsLogic,md::ARLabelsContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x8741E659406FCBBLL)
  {
    if (*(void *)(a3 + 32)) {
      return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)result + 128))(result, a2, v3);
    }
  }
  return result;
}

void md::Logic<md::ARLabelsLogic,md::ARLabelsContext,md::LogicDependencies<gdc::TypeList<>,gdc::TypeList<>>>::_allocateContext()
{
}

void sub_1A209AF04(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

uint64_t gdc::ObjectHolder<md::ARLabelsContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ARLabelsContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5554B0;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0x1000C4077774924);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ARLabelsContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5554B0;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C4077774924);
  }
  return a1;
}

void md::ARLabelsLogic::~ARLabelsLogic(md::ARLabelsLogic *this)
{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

uint64_t md::LabelMarker::elementCount(md::LabelMarker *this)
{
  return 0;
}

void md::LabelMarker::iconImageInfosForLabel(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  a1[3] = *((void *)v2 + 91);
}

void md::LabelMarker::dataIconImageKeys(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  a1[3] = *((void *)v2 + 91);
}

uint64_t md::LabelMarker::externalFeatureCategory(md::LabelMarker *this)
{
  return 0;
}

double md::NavLabelMarker::calloutAnchorPoint(md::NavLabelMarker *this)
{
  return *MEMORY[0x1E4F1DAD8];
}

uint64_t md::LabelMarker::pickedLabelBalloonBehavior(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::selectionBehavior(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::positionOfInterest()
{
  return 0;
}

uint64_t md::LabelMarker::facingDirection(md::LabelMarker *this)
{
  return 0;
}

double md::LabelMarker::elevationOffset(md::LabelMarker *this)
{
  return 0.0;
}

uint64_t md::LabelMarker::buildingFaceAzimuth(md::LabelMarker *this)
{
  return 0;
}

double md::LabelMarker::buildingHeight(md::LabelMarker *this)
{
  return 0.0;
}

uint64_t md::LabelMarker::coordinateNoFallbackElevation(md::LabelMarker *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 584))();
}

void md::NavLabelMarker::coordinate(id *this@<X0>, uint64_t a2@<X8>)
{
  int v3 = md::NavLabelMarker::navRoadLabel(this);
  uint64_t v4 = v3;
  if (v3 && *(void *)[v3 label])
  {
    uint64_t v5 = (uint64_t *)[v4 label];
    uint64_t v7 = *v5;
    uint64_t v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    if (v7)
    {
      uint64_t v8 = *(void *)(v7 + 160);
      if (v8)
      {
        (*(void (**)(uint64_t))(*(void *)v8 + 56))(v8);
        uint64_t v12 = v11;
      }
      else
      {
        double v9 = *(double *)(v7 + 112);
        double v10 = *(double *)(v7 + 120);
        uint64_t v12 = *(void *)(v7 + 128);
      }
      long double v14 = v9 * 6.28318531;
      long double v15 = exp(v10 * 6.28318531 + -3.14159265);
      long double v19 = atan(v15);
      long double v16 = fmod(v14, 6.28318531);
      long double v17 = fmod(v16 + 6.28318531, 6.28318531);
      v18.f64[0] = v19;
      v18.f64[1] = v17;
      float64x2_t v13 = vmlaq_f64((float64x2_t)xmmword_1A28FCC00, (float64x2_t)xmmword_1A28FCBF0, v18);
    }
    else
    {
      float64x2_t v13 = (float64x2_t)vdupq_n_s64(0xC066800000000000);
      uint64_t v12 = 0x7FEFFFFFFFFFFFFFLL;
    }
    *(float64x2_t *)a2 = v13;
    *(void *)(a2 + 16) = v12;
    if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  else
  {

    *(int64x2_t *)a2 = vdupq_n_s64(0xC066800000000000);
    *(void *)(a2 + 16) = 0x7FEFFFFFFFFFFFFFLL;
  }
}

void sub_1A209B474(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A209B488(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id md::NavLabelMarker::navRoadLabel(id *this)
{
  if ((*((unsigned int (**)(id *))*this + 21))(this))
  {
    if ((*((unsigned int (**)(id *))*this + 21))(this)) {
      id WeakRetained = objc_loadWeakRetained(this + 36);
    }
    else {
      id WeakRetained = 0;
    }
    int v3 = [WeakRetained label];
  }
  else
  {
    int v3 = 0;
  }
  return v3;
}

void sub_1A209B550(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::NavLabelMarker::screenPixelBounds(md::NavLabelMarker *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 568))();
}

float md::NavLabelMarker::screenCollisionBounds(id *this)
{
  md::LabelMarker::acquireDisplayLock((md::LabelMarker *)&v10, (uint64_t)this);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v2 = md::NavLabelMarker::navRoadLabel(this);
  int v3 = v2;
  if (!v2 || !*(void *)[v2 label])
  {

LABEL_10:
    float v7 = 3.4028e38;
    goto LABEL_11;
  }
  uint64_t v4 = (uint64_t *)[v3 label];
  uint64_t v6 = *v4;
  uint64_t v5 = (std::__shared_weak_count *)v4[1];
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  if (v6)
  {
    float v7 = *(float *)(v6 + 336);
    if (!v5) {
      goto LABEL_11;
    }
  }
  else
  {
    float v7 = 3.4028e38;
    if (!v5) {
      goto LABEL_11;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_11:
  if (v13) {
    std::recursive_mutex::unlock(v12);
  }
  uint64_t v8 = v11;
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  return v7;
}

void sub_1A209B724(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::pair<std::shared_ptr<md::LabelManager>,std::unique_lock<std::recursive_mutex>>::~pair((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::shared_ptr<md::LabelManager>,std::unique_lock<std::recursive_mutex>>::~pair(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24)) {
    std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 16));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

float md::NavLabelMarker::calloutAnchorRect(id *this)
{
  md::LabelMarker::acquireDisplayLock((md::LabelMarker *)&v10, (uint64_t)this);
  float v2 = 0.0;
  if ((*((uint64_t (**)(id *))*this + 58))(this))
  {
    int v3 = md::NavLabelMarker::navRoadLabel(this);
    uint64_t v4 = v3;
    if (!v3 || !*(void *)[v3 label])
    {

      goto LABEL_10;
    }
    uint64_t v5 = (uint64_t *)[v4 label];
    uint64_t v7 = *v5;
    uint64_t v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    if (v7)
    {
      float v2 = *(float *)(v7 + 336);
      if (!v6) {
        goto LABEL_10;
      }
    }
    else if (!v6)
    {
      goto LABEL_10;
    }
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
LABEL_10:
  if (v13) {
    std::recursive_mutex::unlock(v12);
  }
  uint64_t v8 = v11;
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  return v2;
}

void sub_1A209B970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::pair<std::shared_ptr<md::LabelManager>,std::unique_lock<std::recursive_mutex>>::~pair((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void md::LabelMarker::featureHandles(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  float v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    float v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  a1[3] = *((void *)v2 + 91);
}

void md::LabelMarker::transitSystems(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  float v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    float v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  a1[3] = *((void *)v2 + 91);
}

uint64_t md::LabelMarker::useVKSelectionBalloon(md::LabelMarker *this)
{
  return 1;
}

void md::LabelMarker::featureTile(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t md::LabelMarker::isDragged(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isOccluded(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isAlongSelectedTransitLine(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isTextVisible(md::LabelMarker *this)
{
  return 0;
}

BOOL md::NavLabelMarker::isVisible(id *this)
{
  md::LabelMarker::acquireDisplayLock((md::LabelMarker *)&v10, (uint64_t)this);
  float v2 = md::NavLabelMarker::navRoadLabel(this);
  int v3 = v2;
  if (!v2 || !*(void *)[v2 label])
  {

    BOOL v7 = 0;
    goto LABEL_15;
  }
  uint64_t v4 = (uint64_t *)[v3 label];
  uint64_t v6 = *v4;
  uint64_t v5 = (std::__shared_weak_count *)v4[1];
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  if (v6 && *(unsigned char *)(v6 + 325) && *(unsigned char *)(v6 + 326) && *(float *)(v6 + 268) > 0.0)
  {
    BOOL v7 = *(unsigned char *)(v6 + 327) != 0;
    if (!v5) {
      goto LABEL_15;
    }
  }
  else
  {
    BOOL v7 = 0;
    if (!v5) {
      goto LABEL_15;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_15:
  if (v13) {
    std::recursive_mutex::unlock(v12);
  }
  uint64_t v8 = v11;
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  return v7;
}

void sub_1A209BC8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::pair<std::shared_ptr<md::LabelManager>,std::unique_lock<std::recursive_mutex>>::~pair((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t md::LabelMarker::hasLaidOutForDisplay(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isInPickedState(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::NavLabelMarker::isSelected(id *this)
{
  md::LabelMarker::acquireDisplayLock((md::LabelMarker *)&v6, (uint64_t)this);
  id WeakRetained = objc_loadWeakRetained(this + 36);
  uint64_t v3 = [WeakRetained isPicked];

  if (v9) {
    std::recursive_mutex::unlock(v8);
  }
  uint64_t v4 = v7;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return v3;
}

void sub_1A209BD64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::pair<std::shared_ptr<md::LabelManager>,std::unique_lock<std::recursive_mutex>>::~pair((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t md::NavLabelMarker::isSelectable(md::NavLabelMarker *this)
{
  return 1;
}

uint64_t md::LabelMarker::externalFeatureAnnotation(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::routeAnnotations(md::LabelMarker *this)
{
  return (uint64_t)this + 256;
}

uint64_t md::LabelMarker::arWalkingFeature(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::waypointInfo(md::LabelMarker *this)
{
  return 0;
}

id md::NavLabelMarker::routeInfo(id *this)
{
  if ((*((unsigned int (**)(id *))*this + 21))(this)) {
    id WeakRetained = objc_loadWeakRetained(this + 36);
  }
  else {
    id WeakRetained = 0;
  }
  uint64_t v3 = [WeakRetained routeInfo];

  return v3;
}

void sub_1A209BE28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::LabelMarker::incident(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isVenueButton(md::LabelMarker *this)
{
  return 0;
}

void md::LabelMarker::parentClusterLabelMarker(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t md::LabelMarker::isClusterChild(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::clusterContentBounds(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isLeafCluster(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isCluster(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::clientFeatureID(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::featureID(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::businessID(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isTrail(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isPoint(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isTransitNode(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isOnRoute(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isTransitAccessPoint(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isTransitLine(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isTransit(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::sortKey(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::animationID(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isFlyoverTour(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::featureLabelIdentifier(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isARWalkingFeature(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isRouteAnnotation(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isRouteWaypoint(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isMuninRoadLabel(md::LabelMarker *this)
{
  return 0;
}

BOOL md::NavLabelMarker::isRouteEta(md::NavLabelMarker *this)
{
  return *((unsigned char *)this + 225) == 16;
}

uint64_t md::LabelMarker::isTrafficIncident(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::isOneWayArrow(md::LabelMarker *this)
{
  return 0;
}

void md::LabelMarker::locale(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  float v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    float v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  a1[3] = *((void *)v2 + 91);
}

void md::LabelMarker::subtext(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  float v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    float v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  a1[3] = *((void *)v2 + 91);
}

void md::LabelMarker::text(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  float v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    float v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  a1[3] = *((void *)v2 + 91);
}

void md::LabelMarker::debugString(uint64_t a1@<X8>)
{
  float v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    float v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  *(void *)(a1 + 24) = *((void *)v2 + 91);
  *(unsigned char *)(a1 + 23) = 11;
  strcpy((char *)a1, "LabelMarker");
}

double md::LabelMarker::maxZoomRank(md::LabelMarker *this)
{
  return 0.0;
}

double md::LabelMarker::minZoomRank(md::LabelMarker *this)
{
  return 0.0;
}

void md::LabelMarker::styleAttributes(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t md::LabelMarker::venueComponentType(md::LabelMarker *this)
{
  return 0;
}

void md::Marker::venueLookInsideFloorOrdinal(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t md::LabelMarker::venueFloorOrdinal(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::venueComponentId(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::venueLevelId(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::venueBuildingId(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::venueId(md::LabelMarker *this)
{
  return 0;
}

uint64_t md::LabelMarker::featureId(md::LabelMarker *this)
{
  return 0;
}

void md::Marker::shortName(uint64_t a1@<X8>)
{
  float v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    float v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  *(void *)(a1 + 24) = *((void *)v2 + 91);
  *(unsigned char *)(a1 + 23) = 0;
  *(unsigned char *)a1 = 0;
}

void md::LabelMarker::name(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  float v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    float v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  a1[3] = *((void *)v2 + 91);
}

void md::NavLabelMarker::~NavLabelMarker(id *this)
{
  *this = &unk_1EF5340D8;
  float v2 = this + 36;
  objc_storeWeak(this + 36, 0);
  objc_destroyWeak(v2);
  md::LabelMarker::~LabelMarker((md::LabelMarker *)this);
  JUMPOUT(0x1A6239270);
}

{
  id *v2;
  uint64_t vars8;

  *this = &unk_1EF5340D8;
  float v2 = this + 36;
  objc_storeWeak(this + 36, 0);
  objc_destroyWeak(v2);
  md::LabelMarker::~LabelMarker((md::LabelMarker *)this);
}

void md::LabelMarker::~LabelMarker(md::LabelMarker *this)
{
  *(void *)this = &unk_1EF530830;
  uint64_t v2 = *((void *)this + 32);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 33);
    uint64_t v4 = *((void *)this + 32);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(void **)(v3 - 8);
        v3 -= 8;
      }
      while (v3 != v2);
      uint64_t v4 = *((void *)this + 32);
    }
    *((void *)this + 33) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 35) + 40))(*((void *)this + 35), v4, *((void *)this + 34) - v4);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 30);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  uint64_t v7 = *((void *)this + 24);
  if (v7)
  {
    uint64_t v8 = *((void *)this + 25);
    uint64_t v9 = *((void *)this + 24);
    if (v8 != v7)
    {
      do
      {
        if (*(char *)(v8 - 9) < 0) {
          (*(void (**)(void, void, uint64_t))(**(void **)(v8 - 8) + 40))(*(void *)(v8 - 8), *(void *)(v8 - 32), *(void *)(v8 - 16) & 0x7FFFFFFFFFFFFFFFLL);
        }
        v8 -= 32;
      }
      while (v8 != v7);
      uint64_t v9 = *((void *)this + 24);
    }
    *((void *)this + 25) = v7;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 27) + 40))(*((void *)this + 27), v9, *((void *)this + 26) - v9);
  }
  uint64_t v10 = *((void *)this + 20);
  if (v10)
  {
    uint64_t v11 = *((void *)this + 21);
    uint64_t v12 = *((void *)this + 20);
    if (v11 != v10)
    {
      do
      {
        if (*(char *)(v11 - 9) < 0) {
          (*(void (**)(void, void, uint64_t))(**(void **)(v11 - 8) + 40))(*(void *)(v11 - 8), *(void *)(v11 - 32), *(void *)(v11 - 16) & 0x7FFFFFFFFFFFFFFFLL);
        }
        v11 -= 32;
      }
      while (v11 != v10);
      uint64_t v12 = *((void *)this + 20);
    }
    *((void *)this + 21) = v10;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 23) + 40))(*((void *)this + 23), v12, *((void *)this + 22) - v12);
  }
  char v13 = (void (***)(void, void))*((void *)this + 16);
  if (v13)
  {
    long double v14 = (void (***)(void, void))*((void *)this + 17);
    uint64_t v15 = *((void *)this + 16);
    if (v14 != v13)
    {
      long double v16 = v14 - 3;
      long double v17 = v14 - 3;
      float64x2_t v18 = v14 - 3;
      do
      {
        long double v19 = *v18;
        v18 -= 3;
        (*v19)(v17, v15);
        v16 -= 3;
        BOOL v20 = v17 == v13;
        long double v17 = v18;
      }
      while (!v20);
      uint64_t v15 = *((void *)this + 16);
    }
    *((void *)this + 17) = v13;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 19) + 40))(*((void *)this + 19), v15, *((void *)this + 18) - v15);
  }
  float v21 = (void (***)(void, void))*((void *)this + 12);
  if (v21)
  {
    long long v22 = (void (***)(void, void))*((void *)this + 13);
    uint64_t v23 = *((void *)this + 12);
    if (v22 != v21)
    {
      long long v24 = v22 - 3;
      long long v25 = v22 - 3;
      int8x16_t v26 = v22 - 3;
      do
      {
        uint64_t v27 = *v26;
        v26 -= 3;
        (*v27)(v25, v23);
        v24 -= 3;
        BOOL v20 = v25 == v21;
        long long v25 = v26;
      }
      while (!v20);
      uint64_t v23 = *((void *)this + 12);
    }
    *((void *)this + 13) = v21;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 15) + 40))(*((void *)this + 15), v23, *((void *)this + 14) - v23);
  }
  int v28 = (void (***)(void, void))*((void *)this + 8);
  if (v28)
  {
    char v29 = (void (***)(void, void))*((void *)this + 9);
    uint64_t v30 = *((void *)this + 8);
    if (v29 != v28)
    {
      double v31 = v29 - 3;
      long long v32 = v29 - 3;
      long long v33 = v29 - 3;
      do
      {
        long long v34 = *v33;
        v33 -= 3;
        (*v34)(v32, v30);
        v31 -= 3;
        BOOL v20 = v32 == v28;
        long long v32 = v33;
      }
      while (!v20);
      uint64_t v30 = *((void *)this + 8);
    }
    *((void *)this + 9) = v28;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 11) + 40))(*((void *)this + 11), v30, *((void *)this + 10) - v30);
  }
  uint64_t v35 = *((void *)this + 4);
  if (v35)
  {
    *((void *)this + 5) = v35;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 7) + 40))(*((void *)this + 7), v35, *((void *)this + 6) - v35);
  }
  uint64_t v36 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v36) {
    std::__shared_weak_count::__release_weak(v36);
  }
}

uint64_t md::LabelMarker::LabelMarker(uint64_t result, char a2, char a3, void *a4, float a5)
{
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(void *)BOOL result = &unk_1EF530830;
  *(void *)(result + 40) = 0;
  *(void *)(result + 48) = 0;
  uint64_t v5 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v45 = result;
    float v39 = a5;
    long long v33 = a4;
    char v21 = a2;
    char v27 = a3;
    uint64_t v5 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a2 = v21;
    a3 = v27;
    a4 = v33;
    a5 = v39;
    int v8 = v7;
    BOOL result = v45;
    if (v8) {
      operator new();
    }
  }
  *(void *)(result + 56) = *((void *)v5 + 91);
  *(void *)(result + 64) = 0;
  *(void *)(result + 72) = 0;
  *(void *)(result + 80) = 0;
  {
    uint64_t v46 = result;
    float v40 = a5;
    long long v34 = a4;
    char v22 = a2;
    char v28 = a3;
    uint64_t v5 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a2 = v22;
    a3 = v28;
    a4 = v34;
    a5 = v40;
    int v10 = v9;
    BOOL result = v46;
    if (v10) {
      operator new();
    }
  }
  *(void *)(result + 88) = *((void *)v5 + 91);
  *(void *)(result + 96) = 0;
  *(void *)(result + 104) = 0;
  *(void *)(result + 112) = 0;
  {
    uint64_t v47 = result;
    float v41 = a5;
    uint64_t v35 = a4;
    char v23 = a2;
    char v29 = a3;
    uint64_t v5 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a2 = v23;
    a3 = v29;
    a4 = v35;
    a5 = v41;
    int v12 = v11;
    BOOL result = v47;
    if (v12) {
      operator new();
    }
  }
  *(void *)(result + 120) = *((void *)v5 + 91);
  *(void *)(result + 128) = 0;
  *(void *)(result + 136) = 0;
  *(void *)(result + 144) = 0;
  {
    uint64_t v48 = result;
    float v42 = a5;
    uint64_t v36 = a4;
    char v24 = a2;
    char v30 = a3;
    uint64_t v5 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a2 = v24;
    a3 = v30;
    a4 = v36;
    a5 = v42;
    int v14 = v13;
    BOOL result = v48;
    if (v14) {
      operator new();
    }
  }
  *(void *)(result + 152) = *((void *)v5 + 91);
  *(void *)(result + 160) = 0;
  *(void *)(result + 168) = 0;
  *(void *)(result + 176) = 0;
  {
    uint64_t v49 = result;
    float v43 = a5;
    double v37 = a4;
    char v25 = a2;
    char v31 = a3;
    uint64_t v5 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a2 = v25;
    a3 = v31;
    a4 = v37;
    a5 = v43;
    int v16 = v15;
    BOOL result = v49;
    if (v16) {
      operator new();
    }
  }
  *(void *)(result + 184) = *((void *)v5 + 91);
  *(void *)(result + 192) = 0;
  *(void *)(result + 200) = 0;
  *(void *)(result + 208) = 0;
  {
    uint64_t v50 = result;
    float v44 = a5;
    long long v38 = a4;
    char v26 = a2;
    char v32 = a3;
    uint64_t v5 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a2 = v26;
    a3 = v32;
    a4 = v38;
    a5 = v44;
    int v18 = v17;
    BOOL result = v50;
    if (v18) {
      operator new();
    }
  }
  *(void *)(result + 216) = *((void *)v5 + 91);
  *(unsigned char *)(result + 224) = a2;
  *(unsigned char *)(result + 225) = a3;
  uint64_t v6 = a4[1];
  *(void *)(result + 232) = *a4;
  *(void *)(result + 240) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
  }
  *(float *)(result + 248) = a5;
  *(void *)(result + 264) = 0;
  *(void *)(result + 272) = 0;
  *(void *)(result + 256) = 0;
  {
    uint64_t v51 = result;
    uint64_t v5 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    int v20 = v19;
    BOOL result = v51;
    if (v20) {
      operator new();
    }
  }
  *(void *)(result + 280) = *((void *)v5 + 91);
  return result;
}

uint64_t md::NavLabelMarker::NavLabelMarker(uint64_t a1, uint64_t *a2, id *location, float a4)
{
  id v8 = objc_loadWeakRetained(location);
  int v9 = v8;
  if (v8)
  {
    if ([v8 isEtaFeature]) {
      char v10 = 16;
    }
    else {
      char v10 = 0;
    }
  }
  else
  {
    char v10 = 0;
  }

  uint64_t v11 = *a2;
  int v12 = (std::__shared_weak_count *)a2[1];
  v14[0] = v11;
  v14[1] = v12;
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    md::LabelMarker::LabelMarker(a1, 1, v10, v14, a4);
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  else
  {
    md::LabelMarker::LabelMarker(a1, 1, v10, v14, a4);
  }

  *(void *)a1 = &unk_1EF5340D8;
  objc_copyWeak((id *)(a1 + 288), location);
  return a1;
}

void sub_1A209CF08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::Icon::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::Icon::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Icon::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::Icon::DefaultVbo>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584DC8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Icon::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::Icon::DefaultVbo>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584DC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'ggl::Icon::IconMesh::~IconMesh(ggl::Icon::IconMesh *this)
{
  ggl::Mesh::~Mesh((ggl::Icon::IconMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Icon::IconMesh *)((char *)this - 16));
}

void ggl::Icon::IconMesh::~IconMesh(ggl::Icon::IconMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::Icon::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::Icon::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::Icon::IconPipelineState::~IconPipelineState(ggl::Icon::IconPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void ggl::Icon::IconPipelineSetup::~IconPipelineSetup(ggl::Icon::IconPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::Icon::MaskedIconPipelineState::~MaskedIconPipelineState(ggl::Icon::MaskedIconPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::Icon::MaskedIconPipelineSetup::textureIsEnabled(ggl::Icon::MaskedIconPipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

BOOL ggl::Icon::MaskedIconPipelineSetup::constantDataIsEnabled(ggl::Icon::MaskedIconPipelineSetup *this, unint64_t a2)
{
  return a2 < 5;
}

void ggl::Icon::MaskedIconPipelineSetup::~MaskedIconPipelineSetup(ggl::Icon::MaskedIconPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::Icon::WaypointPipelineState::~WaypointPipelineState(ggl::Icon::WaypointPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::Icon::WaypointPipelineSetup::textureIsEnabled(ggl::Icon::WaypointPipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

BOOL ggl::Icon::WaypointPipelineSetup::constantDataIsEnabled(ggl::Icon::WaypointPipelineSetup *this, unint64_t a2)
{
  return a2 < 5;
}

void ggl::Icon::WaypointPipelineSetup::~WaypointPipelineSetup(ggl::Icon::WaypointPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::Icon::ShadowPipelineState::~ShadowPipelineState(ggl::Icon::ShadowPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void ggl::Icon::ShadowPipelineSetup::~ShadowPipelineSetup(ggl::Icon::ShadowPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t altitude::DtmRequest::getDtmModel@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 224);
  *a2 = *(void *)(this + 216);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

uint64_t altitude::DtmRequest::succeeded(altitude::DtmRequest *this)
{
  return *((unsigned __int8 *)this + 188);
}

void altitude::DtmRequest::jobStep(altitude::DtmRequest *this)
{
  uint64_t v102 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 58) == 16)
  {
    if (*((_DWORD *)this + 62) >= 0xDu)
    {
      uint64_t v97 = 0;
      uint64_t v98 = 0;
      unint64_t v96 = off_1EF5677B0;
      *(void *)size_t v92 = 0;
      uint64_t v93 = 0;
      int v94 = 1;
      __int16 v95 = 0;
      BOOL MetaData = altitude::C3mmRequestManager::loadMetaData(*((void *)this + 25), (unsigned int *)this + 62, (uint64_t)v92, 1, (uint64_t)&v96);
      uint64_t v3 = v97;
      if (!MetaData && v97)
      {
        karo::Job::removeSubJob((pthread_mutex_t **)this, 0);
        uint64_t v4 = v98;
        v91[0] = v97;
        v91[1] = v98;
        if (v98)
        {
          atomic_fetch_add_explicit(&v98->__shared_owners_, 1uLL, memory_order_relaxed);
          karo::Job::addBlockingSubJob((uint64_t *)this, v91, 0, 0);
          if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
            std::__shared_weak_count::__release_weak(v4);
          }
        }
        else
        {
          karo::Job::addBlockingSubJob((uint64_t *)this, v91, 0, 0);
        }
        unint64_t v96 = off_1EF5677B0;
        if (v97) {
          atomic_fetch_add((atomic_uint *volatile)(v97 + 128), 0xFFFFFFFF);
        }
        uint64_t v36 = v98;
        if (v98)
        {
          if (!atomic_fetch_add(&v98->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
            std::__shared_weak_count::__release_weak(v36);
          }
        }
        return;
      }
      if (!v94)
      {
        unsigned int v5 = *((_DWORD *)this + 62);
        if (v5 >= 0x1F) {
          char v6 = 31;
        }
        else {
          char v6 = *((_DWORD *)this + 62);
        }
        int v7 = 1 << v5;
        double v8 = 6.28318531 / (double)v7;
        long double v9 = v8 * ((double)*((int *)this + 64) + 0.5);
        long double v10 = exp(v8 * ((double)((-1 << v6) + *((_DWORD *)this + 63) + v7) + 0.5) + -3.14159265);
        double v11 = atan(v10) * 2.0 + -1.57079633;
        long double v12 = fmod(v9, 6.28318531);
        double v13 = fmod(v12 + 6.28318531, 6.28318531) + -3.14159265;
        __double2 v14 = __sincos_stret(v11);
        double v15 = 6378137.0 / sqrt(v14.__sinval * v14.__sinval * -0.00669437999 + 1.0);
        __double2 v16 = __sincos_stret(v13);
        v17.f64[0] = v15 * v14.__cosval * v16.__sinval;
        v17.f64[1] = v14.__sinval * 0.99330562 * v15;
        long long v57 = 0u;
        long long v58 = 0u;
        long long v59 = 0u;
        long long v60 = 0u;
        long long v55 = 0;
        uint64_t v56 = &unk_1EF568F68;
        v61[0] = 0;
        long long v62 = 0u;
        long long v63 = 0u;
        long long v64 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v68 = 0u;
        int v71 = 0;
        uint64_t v69 = 0;
        uint64_t v70 = 0xFFFFFFFFLL;
        long long v73 = 0u;
        long long v74 = 0u;
        long long v75 = 0u;
        long long v76 = 0u;
        unsigned int v72 = &unk_1EF568F68;
        uint64_t v77 = 0;
        long long v78 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v83 = 0u;
        long long v84 = 0u;
        uint64_t v85 = 0;
        uint64_t v86 = 0xFFFFFFFFLL;
        int v87 = 0;
        uint64_t v90 = 0;
        std::string __p = 0;
        size_t v89 = 0;
        *(double *)buf = v15 * v14.__cosval * v16.__cosval;
        float64x2_t v54 = v17;
        float64x2_t v100 = v17;
        uint64_t v101 = 0x3FF0000000000000;
        altitude::TriggerManager::cullTriggers(*((void *)this + 26), (altitude::TriggerManager::Trigger **)&v55, buf, 0xFFFFFFFF);
        int v18 = (char *)__p;
        if (v55)
        {
          unint64_t v19 = 0;
          unsigned int v20 = 1;
          while (1)
          {
            unint64_t v21 = 240 * v19;
            char v22 = (char *)__p + v21;
            char v23 = (char *)__p + v21 + 72;
            char v24 = &(&v55)[v21 / 8];
            if ((unint64_t)v55 <= 2) {
              char v23 = &v61[v21 / 8];
            }
            if (*v23)
            {
              char v25 = v22 + 40;
              if ((unint64_t)v55 <= 2) {
                char v25 = (char *)(v24 + 6);
              }
              float64x2_t v26 = vsubq_f64(*(float64x2_t *)(v25 + 8), v54);
              float64x2_t v27 = vmulq_f64(v26, v26);
              char v28 = (double *)(v22 + 64);
              char v29 = (double *)(v24 + 9);
              if ((unint64_t)v55 <= 2) {
                char v28 = v29;
              }
              if (v27.f64[0]
                 + (*(double *)v25 - v15 * v14.__cosval * v16.__cosval)
                 * (*(double *)v25 - v15 * v14.__cosval * v16.__cosval)
                 + v27.f64[1] < *v28 * *v28)
                break;
            }
            unint64_t v19 = v20++;
            if ((unint64_t)v55 <= v19) {
              goto LABEL_35;
            }
          }
          char v30 = (char *)__p + v21;
          char v31 = (char *)__p + v21 + 232;
          char v32 = &(&v55)[v21 / 8];
          if ((unint64_t)v55 <= 2) {
            long long v33 = v32 + 30;
          }
          else {
            long long v33 = v31;
          }
          long long v34 = v30 + 228;
          uint64_t v35 = (char *)v32 + 236;
          if ((unint64_t)v55 <= 2) {
            long long v34 = v35;
          }
          *((_DWORD *)this + 58) = 16;
          *((_DWORD *)this + 59) = *(_DWORD *)v34;
          *((_DWORD *)this + 61) = *v33;
        }
LABEL_35:
        if (v18)
        {
          double v37 = v18;
          if (v89 != v18)
          {
            long long v38 = v89 - 240;
            float v39 = v89 - 240;
            float v40 = v89 - 240;
            do
            {
              float v41 = *(void (***)(char *))v40;
              v40 -= 240;
              (*v41)(v39);
              v38 -= 240;
              BOOL v42 = v39 == v18;
              float v39 = v40;
            }
            while (!v42);
            double v37 = __p;
          }
          size_t v89 = v18;
          operator delete(v37);
        }
        altitude::TriggerManager::Trigger::~Trigger((altitude::TriggerManager::Trigger *)&v72);
        altitude::TriggerManager::Trigger::~Trigger((altitude::TriggerManager::Trigger *)&v56);
        uint64_t v3 = v97;
      }
      unint64_t v96 = off_1EF5677B0;
      if (v3) {
        atomic_fetch_add((atomic_uint *volatile)(v3 + 128), 0xFFFFFFFF);
      }
      float v43 = v98;
      if (v98 && !atomic_fetch_add(&v98->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
      }
    }
    if (!*((_DWORD *)this + 59))
    {
      *((unsigned char *)this + 188) = 0;
LABEL_79:
      pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
      *((_DWORD *)this + 40) |= 1u;
      pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
      return;
    }
  }
  if (*((void *)this + 27))
  {
LABEL_75:
    pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
    int v52 = *((_DWORD *)this + 40);
    pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
    BOOL v53 = (v52 & 2) == 0 && *((void *)this + 27) != 0;
    *((unsigned char *)this + 188) = v53;
    goto LABEL_79;
  }
  atomic_load((unsigned int *)this + 4);
  (*(void (**)(void *__return_ptr))(**((void **)this + 24) + 104))(&v55);
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v55) == 4)
  {
    if ((*(uint64_t (**)(void))(**((void **)&v57 + 1) + 48))(*((void *)&v57 + 1))) {
      operator new();
    }
    int v45 = 1;
  }
  else
  {
    if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v55))
    {
      float v44 = (std::__shared_weak_count *)v57;
      unint64_t v96 = (void (**)(karo::AsyncRequestManager::RequestHandle *__hidden))v56;
      uint64_t v97 = v57;
      if ((void)v57)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v57 + 8), 1uLL, memory_order_relaxed);
        karo::Job::addBlockingSubJob((uint64_t *)this, &v96, 1, 0);
        int v45 = 0;
        if (atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
          goto LABEL_66;
        }
        ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
        std::__shared_weak_count::__release_weak(v44);
      }
      else
      {
        karo::Job::addBlockingSubJob((uint64_t *)this, &v96, 1, 0);
      }
      int v45 = 0;
      goto LABEL_66;
    }
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    uint64_t v46 = GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
    {
      int v48 = *((_DWORD *)this + 63);
      int v47 = *((_DWORD *)this + 64);
      int v49 = *((_DWORD *)this + 62);
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)&buf[4] = v48;
      LOWORD(v100.f64[0]) = 1024;
      *(_DWORD *)((char *)v100.f64 + 2) = v47;
      HIWORD(v100.f64[0]) = 1024;
      LODWORD(v100.f64[1]) = v49;
      _os_log_impl(&dword_1A1780000, v46, OS_LOG_TYPE_ERROR, "Failed to load DTM: %u %u %u", buf, 0x14u);
    }
    (*(void (**)(altitude::DtmRequest *))(*(void *)this + 16))(this);
    int v45 = 1;
  }
LABEL_66:
  long long v55 = off_1EF5676C0;
  uint64_t v50 = (std::__shared_weak_count *)v58;
  if ((void)v58 && !atomic_fetch_add((atomic_ullong *volatile)(v58 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
    std::__shared_weak_count::__release_weak(v50);
  }
  long long v55 = off_1EF5677B0;
  if (v56) {
    atomic_fetch_add((atomic_uint *volatile)v56 + 32, 0xFFFFFFFF);
  }
  uint64_t v51 = (std::__shared_weak_count *)v57;
  if ((void)v57 && !atomic_fetch_add((atomic_ullong *volatile)(v57 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
    std::__shared_weak_count::__release_weak(v51);
  }
  if (v45) {
    goto LABEL_75;
  }
}

uint64_t std::__shared_ptr_pointer<karo::media::DigitalTerrainModel *,std::shared_ptr<karo::media::DigitalTerrainModel>::__shared_ptr_default_delete<karo::media::DigitalTerrainModel,karo::media::DigitalTerrainModel>,std::allocator<karo::media::DigitalTerrainModel>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<karo::media::DigitalTerrainModel *,std::shared_ptr<karo::media::DigitalTerrainModel>::__shared_ptr_default_delete<karo::media::DigitalTerrainModel,karo::media::DigitalTerrainModel>,std::allocator<karo::media::DigitalTerrainModel>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void altitude::DtmRequest::~DtmRequest(altitude::DtmRequest *this)
{
  *(void *)this = &unk_1EF5683B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 28);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  karo::Job::~Job(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF5683B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 28);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  karo::Job::~Job(this);
}

double karo::Oriented::setFrame(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = *(void *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 48);
  *(void *)(a1 + 8) = *(void *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 8);
  double result = *(double *)(a2 + 16);
  *(double *)(a1 + 24) = result;
  return result;
}

void karo::Oriented::~Oriented(karo::Oriented *this)
{
  *(void *)this = &unk_1EF5681C8;
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF5681C8;
}

uint64_t std::__function::__func<md::PostchainRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::PostchainRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF575240;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::PostchainRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::PostchainRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF575240;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PostchainRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::PostchainRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5751F8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF5751F8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::PostchainRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::~__func()
{
}

void md::PostchainRenderLayer::~PostchainRenderLayer(md::PostchainRenderLayer *this)
{
  md::PostchainRenderLayer::~PostchainRenderLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  std::__shared_weak_count *v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  std::__shared_weak_count *v24;
  std::__shared_weak_count *v25;
  std::__shared_weak_count *v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  std::__shared_weak_count *v31;
  std::__shared_weak_count *v32;
  std::__shared_weak_count *v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  std::__shared_weak_count *v38;
  std::__shared_weak_count *v39;
  std::__shared_weak_count *v40;
  std::__shared_weak_count *v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  std::__shared_weak_count *v44;
  std::__shared_weak_count *v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  std::__shared_weak_count *v48;
  std::__shared_weak_count *v49;
  uint64_t v50;
  std::__shared_weak_count *v51;
  std::__shared_weak_count *v52;
  std::__shared_weak_count *v53;
  std::__shared_weak_count *v54;
  std::__shared_weak_count *v55;
  std::__shared_weak_count *v56;
  std::__shared_weak_count *v57;
  std::__shared_weak_count *v58;
  std::__shared_weak_count *v59;
  void *v60;

  *(void *)this = &unk_1EF53EC20;
  uint64_t v2 = *((void *)this + 109);
  *((void *)this + 109) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 108);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 106);
    if (!v4) {
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 106);
    if (!v4) {
      goto LABEL_9;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_9:
  unsigned int v5 = (std::__shared_weak_count *)*((void *)this + 104);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  char v6 = *((void *)this + 102);
  *((void *)this + 102) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  int v7 = *((void *)this + 101);
  *((void *)this + 101) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  double v8 = *((void *)this + 100);
  *((void *)this + 100) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  long double v9 = *((void *)this + 99);
  *((void *)this + 99) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  long double v10 = (std::__shared_weak_count *)*((void *)this + 98);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    double v11 = (std::__shared_weak_count *)*((void *)this + 96);
    if (!v11) {
      goto LABEL_26;
    }
  }
  else
  {
    double v11 = (std::__shared_weak_count *)*((void *)this + 96);
    if (!v11) {
      goto LABEL_26;
    }
  }
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
LABEL_26:
  long double v12 = (std::__shared_weak_count *)*((void *)this + 94);
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
    double v13 = (std::__shared_weak_count *)*((void *)this + 92);
    if (!v13) {
      goto LABEL_32;
    }
  }
  else
  {
    double v13 = (std::__shared_weak_count *)*((void *)this + 92);
    if (!v13) {
      goto LABEL_32;
    }
  }
  if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
LABEL_32:
  __double2 v14 = (std::__shared_weak_count *)*((void *)this + 90);
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
    double v15 = (std::__shared_weak_count *)*((void *)this + 88);
    if (!v15) {
      goto LABEL_38;
    }
  }
  else
  {
    double v15 = (std::__shared_weak_count *)*((void *)this + 88);
    if (!v15) {
      goto LABEL_38;
    }
  }
  if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
LABEL_38:
  __double2 v16 = (std::__shared_weak_count *)*((void *)this + 86);
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  float64x2_t v17 = *((void *)this + 84);
  *((void *)this + 84) = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  int v18 = (std::__shared_weak_count *)*((void *)this + 83);
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
    unint64_t v19 = (std::__shared_weak_count *)*((void *)this + 81);
    if (!v19) {
      goto LABEL_49;
    }
  }
  else
  {
    unint64_t v19 = (std::__shared_weak_count *)*((void *)this + 81);
    if (!v19) {
      goto LABEL_49;
    }
  }
  if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
LABEL_49:
  unsigned int v20 = (std::__shared_weak_count *)*((void *)this + 79);
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  unint64_t v21 = *((void *)this + 77);
  *((void *)this + 77) = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  char v22 = *((void *)this + 76);
  *((void *)this + 76) = 0;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  }
  char v23 = (std::__shared_weak_count *)*((void *)this + 75);
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
    char v24 = (std::__shared_weak_count *)*((void *)this + 73);
    if (!v24) {
      goto LABEL_62;
    }
  }
  else
  {
    char v24 = (std::__shared_weak_count *)*((void *)this + 73);
    if (!v24) {
      goto LABEL_62;
    }
  }
  if (!atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
LABEL_62:
  char v25 = (std::__shared_weak_count *)*((void *)this + 71);
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
    float64x2_t v26 = (std::__shared_weak_count *)*((void *)this + 69);
    if (!v26) {
      goto LABEL_68;
    }
  }
  else
  {
    float64x2_t v26 = (std::__shared_weak_count *)*((void *)this + 69);
    if (!v26) {
      goto LABEL_68;
    }
  }
  if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
LABEL_68:
  float64x2_t v27 = (std::__shared_weak_count *)*((void *)this + 67);
  if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
  char v28 = *((void *)this + 65);
  *((void *)this + 65) = 0;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
  }
  char v29 = *((void *)this + 64);
  *((void *)this + 64) = 0;
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
  }
  char v30 = (std::__shared_weak_count *)*((void *)this + 63);
  if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
    char v31 = (std::__shared_weak_count *)*((void *)this + 61);
    if (!v31) {
      goto LABEL_81;
    }
  }
  else
  {
    char v31 = (std::__shared_weak_count *)*((void *)this + 61);
    if (!v31) {
      goto LABEL_81;
    }
  }
  if (!atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
LABEL_81:
  char v32 = (std::__shared_weak_count *)*((void *)this + 59);
  if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
    std::__shared_weak_count::__release_weak(v32);
    long long v33 = (std::__shared_weak_count *)*((void *)this + 57);
    if (!v33) {
      goto LABEL_87;
    }
  }
  else
  {
    long long v33 = (std::__shared_weak_count *)*((void *)this + 57);
    if (!v33) {
      goto LABEL_87;
    }
  }
  if (!atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
LABEL_87:
  long long v34 = (std::__shared_weak_count *)*((void *)this + 55);
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  uint64_t v35 = *((void *)this + 53);
  *((void *)this + 53) = 0;
  if (v35) {
    (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
  }
  uint64_t v36 = *((void *)this + 52);
  *((void *)this + 52) = 0;
  if (v36) {
    (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
  }
  double v37 = (std::__shared_weak_count *)*((void *)this + 51);
  if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
    std::__shared_weak_count::__release_weak(v37);
    long long v38 = (std::__shared_weak_count *)*((void *)this + 49);
    if (!v38) {
      goto LABEL_100;
    }
  }
  else
  {
    long long v38 = (std::__shared_weak_count *)*((void *)this + 49);
    if (!v38) {
      goto LABEL_100;
    }
  }
  if (!atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
    std::__shared_weak_count::__release_weak(v38);
  }
LABEL_100:
  float v39 = (std::__shared_weak_count *)*((void *)this + 47);
  if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
    std::__shared_weak_count::__release_weak(v39);
    float v40 = (std::__shared_weak_count *)*((void *)this + 45);
    if (!v40) {
      goto LABEL_106;
    }
  }
  else
  {
    float v40 = (std::__shared_weak_count *)*((void *)this + 45);
    if (!v40) {
      goto LABEL_106;
    }
  }
  if (!atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
  }
LABEL_106:
  float v41 = (std::__shared_weak_count *)*((void *)this + 43);
  if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
    std::__shared_weak_count::__release_weak(v41);
  }
  BOOL v42 = *((void *)this + 41);
  *((void *)this + 41) = 0;
  if (v42) {
    (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
  }
  float v43 = (std::__shared_weak_count *)*((void *)this + 40);
  if (v43 && !atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
    std::__shared_weak_count::__release_weak(v43);
    float v44 = (std::__shared_weak_count *)*((void *)this + 38);
    if (!v44) {
      goto LABEL_117;
    }
  }
  else
  {
    float v44 = (std::__shared_weak_count *)*((void *)this + 38);
    if (!v44) {
      goto LABEL_117;
    }
  }
  if (!atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
    std::__shared_weak_count::__release_weak(v44);
  }
LABEL_117:
  int v45 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
    std::__shared_weak_count::__release_weak(v45);
  }
  uint64_t v46 = *((void *)this + 34);
  *((void *)this + 34) = 0;
  if (v46) {
    (*(void (**)(uint64_t))(*(void *)v46 + 8))(v46);
  }
  int v47 = (std::__shared_weak_count *)*((void *)this + 33);
  if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
    std::__shared_weak_count::__release_weak(v47);
    int v48 = (std::__shared_weak_count *)*((void *)this + 31);
    if (!v48) {
      goto LABEL_128;
    }
  }
  else
  {
    int v48 = (std::__shared_weak_count *)*((void *)this + 31);
    if (!v48) {
      goto LABEL_128;
    }
  }
  if (!atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
    std::__shared_weak_count::__release_weak(v48);
  }
LABEL_128:
  int v49 = (std::__shared_weak_count *)*((void *)this + 29);
  if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
    std::__shared_weak_count::__release_weak(v49);
  }
  uint64_t v50 = *((void *)this + 27);
  *((void *)this + 27) = 0;
  if (v50) {
    (*(void (**)(uint64_t))(*(void *)v50 + 8))(v50);
  }
  uint64_t v51 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
    std::__shared_weak_count::__release_weak(v51);
    int v52 = (std::__shared_weak_count *)*((void *)this + 24);
    if (!v52) {
      goto LABEL_139;
    }
  }
  else
  {
    int v52 = (std::__shared_weak_count *)*((void *)this + 24);
    if (!v52) {
      goto LABEL_139;
    }
  }
  if (!atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
    std::__shared_weak_count::__release_weak(v52);
  }
LABEL_139:
  BOOL v53 = (std::__shared_weak_count *)*((void *)this + 22);
  if (v53 && !atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
    float64x2_t v54 = (std::__shared_weak_count *)*((void *)this + 20);
    if (!v54) {
      goto LABEL_145;
    }
  }
  else
  {
    float64x2_t v54 = (std::__shared_weak_count *)*((void *)this + 20);
    if (!v54) {
      goto LABEL_145;
    }
  }
  if (!atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
    std::__shared_weak_count::__release_weak(v54);
  }
LABEL_145:
  long long v55 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v55 && !atomic_fetch_add(&v55->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
    std::__shared_weak_count::__release_weak(v55);
    uint64_t v56 = (std::__shared_weak_count *)*((void *)this + 16);
    if (!v56) {
      goto LABEL_151;
    }
  }
  else
  {
    uint64_t v56 = (std::__shared_weak_count *)*((void *)this + 16);
    if (!v56) {
      goto LABEL_151;
    }
  }
  if (!atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
    std::__shared_weak_count::__release_weak(v56);
  }
LABEL_151:
  long long v57 = (std::__shared_weak_count *)*((void *)this + 14);
  if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
    std::__shared_weak_count::__release_weak(v57);
    long long v58 = (std::__shared_weak_count *)*((void *)this + 12);
    if (!v58) {
      goto LABEL_157;
    }
  }
  else
  {
    long long v58 = (std::__shared_weak_count *)*((void *)this + 12);
    if (!v58) {
      goto LABEL_157;
    }
  }
  if (!atomic_fetch_add(&v58->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
    std::__shared_weak_count::__release_weak(v58);
  }
LABEL_157:
  long long v59 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v59 && !atomic_fetch_add(&v59->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
    std::__shared_weak_count::__release_weak(v59);
  }
  *(void *)this = &unk_1EF530C60;
  long long v60 = (void *)*((void *)this + 1);
  if (v60)
  {
    *((void *)this + 2) = v60;
    operator delete(v60);
  }
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOUpsamplePipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOUpsamplePipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587F00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOUpsamplePipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587F00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOUpsamplePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOUpsamplePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587F38;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOUpsamplePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587F38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::PostchainCommon::SsaoUpsampleParam>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::PostchainCommon::SsaoUpsampleParam>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PostchainCommon::SsaoUpsampleParam>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PostchainCommon::SsaoUpsampleParam>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586418;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PostchainCommon::SsaoUpsampleParam>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586418;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOBlurPipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOBlurPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587D40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOBlurPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587D40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOBlurPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOBlurPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587D78;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOBlurPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587D78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::PostchainCommon::SsaoBlurParam>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::PostchainCommon::SsaoBlurParam>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PostchainCommon::SsaoBlurParam>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PostchainCommon::SsaoBlurParam>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5863A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PostchainCommon::SsaoBlurParam>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5863A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::DownsampleDepthPipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::DownsampleDepthPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587FE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::DownsampleDepthPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587FE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::DownsampleDepthPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::DownsampleDepthPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588018;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::DownsampleDepthPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588018;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOPipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587BF0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587BF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587C28;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::SSAOPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587C28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::PostchainCommon::SSAOConstants>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::PostchainCommon::SSAOConstants>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PostchainCommon::SSAOConstants>,geo::StdAllocator<ggl::ConstantDataTyped<ggl::PostchainCommon::SSAOConstants>,ggl::Allocator>>::__on_zero_shared_weak(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a1, 240);
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PostchainCommon::SSAOConstants>,geo::StdAllocator<ggl::ConstantDataTyped<ggl::PostchainCommon::SSAOConstants>,ggl::Allocator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PostchainCommon::SSAOConstants>,geo::StdAllocator<ggl::ConstantDataTyped<ggl::PostchainCommon::SSAOConstants>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586370;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PostchainCommon::SSAOConstants>,geo::StdAllocator<ggl::ConstantDataTyped<ggl::PostchainCommon::SSAOConstants>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586370;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::TentBlurPipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::TentBlurPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587DB0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::TentBlurPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587DB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::TentBlurPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::TentBlurPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587DE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::TentBlurPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587DE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::BGBlurPipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::BGBlurPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587C60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::BGBlurPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587C60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::FGBlurPipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::FGBlurPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587CD0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::FGBlurPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587CD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::BGBlurPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::BGBlurPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587C98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::BGBlurPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587C98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::FGBlurPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::FGBlurPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587D08;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::FGBlurPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587D08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::DownsampleCoCPipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::DownsampleCoCPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587F70;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::DownsampleCoCPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587F70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::DownsampleCoCPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::DownsampleCoCPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587FA8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::DownsampleCoCPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587FA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::DepthSplitPipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::DepthSplitPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587E90;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::DepthSplitPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587E90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::DepthSplitPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::DepthSplitPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587EC8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::DepthSplitPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587EC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::CompositePipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::CompositePipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587E20;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::CompositePipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587E20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::StandardPostchain::CompositePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::CompositePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587E58;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::StandardPostchain::CompositePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587E58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::PostchainCommon::CameraProperties>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::PostchainCommon::CameraProperties>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PostchainCommon::CameraProperties>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PostchainCommon::CameraProperties>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5863E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::PostchainCommon::CameraProperties>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5863E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::Glow::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::Glow::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::Glow::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Glow::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::Glow::DefaultVbo>,ggl::Allocator>>::__on_zero_shared_weak(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a1, 256);
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Glow::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::Glow::DefaultVbo>,ggl::Allocator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Glow::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::Glow::DefaultVbo>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584D90;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Glow::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::Glow::DefaultVbo>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584D90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'ggl::Glow::MeshMesh::~MeshMesh(ggl::Glow::MeshMesh *this)
{
  ggl::Mesh::~Mesh((ggl::Glow::MeshMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Glow::MeshMesh *)((char *)this - 16));
}

void ggl::Glow::MeshMesh::~MeshMesh(ggl::Glow::MeshMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::Glow::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::Glow::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::Glow::MeshPipelineState::~MeshPipelineState(ggl::Glow::MeshPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::Glow::MeshPipelineSetup::textureIsEnabled(ggl::Glow::MeshPipelineSetup *this)
{
  return 0;
}

BOOL ggl::Glow::MeshPipelineSetup::constantDataIsEnabled(ggl::Glow::MeshPipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::Glow::MeshPipelineSetup::~MeshPipelineSetup(ggl::Glow::MeshPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t md::OverlayLineLabelFeature::debugString@<X0>(md::LineLabelFeature *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, unsigned int a4@<W3>, unsigned char *a5@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v28);
  long double v10 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    long double v10 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v22) {
      operator new();
    }
  }
  uint64_t v25 = *((void *)v10 + 91);
  HIBYTE(v24) = 11;
  strcpy((char *)v23, "OverlayLine");
  md::LineLabelFeature::debugRoadString(__p, a1, a2, a3, a4, (uint64_t)v23);
  if ((v27 & 0x80u) == 0) {
    double v11 = __p;
  }
  else {
    double v11 = (void **)__p[0];
  }
  if ((v27 & 0x80u) == 0) {
    uint64_t v12 = v27;
  }
  else {
    uint64_t v12 = (uint64_t)__p[1];
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v28, (uint64_t)v11, v12);
  if (((char)v27 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v24) & 0x80000000) == 0) {
      goto LABEL_10;
    }
LABEL_14:
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v25 + 40))(v25, v23[0], v24 & 0x7FFFFFFFFFFFFFFFLL);
    char v13 = v35;
    if ((v35 & 0x10) == 0) {
      goto LABEL_11;
    }
LABEL_15:
    unint64_t v15 = v34;
    if (v34 < v31)
    {
      unint64_t v34 = v31;
      unint64_t v15 = v31;
    }
    __double2 v16 = (const void **)&v30;
    goto LABEL_19;
  }
  operator delete(__p[0]);
  if (SHIBYTE(v24) < 0) {
    goto LABEL_14;
  }
LABEL_10:
  char v13 = v35;
  if ((v35 & 0x10) != 0) {
    goto LABEL_15;
  }
LABEL_11:
  if ((v13 & 8) == 0)
  {
    size_t v14 = 0;
    a5[23] = 0;
    goto LABEL_27;
  }
  __double2 v16 = (const void **)v29;
  unint64_t v15 = v29[2];
LABEL_19:
  float64x2_t v17 = *v16;
  size_t v14 = v15 - (void)*v16;
  if (v14 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v14 >= 0x17)
  {
    uint64_t v18 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v18 = v14 | 7;
    }
    uint64_t v19 = v18 + 1;
    unsigned int v20 = operator new(v18 + 1);
    *((void *)a5 + 1) = v14;
    *((void *)a5 + 2) = v19 | 0x8000000000000000;
    *(void *)a5 = v20;
    a5 = v20;
    goto LABEL_26;
  }
  a5[23] = v14;
  if (v14) {
LABEL_26:
  }
    memmove(a5, v17, v14);
LABEL_27:
  a5[v14] = 0;
  v28[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v28 + *(void *)(v28[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v28[1] = MEMORY[0x1E4FBA470] + 16;
  if (v33 < 0) {
    operator delete(v32);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v36);
}

void sub_1A20A21BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(a11) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 & 0x7FFFFFFFFFFFFFFFLL);
  }
  std::ostringstream::~ostringstream((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t md::OverlayLineLabelFeature::labelFeatureType(md::OverlayLineLabelFeature *this)
{
  return 5;
}

uint64_t md::OverlayLineLabelFeature::newRootPart(md::LabelFeature *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *((void *)a1 + 29);
  if (!v5) {
    goto LABEL_12;
  }
  unsigned int v11 = *(_DWORD *)(a3 + 48);
  uint64_t v12 = (void *)((char *)a1 + 232);
  do
  {
    unsigned int v13 = *(_DWORD *)(v5 + 32);
    BOOL v14 = v13 >= v11;
    if (v13 >= v11) {
      unint64_t v15 = (uint64_t *)v5;
    }
    else {
      unint64_t v15 = (uint64_t *)(v5 + 8);
    }
    if (v14) {
      uint64_t v12 = (void *)v5;
    }
    uint64_t v5 = *v15;
  }
  while (*v15);
  if (v12 == (void *)((char *)a1 + 232) || v11 < *((_DWORD *)v12 + 8))
  {
LABEL_12:
    uint64_t v16 = 0;
    uint64_t v54 = 0;
    long long v55 = 0;
    return v16;
  }
  uint64_t v18 = v12[5];
  uint64_t v19 = (std::__shared_weak_count *)v12[6];
  uint64_t v54 = v18;
  long long v55 = v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v18 || *(float *)(a4 + 236) == 0.0 || *((void *)a1 + 48) == *((void *)a1 + 49))
  {
    uint64_t v16 = 0;
    if (!v19) {
      return v16;
    }
    goto LABEL_70;
  }
  unsigned int v20 = *(unsigned __int8 *)(a3 + 404);
  int v21 = *((unsigned __int8 *)a1 + 434);
  uint64_t v22 = *(void *)(a4 + 280);
  if (v22)
  {
    if (vabds_f32(*(float *)(v22 + 8), *(float *)(a4 + 104)) >= 0.01)
    {
      md::LabelStyle::updateStyleGroup<md::LabelTextStyleGroup>((unsigned __int8 *)a4, v22, 0);
      uint64_t v22 = *(void *)(a4 + 280);
    }
  }
  else
  {
    uint64_t v22 = md::LabelStyle::prepareStyleGroup<md::LabelTextStyleGroup>(a4, 0);
    *(void *)(a4 + 280) = v22;
  }
  uint64_t v23 = *(void *)v22;
  unint64_t v24 = (*(uint64_t (**)(md::LabelFeature *))(*(void *)a1 + 488))(a1);
  uint64_t v25 = (unsigned __int8 *)*((void *)a1 + 20);
  float64x2_t v26 = (unsigned __int8 *)*((void *)a1 + 21);
  if (v24 > 0x6DB6DB6DB6DB6DB7 * ((v26 - v25) >> 3))
  {
    md::LabelFeature::updateTextVector(a1);
    uint64_t v25 = (unsigned __int8 *)*((void *)a1 + 20);
    float64x2_t v26 = (unsigned __int8 *)*((void *)a1 + 21);
  }
  md::TextDataStore::textDataForZoom(&v52, v25, v26, v21, v23 + 72);
  uint64_t v27 = v52;
  if (v52)
  {
    char v28 = (std::__shared_weak_count *)operator new(0xB0uLL);
    v28->__shared_owners_ = 0;
    v28->__shared_weak_owners_ = 0;
    v28->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582A90;
    uint64_t v29 = md::LabelText::LabelText((uint64_t)&v28[1], v27, (uint64_t)v53, v20);
    uint64_t v50 = v29;
    uint64_t v51 = v28;
    uint64_t v30 = *((void *)a1 + 24);
    if (v20 >= 0x17) {
      uint64_t v31 = 23;
    }
    else {
      uint64_t v31 = v20;
    }
    int v32 = atomic_load((unsigned __int8 *)(v30 + 224 + v31));
    if (v32 == 254)
    {
      if (*(unsigned char *)(v30 + 289)) {
        unsigned int v33 = 24;
      }
      else {
        unsigned int v33 = 5;
      }
      unint64_t v34 = *(unsigned __int8 **)(v30 + 128);
      uint64_t v35 = *(void *)(v30 + 136) - (void)v34;
      if (v35)
      {
        uint64_t v36 = 0;
        unint64_t v37 = v35 / 112;
        if (v37 <= 1) {
          uint64_t v38 = 1;
        }
        else {
          uint64_t v38 = v37;
        }
        int v32 = -1;
        float v39 = 1000.0;
        while (1)
        {
          int v40 = *v34;
          v34 += 112;
          int v41 = v31 - v40;
          if (v31 == v40) {
            break;
          }
          if (v41 >= 0) {
            uint64_t v29 = v41;
          }
          else {
            uint64_t v29 = -v41;
          }
          if (v29 <= v33)
          {
            float v42 = (float)v41;
            if (v41 < 0) {
              float v42 = (float)v41 * -0.8;
            }
            if (v42 < v39) {
              int v32 = v36;
            }
            float v39 = fminf(v42, v39);
          }
          if (v38 == ++v36) {
            goto LABEL_55;
          }
        }
        int v32 = v36;
      }
      else
      {
        int v32 = -1;
      }
LABEL_55:
      atomic_store(v32, (unsigned __int8 *)(v30 + 224 + v31));
    }
    else
    {
      int v32 = (char)v32;
    }
    if (v32 < 0 || ((uint64_t v43 = *(void *)(v30 + 128), v50) ? (v44 = v43 == 0) : (v44 = 1), v44))
    {
      uint64_t v16 = 0;
    }
    else
    {
      *(_WORD *)(a5 + 4) = 359;
      uint64_t v45 = mdm::Allocator::instance((mdm::Allocator *)v29);
      uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v45 + 16))(v45, 1488, 8);
      int v46 = (*(uint64_t (**)(md::LabelFeature *))(*(void *)a1 + 264))(a1);
      md::CurvedTextLabelPart::CurvedTextLabelPart(v16, v46, &v50, a2, a3, a4, &v54, (uint64_t)&v49, 0.0, (unsigned char *)a5, 0);
    }
    int v47 = v51;
    if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  int v48 = v53;
  if (v53 && !atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
    std::__shared_weak_count::__release_weak(v48);
  }
  uint64_t v19 = v55;
  if (v55)
  {
LABEL_70:
    if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  return v16;
}

void sub_1A20A26E4(mdm::Allocator *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v5 = mdm::Allocator::instance(a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 40))(v5, v3, 1488);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  _Unwind_Resume((_Unwind_Exception *)a1);
}

void md::OverlayLineLabelFeature::~OverlayLineLabelFeature(md::OverlayLineLabelFeature *this)
{
  md::LineLabelFeature::~LineLabelFeature(this);
  JUMPOUT(0x1A6239270);
}

void altitude::TileView::~TileView(altitude::TileView *this)
{
}

uint64_t altitude::TileView::isCulled(altitude::TileView *this, unsigned int a2)
{
  if (*((_DWORD *)this + 9) >= a2)
  {
    LOBYTE(v8) = *((unsigned char *)this + 32) != 0;
  }
  else
  {
    uint64_t v4 = (const double *)*((void *)this + 2);
    uint64_t v5 = (double *)(*(uint64_t (**)(void))(**((void **)this + 1) + 24))(*((void *)this + 1));
    uint64_t v6 = (double *)(*(uint64_t (**)(void))(**((void **)this + 1) + 56))(*((void *)this + 1));
    uint64_t v7 = 0;
    int v8 = 0;
    double v9 = v5[4];
    double v10 = v5[5];
    double v11 = v5[6];
    double v13 = v5[2];
    double v12 = v5[3];
    double v15 = *v5;
    double v14 = v5[1];
    double v17 = *v6;
    double v16 = v6[1];
    double v18 = v6[2];
    double v19 = -(*v5 * v10 - v13 * v12);
    double v20 = -(v14 * v12 - *v5 * v9);
    double v21 = v19 + v19;
    double v22 = v19 * -2.0;
    double v23 = v20 * -2.0;
    double v24 = v20 + v20;
    do
    {
      double v25 = v4[v7 + 65];
      double v27 = v4[v7 + 63];
      double v26 = v4[v7 + 64];
      double v28 = -(v25 * v9 - v26 * v10) - (v25 * v9 - v26 * v10);
      double v29 = -(v27 * v10 - v25 * v12) - (v27 * v10 - v25 * v12);
      double v30 = -(v26 * v12 - v27 * v9) - (v26 * v12 - v27 * v9);
      double v31 = v27 + v28 * v11 + v29 * v10 - v30 * v9;
      double v32 = v26 - v28 * v10 + v29 * v11 + v30 * v12;
      double v33 = v25 + v28 * v9 + v30 * v11 - v29 * v12;
      if (v31 >= 0.0) {
        double v34 = v6[3];
      }
      else {
        double v34 = *v6;
      }
      if (v32 >= 0.0) {
        double v35 = v6[4];
      }
      else {
        double v35 = v6[1];
      }
      if (v33 >= 0.0) {
        double v36 = v6[5];
      }
      else {
        double v36 = v6[2];
      }
      double v37 = -(v35 * v10 - v36 * v9) - (v35 * v10 - v36 * v9);
      double v38 = -(v36 * v12 - v34 * v10) - (v36 * v12 - v34 * v10);
      double v39 = -(v34 * v9 - v35 * v12) - (v34 * v9 - v35 * v12);
      double v40 = v35 + v14 + v37 * v10 + v38 * v11 - v39 * v12;
      double v41 = v4[v7 + 66];
      if (v41
         + (v34 + v15 + v37 * v11 + v39 * v9 - v38 * v10) * v27
         + v40 * v26
         + (v36 + v13 + v38 * v12 + v39 * v11 - v37 * v9) * v25 < 0.0)
        goto LABEL_52;
      if (v31 <= 0.0) {
        double v42 = v6[3];
      }
      else {
        double v42 = *v6;
      }
      if (v32 <= 0.0) {
        double v43 = v6[4];
      }
      else {
        double v43 = v6[1];
      }
      if (v33 <= 0.0) {
        double v44 = v6[5];
      }
      else {
        double v44 = v6[2];
      }
      double v45 = -(v43 * v10 - v44 * v9) - (v43 * v10 - v44 * v9);
      double v46 = -(v44 * v12 - v42 * v10) - (v44 * v12 - v42 * v10);
      double v47 = -(v42 * v9 - v43 * v12) - (v42 * v9 - v43 * v12);
      if (v41
         + (v42 + v15 + v47 * v9 + v45 * v11 - v46 * v10) * v27
         + (v43 + v14 - v47 * v12 + v45 * v10 + v46 * v11) * v26
         + (v44 + v13 + v47 * v11 + v46 * v12 - v45 * v9) * v25 < 0.0)
        ++v8;
      v7 += 4;
    }
    while (v7 != 24);
    if (!v8) {
      goto LABEL_53;
    }
    double v107 = -(v13 * v9 - v14 * v10) - (v13 * v9 - v14 * v10);
    uint64_t v98 = *(void *)&v23;
    *(double *)&uint64_t v112 = v21;
    int v48 = v4 + 99;
    char v49 = v4 + 87;
    float64x2x3_t v116 = vld3q_f64(v49);
    v49 += 6;
    float64x2x3_t v114 = vld3q_f64(v49);
    uint64_t v50 = v4 + 105;
    float64x2_t v51 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v15 + v17), 0);
    float64x2_t v52 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v24, 0);
    float64x2_t v53 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(-(v13 * v9 - v14 * v10) * -2.0), 0);
    float64x2_t v54 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v22, 0);
    float64x2_t v55 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v116.val[2], v9)), v116.val[1], v10);
    float64x2_t v56 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v116.val[0], v10)), v116.val[2], v12);
    float64x2_t v57 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v116.val[1], v12)), v116.val[0], v9);
    float64x2_t v106 = vaddq_f64(v56, v56);
    float64x2_t v100 = vaddq_f64(v55, v55);
    double v101 = v24;
    float64x2_t v103 = vaddq_f64(v57, v57);
    float64x2_t v97 = vaddq_f64(v100, v53);
    int8x16_t v58 = (int8x16_t)vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vsubq_f64(v116.val[0], v51), v97, v11), vaddq_f64(v106, v54), v10), vsubq_f64(v52, v103), v9);
    float64x2_t v59 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v114.val[2], v9)), v114.val[1], v10);
    float64x2_t v60 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v114.val[0], v10)), v114.val[2], v12);
    float64x2_t v61 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v114.val[1], v12)), v114.val[0], v9);
    float64x2_t v105 = vaddq_f64(v60, v60);
    float64x2_t v99 = vaddq_f64(v59, v59);
    float64x2_t v109 = vaddq_f64(v61, v61);
    float64x2_t v110 = v114.val[1];
    float64x2_t v111 = v114.val[2];
    float64x2_t v96 = vaddq_f64(v99, v53);
    float64x2_t v62 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vsubq_f64(v114.val[0], v51), v96, v11), vaddq_f64(v105, v54), v10), vsubq_f64(v52, v109), v9);
    float64x2x3_t v113 = vld3q_f64(v48);
    float64x2_t v63 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v113.val[2], v9)), v113.val[1], v10);
    v114.val[1] = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v113.val[0], v10)), v113.val[2], v12);
    v114.val[2] = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v113.val[1], v12)), v113.val[0], v9);
    float64x2_t v104 = vaddq_f64(v114.val[1], v114.val[1]);
    float64x2_t v64 = vaddq_f64(v63, v63);
    float64x2_t v108 = vaddq_f64(v114.val[2], v114.val[2]);
    float64x2_t v95 = vaddq_f64(v64, v53);
    float64x2x3_t v115 = vld3q_f64(v50);
    float64x2_t v65 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vsubq_f64(v113.val[0], v51), v95, v11), vaddq_f64(v104, v54), v10), vsubq_f64(v52, v108), v9);
    float64x2_t v66 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v115.val[2], v9)), v115.val[1], v10);
    float64x2_t v67 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v115.val[0], v10)), v115.val[2], v12);
    float64x2_t v68 = vaddq_f64(v66, v66);
    float64x2_t v102 = vaddq_f64(v67, v67);
    float64x2_t v69 = vaddq_f64(v68, v53);
    float64x2_t v70 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v115.val[1], v12)), v115.val[0], v9);
    float64x2_t v71 = vaddq_f64(v70, v70);
    float64x2_t v72 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vsubq_f64(v115.val[0], v51), v69, v11), vaddq_f64(v102, v54), v10), vsubq_f64(v52, v71), v9);
    double v73 = fmax(v6[3] - v17, 0.0);
    if (*(double *)v58.i64 >= v73
      && *(double *)&v58.i64[1] >= v73
      && v62.f64[0] >= v73
      && v62.f64[1] >= v73
      && v65.f64[0] >= v73
      && v65.f64[1] >= v73
      && v72.f64[0] >= v73
      && v72.f64[1] >= v73)
    {
      goto LABEL_52;
    }
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vorrq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vcgtzq_f64((float64x2_t)vextq_s8(v58, v58, 8uLL)), (int32x4_t)vcgtzq_f64(v62)), (int8x16_t)vuzp1q_s32((int32x4_t)vcgtzq_f64(v65), (int32x4_t)vcgtzq_f64(v72))))) & 1) == 0)goto LABEL_52; {
    float64x2_t v74 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v101 * v12 + *(double *)&v112 * v11), 0);
    }
    float64x2_t v75 = vmlaq_n_f64(v74, v100, v10);
    float64x2_t v76 = vmlaq_n_f64(v74, v99, v10);
    float64x2_t v77 = vmlaq_n_f64(v74, v64, v10);
    float64x2_t v78 = vmlaq_n_f64(v74, v68, v10);
    float64x2_t v79 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v14 + v16), 0);
    float64x2_t v80 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v107 * v10), 0);
    int8x16_t v81 = (int8x16_t)vsubq_f64(vmlaq_n_f64(vmlaq_n_f64(vsubq_f64(vaddq_f64(v80, v116.val[1]), v79), v106, v11), v103, v12), v75);
    float64x2_t v82 = vsubq_f64(vmlaq_n_f64(vmlaq_n_f64(vsubq_f64(vaddq_f64(v80, v110), v79), v105, v11), v109, v12), v76);
    float64x2_t v83 = vsubq_f64(vmlaq_n_f64(vmlaq_n_f64(vsubq_f64(vaddq_f64(v80, v113.val[1]), v79), v104, v11), v108, v12), v77);
    float64x2_t v84 = vsubq_f64(vmlaq_n_f64(vmlaq_n_f64(vsubq_f64(vaddq_f64(v80, v115.val[1]), v79), v102, v11), v71, v12), v78);
    double v85 = fmax(v6[4] - v16, 0.0);
    if (*(double *)v81.i64 >= v85
      && *(double *)&v81.i64[1] >= v85
      && v82.f64[0] >= v85
      && v82.f64[1] >= v85
      && v83.f64[0] >= v85
      && v83.f64[1] >= v85
      && v84.f64[0] >= v85
      && v84.f64[1] >= v85)
    {
      goto LABEL_52;
    }
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vorrq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vcgtzq_f64((float64x2_t)vextq_s8(v81, v81, 8uLL)), (int32x4_t)vcgtzq_f64(v82)), (int8x16_t)vuzp1q_s32((int32x4_t)vcgtzq_f64(v83), (int32x4_t)vcgtzq_f64(v84))))) & 1) == 0)goto LABEL_52; {
    float64x2_t v86 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v13 + v18), 0);
    }
    float64x2_t v87 = (float64x2_t)vdupq_lane_s64(v112, 0);
    float64x2_t v88 = (float64x2_t)vdupq_lane_s64(v98, 0);
    int8x16_t v89 = (int8x16_t)vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vsubq_f64(v116.val[2], v86), v97, v9), vaddq_f64(v103, v88), v11), vsubq_f64(v87, v106), v12);
    float64x2_t v90 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vsubq_f64(v111, v86), v96, v9), vaddq_f64(v109, v88), v11), vsubq_f64(v87, v105), v12);
    float64x2_t v91 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vsubq_f64(v113.val[2], v86), v95, v9), vaddq_f64(v108, v88), v11), vsubq_f64(v87, v104), v12);
    float64x2_t v92 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vsubq_f64(v115.val[2], v86), v69, v9), vaddq_f64(v71, v88), v11), vsubq_f64(v87, v102), v12);
    double v93 = fmax(v6[5] - v18, 0.0);
    if (*(double *)v89.i64 >= v93
      && *(double *)&v89.i64[1] >= v93
      && v90.f64[0] >= v93
      && v90.f64[1] >= v93
      && v91.f64[0] >= v93
      && v91.f64[1] >= v93
      && v92.f64[0] >= v93
      && v92.f64[1] >= v93)
    {
LABEL_52:
      LOBYTE(v8) = 1;
      goto LABEL_53;
    }
    LOBYTE(v8) = vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vorrq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vcgtzq_f64((float64x2_t)vextq_s8(v89, v89, 8uLL)), (int32x4_t)vcgtzq_f64(v90)), (int8x16_t)vuzp1q_s32((int32x4_t)vcgtzq_f64(v91), (int32x4_t)vcgtzq_f64(v92))))) ^ 1;
LABEL_53:
    *((unsigned char *)this + 32) = v8 & 1;
    *((_DWORD *)this + 9) = a2;
  }
  return v8 & 1;
}

uint64_t non-virtual thunk to'md::StandardLabeler::isTransitNodeAlongSelectedLine(md::StandardLabeler *this)
{
  return 0;
}

uint64_t non-virtual thunk to'md::StandardLabeler::trafficTilePool(md::StandardLabeler *this)
{
  return 0;
}

uint64_t non-virtual thunk to'md::StandardLabeler::externalMeshModerator(md::StandardLabeler *this)
{
  return 0;
}

uint64_t non-virtual thunk to'md::StandardLabeler::externalObjectsModerator(md::StandardLabeler *this)
{
  return 0;
}

uint64_t non-virtual thunk to'md::StandardLabeler::transitSupport(md::StandardLabeler *this)
{
  return 0;
}

uint64_t md::MuninStandardLabeler::layoutLabelsForStaging(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void **)(this + 392);
  *(void *)(this + 400) = v2;
  uint64_t v3 = *(unsigned char **)(this + 416);
  *(void *)(this + 424) = v3;
  if (*(unsigned char *)(this + 441))
  {
    uint64_t v5 = *(uint64_t **)(this + 72);
    for (uint64_t i = *(uint64_t **)(this + 80); v5 != i; this = md::Label::updateStateMachineForStaging(v6, 2, 29))
    {
      uint64_t v6 = *v5;
      v5 += 2;
    }
    return this;
  }
  int v8 = *(md::Label ***)(this + 72);
  uint64_t v7 = *(md::Label ***)(this + 80);
  unint64_t v9 = (char *)v7 - (char *)v8;
  unint64_t v10 = ((char *)v7 - (char *)v8) >> 4;
  if (v10 > (uint64_t)(*(void *)(this + 408) - (void)v2) >> 3)
  {
    if ((v9 & 0x8000000000000000) != 0) {
      goto LABEL_83;
    }
    double v11 = (char *)operator new(v9 >> 1);
    *(void *)(v1 + 392) = v11;
    *(void *)(v1 + 400) = v11;
    *(void *)(v1 + 408) = &v11[8 * v10];
    if (v2)
    {
      operator delete(v2);
      int v8 = *(md::Label ***)(v1 + 72);
      uint64_t v7 = *(md::Label ***)(v1 + 80);
      uint64_t v3 = *(unsigned char **)(v1 + 416);
      unint64_t v9 = (char *)v7 - (char *)v8;
      unint64_t v10 = ((char *)v7 - (char *)v8) >> 4;
    }
  }
  if (v10 > (uint64_t)(*(void *)(v1 + 432) - (void)v3) >> 3)
  {
    if ((v9 & 0x8000000000000000) == 0)
    {
      double v12 = *(unsigned char **)(v1 + 424);
      double v13 = (char *)operator new(v9 >> 1);
      uint64_t v14 = v12 - v3;
      double v15 = &v13[(v12 - v3) & 0xFFFFFFFFFFFFFFF8];
      double v16 = v15;
      if (v12 == v3) {
        goto LABEL_19;
      }
      if ((unint64_t)(v14 - 8) >= 0x58)
      {
        double v16 = &v13[(v12 - v3) & 0xFFFFFFFFFFFFFFF8];
        if ((unint64_t)(&v12[-(v14 & 0xFFFFFFFFFFFFFFF8)] - v13) >= 0x20)
        {
          uint64_t v17 = v14 >> 3;
          unint64_t v18 = ((unint64_t)(v14 - 8) >> 3) + 1;
          double v19 = &v13[8 * v17 - 16];
          double v20 = (long long *)(v12 - 16);
          uint64_t v21 = v18 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v22 = *v20;
            *((_OWORD *)v19 - 1) = *(v20 - 1);
            *(_OWORD *)double v19 = v22;
            v19 -= 32;
            v20 -= 2;
            v21 -= 4;
          }
          while (v21);
          double v16 = &v15[-8 * (v18 & 0x3FFFFFFFFFFFFFFCLL)];
          v12 -= 8 * (v18 & 0x3FFFFFFFFFFFFFFCLL);
          if (v18 == (v18 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_19:
            *(void *)(v1 + 416) = v16;
            *(void *)(v1 + 424) = v15;
            *(void *)(v1 + 432) = &v13[8 * v10];
            if (v3)
            {
              operator delete(v3);
              int v8 = *(md::Label ***)(v1 + 72);
              uint64_t v7 = *(md::Label ***)(v1 + 80);
            }
            goto LABEL_21;
          }
        }
      }
      else
      {
        double v16 = &v13[(v12 - v3) & 0xFFFFFFFFFFFFFFF8];
      }
      do
      {
        uint64_t v23 = *((void *)v12 - 1);
        v12 -= 8;
        *((void *)v16 - 1) = v23;
        v16 -= 8;
      }
      while (v12 != v3);
      goto LABEL_19;
    }
LABEL_83:
    abort();
  }
LABEL_21:
  float64x2_t v69 = (md::Label ***)(v1 + 392);
  __int16 v70 = 257;
  char v71 = 1;
  while (v8 != v7)
  {
    md::Label::layoutForStaging(*v8, *(void *)(v1 + 24), *(md::LabelPool **)(v1 + 48), &v70);
    double v25 = *v8;
    if (!*((unsigned char *)*v8 + 1290)) {
      goto LABEL_24;
    }
    if (*((unsigned char *)v25 + 1211) == 18)
    {
      double v27 = *(md::Label ***)(v1 + 400);
      unint64_t v26 = *(void *)(v1 + 408);
      if ((unint64_t)v27 >= v26)
      {
        double v36 = *v69;
        uint64_t v37 = (char *)v27 - (char *)*v69;
        uint64_t v38 = v37 >> 3;
        unint64_t v39 = (v37 >> 3) + 1;
        if (v39 >> 61) {
          goto LABEL_83;
        }
        uint64_t v40 = v26 - (void)v36;
        if (v40 >> 2 > v39) {
          unint64_t v39 = v40 >> 2;
        }
        if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v41 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v41 = v39;
        }
        if (v41)
        {
          if (v41 >> 61) {
LABEL_84:
          }
            std::__throw_bad_array_new_length[abi:nn180100]();
          double v42 = operator new(8 * v41);
        }
        else
        {
          double v42 = 0;
        }
        float64x2_t v51 = (md::Label **)&v42[8 * v38];
        std::__shared_weak_count *v51 = v25;
        float64x2_t v52 = v51 + 1;
        if (v27 == v36)
        {
          double v36 = v27;
        }
        else
        {
          unint64_t v53 = (char *)(v27 - 1) - (char *)v36;
          if (v53 < 0x58) {
            goto LABEL_87;
          }
          if ((unint64_t)((char *)v27 - &v42[v37]) < 0x20) {
            goto LABEL_87;
          }
          uint64_t v54 = (v53 >> 3) + 1;
          float64x2_t v55 = &v42[8 * v38 - 16];
          float64x2_t v56 = v27 - 2;
          uint64_t v57 = v54 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v58 = *(_OWORD *)v56;
            *(v55 - 1) = *((_OWORD *)v56 - 1);
            _OWORD *v55 = v58;
            v55 -= 2;
            v56 -= 4;
            v57 -= 4;
          }
          while (v57);
          v51 -= v54 & 0x3FFFFFFFFFFFFFFCLL;
          v27 -= v54 & 0x3FFFFFFFFFFFFFFCLL;
          if (v54 != (v54 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_87:
            do
            {
              float64x2_t v59 = *--v27;
              *--float64x2_t v51 = v59;
            }
            while (v27 != v36);
            double v36 = *v69;
          }
        }
        *(void *)(v1 + 392) = v51;
        *(void *)(v1 + 400) = v52;
        *(void *)(v1 + 408) = &v42[8 * v41];
        if (v36) {
          operator delete(v36);
        }
        *(void *)(v1 + 400) = v52;
        v8 += 2;
      }
      else
      {
        char *v27 = v25;
        *(void *)(v1 + 400) = v27 + 1;
        v8 += 2;
      }
    }
    else
    {
      double v29 = *(char **)(v1 + 424);
      unint64_t v28 = *(void *)(v1 + 432);
      if ((unint64_t)v29 < v28)
      {
        *(void *)double v29 = v25;
        double v24 = v29 + 8;
      }
      else
      {
        double v30 = *(char **)(v1 + 416);
        uint64_t v31 = (v29 - v30) >> 3;
        unint64_t v32 = v31 + 1;
        if ((unint64_t)(v31 + 1) >> 61) {
          goto LABEL_83;
        }
        uint64_t v33 = v28 - (void)v30;
        if (v33 >> 2 > v32) {
          unint64_t v32 = v33 >> 2;
        }
        if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v34 = v32;
        }
        if (v34)
        {
          if (v34 >> 61) {
            goto LABEL_84;
          }
          double v35 = operator new(8 * v34);
        }
        else
        {
          double v35 = 0;
        }
        double v43 = (md::Label **)&v35[8 * v31];
        *double v43 = v25;
        double v24 = v43 + 1;
        if (v29 == v30)
        {
          double v30 = v29;
        }
        else
        {
          unint64_t v44 = v29 - 8 - v30;
          if (v44 < 0x58) {
            goto LABEL_88;
          }
          if ((unint64_t)(v30 - v35) < 0x20) {
            goto LABEL_88;
          }
          uint64_t v45 = (v44 >> 3) + 1;
          double v46 = &v35[8 * v31 - 16];
          double v47 = v29 - 16;
          uint64_t v48 = v45 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v49 = *(_OWORD *)v47;
            *(v46 - 1) = *((_OWORD *)v47 - 1);
            _OWORD *v46 = v49;
            v46 -= 2;
            v47 -= 32;
            v48 -= 4;
          }
          while (v48);
          v43 -= v45 & 0x3FFFFFFFFFFFFFFCLL;
          v29 -= 8 * (v45 & 0x3FFFFFFFFFFFFFFCLL);
          if (v45 != (v45 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_88:
            do
            {
              uint64_t v50 = (md::Label *)*((void *)v29 - 1);
              v29 -= 8;
              *--double v43 = v50;
            }
            while (v29 != v30);
            double v30 = *(char **)(v1 + 416);
          }
        }
        *(void *)(v1 + 416) = v43;
        *(void *)(v1 + 424) = v24;
        *(void *)(v1 + 432) = &v35[8 * v34];
        if (v30) {
          operator delete(v30);
        }
      }
      *(void *)(v1 + 424) = v24;
LABEL_24:
      v8 += 2;
    }
  }
  (*(void (**)(uint64_t))(*(void *)v1 + 448))(v1);
  float64x2_t v60 = *(float32x2_t ***)(v1 + 136);
  float64x2_t v61 = *(float32x2_t ***)(v1 + 144);
  while (v60 != v61)
  {
    float64x2_t v62 = *v60++;
    md::LabelCollider::addCollidableItem(*(char **)(v1 + 56), v62);
  }
  *(_DWORD *)(v1 + 380) = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 440))(v1);
  *(void *)(v1 + 384) = 0;
  uint64_t v63 = *(void *)(v1 + 24);
  if (*(unsigned char *)(v63 + 3610))
  {
    md::LabelPool::prepareDedupingGroupsForCollision(*(void **)(v1 + 48), (LabelManager *)v63);
    uint64_t v63 = *(void *)(v1 + 24);
  }
  float64x2_t v64 = (unsigned int *)md::LabelSettingsStyleCache::muninPointStyle(*(md::LabelSettingsStyleCache **)(*(void *)(v63 + 336) + 200));
  float64x2_t v65 = *(uint64_t **)(v1 + 392);
  float64x2_t v66 = *(uint64_t **)(v1 + 400);
  unint64_t v67 = 126 - 2 * __clz(v66 - v65);
  if (v66 == v65) {
    uint64_t v68 = 0;
  }
  else {
    uint64_t v68 = v67;
  }
  std::__introsort<std::_ClassicAlgPolicy,md::MuninPoiLabelSorter &,md::Label **,false>(v65, v66, v68, 1);
  return md::MuninStandardLabeler::placeLabels(v1, v69, *v64);
}

float std::__introsort<std::_ClassicAlgPolicy,md::MuninPoiLabelSorter &,md::Label **,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
uint64_t md::MuninStandardLabeler::placeLabels(uint64_t result, void *a2, unint64_t a3)
{
  __int16 v13 = 0;
  uint64_t v14 = 0;
  uint64_t v4 = a2[1] - *a2;
  unint64_t v5 = v4 >> 3;
  if (!v4)
  {
    unint64_t v8 = 0;
    if (!v5) {
      return result;
    }
    goto LABEL_13;
  }
  uint64_t v7 = result;
  unint64_t v8 = 0;
  uint64_t v9 = 0;
  if (v5 <= 1) {
    uint64_t v10 = 1;
  }
  else {
    uint64_t v10 = v4 >> 3;
  }
  while (1)
  {
    uint64_t v11 = *(void *)(*a2 + 8 * v8);
    if (*(unsigned char *)(v11 + 1290))
    {
      if (*(unsigned char *)(*(void *)(v7 + 24) + 3610))
      {
        uint64_t v12 = *(void *)(v7 + 56);
        double v15 = *(md::LabelCollisionItemBase **)(v11 + 328);
        float result = md::LabelCollider::collideItems(v12, &v15, 1);
      }
      else
      {
        float result = md::Label::setCollisionResult(*(void *)(*a2 + 8 * v8), (uint64_t)&v13);
      }
    }
    if (*(unsigned char *)(v11 + 820) == 2 && ++v9 >= a3) {
      break;
    }
    if (v10 == ++v8) {
      return result;
    }
  }
  if (v8 < v5)
  {
    do
LABEL_13:
      float result = md::Label::updateStateMachineForStaging(*(void *)(*a2 + 8 * v8++), 2, 36);
    while (v5 != v8);
  }
  return result;
}

uint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPoiLabelSorter &,md::Label **>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  unint64_t v5 = (unsigned __int8 *)(*a2 + 1240);
  unsigned __int8 v6 = atomic_load(v5);
  unsigned __int8 v7 = atomic_load((unsigned __int8 *)(v4 + 1240));
  if ((v6 & 1) != (v7 & 1))
  {
    unsigned __int8 v8 = atomic_load(v5);
    if ((v8 & 1) == 0) {
      goto LABEL_3;
    }
LABEL_14:
    uint64_t v19 = *a3;
    uint64_t v20 = *a2;
    unsigned __int8 v21 = (unsigned __int8 *)(*a3 + 1240);
    unsigned __int8 v22 = atomic_load(v21);
    unsigned __int8 v23 = atomic_load((unsigned __int8 *)(v20 + 1240));
    if ((v22 & 1) != (v23 & 1))
    {
      unsigned __int8 v24 = atomic_load(v21);
      if ((v24 & 1) == 0) {
        goto LABEL_16;
      }
LABEL_36:
      a2 = a3;
      goto LABEL_60;
    }
    uint64_t v35 = *(void *)(v19 + 24);
    uint64_t v36 = *(void *)(v20 + 24);
    if (v35)
    {
      if (v35 == v36)
      {
        if (*(_DWORD *)(v19 + 32) < *(_DWORD *)(v20 + 32)) {
          goto LABEL_36;
        }
LABEL_16:
        uint64_t v25 = *result;
        void *result = *a2;
        *a2 = v25;
        uint64_t v26 = *a3;
        uint64_t v27 = (unsigned __int8 *)(*a3 + 1240);
        unsigned __int8 v28 = atomic_load(v27);
        unsigned __int8 v29 = atomic_load((unsigned __int8 *)(v25 + 1240));
        if ((v28 & 1) != (v29 & 1))
        {
          unsigned __int8 v30 = atomic_load(v27);
          float result = a2;
          a2 = a3;
          if ((v30 & 1) == 0) {
            return result;
          }
          goto LABEL_60;
        }
        uint64_t v39 = *(void *)(v26 + 24);
        uint64_t v40 = *(void *)(v25 + 24);
        if (v39)
        {
          if (v39 == v40)
          {
            float result = a2;
            a2 = a3;
            if (*(_DWORD *)(v26 + 32) < *(_DWORD *)(v25 + 32)) {
              goto LABEL_60;
            }
            return result;
          }
          uint64_t v41 = *(void *)(v39 + 72);
          if (v41) {
            uint64_t v26 = v41;
          }
        }
        if (v40)
        {
          uint64_t v42 = *(void *)(v40 + 72);
          if (v42) {
            uint64_t v25 = v42;
          }
        }
        float result = a2;
        a2 = a3;
        if (*(float *)(v26 + 780) < *(float *)(v25 + 780)) {
          goto LABEL_60;
        }
        return result;
      }
      uint64_t v37 = *(void *)(v35 + 72);
      if (v37) {
        uint64_t v19 = v37;
      }
    }
    if (v36)
    {
      uint64_t v38 = *(void *)(v36 + 72);
      if (v38) {
        uint64_t v20 = v38;
      }
    }
    if (*(float *)(v19 + 780) < *(float *)(v20 + 780)) {
      goto LABEL_36;
    }
    goto LABEL_16;
  }
  uint64_t v15 = *(void *)(v3 + 24);
  uint64_t v16 = *(void *)(v4 + 24);
  if (v15)
  {
    if (v15 == v16)
    {
      if (*(_DWORD *)(v3 + 32) < *(_DWORD *)(v4 + 32)) {
        goto LABEL_14;
      }
      goto LABEL_3;
    }
    uint64_t v17 = *(void *)(v15 + 72);
    if (v17) {
      uint64_t v3 = v17;
    }
  }
  if (v16)
  {
    uint64_t v18 = *(void *)(v16 + 72);
    if (v18) {
      uint64_t v4 = v18;
    }
  }
  if (*(float *)(v3 + 780) < *(float *)(v4 + 780)) {
    goto LABEL_14;
  }
LABEL_3:
  uint64_t v9 = *a3;
  uint64_t v10 = *a2;
  uint64_t v11 = (unsigned __int8 *)(*a3 + 1240);
  unsigned __int8 v12 = atomic_load(v11);
  unsigned __int8 v13 = atomic_load((unsigned __int8 *)(v10 + 1240));
  if ((v12 & 1) == (v13 & 1))
  {
    uint64_t v31 = *(void *)(v9 + 24);
    uint64_t v32 = *(void *)(v10 + 24);
    if (v31)
    {
      if (v31 == v32)
      {
        if (*(_DWORD *)(v9 + 32) >= *(_DWORD *)(v10 + 32)) {
          return result;
        }
        goto LABEL_49;
      }
      uint64_t v33 = *(void *)(v31 + 72);
      if (v33) {
        uint64_t v9 = v33;
      }
    }
    if (v32)
    {
      uint64_t v34 = *(void *)(v32 + 72);
      if (v34) {
        uint64_t v10 = v34;
      }
    }
    if (*(float *)(v9 + 780) >= *(float *)(v10 + 780)) {
      return result;
    }
    goto LABEL_49;
  }
  unsigned __int8 v14 = atomic_load(v11);
  if ((v14 & 1) == 0) {
    return result;
  }
LABEL_49:
  uint64_t v43 = *a2;
  *a2 = *a3;
  *a3 = v43;
  uint64_t v44 = *a2;
  uint64_t v45 = *result;
  uint64_t v46 = (unsigned __int8 *)(*a2 + 1240);
  unsigned __int8 v47 = atomic_load(v46);
  unsigned __int8 v48 = atomic_load((unsigned __int8 *)(v45 + 1240));
  if ((v47 & 1) != (v48 & 1))
  {
    unsigned __int8 v49 = atomic_load(v46);
    if ((v49 & 1) == 0) {
      return result;
    }
LABEL_60:
    uint64_t v54 = *result;
    void *result = *a2;
    *a2 = v54;
    return result;
  }
  uint64_t v50 = *(void *)(v44 + 24);
  uint64_t v51 = *(void *)(v45 + 24);
  if (!v50) {
    goto LABEL_56;
  }
  if (v50 != v51)
  {
    uint64_t v52 = *(void *)(v50 + 72);
    if (v52) {
      uint64_t v44 = v52;
    }
LABEL_56:
    if (v51)
    {
      uint64_t v53 = *(void *)(v51 + 72);
      if (v53) {
        uint64_t v45 = v53;
      }
    }
    if (*(float *)(v44 + 780) < *(float *)(v45 + 780)) {
      goto LABEL_60;
    }
    return result;
  }
  if (*(_DWORD *)(v44 + 32) < *(_DWORD *)(v45 + 32)) {
    goto LABEL_60;
  }
  return result;
}

float std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPoiLabelSorter &,md::Label **>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPoiLabelSorter &,md::Label **>(a1, a2, a3);
  uint64_t v9 = *a4;
  uint64_t v10 = *a3;
  uint64_t v11 = (unsigned __int8 *)(*a4 + 1240);
  unsigned __int8 v12 = atomic_load(v11);
  unsigned __int8 v13 = atomic_load((unsigned __int8 *)(v10 + 1240));
  if ((v12 & 1) == (v13 & 1))
  {
    uint64_t v15 = *(void *)(v9 + 24);
    uint64_t v16 = *(void *)(v10 + 24);
    if (v15)
    {
      if (v15 == v16)
      {
        if (*(_DWORD *)(v9 + 32) >= *(_DWORD *)(v10 + 32)) {
          return result;
        }
        goto LABEL_14;
      }
      uint64_t v17 = *(void *)(v15 + 72);
      if (v17) {
        uint64_t v9 = v17;
      }
    }
    if (v16)
    {
      uint64_t v18 = *(void *)(v16 + 72);
      if (v18) {
        uint64_t v10 = v18;
      }
    }
    float result = *(float *)(v9 + 780);
    if (result >= *(float *)(v10 + 780)) {
      return result;
    }
    goto LABEL_14;
  }
  unsigned __int8 v14 = atomic_load(v11);
  if ((v14 & 1) == 0) {
    return result;
  }
LABEL_14:
  uint64_t v19 = *a3;
  *a3 = *a4;
  *a4 = v19;
  uint64_t v20 = *a3;
  uint64_t v21 = *a2;
  unsigned __int8 v22 = (unsigned __int8 *)(*a3 + 1240);
  unsigned __int8 v23 = atomic_load(v22);
  unsigned __int8 v24 = atomic_load((unsigned __int8 *)(v21 + 1240));
  if ((v23 & 1) != (v24 & 1))
  {
    unsigned __int8 v25 = atomic_load(v22);
    if ((v25 & 1) == 0) {
      return result;
    }
    goto LABEL_27;
  }
  uint64_t v26 = *(void *)(v20 + 24);
  uint64_t v27 = *(void *)(v21 + 24);
  if (v26)
  {
    if (v26 == v27)
    {
      if (*(_DWORD *)(v20 + 32) >= *(_DWORD *)(v21 + 32)) {
        return result;
      }
LABEL_27:
      uint64_t v30 = *a2;
      *a2 = *a3;
      *a3 = v30;
      uint64_t v31 = *a2;
      uint64_t v32 = *a1;
      uint64_t v33 = (unsigned __int8 *)(*a2 + 1240);
      unsigned __int8 v34 = atomic_load(v33);
      unsigned __int8 v35 = atomic_load((unsigned __int8 *)(v32 + 1240));
      if ((v34 & 1) != (v35 & 1))
      {
        unsigned __int8 v36 = atomic_load(v33);
        if ((v36 & 1) == 0) {
          return result;
        }
        goto LABEL_29;
      }
      uint64_t v38 = *(void *)(v31 + 24);
      uint64_t v39 = *(void *)(v32 + 24);
      if (v38)
      {
        if (v38 == v39)
        {
          if (*(_DWORD *)(v31 + 32) >= *(_DWORD *)(v32 + 32)) {
            return result;
          }
          goto LABEL_29;
        }
        uint64_t v40 = *(void *)(v38 + 72);
        if (v40) {
          uint64_t v31 = v40;
        }
      }
      if (v39)
      {
        uint64_t v41 = *(void *)(v39 + 72);
        if (v41) {
          uint64_t v32 = v41;
        }
      }
      float result = *(float *)(v31 + 780);
      if (result >= *(float *)(v32 + 780)) {
        return result;
      }
LABEL_29:
      uint64_t v37 = *a1;
      *a1 = *a2;
      *a2 = v37;
      return result;
    }
    uint64_t v28 = *(void *)(v26 + 72);
    if (v28) {
      uint64_t v20 = v28;
    }
  }
  if (v27)
  {
    uint64_t v29 = *(void *)(v27 + 72);
    if (v29) {
      uint64_t v21 = v29;
    }
  }
  float result = *(float *)(v20 + 780);
  if (result < *(float *)(v21 + 780)) {
    goto LABEL_27;
  }
  return result;
}

float std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPoiLabelSorter &,md::Label **>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  float result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPoiLabelSorter &,md::Label **>(a1, a2, a3, a4);
  uint64_t v11 = *a5;
  uint64_t v12 = *a4;
  unsigned __int8 v13 = (unsigned __int8 *)(*a5 + 1240);
  unsigned __int8 v14 = atomic_load(v13);
  unsigned __int8 v15 = atomic_load((unsigned __int8 *)(v12 + 1240));
  if ((v14 & 1) != (v15 & 1))
  {
    unsigned __int8 v16 = atomic_load(v13);
    if ((v16 & 1) == 0) {
      return result;
    }
    goto LABEL_14;
  }
  uint64_t v17 = *(void *)(v11 + 24);
  uint64_t v18 = *(void *)(v12 + 24);
  if (v17)
  {
    if (v17 == v18)
    {
      if (*(_DWORD *)(v11 + 32) >= *(_DWORD *)(v12 + 32)) {
        return result;
      }
      goto LABEL_14;
    }
    uint64_t v19 = *(void *)(v17 + 72);
    if (v19) {
      uint64_t v11 = v19;
    }
  }
  if (v18)
  {
    uint64_t v20 = *(void *)(v18 + 72);
    if (v20) {
      uint64_t v12 = v20;
    }
  }
  float result = *(float *)(v11 + 780);
  if (result >= *(float *)(v12 + 780)) {
    return result;
  }
LABEL_14:
  uint64_t v21 = *a4;
  *a4 = *a5;
  *a5 = v21;
  uint64_t v22 = *a4;
  uint64_t v23 = *a3;
  unsigned __int8 v24 = (unsigned __int8 *)(*a4 + 1240);
  unsigned __int8 v25 = atomic_load(v24);
  unsigned __int8 v26 = atomic_load((unsigned __int8 *)(v23 + 1240));
  if ((v25 & 1) == (v26 & 1))
  {
    uint64_t v28 = *(void *)(v22 + 24);
    uint64_t v29 = *(void *)(v23 + 24);
    if (v28)
    {
      if (v28 == v29)
      {
        if (*(_DWORD *)(v22 + 32) >= *(_DWORD *)(v23 + 32)) {
          return result;
        }
        goto LABEL_27;
      }
      uint64_t v30 = *(void *)(v28 + 72);
      if (v30) {
        uint64_t v22 = v30;
      }
    }
    if (v29)
    {
      uint64_t v31 = *(void *)(v29 + 72);
      if (v31) {
        uint64_t v23 = v31;
      }
    }
    float result = *(float *)(v22 + 780);
    if (result >= *(float *)(v23 + 780)) {
      return result;
    }
    goto LABEL_27;
  }
  unsigned __int8 v27 = atomic_load(v24);
  if ((v27 & 1) == 0) {
    return result;
  }
LABEL_27:
  uint64_t v32 = *a3;
  *a3 = *a4;
  *a4 = v32;
  uint64_t v33 = *a3;
  uint64_t v34 = *a2;
  unsigned __int8 v35 = (unsigned __int8 *)(*a3 + 1240);
  unsigned __int8 v36 = atomic_load(v35);
  unsigned __int8 v37 = atomic_load((unsigned __int8 *)(v34 + 1240));
  if ((v36 & 1) != (v37 & 1))
  {
    unsigned __int8 v38 = atomic_load(v35);
    if ((v38 & 1) == 0) {
      return result;
    }
    goto LABEL_40;
  }
  uint64_t v39 = *(void *)(v33 + 24);
  uint64_t v40 = *(void *)(v34 + 24);
  if (v39)
  {
    if (v39 == v40)
    {
      if (*(_DWORD *)(v33 + 32) >= *(_DWORD *)(v34 + 32)) {
        return result;
      }
LABEL_40:
      uint64_t v43 = *a2;
      *a2 = *a3;
      *a3 = v43;
      uint64_t v44 = *a2;
      uint64_t v45 = *a1;
      uint64_t v46 = (unsigned __int8 *)(*a2 + 1240);
      unsigned __int8 v47 = atomic_load(v46);
      unsigned __int8 v48 = atomic_load((unsigned __int8 *)(v45 + 1240));
      if ((v47 & 1) != (v48 & 1))
      {
        unsigned __int8 v49 = atomic_load(v46);
        if ((v49 & 1) == 0) {
          return result;
        }
        goto LABEL_42;
      }
      uint64_t v51 = *(void *)(v44 + 24);
      uint64_t v52 = *(void *)(v45 + 24);
      if (v51)
      {
        if (v51 == v52)
        {
          if (*(_DWORD *)(v44 + 32) >= *(_DWORD *)(v45 + 32)) {
            return result;
          }
          goto LABEL_42;
        }
        uint64_t v53 = *(void *)(v51 + 72);
        if (v53) {
          uint64_t v44 = v53;
        }
      }
      if (v52)
      {
        uint64_t v54 = *(void *)(v52 + 72);
        if (v54) {
          uint64_t v45 = v54;
        }
      }
      float result = *(float *)(v44 + 780);
      if (result >= *(float *)(v45 + 780)) {
        return result;
      }
LABEL_42:
      uint64_t v50 = *a1;
      *a1 = *a2;
      *a2 = v50;
      return result;
    }
    uint64_t v41 = *(void *)(v39 + 72);
    if (v41) {
      uint64_t v33 = v41;
    }
  }
  if (v40)
  {
    uint64_t v42 = *(void *)(v40 + 72);
    if (v42) {
      uint64_t v34 = v42;
    }
  }
  float result = *(float *)(v33 + 780);
  if (result < *(float *)(v34 + 780)) {
    goto LABEL_40;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPoiLabelSorter &,md::Label **>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      unsigned __int8 v8 = atomic_load((unsigned __int8 *)(v6 + 1240));
      unsigned __int8 v9 = atomic_load((unsigned __int8 *)(v7 + 1240));
      if ((v8 & 1) != (v9 & 1))
      {
        unsigned __int8 v10 = atomic_load((unsigned __int8 *)(v6 + 1240));
        if ((v10 & 1) == 0) {
          return result;
        }
        goto LABEL_54;
      }
      uint64_t v36 = *(void *)(v6 + 24);
      uint64_t v37 = *(void *)(v7 + 24);
      if (v36)
      {
        if (v36 == v37)
        {
          if (*(_DWORD *)(v6 + 32) >= *(_DWORD *)(v7 + 32)) {
            return result;
          }
          goto LABEL_54;
        }
        uint64_t v38 = *(void *)(v36 + 72);
        if (v38) {
          uint64_t v6 = v38;
        }
      }
      if (v37)
      {
        uint64_t v39 = *(void *)(v37 + 72);
        if (v39) {
          uint64_t v7 = v39;
        }
      }
      if (*(float *)(v6 + 780) < *(float *)(v7 + 780))
      {
LABEL_54:
        uint64_t v40 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v40;
        return result;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPoiLabelSorter &,md::Label **>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPoiLabelSorter &,md::Label **>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPoiLabelSorter &,md::Label **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v11 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::MuninPoiLabelSorter &,md::Label **>(a1, a1 + 1, a1 + 2);
      uint64_t v12 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v13 = 0;
      int v14 = 0;
      while (2)
      {
        uint64_t v16 = *v12;
        uint64_t v17 = *v11;
        uint64_t v18 = (unsigned __int8 *)(*v12 + 1240);
        unsigned __int8 v19 = atomic_load(v18);
        unsigned __int8 v20 = atomic_load((unsigned __int8 *)(v17 + 1240));
        if ((v19 & 1) != (v20 & 1))
        {
          unsigned __int8 v21 = atomic_load(v18);
          if ((v21 & 1) == 0) {
            goto LABEL_9;
          }
          goto LABEL_23;
        }
        uint64_t v22 = *(void *)(v16 + 24);
        uint64_t v23 = *(void *)(v17 + 24);
        if (!v22) {
          goto LABEL_17;
        }
        if (v22 == v23)
        {
          if (*(_DWORD *)(v16 + 32) >= *(_DWORD *)(v17 + 32)) {
            goto LABEL_9;
          }
        }
        else
        {
          uint64_t v24 = *(void *)(v22 + 72);
          if (v24) {
            uint64_t v16 = v24;
          }
LABEL_17:
          if (v23)
          {
            uint64_t v25 = *(void *)(v23 + 72);
            if (v25) {
              uint64_t v17 = v25;
            }
          }
          if (*(float *)(v16 + 780) >= *(float *)(v17 + 780)) {
            goto LABEL_9;
          }
        }
LABEL_23:
        uint64_t v26 = *v12;
        *uint64_t v12 = *v11;
        unsigned __int8 v15 = a1;
        if (v11 == a1) {
          goto LABEL_8;
        }
        uint64_t v27 = v13;
        while (2)
        {
          uint64_t v29 = *(uint64_t *)((char *)a1 + v27 + 8);
          unsigned __int8 v30 = atomic_load((unsigned __int8 *)(v26 + 1240));
          unsigned __int8 v31 = atomic_load((unsigned __int8 *)(v29 + 1240));
          if ((v30 & 1) != (v31 & 1))
          {
            unsigned __int8 v28 = atomic_load((unsigned __int8 *)(v26 + 1240));
            if ((v28 & 1) == 0) {
              goto LABEL_38;
            }
            goto LABEL_26;
          }
          uint64_t v32 = *(void *)(v26 + 24);
          uint64_t v33 = *(void *)(v29 + 24);
          uint64_t v34 = v26;
          if (!v32) {
            goto LABEL_32;
          }
          if (v32 != v33)
          {
            uint64_t v34 = *(void *)(v32 + 72);
            if (!v34) {
              uint64_t v34 = v26;
            }
LABEL_32:
            if (v33)
            {
              uint64_t v35 = *(void *)(v33 + 72);
              if (v35) {
                uint64_t v29 = v35;
              }
            }
            if (*(float *)(v34 + 780) >= *(float *)(v29 + 780))
            {
              unsigned __int8 v15 = (uint64_t *)((char *)a1 + v27 + 16);
              goto LABEL_8;
            }
LABEL_26:
            --v11;
            *(uint64_t *)((char *)a1 + v27 + 16) = *(uint64_t *)((char *)a1 + v27 + 8);
            v27 -= 8;
            if (v27 == -16)
            {
              unsigned __int8 v15 = a1;
              goto LABEL_8;
            }
            continue;
          }
          break;
        }
        if (*(_DWORD *)(v26 + 32) < *(_DWORD *)(v29 + 32)) {
          goto LABEL_26;
        }
LABEL_38:
        unsigned __int8 v15 = v11;
LABEL_8:
        uint64_t *v15 = v26;
        if (++v14 == 8) {
          return v12 + 1 == a2;
        }
LABEL_9:
        uint64_t v11 = v12;
        v13 += 8;
        if (++v12 != a2) {
          continue;
        }
        return 1;
      }
  }
}

uint64_t md::StandardLabeler::addLinesToCollider(md::StandardLabeler *this)
{
  return 0;
}

uint64_t md::StandardLabeler::isTransitNodeAlongSelectedLine(md::StandardLabeler *this)
{
  return 0;
}

uint64_t md::StandardLabeler::trafficTilePool(md::StandardLabeler *this)
{
  return 0;
}

uint64_t md::StandardLabeler::externalMeshModerator(md::StandardLabeler *this)
{
  return 0;
}

uint64_t md::StandardLabeler::externalObjectsModerator(md::StandardLabeler *this)
{
  return 0;
}

uint64_t md::StandardLabeler::transitSupport(md::StandardLabeler *this)
{
  return 0;
}

void md::MuninStandardLabeler::updateOcclusionQueries(md::MuninStandardLabeler *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 9);
  for (uint64_t i = (uint64_t *)*((void *)this + 10); v1 != i; v1 += 2)
  {
    if (*(unsigned char *)(*v1 + 482)) {
      md::Label::submitOcclusionQuery(*v1, *(void *)(*((void *)this + 3) + 360), *(void *)(*((void *)this + 3) + 432), *(unsigned __int8 *)(*v1 + 1217));
    }
  }
}

uint64_t md::MuninStandardLabeler::checkNeedsOcclusionTests(md::MuninStandardLabeler *this, const md::LayoutContext *a2)
{
  return 1;
}

void md::MuninStandardLabeler::synchronizedUpdate(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  md::StandardLabeler::synchronizedUpdate(a1, a2, a3, a4);
  if (*(unsigned char *)(a1 + 440))
  {
    unint64_t v5 = *(void **)(a1 + 72);
    for (uint64_t i = *(void **)(a1 + 80); v5 != i; v5 += 2)
    {
      uint64_t v7 = (unsigned char *)*v5;
      v7[480] = 1;
      if (v7[820] != 2) {
        v7[485] = 0;
      }
    }
    *(unsigned char *)(a1 + 440) = 0;
  }
  if (*(unsigned char *)(a1 + 442))
  {
    *(unsigned char *)(a1 + 442) = 0;
    int v8 = *(unsigned __int8 *)(*(void *)(a1 + 24) + 3152);
    unsigned __int8 v10 = *(uint64_t **)(a1 + 72);
    unsigned __int8 v9 = *(uint64_t **)(a1 + 80);
    if (v8)
    {
      if (v10 == v9) {
        return;
      }
      while (1)
      {
        uint64_t v12 = *v10;
        if ((*(unsigned char *)(*v10 + 1072) & 0xFD) != 1) {
          goto LABEL_12;
        }
        uint64_t v13 = *(void *)(v12 + 272);
        if (!v13) {
          goto LABEL_12;
        }
        if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 744))(v13) & 1) == 0) {
          break;
        }
LABEL_14:
        v10 += 2;
        if (v10 == v9) {
          return;
        }
      }
      uint64_t v12 = *v10;
LABEL_12:
      uint64_t v11 = *(void *)(v12 + 264);
      if (v11 || (uint64_t v11 = *(void *)(v12 + 272)) != 0) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 512))(v11, 1);
      }
      goto LABEL_14;
    }
    for (; v10 != v9; v10 += 2)
    {
      uint64_t v14 = *(void *)(*v10 + 264);
      if (!v14)
      {
        uint64_t v14 = *(void *)(*v10 + 272);
        if (!v14) {
          continue;
        }
      }
      (*(void (**)(uint64_t, void))(*(void *)v14 + 512))(v14, 0);
    }
  }
}

void md::MuninStandardLabeler::~MuninStandardLabeler(md::MuninStandardLabeler *this)
{
  *(void *)this = &unk_1EF53DD20;
  *((void *)this + 1) = &unk_1EF53DF00;
  *((void *)this + 2) = &unk_1EF53DF48;
  uint64_t v2 = (void *)*((void *)this + 52);
  if (v2)
  {
    *((void *)this + 53) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 49);
  if (v3)
  {
    *((void *)this + 50) = v3;
    operator delete(v3);
  }
  md::StandardLabeler::~StandardLabeler(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF53DD20;
  *((void *)this + 1) = &unk_1EF53DF00;
  *((void *)this + 2) = &unk_1EF53DF48;
  uint64_t v2 = (void *)*((void *)this + 52);
  if (v2)
  {
    *((void *)this + 53) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 49);
  if (v3)
  {
    *((void *)this + 50) = v3;
    operator delete(v3);
  }
  md::StandardLabeler::~StandardLabeler(this);
}

void md::ElevationRequestUpdater::getDsmResource(void *a1, atomic_uchar *a2, uint64_t *a3)
{
  if ((atomic_load_explicit(a2, memory_order_acquire) & 1) == 0)
  {
    *a1 = 0;
    a1[1] = 0;
    return;
  }
  uint64_t v3 = *a3;
  uint64_t v4 = a3[1];
  if (*a3 != v4)
  {
    while (*(_WORD *)v3 != 20)
    {
      v3 += 48;
      if (v3 == v4) {
        goto LABEL_14;
      }
    }
  }
  if (v3 == v4)
  {
LABEL_14:
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v5 = *(void *)(v3 + 24);
    uint64_t v6 = *(void *)(v5 + 112);
    uint64_t v7 = *(std::__shared_weak_count **)(v5 + 120);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6)
    {
      int v8 = *(void **)(v6 + 144);
      if (v8)
      {
        if (*v8 != v8[1])
        {
          *a1 = v6;
          a1[1] = v7;
          return;
        }
      }
    }
  }
  uint64_t v9 = *a3;
  uint64_t v10 = a3[1];
  if (*a3 != v10)
  {
    while (*(_WORD *)v9 != 50)
    {
      v9 += 48;
      if (v9 == v10) {
        goto LABEL_24;
      }
    }
  }
  if (v9 == v10)
  {
LABEL_24:
    *a1 = 0;
    a1[1] = 0;
    if (!v7) {
      return;
    }
    goto LABEL_25;
  }
  uint64_t v11 = *(void *)(v9 + 24);
  uint64_t v13 = *(void *)(v11 + 112);
  uint64_t v12 = *(void *)(v11 + 120);
  *a1 = v13;
  a1[1] = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  if (v7)
  {
LABEL_25:
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void md::ElevationRequestUpdater::createResourceKey(uint64_t a1, const QuadTile *a2, char a3, int a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7)
{
  md::FlyoverMetaData::tileCacheLookup((md::FlyoverMetaData *)&v26, a2, a5, 0, 0);
  if (v29) {
    uint64_t v13 = v28;
  }
  else {
    uint64_t v13 = 0;
  }
  uint64_t v14 = *(void *)(a5 + 4);
  int v15 = a5[1];
  int v16 = *a5;
  if ((v13 & 0xFF00000000) == 0 || a4 == 50) {
    int v18 = 0;
  }
  else {
    int v18 = v13;
  }
  if (*(unsigned char *)a7) {
    int v19 = *(_DWORD *)(a7 + 4);
  }
  else {
    int v19 = 2147483646;
  }
  *(unsigned char *)a1 = a3;
  *(_WORD *)(a1 + 2) = a4;
  *(_DWORD *)(a1 + 4) = v19;
  *(void *)(a1 + 8) = a1 + 40;
  *(void *)(a1 + 16) = a1 + 40;
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 32) = 32;
  *(void *)(a1 + 72) = 0;
  int v26 = HIDWORD(v14);
  int v25 = v14;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a1 + 8), *(char **)(a1 + 16), (char *)&v26, v27);
  int v26 = v25;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a1 + 8), *(char **)(a1 + 16), (char *)&v26, v27);
  int v26 = v15;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a1 + 8), *(char **)(a1 + 16), (char *)&v26, v27);
  int v26 = v16;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a1 + 8), *(char **)(a1 + 16), (char *)&v26, v27);
  int v26 = 0;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a1 + 8), *(char **)(a1 + 16), (char *)&v26, v27);
  int v26 = v18;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a1 + 8), *(char **)(a1 + 16), (char *)&v26, v27);
  unsigned __int8 v20 = *(unsigned __int8 **)(a1 + 16);
  unsigned __int8 v21 = *(unsigned __int8 **)(a1 + 8);
  unint64_t v22 = v20 - v21;
  if (v20 == v21)
  {
    unint64_t v23 = 0;
  }
  else
  {
    unint64_t v23 = 0;
    if (v22 <= 1) {
      unint64_t v22 = 1;
    }
    do
    {
      unsigned int v24 = *v21++;
      v23 ^= (v23 << 6) + (v23 >> 2) - 0x61C8864680B583EBLL + v24;
      --v22;
    }
    while (v22);
  }
  *(void *)(a1 + 72) = v23;
  *(void *)(a1 + 88) = a6;
}

uint64_t md::ElevationRequestUpdater::updateRequest(uint64_t a1, char **a2, uint64_t a3)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)a1, memory_order_acquire) & 1) == 0) {
    return 0;
  }
  uint64_t v7 = *(_WORD **)a3;
  uint64_t v6 = *(_WORD **)(a3 + 8);
  int v8 = *(_WORD **)a3;
  if (*(_WORD **)a3 != v6)
  {
    do
    {
      if (*v8 == 50) {
        goto LABEL_8;
      }
      v8 += 24;
    }
    while (v8 != v6);
    int v8 = *(_WORD **)(a3 + 8);
LABEL_8:
    while (*v7 != 20)
    {
      v7 += 24;
      if (v7 == v6)
      {
        uint64_t v7 = *(_WORD **)(a3 + 8);
        break;
      }
    }
  }
  uint64_t result = 0;
  if (v8 == v6 && v7 == v6)
  {
    uint64_t v9 = *((void *)*a2 + 15);
    uint64_t v10 = (_WORD *)*((void *)*a2 + 16);
    if ((_WORD *)v9 != v10)
    {
      uint64_t v11 = (_WORD *)*((void *)*a2 + 15);
      while (*v11 != 20)
      {
        v11 += 24;
        if (v11 == v10) {
          goto LABEL_24;
        }
      }
      if (v11 != v10)
      {
        uint64_t v12 = *((void *)*a2 + 15);
        while (*(_WORD *)v12 != 20)
        {
          v12 += 48;
          if ((_WORD *)v12 == v10)
          {
            uint64_t v12 = *((void *)*a2 + 16);
            break;
          }
        }
        if (*(void *)(v12 + 32)) {
          return 0;
        }
      }
LABEL_24:
      uint64_t v13 = (_WORD *)*((void *)*a2 + 15);
      while (*v13 != 50)
      {
        v13 += 24;
        if (v13 == v10) {
          goto LABEL_33;
        }
      }
      if (v13 != v10)
      {
        while (*(_WORD *)v9 != 50)
        {
          v9 += 48;
          if ((_WORD *)v9 == v10)
          {
            uint64_t v9 = *((void *)*a2 + 16);
            break;
          }
        }
        if (*(void *)(v9 + 32)) {
          return 0;
        }
      }
    }
LABEL_33:
    uint64_t v14 = (int32x2_t *)*((void *)*a2 + 2);
    __int32 v15 = v14[1].i32[0];
    v40[0] = v14[1].i32[1];
    v40[1] = v15;
    int32x2_t v41 = vrev64_s32(*v14);
    int v16 = *(void **)(a1 + 24);
    uint64_t v17 = v16[1];
    (*(void (**)(uint64_t *__return_ptr))(*v16 + 16))(&v36);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v17 + 24))(&v34, v17, 20);
    if ((_BYTE)v36 && (_BYTE)v34 && HIDWORD(v34) <= v38 && v35 >= v38)
    {
      int v18 = *a2;
      char v19 = **a2;
      uint64_t v20 = *((void *)*a2 + 14);
      v29[0] = 0;
      if (v18[96])
      {
        int v30 = *((_DWORD *)v18 + 25);
        v29[0] = 1;
      }
      md::ElevationRequestUpdater::createResourceKey((uint64_t)v31, *(const QuadTile **)(a1 + 8), v19, 20, &v37, v20, (uint64_t)v29);
      md::FlyoverMetaData::tileCacheLookup((md::FlyoverMetaData *)v42, *(const QuadTile **)(a1 + 8), &v37, 0, 0);
      if (v45 && v42[0] == v37 && v42[1] == v38 && v43 == v39 && v44 == 1)
      {
        gdc::LayerDataRequest::request(*a2, (uint64_t)v31, 0);
        char v21 = 1;
      }
      else
      {
        char v21 = 0;
      }
      if (v32 != v33) {
        free(v32);
      }
      if (v21) {
        return 1;
      }
    }
    (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t, unsigned char *))(*(void *)v17 + 16))(v42, v17, 50, v40);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v17 + 24))(&v27, v17, 50);
    if (!v42[0] || !(_BYTE)v27) {
      return 0;
    }
    uint64_t result = 0;
    if (HIDWORD(v27) <= BYTE5(v43) && v28 >= BYTE5(v43))
    {
      unint64_t v22 = *a2;
      char v23 = **a2;
      uint64_t v24 = *((void *)*a2 + 14);
      v25[0] = 0;
      if (v22[96])
      {
        int v26 = *((_DWORD *)v22 + 25);
        v25[0] = 1;
      }
      md::ElevationRequestUpdater::createResourceKey((uint64_t)v31, *(const QuadTile **)(a1 + 8), v23, 50, (unsigned __int8 *)&v43 + 4, v24, (uint64_t)v25);
      gdc::LayerDataRequest::request(*a2, (uint64_t)v31, 0);
      if (v32 != v33) {
        free(v32);
      }
      return 1;
    }
  }
  return result;
}

void sub_1A20A5FBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16)
{
}

void md::ProgressiveLodRibbon::dpSimplifyProgressive(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  unsigned int v4 = a3 + 1;
  if ((int)a3 + 1 < a4)
  {
    uint64_t v6 = a3;
    uint64_t v9 = (double *)(a2 + 24 * a4);
    uint64_t v10 = a2 + 16;
    do
    {
      uint64_t v11 = (double *)(a2 + 24 * v6);
      double v12 = *v11;
      double v13 = v11[1];
      double v14 = *v9 - *v11;
      double v15 = v9[1] - v13;
      double v16 = v11[2];
      double v17 = v9[2] - v16;
      double v18 = v14 * v14 + v15 * v15 + v17 * v17;
      LODWORD(v19) = 0;
      uint64_t v20 = (double *)(v10 + 24 * v4);
      if (v18 <= 1.0e-15)
      {
        double v29 = 0.0;
        do
        {
          double v30 = *(v20 - 2);
          double v31 = *(v20 - 1);
          double v32 = *v20;
          v20 += 3;
          double v33 = (v30 - v12) * (v30 - v12) + (v31 - v13) * (v31 - v13) + (v32 - v16) * (v32 - v16);
          double v28 = fmax(v33, v29);
          if (v33 <= v29) {
            uint64_t v19 = v19;
          }
          else {
            uint64_t v19 = v4;
          }
          ++v4;
          double v29 = v28;
        }
        while (a4 != v4);
      }
      else
      {
        double v21 = 0.0;
        double v22 = 1.0 / v18;
        do
        {
          double v23 = *(v20 - 2);
          double v24 = *(v20 - 1);
          double v25 = *v20;
          v20 += 3;
          double v26 = fmin(fmax(((v23 - v12) * v14 + (v24 - v13) * v15 + (v25 - v16) * v17) * v22, 0.0), 1.0);
          double v27 = (v23 - (v12 + v26 * v14)) * (v23 - (v12 + v26 * v14))
              + (v24 - (v13 + v26 * v15)) * (v24 - (v13 + v26 * v15))
              + (v25 - (v16 + v26 * v17)) * (v25 - (v16 + v26 * v17));
          double v28 = fmax(v27, v21);
          if (v27 <= v21) {
            uint64_t v19 = v19;
          }
          else {
            uint64_t v19 = v4;
          }
          ++v4;
          double v21 = v28;
        }
        while (a4 != v4);
      }
      if (v28 == 0.0) {
        break;
      }
      int v34 = (int)(0.5 - log2(*(double *)(a1 + 120) * (*(double *)(a1 + 120) * v28)) * 0.5);
      if (v34 > 64) {
        break;
      }
      md::ProgressiveLodRibbon::dpSimplifyProgressive(a1, a2, v6, v19);
      *(unsigned char *)(*(void *)a1 + v19) = v34;
      unsigned int v4 = v19 + 1;
      uint64_t v6 = v19;
    }
    while ((int)v19 + 1 < a4);
  }
}

void std::__shared_ptr_emplace<md::ProgressiveLodRibbon>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 120);
  if (v2)
  {
    *(void *)(a1 + 128) = v2;
    operator delete(v2);
  }

  uint64_t v3 = *(void **)(a1 + 80);
  if (v3)
  {
    *(void *)(a1 + 88) = v3;
    operator delete(v3);
  }
  unsigned int v4 = *(void **)(a1 + 56);
  if (v4)
  {
    *(void *)(a1 + 64) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 24);
  if (v5)
  {
    *(void *)(a1 + 32) = v5;
    operator delete(v5);
  }
}

void std::__shared_ptr_emplace<md::ProgressiveLodRibbon>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581050;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::ProgressiveLodRibbon>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581050;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__hash_table<std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,std::__unordered_map_hasher<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,true>,std::__unordered_map_equal<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,std::equal_to<geo::QuadTile>,geo::QuadTileHash,true>,std::allocator<std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,void *> *>>(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[1];
  if (!v4) {
    goto LABEL_13;
  }
  for (uint64_t i = 0; i != v4; ++i)
    *(void *)(*a1 + 8 * i) = 0;
  uint64_t v6 = a1[2];
  a1[2] = 0;
  a1[3] = 0;
  if (v6)
  {
    while (a2)
    {
      long long v8 = *((_OWORD *)a2 + 1);
      *(void *)(v6 + 32) = a2[4];
      *(_OWORD *)(v6 + 16) = v8;
      uint64_t v10 = a2[5];
      uint64_t v9 = a2[6];
      if (v9) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v11 = *(std::__shared_weak_count **)(v6 + 48);
      *(void *)(v6 + 40) = v10;
      *(void *)(v6 + 48) = v9;
      if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
      uint64_t v7 = *(void *)v6;
      std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::__node_insert_multi((uint64_t)a1, v6);
      a2 = (uint64_t *)*a2;
      uint64_t v6 = v7;
      if (!v7) {
        goto LABEL_13;
      }
    }
    do
    {
      uint64_t v20 = (void *)v6;
      uint64_t v6 = *(void *)v6;
      double v21 = (std::__shared_weak_count *)v20[6];
      if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
      operator delete(v20);
    }
    while (v6);
  }
  else
  {
LABEL_13:
    while (a2)
    {
      double v12 = operator new(0x38uLL);
      *double v12 = 0;
      v12[1] = 0;
      uint64_t v13 = *((unsigned __int8 *)a2 + 17);
      int v15 = *((_DWORD *)a2 + 5);
      int v14 = *((_DWORD *)a2 + 6);
      uint64_t v16 = *((unsigned __int8 *)a2 + 16);
      *((unsigned char *)v12 + 16) = v16;
      *((unsigned char *)v12 + 17) = v13;
      *((_DWORD *)v12 + 5) = v15;
      *((_DWORD *)v12 + 6) = v14;
      uint64_t v17 = a2[6];
      v12[5] = a2[5];
      v12[6] = v17;
      if (v17)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
        uint64_t v16 = *((unsigned __int8 *)v12 + 16);
        uint64_t v13 = *((unsigned __int8 *)v12 + 17);
        int v15 = *((_DWORD *)v12 + 5);
        int v14 = *((_DWORD *)v12 + 6);
      }
      unint64_t v18 = (v13
           - 0x61C8864680B583EBLL
           + ((v16 - 0x61C8864680B583EBLL) << 6)
           + ((unint64_t)(v16 - 0x61C8864680B583EBLL) >> 2)) ^ (v16 - 0x61C8864680B583EBLL);
      unint64_t v19 = (v15 - 0x61C8864680B583EBLL + (v18 << 6) + (v18 >> 2)) ^ v18;
      v12[1] = (v14 - 0x61C8864680B583EBLL + (v19 << 6) + (v19 >> 2)) ^ v19;
      std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::__node_insert_multi((uint64_t)a1, (uint64_t)v12);
      a2 = (uint64_t *)*a2;
    }
  }
}

void sub_1A20A64CC(_Unwind_Exception *a1)
{
  uint64_t v3 = (std::__shared_weak_count *)v1[6];
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__tree<unsigned char,std::greater<unsigned char>,std::allocator<unsigned char>>::__assign_multi<std::__tree_const_iterator<unsigned char,std::__tree_node<unsigned char,void *> *,long>>(uint64_t **a1, void *a2, void *a3)
{
  uint64_t v4 = a2;
  if (a1[2])
  {
    uint64_t v6 = (uint64_t **)*a1;
    long long v8 = a1 + 1;
    uint64_t v7 = a1[1];
    *a1 = (uint64_t *)(a1 + 1);
    void v7[2] = 0;
    a1[2] = 0;
    a1[1] = 0;
    uint64_t v9 = v6[1] ? v6[1] : (uint64_t *)v6;
    if (v9)
    {
      uint64_t v10 = (uint64_t *)v9[2];
      if (v10)
      {
        uint64_t v11 = (uint64_t *)*v10;
        if ((uint64_t *)*v10 == v9)
        {
          *uint64_t v10 = 0;
          while (1)
          {
            int v34 = (void *)v10[1];
            if (!v34) {
              break;
            }
            do
            {
              uint64_t v10 = v34;
              int v34 = (void *)*v34;
            }
            while (v34);
          }
        }
        else
        {
          for (v10[1] = 0; v11; uint64_t v11 = (uint64_t *)v10[1])
          {
            do
            {
              uint64_t v10 = v11;
              uint64_t v11 = (uint64_t *)*v11;
            }
            while (v11);
          }
        }
      }
      if (a2 != a3)
      {
        double v12 = v9;
        uint64_t v13 = v4;
        do
        {
          uint64_t v9 = v10;
          unsigned int v14 = *((unsigned __int8 *)v13 + 25);
          *((unsigned char *)v12 + 25) = v14;
          int v15 = *v8;
          uint64_t v16 = a1 + 1;
          uint64_t v17 = a1 + 1;
          if (*v8)
          {
            do
            {
              while (1)
              {
                uint64_t v16 = v15;
                if (v14 <= *((unsigned __int8 *)v15 + 25)) {
                  break;
                }
                int v15 = (uint64_t *)*v15;
                uint64_t v17 = (uint64_t **)v16;
                if (!*v16) {
                  goto LABEL_20;
                }
              }
              int v15 = (uint64_t *)v15[1];
            }
            while (v15);
            uint64_t v17 = (uint64_t **)(v16 + 1);
          }
LABEL_20:
          *double v12 = 0;
          v12[1] = 0;
          v12[2] = (uint64_t)v16;
          *uint64_t v17 = v12;
          unint64_t v18 = (uint64_t *)**a1;
          if (v18)
          {
            *a1 = v18;
            double v12 = *v17;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v12);
          a1[2] = (uint64_t *)((char *)a1[2] + 1);
          if (v10)
          {
            uint64_t v10 = (uint64_t *)v10[2];
            if (v10)
            {
              double v21 = (void *)*v10;
              if ((uint64_t *)*v10 == v9)
              {
                *uint64_t v10 = 0;
                while (1)
                {
                  double v22 = (void *)v10[1];
                  if (!v22) {
                    break;
                  }
                  do
                  {
                    uint64_t v10 = v22;
                    double v22 = (void *)*v22;
                  }
                  while (v22);
                }
              }
              else
              {
                for (v10[1] = 0; v21; double v21 = (void *)v10[1])
                {
                  do
                  {
                    uint64_t v10 = v21;
                    double v21 = (void *)*v21;
                  }
                  while (v21);
                }
              }
            }
          }
          else
          {
            uint64_t v10 = 0;
          }
          unint64_t v19 = (void *)v13[1];
          if (v19)
          {
            do
            {
              uint64_t v4 = v19;
              unint64_t v19 = (void *)*v19;
            }
            while (v19);
          }
          else
          {
            do
            {
              uint64_t v4 = (void *)v13[2];
              BOOL v20 = *v4 == (void)v13;
              uint64_t v13 = v4;
            }
            while (!v20);
          }
          if (!v9) {
            break;
          }
          double v12 = v9;
          uint64_t v13 = v4;
        }
        while (v4 != a3);
      }
      std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v9);
      if (v10)
      {
        for (uint64_t i = (void *)v10[2]; i; uint64_t i = (void *)i[2])
          uint64_t v10 = i;
        std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v10);
      }
    }
  }
  if (v4 != a3)
  {
    double v24 = (uint64_t ***)(a1 + 1);
    do
    {
      double v25 = (uint64_t *)operator new(0x20uLL);
      double v26 = v25;
      unsigned int v27 = *((unsigned __int8 *)v4 + 25);
      *((unsigned char *)v25 + 25) = v27;
      double v28 = *v24;
      double v29 = a1 + 1;
      double v30 = a1 + 1;
      if (*v24)
      {
        do
        {
          while (1)
          {
            double v29 = v28;
            if (v27 <= *((unsigned __int8 *)v28 + 25)) {
              break;
            }
            double v28 = (uint64_t **)*v28;
            double v30 = v29;
            if (!*v29) {
              goto LABEL_56;
            }
          }
          double v28 = (uint64_t **)v28[1];
        }
        while (v28);
        double v30 = v29 + 1;
      }
LABEL_56:
      *double v25 = 0;
      v25[1] = 0;
      v25[2] = (uint64_t)v29;
      *double v30 = v25;
      double v31 = (uint64_t *)**a1;
      if (v31)
      {
        *a1 = v31;
        double v26 = *v30;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v26);
      a1[2] = (uint64_t *)((char *)a1[2] + 1);
      double v32 = (void *)v4[1];
      if (v32)
      {
        do
        {
          double v33 = v32;
          double v32 = (void *)*v32;
        }
        while (v32);
      }
      else
      {
        do
        {
          double v33 = (void *)v4[2];
          BOOL v20 = *v33 == (void)v4;
          uint64_t v4 = v33;
        }
        while (!v20);
      }
      uint64_t v4 = v33;
    }
    while (v33 != a3);
  }
}

void md::RouteSimplifier::simplifiedRibbonIndices(uint64_t a1, void *a2, int a3, int a4, void *a5, double a6)
{
  id v123 = a2;
  if (![v123 pointCount]) {
    goto LABEL_13;
  }
  uint64_t v13 = *(void **)(a1 + 16);
  uint64_t v12 = a1 + 16;
  uint64_t v11 = v13;
  double v14 = log2(*(double *)(v12 + 16) * a6);
  if (!v13) {
    goto LABEL_13;
  }
  int v15 = (void *)v12;
  do
  {
    unint64_t v16 = v11[4];
    BOOL v17 = v16 >= (unint64_t)v123;
    if (v16 >= (unint64_t)v123) {
      unint64_t v18 = v11;
    }
    else {
      unint64_t v18 = v11 + 1;
    }
    if (v17) {
      int v15 = v11;
    }
    uint64_t v11 = (void *)*v18;
  }
  while (*v18);
  if (v15 == (void *)v12 || v15[4] > (unint64_t)v123)
  {
LABEL_13:
    a5[1] = *a5;
    unint64_t v19 = v123;
    goto LABEL_14;
  }
  uint64_t v20 = v15[5];
  unsigned int v21 = (int)(0.5 - v14);
  double v22 = (char *)*a5;
  a5[1] = *a5;
  int v121 = a4;
  unint64_t v23 = (*(_DWORD *)(v20 + 8) - *(_DWORD *)v20);
  unint64_t v24 = (v23
       + *(unsigned int *)(*(void *)(v20 + 96) + 4 * (int)(0.5 - v14))
       * (unint64_t)(a4 - a3 + 1)
       - 1)
      / v23
      + 2;
  double v25 = (char *)a5[2];
  if (v24 <= (v25 - v22) >> 2)
  {
    double v26 = v22;
    if (v22 < v25)
    {
LABEL_22:
      *(_DWORD *)double v26 = a3;
      unsigned int v27 = v26 + 4;
      int v28 = a4;
      goto LABEL_43;
    }
  }
  else
  {
    if (v24 >> 62) {
      goto LABEL_152;
    }
    double v26 = (char *)operator new(4 * v24);
    double v25 = &v26[4 * v24];
    *a5 = v26;
    a5[1] = v26;
    a5[2] = v25;
    if (v22)
    {
      operator delete(v22);
      double v26 = (char *)a5[1];
      double v25 = (char *)a5[2];
    }
    if (v26 < v25) {
      goto LABEL_22;
    }
  }
  double v29 = (char *)*a5;
  uint64_t v30 = (uint64_t)&v26[-*a5];
  uint64_t v31 = v30 >> 2;
  unint64_t v32 = (v30 >> 2) + 1;
  if (v32 >> 62) {
    goto LABEL_152;
  }
  uint64_t v33 = v25 - v29;
  if (v33 >> 1 > v32) {
    unint64_t v32 = v33 >> 1;
  }
  if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v34 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v34 = v32;
  }
  if (v34)
  {
    if (v34 >> 62) {
      goto LABEL_153;
    }
    unsigned int v35 = operator new(4 * v34);
  }
  else
  {
    unsigned int v35 = 0;
  }
  uint64_t v36 = &v35[4 * v31];
  *uint64_t v36 = a3;
  unsigned int v27 = (char *)(v36 + 1);
  if (v26 == v29)
  {
    int v28 = v121;
    goto LABEL_41;
  }
  unint64_t v37 = v26 - v29 - 4;
  if (v37 < 0x2C || (unint64_t)(v26 - v35 - v30) < 0x20)
  {
    unsigned __int8 v38 = v26;
    int v28 = v121;
    do
    {
LABEL_38:
      int v39 = *((_DWORD *)v38 - 1);
      v38 -= 4;
      *--uint64_t v36 = v39;
    }
    while (v38 != v29);
    goto LABEL_41;
  }
  uint64_t v109 = (v37 >> 2) + 1;
  unsigned __int8 v38 = &v26[-4 * (v109 & 0x7FFFFFFFFFFFFFF8)];
  unsigned __int8 v110 = &v35[4 * v31 - 16];
  uint64_t v111 = v26 - 16;
  uint64_t v112 = v109 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    long long v113 = *(_OWORD *)v111;
    *(v110 - 1) = *((_OWORD *)v111 - 1);
    *unsigned __int8 v110 = v113;
    v110 -= 2;
    v111 -= 32;
    v112 -= 8;
  }
  while (v112);
  v36 -= v109 & 0x7FFFFFFFFFFFFFF8;
  int v28 = v121;
  if (v109 != (v109 & 0x7FFFFFFFFFFFFFF8)) {
    goto LABEL_38;
  }
LABEL_41:
  *a5 = v36;
  a5[1] = v27;
  a5[2] = &v35[4 * v34];
  if (v29) {
    operator delete(v29);
  }
LABEL_43:
  a5[1] = v27;
  int v120 = a3;
  unsigned int v40 = a3 + 1;
  unsigned int v41 = v28 - 1;
  unsigned int v122 = v21;
  if (*(unsigned __int8 *)(v20 + 24) < v21)
  {
    while (1)
    {
      if (v40 > v41) {
        goto LABEL_123;
      }
      if (*(unsigned __int8 *)(*(void *)v20 + v40) <= v21) {
        break;
      }
LABEL_59:
      ++v40;
    }
    unint64_t v59 = a5[2];
    if ((unint64_t)v27 < v59)
    {
      *(_DWORD *)unsigned int v27 = v40;
      uint64_t v58 = v27 + 4;
LABEL_58:
      a5[1] = v58;
      unsigned int v27 = v58;
      goto LABEL_59;
    }
    float64x2_t v60 = (char *)*a5;
    uint64_t v61 = (uint64_t)&v27[-*a5];
    uint64_t v62 = v61 >> 2;
    unint64_t v63 = (v61 >> 2) + 1;
    if (v63 >> 62) {
      goto LABEL_152;
    }
    uint64_t v64 = v59 - (void)v60;
    if (v64 >> 1 > v63) {
      unint64_t v63 = v64 >> 1;
    }
    if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v65 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v65 = v63;
    }
    if (v65)
    {
      if (v65 >> 62) {
        goto LABEL_153;
      }
      unsigned __int8 v66 = operator new(4 * v65);
    }
    else
    {
      unsigned __int8 v66 = 0;
    }
    unsigned __int8 v67 = (unsigned int *)&v66[4 * v62];
    *unsigned __int8 v67 = v40;
    uint64_t v58 = (char *)(v67 + 1);
    if (v27 != v60)
    {
      unint64_t v68 = v27 - 4 - v60;
      if (v68 >= 0xBC)
      {
        if (&v66[v61 - 4 - (v68 & 0xFFFFFFFFFFFFFFFCLL)] > &v66[v61 - 4])
        {
          uint64_t v69 = v27;
        }
        else if (&v27[-(v68 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v27 - 4)
        {
          uint64_t v69 = v27;
        }
        else if ((unint64_t)(v27 - v66 - v61) >= 0x20)
        {
          uint64_t v71 = (v68 >> 2) + 1;
          uint64_t v69 = &v27[-4 * (v71 & 0x7FFFFFFFFFFFFFF8)];
          uint64_t v72 = &v66[4 * v62 - 16];
          unsigned __int8 v73 = v27 - 16;
          uint64_t v74 = v71 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v75 = *(_OWORD *)v73;
            *(v72 - 1) = *((_OWORD *)v73 - 1);
            *uint64_t v72 = v75;
            v72 -= 2;
            v73 -= 32;
            v74 -= 8;
          }
          while (v74);
          v67 -= v71 & 0x7FFFFFFFFFFFFFF8;
          if (v71 == (v71 & 0x7FFFFFFFFFFFFFF8)) {
            goto LABEL_77;
          }
        }
        else
        {
          uint64_t v69 = v27;
        }
      }
      else
      {
        uint64_t v69 = v27;
      }
      do
      {
        unsigned int v70 = *((_DWORD *)v69 - 1);
        v69 -= 4;
        *--unsigned __int8 v67 = v70;
      }
      while (v69 != v60);
    }
LABEL_77:
    *a5 = v67;
    a5[1] = v58;
    a5[2] = &v66[4 * v65];
    if (v60) {
      operator delete(v60);
    }
    unsigned int v21 = v122;
    goto LABEL_58;
  }
  uint64_t v42 = *(char **)(v20 + 56);
  uint64_t v43 = *(char **)(v20 + 64);
  if (v43 != v42)
  {
    unint64_t v44 = (v43 - v42) >> 2;
    char v45 = *(char **)(v20 + 56);
    unint64_t v46 = v44;
    do
    {
      unint64_t v47 = v46 >> 1;
      unsigned __int8 v48 = (unsigned int *)&v45[4 * (v46 >> 1)];
      unsigned int v50 = *v48;
      unsigned __int8 v49 = (char *)(v48 + 1);
      v46 += ~(v46 >> 1);
      if (v50 < v40) {
        char v45 = v49;
      }
      else {
        unint64_t v46 = v47;
      }
    }
    while (v46);
    uint64_t v51 = *(char **)(v20 + 56);
    do
    {
      unint64_t v52 = v44 >> 1;
      uint64_t v53 = (unsigned int *)&v51[4 * (v44 >> 1)];
      unsigned int v55 = *v53;
      uint64_t v54 = (char *)(v53 + 1);
      v44 += ~(v44 >> 1);
      if (v41 < v55) {
        unint64_t v44 = v52;
      }
      else {
        uint64_t v51 = v54;
      }
    }
    while (v44);
    if (v45 != v43)
    {
      unint64_t v56 = (unint64_t)(v45 - v42) >> 2;
      unint64_t v57 = (unint64_t)(v51 - v42 - 4) >> 2;
      while (1)
      {
        if (v56 > v57) {
          goto LABEL_123;
        }
        uint64_t v77 = v56;
        if (*(unsigned __int8 *)(*(void *)(v20 + 32) + v56) <= v21) {
          break;
        }
LABEL_92:
        LODWORD(v56) = v77 + 1;
      }
      uint64_t v78 = *(void *)(v20 + 56);
      unint64_t v79 = a5[2];
      if ((unint64_t)v27 < v79)
      {
        *(_DWORD *)unsigned int v27 = *(_DWORD *)(v78 + 4 * v56);
        float64x2_t v76 = v27 + 4;
LABEL_91:
        a5[1] = v76;
        unsigned int v27 = v76;
        goto LABEL_92;
      }
      uint64_t v80 = (char *)*a5;
      uint64_t v81 = (uint64_t)&v27[-*a5];
      uint64_t v82 = v81 >> 2;
      unint64_t v83 = (v81 >> 2) + 1;
      if (v83 >> 62) {
        goto LABEL_152;
      }
      uint64_t v84 = v79 - (void)v80;
      if (v84 >> 1 > v83) {
        unint64_t v83 = v84 >> 1;
      }
      if ((unint64_t)v84 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v85 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v85 = v83;
      }
      if (v85)
      {
        if (v85 >> 62) {
          goto LABEL_153;
        }
        uint64_t v86 = operator new(4 * v85);
      }
      else
      {
        uint64_t v86 = 0;
      }
      uint64_t v87 = &v86[4 * v82];
      *uint64_t v87 = *(_DWORD *)(v78 + 4 * v77);
      float64x2_t v76 = (char *)(v87 + 1);
      if (v27 != v80)
      {
        unint64_t v88 = v27 - 4 - v80;
        if (v88 >= 0xBC)
        {
          if (&v86[v81 - 4 - (v88 & 0xFFFFFFFFFFFFFFFCLL)] > &v86[v81 - 4])
          {
            uint64_t v89 = v27;
          }
          else if (&v27[-(v88 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v27 - 4)
          {
            uint64_t v89 = v27;
          }
          else if ((unint64_t)(v27 - v86 - v81) >= 0x20)
          {
            uint64_t v91 = (v88 >> 2) + 1;
            uint64_t v89 = &v27[-4 * (v91 & 0x7FFFFFFFFFFFFFF8)];
            unsigned __int8 v92 = &v86[4 * v82 - 16];
            unsigned __int8 v93 = v27 - 16;
            uint64_t v94 = v91 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v95 = *(_OWORD *)v93;
              *(v92 - 1) = *((_OWORD *)v93 - 1);
              _OWORD *v92 = v95;
              v92 -= 2;
              v93 -= 32;
              v94 -= 8;
            }
            while (v94);
            v87 -= v91 & 0x7FFFFFFFFFFFFFF8;
            if (v91 == (v91 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_110;
            }
          }
          else
          {
            uint64_t v89 = v27;
          }
        }
        else
        {
          uint64_t v89 = v27;
        }
        do
        {
          int v90 = *((_DWORD *)v89 - 1);
          v89 -= 4;
          *--uint64_t v87 = v90;
        }
        while (v89 != v80);
      }
LABEL_110:
      *a5 = v87;
      a5[1] = v76;
      a5[2] = &v86[4 * v85];
      if (v80) {
        operator delete(v80);
      }
      unsigned int v21 = v122;
      goto LABEL_91;
    }
  }
LABEL_123:
  unint64_t v19 = v123;
  if (v121 != v120)
  {
    unint64_t v96 = a5[2];
    if ((unint64_t)v27 < v96)
    {
      *(_DWORD *)unsigned int v27 = v121;
      a5[1] = v27 + 4;
      goto LABEL_14;
    }
    unsigned __int8 v97 = (char *)*a5;
    uint64_t v98 = (uint64_t)&v27[-*a5];
    uint64_t v99 = v98 >> 2;
    unint64_t v100 = (v98 >> 2) + 1;
    if (!(v100 >> 62))
    {
      uint64_t v101 = v96 - (void)v97;
      if (v101 >> 1 > v100) {
        unint64_t v100 = v101 >> 1;
      }
      if ((unint64_t)v101 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v102 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v102 = v100;
      }
      if (!v102)
      {
        uint64_t v103 = 0;
LABEL_136:
        uint64_t v104 = &v103[4 * v99];
        uint64_t v105 = &v103[4 * v102];
        *uint64_t v104 = v121;
        uint64_t v106 = v104 + 1;
        if (v27 != v97)
        {
          unint64_t v107 = v27 - v97 - 4;
          if (v107 >= 0x2C)
          {
            if ((unint64_t)(v27 - &v103[v98]) >= 0x20)
            {
              uint64_t v114 = (v107 >> 2) + 1;
              uint64_t v108 = &v27[-4 * (v114 & 0x7FFFFFFFFFFFFFF8)];
              float64x2x3_t v115 = &v103[4 * v99 - 16];
              unsigned __int8 v116 = v27 - 16;
              uint64_t v117 = v114 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                long long v118 = *(_OWORD *)v116;
                *(v115 - 1) = *((_OWORD *)v116 - 1);
                *float64x2x3_t v115 = v118;
                v115 -= 2;
                v116 -= 32;
                v117 -= 8;
              }
              while (v117);
              v104 -= v114 & 0x7FFFFFFFFFFFFFF8;
              if (v114 == (v114 & 0x7FFFFFFFFFFFFFF8)) {
                goto LABEL_149;
              }
            }
            else
            {
              uint64_t v108 = v27;
            }
          }
          else
          {
            uint64_t v108 = v27;
          }
          do
          {
            int v119 = *((_DWORD *)v108 - 1);
            v108 -= 4;
            *--uint64_t v104 = v119;
          }
          while (v108 != v97);
        }
LABEL_149:
        *a5 = v104;
        a5[1] = v106;
        a5[2] = v105;
        if (v97) {
          operator delete(v97);
        }
        unint64_t v19 = v123;
        a5[1] = v106;
        goto LABEL_14;
      }
      if (!(v102 >> 62))
      {
        uint64_t v103 = operator new(4 * v102);
        goto LABEL_136;
      }
LABEL_153:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_152:
    abort();
  }
LABEL_14:
}

void sub_1A20A6FB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

double md::RouteSimplifier::worldPointForPolylineCoordinate(md::RouteSimplifier *this, const GEOComposedRoute *a2, const PolylineCoordinate *a3)
{
  uint64_t v5 = a2;
  double v6 = 0.0;
  if ([(GEOComposedRoute *)v5 pointCount])
  {
    uint64_t v7 = (void *)*((void *)this + 2);
    if (v7)
    {
      long long v8 = (void *)((char *)this + 16);
      do
      {
        unint64_t v9 = v7[4];
        BOOL v10 = v9 >= (unint64_t)v5;
        if (v9 >= (unint64_t)v5) {
          uint64_t v11 = v7;
        }
        else {
          uint64_t v11 = v7 + 1;
        }
        if (v10) {
          long long v8 = v7;
        }
        uint64_t v7 = (void *)*v11;
      }
      while (*v11);
      if (v8 != (void *)((char *)this + 16) && v8[4] <= (unint64_t)v5)
      {
        uint64_t v12 = v8[5];
        [*(id *)(v12 + 88) pointAtRouteCoordinate:*a3];
        double v14 = v13;
        double v16 = v15;
        double v18 = v17;
        unint64_t v19 = **(uint64_t ***)(v12 + 80);
        if (v19 != *(uint64_t **)(*(void *)(v12 + 80) + 8) && *v19 != 0xAB4154EC82453679)
        {
          uint64_t v20 = v19 + 5;
          do
          {
            uint64_t v21 = *v20;
            v20 += 5;
          }
          while (v21 != 0xAB4154EC82453679);
          unint64_t v19 = v20 - 5;
        }
        uint64_t v22 = v19[3];
        unint64_t v23 = (std::__shared_weak_count *)v19[4];
        if (v23)
        {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
        }
        *(double *)uint64_t v31 = v14;
        *(double *)&v31[1] = v16;
        *(double *)&v31[2] = v18;
        uint64_t v24 = (*(uint64_t (**)(uint64_t, void *, char *))(*(void *)v22 + 16))(v22, v31, (char *)this + 48);
        float v25 = *(float *)&v24;
        if ((v24 & 0xFF00000000) == 0)
        {
          float v26 = v18;
          float v25 = v26;
        }
        double v27 = *((float *)this + 11) + v25 * *((float *)this + 10);
        if (*(unsigned char *)(v12 + 128))
        {
          __double2 v28 = __sincos_stret(v14 * 0.0174532925);
          double v6 = (v27 + 6378137.0 / sqrt(v28.__sinval * v28.__sinval * -0.00669437999 + 1.0))
             * v28.__cosval
             * __sincos_stret(v16 * 0.0174532925).__cosval;
        }
        else
        {
          long double v30 = tan(v14 * 0.00872664626 + 0.785398163);
          double v6 = v16 * 0.00277777778 + 0.5;
          log(v30);
        }
      }
    }
  }

  return v6;
}

void sub_1A20A726C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void altitude::GlobeTileComponentViewData::~GlobeTileComponentViewData(altitude::GlobeTileComponentViewData *this)
{
}

void md::PolarFlyoverLayerDataSource::resourceKeyForType(uint64_t a1@<X0>, char a2@<W1>, unsigned __int8 *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  __int16 v8 = *(_WORD *)(a1 + 584);
  if (*(unsigned char *)a5) {
    int v9 = *(_DWORD *)(a5 + 4);
  }
  else {
    int v9 = 2147483646;
  }
  uint64_t v10 = *(void *)(a3 + 4);
  int v18 = v10;
  int v11 = a3[1];
  int v12 = *a3;
  *(unsigned char *)a6 = a2;
  *(_WORD *)(a6 + 2) = v8;
  *(_DWORD *)(a6 + 4) = v9;
  *(void *)(a6 + 8) = a6 + 40;
  *(void *)(a6 + 16) = a6 + 40;
  *(void *)(a6 + 24) = a6 + 40;
  *(void *)(a6 + 32) = 32;
  *(void *)(a6 + 72) = 0;
  int v19 = HIDWORD(v10);
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v18;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v11;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  int v19 = v12;
  geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)(a6 + 8), *(char **)(a6 + 16), (char *)&v19, (char *)&v20);
  double v13 = *(unsigned __int8 **)(a6 + 16);
  double v14 = *(unsigned __int8 **)(a6 + 8);
  unint64_t v15 = v13 - v14;
  if (v13 == v14)
  {
    unint64_t v16 = 0;
  }
  else
  {
    unint64_t v16 = 0;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    do
    {
      unsigned int v17 = *v14++;
      v16 ^= (v16 << 6) + (v16 >> 2) - 0x61C8864680B583EBLL + v17;
      --v15;
    }
    while (v15);
  }
  *(void *)(a6 + 72) = v16;
  *(void *)(a6 + 88) = a4;
}

uint64_t md::PolarFlyoverLayerDataSource::updateRequest(uint64_t a1, void **a2)
{
  uint64_t v4 = (uint64_t)*a2;
  uint64_t v5 = (unsigned __int16 *)(*a2)[15];
  double v6 = (unsigned __int16 *)(*a2)[16];
  if (v5 != v6)
  {
    while (*(unsigned __int16 *)(a1 + 584) != *v5)
    {
      v5 += 24;
      if (v5 == v6)
      {
        uint64_t v5 = (unsigned __int16 *)(*a2)[16];
        break;
      }
    }
  }
  if (!*((void *)v5 + 4)) {
    return 0;
  }
  uint64_t v7 = *((void *)v5 + 3);
  __int16 v8 = v58;
  uint64_t v53 = *(void *)(v7 + 16);
  uint64_t v54 = v58;
  unsigned int v55 = (char *)v58;
  unint64_t v56 = v58;
  uint64_t v57 = 32;
  int v9 = *(char **)(v7 + 24);
  uint64_t v10 = *(char **)(v7 + 32);
  unint64_t v11 = v10 - v9;
  if ((unint64_t)(v10 - v9) >= 0x21)
  {
    if (v11 <= 0x40) {
      size_t v12 = 64;
    }
    else {
      size_t v12 = v10 - v9;
    }
    __int16 v8 = malloc_type_malloc(v12, 0x100004077774924uLL);
    double v13 = (char *)v54;
    double v14 = v55;
    if (v54 == v55) {
      goto LABEL_27;
    }
    unint64_t v15 = v55 - (unsigned char *)v54;
    if ((unint64_t)(v55 - (unsigned char *)v54) < 8)
    {
      unint64_t v16 = v8;
      goto LABEL_26;
    }
    unint64_t v16 = v8;
    if ((unint64_t)((char *)v8 - (unsigned char *)v54) < 0x20) {
      goto LABEL_26;
    }
    if (v15 >= 0x20)
    {
      unint64_t v17 = v15 & 0xFFFFFFFFFFFFFFE0;
      int v19 = (long long *)((char *)v54 + 16);
      uint64_t v20 = v8 + 2;
      unint64_t v21 = v15 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v22 = *v19;
        *(v20 - 1) = *(v19 - 1);
        *uint64_t v20 = v22;
        v19 += 2;
        v20 += 2;
        v21 -= 32;
      }
      while (v21);
      if (v15 == v17) {
        goto LABEL_27;
      }
      if ((v15 & 0x18) == 0)
      {
        v13 += v17;
        unint64_t v16 = (char *)v8 + v17;
        goto LABEL_26;
      }
    }
    else
    {
      unint64_t v17 = 0;
    }
    unint64_t v23 = v15 & 0xFFFFFFFFFFFFFFF8;
    unint64_t v16 = (char *)v8 + (v15 & 0xFFFFFFFFFFFFFFF8);
    unint64_t v24 = v17 - (v15 & 0xFFFFFFFFFFFFFFF8);
    float v25 = &v13[v17];
    float v26 = (void *)((char *)v8 + v17);
    do
    {
      uint64_t v27 = *(void *)v25;
      v25 += 8;
      *v26++ = v27;
      v24 += 8;
    }
    while (v24);
    if (v15 == v23) {
      goto LABEL_27;
    }
    v13 += v23;
    do
    {
LABEL_26:
      char v28 = *v13++;
      *v16++ = v28;
    }
    while (v13 != v14);
LABEL_27:
    uint64_t v54 = v8;
    unsigned int v55 = (char *)v8;
    uint64_t v57 = v12;
  }
  if (v9 != v10)
  {
    if (v11 < 8)
    {
      long double v30 = v8;
      goto LABEL_44;
    }
    if ((unint64_t)((char *)v8 - v9) < 0x20)
    {
      long double v30 = v8;
      goto LABEL_44;
    }
    if (v11 >= 0x20)
    {
      unint64_t v29 = v11 & 0xFFFFFFFFFFFFFFE0;
      uint64_t v31 = (long long *)(v9 + 16);
      unint64_t v32 = v8 + 2;
      unint64_t v33 = v11 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v34 = *v31;
        *(v32 - 1) = *(v31 - 1);
        *unint64_t v32 = v34;
        v31 += 2;
        v32 += 2;
        v33 -= 32;
      }
      while (v33);
      if (v11 == v29) {
        goto LABEL_45;
      }
      if ((v11 & 0x18) == 0)
      {
        v9 += v29;
        long double v30 = (char *)v8 + v29;
        goto LABEL_44;
      }
    }
    else
    {
      unint64_t v29 = 0;
    }
    unint64_t v35 = v11 & 0xFFFFFFFFFFFFFFF8;
    long double v30 = (char *)v8 + (v11 & 0xFFFFFFFFFFFFFFF8);
    unint64_t v36 = v29 - (v11 & 0xFFFFFFFFFFFFFFF8);
    unint64_t v37 = (uint64_t *)&v9[v29];
    unsigned __int8 v38 = (void *)((char *)v8 + v29);
    do
    {
      uint64_t v39 = *v37++;
      *v38++ = v39;
      v36 += 8;
    }
    while (v36);
    if (v11 == v35) {
      goto LABEL_45;
    }
    v9 += v35;
    do
    {
LABEL_44:
      char v40 = *v9++;
      *v30++ = v40;
    }
    while (v9 != v10);
LABEL_45:
    __int16 v8 = v55;
  }
  uint64_t v41 = *(void *)(v7 + 88);
  unsigned int v55 = (char *)v8 + v11;
  v58[4] = v41;
  long long v59 = *(_OWORD *)(v7 + 96);
  uint64_t v42 = *(unsigned __int16 **)(a1 + 792);
  uint64_t v43 = *(unsigned __int16 **)(a1 + 800);
  if (v42 == v43)
  {
    char v44 = 0;
  }
  else
  {
    char v44 = 0;
    do
    {
      int v45 = *v42;
      unint64_t v46 = *(unsigned __int16 **)(v4 + 120);
      unint64_t v47 = *(unsigned __int16 **)(v4 + 128);
      if (v46 != v47)
      {
        while (v45 != *v46)
        {
          v46 += 24;
          if (v46 == v47) {
            goto LABEL_55;
          }
        }
      }
      if (v46 == v47)
      {
LABEL_55:
        char v48 = v53;
        gdc::ResourceKey::keyData((gdc::ResourceKey *)v49, &v53);
        gdc::ResourceKey::ResourceKey((uint64_t)v50, v48, v45, (uint64_t)v49, HIDWORD(v53), 2147483646);
        if (v49[0] != v49[2]) {
          free(v49[0]);
        }
        gdc::LayerDataRequest::request(*a2, (uint64_t)v50, 0);
        if (v51 != v52) {
          free(v51);
        }
        char v44 = 1;
      }
      ++v42;
    }
    while (v42 != v43);
  }
  if (v54 != v56) {
    free(v54);
  }
  return v44 & 1;
}

void md::PolarFlyoverLayerDataSource::createLayerData(uint64_t a1@<X0>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v4 = (gdc::Registry **)a1;
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  double v6 = (unsigned __int16 *)*a2;
  uint64_t v7 = (unsigned __int16 *)a2[1];
  if ((unsigned __int16 *)*a2 != v7)
  {
    while (*v6 != *(unsigned __int16 *)(a1 + 584))
    {
      v6 += 24;
      if (v6 == v7) {
        goto LABEL_11;
      }
    }
  }
  if (v6 == v7 || *((void *)v6 + 4) != 1)
  {
LABEL_11:
    uint64_t v9 = 0;
LABEL_12:
    uint64_t v47 = v9;
    char v48 = 0;
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_13;
  }
  uint64_t v8 = *((void *)v6 + 3);
  uint64_t v9 = *(void *)(v8 + 112);
  uint64_t v10 = *(std::__shared_weak_count **)(v8 + 120);
  if (!v10) {
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v47 = v9;
  char v48 = v10;
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    uint64_t v9 = v47;
    if (!v47) {
      goto LABEL_10;
    }
    goto LABEL_13;
  }
  uint64_t v9 = v47;
  if (v47)
  {
LABEL_13:
    md::PolarFlyoverLayerDataSource::createLayerData(gdc::LayerDataRequestKey const&,geo::linear_map<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>,std::vector<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>> const&,long long)const::$_0::operator()(&v46, (uint64_t)v4, v9);
    uint64_t v43 = 0;
    char v44 = 0;
    int v45 = 0;
    unint64_t v11 = (unsigned __int16 *)v4[100];
    size_t v12 = (unsigned __int16 *)v4[99];
    uint64_t v13 = (char *)v11 - (char *)v12;
    if (v11 == v12)
    {
LABEL_63:
      memset(v42, 0, sizeof(v42));
      gdc::LayerDataSource::populateLoadMetadataListFromMap(*a2, a2[1], v42);
      sp_mut = std::__get_sp_mut(v4 + 94);
      std::__sp_mut::lock(sp_mut);
      char v40 = (atomic_ullong *)v4[95];
      v41[1] = v4[94];
      v41[2] = (gdc::Registry *)v40;
      if (v40) {
        atomic_fetch_add_explicit(v40 + 1, 1uLL, memory_order_relaxed);
      }
      std::__sp_mut::unlock(sp_mut);
      md::RegistryManager::vendRegistry((md::RegistryManager *)v41);
    }
    if ((unint64_t)v13 >= 0x1FFFFFFFFFFFFFFFLL) {
      abort();
    }
    uint64_t v43 = operator new(8 * v13);
    char v44 = (char *)v43;
    int v45 = (char *)v43 + 16 * (v13 >> 1);
    double v14 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    unint64_t v15 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    while (1)
    {
      int v16 = *v12;
      unint64_t v17 = (unsigned __int16 *)*a2;
      int v18 = (unsigned __int16 *)a2[1];
      if ((unsigned __int16 *)*a2 != v18)
      {
        while (*v17 != v16)
        {
          v17 += 24;
          if (v17 == v18) {
            goto LABEL_27;
          }
        }
      }
      if (v17 == v18 || *((void *)v17 + 4) != 1) {
        break;
      }
      uint64_t v19 = *((void *)v17 + 3);
      uint64_t v20 = *(void *)(v19 + 112);
      unint64_t v21 = *(std::__shared_weak_count **)(v19 + 120);
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v49 = v20;
        unsigned int v50 = v21;
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        if (atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          uint64_t v20 = v49;
          if (!v49) {
            goto LABEL_28;
          }
        }
        else
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
          uint64_t v20 = v49;
          if (!v49) {
            goto LABEL_28;
          }
        }
      }
      else
      {
        uint64_t v49 = *(void *)(v19 + 112);
        unsigned int v50 = 0;
        if (!v20) {
          goto LABEL_28;
        }
      }
      md::PolarFlyoverLayerDataSource::createLayerData(gdc::LayerDataRequestKey const&,geo::linear_map<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>,std::vector<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>> const&,long long)const::$_0::operator()((uint64_t *)buf, (uint64_t)v4, v20);
      unint64_t v24 = v44;
      if (v44 >= v45)
      {
        float v25 = v14;
        float v26 = v4;
        uint64_t v27 = (char *)v43;
        uint64_t v28 = (v44 - (unsigned char *)v43) >> 4;
        unint64_t v29 = v28 + 1;
        if ((unint64_t)(v28 + 1) >> 60) {
          abort();
        }
        uint64_t v30 = v45 - (unsigned char *)v43;
        if ((v45 - (unsigned char *)v43) >> 3 > v29) {
          unint64_t v29 = v30 >> 3;
        }
        if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v31 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v31 = v29;
        }
        if (v31 >> 60) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v32 = (char *)operator new(16 * v31);
        unint64_t v33 = &v32[16 * v28];
        *(_OWORD *)unint64_t v33 = *(_OWORD *)buf;
        long long v34 = v33 + 16;
        memset(buf, 0, sizeof(buf));
        if (v24 == v27)
        {
          uint64_t v43 = v33;
          int v45 = &v32[16 * v31];
          double v14 = v25;
          if (v24) {
            goto LABEL_57;
          }
        }
        else
        {
          unint64_t v35 = v24;
          do
          {
            long long v36 = *((_OWORD *)v35 - 1);
            v35 -= 16;
            *((_OWORD *)v33 - 1) = v36;
            v33 -= 16;
            *(void *)unint64_t v35 = 0;
            *((void *)v35 + 1) = 0;
          }
          while (v35 != v27);
          uint64_t v43 = v33;
          char v44 = v34;
          int v45 = &v32[16 * v31];
          do
          {
            unint64_t v37 = (std::__shared_weak_count *)*((void *)v24 - 1);
            if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
              std::__shared_weak_count::__release_weak(v37);
            }
            v24 -= 16;
          }
          while (v24 != v27);
          unint64_t v24 = v27;
          double v14 = v25;
          if (v24) {
LABEL_57:
          }
            operator delete(v24);
        }
        unsigned __int8 v38 = *(std::__shared_weak_count **)&buf[8];
        char v44 = v34;
        uint64_t v4 = v26;
        unint64_t v15 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
        if (*(void *)&buf[8]
          && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
        goto LABEL_33;
      }
      *(_OWORD *)char v44 = *(_OWORD *)buf;
      char v44 = v24 + 16;
LABEL_33:
      unint64_t v23 = v50;
      if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
      if (++v12 == v11) {
        goto LABEL_63;
      }
    }
LABEL_27:
    uint64_t v49 = 0;
    unsigned int v50 = 0;
LABEL_28:
    if (*((void *)v14 + 86) != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    long long v22 = *((id *)v15 + 23);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v16;
      _os_log_impl(&dword_1A1780000, v22, OS_LOG_TYPE_DEBUG, "Missing additional resource raster tile %d!", buf, 8u);
    }

    goto LABEL_33;
  }
LABEL_10:
  *a3 = 0;
  a3[1] = 0;
  if (v48 && !atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
    std::__shared_weak_count::__release_weak(v48);
  }
}

void sub_1A20A83BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, _Unwind_Exception *exception_object, uint64_t a12, char a13, uint64_t a14, gdc::Registry *a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,char a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,int a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47)
{
  if (a42 != -1) {
    ((void (*)(uint64_t, char *))off_1EF58FA38[a42])(v47 - 136, &a30);
  }
  a42 = -1;
  char v48 = *(void **)(v47 - 224);
  if (v48 != *(void **)(v47 - 208)) {
    free(v48);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  std::unique_ptr<gdc::Registry>::~unique_ptr[abi:nn180100](&a15);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a16);
  if (__p) {
    operator delete(__p);
  }
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)&a23);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a26);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a28);
  _Unwind_Resume(a1);
}

void sub_1A20A8770(_Unwind_Exception *a1)
{
}

void md::PolarFlyoverLayerDataSource::createLayerData(gdc::LayerDataRequestKey const&,geo::linear_map<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>,std::vector<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>> const&,long long)const::$_0::operator()(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a3 + 144);
  if (!v4)
  {
    *a1 = 0;
    a1[1] = 0;
    return;
  }
  uint64_t v7 = (char *)operator new(0x58uLL);
  *((void *)v7 + 1) = 0;
  *((void *)v7 + 2) = 0;
  *(void *)uint64_t v7 = &unk_1EF583858;
  *((void *)v7 + 5) = 0;
  *((void *)v7 + 6) = 0;
  *((_DWORD *)v7 + 14) = 0;
  *((void *)v7 + 3) = &unk_1EF55AE58;
  *((void *)v7 + 4) = 0;
  *(void *)&long long v8 = 0x100000001;
  *((void *)&v8 + 1) = 0x100000001;
  *(_OWORD *)(v7 + 60) = v8;
  *(void *)(v7 + 76) = 0x100000001;
  *((_DWORD *)v7 + 21) = 0;
  unint64_t v21 = v7 + 24;
  long long v22 = (std::__shared_weak_count *)v7;
  uint64_t v9 = operator new(0xB0uLL);
  v9[1] = 0;
  void v9[2] = 0;
  *uint64_t v9 = &unk_1EF589EF0;
  *a1 = std::construct_at[abi:nn180100]<ggl::Texture2D,std::shared_ptr<ggl::TextureData2D> &,std::shared_ptr<ggl::SamplerState> &,ggl::Texture2D*>((uint64_t)(v9 + 3), v4, *(std::__shared_weak_count **)(a3 + 152), &v21);
  a1[1] = (uint64_t)v9;
  id v10 = *(id *)(a2 + 776);
  (*(void (**)(uint64_t *__return_ptr))(*(void *)[v10 gglDevice] + 24))(&v20);

  v23[0] = &unk_1EF52E130;
  v23[1] = a1;
  unint64_t v24 = v23;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  (*(void (**)(uint64_t, void *, uint64_t *))(*(void *)v20 + 16))(v20, v23, &v18);
  unint64_t v11 = v19;
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (v24 != v23)
  {
    if (v24) {
      (*(void (**)(void))(*v24 + 40))();
    }
    uint64_t v12 = v20;
    if (!v20) {
      goto LABEL_16;
    }
    goto LABEL_12;
  }
  (*(void (**)(void *))(v23[0] + 32))(v23);
  uint64_t v12 = v20;
  if (v20)
  {
LABEL_12:
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 24))(v12);
    uint64_t v14 = v20;
    uint64_t v20 = 0;
    v23[0] = v14;
    (*(void (**)(uint64_t, void *))(*(void *)v13 + 48))(v13, v23);
    uint64_t v15 = v23[0];
    v23[0] = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
    uint64_t v16 = v20;
    uint64_t v20 = 0;
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
    }
  }
LABEL_16:
  unint64_t v17 = v22;
  if (v22)
  {
    if (!atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

void sub_1A20A8AEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  std::__shared_weak_count::~__shared_weak_count(v12);
  operator delete(v14);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a12);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<md::PolarFlyoverTileData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::PolarFlyoverTileData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E258;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::PolarFlyoverTileData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E258;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__function::__func<md::PolarFlyoverLayerDataSource::createLayerData(gdc::LayerDataRequestKey const&,geo::linear_map<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>,std::vector<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>> const&,long long)::$_0::operator() const(md::RasterTileResource *)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<md::PolarFlyoverLayerDataSource::createLayerData(gdc::LayerDataRequestKey const&,geo::linear_map<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>,std::vector<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>> const&,long long)::$_0::operator() const(md::RasterTileResource *)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a2;
  ggl::Texture2D::vendImplicitLoadItem((ggl::Texture2D *)v4, **(void **)(a1 + 8));
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v2 + 24))(v2, v4);
  uint64_t result = (uint64_t)v6;
  if (v6 == v5) {
    return (*(uint64_t (**)(void *))(v5[0] + 32))(v5);
  }
  if (v6) {
    return (*(uint64_t (**)(void))(*v6 + 40))();
  }
  return result;
}

void sub_1A20A8CC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a19 == v19 + 48)
  {
    (*(void (**)(uint64_t))(a16 + 32))(v19 + 48);
    _Unwind_Resume(exception_object);
  }
  if (a19) {
    (*(void (**)(void))(*(void *)a19 + 40))();
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<md::PolarFlyoverLayerDataSource::createLayerData(gdc::LayerDataRequestKey const&,geo::linear_map<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>,std::vector<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>> const&,long long)::$_0::operator() const(md::RasterTileResource *)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<md::PolarFlyoverLayerDataSource::createLayerData(gdc::LayerDataRequestKey const&,geo::linear_map<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>,std::vector<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>> const&,long long)::$_0::operator() const(md::RasterTileResource *)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF52E130;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::PolarFlyoverLayerDataSource::createLayerData(gdc::LayerDataRequestKey const&,geo::linear_map<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>,std::vector<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>> const&,long long)::$_0::operator() const(md::RasterTileResource *)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<md::PolarFlyoverLayerDataSource::createLayerData(gdc::LayerDataRequestKey const&,geo::linear_map<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>,std::vector<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>> const&,long long)::$_0::operator() const(md::RasterTileResource *)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF52E130;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::PolarFlyoverLayerDataSource::createLayerData(gdc::LayerDataRequestKey const&,geo::linear_map<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>,std::vector<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>> const&,long long)::$_0::operator() const(md::RasterTileResource *)::{lambda(ggl::ResourceAccessor *)#1},std::allocator<md::PolarFlyoverLayerDataSource::createLayerData(gdc::LayerDataRequestKey const&,geo::linear_map<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>,std::vector<std::pair<unsigned short,std::unordered_map<gdc::ResourceKey,std::shared_ptr<gdc::Resource>,gdc::ResourceKeyHash,std::equal_to<gdc::ResourceKey>,std::allocator<std::pair<gdc::ResourceKey const,std::shared_ptr<gdc::Resource>>>>>>> const&,long long)::$_0::operator() const(md::RasterTileResource *)::{lambda(ggl::ResourceAccessor *)#1}>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

void md::PolarFlyoverLayerDataSource::~PolarFlyoverLayerDataSource(md::PolarFlyoverLayerDataSource *this)
{
  md::PolarFlyoverLayerDataSource::~PolarFlyoverLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  void *v3;
  std::__shared_weak_count *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF513B90;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 103);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (void *)*((void *)this + 99);
    if (!v3) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  uint64_t v3 = (void *)*((void *)this + 99);
  if (v3)
  {
LABEL_4:
    *((void *)this + 100) = v3;
    operator delete(v3);
  }
LABEL_5:
  *((void *)this + 96) = &unk_1EF559798;

  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 95);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  md::SingleGEOResourceLayerDataSource::~SingleGEOResourceLayerDataSource(this);
}

uint64_t std::__shared_ptr_pointer<ggl::FlyoverCommon::PolarMesh *,std::shared_ptr<ggl::Mesh>::__shared_ptr_default_delete<ggl::Mesh,ggl::FlyoverCommon::PolarMesh>,std::allocator<ggl::FlyoverCommon::PolarMesh>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ggl::FlyoverCommon::PolarMesh *,std::shared_ptr<ggl::Mesh>::__shared_ptr_default_delete<ggl::Mesh,ggl::FlyoverCommon::PolarMesh>,std::allocator<ggl::FlyoverCommon::PolarMesh>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::PolygonOverlay::AntialiasVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::PolygonOverlay::AntialiasVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::PolygonOverlay::AntialiasVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void non-virtual thunk to'ggl::PolygonOverlay::AntialiasMesh::~AntialiasMesh(ggl::PolygonOverlay::AntialiasMesh *this)
{
  ggl::Mesh::~Mesh((ggl::PolygonOverlay::AntialiasMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::PolygonOverlay::AntialiasMesh *)((char *)this - 16));
}

void ggl::PolygonOverlay::AntialiasMesh::~AntialiasMesh(ggl::PolygonOverlay::AntialiasMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::PolygonOverlay::AntialiasVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::PolygonOverlay::AntialiasVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::PolygonOverlay::FillPipelineState::~FillPipelineState(ggl::PolygonOverlay::FillPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::PolygonOverlay::FillPipelineSetup::textureIsEnabled(ggl::PolygonOverlay::FillPipelineSetup *this)
{
  return 0;
}

BOOL ggl::PolygonOverlay::FillPipelineSetup::constantDataIsEnabled(ggl::PolygonOverlay::FillPipelineSetup *this, unint64_t a2)
{
  if (a2 < 3) {
    return 1;
  }
  if (a2 == 3) {
    return *(unsigned char *)(*((void *)this + 2) + 304) != 0;
  }
  return 0;
}

void ggl::PolygonOverlay::FillPipelineSetup::~FillPipelineSetup(ggl::PolygonOverlay::FillPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::PolygonOverlay::AntialiasPipelineState::~AntialiasPipelineState(ggl::PolygonOverlay::AntialiasPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::PolygonOverlay::AntialiasPipelineSetup::textureIsEnabled(ggl::PolygonOverlay::AntialiasPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::PolygonOverlay::AntialiasPipelineSetup::constantDataIsEnabled(ggl::PolygonOverlay::AntialiasPipelineSetup *this, unint64_t a2)
{
  if (a2 < 3) {
    return 1;
  }
  if (a2 == 3) {
    return *(unsigned char *)(*((void *)this + 2) + 304) != 0;
  }
  return 0;
}

void ggl::PolygonOverlay::AntialiasPipelineSetup::~AntialiasPipelineSetup(ggl::PolygonOverlay::AntialiasPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t md::RegistryManager::LayerDataSets::{unnamed type#1}::~LayerDataSets(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 96);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 80);
  *(void *)(a1 + 80) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 56);
  if (v5)
  {
    do
    {
      double v6 = (void *)*v5;
      operator delete(v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  uint64_t v7 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v7) {
    operator delete(v7);
  }
  long long v8 = *(void **)(a1 + 16);
  if (v8)
  {
    do
    {
      uint64_t v9 = (void *)*v8;
      operator delete(v8);
      long long v8 = v9;
    }
    while (v9);
  }
  id v10 = *(void **)a1;
  *(void *)a1 = 0;
  if (v10) {
    operator delete(v10);
  }
  return a1;
}

uint64_t gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long>::connect(uint64_t a1, void *a2)
{
  v48[3] = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *(void *)a1 + 1;
  *(void *)a1 = v5;
  unint64_t v6 = *(void *)(a1 + 16);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v2 = v5;
      if (v5 >= v6) {
        unint64_t v2 = v5 % v6;
      }
    }
    else
    {
      unint64_t v2 = (v6 - 1) & v5;
    }
    long long v8 = *(void ***)(*(void *)(a1 + 8) + 8 * v2);
    if (v8)
    {
      uint64_t v9 = *v8;
      if (*v8)
      {
        if (v7.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v11 = v9[1];
            if (v11 == v5)
            {
              if (v9[2] == v5) {
                goto LABEL_82;
              }
            }
            else if ((v11 & (v6 - 1)) != v2)
            {
              goto LABEL_22;
            }
            uint64_t v9 = (void *)*v9;
            if (!v9) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v10 = v9[1];
          if (v10 == v5)
          {
            if (v9[2] == v5) {
              goto LABEL_82;
            }
          }
          else
          {
            if (v10 >= v6) {
              v10 %= v6;
            }
            if (v10 != v2) {
              break;
            }
          }
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
    }
  }
LABEL_22:
  uint64_t v12 = (void *)(a1 + 24);
  uint64_t v9 = operator new(0x38uLL);
  *uint64_t v9 = 0;
  v9[1] = v5;
  void v9[2] = v5;
  v9[6] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 32) + 1);
  float v14 = *(float *)(a1 + 40);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    BOOL v15 = 1;
    if (v6 >= 3) {
      BOOL v15 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v6);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v6 = *(void *)(a1 + 16);
    }
    if (prime <= v6)
    {
      if (prime >= v6) {
        goto LABEL_59;
      }
      unint64_t v30 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 32) / *(float *)(a1 + 40));
      if (v6 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
      {
        unint64_t v30 = std::__next_prime(v30);
      }
      else
      {
        uint64_t v32 = 1 << -(char)__clz(v30 - 1);
        if (v30 >= 2) {
          unint64_t v30 = v32;
        }
      }
      if (prime <= v30) {
        size_t prime = v30;
      }
      if (prime >= v6)
      {
        unint64_t v6 = *(void *)(a1 + 16);
LABEL_59:
        if ((v6 & (v6 - 1)) != 0)
        {
          if (v5 >= v6) {
            unint64_t v2 = v5 % v6;
          }
          else {
            unint64_t v2 = v5;
          }
        }
        else
        {
          unint64_t v2 = (v6 - 1) & v5;
        }
        goto LABEL_72;
      }
      if (!prime)
      {
        int v45 = *(void **)(a1 + 8);
        *(void *)(a1 + 8) = 0;
        if (v45) {
          operator delete(v45);
        }
        unint64_t v6 = 0;
        *(void *)(a1 + 16) = 0;
        goto LABEL_59;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v19 = operator new(8 * prime);
    uint64_t v20 = *(void **)(a1 + 8);
    *(void *)(a1 + 8) = v19;
    if (v20) {
      operator delete(v20);
    }
    uint64_t v21 = 0;
    *(void *)(a1 + 16) = prime;
    do
      *(void *)(*(void *)(a1 + 8) + 8 * v21++) = 0;
    while (prime != v21);
    long long v22 = (void *)*v12;
    if (!*v12)
    {
LABEL_58:
      unint64_t v6 = prime;
      goto LABEL_59;
    }
    size_t v23 = v22[1];
    size_t v24 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v25 = v23 & v24;
      *(void *)(*(void *)(a1 + 8) + 8 * v25) = v12;
      for (uint64_t i = (void *)*v22; *v22; uint64_t i = (void *)*v22)
      {
        size_t v27 = i[1] & v24;
        if (v27 == v25)
        {
          long long v22 = i;
        }
        else
        {
          uint64_t v28 = *(void *)(a1 + 8);
          if (*(void *)(v28 + 8 * v27))
          {
            void *v22 = *i;
            uint64_t v29 = 8 * v27;
            *uint64_t i = **(void **)(*(void *)(a1 + 8) + v29);
            **(void **)(*(void *)(a1 + 8) + v29) = i;
          }
          else
          {
            *(void *)(v28 + 8 * v27) = v22;
            long long v22 = i;
            size_t v25 = v27;
          }
        }
      }
      goto LABEL_58;
    }
    if (v23 >= prime) {
      v23 %= prime;
    }
    *(void *)(*(void *)(a1 + 8) + 8 * v23) = v12;
    unint64_t v33 = (void *)*v22;
    if (!*v22) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v23)
      {
        uint64_t v36 = *(void *)(a1 + 8);
        if (!*(void *)(v36 + 8 * v35))
        {
          *(void *)(v36 + 8 * v35) = v22;
          goto LABEL_63;
        }
        void *v22 = *v33;
        uint64_t v34 = 8 * v35;
        *unint64_t v33 = **(void **)(*(void *)(a1 + 8) + v34);
        **(void **)(*(void *)(a1 + 8) + v34) = v33;
        unint64_t v33 = v22;
      }
      size_t v35 = v23;
LABEL_63:
      long long v22 = v33;
      unint64_t v33 = (void *)*v33;
      size_t v23 = v35;
      if (!v33) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  uint64_t v37 = *(void *)(a1 + 8);
  unsigned __int8 v38 = *(void **)(v37 + 8 * v2);
  if (v38)
  {
    *uint64_t v9 = *v38;
LABEL_80:
    *unsigned __int8 v38 = v9;
    goto LABEL_81;
  }
  *uint64_t v9 = *v12;
  *uint64_t v12 = v9;
  *(void *)(v37 + 8 * v2) = v12;
  if (*v9)
  {
    unint64_t v39 = *(void *)(*v9 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v39 >= v6) {
        v39 %= v6;
      }
    }
    else
    {
      v39 &= v6 - 1;
    }
    unsigned __int8 v38 = (void *)(*(void *)(a1 + 8) + 8 * v39);
    goto LABEL_80;
  }
LABEL_81:
  ++*(void *)(a1 + 32);
LABEL_82:
  char v40 = (void *)a2[3];
  if (v40)
  {
    if (v40 == a2)
    {
      uint64_t v47 = v46;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v46);
    }
    else
    {
      uint64_t v47 = (void *)(*(uint64_t (**)(void *))(*v40 + 16))(v40);
    }
  }
  else
  {
    uint64_t v47 = 0;
  }
  uint64_t v41 = v9 + 3;
  if (v9 + 3 != v46)
  {
    uint64_t v42 = v47;
    uint64_t v43 = (void *)v9[6];
    if (v47 == v46)
    {
      if (v43 == v41)
      {
        (*(void (**)(void *, void *))(v46[0] + 24))(v46, v48);
        (*(void (**)(void *))(*v47 + 32))(v47);
        uint64_t v47 = 0;
        (*(void (**)(void, void *))(*(void *)v9[6] + 24))(v9[6], v46);
        (*(void (**)(void))(*(void *)v9[6] + 32))(v9[6]);
        v9[6] = 0;
        uint64_t v47 = v46;
        (*(void (**)(void *, void *))(v48[0] + 24))(v48, v9 + 3);
        (*(void (**)(void *))(v48[0] + 32))(v48);
      }
      else
      {
        (*(void (**)(void *, void *))(v46[0] + 24))(v46, v9 + 3);
        (*(void (**)(void *))(*v47 + 32))(v47);
        uint64_t v47 = (void *)v9[6];
      }
      v9[6] = v41;
    }
    else if (v43 == v41)
    {
      (*(void (**)(void *, void *))(v9[3] + 24))(v9 + 3, v46);
      (*(void (**)(void))(*(void *)v9[6] + 32))(v9[6]);
      v9[6] = v47;
      uint64_t v47 = v46;
    }
    else
    {
      uint64_t v47 = (void *)v9[6];
      v9[6] = v42;
    }
  }
  uint64_t result = (uint64_t)v47;
  if (v47 == v46) {
    return (*(uint64_t (**)(void *))(v46[0] + 32))(v46);
  }
  if (v47) {
    return (*(uint64_t (**)(void))(*v47 + 40))();
  }
  return result;
}

void sub_1A20AA1D8(_Unwind_Exception *a1)
{
  uint64_t v3 = (void *)v1[6];
  if (v3 == v1 + 3)
  {
    (*(void (**)(void *))(v1[3] + 32))(v1 + 3);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void md::RegistryManager::onComponentRemoved(uint64_t a1, int8x8_t *a2, uint64_t *a3, uint64_t a4, unint64_t a5)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 376)) {
    BOOL v5 = a4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v9 = 8 * a4;
    do
    {
      uint64_t v10 = *a3;
      if (GEOGetVectorKitRegistryManagerLog(void)::onceToken[0] != -1) {
        dispatch_once(GEOGetVectorKitRegistryManagerLog(void)::onceToken, &__block_literal_global_9556);
      }
      uint64_t v11 = (id)GEOGetVectorKitRegistryManagerLog(void)::log;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        int v12 = a2[5].u16[0];
        gdc::Registry::stringForComponentTypeId(&__p, a2, a5);
        p_p = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)buf = 67109634;
        int v16 = v12;
        __int16 v17 = 2048;
        uint64_t v18 = v10;
        __int16 v19 = 2080;
        uint64_t v20 = p_p;
        _os_log_impl(&dword_1A1780000, v11, OS_LOG_TYPE_DEBUG, "[ComponentRemoved] Registry:%d Entity:%llu component:%s", buf, 0x1Cu);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }

      ++a3;
      v9 -= 8;
    }
    while (v9);
  }
}

void md::RegistryManager::onComponentAdded(uint64_t a1, int8x8_t *a2, uint64_t *a3, uint64_t a4, unint64_t a5)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 376)) {
    BOOL v5 = a4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v9 = 8 * a4;
    do
    {
      uint64_t v10 = *a3;
      if (GEOGetVectorKitRegistryManagerLog(void)::onceToken[0] != -1) {
        dispatch_once(GEOGetVectorKitRegistryManagerLog(void)::onceToken, &__block_literal_global_9556);
      }
      uint64_t v11 = (id)GEOGetVectorKitRegistryManagerLog(void)::log;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        int v12 = a2[5].u16[0];
        gdc::Registry::stringForComponentTypeId(&__p, a2, a5);
        p_p = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)buf = 67109634;
        int v16 = v12;
        __int16 v17 = 2048;
        uint64_t v18 = v10;
        __int16 v19 = 2080;
        uint64_t v20 = p_p;
        _os_log_impl(&dword_1A1780000, v11, OS_LOG_TYPE_DEBUG, "[ComponentAdded] Registry:%d Entity:%llu component:%s", buf, 0x1Cu);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }

      ++a3;
      v9 -= 8;
    }
    while (v9);
  }
}

uint64_t std::__function::__func<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long)#1},std::allocator<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long)>::operator()(void *a1, uint64_t *a2, uint64_t *a3, void *a4)
{
  uint64_t v6 = *a2;
  uint64_t v7 = *a3;
  uint64_t v8 = a3[1];
  uint64_t v9 = (uint64_t (*)(void *, uint64_t, uint64_t, uint64_t, void))a1[2];
  uint64_t v10 = a1[3];
  uint64_t v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    return (*(uint64_t (**)(void))(*v11 + v9))();
  }
  else {
    return v9(v11, v6, v7, v8, *a4);
  }
}

__n128 std::__function::__func<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long)#1},std::allocator<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5214B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long)#1},std::allocator<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)unint64_t v2 = &unk_1EF5214B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long)#1},std::allocator<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>,unsigned long)>::~__func()
{
}

void md::RegistryManager::onEntityDeleted(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 376)) {
    BOOL v4 = a4 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    dispatch_once_t v7 = GEOGetVectorKitRegistryManagerLog(void)::onceToken[0];
    uint64_t v8 = 8 * a4;
    do
    {
      uint64_t v10 = *a3;
      if (v7 != -1) {
        dispatch_once(GEOGetVectorKitRegistryManagerLog(void)::onceToken, &__block_literal_global_9556);
      }
      uint64_t v11 = GEOGetVectorKitRegistryManagerLog(void)::log;
      if (os_log_type_enabled((os_log_t)GEOGetVectorKitRegistryManagerLog(void)::log, OS_LOG_TYPE_DEBUG))
      {
        int v9 = *(unsigned __int16 *)(a2 + 40);
        *(_DWORD *)buf = 67109376;
        int v13 = v9;
        __int16 v14 = 2048;
        uint64_t v15 = v10;
        _os_log_impl(&dword_1A1780000, v11, OS_LOG_TYPE_DEBUG, "[EntityDeleted] Registry:%d Entity:%llu", buf, 0x12u);
        dispatch_once_t v7 = GEOGetVectorKitRegistryManagerLog(void)::onceToken[0];
      }
      else
      {
        dispatch_once_t v7 = -1;
      }
      ++a3;
      v8 -= 8;
    }
    while (v8);
  }
}

void md::RegistryManager::onEntityCreated(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 376)) {
    BOOL v4 = a4 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    dispatch_once_t v7 = GEOGetVectorKitRegistryManagerLog(void)::onceToken[0];
    uint64_t v8 = 8 * a4;
    do
    {
      uint64_t v10 = *a3;
      if (v7 != -1) {
        dispatch_once(GEOGetVectorKitRegistryManagerLog(void)::onceToken, &__block_literal_global_9556);
      }
      uint64_t v11 = GEOGetVectorKitRegistryManagerLog(void)::log;
      if (os_log_type_enabled((os_log_t)GEOGetVectorKitRegistryManagerLog(void)::log, OS_LOG_TYPE_DEBUG))
      {
        int v9 = *(unsigned __int16 *)(a2 + 40);
        *(_DWORD *)buf = 67109376;
        int v13 = v9;
        __int16 v14 = 2048;
        uint64_t v15 = v10;
        _os_log_impl(&dword_1A1780000, v11, OS_LOG_TYPE_DEBUG, "[EntityCreated] Registry:%d Entity:%llu", buf, 0x12u);
        dispatch_once_t v7 = GEOGetVectorKitRegistryManagerLog(void)::onceToken[0];
      }
      else
      {
        dispatch_once_t v7 = -1;
      }
      ++a3;
      v8 -= 8;
    }
    while (v8);
  }
}

uint64_t std::__function::__func<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(void *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *a3;
  uint64_t v6 = (uint64_t (*)(void *, uint64_t, uint64_t, uint64_t))a1[2];
  uint64_t v7 = a1[3];
  uint64_t v8 = (void *)(a1[1] + (v7 >> 1));
  if (v7) {
    return (*(uint64_t (**)(void))(*v8 + v6))();
  }
  else {
    return v6(v8, v4, v5, a3[1]);
  }
}

__n128 std::__function::__func<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF521470;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)unint64_t v2 = &unk_1EF521470;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1},std::allocator<unsigned long gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>))::{lambda(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)#1}>,void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>::~__func()
{
}

void md::RegistryManager::onRegistryDestroyed(md::RegistryManager *this, gdc::Registry *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 376))
  {
    if (GEOGetVectorKitRegistryManagerLog(void)::onceToken[0] != -1) {
      dispatch_once(GEOGetVectorKitRegistryManagerLog(void)::onceToken, &__block_literal_global_9556);
    }
    uint64_t v3 = GEOGetVectorKitRegistryManagerLog(void)::log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitRegistryManagerLog(void)::log, OS_LOG_TYPE_DEBUG))
    {
      int v4 = *((unsigned __int16 *)a2 + 20);
      v5[0] = 67109120;
      v5[1] = v4;
      _os_log_impl(&dword_1A1780000, v3, OS_LOG_TYPE_DEBUG, "[RegistryDestroyed] Registry:%d", (uint8_t *)v5, 8u);
    }
  }
}

uint64_t std::__function::__func<unsigned long gdc::Signal<gdc::Registry *>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *))::{lambda(gdc::Registry *)#1},std::allocator<unsigned long gdc::Signal<gdc::Registry *>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *))::{lambda(gdc::Registry *)#1}>,void ()(gdc::Registry *)>::operator()(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v4 = a1[3];
  uint64_t v5 = (void *)(a1[1] + (v4 >> 1));
  if (v4) {
    return (*(uint64_t (**)(void))(*v5 + v3))();
  }
  else {
    return v3(v5, v2);
  }
}

__n128 std::__function::__func<unsigned long gdc::Signal<gdc::Registry *>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *))::{lambda(gdc::Registry *)#1},std::allocator<unsigned long gdc::Signal<gdc::Registry *>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *))::{lambda(gdc::Registry *)#1}>,void ()(gdc::Registry *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF57A6E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<unsigned long gdc::Signal<gdc::Registry *>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *))::{lambda(gdc::Registry *)#1},std::allocator<unsigned long gdc::Signal<gdc::Registry *>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *))::{lambda(gdc::Registry *)#1}>,void ()(gdc::Registry *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF57A6E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<unsigned long gdc::Signal<gdc::Registry *>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *))::{lambda(gdc::Registry *)#1},std::allocator<unsigned long gdc::Signal<gdc::Registry *>::connect<md::RegistryManager,md::RegistryManager>(md::RegistryManager *,void (md::RegistryManager::*)(gdc::Registry *))::{lambda(gdc::Registry *)#1}>,void ()(gdc::Registry *)>::~__func()
{
}

uint64_t std::__throw_bad_variant_access[abi:nn180100]()
{
  return std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<overloaded<stringForKey(std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey> const&)::$_0,stringForKey(std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey> const&)::$_1,stringForKey(std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey> const&)::$_2>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey> const&>();
}

std::string *std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<overloaded<stringForKey(std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey> const&)::$_0,stringForKey(std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey> const&)::$_1,stringForKey(std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey> const&)::$_2>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey> const&>(uint64_t a1, unsigned char *a2)
{
  if (*a2) {
    uint64_t v2 = "OverlayRegistry";
  }
  else {
    uint64_t v2 = "PuckRegistry";
  }
  return std::string::__assign_external(*(std::string **)(*(void *)a1 + 8), v2);
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<overloaded<stringForKey(std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey> const&)::$_0,stringForKey(std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey> const&)::$_1,stringForKey(std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey> const&)::$_2>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey> const&>(std::string ***a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  gdc::LayerDataKey::keysInt32Str(&v15, (unsigned __int16 *)(a2 + 8));
  uint64_t v4 = std::string::append(&v15, " id:", 4uLL);
  std::string::size_type v5 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v16.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v16.__r_.__value_.__r.__words[2] = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v14, *(_DWORD *)a2);
  if ((v14.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v6 = &v14;
  }
  else {
    uint64_t v6 = (std::string *)v14.__r_.__value_.__r.__words[0];
  }
  if ((v14.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v14.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v14.__r_.__value_.__l.__size_;
  }
  uint64_t v8 = std::string::append(&v16, (const std::string::value_type *)v6, size);
  std::string v13 = *v8;
  v8->__r_.__value_.__r.__words[0] = 0;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  if ((SHIBYTE(v14.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v16.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_9;
    }
LABEL_17:
    operator delete(v16.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v15.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_18;
  }
  operator delete(v14.__r_.__value_.__l.__data_);
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_17;
  }
LABEL_9:
  if ((SHIBYTE(v15.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_10;
  }
LABEL_18:
  operator delete(v15.__r_.__value_.__l.__data_);
LABEL_10:
  int v9 = *v3;
  int v10 = SHIBYTE(v13.__r_.__value_.__r.__words[2]);
  uint64_t v11 = (void *)v13.__r_.__value_.__r.__words[0];
  if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v12 = &v13;
  }
  else {
    int v12 = (std::string *)v13.__r_.__value_.__r.__words[0];
  }
  std::string::__assign_external(v9, (const std::string::value_type *)v12);
  if (v10 < 0) {
    operator delete(v11);
  }
}

void sub_1A20AAC8C(_Unwind_Exception *exception_object)
{
  int v3 = v2;
  if (v3 < 0) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void md::RegistryManager::removeRegistry(md::RegistryManager *this, const gdc::LayerData *a2)
{
  int v6 = *((_DWORD *)a2 + 2);
  gdc::LayerDataKey::LayerDataKey((uint64_t)&v7, (uint64_t)a2 + 24);
  int v3 = v6;
  gdc::LayerDataKey::LayerDataKey((uint64_t)&v4, (uint64_t)&v7);
  int v5 = 0;
  md::RegistryManager::removeRegistry((uint64_t)this, (uint64_t)&v3);
  if (v5 != -1) {
    ((void (*)(char *, int *))off_1EF58FA78[v5])(&v10, &v3);
  }
  if (v8 != v9) {
    free(v8);
  }
}

void sub_1A20AAD4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,int a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,void *a26)
{
  if (a21 != -1) {
    ((void (*)(uint64_t, uint64_t *))off_1EF58FA78[a21])(v26 - 17, &a9);
  }
  if (a24 != a26) {
    free(a24);
  }
  _Unwind_Resume(exception_object);
}

void md::RegistryManager::removeRegistry(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (GEOGetVectorKitRegistryManagerLog(void)::onceToken[0] != -1) {
    dispatch_once(GEOGetVectorKitRegistryManagerLog(void)::onceToken, &__block_literal_global_9556);
  }
  uint64_t v4 = (id)GEOGetVectorKitRegistryManagerLog(void)::log;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v18 = 0;
    v19[0] = __p;
    v19[1] = __p;
    uint64_t v5 = *(unsigned int *)(a2 + 96);
    if (v5 == -1)
    {
      std::__throw_bad_variant_access[abi:nn180100]();
      __break(1u);
      return;
    }
    uint64_t v20 = v19;
    ((void (*)(void **, uint64_t))off_1EF58FA68[v5])(&v20, a2);
    int v6 = __p;
    if (v18 < 0) {
      int v6 = (void **)__p[0];
    }
    *(_DWORD *)buf = 136315138;
    long long v22 = v6;
    _os_log_impl(&dword_1A1780000, v4, OS_LOG_TYPE_DEBUG, "Queuing outgoing key:%s", buf, 0xCu);
    if (SHIBYTE(v18) < 0) {
      operator delete(__p[0]);
    }
  }

  std::mutex::lock((std::mutex *)(a1 + 144));
  uint64_t v7 = (void *)(a1 + 264);
  uint64_t v8 = *(uint64_t **)(a1 + 264);
  if (!v8)
  {
    int v9 = (uint64_t *)(a1 + 264);
    goto LABEL_31;
  }
  while (1)
  {
    while (1)
    {
      int v9 = v8;
      char v10 = v8 + 4;
      unint64_t v11 = *((unsigned int *)v8 + 32);
      unint64_t v12 = *(unsigned int *)(a2 + 96);
      if (v11 == -1)
      {
        if (v12 == 0xFFFFFFFF) {
          goto LABEL_28;
        }
        goto LABEL_14;
      }
      if (v12 != 0xFFFFFFFF && v12 >= v11) {
        break;
      }
LABEL_23:
      uint64_t v8 = (uint64_t *)*v9;
      uint64_t v7 = v9;
      if (!*v9) {
        goto LABEL_31;
      }
    }
    if (v12 > v11) {
      break;
    }
    __p[0] = v19;
    if (((uint64_t (*)(void **, uint64_t, uint64_t *))off_1EF58FAA8[v12])(__p, a2, v10)) {
      goto LABEL_23;
    }
    unint64_t v12 = *(unsigned int *)(a2 + 96);
    if (v12 == 0xFFFFFFFF) {
      goto LABEL_28;
    }
LABEL_14:
    unint64_t v11 = *((unsigned int *)v9 + 32);
    if (v11 != -1) {
      break;
    }
LABEL_11:
    uint64_t v7 = v9 + 1;
    uint64_t v8 = (uint64_t *)v9[1];
    if (!v8) {
      goto LABEL_31;
    }
  }
  if (v11 < v12) {
    goto LABEL_11;
  }
  if (v11 <= v12)
  {
    __p[0] = v19;
    if (((unsigned int (*)(void **, uint64_t *, uint64_t))off_1EF58FAA8[v11])(__p, v10, a2)) {
      goto LABEL_11;
    }
  }
LABEL_28:
  if (!*v7)
  {
LABEL_31:
    std::string v14 = operator new(0x88uLL);
    v14[32] = 0;
    *((_DWORD *)v14 + 32) = -1;
    uint64_t v15 = *(unsigned int *)(a2 + 96);
    if (v15 != -1)
    {
      ((void (*)(void *, unsigned char *, uint64_t))off_1EF58FA88[v15])(v19, v14 + 32, a2);
      *((_DWORD *)v14 + 32) = v15;
    }
    *(void *)std::string v14 = 0;
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = v9;
    *uint64_t v7 = v14;
    uint64_t v16 = **(void **)(a1 + 256);
    if (v16)
    {
      *(void *)(a1 + 256) = v16;
      std::string v14 = (unsigned char *)*v7;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 264), (uint64_t *)v14);
    ++*(void *)(a1 + 272);
  }
  std::mutex::unlock((std::mutex *)(a1 + 144));
}

void sub_1A20AB060(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  uint64_t v18 = v15[32];
  if (v18 != -1) {
    ((void (*)(void **, uint64_t))off_1EF58FA78[v18])(&__p, v16);
  }
  operator delete(v15);
  std::mutex::unlock(v14);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::unique_ptr<gdc::Registry>>,std::__map_value_compare<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::__value_type<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::unique_ptr<gdc::Registry>>,std::less<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>>,true>,std::allocator<std::__value_type<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::unique_ptr<gdc::Registry>>>>::erase(void *a1, uint64_t a2)
{
  int v3 = *(void **)(a2 + 8);
  if (v3)
  {
    do
    {
      uint64_t v4 = v3;
      int v3 = (void *)*v3;
    }
    while (v3);
  }
  else
  {
    uint64_t v5 = (void *)a2;
    do
    {
      uint64_t v4 = (void *)v5[2];
      BOOL v6 = *v4 == (void)v5;
      uint64_t v5 = v4;
    }
    while (!v6);
  }
  if (*a1 == a2) {
    *a1 = v4;
  }
  uint64_t v7 = (uint64_t *)a1[1];
  --a1[2];
  std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v7, (uint64_t *)a2);
  uint64_t v8 = *(gdc::Registry **)(a2 + 136);
  *(void *)(a2 + 136) = 0;
  if (v8)
  {
    gdc::Registry::~Registry(v8);
    MEMORY[0x1A6239270]();
  }
  uint64_t v9 = *(unsigned int *)(a2 + 128);
  if (v9 != -1) {
    ((void (*)(char *, uint64_t))off_1EF58FA78[v9])(&v10, a2 + 32);
  }
  operator delete((void *)a2);
}

void std::__hash_table<std::__hash_value_type<gdc::Registry *,geo::linear_map<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>,std::equal_to<std::pair<unsigned long,unsigned int>>,std::allocator<std::pair<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>>>,std::vector<std::pair<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>>>>>,std::__unordered_map_hasher<gdc::Registry *,std::__hash_value_type<gdc::Registry *,geo::linear_map<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>,std::equal_to<std::pair<unsigned long,unsigned int>>,std::allocator<std::pair<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>>>,std::vector<std::pair<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>>>>>,std::hash<gdc::Registry *>,std::equal_to<gdc::Registry *>,true>,std::__unordered_map_equal<gdc::Registry *,std::__hash_value_type<gdc::Registry *,geo::linear_map<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>,std::equal_to<std::pair<unsigned long,unsigned int>>,std::allocator<std::pair<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>>>,std::vector<std::pair<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>>>>>,std::equal_to<gdc::Registry *>,std::hash<gdc::Registry *>,true>,std::allocator<std::__hash_value_type<gdc::Registry *,geo::linear_map<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>,std::equal_to<std::pair<unsigned long,unsigned int>>,std::allocator<std::pair<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>>>,std::vector<std::pair<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>>>>>>>::__erase_unique<gdc::Registry *>(uint64_t *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (v2)
  {
    unint64_t v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
    unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
    unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      unint64_t v7 = v5;
      if (v5 >= *(void *)&v2) {
        unint64_t v7 = v5 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v7 = v5 & (*(void *)&v2 - 1);
    }
    uint64_t v8 = *a1;
    uint64_t v9 = *(uint64_t ***)(*a1 + 8 * v7);
    if (v9)
    {
      char v10 = *v9;
      if (*v9)
      {
        uint64_t v11 = *(void *)&v2 - 1;
        if (v6.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == v5)
            {
              if (v10[2] == a2) {
                goto LABEL_22;
              }
            }
            else if ((v12 & v11) != v7)
            {
              return;
            }
            char v10 = (uint64_t *)*v10;
            if (!v10) {
              return;
            }
          }
        }
        do
        {
          unint64_t v13 = v10[1];
          if (v13 == v5)
          {
            if (v10[2] == a2)
            {
LABEL_22:
              if (v6.u32[0] > 1uLL)
              {
                if (v5 >= *(void *)&v2) {
                  v5 %= *(void *)&v2;
                }
              }
              else
              {
                v5 &= v11;
              }
              std::string v14 = *(uint64_t **)(v8 + 8 * v5);
              do
              {
                uint64_t v15 = v14;
                std::string v14 = (uint64_t *)*v14;
              }
              while (v14 != v10);
              if (v15 == a1 + 2) {
                goto LABEL_39;
              }
              unint64_t v16 = v15[1];
              if (v6.u32[0] > 1uLL)
              {
                if (v16 >= *(void *)&v2) {
                  v16 %= *(void *)&v2;
                }
              }
              else
              {
                v16 &= v11;
              }
              if (v16 != v5)
              {
LABEL_39:
                if (!*v10) {
                  goto LABEL_40;
                }
                unint64_t v17 = *(void *)(*v10 + 8);
                if (v6.u32[0] > 1uLL)
                {
                  if (v17 >= *(void *)&v2) {
                    v17 %= *(void *)&v2;
                  }
                }
                else
                {
                  v17 &= v11;
                }
                if (v17 != v5) {
LABEL_40:
                }
                  *(void *)(v8 + 8 * v5) = 0;
              }
              uint64_t v18 = *v10;
              if (*v10)
              {
                unint64_t v19 = *(void *)(v18 + 8);
                if (v6.u32[0] > 1uLL)
                {
                  if (v19 >= *(void *)&v2) {
                    v19 %= *(void *)&v2;
                  }
                }
                else
                {
                  v19 &= v11;
                }
                if (v19 != v5)
                {
                  *(void *)(*a1 + 8 * v19) = v15;
                  uint64_t v18 = *v10;
                }
              }
              uint64_t *v15 = v18;
              *char v10 = 0;
              --a1[3];
              uint64_t v20 = v10[3];
              if (v20)
              {
                uint64_t v21 = v10[4];
                long long v22 = (void *)v10[3];
                if (v21 != v20)
                {
                  do
                  {
                    uint64_t v23 = *(void *)(v21 - 8);
                    *(void *)(v21 - 8) = 0;
                    if (v23) {
                      (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
                    }
                    v21 -= 24;
                  }
                  while (v21 != v20);
                  long long v22 = (void *)v10[3];
                }
                v10[4] = v20;
                operator delete(v22);
              }
              operator delete(v10);
              return;
            }
          }
          else
          {
            if (v13 >= *(void *)&v2) {
              v13 %= *(void *)&v2;
            }
            if (v13 != v7) {
              return;
            }
          }
          char v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_0 &,gdc::Registry **>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      uint64_t v3 = *(a2 - 1);
      uint64_t v4 = *a1;
      if (*(unsigned __int16 *)(v3 + 40) < *(unsigned __int16 *)(*a1 + 40))
      {
        *a1 = v3;
        *(a2 - 1) = v4;
      }
      return 1;
    case 3:
      uint64_t v14 = *a1;
      uint64_t v15 = a1[1];
      unsigned int v16 = *(unsigned __int16 *)(v15 + 40);
      unsigned int v17 = *(unsigned __int16 *)(*a1 + 40);
      uint64_t v18 = *(a2 - 1);
      unsigned int v19 = *(unsigned __int16 *)(v18 + 40);
      if (v16 >= v17)
      {
        if (v19 < v16)
        {
          a1[1] = v18;
          *(a2 - 1) = v15;
          uint64_t v41 = *a1;
          uint64_t v40 = a1[1];
          if (*(unsigned __int16 *)(v40 + 40) < *(unsigned __int16 *)(*a1 + 40))
          {
            *a1 = v40;
            a1[1] = v41;
          }
        }
      }
      else
      {
        if (v19 >= v16)
        {
          *a1 = v15;
          a1[1] = v14;
          uint64_t v47 = *(a2 - 1);
          if (*(unsigned __int16 *)(v47 + 40) >= v17) {
            return 1;
          }
          a1[1] = v47;
        }
        else
        {
          *a1 = v18;
        }
        *(a2 - 1) = v14;
      }
      return 1;
    case 4:
      uint64_t v20 = a1 + 1;
      uint64_t v21 = a1[1];
      long long v22 = a1 + 2;
      uint64_t v23 = a1[2];
      uint64_t v24 = *a1;
      unsigned int v25 = *(unsigned __int16 *)(v21 + 40);
      unsigned int v26 = *(unsigned __int16 *)(*a1 + 40);
      unsigned int v27 = *(unsigned __int16 *)(v23 + 40);
      if (v25 < v26)
      {
        uint64_t v28 = a1;
        uint64_t v29 = a1 + 2;
        uint64_t v30 = *a1;
        if (v27 >= v25)
        {
          *a1 = v21;
          a1[1] = v24;
          uint64_t v28 = a1 + 1;
          uint64_t v29 = a1 + 2;
          uint64_t v30 = v24;
          if (v27 >= v26) {
            goto LABEL_35;
          }
        }
LABEL_34:
        uint64_t *v28 = v23;
        *uint64_t v29 = v24;
        uint64_t v21 = v30;
        goto LABEL_36;
      }
      if (v27 < v25)
      {
        *uint64_t v20 = v23;
        uint64_t *v22 = v21;
        uint64_t v28 = a1;
        uint64_t v29 = a1 + 1;
        uint64_t v30 = v21;
        if (v27 >= v26) {
          goto LABEL_36;
        }
        goto LABEL_34;
      }
LABEL_35:
      uint64_t v21 = v23;
LABEL_36:
      uint64_t v42 = *(a2 - 1);
      if (*(unsigned __int16 *)(v42 + 40) < *(unsigned __int16 *)(v21 + 40))
      {
        uint64_t *v22 = v42;
        *(a2 - 1) = v21;
        uint64_t v43 = *v22;
        uint64_t v44 = *v20;
        unsigned int v45 = *(unsigned __int16 *)(v43 + 40);
        if (v45 < *(unsigned __int16 *)(v44 + 40))
        {
          a1[1] = v43;
          a1[2] = v44;
          uint64_t v46 = *a1;
          if (v45 < *(unsigned __int16 *)(*a1 + 40))
          {
            *a1 = v43;
            a1[1] = v46;
          }
        }
      }
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_0 &,gdc::Registry **,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint8x8_t v6 = a1 + 2;
      uint64_t v5 = a1[2];
      uint64_t v7 = a1[1];
      uint64_t v8 = *a1;
      unsigned int v9 = *(unsigned __int16 *)(v7 + 40);
      unsigned int v10 = *(unsigned __int16 *)(*a1 + 40);
      unsigned int v11 = *(unsigned __int16 *)(v5 + 40);
      if (v9 >= v10)
      {
        if (v11 >= v9) {
          goto LABEL_19;
        }
        a1[1] = v5;
        *uint8x8_t v6 = v7;
        uint64_t v12 = a1;
        unint64_t v13 = a1 + 1;
      }
      else
      {
        uint64_t v12 = a1;
        unint64_t v13 = a1 + 2;
        if (v11 < v9) {
          goto LABEL_18;
        }
        *a1 = v7;
        a1[1] = v8;
        uint64_t v12 = a1 + 1;
        unint64_t v13 = a1 + 2;
      }
      if (v11 >= v10) {
        goto LABEL_19;
      }
LABEL_18:
      *uint64_t v12 = v5;
      *unint64_t v13 = v8;
LABEL_19:
      uint8x8_t v31 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v32 = 0;
      for (uint64_t i = 24; ; i += 8)
      {
        uint64_t v35 = *v31;
        uint64_t v36 = *v6;
        unsigned int v37 = *(unsigned __int16 *)(*v31 + 40);
        if (v37 < *(unsigned __int16 *)(v36 + 40))
        {
          uint64_t v38 = i;
          do
          {
            *(uint64_t *)((char *)a1 + v38) = v36;
            uint64_t v39 = v38 - 8;
            if (v38 == 8)
            {
              uint64_t v34 = a1;
              goto LABEL_22;
            }
            uint64_t v36 = *(uint64_t *)((char *)a1 + v38 - 16);
            v38 -= 8;
          }
          while (v37 < *(unsigned __int16 *)(v36 + 40));
          uint64_t v34 = (uint64_t *)((char *)a1 + v39);
LABEL_22:
          *uint64_t v34 = v35;
          if (++v32 == 8) {
            break;
          }
        }
        uint8x8_t v6 = v31++;
        if (v31 == a2) {
          return 1;
        }
      }
      return v31 + 1 == a2;
  }
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::TypeInfo,std::unique_ptr<gdc::BaseObjectHolder>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::TypeInfo,std::unique_ptr<gdc::BaseObjectHolder>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = v2[5];
      v2[5] = 0;
      if (v3) {
        (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
      }
    }
    operator delete(v2);
  }
  return a1;
}

uint64_t gdc::ObjectHolder<md::components::NonTiled>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::components::NonTiled>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555258;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0xC400A2AC0F1);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::components::NonTiled>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555258;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0xC400A2AC0F1);
  }
  return a1;
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::Registry *,geo::linear_map<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>,std::equal_to<std::pair<unsigned long,unsigned int>>,std::allocator<std::pair<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>>>,std::vector<std::pair<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::Registry *,geo::linear_map<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>,std::equal_to<std::pair<unsigned long,unsigned int>>,std::allocator<std::pair<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>>>,std::vector<std::pair<std::pair<unsigned long,unsigned int>,std::unique_ptr<gdc::EntityCollector>>>>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = v2[3];
      if (v3)
      {
        uint64_t v4 = v2[4];
        uint64_t v5 = (void *)v2[3];
        if (v4 != v3)
        {
          do
          {
            uint64_t v6 = *(void *)(v4 - 8);
            *(void *)(v4 - 8) = 0;
            if (v6) {
              (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
            }
            v4 -= 24;
          }
          while (v4 != v3);
          uint64_t v5 = (void *)v2[3];
        }
        v2[4] = v3;
        operator delete(v5);
      }
    }
    operator delete(v2);
  }
  return a1;
}

uint64_t gdc::ObjectHolder<md::MapDataType>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::MapDataType>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5552A8;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0x1000C40BDFB0063);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::MapDataType>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5552A8;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40BDFB0063);
  }
  return a1;
}

uint64_t std::__function::__func<md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_2,std::allocator<md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_2>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF571460;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_2,std::allocator<md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_2>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF571460;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_2,std::allocator<md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_2>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_1,std::allocator<md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceDetailsLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceDetailsLog_onceToken, &__block_literal_global_21);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceDetailsLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = **(void **)(a1 + 8);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "ResolveRegistries", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_1,std::allocator<md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF571418;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_1,std::allocator<md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF571418;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_1,std::allocator<md::RegistryManager::update(md::RegistryManager::LayerDataSets &,md::SceneContext const&,unsigned long long,BOOL)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__split_buffer<std::pair<std::variant<gdc::LayerDataKeyIdPair,md::NonTiledRegistryKey>,std::unique_ptr<gdc::Registry>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 112;
    os_signpost_id_t v4 = *(gdc::Registry **)(i - 8);
    *(void *)(i - 8) = 0;
    if (v4)
    {
      gdc::Registry::~Registry(v4);
      MEMORY[0x1A6239270]();
    }
    uint64_t v5 = *(unsigned int *)(i - 16);
    if (v5 != -1) {
      ((void (*)(char *, uint64_t))off_1EF58FA78[v5])(&v7, i - 112);
    }
    *(_DWORD *)(i - 16) = -1;
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3gdc18LayerDataKeyIdPairEN2md19NonTiledRegistryKeyEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSJ_OT0_E_JRNS0_6__baseILSG_1EJS9_SB_EEEOSR_EEEDcSJ_DpT0_(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  *a2 = *a3;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3gdc18LayerDataKeyIdPairEN2md19NonTiledRegistryKeyEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSJ_OT0_E_JRNS0_6__baseILSG_1EJS9_SB_EEEOSR_EEEDcSJ_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
  return gdc::LayerDataKey::LayerDataKey((uint64_t)(a2 + 2), (uint64_t)(a3 + 2));
}

void md::RegistryManager::removeCollectorSubscription(int8x8_t *this, uint64_t a2, unsigned int a3)
{
  uint64_t v6 = std::__hash_table<std::__hash_value_type<std::pair<unsigned long,unsigned int>,std::function<std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>>,std::__unordered_map_hasher<std::pair<unsigned long,unsigned int>,std::__hash_value_type<std::pair<unsigned long,unsigned int>,std::function<std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>>,std::hash<std::pair<unsigned long,unsigned int>>,std::equal_to<std::pair<unsigned long,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned long,unsigned int>,std::__hash_value_type<std::pair<unsigned long,unsigned int>,std::function<std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>>,std::equal_to<std::pair<unsigned long,unsigned int>>,std::hash<std::pair<unsigned long,unsigned int>>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned long,unsigned int>,std::function<std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>>>>::find<std::pair<unsigned long,unsigned int>>(this, a2, a3);
  if (v6)
  {
    char v7 = v6;
    int8x8_t v8 = this[1];
    unint64_t v9 = v6[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8(v8);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v8) {
        v9 %= *(void *)&v8;
      }
    }
    else
    {
      v9 &= *(void *)&v8 - 1;
    }
    unsigned int v11 = *(uint64_t **)(*(void *)this + 8 * v9);
    do
    {
      uint64_t v12 = v11;
      unsigned int v11 = (uint64_t *)*v11;
    }
    while (v11 != v6);
    if (v12 == (uint64_t *)&this[2]) {
      goto LABEL_19;
    }
    unint64_t v13 = v12[1];
    if (v10.u32[0] > 1uLL)
    {
      if (v13 >= *(void *)&v8) {
        v13 %= *(void *)&v8;
      }
    }
    else
    {
      v13 &= *(void *)&v8 - 1;
    }
    if (v13 != v9)
    {
LABEL_19:
      if (!*v6) {
        goto LABEL_20;
      }
      unint64_t v14 = *(void *)(*v6 + 8);
      if (v10.u32[0] > 1uLL)
      {
        if (v14 >= *(void *)&v8) {
          v14 %= *(void *)&v8;
        }
      }
      else
      {
        v14 &= *(void *)&v8 - 1;
      }
      if (v14 != v9) {
LABEL_20:
      }
        *(void *)(*(void *)this + 8 * v9) = 0;
    }
    uint64_t v15 = *v6;
    if (*v6)
    {
      unint64_t v16 = *(void *)(v15 + 8);
      if (v10.u32[0] > 1uLL)
      {
        if (v16 >= *(void *)&v8) {
          v16 %= *(void *)&v8;
        }
      }
      else
      {
        v16 &= *(void *)&v8 - 1;
      }
      if (v16 != v9)
      {
        *(void *)(*(void *)this + 8 * v16) = v12;
        uint64_t v15 = *v6;
      }
    }
    *uint64_t v12 = v15;
    *uint64_t v6 = 0;
    --*(void *)&this[3];
    unsigned int v17 = v6 + 4;
    uint64_t v18 = (uint64_t *)v6[7];
    if (v18 == v7 + 4)
    {
      (*(void (**)(uint64_t *))(*v17 + 32))(v7 + 4);
    }
    else if (v18)
    {
      (*(void (**)(uint64_t *))(*v18 + 40))(v18);
    }
    operator delete(v7);
  }
  for (uint64_t i = (void *)this[7]; i; uint64_t i = (void *)*i)
  {
    uint64_t v21 = i[3];
    uint64_t v20 = i[4];
    if (v21 != v20)
    {
      while (*(void *)v21 != a2 || *(_DWORD *)(v21 + 8) != a3)
      {
        v21 += 24;
        if (v21 == v20) {
          goto LABEL_36;
        }
      }
    }
    if (v21 != v20)
    {
      if (v21 + 24 != v20)
      {
        do
        {
          uint64_t v25 = *(void *)(v21 + 16);
          *(void *)uint64_t v21 = *(void *)(v21 + 24);
          *(_DWORD *)(v21 + 8) = *(_DWORD *)(v21 + 32);
          uint64_t v26 = *(void *)(v21 + 40);
          *(void *)(v21 + 40) = 0;
          *(void *)(v21 + 16) = v26;
          if (v25) {
            (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
          }
          uint64_t v23 = v21 + 24;
          uint64_t v24 = v21 + 48;
          v21 += 24;
        }
        while (v24 != v20);
        uint64_t v20 = i[4];
        uint64_t v21 = v23;
      }
      while (v20 != v21)
      {
        uint64_t v27 = *(void *)(v20 - 8);
        *(void *)(v20 - 8) = 0;
        if (v27) {
          (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
        }
        v20 -= 24;
      }
      i[4] = v21;
    }
LABEL_36:
    ;
  }
}

void md::layoutElevatedPolygonMeshes<md::ElevatedPolygonRenderable>(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, unsigned int *a8)
{
  uint64_t v493 = *MEMORY[0x1E4F143B8];
  int v12 = *((_DWORD *)a3 + 4);
  if (a3[3])
  {
    unint64_t v13 = *(std::__shared_weak_count **)(a2 + 256);
    uint64_t v475 = *(void *)(a2 + 248);
    double v476 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v475 = 0;
    double v476 = 0;
  }
  unint64_t v14 = *(void **)(a1 + 8);
  unint64_t v15 = v14[1];
  if ((v15 & (v15 - 1)) != 0)
  {
    unint64_t v17 = 0x1AF456233693CD46;
    if (v15 <= 0x1AF456233693CD46) {
      unint64_t v17 = 0x1AF456233693CD46 % v15;
    }
    unint64_t v16 = *(void **)(*v14 + 8 * v17);
    do
    {
      do
        unint64_t v16 = (void *)*v16;
      while (v16[1] != 0x1AF456233693CD46);
    }
    while (v16[2] != 0x1AF456233693CD46);
  }
  else
  {
    unint64_t v16 = *(void **)(*v14 + 8 * ((v15 - 1) & 0x1AF456233693CD46));
    do
    {
      do
        unint64_t v16 = (void *)*v16;
      while (v16[1] != 0x1AF456233693CD46);
    }
    while (v16[2] != 0x1AF456233693CD46);
  }
  float v18 = fmaxf(*(float *)(*(void *)(v16[5] + 32) + 3080) + *(float *)(*(void *)(v16[5] + 32) + 3076), 1.0);
  uint64_t v19 = *a7;
  uint64_t v20 = (std::__shared_weak_count *)a7[1];
  float32x4_t v492 = 0uLL;
  if (v19)
  {
    uint64_t v479 = (void (**)(ggl::RenderItem *__hidden))v19;
    *(void *)&long long v480 = v20;
    if (v20) {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v484, v19, (uint64_t)v20);
    if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
      if (BYTE8(v485)) {
        goto LABEL_21;
      }
    }
    else if (BYTE8(v485))
    {
LABEL_21:
      uint64_t v21 = *(void *)(*(void *)v484 + 24);
      if ((int)v18 >= 0x17) {
        unsigned int v22 = 23;
      }
      else {
        unsigned int v22 = (int)v18;
      }
      uint64_t v23 = *(float **)v21;
      if (*(void *)v21
        && (float v24 = *v23, LODWORD(v23) = *v23 == 1.0, *(unsigned char *)(v21 + 10))
        && (v24 != 0.0 ? (_ZF = v24 == 1.0) : (_ZF = 1), !_ZF)
        || (v26 = *(unsigned __int8 *)(v21 + v23 + 11), float v24 = 0.0, v26 == 2))
      {
        LOBYTE(v479) = 1;
        LOBYTE(v477) = 1;
        char v27 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v21, 0x5Bu, v22, 0, &v479);
        char v28 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v21, 0x5Bu, v22, 1, &v477);
        if (v24 < 1.0) {
          char v28 = v27;
        }
        if (v28)
        {
LABEL_35:
          uint64_t v29 = *(void *)(*(void *)v484 + 24);
          uint64_t v30 = *(float **)v29;
          if (*(void *)v29
            && (float v31 = *v30, LODWORD(v30) = *v30 == 1.0, *(unsigned char *)(v29 + 10))
            && (v31 != 0.0 ? (BOOL v32 = v31 == 1.0) : (BOOL v32 = 1), !v32)
            || (v33 = *(unsigned __int8 *)(v29 + v30 + 11), float v31 = 0.0, v33 == 2))
          {
            LOBYTE(v479) = 1;
            LOBYTE(v477) = 1;
            int v34 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v29, 0x68u, v22, 0, &v479);
            int v35 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v29, 0x68u, v22, 1u, &v477);
            if (v31 < 1.0) {
              int v35 = v34;
            }
          }
          else
          {
            int v35 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x68u, v22, v33, 0);
          }
          int v465 = v35;
          unint64_t v40 = *(void *)(*(void *)v484 + 24);
          uint64_t v41 = *(float **)v40;
          if (*(void *)v40
            && (float v42 = *v41, LODWORD(v41) = *v41 == 1.0, *(unsigned char *)(v40 + 10))
            && (v42 != 0.0 ? (BOOL v43 = v42 == 1.0) : (BOOL v43 = 1), !v43)
            || (v44 = *(unsigned __int8 *)(v40 + v41 + 11), float v42 = 0.0, v44 == 2))
          {
            LOBYTE(v479) = 1;
            LOBYTE(v477) = 1;
            unint64_t v45 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v40, 0x6Bu, 0, &v479);
            unint64_t v46 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v40, 0x6Bu, 1u, &v477);
            if (v42 >= 1.0) {
              uint64_t v47 = (unsigned char *)v46;
            }
            else {
              uint64_t v47 = (unsigned char *)v45;
            }
            if (*v47) {
              goto LABEL_65;
            }
          }
          else if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(*(void *)(*(void *)v484 + 24), 0x6Bu, v44, 0))
          {
LABEL_65:
            gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v479, *(void *)(*(void *)v484 + 24), 0x5Du, 2u, fminf(fmaxf(v18, 0.0), 23.0));
LABEL_68:
            float32x4_t v492 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)v479)), (float32x4_t)vdupq_n_s32(0x37800080u));
            unint64_t v48 = *(void *)(*(void *)v484 + 24);
            float v49 = fminf(fmaxf(v18, 0.0), 23.0);
            unsigned int v50 = *(float **)v48;
            if (*(void *)v48
              && (float v51 = *v50, LODWORD(v50) = *v50 == 1.0, *(unsigned char *)(v48 + 10))
              && v51 != 0.0
              && v51 != 1.0
              || (v52 = *(unsigned __int8 *)(v48 + v50 + 11), float v51 = 0.0, v52 == 2))
            {
              LOBYTE(v479) = 1;
              LOBYTE(v477) = 1;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v48, 0x61u, 0, (BOOL *)&v479, v49);
              float v54 = v53;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v48, 0x61u, 1u, (BOOL *)&v477, v49);
              float v37 = v54 + (float)((float)(v55 - v54) * v51);
            }
            else
            {
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)v484 + 24), 0x61u, v52, 0, v49);
              float v37 = v56;
            }
            uint64_t v57 = *(void *)(*(void *)v484 + 24);
            uint64_t v58 = *(float **)v57;
            if (*(void *)v57
              && (float v59 = *v58, LODWORD(v58) = *v58 == 1.0, *(unsigned char *)(v57 + 10))
              && v59 != 0.0
              && v59 != 1.0
              || (v60 = *(unsigned __int8 *)(v57 + v58 + 11), float v59 = 0.0, v60 == 2))
            {
              LOBYTE(v479) = 1;
              LOBYTE(v477) = 1;
              int v61 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v57, 0x13Fu, v22, 0, &v479);
              int v62 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v57, 0x13Fu, v22, 1u, &v477);
              if (v59 >= 1.0) {
                LOBYTE(v38) = v62;
              }
              else {
                LOBYTE(v38) = v61;
              }
            }
            else
            {
              int v38 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x13Fu, v22, v60, 0);
            }
            uint64_t v63 = *(void *)(*(void *)v484 + 24);
            uint64_t v64 = *(float **)v63;
            if (*(void *)v63
              && (float v65 = *v64, LODWORD(v64) = *v64 == 1.0, *(unsigned char *)(v63 + 10))
              && v65 != 0.0
              && v65 != 1.0
              || (v66 = *(unsigned __int8 *)(v63 + v64 + 11), float v65 = 0.0, v66 == 2))
            {
              LOBYTE(v479) = 1;
              LOBYTE(v477) = 1;
              int v67 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v63, 0x8Au, v22, 0, &v479);
              int v68 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v63, 0x8Au, v22, 1u, &v477);
              if (v65 < 1.0) {
                LOBYTE(v68) = v67;
              }
            }
            else
            {
              int v68 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x8Au, v22, v66, 0);
            }
            int v36 = v68 - 1 < 2;
LABEL_94:
            gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v484);
            if (a3[1]) {
              goto LABEL_95;
            }
            goto LABEL_47;
          }
          gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v479, *(void *)(*(void *)v484 + 24), 0x5Du, v22, 2u, 0);
          goto LABEL_68;
        }
      }
      else if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(*(void *)v484 + 24), 0x5Bu, v22, v26, 0))
      {
        goto LABEL_35;
      }
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v484);
      goto LABEL_233;
    }
    int v36 = 0;
    int v465 = 0;
    float v37 = 0.0;
    LOBYTE(v38) = 2;
    goto LABEL_94;
  }
  int v36 = 0;
  int v465 = 0;
  float v37 = 0.0;
  LOBYTE(v38) = 2;
  if (a3[1])
  {
LABEL_95:
    float32x4_t v492 = (float32x4_t)xmmword_1A28FC6C0;
    float v39 = 1.0;
    goto LABEL_96;
  }
LABEL_47:
  float v39 = v492.f32[3];
LABEL_96:
  if (v39 < 0.0039062 || v37 < 0.1) {
    goto LABEL_233;
  }
  float v69 = *(float *)(a2 + 368) * v37;
  uint64_t v479 = &off_1EF55A458;
  *((void *)&v480 + 1) = "draped stroke";
  long long v481 = 0uLL;
  *((void *)&v482 + 1) = 0;
  LODWORD(v482) = 0;
  *(_DWORD *)uint64_t v483 = 1065353216;
  memset(&v483[8], 0, 32);
  *(int64x2_t *)&v483[40] = vdupq_n_s64(1uLL);
  *(void *)&v483[56] = 0;
  int v70 = *(_DWORD *)(a6 + 88);
  if (!v70)
  {
    float v452 = v69;
    uint64_t v449 = *(void *)(a6 + 8);
    char v447 = *(unsigned char *)(a6 + 24);
    v491[0] = *(void *)(a6 + 25);
    *(void *)((char *)v491 + 7) = *(void *)(a6 + 32);
    uint64_t v81 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup>::pop(a5[1]);
    uint64_t v82 = *(void *)(*((void *)v81 + 8) + 48);
    memset(v484, 0, sizeof(v484));
    uint64_t v83 = *(void *)(v82 + 8);
    *(void *)&long long v84 = 0;
    *((void *)&v84 + 1) = v82;
    uint64_t v85 = *(void *)(v82 + 72);
    *(_OWORD *)double v484 = v84;
    *(void *)&long long v485 = v83;
    *(void *)&long long v486 = v85;
    WORD4(v485) = 1;
    *(void *)uint64_t v85 = v492.i64[0];
    *(_DWORD *)(v85 + 8) = v492.i32[2];
    *(float *)(v85 + 12) = v39;
    *(_DWORD *)(v85 + 32) = *a8;
    *(_DWORD *)(v85 + 36) = a8[1];
    *(_DWORD *)(v85 + 40) = a8[2];
    *(_DWORD *)(v85 + 44) = a8[3];
    if (v38 == 2)
    {
      float v87 = 0.5;
      float v86 = 0.5;
    }
    else if (v38 == 1)
    {
      float v86 = 1.0;
      float v87 = 0.0;
    }
    else
    {
      float v86 = 0.0;
      float v87 = 1.0;
    }
    float v88 = -(float)(v452 * v87);
    float v89 = v86 * v452;
    if (a3[1])
    {
      float v89 = 1.0;
      float v88 = -1.0;
    }
    *(float *)(v85 + 16) = v88;
    *(float *)(v85 + 20) = v89;
    md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineState,std::shared_ptr<ggl::ElevatedStrokeColorWithDistanceShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v477, (uint64_t)(a5 + 19), v475 != 0, a3[2]);
    ggl::Flyover::FlyoverPipelineSetup::setState(v81, (uint64_t)v477, v478);
    int v90 = v478;
    if (v478 && !atomic_fetch_add(&v478->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v90->__on_zero_shared)(v90);
      std::__shared_weak_count::__release_weak(v90);
    }
    uint64_t v91 = (void *)*((void *)v81 + 8);
    v91[1] = 0;
    uint64_t v92 = *(void *)(a2 + 216);
    void *v91 = v92;
    unsigned __int8 v93 = (void *)*((void *)v81 + 20);
    uint64_t v94 = *(void *)(a2 + 224);
    if (v94) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v94 + 8), 1uLL, memory_order_relaxed);
    }
    long long v95 = (std::__shared_weak_count *)v93[1];
    void *v93 = v92;
    v93[1] = v94;
    if (v95 && !atomic_fetch_add(&v95->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
      std::__shared_weak_count::__release_weak(v95);
    }
    uint64_t v96 = *((void *)v81 + 8);
    *(void *)(v96 + 24) = 0;
    uint64_t v97 = *(void *)(a2 + 232);
    *(void *)(v96 + 16) = v97;
    uint64_t v98 = *((void *)v81 + 20);
    uint64_t v99 = *(void *)(a2 + 240);
    if (v99) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v99 + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v100 = *(std::__shared_weak_count **)(v98 + 24);
    *(void *)(v98 + 16) = v97;
    *(void *)(v98 + 24) = v99;
    if (v100 && !atomic_fetch_add(&v100->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
      std::__shared_weak_count::__release_weak(v100);
    }
    uint64_t v101 = a5;
    uint64_t v102 = *((void *)v81 + 8);
    *(void *)(v102 + 32) = v475;
    *(void *)(v102 + 40) = 0;
    uint64_t v103 = *((void *)v81 + 20);
    if (v476) {
      atomic_fetch_add_explicit(&v476->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v104 = *(std::__shared_weak_count **)(v103 + 40);
    *(void *)(v103 + 32) = v475;
    *(void *)(v103 + 40) = v476;
    if (v104 && !atomic_fetch_add(&v104->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
      std::__shared_weak_count::__release_weak(v104);
    }
    *((void *)&v481 + 1) = v81;
    if ((void)v486)
    {
      unint64_t v106 = *(void *)&v484[16];
      unint64_t v105 = v485;
      if ((void)v485 != *(void *)&v484[16])
      {
        unint64_t v107 = *(void **)&v484[8];
        int v108 = BYTE8(v485);
        int v109 = BYTE9(v485);
        if (*(void *)v484 && *(unsigned char *)(*(void *)&v484[8] + 17) != 2) {
          (*(void (**)(void))(**(void **)v484 + 64))();
        }
        if (v108 && !v109)
        {
          unint64_t v111 = v107[7];
          unint64_t v110 = v107[8];
          if (v110 == v111) {
            unint64_t v111 = v107[10] - v107[9];
          }
          if (v106 < v111) {
            unint64_t v111 = v106;
          }
          if (v110 <= v105) {
            unint64_t v110 = v105;
          }
          if (v110 == v111) {
            unint64_t v110 = v111 + v107[10] - v107[9];
          }
          v107[7] = v111;
          v107[8] = v110;
        }
      }
    }
    char v112 = 0;
    float v113 = v492.f32[3];
LABEL_184:
    a5 = v101;
    if (v113 >= 1.0)
    {
      uint64_t v144 = md::DaVinciRenderStateCache::renderState((unsigned __int8 **)v101 + 94, 3, 0, (a3[1] | a3[2]) == 0, 0, 1, a3[1], 3);
    }
    else
    {
      uint64_t v141 = v101[99];
      if (!v141) {
        goto LABEL_199;
      }
      uint64_t v142 = v101 + 99;
      do
      {
        while (*(float *)(v141 + 28) < v492.f32[0]
             && *(float *)(v141 + 32) < v492.f32[1]
             && *(float *)(v141 + 36) < v492.f32[2]
             && *(float *)(v141 + 40) < v113)
        {
          uint64_t v141 = *(void *)(v141 + 8);
          if (!v141) {
            goto LABEL_194;
          }
        }
        uint64_t v142 = (uint64_t *)v141;
        uint64_t v141 = *(void *)v141;
      }
      while (v141);
LABEL_194:
      if (v142 != v101 + 99
        && (v492.f32[0] >= *((float *)v142 + 7)
         || v492.f32[1] >= *((float *)v142 + 8)
         || v492.f32[2] >= *((float *)v142 + 9)
         || v113 >= *((float *)v142 + 10)))
      {
        int v143 = *((unsigned __int8 *)v142 + 44);
      }
      else
      {
LABEL_199:
        std::__tree<std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>,std::__map_value_compare<geo::Color<float,4,(geo::ColorSpace)0>,std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>,std::less<geo::Color<float,4,(geo::ColorSpace)0>>,true>,std::allocator<std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>>>::__emplace_unique_key_args<geo::Color<float,4,(geo::ColorSpace)0>,geo::Color<float,4,(geo::ColorSpace)0> const&,unsigned char &>(v101 + 98, v492.f32, &v492, *((unsigned char *)v101 + 808));
        int v143 = *((unsigned __int8 *)v101 + 808);
        *((unsigned char *)v101 + 808) = (v143 + 1) % *((unsigned __int8 *)v101 + 809);
      }
      LODWORD(v482) = a3[4] + v143;
      uint64_t v144 = (uint64_t)(v101 + 64);
    }
    *(void *)&long long v481 = v144;
    *((void *)&v482 + 1) = (v465 << 10) | 1u;
    uint64_t v145 = *(void *)(a4 + 8);
    if (v145)
    {
      uint64_t v146 = a4 + 8;
      do
      {
        int v147 = *(_DWORD *)(v145 + 28);
        BOOL v148 = v147 < v36;
        if (v147 >= v36) {
          uint64_t v149 = (uint64_t *)v145;
        }
        else {
          uint64_t v149 = (uint64_t *)(v145 + 8);
        }
        if (!v148) {
          uint64_t v146 = v145;
        }
        uint64_t v145 = *v149;
      }
      while (*v149);
      if (v146 != a4 + 8 && v36 >= *(_DWORD *)(v146 + 28))
      {
        unsigned int v150 = *(void **)(*((void *)a3 + 1) + 8);
        uint64_t v151 = v150[3];
        uint64_t v152 = v150[4];
        uint64_t v153 = v152 - v151;
        if (v152 == v151) {
          goto LABEL_220;
        }
        uint64_t v154 = 0;
        unint64_t v155 = v153 >> 3;
        while (1)
        {
          uint64_t v156 = *(unsigned __int8 **)(v151 + 8 * v154);
          if (*v156 == *(unsigned __int8 *)(v146 + 32))
          {
            unint64_t v157 = *((void *)v156 + 1);
            uint64_t v158 = v150[15];
            if (v157 < (v150[16] - v158) >> 3) {
              break;
            }
          }
          if (++v154 >= v155) {
            goto LABEL_220;
          }
        }
        uint64_t v159 = *(void *)(v158 + 8 * v157);
        if (!v159) {
LABEL_220:
        }
          uint64_t v160 = 0;
        else {
          uint64_t v160 = *(void *)(*(void *)(v159 + 24) + 8 * *(unsigned __int8 *)(v146 + 33));
        }
        if (v112)
        {
          *(_OWORD *)&v484[8] = v480;
          long long v485 = v481;
          long long v486 = v482;
          long long v490 = *(_OWORD *)&v483[48];
          long long v489 = *(_OWORD *)&v483[32];
          long long v488 = *(_OWORD *)&v483[16];
          *(void *)double v484 = &off_1EF55A458;
          long long v487 = *(_OWORD *)v483;
          uint64_t v161 = (void *)v101[92];
          uint64_t v162 = v161[1];
          if (v162 == v101[93])
          {
            uint64_t v161 = (void *)*v161;
            if (!v161)
            {
              uint64_t v161 = malloc_type_malloc(120 * v162 + 16, 0xB644C221uLL);
              *uint64_t v161 = 0;
              v161[1] = 0;
              *(void *)v101[92] = v161;
            }
            v101[92] = (uint64_t)v161;
            uint64_t v162 = v161[1];
          }
          uint64_t v163 = &v161[15 * v162];
          uint64_t v164 = (uint64_t)(v163 + 2);
          v161[1] = v162 + 1;
          v163[2] = &off_1EF55A458;
          long long v165 = v489;
          long long v166 = v490;
          long long v167 = v488;
          *(_OWORD *)(v163 + 9) = v487;
          long long v168 = *(_OWORD *)&v484[8];
          long long v169 = v485;
          *(_OWORD *)(v163 + 7) = v486;
          *(_OWORD *)(v163 + 5) = v169;
          *(_OWORD *)(v163 + 3) = v168;
          *(_OWORD *)(v163 + 15) = v166;
          *(_OWORD *)(v163 + 13) = v165;
          *(_OWORD *)(v163 + 11) = v167;
          v163[10] = v449;
        }
        else
        {
          *(_OWORD *)&v484[8] = v480;
          long long v485 = v481;
          long long v486 = v482;
          long long v490 = *(_OWORD *)&v483[48];
          long long v489 = *(_OWORD *)&v483[32];
          long long v488 = *(_OWORD *)&v483[16];
          *(void *)double v484 = &off_1EF55A458;
          long long v487 = *(_OWORD *)v483;
          unsigned __int8 v170 = (void *)v101[92];
          uint64_t v171 = v170[1];
          if (v171 == v101[93])
          {
            unsigned __int8 v170 = (void *)*v170;
            if (!v170)
            {
              unsigned __int8 v170 = malloc_type_malloc(120 * v171 + 16, 0xB644C221uLL);
              *unsigned __int8 v170 = 0;
              v170[1] = 0;
              *(void *)v101[92] = v170;
            }
            v101[92] = (uint64_t)v170;
            uint64_t v171 = v170[1];
          }
          uint64_t v172 = &v170[15 * v171];
          uint64_t v164 = (uint64_t)(v172 + 2);
          v170[1] = v171 + 1;
          v172[2] = &off_1EF55A458;
          long long v174 = v489;
          long long v173 = v490;
          long long v175 = v488;
          *(_OWORD *)(v172 + 9) = v487;
          *(_OWORD *)(v172 + 11) = v175;
          *(_OWORD *)(v172 + 13) = v174;
          long long v176 = *(_OWORD *)&v484[8];
          long long v177 = v485;
          *(_OWORD *)(v172 + 7) = v486;
          *(_OWORD *)(v172 + 5) = v177;
          *(_OWORD *)(v172 + 3) = v176;
          *(_OWORD *)(v172 + 15) = v173;
          v172[10] = v449;
          *((unsigned char *)v172 + 88) = v447;
          uint64_t v178 = *(void *)((char *)v491 + 7);
          *(void *)((char *)v172 + 89) = v491[0];
          v172[12] = v178;
          v172[13] = 0;
          v172[14] = 1;
        }
        ggl::CommandBuffer::pushRenderItem(v160, v164);
      }
    }
    goto LABEL_233;
  }
  if (v70 != 1) {
    goto LABEL_596;
  }
  if (*(unsigned char *)(a6 + 32))
  {
    float v451 = v69;
    uint64_t v449 = *(void *)(a6 + 8);
    uint64_t v71 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::ElevatedStrokeColorPipelineSetup>::pop(*a5);
    md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedStrokeColorPipelineState,std::shared_ptr<ggl::ElevatedStrokeColorShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants((std::__shared_weak_count **)v484, (uint64_t)(a5 + 4), v475 != 0);
    ggl::Flyover::FlyoverPipelineSetup::setState(v71, *(uint64_t *)v484, *(std::__shared_weak_count **)&v484[8]);
    uint64_t v72 = *(std::__shared_weak_count **)&v484[8];
    if (*(void *)&v484[8]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v484[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
      std::__shared_weak_count::__release_weak(v72);
    }
    unsigned __int8 v73 = (void *)*((void *)v71 + 8);
    uint64_t v74 = v73[6];
    memset(v484, 0, sizeof(v484));
    uint64_t v75 = *(void *)(v74 + 8);
    *(void *)&long long v76 = 0;
    *((void *)&v76 + 1) = v74;
    uint64_t v77 = *(void *)(v74 + 72);
    *(_OWORD *)double v484 = v76;
    *(void *)&long long v485 = v75;
    *(void *)&long long v486 = v77;
    WORD4(v485) = 1;
    float32_t v78 = v492.f32[3];
    *(float32x4_t *)uint64_t v77 = v492;
    *(_DWORD *)(v77 + 48) = v12;
    float32x2_t v79 = (float32x2_t)*a8;
    *(_DWORD *)(v77 + 32) = v79.i32[0];
    *(_DWORD *)(v77 + 36) = a8[1];
    *(_DWORD *)(v77 + 40) = a8[2];
    *(_DWORD *)(v77 + 44) = a8[3];
    if (!*(unsigned char *)(a6 + 32)) {
      goto LABEL_597;
    }
    v79.i32[0] = *(_DWORD *)(a6 + 24);
    if (v38 == 2)
    {
      float32x2_t v80 = (float32x2_t)0x3F0000003F000000;
    }
    else if (v38 == 1)
    {
      float32x2_t v80 = (float32x2_t)1065353216;
    }
    else
    {
      float32x2_t v80 = (float32x2_t)0x3F80000000000000;
    }
    float32x2_t v114 = vmul_n_f32(v80, v451);
    v115.i32[0] = vsub_f32(v79, v114).u32[0];
    v115.i32[1] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&v79, 0), v114).i32[1];
    v79.f32[0] = *(float *)(a6 + 28) + v79.f32[0];
    float32x2_t v116 = vmaxnm_f32(vdiv_f32(v115, (float32x2_t)vdup_lane_s32((int32x2_t)v79, 0)), 0);
    __asm
    {
      FMOV            V1.2S, #1.0
      FMOV            V4.2S, #-1.0
    }
    *(int8x8_t *)(v77 + 16) = vbsl_s8((int8x8_t)vcgt_f32(v116, _D1), (int8x8_t)_D1, (int8x8_t)vmla_f32(_D4, (float32x2_t)0x4000000040000000, v116));
    v73[1] = 0;
    uint64_t v122 = *(void *)(a2 + 216);
    void *v73 = v122;
    id v123 = (void *)*((void *)v71 + 20);
    uint64_t v124 = *(void *)(a2 + 224);
    if (v124) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v124 + 8), 1uLL, memory_order_relaxed);
    }
    unsigned __int8 v125 = (std::__shared_weak_count *)v123[1];
    *id v123 = v122;
    v123[1] = v124;
    if (v125 && !atomic_fetch_add(&v125->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      float v457 = v78;
      ((void (*)(std::__shared_weak_count *))v125->__on_zero_shared)(v125);
      std::__shared_weak_count::__release_weak(v125);
      float32_t v78 = v457;
    }
    uint64_t v126 = *((void *)v71 + 8);
    *(void *)(v126 + 24) = 0;
    uint64_t v127 = *(void *)(a2 + 232);
    *(void *)(v126 + 16) = v127;
    uint64_t v128 = *((void *)v71 + 20);
    uint64_t v129 = *(void *)(a2 + 240);
    if (v129) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v129 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v130 = *(std::__shared_weak_count **)(v128 + 24);
    *(void *)(v128 + 16) = v127;
    *(void *)(v128 + 24) = v129;
    if (v130 && !atomic_fetch_add(&v130->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      float v458 = v78;
      ((void (*)(std::__shared_weak_count *))v130->__on_zero_shared)(v130);
      std::__shared_weak_count::__release_weak(v130);
      float32_t v78 = v458;
    }
    uint64_t v101 = a5;
    uint64_t v131 = *((void *)v71 + 8);
    *(void *)(v131 + 32) = v475;
    *(void *)(v131 + 40) = 0;
    uint64_t v132 = *((void *)v71 + 20);
    if (v476) {
      atomic_fetch_add_explicit(&v476->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unsigned __int8 v133 = *(std::__shared_weak_count **)(v132 + 40);
    *(void *)(v132 + 32) = v475;
    *(void *)(v132 + 40) = v476;
    if (v133 && !atomic_fetch_add(&v133->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      float v459 = v78;
      ((void (*)(std::__shared_weak_count *))v133->__on_zero_shared)(v133);
      std::__shared_weak_count::__release_weak(v133);
      float32_t v78 = v459;
    }
    *((void *)&v481 + 1) = v71;
    if ((void)v486)
    {
      unint64_t v135 = *(void *)&v484[16];
      unint64_t v134 = v485;
      if ((void)v485 != *(void *)&v484[16])
      {
        unsigned __int8 v136 = *(void **)&v484[8];
        int v137 = BYTE8(v485);
        int v138 = BYTE9(v485);
        if (*(void *)v484 && *(unsigned char *)(*(void *)&v484[8] + 17) != 2)
        {
          float v460 = v78;
          (*(void (**)(void))(**(void **)v484 + 64))();
          float32_t v78 = v460;
        }
        if (v137 && !v138)
        {
          unint64_t v140 = v136[7];
          unint64_t v139 = v136[8];
          if (v139 == v140) {
            unint64_t v140 = v136[10] - v136[9];
          }
          if (v135 < v140) {
            unint64_t v140 = v135;
          }
          if (v139 <= v134) {
            unint64_t v139 = v134;
          }
          if (v139 == v140) {
            unint64_t v139 = v140 + v136[10] - v136[9];
          }
          v136[7] = v140;
          v136[8] = v139;
        }
      }
    }
    char v447 = 0;
    float v113 = v78;
    char v112 = 1;
    goto LABEL_184;
  }
LABEL_233:
  uint64_t v179 = *a7;
  uint64_t v180 = (std::__shared_weak_count *)a7[1];
  float32x4_t v492 = 0uLL;
  if (v179)
  {
    uint64_t v479 = (void (**)(ggl::RenderItem *__hidden))v179;
    *(void *)&long long v480 = v180;
    if (v180) {
      atomic_fetch_add_explicit(&v180->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v484, v179, (uint64_t)v180);
    if (v180 && !atomic_fetch_add(&v180->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v180->__on_zero_shared)(v180);
      std::__shared_weak_count::__release_weak(v180);
      if (BYTE8(v485)) {
        goto LABEL_239;
      }
    }
    else if (BYTE8(v485))
    {
LABEL_239:
      uint64_t v181 = *(void *)(*(void *)v484 + 24);
      if ((int)v18 >= 0x17) {
        unsigned int v182 = 23;
      }
      else {
        unsigned int v182 = (int)v18;
      }
      unsigned __int8 v183 = *(float **)v181;
      if (*(void *)v181
        && (float v184 = *v183, LODWORD(v183) = *v183 == 1.0, *(unsigned char *)(v181 + 10))
        && (v184 != 0.0 ? (BOOL v185 = v184 == 1.0) : (BOOL v185 = 1), !v185)
        || (int v186 = *(unsigned __int8 *)(v181 + v183 + 11), v184 = 0.0, v186 == 2))
      {
        LOBYTE(v479) = 1;
        LOBYTE(v477) = 1;
        char v187 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v181, 0x5Bu, v182, 0, &v479);
        char v188 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v181, 0x5Bu, v182, 1, &v477);
        if (v184 < 1.0) {
          char v188 = v187;
        }
        if (v188)
        {
LABEL_253:
          uint64_t v189 = *(void *)(*(void *)v484 + 24);
          unsigned __int8 v190 = *(float **)v189;
          if (*(void *)v189
            && (float v191 = *v190, LODWORD(v190) = *v190 == 1.0, *(unsigned char *)(v189 + 10))
            && (v191 != 0.0 ? (BOOL v192 = v191 == 1.0) : (BOOL v192 = 1), !v192)
            || (v193 = *(unsigned __int8 *)(v189 + v190 + 11), float v191 = 0.0, v193 == 2))
          {
            LOBYTE(v479) = 1;
            LOBYTE(v477) = 1;
            int v194 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v189, 0x68u, v182, 0, &v479);
            int v195 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v189, 0x68u, v182, 1u, &v477);
            if (v191 < 1.0) {
              int v195 = v194;
            }
          }
          else
          {
            int v195 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x68u, v182, v193, 0);
          }
          int v466 = v195;
          unint64_t v200 = *(void *)(*(void *)v484 + 24);
          unsigned __int8 v201 = *(float **)v200;
          if (*(void *)v200
            && (float v202 = *v201, LODWORD(v201) = *v201 == 1.0, *(unsigned char *)(v200 + 10))
            && (v202 != 0.0 ? (BOOL v203 = v202 == 1.0) : (BOOL v203 = 1), !v203)
            || (v204 = *(unsigned __int8 *)(v200 + v201 + 11), float v202 = 0.0, v204 == 2))
          {
            LOBYTE(v479) = 1;
            LOBYTE(v477) = 1;
            unint64_t v205 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v200, 0x197u, 0, &v479);
            unint64_t v206 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v200, 0x197u, 1u, &v477);
            if (v202 >= 1.0) {
              size_t v207 = (unsigned char *)v206;
            }
            else {
              size_t v207 = (unsigned char *)v205;
            }
            if (*v207) {
              goto LABEL_283;
            }
          }
          else if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(*(void *)(*(void *)v484 + 24), 0x197u, v204, 0))
          {
LABEL_283:
            gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v479, *(void *)(*(void *)v484 + 24), 0x193u, 2u, fminf(fmaxf(v18, 0.0), 23.0));
LABEL_286:
            float32x4_t v492 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)v479)), (float32x4_t)vdupq_n_s32(0x37800080u));
            unint64_t v208 = *(void *)(*(void *)v484 + 24);
            float v209 = fminf(fmaxf(v18, 0.0), 23.0);
            unsigned __int8 v210 = *(float **)v208;
            if (*(void *)v208
              && (float v211 = *v210, LODWORD(v210) = *v210 == 1.0, *(unsigned char *)(v208 + 10))
              && v211 != 0.0
              && v211 != 1.0
              || (v212 = *(unsigned __int8 *)(v208 + v210 + 11), float v211 = 0.0, v212 == 2))
            {
              LOBYTE(v479) = 1;
              LOBYTE(v477) = 1;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v208, 0x194u, 0, (BOOL *)&v479, v209);
              float v214 = v213;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v208, 0x194u, 1u, (BOOL *)&v477, v209);
              float v197 = v214 + (float)((float)(v215 - v214) * v211);
            }
            else
            {
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)v484 + 24), 0x194u, v212, 0, v209);
              float v197 = v216;
            }
            uint64_t v217 = *(void *)(*(void *)v484 + 24);
            uint64_t v218 = *(float **)v217;
            if (*(void *)v217
              && (float v219 = *v218, LODWORD(v218) = *v218 == 1.0, *(unsigned char *)(v217 + 10))
              && v219 != 0.0
              && v219 != 1.0
              || (v220 = *(unsigned __int8 *)(v217 + v218 + 11), float v219 = 0.0, v220 == 2))
            {
              LOBYTE(v479) = 1;
              LOBYTE(v477) = 1;
              int v221 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v217, 0x198u, v182, 0, &v479);
              int v222 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v217, 0x198u, v182, 1u, &v477);
              if (v219 >= 1.0) {
                LOBYTE(v198) = v222;
              }
              else {
                LOBYTE(v198) = v221;
              }
            }
            else
            {
              int v198 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x198u, v182, v220, 0);
            }
            uint64_t v223 = *(void *)(*(void *)v484 + 24);
            uint64_t v224 = *(float **)v223;
            if (*(void *)v223
              && (float v225 = *v224, LODWORD(v224) = *v224 == 1.0, *(unsigned char *)(v223 + 10))
              && v225 != 0.0
              && v225 != 1.0
              || (v226 = *(unsigned __int8 *)(v223 + v224 + 11), float v225 = 0.0, v226 == 2))
            {
              LOBYTE(v479) = 1;
              LOBYTE(v477) = 1;
              int v227 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v223, 0x8Au, v182, 0, &v479);
              int v228 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v223, 0x8Au, v182, 1u, &v477);
              if (v225 < 1.0) {
                LOBYTE(v228) = v227;
              }
            }
            else
            {
              int v228 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x8Au, v182, v226, 0);
            }
            int v196 = v228 - 1 < 2;
LABEL_312:
            gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v484);
            if (a3[1]) {
              goto LABEL_313;
            }
            goto LABEL_265;
          }
          gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v479, *(void *)(*(void *)v484 + 24), 0x193u, v182, 2u, 0);
          goto LABEL_286;
        }
      }
      else if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(*(void *)v484 + 24), 0x5Bu, v182, v186, 0))
      {
        goto LABEL_253;
      }
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v484);
      goto LABEL_453;
    }
    int v196 = 0;
    int v466 = 0;
    float v197 = 0.0;
    LOBYTE(v198) = 2;
    goto LABEL_312;
  }
  int v196 = 0;
  int v466 = 0;
  float v197 = 0.0;
  LOBYTE(v198) = 2;
  if (a3[1])
  {
LABEL_313:
    float32x4_t v492 = (float32x4_t)xmmword_1A28FC6C0;
    float v199 = 1.0;
    goto LABEL_314;
  }
LABEL_265:
  float v199 = v492.f32[3];
LABEL_314:
  if (v199 < 0.0039062 || v197 < 0.1) {
    goto LABEL_453;
  }
  float v229 = *(float *)(a2 + 368) * v197;
  uint64_t v479 = &off_1EF55A458;
  *((void *)&v480 + 1) = "draped stroke";
  long long v481 = 0uLL;
  *((void *)&v482 + 1) = 0;
  LODWORD(v482) = 0;
  *(_DWORD *)uint64_t v483 = 1065353216;
  memset(&v483[8], 0, 32);
  *(int64x2_t *)&v483[40] = vdupq_n_s64(1uLL);
  *(void *)&v483[56] = 0;
  int v230 = *(_DWORD *)(a6 + 88);
  if (!v230)
  {
    float v454 = v229;
    uint64_t v450 = *(void *)(a6 + 8);
    char v448 = *(unsigned char *)(a6 + 24);
    v491[0] = *(void *)(a6 + 25);
    *(void *)((char *)v491 + 7) = *(void *)(a6 + 32);
    uint64_t v241 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup>::pop(a5[1]);
    uint64_t v242 = *(void *)(*((void *)v241 + 8) + 48);
    memset(v484, 0, sizeof(v484));
    uint64_t v243 = *(void *)(v242 + 8);
    *(void *)&long long v244 = 0;
    *((void *)&v244 + 1) = v242;
    uint64_t v245 = *(void *)(v242 + 72);
    *(_OWORD *)double v484 = v244;
    *(void *)&long long v485 = v243;
    *(void *)&long long v486 = v245;
    WORD4(v485) = 1;
    *(void *)uint64_t v245 = v492.i64[0];
    *(_DWORD *)(v245 + 8) = v492.i32[2];
    *(float *)(v245 + 12) = v199;
    *(_DWORD *)(v245 + 32) = *a8;
    *(_DWORD *)(v245 + 36) = a8[1];
    *(_DWORD *)(v245 + 40) = a8[2];
    *(_DWORD *)(v245 + 44) = a8[3];
    if (v198 == 2)
    {
      float v248 = 0.5;
      float v247 = 0.5;
      float v246 = v454;
    }
    else
    {
      float v246 = v454;
      if (v198 == 1)
      {
        float v247 = 1.0;
        float v248 = 0.0;
      }
      else
      {
        float v247 = 0.0;
        float v248 = 1.0;
      }
    }
    float v249 = -(float)(v246 * v248);
    float v250 = v247 * v246;
    if (a3[1])
    {
      float v250 = 1.0;
      float v249 = -1.0;
    }
    *(float *)(v245 + 16) = v249;
    *(float *)(v245 + 20) = v250;
    md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineState,std::shared_ptr<ggl::ElevatedStrokeColorWithDistanceShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(&v477, (uint64_t)(a5 + 19), v475 != 0, a3[2]);
    ggl::Flyover::FlyoverPipelineSetup::setState(v241, (uint64_t)v477, v478);
    unsigned __int8 v251 = v478;
    if (v478 && !atomic_fetch_add(&v478->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v251->__on_zero_shared)(v251);
      std::__shared_weak_count::__release_weak(v251);
    }
    uint64_t v252 = (void *)*((void *)v241 + 8);
    v252[1] = 0;
    uint64_t v253 = *(void *)(a2 + 216);
    *uint64_t v252 = v253;
    uint64_t v254 = (void *)*((void *)v241 + 20);
    uint64_t v255 = *(void *)(a2 + 224);
    if (v255) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v255 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v256 = (std::__shared_weak_count *)v254[1];
    *uint64_t v254 = v253;
    v254[1] = v255;
    if (v256 && !atomic_fetch_add(&v256->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v256->__on_zero_shared)(v256);
      std::__shared_weak_count::__release_weak(v256);
    }
    uint64_t v257 = *((void *)v241 + 8);
    *(void *)(v257 + 24) = 0;
    uint64_t v258 = *(void *)(a2 + 232);
    *(void *)(v257 + 16) = v258;
    uint64_t v259 = *((void *)v241 + 20);
    uint64_t v260 = *(void *)(a2 + 240);
    if (v260) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v260 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v261 = *(std::__shared_weak_count **)(v259 + 24);
    *(void *)(v259 + 16) = v258;
    *(void *)(v259 + 24) = v260;
    if (v261 && !atomic_fetch_add(&v261->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v261->__on_zero_shared)(v261);
      std::__shared_weak_count::__release_weak(v261);
    }
    uint64_t v262 = *((void *)v241 + 8);
    *(void *)(v262 + 32) = v475;
    *(void *)(v262 + 40) = 0;
    uint64_t v263 = *((void *)v241 + 20);
    if (v476) {
      atomic_fetch_add_explicit(&v476->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v264 = a5;
    uint64_t v265 = *(std::__shared_weak_count **)(v263 + 40);
    *(void *)(v263 + 32) = v475;
    *(void *)(v263 + 40) = v476;
    if (v265 && !atomic_fetch_add(&v265->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v265->__on_zero_shared)(v265);
      std::__shared_weak_count::__release_weak(v265);
    }
    *((void *)&v481 + 1) = v241;
    if ((void)v486)
    {
      unint64_t v267 = *(void *)&v484[16];
      unint64_t v266 = v485;
      if ((void)v485 != *(void *)&v484[16])
      {
        uint64_t v268 = *(void **)&v484[8];
        int v269 = BYTE8(v485);
        int v270 = BYTE9(v485);
        if (*(void *)v484 && *(unsigned char *)(*(void *)&v484[8] + 17) != 2) {
          (*(void (**)(void))(**(void **)v484 + 64))();
        }
        if (v269 && !v270)
        {
          unint64_t v272 = v268[7];
          unint64_t v271 = v268[8];
          if (v271 == v272) {
            unint64_t v272 = v268[10] - v268[9];
          }
          if (v267 < v272) {
            unint64_t v272 = v267;
          }
          if (v271 <= v266) {
            unint64_t v271 = v266;
          }
          if (v271 == v272) {
            unint64_t v271 = v272 + v268[10] - v268[9];
          }
          v268[7] = v272;
          v268[8] = v271;
        }
      }
    }
    char v273 = 0;
    float v274 = v492.f32[3];
    goto LABEL_402;
  }
  if (v230 != 1)
  {
LABEL_596:
    std::__throw_bad_variant_access[abi:nn180100]();
LABEL_598:
    __break(1u);
    return;
  }
  if (!*(unsigned char *)(a6 + 64)) {
    goto LABEL_453;
  }
  float v453 = v229;
  uint64_t v450 = *(void *)(a6 + 40);
  uint64_t v231 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::ElevatedStrokeColorPipelineSetup>::pop(*a5);
  md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedStrokeColorPipelineState,std::shared_ptr<ggl::ElevatedStrokeColorShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants((std::__shared_weak_count **)v484, (uint64_t)(a5 + 4), v475 != 0);
  ggl::Flyover::FlyoverPipelineSetup::setState(v231, *(uint64_t *)v484, *(std::__shared_weak_count **)&v484[8]);
  uint64_t v232 = *(std::__shared_weak_count **)&v484[8];
  if (*(void *)&v484[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v484[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v232->__on_zero_shared)(v232);
    std::__shared_weak_count::__release_weak(v232);
  }
  uint64_t v233 = (void *)*((void *)v231 + 8);
  uint64_t v234 = v233[6];
  memset(v484, 0, sizeof(v484));
  uint64_t v235 = *(void *)(v234 + 8);
  *(void *)&long long v236 = 0;
  *((void *)&v236 + 1) = v234;
  uint64_t v237 = *(void *)(v234 + 72);
  *(_OWORD *)double v484 = v236;
  *(void *)&long long v485 = v235;
  *(void *)&long long v486 = v237;
  WORD4(v485) = 1;
  float32_t v238 = v492.f32[3];
  *(float32x4_t *)uint64_t v237 = v492;
  *(_DWORD *)(v237 + 48) = v12;
  float32x2_t v239 = (float32x2_t)*a8;
  *(_DWORD *)(v237 + 32) = v239.i32[0];
  *(_DWORD *)(v237 + 36) = a8[1];
  *(_DWORD *)(v237 + 40) = a8[2];
  *(_DWORD *)(v237 + 44) = a8[3];
  if (!*(unsigned char *)(a6 + 64))
  {
LABEL_597:
    std::__throw_bad_optional_access[abi:nn180100]();
    goto LABEL_598;
  }
  v239.i32[0] = *(_DWORD *)(a6 + 56);
  if (v198 == 2)
  {
    float32x2_t v240 = (float32x2_t)0x3F0000003F000000;
  }
  else if (v198 == 1)
  {
    float32x2_t v240 = (float32x2_t)1065353216;
  }
  else
  {
    float32x2_t v240 = (float32x2_t)0x3F80000000000000;
  }
  float32x2_t v275 = vmul_n_f32(v240, v453);
  v276.i32[0] = vsub_f32(v239, v275).u32[0];
  v276.i32[1] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&v239, 0), v275).i32[1];
  v239.f32[0] = *(float *)(a6 + 60) + v239.f32[0];
  float32x2_t v277 = vmaxnm_f32(vdiv_f32(v276, (float32x2_t)vdup_lane_s32((int32x2_t)v239, 0)), 0);
  __asm
  {
    FMOV            V1.2S, #1.0
    FMOV            V4.2S, #-1.0
  }
  *(int8x8_t *)(v237 + 16) = vbsl_s8((int8x8_t)vcgt_f32(v277, _D1), (int8x8_t)_D1, (int8x8_t)vmla_f32(_D4, (float32x2_t)0x4000000040000000, v277));
  v233[1] = 0;
  uint64_t v280 = *(void *)(a2 + 216);
  *uint64_t v233 = v280;
  uint64_t v281 = (void *)*((void *)v231 + 20);
  uint64_t v282 = *(void *)(a2 + 224);
  if (v282) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v282 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v283 = (std::__shared_weak_count *)v281[1];
  *uint64_t v281 = v280;
  v281[1] = v282;
  if (v283 && !atomic_fetch_add(&v283->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    float v461 = v238;
    ((void (*)(std::__shared_weak_count *))v283->__on_zero_shared)(v283);
    std::__shared_weak_count::__release_weak(v283);
    float32_t v238 = v461;
  }
  uint64_t v284 = *((void *)v231 + 8);
  *(void *)(v284 + 24) = 0;
  uint64_t v285 = *(void *)(a2 + 232);
  *(void *)(v284 + 16) = v285;
  uint64_t v286 = *((void *)v231 + 20);
  uint64_t v287 = *(void *)(a2 + 240);
  if (v287) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v287 + 8), 1uLL, memory_order_relaxed);
  }
  unsigned __int8 v288 = *(std::__shared_weak_count **)(v286 + 24);
  *(void *)(v286 + 16) = v285;
  *(void *)(v286 + 24) = v287;
  if (v288 && !atomic_fetch_add(&v288->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    float v462 = v238;
    ((void (*)(std::__shared_weak_count *))v288->__on_zero_shared)(v288);
    std::__shared_weak_count::__release_weak(v288);
    float32_t v238 = v462;
  }
  uint64_t v289 = *((void *)v231 + 8);
  *(void *)(v289 + 32) = v475;
  *(void *)(v289 + 40) = 0;
  uint64_t v290 = *((void *)v231 + 20);
  if (v476) {
    atomic_fetch_add_explicit(&v476->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v264 = a5;
  uint64_t v291 = *(std::__shared_weak_count **)(v290 + 40);
  *(void *)(v290 + 32) = v475;
  *(void *)(v290 + 40) = v476;
  if (v291 && !atomic_fetch_add(&v291->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    float v463 = v238;
    ((void (*)(std::__shared_weak_count *))v291->__on_zero_shared)(v291);
    std::__shared_weak_count::__release_weak(v291);
    float32_t v238 = v463;
  }
  *((void *)&v481 + 1) = v231;
  if ((void)v486)
  {
    unint64_t v293 = *(void *)&v484[16];
    unint64_t v292 = v485;
    if ((void)v485 != *(void *)&v484[16])
    {
      uint64_t v294 = *(void **)&v484[8];
      int v295 = BYTE8(v485);
      int v296 = BYTE9(v485);
      if (*(void *)v484 && *(unsigned char *)(*(void *)&v484[8] + 17) != 2)
      {
        float v464 = v238;
        (*(void (**)(void))(**(void **)v484 + 64))();
        float32_t v238 = v464;
      }
      if (v295 && !v296)
      {
        unint64_t v298 = v294[7];
        unint64_t v297 = v294[8];
        if (v297 == v298) {
          unint64_t v298 = v294[10] - v294[9];
        }
        if (v293 < v298) {
          unint64_t v298 = v293;
        }
        if (v297 <= v292) {
          unint64_t v297 = v292;
        }
        if (v297 == v298) {
          unint64_t v297 = v298 + v294[10] - v294[9];
        }
        v294[7] = v298;
        v294[8] = v297;
      }
    }
  }
  char v448 = 0;
  float v274 = v238;
  char v273 = 1;
LABEL_402:
  a5 = v264;
  if (v274 >= 1.0)
  {
    uint64_t v302 = md::DaVinciRenderStateCache::renderState((unsigned __int8 **)v264 + 94, 3, 0, (a3[1] | a3[2]) == 0, 0, 1, a3[1], 3);
  }
  else
  {
    uint64_t v299 = v264[99];
    if (!v299) {
      goto LABEL_417;
    }
    uint64_t v300 = v264 + 99;
    do
    {
      while (*(float *)(v299 + 28) < v492.f32[0]
           && *(float *)(v299 + 32) < v492.f32[1]
           && *(float *)(v299 + 36) < v492.f32[2]
           && *(float *)(v299 + 40) < v274)
      {
        uint64_t v299 = *(void *)(v299 + 8);
        if (!v299) {
          goto LABEL_412;
        }
      }
      uint64_t v300 = (uint64_t *)v299;
      uint64_t v299 = *(void *)v299;
    }
    while (v299);
LABEL_412:
    if (v300 != v264 + 99
      && (v492.f32[0] >= *((float *)v300 + 7)
       || v492.f32[1] >= *((float *)v300 + 8)
       || v492.f32[2] >= *((float *)v300 + 9)
       || v274 >= *((float *)v300 + 10)))
    {
      int v301 = *((unsigned __int8 *)v300 + 44);
    }
    else
    {
LABEL_417:
      std::__tree<std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>,std::__map_value_compare<geo::Color<float,4,(geo::ColorSpace)0>,std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>,std::less<geo::Color<float,4,(geo::ColorSpace)0>>,true>,std::allocator<std::__value_type<geo::Color<float,4,(geo::ColorSpace)0>,unsigned char>>>::__emplace_unique_key_args<geo::Color<float,4,(geo::ColorSpace)0>,geo::Color<float,4,(geo::ColorSpace)0> const&,unsigned char &>(v264 + 98, v492.f32, &v492, *((unsigned char *)v264 + 808));
      int v301 = *((unsigned __int8 *)v264 + 808);
      *((unsigned char *)v264 + 808) = (v301 + 1) % *((unsigned __int8 *)v264 + 809);
    }
    LODWORD(v482) = a3[4] + v301;
    uint64_t v302 = (uint64_t)(v264 + 64);
  }
  *(void *)&long long v481 = v302;
  *((void *)&v482 + 1) = (v466 << 10) | 3u;
  uint64_t v303 = *(void *)(a4 + 8);
  if (v303)
  {
    uint64_t v304 = a4 + 8;
    do
    {
      int v305 = *(_DWORD *)(v303 + 28);
      BOOL v306 = v305 < v196;
      if (v305 >= v196) {
        uint64_t v307 = (uint64_t *)v303;
      }
      else {
        uint64_t v307 = (uint64_t *)(v303 + 8);
      }
      if (!v306) {
        uint64_t v304 = v303;
      }
      uint64_t v303 = *v307;
    }
    while (*v307);
    if (v304 != a4 + 8 && v196 >= *(_DWORD *)(v304 + 28))
    {
      uint64_t v308 = *(void **)(*((void *)a3 + 1) + 8);
      uint64_t v309 = v308[3];
      uint64_t v310 = v308[4];
      uint64_t v311 = v310 - v309;
      if (v310 == v309) {
        goto LABEL_438;
      }
      uint64_t v312 = 0;
      unint64_t v313 = v311 >> 3;
      while (1)
      {
        double v314 = *(unsigned __int8 **)(v309 + 8 * v312);
        if (*v314 == *(unsigned __int8 *)(v304 + 32))
        {
          unint64_t v315 = *((void *)v314 + 1);
          uint64_t v316 = v308[15];
          if (v315 < (v308[16] - v316) >> 3) {
            break;
          }
        }
        if (++v312 >= v313) {
          goto LABEL_438;
        }
      }
      uint64_t v317 = *(void *)(v316 + 8 * v315);
      if (!v317) {
LABEL_438:
      }
        uint64_t v318 = 0;
      else {
        uint64_t v318 = *(void *)(*(void *)(v317 + 24) + 8 * *(unsigned __int8 *)(v304 + 33));
      }
      if (v273)
      {
        *(_OWORD *)&v484[8] = v480;
        long long v485 = v481;
        long long v486 = v482;
        long long v490 = *(_OWORD *)&v483[48];
        long long v489 = *(_OWORD *)&v483[32];
        long long v488 = *(_OWORD *)&v483[16];
        *(void *)double v484 = &off_1EF55A458;
        long long v487 = *(_OWORD *)v483;
        double v319 = (void *)v264[92];
        uint64_t v320 = v319[1];
        if (v320 == v264[93])
        {
          double v319 = (void *)*v319;
          uint64_t v321 = v450;
          if (!v319)
          {
            double v319 = malloc_type_malloc(120 * v320 + 16, 0xB644C221uLL);
            *double v319 = 0;
            v319[1] = 0;
            *(void *)v264[92] = v319;
          }
          v264[92] = (uint64_t)v319;
          uint64_t v320 = v319[1];
        }
        else
        {
          uint64_t v321 = v450;
        }
        uint16x4_t v325 = &v319[15 * v320];
        uint64_t v326 = (uint64_t)(v325 + 2);
        v319[1] = v320 + 1;
        v325[2] = &off_1EF55A458;
        long long v327 = v489;
        long long v328 = v490;
        long long v329 = v488;
        *(_OWORD *)(v325 + 9) = v487;
        long long v330 = *(_OWORD *)&v484[8];
        long long v331 = v485;
        *(_OWORD *)(v325 + 7) = v486;
        *(_OWORD *)(v325 + 5) = v331;
        *(_OWORD *)(v325 + 3) = v330;
        *(_OWORD *)(v325 + 15) = v328;
        *(_OWORD *)(v325 + 13) = v327;
        *(_OWORD *)(v325 + 11) = v329;
        v325[10] = v321;
      }
      else
      {
        *(_OWORD *)&v484[8] = v480;
        long long v485 = v481;
        long long v486 = v482;
        long long v490 = *(_OWORD *)&v483[48];
        long long v489 = *(_OWORD *)&v483[32];
        long long v488 = *(_OWORD *)&v483[16];
        *(void *)double v484 = &off_1EF55A458;
        long long v487 = *(_OWORD *)v483;
        __n128 v322 = (void *)v264[92];
        uint64_t v323 = v322[1];
        if (v323 == v264[93])
        {
          __n128 v322 = (void *)*v322;
          uint64_t v324 = v450;
          if (!v322)
          {
            __n128 v322 = malloc_type_malloc(120 * v323 + 16, 0xB644C221uLL);
            *__n128 v322 = 0;
            v322[1] = 0;
            *(void *)v264[92] = v322;
          }
          v264[92] = (uint64_t)v322;
          uint64_t v323 = v322[1];
        }
        else
        {
          uint64_t v324 = v450;
        }
        long double v332 = &v322[15 * v323];
        uint64_t v326 = (uint64_t)(v332 + 2);
        v322[1] = v323 + 1;
        v332[2] = &off_1EF55A458;
        long long v334 = v489;
        long long v333 = v490;
        long long v335 = v488;
        *(_OWORD *)(v332 + 9) = v487;
        *(_OWORD *)(v332 + 11) = v335;
        *(_OWORD *)(v332 + 13) = v334;
        long long v336 = *(_OWORD *)&v484[8];
        long long v337 = v485;
        *(_OWORD *)(v332 + 7) = v486;
        *(_OWORD *)(v332 + 5) = v337;
        *(_OWORD *)(v332 + 3) = v336;
        *(_OWORD *)(v332 + 15) = v333;
        v332[10] = v324;
        *((unsigned char *)v332 + 88) = v448;
        uint64_t v338 = *(void *)((char *)v491 + 7);
        *(void *)((char *)v332 + 89) = v491[0];
        v332[12] = v338;
        v332[13] = 0;
        v332[14] = 1;
      }
      ggl::CommandBuffer::pushRenderItem(v318, v326);
    }
  }
LABEL_453:
  uint64_t v339 = *a7;
  if (!*a7)
  {
    if (!*a3) {
      goto LABEL_592;
    }
    int v354 = 0;
    int v356 = 0;
    goto LABEL_516;
  }
  uint64_t v340 = (std::__shared_weak_count *)a7[1];
  uint64_t v479 = (void (**)(ggl::RenderItem *__hidden))v339;
  *(void *)&long long v480 = v340;
  if (v340) {
    atomic_fetch_add_explicit(&v340->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v484, v339, (uint64_t)v340);
  if (v340 && !atomic_fetch_add(&v340->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v340->__on_zero_shared)(v340);
    std::__shared_weak_count::__release_weak(v340);
    if (BYTE8(v485)) {
      goto LABEL_459;
    }
LABEL_486:
    int v356 = 0;
    int v354 = 0;
    int8x16_t v467 = 0u;
    goto LABEL_515;
  }
  if (!BYTE8(v485)) {
    goto LABEL_486;
  }
LABEL_459:
  uint64_t v341 = *(void *)(*(void *)v484 + 24);
  if ((int)v18 >= 0x17) {
    unsigned int v342 = 23;
  }
  else {
    unsigned int v342 = (int)v18;
  }
  uint64_t v343 = *(float **)v341;
  if (!*(void *)v341
    || (float v344 = *v343, LODWORD(v343) = *v343 == 1.0, !*(unsigned char *)(v341 + 10))
    || (v344 != 0.0 ? (BOOL v345 = v344 == 1.0) : (BOOL v345 = 1), v345))
  {
    int v346 = *(unsigned __int8 *)(v341 + v343 + 11);
    float v344 = 0.0;
    if (v346 != 2)
    {
      if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(*(void *)v484 + 24), 0x5Bu, v342, v346, 0))goto LABEL_473; {
LABEL_488:
      }
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v484);
      goto LABEL_592;
    }
  }
  LOBYTE(v479) = 1;
  v492.i8[0] = 1;
  char v347 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v341, 0x5Bu, v342, 0, &v479);
  char v348 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v341, 0x5Bu, v342, 1, &v492);
  if (v344 < 1.0) {
    char v348 = v347;
  }
  if (!v348) {
    goto LABEL_488;
  }
LABEL_473:
  uint64_t v349 = *(void *)(*(void *)v484 + 24);
  uint64_t v350 = *(float **)v349;
  if (*(void *)v349
    && (float v351 = *v350, LODWORD(v350) = *v350 == 1.0, *(unsigned char *)(v349 + 10))
    && (v351 != 0.0 ? (BOOL v352 = v351 == 1.0) : (BOOL v352 = 1), !v352)
    || (v353 = *(unsigned __int8 *)(v349 + v350 + 11), float v351 = 0.0, v353 == 2))
  {
    LOBYTE(v479) = 1;
    v492.i8[0] = 1;
    int v354 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v349, 0x68u, v342, 0, &v479);
    int v355 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v349, 0x68u, v342, 1u, &v492);
    if (v351 >= 1.0) {
      int v354 = v355;
    }
  }
  else
  {
    int v354 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x68u, v342, v353, 0);
  }
  unint64_t v357 = *(void *)(*(void *)v484 + 24);
  uint64_t v358 = *(float **)v357;
  if (*(void *)v357
    && (float v359 = *v358, LODWORD(v358) = *v358 == 1.0, *(unsigned char *)(v357 + 10))
    && (v359 != 0.0 ? (BOOL v360 = v359 == 1.0) : (BOOL v360 = 1), !v360)
    || (v361 = *(unsigned __int8 *)(v357 + v358 + 11), float v359 = 0.0, v361 == 2))
  {
    LOBYTE(v479) = 1;
    v492.i8[0] = 1;
    unint64_t v362 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v357, 0x6Cu, 0, &v479);
    unint64_t v363 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(v357, 0x6Cu, 1u, &v492);
    if (v359 >= 1.0) {
      uint64_t v364 = (unsigned char *)v363;
    }
    else {
      uint64_t v364 = (unsigned char *)v362;
    }
    if (*v364) {
      goto LABEL_502;
    }
LABEL_504:
    gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v479, *(void *)(*(void *)v484 + 24), 0x5Cu, v342, 2u, 0);
    goto LABEL_505;
  }
  if (!*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<BOOL>(*(void *)(*(void *)v484 + 24), 0x6Cu, v361, 0))goto LABEL_504; {
LABEL_502:
  }
  gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v479, *(void *)(*(void *)v484 + 24), 0x5Cu, 2u, fminf(fmaxf(v18, 0.0), 23.0));
LABEL_505:
  uint64_t v365 = v479;
  uint64_t v366 = *(void *)(*(void *)v484 + 24);
  long double v367 = *(float **)v366;
  if (*(void *)v366
    && (float v368 = *v367, LODWORD(v367) = *v367 == 1.0, *(unsigned char *)(v366 + 10))
    && v368 != 0.0
    && v368 != 1.0
    || (v369 = *(unsigned __int8 *)(v366 + v367 + 11), float v368 = 0.0, v369 == 2))
  {
    LOBYTE(v479) = 1;
    v492.i8[0] = 1;
    int v370 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v366, 0x8Au, v342, 0, &v479);
    int v371 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v366, 0x8Au, v342, 1u, &v492);
    if (v368 < 1.0) {
      LOBYTE(v371) = v370;
    }
  }
  else
  {
    int v371 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)v484 + 24), 0x8Au, v342, v369, 0);
  }
  int8x16_t v467 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)v365)), (float32x4_t)vdupq_n_s32(0x37800080u));
  int v356 = v371 - 1 < 2;
LABEL_515:
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v484);
  if (*a3)
  {
LABEL_516:
    uint64_t v372 = 0x3F80000000000000;
    unint64_t v373 = 0x3F80000000000000;
    goto LABEL_517;
  }
  uint64_t v372 = v467.i64[0];
  if (*(float *)&v467.i32[3] < 0.0039062) {
    goto LABEL_592;
  }
  unint64_t v373 = vextq_s8(v467, v467, 8uLL).u64[0];
LABEL_517:
  uint64_t v479 = &off_1EF55A458;
  *((void *)&v480 + 1) = "draped fill";
  long long v481 = 0uLL;
  *((void *)&v482 + 1) = 0;
  LODWORD(v482) = 0;
  *(_DWORD *)uint64_t v483 = 1065353216;
  memset(&v483[8], 0, 32);
  *(int64x2_t *)&v483[40] = vdupq_n_s64(1uLL);
  *(void *)&v483[56] = 0;
  int v374 = *(_DWORD *)(a6 + 88);
  if (v374)
  {
    if (v374 == 1)
    {
      uint64_t v375 = *(void *)(a6 + 72);
      if (v375)
      {
        unint64_t v455 = v373;
        uint64_t v468 = v372;
        long long v376 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::ElevatedFillColorPipelineSetup>::pop(a5[2]);
        md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedFillColorPipelineState,std::shared_ptr<ggl::ElevatedFillNoWidthClipColorShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants((std::__shared_weak_count **)v484, (uint64_t)(a5 + 34), v475 != 0);
        uint64_t v377 = a5;
        ggl::Flyover::FlyoverPipelineSetup::setState(v376, *(uint64_t *)v484, *(std::__shared_weak_count **)&v484[8]);
        double v378 = *(std::__shared_weak_count **)&v484[8];
        if (*(void *)&v484[8]
          && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v484[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v378->__on_zero_shared)(v378);
          std::__shared_weak_count::__release_weak(v378);
        }
        unint64_t v379 = (void *)*((void *)v376 + 8);
        unint64_t v380 = (void *)v379[4];
        unint64_t v381 = v380[1];
        uint64_t v382 = v380[9];
        *(void *)uint64_t v382 = v468;
        *(void *)(v382 + 8) = v455;
        *(_DWORD *)(v382 + 32) = v12;
        *(_DWORD *)(v382 + 16) = *a8;
        *(_DWORD *)(v382 + 20) = a8[1];
        *(_DWORD *)(v382 + 24) = a8[2];
        *(_DWORD *)(v382 + 28) = a8[3];
        v379[1] = 0;
        uint64_t v383 = *(void *)(a2 + 216);
        *unint64_t v379 = v383;
        long double v384 = (void *)*((void *)v376 + 20);
        uint64_t v385 = *(void *)(a2 + 224);
        if (v385) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v385 + 8), 1uLL, memory_order_relaxed);
        }
        long long v386 = (std::__shared_weak_count *)v384[1];
        *long double v384 = v383;
        v384[1] = v385;
        if (v386 && !atomic_fetch_add(&v386->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v386->__on_zero_shared)(v386);
          std::__shared_weak_count::__release_weak(v386);
        }
        uint64_t v387 = *((void *)v376 + 8);
        *(void *)(v387 + 24) = 0;
        uint64_t v388 = *(void *)(a2 + 232);
        *(void *)(v387 + 16) = v388;
        uint64_t v389 = *((void *)v376 + 20);
        uint64_t v390 = *(void *)(a2 + 240);
        if (v390) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v390 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v391 = *(std::__shared_weak_count **)(v389 + 24);
        *(void *)(v389 + 16) = v388;
        *(void *)(v389 + 24) = v390;
        if (v391 && !atomic_fetch_add(&v391->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v391->__on_zero_shared)(v391);
          std::__shared_weak_count::__release_weak(v391);
        }
        uint64_t v392 = *((void *)v376 + 8);
        *(void *)(v392 + 48) = v475;
        *(void *)(v392 + 56) = 0;
        uint64_t v393 = *((void *)v376 + 20);
        if (v476) {
          atomic_fetch_add_explicit(&v476->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v394 = *(std::__shared_weak_count **)(v393 + 56);
        *(void *)(v393 + 48) = v475;
        *(void *)(v393 + 56) = v476;
        if (v394)
        {
          char v474 = 0;
          char v395 = 1;
          if (atomic_fetch_add(&v394->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_560;
          }
          goto LABEL_556;
        }
        char v474 = 0;
        char v395 = 1;
        goto LABEL_560;
      }
      goto LABEL_592;
    }
    goto LABEL_596;
  }
  if (*(unsigned char *)(a6 + 40))
  {
    unint64_t v456 = v373;
    uint64_t v469 = v372;
    uint64_t v375 = *(void *)(a6 + 8);
    char v396 = *(unsigned char *)(a6 + 24);
    v492.i64[0] = *(void *)(a6 + 25);
    *(uint64_t *)((char *)v492.i64 + 7) = *(void *)(a6 + 32);
    long long v376 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::ElevatedFillColorWithDistancePipelineSetup>::pop(a5[3]);
    char v474 = v396;
    md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedFillColorWithDistancePipelineState,std::shared_ptr<ggl::ElevatedFillColorShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants((std::__shared_weak_count **)v484, (uint64_t)(a5 + 49), v475 != 0);
    uint64_t v377 = a5;
    ggl::Flyover::FlyoverPipelineSetup::setState(v376, *(uint64_t *)v484, *(std::__shared_weak_count **)&v484[8]);
    uint64_t v397 = *(std::__shared_weak_count **)&v484[8];
    if (*(void *)&v484[8]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v484[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v397->__on_zero_shared)(v397);
      std::__shared_weak_count::__release_weak(v397);
    }
    double v398 = (void *)*((void *)v376 + 8);
    unint64_t v380 = (void *)v398[4];
    unint64_t v381 = v380[1];
    uint64_t v399 = v380[9];
    *(void *)&long long v400 = v469;
    *((void *)&v400 + 1) = v456;
    *(_OWORD *)uint64_t v399 = v400;
    *(_DWORD *)(v399 + 16) = *a8;
    *(_DWORD *)(v399 + 20) = a8[1];
    *(_DWORD *)(v399 + 24) = a8[2];
    *(_DWORD *)(v399 + 28) = a8[3];
    v398[1] = 0;
    uint64_t v401 = *(void *)(a2 + 216);
    *double v398 = v401;
    uint64_t v402 = (void *)*((void *)v376 + 20);
    uint64_t v403 = *(void *)(a2 + 224);
    if (v403) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v403 + 8), 1uLL, memory_order_relaxed);
    }
    double v404 = (std::__shared_weak_count *)v402[1];
    *uint64_t v402 = v401;
    v402[1] = v403;
    if (v404 && !atomic_fetch_add(&v404->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v404->__on_zero_shared)(v404);
      std::__shared_weak_count::__release_weak(v404);
    }
    uint64_t v405 = *((void *)v376 + 8);
    *(void *)(v405 + 24) = 0;
    uint64_t v406 = *(void *)(a2 + 232);
    *(void *)(v405 + 16) = v406;
    uint64_t v407 = *((void *)v376 + 20);
    uint64_t v408 = *(void *)(a2 + 240);
    if (v408) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v408 + 8), 1uLL, memory_order_relaxed);
    }
    v409 = *(std::__shared_weak_count **)(v407 + 24);
    *(void *)(v407 + 16) = v406;
    *(void *)(v407 + 24) = v408;
    if (v409 && !atomic_fetch_add(&v409->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v409->__on_zero_shared)(v409);
      std::__shared_weak_count::__release_weak(v409);
    }
    uint64_t v410 = *((void *)v376 + 8);
    *(void *)(v410 + 48) = v475;
    *(void *)(v410 + 56) = 0;
    uint64_t v411 = *((void *)v376 + 20);
    if (v476) {
      atomic_fetch_add_explicit(&v476->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v394 = *(std::__shared_weak_count **)(v411 + 56);
    *(void *)(v411 + 48) = v475;
    *(void *)(v411 + 56) = v476;
    char v395 = 0;
    if (v394 && !atomic_fetch_add(&v394->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
LABEL_556:
      ((void (*)(std::__shared_weak_count *))v394->__on_zero_shared)(v394);
      std::__shared_weak_count::__release_weak(v394);
    }
LABEL_560:
    *((void *)&v481 + 1) = v376;
    unint64_t v412 = v380[8];
    if (v412 <= v381) {
      unint64_t v412 = v381;
    }
    v380[7] = 0;
    v380[8] = v412;
    *(void *)&long long v481 = md::DaVinciRenderStateCache::renderState((unsigned __int8 **)v377 + 94, 3, 0, *a3 == 0, 0, 1, *a3, 3);
    *((void *)&v482 + 1) = (v354 << 10);
    uint64_t v413 = *(void *)(a4 + 8);
    uint64_t v472 = a4 + 8;
    if (v413)
    {
      uint64_t v414 = v472;
      do
      {
        int v415 = *(_DWORD *)(v413 + 28);
        BOOL v416 = v415 < v356;
        if (v415 >= v356) {
          uint64_t v417 = (uint64_t *)v413;
        }
        else {
          uint64_t v417 = (uint64_t *)(v413 + 8);
        }
        if (!v416) {
          uint64_t v414 = v413;
        }
        uint64_t v413 = *v417;
      }
      while (*v417);
      if (v414 != v472 && v356 >= *(_DWORD *)(v414 + 28))
      {
        uint64_t v418 = *(void **)(*((void *)a3 + 1) + 8);
        uint64_t v419 = v418[3];
        uint64_t v420 = v418[4];
        uint64_t v421 = v420 - v419;
        if (v420 == v419) {
          goto LABEL_579;
        }
        uint64_t v422 = 0;
        unint64_t v423 = v421 >> 3;
        while (1)
        {
          int v424 = *(unsigned __int8 **)(v419 + 8 * v422);
          if (*v424 == *(unsigned __int8 *)(v414 + 32))
          {
            unint64_t v425 = *((void *)v424 + 1);
            uint64_t v426 = v418[15];
            if (v425 < (v418[16] - v426) >> 3) {
              break;
            }
          }
          if (++v422 >= v423) {
            goto LABEL_579;
          }
        }
        uint64_t v427 = *(void *)(v426 + 8 * v425);
        if (!v427) {
LABEL_579:
        }
          uint64_t v428 = 0;
        else {
          uint64_t v428 = *(void *)(*(void *)(v427 + 24) + 8 * *(unsigned __int8 *)(v414 + 33));
        }
        if (v395)
        {
          *(_OWORD *)&v484[8] = v480;
          long long v485 = v481;
          long long v486 = v482;
          long long v490 = *(_OWORD *)&v483[48];
          long long v489 = *(_OWORD *)&v483[32];
          long long v488 = *(_OWORD *)&v483[16];
          *(void *)double v484 = &off_1EF55A458;
          long long v487 = *(_OWORD *)v483;
          v429 = (void *)v377[92];
          uint64_t v430 = v429[1];
          if (v430 == v377[93])
          {
            v429 = (void *)*v429;
            if (!v429)
            {
              v429 = malloc_type_malloc(120 * v430 + 16, 0xB644C221uLL);
              void *v429 = 0;
              v429[1] = 0;
              *(void *)v377[92] = v429;
            }
            v377[92] = (uint64_t)v429;
            uint64_t v430 = v429[1];
          }
          uint64_t v431 = &v429[15 * v430];
          uint64_t v432 = (uint64_t)(v431 + 2);
          v429[1] = v430 + 1;
          v431[2] = &off_1EF55A458;
          long long v433 = v489;
          long long v434 = v490;
          long long v435 = v488;
          *(_OWORD *)(v431 + 9) = v487;
          long long v436 = *(_OWORD *)&v484[8];
          long long v437 = v485;
          *(_OWORD *)(v431 + 7) = v486;
          *(_OWORD *)(v431 + 5) = v437;
          *(_OWORD *)(v431 + 3) = v436;
          *(_OWORD *)(v431 + 15) = v434;
          *(_OWORD *)(v431 + 13) = v433;
          *(_OWORD *)(v431 + 11) = v435;
          v431[10] = v375;
        }
        else
        {
          *(_OWORD *)&v484[8] = v480;
          long long v485 = v481;
          long long v486 = v482;
          long long v490 = *(_OWORD *)&v483[48];
          long long v489 = *(_OWORD *)&v483[32];
          long long v488 = *(_OWORD *)&v483[16];
          *(void *)double v484 = &off_1EF55A458;
          long long v487 = *(_OWORD *)v483;
          uint64_t v438 = (void *)v377[92];
          uint64_t v439 = v438[1];
          if (v439 == v377[93])
          {
            uint64_t v438 = (void *)*v438;
            if (!v438)
            {
              uint64_t v438 = malloc_type_malloc(120 * v439 + 16, 0xB644C221uLL);
              *uint64_t v438 = 0;
              v438[1] = 0;
              *(void *)v377[92] = v438;
            }
            v377[92] = (uint64_t)v438;
            uint64_t v439 = v438[1];
          }
          v440 = &v438[15 * v439];
          uint64_t v432 = (uint64_t)(v440 + 2);
          v438[1] = v439 + 1;
          v440[2] = &off_1EF55A458;
          long long v442 = v489;
          long long v441 = v490;
          long long v443 = v488;
          *(_OWORD *)(v440 + 9) = v487;
          *(_OWORD *)(v440 + 11) = v443;
          *(_OWORD *)(v440 + 13) = v442;
          long long v444 = *(_OWORD *)&v484[8];
          long long v445 = v485;
          *(_OWORD *)(v440 + 7) = v486;
          *(_OWORD *)(v440 + 5) = v445;
          *(_OWORD *)(v440 + 3) = v444;
          *(_OWORD *)(v440 + 15) = v441;
          v440[10] = v375;
          *((unsigned char *)v440 + 88) = v474;
          uint64_t v446 = *(uint64_t *)((char *)v492.i64 + 7);
          *(void *)((char *)v440 + 89) = v492.i64[0];
          v440[12] = v446;
          v440[13] = 0;
          v440[14] = 1;
        }
        ggl::CommandBuffer::pushRenderItem(v428, v432);
      }
    }
  }
LABEL_592:
  if (v476)
  {
    if (!atomic_fetch_add(&v476->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v476->__on_zero_shared)(v476);
      std::__shared_weak_count::__release_weak(v476);
    }
  }
}

void sub_1A20AF15C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::ElevatedStrokeColorPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    os_signpost_id_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        int v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *int v12 = v3;
        }
      }
      else
      {
        int v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        int v34 = v12 - 2;
        int v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)int v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--int v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    os_signpost_id_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        int v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *int v12 = v3;
        }
      }
      else
      {
        int v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        int v26 = v12 - 2;
        char v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)int v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--int v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedStrokeColorPipelineState,std::shared_ptr<ggl::ElevatedStrokeColorShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(std::__shared_weak_count **a1, uint64_t a2, __int8 a3)
{
  v6.i64[0] = 65792;
  v6.i32[2] = 65792;
  v6.i16[6] = 0;
  v6.i8[14] = 0;
  v6.i8[15] = a3;
  int8x16_t v7 = vceqzq_s8(v6);
  int16x8_t v8 = vmovl_s8(*(int8x8_t *)v7.i8);
  int32x4_t v9 = vmovl_high_s16(v8);
  v10.i64[0] = v9.u32[2];
  v10.i64[1] = v9.u32[3];
  int8x16_t v11 = v10;
  int16x8_t v12 = vmovl_high_s8(v7);
  int32x4_t v13 = vmovl_high_s16(v12);
  v10.i64[0] = v13.u32[2];
  v10.i64[1] = v13.u32[3];
  int8x16_t v14 = v10;
  int32x4_t v15 = vmovl_s16(*(int16x4_t *)v8.i8);
  v10.i64[0] = v15.u32[2];
  v10.i64[1] = v15.u32[3];
  int8x16_t v16 = v10;
  int32x4_t v17 = vmovl_s16(*(int16x4_t *)v12.i8);
  v10.i64[0] = v17.u32[2];
  v10.i64[1] = v17.u32[3];
  int8x16_t v18 = v10;
  v10.i64[0] = v9.u32[0];
  v10.i64[1] = v9.u32[1];
  int8x16_t v19 = v10;
  v10.i64[0] = v13.u32[0];
  v10.i64[1] = v13.u32[1];
  int8x16_t v20 = v10;
  v10.i64[0] = v15.u32[0];
  v10.i64[1] = v15.u32[1];
  int8x16_t v21 = v10;
  v10.i64[0] = v17.u32[0];
  v10.i64[1] = v17.u32[1];
  unint64_t v22 = vaddvq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v21), vbicq_s8((int8x16_t)xmmword_1A28FCA60, v10)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v19), vbicq_s8((int8x16_t)xmmword_1A28FCA40, v20))), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v16), vbicq_s8((int8x16_t)xmmword_1A28FCA20, v18)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v11), vbicq_s8((int8x16_t)xmmword_1A28FCA00, v14)))));
  unint64_t v23 = v22;
  uint64_t v25 = (uint64_t **)(a2 + 104);
  uint64_t v24 = *(void **)(a2 + 104);
  if (!v24) {
    goto LABEL_12;
  }
  int v26 = (uint64_t **)(a2 + 104);
  do
  {
    unint64_t v27 = v24[4];
    BOOL v28 = v27 >= v22;
    if (v27 >= v22) {
      long long v29 = v24;
    }
    else {
      long long v29 = v24 + 1;
    }
    if (v28) {
      int v26 = (uint64_t **)v24;
    }
    uint64_t v24 = (void *)*v29;
  }
  while (*v29);
  if (v26 != v25 && v22 >= (unint64_t)v26[4])
  {
    *a1 = (std::__shared_weak_count *)v26[5];
    float v113 = v26[6];
    a1[1] = (std::__shared_weak_count *)v113;
    if (v113) {
      atomic_fetch_add_explicit(v113 + 1, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_12:
    uint64_t v30 = (std::__shared_weak_count *)operator new(0x198uLL);
    v30->__shared_owners_ = 0;
    v30->__shared_weak_owners_ = 0;
    v30->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5897F0;
    unint64_t v31 = v30 + 1;
    long long v115 = *(_OWORD *)(a2 + 16);
    long long v116 = *(_OWORD *)(a2 + 32);
    {
      if (v114)
      {
        {
          if (v114)
          {
            {
              {
                ggl::MeshTyped<ggl::PolylineOverlayRibbon::ElevatedVbo>::attributesReflection(void)::r = (uint64_t)&ggl::PolylineOverlayRibbon::elevatedVboReflection;
              }
              ggl::MeshTyped<ggl::PolylineOverlayRibbon::ElevatedVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::PolylineOverlayRibbon::ElevatedVbo>::attributesReflection(void)::r;
              unk_1E95911D0 = 1;
            }
            ggl::DaVinci::ElevatedStrokeColorPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::PolylineOverlayRibbon::ElevatedVbo>::typedReflection(void)::r;
            *(void *)algn_1E9591008 = &ggl::DaVinci::pipelineDataElevatedStrokeColorPipelineDeviceStructs(void)::ref;
            qword_1E9591010 = 0;
            {
              ggl::DaVinci::pipelineDataElevatedStrokeColorPipelineConstantStructs(void)::ref = (uint64_t)ggl::Tile::View::reflection(void)::reflection;
              unk_1E9591180 = ggl::Tile::Transform::reflection(void)::reflection;
              qword_1E9591188 = (uint64_t)ggl::Tile::Clipping::reflection(void)::reflection;
              unk_1E9591190 = ggl::DaVinci::ClippedStroke::reflection(void)::reflection;
              qword_1E9591198 = (uint64_t)ggl::PolylineOverlayRibbon::Style::reflection(void)::reflection;
            }
            qword_1E9591018 = (uint64_t)&ggl::DaVinci::pipelineDataElevatedStrokeColorPipelineConstantStructs(void)::ref;
            unk_1E9591020 = xmmword_1A28FC940;
          }
        }
        ggl::DaVinci::ElevatedStrokeColorPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::DaVinci::ElevatedStrokeColorPipelineSetup::typedReflection(void)::ref;
        ggl::ElevatedStrokeColorShader::typedReflection(v114);
        qword_1E9590FB0 = (uint64_t)&ggl::ElevatedStrokeColorShader::typedReflection(void)::ref;
        {
          ggl::DaVinci::pipelineStateElevatedStrokeColorPipelineAttributeStructBinding(void)::attr = 0;
          unk_1E9591040 = 0;
          qword_1E9591048 = (uint64_t)"";
          dword_1E9591050 = 0;
          qword_1E9591058 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorPipelineAttributeBinding_0(void)::attr;
          unk_1E9591060 = 4;
        }
        qword_1E9590FB8 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorPipelineAttributeStructBinding(void)::attr;
        unk_1E9590FC0 = 1;
        qword_1E9590FC8 = 0;
        unk_1E9590FD0 = 1;
        qword_1E9590FD8 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorPipelineDeviceStructBinding(void)::ref;
        unk_1E9590FE0 = 0;
        {
          ggl::DaVinci::pipelineStateElevatedStrokeColorPipelineConstantStructBinding(void)::ref = 0;
          unk_1E9591080 = 0;
          qword_1E9591088 = (uint64_t)"view";
          dword_1E9591090 = 3;
          qword_1E9591098 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorPipelineConstantViewBinding(void)::reflection;
          unk_1E95910A0 = xmmword_1A28FCEB0;
          qword_1E95910B0 = 1;
          unk_1E95910B8 = "transform";
          dword_1E95910C0 = 3;
          qword_1E95910C8 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorPipelineConstantTransformBinding(void)::reflection;
          *(_OWORD *)algn_1E95910D0 = xmmword_1A28FCF70;
          qword_1E95910E0 = 2;
          unk_1E95910E8 = "tileClipping";
          dword_1E95910F0 = 3;
          qword_1E95910F8 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorPipelineConstantTileClippingBinding(void)::reflection;
          unk_1E9591100 = xmmword_1A28FC910;
          qword_1E9591110 = 3;
          unk_1E9591118 = "clippedStroke";
          dword_1E9591120 = 3;
          qword_1E9591128 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorPipelineConstantClippedStrokeBinding(void)::reflection;
          *(int64x2_t *)algn_1E9591130 = vdupq_n_s64(4uLL);
          qword_1E9591140 = 4;
          unk_1E9591148 = "style";
          dword_1E9591150 = 3;
          qword_1E9591158 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorPipelineConstantStyleBinding(void)::reflection;
          unk_1E9591160 = 8;
        }
        qword_1E9590FE8 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedStrokeColorPipelineConstantStructBinding(void)::ref;
        unk_1E9590FF0 = 5;
      }
    }
    uint64_t v32 = *(std::__shared_weak_count_vtbl **)a2;
    uint64_t v33 = *(std::__shared_weak_count **)(a2 + 8);
    if (v33) {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(_OWORD *)uint64_t v117 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)&v117[12] = *(_OWORD *)(a2 + 60);
    long long v34 = *(_OWORD *)(a2 + 76);
    char v35 = *(unsigned char *)(a2 + 92);
    v30[1].__shared_weak_owners_ = 0;
    v30[2].__vftable = 0;
    LODWORD(v30[2].__shared_owners_) = 0;
    v30[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55B208;
    v30[1].__shared_owners_ = 0;
    v30[2].__shared_weak_owners_ = (uint64_t)&ggl::DaVinci::ElevatedStrokeColorPipelineState::typedReflection(void)::ref;
    v30[3].__vftable = v32;
    v30[3].__shared_owners_ = (uint64_t)v33;
    if (v33) {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    LOBYTE(v30[5].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v30[5].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v30[6].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v30[7].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v30[6].__shared_weak_owners_ + 4) = 0;
    LOBYTE(v30[7].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v30[7].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v30[8].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v30[9].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v30[8].__shared_weak_owners_ + 4) = 0;
    LOBYTE(v30[9].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v30[9].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v30[10].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v30[11].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v30[10].__shared_weak_owners_ + 4) = 0;
    *(_OWORD *)&v30[11].__shared_weak_owners_ = v115;
    *(_OWORD *)&v30[12].__shared_owners_ = v116;
    LOBYTE(v30[13].__vftable) = 0;
    v30[16].__vftable = 0;
    *(_OWORD *)&v30[14].__shared_weak_owners_ = 0u;
    *(_OWORD *)&v30[15].__shared_owners_ = 0u;
    *(_OWORD *)&v30[13].__shared_owners_ = 0u;
    v30[14].std::__shared_count = 0u;
    v30[16].__shared_owners_ = 0x100000001;
    LOBYTE(v30[16].__shared_weak_owners_) = 0;
    *(std::__shared_count *)((char *)&v30[4].std::__shared_count + 4) = *(std::__shared_count *)&v117[12];
    *(_OWORD *)&v30[3].__shared_weak_owners_ = *(_OWORD *)v117;
    *(_OWORD *)((char *)&v30[4].__shared_weak_owners_ + 4) = v34;
    BYTE4(v30[5].__shared_owners_) = v35;
    if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
    *(std::__shared_weak_count_vtbl **)((char *)&v30[14].__vftable + 1) = 0;
    BYTE1(v30[14].__shared_owners_) = 0;
    *(uint64_t *)((char *)&v30[13].__shared_weak_owners_ + 1) = 0;
    WORD1(v30[14].__shared_owners_) = 257;
    HIDWORD(v30[14].__shared_owners_) = 0;
    v30[14].__shared_weak_owners_ = 16842752;
    int8x16_t v36 = *(int8x16_t *)&v30[14].__shared_owners_;
    int8x16_t v37 = vceqzq_s8(*(int8x16_t *)&v30[13].__shared_weak_owners_);
    int16x8_t v38 = vmovl_high_s8(v37);
    int32x4_t v39 = vmovl_s16(*(int16x4_t *)v38.i8);
    v40.i64[0] = v39.u32[0];
    v40.i64[1] = v39.u32[1];
    int8x16_t v41 = v40;
    int16x8_t v42 = vmovl_s8(*(int8x8_t *)v37.i8);
    int32x4_t v43 = vmovl_s16(*(int16x4_t *)v42.i8);
    v40.i64[0] = v43.u32[0];
    v40.i64[1] = v43.u32[1];
    int8x16_t v44 = v40;
    int32x4_t v45 = vmovl_high_s16(v38);
    v40.i64[0] = v45.u32[0];
    v40.i64[1] = v45.u32[1];
    int8x16_t v46 = v40;
    int32x4_t v47 = vmovl_high_s16(v42);
    v40.i64[0] = v47.u32[0];
    v40.i64[1] = v47.u32[1];
    int8x16_t v48 = v40;
    v40.i64[0] = v39.u32[2];
    v40.i64[1] = v39.u32[3];
    int8x16_t v49 = v40;
    v40.i64[0] = v43.u32[2];
    v40.i64[1] = v43.u32[3];
    int8x16_t v50 = v40;
    v40.i64[0] = v45.u32[2];
    v40.i64[1] = v45.u32[3];
    int8x16_t v51 = v40;
    v40.i64[0] = v47.u32[2];
    v40.i64[1] = v47.u32[3];
    int8x16_t v52 = vbicq_s8((int8x16_t)xmmword_1A28FC980, v40);
    v30[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF561378;
    LOBYTE(v30[15].__vftable) = a3;
    int8x16_t v53 = vbicq_s8((int8x16_t)xmmword_1A28FC990, v51);
    int8x16_t v54 = vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v50);
    HIDWORD(v30[15].__vftable) = 0;
    int8x16_t v55 = vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v46);
    *(_DWORD *)((char *)&v30[15].__vftable + 1) = 0;
    int8x16_t v56 = vceqzq_s8(v36);
    int16x8_t v57 = vmovl_high_s8(v56);
    int32x4_t v58 = vmovl_s16(*(int16x4_t *)v57.i8);
    v40.i64[0] = v58.u32[0];
    v40.i64[1] = v58.u32[1];
    int8x16_t v59 = v40;
    int16x8_t v60 = vmovl_s8(*(int8x8_t *)v56.i8);
    int32x4_t v61 = vmovl_s16(*(int16x4_t *)v60.i8);
    v40.i64[0] = v61.u32[0];
    v40.i64[1] = v61.u32[1];
    int8x16_t v62 = v40;
    int32x4_t v63 = vmovl_high_s16(v57);
    v40.i64[0] = v63.u32[0];
    v40.i64[1] = v63.u32[1];
    int8x16_t v64 = v40;
    int32x4_t v65 = vmovl_high_s16(v60);
    v40.i64[0] = v65.u32[0];
    v40.i64[1] = v65.u32[1];
    int8x16_t v66 = v40;
    v40.i64[0] = v58.u32[2];
    v40.i64[1] = v58.u32[3];
    int8x16_t v67 = v40;
    v40.i64[0] = v61.u32[2];
    v40.i64[1] = v61.u32[3];
    int8x16_t v68 = v40;
    v40.i64[0] = v63.u32[2];
    v40.i64[1] = v63.u32[3];
    int8x16_t v69 = v40;
    v40.i64[0] = v65.u32[2];
    v40.i64[1] = v65.u32[3];
    int8x16_t v70 = vbicq_s8((int8x16_t)xmmword_1A28FCA00, v69);
    int8x16_t v71 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA60, v59), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v41));
    int8x16_t v72 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v62), vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v44));
    int8x16_t v73 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA40, v64), v55);
    int8x16_t v74 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v66), vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v48));
    int8x16_t v75 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA20, v67), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v49));
    int8x16_t v76 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v68), v54);
    int8x16_t v77 = vorrq_s8(v70, v53);
    int8x16_t v78 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v40), v52);
    int8x16_t v79 = vceqzq_s8((int8x16_t)v30[15].std::__shared_count);
    int16x8_t v80 = vmovl_s8(*(int8x8_t *)v79.i8);
    int32x4_t v81 = vmovl_high_s16(v80);
    v40.i64[0] = v81.i32[2];
    v40.i64[1] = v81.i32[3];
    int8x16_t v82 = v40;
    int16x8_t v83 = vmovl_high_s8(v79);
    int32x4_t v84 = vmovl_high_s16(v83);
    v40.i64[0] = v84.i32[2];
    v40.i64[1] = v84.i32[3];
    int8x16_t v85 = v40;
    int32x4_t v86 = vmovl_s16(*(int16x4_t *)v80.i8);
    v40.i64[0] = v86.i32[2];
    v40.i64[1] = v86.i32[3];
    int8x16_t v87 = v40;
    int32x4_t v88 = vmovl_s16(*(int16x4_t *)v83.i8);
    v40.i64[0] = v88.i32[2];
    v40.i64[1] = v88.i32[3];
    int8x16_t v89 = v40;
    v40.i64[0] = v81.i32[0];
    v40.i64[1] = v81.i32[1];
    int8x16_t v90 = v40;
    v40.i64[0] = v84.i32[0];
    v40.i64[1] = v84.i32[1];
    int8x16_t v91 = v40;
    v40.i64[0] = v86.i32[0];
    v40.i64[1] = v86.i32[1];
    int8x16_t v92 = v40;
    v40.i64[0] = v88.i32[0];
    v40.i64[1] = v88.i32[1];
    int8x16_t v93 = vbicq_s8((int8x16_t)xmmword_1A28FCA70, v40);
    int8x16_t v94 = vceqzq_s8(*(int8x16_t *)&v30[15].__shared_weak_owners_);
    int16x8_t v95 = vmovl_high_s8(v94);
    int32x4_t v96 = vmovl_s16(*(int16x4_t *)v95.i8);
    v40.i64[0] = v96.i32[0];
    v40.i64[1] = v96.i32[1];
    int8x16_t v97 = v40;
    int16x8_t v98 = vmovl_s8(*(int8x8_t *)v94.i8);
    int32x4_t v99 = vmovl_s16(*(int16x4_t *)v98.i8);
    v40.i64[0] = v99.i32[0];
    v40.i64[1] = v99.i32[1];
    int8x16_t v100 = v40;
    int32x4_t v101 = vmovl_high_s16(v95);
    v40.i64[0] = v101.i32[0];
    v40.i64[1] = v101.i32[1];
    int8x16_t v102 = v40;
    int32x4_t v103 = vmovl_high_s16(v98);
    v40.i64[0] = v103.i32[0];
    v40.i64[1] = v103.i32[1];
    int8x16_t v104 = v40;
    v40.i64[0] = v96.i32[2];
    v40.i64[1] = v96.i32[3];
    int8x16_t v105 = v40;
    v40.i64[0] = v99.i32[2];
    v40.i64[1] = v99.i32[3];
    int8x16_t v106 = v40;
    v40.i64[0] = v101.i32[2];
    v40.i64[1] = v101.i32[3];
    int8x16_t v107 = v40;
    v40.i64[0] = v103.i32[2];
    v40.i64[1] = v103.i32[3];
    v30[13].__shared_owners_ = vaddvq_s64(vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB50, v100), vbicq_s8((int8x16_t)xmmword_1A28FCA80, v92)), v72), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB60, v97), v93), v71)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB30, v104), vbicq_s8((int8x16_t)xmmword_1A28FCAA0, v90)), v74), vorrq_s8(vorrq_s8(
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCB40, v102),
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCA90, v91)),
                                                    v73))),
                                   (int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB10, v106), vbicq_s8((int8x16_t)xmmword_1A28FCAC0, v87)), v76), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB20, v105), vbicq_s8((int8x16_t)xmmword_1A28FCAB0, v89)), v75)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAF0, v40), vbicq_s8((int8x16_t)xmmword_1A28FCAE0, v82)), v78), vorrq_s8(vorrq_s8(
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCB00, v107),
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCAD0, v85)),
                                                    v77)))));
    LOBYTE(v30[13].__vftable) = 1;
    *a1 = v31;
    a1[1] = v30;
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
    int v108 = *v25;
    int v109 = v25;
    if (*v25)
    {
      while (1)
      {
        while (1)
        {
          int v109 = (uint64_t **)v108;
          unint64_t v110 = v108[4];
          if (v23 >= v110) {
            break;
          }
          int v108 = *v109;
          uint64_t v25 = v109;
          if (!*v109) {
            goto LABEL_27;
          }
        }
        if (v110 >= v23) {
          break;
        }
        int v108 = v109[1];
        if (!v108)
        {
          uint64_t v25 = v109 + 1;
          goto LABEL_27;
        }
      }
      if (!atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    else
    {
LABEL_27:
      unint64_t v111 = (uint64_t *)operator new(0x38uLL);
      v111[4] = v23;
      v111[5] = (uint64_t)v31;
      v111[6] = (uint64_t)v30;
      *unint64_t v111 = 0;
      v111[1] = 0;
      v111[2] = (uint64_t)v109;
      *uint64_t v25 = v111;
      uint64_t v112 = **(void **)(a2 + 96);
      if (v112)
      {
        *(void *)(a2 + 96) = v112;
        unint64_t v111 = *v25;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a2 + 104), v111);
      ++*(void *)(a2 + 112);
    }
  }
}

void sub_1A20B0008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  md::components::Material::~Material((md::components::Material *)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v17);
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::DaVinci::ElevatedFillColorPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    os_signpost_id_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        int16x8_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *int16x8_t v12 = v3;
        }
      }
      else
      {
        int16x8_t v12 = (uint64_t *)(8 * v17);
      }
      int32x4_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        long long v34 = v12 - 2;
        char v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)long long v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--int16x8_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    os_signpost_id_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        int16x8_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *int16x8_t v12 = v3;
        }
      }
      else
      {
        int16x8_t v12 = (uint64_t *)(8 * v7);
      }
      int32x4_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        int v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)int v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--int16x8_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  int32x4_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void md::DaVinciPipelineStateManager<ggl::DaVinci::ElevatedFillColorPipelineState,std::shared_ptr<ggl::ElevatedFillNoWidthClipColorShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants(std::__shared_weak_count **a1, uint64_t a2, __int8 a3)
{
  v6.i64[0] = 65792;
  v6.i32[2] = 65792;
  v6.i16[6] = 0;
  v6.i8[14] = 0;
  v6.i8[15] = a3;
  int8x16_t v7 = vceqzq_s8(v6);
  int16x8_t v8 = vmovl_s8(*(int8x8_t *)v7.i8);
  int32x4_t v9 = vmovl_high_s16(v8);
  v10.i64[0] = v9.u32[2];
  v10.i64[1] = v9.u32[3];
  int8x16_t v11 = v10;
  int16x8_t v12 = vmovl_high_s8(v7);
  int32x4_t v13 = vmovl_high_s16(v12);
  v10.i64[0] = v13.u32[2];
  v10.i64[1] = v13.u32[3];
  int8x16_t v14 = v10;
  int32x4_t v15 = vmovl_s16(*(int16x4_t *)v8.i8);
  v10.i64[0] = v15.u32[2];
  v10.i64[1] = v15.u32[3];
  int8x16_t v16 = v10;
  int32x4_t v17 = vmovl_s16(*(int16x4_t *)v12.i8);
  v10.i64[0] = v17.u32[2];
  v10.i64[1] = v17.u32[3];
  int8x16_t v18 = v10;
  v10.i64[0] = v9.u32[0];
  v10.i64[1] = v9.u32[1];
  int8x16_t v19 = v10;
  v10.i64[0] = v13.u32[0];
  v10.i64[1] = v13.u32[1];
  int8x16_t v20 = v10;
  v10.i64[0] = v15.u32[0];
  v10.i64[1] = v15.u32[1];
  int8x16_t v21 = v10;
  v10.i64[0] = v17.u32[0];
  v10.i64[1] = v17.u32[1];
  unint64_t v22 = vaddvq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v21), vbicq_s8((int8x16_t)xmmword_1A28FCA60, v10)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v19), vbicq_s8((int8x16_t)xmmword_1A28FCA40, v20))), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v16), vbicq_s8((int8x16_t)xmmword_1A28FCA20, v18)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v11), vbicq_s8((int8x16_t)xmmword_1A28FCA00, v14)))));
  unint64_t v23 = v22;
  uint64_t v25 = (uint64_t **)(a2 + 104);
  uint64_t v24 = *(void **)(a2 + 104);
  if (!v24) {
    goto LABEL_12;
  }
  int v26 = (uint64_t **)(a2 + 104);
  do
  {
    unint64_t v27 = v24[4];
    BOOL v28 = v27 >= v22;
    if (v27 >= v22) {
      long long v29 = v24;
    }
    else {
      long long v29 = v24 + 1;
    }
    if (v28) {
      int v26 = (uint64_t **)v24;
    }
    uint64_t v24 = (void *)*v29;
  }
  while (*v29);
  if (v26 != v25 && v22 >= (unint64_t)v26[4])
  {
    *a1 = (std::__shared_weak_count *)v26[5];
    float v113 = v26[6];
    a1[1] = (std::__shared_weak_count *)v113;
    if (v113) {
      atomic_fetch_add_explicit(v113 + 1, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_12:
    uint64_t v30 = (std::__shared_weak_count *)operator new(0x198uLL);
    v30->__shared_owners_ = 0;
    v30->__shared_weak_owners_ = 0;
    v30->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589748;
    unint64_t v31 = v30 + 1;
    long long v114 = *(_OWORD *)(a2 + 16);
    long long v115 = *(_OWORD *)(a2 + 32);
    {
      {
        {
          {
            ggl::MeshTyped<ggl::DaVinci::ElevatedFillVbo>::attributesReflection(void)::r = (uint64_t)&ggl::DaVinci::elevatedFillVboReflection;
          }
          ggl::MeshTyped<ggl::DaVinci::ElevatedFillVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::DaVinci::ElevatedFillVbo>::attributesReflection(void)::r;
          *(void *)algn_1E958ECA8 = 1;
        }
        ggl::DaVinci::ElevatedFillColorPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::DaVinci::ElevatedFillVbo>::typedReflection(void)::r;
        unk_1E958EAF0 = &ggl::DaVinci::pipelineDataElevatedFillColorPipelineDeviceStructs(void)::ref;
        qword_1E958EAF8 = 0;
        {
          ggl::DaVinci::pipelineDataElevatedFillColorPipelineConstantStructs(void)::ref = (uint64_t)ggl::Tile::View::reflection(void)::reflection;
          *(void *)algn_1E958EC58 = ggl::Tile::Transform::reflection(void)::reflection;
          qword_1E958EC60 = (uint64_t)ggl::DaVinci::ElevatedFillStyle::reflection(void)::reflection;
          unk_1E958EC68 = ggl::Tile::Clipping::reflection(void)::reflection;
        }
        qword_1E958EB00 = (uint64_t)&ggl::DaVinci::pipelineDataElevatedFillColorPipelineConstantStructs(void)::ref;
        unk_1E958EB08 = xmmword_1A28FCFA0;
      }
      ggl::DaVinci::ElevatedFillColorPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::DaVinci::ElevatedFillColorPipelineSetup::typedReflection(void)::ref;
      {
        ggl::ElevatedFillNoWidthClipColorShader::typedReflection(void)::ref = (uint64_t)"ElevatedFillNoWidthClipColorShader";
        {
          qword_1EB31D2B8 = (uint64_t)"ElevatedFillNoWidthClipColorShader";
          unk_1EB31D2C0 = ggl::elevatedFillNoWidthClipColorShaderVertShaderFunctionAttributes(void)::ref;
          qword_1EB31D2C8 = 1;
          unk_1EB31D2D0 = &ggl::elevatedFillNoWidthClipColorShaderVertShaderFunctionConstantMapping(void)::ref;
          qword_1EB31D2D8 = 4;
          unk_1EB31D2E0 = &ggl::elevatedFillNoWidthClipColorShaderVertShaderFunctionBufferMapping(void)::ref;
          qword_1EB31D2E8 = 0;
          unk_1EB31D2F0 = &ggl::elevatedFillNoWidthClipColorShaderVertShaderFunctionTextureMapping(void)::ref;
          ggl::elevatedFillNoWidthClipColorShaderVertexFunctionDescriptor(void)::ref = 2431374733;
          qword_1EB31D2F8 = 0;
          unk_1EB31D300 = &ggl::elevatedFillNoWidthClipColorShaderVertShaderFunctionSamplerMapping(void)::ref;
          qword_1EB31D310 = 0;
          unk_1EB31D318 = 0;
          qword_1EB31D308 = 0;
        }
        qword_1EB31C368 = (uint64_t)&ggl::elevatedFillNoWidthClipColorShaderVertexFunctionDescriptor(void)::ref;
        dword_1EB31C370 = -1863592563;
        {
          ggl::elevatedFillNoWidthClipColorShaderFragmentFunctionDescriptor(void)::ref = 0x138D1A785;
          qword_1EB31D570 = (uint64_t)"ElevatedFillNoWidthClipColorShader";
          unk_1EB31D578 = 0;
          qword_1EB31D580 = 0;
          unk_1EB31D588 = &ggl::elevatedFillNoWidthClipColorShaderFragShaderFunctionConstantMapping(void)::ref;
          qword_1EB31D590 = 2;
          unk_1EB31D598 = &ggl::elevatedFillNoWidthClipColorShaderFragShaderFunctionBufferMapping(void)::ref;
          qword_1EB31D5A0 = 0;
          unk_1EB31D5A8 = &ggl::elevatedFillNoWidthClipColorShaderFragShaderFunctionTextureMapping(void)::ref;
          qword_1EB31D5B0 = 0;
          unk_1EB31D5B8 = &ggl::elevatedFillNoWidthClipColorShaderFragShaderFunctionSamplerMapping(void)::ref;
          qword_1EB31D5C8 = 0;
          unk_1EB31D5D0 = 0;
          qword_1EB31D5C0 = 0;
        }
        qword_1EB31C378 = (uint64_t)&ggl::elevatedFillNoWidthClipColorShaderFragmentFunctionDescriptor(void)::ref;
        dword_1EB31C380 = 953264005;
        qword_1EB31C388 = (uint64_t)ggl::elevatedFillNoWidthClipColorShaderShaderConstants(void)::ref;
        unk_1EB31C390 = 4;
        qword_1EB31C398 = (uint64_t)&ggl::elevatedFillNoWidthClipColorShaderShaderTextures(void)::ref;
        unk_1EB31C3A0 = 0;
        qword_1EB31C3A8 = (uint64_t)&ggl::elevatedFillNoWidthClipColorShaderShaderSamplers(void)::ref;
        unk_1EB31C3B0 = 0;
      }
      qword_1E958EA98 = (uint64_t)&ggl::ElevatedFillNoWidthClipColorShader::typedReflection(void)::ref;
      {
        ggl::DaVinci::pipelineStateElevatedFillColorPipelineAttributeStructBinding(void)::attr = 0;
        *(void *)algn_1E958EB48 = 0;
        qword_1E958EB50 = (uint64_t)"";
        dword_1E958EB58 = 0;
        qword_1E958EB60 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorPipelineAttributeBinding_0(void)::attr;
        unk_1E958EB68 = 2;
      }
      qword_1E958EAA0 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorPipelineAttributeStructBinding(void)::attr;
      *(void *)algn_1E958EAA8 = 1;
      qword_1E958EAB0 = 0;
      unk_1E958EAB8 = 0;
      qword_1E958EAC0 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorPipelineDeviceStructBinding(void)::ref;
      unk_1E958EAC8 = 0;
      {
        ggl::DaVinci::pipelineStateElevatedFillColorPipelineConstantStructBinding(void)::ref = 0;
        *(void *)algn_1E958EB88 = 0;
        qword_1E958EB90 = (uint64_t)"view";
        dword_1E958EB98 = 3;
        qword_1E958EBA0 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorPipelineConstantViewBinding(void)::reflection;
        unk_1E958EBA8 = xmmword_1A28FCEB0;
        qword_1E958EBB8 = 1;
        unk_1E958EBC0 = "transform";
        dword_1E958EBC8 = 3;
        qword_1E958EBD0 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorPipelineConstantTransformBinding(void)::reflection;
        unk_1E958EBD8 = xmmword_1A28FCF70;
        qword_1E958EBE8 = 2;
        unk_1E958EBF0 = "style";
        dword_1E958EBF8 = 3;
        qword_1E958EC00 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorPipelineConstantStyleBinding(void)::reflection;
        unk_1E958EC08 = vdupq_n_s64(3uLL);
        qword_1E958EC18 = 3;
        unk_1E958EC20 = "tileClipping";
        dword_1E958EC28 = 3;
        qword_1E958EC30 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorPipelineConstantTileClippingBinding(void)::reflection;
        unk_1E958EC38 = 2;
      }
      qword_1E958EAD0 = (uint64_t)&ggl::DaVinci::pipelineStateElevatedFillColorPipelineConstantStructBinding(void)::ref;
      *(void *)algn_1E958EAD8 = 4;
    }
    uint64_t v32 = *(std::__shared_weak_count_vtbl **)a2;
    uint64_t v33 = *(std::__shared_weak_count **)(a2 + 8);
    if (v33) {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(_OWORD *)long long v116 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)&v116[12] = *(_OWORD *)(a2 + 60);
    long long v34 = *(_OWORD *)(a2 + 76);
    char v35 = *(unsigned char *)(a2 + 92);
    v30[1].__shared_weak_owners_ = 0;
    v30[2].__vftable = 0;
    LODWORD(v30[2].__shared_owners_) = 0;
    v30[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55B208;
    v30[1].__shared_owners_ = 0;
    v30[2].__shared_weak_owners_ = (uint64_t)&ggl::DaVinci::ElevatedFillColorPipelineState::typedReflection(void)::ref;
    v30[3].__vftable = v32;
    v30[3].__shared_owners_ = (uint64_t)v33;
    if (v33) {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    LOBYTE(v30[5].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v30[5].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v30[6].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v30[7].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v30[6].__shared_weak_owners_ + 4) = 0;
    LOBYTE(v30[7].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v30[7].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v30[8].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v30[9].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v30[8].__shared_weak_owners_ + 4) = 0;
    LOBYTE(v30[9].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v30[9].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v30[10].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v30[11].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v30[10].__shared_weak_owners_ + 4) = 0;
    *(_OWORD *)&v30[11].__shared_weak_owners_ = v114;
    *(_OWORD *)&v30[12].__shared_owners_ = v115;
    LOBYTE(v30[13].__vftable) = 0;
    v30[16].__vftable = 0;
    *(_OWORD *)&v30[14].__shared_weak_owners_ = 0u;
    *(_OWORD *)&v30[15].__shared_owners_ = 0u;
    *(_OWORD *)&v30[13].__shared_owners_ = 0u;
    v30[14].std::__shared_count = 0u;
    v30[16].__shared_owners_ = 0x100000001;
    LOBYTE(v30[16].__shared_weak_owners_) = 0;
    *(std::__shared_count *)((char *)&v30[4].std::__shared_count + 4) = *(std::__shared_count *)&v116[12];
    *(_OWORD *)&v30[3].__shared_weak_owners_ = *(_OWORD *)v116;
    *(_OWORD *)((char *)&v30[4].__shared_weak_owners_ + 4) = v34;
    BYTE4(v30[5].__shared_owners_) = v35;
    if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
    *(std::__shared_weak_count_vtbl **)((char *)&v30[14].__vftable + 1) = 0;
    BYTE1(v30[14].__shared_owners_) = 0;
    *(uint64_t *)((char *)&v30[13].__shared_weak_owners_ + 1) = 0;
    WORD1(v30[14].__shared_owners_) = 257;
    HIDWORD(v30[14].__shared_owners_) = 0;
    v30[14].__shared_weak_owners_ = 16842752;
    int8x16_t v36 = *(int8x16_t *)&v30[14].__shared_owners_;
    int8x16_t v37 = vceqzq_s8(*(int8x16_t *)&v30[13].__shared_weak_owners_);
    int16x8_t v38 = vmovl_high_s8(v37);
    int32x4_t v39 = vmovl_s16(*(int16x4_t *)v38.i8);
    v40.i64[0] = v39.u32[0];
    v40.i64[1] = v39.u32[1];
    int8x16_t v41 = v40;
    int16x8_t v42 = vmovl_s8(*(int8x8_t *)v37.i8);
    int32x4_t v43 = vmovl_s16(*(int16x4_t *)v42.i8);
    v40.i64[0] = v43.u32[0];
    v40.i64[1] = v43.u32[1];
    int8x16_t v44 = v40;
    int32x4_t v45 = vmovl_high_s16(v38);
    v40.i64[0] = v45.u32[0];
    v40.i64[1] = v45.u32[1];
    int8x16_t v46 = v40;
    int32x4_t v47 = vmovl_high_s16(v42);
    v40.i64[0] = v47.u32[0];
    v40.i64[1] = v47.u32[1];
    int8x16_t v48 = v40;
    v40.i64[0] = v39.u32[2];
    v40.i64[1] = v39.u32[3];
    int8x16_t v49 = v40;
    v40.i64[0] = v43.u32[2];
    v40.i64[1] = v43.u32[3];
    int8x16_t v50 = v40;
    v40.i64[0] = v45.u32[2];
    v40.i64[1] = v45.u32[3];
    int8x16_t v51 = v40;
    v40.i64[0] = v47.u32[2];
    v40.i64[1] = v47.u32[3];
    int8x16_t v52 = vbicq_s8((int8x16_t)xmmword_1A28FC980, v40);
    v30[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF561298;
    LOBYTE(v30[15].__vftable) = a3;
    int8x16_t v53 = vbicq_s8((int8x16_t)xmmword_1A28FC990, v51);
    int8x16_t v54 = vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v50);
    HIDWORD(v30[15].__vftable) = 0;
    int8x16_t v55 = vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v46);
    *(_DWORD *)((char *)&v30[15].__vftable + 1) = 0;
    int8x16_t v56 = vceqzq_s8(v36);
    int16x8_t v57 = vmovl_high_s8(v56);
    int32x4_t v58 = vmovl_s16(*(int16x4_t *)v57.i8);
    v40.i64[0] = v58.u32[0];
    v40.i64[1] = v58.u32[1];
    int8x16_t v59 = v40;
    int16x8_t v60 = vmovl_s8(*(int8x8_t *)v56.i8);
    int32x4_t v61 = vmovl_s16(*(int16x4_t *)v60.i8);
    v40.i64[0] = v61.u32[0];
    v40.i64[1] = v61.u32[1];
    int8x16_t v62 = v40;
    int32x4_t v63 = vmovl_high_s16(v57);
    v40.i64[0] = v63.u32[0];
    v40.i64[1] = v63.u32[1];
    int8x16_t v64 = v40;
    int32x4_t v65 = vmovl_high_s16(v60);
    v40.i64[0] = v65.u32[0];
    v40.i64[1] = v65.u32[1];
    int8x16_t v66 = v40;
    v40.i64[0] = v58.u32[2];
    v40.i64[1] = v58.u32[3];
    int8x16_t v67 = v40;
    v40.i64[0] = v61.u32[2];
    v40.i64[1] = v61.u32[3];
    int8x16_t v68 = v40;
    v40.i64[0] = v63.u32[2];
    v40.i64[1] = v63.u32[3];
    int8x16_t v69 = v40;
    v40.i64[0] = v65.u32[2];
    v40.i64[1] = v65.u32[3];
    int8x16_t v70 = vbicq_s8((int8x16_t)xmmword_1A28FCA00, v69);
    int8x16_t v71 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA60, v59), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v41));
    int8x16_t v72 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v62), vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v44));
    int8x16_t v73 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA40, v64), v55);
    int8x16_t v74 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v66), vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v48));
    int8x16_t v75 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA20, v67), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v49));
    int8x16_t v76 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v68), v54);
    int8x16_t v77 = vorrq_s8(v70, v53);
    int8x16_t v78 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v40), v52);
    int8x16_t v79 = vceqzq_s8((int8x16_t)v30[15].std::__shared_count);
    int16x8_t v80 = vmovl_s8(*(int8x8_t *)v79.i8);
    int32x4_t v81 = vmovl_high_s16(v80);
    v40.i64[0] = v81.i32[2];
    v40.i64[1] = v81.i32[3];
    int8x16_t v82 = v40;
    int16x8_t v83 = vmovl_high_s8(v79);
    int32x4_t v84 = vmovl_high_s16(v83);
    v40.i64[0] = v84.i32[2];
    v40.i64[1] = v84.i32[3];
    int8x16_t v85 = v40;
    int32x4_t v86 = vmovl_s16(*(int16x4_t *)v80.i8);
    v40.i64[0] = v86.i32[2];
    v40.i64[1] = v86.i32[3];
    int8x16_t v87 = v40;
    int32x4_t v88 = vmovl_s16(*(int16x4_t *)v83.i8);
    v40.i64[0] = v88.i32[2];
    v40.i64[1] = v88.i32[3];
    int8x16_t v89 = v40;
    v40.i64[0] = v81.i32[0];
    v40.i64[1] = v81.i32[1];
    int8x16_t v90 = v40;
    v40.i64[0] = v84.i32[0];
    v40.i64[1] = v84.i32[1];
    int8x16_t v91 = v40;
    v40.i64[0] = v86.i32[0];
    v40.i64[1] = v86.i32[1];
    int8x16_t v92 = v40;
    v40.i64[0] = v88.i32[0];
    v40.i64[1] = v88.i32[1];
    int8x16_t v93 = vbicq_s8((int8x16_t)xmmword_1A28FCA70, v40);
    int8x16_t v94 = vceqzq_s8(*(int8x16_t *)&v30[15].__shared_weak_owners_);
    int16x8_t v95 = vmovl_high_s8(v94);
    int32x4_t v96 = vmovl_s16(*(int16x4_t *)v95.i8);
    v40.i64[0] = v96.i32[0];
    v40.i64[1] = v96.i32[1];
    int8x16_t v97 = v40;
    int16x8_t v98 = vmovl_s8(*(int8x8_t *)v94.i8);
    int32x4_t v99 = vmovl_s16(*(int16x4_t *)v98.i8);
    v40.i64[0] = v99.i32[0];
    v40.i64[1] = v99.i32[1];
    int8x16_t v100 = v40;
    int32x4_t v101 = vmovl_high_s16(v95);
    v40.i64[0] = v101.i32[0];
    v40.i64[1] = v101.i32[1];
    int8x16_t v102 = v40;
    int32x4_t v103 = vmovl_high_s16(v98);
    v40.i64[0] = v103.i32[0];
    v40.i64[1] = v103.i32[1];
    int8x16_t v104 = v40;
    v40.i64[0] = v96.i32[2];
    v40.i64[1] = v96.i32[3];
    int8x16_t v105 = v40;
    v40.i64[0] = v99.i32[2];
    v40.i64[1] = v99.i32[3];
    int8x16_t v106 = v40;
    v40.i64[0] = v101.i32[2];
    v40.i64[1] = v101.i32[3];
    int8x16_t v107 = v40;
    v40.i64[0] = v103.i32[2];
    v40.i64[1] = v103.i32[3];
    v30[13].__shared_owners_ = vaddvq_s64(vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB50, v100), vbicq_s8((int8x16_t)xmmword_1A28FCA80, v92)), v72), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB60, v97), v93), v71)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB30, v104), vbicq_s8((int8x16_t)xmmword_1A28FCAA0, v90)), v74), vorrq_s8(vorrq_s8(
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCB40, v102),
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCA90, v91)),
                                                    v73))),
                                   (int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB10, v106), vbicq_s8((int8x16_t)xmmword_1A28FCAC0, v87)), v76), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB20, v105), vbicq_s8((int8x16_t)xmmword_1A28FCAB0, v89)), v75)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAF0, v40), vbicq_s8((int8x16_t)xmmword_1A28FCAE0, v82)), v78), vorrq_s8(vorrq_s8(
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCB00, v107),
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCAD0, v85)),
                                                    v77)))));
    LOBYTE(v30[13].__vftable) = 1;
    *a1 = v31;
    a1[1] = v30;
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
    int v108 = *v25;
    int v109 = v25;
    if (*v25)
    {
      while (1)
      {
        while (1)
        {
          int v109 = (uint64_t **)v108;
          unint64_t v110 = v108[4];
          if (v23 >= v110) {
            break;
          }
          int v108 = *v109;
          uint64_t v25 = v109;
          if (!*v109) {
            goto LABEL_27;
          }
        }
        if (v110 >= v23) {
          break;
        }
        int v108 = v109[1];
        if (!v108)
        {
          uint64_t v25 = v109 + 1;
          goto LABEL_27;
        }
      }
      if (!atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    else
    {
LABEL_27:
      unint64_t v111 = (uint64_t *)operator new(0x38uLL);
      v111[4] = v23;
      v111[5] = (uint64_t)v31;
      v111[6] = (uint64_t)v30;
      *unint64_t v111 = 0;
      v111[1] = 0;
      v111[2] = (uint64_t)v109;
      *uint64_t v25 = v111;
      uint64_t v112 = **(void **)(a2 + 96);
      if (v112)
      {
        *(void *)(a2 + 96) = v112;
        unint64_t v111 = *v25;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a2 + 104), v111);
      ++*(void *)(a2 + 112);
    }
  }
}

void sub_1A20B0F84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  md::components::Material::~Material((md::components::Material *)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v17);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<ggl::DaVinci::ElevatedFillColorWithDistancePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DaVinci::ElevatedFillColorWithDistancePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589860;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DaVinci::ElevatedFillColorWithDistancePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589860;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::DaVinci::ElevatedFillColorPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DaVinci::ElevatedFillColorPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589748;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DaVinci::ElevatedFillColorPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589748;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589898;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589898;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::DaVinci::ElevatedStrokeColorPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DaVinci::ElevatedStrokeColorPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5897F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DaVinci::ElevatedStrokeColorPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5897F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::Logic<md::ARDebugDrawIntersectionsLogic,md::ARDebugDrawIntersectionsContext,md::LogicDependencies<gdc::TypeList<md::ARWorldIntersectorContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    unint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      unint64_t v5 = __p;
    }
    int16x8_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void md::ARDebugDrawIntersectionsLogic::runBeforeLayout(uint64_t a1)
{
  uint64_t v2 = *(int8x8_t **)(a1 + 120);
  uint64_t v3 = (void *)gdc::Registry::storage<arComponents::DidIntersectFrustum>(v2);
  uint64_t v4 = (void *)gdc::Registry::storage<arComponents::LocalBounds>(v2);
  uint64_t v5 = gdc::Registry::storage<arComponents::MapTileDataComponent>(v2);
  int8x16_t v6 = (void *)v5;
  uint64_t v7 = v5 + 32;
  uint64_t v9 = v3[7];
  uint64_t v8 = v3[8];
  if (v4[8] - v4[7] >= (unint64_t)(v8 - v9)) {
    int8x16_t v10 = v3 + 4;
  }
  else {
    int8x16_t v10 = v4 + 4;
  }
  if (*(void *)(v5 + 64) - *(void *)(v5 + 56) >= v10[4] - v10[3]) {
    int8x16_t v11 = v10;
  }
  else {
    int8x16_t v11 = (void *)(v5 + 32);
  }
  if (v3 + 4 == v11 && v9 != v8)
  {
    do
    {
      unint64_t v22 = *(unsigned int *)(v9 + 4);
      unint64_t v23 = v22 >> 7;
      uint64_t v24 = v4[4];
      if (v22 >> 7 < (v4[5] - v24) >> 3)
      {
        uint64_t v25 = *(void *)(v24 + 8 * v23);
        if (v25)
        {
          unint64_t v26 = *(unsigned __int16 *)(v25 + 2 * (v22 & 0x7F));
          uint64_t v28 = v4[7];
          uint64_t v27 = v4[8];
          if (v26 < (v27 - v28) >> 3)
          {
            uint64_t v29 = v28 + 8 * v26;
            if (v29 != v27 && *(_DWORD *)(v29 + 4) == v22)
            {
              uint64_t v31 = v6[4];
              if (v23 < (v6[5] - v31) >> 3)
              {
                uint64_t v32 = *(void *)(v31 + 8 * v23);
                if (v32)
                {
                  unint64_t v33 = *(unsigned __int16 *)(v32 + 2 * (v22 & 0x7F));
                  uint64_t v35 = v6[7];
                  uint64_t v34 = v6[8];
                  if (v33 < (v34 - v35) >> 3)
                  {
                    uint64_t v36 = v35 + 8 * v33;
                    if (v36 != v34 && *(_DWORD *)(v36 + 4) == v22) {
                      _ZZN2md29ARDebugDrawIntersectionsLogic15runBeforeLayoutERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_25ARWorldIntersectorContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_31ARDebugDrawIntersectionsContextEENK3__0clENS5_6EntityERN12arComponents11LocalBoundsERNSI_20MapTileDataComponentE(a1, *(void *)v9);
                    }
                  }
                }
              }
            }
          }
        }
      }
      v9 += 8;
    }
    while (v9 != v8);
  }
  if (v4 + 4 == v11)
  {
    uint64_t v57 = v4[7];
    uint64_t v58 = v4[8];
    while (v57 != v58)
    {
      unint64_t v59 = *(unsigned int *)(v57 + 4);
      unint64_t v60 = v59 >> 7;
      uint64_t v61 = v3[4];
      if (v59 >> 7 < (v3[5] - v61) >> 3)
      {
        uint64_t v62 = *(void *)(v61 + 8 * v60);
        if (v62)
        {
          unint64_t v63 = *(unsigned __int16 *)(v62 + 2 * (v59 & 0x7F));
          uint64_t v65 = v3[7];
          uint64_t v64 = v3[8];
          if (v63 < (v64 - v65) >> 3)
          {
            uint64_t v66 = v65 + 8 * v63;
            if (v66 != v64 && *(_DWORD *)(v66 + 4) == v59)
            {
              uint64_t v68 = v6[4];
              if (v60 < (v6[5] - v68) >> 3)
              {
                uint64_t v69 = *(void *)(v68 + 8 * v60);
                if (v69)
                {
                  unint64_t v70 = *(unsigned __int16 *)(v69 + 2 * (v59 & 0x7F));
                  uint64_t v72 = v6[7];
                  uint64_t v71 = v6[8];
                  if (v70 < (v71 - v72) >> 3)
                  {
                    uint64_t v73 = v72 + 8 * v70;
                    if (v73 != v71 && *(_DWORD *)(v73 + 4) == v59) {
                      _ZZN2md29ARDebugDrawIntersectionsLogic15runBeforeLayoutERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_25ARWorldIntersectorContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_31ARDebugDrawIntersectionsContextEENK3__0clENS5_6EntityERN12arComponents11LocalBoundsERNSI_20MapTileDataComponentE(a1, *(void *)v57);
                    }
                  }
                }
              }
            }
          }
        }
      }
      v57 += 8;
    }
  }
  if ((void *)v7 == v11)
  {
    uint64_t v76 = v6[7];
    uint64_t v75 = v6[8];
    while (v76 != v75)
    {
      unint64_t v77 = *(unsigned int *)(v76 + 4);
      unint64_t v78 = v77 >> 7;
      uint64_t v79 = v3[4];
      if (v77 >> 7 < (v3[5] - v79) >> 3)
      {
        uint64_t v80 = *(void *)(v79 + 8 * v78);
        if (v80)
        {
          unint64_t v81 = *(unsigned __int16 *)(v80 + 2 * (v77 & 0x7F));
          uint64_t v83 = v3[7];
          uint64_t v82 = v3[8];
          if (v81 < (v82 - v83) >> 3)
          {
            uint64_t v84 = v83 + 8 * v81;
            if (v84 != v82 && *(_DWORD *)(v84 + 4) == v77)
            {
              uint64_t v86 = v4[4];
              if (v78 < (v4[5] - v86) >> 3)
              {
                uint64_t v87 = *(void *)(v86 + 8 * v78);
                if (v87)
                {
                  unint64_t v88 = *(unsigned __int16 *)(v87 + 2 * (v77 & 0x7F));
                  uint64_t v90 = v4[7];
                  uint64_t v89 = v4[8];
                  if (v88 < (v89 - v90) >> 3)
                  {
                    uint64_t v91 = v90 + 8 * v88;
                    if (v91 != v89 && *(_DWORD *)(v91 + 4) == v77) {
                      _ZZN2md29ARDebugDrawIntersectionsLogic15runBeforeLayoutERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_25ARWorldIntersectorContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_31ARDebugDrawIntersectionsContextEENK3__0clENS5_6EntityERN12arComponents11LocalBoundsERNSI_20MapTileDataComponentE(a1, *(void *)v76);
                    }
                  }
                }
              }
            }
          }
        }
      }
      v76 += 8;
    }
  }
  uint64_t v13 = *(int8x8_t **)(a1 + 120);
  int8x16_t v14 = (void *)gdc::Registry::storage<arComponents::DidIntersectFrustum>(v13);
  uint64_t v15 = gdc::Registry::storage<arComponents::WorldBounds>(v13);
  int8x16_t v16 = (void *)v15;
  uint64_t v17 = v15 + 32;
  uint64_t v19 = v14[7];
  uint64_t v18 = v14[8];
  if (*(void *)(v15 + 64) - *(void *)(v15 + 56) >= (unint64_t)(v18 - v19)) {
    int8x16_t v20 = v14 + 4;
  }
  else {
    int8x16_t v20 = (void *)(v15 + 32);
  }
  if (v14 + 4 == v20 && v19 != v18)
  {
    do
    {
      unint64_t v42 = *(unsigned int *)(v19 + 4);
      uint64_t v43 = v16[4];
      if (v42 >> 7 >= (v16[5] - v43) >> 3) {
        goto LABEL_45;
      }
      uint64_t v44 = *(void *)(v43 + 8 * (v42 >> 7));
      if (!v44) {
        goto LABEL_45;
      }
      unint64_t v45 = *(unsigned __int16 *)(v44 + 2 * (v42 & 0x7F));
      uint64_t v47 = v16[7];
      uint64_t v46 = v16[8];
      if (v45 >= (v46 - v47) >> 3) {
        goto LABEL_45;
      }
      uint64_t v48 = v47 + 8 * v45;
      if (v48 == v46 || *(_DWORD *)(v48 + 4) != v42) {
        goto LABEL_45;
      }
      unint64_t v50 = *(void *)v19;
      unint64_t v51 = *(void *)v19 >> 39;
      int8x16_t v52 = (void *)gdc::Registry::storage<arComponents::DidIntersectRaycast>(*(int8x8_t **)(a1 + 120));
      uint64_t v53 = v52[4];
      if (v51 < (v52[5] - v53) >> 3 && (uint64_t v54 = *(void *)(v53 + 8 * v51)) != 0)
      {
        unint64_t v55 = *(unsigned __int16 *)(v54 + 2 * (HIDWORD(v50) & 0x7F));
        uint64_t v56 = v52[7];
        uint64_t v38 = v52[8];
        if (v55 < (v38 - v56) >> 3)
        {
          uint64_t v39 = v56 + 8 * v55;
          if (*(_DWORD *)(v39 + 4) != HIDWORD(v50)) {
            uint64_t v39 = v52[8];
          }
          goto LABEL_44;
        }
      }
      else
      {
        uint64_t v38 = v52[8];
      }
      uint64_t v39 = v38;
LABEL_44:
      int8x16_t v40 = *(int8x8_t **)(a1 + 120);
      v113[0] = 0;
      v113[1] = v39 == v38;
      int v114 = -16776961;
      int8x16_t v41 = (void *)gdc::Registry::storage<arComponents::NeedsDebugDraw>(v40);
      gdc::ComponentStorageWrapper<arComponents::NeedsDebugDraw>::emplace(v41, v50, (uint64_t)v113);
LABEL_45:
      v19 += 8;
    }
    while (v19 != v18);
  }
  if ((void *)v17 == v20)
  {
    uint64_t v93 = v16[7];
    for (uint64_t i = v16[8]; v93 != i; v93 += 8)
    {
      unint64_t v99 = *(unsigned int *)(v93 + 4);
      uint64_t v100 = v14[4];
      if (v99 >> 7 >= (v14[5] - v100) >> 3) {
        continue;
      }
      uint64_t v101 = *(void *)(v100 + 8 * (v99 >> 7));
      if (!v101) {
        continue;
      }
      unint64_t v102 = *(unsigned __int16 *)(v101 + 2 * (v99 & 0x7F));
      uint64_t v104 = v14[7];
      uint64_t v103 = v14[8];
      if (v102 >= (v103 - v104) >> 3) {
        continue;
      }
      uint64_t v105 = v104 + 8 * v102;
      if (v105 == v103 || *(_DWORD *)(v105 + 4) != v99) {
        continue;
      }
      unint64_t v107 = *(void *)v93;
      int v108 = (void *)gdc::Registry::storage<arComponents::DidIntersectRaycast>(*(int8x8_t **)(a1 + 120));
      uint64_t v109 = v108[4];
      if (v107 >> 39 < (v108[5] - v109) >> 3 && (uint64_t v110 = *(void *)(v109 + 8 * (v107 >> 39))) != 0)
      {
        unint64_t v111 = *(unsigned __int16 *)(v110 + 2 * (HIDWORD(v107) & 0x7F));
        uint64_t v112 = v108[7];
        uint64_t v95 = v108[8];
        if (v111 < (v95 - v112) >> 3)
        {
          uint64_t v96 = v112 + 8 * v111;
          if (*(_DWORD *)(v96 + 4) != HIDWORD(v107)) {
            uint64_t v96 = v108[8];
          }
          goto LABEL_104;
        }
      }
      else
      {
        uint64_t v95 = v108[8];
      }
      uint64_t v96 = v95;
LABEL_104:
      int8x16_t v97 = *(int8x8_t **)(a1 + 120);
      v115[0] = 0;
      v115[1] = v96 == v95;
      int v116 = -16776961;
      int16x8_t v98 = (void *)gdc::Registry::storage<arComponents::NeedsDebugDraw>(v97);
      gdc::ComponentStorageWrapper<arComponents::NeedsDebugDraw>::emplace(v98, v107, (uint64_t)v115);
    }
  }
}

uint64_t gdc::Registry::storage<arComponents::DidIntersectFrustum>(int8x8_t *a1)
{
  uint64_t v10 = 0x410D1776E02BD50ALL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x410D1776E02BD50ALL;
    if (*(void *)&v1 <= 0x410D1776E02BD50AuLL) {
      uint64_t v3 = 0x410D1776E02BD50AuLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x410D1776E02BD50ALL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x410D1776E02BD50ALL)
      {
        if (v5[2] == 0x410D1776E02BD50ALL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x410D1776E02BD50ALL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x410D1776E02BD50ALL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A20B1A28(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void _ZZN2md29ARDebugDrawIntersectionsLogic15runBeforeLayoutERKNS_13LayoutContextERKNS_17LogicDependenciesIJN3gdc8TypeListIJNS_25ARWorldIntersectorContextEEEENS6_IJEEEEE20ResolvedDependenciesERNS_31ARDebugDrawIntersectionsContextEENK3__0clENS5_6EntityERN12arComponents11LocalBoundsERNSI_20MapTileDataComponentE(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = (void *)gdc::Registry::storage<arComponents::DidIntersectRaycast>(*(int8x8_t **)(a1 + 120));
  uint64_t v5 = v4[4];
  if (a2 >> 39 < (v4[5] - v5) >> 3
    && (uint64_t v6 = *(void *)(v5 + 8 * (a2 >> 39))) != 0
    && (unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F)), v9 = v4[7], v8 = v4[8], v7 < (v8 - v9) >> 3)
    && ((uint64_t v10 = v9 + 8 * v7, v10 != v8) ? (v11 = *(_DWORD *)(v10 + 4) == HIDWORD(a2)) : (v11 = 0), v11))
  {
    uint64_t v15 = *(int8x8_t **)(a1 + 120);
    __int16 v18 = 0;
    int v19 = -16776961;
    uint64_t v13 = (void *)gdc::Registry::storage<arComponents::NeedsDebugDraw>(v15);
    int8x16_t v14 = &v18;
  }
  else
  {
    int16x8_t v12 = *(int8x8_t **)(a1 + 120);
    __int16 v16 = 257;
    int v17 = -256;
    uint64_t v13 = (void *)gdc::Registry::storage<arComponents::NeedsDebugDraw>(v12);
    int8x16_t v14 = &v16;
  }
  gdc::ComponentStorageWrapper<arComponents::NeedsDebugDraw>::emplace(v13, a2, (uint64_t)v14);
}

uint64_t gdc::Registry::storage<arComponents::DidIntersectRaycast>(int8x8_t *a1)
{
  unint64_t v10 = 0xB9556ADEAD93443FLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xB9556ADEAD93443FLL;
    if (*(void *)&v1 <= 0xB9556ADEAD93443FLL) {
      unint64_t v3 = 0xB9556ADEAD93443FLL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xB9556ADEAD93443FLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xB9556ADEAD93443FLL)
      {
        if (v5[2] == 0xB9556ADEAD93443FLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xB9556ADEAD93443FLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xB9556ADEAD93443FLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A20B1D58(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL gdc::ComponentStorageWrapper<arComponents::DidIntersectRaycast>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::DidIntersectRaycast>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  int8x16_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    int8x16_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::DidIntersectRaycast>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::DidIntersectRaycast>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<arComponents::DidIntersectFrustum>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::DidIntersectFrustum>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  int8x16_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    int8x16_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::DidIntersectFrustum>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::DidIntersectFrustum>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::Logic<md::ARDebugDrawIntersectionsLogic,md::ARDebugDrawIntersectionsContext,md::LogicDependencies<gdc::TypeList<md::ARWorldIntersectorContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::ARDebugDrawIntersectionsLogic,md::ARDebugDrawIntersectionsContext,md::LogicDependencies<gdc::TypeList<md::ARWorldIntersectorContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) != 0xA77E48F1AFA034A1 || !*(void *)(a3 + 32))
  {
    a4[23] = 0;
    *a4 = 0;
    return result;
  }
  uint64_t v4 = *(void **)(a2 + 8);
  int8x8_t v5 = (int8x8_t)v4[1];
  if (!*(void *)&v5) {
    goto LABEL_27;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    uint64_t v7 = 0x6DBE9777D7FEDAAELL;
    if (*(void *)&v5 <= 0x6DBE9777D7FEDAAEuLL) {
      uint64_t v7 = 0x6DBE9777D7FEDAAEuLL % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v7 = (*(void *)&v5 - 1) & 0x6DBE9777D7FEDAAELL;
  }
  uint64_t v8 = *(void **)(*v4 + 8 * v7);
  if (!v8) {
    goto LABEL_27;
  }
  uint64_t v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_27;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v10 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v12 = v9[1];
      if (v12 == 0x6DBE9777D7FEDAAELL)
      {
        if (v9[2] == 0x6DBE9777D7FEDAAELL) {
          goto LABEL_25;
        }
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_27;
      }
      uint64_t v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_27;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v9[1];
    if (v11 == 0x6DBE9777D7FEDAAELL) {
      break;
    }
    if (v11 >= *(void *)&v5) {
      v11 %= *(void *)&v5;
    }
    if (v11 != v7) {
      goto LABEL_27;
    }
LABEL_14:
    uint64_t v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_27;
    }
  }
  if (v9[2] != 0x6DBE9777D7FEDAAELL) {
    goto LABEL_14;
  }
LABEL_25:
  uint64_t v13 = v9[5];
  if (*(void *)(v13 + 8) == 0x6DBE9777D7FEDAAELL)
  {
    uint64_t v14 = *(void *)(v13 + 32);
    goto LABEL_28;
  }
LABEL_27:
  uint64_t v14 = 0;
LABEL_28:
  uint64_t v15 = v14;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 160))(result);
}

uint64_t md::Logic<md::ARDebugDrawIntersectionsLogic,md::ARDebugDrawIntersectionsContext,md::LogicDependencies<gdc::TypeList<md::ARWorldIntersectorContext>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0xA77E48F1AFA034A1 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x6DBE9777D7FEDAAELL;
    if (*(void *)&v4 <= 0x6DBE9777D7FEDAAEuLL) {
      uint64_t v6 = 0x6DBE9777D7FEDAAEuLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x6DBE9777D7FEDAAELL;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x6DBE9777D7FEDAAELL)
      {
        if (v8[2] == 0x6DBE9777D7FEDAAELL) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x6DBE9777D7FEDAAELL) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x6DBE9777D7FEDAAELL) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x6DBE9777D7FEDAAELL)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 152))(result);
}

uint64_t md::Logic<md::ARDebugDrawIntersectionsLogic,md::ARDebugDrawIntersectionsContext,md::LogicDependencies<gdc::TypeList<md::ARWorldIntersectorContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0xA77E48F1AFA034A1 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x6DBE9777D7FEDAAELL;
    if (*(void *)&v4 <= 0x6DBE9777D7FEDAAEuLL) {
      uint64_t v6 = 0x6DBE9777D7FEDAAEuLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x6DBE9777D7FEDAAELL;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x6DBE9777D7FEDAAELL)
      {
        if (v8[2] == 0x6DBE9777D7FEDAAELL) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x6DBE9777D7FEDAAELL) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x6DBE9777D7FEDAAELL) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x6DBE9777D7FEDAAELL)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 144))(result);
}

uint64_t md::Logic<md::ARDebugDrawIntersectionsLogic,md::ARDebugDrawIntersectionsContext,md::LogicDependencies<gdc::TypeList<md::ARWorldIntersectorContext>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0xA77E48F1AFA034A1 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x6DBE9777D7FEDAAELL;
    if (*(void *)&v4 <= 0x6DBE9777D7FEDAAEuLL) {
      uint64_t v6 = 0x6DBE9777D7FEDAAEuLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x6DBE9777D7FEDAAELL;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x6DBE9777D7FEDAAELL)
      {
        if (v8[2] == 0x6DBE9777D7FEDAAELL) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x6DBE9777D7FEDAAELL) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x6DBE9777D7FEDAAELL) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x6DBE9777D7FEDAAELL)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 136))(result);
}

uint64_t md::Logic<md::ARDebugDrawIntersectionsLogic,md::ARDebugDrawIntersectionsContext,md::LogicDependencies<gdc::TypeList<md::ARWorldIntersectorContext>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0xA77E48F1AFA034A1 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x6DBE9777D7FEDAAELL;
    if (*(void *)&v4 <= 0x6DBE9777D7FEDAAEuLL) {
      uint64_t v6 = 0x6DBE9777D7FEDAAEuLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x6DBE9777D7FEDAAELL;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x6DBE9777D7FEDAAELL)
      {
        if (v8[2] == 0x6DBE9777D7FEDAAELL) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x6DBE9777D7FEDAAELL) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x6DBE9777D7FEDAAELL) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x6DBE9777D7FEDAAELL)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 128))(result);
}

void md::Logic<md::ARDebugDrawIntersectionsLogic,md::ARDebugDrawIntersectionsContext,md::LogicDependencies<gdc::TypeList<md::ARWorldIntersectorContext>,gdc::TypeList<>>>::_allocateContext()
{
}

void sub_1A20B28F4(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

uint64_t gdc::ObjectHolder<md::ARDebugDrawIntersectionsContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ARDebugDrawIntersectionsContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555DC0;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0xC400A2AC0F1);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ARDebugDrawIntersectionsContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555DC0;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0xC400A2AC0F1);
  }
  return a1;
}

void md::ARDebugDrawIntersectionsLogic::~ARDebugDrawIntersectionsLogic(md::ARDebugDrawIntersectionsLogic *this)
{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void md::RegionalResourceTileData::~RegionalResourceTileData(md::RegionalResourceTileData *this)
{
  *(void *)this = &unk_1EF545738;
  *((void *)this + 79) = &unk_1EF545778;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 91);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::MapTileData::~MapTileData(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF545738;
  *((void *)this + 79) = &unk_1EF545778;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 91);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::MapTileData::~MapTileData(this);
}

void md::TransitLine::updateFeatureQueryForMergeTypeIfNecessary(uint64_t *a1, unsigned int a2)
{
  __int16 v2 = a2;
  uint64_t v5 = a1[8];
  uint64_t v6 = (uint64_t *)(v5 + 184 * a2);
  int v7 = *((unsigned __int8 *)a1 + 88);
  if (!*((unsigned char *)v6 + 176)
    && *(unsigned __int8 *)(v5 + 184 * a2 + 178) == v7
    && *(unsigned __int8 *)(v5 + 184 * a2 + 179) == a2)
  {
    return;
  }
  memset(v72, 0, sizeof(v72));
  char v73 = 1;
  *(_WORD *)geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[]((uint64_t *)v72, 0x10002u) = v7;
  uint64_t v8 = geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[]((uint64_t *)v72, 0x10015u);
  *(_WORD *)uint64_t v8 = v2;
  *(_WORD *)(v5 + 184 * a2 + 178) = v7 | (v2 << 8);
  uint64_t v9 = *v6;
  if (*v6)
  {
    *(void *)int8x16_t v67 = 0;
    uint64_t v68 = 0;
    uint64_t v8 = *(void *)(v9 + 16);
    if (!v8) {
      goto LABEL_97;
    }
    uint64_t v8 = (uint64_t)std::__shared_weak_count::lock((std::__shared_weak_count *)v8);
    uint64_t v68 = (std::__shared_weak_count *)v8;
    if (!v8) {
      goto LABEL_97;
    }
    uint64_t v10 = *(void *)(v9 + 8);
    *(void *)int8x16_t v67 = v10;
    if (!v10) {
      goto LABEL_97;
    }
    uint64_t v11 = *(void *)(v10 + 520);
    uint64_t v12 = *(std::__shared_weak_count **)(v10 + 528);
    if (v12)
    {
      p_shared_owners = &v12->__shared_owners_;
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      if (*(unsigned char *)(v11 + 252))
      {
        if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
        goto LABEL_79;
      }
      uint64_t v54 = *(void *)(v9 + 256);
      if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
      if (v54)
      {
LABEL_79:
        gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)&v75, *(uint64_t *)v67, (gss::FeatureAttributeSet *)(v9 + 272), (gss::QueryOverrides *)v72);
        long long v55 = v75;
        long long v75 = 0uLL;
        uint64_t v46 = *(std::__shared_weak_count **)(v9 + 264);
        *(_OWORD *)(v9 + 256) = v55;
        if (v46)
        {
LABEL_80:
          if (!atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
            std::__shared_weak_count::__release_weak(v46);
          }
        }
LABEL_82:
        uint64_t v56 = (std::__shared_weak_count *)*((void *)&v75 + 1);
        if (*((void *)&v75 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v75 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
          std::__shared_weak_count::__release_weak(v56);
        }
        uint64_t v57 = *(void *)(*(void *)v67 + 520);
        uint64_t v58 = *(std::__shared_weak_count **)(*(void *)v67 + 528);
        if (v58)
        {
          atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
          int v59 = *(unsigned __int8 *)(v57 + 252);
          if (!atomic_fetch_add(&v58->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
            std::__shared_weak_count::__release_weak(v58);
          }
          if (v59) {
            goto LABEL_97;
          }
          goto LABEL_91;
        }
        if (!*(unsigned char *)(v57 + 252))
        {
LABEL_91:
          unint64_t v60 = (geo::read_write_lock *)pthread_rwlock_wrlock((pthread_rwlock_t *)(v9 + 32));
          if (v60) {
            geo::read_write_lock::logFailure(v60, (uint64_t)"write lock", v61);
          }
          uint64_t v62 = *(void *)(v9 + 24);
          *(void *)(v9 + 24) = 0;
          if (v62) {
            std::default_delete<gss::RenderStyle<gss::PropertyID>>::operator()[abi:nn180100](v62);
          }
          uint64_t v8 = pthread_rwlock_unlock((pthread_rwlock_t *)(v9 + 32));
          if (v8) {
            geo::read_write_lock::logFailure((geo::read_write_lock *)v8, (uint64_t)"unlock", v63);
          }
        }
LABEL_97:
        if (v68 && !atomic_fetch_add(&v68->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
          std::__shared_weak_count::__release_weak(v68);
        }
        goto LABEL_100;
      }
    }
    else if (*(unsigned char *)(v11 + 252) || *(void *)(v9 + 256))
    {
      goto LABEL_79;
    }
    gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)&v75, *(uint64_t *)v67, (gss::FeatureAttributeSet *)(v9 + 272), (gss::QueryOverrides *)v72);
    long long v45 = v75;
    long long v75 = 0uLL;
    uint64_t v46 = *(std::__shared_weak_count **)(v9 + 248);
    *(_OWORD *)(v9 + 240) = v45;
    if (v46) {
      goto LABEL_80;
    }
    goto LABEL_82;
  }
  uint64_t v14 = *a1;
  if (*a1)
  {
    md::createFeatureAttributeSet((gss::Allocator *)v67, (uint64_t *)(a1[2] + 24));
    uint64_t v15 = *(std::__shared_weak_count **)(v14 + 8);
    *(void *)&long long v74 = *(void *)v14;
    if (!v15 || (*((void *)&v74 + 1) = std::__shared_weak_count::lock(v15)) == 0)
    {
      std::__throw_bad_weak_ptr[abi:nn180100]();
      __break(1u);
      return;
    }
    uint64_t v16 = (char *)operator new(0x148uLL);
    unint64_t v17 = v16;
    *(_OWORD *)(v16 + 8) = 0u;
    *(void *)uint64_t v16 = &unk_1EF58A698;
    uint64_t v18 = v16 + 24;
    long long v19 = v74;
    long long v74 = 0u;
    long long v75 = v19;
    long long v20 = v19;
    if (*((void *)&v19 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v19 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    gss::Queryable<gss::PropertyID>::Queryable((uint64_t)(v16 + 24), &v75);
    int8x16_t v21 = (std::__shared_weak_count *)*((void *)&v75 + 1);
    if (*((void *)&v75 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v75 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
    *((void *)v17 + 3) = &unk_1EF567478;
    unint64_t v22 = operator new(0x158uLL);
    unint64_t v23 = v22;
    v22[1] = 0;
    v22[2] = 0;
    void *v22 = &unk_1EF58A5B8;
    uint64_t v24 = v22 + 3;
    if (*((void *)&v20 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v20 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v25 = (gss::Allocator *)gss::StylesheetQuery<gss::PropertyID>::StylesheetQuery((uint64_t)(v22 + 3), v20, *((std::__shared_weak_count **)&v20 + 1), (uint64_t)v67, (uint64_t *)v72);
    if (*((void *)&v20 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v20 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(void))(**((void **)&v20 + 1) + 16))(*((void *)&v20 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v20 + 1));
    }
    *((void *)v17 + 33) = v24;
    *((void *)v17 + 34) = v23;
    *((void *)v17 + 39) = 0;
    *(_OWORD *)(v17 + 280) = 0u;
    *(_OWORD *)(v17 + 296) = 0u;
    *((void *)v17 + 40) = gss::Allocator::instance(v25);
    std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::__assign_with_size[abi:nn180100]<std::pair<gss::StyleAttribute,unsigned short>*,std::pair<gss::StyleAttribute,unsigned short>*>((uint64_t *)v17 + 37, *(uint64_t *)v67, v68, ((uint64_t)v68 - *(void *)v67) >> 3);
    if (*((void *)&v20 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v20 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(void))(**((void **)&v20 + 1) + 16))(*((void *)&v20 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v20 + 1));
    }
    *(void *)&long long v71 = v18;
    *((void *)&v71 + 1) = v17;
    unint64_t v26 = (std::__shared_weak_count *)*((void *)&v74 + 1);
    if (*((void *)&v74 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v74 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
    uint64_t v27 = (pthread_rwlock_t *)(v14 + 320);
    *(void *)&long long v75 = v14 + 320;
    uint64_t v28 = (geo::read_write_lock *)pthread_rwlock_wrlock((pthread_rwlock_t *)(v14 + 320));
    if (v28) {
      geo::read_write_lock::logFailure(v28, (uint64_t)"write lock", v29);
    }
    long long v66 = v71;
    uint64_t v30 = (std::__shared_weak_count *)*((void *)&v71 + 1);
    if (*((void *)&v71 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v71 + 1) + 16), 1uLL, memory_order_relaxed);
    }
    uint64_t v31 = *(_OWORD **)(v14 + 96);
    unint64_t v32 = *(void *)(v14 + 104);
    if ((unint64_t)v31 >= v32)
    {
      uint64_t v37 = *(void *)(v14 + 88);
      uint64_t v38 = ((uint64_t)v31 - v37) >> 4;
      unint64_t v39 = v38 + 1;
      if ((unint64_t)(v38 + 1) >> 60) {
        abort();
      }
      uint64_t v40 = v32 - v37;
      if (v40 >> 3 > v39) {
        unint64_t v39 = v40 >> 3;
      }
      if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF0) {
        uint64_t v41 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v41 = v39;
      }
      if (v41)
      {
        uint64_t v42 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v14 + 112) + 16))(*(void *)(v14 + 112), 16 * v41, 8);
        uint64_t v43 = (_OWORD *)(v42 + 16 * v38);
        uint64_t v44 = v42 + 16 * v41;
        if (v42)
        {
          *uint64_t v43 = v66;
          long long v66 = 0u;
        }
      }
      else
      {
        uint64_t v44 = 0;
        uint64_t v43 = (_OWORD *)(16 * v38);
      }
      uint64_t v47 = v43 + 1;
      uint64_t v48 = *(void **)(v14 + 88);
      int8x16_t v49 = *(void **)(v14 + 96);
      if (v49 == v48)
      {
        *(void *)(v14 + 88) = v43;
        *(void *)(v14 + 96) = v47;
        uint64_t v52 = *(void *)(v14 + 104);
        *(void *)(v14 + 104) = v44;
      }
      else
      {
        do
        {
          long long v50 = *((_OWORD *)v49 - 1);
          v49 -= 2;
          *--uint64_t v43 = v50;
          *int8x16_t v49 = 0;
          v49[1] = 0;
        }
        while (v49 != v48);
        int8x16_t v49 = *(void **)(v14 + 88);
        unint64_t v51 = *(void **)(v14 + 96);
        *(void *)(v14 + 88) = v43;
        *(void *)(v14 + 96) = v47;
        uint64_t v52 = *(void *)(v14 + 104);
        *(void *)(v14 + 104) = v44;
        while (v51 != v49)
        {
          uint64_t v53 = (std::__shared_weak_count *)*(v51 - 1);
          if (v53) {
            std::__shared_weak_count::__release_weak(v53);
          }
          v51 -= 2;
        }
      }
      if (v49) {
        (*(void (**)(void, void *, uint64_t))(**(void **)(v14 + 112) + 40))(*(void *)(v14 + 112), v49, v52 - (void)v49);
      }
      uint64_t v30 = (std::__shared_weak_count *)*((void *)&v66 + 1);
      *(void *)(v14 + 96) = v47;
      if (!*((void *)&v66 + 1)) {
        goto LABEL_40;
      }
    }
    else
    {
      if (v31)
      {
        uint64_t v30 = 0;
        *uint64_t v31 = v66;
      }
      *(void *)(v14 + 96) = v31 + 1;
      if (!v30) {
        goto LABEL_40;
      }
    }
    std::__shared_weak_count::__release_weak(v30);
    uint64_t v27 = (pthread_rwlock_t *)v75;
LABEL_40:
    uint64_t v8 = pthread_rwlock_unlock(v27);
    if (v8) {
      geo::read_write_lock::logFailure((geo::read_write_lock *)v8, (uint64_t)"unlock", v33);
    }
    long long v34 = v71;
    long long v71 = 0uLL;
    uint64_t v35 = (std::__shared_weak_count *)v6[1];
    *(_OWORD *)uint64_t v6 = v34;
    if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
    uint64_t v36 = (std::__shared_weak_count *)*((void *)&v71 + 1);
    if (*((void *)&v71 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v71 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
    if (*(void *)v67)
    {
      uint64_t v68 = *(std::__shared_weak_count **)v67;
      uint64_t v8 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v70 + 40))(v70, *(void *)v67, v69 - *(void *)v67);
    }
  }
LABEL_100:
  *((unsigned char *)v6 + 176) = 0;
  *(unsigned char *)(v5 + 184 * a2 + 177) = 1;
  if (!v72[14])
  {
    uint64_t v64 = *(void *)v72;
    if (*(void *)v72)
    {
      uint64_t v65 = gss::Allocator::instance((gss::Allocator *)v8);
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v65 + 40))(v65, v64, *(unsigned __int16 *)&v72[12]);
    }
  }
}

void sub_1A20B3530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  gss::QueryOverrides::~QueryOverrides((gss::QueryOverrides *)va1);
  _Unwind_Resume(a1);
}

uint64_t md::TransitLine::_resolveStyle(uint64_t a1, char a2, uint64_t a3, std::__shared_weak_count *a4, uint64_t a5)
{
  LOBYTE(v7) = a2;
  *(void *)&long long v127 = a3;
  *((void *)&v127 + 1) = a4;
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v130, a3, (uint64_t)a4);
  if (a4 && !atomic_fetch_add(&a4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a4->__on_zero_shared)(a4);
    std::__shared_weak_count::__release_weak(a4);
    if (!v131) {
      goto LABEL_177;
    }
  }
  else if (!v131)
  {
    goto LABEL_177;
  }
  uint64_t v9 = *(void *)(v130[0] + 24);
  if (v7 >= 0x17u) {
    unsigned int v7 = 23;
  }
  else {
    unsigned int v7 = v7;
  }
  uint64_t v10 = *(float **)v9;
  if (*(void *)v9
    && (float v11 = *v10, LODWORD(v10) = *v10 == 1.0, *(unsigned char *)(v9 + 10))
    && (v11 != 0.0 ? (_ZF = v11 == 1.0) : (_ZF = 1), !_ZF)
    || (v13 = *(unsigned __int8 *)(v9 + v10 + 11), float v11 = 0.0, v13 == 2))
  {
    LOBYTE(v127) = 1;
    char v132 = 1;
    char v14 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v9, 0x5Bu, v7, 0, &v127);
    char v15 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v9, 0x5Bu, v7, 1, &v132);
    if (v11 >= 1.0) {
      char v16 = v15;
    }
    else {
      char v16 = v14;
    }
  }
  else
  {
    char v16 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(v130[0] + 24), 0x5Bu, v7, v13, 0);
  }
  char v132 = 1;
  gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v127, *(void *)(v130[0] + 24), 0x5Cu, v7, 0, (BOOL *)&v132);
  if (v132) {
    float32x4_t v17 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)&v127)), (float32x4_t)vdupq_n_s32(0x37800080u));
  }
  else {
    float32x4_t v17 = *(float32x4_t *)(a1 + 36);
  }
  float32x4_t v123 = v17;
  char v132 = 1;
  gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v127, *(void *)(v130[0] + 24), 0x5Cu, v7, 1u, (BOOL *)&v132);
  if (v132) {
    float32x4_t v18 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)&v127)), (float32x4_t)vdupq_n_s32(0x37800080u));
  }
  else {
    float32x4_t v18 = *(float32x4_t *)(a1 + 36);
  }
  uint64_t v19 = *(void *)(v130[0] + 24);
  long long v20 = *(float **)v19;
  if (!*(void *)v19)
  {
    *(float32x4_t *)a5 = v123;
    *(float32x4_t *)(a5 + 16) = v18;
    unint64_t v22 = (float32x4_t *)(a5 + 16);
    int8x16_t v21 = (float *)(a5 + 28);
    if (v16)
    {
      BOOL v24 = 0;
      goto LABEL_40;
    }
LABEL_42:
    float v28 = 0.0;
    goto LABEL_44;
  }
  *(float32x4_t *)a5 = vmlaq_n_f32(v123, vsubq_f32(v18, v123), *v20);
  int8x16_t v21 = (float *)(a5 + 28);
  *(float32x4_t *)(a5 + 16) = v18;
  unint64_t v22 = (float32x4_t *)(a5 + 16);
  if (!v16) {
    goto LABEL_42;
  }
  float v23 = *v20;
  BOOL v24 = *v20 == 1.0;
  if (!*(unsigned char *)(v19 + 10) || (v23 != 0.0 ? (BOOL v25 = v23 == 1.0) : (BOOL v25 = 1), v25))
  {
LABEL_40:
    unsigned int v26 = *(unsigned __int8 *)(v19 + v24 + 11);
    float v23 = 0.0;
    if (v26 != 2)
    {
      float v28 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v19, 0x5Eu, v7, v26, 0);
      goto LABEL_44;
    }
  }
  LOBYTE(v127) = 1;
  char v132 = 1;
  float v27 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v19, 0x5Eu, v7, 0, &v127);
  float v28 = v27
      + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v19, 0x5Eu, v7, 1u, &v132)- v27)* v23);
LABEL_44:
  *(float *)(a5 + 56) = v28;
  uint64_t v29 = *(void *)(v130[0] + 24);
  uint64_t v30 = *(float **)v29;
  if (*(void *)v29
    && (float v31 = *v30, LODWORD(v30) = *v30 == 1.0, *(unsigned char *)(v29 + 10))
    && (v31 != 0.0 ? (BOOL v32 = v31 == 1.0) : (BOOL v32 = 1), !v32)
    || (v33 = *(unsigned __int8 *)(v29 + v30 + 11), float v31 = 0.0, v33 == 2))
  {
    LOBYTE(v127) = 1;
    char v132 = 1;
    float v34 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v29, 0x108u, v7, 0, &v127);
    float v35 = v34
        + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v29, 0x108u, v7, 1u, &v132)- v34)* v31);
  }
  else
  {
    float v35 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v130[0] + 24), 0x108u, v7, v33, 0);
  }
  *(float *)(a5 + 60) = v35;
  if (v16)
  {
    uint64_t v36 = *(void *)(v130[0] + 24);
    uint64_t v37 = *(float **)v36;
    if (*(void *)v36 && (float v38 = *v37, LODWORD(v37) = *v37 == 1.0, *(unsigned char *)(v36 + 10)) && v38 != 0.0 && v38 != 1.0
      || (v39 = *(unsigned __int8 *)(v36 + v37 + 11), float v38 = 0.0, v39 == 2))
    {
      LOBYTE(v127) = 1;
      char v132 = 1;
      float v40 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v36, 0x61u, v7, 0, &v127);
      float v41 = v40
          + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v36, 0x61u, v7, 1u, &v132)- v40)* v38);
    }
    else
    {
      float v41 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v130[0] + 24), 0x61u, v7, v39, 0);
    }
  }
  else
  {
    float v41 = 0.0;
  }
  *(float *)(a5 + 64) = v41;
  gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v127, *(void *)(v130[0] + 24), 0x5Du, v7, 2u, 0);
  *(float32x4_t *)(a5 + 32) = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)&v127)), (float32x4_t)vdupq_n_s32(0x37800080u));
  uint64_t v42 = *(void *)(v130[0] + 24);
  uint64_t v43 = *(float **)v42;
  if (*(void *)v42 && (float v44 = *v43, LODWORD(v43) = *v43 == 1.0, *(unsigned char *)(v42 + 10)) && v44 != 0.0 && v44 != 1.0
    || (v45 = *(unsigned __int8 *)(v42 + v43 + 11), float v44 = 0.0, v45 == 2))
  {
    LOBYTE(v127) = 1;
    char v132 = 1;
    char v46 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v42, 0x109u, v7, 0, &v127);
    char v47 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v42, 0x109u, v7, 1, &v132);
    if (v44 < 1.0) {
      char v47 = v46;
    }
  }
  else
  {
    char v47 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(v130[0] + 24), 0x109u, v7, v45, 0);
  }
  *(unsigned char *)(a5 + 68) = v47 != 0;
  uint64_t v48 = *(void *)(v130[0] + 24);
  int8x16_t v49 = *(float **)v48;
  if (*(void *)v48 && (float v50 = *v49, LODWORD(v49) = *v49 == 1.0, *(unsigned char *)(v48 + 10)) && v50 != 0.0 && v50 != 1.0
    || (v51 = *(unsigned __int8 *)(v48 + v49 + 11), float v50 = 0.0, v51 == 2))
  {
    LOBYTE(v127) = 1;
    char v132 = 1;
    int v52 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v48, 0x10Bu, v7, 0, &v127);
    int v53 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v48, 0x10Bu, v7, 1u, &v132);
    if (v50 < 1.0) {
      int v53 = v52;
    }
  }
  else
  {
    int v53 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(v130[0] + 24), 0x10Bu, v7, v51, 0);
  }
  *(_DWORD *)(a5 + 72) = v53;
  uint64_t v54 = *(void *)(v130[0] + 24);
  long long v55 = *(float **)v54;
  if (*(void *)v54 && (float v56 = *v55, LODWORD(v55) = *v55 == 1.0, *(unsigned char *)(v54 + 10)) && v56 != 0.0 && v56 != 1.0
    || (v57 = *(unsigned __int8 *)(v54 + v55 + 11), float v56 = 0.0, v57 == 2))
  {
    LOBYTE(v127) = 1;
    char v132 = 1;
    char v58 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v54, 0x10Cu, v7, 0, &v127);
    char v59 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v54, 0x10Cu, v7, 1, &v132);
    if (v56 < 1.0) {
      char v59 = v58;
    }
  }
  else
  {
    char v59 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(v130[0] + 24), 0x10Cu, v7, v57, 0);
  }
  *(unsigned char *)(a5 + 76) = v59 != 0;
  uint64_t v60 = *(void *)(v130[0] + 24);
  uint64_t v61 = *(float **)v60;
  if (*(void *)v60 && (float v62 = *v61, LODWORD(v61) = *v61 == 1.0, *(unsigned char *)(v60 + 10)) && v62 != 0.0 && v62 != 1.0
    || (v63 = *(unsigned __int8 *)(v60 + v61 + 11), float v62 = 0.0, v63 == 2))
  {
    LOBYTE(v127) = 1;
    char v132 = 1;
    int v64 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v60, 0x10Du, v7, 0, &v127);
    int v65 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v60, 0x10Du, v7, 1u, &v132);
    if (v62 < 1.0) {
      int v65 = v64;
    }
  }
  else
  {
    int v65 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(v130[0] + 24), 0x10Du, v7, v63, 0);
  }
  *(_DWORD *)(a5 + 80) = v65;
  uint64_t v66 = *(void *)(v130[0] + 24);
  int8x16_t v67 = *(float **)v66;
  if (*(void *)v66 && (float v68 = *v67, LODWORD(v67) = *v67 == 1.0, *(unsigned char *)(v66 + 10)) && v68 != 0.0 && v68 != 1.0
    || (v69 = *(unsigned __int8 *)(v66 + v67 + 11), float v68 = 0.0, v69 == 2))
  {
    LOBYTE(v127) = 1;
    char v132 = 1;
    int v70 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v66, 0x68u, v7, 0, &v127);
    int v71 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v66, 0x68u, v7, 1u, &v132);
    if (v68 < 1.0) {
      int v71 = v70;
    }
  }
  else
  {
    int v71 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(v130[0] + 24), 0x68u, v7, v69, 0);
  }
  *(_DWORD *)(a5 + 84) = v71;
  uint64_t v72 = v130[0];
  if (*(float *)(a5 + 12) > 0.0)
  {
    uint64_t v73 = *(void *)(v130[0] + 24);
    long long v74 = *(float **)v73;
    if (*(void *)v73)
    {
      float v75 = *v74;
      BOOL v76 = *v74 == 1.0;
      if (*(unsigned char *)(v73 + 10) && v75 != 0.0 && v75 != 1.0)
      {
LABEL_116:
        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v130[0] + 24), 0x114u, v7, 0)) {
          goto LABEL_119;
        }
        unsigned int v77 = 1;
LABEL_118:
        if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v73, 0x114u, v7, v77)) {
          goto LABEL_129;
        }
LABEL_119:
        float32x4_t v124 = *(float32x4_t *)a5;
        if (v74)
        {
          float v78 = *v74;
          BOOL v79 = *v74 == 1.0;
          if (*(unsigned char *)(v73 + 10) && v78 != 0.0 && v78 != 1.0) {
            goto LABEL_126;
          }
        }
        else
        {
          BOOL v79 = 0;
        }
        unsigned int v80 = *(unsigned __int8 *)(v73 + v79 + 11);
        float v78 = 0.0;
        if (v80 != 2)
        {
          float v82 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v73, 0x114u, v7, v80, 0);
          goto LABEL_128;
        }
LABEL_126:
        LOBYTE(v127) = 1;
        char v132 = 1;
        float v81 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v73, 0x114u, v7, 0, &v127);
        float v82 = v81
            + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v73, 0x114u, v7, 1u, &v132)- v81)* v78);
LABEL_128:
        __asm
        {
          FMOV            V1.4S, #-1.0
          FMOV            V2.4S, #1.0
        }
        *(float32x4_t *)a5 = vmlaq_n_f32(_Q2, vaddq_f32(v124, _Q1), v82);
        uint64_t v72 = v130[0];
        goto LABEL_129;
      }
    }
    else
    {
      BOOL v76 = 0;
    }
    unsigned int v77 = *(unsigned __int8 *)(v73 + v76 + 11);
    if (v77 != 2) {
      goto LABEL_118;
    }
    goto LABEL_116;
  }
LABEL_129:
  if (*v21 <= 0.0) {
    goto LABEL_137;
  }
  uint64_t v88 = *(void *)(v72 + 24);
  unsigned int v89 = *(unsigned __int8 *)(v88 + 12);
  if (v89 != 2)
  {
    if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v88, 0x114u, v7, *(unsigned __int8 *)(v88 + 12)))goto LABEL_137; {
    float32x4_t v125 = *v22;
    }
    int v90 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v88, 0x114u, v7, v89, 0);
    goto LABEL_136;
  }
  if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v88, 0x114u, v7, 0) & 1) != 0
    || (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v88, 0x114u, v7, 1u) & 1) != 0)
  {
    float32x4_t v125 = *v22;
    LOBYTE(v127) = 1;
    char v132 = 1;
    int v122 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v88, 0x114u, v7, 0, &v127);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v88, 0x114u, v7, 1u, &v132);
    int v90 = v122;
LABEL_136:
    __asm
    {
      FMOV            V0.4S, #-1.0
      FMOV            V1.4S, #1.0
    }
    float32x4_t *v22 = vmlaq_n_f32(_Q1, vaddq_f32(v125, _Q0), *(float *)&v90);
    uint64_t v72 = v130[0];
  }
LABEL_137:
  float v93 = *(float *)(a5 + 44);
  if (v93 <= 0.0) {
    goto LABEL_158;
  }
  uint64_t v94 = *(void *)(v72 + 24);
  uint64_t v95 = *(float **)v94;
  if (!*(void *)v94)
  {
    BOOL v97 = 0;
    goto LABEL_144;
  }
  float v96 = *v95;
  BOOL v97 = *v95 == 1.0;
  if (!*(unsigned char *)(v94 + 10) || v96 == 0.0 || v96 == 1.0)
  {
LABEL_144:
    unsigned int v98 = *(unsigned __int8 *)(v94 + v97 + 11);
    if (v98 != 2) {
      goto LABEL_147;
    }
  }
  if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v72 + 24), 0x115u, v7, 0)) {
    goto LABEL_148;
  }
  unsigned int v98 = 1;
LABEL_147:
  if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v94, 0x115u, v7, v98))
  {
LABEL_148:
    float32x4_t v126 = *(float32x4_t *)(a5 + 32);
    if (v95)
    {
      float v99 = *v95;
      BOOL v100 = *v95 == 1.0;
      if (*(unsigned char *)(v94 + 10) && v99 != 0.0 && v99 != 1.0) {
        goto LABEL_155;
      }
    }
    else
    {
      BOOL v100 = 0;
    }
    unsigned int v101 = *(unsigned __int8 *)(v94 + v100 + 11);
    float v99 = 0.0;
    if (v101 != 2)
    {
      float v103 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v94, 0x115u, v7, v101, 0);
      goto LABEL_157;
    }
LABEL_155:
    LOBYTE(v127) = 1;
    char v132 = 1;
    float v102 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v94, 0x115u, v7, 0, &v127);
    float v103 = v102
         + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v94, 0x115u, v7, 1u, &v132)- v102)* v99);
LABEL_157:
    __asm
    {
      FMOV            V1.4S, #-1.0
      FMOV            V2.4S, #1.0
    }
    float32x4_t v106 = vmlaq_n_f32(_Q2, vaddq_f32(v126, _Q1), v103);
    *(float32x4_t *)(a5 + 32) = v106;
    float v93 = v106.f32[3];
    uint64_t v72 = v130[0];
  }
LABEL_158:
  *(float *)(a5 + 64) = *(float *)(a5 + 56) + (float)(*(float *)(a5 + 64) * 2.0);
  *(_DWORD *)(a5 + 48) = *(_DWORD *)(a5 + 12);
  *(float *)(a5 + 52) = v93;
  gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<gss::DashPattern>((uint64_t)&v127, *(void *)(v72 + 24), 0x12Cu, v7, 2);
  uint64_t v107 = *(void *)(a5 + 96);
  if (v107)
  {
    *(void *)(a5 + 104) = v107;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a5 + 120) + 40))(*(void *)(a5 + 120), v107, *(void *)(a5 + 112) - v107);
    *(void *)(a5 + 96) = 0;
    *(void *)(a5 + 104) = 0;
    *(void *)(a5 + 112) = 0;
  }
  *(_OWORD *)(a5 + 96) = v127;
  *(void *)(a5 + 112) = v128;
  *(_DWORD *)(a5 + 128) = v129;
  uint64_t v108 = *(void *)(v130[0] + 24);
  uint64_t v109 = *(float **)v108;
  if (*(void *)v108
    && (float v110 = *v109, LODWORD(v109) = *v109 == 1.0, *(unsigned char *)(v108 + 10))
    && v110 != 0.0
    && v110 != 1.0
    || (v111 = *(unsigned __int8 *)(v108 + v109 + 11), float v110 = 0.0, v111 == 2))
  {
    LOBYTE(v127) = 1;
    char v132 = 1;
    float v112 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v108, 0x146u, v7, 0, &v127);
    float v113 = v112
         + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v108, 0x146u, v7, 1u, &v132)- v112)* v110);
  }
  else
  {
    float v113 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v130[0] + 24), 0x146u, v7, v111, 0);
  }
  *(float *)(a5 + 152) = v113;
  gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v127, *(void *)(v130[0] + 24), 0x97u, v7, 2u, 0);
  *(float32x4_t *)(a5 + 136) = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)&v127)), (float32x4_t)vdupq_n_s32(0x37800080u));
  uint64_t v114 = *(void *)(v130[0] + 24);
  long long v115 = *(float **)v114;
  if (*(void *)v114
    && (float v116 = *v115, LODWORD(v115) = *v115 == 1.0, *(unsigned char *)(v114 + 10))
    && v116 != 0.0
    && v116 != 1.0
    || (v117 = *(unsigned __int8 *)(v114 + v115 + 11), float v116 = 0.0, v117 == 2))
  {
    LOBYTE(v127) = 1;
    char v132 = 1;
    int v118 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v114, 0x155u, v7, 0, &v127);
    int v119 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v114, 0x155u, v7, 1u, &v132);
    if (v116 < 1.0) {
      LOBYTE(v119) = v118;
    }
  }
  else
  {
    int v119 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(v130[0] + 24), 0x155u, v7, v117, 0);
  }
  *(unsigned char *)(a5 + 88) = v119;
LABEL_177:
  float v120 = *(float *)(a5 + 52);
  *(float *)(a5 + 12) = *(float *)(a1 + 52) * *(float *)(a5 + 48);
  *(float *)(a5 + 44) = *(float *)(a1 + 52) * v120;
  return gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v130);
}

void sub_1A20B45D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<gss::DashPattern>(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  if (a5 == 2)
  {
    uint64_t v9 = *(void *)a2;
    if (*(void *)a2)
    {
      float v10 = *(float *)v9;
      LODWORD(v9) = *(float *)v9 == 1.0;
      if (*(unsigned char *)(a2 + 10))
      {
        if (v10 != 0.0 && v10 != 1.0) {
          goto LABEL_12;
        }
      }
    }
    uint64_t v9 = v9;
  }
  else
  {
    uint64_t v9 = 1;
  }
  unsigned int v12 = *(unsigned __int8 *)(a2 + v9 + 11);
  float v10 = 0.0;
  if (v12 != 2)
  {
    float v23 = gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<gss::DashPattern>(a2, a3, a4, v12, 0);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    uint64_t result = v23[3];
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = result;
    BOOL v25 = (_DWORD *)*v23;
    unsigned int v26 = (_DWORD *)v23[1];
    uint64_t v27 = (uint64_t)v26 - *v23;
    if (v26 != (_DWORD *)*v23)
    {
      if (v27 < 0) {
        goto LABEL_59;
      }
      uint64_t v28 = v27 >> 2;
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
      *(void *)a1 = result;
      *(void *)(a1 + 16) = result + 4 * v28;
      do
      {
        if (result) {
          *(_DWORD *)uint64_t result = *v25;
        }
        ++v25;
        result += 4;
      }
      while (v25 != v26);
      *(void *)(a1 + 8) = result;
    }
    *(_DWORD *)(a1 + 32) = *((_DWORD *)v23 + 8);
    return result;
  }
LABEL_12:
  char v47 = 1;
  char v46 = 1;
  int v13 = gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<gss::DashPattern>(a2, a3, a4, 0, &v47);
  char v14 = v13;
  uint64_t v15 = v13[3];
  uint64_t v16 = *v13;
  uint64_t v17 = v13[1];
  uint64_t v18 = v17 - *v13;
  if (v17 != *v13)
  {
    if ((v18 & 0x8000000000000000) == 0)
    {
      uint64_t v19 = v18 >> 2;
      uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 16))(v13[3]);
      int8x16_t v21 = (char *)v20;
      uint64_t v22 = 0;
      do
      {
        if (v20 + v22) {
          *(_DWORD *)(v20 + v22) = *(_DWORD *)(v16 + v22);
        }
        v22 += 4;
      }
      while (v16 + v22 != v17);
      uint64_t v29 = (char *)(v20 + v22);
      uint64_t v45 = v20 + 4 * v19;
      goto LABEL_28;
    }
LABEL_59:
    abort();
  }
  uint64_t v29 = 0;
  uint64_t v45 = 0;
  int8x16_t v21 = 0;
LABEL_28:
  float v30 = *((float *)v14 + 8);
  float v31 = gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<gss::DashPattern>(a2, a3, a4, 1u, &v46);
  BOOL v32 = v31;
  uint64_t v33 = v31[3];
  uint64_t v35 = *v31;
  uint64_t v34 = v31[1];
  uint64_t v36 = v34 - *v31;
  if (v34 == *v31)
  {
    float v38 = 0;
    float v40 = 0;
  }
  else
  {
    if (v36 < 0) {
      abort();
    }
    uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v33 + 16))(v31[3], v36, 4);
    float v38 = (char *)v37;
    uint64_t v39 = 0;
    do
    {
      if (v37 + v39) {
        *(_DWORD *)(v37 + v39) = *(_DWORD *)(v35 + v39);
      }
      v39 += 4;
    }
    while (v35 + v39 != v34);
    float v40 = (char *)(v37 + v39);
    uint64_t v36 = v37 + 4 * (v36 >> 2);
  }
  float v41 = *((float *)v32 + 8);
  if (v10 >= 1.0) {
    uint64_t result = v33;
  }
  else {
    uint64_t result = v15;
  }
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = result;
  if (v10 >= 1.0) {
    uint64_t v42 = v38;
  }
  else {
    uint64_t v42 = v21;
  }
  if (v10 >= 1.0) {
    uint64_t v29 = v40;
  }
  uint64_t v43 = v29 - v42;
  if (v29 != v42)
  {
    if (v43 < 0) {
      abort();
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, int64_t, uint64_t))(*(void *)result + 16))(result, v29 - v42, 4);
    *(void *)a1 = result;
    *(void *)(a1 + 16) = result + 4 * (v43 >> 2);
    do
    {
      if (result) {
        *(_DWORD *)uint64_t result = *(_DWORD *)v42;
      }
      v42 += 4;
      result += 4;
    }
    while (v42 != v29);
    *(void *)(a1 + 8) = result;
  }
  if (v10 >= 1.0) {
    float v44 = v41;
  }
  else {
    float v44 = v30;
  }
  *(float *)(a1 + 32) = v44;
  if (v38) {
    uint64_t result = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)v33 + 40))(v33, v38, v36 - (void)v38);
  }
  if (v21) {
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)v15 + 40))(v15, v21, v45 - (void)v21);
  }
  return result;
}

void sub_1A20B49F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (v12)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v11 + 40))(v11, v12, v13 - v12);
    if (!v10) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if (!v10)
  {
    goto LABEL_3;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 40))(v9, v10, a9 - v10);
  _Unwind_Resume(exception_object);
}

uint64_t *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<gss::DashPattern>(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned char *a5)
{
  uint64_t v5 = *(void *)(a1 + 16 * a4 + 16);
  if (!v5)
  {
    if (a5) {
      *a5 = 0;
    }
    return (uint64_t *)gss::defaultValueForKey<gss::PropertyID,gss::DashPattern>();
  }
  uint64_t v6 = a1 + 16 * a4;
  uint64_t v7 = *(unsigned __int16 *)(v6 + 56);
  if (*(_WORD *)(v6 + 56))
  {
    uint64_t v8 = *(void *)(v6 + 48);
    uint64_t v9 = v8 + 8 * v7;
    do
    {
      uint64_t v11 = *(uint64_t **)(*(void *)v8 + 72);
      if (v11)
      {
        uint64_t v14 = *v11;
        uint64_t v12 = v11 + 2;
        uint64_t v13 = v14;
        uint64_t v15 = (unsigned __int16 **)(v14 + 80 * *((unsigned __int8 *)v12 + a3));
        unint64_t v16 = *((unsigned __int16 *)v15 + 5);
        if (*((_WORD *)v15 + 5))
        {
          uint64_t v17 = *v15;
          if (*((unsigned char *)v15 + 15))
          {
            if (v16 >= 0x1E)
            {
              uint64_t v22 = *v15;
              unint64_t v23 = v16;
              do
              {
                unint64_t v24 = v23 >> 1;
                BOOL v25 = &v22[v23 >> 1];
                unsigned int v27 = *v25;
                unsigned int v26 = v25 + 1;
                v23 += ~(v23 >> 1);
                if (v27 < a2) {
                  uint64_t v22 = v26;
                }
                else {
                  unint64_t v23 = v24;
                }
              }
              while (v23);
              if (v22 == &v17[v16] || *v22 != a2) {
                goto LABEL_6;
              }
              unint64_t v10 = (unint64_t)((char *)v22 - (char *)v17) >> 1;
            }
            else
            {
              uint64_t v18 = 0;
              while (1)
              {
                unsigned int v19 = v17[v18];
                if (v19 >= a2) {
                  break;
                }
                if (v16 == ++v18) {
                  goto LABEL_6;
                }
              }
              if (v19 == a2) {
                LOWORD(v10) = v18;
              }
              else {
                LOWORD(v10) = v16;
              }
            }
          }
          else
          {
            uint64_t v20 = 2 * v16;
            int8x16_t v21 = *v15;
            while (*v21 != a2)
            {
              ++v21;
              v20 -= 2;
              if (!v20)
              {
                int8x16_t v21 = &v17[v16];
                break;
              }
            }
            unint64_t v10 = (unint64_t)((char *)v21 - (char *)v17) >> 1;
          }
        }
        else
        {
          LOWORD(v10) = 0;
        }
        if (v16 != (unsigned __int16)v10)
        {
          if (a3 >= 0x17) {
            unsigned int v35 = 23;
          }
          else {
            unsigned int v35 = a3;
          }
          uint64_t v30 = v13 + 80 * *((unsigned __int8 *)v12 + v35);
          return gss::PropertySetValueHelper<gss::PropertyID,gss::DashPattern>::value(a2, v30);
        }
      }
LABEL_6:
      v8 += 8;
    }
    while (v8 != v9);
  }
  uint64_t v28 = *(void **)(v5 + 72);
  if (!v28) {
    goto LABEL_69;
  }
  uint64_t v29 = a3 >= 0x17 ? 23 : a3;
  uint64_t v30 = *v28 + 80 * *((unsigned __int8 *)v28 + v29 + 16);
  uint64_t v31 = *(unsigned __int16 *)(v30 + 10);
  if (!*(_WORD *)(v30 + 10)) {
    goto LABEL_69;
  }
  BOOL v32 = *(unsigned __int16 **)v30;
  if (!*(unsigned char *)(v30 + 15))
  {
    uint64_t v36 = 2 * v31;
    uint64_t v37 = *(unsigned __int16 **)v30;
    while (*v37 != a2)
    {
      ++v37;
      v36 -= 2;
      if (!v36)
      {
        uint64_t v37 = &v32[v31];
        break;
      }
    }
    if (v31 == (unsigned __int16)((unint64_t)((char *)v37 - (char *)v32) >> 1)) {
      goto LABEL_69;
    }
    return gss::PropertySetValueHelper<gss::PropertyID,gss::DashPattern>::value(a2, v30);
  }
  if (v31 >= 0x1E)
  {
    float v38 = *(unsigned __int16 **)v30;
    unint64_t v39 = *(unsigned __int16 *)(v30 + 10);
    do
    {
      unint64_t v40 = v39 >> 1;
      float v41 = &v38[v39 >> 1];
      unsigned int v43 = *v41;
      uint64_t v42 = v41 + 1;
      v39 += ~(v39 >> 1);
      if (v43 < a2) {
        float v38 = v42;
      }
      else {
        unint64_t v39 = v40;
      }
    }
    while (v39);
    if (v38 != &v32[v31]
      && *v38 == a2
      && v31 != (unsigned __int16)((unint64_t)((char *)v38 - (char *)v32) >> 1))
    {
      return gss::PropertySetValueHelper<gss::PropertyID,gss::DashPattern>::value(a2, v30);
    }
LABEL_69:
    if (a5) {
      *a5 = 0;
    }
    return (uint64_t *)gss::defaultValueForKey<gss::PropertyID,gss::DashPattern>();
  }
  uint64_t v33 = 0;
  while (1)
  {
    unsigned int v34 = v32[v33];
    if (v34 >= a2) {
      break;
    }
    if (v31 == ++v33) {
      goto LABEL_69;
    }
  }
  if (v34 == a2) {
    unsigned __int16 v44 = v33;
  }
  else {
    unsigned __int16 v44 = *(_WORD *)(v30 + 10);
  }
  if (v31 == v44) {
    goto LABEL_69;
  }
  return gss::PropertySetValueHelper<gss::PropertyID,gss::DashPattern>::value(a2, v30);
}

uint64_t *gss::PropertySetValueHelper<gss::PropertyID,gss::DashPattern>::value(unsigned int a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int16 *)(a2 + 74);
  if (!*(_WORD *)(a2 + 74)) {
    goto LABEL_21;
  }
  uint64_t v3 = *(void *)(a2 + 64);
  if (*(unsigned char *)(a2 + 79))
  {
    if (v2 < 0x1E)
    {
      uint64_t v4 = 0;
      while (1)
      {
        unsigned int v5 = *(unsigned __int16 *)(v3 + 2 * v4);
        if (v5 >= a1) {
          break;
        }
        if (v2 == ++v4) {
          goto LABEL_21;
        }
      }
      unsigned int v13 = (unsigned __int16)v4;
      if (v5 != a1) {
        unsigned int v13 = *(unsigned __int16 *)(a2 + 74);
      }
      if (v13 != v2) {
        return *(uint64_t **)(*(void *)(a2 + 64) + *(unsigned __int16 *)(a2 + 72) + 16 * v13 + 8);
      }
      goto LABEL_21;
    }
    uint64_t v7 = *(unsigned __int16 **)(a2 + 64);
    unint64_t v8 = *(unsigned __int16 *)(a2 + 74);
    do
    {
      unint64_t v9 = v8 >> 1;
      unint64_t v10 = &v7[v8 >> 1];
      unsigned int v12 = *v10;
      uint64_t v11 = v10 + 1;
      v8 += ~(v8 >> 1);
      if (v12 < a1) {
        uint64_t v7 = v11;
      }
      else {
        unint64_t v8 = v9;
      }
    }
    while (v8);
    if (v7 == (unsigned __int16 *)(v3 + 2 * v2) || *v7 != a1) {
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v6 = 2 * v2;
    uint64_t v7 = *(unsigned __int16 **)(a2 + 64);
    while (*v7 != a1)
    {
      ++v7;
      v6 -= 2;
      if (!v6)
      {
        LODWORD(v7) = v3 + 2 * v2;
        break;
      }
    }
  }
  unsigned int v13 = (unsigned __int16)((v7 - v3) >> 1);
  if (v13 != v2) {
    return *(uint64_t **)(*(void *)(a2 + 64) + *(unsigned __int16 *)(a2 + 72) + 16 * v13 + 8);
  }
LABEL_21:
  if (v15)
  {
    gss::PropertySetValueHelper<gss::PropertyID,gss::DashPattern>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue = 0;
    unk_1E958C9A0 = 0;
    qword_1E958C9A8 = 0;
    qword_1E958C9B0 = gss::Allocator::instance(v15);
    __cxa_atexit((void (*)(void *))gss::DashPattern::~DashPattern, &gss::PropertySetValueHelper<gss::PropertyID,gss::DashPattern>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue, &dword_1A1780000);
  }
  return &gss::PropertySetValueHelper<gss::PropertyID,gss::DashPattern>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
}

void gss::DashPattern::~DashPattern(gss::DashPattern *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v1;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 3) + 40))(*((void *)this + 3), v1, *((void *)this + 2) - v1);
  }
}

{
  uint64_t v1;

  uint64_t v1 = *(void *)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v1;
    std::allocator_traits<geo::StdAllocator<float,gss::Allocator>>::deallocate[abi:ne180100]((void *)this + 3, v1, (*((void *)this + 2) - v1) >> 2);
  }
}

uint64_t std::__shared_ptr_emplace<gss::StylesheetQuery<gss::PropertyID>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<gss::StylesheetQuery<gss::PropertyID>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A5B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gss::StylesheetQuery<gss::PropertyID>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A5B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t gss::FeatureQueryImpl<gss::PropertyID>::getAttributeMapForStyle(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = (uint64_t *)(a1 + 256);
    if (!*(void *)(a1 + 256)) {
      uint64_t v3 = (uint64_t *)(a1 + 240);
    }
    uint64_t result = *v3;
    if (*v3) {
      return (*(uint64_t (**)(void))(*(void *)result + 64))();
    }
  }
  else
  {
    uint64_t result = *(void *)(a1 + 240);
    if (result) {
      return (*(uint64_t (**)(void))(*(void *)result + 64))();
    }
  }
  return result;
}

void gss::FeatureQueryImpl<gss::PropertyID>::unlock(uint64_t a1)
{
  uint64_t v2 = (unint64_t *)(a1 + 240);
  unint64_t v3 = *(void *)(a1 + 240);
  unint64_t v4 = *(void *)(a1 + 256);
  if (v3 >= v4) {
    uint64_t v5 = a1 + 240;
  }
  else {
    uint64_t v5 = a1 + 256;
  }
  uint64_t v6 = *(std::__shared_weak_count **)(v5 + 8);
  if (v3 >= v4) {
    uint64_t v7 = *(void *)(a1 + 240);
  }
  else {
    uint64_t v7 = *(void *)(a1 + 256);
  }
  unsigned int v13 = v6;
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    unint64_t v3 = *v2;
    unint64_t v4 = *(void *)(a1 + 256);
  }
  if (v3 >= v4) {
    uint64_t v2 = (unint64_t *)(a1 + 256);
  }
  unint64_t v8 = *v2;
  unint64_t v9 = (std::__shared_weak_count *)v2[1];
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v8) {
    (*(void (**)(unint64_t))(*(void *)v8 + 56))(v8);
  }
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 56))(v7);
  }
  unint64_t v10 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 32));
  if (v10) {
    geo::read_write_lock::logFailure(v10, (uint64_t)"unlock", v11);
  }
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    unsigned int v12 = v13;
    if (!v13) {
      return;
    }
  }
  else
  {
    unsigned int v12 = v13;
    if (!v13) {
      return;
    }
  }
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
}

void sub_1A20B5184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t gss::FeatureQueryImpl<gss::PropertyID>::lock(void *a1, uint64_t a2)
{
  unint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3) {
    return 0;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v3);
  uint64_t v18 = v5;
  if (!v5) {
    return 0;
  }
  if (!a1[1])
  {
    uint64_t v15 = v5;
    uint64_t v14 = 0;
LABEL_38:
    if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    return v14;
  }
  uint64_t v6 = a1 + 30;
  unint64_t v7 = a1[30];
  unint64_t v8 = a1[32];
  if (v7 >= v8) {
    unint64_t v9 = a1 + 30;
  }
  else {
    unint64_t v9 = a1 + 32;
  }
  unint64_t v10 = (std::__shared_weak_count *)v9[1];
  if (v7 >= v8) {
    unint64_t v11 = a1[30];
  }
  else {
    unint64_t v11 = a1[32];
  }
  uint64_t v17 = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    unint64_t v7 = *v6;
    unint64_t v8 = a1[32];
  }
  if (v7 >= v8) {
    uint64_t v6 = a1 + 32;
  }
  unint64_t v13 = *v6;
  unsigned int v12 = (std::__shared_weak_count *)v6[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v11 && ((*(uint64_t (**)(unint64_t, void))(*(void *)v11 + 48))(v11, 0) & 1) == 0)
  {
LABEL_31:
    uint64_t v14 = 0;
    if (!v12) {
      goto LABEL_34;
    }
    goto LABEL_32;
  }
  if (v13 && ((*(uint64_t (**)(unint64_t, void))(*(void *)v13 + 48))(v13, 0) & 1) == 0)
  {
    unint64_t v13 = v11;
    if (!v11) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  if ((gss::Queryable<gss::PropertyID>::lock((uint64_t)a1, a2) & 1) == 0)
  {
    if (v11) {
      (*(void (**)(unint64_t))(*(void *)v11 + 56))(v11);
    }
    if (!v13) {
      goto LABEL_31;
    }
LABEL_30:
    (*(void (**)(unint64_t))(*(void *)v13 + 56))(v13);
    goto LABEL_31;
  }
  uint64_t v14 = 1;
  if (!v12) {
    goto LABEL_34;
  }
LABEL_32:
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
LABEL_34:
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v15 = v18;
  if (v18) {
    goto LABEL_38;
  }
  return v14;
}

void sub_1A20B5430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
}

uint64_t gss::FeatureQueryImpl<gss::PropertyID>::resolve(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 240);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  uint64_t result = *(void *)(a1 + 256);
  if (result)
  {
    unint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 40);
    return v4();
  }
  return result;
}

uint64_t gss::FeatureQueryImpl<gss::PropertyID>::targetCartoStyle@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)(a1 + 256);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  uint64_t result = *(void *)(a1 + 240);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t gss::FeatureQueryImpl<gss::PropertyID>::sourceCartoStyle(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 240) + 16))();
}

void gss::FeatureQueryImpl<gss::PropertyID>::~FeatureQueryImpl(uint64_t a1)
{
  gss::FeatureQueryImpl<gss::PropertyID>::~FeatureQueryImpl(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t gss::FeatureQueryImpl<gss::PropertyID>::~FeatureQueryImpl(uint64_t a1)
{
  *(void *)a1 = &unk_1EF567478;
  uint64_t v2 = *(void *)(a1 + 272);
  if (v2)
  {
    *(void *)(a1 + 280) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 296) + 40))(*(void *)(a1 + 296), v2, *(void *)(a1 + 288) - v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 264);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    unint64_t v4 = *(std::__shared_weak_count **)(a1 + 248);
    if (!v4) {
      goto LABEL_9;
    }
  }
  else
  {
    unint64_t v4 = *(std::__shared_weak_count **)(a1 + 248);
    if (!v4) {
      goto LABEL_9;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_9:
  *(void *)a1 = &unk_1EF5674D0;
  uint64_t v5 = (geo::read_write_lock *)pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 32));
  if (v5) {
    geo::read_write_lock::logFailure(v5, (uint64_t)"destruction", v6);
  }
  uint64_t v7 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v7) {
    std::default_delete<gss::RenderStyle<gss::PropertyID>>::operator()[abi:nn180100](v7);
  }
  unint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<gss::FeatureQueryImpl<gss::PropertyID>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<gss::FeatureQueryImpl<gss::PropertyID>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A698;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gss::FeatureQueryImpl<gss::PropertyID>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A698;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::TransitLine::TransitLine(uint64_t a1, uint64_t a2, uint64_t **a3, uint64_t a4, uint64_t a5)
{
  *(void *)a1 = a4;
  *(void *)(a1 + 8) = a5;
  if (a5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a5 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = -1;
  *(_DWORD *)(a1 + 52) = 1065353216;
  *(void *)(a1 + 56) = -1;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  unint64_t v9 = operator new(0x2E0uLL);
  *(void *)(a1 + 64) = v9;
  *(void *)(a1 + 72) = v9;
  *(void *)(a1 + 80) = v9 + 46;
  v9[6] = 0u;
  uint64_t v9[7] = 0u;
  *unint64_t v9 = 0u;
  v9[1] = 0u;
  void v9[2] = 0u;
  void v9[3] = 0u;
  v9[4] = 0u;
  void v9[5] = 0u;
  v9[8] = 0u;
  v9[9] = 0u;
  v9[10] = 0u;
  *((void *)v9 + 22) = 0;
  *((_DWORD *)v9 + 22) = -1;
  *((_DWORD *)v9 + 24) = -1;
  *((unsigned char *)v9 + 104) = 1;
  *((void *)v9 + 14) = 0;
  *((void *)v9 + 15) = 0;
  *((void *)v9 + 16) = 0;
  unint64_t v10 = (gss::Allocator *)gss::Allocator::instance((gss::Allocator *)v9);
  *(_OWORD *)((char *)v9 + 184) = 0u;
  *((void *)v9 + 17) = v10;
  *(_OWORD *)((char *)v9 + 152) = xmmword_1A28FCDD0;
  *((_DWORD *)v9 + 42) = 0;
  *((_DWORD *)v9 + 44) = 257;
  *(_OWORD *)((char *)v9 + 264) = 0u;
  *(_OWORD *)((char *)v9 + 280) = 0u;
  *(_OWORD *)((char *)v9 + 200) = 0u;
  *(_OWORD *)((char *)v9 + 216) = 0u;
  *(_OWORD *)((char *)v9 + 232) = 0u;
  *(_OWORD *)((char *)v9 + 248) = 0u;
  *(_OWORD *)((char *)v9 + 296) = 0u;
  *(_OWORD *)((char *)v9 + 312) = 0u;
  *(_OWORD *)((char *)v9 + 328) = 0u;
  *(_OWORD *)((char *)v9 + 344) = 0u;
  *((void *)v9 + 45) = 0;
  *((_DWORD *)v9 + 68) = -1;
  *((_DWORD *)v9 + 70) = -1;
  *((unsigned char *)v9 + 288) = 1;
  *((void *)v9 + 37) = 0;
  *((void *)v9 + 38) = 0;
  *((void *)v9 + 39) = 0;
  unint64_t v11 = (gss::Allocator *)gss::Allocator::instance(v10);
  *((void *)v9 + 40) = v11;
  v9[21] = xmmword_1A28FCDD0;
  *((_DWORD *)v9 + 88) = 0;
  *((_DWORD *)v9 + 90) = 257;
  v9[28] = 0u;
  v9[29] = 0u;
  v9[23] = 0u;
  v9[24] = 0u;
  v9[25] = 0u;
  v9[26] = 0u;
  v9[27] = 0u;
  v9[30] = 0u;
  v9[31] = 0u;
  v9[32] = 0u;
  v9[33] = 0u;
  *((void *)v9 + 68) = 0;
  *((_DWORD *)v9 + 114) = -1;
  *((_DWORD *)v9 + 116) = -1;
  *((unsigned char *)v9 + 472) = 1;
  *((void *)v9 + 60) = 0;
  *((void *)v9 + 61) = 0;
  *((void *)v9 + 62) = 0;
  unsigned int v12 = (gss::Allocator *)gss::Allocator::instance(v11);
  *((void *)v9 + 63) = v12;
  *(_OWORD *)((char *)v9 + 520) = xmmword_1A28FCDD0;
  *((_DWORD *)v9 + 134) = 0;
  *((_DWORD *)v9 + 136) = 257;
  *(_OWORD *)((char *)v9 + 552) = 0u;
  *(_OWORD *)((char *)v9 + 568) = 0u;
  *(_OWORD *)((char *)v9 + 584) = 0u;
  *(_OWORD *)((char *)v9 + 600) = 0u;
  *(_OWORD *)((char *)v9 + 616) = 0u;
  *(_OWORD *)((char *)v9 + 632) = 0u;
  *(_OWORD *)((char *)v9 + 648) = 0u;
  *(_OWORD *)((char *)v9 + 664) = 0u;
  *(_OWORD *)((char *)v9 + 680) = 0u;
  *(_OWORD *)((char *)v9 + 696) = 0u;
  *(_OWORD *)((char *)v9 + 712) = 0u;
  *((void *)v9 + 91) = 0;
  *((_DWORD *)v9 + 160) = -1;
  *((_DWORD *)v9 + 162) = -1;
  *((unsigned char *)v9 + 656) = 1;
  *((void *)v9 + 83) = 0;
  *((void *)v9 + 84) = 0;
  *((void *)v9 + 85) = 0;
  *((void *)v9 + 86) = gss::Allocator::instance(v12);
  v9[44] = xmmword_1A28FCDD0;
  *((_DWORD *)v9 + 180) = 0;
  *((_DWORD *)v9 + 182) = 257;
  *(void *)(a1 + 72) = v9 + 46;
  *(unsigned char *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  md::createFeatureAttributeSet((gss::Allocator *)v34, (uint64_t *)(a2 + 24));
  BOOL ColorOverrideForAttributes = md::DataOverrideManager::getColorOverrideForAttributes(a3, v34, (_DWORD *)(a1 + 36));
  if (v34[0])
  {
    v34[1] = v34[0];
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v35 + 40))(v35, v34[0], v34[2] - v34[0]);
  }
  if (!ColorOverrideForAttributes)
  {
    unint64_t v16 = *(unsigned char **)(a1 + 16);
    LOBYTE(v14) = v16[80];
    float v17 = (float)v14;
    LOBYTE(v15) = v16[81];
    float v18 = (float)v15;
    LOBYTE(v15) = v16[82];
    float v19 = (float)v15;
    LOBYTE(v5) = v16[83];
    if ((float)(v17 * 0.0039216) >= 0.04045) {
      float v20 = powf((float)(v17 * 0.0037171) + 0.052133, 2.4);
    }
    else {
      float v20 = v17 * 0.00030353;
    }
    if ((float)(v18 * 0.0039216) >= 0.04045) {
      float v21 = powf((float)(v18 * 0.0037171) + 0.052133, 2.4);
    }
    else {
      float v21 = v18 * 0.00030353;
    }
    if ((float)(v19 * 0.0039216) >= 0.04045) {
      float v22 = powf((float)(v19 * 0.0037171) + 0.052133, 2.4);
    }
    else {
      float v22 = v19 * 0.00030353;
    }
    *(float *)(a1 + 36) = v20;
    *(float *)(a1 + 40) = v21;
    *(float *)(a1 + 44) = v22;
    *(float *)(a1 + 48) = (float)v5 * 0.0039216;
  }
  uint64_t v23 = *(void *)(a1 + 64);
  md::TransitLine::updateFeatureQueryForMergeTypeIfNecessary((uint64_t *)a1, 0);
  if (*(unsigned char *)(v23 + 177))
  {
    md::TransitLine::_resolveStyle(a1, *(_DWORD *)(a1 + 60), *(void *)v23, *(std::__shared_weak_count **)(v23 + 8), v23 + 16);
    *(unsigned char *)(v23 + 177) = 0;
  }
  unint64_t v24 = *(std::__shared_weak_count **)(a2 + 8);
  if (v24)
  {
    unint64_t v24 = std::__shared_weak_count::lock(v24);
    BOOL v25 = v24;
    if (v24) {
      unint64_t v24 = *(std::__shared_weak_count **)a2;
    }
  }
  else
  {
    BOOL v25 = 0;
  }
  uint64_t v26 = geo::codec::VectorTile::transitSystems((geo::codec::VectorTile *)v24);
  unsigned int v27 = *(_DWORD *)(a2 + 84);
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
  *(void *)(a1 + 24) = *(void *)(v26 + 72 * v27 + 16);
  uint64_t v28 = *(unsigned __int8 **)(*(void *)(a1 + 16) + 24);
  uint64_t v29 = v28[33];
  if (v28[33])
  {
    uint64_t v30 = (_DWORD *)(*(void *)v28 + 4);
    uint64_t v31 = 8 * v29;
    do
    {
      int v32 = *(v30 - 1);
      if (v32 == 53)
      {
        *(_DWORD *)(a1 + 32) = *v30;
      }
      else if (v32 == 37)
      {
        *(void *)(a1 + 96) = 1 << *v30;
      }
      v30 += 2;
      v31 -= 8;
    }
    while (v31);
  }
  return a1;
}

void sub_1A20B5CA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  float v20 = (char *)*v18;
  if (*v18)
  {
    float v21 = *(char **)(v16 + 72);
    float v22 = *v18;
    if (v21 != v20)
    {
      do
      {
        uint64_t v23 = *((void *)v21 - 9);
        if (v23)
        {
          *((void *)v21 - 8) = v23;
          (*(void (**)(void, uint64_t, uint64_t))(**((void **)v21 - 6) + 40))(*((void *)v21 - 6), v23, *((void *)v21 - 7) - v23);
        }
        unint64_t v24 = (std::__shared_weak_count *)*((void *)v21 - 22);
        if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
        v21 -= 184;
      }
      while (v21 != v20);
      float v22 = *v18;
    }
    *(void *)(v16 + 72) = v20;
    operator delete(v22);
  }
  BOOL v25 = *(std::__shared_weak_count **)(v16 + 8);
  if (v25)
  {
    if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t md::TransitLine::debugSystemName(md::TransitLine *this)
{
  uint64_t v2 = (std::__shared_weak_count **)*((void *)this + 2);
  unint64_t v3 = v2[1];
  if (v3)
  {
    unint64_t v3 = std::__shared_weak_count::lock(v3);
    unint64_t v4 = v3;
    if (v3) {
      unint64_t v3 = *v2;
    }
  }
  else
  {
    unint64_t v4 = 0;
  }
  uint64_t v5 = geo::codec::VectorTile::transitSystems((geo::codec::VectorTile *)v3);
  unsigned int v6 = *(_DWORD *)(*((void *)this + 2) + 84);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return *(void *)(v5 + 72 * v6 + 56);
}

void sub_1A20B5F04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

id md::TransitLine::debugString(uint64_t a1, unsigned int a2)
{
  unint64_t v4 = [MEMORY[0x1E4F28E78] string];
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v6 = v5 + 184 * a2;
  if (!*(unsigned char *)(v6 + 176))
  {
    uint64_t v7 = *(void *)v6;
    if (*(void *)v6)
    {
      unint64_t v8 = *(std::__shared_weak_count **)(v6 + 8);
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v19, v7, (uint64_t)v8);
      if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
        if (v20) {
          goto LABEL_8;
        }
      }
      else if (v20)
      {
LABEL_8:
        uint64_t v10 = *(void *)(v19[0] + 24);
        uint64_t v11 = *(void *)(v10 + 16);
        unsigned int v12 = *(std::__shared_weak_count **)(v10 + 24);
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        unint64_t v13 = "";
        if (v11)
        {
          unsigned int v14 = *(const char **)(v11 + 104);
          if (v14) {
            unint64_t v13 = v14;
          }
        }
        objc_msgSend(v4, "appendFormat:", @"style:%s\n", v13);
        if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      unsigned int v15 = md::HighlightHelper::debugAttributesToString((md::HighlightHelper *)(*(void *)v6 + 272), v9);
      [v4 appendFormat:@"attrs:{%@}\n", v15];

      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v19);
    }
  }
  if (!*(unsigned char *)(v5 + 184 * a2 + 177)) {
    [v4 appendFormat:@"width: fill=%.1f, stroke=%.1f spacing=%.1f\n", *(float *)(v5 + 184 * a2 + 72), *(float *)(v5 + 184 * a2 + 80), *(float *)(v5 + 184 * a2 + 76)];
  }
  uint64_t v16 = *(float32x2_t **)(a1 + 64);
  int32x2_t v17 = (int32x2_t)vshl_u32((uint32x2_t)vcvt_s32_f32(vmul_f32(v16[3], (float32x2_t)vdup_n_s32(0x437F0000u))), (uint32x2_t)0x1800000010);
  objc_msgSend(v4, "appendFormat:", @"system=%llu color=%X group=%i z=%i\n", *(void *)(a1 + 24), bswap32(vorr_s8((int8x8_t)vdup_lane_s32(v17, 1), (int8x8_t)v17).u32[0] | ((int)(float)(v16[2].f32[1] * 255.0) << 8) | (int)(float)(v16[2].f32[0] * 255.0)), *(unsigned int *)(a1 + 32), v16[12].u32[1]);
  objc_msgSend(v4, "appendFormat:", @"Merge: SameSys+Color=%i SysThresh=%i Group=%i GroupThresh=%i\n", v16[10].u8[4], v16[11].u32[0], v16[11].u8[4], v16[12].u32[0]);
  return v4;
}

void sub_1A20B61C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va1);

  _Unwind_Resume(a1);
}

void *md::MuninLabelLayer::clearScene(md::MuninLabelLayer *this)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (md::LabelManager *)*((void *)this + 6);
  v3[0] = &unk_1EF56E5F8;
  v3[1] = v1;
  unsigned char v3[2] = 0;
  unint64_t v4 = v3;
  md::LabelManager::queueCommand(v1, 19, 1, v3);
  uint64_t result = v4;
  if (v4 == v3) {
    return (void *)(*(uint64_t (**)(void *))(v3[0] + 32))(v3);
  }
  if (v4) {
    return (void *)(*(uint64_t (**)(void))(*v4 + 40))();
  }
  return result;
}

void sub_1A20B6300(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
    _Unwind_Resume(exception_object);
  }
  if (a13) {
    (*(void (**)(void))(*a13 + 40))();
  }
  _Unwind_Resume(exception_object);
}

void md::MuninLabelLayer::layout(md::MuninLabelLayer *this, const md::LayoutContext *a2)
{
  unint64_t v3 = this;
  ++*((_DWORD *)this + 18);
  uint64_t v4 = *((void *)this + 8);
  if (*(void *)(v4 + 40))
  {
    uint64_t v5 = *(void **)(v4 + 24);
    while (v5)
    {
      uint64_t v6 = v5;
      uint64_t v5 = (void *)*v5;
      uint64_t v7 = (std::__shared_weak_count *)v6[3];
      if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
      (*(void (**)(void, void *, uint64_t))(**(void **)(v4 + 32) + 40))(*(void *)(v4 + 32), v6, 32);
    }
    *(void *)(v4 + 24) = 0;
    uint64_t v8 = *(void *)(v4 + 8);
    if (v8)
    {
      for (uint64_t i = 0; i != v8; ++i)
        *(void *)(*(void *)v4 + 8 * i) = 0;
    }
    *(void *)(v4 + 40) = 0;
    unint64_t v3 = this;
  }
  uint64_t v10 = (void *)*((void *)a2 + 1);
  int8x8_t v11 = (int8x8_t)v10[1];
  unint64_t v157 = a2;
  if (!*(void *)&v11) {
    goto LABEL_35;
  }
  uint8x8_t v12 = (uint8x8_t)vcnt_s8(v11);
  v12.i16[0] = vaddlv_u8(v12);
  if (v12.u32[0] > 1uLL)
  {
    unint64_t v13 = 0xC83717EF586624DCLL;
    if (*(void *)&v11 <= 0xC83717EF586624DCLL) {
      unint64_t v13 = 0xC83717EF586624DCLL % *(void *)&v11;
    }
  }
  else
  {
    unint64_t v13 = (*(void *)&v11 - 1) & 0xC83717EF586624DCLL;
  }
  unsigned int v14 = *(void **)(*v10 + 8 * v13);
  if (!v14) {
    goto LABEL_35;
  }
  unsigned int v15 = (void *)*v14;
  if (!v15) {
    goto LABEL_35;
  }
  if (v12.u32[0] < 2uLL)
  {
    uint64_t v16 = *(void *)&v11 - 1;
    while (1)
    {
      uint64_t v18 = v15[1];
      if (v18 == 0xC83717EF586624DCLL)
      {
        if (v15[2] == 0xC83717EF586624DCLL) {
          goto LABEL_33;
        }
      }
      else if ((v18 & v16) != v13)
      {
        goto LABEL_35;
      }
      unsigned int v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_35;
      }
    }
  }
  while (1)
  {
    unint64_t v17 = v15[1];
    if (v17 == 0xC83717EF586624DCLL) {
      break;
    }
    if (v17 >= *(void *)&v11) {
      v17 %= *(void *)&v11;
    }
    if (v17 != v13) {
      goto LABEL_35;
    }
LABEL_22:
    unsigned int v15 = (void *)*v15;
    if (!v15) {
      goto LABEL_35;
    }
  }
  if (v15[2] != 0xC83717EF586624DCLL) {
    goto LABEL_22;
  }
LABEL_33:
  uint64_t v19 = v15[5];
  if (*(void *)(v19 + 8) == 0xC83717EF586624DCLL)
  {
    uint64_t v158 = *(void *)(v19 + 32);
    goto LABEL_36;
  }
LABEL_35:
  uint64_t v158 = 0;
LABEL_36:
  char v20 = 0;
  uint64_t v21 = 0;
  int v176 = 2490405;
  while (2)
  {
    char v159 = v20;
    int v22 = *((unsigned __int16 *)&v176 + v21);
    md::SceneContext::renderData((md::SceneContext *)&v174, *(void *)(v158 + 8), v22);
    long long v23 = v174;
    int v165 = v22;
    uint64_t v166 = v175;
    uint64_t v164 = v22 - 0x61C8864680B583EBLL;
    while (2)
    {
      uint64_t v167 = *((void *)&v23 + 1);
      uint64_t v24 = v23;
      if ((void)v23 != v166)
      {
        uint64_t v25 = *(void *)(v23 + 112);
        uint64_t v26 = *(unsigned __int8 **)(v25 + 720);
        uint64_t v27 = *(void *)(v25 + 728);
        *(void *)&long long v173 = v26;
        *((void *)&v173 + 1) = v27;
        if (v27) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v28 = (const QuadTile *)(v25 + 168);
        uint64_t v29 = *(unsigned __int8 *)(v25 + 168);
        uint64_t v30 = *(unsigned __int8 *)(v25 + 169);
        *(void *)&long long v23 = *(void *)(v25 + 172);
        uint64_t v31 = (void *)*((void *)v3 + 8);
        int v32 = v31 + 13;
        unint64_t v33 = (v30
             - 0x61C8864680B583EBLL
             + ((v29 - 0x61C8864680B583EBLL) << 6)
             + ((unint64_t)(v29 - 0x61C8864680B583EBLL) >> 2)) ^ (v29 - 0x61C8864680B583EBLL);
        int v34 = v23;
        unint64_t v35 = ((int)v23 - 0x61C8864680B583EBLL + (v33 << 6) + (v33 >> 2)) ^ v33;
        long long v168 = v23;
        unsigned int v36 = DWORD1(v23);
        unint64_t v37 = (SDWORD1(v23) - 0x61C8864680B583EBLL + (v35 << 6) + (v35 >> 2)) ^ v35;
        unint64_t v38 = v164 + (v37 << 6) + (v37 >> 2);
        unint64_t v39 = v38 ^ v37;
        int8x8_t v40 = (int8x8_t)v31[9];
        if (v40)
        {
          uint8x8_t v41 = (uint8x8_t)vcnt_s8(v40);
          v41.i16[0] = vaddlv_u8(v41);
          if (v41.u32[0] > 1uLL)
          {
            unint64_t v42 = v38 ^ v37;
            if (v39 >= *(void *)&v40) {
              unint64_t v42 = v39 % *(void *)&v40;
            }
          }
          else
          {
            unint64_t v42 = v39 & (*(void *)&v40 - 1);
          }
          unsigned int v43 = *(uint64_t ***)(v31[8] + 8 * v42);
          if (v43)
          {
            unsigned __int16 v44 = *v43;
            if (v44)
            {
              if (v41.u32[0] < 2uLL)
              {
                uint64_t v45 = *(void *)&v40 - 1;
                while (1)
                {
                  uint64_t v47 = v44[1];
                  if (v47 == v39)
                  {
                    if (__PAIR64__(*((unsigned __int8 *)v44 + 17), *((unsigned __int8 *)v44 + 16)) == __PAIR64__(v30, v29)
                      && *((_DWORD *)v44 + 5) == v34
                      && *((_DWORD *)v44 + 6) == v36
                      && *((unsigned __int16 *)v44 + 20) == v165)
                    {
                      goto LABEL_69;
                    }
                  }
                  else if ((v47 & v45) != v42)
                  {
                    goto LABEL_72;
                  }
                  unsigned __int16 v44 = (uint64_t *)*v44;
                  if (!v44) {
                    goto LABEL_72;
                  }
                }
              }
              do
              {
                unint64_t v46 = v44[1];
                if (v46 == v39)
                {
                  if (__PAIR64__(*((unsigned __int8 *)v44 + 17), *((unsigned __int8 *)v44 + 16)) == __PAIR64__(v30, v29)
                    && *((_DWORD *)v44 + 5) == v34
                    && *((_DWORD *)v44 + 6) == v36
                    && *((unsigned __int16 *)v44 + 20) == v165)
                  {
LABEL_69:
                    int v32 = (uint64_t *)v31[14];
                    uint64_t v48 = (uint64_t *)v44[6];
                    if (v32 != v48)
                    {
                      int8x16_t v49 = (uint64_t *)v48[1];
                      if (v49 != v32)
                      {
                        uint64_t v50 = *v48;
                        *(void *)(v50 + 8) = v49;
                        *(void *)v48[1] = v50;
                        uint64_t v51 = *v32;
                        *(void *)(v51 + 8) = v48;
                        *uint64_t v48 = v51;
                        *int v32 = (uint64_t)v48;
                        v48[1] = (uint64_t)v32;
                        int v32 = (uint64_t *)v31[14];
                        uint64_t v31 = (void *)*((void *)v3 + 8);
                      }
                    }
                    break;
                  }
                }
                else
                {
                  if (v46 >= *(void *)&v40) {
                    v46 %= *(void *)&v40;
                  }
                  if (v46 != v42) {
                    break;
                  }
                }
                unsigned __int16 v44 = (uint64_t *)*v44;
              }
              while (v44);
            }
          }
        }
LABEL_72:
        if (v32 != v31 + 13)
        {
          uint64_t v53 = v32[6];
          uint64_t v52 = v32[7];
          if (v52) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v52 + 8), 1uLL, memory_order_relaxed);
          }
          *(void *)&long long v172 = v53;
          *((void *)&v172 + 1) = v52;
          goto LABEL_76;
        }
        unsigned int v163 = v36;
        uint64_t v160 = v25;
        uint64_t v161 = v24;
        int v59 = *v26;
        uint64_t v60 = (std::__shared_weak_count *)operator new(0x208uLL);
        v60->__shared_owners_ = 0;
        v60->__shared_weak_owners_ = 0;
        v60->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580410;
        uint64_t v61 = (std::__shared_weak_count_vtbl *)&v60[1];
        md::LabelMapTile::LabelMapTile((md::LabelMapTile *)&v60[1], v28);
        v60[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF537350;
        BYTE5(v60[21].__shared_owners_) = v59;
        BYTE2(v60[6].__shared_owners_) = v59 == 7;
        shared_owners = (std::__shared_weak_count *)v60[4].__shared_owners_;
        if (!shared_owners)
        {
          atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
          atomic_fetch_add_explicit(&v60->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          v60[4].__vftable = v61;
          v60[4].__shared_owners_ = (uint64_t)v60;
          unint64_t v63 = v163;
          goto LABEL_102;
        }
        unint64_t v63 = v163;
        if (shared_owners->__shared_owners_ == -1)
        {
          atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
          atomic_fetch_add_explicit(&v60->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          v60[4].__vftable = v61;
          v60[4].__shared_owners_ = (uint64_t)v60;
          std::__shared_weak_count::__release_weak(shared_owners);
LABEL_102:
          if (!atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
            std::__shared_weak_count::__release_weak(v60);
          }
        }
        *(void *)&long long v172 = v60 + 1;
        *((void *)&v172 + 1) = v60;
        uint64_t v66 = *((void *)this + 8) + 56;
        uint64_t v171 = v60;
        atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
        *(void *)&v177[0] = v60 + 1;
        *((void *)&v177[0] + 1) = v60;
        atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
        int8x8_t v67 = *(int8x8_t *)(v66 + 16);
        if (v67)
        {
          uint8x8_t v68 = (uint8x8_t)vcnt_s8(v67);
          v68.i16[0] = vaddlv_u8(v68);
          if (v68.u32[0] > 1uLL)
          {
            unint64_t v69 = v39;
            if (v39 >= *(void *)&v67) {
              unint64_t v69 = v39 % *(void *)&v67;
            }
          }
          else
          {
            unint64_t v69 = v39 & (*(void *)&v67 - 1);
          }
          int v70 = *(uint64_t ***)(*(void *)(v66 + 8) + 8 * v69);
          if (v70)
          {
            int v71 = *v70;
            if (*v70)
            {
              if (v68.u32[0] < 2uLL)
              {
                uint64_t v72 = *(void *)&v67 - 1;
                while (1)
                {
                  uint64_t v74 = v71[1];
                  if (v74 == v39)
                  {
                    if (*((unsigned __int8 *)v71 + 16) == v29
                      && *((unsigned __int8 *)v71 + 17) == v30
                      && *((_DWORD *)v71 + 5) == v34
                      && *((_DWORD *)v71 + 6) == v63
                      && *((unsigned __int16 *)v71 + 20) == v165)
                    {
                      goto LABEL_132;
                    }
                  }
                  else if ((v74 & v72) != v69)
                  {
                    goto LABEL_162;
                  }
                  int v71 = (uint64_t *)*v71;
                  if (!v71) {
                    goto LABEL_162;
                  }
                }
              }
              do
              {
                unint64_t v73 = v71[1];
                if (v73 == v39)
                {
                  if (*((unsigned __int8 *)v71 + 16) == v29
                    && *((unsigned __int8 *)v71 + 17) == v30
                    && *((_DWORD *)v71 + 5) == v34
                    && *((_DWORD *)v71 + 6) == v63
                    && *((unsigned __int16 *)v71 + 20) == v165)
                  {
LABEL_132:
                    float v75 = (uint64_t *)v71[6];
                    uint64_t v76 = *v75;
                    *(void *)(v76 + 8) = v75[1];
                    *(void *)v75[1] = v76;
                    --*(void *)(v66 + 64);
                    unsigned int v77 = (std::__shared_weak_count *)v75[7];
                    if (v77 && !atomic_fetch_add(&v77->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
                      std::__shared_weak_count::__release_weak(v77);
                    }
                    operator delete(v75);
                    int8x8_t v78 = *(int8x8_t *)(v66 + 16);
                    unint64_t v79 = v71[1];
                    uint8x8_t v80 = (uint8x8_t)vcnt_s8(v78);
                    v80.i16[0] = vaddlv_u8(v80);
                    if (v80.u32[0] > 1uLL)
                    {
                      if (v79 >= *(void *)&v78) {
                        v79 %= *(void *)&v78;
                      }
                    }
                    else
                    {
                      v79 &= *(void *)&v78 - 1;
                    }
                    uint64_t v81 = *(void *)(v66 + 8);
                    float v82 = *(uint64_t **)(v81 + 8 * v79);
                    do
                    {
                      uint64_t v83 = v82;
                      float v82 = (uint64_t *)*v82;
                    }
                    while (v82 != v71);
                    if (v83 == (uint64_t *)(v66 + 24)) {
                      goto LABEL_152;
                    }
                    unint64_t v84 = v83[1];
                    if (v80.u32[0] > 1uLL)
                    {
                      if (v84 >= *(void *)&v78) {
                        v84 %= *(void *)&v78;
                      }
                    }
                    else
                    {
                      v84 &= *(void *)&v78 - 1;
                    }
                    if (v84 != v79)
                    {
LABEL_152:
                      if (!*v71) {
                        goto LABEL_153;
                      }
                      unint64_t v85 = *(void *)(*v71 + 8);
                      if (v80.u32[0] > 1uLL)
                      {
                        if (v85 >= *(void *)&v78) {
                          v85 %= *(void *)&v78;
                        }
                      }
                      else
                      {
                        v85 &= *(void *)&v78 - 1;
                      }
                      if (v85 != v79) {
LABEL_153:
                      }
                        *(void *)(v81 + 8 * v79) = 0;
                    }
                    uint64_t v86 = (uint64_t *)*v71;
                    if (*v71)
                    {
                      unint64_t v87 = v86[1];
                      if (v80.u32[0] > 1uLL)
                      {
                        if (v87 >= *(void *)&v78) {
                          v87 %= *(void *)&v78;
                        }
                      }
                      else
                      {
                        v87 &= *(void *)&v78 - 1;
                      }
                      if (v87 != v79)
                      {
                        *(void *)(*(void *)(v66 + 8) + 8 * v87) = v83;
                        uint64_t v86 = (uint64_t *)*v71;
                      }
                    }
                    *uint64_t v83 = (uint64_t)v86;
                    *int v71 = 0;
                    --*(void *)(v66 + 32);
                    operator delete(v71);
                    break;
                  }
                }
                else
                {
                  if (v73 >= *(void *)&v67) {
                    v73 %= *(void *)&v67;
                  }
                  if (v73 != v69) {
                    break;
                  }
                }
                int v71 = (uint64_t *)*v71;
              }
              while (v71);
            }
          }
        }
LABEL_162:
        uint64_t v88 = (char *)operator new(0x40uLL);
        unsigned int v89 = v88;
        int v90 = v34;
        v88[16] = v29;
        v88[17] = v30;
        *((void *)&v91 + 1) = *((void *)&v168 + 1);
        *(void *)(v88 + 20) = v168;
        *((_WORD *)v88 + 20) = v165;
        int8x16_t v92 = (std::__shared_weak_count *)*((void *)&v177[0] + 1);
        *((void *)v88 + 6) = *(void *)&v177[0];
        *((void *)v88 + 7) = v92;
        if (v92) {
          atomic_fetch_add_explicit(&v92->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v93 = v66 + 48;
        *(void *)uint64_t v88 = v66 + 48;
        uint64_t v94 = *(void **)(v66 + 56);
        *((void *)v88 + 1) = v94;
        *uint64_t v94 = v88;
        uint64_t v95 = *(void *)(v66 + 64) + 1;
        *(void *)(v66 + 56) = v88;
        *(void *)(v66 + 64) = v95;
        unint64_t v96 = *(void *)(v66 + 16);
        if (v96)
        {
          uint8x8_t v97 = (uint8x8_t)vcnt_s8((int8x8_t)v96);
          v97.i16[0] = vaddlv_u8(v97);
          if (v97.u32[0] > 1uLL)
          {
            unint64_t v63 = v39;
            if (v39 >= v96) {
              unint64_t v63 = v39 % v96;
            }
          }
          else
          {
            unint64_t v63 = v39 & (v96 - 1);
          }
          unsigned int v98 = *(uint64_t ***)(*(void *)(v66 + 8) + 8 * v63);
          if (v98)
          {
            float v99 = *v98;
            if (v99)
            {
              if (v97.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v101 = v99[1];
                  if (v101 == v39)
                  {
                    if (*((unsigned __int8 *)v99 + 16) == v29
                      && *((unsigned __int8 *)v99 + 17) == v30
                      && *((_DWORD *)v99 + 5) == v90
                      && *((_DWORD *)v99 + 6) == v163
                      && *((unsigned __int16 *)v99 + 20) == v165)
                    {
                      goto LABEL_260;
                    }
                  }
                  else if ((v101 & (v96 - 1)) != v63)
                  {
                    goto LABEL_193;
                  }
                  float v99 = (uint64_t *)*v99;
                  if (!v99) {
                    goto LABEL_193;
                  }
                }
              }
              do
              {
                unint64_t v100 = v99[1];
                if (v100 == v39)
                {
                  if (*((unsigned __int8 *)v99 + 16) == v29
                    && *((unsigned __int8 *)v99 + 17) == v30
                    && *((_DWORD *)v99 + 5) == v90
                    && *((_DWORD *)v99 + 6) == v163
                    && *((unsigned __int16 *)v99 + 20) == v165)
                  {
                    goto LABEL_260;
                  }
                }
                else
                {
                  if (v100 >= v96) {
                    v100 %= v96;
                  }
                  if (v100 != v63) {
                    break;
                  }
                }
                float v99 = (uint64_t *)*v99;
              }
              while (v99);
            }
          }
        }
LABEL_193:
        float v102 = operator new(0x38uLL);
        *float v102 = 0;
        v102[1] = v39;
        *((unsigned char *)v102 + 16) = v29;
        *((unsigned char *)v102 + 17) = v30;
        *((void *)&v91 + 1) = *((void *)&v168 + 1);
        *(void *)((char *)v102 + 20) = v168;
        *((_WORD *)v102 + 20) = v165;
        v102[6] = v89;
        *(float *)&long long v91 = (float)(unint64_t)(*(void *)(v66 + 32) + 1);
        float v103 = *(float *)(v66 + 40);
        if (!v96 || (float)(v103 * (float)v96) < *(float *)&v91)
        {
          BOOL v104 = (v96 & (v96 - 1)) != 0;
          if (v96 < 3) {
            BOOL v104 = 1;
          }
          unint64_t v105 = v104 | (2 * v96);
          unint64_t v106 = vcvtps_u32_f32(*(float *)&v91 / v103);
          if (v105 <= v106) {
            size_t prime = v106;
          }
          else {
            size_t prime = v105;
          }
          if (prime == 1)
          {
            size_t prime = 2;
          }
          else if ((prime & (prime - 1)) != 0)
          {
            size_t prime = std::__next_prime(prime);
            unint64_t v96 = *(void *)(v66 + 16);
          }
          if (prime <= v96)
          {
            if (prime < v96)
            {
              unint64_t v120 = vcvtps_u32_f32((float)*(unint64_t *)(v66 + 32) / *(float *)(v66 + 40));
              if (v96 < 3
                || (uint8x8_t v121 = (uint8x8_t)vcnt_s8((int8x8_t)v96), v121.i16[0] = vaddlv_u8(v121), v121.u32[0] > 1uLL))
              {
                unint64_t v120 = std::__next_prime(v120);
              }
              else
              {
                uint64_t v122 = 1 << -(char)__clz(v120 - 1);
                if (v120 >= 2) {
                  unint64_t v120 = v122;
                }
              }
              if (prime <= v120) {
                size_t prime = v120;
              }
              if (prime < v96)
              {
                if (prime) {
                  goto LABEL_205;
                }
                long long v127 = *(void **)(v66 + 8);
                *(void *)(v66 + 8) = 0;
                if (v127) {
                  operator delete(v127);
                }
                *(void *)(v66 + 16) = 0;
              }
            }
            goto LABEL_245;
          }
LABEL_205:
          if (prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v108 = operator new(8 * prime);
          uint64_t v109 = *(void **)(v66 + 8);
          *(void *)(v66 + 8) = v108;
          if (v109) {
            operator delete(v109);
          }
          uint64_t v110 = 0;
          *(void *)(v66 + 16) = prime;
          do
            *(void *)(*(void *)(v66 + 8) + 8 * v110++) = 0;
          while (prime != v110);
          uint64_t v112 = v66 + 24;
          unsigned int v111 = *(void **)(v66 + 24);
          if (!v111) {
            goto LABEL_245;
          }
          size_t v113 = v111[1];
          size_t v114 = prime - 1;
          if ((prime & (prime - 1)) == 0)
          {
            size_t v115 = v113 & v114;
            *(void *)(*(void *)(v66 + 8) + 8 * v115) = v112;
            while (1)
            {
              float v116 = (void *)*v111;
              if (!*v111) {
                break;
              }
              size_t v117 = v116[1] & v114;
              if (v117 == v115)
              {
                unsigned int v111 = (void *)*v111;
              }
              else
              {
                uint64_t v118 = *(void *)(v66 + 8);
                if (*(void *)(v118 + 8 * v117))
                {
                  *unsigned int v111 = *v116;
                  uint64_t v119 = 8 * v117;
                  *float v116 = **(void **)(*(void *)(v66 + 8) + v119);
                  **(void **)(*(void *)(v66 + 8) + v119) = v116;
                }
                else
                {
                  *(void *)(v118 + 8 * v117) = v111;
                  unsigned int v111 = v116;
                  size_t v115 = v117;
                }
              }
            }
            goto LABEL_245;
          }
          if (v113 >= prime) {
            v113 %= prime;
          }
          *(void *)(*(void *)(v66 + 8) + 8 * v113) = v112;
          float32x4_t v123 = (void *)*v111;
          if (!*v111)
          {
LABEL_245:
            unint64_t v96 = *(void *)(v66 + 16);
            if ((v96 & (v96 - 1)) != 0)
            {
              if (v39 >= v96) {
                unint64_t v63 = v39 % v96;
              }
              else {
                unint64_t v63 = v39;
              }
            }
            else
            {
              unint64_t v63 = (v96 - 1) & v39;
            }
            goto LABEL_250;
          }
          while (2)
          {
            size_t v125 = v123[1];
            if (v125 >= prime) {
              v125 %= prime;
            }
            if (v125 != v113)
            {
              uint64_t v126 = *(void *)(v66 + 8);
              if (!*(void *)(v126 + 8 * v125))
              {
                *(void *)(v126 + 8 * v125) = v111;
LABEL_231:
                unsigned int v111 = v123;
                float32x4_t v123 = (void *)*v123;
                size_t v113 = v125;
                if (!v123) {
                  goto LABEL_245;
                }
                continue;
              }
              *unsigned int v111 = *v123;
              uint64_t v124 = 8 * v125;
              *float32x4_t v123 = **(void **)(*(void *)(v66 + 8) + v124);
              **(void **)(*(void *)(v66 + 8) + v124) = v123;
              float32x4_t v123 = v111;
            }
            break;
          }
          size_t v125 = v113;
          goto LABEL_231;
        }
LABEL_250:
        uint64_t v128 = *(void *)(v66 + 8);
        int v129 = *(void **)(v128 + 8 * v63);
        if (v129)
        {
          *float v102 = *v129;
          goto LABEL_258;
        }
        *float v102 = *(void *)(v66 + 24);
        *(void *)(v66 + 24) = v102;
        *(void *)(v128 + 8 * v63) = v66 + 24;
        if (*v102)
        {
          unint64_t v130 = *(void *)(*v102 + 8);
          if ((v96 & (v96 - 1)) != 0)
          {
            if (v130 >= v96) {
              v130 %= v96;
            }
          }
          else
          {
            v130 &= v96 - 1;
          }
          int v129 = (void *)(*(void *)(v66 + 8) + 8 * v130);
LABEL_258:
          *int v129 = v102;
        }
        ++*(void *)(v66 + 32);
        int8x16_t v92 = (std::__shared_weak_count *)*((void *)&v177[0] + 1);
LABEL_260:
        if (v92 && !atomic_fetch_add(&v92->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
          std::__shared_weak_count::__release_weak(v92);
        }
        for (unint64_t j = *(void *)(v66 + 64); j > *(void *)v66; unint64_t j = *(void *)(v66 + 64))
        {
          char v132 = *(uint64_t **)v93;
          uint64_t v133 = *(unsigned __int8 *)(*(void *)v93 + 17);
          uint64_t v134 = *(unsigned __int8 *)(*(void *)v93 + 16);
          *(void *)&long long v91 = *(void *)(*(void *)v93 + 20);
          long long v169 = v91;
          int v135 = *(unsigned __int16 *)(*(void *)v93 + 40);
          unsigned __int8 v136 = *(std::__shared_weak_count **)(*(void *)v93 + 56);
          if (v136)
          {
            atomic_fetch_add_explicit(&v136->__shared_owners_, 1uLL, memory_order_relaxed);
            char v132 = *(uint64_t **)(v66 + 48);
            int v137 = (std::__shared_weak_count *)v132[7];
            unint64_t j = *(void *)(v66 + 64);
          }
          else
          {
            int v137 = 0;
          }
          uint64_t v138 = *v132;
          *(void *)(v138 + 8) = v132[1];
          *(void *)v132[1] = v138;
          *(void *)(v66 + 64) = j - 1;
          if (v137 && !atomic_fetch_add(&v137->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v137->__on_zero_shared)(v137);
            std::__shared_weak_count::__release_weak(v137);
          }
          operator delete(v132);
          int8x8_t v139 = *(int8x8_t *)(v66 + 16);
          if (v139)
          {
            unint64_t v140 = (v133
                  - 0x61C8864680B583EBLL
                  + ((v134 - 0x61C8864680B583EBLL) << 6)
                  + ((unint64_t)(v134 - 0x61C8864680B583EBLL) >> 2)) ^ (v134 - 0x61C8864680B583EBLL);
            *((void *)&v91 + 1) = *((void *)&v169 + 1);
            unint64_t v141 = ((int)v169 - 0x61C8864680B583EBLL + (v140 << 6) + (v140 >> 2)) ^ v140;
            unint64_t v142 = (SDWORD1(v169) - 0x61C8864680B583EBLL + (v141 << 6) + (v141 >> 2)) ^ v141;
            unint64_t v143 = (v135 - 0x61C8864680B583EBLL + (v142 << 6) + (v142 >> 2)) ^ v142;
            *(int8x8_t *)&long long v91 = vcnt_s8(v139);
            LOWORD(v91) = vaddlv_u8(*(uint8x8_t *)&v91);
            if (v91 > 1uLL)
            {
              unint64_t v144 = v143;
              if (v143 >= *(void *)&v139) {
                unint64_t v144 = v143 % *(void *)&v139;
              }
            }
            else
            {
              unint64_t v144 = v143 & (*(void *)&v139 - 1);
            }
            uint64_t v145 = *(void *)(v66 + 8);
            uint64_t v146 = *(uint64_t ***)(v145 + 8 * v144);
            if (v146)
            {
              int v147 = *v146;
              if (*v146)
              {
                uint64_t v148 = *(void *)&v139 - 1;
                if (v91 < 2uLL)
                {
                  while (1)
                  {
                    uint64_t v149 = v147[1];
                    if (v149 == v143)
                    {
                      if (*((unsigned __int8 *)v147 + 16) == v134
                        && *((unsigned __int8 *)v147 + 17) == v133
                        && *(uint64_t *)((char *)v147 + 20) == (void)v169
                        && *((unsigned __int16 *)v147 + 20) == v135)
                      {
                        goto LABEL_288;
                      }
                    }
                    else if ((v149 & v148) != v144)
                    {
                      goto LABEL_325;
                    }
                    int v147 = (uint64_t *)*v147;
                    if (!v147) {
                      goto LABEL_325;
                    }
                  }
                }
                do
                {
                  unint64_t v150 = v147[1];
                  if (v150 == v143)
                  {
                    if (*((unsigned __int8 *)v147 + 16) == v134
                      && *((unsigned __int8 *)v147 + 17) == v133
                      && *(uint64_t *)((char *)v147 + 20) == (void)v169
                      && *((unsigned __int16 *)v147 + 20) == v135)
                    {
LABEL_288:
                      if (v91 > 1uLL)
                      {
                        if (v143 >= *(void *)&v139) {
                          v143 %= *(void *)&v139;
                        }
                      }
                      else
                      {
                        v143 &= v148;
                      }
                      uint64_t v151 = *(uint64_t **)(v145 + 8 * v143);
                      do
                      {
                        uint64_t v152 = v151;
                        uint64_t v151 = (uint64_t *)*v151;
                      }
                      while (v151 != v147);
                      if (v152 == (uint64_t *)(v66 + 24)) {
                        goto LABEL_315;
                      }
                      unint64_t v153 = v152[1];
                      if (v91 > 1uLL)
                      {
                        if (v153 >= *(void *)&v139) {
                          v153 %= *(void *)&v139;
                        }
                      }
                      else
                      {
                        v153 &= v148;
                      }
                      if (v153 != v143)
                      {
LABEL_315:
                        if (!*v147) {
                          goto LABEL_316;
                        }
                        unint64_t v154 = *(void *)(*v147 + 8);
                        if (v91 > 1uLL)
                        {
                          if (v154 >= *(void *)&v139) {
                            v154 %= *(void *)&v139;
                          }
                        }
                        else
                        {
                          v154 &= v148;
                        }
                        if (v154 != v143) {
LABEL_316:
                        }
                          *(void *)(v145 + 8 * v143) = 0;
                      }
                      unint64_t v155 = (uint64_t *)*v147;
                      if (*v147)
                      {
                        unint64_t v156 = v155[1];
                        if (v91 > 1uLL)
                        {
                          if (v156 >= *(void *)&v139) {
                            v156 %= *(void *)&v139;
                          }
                        }
                        else
                        {
                          v156 &= v148;
                        }
                        if (v156 != v143)
                        {
                          *(void *)(*(void *)(v66 + 8) + 8 * v156) = v152;
                          unint64_t v155 = (uint64_t *)*v147;
                        }
                      }
                      *uint64_t v152 = (uint64_t)v155;
                      --*(void *)(v66 + 32);
                      operator delete(v147);
                      break;
                    }
                  }
                  else
                  {
                    if (v150 >= *(void *)&v139) {
                      v150 %= *(void *)&v139;
                    }
                    if (v150 != v144) {
                      break;
                    }
                  }
                  int v147 = (uint64_t *)*v147;
                }
                while (v147);
              }
            }
          }
LABEL_325:
          if (v136 && !atomic_fetch_add(&v136->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v136->__on_zero_shared)(v136);
            std::__shared_weak_count::__release_weak(v136);
          }
        }
        uint64_t v24 = v161;
        unint64_t v3 = this;
        uint64_t v25 = v160;
        if (v171 && !atomic_fetch_add(&v171->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v171->__on_zero_shared)(v171);
          std::__shared_weak_count::__release_weak(v171);
        }
LABEL_76:
        uint64_t v54 = *(void *)(v25 + 736);
        long long v55 = *(std::__shared_weak_count **)(v25 + 744);
        unsigned __int8 v170 = v55;
        if (v55) {
          atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        md::LabelMapTile::loadResourcesTile(v172, v54, v55);
        long long v184 = 0u;
        long long v185 = 0u;
        long long v182 = 0u;
        long long v183 = 0u;
        long long v180 = 0u;
        long long v181 = 0u;
        long long v178 = 0u;
        long long v179 = 0u;
        memset(v177, 0, sizeof(v177));
        if (*((void *)&v173 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v173 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        long long v178 = v173;
        md::LabelMapTile::loadLabelTiles((md::LabelMapTile *)v172, (const md::LabelTileSet *)v177);
        md::LabelTileSet::~LabelTileSet((md::LabelTileSet *)v177);
        unint64_t v56 = *((void *)v3 + 8);
        v177[0] = v172;
        if (*((void *)&v172 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v172 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        std::__hash_table<std::shared_ptr<md::LabelMapTile>,std::hash<std::shared_ptr<md::LabelMapTile>>,std::equal_to<std::shared_ptr<md::LabelMapTile>>,geo::StdAllocator<std::shared_ptr<md::LabelMapTile>,mdm::Allocator>>::__emplace_unique_key_args<std::shared_ptr<md::LabelMapTile>,std::shared_ptr<md::LabelMapTile>>(v56, v172, (uint64_t)v177);
        int v57 = (std::__shared_weak_count *)*((void *)&v177[0] + 1);
        if (*((void *)&v177[0] + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v177[0] + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
          std::__shared_weak_count::__release_weak(v57);
          char v58 = v170;
          if (v170) {
            goto LABEL_85;
          }
        }
        else
        {
          char v58 = v170;
          if (v170)
          {
LABEL_85:
            if (!atomic_fetch_add(&v58->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
              std::__shared_weak_count::__release_weak(v58);
            }
          }
        }
        if (*((void *)&v172 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v172 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          (*(void (**)(void))(**((void **)&v172 + 1) + 16))(*((void *)&v172 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v172 + 1));
          int v64 = (std::__shared_weak_count *)*((void *)&v173 + 1);
          if (*((void *)&v173 + 1)) {
            goto LABEL_94;
          }
        }
        else
        {
          int v64 = (std::__shared_weak_count *)*((void *)&v173 + 1);
          if (*((void *)&v173 + 1))
          {
LABEL_94:
            if (!atomic_fetch_add(&v64->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
              std::__shared_weak_count::__release_weak(v64);
            }
          }
        }
        uint64_t v65 = v24 + 144;
        if (v24 + 144 != v167)
        {
          while (!*(void *)(v65 + 112))
          {
            v65 += 144;
            if (v65 == v167)
            {
              uint64_t v65 = v167;
              break;
            }
          }
        }
        *((void *)&v23 + 1) = v167;
        *(void *)&long long v23 = v65;
        continue;
      }
      break;
    }
    char v20 = 1;
    uint64_t v21 = 1;
    if ((v159 & 1) == 0) {
      continue;
    }
    break;
  }
  md::LabelManager::layout(*((void *)v3 + 6), v157, *((void *)v3 + 8));
}

void sub_1A20B780C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,char a25,uint64_t a26,char a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  operator delete(v37);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a37);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a25);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a27);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a29);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<md::MuninLabelMapTile>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::MuninLabelMapTile>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580410;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::MuninLabelMapTile>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580410;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::MuninLabelLayer::~MuninLabelLayer(md::MuninLabelLayer *this)
{
  *(void *)this = &unk_1EF534F70;
  uint64_t v2 = (uint64_t *)*((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v2) {
    std::default_delete<md::MuninLabelTileCache>::operator()[abi:nn180100](v2);
  }
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  *(void *)this = &unk_1EF530C60;
  uint64_t v4 = (void *)*((void *)this + 1);
  if (v4)
  {
    *((void *)this + 2) = v4;
    operator delete(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t *v2;
  std::__shared_weak_count *v3;
  void *v4;

  *(void *)this = &unk_1EF534F70;
  uint64_t v2 = (uint64_t *)*((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v2) {
    std::default_delete<md::MuninLabelTileCache>::operator()[abi:nn180100](v2);
  }
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  *(void *)this = &unk_1EF530C60;
  uint64_t v4 = (void *)*((void *)this + 1);
  if (v4)
  {
    *((void *)this + 2) = v4;
    operator delete(v4);
  }
}

void std::default_delete<md::MuninLabelTileCache>::operator()[abi:nn180100](uint64_t *a1)
{
  if (a1[15])
  {
    uint64_t v2 = a1 + 13;
    uint64_t v3 = a1[13];
    uint64_t v4 = (uint64_t *)a1[14];
    uint64_t v5 = *v4;
    *(void *)(v5 + 8) = *(void *)(v3 + 8);
    **(void **)(v3 + 8) = v5;
    a1[15] = 0;
    if (v4 != a1 + 13)
    {
      do
      {
        uint64_t v6 = (uint64_t *)v4[1];
        uint64_t v7 = (std::__shared_weak_count *)v4[7];
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        operator delete(v4);
        uint64_t v4 = v6;
      }
      while (v6 != v2);
    }
  }
  uint64_t v8 = (void *)a1[10];
  if (v8)
  {
    do
    {
      unint64_t v9 = (void *)*v8;
      operator delete(v8);
      uint64_t v8 = v9;
    }
    while (v9);
  }
  uint64_t v10 = (void *)a1[8];
  a1[8] = 0;
  if (v10) {
    operator delete(v10);
  }
  int8x8_t v11 = (void *)a1[3];
  while (v11)
  {
    uint8x8_t v12 = v11;
    int8x8_t v11 = (void *)*v11;
    unint64_t v13 = (std::__shared_weak_count *)v12[3];
    if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    (*(void (**)(uint64_t, void *, uint64_t))(*(void *)a1[4] + 40))(a1[4], v12, 32);
  }
  uint64_t v14 = *a1;
  *a1 = 0;
  if (v14) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[2] + 40))(a1[2], v14, 8 * a1[1]);
  }
  JUMPOUT(0x1A6239270);
}

unint64_t altitude::TileKey::getGEOTileKey(unsigned int *a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = a1[4];
  if (v3 > 0x1F) {
    int v4 = a1[5];
  }
  else {
    int v4 = (1 << v3) + ~a1[5];
  }
  unint64_t v5 = *((void *)a1 + 3);
  unint64_t v6 = *a1;
  double v7 = *(double *)(a2 + 32);
  uint64_t v8 = [MEMORY[0x1E4F64918] modernManager];
  unint64_t v9 = [v8 activeTileGroup];
  uint64_t v10 = v9;
  if (v7 <= 1.0) {
    unsigned int v11 = 1;
  }
  else {
    unsigned int v11 = 2;
  }
  if (v6 == 33 || v6 == 17) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = v11;
  }
  uint64_t v14 = [v9 activeTileSetForTileType:v6 scale:v13];

  switch((int)v6)
  {
    case 1:
    case 7:
    case 12:
    case 13:
    case 17:
    case 20:
    case 22:
    case 26:
    case 33:
    case 45:
    case 68:
      [v14 size];
      [v14 scale];
      uint64_t v15 = GEOTileKeyMake();
      if (v6 <= 0x19 && ((1 << v6) & 0x200101C) != 0) {
        unint64_t v16 = 128;
      }
      else {
        unint64_t v16 = (unint64_t)(v6 == 26) << 7;
      }
      unint64_t v6 = v16 | v15 & 0xFFFFFFFFFFFFFF7FLL;
      break;
    case 14:
      uint64_t v19 = a1[2];
      [v14 size];
      unsigned int v20 = a1[1];
      LOBYTE(v22) = GEOTileKeyMakeEmpty();
      *((void *)&v22 + 1) = v21;
      *(void *)((char *)&v22 + 1) = v19 & 0xFF000000FFFFFFFFLL | ((*(void *)&v20 & 0xFFFFFFLL) << 32) | 0xE00000000000000;
      unint64_t v6 = v22;
      break;
    case 15:
    case 42:
    case 43:
    case 44:
    case 52:
      [v14 size];
      [v14 scale];
      LOBYTE(v22) = GEOTileKeyMakeEmpty();
      *(void *)((char *)&v22 + 1) = v3 & 0x3F | ((unint64_t)(v4 & 0x3FFFFFF) << 32) | (v5 << 6) | (HIDWORD(v5) << 58);
      unint64_t v6 = v22;
      break;
    case 16:
      [v14 size];
      [v14 scale];
      LOBYTE(v22) = GEOTileKeyMakeEmpty();
      *(void *)((char *)&v22 + 1) = v3 & 0x3F | ((unint64_t)(v4 & 0x3FFFFFF) << 32) | (v5 << 6);
      unint64_t v6 = v22;
      break;
    default:
      if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
      }
      uint64_t v18 = (id)GEOGetVectorKitVKDefaultLog_log;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v22) = 67109120;
        DWORD1(v22) = v6;
        _os_log_impl(&dword_1A1780000, v18, OS_LOG_TYPE_ERROR, "Unhandled tile style found: %d", (uint8_t *)&v22, 8u);
      }

      break;
  }

  return v6;
}

void sub_1A20B8024(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t altitude::TileKey::toUrlString(unsigned char *a1, _DWORD *a2, uint64_t a3, uint64_t a4, int a5)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)v65);
  uint64_t v10 = *(unsigned __int8 *)(a4 + 23);
  int v11 = (char)v10;
  if ((v10 & 0x80u) != 0) {
    uint64_t v10 = *(void *)(a4 + 8);
  }
  if (v10 == 15)
  {
    if (v11 >= 0) {
      uint64_t v23 = (uint64_t *)a4;
    }
    else {
      uint64_t v23 = *(uint64_t **)a4;
    }
    if (*v23 == 0x756F7365726F6567 && *(uint64_t *)((char *)v23 + 7) == 0x6833635F65637275)
    {
      int v38 = *(char *)(a3 + 23);
      if (v38 >= 0) {
        uint64_t v39 = a3;
      }
      else {
        uint64_t v39 = *(void *)a3;
      }
      if (v38 >= 0) {
        uint64_t v40 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        uint64_t v40 = *(void *)(a3 + 8);
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, v39, v40);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, (uint64_t)"_", 1);
      uint8x8_t v41 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v41, (uint64_t)"_", 1);
      unint64_t v42 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v42, (uint64_t)"_", 1);
      std::ostream::operator<<();
      if (a5)
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, (uint64_t)"_", 1);
        std::ostream::operator<<();
      }
      unsigned int v43 = ".c3h";
    }
    else
    {
      uint64_t v25 = *v23;
      uint64_t v26 = *(uint64_t *)((char *)v23 + 7);
      if (v25 != 0x756F7365726F6567 || v26 != 0x6233635F65637275) {
        goto LABEL_32;
      }
      int v44 = *(char *)(a3 + 23);
      if (v44 >= 0) {
        uint64_t v45 = a3;
      }
      else {
        uint64_t v45 = *(void *)a3;
      }
      if (v44 >= 0) {
        uint64_t v46 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        uint64_t v46 = *(void *)(a3 + 8);
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, v45, v46);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, (uint64_t)"_", 1);
      uint64_t v47 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v47, (uint64_t)"_", 1);
      uint64_t v48 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v48, (uint64_t)"_", 1);
      std::ostream::operator<<();
      if (a5)
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, (uint64_t)"_", 1);
        std::ostream::operator<<();
      }
      unsigned int v43 = ".c3b";
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, (uint64_t)v43, 4);
    goto LABEL_68;
  }
  if (v10 == 5)
  {
    uint64_t v12 = v11 >= 0 ? a4 : *(void *)a4;
    int v13 = *(_DWORD *)v12;
    int v14 = *(unsigned __int8 *)(v12 + 4);
    if (v13 == 1819308129 && v14 == 101)
    {
      int v16 = *(char *)(a3 + 23);
      if (v16 >= 0) {
        uint64_t v17 = a3;
      }
      else {
        uint64_t v17 = *(void *)a3;
      }
      if (v16 >= 0) {
        uint64_t v18 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        uint64_t v18 = *(void *)(a3 + 8);
      }
      if (*a2 == 14)
      {
        uint64_t v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, v17, v18);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"style=", 6);
        unsigned int v20 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"&region=", 8);
        uint64_t v21 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)"&v=", 3);
        long long v22 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)"&part=", 6);
      }
      else
      {
        int8x16_t v49 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, v17, v18);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v49, (uint64_t)"style=", 6);
        uint64_t v50 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v50, (uint64_t)"&region=", 8);
        uint64_t v51 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v51, (uint64_t)"&v=", 3);
        uint64_t v52 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"&z=", 3);
        uint64_t v53 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v53, (uint64_t)"&x=", 3);
        uint64_t v54 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v54, (uint64_t)"&y=", 3);
        long long v55 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"&h=", 3);
      }
      std::ostream::operator<<();
      goto LABEL_68;
    }
  }
LABEL_32:
  int v28 = *(char *)(a3 + 23);
  if (v28 >= 0) {
    uint64_t v29 = a3;
  }
  else {
    uint64_t v29 = *(void *)a3;
  }
  if (v28 >= 0) {
    uint64_t v30 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v30 = *(void *)(a3 + 8);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, v29, v30);
  uint64_t v31 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v31, (uint64_t)"/", 1);
  int v32 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v32, (uint64_t)"/map_", 5);
  unint64_t v33 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)"_", 1);
  int v34 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v34, (uint64_t)"_", 1);
  std::ostream::operator<<();
  if (a5)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, (uint64_t)"_", 1);
    std::ostream::operator<<();
  }
  int v35 = *(char *)(a4 + 23);
  if (v35 >= 0) {
    uint64_t v36 = a4;
  }
  else {
    uint64_t v36 = *(void *)a4;
  }
  if (v35 >= 0) {
    uint64_t v37 = *(unsigned __int8 *)(a4 + 23);
  }
  else {
    uint64_t v37 = *(void *)(a4 + 8);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, v36, v37);
LABEL_68:
  if ((v73 & 0x10) != 0)
  {
    unint64_t v57 = v72;
    if (v72 < v69)
    {
      unint64_t v72 = v69;
      unint64_t v57 = v69;
    }
    char v58 = (const void **)&v68;
  }
  else
  {
    if ((v73 & 8) == 0)
    {
      size_t v56 = 0;
      a1[23] = 0;
      goto LABEL_83;
    }
    char v58 = (const void **)v67;
    unint64_t v57 = v67[2];
  }
  int v59 = *v58;
  size_t v56 = v57 - (void)*v58;
  if (v56 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v56 >= 0x17)
  {
    uint64_t v60 = (v56 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v56 | 7) != 0x17) {
      uint64_t v60 = v56 | 7;
    }
    uint64_t v61 = v60 + 1;
    float v62 = operator new(v60 + 1);
    *((void *)a1 + 1) = v56;
    *((void *)a1 + 2) = v61 | 0x8000000000000000;
    *(void *)a1 = v62;
    a1 = v62;
    goto LABEL_82;
  }
  a1[23] = v56;
  if (v56) {
LABEL_82:
  }
    memmove(a1, v59, v56);
LABEL_83:
  a1[v56] = 0;
  v65[0] = *MEMORY[0x1E4FBA408];
  uint64_t v63 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v65 + *(void *)(v65[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v66[0] = v63;
  v66[1] = MEMORY[0x1E4FBA470] + 16;
  if (v71 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A62391A0](&v74);
}

void sub_1A20B87CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void altitude::TriggerManager::Trigger::~Trigger(altitude::TriggerManager::Trigger *this)
{
  altitude::TriggerManager::Trigger::~Trigger(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  void *v3;

  *(void *)this = &unk_1EF568F68;
  uint64_t v2 = *((void *)this + 9);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (*((char *)this + 223) < 0)
  {
    operator delete(*((void **)this + 25));
    if ((*((char *)this + 199) & 0x80000000) == 0)
    {
LABEL_5:
      if ((*((char *)this + 175) & 0x80000000) == 0) {
        goto LABEL_6;
      }
      goto LABEL_12;
    }
  }
  else if ((*((char *)this + 199) & 0x80000000) == 0)
  {
    goto LABEL_5;
  }
  operator delete(*((void **)this + 22));
  if ((*((char *)this + 175) & 0x80000000) == 0)
  {
LABEL_6:
    if ((*((char *)this + 151) & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_13;
  }
LABEL_12:
  operator delete(*((void **)this + 19));
  if ((*((char *)this + 151) & 0x80000000) == 0)
  {
LABEL_7:
    unsigned int v3 = (void *)*((void *)this + 13);
    if (!v3) {
      return;
    }
    goto LABEL_8;
  }
LABEL_13:
  operator delete(*((void **)this + 16));
  unsigned int v3 = (void *)*((void *)this + 13);
  if (!v3) {
    return;
  }
LABEL_8:
  *((void *)this + 14) = v3;
  operator delete(v3);
}

void altitude::TriggerManager::tagRead(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v335[19] = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *(void (****)(void))(a1 + 40);
  int v4 = *(void (****)(void))(a1 + 48);
  unint64_t v6 = (void *)(a1 + 40);
  if (v4 != v5)
  {
    double v7 = v4 - 30;
    uint64_t v8 = v4 - 30;
    unint64_t v9 = v4 - 30;
    do
    {
      uint64_t v10 = *v9;
      v9 -= 30;
      (*v10)(v8);
      v7 -= 30;
      BOOL v11 = v8 == v5;
      uint64_t v8 = v9;
    }
    while (!v11);
  }
  uint64_t v12 = *(void **)(a1 + 88);
  *(void *)(a1 + 48) = v5;
  unint64_t v267 = (void **)(a1 + 88);
  unint64_t v271 = (void *)(a1 + 96);
  if (v12 != (void *)(a1 + 96))
  {
    do
    {
      int v16 = (void *)v12[5];
      uint64_t v17 = v16[6];
      if (v17) {
        karo::BoundsTreeElement<karo::StaticSphereTreeElement,karo::BoundsTreeCommon<karo::StaticSphereTreeElement>,gm::Sphere<double,3,std::enable_if<true,void>>>::clear(v17);
      }
      v16[6] = 0;
      (*(void (**)(void *))(*v16 + 8))(v16);
      uint64_t v18 = (void *)v12[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          uint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v12[2];
          BOOL v11 = *v19 == (void)v12;
          uint64_t v12 = v19;
        }
        while (!v11);
      }
      uint64_t v12 = v19;
    }
    while (v19 != v271);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 96));
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = v271;
  v328[1] = 0;
  v328[0] = 0;
  long long v327 = v328;
  HIBYTE(__p[2]) = 7;
  strcpy((char *)__p, "trigger");
  if (*(void *)a3 && (int v13 = *(const xmlNode **)(*(void *)a3 + 24)) != 0)
  {
    while (1)
    {
      int v14 = SHIBYTE(__p[2]) >= 0 ? (const xmlChar *)__p : (const xmlChar *)__p[0];
      int v15 = SHIBYTE(__p[2]) >= 0 ? HIBYTE(__p[2]) : LODWORD(__p[1]);
      if (!xmlStrncmp(v13->name, v14, v15)) {
        break;
      }
      int v13 = v13->next;
      if (!v13) {
        goto LABEL_16;
      }
    }
    memset(&v326[1], 0, 40);
    v326[0] = v13;
    if (SHIBYTE(__p[2]) < 0)
    {
LABEL_29:
      operator delete(__p[0]);
      unint64_t v272 = v6;
      if (v326[0]) {
        goto LABEL_30;
      }
      goto LABEL_419;
    }
  }
  else
  {
LABEL_16:
    int v13 = 0;
    memset(v326, 0, 48);
    if (SHIBYTE(__p[2]) < 0) {
      goto LABEL_29;
    }
  }
  unint64_t v272 = v6;
  if (v13)
  {
LABEL_30:
    uint64_t v265 = *(void **)(MEMORY[0x1E4FBA408] + 24);
    unint64_t v266 = *(void **)(MEMORY[0x1E4FBA408] + 16);
    uint64_t v263 = *(void **)(MEMORY[0x1E4FBA408] + 40);
    uint64_t v264 = *(void **)(MEMORY[0x1E4FBA408] + 32);
    uint64_t v262 = *(void **)(MEMORY[0x1E4FBA408] + 48);
    uint64_t v260 = (void *)*MEMORY[0x1E4FBA408];
    uint64_t v261 = *(void **)(MEMORY[0x1E4FBA408] + 8);
    unsigned int v20 = *(void **)"c3meshdata";
    uint64_t v258 = *(void **)(MEMORY[0x1E4FBA408] + 72);
    uint64_t v259 = *(void **)(MEMORY[0x1E4FBA408] + 64);
    uint64_t v21 = v326[0];
    do
    {
      HIBYTE(__p[2]) = 4;
      strcpy((char *)__p, "data");
      if (v21 && (children = v21->children) != 0)
      {
        while (1)
        {
          uint64_t v23 = SHIBYTE(__p[2]) >= 0 ? (const xmlChar *)__p : (const xmlChar *)__p[0];
          int v24 = SHIBYTE(__p[2]) >= 0 ? HIBYTE(__p[2]) : LODWORD(__p[1]);
          if (!xmlStrncmp(children->name, v23, v24)) {
            break;
          }
          children = children->next;
          if (!children) {
            goto LABEL_42;
          }
        }
        v325[0] = children;
        memset(&v325[1], 0, 40);
        if (SHIBYTE(__p[2]) < 0) {
LABEL_43:
        }
          operator delete(__p[0]);
      }
      else
      {
LABEL_42:
        memset(v325, 0, sizeof(v325));
        if (SHIBYTE(__p[2]) < 0) {
          goto LABEL_43;
        }
      }
      HIBYTE(__p[2]) = 5;
      strcpy((char *)__p, "shape");
      if (v326[0] && (uint64_t v25 = v326[0]->children) != 0)
      {
        while (1)
        {
          uint64_t v26 = SHIBYTE(__p[2]) >= 0 ? (const xmlChar *)__p : (const xmlChar *)__p[0];
          int v27 = SHIBYTE(__p[2]) >= 0 ? HIBYTE(__p[2]) : LODWORD(__p[1]);
          if (!xmlStrncmp(v25->name, v26, v27)) {
            break;
          }
          uint64_t v25 = v25->next;
          if (!v25) {
            goto LABEL_54;
          }
        }
        v324[0] = v25;
        memset(&v324[1], 0, 40);
        if (SHIBYTE(__p[2]) < 0) {
LABEL_55:
        }
          operator delete(__p[0]);
      }
      else
      {
LABEL_54:
        memset(v324, 0, sizeof(v324));
        if (SHIBYTE(__p[2]) < 0) {
          goto LABEL_55;
        }
      }
      HIBYTE(__p[2]) = 10;
      strcpy((char *)&__p[1], "ta");
      __p[0] = v20;
      if (!v326[0] || (int v28 = v326[0]->children) == 0)
      {
LABEL_66:
        memset(v323, 0, sizeof(v323));
        if ((SHIBYTE(__p[2]) & 0x80000000) == 0) {
          goto LABEL_68;
        }
LABEL_67:
        operator delete(__p[0]);
        goto LABEL_68;
      }
      while (1)
      {
        uint64_t v29 = SHIBYTE(__p[2]) >= 0 ? (const xmlChar *)__p : (const xmlChar *)__p[0];
        int v30 = SHIBYTE(__p[2]) >= 0 ? HIBYTE(__p[2]) : LODWORD(__p[1]);
        if (!xmlStrncmp(v28->name, v29, v30)) {
          break;
        }
        int v28 = v28->next;
        if (!v28) {
          goto LABEL_66;
        }
      }
      v323[0] = v28;
      memset(&v323[1], 0, 40);
      if (SHIBYTE(__p[2]) < 0) {
        goto LABEL_67;
      }
LABEL_68:
      *((unsigned char *)&v322.__r_.__value_.__s + 23) = 4;
      strcpy((char *)&v322, ".c3m");
      *((unsigned char *)&v321.__r_.__value_.__s + 23) = 5;
      strcpy((char *)&v321, ".c3mm");
      *((unsigned char *)&v320.__r_.__value_.__s + 23) = 0;
      v320.__r_.__value_.__s.__data_[0] = 0;
      double v318 = 0.0;
      double v317 = 0.0;
      double v319 = 0.0;
      double v316 = 0.0;
      *((unsigned char *)&v315.__r_.__value_.__s + 23) = 0;
      v315.__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&v314.__r_.__value_.__s + 23) = 0;
      v314.__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&v313.__r_.__value_.__s + 23) = 0;
      v313.__r_.__value_.__s.__data_[0] = 0;
      *(void *)uint64_t v312 = 0;
      int v311 = 0;
      int v310 = 1;
      int v309 = -1;
      double v308 = 384.0;
      int v307 = 0x7FFFFFFF;
      if (v325[0])
      {
        if (v324[0])
        {
          if (!v323[0])
          {
            if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
              dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
            }
            uint64_t v31 = GEOGetVectorKitVKDefaultLog_log;
            if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
            {
              LOWORD(__p[0]) = 0;
              _os_log_impl(&dword_1A1780000, v31, OS_LOG_TYPE_ERROR, "Malformed trigger tag in xml: missing c3meshdata node", (uint8_t *)__p, 2u);
            }
          }
          int v32 = XmlNode::Attribute(v325, (const xmlChar *)"type");
          if (v32)
          {
            unint64_t v33 = v32;
            if (!strncmp((const char *)v32, "c3mesh", 6uLL))
            {
              uint64_t v45 = XmlNode::Attribute(v325, (const xmlChar *)"dataurl");
              if (v45)
              {
                std::string::__assign_external(&v315, (const std::string::value_type *)v45);
                uint64_t v46 = XmlNode::Attribute(v325, (const xmlChar *)"dataurlformat");
                if (v46) {
                  std::string::__assign_external(&v322, (const std::string::value_type *)v46);
                }
                uint64_t v47 = XmlNode::Attribute(v325, (const xmlChar *)"metaurl");
                if (v47)
                {
                  std::string::__assign_external(&v314, (const std::string::value_type *)v47);
                  uint64_t v48 = XmlNode::Attribute(v325, (const xmlChar *)"metaurlformat");
                  if (v48) {
                    std::string::__assign_external(&v321, (const std::string::value_type *)v48);
                  }
                  int8x16_t v49 = XmlNode::Attribute(v323, (const xmlChar *)"dtmurl");
                  if (v49) {
                    std::string::__assign_external(&v313, (const std::string::value_type *)v49);
                  }
                  uint64_t v50 = XmlNode::Attribute(v323, (const xmlChar *)"dtmurlformat");
                  if (v50) {
                    std::string::__assign_external(&v320, (const std::string::value_type *)v50);
                  }
                  XmlNode::Attribute(v323, (const xmlChar *)"priority", &v312[1]);
                  if (!XmlNode::Attribute(v323, (const xmlChar *)"level", v312))
                  {
                    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                    }
                    uint64_t v51 = GEOGetVectorKitVKDefaultLog_log;
                    if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
                    {
                      LOWORD(__p[0]) = 0;
                      _os_log_impl(&dword_1A1780000, v51, OS_LOG_TYPE_ERROR, "Failed to load start level of c3 mesh trigger", (uint8_t *)__p, 2u);
                    }
                  }
                  uint64_t v52 = XmlNode::Attribute(v324, (const xmlChar *)"type");
                  if (v52)
                  {
                    if (!strncmp((const char *)v52, "sphere", 6uLL))
                    {
                      if (XmlNode::Attribute(v324, (const xmlChar *)"latitude", &v317))
                      {
                        if (XmlNode::Attribute(v324, (const xmlChar *)"longitude", &v318))
                        {
                          if (XmlNode::Attribute(v324, (const xmlChar *)"radius", &v316))
                          {
                            XmlNode::Attribute(v324, (const xmlChar *)"altitude", &v319);
                            uint64_t v61 = 0;
                            __s = 0;
                            float v82 = 0;
                            goto LABEL_235;
                          }
                          if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                            dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                          }
                          uint64_t v115 = GEOGetVectorKitVKDefaultLog_log;
                          if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
                          {
                            LOWORD(__p[0]) = 0;
                            uint8x8_t v41 = v115;
                            unint64_t v42 = "Missing radius in sphere shape trigger specification";
                            goto LABEL_276;
                          }
                        }
                        else
                        {
                          if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                            dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                          }
                          uint64_t v88 = GEOGetVectorKitVKDefaultLog_log;
                          if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
                          {
                            LOWORD(__p[0]) = 0;
                            uint8x8_t v41 = v88;
                            unint64_t v42 = "Missing longitude in sphere shape trigger specification";
                            goto LABEL_276;
                          }
                        }
                      }
                      else
                      {
                        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                        }
                        uint64_t v87 = GEOGetVectorKitVKDefaultLog_log;
                        if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
                        {
                          LOWORD(__p[0]) = 0;
                          uint8x8_t v41 = v87;
                          unint64_t v42 = "Missing latitude in sphere shape trigger specification";
                          goto LABEL_276;
                        }
                      }
                    }
                    else
                    {
                      if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                        dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                      }
                      uint64_t v53 = GEOGetVectorKitVKDefaultLog_log;
                      if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
                      {
                        LOWORD(__p[0]) = 0;
                        uint8x8_t v41 = v53;
                        unint64_t v42 = "Unknown shape type in trigger";
                        goto LABEL_276;
                      }
                    }
                  }
                  else
                  {
                    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                    }
                    uint64_t v80 = GEOGetVectorKitVKDefaultLog_log;
                    if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
                    {
                      LOWORD(__p[0]) = 0;
                      uint8x8_t v41 = v80;
                      unint64_t v42 = "No shape type specified in trigger";
                      goto LABEL_276;
                    }
                  }
                }
                else
                {
                  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                  }
                  uint64_t v78 = GEOGetVectorKitVKDefaultLog_log;
                  if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
                  {
                    LOWORD(__p[0]) = 0;
                    uint8x8_t v41 = v78;
                    unint64_t v42 = "No meta url specified for trigger";
                    goto LABEL_276;
                  }
                }
              }
              else
              {
                if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                  dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                }
                uint64_t v76 = GEOGetVectorKitVKDefaultLog_log;
                if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(__p[0]) = 0;
                  uint8x8_t v41 = v76;
                  unint64_t v42 = "No data url specified for trigger";
                  goto LABEL_276;
                }
              }
            }
            else
            {
              if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
              }
              int v34 = GEOGetVectorKitVKDefaultLog_log;
              if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
              {
                LODWORD(__p[0]) = 136315138;
                *(void **)((char *)__p + 4) = v33;
                _os_log_impl(&dword_1A1780000, v34, OS_LOG_TYPE_ERROR, "Invalid data type in trigger specification: %s", (uint8_t *)__p, 0xCu);
                if ((SHIBYTE(v313.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  goto LABEL_278;
                }
                goto LABEL_416;
              }
            }
          }
          else
          {
            if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
              dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
            }
            uint64_t v44 = GEOGetVectorKitVKDefaultLog_log;
            if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
            {
              LOWORD(__p[0]) = 0;
              uint8x8_t v41 = v44;
              unint64_t v42 = "No data type specified for trigger";
              goto LABEL_276;
            }
          }
        }
        else
        {
          if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
            dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
          }
          uint64_t v40 = GEOGetVectorKitVKDefaultLog_log;
          if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p[0]) = 0;
            uint8x8_t v41 = v40;
            unint64_t v42 = "Malformed trigger tag in xml: missing shape node";
LABEL_276:
            _os_log_impl(&dword_1A1780000, v41, OS_LOG_TYPE_ERROR, v42, (uint8_t *)__p, 2u);
          }
        }
      }
      else
      {
        if (!((uint64_t)v324[0] | (uint64_t)v323[0]))
        {
          int v35 = XmlNode::Attribute(v326, (const xmlChar *)"type");
          if (!v35) {
            goto LABEL_141;
          }
          uint64_t v36 = v35;
          size_t v37 = strlen((const char *)v35);
          if (v37 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_485;
          }
          int v38 = (void *)v37;
          if (v37 >= 0x17)
          {
            uint64_t v54 = (v37 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v37 | 7) != 0x17) {
              uint64_t v54 = v37 | 7;
            }
            uint64_t v55 = v54 + 1;
            uint64_t v39 = operator new(v54 + 1);
            __p[2] = (void *)(v55 | 0x8000000000000000);
            __p[0] = v39;
            __p[1] = v38;
          }
          else
          {
            HIBYTE(__p[2]) = v37;
            uint64_t v39 = __p;
            if (!v37)
            {
LABEL_131:
              BOOL v56 = 0;
              *((unsigned char *)v38 + (void)v39) = 0;
              unint64_t v57 = (void *)HIBYTE(__p[2]);
              if (SHIBYTE(__p[2]) < 0) {
                unint64_t v57 = __p[1];
              }
              if (v57 == (void *)4)
              {
                char v58 = (void **)__p[0];
                if (SHIBYTE(__p[2]) >= 0) {
                  char v58 = __p;
                }
                BOOL v56 = *(_DWORD *)v58 == 1920298868;
                unsigned int v20 = *(void **)"c3meshdata";
                if ((SHIBYTE(__p[2]) & 0x80000000) == 0) {
                  goto LABEL_135;
                }
              }
              else
              {
                unsigned int v20 = *(void **)"c3meshdata";
                if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
                {
LABEL_135:
                  if (v56) {
                    goto LABEL_277;
                  }
                  goto LABEL_141;
                }
              }
              operator delete(__p[0]);
              if (v56) {
                goto LABEL_277;
              }
LABEL_141:
              int v59 = XmlNode::Attribute(v326, (const xmlChar *)"meta_levels");
              uint64_t v60 = XmlNode::Attribute(v326, (const xmlChar *)"meta_zmax");
              uint64_t v61 = XmlNode::Attribute(v326, (const xmlChar *)"meta_region");
              if (SHIBYTE(v322.__r_.__value_.__r.__words[2]) < 0)
              {
                v322.__r_.__value_.__l.__size_ = 5;
                float v62 = (std::string *)v322.__r_.__value_.__r.__words[0];
              }
              else
              {
                *((unsigned char *)&v322.__r_.__value_.__s + 23) = 5;
                float v62 = &v322;
              }
              strcpy((char *)v62, "apple");
              if (SHIBYTE(v321.__r_.__value_.__r.__words[2]) < 0)
              {
                v321.__r_.__value_.__l.__size_ = 5;
                uint64_t v63 = (std::string *)v321.__r_.__value_.__r.__words[0];
              }
              else
              {
                *((unsigned char *)&v321.__r_.__value_.__s + 23) = 5;
                uint64_t v63 = &v321;
              }
              strcpy((char *)v63, "apple");
              if (SHIBYTE(v320.__r_.__value_.__r.__words[2]) < 0)
              {
                v320.__r_.__value_.__l.__size_ = 5;
                int v64 = (std::string *)v320.__r_.__value_.__r.__words[0];
              }
              else
              {
                *((unsigned char *)&v320.__r_.__value_.__s + 23) = 5;
                int v64 = &v320;
              }
              strcpy((char *)v64, "apple");
              std::string::__assign_external(&v315, "http://some.server.com/tile?style=15", 0x24uLL);
              std::string::__assign_external(&v313, "http://some.server.com/tile?style=16", 0x24uLL);
              if (XmlNode::Attribute(v326, (const xmlChar *)"latitude", &v317))
              {
                if (XmlNode::Attribute(v326, (const xmlChar *)"longitude", &v318))
                {
                  if (XmlNode::Attribute(v326, (const xmlChar *)"radius", &v316))
                  {
                    if (XmlNode::Attribute(v326, (const xmlChar *)"altitude", &v319))
                    {
                      XmlNode::Attribute(v326, (const xmlChar *)"priority", &v312[1]);
                      XmlNode::Attribute(v326, (const xmlChar *)"tilepixels", &v308);
                      if (XmlNode::Attribute(v326, (const xmlChar *)"region", &v311))
                      {
                        if (XmlNode::Attribute(v326, (const xmlChar *)"version", &v310))
                        {
                          __s = (char *)v60;
                          unsigned __int8 v251 = (void *)(MEMORY[0x1E4FBA488] + 24);
                          uint64_t v252 = v59;
                          uint64_t v65 = MEMORY[0x1E4FBA488] + 104;
                          v335[0] = MEMORY[0x1E4FBA488] + 104;
                          uint64_t v66 = (void *)(MEMORY[0x1E4FBA488] + 64);
                          __p[2] = (void *)(MEMORY[0x1E4FBA488] + 64);
                          __p[0] = v266;
                          *(void **)((char *)__p + *((void *)v266 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v265;
                          __p[1] = 0;
                          int8x8_t v67 = (std::ios_base *)((char *)__p + *((void *)__p[0] - 3));
                          std::ios_base::init(v67, &__p[3]);
                          v67[1].__vftable = 0;
                          v67[1].__fmtflags_ = -1;
                          __p[2] = v264;
                          *(void **)((char *)&__p[2] + *((void *)v264 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v263;
                          __p[0] = v261;
                          *(void **)((char *)__p + *((void *)v261 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v262;
                          v335[0] = v65;
                          __p[0] = v251;
                          __p[2] = v66;
                          std::streambuf::basic_streambuf();
                          uint64_t v68 = (void *)(MEMORY[0x1E4FBA470] + 16);
                          __p[3] = (void *)(MEMORY[0x1E4FBA470] + 16);
                          long long v332 = 0u;
                          long long v333 = 0u;
                          int v334 = 24;
                          if ((v313.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                            unint64_t v69 = &v313;
                          }
                          else {
                            unint64_t v69 = (std::string *)v313.__r_.__value_.__r.__words[0];
                          }
                          if ((v313.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                            std::string::size_type size = HIBYTE(v313.__r_.__value_.__r.__words[2]);
                          }
                          else {
                            std::string::size_type size = v313.__r_.__value_.__l.__size_;
                          }
                          char v71 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&__p[2], (uint64_t)v69, size);
                          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v71, (uint64_t)"&v=", 3);
                          unint64_t v72 = (void *)std::ostream::operator<<();
                          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v72, (uint64_t)"&region=", 8);
                          std::ostream::operator<<();
                          if ((v334 & 0x10) != 0)
                          {
                            unint64_t v85 = (unsigned char *)*((void *)&v333 + 1);
                            uint64_t v86 = (const void **)&v330;
                            if (*((void *)&v333 + 1) < (unint64_t)v331)
                            {
                              *((void *)&v333 + 1) = v331;
                              unint64_t v85 = v331;
                              uint64_t v86 = (const void **)&v330;
                            }
                          }
                          else
                          {
                            if ((v334 & 8) == 0)
                            {
                              std::string::size_type v73 = 0;
                              *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
                              p_dst = &__dst;
                              goto LABEL_224;
                            }
                            unint64_t v85 = __p[7];
                            uint64_t v86 = (const void **)&__p[5];
                          }
                          unsigned int v89 = *v86;
                          std::string::size_type v73 = v85 - (unsigned char *)*v86;
                          if (v73 > 0x7FFFFFFFFFFFFFF7) {
                            goto LABEL_485;
                          }
                          if (v73 >= 0x17)
                          {
                            uint64_t v90 = (v73 & 0xFFFFFFFFFFFFFFF8) + 8;
                            if ((v73 | 7) != 0x17) {
                              uint64_t v90 = v73 | 7;
                            }
                            uint64_t v91 = v90 + 1;
                            p_dst = (std::string *)operator new(v90 + 1);
                            __dst.__r_.__value_.__r.__words[2] = v91 | 0x8000000000000000;
                            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
                            __dst.__r_.__value_.__l.__size_ = v73;
                          }
                          else
                          {
                            *((unsigned char *)&__dst.__r_.__value_.__s + 23) = (_BYTE)v85 - *(unsigned char *)v86;
                            p_dst = &__dst;
                            if (!v73) {
                              goto LABEL_224;
                            }
                          }
                          memmove(p_dst, v89, v73);
LABEL_224:
                          p_dst->__r_.__value_.__s.__data_[v73] = 0;
                          if (SHIBYTE(v313.__r_.__value_.__r.__words[2]) < 0) {
                            operator delete(v313.__r_.__value_.__l.__data_);
                          }
                          std::string v313 = __dst;
                          XmlNode::Attribute(v326, (const xmlChar *)"level", v312);
                          XmlNode::Attribute(v326, (const xmlChar *)"max_level", &v309);
                          if (XmlNode::Attribute(v326, (const xmlChar *)"FLYOVER_C3M_MESH"))
                          {
                            int8x16_t v92 = XmlNode::Attribute(v326, (const xmlChar *)"FLYOVER_C3M_MESH");
                            strncmp((const char *)v92, "true", 4uLL);
                          }
                          if (XmlNode::Attribute(v326, (const xmlChar *)"FLYOVER_C3M_JPEG_TEXTURE"))
                          {
                            uint64_t v93 = XmlNode::Attribute(v326, (const xmlChar *)"FLYOVER_C3M_JPEG_TEXTURE");
                            strncmp((const char *)v93, "true", 4uLL);
                          }
                          float v82 = (const char *)v252;
                          if (XmlNode::Attribute(v326, (const xmlChar *)"FLYOVER_C3M_ASTC_TEXTURE"))
                          {
                            uint64_t v94 = XmlNode::Attribute(v326, (const xmlChar *)"FLYOVER_C3M_ASTC_TEXTURE");
                            strncmp((const char *)v94, "true", 4uLL);
                          }
                          XmlNode::Attribute(v326, (const xmlChar *)"highres_tex_min_level", &v307);
                          __p[0] = v260;
                          *(void **)((char *)__p + *((void *)v260 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v259;
                          __p[2] = v258;
                          __p[3] = v68;
                          if (SBYTE7(v333) < 0) {
                            operator delete((void *)v332);
                          }
                          std::streambuf::~streambuf();
                          std::iostream::~basic_iostream();
                          MEMORY[0x1A62391A0](v335);
LABEL_235:
                          double v95 = v318;
                          double v96 = v319;
                          __double2 v97 = __sincos_stret(v317);
                          __double2 v100 = __sincos_stret(v95);
                          v99.f64[0] = v100.__cosval;
                          double sinval = v100.__sinval;
                          long long v293 = 0u;
                          long long v294 = 0u;
                          float64x2_t v295 = 0u;
                          long long v296 = 0u;
                          v292[1] = &unk_1EF568F68;
                          uint64_t v297 = 0;
                          long long v301 = 0u;
                          memset(v302, 0, sizeof(v302));
                          memset(v303, 0, sizeof(v303));
                          memset(&v304, 0, sizeof(v304));
                          int v306 = 0;
                          uint64_t v305 = 0xFFFFFFFFLL;
                          if (SHIBYTE(v321.__r_.__value_.__r.__words[2]) < 0)
                          {
                            std::string::__assign_no_alias<true>(v303[1].__r_.__value_.__r.__words, v321.__r_.__value_.__l.__data_, v321.__r_.__value_.__l.__size_);
                            double v101 = 1.0;
                            if (SHIBYTE(v304.__r_.__value_.__r.__words[2]) < 0)
                            {
                              if ((v322.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                float v102 = &v322;
                              }
                              else {
                                float v102 = (std::string *)v322.__r_.__value_.__r.__words[0];
                              }
                              if ((v322.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                size_t v103 = HIBYTE(v322.__r_.__value_.__r.__words[2]);
                              }
                              else {
                                size_t v103 = v322.__r_.__value_.__l.__size_;
                              }
                              std::string::__assign_no_alias<false>((void **)&v304.__r_.__value_.__l.__data_, v102, v103);
                              v99.f64[0] = v100.__cosval;
                              double sinval = v100.__sinval;
                            }
                            else
                            {
                              v99.f64[0] = v100.__cosval;
                              double sinval = v100.__sinval;
                              if ((*((unsigned char *)&v322.__r_.__value_.__s + 23) & 0x80) != 0) {
                                goto LABEL_240;
                              }
LABEL_237:
                              std::string v304 = v322;
                            }
                          }
                          else
                          {
                            v303[1] = v321;
                            double v101 = 1.0;
                            if ((SHIBYTE(v322.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                              goto LABEL_237;
                            }
LABEL_240:
                            double v249 = sinval;
                            float64_t v257 = v99.f64[0];
                            std::string::__assign_no_alias<true>(&v304, v322.__r_.__value_.__l.__data_, v322.__r_.__value_.__l.__size_);
                            double sinval = v249;
                            v99.f64[0] = v257;
                          }
                          double v104 = 6378137.0 / sqrt(v101 + v97.__sinval * v97.__sinval * -0.00669437999);
                          v99.f64[1] = sinval;
                          *(double *)&long long v105 = (v96 + v104 * 0.99330562) * v97.__sinval;
                          *((double *)&v105 + 1) = v316;
                          float64x2_t v295 = vmulq_n_f64(v99, (v104 + v96) * v97.__cosval);
                          long long v296 = v105;
                          if (SHIBYTE(v303[0].__r_.__value_.__r.__words[2]) < 0)
                          {
                            if ((v315.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                              unint64_t v106 = &v315;
                            }
                            else {
                              unint64_t v106 = (std::string *)v315.__r_.__value_.__r.__words[0];
                            }
                            if ((v315.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                              size_t v107 = HIBYTE(v315.__r_.__value_.__r.__words[2]);
                            }
                            else {
                              size_t v107 = v315.__r_.__value_.__l.__size_;
                            }
                            std::string::__assign_no_alias<false>((void **)&v303[0].__r_.__value_.__l.__data_, v106, v107);
                          }
                          else if ((*((unsigned char *)&v315.__r_.__value_.__s + 23) & 0x80) != 0)
                          {
                            std::string::__assign_no_alias<true>(v303, v315.__r_.__value_.__l.__data_, v315.__r_.__value_.__l.__size_);
                          }
                          else
                          {
                            v303[0] = v315;
                          }
                          std::string::size_type v108 = HIBYTE(v304.__r_.__value_.__r.__words[2]);
                          if ((v304.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                            std::string::size_type v108 = v304.__r_.__value_.__l.__size_;
                          }
                          if (v108 != 4) {
                            goto LABEL_320;
                          }
                          uint64_t v109 = &v304;
                          if ((v304.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                            uint64_t v109 = (std::string *)v304.__r_.__value_.__r.__words[0];
                          }
                          if (LODWORD(v109->__r_.__value_.__l.__data_) != 1832084270) {
                            goto LABEL_320;
                          }
                          size_t v110 = HIBYTE(v303[0].__r_.__value_.__r.__words[2]);
                          size_t v111 = v303[0].__r_.__value_.__l.__size_;
                          if ((v303[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                            std::string::size_type v112 = HIBYTE(v303[0].__r_.__value_.__r.__words[2]);
                          }
                          else {
                            std::string::size_type v112 = v303[0].__r_.__value_.__l.__size_;
                          }
                          std::string::size_type v113 = v112 - 1;
                          if ((SHIBYTE(v303[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                          {
                            if (v303[0].__r_.__value_.__s.__data_[v113] != 47)
                            {
                              if (HIBYTE(v303[0].__r_.__value_.__r.__words[2]) == 22)
                              {
                                size_t v114 = v303;
                                size_t v111 = 22;
                                goto LABEL_303;
                              }
                              *((unsigned char *)&v303[0].__r_.__value_.__s + 23) = (*((unsigned char *)&v303[0].__r_.__value_.__s + 23)
                                                                           + 1) & 0x7F;
                              size_t v111 = v110;
                              size_t v114 = v303;
LABEL_319:
                              *(_WORD *)((char *)&v114->__r_.__value_.__l.__data_ + v111) = 47;
                            }
LABEL_320:
                            if (SHIBYTE(v302[3]) < 0)
                            {
                              if ((v314.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                long long v127 = &v314;
                              }
                              else {
                                long long v127 = (std::string *)v314.__r_.__value_.__r.__words[0];
                              }
                              if ((v314.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                size_t v128 = HIBYTE(v314.__r_.__value_.__r.__words[2]);
                              }
                              else {
                                size_t v128 = v314.__r_.__value_.__l.__size_;
                              }
                              std::string::__assign_no_alias<false>((void **)&v302[1], v127, v128);
                              uint64_t v126 = __s;
                            }
                            else
                            {
                              uint64_t v126 = __s;
                              if ((*((unsigned char *)&v314.__r_.__value_.__s + 23) & 0x80) != 0) {
                                std::string::__assign_no_alias<true>(&v302[1], v314.__r_.__value_.__l.__data_, v314.__r_.__value_.__l.__size_);
                              }
                              else {
                                *(std::string *)&v302[1] = v314;
                              }
                            }
                            HIDWORD(v305) = v311;
                            int v306 = v310;
                            if (v61)
                            {
                              size_t v129 = strlen((const char *)v61);
                              if (v129 > 0x7FFFFFFFFFFFFFF7) {
                                goto LABEL_485;
                              }
                              std::string::size_type v130 = v129;
                              uint64_t v253 = v82;
                              if (v129 >= 0x17)
                              {
                                uint64_t v132 = (v129 & 0xFFFFFFFFFFFFFFF8) + 8;
                                if ((v129 | 7) != 0x17) {
                                  uint64_t v132 = v129 | 7;
                                }
                                uint64_t v133 = v132 + 1;
                                char v131 = (std::string *)operator new(v132 + 1);
                                __dst.__r_.__value_.__r.__words[2] = v133 | 0x8000000000000000;
                                __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v131;
                                __dst.__r_.__value_.__l.__size_ = v130;
                              }
                              else
                              {
                                *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v129;
                                char v131 = &__dst;
                                if (!v129)
                                {
LABEL_340:
                                  v131->__r_.__value_.__s.__data_[v130] = 0;
                                  float v250 = (void *)(MEMORY[0x1E4FBA488] + 24);
                                  uint64_t v248 = MEMORY[0x1E4FBA488] + 104;
                                  v335[0] = MEMORY[0x1E4FBA488] + 104;
                                  uint64_t v134 = (void *)(MEMORY[0x1E4FBA488] + 64);
                                  __p[2] = (void *)(MEMORY[0x1E4FBA488] + 64);
                                  __p[0] = v266;
                                  *(void **)((char *)__p + *((void *)v266 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v265;
                                  __p[1] = 0;
                                  int v135 = (std::ios_base *)((char *)__p + *((void *)__p[0] - 3));
                                  std::ios_base::init(v135, &__p[3]);
                                  v135[1].__vftable = 0;
                                  v135[1].__fmtflags_ = -1;
                                  __p[2] = v264;
                                  *(void **)((char *)&__p[2] + *((void *)v264 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v263;
                                  __p[0] = v261;
                                  *(void **)((char *)__p + *((void *)v261 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v262;
                                  v335[0] = v248;
                                  __p[0] = v250;
                                  __p[2] = v134;
                                  uint64_t v136 = std::streambuf::basic_streambuf();
                                  int v137 = (void *)(MEMORY[0x1E4FBA470] + 16);
                                  long long v332 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
                                  long long v333 = __dst.__r_.__value_.__r.__words[2];
                                  __p[3] = (void *)(MEMORY[0x1E4FBA470] + 16);
                                  int v334 = 24;
                                  std::stringbuf::__init_buf_ptrs[abi:nn180100](v136);
                                  LODWORD(__dst.__r_.__value_.__l.__data_) = 0;
                                  LODWORD(v275) = 0;
                                  LODWORD(v273) = 0;
                                  v292[0] = 0;
                                  uint64_t v138 = MEMORY[0x1A6238CB0](__p, &__dst);
                                  uint64_t v139 = MEMORY[0x1A6238CB0](v138, &v275);
                                  uint64_t v140 = MEMORY[0x1A6238CB0](v139, &v273);
                                  uint64_t v141 = MEMORY[0x1A6238CB0](v140, (char *)v292 + 4);
                                  unint64_t v142 = (void *)MEMORY[0x1A6238CB0](v141, v292);
                                  if ((*((unsigned char *)v142 + *(void *)(*v142 - 24) + 32) & 5) != 0)
                                  {
                                    uint64_t v298 = 0;
                                    unint64_t v299 = 0;
                                    int v300 = 0;
                                  }
                                  else
                                  {
                                    LOBYTE(v298) = __dst.__r_.__value_.__s.__data_[0];
                                    HIDWORD(v298) = v275;
                                    unint64_t v299 = __PAIR64__(HIDWORD(v292[0]), v273);
                                    int v300 = v292[0];
                                  }
                                  uint64_t v126 = __s;
                                  __p[0] = v260;
                                  *(void **)((char *)__p + *((void *)v260 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v259;
                                  __p[2] = v258;
                                  __p[3] = v137;
                                  if (SBYTE7(v333) < 0) {
                                    operator delete((void *)v332);
                                  }
                                  std::streambuf::~streambuf();
                                  std::iostream::~basic_iostream();
                                  MEMORY[0x1A62391A0](v335);
                                  float v82 = v253;
                                  goto LABEL_346;
                                }
                              }
                              memmove(v131, v61, v130);
                              goto LABEL_340;
                            }
LABEL_346:
                            if (v82 && v126)
                            {
                              size_t v143 = strlen(v82);
                              if (v143 > 0x7FFFFFFFFFFFFFF7) {
                                goto LABEL_485;
                              }
                              std::string::size_type v144 = v143;
                              if (v143 >= 0x17)
                              {
                                uint64_t v146 = (v143 & 0xFFFFFFFFFFFFFFF8) + 8;
                                if ((v143 | 7) != 0x17) {
                                  uint64_t v146 = v143 | 7;
                                }
                                uint64_t v147 = v146 + 1;
                                uint64_t v145 = (std::string *)operator new(v146 + 1);
                                __dst.__r_.__value_.__r.__words[2] = v147 | 0x8000000000000000;
                                __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v145;
                                __dst.__r_.__value_.__l.__size_ = v144;
                              }
                              else
                              {
                                *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v143;
                                uint64_t v145 = &__dst;
                                if (!v143)
                                {
LABEL_356:
                                  v145->__r_.__value_.__s.__data_[v144] = 0;
                                  float v246 = (void *)(MEMORY[0x1E4FBA488] + 24);
                                  uint64_t v148 = MEMORY[0x1E4FBA488] + 104;
                                  v335[0] = MEMORY[0x1E4FBA488] + 104;
                                  uint64_t v149 = (void *)(MEMORY[0x1E4FBA488] + 64);
                                  __p[2] = (void *)(MEMORY[0x1E4FBA488] + 64);
                                  __p[0] = v266;
                                  *(void **)((char *)__p + *((void *)v266 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v265;
                                  __p[1] = 0;
                                  unint64_t v150 = (std::ios_base *)((char *)__p + *((void *)__p[0] - 3));
                                  std::ios_base::init(v150, &__p[3]);
                                  v150[1].__vftable = 0;
                                  v150[1].__fmtflags_ = -1;
                                  __p[2] = v264;
                                  *(void **)((char *)&__p[2] + *((void *)v264 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v263;
                                  __p[0] = v261;
                                  *(void **)((char *)__p + *((void *)v261 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v262;
                                  v335[0] = v148;
                                  __p[0] = v246;
                                  __p[2] = v149;
                                  std::streambuf::basic_streambuf();
                                  uint64_t v151 = MEMORY[0x1E4FBA470] + 16;
                                  long long v332 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
                                  long long v333 = __dst.__r_.__value_.__r.__words[2];
                                  __p[3] = (void *)(MEMORY[0x1E4FBA470] + 16);
                                  int v334 = 24;
                                  std::stringbuf::__init_buf_ptrs[abi:nn180100]((uint64_t)&__p[3]);
                                  size_t v152 = strlen(__s);
                                  if (v152 > 0x7FFFFFFFFFFFFFF7) {
                                    goto LABEL_485;
                                  }
                                  size_t v153 = v152;
                                  float v247 = (void *)v151;
                                  if (v152 >= 0x17)
                                  {
                                    uint64_t v155 = (v152 & 0xFFFFFFFFFFFFFFF8) + 8;
                                    if ((v152 | 7) != 0x17) {
                                      uint64_t v155 = v152 | 7;
                                    }
                                    uint64_t v156 = v155 + 1;
                                    unint64_t v154 = (long long *)operator new(v155 + 1);
                                    unint64_t v276 = v156 | 0x8000000000000000;
                                    *(void *)&long long v275 = v154;
                                    *((void *)&v275 + 1) = v153;
                                  }
                                  else
                                  {
                                    HIBYTE(v276) = v152;
                                    unint64_t v154 = &v275;
                                    if (!v152) {
                                      goto LABEL_364;
                                    }
                                  }
                                  memmove(v154, __s, v153);
LABEL_364:
                                  *((unsigned char *)v154 + v153) = 0;
                                  __sb = (char *)(MEMORY[0x1E4FBA488] + 24);
                                  uint64_t v157 = MEMORY[0x1E4FBA488] + 104;
                                  v291[0] = MEMORY[0x1E4FBA488] + 104;
                                  uint64_t v158 = MEMORY[0x1E4FBA488] + 64;
                                  __dst.__r_.__value_.__r.__words[2] = MEMORY[0x1E4FBA488] + 64;
                                  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v266;
                                  *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words
                                                            + *((void *)v266 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = (std::string::size_type)v265;
                                  __dst.__r_.__value_.__l.__size_ = 0;
                                  char v159 = (std::ios_base *)((char *)&__dst
                                                         + *(void *)(__dst.__r_.__value_.__r.__words[0] - 24));
                                  std::ios_base::init(v159, v286);
                                  v159[1].__vftable = 0;
                                  v159[1].__fmtflags_ = -1;
                                  __dst.__r_.__value_.__r.__words[2] = (std::string::size_type)v264;
                                  *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[2]
                                                            + *((void *)v264 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = (std::string::size_type)v263;
                                  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v261;
                                  *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words
                                                            + *((void *)v261 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = (std::string::size_type)v262;
                                  v291[0] = v157;
                                  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)__sb;
                                  __dst.__r_.__value_.__r.__words[2] = v158;
                                  uint64_t v160 = std::streambuf::basic_streambuf();
                                  long long v287 = v275;
                                  unint64_t v288 = v276;
                                  __sa = (char *)(MEMORY[0x1E4FBA470] + 16);
                                  v286[0] = MEMORY[0x1E4FBA470] + 16;
                                  uint64_t v289 = 0;
                                  int v290 = 24;
                                  std::stringbuf::__init_buf_ptrs[abi:nn180100](v160);
                                  while (!*(_DWORD *)((char *)&__p[4] + *((void *)__p[0] - 3))
                                       && !*(_DWORD *)((char *)&v286[1]
                                                     + *(void *)(__dst.__r_.__value_.__r.__words[0] - 24)))
                                  {
                                    LODWORD(v275) = 0;
                                    LODWORD(v273) = 0;
                                    MEMORY[0x1A6238CB0](__p, &v275);
                                    MEMORY[0x1A6238CB0](&__dst, &v273);
                                    unsigned __int8 v161 = v275;
                                    __int16 v162 = v273;
                                    unsigned int v163 = (char *)*((void *)&v301 + 1);
                                    if (*((void *)&v301 + 1) < v302[0])
                                    {
                                      **((_WORD **)&v301 + 1) = v275 | (unsigned __int16)((_WORD)v273 << 8);
                                      *((void *)&v301 + 1) = v163 + 2;
                                    }
                                    else
                                    {
                                      uint64_t v164 = (char *)v301;
                                      uint64_t v165 = *((void *)&v301 + 1) - v301;
                                      if ((uint64_t)(*((void *)&v301 + 1) - v301) <= -3) {
                                        goto LABEL_485;
                                      }
                                      uint64_t v166 = v165 >> 1;
                                      if (v302[0] - (void)v301 <= (unint64_t)((v165 >> 1) + 1)) {
                                        uint64_t v167 = v166 + 1;
                                      }
                                      else {
                                        uint64_t v167 = v302[0] - v301;
                                      }
                                      if (v302[0] - (void)v301 >= 0x7FFFFFFFFFFFFFFEuLL) {
                                        uint64_t v168 = 0x7FFFFFFFFFFFFFFFLL;
                                      }
                                      else {
                                        uint64_t v168 = v167;
                                      }
                                      if (v168)
                                      {
                                        if (v168 < 0) {
LABEL_486:
                                        }
                                          std::__throw_bad_array_new_length[abi:nn180100]();
                                        long long v169 = (char *)operator new(2 * v168);
                                      }
                                      else
                                      {
                                        long long v169 = 0;
                                      }
                                      unsigned __int8 v170 = &v169[2 * v166];
                                      *(_WORD *)unsigned __int8 v170 = v161 | (unsigned __int16)(v162 << 8);
                                      uint64_t v171 = v170 + 2;
                                      if (v163 == v164)
                                      {
                                        uint64_t v164 = v163;
                                      }
                                      else
                                      {
                                        unint64_t v172 = v163 - 2 - v164;
                                        if (v172 < 0x1E) {
                                          goto LABEL_490;
                                        }
                                        if (v163 - v169 - (v165 & 0xFFFFFFFFFFFFFFFELL) < 0x20) {
                                          goto LABEL_490;
                                        }
                                        uint64_t v173 = (v172 >> 1) + 1;
                                        long long v174 = &v169[2 * v166 - 16];
                                        uint64_t v175 = v163 - 16;
                                        unint64_t v176 = v173 & 0xFFFFFFFFFFFFFFF0;
                                        do
                                        {
                                          long long v177 = *(_OWORD *)v175;
                                          *((_OWORD *)v174 - 1) = *((_OWORD *)v175 - 1);
                                          *(_OWORD *)long long v174 = v177;
                                          v174 -= 32;
                                          v175 -= 32;
                                          v176 -= 16;
                                        }
                                        while (v176);
                                        v170 -= 2 * (v173 & 0xFFFFFFFFFFFFFFF0);
                                        v163 -= 2 * (v173 & 0xFFFFFFFFFFFFFFF0);
                                        if (v173 != (v173 & 0xFFFFFFFFFFFFFFF0))
                                        {
LABEL_490:
                                          do
                                          {
                                            __int16 v178 = *((_WORD *)v163 - 1);
                                            v163 -= 2;
                                            *((_WORD *)v170 - 1) = v178;
                                            v170 -= 2;
                                          }
                                          while (v163 != v164);
                                          uint64_t v164 = (char *)v301;
                                        }
                                      }
                                      *(void *)&long long v301 = v170;
                                      *((void *)&v301 + 1) = v171;
                                      v302[0] = &v169[2 * v168];
                                      if (v164) {
                                        operator delete(v164);
                                      }
                                      *((void *)&v301 + 1) = v171;
                                    }
                                  }
                                  uint64_t v245 = MEMORY[0x1E4FBA488] + 24;
                                  uint64_t v244 = MEMORY[0x1E4FBA488] + 104;
                                  v284[0] = MEMORY[0x1E4FBA488] + 104;
                                  uint64_t v179 = MEMORY[0x1E4FBA488] + 64;
                                  unint64_t v276 = MEMORY[0x1E4FBA488] + 64;
                                  *(void *)&long long v275 = v266;
                                  *(void *)((char *)&v275 + *((void *)v266 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v265;
                                  *((void *)&v275 + 1) = 0;
                                  long long v180 = (std::ios_base *)((char *)&v275 + *(void *)(v275 - 24));
                                  std::ios_base::init(v180, &v277);
                                  v180[1].__vftable = 0;
                                  v180[1].__fmtflags_ = -1;
                                  unint64_t v276 = (unint64_t)v264;
                                  *(unint64_t *)((char *)&v276 + *((void *)v264 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = (unint64_t)v263;
                                  *(void *)&long long v275 = v261;
                                  *(void *)((char *)&v275 + *((void *)v261 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v262;
                                  v284[0] = v244;
                                  *(void *)&long long v275 = v245;
                                  unint64_t v276 = v179;
                                  std::streambuf::basic_streambuf();
                                  uint64_t v181 = MEMORY[0x1E4FBA470] + 16;
                                  uint64_t v277 = MEMORY[0x1E4FBA470] + 16;
                                  long long v281 = 0u;
                                  long long v282 = 0u;
                                  int v283 = 24;
                                  long long v182 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v276, (uint64_t)"http://some.server.com/tile?style=52&x=0&y=0&z=0&h=0", 52);
                                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v182, (uint64_t)"&v=", 3);
                                  long long v183 = (void *)std::ostream::operator<<();
                                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v183, (uint64_t)"&region=", 8);
                                  std::ostream::operator<<();
                                  if ((v283 & 0x10) != 0)
                                  {
                                    unint64_t v186 = *((void *)&v282 + 1);
                                    char v187 = (const void **)&v279;
                                    if (*((void *)&v282 + 1) < v280)
                                    {
                                      *((void *)&v282 + 1) = v280;
                                      unint64_t v186 = v280;
                                      char v187 = (const void **)&v279;
                                    }
                                  }
                                  else
                                  {
                                    if ((v283 & 8) == 0)
                                    {
                                      size_t v184 = 0;
                                      HIBYTE(v274) = 0;
                                      long long v185 = &v273;
                                      goto LABEL_406;
                                    }
                                    unint64_t v186 = v278[2];
                                    char v187 = (const void **)v278;
                                  }
                                  char v188 = *v187;
                                  size_t v184 = v186 - (void)*v187;
                                  if (v184 > 0x7FFFFFFFFFFFFFF7) {
                                    goto LABEL_485;
                                  }
                                  if (v184 >= 0x17)
                                  {
                                    uint64_t v189 = (v184 & 0xFFFFFFFFFFFFFFF8) + 8;
                                    if ((v184 | 7) != 0x17) {
                                      uint64_t v189 = v184 | 7;
                                    }
                                    uint64_t v190 = v189 + 1;
                                    long long v185 = (long long *)operator new(v189 + 1);
                                    unint64_t v274 = v190 | 0x8000000000000000;
                                    *(void *)&long long v273 = v185;
                                    *((void *)&v273 + 1) = v184;
                                  }
                                  else
                                  {
                                    HIBYTE(v274) = v186 - *(unsigned char *)v187;
                                    long long v185 = &v273;
                                    if (!v184)
                                    {
LABEL_406:
                                      *((unsigned char *)v185 + v184) = 0;
                                      if (SHIBYTE(v302[3]) < 0) {
                                        operator delete((void *)v302[1]);
                                      }
                                      *(_OWORD *)&v302[1] = v273;
                                      v302[3] = v274;
                                      *(void *)&long long v275 = v260;
                                      *(void *)((char *)&v275 + *((void *)v260 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v259;
                                      unint64_t v276 = (unint64_t)v258;
                                      uint64_t v277 = v181;
                                      if (SBYTE7(v282) < 0) {
                                        operator delete((void *)v281);
                                      }
                                      std::streambuf::~streambuf();
                                      std::iostream::~basic_iostream();
                                      MEMORY[0x1A62391A0](v284);
                                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v260;
                                      *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words
                                                                + *((void *)v260 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = (std::string::size_type)v259;
                                      __dst.__r_.__value_.__r.__words[2] = (std::string::size_type)v258;
                                      v286[0] = __sa;
                                      if (SHIBYTE(v288) < 0) {
                                        operator delete((void *)v287);
                                      }
                                      std::streambuf::~streambuf();
                                      std::iostream::~basic_iostream();
                                      MEMORY[0x1A62391A0](v291);
                                      __p[0] = v260;
                                      *(void **)((char *)__p + *((void *)v260 - std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)this + 16, *((void **)this + 3)) = v259;
                                      __p[2] = v258;
                                      __p[3] = v247;
                                      if (SBYTE7(v333) < 0) {
                                        operator delete((void *)v332);
                                      }
                                      std::streambuf::~streambuf();
                                      std::iostream::~basic_iostream();
                                      MEMORY[0x1A62391A0](v335);
                                      goto LABEL_415;
                                    }
                                  }
                                  memmove(v185, v188, v184);
                                  goto LABEL_406;
                                }
                              }
                              memmove(v145, v82, v144);
                              goto LABEL_356;
                            }
LABEL_415:
                            XmlNode::Attribute(v325, (const xmlChar *)"system");
                            operator new();
                          }
                          size_t v114 = (std::string *)v303[0].__r_.__value_.__r.__words[0];
                          if (*(unsigned char *)(v303[0].__r_.__value_.__r.__words[0] + v113) == 47) {
                            goto LABEL_320;
                          }
                          if (v303[0].__r_.__value_.__l.__size_ == (v303[0].__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL)
                                                                  - 1)
                          {
                            if ((v303[0].__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) == 0x7FFFFFFFFFFFFFF8) {
                              goto LABEL_485;
                            }
                            if (v303[0].__r_.__value_.__l.__size_ >= 0x3FFFFFFFFFFFFFF3)
                            {
                              unint64_t v120 = v82;
                              size_t v125 = (std::string *)operator new(0x7FFFFFFFFFFFFFF7uLL);
                              memmove(v125, v114, v111);
                              size_t v121 = 0x7FFFFFFFFFFFFFF7;
                            }
                            else
                            {
LABEL_303:
                              if (v111 + 1 > 2 * v111) {
                                unint64_t v119 = v111 + 1;
                              }
                              else {
                                unint64_t v119 = 2 * v111;
                              }
                              unint64_t v120 = v82;
                              if (v119 >= 0x17)
                              {
                                uint64_t v122 = (v119 & 0x7FFFFFFFFFFFFFF8) + 8;
                                uint64_t v123 = v119 | 7;
                                if (v123 == 23) {
                                  uint64_t v123 = v122;
                                }
                                size_t v121 = v123 + 1;
                              }
                              else
                              {
                                size_t v121 = 23;
                              }
                              uint64_t v124 = (std::string *)operator new(v121);
                              size_t v125 = v124;
                              if (v111)
                              {
                                memmove(v124, v114, v111);
                                if (v111 == 22)
                                {
LABEL_317:
                                  v303[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v125;
                                  v303[0].__r_.__value_.__r.__words[2] = v121 | 0x8000000000000000;
                                  size_t v114 = v125;
                                  float v82 = v120;
                                  goto LABEL_318;
                                }
                              }
                            }
                            operator delete(v114);
                            goto LABEL_317;
                          }
LABEL_318:
                          v303[0].__r_.__value_.__l.__size_ = v111 + 1;
                          goto LABEL_319;
                        }
                        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                        }
                        uint64_t v84 = GEOGetVectorKitVKDefaultLog_log;
                        if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
                        {
                          LOWORD(__p[0]) = 0;
                          uint8x8_t v41 = v84;
                          unint64_t v42 = "Missing version in trigger specification";
                          goto LABEL_276;
                        }
                      }
                      else
                      {
                        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                        }
                        uint64_t v83 = GEOGetVectorKitVKDefaultLog_log;
                        if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
                        {
                          LOWORD(__p[0]) = 0;
                          uint8x8_t v41 = v83;
                          unint64_t v42 = "Missing region in trigger specification";
                          goto LABEL_276;
                        }
                      }
                    }
                    else
                    {
                      if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                        dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                      }
                      uint64_t v81 = GEOGetVectorKitVKDefaultLog_log;
                      if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
                      {
                        LOWORD(__p[0]) = 0;
                        uint8x8_t v41 = v81;
                        unint64_t v42 = "Missing altitude in trigger specification";
                        goto LABEL_276;
                      }
                    }
                  }
                  else
                  {
                    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                    }
                    uint64_t v79 = GEOGetVectorKitVKDefaultLog_log;
                    if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
                    {
                      LOWORD(__p[0]) = 0;
                      uint8x8_t v41 = v79;
                      unint64_t v42 = "Missing radius in trigger specification";
                      goto LABEL_276;
                    }
                  }
                }
                else
                {
                  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                  }
                  uint64_t v77 = GEOGetVectorKitVKDefaultLog_log;
                  if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
                  {
                    LOWORD(__p[0]) = 0;
                    uint8x8_t v41 = v77;
                    unint64_t v42 = "Missing longitude in trigger specification";
                    goto LABEL_276;
                  }
                }
              }
              else
              {
                if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                  dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                }
                uint64_t v75 = GEOGetVectorKitVKDefaultLog_log;
                if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(__p[0]) = 0;
                  uint8x8_t v41 = v75;
                  unint64_t v42 = "Missing latitude in trigger specification";
                  goto LABEL_276;
                }
              }
              goto LABEL_277;
            }
          }
          memmove(v39, v36, (size_t)v38);
          goto LABEL_131;
        }
        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
        }
        uint64_t v43 = GEOGetVectorKitVKDefaultLog_log;
        if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p[0]) = 0;
          uint8x8_t v41 = v43;
          unint64_t v42 = "Malformed trigger tag in xml: missing data node";
          goto LABEL_276;
        }
      }
LABEL_277:
      if ((SHIBYTE(v313.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_278:
        if (SHIBYTE(v314.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_417;
        }
        goto LABEL_279;
      }
LABEL_416:
      operator delete(v313.__r_.__value_.__l.__data_);
      if (SHIBYTE(v314.__r_.__value_.__r.__words[2]) < 0)
      {
LABEL_417:
        operator delete(v314.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v315.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_280;
        }
        goto LABEL_418;
      }
LABEL_279:
      if ((SHIBYTE(v315.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_280;
      }
LABEL_418:
      operator delete(v315.__r_.__value_.__l.__data_);
LABEL_280:
      if (SHIBYTE(v320.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v320.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v321.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_282:
          if (SHIBYTE(v322.__r_.__value_.__r.__words[2]) < 0) {
            goto LABEL_298;
          }
          goto LABEL_283;
        }
      }
      else if ((SHIBYTE(v321.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_282;
      }
      operator delete(v321.__r_.__value_.__l.__data_);
      if (SHIBYTE(v322.__r_.__value_.__r.__words[2]) < 0) {
LABEL_298:
      }
        operator delete(v322.__r_.__value_.__l.__data_);
LABEL_283:
      XmlNode::~XmlNode((XmlNode *)v323);
      XmlNode::~XmlNode((XmlNode *)v324);
      XmlNode::~XmlNode((XmlNode *)v325);
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&__dst, "trigger");
      float v116 = v326[0];
      if (v326[0])
      {
        while (1)
        {
          float v116 = v116->next;
          if (!v116) {
            break;
          }
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            size_t v117 = &__dst;
          }
          else {
            size_t v117 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          }
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            int v118 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          }
          else {
            int v118 = __dst.__r_.__value_.__r.__words[1];
          }
          if (!xmlStrncmp(v116->name, (const xmlChar *)v117, v118))
          {
            __p[0] = (void *)v116;
            memset(&__p[1], 0, 40);
            goto LABEL_294;
          }
        }
      }
      float v116 = 0;
      memset(__p, 0, 48);
LABEL_294:
      XmlNodeWrapper::operator=((uint64_t *)v326, (uint64_t)v116);
      XmlNode::~XmlNode((XmlNode *)__p);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      uint64_t v21 = v326[0];
    }
    while (v326[0]);
  }
LABEL_419:
  XmlNode::~XmlNode((XmlNode *)v326);
  float v191 = v327;
  if (v327 != v328)
  {
    do
    {
      unsigned int v192 = *((_DWORD *)v191 + 8);
      int v194 = v191[5];
      unsigned int v193 = v191[6];
      int64_t v195 = v193 - v194;
      if (v193 == v194)
      {
        unint64_t v200 = 0;
        uint64_t v218 = 0;
        goto LABEL_455;
      }
      unsigned int v270 = *((_DWORD *)v191 + 8);
      if (v195 < 0) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      int v196 = (char *)operator new(v193 - v194);
      memcpy(v196, v194, v195);
      if ((unint64_t)v195 >= 0x7FFFFFFFFFFFFFFDLL) {
        goto LABEL_485;
      }
      uint64_t v197 = v195 >> 2;
      int v198 = (unsigned int *)&v196[4 * (v195 >> 2)];
      int64_t v195 = (int64_t)operator new(2 * v195);
      float v199 = (uint64_t *)(v195 + 8 * v197);
      unint64_t v200 = (uint64_t *)v195;
      int v269 = v196;
      unsigned __int8 v201 = (unsigned int *)v196;
      do
      {
        uint64_t v202 = *v6 + 240 * *v201;
        if (v200 < v199)
        {
          *v200++ = v202;
          goto LABEL_427;
        }
        BOOL v203 = (char *)v200 - v195;
        uint64_t v204 = ((uint64_t)v200 - v195) >> 3;
        unint64_t v205 = v204 + 1;
        if ((unint64_t)(v204 + 1) >> 61) {
          goto LABEL_485;
        }
        if (((uint64_t)v199 - v195) >> 2 > v205) {
          unint64_t v205 = ((uint64_t)v199 - v195) >> 2;
        }
        if ((unint64_t)v199 - v195 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v206 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v206 = v205;
        }
        if (v206)
        {
          if (v206 >> 61) {
            goto LABEL_486;
          }
          size_t v207 = (char *)operator new(8 * v206);
        }
        else
        {
          size_t v207 = 0;
        }
        unint64_t v208 = (uint64_t *)&v207[8 * v204];
        float v199 = (uint64_t *)&v207[8 * v206];
        *unint64_t v208 = v202;
        float v209 = v208 + 1;
        if (v200 == (uint64_t *)v195)
        {
LABEL_444:
          operator delete((void *)v195);
          goto LABEL_445;
        }
        unint64_t v210 = (unint64_t)v200 - v195 - 8;
        if (v210 < 0x168
          || &v203[(void)v207 - 8 - (v210 & 0xFFFFFFFFFFFFFFF8)] > &v203[(void)v207 - 8]
          || (uint64_t *)((char *)v200 - (v210 & 0xFFFFFFFFFFFFFFF8) - 8) > v200 - 1
          || (unint64_t)(v195 - (void)v207) < 0x20)
        {
          float v211 = v200;
          do
          {
LABEL_442:
            uint64_t v212 = *--v211;
            *--unint64_t v208 = v212;
          }
          while (v211 != (uint64_t *)v195);
          goto LABEL_443;
        }
        uint64_t v213 = (v210 >> 3) + 1;
        float v211 = &v200[-(v213 & 0x3FFFFFFFFFFFFFFCLL)];
        float v214 = &v203[(void)v207 - 16];
        float v215 = v200 - 2;
        uint64_t v216 = v213 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v217 = *(_OWORD *)v215;
          *((_OWORD *)v214 - 1) = *((_OWORD *)v215 - 1);
          *(_OWORD *)float v214 = v217;
          v214 -= 32;
          v215 -= 4;
          v216 -= 4;
        }
        while (v216);
        v208 -= v213 & 0x3FFFFFFFFFFFFFFCLL;
        if (v213 != (v213 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_442;
        }
LABEL_443:
        if (v195) {
          goto LABEL_444;
        }
LABEL_445:
        int64_t v195 = (int64_t)v208;
        unint64_t v200 = v209;
        unint64_t v6 = v272;
LABEL_427:
        ++v201;
      }
      while (v201 != v198);
      uint64_t v218 = v269;
      unsigned int v192 = v270;
LABEL_455:
      float v219 = (uint64_t **)(a1 + 96);
      while (1)
      {
        unsigned int v220 = *v219;
        int v221 = v219;
        if (!*v219) {
          break;
        }
        while (1)
        {
          float v219 = (uint64_t **)v220;
          unsigned int v222 = *((_DWORD *)v220 + 8);
          if (v192 < v222) {
            break;
          }
          if (v222 >= v192) {
            goto LABEL_464;
          }
          unsigned int v220 = v219[1];
          if (!v220)
          {
            int v221 = v219 + 1;
            goto LABEL_461;
          }
        }
      }
LABEL_461:
      uint64_t v223 = (uint64_t *)v219;
      unsigned int v224 = v192;
      float v219 = (uint64_t **)operator new(0x30uLL);
      *((_DWORD *)v219 + 8) = v224;
      v219[5] = 0;
      *float v219 = 0;
      v219[1] = 0;
      v219[2] = v223;
      *int v221 = (uint64_t *)v219;
      float v225 = (void *)**v267;
      unsigned int v226 = (uint64_t *)v219;
      if (v225)
      {
        *unint64_t v267 = v225;
        unsigned int v226 = *v221;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 96), v226);
      ++*(void *)(a1 + 104);
LABEL_464:
      if ((uint64_t *)v195 != v200)
      {
        uint64_t v227 = (uint64_t)v219[5];
        int64_t v228 = (int64_t)v200 - v195;
        if ((uint64_t *)((char *)v200 - v195) == (uint64_t *)8)
        {
          uint64_t v229 = *(void *)v195;
          *(void *)(v227 + 48) = *(void *)v195;
          *(void *)(v229 + 8) = v227;
          *(void *)(v229 + 16) = 0;
          goto LABEL_471;
        }
        karo::Pool<karo::StaticSphereTreeElement>::construct<>((uint64_t **)(v227 + 8));
        *(void *)(v227 + 48) = v230;
        memset(__p, 0, 24);
        if ((v228 & 0x8000000000000000) == 0)
        {
          uint64_t v231 = v230;
          uint64_t v232 = (char *)operator new(v228);
          uint64_t v233 = &v232[v228];
          __p[0] = v232;
          __p[2] = &v232[v228];
          memcpy(v232, (const void *)v195, v228);
          __p[1] = v233;
          karo::StaticSphereTreeElement::build(v231, __p, 0, v228 >> 3, v227, 0);
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
          goto LABEL_470;
        }
LABEL_485:
        abort();
      }
LABEL_470:
      if (v195) {
LABEL_471:
      }
        operator delete((void *)v195);
      if (v218) {
        operator delete(v218);
      }
      uint64_t v234 = v191[1];
      if (v234)
      {
        do
        {
          uint64_t v235 = (void **)v234;
          uint64_t v234 = (void *)*v234;
        }
        while (v234);
      }
      else
      {
        do
        {
          uint64_t v235 = (void **)v191[2];
          BOOL v11 = *v235 == v191;
          float v191 = v235;
        }
        while (!v11);
      }
      float v191 = v235;
    }
    while (v235 != v328);
  }
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 112));
  uint64_t v236 = *(void *)(a1 + 96);
  long long v237 = *(_OWORD *)(a1 + 64);
  *(void *)(a1 + 72) = v236;
  long long v238 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a1 + 40) = v238;
  uint64_t v239 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = v239;
  uint64_t v240 = *(void *)(a1 + 80);
  *(void *)(a1 + 64) = *(void *)(a1 + 88);
  *(_OWORD *)(a1 + 88) = v237;
  uint64_t v241 = *(void *)(a1 + 104);
  *(void *)(a1 + 80) = v241;
  *(void *)(a1 + 104) = v240;
  uint64_t v242 = (void *)(v236 + 16);
  if (!v241) {
    uint64_t v242 = (void *)(a1 + 64);
  }
  *uint64_t v242 = a1 + 72;
  uint64_t v243 = (void *)(*(void *)(a1 + 96) + 16);
  if (!v240) {
    uint64_t v243 = (void *)(a1 + 88);
  }
  *uint64_t v243 = v271;
  ++*(_DWORD *)(a1 + 120);
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 112));
  std::__tree<std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>,std::__map_value_compare<md::FrameGraphPass *,std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>,md::FrameGraphPassLessThan,true>,std::allocator<std::__value_type<md::FrameGraphPass *,geo::linear_set<md::FrameGraphPass *,md::FrameGraphPassLessThan,std::allocator<md::FrameGraphPass *>,std::vector<md::FrameGraphPass *>>>>>::destroy(v328[0]);
}

uint64_t karo::BoundsTreeElement<karo::StaticSphereTreeElement,karo::BoundsTreeCommon<karo::StaticSphereTreeElement>,gm::Sphere<double,3,std::enable_if<true,void>>>::clear(uint64_t a1)
{
  unsigned int v3 = (void *)(a1 + 24);
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    karo::BoundsTreeElement<karo::StaticSphereTreeElement,karo::BoundsTreeCommon<karo::StaticSphereTreeElement>,gm::Sphere<double,3,std::enable_if<true,void>>>::clear();
    if (*(void *)(a1 + 32)) {
      karo::BoundsTreeElement<karo::StaticSphereTreeElement,karo::BoundsTreeCommon<karo::StaticSphereTreeElement>,gm::Sphere<double,3,std::enable_if<true,void>>>::clear();
    }
    *unsigned int v3 = 0;
    v3[1] = 0;
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t result = (**(uint64_t (***)(uint64_t))a1)(a1);
    *(void *)a1 = *(void *)(v4 + 40);
    *(void *)(v4 + 40) = a1;
  }
  return result;
}

altitude::TriggerManager::Trigger *altitude::TriggerManager::Trigger::Trigger(altitude::TriggerManager::Trigger *this, const altitude::TriggerManager::Trigger *a2)
{
  *(void *)this = &unk_1EF567770;
  long long v4 = *(_OWORD *)((char *)a2 + 8);
  long long v5 = *(_OWORD *)((char *)a2 + 24);
  long long v6 = *(_OWORD *)((char *)a2 + 40);
  *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 56);
  *(_OWORD *)((char *)this + 40) = v6;
  *(_OWORD *)((char *)this + 24) = v5;
  *(_OWORD *)((char *)this + 8) = v4;
  *(void *)this = &unk_1EF568F68;
  *((void *)this + 9) = 0;
  long long v7 = *((_OWORD *)a2 + 5);
  *((_DWORD *)this + 24) = *((_DWORD *)a2 + 24);
  *((_OWORD *)this + 5) = v7;
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 13) = 0;
  unint64_t v9 = (unsigned char *)*((void *)a2 + 13);
  uint64_t v8 = (unsigned char *)*((void *)a2 + 14);
  int64_t v10 = v8 - v9;
  if (v8 != v9)
  {
    if (v10 < 0) {
      abort();
    }
    BOOL v11 = (char *)operator new(v8 - v9);
    *((void *)this + 13) = v11;
    *((void *)this + 14) = v11;
    uint64_t v12 = &v11[2 * (v10 >> 1)];
    *((void *)this + 15) = v12;
    memcpy(v11, v9, v10);
    *((void *)this + 14) = v12;
  }
  int v13 = (std::string *)((char *)this + 128);
  if (*((char *)a2 + 151) < 0)
  {
    std::string::__init_copy_ctor_external(v13, *((const std::string::value_type **)a2 + 16), *((void *)a2 + 17));
  }
  else
  {
    long long v14 = *((_OWORD *)a2 + 8);
    *((void *)this + 18) = *((void *)a2 + 18);
    *(_OWORD *)&v13->__r_.__value_.__l.__data_ = v14;
  }
  int v15 = (std::string *)((char *)this + 152);
  if (*((char *)a2 + 175) < 0)
  {
    std::string::__init_copy_ctor_external(v15, *((const std::string::value_type **)a2 + 19), *((void *)a2 + 20));
  }
  else
  {
    long long v16 = *(_OWORD *)((char *)a2 + 152);
    *((void *)this + 21) = *((void *)a2 + 21);
    *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v16;
  }
  uint64_t v17 = (std::string *)((char *)this + 176);
  if (*((char *)a2 + 199) < 0)
  {
    std::string::__init_copy_ctor_external(v17, *((const std::string::value_type **)a2 + 22), *((void *)a2 + 23));
  }
  else
  {
    long long v18 = *((_OWORD *)a2 + 11);
    *((void *)this + 24) = *((void *)a2 + 24);
    *(_OWORD *)&v17->__r_.__value_.__l.__data_ = v18;
  }
  uint64_t v19 = (std::string *)((char *)this + 200);
  if (*((char *)a2 + 223) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *((const std::string::value_type **)a2 + 25), *((void *)a2 + 26));
  }
  else
  {
    long long v20 = *(_OWORD *)((char *)a2 + 200);
    *((void *)this + 27) = *((void *)a2 + 27);
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = v20;
  }
  uint64_t v21 = *((void *)a2 + 28);
  *((_DWORD *)this + 58) = *((_DWORD *)a2 + 58);
  *((void *)this + 28) = v21;
  *((void *)this + 9) = (*(uint64_t (**)(void))(**((void **)a2 + 9) + 16))(*((void *)a2 + 9));
  return this;
}

altitude::TriggerManager::Trigger *std::vector<altitude::TriggerManager::Trigger>::__push_back_slow_path<altitude::TriggerManager::Trigger const&>(altitude::TriggerManager::Trigger **a1, const altitude::TriggerManager::Trigger *a2)
{
  unint64_t v2 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 4);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x111111111111111) {
    abort();
  }
  if (0xDDDDDDDDDDDDDDDELL * ((a1[2] - *a1) >> 4) > v3) {
    unint64_t v3 = 0xDDDDDDDDDDDDDDDELL * ((a1[2] - *a1) >> 4);
  }
  if (0xEEEEEEEEEEEEEEEFLL * ((a1[2] - *a1) >> 4) >= 0x88888888888888) {
    unint64_t v6 = 0x111111111111111;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x111111111111111) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    long long v7 = (char *)operator new(240 * v6);
  }
  else
  {
    long long v7 = 0;
  }
  uint64_t v8 = (altitude::TriggerManager::Trigger *)&v7[240 * v6];
  unint64_t v9 = altitude::TriggerManager::Trigger::Trigger((altitude::TriggerManager::Trigger *)&v7[240 * v2], a2);
  int64_t v10 = (altitude::TriggerManager::Trigger *)((char *)v9 + 240);
  uint64_t v12 = *a1;
  BOOL v11 = a1[1];
  if (v11 == *a1)
  {
    *a1 = v9;
    a1[1] = v10;
    a1[2] = v8;
    if (!v11) {
      return v10;
    }
    goto LABEL_18;
  }
  do
  {
    BOOL v11 = (const altitude::TriggerManager::Trigger *)((char *)v11 - 240);
    unint64_t v9 = altitude::TriggerManager::Trigger::Trigger((altitude::TriggerManager::Trigger *)((char *)v9 - 240), v11);
  }
  while (v11 != v12);
  BOOL v11 = *a1;
  int v13 = a1[1];
  *a1 = v9;
  a1[1] = v10;
  a1[2] = v8;
  if (v13 != v11)
  {
    long long v14 = (char *)v13 - 240;
    int v15 = (const altitude::TriggerManager::Trigger *)((char *)v13 - 240);
    long long v16 = (const altitude::TriggerManager::Trigger *)((char *)v13 - 240);
    do
    {
      uint64_t v17 = *(void (***)(const altitude::TriggerManager::Trigger *))v16;
      long long v16 = (const altitude::TriggerManager::Trigger *)((char *)v16 - 240);
      (*v17)(v15);
      v14 -= 240;
      BOOL v18 = v15 == v11;
      int v15 = v16;
    }
    while (!v18);
  }
  if (v11) {
LABEL_18:
  }
    operator delete(v11);
  return v10;
}

double karo::Pool<karo::StaticSphereTreeElement>::construct<>(uint64_t **a1)
{
  unint64_t v2 = a1[4];
  if (v2)
  {
    unint64_t v3 = (uint64_t *)*v2;
  }
  else
  {
    long long v4 = (char *)malloc_type_malloc(*((unsigned int *)a1 + 7), 0xF0B72BE0uLL);
    long long v5 = v4;
    long long v7 = a1 + 1;
    unint64_t v6 = a1[1];
    if (v6)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v8 = (uint64_t **)v6;
          unint64_t v9 = v6[4];
          if ((unint64_t)v4 >= v9) {
            break;
          }
          unint64_t v6 = *v8;
          long long v7 = v8;
          if (!*v8) {
            goto LABEL_10;
          }
        }
        if (v9 >= (unint64_t)v4) {
          break;
        }
        unint64_t v6 = v8[1];
        if (!v6)
        {
          long long v7 = v8 + 1;
          goto LABEL_10;
        }
      }
    }
    else
    {
      uint64_t v8 = a1 + 1;
LABEL_10:
      int64_t v10 = (uint64_t *)operator new(0x28uLL);
      v10[4] = (uint64_t)v5;
      *int64_t v10 = 0;
      v10[1] = 0;
      v10[2] = (uint64_t)v8;
      *long long v7 = v10;
      BOOL v11 = (uint64_t *)**a1;
      if (v11)
      {
        *a1 = v11;
        uint64_t v12 = *v7;
      }
      else
      {
        uint64_t v12 = v10;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v12);
      a1[2] = (uint64_t *)((char *)a1[2] + 1);
    }
    int v13 = &v5[72 * *((_DWORD *)a1 + 6) - 72];
    long long v14 = (char *)a1[4];
    do
    {
      unint64_t v3 = (uint64_t *)v14;
      long long v14 = v13;
      *(void *)int v13 = v3;
      v13 -= 72;
    }
    while (v13 >= v5);
    unint64_t v2 = (uint64_t *)(v13 + 72);
  }
  a1[4] = v3;
  double result = 0.0;
  *(_OWORD *)(v2 + 3) = 0u;
  *(_OWORD *)(v2 + 1) = 0u;
  uint64_t *v2 = (uint64_t)&unk_1EF567818;
  *(_OWORD *)(v2 + 5) = 0u;
  *(_OWORD *)(v2 + 7) = 0u;
  return result;
}

void karo::BoundsTreeElement<karo::StaticSphereTreeElement,karo::BoundsTreeCommon<karo::StaticSphereTreeElement>,gm::Sphere<double,3,std::enable_if<true,void>>>::~BoundsTreeElement()
{
}

void karo::BoundsTreeCommon<karo::StaticSphereTreeElement>::~BoundsTreeCommon(uint64_t a1)
{
  *(void *)a1 = &unk_1EF567750;
  karo::Pool<karo::StaticSphereTreeElement>::disposeElements(a1 + 8);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 16));
  JUMPOUT(0x1A6239270);
}

void karo::Pool<karo::StaticSphereTreeElement>::disposeElements(uint64_t a1)
{
  int v30 = 0;
  uint64_t v31 = 0;
  uint64_t v29 = &v30;
  unint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      long long v5 = v30;
      unint64_t v6 = &v30;
      long long v7 = &v30;
      if (v30)
      {
        while (1)
        {
          while (1)
          {
            long long v7 = (uint64_t **)v5;
            unint64_t v8 = v5[4];
            if ((unint64_t)v2 >= v8) {
              break;
            }
            long long v5 = *v7;
            unint64_t v6 = v7;
            if (!*v7) {
              goto LABEL_13;
            }
          }
          if (v8 >= (unint64_t)v2) {
            break;
          }
          long long v5 = v7[1];
          if (!v5)
          {
            unint64_t v6 = v7 + 1;
            goto LABEL_13;
          }
        }
      }
      else
      {
LABEL_13:
        unint64_t v9 = (uint64_t *)operator new(0x28uLL);
        v9[4] = (uint64_t)v2;
        *unint64_t v9 = 0;
        v9[1] = 0;
        void v9[2] = (uint64_t)v7;
        *unint64_t v6 = v9;
        if (*v29)
        {
          uint64_t v29 = (uint64_t **)*v29;
          long long v4 = *v6;
        }
        else
        {
          long long v4 = v9;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v30, v4);
        uint64_t v3 = ++v31;
        unint64_t v2 = *(void **)(a1 + 32);
      }
      unint64_t v2 = (void *)*v2;
      *(void *)(a1 + 32) = v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  unint64_t v10 = *(unsigned int *)(a1 + 24);
  BOOL v11 = *(void **)a1;
  uint64_t v12 = (void *)(a1 + 8);
  BOOL v13 = v3 == *(void *)(a1 + 16) * v10 || v11 == v12;
  if (v13 || v10 == 0)
  {
    if (v11 == v12) {
      goto LABEL_48;
    }
    goto LABEL_50;
  }
  uint64_t v15 = 1;
  do
  {
    if (v15)
    {
      unint64_t v16 = 0;
      uint64_t v17 = v11[4];
      do
      {
        BOOL v18 = (void (***)(void))(v17 + (72 * v16));
        uint64_t v19 = v30;
        if (!v30) {
          goto LABEL_29;
        }
        long long v20 = &v30;
        do
        {
          uint64_t v21 = v19;
          long long v22 = v20;
          unint64_t v23 = v19[4];
          int v24 = (uint64_t **)(v19 + 1);
          if (v23 >= (unint64_t)v18)
          {
            int v24 = (uint64_t **)v21;
            long long v20 = (uint64_t **)v21;
          }
          uint64_t v19 = *v24;
        }
        while (v19);
        if (v20 == &v30) {
          goto LABEL_29;
        }
        if (v23 < (unint64_t)v18) {
          uint64_t v21 = (uint64_t *)v22;
        }
        if ((unint64_t)v18 < v21[4])
        {
LABEL_29:
          (**v18)(v18);
          unint64_t v10 = *(unsigned int *)(a1 + 24);
        }
        ++v16;
        uint64_t v15 = v10;
      }
      while (v16 < v10);
    }
    uint64_t v25 = (void *)v11[1];
    if (v25)
    {
      do
      {
        uint64_t v26 = v25;
        uint64_t v25 = (void *)*v25;
      }
      while (v25);
    }
    else
    {
      do
      {
        uint64_t v26 = (void *)v11[2];
        BOOL v13 = *v26 == (void)v11;
        BOOL v11 = v26;
      }
      while (!v13);
    }
    BOOL v11 = v26;
  }
  while (v26 != v12);
  BOOL v11 = *(void **)a1;
  if (*(void **)a1 != v12)
  {
    do
    {
LABEL_50:
      free((void *)v11[4]);
      int v27 = (void *)v11[1];
      if (v27)
      {
        do
        {
          int v28 = v27;
          int v27 = (void *)*v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          int v28 = (void *)v11[2];
          BOOL v13 = *v28 == (void)v11;
          BOOL v11 = v28;
        }
        while (!v13);
      }
      BOOL v11 = v28;
    }
    while (v28 != v12);
  }
LABEL_48:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v12;
  *(void *)(a1 + 32) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v30);
}

uint64_t karo::BoundsTreeCommon<karo::StaticSphereTreeElement>::~BoundsTreeCommon(uint64_t a1)
{
  *(void *)a1 = &unk_1EF567750;
  karo::Pool<karo::StaticSphereTreeElement>::disposeElements(a1 + 8);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 16));
  return a1;
}

void altitude::TriggerManager::Trigger::C3MeshData::clone(altitude::TriggerManager::Trigger::C3MeshData *this)
{
}

void altitude::TriggerManager::Trigger::C3MeshData::~C3MeshData(void **this)
{
  *this = &unk_1EF568F40;
  if (*((char *)this + 71) < 0)
  {
    operator delete(this[6]);
    if ((*((char *)this + 47) & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((*((char *)this + 47) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[3]);
LABEL_3:
  JUMPOUT(0x1A6239270);
}

{
  *this = &unk_1EF568F40;
  if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    if ((*((char *)this + 47) & 0x80000000) == 0) {
      return;
    }
LABEL_5:
    operator delete(this[3]);
    return;
  }
  operator delete(this[6]);
  if (*((char *)this + 47) < 0) {
    goto LABEL_5;
  }
}

void altitude::TriggerManager::~TriggerManager(altitude::TriggerManager *this)
{
  altitude::TriggerManager::~TriggerManager(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  void (***v8)(void);
  void (***v9)(void);
  void *v10;
  void (***v11)(void);
  void (***v12)(void);
  void (***v13)(void);
  void (**v14)(void);
  BOOL v15;
  void (***v16)(void);
  void (***v17)(void);
  void *v18;
  void (***v19)(void);
  void (***v20)(void);
  void (***v21)(void);
  void (**v22)(void);
  void *v23;
  uint64_t v24;
  char *v25;
  char *v26;
  void *v27;
  uint64_t v28;
  char *v29;
  char *v30;
  const void *v31[2];
  char v32;

  *(void *)this = &unk_1EF568F88;
  unint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    int v32 = 8;
    strcpy((char *)v31, "triggers");
    altitude::ManifestManager::unregisterListener(v2, v31, (unint64_t)this);
  }
  uint64_t v3 = (char *)*((void *)this + 11);
  long long v4 = (char *)this + 96;
  if (v3 != (char *)this + 96)
  {
    do
    {
      unint64_t v23 = (void *)*((void *)v3 + 5);
      int v24 = v23[6];
      if (v24) {
        karo::BoundsTreeElement<karo::StaticSphereTreeElement,karo::BoundsTreeCommon<karo::StaticSphereTreeElement>,gm::Sphere<double,3,std::enable_if<true,void>>>::clear(v24);
      }
      v23[6] = 0;
      (*(void (**)(void *))(*v23 + 8))(v23);
      uint64_t v25 = (char *)*((void *)v3 + 1);
      if (v25)
      {
        do
        {
          uint64_t v26 = v25;
          uint64_t v25 = *(char **)v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          uint64_t v26 = (char *)*((void *)v3 + 2);
          uint64_t v15 = *(void *)v26 == (void)v3;
          uint64_t v3 = v26;
        }
        while (!v15);
      }
      uint64_t v3 = v26;
    }
    while (v26 != v4);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 12));
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 11) = v4;
  long long v5 = (char *)*((void *)this + 8);
  unint64_t v6 = (char *)this + 72;
  if (v5 != (char *)this + 72)
  {
    do
    {
      int v27 = (void *)*((void *)v5 + 5);
      int v28 = v27[6];
      if (v28) {
        karo::BoundsTreeElement<karo::StaticSphereTreeElement,karo::BoundsTreeCommon<karo::StaticSphereTreeElement>,gm::Sphere<double,3,std::enable_if<true,void>>>::clear(v28);
      }
      v27[6] = 0;
      (*(void (**)(void *))(*v27 + 8))(v27);
      uint64_t v29 = (char *)*((void *)v5 + 1);
      if (v29)
      {
        do
        {
          int v30 = v29;
          uint64_t v29 = *(char **)v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          int v30 = (char *)*((void *)v5 + 2);
          uint64_t v15 = *(void *)v30 == (void)v5;
          long long v5 = v30;
        }
        while (!v15);
      }
      long long v5 = v30;
    }
    while (v30 != v6);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 9));
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 8) = v6;
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 14));
  long long v7 = *((void *)this + 14);
  if (v7) {
    MEMORY[0x1A6239270](v7, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 14) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 12));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 9));
  unint64_t v8 = (void (***)(void))*((void *)this + 5);
  if (v8)
  {
    unint64_t v9 = (void (***)(void))*((void *)this + 6);
    unint64_t v10 = (void *)*((void *)this + 5);
    if (v9 != v8)
    {
      BOOL v11 = v9 - 30;
      uint64_t v12 = v9 - 30;
      BOOL v13 = v9 - 30;
      do
      {
        long long v14 = *v13;
        v13 -= 30;
        (*v14)(v12);
        v11 -= 30;
        uint64_t v15 = v12 == v8;
        uint64_t v12 = v13;
      }
      while (!v15);
      unint64_t v10 = (void *)*((void *)this + 5);
    }
    *((void *)this + 6) = v8;
    operator delete(v10);
  }
  unint64_t v16 = (void (***)(void))*((void *)this + 2);
  if (v16)
  {
    uint64_t v17 = (void (***)(void))*((void *)this + 3);
    BOOL v18 = (void *)*((void *)this + 2);
    if (v17 != v16)
    {
      uint64_t v19 = v17 - 30;
      long long v20 = v17 - 30;
      uint64_t v21 = v17 - 30;
      do
      {
        long long v22 = *v21;
        v21 -= 30;
        (*v22)(v20);
        v19 -= 30;
        uint64_t v15 = v20 == v16;
        long long v20 = v21;
      }
      while (!v15);
      BOOL v18 = (void *)*((void *)this + 2);
    }
    *((void *)this + 3) = v16;
    operator delete(v18);
  }
}

uint64_t altitude::TriggerManager::Trigger::operator=(uint64_t a1, void *a2)
{
  long long v4 = *(_OWORD *)(a2 + 1);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 3);
  *(_OWORD *)(a1 + 8) = v4;
  *(void *)(a1 + 40) = a2[5];
  *(void *)(a1 + 48) = a2[6];
  *(void *)(a1 + 56) = a2[7];
  *(void *)(a1 + 64) = a2[8];
  uint64_t v5 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = (*(uint64_t (**)(void))(*(void *)a2[9] + 16))(a2[9]);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  long long v6 = *((_OWORD *)a2 + 5);
  *(_DWORD *)(a1 + 96) = *((_DWORD *)a2 + 24);
  *(_OWORD *)(a1 + 80) = v6;
  if ((void *)a1 != a2)
  {
    long long v7 = *(char **)(a1 + 104);
    unint64_t v8 = (char *)a2[13];
    unint64_t v9 = (unsigned char *)a2[14];
    size_t v10 = v9 - v8;
    unint64_t v11 = (v9 - v8) >> 1;
    unint64_t v12 = *(void *)(a1 + 120);
    if (v11 > (uint64_t)(v12 - (void)v7) >> 1)
    {
      if (v7)
      {
        *(void *)(a1 + 112) = v7;
        operator delete(v7);
        unint64_t v12 = 0;
        *(void *)(a1 + 104) = 0;
        *(void *)(a1 + 112) = 0;
        *(void *)(a1 + 120) = 0;
      }
      if ((v10 & 0x8000000000000000) != 0) {
        goto LABEL_69;
      }
      if (v12 <= v11) {
        uint64_t v13 = (v9 - v8) >> 1;
      }
      else {
        uint64_t v13 = v12;
      }
      BOOL v14 = v12 >= 0x7FFFFFFFFFFFFFFELL;
      uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
      if (!v14) {
        uint64_t v15 = v13;
      }
      if (v15 < 0) {
LABEL_69:
      }
        abort();
      uint64_t v16 = 2 * v15;
      uint64_t v17 = (char *)operator new(2 * v15);
      long long v7 = v17;
      *(void *)(a1 + 104) = v17;
      *(void *)(a1 + 112) = v17;
      *(void *)(a1 + 120) = &v17[v16];
      if (v9 != v8) {
        memcpy(v17, v8, v9 - v8);
      }
      goto LABEL_24;
    }
    BOOL v18 = *(unsigned char **)(a1 + 112);
    unint64_t v19 = (v18 - v7) >> 1;
    if (v19 >= v11)
    {
      if (v9 == v8)
      {
LABEL_24:
        *(void *)(a1 + 112) = &v7[v10];
        unint64_t v23 = (void **)(a1 + 128);
        char v24 = *((unsigned char *)a2 + 151);
        if (*(char *)(a1 + 151) < 0)
        {
          if (v24 >= 0) {
            uint64_t v26 = a2 + 16;
          }
          else {
            uint64_t v26 = (void *)a2[16];
          }
          if (v24 >= 0) {
            size_t v27 = *((unsigned __int8 *)a2 + 151);
          }
          else {
            size_t v27 = a2[17];
          }
          std::string::__assign_no_alias<false>(v23, v26, v27);
        }
        else if ((*((unsigned char *)a2 + 151) & 0x80) != 0)
        {
          std::string::__assign_no_alias<true>(v23, (void *)a2[16], a2[17]);
        }
        else
        {
          long long v25 = *((_OWORD *)a2 + 8);
          *(void *)(a1 + 144) = a2[18];
          *(_OWORD *)unint64_t v23 = v25;
        }
        int v28 = (void **)(a1 + 152);
        char v29 = *((unsigned char *)a2 + 175);
        if (*(char *)(a1 + 175) < 0)
        {
          if (v29 >= 0) {
            uint64_t v31 = a2 + 19;
          }
          else {
            uint64_t v31 = (void *)a2[19];
          }
          if (v29 >= 0) {
            size_t v32 = *((unsigned __int8 *)a2 + 175);
          }
          else {
            size_t v32 = a2[20];
          }
          std::string::__assign_no_alias<false>(v28, v31, v32);
        }
        else if ((*((unsigned char *)a2 + 175) & 0x80) != 0)
        {
          std::string::__assign_no_alias<true>(v28, (void *)a2[19], a2[20]);
        }
        else
        {
          long long v30 = *(_OWORD *)(a2 + 19);
          *(void *)(a1 + 168) = a2[21];
          *(_OWORD *)int v28 = v30;
        }
        unint64_t v33 = (void **)(a1 + 176);
        char v34 = *((unsigned char *)a2 + 199);
        if (*(char *)(a1 + 199) < 0)
        {
          if (v34 >= 0) {
            uint64_t v36 = a2 + 22;
          }
          else {
            uint64_t v36 = (void *)a2[22];
          }
          if (v34 >= 0) {
            size_t v37 = *((unsigned __int8 *)a2 + 199);
          }
          else {
            size_t v37 = a2[23];
          }
          std::string::__assign_no_alias<false>(v33, v36, v37);
        }
        else if ((*((unsigned char *)a2 + 199) & 0x80) != 0)
        {
          std::string::__assign_no_alias<true>(v33, (void *)a2[22], a2[23]);
        }
        else
        {
          long long v35 = *((_OWORD *)a2 + 11);
          *(void *)(a1 + 192) = a2[24];
          *(_OWORD *)unint64_t v33 = v35;
        }
        int v38 = (void **)(a1 + 200);
        char v39 = *((unsigned char *)a2 + 223);
        if (*(char *)(a1 + 223) < 0)
        {
          if (v39 >= 0) {
            uint8x8_t v41 = a2 + 25;
          }
          else {
            uint8x8_t v41 = (void *)a2[25];
          }
          if (v39 >= 0) {
            size_t v42 = *((unsigned __int8 *)a2 + 223);
          }
          else {
            size_t v42 = a2[26];
          }
          std::string::__assign_no_alias<false>(v38, v41, v42);
        }
        else if ((*((unsigned char *)a2 + 223) & 0x80) != 0)
        {
          std::string::__assign_no_alias<true>(v38, (void *)a2[25], a2[26]);
        }
        else
        {
          long long v40 = *(_OWORD *)(a2 + 25);
          *(void *)(a1 + 216) = a2[27];
          *(_OWORD *)int v38 = v40;
        }
        goto LABEL_68;
      }
      uint64_t v21 = *(void **)(a1 + 104);
      long long v22 = (char *)a2[13];
    }
    else
    {
      long long v20 = &v8[2 * v19];
      if (v18 != v7)
      {
        memmove(*(void **)(a1 + 104), (const void *)a2[13], v18 - v7);
        long long v7 = *(char **)(a1 + 112);
      }
      size_t v10 = v9 - v20;
      if (v9 == v20) {
        goto LABEL_24;
      }
      uint64_t v21 = v7;
      long long v22 = v20;
    }
    memmove(v21, v22, v10);
    goto LABEL_24;
  }
LABEL_68:
  uint64_t v43 = a2[28];
  *(_DWORD *)(a1 + 232) = *((_DWORD *)a2 + 58);
  *(void *)(a1 + 224) = v43;
  return a1;
}

void altitude::TriggerManager::cullTriggers(uint64_t a1, altitude::TriggerManager::Trigger **a2, _OWORD *a3, unsigned int a4)
{
  long long v22 = 0;
  unint64_t v23 = 0;
  uint64_t v24 = 0;
  long long v7 = a3[1];
  v20[0] = *a3;
  v20[1] = v7;
  uint64_t v21 = (void **)&v22;
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 112));
  unint64_t v8 = *(void **)(a1 + 64);
  if (v8 != (void *)(a1 + 72))
  {
    do
    {
      if (*((_DWORD *)v8 + 8) <= a4)
      {
        uint64_t v11 = *(void *)(v8[5] + 48);
        if (v11) {
          karo::BoundsTreeElement<karo::StaticSphereTreeElement,karo::BoundsTreeCommon<karo::StaticSphereTreeElement>,gm::Sphere<double,3,std::enable_if<true,void>>>::collectLeafs<altitude::SphereCulling<altitude::TriggerManager::Trigger>>(v11, (uint64_t)v20);
        }
      }
      unint64_t v12 = (void *)v8[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          unint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v8[2];
          BOOL v14 = *v13 == (void)v8;
          unint64_t v8 = v13;
        }
        while (!v14);
      }
      unint64_t v8 = v13;
    }
    while (v13 != (void *)(a1 + 72));
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 112));
  unint64_t v9 = v22;
  size_t v10 = v23;
  if (v22 != v23)
  {
    do
    {
      uint64_t v15 = *(const altitude::TriggerManager::Trigger **)v9;
      if (*(void *)(*(void *)v9 + 72))
      {
        uint64_t v16 = *a2;
        if ((unint64_t)*a2 <= 1)
        {
          *a2 = (altitude::TriggerManager::Trigger *)((char *)v16 + 1);
          altitude::TriggerManager::Trigger::operator=((uint64_t)&a2[30 * (void)v16 + 1], v15);
        }
        else
        {
          uint64_t v17 = a2[62];
          if (v16 == (altitude::TriggerManager::Trigger *)2)
          {
            if (v17 >= a2[63]) {
              BOOL v18 = std::vector<altitude::TriggerManager::Trigger>::__push_back_slow_path<altitude::TriggerManager::Trigger const&>(a2 + 61, (const altitude::TriggerManager::Trigger *)(a2 + 1));
            }
            else {
              BOOL v18 = (altitude::TriggerManager::Trigger *)((char *)altitude::TriggerManager::Trigger::Trigger(v17, (const altitude::TriggerManager::Trigger *)(a2 + 1))+ 240);
            }
            a2[62] = v18;
            if (v18 >= a2[63]) {
              uint64_t v17 = std::vector<altitude::TriggerManager::Trigger>::__push_back_slow_path<altitude::TriggerManager::Trigger const&>(a2 + 61, (const altitude::TriggerManager::Trigger *)(a2 + 31));
            }
            else {
              uint64_t v17 = (altitude::TriggerManager::Trigger *)((char *)altitude::TriggerManager::Trigger::Trigger(v18, (const altitude::TriggerManager::Trigger *)(a2 + 31))+ 240);
            }
            a2[62] = v17;
          }
          if (v17 >= a2[63]) {
            unint64_t v19 = std::vector<altitude::TriggerManager::Trigger>::__push_back_slow_path<altitude::TriggerManager::Trigger const&>(a2 + 61, v15);
          }
          else {
            unint64_t v19 = (altitude::TriggerManager::Trigger *)((char *)altitude::TriggerManager::Trigger::Trigger(v17, v15)
          }
                                                      + 240);
          a2[62] = v19;
          *a2 = (altitude::TriggerManager::Trigger *)((char *)*a2 + 1);
        }
      }
      v9 += 8;
    }
    while (v9 != v10);
    unint64_t v9 = v22;
  }
  if (v9)
  {
    unint64_t v23 = v9;
    operator delete(v9);
  }
}

void karo::BoundsTreeElement<karo::StaticSphereTreeElement,karo::BoundsTreeCommon<karo::StaticSphereTreeElement>,gm::Sphere<double,3,std::enable_if<true,void>>>::collectLeafs<altitude::SphereCulling<altitude::TriggerManager::Trigger>>(uint64_t a1, uint64_t a2)
{
  while (1)
  {
    float64x2_t v4 = vsubq_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a2 + 8));
    float64x2_t v5 = vmulq_f64(v4, v4);
    double v6 = sqrt(v5.f64[0] + (*(double *)(a1 + 40) - *(double *)a2) * (*(double *)(a1 + 40) - *(double *)a2) + v5.f64[1]);
    double v7 = *(double *)(a2 + 24);
    double v8 = *(double *)(a1 + 64);
    if (v6 <= v8 + v7)
    {
      if (v6 + v8 <= v7)
      {
        unsigned int v9 = 0;
        if (!*(void *)(a1 + 24))
        {
LABEL_14:
          if (v9 <= 1)
          {
            uint64_t v10 = *(void *)(a2 + 32);
            altitude::SphereCulling<altitude::TriggerManager::Trigger>::collectLeaf(v10, a1);
          }
          return;
        }
      }
      else
      {
        unsigned int v9 = 1;
        if (!*(void *)(a1 + 24)) {
          goto LABEL_14;
        }
      }
    }
    else
    {
      unsigned int v9 = 2;
      if (!*(void *)(a1 + 24)) {
        goto LABEL_14;
      }
    }
    if (v9 != 1) {
      break;
    }
    karo::BoundsTreeElement<karo::StaticSphereTreeElement,karo::BoundsTreeCommon<karo::StaticSphereTreeElement>,gm::Sphere<double,3,std::enable_if<true,void>>>::collectLeafs<altitude::SphereCulling<altitude::TriggerManager::Trigger>>();
    a1 = *(void *)(a1 + 32);
  }
  if (!v9)
  {
    karo::BoundsTreeElement<karo::StaticSphereTreeElement,karo::BoundsTreeCommon<karo::StaticSphereTreeElement>,gm::Sphere<double,3,std::enable_if<true,void>>>::addLeafs<altitude::SphereCulling<altitude::TriggerManager::Trigger>>(a1, a2);
  }
}

void altitude::SphereCulling<altitude::TriggerManager::Trigger>::collectLeaf(uint64_t a1, uint64_t a2)
{
  float64x2_t v5 = *(void **)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  double v6 = v5;
  if ((unint64_t)v5 >= v4)
  {
    double v8 = *(unsigned char **)a1;
    uint64_t v9 = (uint64_t)v5 - *(void *)a1;
    uint64_t v10 = v9 >> 3;
    unint64_t v11 = (v9 >> 3) + 1;
    if (v11 >> 61) {
      abort();
    }
    uint64_t v12 = v4 - (void)v8;
    if (v12 >> 2 > v11) {
      unint64_t v11 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13)
    {
      if (v13 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      BOOL v14 = operator new(8 * v13);
    }
    else
    {
      BOOL v14 = 0;
    }
    uint64_t v15 = &v14[8 * v10];
    uint64_t v16 = &v14[8 * v13];
    void *v15 = a2;
    double v7 = v15 + 1;
    if (v5 == (void *)v8)
    {
      double v8 = v5;
    }
    else
    {
      unint64_t v17 = (char *)v5 - v8 - 8;
      if (v17 < 0x58) {
        goto LABEL_29;
      }
      if ((unint64_t)((char *)v5 - v14 - v9) < 0x20) {
        goto LABEL_29;
      }
      uint64_t v18 = (v17 >> 3) + 1;
      double v6 = &v5[-(v18 & 0x3FFFFFFFFFFFFFFCLL)];
      unint64_t v19 = &v14[8 * v10 - 16];
      long long v20 = (long long *)(v5 - 2);
      uint64_t v21 = v18 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v22 = *v20;
        *(v19 - 1) = *(v20 - 1);
        *unint64_t v19 = v22;
        v19 -= 2;
        v20 -= 2;
        v21 -= 4;
      }
      while (v21);
      v15 -= v18 & 0x3FFFFFFFFFFFFFFCLL;
      if (v18 != (v18 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_29:
        do
        {
          uint64_t v23 = *--v6;
          *--uint64_t v15 = v23;
        }
        while (v6 != (void *)v8);
        double v8 = *(unsigned char **)a1;
      }
    }
    *(void *)a1 = v15;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = v16;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    void *v5 = a2;
    double v7 = v5 + 1;
  }
  *(void *)(a1 + 8) = v7;
}

void karo::BoundsTreeElement<karo::StaticSphereTreeElement,karo::BoundsTreeCommon<karo::StaticSphereTreeElement>,gm::Sphere<double,3,std::enable_if<true,void>>>::addLeafs<altitude::SphereCulling<altitude::TriggerManager::Trigger>>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  for (uint64_t i = *(void *)(a1 + 24); i; uint64_t i = *(void *)(v3 + 24))
  {
    karo::BoundsTreeElement<karo::StaticSphereTreeElement,karo::BoundsTreeCommon<karo::StaticSphereTreeElement>,gm::Sphere<double,3,std::enable_if<true,void>>>::addLeafs<altitude::SphereCulling<altitude::TriggerManager::Trigger>>(i, a2);
    uint64_t v3 = *(void *)(v3 + 32);
  }
  uint64_t v5 = *(void *)(a2 + 32);
  altitude::SphereCulling<altitude::TriggerManager::Trigger>::collectLeaf(v5, v3);
}

void karo::Pool<altitude::Anchor>::disposeElements(uint64_t a1)
{
  long long v40 = 0;
  uint64_t v41 = 0;
  char v39 = &v40;
  unint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v5 = v40;
      double v6 = &v40;
      double v7 = &v40;
      if (v40)
      {
        while (1)
        {
          while (1)
          {
            double v7 = (uint64_t **)v5;
            unint64_t v8 = v5[4];
            if ((unint64_t)v2 >= v8) {
              break;
            }
            uint64_t v5 = *v7;
            double v6 = v7;
            if (!*v7) {
              goto LABEL_13;
            }
          }
          if (v8 >= (unint64_t)v2) {
            break;
          }
          uint64_t v5 = v7[1];
          if (!v5)
          {
            double v6 = v7 + 1;
            goto LABEL_13;
          }
        }
      }
      else
      {
LABEL_13:
        uint64_t v9 = (uint64_t *)operator new(0x28uLL);
        v9[4] = (uint64_t)v2;
        *uint64_t v9 = 0;
        v9[1] = 0;
        void v9[2] = (uint64_t)v7;
        *double v6 = v9;
        if (*v39)
        {
          char v39 = (uint64_t **)*v39;
          unint64_t v4 = *v6;
        }
        else
        {
          unint64_t v4 = v9;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v40, v4);
        uint64_t v3 = ++v41;
        unint64_t v2 = *(void **)(a1 + 32);
      }
      unint64_t v2 = (void *)*v2;
      *(void *)(a1 + 32) = v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  unint64_t v10 = *(unsigned int *)(a1 + 24);
  unint64_t v11 = *(void **)a1;
  uint64_t v12 = (void *)(a1 + 8);
  BOOL v13 = v3 == *(void *)(a1 + 16) * v10 || v11 == v12;
  if (v13 || v10 == 0)
  {
    if (v11 == v12) {
      goto LABEL_65;
    }
    goto LABEL_67;
  }
  uint64_t v15 = 1;
  do
  {
    if (v15)
    {
      unint64_t v16 = 0;
      uint64_t v17 = v11[4];
      do
      {
        unint64_t v18 = v17 + (104 * v16);
        unint64_t v19 = v40;
        if (!v40) {
          goto LABEL_40;
        }
        long long v20 = &v40;
        do
        {
          uint64_t v21 = v19;
          long long v22 = v20;
          unint64_t v23 = v19[4];
          uint64_t v24 = (uint64_t **)(v19 + 1);
          if (v23 >= v18)
          {
            uint64_t v24 = (uint64_t **)v21;
            long long v20 = (uint64_t **)v21;
          }
          unint64_t v19 = *v24;
        }
        while (v19);
        if (v20 == &v40) {
          goto LABEL_40;
        }
        if (v23 < v18) {
          uint64_t v21 = (uint64_t *)v22;
        }
        if (v18 < v21[4])
        {
LABEL_40:
          long long v25 = *(void **)(v18 + 88);
          uint64_t v26 = (uint64_t *)v25[3];
          if (v26)
          {
            size_t v27 = v25 + 3;
            int v28 = (void *)v25[3];
            do
            {
              unint64_t v29 = v28[4];
              BOOL v30 = v29 >= v18;
              if (v29 >= v18) {
                uint64_t v31 = v28;
              }
              else {
                uint64_t v31 = v28 + 1;
              }
              if (v30) {
                size_t v27 = v28;
              }
              int v28 = (void *)*v31;
            }
            while (*v31);
            if (v27 != v25 + 3 && v27[4] <= v18)
            {
              size_t v32 = (uint64_t *)v27[1];
              unint64_t v33 = v27;
              if (v32)
              {
                do
                {
                  char v34 = v32;
                  size_t v32 = (uint64_t *)*v32;
                }
                while (v32);
              }
              else
              {
                do
                {
                  char v34 = (uint64_t *)v33[2];
                  BOOL v13 = *v34 == (void)v33;
                  unint64_t v33 = v34;
                }
                while (!v13);
              }
              if ((uint64_t *)v25[2] == v27) {
                v25[2] = v34;
              }
              --v25[4];
              std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v26, v27);
              operator delete(v27);
              unint64_t v10 = *(unsigned int *)(a1 + 24);
            }
          }
        }
        ++v16;
        uint64_t v15 = v10;
      }
      while (v16 < v10);
    }
    long long v35 = (void *)v11[1];
    if (v35)
    {
      do
      {
        uint64_t v36 = v35;
        long long v35 = (void *)*v35;
      }
      while (v35);
    }
    else
    {
      do
      {
        uint64_t v36 = (void *)v11[2];
        BOOL v13 = *v36 == (void)v11;
        unint64_t v11 = v36;
      }
      while (!v13);
    }
    unint64_t v11 = v36;
  }
  while (v36 != v12);
  unint64_t v11 = *(void **)a1;
  if (*(void **)a1 != v12)
  {
    do
    {
LABEL_67:
      free((void *)v11[4]);
      size_t v37 = (void *)v11[1];
      if (v37)
      {
        do
        {
          int v38 = v37;
          size_t v37 = (void *)*v37;
        }
        while (v37);
      }
      else
      {
        do
        {
          int v38 = (void *)v11[2];
          BOOL v13 = *v38 == (void)v11;
          unint64_t v11 = v38;
        }
        while (!v13);
      }
      unint64_t v11 = v38;
    }
    while (v38 != v12);
  }
LABEL_65:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v12;
  *(void *)(a1 + 32) = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v40);
}

void altitude::AnchorManager::~AnchorManager(altitude::AnchorManager *this)
{
  uint64_t v2 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v2)
  {
    karo::Pool<altitude::Anchor>::disposeElements(v2);
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v2 + 8));
    MEMORY[0x1A6239270](v2, 0x1020C40D4280EFALL);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 3));
}

void std::vector<md::MetaDataRegion>::__base_destruct_at_end[abi:nn180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 48)
  {
    uint64_t v6 = *(void *)(i - 24);
    if (v6)
    {
      uint64_t v7 = *(void *)(i - 16);
      uint64_t v5 = *(void **)(i - 24);
      if (v7 != v6)
      {
        do
        {
          uint64_t v8 = *(void *)(v7 - 24);
          if (v8)
          {
            uint64_t v9 = *(void *)(v7 - 16);
            unint64_t v10 = *(void **)(v7 - 24);
            if (v9 != v8)
            {
              uint64_t v11 = *(void *)(v7 - 16);
              do
              {
                BOOL v13 = *(void **)(v11 - 24);
                v11 -= 24;
                uint64_t v12 = v13;
                if (v13)
                {
                  *(void *)(v9 - 16) = v12;
                  operator delete(v12);
                }
                uint64_t v9 = v11;
              }
              while (v11 != v8);
              unint64_t v10 = *(void **)(v7 - 24);
            }
            *(void *)(v7 - 16) = v8;
            operator delete(v10);
          }
          BOOL v14 = *(void **)(v7 - 48);
          if (v14)
          {
            *(void *)(v7 - 40) = v14;
            operator delete(v14);
          }
          v7 -= 64;
        }
        while (v7 != v6);
        uint64_t v5 = *(void **)(i - 24);
      }
      *(void *)(i - 16) = v6;
      operator delete(v5);
    }
  }
  *(void *)(a1 + 8) = a2;
}

uint64_t std::construct_at[abi:nn180100]<md::MetaDataRegionPolygon,md::MetaDataRegionPolygon,md::MetaDataRegionPolygon*>(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)a1 = v4;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  uint64_t v6 = (unsigned char *)*((void *)a2 + 2);
  uint64_t v5 = (unsigned char *)*((void *)a2 + 3);
  uint64_t v7 = v5 - v6;
  if (v5 != v6)
  {
    if (v7 < 0) {
      abort();
    }
    uint64_t v8 = (char *)operator new(v5 - v6);
    *(void *)(a1 + 16) = v8;
    *(void *)(a1 + 24) = v8;
    *(void *)(a1 + 32) = &v8[8 * (v7 >> 3)];
    size_t v9 = v7 & 0xFFFFFFFFFFFFFFF8;
    memcpy(v8, v6, v9);
    *(void *)(a1 + 24) = &v8[v9];
  }
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  uint64_t v10 = *((void *)a2 + 5);
  uint64_t v11 = *((void *)a2 + 6);
  int64_t v12 = v11 - v10;
  if (v11 != v10)
  {
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * (v12 >> 3);
    if (v13 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    BOOL v14 = (char *)operator new(v12);
    uint64_t v15 = 0;
    *(void *)(a1 + 40) = v14;
    *(void *)(a1 + 48) = v14;
    *(void *)(a1 + 56) = &v14[24 * v13];
    do
    {
      uint64_t v18 = v10 + v15;
      unint64_t v19 = &v14[v15];
      *(void *)unint64_t v19 = 0;
      *((void *)v19 + 1) = 0;
      *((void *)v19 + 2) = 0;
      uint64_t v21 = *(unsigned char **)(v10 + v15);
      long long v20 = *(unsigned char **)(v10 + v15 + 8);
      uint64_t v22 = v20 - v21;
      if (v20 != v21)
      {
        if (v22 < 0) {
          abort();
        }
        unint64_t v16 = (char *)operator new(v20 - v21);
        *(void *)unint64_t v19 = v16;
        *((void *)v19 + 1) = v16;
        *((void *)v19 + 2) = &v16[8 * (v22 >> 3)];
        size_t v17 = v22 & 0xFFFFFFFFFFFFFFF8;
        memcpy(v16, v21, v17);
        *((void *)v19 + 1) = &v16[v17];
      }
      v15 += 24;
    }
    while (v18 + 24 != v11);
    *(void *)(a1 + 48) = &v14[v15];
  }
  return a1;
}

void sub_1A20BDB3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  int64_t v12 = *a10;
  if (*a10)
  {
    *(void *)(v10 + 24) = v12;
    operator delete(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<md::MetaDataRegionPolygon>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 64;
    uint64_t v4 = *(void *)(i - 24);
    if (v4)
    {
      uint64_t v5 = *(void *)(i - 16);
      uint64_t v6 = *(void **)(i - 24);
      if (v5 != v4)
      {
        uint64_t v7 = *(void *)(i - 16);
        do
        {
          size_t v9 = *(void **)(v7 - 24);
          v7 -= 24;
          uint64_t v8 = v9;
          if (v9)
          {
            *(void *)(v5 - 16) = v8;
            operator delete(v8);
          }
          uint64_t v5 = v7;
        }
        while (v7 != v4);
        uint64_t v6 = *(void **)(i - 24);
      }
      *(void *)(i - 16) = v4;
      operator delete(v6);
    }
    uint64_t v10 = *(void **)(i - 48);
    if (v10)
    {
      *(void *)(i - 40) = v10;
      operator delete(v10);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void md::RegionMetaTileData::~RegionMetaTileData(md::RegionMetaTileData *this)
{
  *(void *)this = &unk_1EF53A5D0;
  *((void *)this + 79) = &unk_1EF53A610;
  uint64_t v2 = *((void *)this + 90);
  if (v2)
  {
    std::vector<md::MetaDataRegion>::__base_destruct_at_end[abi:nn180100]((uint64_t)this + 720, v2);
    operator delete(*((void **)this + 90));
  }
  md::MapTileData::~MapTileData(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF53A5D0;
  *((void *)this + 79) = &unk_1EF53A610;
  uint64_t v2 = *((void *)this + 90);
  if (v2)
  {
    std::vector<md::MetaDataRegion>::__base_destruct_at_end[abi:nn180100]((uint64_t)this + 720, v2);
    operator delete(*((void **)this + 90));
  }
  md::MapTileData::~MapTileData(this);
}

void *std::function<BOOL ()(md::MuninRoadEdge const*,md::GraphTraversalPath const*)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<BOOL ()(md::MuninJunction const*,md::GraphTraversalPath const*,unsigned int)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::GlobeStars::StarsPipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::GlobeStars::StarsPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583190;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::GlobeStars::StarsPipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583190;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::GlobeStars::View>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::GlobeStars::View>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::GlobeStars::View>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::GlobeStars::View>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585960;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::GlobeStars::View>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585960;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::GlobeAtmosphere::BasePipelineSetup>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::GlobeAtmosphere::BasePipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584188;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::GlobeAtmosphere::BasePipelineSetup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584188;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::GlobeAtmosphere::AtmosphereConstants>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::GlobeAtmosphere::AtmosphereConstants>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::GlobeAtmosphere::AtmosphereConstants>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::GlobeAtmosphere::AtmosphereConstants>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586300;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::GlobeAtmosphere::AtmosphereConstants>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586300;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__function::__func<md::GlobeSkyRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::GlobeSkyRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF574868;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::GlobeSkyRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::GlobeSkyRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF574868;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::GlobeSkyRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::GlobeSkyRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::GlobeSkyRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::GlobeSkyRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF574820;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::GlobeSkyRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::GlobeSkyRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF574820;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::GlobeSkyRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::GlobeSkyRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::~__func()
{
}

void md::GlobeSkyRenderLayer::~GlobeSkyRenderLayer(md::GlobeSkyRenderLayer *this)
{
  *(void *)this = &unk_1EF53BA60;
  uint64_t v2 = (md::GlobeSkyRenderResources *)*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v2)
  {
    md::GlobeSkyRenderResources::~GlobeSkyRenderResources(v2);
    MEMORY[0x1A6239270]();
  }
  *(void *)this = &unk_1EF530C60;
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  md::GlobeSkyRenderResources *v2;
  void *v3;

  *(void *)this = &unk_1EF53BA60;
  uint64_t v2 = (md::GlobeSkyRenderResources *)*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v2)
  {
    md::GlobeSkyRenderResources::~GlobeSkyRenderResources(v2);
    MEMORY[0x1A6239270]();
  }
  *(void *)this = &unk_1EF530C60;
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
}

void ggl::ConstantDataTyped<ggl::Building::Fade>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::Building::Fade>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Building::Fade>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Building::Fade>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587678;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Building::Fade>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587678;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::RouteLineArrow::BasePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::RouteLineArrow::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583E78;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::RouteLineArrow::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583E78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::RibbonBatch<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonBatch(void *a1)
{
  *a1 = &unk_1EF530F78;
  uint64_t v2 = (std::__shared_weak_count *)a1[36];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return md::Ribbons::RibbonBatch<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonBatch((uint64_t)a1);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *a1 = &unk_1EF530F78;
  uint64_t v2 = (std::__shared_weak_count *)a1[36];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return md::Ribbons::RibbonBatch<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonBatch((uint64_t)a1);
}

uint64_t md::Ribbons::RibbonBatch<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonBatch(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5539D0;
  uint64_t v2 = *(uint64_t **)(a1 + 248);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 256);
    uint64_t v4 = *(void **)(a1 + 248);
    if (v3 != v2)
    {
      do
        std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](--v3, 0);
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 248);
    }
    *(void *)(a1 + 256) = v2;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 224);
  do
  {
    if (v5[1])
    {
      unint64_t v6 = 0;
      uint64_t v7 = v5 + 2;
      uint64_t v8 = v5 + 2;
      size_t v9 = (void (***)(void))(v5 + 2);
      do
      {
        uint64_t v10 = (void (**)(void *))*v9;
        v9 += 15;
        (*v10)(v8);
        ++v6;
        v7 += 15;
        uint64_t v8 = v9;
      }
      while (v6 < v5[1]);
    }
    v5[1] = 0;
    uint64_t v5 = (void *)*v5;
  }
  while (v5);
  uint64_t v11 = *(void ***)(a1 + 224);
  *(void *)(a1 + 232) = v11;
  int64_t v12 = *v11;
  *uint64_t v11 = 0;
  if (v12)
  {
    do
    {
      unint64_t v13 = (void *)*v12;
      free(v12);
      int64_t v12 = v13;
    }
    while (v13);
    uint64_t v11 = *(void ***)(a1 + 224);
  }
  free(v11);
  BOOL v14 = *(void **)(a1 + 200);
  if (v14)
  {
    *(void *)(a1 + 208) = v14;
    operator delete(v14);
  }
  uint64_t v15 = *(void *)(a1 + 168);
  if (v15)
  {
    uint64_t v16 = *(void *)(a1 + 176);
    uint64_t v17 = *(void *)(a1 + 168);
    if (v16 != v15)
    {
      uint64_t v18 = *(void *)(a1 + 176);
      do
      {
        long long v20 = *(void **)(v18 - 24);
        v18 -= 24;
        unint64_t v19 = v20;
        if (v20)
        {
          *(void *)(v16 - 16) = v19;
          operator delete(v19);
        }
        uint64_t v16 = v18;
      }
      while (v18 != v15);
      uint64_t v17 = *(void *)(a1 + 168);
    }
    *(void *)(a1 + 176) = v15;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 192) + 40))(*(void *)(a1 + 192), v17, *(void *)(a1 + 184) - v17);
  }
  uint64_t v21 = *(void **)(a1 + 144);
  if (v21)
  {
    *(void *)(a1 + 152) = v21;
    operator delete(v21);
  }
  *(void *)(a1 + 16) = &off_1EF55A458;
  *(void *)(a1 + 32) = 3131955885;
  return a1;
}

uint64_t *std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  void *result = a2;
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 56);
    if (v3)
    {
      uint64_t v4 = *(void **)(v2 + 64);
      uint64_t v5 = *(void *)(v2 + 56);
      if (v4 != v3)
      {
        do
        {
          uint64_t v7 = (void (***)(void, uint64_t))*--v4;
          unint64_t v6 = v7;
          void *v4 = 0;
          if (v7)
          {
            (**v6)(v6, v5);
            {
              operator new();
            }
            (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                             + 40))(mdm::Allocator::instance(void)::alloc, v6, 104);
          }
        }
        while (v4 != v3);
        uint64_t v5 = *(void *)(v2 + 56);
      }
      *(void *)(v2 + 64) = v3;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 80) + 40))(*(void *)(v2 + 80), v5, *(void *)(v2 + 72) - v5);
    }
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void md::Ribbons::RibbonBatch<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonBatch(uint64_t a1)
{
  md::Ribbons::RibbonBatch<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonBatch(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::ConstantDataTyped<ggl::RouteLineArrow::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::RouteLineArrow::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::RouteLineArrow::Style>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::RouteLineArrow::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5861E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::RouteLineArrow::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5861E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::RouteLineArrowBatch::~RouteLineArrowBatch(md::RouteLineArrowBatch *this)
{
  *(void *)this = &unk_1EF53C200;
  uint64_t v2 = *((void *)this + 37);
  *((void *)this + 37) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *(void *)this = &unk_1EF530F78;
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  md::Ribbons::RibbonBatch<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonBatch((uint64_t)this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF53C200;
  uint64_t v2 = *((void *)this + 37);
  *((void *)this + 37) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *(void *)this = &unk_1EF530F78;
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  md::Ribbons::RibbonBatch<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonBatch((uint64_t)this);
}

void md::RibbonBatch<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonBatch(void *a1)
{
  *a1 = &unk_1EF530F78;
  uint64_t v2 = (std::__shared_weak_count *)a1[36];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::Ribbons::RibbonBatch<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonBatch((uint64_t)a1);
  JUMPOUT(0x1A6239270);
}

void md::Ribbons::PassRenderItem::~PassRenderItem(md::Ribbons::PassRenderItem *this)
{
  *(void *)this = &off_1EF55A458;
  *((void *)this + 2) = 3131955885;
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &off_1EF55A458;
  *((void *)this + 2) = 3131955885;
}

void md::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::RibbonLayer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    int v73 = a6[24];
    if (a6[24])
    {
      char v6 = a6[1];
      char v74 = *a6;
      uint64_t v8 = *(void *)(a6 + 4);
    }
    else
    {
      char v74 = 0;
    }
    *(void *)a1 = &unk_1EF553C10;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(void *)(a1 + 72) = 0;
    *(unsigned char *)(a1 + 80) = 0;
    *(unsigned char *)(a1 + 104) = 0;
    *(_OWORD *)(a1 + 48) = 0u;
    *(unsigned char *)(a1 + 64) = 0;
    if (v73)
    {
      *(unsigned char *)(a1 + 80) = v74;
      *(unsigned char *)(a1 + 81) = v6;
      *(void *)(a1 + 84) = v8;
      *(unsigned char *)(a1 + 104) = 1;
    }
    uint64_t v75 = operator new(0xF8uLL);
    v75[1] = 0;
    v75[2] = 0;
    *uint64_t v75 = &unk_1EF584968;
    ggl::BufferData::BufferData((uint64_t)(v75 + 3), 32, 0, 0, 1, 0);
    v75[29] = "BatchType/VData";
    v75[30] = &ggl::RouteLineArrow::defaultVboReflection;
    v75[3] = &unk_1EF55C548;
    v75[28] = &unk_1EF55C568;
    uint64_t v76 = operator new(0xF8uLL);
    v76[1] = 0;
    v76[2] = 0;
    *uint64_t v76 = &unk_1EF583D28;
    ggl::BufferData::BufferData((uint64_t)(v76 + 3), 2, 1, 0, 1, 0);
    *((_DWORD *)v76 + 60) = 0;
    v76[3] = &unk_1EF55B630;
    v76[4] = 2;
    v76[28] = &unk_1EF55B650;
    v76[29] = "BatchType/IData";
    operator new();
  }
  long long v78 = 0uLL;
  {
    operator new();
  }
  uint64_t v79 = mdm::Allocator::instance(void)::alloc;
  uint64_t v80 = 0;
  {
    operator new();
  }
  uint64_t v81 = mdm::Allocator::instance(void)::alloc;
  unint64_t v82 = 0;
  float v83 = 1.0;
  size_t v9 = *(uint64_t **)(a3 + 32);
  uint64_t v10 = *(uint64_t **)(a3 + 40);
  if (v9 == v10) {
LABEL_5:
  }
    operator new();
  while (1)
  {
    unsigned int v12 = ggl::CullingGrid::intersectedCellsForRibbon(*(void *)(*v9 + 88), *(void **)(*v9 + 72));
    unsigned int v13 = v12;
    unint64_t v14 = v12;
    size_t v15 = *((void *)&v78 + 1);
    if (*((void *)&v78 + 1))
    {
      uint8x8_t v16 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v78 + 8));
      v16.i16[0] = vaddlv_u8(v16);
      if (v16.u32[0] > 1uLL)
      {
        unint64_t v7 = v12;
        if (*((void *)&v78 + 1) <= (unint64_t)v12) {
          unint64_t v7 = (unint64_t)v12 % *((void *)&v78 + 1);
        }
      }
      else
      {
        unint64_t v7 = (DWORD2(v78) - 1) & v12;
      }
      uint64_t v17 = *(uint64_t **)(v78 + 8 * v7);
      if (v17)
      {
        uint64_t v18 = *v17;
        if (*v17)
        {
          if (v16.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v20 = *(void *)(v18 + 8);
              if (v20 == v12)
              {
                if (*(_DWORD *)(v18 + 16) == v12) {
                  goto LABEL_88;
                }
              }
              else if ((v20 & (*((void *)&v78 + 1) - 1)) != v7)
              {
                goto LABEL_28;
              }
              uint64_t v18 = *(void *)v18;
              if (!v18) {
                goto LABEL_28;
              }
            }
          }
          do
          {
            unint64_t v19 = *(void *)(v18 + 8);
            if (v19 == v12)
            {
              if (*(_DWORD *)(v18 + 16) == v12) {
                goto LABEL_88;
              }
            }
            else
            {
              if (v19 >= *((void *)&v78 + 1)) {
                v19 %= *((void *)&v78 + 1);
              }
              if (v19 != v7) {
                break;
              }
            }
            uint64_t v18 = *(void *)v18;
          }
          while (v18);
        }
      }
    }
LABEL_28:
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v81 + 16))(v81, 56, 8);
    *(void *)uint64_t v18 = 0;
    *(void *)(v18 + 8) = v14;
    *(_DWORD *)(v18 + 16) = v13;
    *(void *)(v18 + 32) = 0;
    *(void *)(v18 + 40) = 0;
    *(void *)(v18 + 24) = 0;
    {
      operator new();
    }
    *(void *)(v18 + 48) = mdm::Allocator::instance(void)::alloc;
    float v21 = (float)(v82 + 1);
    if (!*((void *)&v78 + 1) || (float)(v83 * (float)*((unint64_t *)&v78 + 1)) < v21) {
      break;
    }
LABEL_78:
    size_t v42 = *(uint64_t **)(v78 + 8 * v7);
    if (v42)
    {
      *(void *)uint64_t v18 = *v42;
LABEL_86:
      *size_t v42 = v18;
      goto LABEL_87;
    }
    *(void *)uint64_t v18 = v80;
    uint64_t v80 = v18;
    *(void *)(v78 + 8 * v7) = &v80;
    if (*(void *)v18)
    {
      size_t v43 = *(void *)(*(void *)v18 + 8);
      if ((v15 & (v15 - 1)) != 0)
      {
        if (v43 >= v15) {
          v43 %= v15;
        }
      }
      else
      {
        v43 &= v15 - 1;
      }
      size_t v42 = (uint64_t *)(v78 + 8 * v43);
      goto LABEL_86;
    }
LABEL_87:
    ++v82;
LABEL_88:
    uint64_t v44 = *(void **)(v18 + 32);
    unint64_t v45 = *(void *)(v18 + 40);
    if ((unint64_t)v44 < v45)
    {
      if (v44)
      {
        uint64_t v46 = *v9;
        *size_t v9 = 0;
        *uint64_t v44 = v46;
      }
      uint64_t v11 = v44 + 1;
      goto LABEL_7;
    }
    uint64_t v47 = *(void *)(v18 + 24);
    uint64_t v48 = ((uint64_t)v44 - v47) >> 3;
    unint64_t v49 = v48 + 1;
    if ((unint64_t)(v48 + 1) >> 61) {
      abort();
    }
    uint64_t v50 = v45 - v47;
    if (v50 >> 2 > v49) {
      unint64_t v49 = v50 >> 2;
    }
    if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v51 = v49;
    }
    if (v51)
    {
      uint64_t v52 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v18 + 48) + 16))(*(void *)(v18 + 48), 8 * v51, 8);
      uint64_t v53 = (void *)(v52 + 8 * v48);
      uint64_t v54 = v52 + 8 * v51;
      if (v52)
      {
        uint64_t v55 = *v9;
        *size_t v9 = 0;
        void *v53 = v55;
      }
    }
    else
    {
      uint64_t v54 = 0;
      uint64_t v53 = (void *)(8 * v48);
    }
    uint64_t v11 = v53 + 1;
    BOOL v56 = *(void **)(v18 + 24);
    unint64_t v57 = *(void *)(v18 + 32);
    if ((void *)v57 != v56)
    {
      unint64_t v58 = v57 - (void)v56 - 8;
      if (v58 > 0x47
        && ((unint64_t v59 = v58 >> 3, v57 - 8 * v59 - 8 >= (unint64_t)v53) || (unint64_t)&v53[-v59 - 1] >= v57))
      {
        unint64_t v65 = v59 + 1;
        uint64_t v66 = (v59 + 1) & 0x3FFFFFFFFFFFFFFCLL;
        uint64_t v60 = (void *)(v57 - 8 * v66);
        int8x8_t v67 = v53 - 2;
        uint64_t v68 = (long long *)(v57 - 32);
        uint64_t v69 = v66;
        do
        {
          long long v71 = *v68;
          long long v70 = v68[1];
          *uint64_t v68 = 0uLL;
          v68[1] = 0uLL;
          v68 -= 2;
          *(v67 - 1) = v71;
          *int8x8_t v67 = v70;
          v67 -= 2;
          v69 -= 4;
        }
        while (v69);
        v53 -= v66;
        if (v65 == v66) {
          goto LABEL_107;
        }
      }
      else
      {
        uint64_t v60 = *(void **)(v18 + 32);
      }
      do
      {
        uint64_t v61 = *--v60;
        void *v60 = 0;
        *--uint64_t v53 = v61;
      }
      while (v60 != v56);
LABEL_107:
      unint64_t v57 = *(void *)(v18 + 24);
      float v62 = *(void **)(v18 + 32);
      *(void *)(v18 + 24) = v53;
      *(void *)(v18 + 32) = v11;
      uint64_t v63 = *(void *)(v18 + 40);
      *(void *)(v18 + 40) = v54;
      while (v62 != (void *)v57)
      {
        unint64_t v64 = *--v62;
        unint64_t v7 = v64;
        void *v62 = 0;
        if (v64)
        {
          (**(void (***)(unint64_t))v7)(v7);
          {
            operator new();
          }
          (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                     + 40))(mdm::Allocator::instance(void)::alloc, v7, 104);
        }
      }
      if (!v57) {
        goto LABEL_7;
      }
LABEL_117:
      (*(void (**)(void, unint64_t, unint64_t))(**(void **)(v18 + 48) + 40))(*(void *)(v18 + 48), v57, v63 - v57);
      goto LABEL_7;
    }
    *(void *)(v18 + 24) = v53;
    *(void *)(v18 + 32) = v11;
    uint64_t v63 = *(void *)(v18 + 40);
    *(void *)(v18 + 40) = v54;
    if (v57) {
      goto LABEL_117;
    }
LABEL_7:
    *(void *)(v18 + 32) = v11;
    if (++v9 == v10) {
      goto LABEL_5;
    }
  }
  BOOL v22 = (*((void *)&v78 + 1) & (*((void *)&v78 + 1) - 1)) != 0;
  if (*((void *)&v78 + 1) < 3uLL) {
    BOOL v22 = 1;
  }
  unint64_t v23 = v22 | (2 * *((void *)&v78 + 1));
  unint64_t v24 = vcvtps_u32_f32(v21 / v83);
  if (v23 <= v24) {
    size_t prime = v24;
  }
  else {
    size_t prime = v23;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
  }
  size_t v15 = *((void *)&v78 + 1);
  if (prime <= *((void *)&v78 + 1))
  {
    if (prime >= *((void *)&v78 + 1)) {
      goto LABEL_65;
    }
    unint64_t v36 = vcvtps_u32_f32((float)v82 / v83);
    if (*((void *)&v78 + 1) < 3uLL
      || (uint8x8_t v37 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v78 + 8)), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
    {
      unint64_t v36 = std::__next_prime(v36);
    }
    else
    {
      uint64_t v38 = 1 << -(char)__clz(v36 - 1);
      if (v36 >= 2) {
        unint64_t v36 = v38;
      }
    }
    if (prime <= v36) {
      size_t prime = v36;
    }
    if (prime >= *((void *)&v78 + 1))
    {
      size_t v15 = *((void *)&v78 + 1);
LABEL_65:
      if ((v15 & (v15 - 1)) != 0)
      {
        if (v15 <= v14) {
          unint64_t v7 = v14 % v15;
        }
        else {
          unint64_t v7 = v14;
        }
      }
      else
      {
        unint64_t v7 = (v15 - 1) & v14;
      }
      goto LABEL_78;
    }
    if (!prime)
    {
      uint64_t v72 = v78;
      *(void *)&long long v78 = 0;
      if (v72) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v79 + 40))(v79, v72, 8 * *((void *)&v78 + 1));
      }
      size_t v15 = 0;
      *((void *)&v78 + 1) = 0;
      goto LABEL_65;
    }
  }
  uint64_t v26 = (*(uint64_t (**)(uint64_t, size_t, uint64_t))(*(void *)v79 + 16))(v79, 8 * prime, 8);
  uint64_t v27 = v78;
  *(void *)&long long v78 = v26;
  if (v27) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v79 + 40))(v79, v27, 8 * *((void *)&v78 + 1));
  }
  uint64_t v28 = 0;
  *((void *)&v78 + 1) = prime;
  do
    *(void *)(v78 + 8 * v28++) = 0;
  while (prime != v28);
  unint64_t v29 = (void **)v80;
  if (!v80)
  {
LABEL_64:
    size_t v15 = prime;
    goto LABEL_65;
  }
  size_t v30 = *(void *)(v80 + 8);
  size_t v31 = prime - 1;
  if ((prime & (prime - 1)) == 0)
  {
    size_t v32 = v30 & v31;
    *(void *)(v78 + 8 * v32) = &v80;
    for (uint64_t i = *v29; *v29; uint64_t i = *v29)
    {
      size_t v34 = i[1] & v31;
      if (v34 == v32)
      {
        unint64_t v29 = (void **)i;
      }
      else if (*(void *)(v78 + 8 * v34))
      {
        *unint64_t v29 = (void *)*i;
        uint64_t v35 = 8 * v34;
        *uint64_t i = **(void **)(v78 + v35);
        **(void **)(v78 + v35) = i;
      }
      else
      {
        *(void *)(v78 + 8 * v34) = v29;
        unint64_t v29 = (void **)i;
        size_t v32 = v34;
      }
    }
    goto LABEL_64;
  }
  if (v30 >= prime) {
    v30 %= prime;
  }
  *(void *)(v78 + 8 * v30) = &v80;
  char v39 = *v29;
  if (!*v29) {
    goto LABEL_64;
  }
  while (1)
  {
    size_t v41 = v39[1];
    if (v41 >= prime) {
      v41 %= prime;
    }
    if (v41 != v30)
    {
      if (!*(void *)(v78 + 8 * v41))
      {
        *(void *)(v78 + 8 * v41) = v29;
        goto LABEL_69;
      }
      *unint64_t v29 = (void *)*v39;
      uint64_t v40 = 8 * v41;
      void *v39 = **(void **)(v78 + v40);
      **(void **)(v78 + v40) = v39;
      char v39 = v29;
    }
    size_t v41 = v30;
LABEL_69:
    unint64_t v29 = (void **)v39;
    char v39 = (void *)*v39;
    size_t v30 = v41;
    if (!v39) {
      goto LABEL_64;
    }
  }
}

void sub_1A20C3CE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void **a39,uint64_t a40,uint64_t *a41,uint64_t a42,void **a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *a58)
{
  MEMORY[0x1A6239270](v58, 0x1020C4007FF0C4BLL);
  if (v59) {
    operator delete(v59);
  }
  std::unique_ptr<gdc::GlobeTileGrid>::~unique_ptr[abi:nn180100](a41);
  uint64_t v61 = *a43;
  if (*a43)
  {
    *(void *)(a30 + 40) = v61;
    operator delete(v61);
  }
  float v62 = *a39;
  if (*a39)
  {
    *(void *)(a30 + 16) = v62;
    operator delete(v62);
    if (!a58) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!a58)
  {
    goto LABEL_8;
  }
  operator delete(a58);
  goto LABEL_8;
}

void md::RouteLineArrowLayer::~RouteLineArrowLayer(md::RouteLineArrowLayer *this)
{
  *(void *)this = &unk_1EF5310D8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF5310D8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonLayer(this);
}

void *md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonLayer(void *a1)
{
  *a1 = &unk_1EF553C10;
  uint64_t v2 = (void *)a1[1];
  uint64_t v3 = (void *)a1[2];
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = (void *)a1[4];
  uint64_t v5 = (void *)a1[5];
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = a1[9];
  a1[9] = 0;
  if (v6)
  {
    uint64_t v7 = *(void *)(v6 + 2584);
    if (v7) {
      MEMORY[0x1A6239250](v7, 0x1000C8000313F17);
    }
    MEMORY[0x1A6239270](v6, 0x1020C4007FF0C4BLL);
  }
  uint64_t v8 = (void *)a1[4];
  if (v8)
  {
    a1[5] = v8;
    operator delete(v8);
  }
  size_t v9 = (void *)a1[1];
  if (v9)
  {
    a1[2] = v9;
    operator delete(v9);
  }
  return a1;
}

void md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonLayer(void *a1)
{
  md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonLayer(a1);
  JUMPOUT(0x1A6239270);
}

void md::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonLayer(void *a1)
{
  *a1 = &unk_1EF5310D8;
  uint64_t v2 = (std::__shared_weak_count *)a1[17];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[15];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[15];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonLayer(a1);
  JUMPOUT(0x1A6239270);
}

void *md::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonLayer(void *a1)
{
  *a1 = &unk_1EF5310D8;
  uint64_t v2 = (std::__shared_weak_count *)a1[17];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[15];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[15];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  return md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::~RibbonLayer(a1);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::RouteLineArrow::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::RouteLineArrow::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::RouteLineArrow::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::RouteLineArrow::DefaultVbo>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::RouteLineArrow::DefaultVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584968;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::RouteLineArrow::DefaultVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584968;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::batch(std::unordered_map<md::RouteLineArrowBatchKey,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::RouteLineArrowBatchKey,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*,false>(uint64_t result, int8x16_t *a2, uint64_t a3, char a4)
{
  uint64_t v6 = (int8x16_t *)result;
LABEL_2:
  uint64_t v160 = &a2[-1].i64[1];
  uint64_t v7 = v6;
  while (1)
  {
    uint64_t v6 = v7;
    uint64_t v8 = (char *)a2 - (char *)v7;
    uint64_t v9 = ((char *)a2 - (char *)v7) >> 3;
    if (!(!v5 & v4))
    {
      switch(v9)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v65 = *v160;
          uint64_t v66 = v7->i64[0];
          double result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v160 + 96), v7->i64[0]);
          if (result)
          {
            v7->i64[0] = v65;
            *uint64_t v160 = v66;
          }
          break;
        case 3:
          double result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7->i64, &v7->i64[1], v160);
          break;
        case 4:
          int8x8_t v67 = v7 + 1;
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7->i64, &v7->i64[1], v7[1].i64);
          uint64_t v68 = *v160;
          uint64_t v69 = v7[1].i64[0];
          double result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v160 + 96), v69);
          if (result)
          {
            v67->i64[0] = v68;
            *uint64_t v160 = v69;
            double result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v67->i64[0] + 96), v7->i64[1]);
            if (result)
            {
              int8x16_t v70 = *(int8x16_t *)((char *)v7 + 8);
              *(int8x16_t *)((char *)v7 + 8) = vextq_s8(v70, v70, 8uLL);
              double result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v70.i64[1] + 96), v7->i64[0]);
              if (result) {
                *uint64_t v7 = vextq_s8(*v7, *v7, 8uLL);
              }
            }
          }
          break;
        case 5:
          double result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7->i64, &v7->i64[1], v7[1].i64, &v7[1].i64[1], v160);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v8 <= 191)
    {
      long long v71 = (int8x16_t *)&v7->u64[1];
      BOOL v73 = v7 == a2 || v71 == a2;
      if (a4)
      {
        if (!v73)
        {
          char v74 = (uint64_t *)v7;
          do
          {
            uint64_t v76 = v71;
            uint64_t v77 = v74[1];
            double result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v77 + 96), *v74);
            if (result)
            {
              long long v78 = (uint64_t *)v76;
              uint64_t v79 = 0;
              *long long v78 = 0;
              uint64_t v167 = v77;
              uint64_t v80 = *v74;
              unsigned int v163 = v78;
              for (i = v78; ; uint64_t v79 = *i)
              {
                *uint64_t i = v80;
                uint64_t i = v74;
                *char v74 = 0;
                if (v79)
                {
                  uint64_t v81 = *(void **)(v79 + 56);
                  if (v81)
                  {
                    unint64_t v82 = *(void **)(v79 + 64);
                    uint64_t v83 = *(void *)(v79 + 56);
                    if (v82 != v81)
                    {
                      do
                      {
                        unint64_t v85 = (void (***)(void, uint64_t))*--v82;
                        uint64_t v84 = v85;
                        *unint64_t v82 = 0;
                        if (v85)
                        {
                          (**v84)(v84, v83);
                          {
                            operator new();
                          }
                          (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v84, 104);
                        }
                      }
                      while (v82 != v81);
                      uint64_t v83 = *(void *)(v79 + 56);
                    }
                    *(void *)(v79 + 64) = v81;
                    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v79 + 80) + 40))(*(void *)(v79 + 80), v83, *(void *)(v79 + 72) - v83);
                  }
                  MEMORY[0x1A6239270](v79, 0x1020C4010FC18DELL);
                }
                uint64_t v86 = v167;
                if (i == (uint64_t *)v6) {
                  break;
                }
                unint64_t v87 = *(unsigned int *)(v167 + 96);
                if ((v87 & 0xF000) != 0) {
                  uint64_t v88 = 3;
                }
                else {
                  uint64_t v88 = 0;
                }
                if ((v87 & 0xF00) != 0) {
                  uint64_t v88 = 2;
                }
                if ((v87 & 0xF0) != 0) {
                  uint64_t v88 = 1;
                }
                if ((v87 & 0xF) != 0) {
                  uint64_t v88 = 0;
                }
                int v89 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v88];
                int v90 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v87 >> 12];
                int v91 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v87 >> 8) & 0xF];
                int v92 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v87 >> 4];
                unsigned int v93 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v87 & 0xF];
                char v74 = i - 1;
                uint64_t v80 = *(i - 1);
                unint64_t v94 = *(unsigned int *)(v80 + 96);
                if ((v94 & 0xF000) != 0) {
                  uint64_t v95 = 3;
                }
                else {
                  uint64_t v95 = 0;
                }
                if ((v94 & 0xF00) != 0) {
                  uint64_t v95 = 2;
                }
                if ((v94 & 0xF0) != 0) {
                  uint64_t v95 = 1;
                }
                if ((v94 & 0xF) != 0) {
                  uint64_t v95 = 0;
                }
                if (((v90 << 12) | (v89 << 16) | (v91 << 8) | (16 * v92) | v93) >= ((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v94 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v95] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v94 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v94 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v94 & 0xF])) {
                  goto LABEL_128;
                }
              }
              uint64_t i = (uint64_t *)v6;
LABEL_128:
              uint64_t v167 = 0;
              std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](i, v86);
              double result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
              uint64_t v76 = (int8x16_t *)v163;
            }
            long long v71 = (int8x16_t *)&v76->u64[1];
            char v74 = (uint64_t *)v76;
          }
          while (&v76->u64[1] != (unint64_t *)a2);
        }
      }
      else if (!v73)
      {
        do
        {
          uint64_t v138 = v71;
          uint64_t v139 = v6->i64[1];
          double result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v139 + 96), v6->i64[0]);
          if (result)
          {
            uint64_t v140 = (uint64_t *)v138;
            uint64_t v141 = 0;
            uint64_t *v140 = 0;
            uint64_t v167 = v139;
            uint64_t v142 = v6->i64[0];
            uint64_t v164 = v140;
            for (j = v140; ; uint64_t v141 = *j)
            {
              uint64_t *j = v142;
              unint64_t j = (uint64_t *)v6;
              v6->i64[0] = 0;
              if (v141)
              {
                std::string::size_type v144 = *(void **)(v141 + 56);
                if (v144)
                {
                  uint64_t v145 = *(void **)(v141 + 64);
                  uint64_t v146 = *(void *)(v141 + 56);
                  if (v145 != v144)
                  {
                    do
                    {
                      uint64_t v148 = (void (***)(void, uint64_t))*--v145;
                      uint64_t v147 = v148;
                      *uint64_t v145 = 0;
                      if (v148)
                      {
                        (**v147)(v147, v146);
                        {
                          operator new();
                        }
                        (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v147, 104);
                      }
                    }
                    while (v145 != v144);
                    uint64_t v146 = *(void *)(v141 + 56);
                  }
                  *(void *)(v141 + 64) = v144;
                  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v141 + 80) + 40))(*(void *)(v141 + 80), v146, *(void *)(v141 + 72) - v146);
                }
                MEMORY[0x1A6239270](v141, 0x1020C4010FC18DELL);
              }
              uint64_t v149 = v167;
              unint64_t v150 = *(unsigned int *)(v167 + 96);
              if ((v150 & 0xF000) != 0) {
                uint64_t v151 = 3;
              }
              else {
                uint64_t v151 = 0;
              }
              if ((v150 & 0xF00) != 0) {
                uint64_t v151 = 2;
              }
              if ((v150 & 0xF0) != 0) {
                uint64_t v151 = 1;
              }
              if ((v150 & 0xF) != 0) {
                uint64_t v151 = 0;
              }
              int v152 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v151];
              int v153 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v150 >> 12];
              int v154 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v150 >> 8) & 0xF];
              int v155 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v150 >> 4];
              unsigned int v156 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v150 & 0xF];
              uint64_t v6 = (int8x16_t *)(j - 1);
              uint64_t v142 = *(j - 1);
              unint64_t v157 = *(unsigned int *)(v142 + 96);
              if ((v157 & 0xF000) != 0) {
                uint64_t v158 = 3;
              }
              else {
                uint64_t v158 = 0;
              }
              if ((v157 & 0xF00) != 0) {
                uint64_t v158 = 2;
              }
              if ((v157 & 0xF0) != 0) {
                uint64_t v158 = 1;
              }
              if ((v157 & 0xF) != 0) {
                uint64_t v158 = 0;
              }
              if (((v153 << 12) | (v152 << 16) | (v154 << 8) | (16 * v155) | v156) >= ((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v157 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v158] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v157 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v157 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v157 & 0xF])) {
                break;
              }
            }
            uint64_t v167 = 0;
            std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](j, v149);
            double result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
            uint64_t v138 = (int8x16_t *)v164;
          }
          long long v71 = (int8x16_t *)&v138->u64[1];
          uint64_t v6 = v138;
        }
        while (&v138->u64[1] != (unint64_t *)a2);
      }
      return result;
    }
    if (!a3) {
      break;
    }
    unint64_t v10 = (unint64_t)v9 >> 1;
    uint64_t v11 = &v7->i64[(unint64_t)v9 >> 1];
    if ((unint64_t)v8 < 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v11, v7->i64, v160);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7->i64, v11, v160);
      uint64_t v12 = v10;
      unsigned int v13 = &v7->i64[v10];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(&v7->i64[1], v13 - 1, a2[-1].i64);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7[1].i64, &v7->i64[v12 + 1], &a2[-2].i64[1]);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v13 - 1, v11, &v7->i64[v12 + 1]);
      uint64_t v14 = v7->i64[0];
      v7->i64[0] = *v13;
      *unsigned int v13 = v14;
    }
    --a3;
    uint64_t v15 = v7->i64[0];
    if ((a4 & 1) != 0
      || md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v7[-1].i64[1] + 96), v7->i64[0]))
    {
      v7->i64[0] = 0;
      uint64_t v167 = v15;
      uint8x8_t v16 = v7;
      do
      {
        uint64_t v17 = v16;
        uint64_t v19 = v16->i64[1];
        uint8x8_t v16 = (int8x16_t *)((char *)v16 + 8);
        uint64_t v18 = v19;
      }
      while (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v19 + 96), v15));
      uint64_t v20 = (uint64_t *)a2;
      if (v17 == v6)
      {
        uint64_t v20 = (uint64_t *)a2;
        do
        {
          if (v16 >= (int8x16_t *)v20) {
            break;
          }
          uint64_t v22 = *--v20;
        }
        while (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v22 + 96), v15));
      }
      else
      {
        do
          uint64_t v21 = *--v20;
        while (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v21 + 96), v15));
      }
      if (v16 < (int8x16_t *)v20)
      {
        uint64_t v23 = *v20;
        unint64_t v24 = (uint64_t *)v16;
        long long v25 = v20;
        do
        {
          *unint64_t v24 = v23;
          *long long v25 = v18;
          uint64_t v15 = v167;
          unint64_t v26 = *(unsigned int *)(v167 + 96);
          int v27 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v26 >> 8) & 0xF];
          int v28 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v26 >> 12] << 12;
          int v29 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v26 >> 4];
          int v30 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v26 & 0xF];
          if ((v26 & 0xF000) != 0) {
            uint64_t v31 = 3;
          }
          else {
            uint64_t v31 = 0;
          }
          if ((v26 & 0xF00) != 0) {
            uint64_t v31 = 2;
          }
          if (*(_DWORD *)(v167 + 96)) {
            BOOL v32 = (*(_DWORD *)(v167 + 96) & 0xF) == 0;
          }
          else {
            BOOL v32 = v31;
          }
          unsigned int v33 = v28 | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v32] << 16) | (v27 << 8) | (16 * v29) | v30;
          do
          {
            uint64_t v34 = v24[1];
            ++v24;
            uint64_t v18 = v34;
            unint64_t v35 = *(unsigned int *)(v34 + 96);
            if ((v35 & 0xF000) != 0) {
              uint64_t v36 = 3;
            }
            else {
              uint64_t v36 = 0;
            }
            if ((v35 & 0xF00) != 0) {
              uint64_t v36 = 2;
            }
            if ((v35 & 0xF0) != 0) {
              uint64_t v36 = 1;
            }
            if ((v35 & 0xF) != 0) {
              uint64_t v36 = 0;
            }
          }
          while (((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v35 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v36] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v35 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v35 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v35 & 0xF]) < v33);
          uint64_t v17 = (int8x16_t *)(v24 - 1);
          do
          {
            uint64_t v37 = *--v25;
            uint64_t v23 = v37;
            unint64_t v38 = *(unsigned int *)(v37 + 96);
            if ((v38 & 0xF000) != 0) {
              uint64_t v39 = 3;
            }
            else {
              uint64_t v39 = 0;
            }
            if ((v38 & 0xF00) != 0) {
              uint64_t v39 = 2;
            }
            if ((v38 & 0xF0) != 0) {
              uint64_t v39 = 1;
            }
            if ((v38 & 0xF) != 0) {
              uint64_t v39 = 0;
            }
          }
          while (((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v38 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v39] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v38 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v38 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v38 & 0xF]) >= v33);
        }
        while (v24 < v25);
      }
      if (v17 != v6)
      {
        uint64_t v40 = v17->i64[0];
        v17->i64[0] = 0;
        std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](v6->i64, v40);
        uint64_t v15 = v167;
      }
      uint64_t v167 = 0;
      std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](v17->i64, v15);
      std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
      if (v16 < (int8x16_t *)v20) {
        goto LABEL_58;
      }
      char v41 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::batch(std::unordered_map<md::RouteLineArrowBatchKey,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::RouteLineArrowBatchKey,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v6, v17);
      uint64_t v7 = (int8x16_t *)&v17->u64[1];
      double result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::batch(std::unordered_map<md::RouteLineArrowBatchKey,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::RouteLineArrowBatchKey,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>((int8x16_t *)&v17->u64[1], a2);
      if (result)
      {
        a2 = v17;
        if (v41) {
          return result;
        }
        goto LABEL_2;
      }
      if ((v41 & 1) == 0)
      {
LABEL_58:
        double result = std::__introsort<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::batch(std::unordered_map<md::RouteLineArrowBatchKey,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::RouteLineArrowBatchKey,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*,false>(v6, v17, a3, a4 & 1);
        a4 = 0;
        uint64_t v7 = (int8x16_t *)&v17->u64[1];
      }
    }
    else
    {
      v7->i64[0] = 0;
      uint64_t v167 = v15;
      unint64_t v42 = *(unsigned int *)(v15 + 96);
      if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(v42, *v160))
      {
        do
        {
          uint64_t v43 = v7->i64[1];
          uint64_t v7 = (int8x16_t *)((char *)v7 + 8);
        }
        while (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(v42, v43));
      }
      else
      {
        uint64_t v44 = (int8x16_t *)&v7->u64[1];
        do
        {
          uint64_t v7 = v44;
          if (v44 >= a2) {
            break;
          }
          uint64_t v44 = (int8x16_t *)((char *)v44 + 8);
        }
        while (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(v42, v7->i64[0]));
      }
      unint64_t v45 = a2;
      if (v7 < a2)
      {
        unint64_t v45 = a2;
        do
        {
          uint64_t v46 = v45[-1].i64[1];
          unint64_t v45 = (int8x16_t *)((char *)v45 - 8);
        }
        while (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(v42, v46));
      }
      if (v7 < v45)
      {
        uint64_t v47 = v7->i64[0];
        uint64_t v48 = v45->i64[0];
        do
        {
          v7->i64[0] = v48;
          v45->i64[0] = v47;
          uint64_t v15 = v167;
          unint64_t v49 = *(unsigned int *)(v167 + 96);
          int v50 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v49 >> 8) & 0xF];
          int v51 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v49 >> 4];
          int v52 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v49 & 0xF];
          int v53 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v49 >> 12] << 12;
          if ((v49 & 0xF000) != 0) {
            uint64_t v54 = 3;
          }
          else {
            uint64_t v54 = 0;
          }
          if ((v49 & 0xF00) != 0) {
            uint64_t v54 = 2;
          }
          if (*(_DWORD *)(v167 + 96)) {
            BOOL v55 = (*(_DWORD *)(v167 + 96) & 0xF) == 0;
          }
          else {
            BOOL v55 = v54;
          }
          unsigned int v56 = v53 | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v55] << 16) | (v50 << 8) | (16 * v51) | v52;
          do
          {
            uint64_t v57 = v7->i64[1];
            uint64_t v7 = (int8x16_t *)((char *)v7 + 8);
            uint64_t v47 = v57;
            unint64_t v58 = *(unsigned int *)(v57 + 96);
            if ((v58 & 0xF000) != 0) {
              uint64_t v59 = 3;
            }
            else {
              uint64_t v59 = 0;
            }
            if ((v58 & 0xF00) != 0) {
              uint64_t v59 = 2;
            }
            if ((v58 & 0xF0) != 0) {
              uint64_t v59 = 1;
            }
            if ((v58 & 0xF) != 0) {
              uint64_t v59 = 0;
            }
          }
          while (v56 >= ((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v58 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v59] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v58 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v58 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v58 & 0xF]));
          do
          {
            uint64_t v60 = v45[-1].i64[1];
            unint64_t v45 = (int8x16_t *)((char *)v45 - 8);
            uint64_t v48 = v60;
            unint64_t v61 = *(unsigned int *)(v60 + 96);
            if ((v61 & 0xF000) != 0) {
              uint64_t v62 = 3;
            }
            else {
              uint64_t v62 = 0;
            }
            if ((v61 & 0xF00) != 0) {
              uint64_t v62 = 2;
            }
            if ((v61 & 0xF0) != 0) {
              uint64_t v62 = 1;
            }
            if ((v61 & 0xF) != 0) {
              uint64_t v62 = 0;
            }
          }
          while (v56 < ((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v61 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v62] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v61 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v61 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v61 & 0xF]));
        }
        while (v7 < v45);
      }
      uint64_t v63 = &v7[-1].i64[1];
      if (&v7[-1].u64[1] != (unint64_t *)v6)
      {
        uint64_t v64 = *v63;
        uint64_t *v63 = 0;
        std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](v6->i64, v64);
        uint64_t v15 = v167;
      }
      uint64_t v167 = 0;
      std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](&v7[-1].i64[1], v15);
      double result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
      a4 = 0;
    }
  }
  if (v7 != a2)
  {
    unint64_t v161 = (char *)a2 - (char *)v7;
    int64_t v96 = (unint64_t)(v9 - 2) >> 1;
    int64_t v97 = v96;
    do
    {
      int64_t v98 = v97;
      if (v96 >= v97)
      {
        uint64_t v99 = (2 * v97) | 1;
        __double2 v100 = &v6->i64[v99];
        if (2 * v97 + 2 < v9)
        {
          uint64_t v101 = *v100;
          uint64_t v102 = v100[1];
          BOOL v103 = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v100 + 96), v102);
          if (v103) {
            uint64_t v104 = v102;
          }
          else {
            uint64_t v104 = v101;
          }
          if (v103)
          {
            ++v100;
            uint64_t v99 = 2 * v98 + 2;
          }
        }
        else
        {
          uint64_t v104 = *v100;
        }
        long long v105 = &v6->i64[v98];
        uint64_t v106 = *v105;
        double result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v104 + 96), *v105);
        if ((result & 1) == 0)
        {
          *long long v105 = 0;
          uint64_t v167 = v106;
          uint64_t v107 = *v100;
          while (1)
          {
            size_t v111 = v100;
            uint64_t *v100 = 0;
            std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](v105, v107);
            if (v96 < v99) {
              break;
            }
            uint64_t v112 = (2 * v99) | 1;
            __double2 v100 = &v6->i64[v112];
            uint64_t v113 = 2 * v99 + 2;
            if (v113 < v9)
            {
              uint64_t v108 = *v100;
              uint64_t v107 = v100[1];
              BOOL v109 = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v100 + 96), v107);
              if (v109) {
                ++v100;
              }
              else {
                uint64_t v107 = v108;
              }
              if (v109) {
                uint64_t v99 = v113;
              }
              else {
                uint64_t v99 = v112;
              }
            }
            else
            {
              uint64_t v107 = *v100;
              uint64_t v99 = (2 * v99) | 1;
            }
            uint64_t v110 = v167;
            long long v105 = v111;
            if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v107 + 96), v167))
            {
              goto LABEL_168;
            }
          }
          uint64_t v110 = v167;
LABEL_168:
          uint64_t v167 = 0;
          std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](v111, v110);
          double result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
        }
      }
      int64_t v97 = v98 - 1;
    }
    while (v98);
    uint64_t v114 = v161 >> 3;
    while (2)
    {
      if (v114 >= 2)
      {
        uint64_t v118 = 0;
        uint64_t v119 = v6->i64[0];
        v6->i64[0] = 0;
        uint64_t v166 = v119;
        unint64_t v120 = (uint64_t *)v6;
        do
        {
          size_t v125 = &v120[v118 + 1];
          uint64_t v126 = (2 * v118) | 1;
          uint64_t v127 = 2 * v118 + 2;
          if (v127 < v114)
          {
            uint64_t v121 = *v125;
            uint64_t v122 = v120[v118 + 2];
            BOOL v123 = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v125 + 96), v125[1]);
            if (v123) {
              uint64_t v124 = v122;
            }
            else {
              uint64_t v124 = v121;
            }
            if (v123)
            {
              ++v125;
              uint64_t v118 = v127;
            }
            else
            {
              uint64_t v118 = v126;
            }
          }
          else
          {
            uint64_t v124 = *v125;
            uint64_t v118 = (2 * v118) | 1;
          }
          *size_t v125 = 0;
          std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](v120, v124);
          unint64_t v120 = v125;
        }
        while (v118 <= (uint64_t)((unint64_t)(v114 - 2) >> 1));
        size_t v128 = &a2[-1].i64[1];
        if (v125 == (uint64_t *)&a2[-1].u64[1])
        {
          uint64_t v115 = v166;
          uint64_t v166 = 0;
          float v116 = v125;
          goto LABEL_193;
        }
        uint64_t v129 = *v128;
        uint64_t *v128 = 0;
        std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](v125, v129);
        uint64_t v130 = v166;
        uint64_t v166 = 0;
        std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](v128, v130);
        uint64_t v131 = (char *)v125 - (char *)v6 + 8;
        if (v131 >= 9)
        {
          unint64_t v132 = (unint64_t)((v131 >> 3) - 2) >> 1;
          uint64_t v133 = &v6->i64[v132];
          uint64_t v134 = *v125;
          if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v133 + 96), *v125))
          {
            *size_t v125 = 0;
            uint64_t v167 = v134;
            uint64_t v135 = *v133;
            do
            {
              uint64_t v136 = v133;
              *uint64_t v133 = 0;
              std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](v125, v135);
              uint64_t v137 = v167;
              if (!v132) {
                break;
              }
              unint64_t v132 = (v132 - 1) >> 1;
              uint64_t v133 = &v6->i64[v132];
              uint64_t v135 = *v133;
              size_t v125 = v136;
            }
            while (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v133 + 96), v167));
            uint64_t v167 = 0;
            std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](v136, v137);
            float v116 = &v167;
            uint64_t v115 = 0;
LABEL_193:
            std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](v116, v115);
          }
        }
        double result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](&v166, 0);
      }
      a2 = (int8x16_t *)((char *)a2 - 8);
      if ((unint64_t)v114-- <= 2) {
        return result;
      }
      continue;
    }
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,geo::StdAllocator<std::__hash_value_type<unsigned int,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>>,mdm::Allocator>>::__deallocate_node(uint64_t result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    uint64_t v3 = result;
    do
    {
      char v5 = (uint64_t *)*v2;
      uint64_t v6 = (void *)v2[3];
      if (v6)
      {
        uint64_t v7 = (void *)v2[4];
        uint64_t v4 = v2[3];
        if (v7 != v6)
        {
          do
          {
            uint64_t v9 = (void (***)(void, uint64_t))*--v7;
            uint64_t v8 = v9;
            *uint64_t v7 = 0;
            if (v9)
            {
              (**v8)(v8, v4);
              {
                  operator new();
              }
              (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                               + 40))(mdm::Allocator::instance(void)::alloc, v8, 104);
            }
          }
          while (v7 != v6);
          uint64_t v4 = v2[3];
        }
        v2[4] = (uint64_t)v6;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[6] + 40))(v2[6], v4, v2[5] - v4);
      }
      double result = (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(v3 + 32) + 40))(*(void *)(v3 + 32), v2, 56);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  return result;
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::batch(std::unordered_map<md::RouteLineArrowBatchKey,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::RouteLineArrowBatchKey,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(int8x16_t *a1, int8x16_t *a2)
{
  BOOL v4 = 1;
  switch(((char *)a2 - (char *)a1) >> 3)
  {
    case 0:
    case 1:
      return v4;
    case 2:
      uint64_t v5 = a2[-1].i64[1];
      uint64_t v6 = a1->i64[0];
      if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v5 + 96), a1->i64[0]))
      {
        a1->i64[0] = v5;
        a2[-1].i64[1] = v6;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(a1->i64, &a1->i64[1], &a2[-1].i64[1]);
      return v4;
    case 4:
      uint8x8_t v16 = a1 + 1;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(a1->i64, &a1->i64[1], a1[1].i64);
      uint64_t v17 = a2[-1].i64[1];
      uint64_t v18 = a1[1].i64[0];
      if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v17 + 96), v18))
      {
        v16->i64[0] = v17;
        a2[-1].i64[1] = v18;
        if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v16->i64[0] + 96), a1->i64[1]))
        {
          int8x16_t v19 = *(int8x16_t *)((char *)a1 + 8);
          *(int8x16_t *)((char *)a1 + 8) = vextq_s8(v19, v19, 8uLL);
          if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v19.i64[1] + 96), a1->i64[0]))
          {
            *a1 = vextq_s8(*a1, *a1, 8uLL);
          }
        }
      }
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(a1->i64, &a1->i64[1], a1[1].i64, &a1[1].i64[1], &a2[-1].i64[1]);
      return v4;
    default:
      i64 = a1[1].i64;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(a1->i64, &a1->i64[1], a1[1].i64);
      uint64_t v8 = &a1[1].i64[1];
      if (&a1[1].u64[1] == (unint64_t *)a2) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (1)
  {
    uint64_t v11 = *v8;
    if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v8 + 96), *i64))
    {
      break;
    }
LABEL_6:
    i64 = v8;
    v9 += 8;
    if (++v8 == (uint64_t *)a2) {
      return 1;
    }
  }
  *uint64_t v8 = 0;
  uint64_t v21 = v11;
  uint64_t v12 = *i64;
  uint64_t v13 = v9;
  while (1)
  {
    *(uint64_t *)((char *)a1[1].i64 + v13) = 0;
    std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100]((uint64_t *)((char *)&a1[1].i64[1] + v13), v12);
    uint64_t v14 = v21;
    if (v13 == -16) {
      break;
    }
    uint64_t v12 = *(uint64_t *)((char *)&a1->i64[1] + v13);
    v13 -= 8;
    if (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v21 + 96), v12))
    {
      uint64_t v15 = (uint64_t *)((char *)&a1[1].i64[1] + v13);
      goto LABEL_13;
    }
  }
  uint64_t v15 = (uint64_t *)a1;
LABEL_13:
  uint64_t v21 = 0;
  std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](v15, v14);
  if (++v10 != 8)
  {
    std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](&v21, 0);
    goto LABEL_6;
  }
  BOOL v4 = v8 + 1 == (uint64_t *)a2;
  std::unique_ptr<md::RibbonSection<md::Ribbons::RouteLineArrowRibbonDescriptor>>::reset[abi:nn180100](&v21, 0);
  return v4;
}

uint64_t std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<unsigned int,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>>,void *>,mdm::Allocator>>::operator()[abi:nn180100](uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(unsigned char *)(result + 8))
  {
    BOOL v4 = *(void **)(a2 + 24);
    if (v4)
    {
      uint64_t v5 = *(void **)(a2 + 32);
      uint64_t v6 = *(void *)(a2 + 24);
      if (v5 != v4)
      {
        do
        {
          uint64_t v8 = (void (***)(void, uint64_t))*--v5;
          uint64_t v7 = v8;
          void *v5 = 0;
          if (v8)
          {
            (**v7)(v7, v6);
            {
              operator new();
            }
            (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                             + 40))(mdm::Allocator::instance(void)::alloc, v7, 104);
          }
        }
        while (v5 != v4);
        uint64_t v6 = *(void *)(a2 + 24);
      }
      *(void *)(a2 + 32) = v4;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 48) + 40))(*(void *)(a2 + 48), v6, *(void *)(a2 + 40) - v6);
    }
  }
  else if (!a2)
  {
    return result;
  }
  uint64_t v9 = *(uint64_t (**)(void))(***(void ***)v3 + 40);
  return v9();
}

uint64_t md::RouteLineArrowLayer::layout(md::RouteLineArrowLayer *this, const md::RouteLineArrowContext *a2)
{
  uint64_t v4 = 24;
  if (!*((unsigned char *)a2 + 56)) {
    uint64_t v4 = 16;
  }
  *((void *)this + 7) = *(void *)(*((void *)this + 20) + v4);
  uint64_t v5 = *(void **)(*(void *)a2 + 8);
  int8x8_t v6 = (int8x8_t)v5[1];
  if (!*(void *)&v6) {
    goto LABEL_31;
  }
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    uint64_t v8 = 0x1AF456233693CD46;
    if (*(void *)&v6 <= 0x1AF456233693CD46uLL) {
      uint64_t v8 = 0x1AF456233693CD46uLL % *(void *)&v6;
    }
  }
  else
  {
    uint64_t v8 = (*(void *)&v6 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v9 = *(void **)(*v5 + 8 * v8);
  if (!v9) {
    goto LABEL_31;
  }
  int v10 = (void *)*v9;
  if (!v10) {
    goto LABEL_31;
  }
  if (v7.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v12 = v10[1];
      if (v12 == 0x1AF456233693CD46)
      {
        if (v10[2] == 0x1AF456233693CD46) {
          goto LABEL_24;
        }
      }
      else if ((v12 & (*(void *)&v6 - 1)) != v8)
      {
        goto LABEL_31;
      }
      int v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_31;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v10[1];
    if (v11 == 0x1AF456233693CD46) {
      break;
    }
    if (v11 >= *(void *)&v6) {
      v11 %= *(void *)&v6;
    }
    if (v11 != v8) {
      goto LABEL_31;
    }
LABEL_13:
    int v10 = (void *)*v10;
    if (!v10) {
      goto LABEL_31;
    }
  }
  if (v10[2] != 0x1AF456233693CD46) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v13 = v10[5];
  if (*(void *)(v13 + 8) != 0x1AF456233693CD46)
  {
LABEL_31:
    uint64_t v14 = 0;
    if (MEMORY[0xEC0]) {
      goto LABEL_32;
    }
LABEL_26:
    if ((*(void *)&v6 & (*(void *)&v6 - 1)) != 0)
    {
      unint64_t v21 = 0x8BD499FBD96FBB9ELL;
      if (*(void *)&v6 <= 0x8BD499FBD96FBB9ELL) {
        unint64_t v21 = 0x8BD499FBD96FBB9ELL % *(void *)&v6;
      }
      uint64_t v15 = *(void **)(*v5 + 8 * v21);
      do
      {
        do
          uint64_t v15 = (void *)*v15;
        while (v15[1] != 0x8BD499FBD96FBB9ELL);
      }
      while (v15[2] != 0x8BD499FBD96FBB9ELL);
    }
    else
    {
      uint64_t v15 = *(void **)(*v5 + 8 * ((*(void *)&v6 - 1) & 0x8BD499FBD96FBB9ELL));
      do
      {
        do
          uint64_t v15 = (void *)*v15;
        while (v15[1] != 0x8BD499FBD96FBB9ELL);
      }
      while (v15[2] != 0x8BD499FBD96FBB9ELL);
    }
    double v22 = 0.0;
    if (**(unsigned char **)(v15[5] + 32) && *((unsigned char *)this + 104)) {
      double v22 = *(double *)(v14 + 24) * 0.0000000249532021 * (double)(1 << *((unsigned char *)this + 81));
    }
    uint64_t v23 = *((void *)this + 14);
    if ((*(unsigned char *)(v23 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      v98[0] = (uint64_t)&v100;
      v101[0] = (uint16x4_t)v98;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, v101, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    int8x16_t v19 = *(float **)(v23 + 72);
    double v20 = v22;
    goto LABEL_50;
  }
  uint64_t v14 = *(void *)(v13 + 32);
  if (!*(unsigned char *)(v14 + 3776)) {
    goto LABEL_26;
  }
LABEL_32:
  uint64_t v16 = *((void *)this + 9);
  if (!v16)
  {
    uint64_t v18 = *((void *)this + 14);
    if ((*(unsigned char *)(v18 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      v98[0] = (uint64_t)&v100;
      v101[0] = (uint16x4_t)v98;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, v101, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    int8x16_t v19 = *(float **)(v18 + 72);
    double v20 = 0.0;
LABEL_50:
    uint64_t result = ggl::CullingGrid::intersectedCellsForView(v19, v20);
    goto LABEL_51;
  }
  uint64_t result = gdc::GlobeTileGrid::intersectWithFrustum(v16, (const double *)(v14 + 984), *(double *)(v14 + 24));
LABEL_51:
  unint64_t v24 = (uint64_t *)*((void *)this + 1);
  long long v25 = (uint64_t *)*((void *)this + 2);
  if (v24 != v25)
  {
    do
    {
      uint64_t v27 = *v24;
      int v28 = *(uint64_t **)(*v24 + 248);
      int v29 = *(uint64_t **)(*v24 + 256);
      if (v28 == v29)
      {
        char v26 = 0;
      }
      else
      {
        char v26 = 0;
        do
        {
          uint64_t v30 = *v28++;
          BOOL v31 = (*(_DWORD *)(v30 + 96) & result) != 0;
          v26 |= v31;
          *(unsigned char *)(v30 + 48) = v31;
        }
        while (v28 != v29);
      }
      *(unsigned char *)(v27 + 136) = v26 & 1;
      *(unsigned char *)(v27 + 272) = v26 & 1;
      ++v24;
    }
    while (v24 != v25);
    BOOL v32 = (uint64_t *)*((void *)this + 1);
    unsigned int v33 = (uint64_t *)*((void *)this + 2);
    if (v32 != v33)
    {
      __asm { FMOV            V0.4S, #1.0 }
      long long v92 = _Q0;
      float32x4_t v97 = (float32x4_t)vdupq_n_s32(0x37800080u);
      do
      {
        uint64_t v38 = *v32;
        if (!*(unsigned char *)(*v32 + 272)) {
          goto LABEL_63;
        }
        uint64_t v39 = *(void *)(v38 + 280);
        uint64_t v40 = *(std::__shared_weak_count **)(v38 + 288);
        if (v40) {
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v98, v39, (uint64_t)v40);
        if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
          std::__shared_weak_count::__release_weak(v40);
          if (v99)
          {
LABEL_70:
            float v41 = *((float *)a2 + 2);
            uint64_t v42 = *(void *)(v98[0] + 24);
            uint64_t v43 = *(float **)v42;
            if (*(void *)v42
              && (float v44 = *v43, LODWORD(v43) = *v43 == 1.0, *(unsigned char *)(v42 + 10))
              && (v44 != 0.0 ? (_ZF = v44 == 1.0) : (_ZF = 1), !_ZF)
              || (v46 = *(unsigned __int8 *)(v42 + v43 + 11), float v44 = 0.0, v46 == 2))
            {
              v101[0].i8[0] = 1;
              char v100 = 1;
              uint64_t v47 = (float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v42, 0xF3u, 0, v101);
              float v48 = *v47
                  + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v42, 0xF3u, 1u, &v100)- *v47)* v44);
            }
            else
            {
              float v48 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(*(void *)(v98[0] + 24), 0xF3u, v46, 0);
            }
            uint64_t v49 = *(void *)(v98[0] + 24);
            int v50 = *(float **)v49;
            if (*(void *)v49
              && (float v51 = *v50, LODWORD(v50) = *v50 == 1.0, *(unsigned char *)(v49 + 10))
              && (v51 != 0.0 ? (BOOL v52 = v51 == 1.0) : (BOOL v52 = 1), !v52)
              || (unsigned int v53 = *(unsigned __int8 *)(v49 + v50 + 11), v51 = 0.0, v53 == 2))
            {
              v101[0].i8[0] = 1;
              char v100 = 1;
              uint64_t v54 = (float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v49, 0xF4u, 0, v101);
              float v55 = *v54
                  + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v49, 0xF4u, 1u, &v100)- *v54)* v51);
            }
            else
            {
              float v55 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(*(void *)(v98[0] + 24), 0xF4u, v53, 0);
            }
            uint64_t v56 = *(void *)(v98[0] + 24);
            uint64_t v57 = *(float **)v56;
            if (*(void *)v56
              && (float v58 = *v57, LODWORD(v57) = *v57 == 1.0, *(unsigned char *)(v56 + 10))
              && (v58 != 0.0 ? (BOOL v59 = v58 == 1.0) : (BOOL v59 = 1), !v59)
              || (v60 = *(unsigned __int8 *)(v56 + v57 + 11), float v58 = 0.0, v60 == 2))
            {
              v101[0].i8[0] = 1;
              char v100 = 1;
              unint64_t v61 = (float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v56, 0xF5u, 0, v101);
              float v62 = *v61
                  + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v56, 0xF5u, 1u, &v100)- *v61)* v58);
            }
            else
            {
              float v62 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(*(void *)(v98[0] + 24), 0xF5u, v60, 0);
            }
            uint64_t v63 = *(void *)(v98[0] + 24);
            if ((int)v41 >= 0x17) {
              unsigned int v64 = 23;
            }
            else {
              unsigned int v64 = (int)v41;
            }
            uint64_t v65 = *(float **)v63;
            if (*(void *)v63
              && (float v66 = *v65, LODWORD(v65) = *v65 == 1.0, *(unsigned char *)(v63 + 10))
              && (v66 != 0.0 ? (BOOL v67 = v66 == 1.0) : (BOOL v67 = 1), !v67)
              || (unsigned int v68 = *(unsigned __int8 *)(v63 + v65 + 11), v66 = 0.0, v68 == 2))
            {
              v101[0].i8[0] = 1;
              char v100 = 1;
              float v69 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v63, 0x5Eu, v64, 0, v101);
              float v70 = v69
                  + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v63, 0x5Eu, v64, 1u, &v100)- v69)* v66);
            }
            else
            {
              float v70 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v98[0] + 24), 0x5Eu, v64, v68, 0);
            }
            float v71 = *((float *)a2 + 32);
            {
              md::RouteLineArrowBatch::layout(md::RouteLineArrowContext const&)::defaultFillColor = xmmword_1A28FE270;
            }
            {
              md::RouteLineArrowBatch::layout(md::RouteLineArrowContext const&)::defaultStrokeColor = xmmword_1A28FE280;
            }
            {
              md::RouteLineArrowBatch::layout(md::RouteLineArrowContext const&)::defaultHighlightedFillColor = v92;
            }
            {
              md::RouteLineArrowBatch::layout(md::RouteLineArrowContext const&)::defaultHighlightedStrokeColor = xmmword_1A28FE290;
            }
            float32x4_t v95 = (float32x4_t)md::RouteLineArrowBatch::layout(md::RouteLineArrowContext const&)::defaultStrokeColor;
            float32x4_t v96 = (float32x4_t)md::RouteLineArrowBatch::layout(md::RouteLineArrowContext const&)::defaultFillColor;
            unint64_t v72 = *(void *)(v98[0] + 24);
            BOOL v73 = *(float **)v72;
            long long v93 = md::RouteLineArrowBatch::layout(md::RouteLineArrowContext const&)::defaultHighlightedStrokeColor;
            float32x4_t v94 = (float32x4_t)md::RouteLineArrowBatch::layout(md::RouteLineArrowContext const&)::defaultHighlightedFillColor;
            if (!*(void *)v72)
            {
              BOOL v75 = 0;
              goto LABEL_125;
            }
            float v74 = *v73;
            BOOL v75 = *v73 == 1.0;
            if (!*(unsigned char *)(v72 + 10) || v74 == 0.0 || v74 == 1.0)
            {
LABEL_125:
              unsigned int v76 = *(unsigned __int8 *)(v72 + v75 + 11);
              if (v76 == 2) {
                goto LABEL_126;
              }
LABEL_128:
              if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v72, 0x86u, v76)) {
                goto LABEL_129;
              }
            }
            else
            {
LABEL_126:
              if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v72, 0x86u, 0) & 1) == 0)
              {
                unsigned int v76 = 1;
                goto LABEL_128;
              }
LABEL_129:
              gss::RenderStyleHelper<gss::PropertyID,geo::Color<unsigned short,4,(geo::ColorSpace)0>>::valueForKey((unint64_t *)v101, 0x86u, 2, v72);
              float32x4_t v96 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v101[0])), v97);
              unint64_t v72 = *(void *)(v98[0] + 24);
              BOOL v73 = *(float **)v72;
            }
            if (!v73)
            {
              BOOL v78 = 0;
              goto LABEL_136;
            }
            float v77 = *v73;
            BOOL v78 = *v73 == 1.0;
            if (!*(unsigned char *)(v72 + 10) || v77 == 0.0 || v77 == 1.0)
            {
LABEL_136:
              unsigned int v79 = *(unsigned __int8 *)(v72 + v78 + 11);
              if (v79 == 2) {
                goto LABEL_137;
              }
LABEL_139:
              if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v72, 0x87u, v79)) {
                goto LABEL_140;
              }
            }
            else
            {
LABEL_137:
              if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v72, 0x87u, 0) & 1) == 0)
              {
                unsigned int v79 = 1;
                goto LABEL_139;
              }
LABEL_140:
              gss::RenderStyleHelper<gss::PropertyID,geo::Color<unsigned short,4,(geo::ColorSpace)0>>::valueForKey((unint64_t *)v101, 0x87u, 2, v72);
              float32x4_t v95 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v101[0])), v97);
              unint64_t v72 = *(void *)(v98[0] + 24);
              BOOL v73 = *(float **)v72;
            }
            if (!v73)
            {
              BOOL v81 = 0;
              goto LABEL_147;
            }
            float v80 = *v73;
            BOOL v81 = *v73 == 1.0;
            if (!*(unsigned char *)(v72 + 10) || v80 == 0.0 || v80 == 1.0)
            {
LABEL_147:
              unsigned int v82 = *(unsigned __int8 *)(v72 + v81 + 11);
              if (v82 == 2) {
                goto LABEL_148;
              }
LABEL_150:
              if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v72, 0x13Du, v82)) {
                goto LABEL_151;
              }
            }
            else
            {
LABEL_148:
              if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v72, 0x13Du, 0) & 1) == 0)
              {
                unsigned int v82 = 1;
                goto LABEL_150;
              }
LABEL_151:
              gss::RenderStyleHelper<gss::PropertyID,geo::Color<unsigned short,4,(geo::ColorSpace)0>>::valueForKey((unint64_t *)v101, 0x13Du, 2, v72);
              float32x4_t v94 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v101[0])), v97);
              unint64_t v72 = *(void *)(v98[0] + 24);
              BOOL v73 = *(float **)v72;
            }
            if (!v73)
            {
              BOOL v84 = 0;
              goto LABEL_158;
            }
            float v83 = *v73;
            BOOL v84 = *v73 == 1.0;
            if (!*(unsigned char *)(v72 + 10) || v83 == 0.0 || v83 == 1.0)
            {
LABEL_158:
              unsigned int v85 = *(unsigned __int8 *)(v72 + v84 + 11);
              if (v85 == 2) {
                goto LABEL_159;
              }
LABEL_161:
              int hasValueForKeyAtEnd = gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v72, 0x13Eu, v85);
              float32x4_t v87 = (float32x4_t)v93;
              if (hasValueForKeyAtEnd) {
                goto LABEL_162;
              }
            }
            else
            {
LABEL_159:
              if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v72, 0x13Eu, 0) & 1) == 0)
              {
                unsigned int v85 = 1;
                goto LABEL_161;
              }
LABEL_162:
              gss::RenderStyleHelper<gss::PropertyID,geo::Color<unsigned short,4,(geo::ColorSpace)0>>::valueForKey((unint64_t *)v101, 0x13Eu, 2, v72);
              float32x4_t v87 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v101[0])), v97);
            }
            float v88 = (float)(v70 + (float)(fminf(fmaxf(v55 * (float)(v41 - v48), 0.0), v62) * v70)) * v71;
            int v89 = *(void **)(*(void *)(*(void *)(v38 + 296) + 64) + 32);
            unint64_t v90 = v89[1];
            int v91 = (float32x4_t *)v89[9];
            v91[5] = v94;
            v91[6] = v87;
            v91[7].f32[0] = v88 * 0.6;
            v91[3] = v96;
            v91[4] = v95;
            v91[2].i32[1] = *((_DWORD *)a2 + 55);
            v91[7].i32[1] = *((_DWORD *)a2 + 54);
            v91->f32[0] = v88 * 0.475;
            if (v89[8] > v90) {
              unint64_t v90 = v89[8];
            }
            v89[7] = 0;
            v89[8] = v90;
            *(_DWORD *)(v38 + 56) = *((unsigned __int8 *)a2 + 57);
            *(void *)(v38 + 64) = *((void *)a2 + 17);
            goto LABEL_62;
          }
        }
        else if (v99)
        {
          goto LABEL_70;
        }
        *(unsigned char *)(v38 + 136) = 0;
        *(unsigned char *)(v38 + 272) = 0;
LABEL_62:
        uint64_t result = gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v98);
LABEL_63:
        ++v32;
      }
      while (v32 != v33);
    }
  }
  return result;
}

void sub_1A20C6A64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

BOOL md::OBBIntersectsXYAABB(float *a1, float *a2, float *a3)
{
  float v3 = a2[1];
  float v4 = a2[2];
  float v5 = (float)(a2[3] - *a2) * 0.5;
  float v6 = (float)(a2[4] - v3) * 0.5;
  float v7 = (float)(a2[5] - v4) * 0.5;
  float v8 = v5 + *a2;
  float v9 = v6 + v3;
  float v10 = v7 + v4;
  float v11 = a1[3];
  float v12 = a1[6];
  float v13 = (float)((float)(a1[9] + (float)(*a1 * v8)) + (float)(v11 * v9)) + (float)(v12 * v10);
  float v14 = (float)(fabsf(v5 * *a1) + fabsf(v6 * v11)) + fabsf(v7 * v12);
  if ((float)(v14 + v13) < *a3 || (float)(v13 - v14) > a3[2]) {
    return 0;
  }
  float v17 = a1[1];
  float v18 = a1[4];
  float v19 = a1[7];
  float v20 = (float)((float)(a1[10] + (float)(v17 * v8)) + (float)(v18 * v9)) + (float)(v19 * v10);
  float v21 = (float)(fabsf(v6 * v18) + fabsf(v5 * v17)) + fabsf(v7 * v19);
  return (float)(v21 + v20) >= a3[1] && (float)(v20 - v21) <= a3[3];
}

uint64_t md::MuninLabeler::layoutForStaging(uint64_t a1, uint64_t a2)
{
  (*(void (**)(void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56));
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 64) + 40))(*(void *)(a1 + 64), a2);
  float v5 = *(void **)(a1 + 56);
  if (v5[52] != v5[53])
  {
    uint64_t v6 = md::LabelSettingsStyleCache::muninPointStyle(*(md::LabelSettingsStyleCache **)(*(void *)(v5[3] + 336)
                                                                                      + 200));
    float v7 = (uint64_t *)v5[52];
    float v8 = (uint64_t *)v5[53];
    unint64_t v9 = 126 - 2 * __clz(v8 - v7);
    if (v8 == v7) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = v9;
    }
    std::__introsort<std::_ClassicAlgPolicy,md::MuninPoiLabelSorter &,md::Label **,false>(v7, v8, v10, 1);
    unint64_t v11 = *(unsigned int *)(v6 + 24);
    return md::MuninStandardLabeler::placeLabels((uint64_t)v5, v5 + 52, v11);
  }
  return result;
}

uint64_t md::MuninLabeler::synchronizedUpdate(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7 = *(unsigned __int8 *)(result + 72);
  int v8 = *(unsigned __int8 *)(*(void *)(result + 48) + 3034) ^ 1;
  if (v7 != v8)
  {
    *(unsigned char *)(result + 72) = *(unsigned char *)(*(void *)(result + 48) + 3034) ^ 1;
    *(unsigned char *)(*(void *)(result + 64) + 78) = v8;
    int v7 = v8;
  }
  if (*(unsigned char *)(result + 74))
  {
    *(unsigned char *)(result + 74) = 0;
    int v9 = *(unsigned __int8 *)(result + 75);
    uint64_t v10 = *(void *)(result + 64);
    *(unsigned char *)(*(void *)(result + 56) + 441) = v9;
    *(unsigned char *)(v10 + 78) = (v9 | v7) != 0;
  }
  unint64_t v11 = *(uint64_t **)(result + 8);
  for (uint64_t i = *(uint64_t **)(result + 16);
        v11 != i;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, a2, a3, a4))
  {
    uint64_t v13 = *v11++;
  }
  return result;
}

uint64_t md::MuninLabeler::startFrameLayout(uint64_t this, const md::LayoutContext *a2, float a3)
{
  float v5 = (void *)*((void *)a2 + 1);
  unint64_t v6 = v5[1];
  if ((v6 & (v6 - 1)) != 0)
  {
    unint64_t v8 = 0xC83717EF586624DCLL;
    if (v6 <= 0xC83717EF586624DCLL) {
      unint64_t v8 = 0xC83717EF586624DCLL % v6;
    }
    int v7 = *(void **)(*v5 + 8 * v8);
    do
    {
      do
        int v7 = (void *)*v7;
      while (v7[1] != 0xC83717EF586624DCLL);
    }
    while (v7[2] != 0xC83717EF586624DCLL);
  }
  else
  {
    int v7 = *(void **)(*v5 + 8 * ((v6 - 1) & 0xC83717EF586624DCLL));
    do
    {
      do
        int v7 = (void *)*v7;
      while (v7[1] != 0xC83717EF586624DCLL);
    }
    while (v7[2] != 0xC83717EF586624DCLL);
  }
  int v9 = *(void **)(v7[5] + 32);
  uint64_t v10 = (unsigned char *)v9[5];
  for (uint64_t i = (unsigned char *)v9[6]; v10 != i; v10 += 272)
  {
    switch(*v10)
    {
      case 2:
        uint64_t v12 = *(void *)(this + 48);
        uint64_t v13 = *(void *)(this + 56);
        *(unsigned char *)(v12 + 3571) = 1;
        *(unsigned char *)(v12 + 462) = 0;
        *(_OWORD *)(v12 + 552) = *(_OWORD *)(v12 + 576);
        *(void *)(v12 + 568) = *(void *)(v12 + 592);
        *(unsigned char *)(v13 + 442) = 1;
        break;
      case 5:
        *(unsigned char *)(*(void *)(this + 48) + 3571) = 0;
        break;
      case 6:
        uint64_t v15 = *(void *)(this + 48);
        uint64_t v14 = *(void *)(this + 56);
        *(unsigned char *)(v14 + 440) = 1;
        *(unsigned char *)(v15 + 462) = 1;
        *(_OWORD *)(v15 + 552) = *(_OWORD *)(v15 + 576);
        *(void *)(v15 + 568) = *(void *)(v15 + 592);
        *(unsigned char *)(v14 + 442) = 1;
        break;
      case 7:
        *(_WORD *)(this + 74) = 257;
        break;
      case 8:
        *(_WORD *)(this + 74) = 1;
        break;
      default:
        continue;
    }
  }
  uint64_t v16 = (void *)v9[1];
  float v17 = (unsigned __int16 *)v16[23];
  float v18 = (unsigned __int16 *)v16[24];
  if (v17 == v18)
  {
LABEL_29:
    float v21 = (unsigned __int16 *)v16[26];
    double v22 = (unsigned __int16 *)v16[27];
    if (v21 == v22)
    {
      if (*(unsigned char *)(this + 73) == 1) {
        goto LABEL_48;
      }
      *(unsigned char *)(this + 73) = 1;
      *(unsigned char *)(*(void *)(this + 48) + 3572) = 1;
    }
    else
    {
      unint64_t v24 = (unsigned __int16 *)v16[14];
      uint64_t v23 = (unsigned __int16 *)v16[15];
      do
      {
        uint64_t v27 = v24;
        if (v24 != v23)
        {
          uint64_t v27 = v24;
          while (*v27 != *v21)
          {
            v27 += 56;
            if (v27 == v23)
            {
              uint64_t v27 = v23;
              break;
            }
          }
        }
        int v25 = *((unsigned __int8 *)v27 + 9);
        ++v21;
        if (v25) {
          BOOL v26 = v21 == v22;
        }
        else {
          BOOL v26 = 1;
        }
      }
      while (!v26);
      int v28 = v25 != 0;
      if (*(unsigned __int8 *)(this + 73) == v28) {
        goto LABEL_48;
      }
      *(unsigned char *)(this + 73) = v28;
      *(unsigned char *)(*(void *)(this + 48) + 3572) = v28;
      if (!v25) {
        goto LABEL_48;
      }
    }
    *(unsigned char *)(*(void *)(this + 56) + 440) = 1;
    goto LABEL_48;
  }
  float v19 = (unsigned __int16 *)v16[15];
  while (1)
  {
    float v20 = (unsigned __int16 *)v16[14];
    if (v20 != v19)
    {
      float v20 = (unsigned __int16 *)v16[14];
      while (*v20 != *v17)
      {
        v20 += 56;
        if (v20 == v19)
        {
          float v20 = (unsigned __int16 *)v16[15];
          break;
        }
      }
    }
    if (!*((unsigned char *)v20 + 9)) {
      break;
    }
    if (++v17 == v18) {
      goto LABEL_29;
    }
  }
  if (*(unsigned char *)(this + 73))
  {
    *(unsigned char *)(this + 73) = 0;
    *(unsigned char *)(*(void *)(this + 48) + 3572) = 0;
  }
LABEL_48:
  int v29 = *(uint64_t **)(this + 8);
  for (unint64_t j = *(uint64_t **)(this + 16);
        v29 != j;
        this = (*(uint64_t (**)(uint64_t, const md::LayoutContext *, float))(*(void *)v31 + 24))(v31, a2, a3))
  {
    uint64_t v31 = *v29++;
  }
  return this;
}

void md::MuninLabeler::~MuninLabeler(md::MuninLabeler *this)
{
  *(void *)this = &unk_1EF531728;
  uint64_t v2 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *(void *)this = &unk_1EF536078;
  uint64_t v4 = *((void *)this + 1);
  if (v4)
  {
    *((void *)this + 2) = v4;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v4, *((void *)this + 3) - v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(void *)this = &unk_1EF531728;
  uint64_t v2 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *(void *)this = &unk_1EF536078;
  uint64_t v4 = *((void *)this + 1);
  if (v4)
  {
    *((void *)this + 2) = v4;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v4, *((void *)this + 3) - v4);
  }
}

uint64_t altitude::DtmCacheNode::getCacheKeyForKey@<X0>(uint64_t result@<X0>, _OWORD *a2@<X1>, uint64_t a3@<X8>)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  *(_OWORD *)a3 = *a2;
  *(_OWORD *)(a3 + 16) = v5;
  if (v4 != 17 && *(_DWORD *)(a3 + 16) >= 0xEu)
  {
    *(_DWORD *)(a3 + 16) = 14;
    *(uint32x2_t *)(a3 + 20) = vshl_u32(*(uint32x2_t *)(a3 + 20), (uint32x2_t)vneg_s32(vdup_n_s32(*((_DWORD *)a2 + 4) - 14)));
    int v7 = 16;
  }
  else
  {
    int v7 = 17;
    uint64_t result = altitude::GeoResourceManager::getTileIdWithDataForTileId(*(void *)(*(void *)(result + 160) + 32), (long long *)(a3 + 16), 17);
    *(void *)(a3 + 16) = result;
    *(void *)(a3 + 24) = v8;
  }
  *(_DWORD *)a3 = v7;
  return result;
}

void altitude::DtmCacheNode::fetchData(uint64_t a1@<X1>, uint64_t a2@<X2>, char **a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = *(void **)a1;
  int v7 = *(std::__shared_weak_count **)(a1 + 8);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (((*(uint64_t (**)(void *))(*v8 + 40))(v8) & 1) == 0)
  {
    *a4 = 0;
    a4[1] = 0;
    goto LABEL_15;
  }
  uint64_t v9 = v8[39];
  uint64_t v10 = v8[40];
  *a4 = v9;
  a4[1] = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  if (!v9
    || (uint64_t v12 = *(void *)(v9 + 136), v11 = *(void *)(v9 + 144), *(_DWORD *)(a2 + 48) == v12)
    && (*(_DWORD *)(a2 + 52) == HIDWORD(v12) ? (BOOL v13 = *(_DWORD *)(a2 + 56) == v11) : (BOOL v13 = 0), v13))
  {
LABEL_15:
    if (!v7) {
      return;
    }
    goto LABEL_16;
  }
  long long v14 = *(_OWORD *)(a2 + 32);
  uint64_t v16 = a3[1];
  unint64_t v15 = (unint64_t)a3[2];
  if ((unint64_t)v16 >= v15)
  {
    float v18 = *a3;
    uint64_t v19 = (v16 - *a3) >> 5;
    unint64_t v20 = v19 + 1;
    if ((unint64_t)(v19 + 1) >> 59) {
      abort();
    }
    long long v29 = v14;
    uint64_t v21 = v15 - (void)v18;
    if (v21 >> 4 > v20) {
      unint64_t v20 = v21 >> 4;
    }
    BOOL v22 = (unint64_t)v21 >= 0x7FFFFFFFFFFFFFE0;
    unint64_t v23 = 0x7FFFFFFFFFFFFFFLL;
    if (!v22) {
      unint64_t v23 = v20;
    }
    if (v23 >> 59) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v24 = 32 * v23;
    int v25 = (char *)operator new(32 * v23);
    BOOL v26 = &v25[32 * v19];
    *(_OWORD *)BOOL v26 = v29;
    uint64_t v27 = &v25[v24];
    *((void *)v26 + 2) = v12;
    *((void *)v26 + 3) = v11;
    float v17 = v26 + 32;
    if (v16 != v18)
    {
      do
      {
        long long v28 = *((_OWORD *)v16 - 2);
        v16 -= 32;
        *((_OWORD *)v26 - 2) = v28;
        v26 -= 32;
        *((_OWORD *)v26 + 1) = *((_OWORD *)v16 + 1);
      }
      while (v16 != v18);
      uint64_t v16 = *a3;
    }
    *a3 = v26;
    a3[1] = v17;
    a3[2] = v27;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v16 = v14;
    float v17 = v16 + 32;
    *((void *)v16 + 2) = v12;
    *((void *)v16 + 3) = v11;
  }
  a3[1] = v17;
  if (v7)
  {
LABEL_16:
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

uint64_t altitude::GenericCacheNode<altitude::TileKey,karo::media::DigitalTerrainModel>::hasValidKey()
{
  return 1;
}

uint64_t altitude::GenericCacheNode<altitude::TileKey,karo::media::DigitalTerrainModel>::clear(uint64_t a1)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 136));
  if (*(void *)(a1 + 120))
  {
    uint64_t v2 = *(void **)(a1 + 112);
    if (v2)
    {
      do
      {
        int v7 = (void *)*v2;
        uint64_t v8 = (std::__shared_weak_count *)v2[7];
        if (v8) {
          std::__shared_weak_count::__release_weak(v8);
        }
        operator delete(v2);
        uint64_t v2 = v7;
      }
      while (v7);
    }
    *(void *)(a1 + 112) = 0;
    uint64_t v3 = *(void *)(a1 + 104);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*(void *)(a1 + 96) + 8 * i) = 0;
    }
    *(void *)(a1 + 120) = 0;
  }
  long long v5 = *(pthread_mutex_t **)(a1 + 136);
  return pthread_mutex_unlock(v5);
}

BOOL altitude::DtmCacheNode::hasDataAvailable(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 144))(&v2);
  return v3 != 0;
}

void altitude::GenericCacheNode<altitude::TileKey,karo::media::DigitalTerrainModel>::requestCached(uint64_t a1@<X0>, _OWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, std::__shared_weak_count_vtbl **a5@<X8>)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1) & 1) == 0)
  {
    *a5 = 0;
    a5[1] = 0;
    a5[3] = 0;
    a5[4] = 0;
    a5[2] = (std::__shared_weak_count_vtbl *)off_1EF5677B0;
    return;
  }
  (*(void (**)(void **__return_ptr, uint64_t, _OWORD *))(*(void *)a1 + 144))(__p, a1, a2);
  long long v10 = a2[1];
  v59[0] = *a2;
  v59[1] = v10;
  long long v60 = *(_OWORD *)__p;
  long long v61 = v58;
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 136));
  int8x8_t v11 = *(int8x8_t *)(a1 + 104);
  if (!*(void *)&v11) {
    goto LABEL_41;
  }
  unint64_t v12 = ((unint64_t)v61 << 58) | ((unint64_t)(DWORD1(v61) & 0x1FFFFFFF) << 29) | DWORD2(v61) & 0x1FFFFFFF;
  uint8x8_t v13 = (uint8x8_t)vcnt_s8(v11);
  v13.i16[0] = vaddlv_u8(v13);
  if (v13.u32[0] > 1uLL)
  {
    unint64_t v14 = ((unint64_t)v61 << 58) | ((unint64_t)(DWORD1(v61) & 0x1FFFFFFF) << 29) | DWORD2(v61) & 0x1FFFFFFF;
    if (v12 >= *(void *)&v11) {
      unint64_t v14 = v12 % *(void *)&v11;
    }
  }
  else
  {
    unint64_t v14 = v12 & (*(void *)&v11 - 1);
  }
  unint64_t v15 = *(std::__shared_weak_count ***)(*(void *)(a1 + 96) + 8 * v14);
  if (!v15) {
    goto LABEL_41;
  }
  uint64_t v16 = *v15;
  if (!*v15)
  {
LABEL_42:
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 136));
    goto LABEL_43;
  }
  if (v13.u32[0] < 2uLL)
  {
    uint64_t v17 = *(void *)&v11 - 1;
    while (1)
    {
      uint64_t shared_owners = v16->__shared_owners_;
      if (shared_owners == v12)
      {
        if (LODWORD(v16[1].__shared_owners_) == v61
          && *(uint64_t *)((char *)&v16[1].__shared_owners_ + 4) == *(void *)((char *)&v61 + 4)
          && HIDWORD(v61) == HIDWORD(v16[1].__shared_weak_owners_)
          && LODWORD(v16->__shared_weak_owners_) == v60
          && *(uint64_t *)((char *)&v16->__shared_weak_owners_ + 4) == *(void *)((char *)&v60 + 4))
        {
          goto LABEL_31;
        }
      }
      else if ((shared_owners & v17) != v14)
      {
        goto LABEL_41;
      }
      uint64_t v16 = (std::__shared_weak_count *)v16->__vftable;
      if (!v16) {
        goto LABEL_42;
      }
    }
  }
  while (1)
  {
    unint64_t v18 = v16->__shared_owners_;
    if (v18 == v12) {
      break;
    }
    if (v18 >= *(void *)&v11) {
      v18 %= *(void *)&v11;
    }
    if (v18 != v14) {
      goto LABEL_41;
    }
LABEL_13:
    uint64_t v16 = (std::__shared_weak_count *)v16->__vftable;
    if (!v16) {
      goto LABEL_42;
    }
  }
  if (LODWORD(v16[1].__shared_owners_) != v61
    || *(uint64_t *)((char *)&v16[1].__shared_owners_ + 4) != *(void *)((char *)&v61 + 4)
    || HIDWORD(v61) != HIDWORD(v16[1].__shared_weak_owners_)
    || LODWORD(v16->__shared_weak_owners_) != v60
    || *(uint64_t *)((char *)&v16->__shared_weak_owners_ + 4) != *(void *)((char *)&v60 + 4))
  {
    goto LABEL_13;
  }
LABEL_31:
  if (((*(uint64_t (**)(uint64_t, long long *, uint64_t *))(*(void *)a1 + 128))(a1, &v60, &v16->__shared_weak_owners_) & 1) == 0)
  {
    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)__p, (void *)(a1 + 96), v16);
    BOOL v22 = __p[0];
    if (__p[0])
    {
      if ((_BYTE)v58)
      {
        unint64_t v23 = (std::__shared_weak_count *)*((void *)__p[0] + 7);
        if (v23) {
          std::__shared_weak_count::__release_weak(v23);
        }
      }
      operator delete(v22);
    }
    goto LABEL_41;
  }
  unint64_t v20 = (std::__shared_weak_count *)v16[2].__shared_owners_;
  if (!v20)
  {
LABEL_41:
    uint64_t v16 = 0;
    goto LABEL_42;
  }
  uint64_t v21 = v16[2].__vftable;
  atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = std::__shared_weak_count::lock(v20);
  std::__shared_weak_count::__release_weak(v20);
  if (!v16) {
    goto LABEL_42;
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 136));
  if (v21)
  {
    __p[1] = 0;
    *(void *)&long long v58 = 0;
    __p[0] = off_1EF5677B0;
    *a5 = v21;
    a5[1] = (std::__shared_weak_count_vtbl *)v16;
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    a5[3] = 0;
    a5[4] = 0;
    a5[2] = (std::__shared_weak_count_vtbl *)off_1EF5677B0;
    goto LABEL_92;
  }
LABEL_43:
  (*(void (**)(void (***__return_ptr)(karo::AsyncRequestManager::RequestHandle *__hidden), uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 80))(&v54, a1, v59, a3, a4, 300, 1, 0);
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v54) == 4)
  {
    float v51 = 0;
    BOOL v52 = 0;
    uint64_t v53 = 0;
    (*(void (**)(std::__shared_weak_count_vtbl **__return_ptr, uint64_t, std::__shared_weak_count_vtbl **, _OWORD *, void **))(*(void *)a1 + 136))(&v49, a1, &v55, v59, &v51);
    pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 136));
    uint64_t v24 = std::__hash_table<std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::__unordered_map_hasher<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::hash<altitude::TileKey>,std::equal_to<altitude::TileKey>,true>,std::__unordered_map_equal<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::equal_to<altitude::TileKey>,std::hash<altitude::TileKey>,true>,std::allocator<std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>>>::__emplace_unique_key_args<altitude::TileKey,std::piecewise_construct_t const&,std::tuple<altitude::TileKey const&>,std::tuple<>>((float *)(a1 + 96), (int *)&v60, &v60);
    BOOL v26 = v49;
    int v25 = v50;
    if (v50) {
      atomic_fetch_add_explicit(&v50->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v27 = (std::__shared_weak_count *)v24[7];
    v24[6] = v26;
    v24[7] = v25;
    if (v27) {
      std::__shared_weak_count::__release_weak(v27);
    }
    long long v28 = (int *)v51;
    if (v51 != v52)
    {
      do
      {
        long long v29 = std::__hash_table<std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::__unordered_map_hasher<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::hash<altitude::TileKey>,std::equal_to<altitude::TileKey>,true>,std::__unordered_map_equal<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::equal_to<altitude::TileKey>,std::hash<altitude::TileKey>,true>,std::allocator<std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>>>::__emplace_unique_key_args<altitude::TileKey,std::piecewise_construct_t const&,std::tuple<altitude::TileKey const&>,std::tuple<>>((float *)(a1 + 96), v28, v28);
        uint64_t v31 = v49;
        uint64_t v30 = v50;
        if (v50) {
          atomic_fetch_add_explicit(&v50->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        BOOL v32 = (std::__shared_weak_count *)v29[7];
        v29[6] = v31;
        v29[7] = v30;
        if (v32) {
          std::__shared_weak_count::__release_weak(v32);
        }
        v28 += 8;
      }
      while (v28 != v52);
    }
    unsigned int v35 = *(_DWORD *)(a1 + 144) + 1;
    *(_DWORD *)(a1 + 144) = v35;
    if (v35 > 0x14)
    {
      *(_DWORD *)(a1 + 144) = 0;
      for (uint64_t i = *(void **)(a1 + 112); i; uint64_t i = (void *)*i)
      {
        while (1)
        {
          uint64_t v37 = (std::__shared_weak_count *)i[7];
          if (!v37) {
            goto LABEL_71;
          }
          uint64_t v38 = std::__shared_weak_count::lock(v37);
          if (!v38) {
            goto LABEL_71;
          }
          uint64_t v39 = v38;
          uint64_t v40 = i[6];
          if (atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            break;
          }
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v39);
          if (v40) {
            goto LABEL_68;
          }
LABEL_71:
          float v41 = (void *)*i;
          std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)__p, (void *)(a1 + 96), i);
          uint64_t v42 = __p[0];
          if (__p[0])
          {
            if ((_BYTE)v58)
            {
              uint64_t v43 = (std::__shared_weak_count *)*((void *)__p[0] + 7);
              if (v43) {
                std::__shared_weak_count::__release_weak(v43);
              }
            }
            operator delete(v42);
          }
          uint64_t i = v41;
          if (!v41) {
            goto LABEL_75;
          }
        }
        if (!v40) {
          goto LABEL_71;
        }
LABEL_68:
        ;
      }
    }
LABEL_75:
    float v44 = v50;
    *a5 = v49;
    a5[1] = (std::__shared_weak_count_vtbl *)v44;
    if (v44) {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v45 = v55;
    unsigned int v46 = v56;
    a5[2] = (std::__shared_weak_count_vtbl *)off_1EF5677B0;
    a5[3] = v45;
    a5[4] = (std::__shared_weak_count_vtbl *)v46;
    if (v46)
    {
      atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v45 = a5[3];
    }
    if (v45) {
      atomic_fetch_add((atomic_uint *volatile)&v45[3].~__shared_weak_count_0, 1u);
    }
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 136));
    uint64_t v47 = v50;
    if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
    if (v51)
    {
      BOOL v52 = v51;
      operator delete(v51);
    }
  }
  else
  {
    *a5 = 0;
    a5[1] = 0;
    unsigned int v33 = v55;
    uint64_t v34 = v56;
    a5[2] = (std::__shared_weak_count_vtbl *)off_1EF5677B0;
    a5[3] = v33;
    a5[4] = (std::__shared_weak_count_vtbl *)v34;
    if (v34)
    {
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      unsigned int v33 = a5[3];
    }
    if (v33) {
      atomic_fetch_add((atomic_uint *volatile)&v33[3].~__shared_weak_count_0, 1u);
    }
  }
  uint64_t v54 = off_1EF5677B0;
  if (v55) {
    atomic_fetch_add((atomic_uint *volatile)&v55[3].~__shared_weak_count_0, 0xFFFFFFFF);
  }
  float v48 = v56;
  if (v56 && !atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
    std::__shared_weak_count::__release_weak(v48);
  }
  if (v16)
  {
LABEL_92:
    if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

void *std::__hash_table<std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::__unordered_map_hasher<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::hash<altitude::TileKey>,std::equal_to<altitude::TileKey>,true>,std::__unordered_map_equal<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::equal_to<altitude::TileKey>,std::hash<altitude::TileKey>,true>,std::allocator<std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>>>::__emplace_unique_key_args<altitude::TileKey,std::piecewise_construct_t const&,std::tuple<altitude::TileKey const&>,std::tuple<>>(float *a1, int *a2, _OWORD *a3)
{
  uint64_t v6 = a2[4];
  unsigned int v7 = a2[5];
  int v8 = a2[6];
  unint64_t v9 = (v6 << 58) | ((unint64_t)(v7 & 0x1FFFFFFF) << 29) | v8 & 0x1FFFFFFF;
  unint64_t v10 = *((void *)a1 + 1);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = (v6 << 58) | ((unint64_t)(v7 & 0x1FFFFFFF) << 29) | v8 & 0x1FFFFFFF;
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
    }
    else
    {
      unint64_t v3 = v9 & (v10 - 1);
    }
    unint64_t v12 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      uint8x8_t v13 = *v12;
      if (*v12)
      {
        int v14 = a2[7];
        int v15 = *a2;
        int v16 = a2[1];
        int v17 = a2[2];
        if (v11.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v19 = v13[1];
            if (v19 == v9)
            {
              if (v13[4] == __PAIR64__(v7, v6)
                && *((_DWORD *)v13 + 10) == v8
                && v14 == *((_DWORD *)v13 + 11)
                && *((_DWORD *)v13 + 4) == v15
                && *((_DWORD *)v13 + 5) == v16
                && *((_DWORD *)v13 + 6) == v17)
              {
                return v13;
              }
            }
            else if ((v19 & (v10 - 1)) != v3)
            {
              goto LABEL_33;
            }
            uint8x8_t v13 = (void *)*v13;
            if (!v13) {
              goto LABEL_33;
            }
          }
        }
        do
        {
          unint64_t v18 = v13[1];
          if (v18 == v9)
          {
            if (v13[4] == __PAIR64__(v7, v6)
              && *((_DWORD *)v13 + 10) == v8
              && v14 == *((_DWORD *)v13 + 11)
              && *((_DWORD *)v13 + 4) == v15
              && *((_DWORD *)v13 + 5) == v16
              && *((_DWORD *)v13 + 6) == v17)
            {
              return v13;
            }
          }
          else
          {
            if (v18 >= v10) {
              v18 %= v10;
            }
            if (v18 != v3) {
              break;
            }
          }
          uint8x8_t v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_33:
  uint8x8_t v13 = operator new(0x40uLL);
  *uint8x8_t v13 = 0;
  v13[1] = v9;
  long long v20 = a3[1];
  *((_OWORD *)v13 + 1) = *a3;
  *((_OWORD *)v13 + 2) = v20;
  v13[6] = 0;
  v13[7] = 0;
  float v21 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v22 = a1[8];
  if (!v10 || (float)(v22 * (float)v10) < v21)
  {
    BOOL v23 = 1;
    if (v10 >= 3) {
      BOOL v23 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v10);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v10 = *((void *)a1 + 1);
    }
    if (prime <= v10)
    {
      if (prime >= v10) {
        goto LABEL_70;
      }
      unint64_t v38 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v10 < 3 || (uint8x8_t v39 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v39.i16[0] = vaddlv_u8(v39), v39.u32[0] > 1uLL))
      {
        unint64_t v38 = std::__next_prime(v38);
      }
      else
      {
        uint64_t v40 = 1 << -(char)__clz(v38 - 1);
        if (v38 >= 2) {
          unint64_t v38 = v40;
        }
      }
      if (prime <= v38) {
        size_t prime = v38;
      }
      if (prime >= v10)
      {
        unint64_t v10 = *((void *)a1 + 1);
LABEL_70:
        if ((v10 & (v10 - 1)) != 0)
        {
          if (v9 >= v10) {
            unint64_t v3 = v9 % v10;
          }
          else {
            unint64_t v3 = v9;
          }
        }
        else
        {
          unint64_t v3 = (v10 - 1) & v9;
        }
        goto LABEL_83;
      }
      if (!prime)
      {
        float v48 = *(void **)a1;
        *(void *)a1 = 0;
        if (v48) {
          operator delete(v48);
        }
        unint64_t v10 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_70;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v27 = operator new(8 * prime);
    long long v28 = *(void **)a1;
    *(void *)a1 = v27;
    if (v28) {
      operator delete(v28);
    }
    uint64_t v29 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v29++) = 0;
    while (prime != v29);
    uint64_t v31 = (uint64_t *)(a1 + 4);
    uint64_t v30 = (void *)*((void *)a1 + 2);
    if (!v30)
    {
LABEL_69:
      unint64_t v10 = prime;
      goto LABEL_70;
    }
    size_t v32 = v30[1];
    size_t v33 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v34 = v32 & v33;
      *(void *)(*(void *)a1 + 8 * v34) = v31;
      for (uint64_t i = (void *)*v30; *v30; uint64_t i = (void *)*v30)
      {
        size_t v36 = i[1] & v33;
        if (v36 == v34)
        {
          uint64_t v30 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v36))
        {
          *uint64_t v30 = *i;
          uint64_t v37 = 8 * v36;
          *uint64_t i = **(void **)(*(void *)a1 + v37);
          **(void **)(*(void *)a1 + v37) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v36) = v30;
          uint64_t v30 = i;
          size_t v34 = v36;
        }
      }
      goto LABEL_69;
    }
    if (v32 >= prime) {
      v32 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v32) = v31;
    float v41 = (void *)*v30;
    if (!*v30) {
      goto LABEL_69;
    }
    while (1)
    {
      size_t v43 = v41[1];
      if (v43 >= prime) {
        v43 %= prime;
      }
      if (v43 != v32)
      {
        if (!*(void *)(*(void *)a1 + 8 * v43))
        {
          *(void *)(*(void *)a1 + 8 * v43) = v30;
          goto LABEL_74;
        }
        *uint64_t v30 = *v41;
        uint64_t v42 = 8 * v43;
        *float v41 = **(void **)(*(void *)a1 + v42);
        **(void **)(*(void *)a1 + v42) = v41;
        float v41 = v30;
      }
      size_t v43 = v32;
LABEL_74:
      uint64_t v30 = v41;
      float v41 = (void *)*v41;
      size_t v32 = v43;
      if (!v41) {
        goto LABEL_69;
      }
    }
  }
LABEL_83:
  float v44 = *(void **)a1;
  unint64_t v45 = *(void **)(*(void *)a1 + 8 * v3);
  if (v45)
  {
    *uint8x8_t v13 = *v45;
LABEL_91:
    void *v45 = v13;
    goto LABEL_92;
  }
  *uint8x8_t v13 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v13;
  v44[v3] = a1 + 4;
  if (*v13)
  {
    unint64_t v46 = *(void *)(*v13 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v46 >= v10) {
        v46 %= v10;
      }
    }
    else
    {
      v46 &= v10 - 1;
    }
    unint64_t v45 = (void *)(*(void *)a1 + 8 * v46);
    goto LABEL_91;
  }
LABEL_92:
  ++*((void *)a1 + 3);
  return v13;
}

void altitude::DtmCacheNode::createRequest()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t std::__shared_ptr_pointer<altitude::DtmCacheNodeJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::DtmCacheNodeJob>,std::allocator<altitude::DtmCacheNodeJob>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::DtmCacheNodeJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::DtmCacheNodeJob>,std::allocator<altitude::DtmCacheNodeJob>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t altitude::DtmCacheNodeJob::succeeded(altitude::DtmCacheNodeJob *this)
{
  return *((unsigned __int8 *)this + 225);
}

void altitude::DtmCacheNodeJob::jobStep(altitude::DtmCacheNodeJob *this)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (char *)this + 284;
  uint64_t v3 = *((void *)this + 39);
  if (v3) {
    goto LABEL_2;
  }
  uint64_t v59 = 0;
  long long v60 = 0;
  *(void *)buf = off_1EF5677B0;
  atomic_load((unsigned int *)this + 4);
  (*(void (**)(void *__return_ptr))(**((void **)this + 29) + 104))(&v45);
  if (v59) {
    atomic_fetch_add((atomic_uint *volatile)(v59 + 128), 0xFFFFFFFF);
  }
  uint64_t v15 = v46;
  int v16 = v47;
  if (v47) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v47 + 1, 1uLL, memory_order_relaxed);
  }
  int v17 = v60;
  uint64_t v59 = v15;
  long long v60 = (std::__shared_weak_count *)v16;
  if (v17)
  {
    if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
    uint64_t v15 = v59;
  }
  if (v15) {
    atomic_fetch_add((atomic_uint *volatile)(v15 + 128), 1u);
  }
  unint64_t v45 = off_1EF5677B0;
  if (v46) {
    atomic_fetch_add((atomic_uint *volatile)(v46 + 128), 0xFFFFFFFF);
  }
  unint64_t v18 = (std::__shared_weak_count *)v47;
  if (v47 && !atomic_fetch_add((atomic_ullong *volatile)v47 + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)buf) == 4)
  {
    uint64_t v19 = (pthread_mutex_t **)*((void *)this + 29);
    pthread_mutex_lock(v19[5]);
    (*(void (**)(void (***__return_ptr)(karo::AsyncRequestManager::RequestHandle *__hidden), pthread_mutex_t **, char *, void))&(*v19)[1].__opaque[24])(&v45, v19, (char *)this + 280, 0);
    float v21 = v45;
    long long v20 = (std::__shared_weak_count *)v46;
    if (v46) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v46 + 8), 1uLL, memory_order_relaxed);
    }
    if ((*((uint64_t (**)(void))*v21 + 5))(v21))
    {
      (*((void (**)(long long *__return_ptr, void (**)(karo::AsyncRequestManager::RequestHandle *__hidden)))*v21
       + 6))(&v50, v21);
      if (!v20)
      {
LABEL_44:
        BOOL v23 = (std::__shared_weak_count *)v46;
        if (v46 && !atomic_fetch_add((atomic_ullong *volatile)(v46 + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
        pthread_mutex_unlock(v19[5]);
        long long v24 = v50;
        long long v50 = 0uLL;
        unint64_t v25 = (std::__shared_weak_count *)*((void *)this + 40);
        *(_OWORD *)(v2 + 28) = v24;
        if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
        BOOL v26 = (std::__shared_weak_count *)*((void *)&v50 + 1);
        if (*((void *)&v50 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v50 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
        goto LABEL_106;
      }
    }
    else
    {
      long long v50 = 0uLL;
      if (!v20) {
        goto LABEL_44;
      }
    }
    if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
    goto LABEL_44;
  }
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)buf))
  {
    float v22 = v60;
    v43[0] = v59;
    v43[1] = v60;
    if (v60)
    {
      atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::Job::addBlockingSubJob((uint64_t *)this, v43, -1, 0);
      if (!atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    else
    {
      karo::Job::addBlockingSubJob((uint64_t *)this, v43, -1, 0);
    }
LABEL_112:
    *(void *)buf = off_1EF5677B0;
    if (v59) {
      atomic_fetch_add((atomic_uint *volatile)(v59 + 128), 0xFFFFFFFF);
    }
    float v41 = v60;
    if (v60 && !atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
    return;
  }
  uint64_t v27 = (char *)this + 248;
  if (*((_DWORD *)this + 70) != 16) {
    uint64_t v27 = (char *)this + 280;
  }
  long long v28 = *((_OWORD *)v27 + 1);
  long long v50 = *(_OWORD *)v27;
  long long v51 = v28;
  LODWORD(v50) = 17;
  atomic_load((unsigned int *)this + 4);
  (*(void (**)(void *__return_ptr))(**((void **)this + 30) + 104))(&v45);
  uint64_t v29 = v45;
  if (v45)
  {
    uint64_t v30 = v46;
    if (v46) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v46 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v31 = (std::__shared_weak_count *)*((void *)this + 40);
    *((void *)this + 39) = v29;
    *((void *)this + 40) = v30;
    if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
LABEL_71:
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  else if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v47))
  {
    uint64_t v31 = v49;
    v44[0] = v48;
    v44[1] = v49;
    if (v49)
    {
      atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::Job::addBlockingSubJob((uint64_t *)this, v44, -1, 0);
      if (atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_97;
      }
      goto LABEL_71;
    }
    karo::Job::addBlockingSubJob((uint64_t *)this, v44, -1, 0);
  }
  else
  {
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    size_t v34 = GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)BOOL v52 = 67109632;
      int v53 = DWORD1(v51);
      __int16 v54 = 1024;
      int v55 = DWORD2(v51);
      __int16 v56 = 1024;
      int v57 = v51;
      _os_log_impl(&dword_1A1780000, v34, OS_LOG_TYPE_ERROR, "Failed to get fallback dtm with key %u %u %u", v52, 0x14u);
    }
    (*(void (**)(altitude::DtmCacheNodeJob *))(*(void *)this + 16))(this);
  }
LABEL_97:
  uint64_t v47 = off_1EF5677B0;
  if (v48) {
    atomic_fetch_add((atomic_uint *volatile)(v48 + 128), 0xFFFFFFFF);
  }
  unint64_t v38 = v49;
  if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
    std::__shared_weak_count::__release_weak(v38);
  }
  uint8x8_t v39 = (std::__shared_weak_count *)v46;
  if (v46 && !atomic_fetch_add((atomic_ullong *volatile)(v46 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
    std::__shared_weak_count::__release_weak(v39);
  }
  if (!v29) {
    goto LABEL_112;
  }
LABEL_106:
  *(void *)buf = off_1EF5677B0;
  if (v59) {
    atomic_fetch_add((atomic_uint *volatile)(v59 + 128), 0xFFFFFFFF);
  }
  uint64_t v40 = v60;
  if (v60 && !atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
    uint64_t v3 = *(void *)(v2 + 28);
    if (!v3) {
      return;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 + 28);
    if (!v3) {
      return;
    }
  }
LABEL_2:
  if (*((_DWORD *)this + 70) == 17 || !*(unsigned char *)(v3 + 156)) {
    goto LABEL_94;
  }
  uint64_t v5 = *(void *)(v3 + 160);
  long long v4 = *(std::__shared_weak_count **)(v3 + 168);
  if (!v4
    || (atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed),
        atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
  {
    if (!v5) {
      goto LABEL_7;
    }
LABEL_94:
    pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
    BOOL v37 = (*((_DWORD *)this + 40) & 2) == 0;
    pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
    *((unsigned char *)this + 225) = v37;
    pthread_mutex_lock(*((pthread_mutex_t **)this + 19));
    *((_DWORD *)this + 40) |= 1u;
    pthread_mutex_unlock(*((pthread_mutex_t **)this + 19));
    return;
  }
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  if (v5) {
    goto LABEL_94;
  }
LABEL_7:
  int v6 = *((_DWORD *)v2 + 2);
  *(void *)((char *)&v50 + 4) = *(void *)v2;
  long long v51 = *(_OWORD *)((char *)this + 296);
  uint64_t v7 = *((void *)this + 39);
  uint64_t v9 = *(void *)(v7 + 136);
  uint64_t v8 = *(void *)(v7 + 144);
  HIDWORD(v50) = v6;
  *(void *)&long long v51 = v9;
  DWORD2(v51) = v8;
  LODWORD(v50) = 17;
  atomic_load((unsigned int *)this + 4);
  (*(void (**)(void *__return_ptr))(**((void **)this + 30) + 104))(&v45);
  unint64_t v10 = v45;
  if (v45)
  {
    uint64_t v11 = *(void *)(v2 + 28);
    unint64_t v12 = (std::__shared_weak_count *)v46;
    if (v46)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v46 + 8), 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint8x8_t v13 = *(std::__shared_weak_count **)(v11 + 168);
    *(void *)(v11 + 160) = v10;
    *(void *)(v11 + 168) = v12;
    if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
      int v14 = 1;
    }
    else
    {
      int v14 = 1;
    }
  }
  else if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v47))
  {
    size_t v32 = v49;
    v42[0] = v48;
    v42[1] = v49;
    if (v49)
    {
      atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::Job::addBlockingSubJob((uint64_t *)this, v42, -1, 0);
      int v14 = 0;
      if (atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_85;
      }
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
    else
    {
      karo::Job::addBlockingSubJob((uint64_t *)this, v42, -1, 0);
    }
    int v14 = 0;
  }
  else
  {
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    size_t v33 = GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKDefaultLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = DWORD1(v51);
      LOWORD(v59) = 1024;
      *(_DWORD *)((char *)&v59 + 2) = DWORD2(v51);
      HIWORD(v59) = 1024;
      LODWORD(v60) = v51;
      _os_log_impl(&dword_1A1780000, v33, OS_LOG_TYPE_ERROR, "Failed to get invalide value fallback dtm with key %u %u %u", buf, 0x14u);
    }
    (*(void (**)(altitude::DtmCacheNodeJob *))(*(void *)this + 16))(this);
    int v14 = 1;
  }
LABEL_85:
  uint64_t v47 = off_1EF5677B0;
  if (v48) {
    atomic_fetch_add((atomic_uint *volatile)(v48 + 128), 0xFFFFFFFF);
  }
  unsigned int v35 = v49;
  if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
  size_t v36 = (std::__shared_weak_count *)v46;
  if (v46)
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(v46 + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  if (v14) {
    goto LABEL_94;
  }
}

void altitude::DtmCacheNodeJob::~DtmCacheNodeJob(altitude::DtmCacheNodeJob *this)
{
  altitude::DtmCacheNodeJob::~DtmCacheNodeJob(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF569028;
  uint64_t v2 = (void *)*((void *)this + 41);
  if (v2)
  {
    *((void *)this + 42) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 40);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  *(void *)this = &unk_1EF56A2A8;
  if (*((char *)this + 223) < 0) {
    operator delete(*((void **)this + 25));
  }
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 24));
  long long v4 = *((void *)this + 24);
  if (v4) {
    MEMORY[0x1A6239270](v4, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 24) = 0;
  karo::Job::~Job(this);
}

void altitude::DtmCacheNode::~DtmCacheNode(altitude::DtmCacheNode *this)
{
  altitude::GenericCacheNode<altitude::TileKey,karo::media::DigitalTerrainModel>::~GenericCacheNode(this);
  JUMPOUT(0x1A6239270);
}

void altitude::GenericCacheNode<altitude::TileKey,karo::media::DigitalTerrainModel>::~GenericCacheNode(karo::AsyncRequestManager *a1)
{
  *(void *)a1 = &unk_1EF569358;
  pthread_mutex_destroy(*((pthread_mutex_t **)a1 + 17));
  uint64_t v2 = *((void *)a1 + 17);
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40FA0F61DDLL);
  }
  *((void *)a1 + 17) = 0;
  uint64_t v3 = (void *)*((void *)a1 + 14);
  if (v3)
  {
    do
    {
      uint64_t v5 = (void *)*v3;
      int v6 = (std::__shared_weak_count *)v3[7];
      if (v6) {
        std::__shared_weak_count::__release_weak(v6);
      }
      operator delete(v3);
      uint64_t v3 = v5;
    }
    while (v5);
  }
  long long v4 = (void *)*((void *)a1 + 12);
  *((void *)a1 + 12) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)a1 = &unk_1EF567B80;
  while (*((void *)a1 + 10))
    (*(void (**)(karo::AsyncRequestManager *, uint64_t))(*(void *)a1 + 48))(a1, *((void *)a1 + 8) + 32);
  std::__tree<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::TileKey>,std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::TileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)a1 + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(a1);
}

__n128 altitude::GenericCacheNode<altitude::TileKey,karo::media::DigitalTerrainModel>::getCacheKeyForKey@<Q0>(uint64_t a1@<X1>, _OWORD *a2@<X8>)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v3;
  return result;
}

void md::BuildingTileDataRenderable::~BuildingTileDataRenderable(id *this)
{
  md::BuildingTileDataRenderable::~BuildingTileDataRenderable(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t vars8;

  *this = &unk_1EF513B20;
  [this[53] stop];
  [this[56] stop];
  uint64_t v2 = (std::__shared_weak_count *)this[63];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  long long v3 = (std::__shared_weak_count *)this[61];
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  long long v4 = (std::__shared_weak_count *)this[59];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  this[55] = &unk_1EF5593D8;

  this[52] = &unk_1EF5593D8;
  *this = &unk_1EF513608;
  uint64_t v5 = (std::__shared_weak_count *)this[49];
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  md::BaseMapTileDataRenderable::~BaseMapTileDataRenderable((md::BaseMapTileDataRenderable *)this);
}

void sub_1A20C9664(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 496);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 480);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 464);
  *(void *)(v1 + 440) = &unk_1EF5593D8;

  *(void *)(v1 + 416) = &unk_1EF5593D8;
  md::MapTileDataRenderable<md::BuildingTileData>::~MapTileDataRenderable((md::BaseMapTileDataRenderable *)v1);
  _Unwind_Resume(a1);
}

void md::MapTileDataRenderable<md::BuildingTileData>::~MapTileDataRenderable(md::BaseMapTileDataRenderable *this)
{
  *(void *)this = &unk_1EF513608;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 49);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::BaseMapTileDataRenderable::~BaseMapTileDataRenderable(this);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF513608;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 49);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::BaseMapTileDataRenderable::~BaseMapTileDataRenderable(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF513608;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 49);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::BaseMapTileDataRenderable::~BaseMapTileDataRenderable(this);
}

void md::LabelTransitRoute::LabelTransitRoute(md::LabelTransitRoute *this, GEOComposedRoute *a2, int a3)
{
  v269[16] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2;
  *(void *)this = &unk_1EF5595D8;
  *((void *)this + 1) = 0;
  int v6 = v5;
  *(void *)((char *)this + 52) = 0;
  uint64_t v7 = (_DWORD *)((char *)this + 52);
  double v249 = v6;
  *((void *)this + 3) = &unk_1EF559678;
  *((void *)this + 4) = v6;
  *((_DWORD *)this + 12) = a3;
  *(void *)((char *)this + 60) = 0;
  *(void *)((char *)this + 68) = 0;
  *((_DWORD *)this + 19) = 0;
  {
    operator new();
  }
  uint64_t v8 = mdm::Allocator::instance(void)::alloc;
  *((void *)this + 11) = 0;
  *((void *)this + 10) = v8;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  {
    operator new();
  }
  uint64_t v9 = mdm::Allocator::instance(void)::alloc;
  *((void *)this + 20) = 0;
  *((_DWORD *)this + 32) = -1;
  *((void *)this + 14) = v9;
  *((void *)this + 15) = -1;
  *((void *)this + 17) = 0;
  *((_DWORD *)this + 36) = -1;
  {
    operator new();
  }
  *((void *)this + 21) = mdm::Allocator::instance(void)::alloc;
  *((void *)this + 22) = 0;
  *((void *)this + 19) = (char *)this + 160;
  *(_OWORD *)((char *)this + 184) = xmmword_1A28FCCC0;
  *((void *)this + 25) = 0x3EB0C6F7A0B5ED8DLL;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((void *)this + 32) = 0;
  {
    operator new();
  }
  *((void *)this + 33) = mdm::Allocator::instance(void)::alloc;
  *((void *)this + 34) = 0;
  *((void *)this + 35) = 0;
  *((void *)this + 36) = 0;
  {
    operator new();
  }
  *((void *)this + 37) = mdm::Allocator::instance(void)::alloc;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  {
    operator new();
  }
  *((void *)this + 42) = mdm::Allocator::instance(void)::alloc;
  uint64_t v254 = this;
  id v10 = *((id *)this + 4);
  *uint64_t v7 = [v10 pointCount];

  if (*v7)
  {
    [*((id *)this + 4) pointAt:0];
    double v12 = v11;
    long double v13 = cos(v11 * 0.034906585) * -559.82 + 111132.92;
    long double v14 = v13 + cos(v12 * 0.0698131701) * 1.175;
    long double v15 = v14 + cos(v12 * 0.104719755) * -0.0023;
    double v16 = v12 * 0.00872664626;
    long double v17 = tan(v12 * 0.00872664626 + 0.78103484);
    double v18 = log(v17);
    long double v19 = tan(v16 + 0.789761487);
    double v20 = fabs((log(v19) - v18) * 0.159154943) / v15;
    float64x2_t v21 = vmulq_n_f64((float64x2_t)xmmword_1A28FE2A0, v20);
    *(float64x2_t *)((char *)this + 184) = vmulq_f64(v21, v21);
    float64x2_t v22 = vmulq_n_f64((float64x2_t)xmmword_1A28FE2B0, v20);
    *((float64x2_t *)this + 14) = vmulq_f64(v22, v22);
    float64x2_t v23 = vmulq_n_f64((float64x2_t)xmmword_1A28FE2C0, v20);
    *((void *)this + 27) = *(_OWORD *)&vmulq_f64(v23, v23);
    *(float64x2_t *)((char *)this + 200) = v23;
  }
  id v24 = *((id *)this + 4);
  unint64_t v25 = objc_msgSend(v24, "segments", &unk_1EF5595D8, (char *)this + 160, &unk_1EF559678, v249, (char *)this + 304, (char *)this + 272);
  unint64_t v26 = [v25 count];
  unint64_t v27 = v26;
  long long v28 = this;
  uint64_t v29 = *((void *)this + 7);
  if (v26 <= (*((void *)v254 + 9) - v29) >> 3) {
    goto LABEL_30;
  }
  if (v26 >> 61) {
    abort();
  }
  uint64_t v30 = *((void *)v254 + 8);
  uint64_t v31 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**((void **)v254 + 10) + 16))(*((void *)v254 + 10), 8 * v26, 8);
  uint64_t v32 = v30 - v29;
  unint64_t v33 = v31 + ((v30 - v29) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v34 = v31 + 8 * v27;
  unsigned int v35 = (char *)*((void *)v254 + 7);
  size_t v36 = (char *)*((void *)v254 + 8);
  if (v36 == v35)
  {
    *((void *)v254 + 7) = v33;
    *((void *)v254 + 8) = v33;
    uint64_t v39 = *((void *)v254 + 9);
    *((void *)v254 + 9) = v34;
LABEL_28:
    long long v28 = v254;
    if (v36) {
      (*(void (**)(void, char *, uint64_t))(**((void **)v254 + 10) + 40))(*((void *)v254 + 10), v36, v39 - (void)v36);
    }
LABEL_30:

    long long v265 = 0u;
    long long v266 = 0u;
    long long v263 = 0u;
    long long v264 = 0u;
    long long v51 = [*((id *)v28 + 4) segments];
    uint64_t v52 = [v51 countByEnumeratingWithState:&v263 objects:v269 count:16];
    if (!v52) {
      goto LABEL_80;
    }
    int v53 = 0;
    uint64_t v54 = *(void *)v264;
    id obj = v51;
    while (1)
    {
      for (uint64_t i = 0; i != v52; ++i)
      {
        if (*(void *)v264 != v54) {
          objc_enumerationMutation(obj);
        }
        __int16 v56 = *(void **)(*((void *)&v263 + 1) + 8 * i);
        int v57 = (char *)operator new(0x50uLL);
        *(void *)int v57 = 1;
        *(_OWORD *)(v57 + 40) = 0u;
        *(_OWORD *)(v57 + 56) = 0u;
        *(_OWORD *)(v57 + 24) = 0u;
        *((void *)v57 + 9) = 0;
        *((void *)v57 + 1) = &unk_1EF559A58;
        *((void *)v57 + 2) = 0;
        *(void *)(v57 + 44) = 0;
        *(void *)(v57 + 52) = 0;
        *(void *)(v57 + 60) = 0;
        *(void *)&long long v268 = v57;
        id v58 = v56;
        uint64_t v59 = v58;
        if (v58) {
          id v60 = v58;
        }
        uint64_t v61 = (void *)*((void *)v57 + 2);
        *((void *)v57 + 2) = v59;

        *((_DWORD *)v57 + 8) = v53;
        float v62 = (void *)*((void *)v254 + 8);
        unint64_t v63 = *((void *)v254 + 9);
        if ((unint64_t)v62 < v63)
        {
          if (v62)
          {
            void *v62 = v57;
            ++*(void *)v57;
          }
          unsigned int v64 = v62 + 1;
          goto LABEL_68;
        }
        uint64_t v65 = *((void *)v254 + 7);
        uint64_t v66 = ((uint64_t)v62 - v65) >> 3;
        unint64_t v67 = v66 + 1;
        if ((unint64_t)(v66 + 1) >> 61) {
          abort();
        }
        uint64_t v68 = v63 - v65;
        if (v68 >> 2 > v67) {
          unint64_t v67 = v68 >> 2;
        }
        if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v69 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v69 = v67;
        }
        if (v69)
        {
          uint64_t v70 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v254 + 10) + 16))(*((void *)v254 + 10), 8 * v69, 8);
          float v71 = (void *)(v70 + 8 * v66);
          uint64_t v72 = v70 + 8 * v69;
          if (v70)
          {
            *float v71 = v57;
            ++*(void *)v57;
          }
        }
        else
        {
          uint64_t v72 = 0;
          float v71 = (void *)(8 * v66);
        }
        unsigned int v64 = v71 + 1;
        BOOL v73 = (char *)*((void *)v254 + 7);
        float v74 = (char *)*((void *)v254 + 8);
        if (v74 != v73)
        {
          unint64_t v75 = v74 - v73 - 8;
          if (v75 <= 0x47
            || (unint64_t v76 = (v73 - v74 + 7) & 0xFFFFFFFFFFFFFFF8, (char *)v71 + v76 < v74) && &v74[v76] < (char *)v71)
          {
            float v77 = (char *)*((void *)v254 + 8);
            goto LABEL_57;
          }
          uint64_t v88 = (v75 >> 3) + 1;
          float v77 = &v74[-8 * (v88 & 0x3FFFFFFFFFFFFFFCLL)];
          int v89 = v71 - 4;
          unint64_t v90 = v74 - 32;
          uint64_t v91 = v88 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            *int v89 = 0uLL;
            v89[1] = 0uLL;
            long long v92 = *((_OWORD *)v90 + 1);
            *int v89 = *(_OWORD *)v90;
            v89[1] = v92;
            v89 -= 2;
            *(_OWORD *)unint64_t v90 = 0uLL;
            *((_OWORD *)v90 + 1) = 0uLL;
            v90 -= 32;
            v91 -= 4;
          }
          while (v91);
          v71 -= v88 & 0x3FFFFFFFFFFFFFFCLL;
          if (v88 != (v88 & 0x3FFFFFFFFFFFFFFCLL))
          {
            do
            {
LABEL_57:
              *--float v71 = 0;
              uint64_t v78 = *((void *)v77 - 1);
              v77 -= 8;
              *float v71 = v78;
              *(void *)float v77 = 0;
            }
            while (v77 != v73);
          }
          float v74 = (char *)*((void *)v254 + 7);
          unsigned int v79 = (char *)*((void *)v254 + 8);
          *((void *)v254 + 7) = v71;
          *((void *)v254 + 8) = v64;
          uint64_t v80 = *((void *)v254 + 9);
          *((void *)v254 + 9) = v72;
          if (v79 != v74)
          {
            BOOL v81 = v79;
            do
            {
              uint64_t v83 = *((void *)v81 - 1);
              v81 -= 8;
              uint64_t v82 = v83;
              if (v83)
              {
                _ZF = (*(void *)v82)-- == 1;
                if (_ZF)
                {
                  *(void *)(v82 + 8) = &unk_1EF559A58;

                  operator delete(*((void **)v79 - 1));
                  *((void *)v79 - 1) = 0;
                }
              }
              unsigned int v79 = v81;
            }
            while (v81 != v74);
          }
          goto LABEL_66;
        }
        *((void *)v254 + 7) = v71;
        *((void *)v254 + 8) = v64;
        uint64_t v80 = *((void *)v254 + 9);
        *((void *)v254 + 9) = v72;
LABEL_66:
        if (v74) {
          (*(void (**)(void, char *, uint64_t))(**((void **)v254 + 10) + 40))(*((void *)v254 + 10), v74, v80 - (void)v74);
        }
LABEL_68:
        *((void *)v254 + 8) = v64;
        int v84 = [v59 pointRange];
        unsigned int v85 = (void *)v268;
        if ((void)v268) {
          uint64_t v86 = v268 + 8;
        }
        else {
          uint64_t v86 = 0;
        }
        *(_DWORD *)(v86 + 44) = v84;
        [v59 pointRange];
        *(_DWORD *)(v86 + 48) = v87;
        if (v85)
        {
          _ZF = (*(void *)v85)-- == 1;
          if (_ZF)
          {
            *((void *)v85 + 1) = &unk_1EF559A58;

            operator delete(v85);
          }
        }
        ++v53;
      }
      long long v51 = obj;
      uint64_t v52 = [obj countByEnumeratingWithState:&v263 objects:v269 count:16];
      if (!v52)
      {
LABEL_80:

        long long v93 = (uint64_t *)*((void *)v254 + 7);
        float32x4_t v94 = (uint64_t *)*((void *)v254 + 8);
        while (v93 != v94)
        {
          if (*v93) {
            uint64_t v96 = *v93 + 8;
          }
          else {
            uint64_t v96 = 0;
          }
          id v97 = *(id *)(v96 + 8);
          BOOL v98 = [v97 type] == 5;

          uint64_t v99 = *v93;
          uint64_t v100 = *v93 + 8;
          if (!*v93) {
            uint64_t v100 = 0;
          }
          if (!v98)
          {
            id v108 = *(id *)(v100 + 8);
            BOOL v109 = [v108 type] == 6;

            if (!v109) {
              goto LABEL_86;
            }
            long long v257 = 0u;
            long long v258 = 0u;
            long long v255 = 0u;
            long long v256 = 0u;
            if (*v93) {
              uint64_t v110 = *v93 + 8;
            }
            else {
              uint64_t v110 = 0;
            }
            id v111 = *(id *)(v110 + 8);
            uint64_t v112 = [v111 steps];

            uint64_t v113 = [v112 countByEnumeratingWithState:&v255 objects:&v267 count:16];
            if (!v113)
            {
LABEL_118:

              goto LABEL_86;
            }
            uint64_t v114 = *(void *)v256;
LABEL_112:
            uint64_t v115 = 0;
            while (1)
            {
              if (*(void *)v256 != v114) {
                objc_enumerationMutation(v112);
              }
              float v116 = [*(id *)(*((void *)&v255 + 1) + 8 * v115) transitStep];
              BOOL v117 = [v116 maneuverType] == 3;

              if (v117) {
                break;
              }
              if (v113 == ++v115)
              {
                uint64_t v113 = [v112 countByEnumeratingWithState:&v255 objects:&v267 count:16];
                if (!v113) {
                  goto LABEL_118;
                }
                goto LABEL_112;
              }
            }
            if (*v93) {
              uint64_t v95 = *v93 + 8;
            }
            else {
              uint64_t v95 = 0;
            }
            *(unsigned char *)(v95 + 70) = 1;

            goto LABEL_86;
          }
          if (*(int *)(v100 + 48) >= 2)
          {
            long long v261 = 0u;
            long long v262 = 0u;
            long long v259 = 0u;
            long long v260 = 0u;
            if (*v93) {
              uint64_t v101 = *v93 + 8;
            }
            else {
              uint64_t v101 = 0;
            }
            id v102 = *(id *)(v101 + 8);
            BOOL v103 = [v102 steps];

            uint64_t v104 = [v103 countByEnumeratingWithState:&v259 objects:&v268 count:16];
            if (v104)
            {
              uint64_t v105 = *(void *)v260;
              do
              {
                for (uint64_t j = 0; j != v104; ++j)
                {
                  if (*(void *)v260 != v105) {
                    objc_enumerationMutation(v103);
                  }
                  uint64_t v107 = [*(id *)(*((void *)&v259 + 1) + 8 * j) transitStep];
                  if ([v107 maneuverType] == 7)
                  {
                    if (*v93) {
                      uint64_t v118 = *v93 + 8;
                    }
                    else {
                      uint64_t v118 = 0;
                    }
                    *(unsigned char *)(v118 + 69) = 1;

                    goto LABEL_123;
                  }
                }
                uint64_t v104 = [v103 countByEnumeratingWithState:&v259 objects:&v268 count:16];
              }
              while (v104);
            }
LABEL_123:

            uint64_t v99 = *v93;
          }
          if (v99) {
            uint64_t v119 = v99 + 8;
          }
          else {
            uint64_t v119 = 0;
          }
          if (*(unsigned char *)(v119 + 69))
          {
            int v120 = *(_DWORD *)(v119 + 48);
            _CF = v120 != 0;
            int v121 = v120 - 1;
            if (!_CF) {
              int v121 = 0;
            }
            int v122 = *(_DWORD *)(v119 + 44) + v121;
            int v123 = *(_DWORD *)(v119 + 24);
          }
          else
          {
            int v123 = *(_DWORD *)(v119 + 24);
            if (v123)
            {
              uint64_t v124 = *(void *)(*((void *)v254 + 7) + 8 * (v123 - 1));
              if (v124) {
                uint64_t v125 = v124 + 8;
              }
              else {
                uint64_t v125 = 0;
              }
              uint64_t v128 = v125 + 44;
              int v126 = *(_DWORD *)(v125 + 44);
              int v127 = *(_DWORD *)(v128 + 4);
              _CF = v127 != 0;
              int v129 = v127 - 1;
              if (!_CF) {
                int v129 = 0;
              }
              int v122 = v126 + v129;
            }
            else
            {
              int v122 = -1;
            }
            uint64_t v130 = v119;
            if (*(int *)(v119 + 48) >= 2) {
              goto LABEL_143;
            }
          }
          unint64_t v131 = v123 + 1;
          uint64_t v132 = *((void *)v254 + 7);
          if (v131 < (*((void *)v254 + 8) - v132) >> 3)
          {
            uint64_t v133 = *(void *)(v132 + 8 * v131);
            uint64_t v130 = v133 + 8;
            if (!v133) {
              uint64_t v130 = 0;
            }
LABEL_143:
            int v134 = *(_DWORD *)(v130 + 44);
            goto LABEL_145;
          }
          int v134 = -1;
LABEL_145:
          _ZF = v122 == -1 && v134 == -1;
          if (!_ZF)
          {
            if (v122 == v134) {
              int v136 = 2;
            }
            else {
              int v136 = 1;
            }
            *(_DWORD *)(v119 + 56) = v136;
            if (v122 == -1)
            {
              *(_DWORD *)(v119 + 52) = v134;
              int v137 = v134 - v136;
            }
            else
            {
              *(_DWORD *)(v119 + 52) = v122;
              int v137 = v122 - v136 + 1;
            }
            *(_DWORD *)(v119 + 64) = v137;
          }
LABEL_86:
          ++v93;
        }
        {
          operator new();
        }
        uint64_t v250 = mdm::Allocator::instance(void)::alloc;
        uint64_t v138 = (void *)*((void *)v254 + 7);
        uint64_t v139 = (void *)*((void *)v254 + 8);
        if (v138 == v139)
        {
          LODWORD(v144) = 0;
          uint64_t v141 = 0;
          uint64_t v142 = 0;
          unint64_t v143 = 0;
          goto LABEL_204;
        }
        uint64_t v140 = 0;
        uint64_t v141 = 0;
        uint64_t v142 = 0;
        unint64_t v143 = 0;
        while (2)
        {
          uint64_t v146 = *v138 + 8;
          if (*v138) {
            uint64_t v147 = *v138 + 8;
          }
          else {
            uint64_t v147 = 0;
          }
          if (*(_DWORD *)(v147 + 56))
          {
            if ((unint64_t)v142 < v143)
            {
              if (v142) {
                *(void *)uint64_t v142 = *(void *)(v147 + 52);
              }
              v142 += 8;
              goto LABEL_189;
            }
            uint64_t v148 = (v142 - v141) >> 3;
            unint64_t v149 = v148 + 1;
            if ((unint64_t)(v148 + 1) >> 61) {
              abort();
            }
            unint64_t v150 = v143 - (void)v141;
            if ((uint64_t)(v143 - (void)v141) >> 2 > v149) {
              unint64_t v149 = (uint64_t)(v143 - (void)v141) >> 2;
            }
            if (v150 >= 0x7FFFFFFFFFFFFFF8) {
              uint64_t v151 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v151 = v149;
            }
            if (v151)
            {
              uint64_t v152 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v250 + 16))(v250, 8 * v151, 4);
              int v153 = (char *)(v152 + 8 * v148);
              unint64_t v143 = v152 + 8 * v151;
              if (v152) {
                *(void *)int v153 = *(void *)(v147 + 52);
              }
            }
            else
            {
              unint64_t v143 = 0;
              int v153 = (char *)(8 * v148);
            }
            int v154 = v153;
            if (v142 != v141)
            {
              unint64_t v155 = v142 - v141 - 8;
              if (v155 < 0x138
                || &v153[-(v155 & 0xFFFFFFFFFFFFFFF8) - 8] > v153 - 8
                || &v142[-(v155 & 0xFFFFFFFFFFFFFFF8) - 8] > v142 - 8
                || (unint64_t)(v142 - v153) < 0x20)
              {
                unsigned int v156 = v142;
                int v154 = v153;
              }
              else
              {
                uint64_t v159 = (v155 >> 3) + 1;
                unsigned int v156 = &v142[-8 * (v159 & 0x3FFFFFFFFFFFFFFCLL)];
                uint64_t v160 = v153 - 16;
                unint64_t v161 = v142 - 16;
                uint64_t v162 = v159 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v163 = *(_OWORD *)v161;
                  *((_OWORD *)v160 - 1) = *((_OWORD *)v161 - 1);
                  *(_OWORD *)uint64_t v160 = v163;
                  v160 -= 32;
                  v161 -= 32;
                  v162 -= 4;
                }
                while (v162);
                int v154 = &v153[-8 * (v159 & 0x3FFFFFFFFFFFFFFCLL)];
                if (v159 == (v159 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_186;
                }
              }
              do
              {
                uint64_t v157 = *((void *)v156 - 1);
                v156 -= 8;
                *((void *)v154 - 1) = v157;
                v154 -= 8;
              }
              while (v156 != v141);
            }
LABEL_186:
            uint64_t v142 = v153 + 8;
            if (v141) {
              (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v250 + 40))(v250, v141, v150);
            }
            uint64_t v141 = v154;
LABEL_189:
            uint64_t v146 = *v138 + 8;
            if (*v138) {
              uint64_t v158 = *v138 + 8;
            }
            else {
              uint64_t v158 = 0;
            }
            uint64_t v144 = (*(_DWORD *)(v158 + 56) + v140);
          }
          else
          {
            uint64_t v144 = v140;
          }
          if (*(unsigned char *)(v146 + 69)) {
            int v145 = v140;
          }
          else {
            int v145 = v144;
          }
          *(_DWORD *)(v146 + 60) = v145;
          ++v138;
          uint64_t v140 = v144;
          if (v138 == v139)
          {
            if ((unint64_t)v142 < v143)
            {
              if (v142) {
                *(void *)uint64_t v142 = 0x7FFFFFFFLL;
              }
              goto LABEL_228;
            }
LABEL_204:
            uint64_t v164 = (v142 - v141) >> 3;
            unint64_t v165 = v164 + 1;
            if ((unint64_t)(v164 + 1) >> 61) {
              abort();
            }
            unint64_t v166 = v143 - (void)v141;
            if ((uint64_t)(v143 - (void)v141) >> 2 > v165) {
              unint64_t v165 = (uint64_t)(v143 - (void)v141) >> 2;
            }
            if (v166 >= 0x7FFFFFFFFFFFFFF8) {
              uint64_t v167 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v167 = v165;
            }
            if (v167)
            {
              uint64_t v168 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v250 + 16))(v250, 8 * v167, 4);
              long long v169 = (char *)(v168 + 8 * v164);
              if (v168) {
                *(void *)long long v169 = 0x7FFFFFFFLL;
              }
              unsigned __int8 v170 = (char *)(v142 - v141);
              if (v142 == v141) {
                goto LABEL_225;
              }
LABEL_216:
              unint64_t v171 = (unint64_t)(v170 - 8);
              if (v171 < 0x38)
              {
                uint64_t v173 = v142;
              }
              else if ((unint64_t)(v142 - v169) < 0x20)
              {
                uint64_t v173 = v142;
              }
              else
              {
                uint64_t v172 = (v171 >> 3) + 1;
                uint64_t v173 = &v142[-8 * (v172 & 0x3FFFFFFFFFFFFFFCLL)];
                long long v174 = v169 - 16;
                uint64_t v175 = v142 - 16;
                uint64_t v176 = v172 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v177 = *(_OWORD *)v175;
                  *((_OWORD *)v174 - 1) = *((_OWORD *)v175 - 1);
                  *(_OWORD *)long long v174 = v177;
                  v174 -= 32;
                  v175 -= 32;
                  v176 -= 4;
                }
                while (v176);
                v169 -= 8 * (v172 & 0x3FFFFFFFFFFFFFFCLL);
                if (v172 == (v172 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_225;
                }
              }
              do
              {
                uint64_t v178 = *((void *)v173 - 1);
                v173 -= 8;
                *((void *)v169 - 1) = v178;
                v169 -= 8;
              }
              while (v173 != v141);
            }
            else
            {
              long long v169 = (char *)(8 * v164);
              unsigned __int8 v170 = (char *)(v142 - v141);
              if (v142 != v141) {
                goto LABEL_216;
              }
            }
LABEL_225:
            if (v141) {
              (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v250 + 40))(v250, v141, v166);
            }
            uint64_t v141 = v169;
LABEL_228:
            unsigned int v179 = [*((id *)v254 + 4) pointCount];
            uint64_t v180 = *((void *)v254 + 30);
            uint64_t v181 = (uint64_t *)((char *)v254 + 240);
            uint64_t v182 = v179;
            unint64_t v183 = v179 + (uint64_t)(int)v144;
            unint64_t v184 = (*((void *)v254 + 31) - v180) >> 4;
            if (v183 <= v184)
            {
              if (v183 < v184) {
                *((void *)v254 + 31) = v180 + 16 * v183;
              }
            }
            else
            {
              std::vector<geo::Mercator2<double>,geo::StdAllocator<geo::Mercator2<double>,mdm::Allocator>>::__append((uint64_t)v181, v183 - v184);
            }
            if (v179)
            {
              uint64_t v185 = 0;
              uint64_t v186 = 0;
              uint64_t v187 = 0;
              __asm { FMOV            V0.2D, #0.5 }
              float64x2_t v251 = _Q0;
              do
              {
                id v192 = *((id *)v254 + 4);
                [v192 pointAt:v185];
                float64_t obja = v193;
                double v195 = v194;

                long double v196 = tan(v195 * 0.00872664626 + 0.785398163);
                long double v197 = log(v196);
                uint64_t v198 = *v181;
                v199.f64[0] = obja;
                v199.f64[1] = v197;
                *(float64x2_t *)(*v181 + 16 * v187) = vmlaq_f64(v251, (float64x2_t)xmmword_1A28FCBE0, v199);
                if (v185 == *(_DWORD *)&v141[8 * v186])
                {
                  uint64_t v200 = v198 + 16;
                  do
                  {
                    uint64_t v201 = *(unsigned int *)&v141[8 * v186 + 4];
                    if ((int)v201 < 1)
                    {
                      uint64_t v191 = v187;
                    }
                    else
                    {
                      int64x2_t v202 = *(int64x2_t *)(v198 + 16 * v187);
                      uint64_t v203 = v187;
                      if (v201 <= 0x19) {
                        goto LABEL_250;
                      }
                      unint64_t v204 = v200 + 16 * v187;
                      uint64_t v205 = 16 * (v201 - 1);
                      unint64_t v206 = v204 + v205;
                      unint64_t v207 = v198 + 24 + 16 * v187;
                      unint64_t v208 = v207 + v205;
                      _CF = v206 >= v204 && v208 >= v207;
                      uint64_t v203 = v187;
                      if (!_CF) {
                        goto LABEL_250;
                      }
                      uint64_t v210 = v201 & 0x7FFFFFFC;
                      int64x2_t v211 = vdupq_lane_s64(v202.i64[0], 0);
                      int64x2_t v212 = vdupq_laneq_s64(v202, 1);
                      int64x2_t v213 = vzip2q_s64(v211, v212);
                      int64x2_t v214 = vzip1q_s64(v211, v212);
                      float v215 = (int64x2_t *)(v198 + 48 + 16 * v187);
                      uint64_t v216 = v201 & 0xFFFFFFFC;
                      do
                      {
                        v215[-2] = v214;
                        v215[-1] = v213;
                        *float v215 = v214;
                        v215[1] = v213;
                        v215 += 4;
                        v216 -= 4;
                      }
                      while (v216);
                      uint64_t v203 = v187 + v210;
                      uint64_t v191 = v187 + v210;
                      if (v210 != v201)
                      {
LABEL_250:
                        int v217 = v201 + v187 - v203;
                        do
                        {
                          uint64_t v191 = v203 + 1;
                          *(int64x2_t *)(v200 + 16 * v203++) = v202;
                          --v217;
                        }
                        while (v217);
                      }
                    }
                    ++v186;
                    uint64_t v187 = v191;
                  }
                  while (v185 == *(_DWORD *)&v141[8 * v186]);
                }
                else
                {
                  uint64_t v191 = v187;
                }
                ++v185;
                uint64_t v187 = v191 + 1;
              }
              while (v185 != v182);
            }
            else
            {
              uint64_t v198 = *v181;
            }
            uint64_t v218 = *((void *)v254 + 31) - v198;
            unint64_t v219 = v218 >> 4;
            uint64_t v221 = *((void *)v254 + 34);
            unsigned int v220 = (_DWORD *)*((void *)v254 + 35);
            unsigned int v222 = (char *)v220 - v221;
            unint64_t v223 = ((uint64_t)v220 - v221) >> 2;
            unint64_t v224 = (v218 >> 4) - v223;
            if (v218 >> 4 <= v223)
            {
              if (v218 >> 4 < v223) {
                *((void *)v254 + 35) = v221 + 4 * v219;
              }
            }
            else
            {
              uint64_t v225 = *((void *)v254 + 36);
              if (v224 <= (v225 - (uint64_t)v220) >> 2)
              {
                uint64_t v233 = &v220[v224];
                uint64_t v234 = 4 * v219 - 4 * v223;
                do
                {
                  if (v220) {
                    *unsigned int v220 = 0;
                  }
                  ++v220;
                  v234 -= 4;
                }
                while (v234);
                *((void *)v254 + 35) = v233;
              }
              else
              {
                if (v218 < 0) {
                  abort();
                }
                unint64_t v226 = v225 - v221;
                unint64_t v227 = (v225 - v221) >> 1;
                if (v227 <= v219) {
                  unint64_t v227 = v218 >> 4;
                }
                if (v226 >= 0x7FFFFFFFFFFFFFFCLL) {
                  uint64_t v228 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  uint64_t v228 = v227;
                }
                uint64_t v229 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v254 + 37) + 16))(*((void *)v254 + 37), 4 * v228, 4);
                uint64_t v230 = (_DWORD *)(v229 + 4 * v223);
                uint64_t v231 = 4 * v219 - 4 * v223;
                uint64_t v232 = v230;
                do
                {
                  if (v232) {
                    *uint64_t v232 = 0;
                  }
                  ++v232;
                  v231 -= 4;
                }
                while (v231);
                uint64_t v235 = *((void *)v254 + 34);
                uint64_t v236 = *((void *)v254 + 35);
                if (v236 != v235)
                {
                  unint64_t v237 = v236 - v235 - 4;
                  if (v237 < 0x2C) {
                    goto LABEL_311;
                  }
                  if ((unint64_t)(v236 - (void)&v222[v229]) < 0x20) {
                    goto LABEL_311;
                  }
                  uint64_t v238 = (v237 >> 2) + 1;
                  uint64_t v239 = v236 - 4 * (v238 & 0x7FFFFFFFFFFFFFF8);
                  uint64_t v240 = (_OWORD *)(v229 + 4 * v223 - 16);
                  uint64_t v241 = (long long *)(v236 - 16);
                  uint64_t v242 = v238 & 0x7FFFFFFFFFFFFFF8;
                  do
                  {
                    long long v243 = *v241;
                    *(v240 - 1) = *(v241 - 1);
                    *uint64_t v240 = v243;
                    v240 -= 2;
                    v241 -= 2;
                    v242 -= 8;
                  }
                  while (v242);
                  v230 -= v238 & 0x7FFFFFFFFFFFFFF8;
                  uint64_t v236 = v239;
                  if (v238 != (v238 & 0x7FFFFFFFFFFFFFF8))
                  {
LABEL_311:
                    do
                    {
                      int v244 = *(_DWORD *)(v236 - 4);
                      v236 -= 4;
                      *--uint64_t v230 = v244;
                    }
                    while (v236 != v235);
                  }
                }
                *((void *)v254 + 34) = v230;
                *((void *)v254 + 35) = v229 + 4 * v219;
                uint64_t v245 = *((void *)v254 + 36);
                *((void *)v254 + 36) = v229 + 4 * v228;
                if (v235) {
                  (*(void (**)(void, uint64_t, uint64_t))(**((void **)v254 + 37) + 40))(*((void *)v254 + 37), v235, v245 - v235);
                }
              }
            }
            {
              operator new();
            }
            v269[3] = mdm::Allocator::instance(void)::alloc;
            uint64_t v247 = *((void *)v254 + 30);
            uint64_t v246 = *((void *)v254 + 31);
            uint64_t v248 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                            + 16))(mdm::Allocator::instance(void)::alloc, 8, 4);
            if (v248) {
              *uint64_t v248 = ((v246 - v247) << 28) & 0xFFFFFFFF00000000;
            }
            v269[2] = v248 + 1;
            v269[0] = v248;
            v269[1] = v248 + 1;
            operator new();
          }
          continue;
        }
      }
    }
  }
  unint64_t v37 = v36 - v35 - 8;
  if (v37 > 0x67)
  {
    if ((v32 & 0xFFFFFFFFFFFFFFF8) - (v37 & 0xFFFFFFFFFFFFFFF8) + v31 - 8 >= (unint64_t)v36
      || (unint64_t v38 = (void *)(v31 + ((v30 - v29) & 0xFFFFFFFFFFFFFFF8)),
          (unint64_t)&v36[-(v37 & 0xFFFFFFFFFFFFFFF8) - 8] >= v33))
    {
      uint64_t v40 = v32 >> 3;
      uint64_t v41 = (v37 >> 3) + 1;
      uint64_t v42 = (_OWORD *)(v31 + 8 * v40 - 32);
      size_t v43 = v36 - 32;
      uint64_t v44 = v41 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        *uint64_t v42 = 0uLL;
        v42[1] = 0uLL;
        long long v45 = *((_OWORD *)v43 + 1);
        *uint64_t v42 = *(_OWORD *)v43;
        v42[1] = v45;
        v42 -= 2;
        *(_OWORD *)size_t v43 = 0uLL;
        *((_OWORD *)v43 + 1) = 0uLL;
        v43 -= 32;
        v44 -= 4;
      }
      while (v44);
      unint64_t v38 = (void *)(v33 - 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL));
      v36 -= 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL);
      if (v41 == (v41 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_21:
        size_t v36 = (char *)*((void *)v254 + 7);
        uint64_t v47 = (char *)*((void *)v254 + 8);
        *((void *)v254 + 7) = v38;
        *((void *)v254 + 8) = v33;
        uint64_t v39 = *((void *)v254 + 9);
        *((void *)v254 + 9) = v34;
        if (v47 != v36)
        {
          uint64_t v48 = v47;
          do
          {
            uint64_t v50 = *((void *)v48 - 1);
            v48 -= 8;
            uint64_t v49 = v50;
            if (v50)
            {
              _ZF = (*(void *)v49)-- == 1;
              if (_ZF)
              {
                *(void *)(v49 + 8) = &unk_1EF559A58;

                operator delete(*((void **)v47 - 1));
                *((void *)v47 - 1) = 0;
              }
            }
            uint64_t v47 = v48;
          }
          while (v48 != v36);
        }
        goto LABEL_28;
      }
    }
  }
  else
  {
    unint64_t v38 = (void *)(v31 + ((v30 - v29) & 0xFFFFFFFFFFFFFFF8));
  }
  do
  {
    *--unint64_t v38 = 0;
    uint64_t v46 = *((void *)v36 - 1);
    v36 -= 8;
    *unint64_t v38 = v46;
    *(void *)size_t v36 = 0;
  }
  while (v36 != v35);
  goto LABEL_21;
}

void sub_1A20CCDA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t **a13, gss::FeatureAttributeSet *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48)
{
  geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>::~fast_shared_ptr(&a39);
  std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)&a47, (void *)a48);
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100]((uint64_t *)(a38 + 312));
  std::unique_ptr<md::LabelRouteCollisionInfo>::~unique_ptr[abi:nn180100](a13);
  gss::FeatureAttributeSet::~FeatureAttributeSet(a14);
  gss::FeatureAttributeSet::~FeatureAttributeSet((gss::FeatureAttributeSet *)(a38 + 240));
  std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy(a10 - 8, *(void **)(a38 + 160));
  std::vector<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>,mdm::Allocator>>::~vector[abi:nn180100](a28);
  std::vector<geo::fast_shared_ptr<md::LabelTransitRoute::LegInfo,std::allocator>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelTransitRoute::LegInfo,std::allocator>,mdm::Allocator>>::~vector[abi:nn180100]((uint64_t *)(a38 + 56));
  *(void *)(a38 + 24) = a11;

  *(void *)a38 = a9;
  _Unwind_Resume(a1);
}

uint64_t **std::unique_ptr<md::LabelRouteCollisionInfo>::~unique_ptr[abi:nn180100](uint64_t **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = v2[6];
    if (v3)
    {
      v2[7] = v3;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[9] + 40))(v2[9], v3, v2[8] - v3);
    }
    if (*v2)
    {
      std::vector<geo::fast_shared_ptr<md::LabelRouteZoomCollisionInfo,std::allocator>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelRouteZoomCollisionInfo,std::allocator>,mdm::Allocator>>::__clear[abi:nn180100](v2);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[3] + 40))(v2[3], *v2, v2[2] - *v2);
    }
    MEMORY[0x1A6239270](v2, 0x60C40FC37DD7DLL);
  }
  return a1;
}

uint64_t std::vector<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>,mdm::Allocator>>::~vector[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)a1;
  if (*(void *)a1)
  {
    uint64_t v3 = *(void ***)(a1 + 8);
    long long v4 = v2;
    if (v3 != v2)
    {
      do
        uint64_t v3 = geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>::~fast_shared_ptr(v3 - 1);
      while (v3 != v2);
      long long v4 = *(void ***)a1;
    }
    *(void *)(a1 + 8) = v2;
    (*(void (**)(void, void **, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v4, *(void *)(a1 + 16) - (void)v4);
  }
  return a1;
}

uint64_t *std::vector<geo::fast_shared_ptr<md::LabelTransitRoute::LegInfo,std::allocator>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelTransitRoute::LegInfo,std::allocator>,mdm::Allocator>>::~vector[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      uint64_t v5 = a1[1];
      do
      {
        uint64_t v7 = *(void *)(v5 - 8);
        v5 -= 8;
        uint64_t v6 = v7;
        if (v7)
        {
          if ((*(void *)v6)-- == 1)
          {
            *(void *)(v6 + 8) = &unk_1EF559A58;

            operator delete(*(void **)(v3 - 8));
            *(void *)(v3 - 8) = 0;
          }
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v4, a1[2] - v4);
  }
  return a1;
}

void geo::_retain_ptr<GEOComposedRouteSegment * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559A58;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<GEOComposedRouteSegment * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559A58;

  return a1;
}

void **geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>::~fast_shared_ptr(void **a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((*(void *)v2)-- == 1)
    {
      uint64_t v4 = (std::__shared_weak_count *)*((void *)v2 + 11);
      if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }

      operator delete(*a1);
      *a1 = 0;
    }
  }
  return a1;
}

void std::vector<geo::fast_shared_ptr<md::LabelRouteZoomCollisionInfo,std::allocator>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelRouteZoomCollisionInfo,std::allocator>,mdm::Allocator>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (v3 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void *)(v4 - 8);
      v4 -= 8;
      uint64_t v5 = v6;
      if (v6)
      {
        if ((*(void *)v5)-- == 1)
        {
          uint64_t v8 = *(void *)(v5 + 120);
          if (v8)
          {
            *(void *)(v5 + 128) = v8;
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v5 + 144) + 40))(*(void *)(v5 + 144), v8, *(void *)(v5 + 136) - v8);
          }
          uint64_t v9 = *(void *)(v5 + 88);
          if (v9)
          {
            *(void *)(v5 + 96) = v9;
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v5 + 112) + 40))(*(void *)(v5 + 112), v9, *(void *)(v5 + 104) - v9);
          }
          std::__hash_table<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,geo::StdAllocator<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,mdm::Allocator>>::~__hash_table((uint64_t *)(v5 + 32));
          operator delete(*(void **)(v3 - 8));
          *(void *)(v3 - 8) = 0;
        }
      }
      uint64_t v3 = v4;
    }
    while (v4 != v2);
  }
  a1[1] = v2;
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,geo::StdAllocator<std::__hash_value_type<unsigned int,geo::fast_shared_ptr<md::LabelRouteTileCollisionInfo,std::allocator>>,mdm::Allocator>>::~__hash_table(uint64_t *a1)
{
  uint64_t v2 = (void *)a1[3];
  while (v2)
  {
    uint64_t v5 = v2;
    uint64_t v2 = (void *)*v2;
    uint64_t v6 = (void *)v5[3];
    if (v6)
    {
      if ((*v6)-- == 1)
      {
        uint64_t v8 = v6[6];
        if (v8)
        {
          v6[7] = v8;
          (*(void (**)(void, uint64_t, uint64_t))(*(void *)v6[9] + 40))(v6[9], v8, v6[8] - v8);
          uint64_t v6 = (void *)v5[3];
        }
        operator delete(v6);
        void v5[3] = 0;
      }
    }
    (*(void (**)(uint64_t, void *, uint64_t))(*(void *)a1[4] + 40))(a1[4], v5, 32);
  }
  uint64_t v3 = *a1;
  *a1 = 0;
  if (v3) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[2] + 40))(a1[2], v3, 8 * a1[1]);
  }
  return a1;
}

void *std::vector<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>,mdm::Allocator>>::__emplace_back_slow_path<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>&>(uint64_t a1, void **a2)
{
  uint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    abort();
  }
  uint64_t v5 = *(void *)(a1 + 16) - *(void *)a1;
  if (v5 >> 2 > v3) {
    unint64_t v3 = v5 >> 2;
  }
  BOOL v19 = (unint64_t)v5 >= 0x7FFFFFFFFFFFFFF8;
  uint64_t v6 = 0x1FFFFFFFFFFFFFFFLL;
  if (!v19) {
    uint64_t v6 = v3;
  }
  if (v6)
  {
    uint64_t v8 = 8 * v6;
    uint64_t v9 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), 8 * v6, 8);
    id v10 = (void *)(v9 + 8 * v2);
    uint64_t v6 = v9 + v8;
    if (v9)
    {
      *id v10 = 0;
      double v11 = *a2;
      *id v10 = *a2;
      if (v11) {
        ++*v11;
      }
    }
  }
  else
  {
    id v10 = (void *)(8 * v2);
  }
  double v12 = v10 + 1;
  long double v13 = *(char **)a1;
  long double v14 = *(void ***)(a1 + 8);
  if (v14 == *(void ***)a1)
  {
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    uint64_t v28 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v6;
    if (!v14) {
      return v12;
    }
    goto LABEL_27;
  }
  unint64_t v15 = (unint64_t)v14 - *(void *)a1 - 8;
  if (v15 <= 0x47
    || ((unint64_t v16 = (v13 - (char *)v14 + 7) & 0xFFFFFFFFFFFFFFF8,
         long double v17 = (char *)v10 + v16,
         unint64_t v18 = (unint64_t)v14 + v16,
         v17 < (char *)v14)
      ? (BOOL v19 = v18 >= (unint64_t)v10)
      : (BOOL v19 = 1),
        !v19))
  {
    float64x2_t v21 = *(void ***)(a1 + 8);
    do
    {
LABEL_23:
      *--id v10 = 0;
      uint64_t v26 = (uint64_t)*--v21;
      *id v10 = v26;
      std::__shared_weak_count_vtbl *v21 = 0;
    }
    while (v21 != (void **)v13);
    goto LABEL_24;
  }
  uint64_t v20 = (v15 >> 3) + 1;
  float64x2_t v21 = &v14[-(v20 & 0x3FFFFFFFFFFFFFFCLL)];
  float64x2_t v22 = v10 - 4;
  float64x2_t v23 = v14 - 4;
  uint64_t v24 = v20 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    _OWORD *v22 = 0uLL;
    v22[1] = 0uLL;
    long long v25 = *((_OWORD *)v23 + 1);
    _OWORD *v22 = *(_OWORD *)v23;
    v22[1] = v25;
    v22 -= 2;
    *(_OWORD *)float64x2_t v23 = 0uLL;
    *((_OWORD *)v23 + 1) = 0uLL;
    v23 -= 4;
    v24 -= 4;
  }
  while (v24);
  v10 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
  if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_23;
  }
LABEL_24:
  long double v14 = *(void ***)a1;
  unint64_t v27 = *(void ***)(a1 + 8);
  *(void *)a1 = v10;
  *(void *)(a1 + 8) = v12;
  uint64_t v28 = *(void *)(a1 + 16);
  for (*(void *)(a1 + 16) = v6;
        v27 != v14;
  if (v14) {
LABEL_27:
  }
    (*(void (**)(void, void **, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v14, v28 - (void)v14);
  return v12;
}

void **geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>::operator=(void **a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((*(void *)v2)-- == 1)
    {
      uint64_t v4 = (std::__shared_weak_count *)*((void *)v2 + 11);
      if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }

      operator delete(*a1);
    }
  }
  *a1 = 0;
  return a1;
}

BOOL isOriginStopSkippedForStep(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [v1 transitVehicle];
  int v3 = [v2 pickupDropoffType];

  if (v3 == 100)
  {
    BOOL v4 = 1;
  }
  else
  {
    if ([v1 maneuver] != 9) {
      goto LABEL_7;
    }
    uint64_t v5 = [v1 originStop];
    uint64_t v6 = [v5 muid];
    uint64_t v7 = [v1 destinationStop];
    uint64_t v8 = [v7 muid];

    if (v6 != v8) {
      goto LABEL_7;
    }
    uint64_t v9 = [v1 getNextStep];
    id v10 = v9;
    if (v9)
    {
      double v11 = [v9 transitVehicle];
      BOOL v4 = [v11 pickupDropoffType] == 100;
    }
    else
    {
LABEL_7:
      BOOL v4 = 0;
    }
  }

  return v4;
}

void sub_1A20CDBB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void **md::LabelTransitRoute::insertStationWalkingPathNodes(uint64_t a1, int a2, void *a3, void **a4)
{
  uint64_t v8 = *a3;
  uint64_t v9 = (int *)(*a3 + 8);
  if (!*a3) {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(void *)(*(void *)(a1 + 56) + 8 * v9[6]);
  if (v10) {
    uint64_t v11 = v10 + 8;
  }
  else {
    uint64_t v11 = 0;
  }
  int v13 = v9[11];
  int v12 = v9[12];
  unint64_t v14 = (*(_DWORD *)(v11 + 60) + v13);
  BOOL v15 = v12 != 0;
  int v16 = v12 - 1;
  if (v15) {
    int v17 = v16;
  }
  else {
    int v17 = 0;
  }
  unint64_t v18 = *a4;
  if (*a4)
  {
    if ((v14 & 0x80000000) == 0)
    {
      uint64_t v19 = *(void *)(a1 + 240);
      if (v14 < (*(void *)(a1 + 248) - v19) >> 4)
      {
        uint64_t v20 = (double *)(v19 + 16 * v14);
        double v21 = *(double *)(a1 + 200);
        if (vabdd_f64(*v20, *((double *)v18 + 5)) < v21 && vabdd_f64(v20[1], *((double *)v18 + 6)) < v21)
        {
          if (*((unsigned char *)v18 + 109) != 4)
          {
            float64x2_t v22 = *(void ***)(a1 + 96);
            if ((unint64_t)v22 >= *(void *)(a1 + 104))
            {
              *(void *)(a1 + 96) = std::vector<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>,mdm::Allocator>>::__emplace_back_slow_path<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>&>(a1 + 88, (void **)a4);
            }
            else
            {
              if (v22)
              {
                _OWORD *v22 = 0;
                float64x2_t v23 = *a4;
                _OWORD *v22 = *a4;
                if (v23) {
                  ++*v23;
                }
              }
              *(void *)(a1 + 96) = v22 + 1;
            }
          }
          geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>::operator=(a4);
          goto LABEL_40;
        }
      }
    }
    uint64_t v24 = *(void ***)(a1 + 96);
    if ((unint64_t)v24 >= *(void *)(a1 + 104))
    {
      uint64_t v26 = std::vector<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>,mdm::Allocator>>::__emplace_back_slow_path<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>&>(a1 + 88, (void **)a4);
    }
    else
    {
      if (v24)
      {
        *uint64_t v24 = 0;
        long long v25 = *a4;
        *uint64_t v24 = *a4;
        if (v25) {
          ++*v25;
        }
      }
      uint64_t v26 = v24 + 1;
    }
    *(void *)(a1 + 96) = v26;
    geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>::operator=(a4);
    uint64_t v8 = *a3;
  }
  uint64_t v27 = v8 + 8;
  if (!v8) {
    uint64_t v27 = 0;
  }
  int v28 = *(_DWORD *)(v27 + 24);
  uint64_t v29 = (char *)operator new(0x70uLL);
  *(void *)uint64_t v29 = 1;
  *((void *)v29 + 13) = 0;
  *(_OWORD *)(v29 + 56) = 0u;
  *(_OWORD *)(v29 + 8) = 0u;
  *(_OWORD *)(v29 + 24) = 0u;
  *(_OWORD *)(v29 + 40) = 0u;
  *(_OWORD *)(v29 + 72) = 0u;
  *(_OWORD *)(v29 + 88) = 0u;
  uint64_t v44 = v29;
  v29[109] = 4;
  *((_DWORD *)v29 + 15) = a2;
  *((_DWORD *)v29 + 16) = v14;
  if ((v14 & 0x80000000) != 0 || (uint64_t v30 = *(void *)(a1 + 240), v14 >= (*(void *)(a1 + 248) - v30) >> 4))
  {
    char v32 = 0;
  }
  else
  {
    uint64_t v31 = (void *)(v30 + 16 * v14);
    *((void *)v29 + 5) = *v31;
    *((void *)v29 + 6) = v31[1];
    char v32 = 1;
  }
  v29[99] = v32;
  *((_DWORD *)v29 + 14) = v28;
  v29[68] = 3;
  unint64_t v33 = *(void **)(a1 + 96);
  if ((unint64_t)v33 >= *(void *)(a1 + 104))
  {
    unsigned int v35 = std::vector<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>,mdm::Allocator>>::__emplace_back_slow_path<geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>&>(a1 + 88, &v44);
  }
  else
  {
    if (v33)
    {
      *unint64_t v33 = 0;
      uint64_t v34 = v44;
      *unint64_t v33 = v44;
      if (v34) {
        ++*v34;
      }
    }
    unsigned int v35 = v33 + 1;
  }
  *(void *)(a1 + 96) = v35;
  geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>::~fast_shared_ptr((void **)&v44);
LABEL_40:
  if (*a3) {
    uint64_t v36 = *a3 + 8;
  }
  else {
    uint64_t v36 = 0;
  }
  int v37 = *(_DWORD *)(v36 + 24);
  uint64_t v44 = 0;
  unint64_t v38 = (char *)operator new(0x70uLL);
  *(void *)unint64_t v38 = 1;
  unint64_t v39 = (v14 + v17);
  *((void *)v38 + 13) = 0;
  *(_OWORD *)(v38 + 56) = 0u;
  *(_OWORD *)(v38 + 8) = 0u;
  *(_OWORD *)(v38 + 24) = 0u;
  *(_OWORD *)(v38 + 40) = 0u;
  *(_OWORD *)(v38 + 72) = 0u;
  *(_OWORD *)(v38 + 88) = 0u;
  uint64_t v44 = v38;
  v38[109] = 4;
  *((_DWORD *)v38 + 15) = a2;
  *((_DWORD *)v38 + 16) = v39;
  if ((v39 & 0x80000000) != 0 || (uint64_t v40 = *(void *)(a1 + 240), v39 >= (*(void *)(a1 + 248) - v40) >> 4))
  {
    char v42 = 0;
  }
  else
  {
    uint64_t v41 = (void *)(v40 + 16 * v39);
    *((void *)v38 + 5) = *v41;
    *((void *)v38 + 6) = v41[1];
    char v42 = 1;
  }
  v38[99] = v42;
  *((_DWORD *)v38 + 14) = v37;
  v38[68] = 2;
  geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>::operator=(a4, (void **)&v44);
  return geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>::~fast_shared_ptr((void **)&v44);
}

void sub_1A20CDF10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>::~fast_shared_ptr((void **)va);
  _Unwind_Resume(a1);
}

void **geo::fast_shared_ptr<md::LabelTransitRoute::NodeInfo,std::allocator>::operator=(void **a1, void **a2)
{
  BOOL v4 = *a1;
  if (*a1)
  {
    if ((*(void *)v4)-- == 1)
    {
      uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 + 11);
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }

      operator delete(*a1);
      *a1 = 0;
    }
  }
  *a1 = *a2;
  *a2 = 0;
  return a1;
}

void **geo::fast_shared_ptr<md::LabelTransitRoute::LegInfo,std::allocator>::~fast_shared_ptr(void **a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((*(void *)v2)-- == 1)
    {
      *((void *)v2 + 1) = &unk_1EF559A58;

      operator delete(*a1);
      *a1 = 0;
    }
  }
  return a1;
}

void md::LabelTransitRoute::buildFeatureForWaypoint(md::LabelTransitRoute *this, md::LabelManager *a2, VKRouteWaypointInfo *a3, int a4)
{
  uint64_t v174 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a3;
  uint64_t v8 = (std::__shared_weak_count *)operator new(0x1D8uLL);
  uint64_t v159 = this;
  v8->__shared_owners_ = 0;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581CC8;
  unint64_t v165 = md::LabelExternalPointFeature::LabelExternalPointFeature((md::LabelExternalPointFeature *)&v8[1]);
  unint64_t v166 = v8;
  uint64_t v9 = [(VKRouteWaypointInfo *)v7 waypoint];
  v8[1].__shared_weak_owners_ = [v9 muid];
  [v9 coordinate];
  int v13 = v8[9].__vftable;
  if ((std::__shared_weak_count_vtbl *)v8[9].__shared_owners_ != v13)
  {
    double v14 = v12;
    if (fabs(v10) <= 85.0511169)
    {
      float64_t v161 = v11;
      long double v19 = tan(v10 * 0.00872664626 + 0.785398163);
      long double v20 = log(v19);
      v21.f64[0] = v161;
      v21.f64[1] = v20;
      __asm { FMOV            V1.2D, #0.5 }
      *(float64x2_t *)&v13->__get_deleter = vmlaq_f64(_Q1, (float64x2_t)xmmword_1A28FCBE0, v21);
      *(_WORD *)((char *)&v13[1].~__shared_weak_count + 5) = 257;
    }
    else
    {
      double v15 = v11 * 0.0174532925;
      __double2 v16 = __sincos_stret(v10 * 0.0174532925);
      double v17 = 6378137.0 / sqrt(v16.__sinval * v16.__sinval * -0.00669437999 + 1.0);
      __double2 v18 = __sincos_stret(v15);
      *(double *)&v13->~__shared_weak_count = v17 * v16.__cosval * v18.__cosval;
      *(double *)&v13->~__shared_weak_count_0 = v17 * v16.__cosval * v18.__sinval;
      *(double *)&v13->__on_zero_shared = v16.__sinval * 0.99330562 * v17;
      BYTE4(v13[1].~__shared_weak_count) = 1;
    }
    if (v14 != 1.79769313e308)
    {
      float v27 = v14;
      *(float *)&v13[1].~__shared_weak_count = v27;
    }
  }
  int v162 = a4;
  id v28 = v9;
  uint64_t v29 = [v28 artwork];

  if (v29)
  {
    id v30 = objc_alloc(MEMORY[0x1E4F645A0]);
    uint64_t v31 = [v28 artwork];
    char v32 = [v31 iconDataSource];
    unint64_t v33 = [v32 styleAttributes];
    uint64_t v34 = (void *)[v30 initWithGEOStyleAttributes:v33];
  }
  else
  {
    unsigned int v35 = [v28 styleAttributes];

    if (v35)
    {
      uint64_t v36 = [v28 styleAttributes];
    }
    else
    {
      uint64_t v36 = objc_msgSend(objc_alloc(MEMORY[0x1E4F645A0]), "initWithAttributes:", 5, 3, 6, 348, 0);
    }
    uint64_t v34 = (void *)v36;
  }

  uint64_t v167 = 0;
  uint64_t v168 = 0;
  unint64_t v169 = 0;
  {
    operator new();
  }
  uint64_t v160 = a2;
  uint64_t v170 = mdm::Allocator::instance(void)::alloc;
  int v37 = (char *)[v34 v];
  uint64_t v38 = [v34 v];
  unsigned int v39 = [v34 countAttrs];
  std::vector<GeoCodecsFeatureStylePair,geo::StdAllocator<GeoCodecsFeatureStylePair,mdm::Allocator>>::__insert_with_size[abi:nn180100]<GeoCodecsFeatureStylePair*,GeoCodecsFeatureStylePair*>((uint64_t *)&v167, 0, v37, (char *)(v38 + 8 * v39), (v38 + 8 * v39 - (uint64_t)v37) >> 3);
  uint64_t v40 = v168;
  unint64_t v41 = v169;
  if ((unint64_t)v168 < v169)
  {
    if (v168) {
      *uint64_t v168 = 0x300000005;
    }
    char v42 = v40 + 1;
    goto LABEL_43;
  }
  uint64_t v43 = (uint64_t)v167;
  uint64_t v44 = v168 - v167;
  unint64_t v45 = v44 + 1;
  if ((unint64_t)(v44 + 1) >> 61) {
    abort();
  }
  if ((uint64_t)(v169 - (void)v167) >> 2 > v45) {
    unint64_t v45 = (uint64_t)(v169 - (void)v167) >> 2;
  }
  if (v169 - (unint64_t)v167 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v46 = v45;
  }
  if (v46)
  {
    uint64_t v47 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v170 + 16))(v170, 8 * v46, 4);
    uint64_t v48 = (void *)(v47 + 8 * v44);
    uint64_t v46 = v47 + 8 * v46;
    if (v47) {
      *uint64_t v48 = 0x300000005;
    }
  }
  else
  {
    uint64_t v48 = (void *)(8 * v44);
  }
  char v42 = v48 + 1;
  if (v40 != (void *)v43)
  {
    unint64_t v49 = (unint64_t)v40 - v43 - 8;
    if (v49 < 0x38)
    {
      long long v51 = v40;
    }
    else if ((unint64_t)((char *)v40 - (char *)v48) < 0x20)
    {
      long long v51 = v40;
    }
    else
    {
      uint64_t v50 = (v49 >> 3) + 1;
      long long v51 = &v40[-(v50 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v52 = v48 - 2;
      int v53 = (long long *)(v40 - 2);
      uint64_t v54 = v50 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v55 = *v53;
        *(v52 - 1) = *(v53 - 1);
        _OWORD *v52 = v55;
        v52 -= 2;
        v53 -= 2;
        v54 -= 4;
      }
      while (v54);
      v48 -= v50 & 0x3FFFFFFFFFFFFFFCLL;
      if (v50 == (v50 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_40;
      }
    }
    do
    {
      uint64_t v56 = *--v51;
      *--uint64_t v48 = v56;
    }
    while (v51 != (void *)v43);
    uint64_t v43 = (uint64_t)v167;
    unint64_t v41 = v169;
    goto LABEL_40;
  }
  uint64_t v43 = (uint64_t)v40;
LABEL_40:
  uint64_t v167 = v48;
  unint64_t v169 = v46;
  if (v43) {
    (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)v170 + 40))(v170, v43, v41 - v43);
  }
  unint64_t v41 = v46;
LABEL_43:
  uint64_t v168 = v42;
  if ((unint64_t)v42 < v41)
  {
    *char v42 = 0x400010023;
    unint64_t v57 = v41;
    id v58 = v42 + 1;
    goto LABEL_69;
  }
  uint64_t v59 = (uint64_t)v167;
  uint64_t v60 = v42 - v167;
  unint64_t v61 = v60 + 1;
  if ((unint64_t)(v60 + 1) >> 61) {
    abort();
  }
  if ((uint64_t)(v41 - (void)v167) >> 2 > v61) {
    unint64_t v61 = (uint64_t)(v41 - (void)v167) >> 2;
  }
  if (v41 - (unint64_t)v167 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v57 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v57 = v61;
  }
  if (v57)
  {
    uint64_t v62 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v170 + 16))(v170, 8 * v57, 4);
    unint64_t v63 = (void *)(v62 + 8 * v60);
    unint64_t v57 = v62 + 8 * v57;
    if (v62) {
      void *v63 = 0x400010023;
    }
  }
  else
  {
    unint64_t v63 = (void *)(8 * v60);
  }
  id v58 = v63 + 1;
  if (v42 != (void *)v59)
  {
    unint64_t v64 = (unint64_t)v42 - v59 - 8;
    if (v64 < 0x38)
    {
      uint64_t v66 = v42;
    }
    else if ((unint64_t)((char *)v42 - (char *)v63) < 0x20)
    {
      uint64_t v66 = v42;
    }
    else
    {
      uint64_t v65 = (v64 >> 3) + 1;
      uint64_t v66 = &v42[-(v65 & 0x3FFFFFFFFFFFFFFCLL)];
      unint64_t v67 = v63 - 2;
      uint64_t v68 = (long long *)(v42 - 2);
      uint64_t v69 = v65 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v70 = *v68;
        *(v67 - 1) = *(v68 - 1);
        *unint64_t v67 = v70;
        v67 -= 2;
        v68 -= 2;
        v69 -= 4;
      }
      while (v69);
      v63 -= v65 & 0x3FFFFFFFFFFFFFFCLL;
      if (v65 == (v65 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_67;
      }
    }
    do
    {
      uint64_t v71 = *--v66;
      *--unint64_t v63 = v71;
    }
    while (v66 != (void *)v59);
    uint64_t v59 = (uint64_t)v167;
    unint64_t v41 = v169;
LABEL_67:
    uint64_t v167 = v63;
    unint64_t v169 = v57;
    char v42 = (void *)v59;
    if (!v59) {
      goto LABEL_69;
    }
    goto LABEL_68;
  }
  uint64_t v167 = v63;
  unint64_t v169 = v57;
LABEL_68:
  (*(void (**)(uint64_t, void *, unint64_t))(*(void *)v170 + 40))(v170, v42, v41 - (void)v42);
LABEL_69:
  uint64_t v168 = v58;
  if ((unint64_t)v58 < v57)
  {
    void *v58 = 0x100010002;
    unint64_t v72 = v169;
    BOOL v73 = v58 + 1;
    goto LABEL_95;
  }
  uint64_t v74 = (uint64_t)v167;
  uint64_t v75 = v58 - v167;
  unint64_t v76 = v75 + 1;
  if ((unint64_t)(v75 + 1) >> 61) {
    abort();
  }
  if ((uint64_t)(v57 - (void)v167) >> 2 > v76) {
    unint64_t v76 = (uint64_t)(v57 - (void)v167) >> 2;
  }
  if (v57 - (unint64_t)v167 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v72 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v72 = v76;
  }
  if (v72)
  {
    uint64_t v77 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v170 + 16))(v170, 8 * v72, 4);
    uint64_t v78 = (void *)(v77 + 8 * v75);
    unint64_t v72 = v77 + 8 * v72;
    if (v77) {
      *uint64_t v78 = 0x100010002;
    }
  }
  else
  {
    uint64_t v78 = (void *)(8 * v75);
  }
  BOOL v73 = v78 + 1;
  if (v58 != (void *)v74)
  {
    unint64_t v79 = (unint64_t)v58 - v74 - 8;
    if (v79 < 0x38)
    {
      BOOL v81 = v58;
    }
    else if ((unint64_t)((char *)v58 - (char *)v78) < 0x20)
    {
      BOOL v81 = v58;
    }
    else
    {
      uint64_t v80 = (v79 >> 3) + 1;
      BOOL v81 = &v58[-(v80 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v82 = v78 - 2;
      uint64_t v83 = (long long *)(v58 - 2);
      uint64_t v84 = v80 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v85 = *v83;
        *(v82 - 1) = *(v83 - 1);
        *uint64_t v82 = v85;
        v82 -= 2;
        v83 -= 2;
        v84 -= 4;
      }
      while (v84);
      v78 -= v80 & 0x3FFFFFFFFFFFFFFCLL;
      if (v80 == (v80 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_93;
      }
    }
    do
    {
      uint64_t v86 = *--v81;
      *--uint64_t v78 = v86;
    }
    while (v81 != (void *)v74);
    uint64_t v74 = (uint64_t)v167;
    unint64_t v57 = v169;
LABEL_93:
    uint64_t v167 = v78;
    unint64_t v169 = v72;
    id v58 = (void *)v74;
    if (!v74) {
      goto LABEL_95;
    }
    goto LABEL_94;
  }
  uint64_t v167 = v78;
  unint64_t v169 = v72;
LABEL_94:
  (*(void (**)(uint64_t, void *, unint64_t))(*(void *)v170 + 40))(v170, v58, v57 - (void)v58);
LABEL_95:
  uint64_t v168 = v73;
  if ((unint64_t)v73 < v72)
  {
    void *v73 = 0x100010024;
    unint64_t v87 = v169;
    uint64_t v88 = v73 + 1;
    goto LABEL_121;
  }
  uint64_t v89 = (uint64_t)v167;
  uint64_t v90 = v73 - v167;
  unint64_t v91 = v90 + 1;
  if ((unint64_t)(v90 + 1) >> 61) {
    abort();
  }
  if ((uint64_t)(v72 - (void)v167) >> 2 > v91) {
    unint64_t v91 = (uint64_t)(v72 - (void)v167) >> 2;
  }
  if (v72 - (unint64_t)v167 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v87 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v87 = v91;
  }
  if (v87)
  {
    uint64_t v92 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v170 + 16))(v170, 8 * v87, 4);
    long long v93 = (void *)(v92 + 8 * v90);
    unint64_t v87 = v92 + 8 * v87;
    if (v92) {
      void *v93 = 0x100010024;
    }
  }
  else
  {
    long long v93 = (void *)(8 * v90);
  }
  uint64_t v88 = v93 + 1;
  if (v73 != (void *)v89)
  {
    unint64_t v94 = (unint64_t)v73 - v89 - 8;
    if (v94 < 0x38)
    {
      uint64_t v96 = v73;
    }
    else if ((unint64_t)((char *)v73 - (char *)v93) < 0x20)
    {
      uint64_t v96 = v73;
    }
    else
    {
      uint64_t v95 = (v94 >> 3) + 1;
      uint64_t v96 = &v73[-(v95 & 0x3FFFFFFFFFFFFFFCLL)];
      id v97 = v93 - 2;
      BOOL v98 = (long long *)(v73 - 2);
      uint64_t v99 = v95 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v100 = *v98;
        *(v97 - 1) = *(v98 - 1);
        _OWORD *v97 = v100;
        v97 -= 2;
        v98 -= 2;
        v99 -= 4;
      }
      while (v99);
      v93 -= v95 & 0x3FFFFFFFFFFFFFFCLL;
      if (v95 == (v95 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_119;
      }
    }
    do
    {
      uint64_t v101 = *--v96;
      *--long long v93 = v101;
    }
    while (v96 != (void *)v89);
    uint64_t v89 = (uint64_t)v167;
    unint64_t v72 = v169;
LABEL_119:
    uint64_t v167 = v93;
    unint64_t v169 = v87;
    BOOL v73 = (void *)v89;
    if (!v89) {
      goto LABEL_121;
    }
    goto LABEL_120;
  }
  uint64_t v167 = v93;
  unint64_t v169 = v87;
LABEL_120:
  (*(void (**)(uint64_t, void *, unint64_t))(*(void *)v170 + 40))(v170, v73, v72 - (void)v73);
LABEL_121:
  uint64_t v168 = v88;
  if ((unint64_t)v88 < v87)
  {
    void *v88 = 0x20001001FLL;
    unint64_t v102 = v169;
    BOOL v103 = v88 + 1;
    goto LABEL_147;
  }
  uint64_t v104 = (uint64_t)v167;
  uint64_t v105 = v88 - v167;
  unint64_t v106 = v105 + 1;
  if ((unint64_t)(v105 + 1) >> 61) {
    abort();
  }
  if ((uint64_t)(v87 - (void)v167) >> 2 > v106) {
    unint64_t v106 = (uint64_t)(v87 - (void)v167) >> 2;
  }
  if (v87 - (unint64_t)v167 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v102 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v102 = v106;
  }
  if (v102)
  {
    uint64_t v107 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v170 + 16))(v170, 8 * v102, 4);
    id v108 = (void *)(v107 + 8 * v105);
    unint64_t v102 = v107 + 8 * v102;
    if (v107) {
      *id v108 = 0x20001001FLL;
    }
  }
  else
  {
    id v108 = (void *)(8 * v105);
  }
  BOOL v103 = v108 + 1;
  if (v88 != (void *)v104)
  {
    unint64_t v109 = (unint64_t)v88 - v104 - 8;
    if (v109 < 0x38)
    {
      id v111 = v88;
    }
    else if ((unint64_t)((char *)v88 - (char *)v108) < 0x20)
    {
      id v111 = v88;
    }
    else
    {
      uint64_t v110 = (v109 >> 3) + 1;
      id v111 = &v88[-(v110 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v112 = v108 - 2;
      uint64_t v113 = (long long *)(v88 - 2);
      uint64_t v114 = v110 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v115 = *v113;
        *(v112 - 1) = *(v113 - 1);
        *uint64_t v112 = v115;
        v112 -= 2;
        v113 -= 2;
        v114 -= 4;
      }
      while (v114);
      v108 -= v110 & 0x3FFFFFFFFFFFFFFCLL;
      if (v110 == (v110 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_145;
      }
    }
    do
    {
      uint64_t v116 = *--v111;
      *--id v108 = v116;
    }
    while (v111 != (void *)v104);
    uint64_t v104 = (uint64_t)v167;
    unint64_t v87 = v169;
LABEL_145:
    uint64_t v167 = v108;
    unint64_t v169 = v102;
    uint64_t v88 = (void *)v104;
    if (!v104) {
      goto LABEL_147;
    }
    goto LABEL_146;
  }
  uint64_t v167 = v108;
  unint64_t v169 = v102;
LABEL_146:
  (*(void (**)(uint64_t, void *, unint64_t))(*(void *)v170 + 40))(v170, v88, v87 - (void)v88);
LABEL_147:
  uint64_t v168 = v103;
  if (v162) {
    uint64_t v117 = 3;
  }
  else {
    uint64_t v117 = 4;
  }
  if ((unint64_t)v103 < v102)
  {
    void *v103 = (v117 << 32) | 0x2C;
    uint64_t v118 = (char *)(v103 + 1);
    goto LABEL_176;
  }
  uint64_t v119 = (uint64_t)v167;
  uint64_t v120 = v103 - v167;
  unint64_t v121 = v120 + 1;
  if ((unint64_t)(v120 + 1) >> 61) {
    abort();
  }
  if ((uint64_t)(v102 - (void)v167) >> 2 > v121) {
    unint64_t v121 = (uint64_t)(v102 - (void)v167) >> 2;
  }
  if (v102 - (unint64_t)v167 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v122 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v122 = v121;
  }
  if (v122)
  {
    uint64_t v123 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v170 + 16))(v170, 8 * v122, 4);
    uint64_t v124 = (uint64_t *)(v123 + 8 * v120);
    uint64_t v125 = v123 + 8 * v122;
    if (v123) {
      *uint64_t v124 = (v117 << 32) | 0x2C;
    }
  }
  else
  {
    uint64_t v125 = 0;
    uint64_t v124 = (uint64_t *)(8 * v120);
  }
  uint64_t v118 = (char *)(v124 + 1);
  if (v103 != (void *)v119)
  {
    unint64_t v126 = (unint64_t)v103 - v119 - 8;
    if (v126 < 0x38)
    {
      uint64_t v128 = v103;
    }
    else if ((unint64_t)((char *)v103 - (char *)v124) < 0x20)
    {
      uint64_t v128 = v103;
    }
    else
    {
      uint64_t v127 = (v126 >> 3) + 1;
      uint64_t v128 = &v103[-(v127 & 0x3FFFFFFFFFFFFFFCLL)];
      int v129 = v124 - 2;
      uint64_t v130 = (long long *)(v103 - 2);
      uint64_t v131 = v127 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v132 = *v130;
        *((_OWORD *)v129 - 1) = *(v130 - 1);
        *(_OWORD *)int v129 = v132;
        v129 -= 4;
        v130 -= 2;
        v131 -= 4;
      }
      while (v131);
      v124 -= v127 & 0x3FFFFFFFFFFFFFFCLL;
      if (v127 == (v127 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_174;
      }
    }
    do
    {
      uint64_t v133 = *--v128;
      *--uint64_t v124 = v133;
    }
    while (v128 != (void *)v119);
    uint64_t v119 = (uint64_t)v167;
    unint64_t v102 = v169;
LABEL_174:
    uint64_t v167 = v124;
    unint64_t v169 = v125;
    BOOL v103 = (void *)v119;
    if (!v119) {
      goto LABEL_176;
    }
    goto LABEL_175;
  }
  uint64_t v167 = v124;
  unint64_t v169 = v125;
LABEL_175:
  (*(void (**)(uint64_t, void *, unint64_t))(*(void *)v170 + 40))(v170, v103, v102 - (void)v103);
LABEL_176:
  _ZNSt3__115allocate_sharedB8nn180100I22FeatureStyleAttributesNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v163);
  uint64_t v134 = v163;
  uint64_t v135 = (uint64_t)v167;
  if (((v118 - (char *)v167) & 0x7FFFFFFF8) != 0)
  {
    uint64_t v136 = 0;
    char v137 = 0;
    uint64_t v138 = ((unint64_t)(v118 - (char *)v167) >> 3);
    unsigned __int8 v139 = *(unsigned char *)(v163 + 33);
    while (1)
    {
      size_t v140 = v139;
      uint64_t v141 = *(void **)v134;
      if (v139) {
        break;
      }
LABEL_178:
      v141[v140] = *(void *)(v135 + 8 * v136);
      unsigned __int8 v139 = *(unsigned char *)(v134 + 33) + 1;
      *(unsigned char *)(v134 + 33) = v139;
      ++v136;
      char v137 = 1;
      if (v136 == v138)
      {
        uint64_t v141 = *(void **)v134;
        size_t v140 = v139;
LABEL_195:
        qsort(v141, v140, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
        goto LABEL_196;
      }
    }
    if (v139 > 0x1Fu)
    {
      do
      {
        uint64_t v145 = 0;
        uint64_t v146 = (int *)v141;
        while (1)
        {
          int v147 = *v146;
          v146 += 2;
          if (v147 == *(_DWORD *)(v135 + 8 * v136)) {
            break;
          }
          if (v140 == ++v145) {
            goto LABEL_189;
          }
        }
        HIDWORD(v141[v145]) = *(_DWORD *)(v135 + 8 * v136 + 4);
LABEL_189:
        ++v136;
      }
      while (v136 != v138);
    }
    else
    {
      do
      {
        uint64_t v142 = 0;
        unint64_t v143 = (int *)v141;
        while (1)
        {
          int v144 = *v143;
          v143 += 2;
          if (v144 == *(_DWORD *)(v135 + 8 * v136)) {
            break;
          }
          if (v140 == ++v142) {
            goto LABEL_178;
          }
        }
        HIDWORD(v141[v142]) = *(_DWORD *)(v135 + 8 * v136++ + 4);
      }
      while (v136 != v138);
    }
    if (v137) {
      goto LABEL_195;
    }
  }
LABEL_196:
  if (v135)
  {
    uint64_t v168 = (void *)v135;
    (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)v170 + 40))(v170, v135, v169 - v135);
  }

  uint64_t v148 = v164;
  uint64_t v163 = 0;
  uint64_t v164 = 0;
  if (v148) {
    atomic_fetch_add_explicit(&v148->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  shared_weak_owners = (std::__shared_weak_count *)v8[2].__shared_weak_owners_;
  v8[2].__shared_owners_ = v134;
  v8[2].__shared_weak_owners_ = (uint64_t)v148;
  if (shared_weak_owners && !atomic_fetch_add(&shared_weak_owners->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))shared_weak_owners->__on_zero_shared)(shared_weak_owners);
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  if (v148 && !atomic_fetch_add(&v148->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v148->__on_zero_shared)(v148);
    std::__shared_weak_count::__release_weak(v148);
  }
  unint64_t v150 = v164;
  if (v164 && !atomic_fetch_add(&v164->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v150->__on_zero_shared)(v150);
    std::__shared_weak_count::__release_weak(v150);
  }
  uint64_t v151 = [v28 name];

  if (v151)
  {
    uint64_t v152 = (int64x2_t *)v165;
    id v153 = [v28 name];
    md::LabelExternalFeature::addTextForZoom(v152, 0, 0, (const char *)[v153 UTF8String], 0);
  }
  int v154 = [(VKRouteWaypointInfo *)v7 annotationText];

  unint64_t v155 = (int64x2_t *)v165;
  if (v154)
  {
    id v156 = [(VKRouteWaypointInfo *)v7 annotationText];
    md::LabelExternalFeature::addTextForZoom(v155, 0, 2, (const char *)[v156 UTF8String], 0);
  }
  extractCustomImageData(&__p, v7);
  md::CustomImageData::operator=((uint64_t)&v155[7].i64[1], &__p);
  if (v173 == v172)
  {
    (*(void (**)(void *))(v172[0] + 32))(v172);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_217;
    }
LABEL_222:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_217;
  }
  if (v173) {
    (*(void (**)(void))(*v173 + 40))();
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_222;
  }
LABEL_217:
  uint64_t v157 = operator new(0x308uLL);
  v157[1] = 0;
  v157[2] = 0;
  *uint64_t v157 = &unk_1EF581DA8;
  *(void *)uint64_t v159 = md::RouteWaypointLabelFeature::RouteWaypointLabelFeature((uint64_t)(v157 + 3), v7, 1, 1, (uint64_t *)&v165, (uint64_t)v160);
  *((void *)v159 + 1) = v157;
  v157[12] = atomic_fetch_add((atomic_ullong *volatile)(*((void *)v160 + 36) + 680), 1uLL) + 1;

  uint64_t v158 = v166;
  if (v166 && !atomic_fetch_add(&v166->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v158->__on_zero_shared)(v158);
    std::__shared_weak_count::__release_weak(v158);
  }
}